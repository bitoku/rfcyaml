- contents:
  - "                   RObust Header Compression (ROHC):\n               Corrections
    and Clarifications to RFC 3095\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   RFC 3095 defines the RObust Header Compression (ROHC) framework
    and\n   profiles for IP (Internet Protocol), UDP (User Datagram Protocol),\n   RTP
    (Real-Time Transport Protocol), and ESP (Encapsulating Security\n   Payload).
    \ Some parts of the specification are unclear or contain\n   errors that may lead
    to misinterpretations that may impair\n   interoperability between different implementations.
    \ This document\n   provides corrections, additions, and clarifications to RFC
    3095; this\n   document thus updates RFC 3095.  In addition, other clarifications\n
    \  related to RFC 3241 (ROHC over PPP), RFC 3843 (ROHC IP profile) and\n   RFC
    4109 (ROHC UDP-Lite profiles) are also provided.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction and Terminology ....................................3\n
    \  2. CRC Calculation and Coverage ....................................4\n      2.1.
    CRC Calculation ............................................4\n      2.2. Padding
    Octet and CRC Calculations .........................4\n      2.3. CRC Coverage
    in CRC Feedback Options .......................5\n      2.4. CRC Coverage of the
    ESP NULL Header ........................5\n   3. Mode Transition .................................................5\n
    \     3.1. Feedback During Mode Transition to U- and O-Mode ...........5\n           3.1.1.
    Mode Transition Procedures Allowing Sparse Feedback .6\n           3.1.2. Transition
    from Reliable to Optimistic Mode .........7\n           3.1.3. Transition to Unidirectional
    Mode ...................8\n      3.2. Feedback During Mode Transition ............................8\n
    \     3.3. Packet Decoding During Mode Transition .....................9\n   4.
    Timestamp Encoding ..............................................9\n      4.1.
    Encoding Used for Compressed TS Bits .......................9\n      4.2. (De)compression
    of TS without Transmitted TS Bits .........10\n      4.3. Interpretation Intervals
    for TS Encoding ..................11\n      4.4. Scaled RTP Timestamp Encoding
    .............................11\n           4.4.1. TS_STRIDE for Scaled Timestamp
    Encoding ............11\n           4.4.2. TS Wraparound with Scaled Timestamp
    Encoding .......12\n           4.4.3. Algorithm for Scaled Timestamp Encoding
    ............12\n      4.5. Recalculating TS_OFFSET ...................................14\n
    \     4.6. TS_STRIDE and the Tsc Flag in Extension 3 .................14\n      4.7.
    Using Timer-Based Compression .............................15\n   5. List Compression
    ...............................................15\n      5.1. CSRC List Items
    in RTP Dynamic Chain ......................15\n      5.2. Multiple Occurrences
    of the CC Field ......................15\n      5.3. Bit Masks in List Compression
    .............................16\n      5.4. Headers Compressed with List Compression
    ..................16\n      5.5. ESP NULL Header List Compression ..........................17\n
    \     5.6. Translation Tables and Indexes for IP Extension Headers ...17\n      5.7.
    Reference List ............................................17\n      5.8. Compression
    of AH and GRE Sequence Numbers ................18\n   6. Updating Properties ............................................19\n
    \     6.1. Implicit Updates ..........................................19\n      6.2.
    Updating Properties of UO-1* ..............................20\n      6.3. Context
    Updating Properties for IR Packets ................20\n      6.4. RTP Padding
    Field (R-P) in Extension 3 ....................20\n      6.5. RTP eXtension bit
    (X) in dynamic part .....................21\n   7. Context management and CID/context
    Reuse .......................21\n      7.1. Persistence of Decompressor Contexts
    ......................21\n      7.2. CID/Context Reuse .........................................21\n
    \          7.2.1. Reusing a CID/Context with the Same Profile ........22\n           7.2.2.
    Reusing a CID/Context with a Different Profile .....23\n   8. Other Protocol Clarifications
    ..................................23\n      8.1. Meaning of NBO ............................................23\n
    \     8.2. IP-ID .....................................................23\n      8.3.
    Extension-3 in UOR-2* Packets .............................24\n      8.4. Multiple
    Occurrences of the M Bit .........................24\n      8.5. Multiple SN options
    in one feedback packet ................24\n      8.6. Multiple CRC Options in
    One Feedback Packet ...............25\n      8.7. Responding to Lost Feedback
    Links .........................25\n      8.8. UOR-2 in Profile 0x0002 (UDP) and
    Profile 0x0003 (ESP) ....25\n      8.9. Sequence Number LSB's in IP Extension
    Headers .............25\n      8.10. Expecting UOR-2 ACKs in O-Mode ...........................26\n
    \     8.11. Context Repairs, TS_STRIDE and TIME_STRIDE ...............26\n   9.
    ROHC Negotiation ...............................................27\n   10. PROFILES
    Sub-option in ROHC-over-PPP ..........................27\n   11. Constant IP-ID
    Encoding in IP-only and UPD-Lite Profiles ......27\n   12. Security Considerations
    .......................................28\n   13. Acknowledgments ...............................................28\n
    \  14. References ....................................................28\n      14.1.
    Normative References .....................................28\n      14.2. Informative
    References ...................................29\n   Appendix A. Sample CRC Algorithm
    ..................................30\n"
  title: Table of Contents
- contents:
  - "1.  Introduction and Terminology\n   RFC 3095 [1] defines the RObust Header Compression
    (ROHC) framework\n   and profiles for IP (Internet Protocol) [8][9], UDP (User
    Datagram\n   Protocol) [10], RTP (Real-Time Transport Protocol) [11], and ESP\n
    \  (Encapsulating Security Payload) [12].  During implementation and\n   interoperability
    testing of RFC 3095, some ambiguities and common\n   misinterpretations have been
    identified, as well as a few errors.\n   This document summarizes identified issues
    and provides corrections\n   needed for implementations of RFC 3095 to interoperate,
    i.e., it\n   constitutes an update to RFC 3095.  This document also provides other\n
    \  clarifications related to common misinterpretations of the\n   specification.
    \ References to RFC 3095 should, therefore, also\n   include this document.\n
    \  In addition, some clarifications and corrections are also provided\n   for
    RFC 3241 (ROHC over PPP) [2], RFC 3843 (ROHC IP-only profile)\n   [4], and RFC
    4019 (ROHC UDP-Lite profiles) [5], which are thus also\n   updated by this document.
    \ Furthermore, RFC 4362 (ROHC Link-Layer\n   Assisted Profile) [7] is implicitly
    updated by this document, since\n   RFC 4362 is also based on RFC 3095.\n   The
    key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\",
    \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document
    are to be interpreted as described in RFC 2119 [6].\n   When a section of this
    document makes formal corrections, additions\n   or invalidations to text in RFC
    3095, this is clearly summarized.\n   The text from RFC 3095 that is being addressed
    is given and labeled\n   \"INCOMPLETE\", \"INCORRECT\", or \"INCORRECT AND INVALIDATED\",
    followed\n   by the correct text labeled \"CORRECTED\", where applicable.  When
    text\n   is added that does not simply correct text in previous\n   specifications,
    it is given with the label \"FORMAL ADDITION\".\n   In this document, a reference
    to a section in RFC 3095 [1] is written\n   as RFC 3095-Section <number>.\n"
  title: 1.  Introduction and Terminology
- contents:
  - '2.  CRC Calculation and Coverage

    '
  - contents:
    - "2.1.  CRC Calculation\n   RFC 3095-Section 5.9 defines polynomials for 3-,
      7-, and 8-bit Cyclic\n   Redundancy Checks (CRCs), but it does not specify what
      algorithm is\n   used.  The 3-, 7- and 8-bit CRCs are calculated using the CRC\n
      \  algorithm defined in [3].\n   A Perl implementation of the algorithm can
      be found in Appendix A of\n   this document.\n"
    title: 2.1.  CRC Calculation
  - contents:
    - "2.2.  Padding Octet and CRC Calculations\n   RFC 3095-Section 5.9.1 is incomplete,
      as it does not mention how to\n   handle the padding octet in CRC calculations
      for IR and IR-DYN\n   packets.  Padding isn't meant to be a meaningful part
      of a packet and\n   is not included in the CRC calculation.  As a result, the
      CRC does\n   not cover the Add-CID octet for CID 0, either.\n   INCOMPLETE RFC
      3095 TEXT (RFC 3095-Section 5.9.1):\n      \"The CRC in the IR and IR-DYN packet
      is calculated over the entire\n       IR or IR-DYN packet, excluding Payload
      and including CID or any\n       Add-CID octet.\"\n   CORRECTED TEXT:\n      \"The
      CRC in the IR and IR-DYN packet is calculated over the entire\n       IR or
      IR-DYN packet, excluding Payload, Padding and including CID\n       or any Add-CID
      octet, except for the add-CID octet for CID 0.\"\n"
    title: 2.2.  Padding Octet and CRC Calculations
  - contents:
    - "2.3.  CRC Coverage in CRC Feedback Options\n   RFC 3095-Section 5.7.6.3 is
      incomplete, as it does not mention how\n   the \"size\" field is handled when
      calculating the 8-bit CRC used in\n   the CRC feedback option.  Since the \"size\"
      field is an extension of\n   the \"code\" field, it must be treated in the same
      way.\n   INCOMPLETE RFC 3095 TEXT (RFC 3095-Section 5.7.6.3):\n      \"The CRC
      option contains an 8-bit CRC computed over the entire\n       feedback payload,
      without the packet type and code octet, but\n       including any CID fields,
      using the polynomial of section 5.9.1.\"\n   CORRECTED TEXT:\n      \"The CRC
      option contains an 8-bit CRC computed over the entire\n       feedback payload
      including any CID fields but excluding the\n       packet type, the 'Size' field
      and the 'Code' octet, using the\n       polynomial of Section 5.9.1.\"\n"
    title: 2.3.  CRC Coverage in CRC Feedback Options
  - contents:
    - "2.4.  CRC Coverage of the ESP NULL Header\n   RFC 3095-Section 5.8.7 gives
      the CRC coverage of the ESP NULL [13]\n   header as \"Entire ESP header\".  This
      must be interpreted as including\n   only the initial part of the header (i.e.,
      Security Parameter Index\n   (SPI) and sequence number), and not the trailer
      part at the end of\n   the payload.  Therefore, the ESP NULL header has the
      same CRC\n   coverage as the ESP header used in the ESP profile (RFC 3095-Section\n
      \  5.7.7.7).\n"
    title: 2.4.  CRC Coverage of the ESP NULL Header
  title: 2.  CRC Calculation and Coverage
- contents:
  - '3.  Mode Transition

    '
  - contents:
    - "3.1.  Feedback During Mode Transition to U- and O-Mode\n   RFC 3095-Section
      5.6.1 states that during mode transitions, while the\n   D_TRANS parameter is
      I, the decompressor sends feedback for each\n   received packet.  This restrictive
      behavior prevents the decompressor\n   from using a sparse feedback algorithm
      during mode transitions.\n   To reduce transmission overhead and computational
      complexity\n   (including CRC calculation) associated with feedback packets
      sent for\n   each decompressed packet during mode transition, a decompressor
      MAY\n   be implemented with slightly modified mode transition procedures\n   compared
      to those defined in [1], as described in this section.\n   These enhanced procedures
      should be considered only as a possible\n   improvement to a decompressor implementation,
      since interoperability\n   is not affected in any way.  A decompressor implemented
      according to\n   the optimized procedures will interoperate with an RFC 3095\n
      \  compressor, as well as a decompressor implemented according to the\n   procedures
      described in RFC 3095.\n"
    - contents:
      - "3.1.1.  Mode Transition Procedures Allowing Sparse Feedback\n   The purpose
        of these enhanced transition procedures is to allow the\n   decompressor to
        sparsely send feedback for packets decompressed\n   during the second half
        of the transition procedure, i.e., after an\n   appropriate IR/IR-DYN/UOR-2
        packet has been received from the\n   compressor.  This is achieved by allowing
        the decompressor transition\n   parameter (D_TRANS) to be set to P (Pending)
        at that stage, as shown\n   in the transition diagrams of Sections 3.1.2 and
        3.1.3 below.\n   This enhanced transition, where feedback need not be sent
        for every\n   decompressed packet, does however introduce some considerations
        in\n   case feedback messages would be lost.  Specifically, there is a risk\n
        \  for a deadlock situation when a transition from R-mode is performed;\n
        \  if no feedback message successfully reaches the compressor, the\n   transition
        is never completed.  For transition between U-mode and\n   O-mode, there is
        also a small risk for reduced compression\n   efficiency.\n   To avoid this,
        the decompressor MUST continue to send feedback at\n   least periodically,
        as well as when in a Pending transition state.\n   This is equivalent to enhancing
        the definition of the D_TRANS\n   parameter in RFC 3095-Section 5.6.1, to
        include the definition of a\n   Pending state:\n   -  D_TRANS:\n      Possible
        values for the D_TRANS parameter are (I)NITIATED,\n      (P)ENDING, and (D)ONE.
        \ D_TRANS MUST be initialized to D, and a\n      mode transition can be initiated
        only when D_TRANS is D.  While\n      D_TRANS is I, the decompressor sends
        a NACK or ACK carrying a CRC\n      option for each packet received.  When
        D_TRANS is set to P, the\n      decompressor does not have to send a NACK
        or ACK for each packet\n      received, but it MUST continue to send feedback
        with some\n      periodicity, and all feedback packets sent MUST include the
        CRC\n      option.  This ensures that all mode transitions will be completed\n
        \     also in case of feedback losses.\n   The modifications affect transitions
        to Optimistic and Unidirectional\n   modes of operation (i.e., the transitions
        described in RFC 3095-\n   Section 5.6.5 and RFC 3095-Section 5.6.6) and make
        those transition\n   diagrams more consistent with the diagram describing
        the transition\n   to R-mode.\n"
      title: 3.1.1.  Mode Transition Procedures Allowing Sparse Feedback
    - contents:
      - "3.1.2.  Transition from Reliable to Optimistic Mode\n   The enhanced procedure
        for transition from Reliable to Optimistic\n   mode is shown below:\n             Compressor
        \                    Decompressor\n            ----------------------------------------------\n
        \                 |                               |\n                  |        ACK(O)/NACK(O)
        +-<-<-<-| D_TRANS = I\n                  |       +-<-<-<-<-<-<-<-+       |\n
        \     C_TRANS = P |-<-<-<-+                       |\n      C_MODE = O  |                               |\n
        \                 |->->->-+ IR/IR-DYN/UOR-2(SN,O) |\n                  |       +->->->->->->->-+
        \      |\n                  |->-..                  +->->->-| D_TRANS = P\n
        \                 |->-..                          | D_MODE = O\n                  |
        \          ACK(SN,O)   +-<-<-<-|\n                  |       +-<-<-<-<-<-<-<-+
        \      |\n      C_TRANS = D |-<-<-<-+                       |\n                  |
        \                              |\n                  |->->->-+  UO-0, UO-1*
        \         |\n                  |       +->->->->->->->-+       |\n                  |
        \                      +->->->-| D_TRANS = D\n                  |                               |\n"
      title: 3.1.2.  Transition from Reliable to Optimistic Mode
    - contents:
      - "3.1.3.  Transition to Unidirectional Mode\n   The enhanced procedure for
        transition to Unidirectional mode is shown\n   on the following figure:\n
        \                Compressor                     Decompressor\n                ----------------------------------------------\n
        \                 |                               |\n                  |        ACK(U)/NACK(U)
        +-<-<-<-| D_TRANS = I\n                  |       +-<-<-<-<-<-<-<-+       |\n
        \     C_TRANS = P |-<-<-<-+                       |\n      C_MODE = U  |                               |\n
        \                 |->->->-+ IR/IR-DYN/UOR-2(SN,U) |\n                  |       +->->->->->->->-+
        \      |\n                  |->-..                  +->->->-| D_TRANS = P\n
        \                 |->-..                          |\n                  |           ACK(SN,U)
        \  +-<-<-<-|\n                  |       +-<-<-<-<-<-<-<-+       |\n      C_TRANS
        = D |-<-<-<-+                       |\n                  |                               |\n
        \                 |->->->-+  UO-0, UO-1*          |\n                  |       +->->->->->->->-+
        \      |\n                  |                       +->->->-| D_TRANS = D\n
        \                 |                               | D_MODE= U\n"
      title: 3.1.3.  Transition to Unidirectional Mode
    title: 3.1.  Feedback During Mode Transition to U- and O-Mode
  - contents:
    - "3.2.  Feedback During Mode Transition\n   RFC 3095-Section 5.6.1 states that
      feedback is always used during\n   mode transitions.  However, the text then
      continues by making\n   concrete applications of the rule in an inconsistent
      way, making it\n   unclear when CRCs are used.  Further, the text does not define
      how\n   the compressor should act during mode transitions based on feedback\n
      \  not protected by CRCs, i.e., whether or not to carry out mode\n   transition
      actions.  The proper behavior from the compressor is to\n   perform any action
      related to mode transitions only when the feedback\n   is protected by the CRC
      option.\n   INCOMPLETE RFC 3095 TEXT (RFC 3095-Section 5.6.1):\n      \"As a
      safeguard against residual errors, all feedback sent during\n       a mode transition
      MUST be protected by a CRC, i.e., the CRC\n       option MUST be used.\"\n   CORRECTED
      TEXT:\n       \"As a safeguard against residual errors, all feedback sent by
      the\n       decompressor during a mode transition MUST be protected by a CRC,\n
      \      i.e., the CRC option MUST be used.  The compressor MUST ignore\n       feedback
      information related to mode transition if the feedback\n       is not protected
      by the CRC option.\"\n   One more related issue that requires clarifications
      comes from the\n   following text at the end of RFC 3095-Section 5.6.1:\n      \"While
      D_TRANS is I, the decompressor sends a NACK or ACK carrying\n       a CRC option
      for each received packet.\"\n   However, RFC 3095-Section 5.5.2.2 already stated
      that for R-mode,\n   feedback is never sent for packets that do not update the
      context,\n   i.e., for packets that do not carry a CRC, such as R-0 and R-1*.\n
      \  This means that when D_TRANS=I during mode transition, a decompressor\n   operating
      in R-mode sends an acknowledgement for each packet it\n   receives and MUST
      use the sequence number that corresponds to the\n   packet that last updated
      the context, i.e., the decompressor MUST NOT\n   use the sequence number of
      the R-0 or the R-1* packet.\n"
    title: 3.2.  Feedback During Mode Transition
  - contents:
    - "3.3.  Packet Decoding During Mode Transition\n   The purpose of a mode transition
      is to ensure that the compressor and\n   the decompressor coherently move from
      one mode of operation to\n   another using a three-way handshake.  At one point
      during the mode\n   transition, the decompressor acknowledges the reception
      of one (or\n   more) IR, IR-DYN or UOR-2 packet(s) that have mode bits set to
      the\n   new mode.  Packets of type 0 or type 1 that are received up to this\n
      \  point are decompressed using the old mode, while afterwards they are\n   decompressed
      using the new mode.  If the enhanced transition\n   procedures described in
      Section 3.1 are used, the setting of the\n   D_TRANS parameter to P represents
      this breakpoint.  The successful\n   decompression of a packet of type 0 or
      type 1 completes the mode\n   transition.\n"
    title: 3.3.  Packet Decoding During Mode Transition
  title: 3.  Mode Transition
- contents:
  - '4.  Timestamp Encoding

    '
  - contents:
    - "4.1.  Encoding Used for Compressed TS Bits\n   RTP Timestamp (TS) values are
      always encoded using W-LSB encoding,\n   both when sent scaled and unscaled.
      \ When no TS bits are transmitted\n   in a compressed packet, TS is always scaled.
      \ If a compressed packet\n   carries an Extension 3 and field(Tsc)=0, the compressed
      packet must\n   thus always carry unscaled TS bits.  For TS values sent in Extension\n
      \  3, W-LSB encoded values are sent using the self-describing variable-\n   length
      format (RFC 3095-Section 4.5.6), and this applies to both\n   scaled and unscaled
      values.\n"
    title: 4.1.  Encoding Used for Compressed TS Bits
  - contents:
    - "4.2.  (De)compression of TS without Transmitted TS Bits\n   When ROHC RTP operates
      using its most efficient packet types, apart\n   from packet type identification
      and the error detection CRC, only RTP\n   sequence number (SN) bits are transmitted
      in RTP compressed headers.\n   All other fields are then omitted either because
      they are unchanged\n   or because they can be reconstructed through a function
      from the SN\n   (i.e., by combining the transmitted SN bits with state information\n
      \  from the context).  Fields that can be inferred from the SN are the\n   IP
      Identification (IP-ID) and the RTP Timestamp (TS).\n   IP-ID compression and
      decompression, both with and without\n   transmitted IP-ID bits in the compressed
      header, are well defined in\n   RFC 3095-Section 4.5.5 (see Section 8.2).  For
      the TS field, however,\n   RFC 3095 only defines how to decompress based on
      actual TS bits in\n   the compressed header, either scaled or unscaled, but
      not how to\n   infer the TS from the SN when there are no TS bits present in
      the\n   compressed header.\n   When no TS bits are received in the compressed
      header, the scaled TS\n   value is reconstructed assuming a linear extrapolation
      from the SN,\n   i.e., delta_TS = delta_SN * default-slope, where delta_SN and\n
      \  delta_TS are both signed integers.  RFC 3095-Section 5.7 defines the\n   potential
      values for default-slope.\n   INCOMPLETE RFC 3095 TEXT (RFC 3095-Section 5.7):\n
      \     \"If value(Tsc) = 1, Scaled RTP Timestamp encoding is used before\n       compression
      (see section 4.5.3), and default-slope(TS) = 1.\n       If value(Tsc) = 0, the
      Timestamp value is compressed as-is, and\n       default-slope(TS) = value(TS_STRIDE).\"\n
      \  CORRECTED TEXT:\n      \"When a compressed header with no TS bits is received,
      the scaled\n       TS value is reconstructed assuming a linear extrapolation
      from\n       the SN, i.e., delta_TS = delta_SN * default-slope(TS).\n       If
      value(Tsc) = 1, Scaled RTP Timestamp encoding is used before\n       compression
      (see Section 4.5.3), and default-slope(TS) = 1.\n       If value(Tsc) = 0, the
      Timestamp value is compressed as-is, and\n       default-slope(TS) = value(TS_STRIDE).
      \ If a packet with no TS\n       bits is received with Tsc = 0, the decompressor
      MUST discard the\n       packet.\"\n   INCORRECT AND INVALIDATED RFC 3095 TEXT
      (Section RFC 3095-5.5.1.2):\n       \"For example, in a typical case where the
      string pattern has the\n       form of non-SN-field = SN * slope + offset, one
      ACK is enough if\n       the slope has been previously established by the decompressor\n
      \      (i.e., only the new offset needs to be synchronized).  Otherwise,\n       two
      ACKs are required since the decompressor needs two headers to\n       learn
      both the new slope and the new offset.\"\n   Consequently, there is no other
      slope value than the default-slope,\n   as defined in RFC 3095-Section 5.7.\n"
    title: 4.2.  (De)compression of TS without Transmitted TS Bits
  - contents:
    - "4.3.  Interpretation Intervals for TS Encoding\n   RFC 3095-Section 4.5.4 defines
      the interpretation interval, p, for\n   timer-based compression of the RTP timestamp.
      \ However, RFC 3095-\n   Section 5.7 defines a different interpretation interval,
      which is\n   defined as the interpretation interval to use for all TS values.
      \ It\n   is thus unclear which p-value to use, at least for timer-based\n   compression.\n
      \  The way this should be interpreted is that the p-value differs\n   depending
      on whether or not timer-based compression is enabled.\n   For timer-based compression
      (TIME_STRIDE set to a non-zero value),\n   the interpretation interval is:\n
      \     p = 2^(k-1) - 1 (as per RFC 3095-Section 4.5.4)\n   Otherwise, the interpretation
      interval is:\n      p = 2^(k-2) - 1 (as per RFC 3095-Section 5.7)\n"
    title: 4.3.  Interpretation Intervals for TS Encoding
  - contents:
    - "4.4.  Scaled RTP Timestamp Encoding\n   This section redefines the algorithm
      for scaled RTP timestamp\n   encoding, defined as a 5-step procedure in RFC
      3095-Section 4.5.3.\n   Two formal errors have been corrected, as described
      in sub-sections\n   4.4.1 and 4.4.2 below, and the whole algorithm has been
      reworked to\n   be more concise and to use well-defined terminology.  The resulting\n
      \  text can be found in 4.4.3 below.\n"
    - contents:
      - "4.4.1.  TS_STRIDE for Scaled Timestamp Encoding\n   RFC 3095 defines the
        timestamp stride (TS_STRIDE) as the expected\n   increase in the timestamp
        value between two RTP packets with\n   consecutive sequence numbers.  TS_STRIDE
        is set by the compressor and\n   explicitly communicated to the decompressor,
        and it is used as the\n   scaling factor for scaled TS encoding.\n   The relation
        between TS and TS_SCALED, given by the following\n   equality in RFC 3095-Section
        4.5.3, defines the mathematical meaning\n   of TS_STRIDE:\n      TS = TS_SCALED
        * TS_STRIDE + TS_OFFSET\n   TS_SCALED is incompletely written as TS / TS_STRIDE
        in the\n   compression step following the above core equality.  This formula
        is\n   incorrect both because it excludes TS_OFFSET and because it would\n
        \  prevent a TS_STRIDE value of 0, which is an alternative not excluded\n
        \  by the definition or by the core equality above.  If \"/\" were a\n   generally
        unambiguously defined operation meaning \"the integral part\n   of the result
        from dividing X by Y\", the absence of TS_OFFSET could\n   be explained, but
        the formula would still lack a proper output for\n   TS_STRIDE equal to 0.
        \ The formula of \"2. Compression\" is thus valid\n   only with the following
        requirements:\n     a) \"/\" means \"the integral part of the result from
        dividing X by Y\"\n     b) TS_STRIDE>0 (TS is never sent scaled when TS_STRIDE=0)\n"
      title: 4.4.1.  TS_STRIDE for Scaled Timestamp Encoding
    - contents:
      - "4.4.2.  TS Wraparound with Scaled Timestamp Encoding\n   RFC 3095-Section
        4.5.3 states in points 4 and 5 that the compressor\n   is not required to
        initialize TS_OFFSET at wraparound, but that it is\n   required to increase
        the number of bits sent for the scaled TS value\n   when there is a TS wraparound.
        \ The decompressor is also required to\n   detect and cope with TS wraparound,
        including updating TS_OFFSET.\n   This method is not interoperable and not
        robust.  The gain is also\n   insignificant, as TS wraparound happens very
        seldomly.  Therefore,\n   the compressor should reinitialize TS_OFFSET upon
        TS wraparound, by\n   sending an unscaled TS.\n"
      title: 4.4.2.  TS Wraparound with Scaled Timestamp Encoding
    - contents:
      - "4.4.3.  Algorithm for Scaled Timestamp Encoding\n   INCORRECT RFC 3095 TEXT
        (RFC 3095-Section 4.5.3):\n     \"1. Initialization: The compressor sends
        to the decompressor the\n         value of TS_STRIDE and the absolute value
        of one or several TS\n         fields.  The latter are used by the decompressor
        to initialize\n         TS_OFFSET to (absolute value) modulo TS_STRIDE.  Note
        that\n         TS_OFFSET is the same regardless of which absolute value is\n
        \        used, as long as the unscaled TS value does not wrap around;\n         see
        4) below.\n      2. Compression: After initialization, the compressor no longer\n
        \        compresses the original TS values.  Instead, it compresses the\n
        \        downscaled values: TS_SCALED = TS / TS_STRIDE.  The compression\n
        \        method could be either W-LSB encoding or the timer-based\n         encoding
        described in the next section.\n      3. Decompression: When receiving the
        compressed value of\n         TS_SCALED, the decompressor first derives the
        value of the\n         original TS_SCALED.  The original RTP TS is then calculated
        as\n         TS = TS_SCALED * TS_STRIDE + TS_OFFSET.\n      4. Offset at wraparound:
        Wraparound of the unscaled 32-bit TS will\n         invalidate the current
        value of TS_OFFSET used in the equation\n         above.  For example, let
        us assume TS_STRIDE = 160 = 0xA0 and\n         the current TS = 0xFFFFFFF0.
        \ TS_OFFSET is then 0x50 = 80.\n         Then if the next RTP TS = 0x00000130
        (i.e., the increment is\n         160 * 2 = 320), the new TS_OFFSET should
        be 0x00000130 modulo\n         0xA0 = 0x90 = 144.  The compressor is not required
        to re-\n         initialize TS_OFFSET at wraparound.  Instead, the decompressor\n
        \        MUST detect wraparound of the unscaled TS (which is trivial)\n         and
        update TS_OFFSET to TS_OFFSET = (Wrapped around unscaled\n         TS) modulo
        TS_STRIDE\"\n   CORRECTED TEXT:\n     \"1. Initialization and updating of
        RTP TS scaling function:  The\n         compressor sends to the decompressor
        the value of TS_STRIDE\n         along with an unscaled TS.  These are both
        needed by the\n         decompressor to initialize TS_OFFSET as hdr(TS) modulo\n
        \        field(TS_STRIDE).  Note that TS_OFFSET is the same for any TS\n         as
        long as TS_STRIDE does not change and as long as the\n         unscaled TS
        value does not wrap around; see 4) below.\n      2. Compression: After initialization,
        the compressor no longer\n         compresses the unscaled TS values.  Instead,
        it compresses the\n         scaled values.  The compression method can be
        either W-LSB\n         encoding or timer-based encoding.\n      3. Decompression:
        When receiving a (compressed) TS_SCALED, the\n         field is first decompressed,
        and the unscaled RTP TS is then\n         calculated as TS = TS_SCALED * TS_STRIDE
        + TS_OFFSET.\n      4. Offset at wraparound: If the value of TS_STRIDE is
        not equal to\n         a power of two, wraparound of the unscaled 32-bit TS
        will\n         change the value of TS_OFFSET.  When this happens, the\n         compressor
        SHOULD reinitialize TS_OFFSET by sending unscaled\n         TS, as in 1 above.\"\n
        \  INCORRECT AND INVALIDATED RFC 3095 TEXT (RFC 3095-Section 4.5.3):\n      The
        entire point 5, i.e. the entire text starting from \"5.\n      Interpretation
        interval at wraparound ...\", down to and including\n      the block of text
        that starts with \"Let a be the number of LSBs\"\n      and that ends with
        \"...interpretation interval is b.\" is incorrect\n      and is thus invalid.\n"
      title: 4.4.3.  Algorithm for Scaled Timestamp Encoding
    title: 4.4.  Scaled RTP Timestamp Encoding
  - contents:
    - "4.5.  Recalculating TS_OFFSET\n   TS can be sent unscaled if the TS value change
      does not match the\n   established TS_STRIDE, but the TS_STRIDE might still
      stay unchanged.\n   To ensure correct decompression of subsequent packets, the\n
      \  decompressor MUST therefore always recalculate TS_OFFSET (RTP TS\n   modulo
      TS_STRIDE) when a packet with an unscaled TS value is\n   received.\n"
    title: 4.5.  Recalculating TS_OFFSET
  - contents:
    - "4.6.  TS_STRIDE and the Tsc Flag in Extension 3\n   The Tsc flag in Extension
      3 indicates whether or not TS is scaled.\n   The value of the Tsc flag thus
      applies to all TS bits, as well as if\n   there are no TS bits in the extension
      itself.  When TS is scaled, it\n   is always scaled using context(TS_STRIDE).
      \ The legend for Extension\n   3 in RFC 3095-Section 5.7.5 incorrectly states
      that value(TS_STRIDE)\n   is used for scaled TS.\n   If TS_STRIDE is present
      in Extension 3, as indicated by the Tss flag\n   being set, the compressed header
      SHOULD carry unscaled TS bits; i.e.,\n   the Tsc flag SHOULD NOT be set when
      Tss is set since an unscaled TS\n   is needed together with TS_STRIDE to recalculate
      the TS_OFFSET.  If\n   TS_STRIDE is included in a compressed header with scaled
      TS, the\n   decompressor must ignore and discard field(TS_STRIDE).\n   INCORRECT
      RFC 3095 TEXT (RFC 3095-Section 5.7.5):\n      \"Tsc: Tsc = 0 indicates that
      TS is not scaled;\n            Tsc = 1 indicates that TS is scaled according
      to section\n             4.5.3, using value(TS_STRIDE).\n             Context(Tsc)
      is always 1.  If scaling is not desired, the\n             compressor will establish
      TS_STRIDE = 1.\"\n   CORRECTED TEXT:\n      \"Tsc: Tsc = 0 indicates that TS
      is not scaled;\n            Tsc = 1 indicates that TS is scaled according to
      Section\n            4.5.3, using context(TS_STRIDE).\n            Context(Tsc)
      is always 1.  If scaling is not desired, the\n            compressor will establish
      TS_STRIDE = 1.\n            If field(Tsc) = 1, and if TSS = 1 (meaning that
      TS_STRIDE is\n            present in the extension), field(TS_STRIDE) MUST be
      ignored\n            and discarded.\"\n   When the compressor re-establishes
      a new value for TS_STRIDE using\n   Extension 3, it should send unscaled TS
      bits together with TS_STRIDE.\n"
    title: 4.6.  TS_STRIDE and the Tsc Flag in Extension 3
  - contents:
    - "4.7.  Using Timer-Based Compression\n   Timer-based compression of the RTP
      timestamp, as described in RFC\n   3095-Section 4.5.4, may be used to reduce
      the number of transmitted\n   timestamp bits (bytes) needed when the timestamp
      cannot be inferred\n   from the SN.  Timer-based compression is only used for
      decompression\n   of compressed headers that contains a TS field; otherwise,
      when no\n   timestamp bits are present, the timestamp is linearly inferred from\n
      \  the SN (see Section 4.2 of this document).\n   Whether or not to use timer-based
      compression is controlled by the\n   TIME_STRIDE control field, which can be
      set by either an IR, an IR-\n   DYN, or a compressed packet with Extension 3.
      \ Before timer-based\n   compression can be used, the decompressor has to inform
      the\n   compressor (on a per-channel basis) about its clock resolution by\n
      \  sending a CLOCK feedback option for any CID on the channel.  The\n   compressor
      can then initiate timer-based compression by sending (on a\n   per-context basis)
      a non-zero TIME_STRIDE to the decompressor.  When\n   the compressor is confident
      that the decompressor has received the\n   TIME_STRIDE value, it can switch
      to timer-based compression.\n"
    title: 4.7.  Using Timer-Based Compression
  title: 4.  Timestamp Encoding
- contents:
  - '5.  List Compression

    '
  - contents:
    - "5.1.  CSRC List Items in RTP Dynamic Chain\n   RFC 3095-Section 5.7.7.6 defines
      the static and dynamic parts of the\n   RTP header.  This section indicates
      a 'Generic CSRC list' field in\n   the dynamic chain, which has a variable length
      (see RFC 3095-Section\n   5.8.6).  This field is always at least one octet in
      size, even if the\n   list is empty (as opposed to the CSRC list in the uncompressed
      RTP\n   header, which is not present when the RTP CC field is set to 0).\n"
    title: 5.1.  CSRC List Items in RTP Dynamic Chain
  - contents:
    - "5.2.  Multiple Occurrences of the CC Field\n   The static and the dynamic parts
      of the RTP header are defined in RFC\n   3095-Section 5.7.7.6.  In the dynamic
      part, a CC field indicates the\n   number of CSRC items present in the 'Generic
      CSRC list'.  Another CC\n   field also appears within the 'Generic CSRC list'
      (RFC 3095-Section\n   5.8.6.1), because Encoding Type 0 is always used in the
      dynamic\n   chain.  Both CC fields have the same meaning: the value of the CC\n
      \  field determines the number of XI items in the CSRC list for Encoding\n   Type
      0, and it is not used otherwise.  Therefore, the following\n   applies:\n   FORMAL
      ADDITION TO RFC 3095:\n      \"The first octet in the dynamic part of the RTP
      header contains a\n       CC field, as defined in Section 5.7.7.6.  A second
      occurrence\n       appears in the 'Generic CSRC list', which is also in the
      dynamic\n       part of the RTP header, where Encoding Type 0 is used according\n
      \      to the format defined in RFC 3095-5.8.6.1.\n       The compressor MUST
      set both occurrences of the CC field to the\n       same value.\n       The
      decompressor MUST use the value of the CC field from the\n       Encoding Type
      0 within the Generic CRSC list, and it MUST thus\n       ignore the first occurrence
      of the CC field.\"\n"
    title: 5.2.  Multiple Occurrences of the CC Field
  - contents:
    - "5.3.  Bit Masks in List Compression\n   The insertion and/or removal schemes,
      described in RFC 3095-Sections\n   5.8.6.2 - 5.8.6.4, use bit masks to indicates
      insertion or removal\n   positions within the reference list.  The size of the
      bit mask can be\n   7 bits or 15 bits.\n   The compressor MAY use a 7-bit mask,
      even if the reference list has\n   more than seven items, provided that changes
      to the list are only\n   applied to items within the first seven items of the
      reference list,\n   leaving items with an index not covered by the 7-bit mask
      unchanged.\n   The decompressor MUST NOT modify items with an index not covered
      by\n   the 7-bit mask, when a 7-bit mask is received for a reference list\n
      \  that contains more than seven items.\n"
    title: 5.3.  Bit Masks in List Compression
  - contents:
    - "5.4.  Headers Compressed with List Compression\n   In RFC 3095-Section 5.8,
      it states that headers that can be part of\n   extension header chains \"include\"
      AH [14], ESP NULL [13], minimal\n   encapsulation (MINE) [15], GRE [16][17],
      and IPv6 [9] extensions.\n   This list of headers that can be compressed is
      correct, but the word\n   \"include\" should not be there, since only the header
      types listed can\n   actually be handled.  It should further be noted that for
      the Minimal\n   Encapsulation (MINE) header, there is no explicit discussion
      of how\n   to compress it, as the header is sent either uncompressed or fully\n
      \  compressed away.\n"
    title: 5.4.  Headers Compressed with List Compression
  - contents:
    - "5.5.  ESP NULL Header List Compression\n   Due to the offset of the fields
      in the trailer part of the ESP\n   header, a compressor MUST NOT compress packets
      containing more than\n   one NULL ESP [13] header, unless the second-outermost
      header is\n   treated as a regular ESP [12] header and the packets are compressed\n
      \  using profile 0x0003.\n"
    title: 5.5.  ESP NULL Header List Compression
  - contents:
    - "5.6.  Translation Tables and Indexes for IP Extension Headers\n   RFC 3095-Section
      5.8.4 describes how list indexes are associated to\n   list items and how table
      lists are built for IP extension headers.\n   The text incorrectly states that
      one index per type is used, since\n   the same type can appear several times
      with different content in one\n   single chain.\n   In IP extension header list
      compression, an index is associated with\n   each individual extension header
      of an extension header chain.  When\n   there are multiple non-identical occurrences
      of the same extension\n   type (Protocol Number) within a header chain, each
      MUST be given its\n   own index.\n   In the case where there are multiple identical
      occurrences of the\n   same extension type, the compressor can associate them
      to the same\n   index.  When the value of an item whose index occurs more than
      once\n   in the list is updated, the compressor MUST send the value for each\n
      \  occurrence of that index in the list.\n   When content of extension headers
      changes, an implementation can\n   choose to either use a different index or
      update the existing one.\n   Some extensions can be compressed away even when
      some fields change,\n   as those changes can be conveyed to the decompressor
      implicitly (e.g.\n   sequence numbers in extension headers that can be inferred
      from the\n   RTP SN) or explicitly (e.g., as part of the 'IP extension header(s)'\n
      \  field in Extension 3).\n   When there is more than one IP header, there is
      more than one list of\n   extension headers, and a translation table is maintained
      for each\n   list independently of one another.\n"
    title: 5.6.  Translation Tables and Indexes for IP Extension Headers
  - contents:
    - "5.7.  Reference List\n   A list compressed using encoding type 1 (insertion),
      type 2\n   (removal), or type 3 (removal/insertion) uses a coding scheme that
      is\n   based on the use of a reference list in the context (identified as\n
      \  ref_id).\n   While it could seem to be a fair choice to send a type 1 list
      when\n   ref_id is an empty list, there is nothing gained in doing so with\n
      \  respect to using a type 0 list.  Sending a type 2 list when ref_id is\n   an
      empty list would lead to a failure, while sending a type 3 list\n   has very
      little meaning.  All these alternatives could be seen as\n   possible, based
      on how list compression is specified in RFC 3095.\n   If these alternatives
      were allowed, a decompressor would become\n   required to maintain a sliding
      window of ref_id lists in R-mode, even\n   for the case where no items are sent
      in the compressed list, and this\n   is not a desirable requirement.  Using
      list encoding type 1, type 2,\n   and type 3 is therefore only allowed for non-empty
      reference lists.\n   FORMAL ADDITION TO RFC 3095:\n      \"Regardless of the
      operating mode, for list encoding of type 1,\n       type 2, and type 3 lists,
      ref_id MUST refer to a non-empty list.\"\n"
    title: 5.7.  Reference List
  - contents:
    - "5.8.  Compression of AH and GRE Sequence Numbers\n   RFC 3095-Section 5.8.4.2
      and RFC 3095-Section 5.8.4.4 describe how to\n   compress the Authentication
      Header (AH) [14] and the Generic Routing\n   Encapsulation (GRE) [16][17] header.
      \ Both these sections present a\n   possibility to omit the AH/GRE sequence
      number in the compressed\n   header, under certain circumstances.  However,
      the specific\n   conditions for omitting the AH/GRE sequence number, as well
      as the\n   concrete compression and decompression procedures to apply, are not\n
      \  clearly defined to guarantee robustness and facilitate interoperable\n   implementation.\n
      \  Proper rules are provided for the ESP case, i.e.,:\n      \"Sequence Number:
      Not sent when the offset from the sequence\n       number of the compressed
      header is constant, when the compressor\n       has confidence that the decompressor
      has established the correct\n       offset.  When the offset is not constant,
      the sequence number may\n       be compressed by sending LSBs\"\n   The same
      logic applies to the AH/GRE sequence numbers.\n   INCORRECT RFC 3095 TEXT (RFC
      3095-Section 5.8.4.2):\n      \"If the sequence number in the AH linearly increases
      as the RTP\n       Sequence Number increases, and the compressor is confident
      that\n       the decompressor has obtained the pattern, the sequence number
      in\n       AH need not be sent.  The decompressor applies linear\n       extrapolation
      to reconstruct the sequence number in the AH.\"\n   CORRECTED TEXT:\n      \"The
      AH sequence number can be omitted from the compressed header\n       when the
      offset from the sequence number (SN) of the compressed\n       header is constant,
      when the compressor has confidence that the\n       decompressor has established
      the correct offset.\"\n   INCORRECT RFC 3095 TEXT (RFC 3095-Section 5.8.4.4):\n
      \     \"If the sequence number in the GRE header linearly increases as\n       the
      RTP Sequence Number increases and the compressor is confident\n       that the
      decompressor has received the pattern, the sequence\n       number in GRE need
      not be sent.  The decompressor applies linear\n       extrapolation to reconstruct
      the sequence number in the GRE\n       header.\"\n   CORRECTED TEXT:\n      \"The
      GRE sequence number can be omitted from the compressed header\n       when the
      offset from the sequence number (SN) of the compressed\n       header is constant,
      when the compressor has confidence that the\n       decompressor has established
      the correct offset.\"\n"
    title: 5.8.  Compression of AH and GRE Sequence Numbers
  title: 5.  List Compression
- contents:
  - '6.  Updating Properties

    '
  - contents:
    - "6.1.  Implicit Updates\n   A context updating packet that contains compressed
      sequence number\n   information may also carry information about other fields;
      in such\n   cases, these fields are updated according to the content of the\n
      \  packet.  The updating packet also implicitly updates inferred fields\n   (e.g.,
      RTP Timestamp) according to the current mode and the\n   appropriate mapping
      function of the updated and inferred fields.\n   An updating packet thus updates
      the reference values of all header\n   fields, either explicitly or implicitly,
      except for the UO-1-ID\n   packet (see Section 6.2 of this document).  In UO-mode,
      all packets\n   are updating packets, while in R-mode, all packets with a CRC
      are\n   updating packets.\n   For example, a UO-0 packet contains the compressed
      RTP sequence\n   number (SN).  Such a packet also implicitly updates RTP timestamp,\n
      \  IPv4 ID, and sequence numbers of IP extension headers.\n"
    title: 6.1.  Implicit Updates
  - contents:
    - "6.2.  Updating Properties of UO-1*\n   RFC 3095-Section 5.7.3 states that the
      values provided in extensions\n   carried by a UO-1-ID packet do not update
      the context, except for SN,\n   TS, or IP-ID fields.  However, RFC 3095-Section
      5.8.1 correctly\n   states that the translation table in the context is updated
      whenever\n   an (Index, item) pair is received, something that is contradicted
      by\n   the statement in RFC 3095-5.7.3 because the UO-1-ID packet can carry\n
      \  Extension 3 with (Index, item) pair items within the 'Compressed CSRC\n   list'
      field.  In addition to this contradiction, the text does not\n   mention what
      to do with the other sequence numbers inferred from the\n   SN, which are also
      to be implicitly updated.  The updating properties\n   of UO-1* as stated by
      RFC 3095-Section 5.7.3 are thus incomplete.\n   INCOMPLETE RFC 3095 TEXT (RFC
      3095-Section 5.7.3):\n      \"Values provided in extensions, except those in
      other SN, TS, or\n       IP-ID fields, do not update the context.\"\n   CORRECTED
      TEXT:\n      \"UO-1-ID packets only updates TS, SN, IP-ID, and sequence numbers\n
      \      of IP extension headers.  Other values provided in extensions do\n       not
      update the context.\n       The decompressor MUST update its translation table
      whenever an\n       (Index, item) pair is received, as per RFC 3095-Section
      5.8.1,\n       and this rule applies also to UO-1-ID packets.\"\n"
    title: 6.2.  Updating Properties of UO-1*
  - contents:
    - "6.3.  Context Updating Properties for IR Packets\n   IR packets do not clear
      the whole context, but update all fields\n   carried in the IR header.  Similarly,
      an IR without a dynamic chain\n   simply updates the static part of the context,
      while the rest of the\n   context is left unchanged.\n   A consequence of this
      is that fields that are not updated by the IR\n   packet, e.g., the translation
      tables for list compression, MUST NOT\n   be invalidated by the decompressor
      when it assumes context damage.\n"
    title: 6.3.  Context Updating Properties for IR Packets
  - contents:
    - "6.4.  RTP Padding Field (R-P) in Extension 3\n   RFC 3095-Section 5.7.5 defines
      the properties of RTP header flags and\n   fields in Extension 3.  These get
      updated when the rtp flag of the\n   Extension 3 is set, i.e., when rtp = 1;
      otherwise, they are not\n   updated.  However, it is unclear how Extension 3
      updates the R-P bit\n   in the context.\n   INCOMPLETE RFC 3095 TEXT (RFC 3095-Section
      5.7.5):\n      \"R-P: RTP Padding bit, absolute value (presumed zero if absent).\"\n
      \  CORRECTED TEXT:\n      \"R-P: RTP Padding bit.  If R-PT = 1, R-P is the absolute
      value of\n            the RTP padding bit and this value updates context(R-P).
      \ If\n            R-PT = 0, context(R-P) is updated to zero.\"\n"
    title: 6.4.  RTP Padding Field (R-P) in Extension 3
  - contents:
    - "6.5.  RTP eXtension bit (X) in dynamic part\n   RFC 3095-Section 5.7.7.6 defines
      the properties of the RTP header\n   flags and fields in the RTP part of the
      dynamic chain of IR and IR-\n   DYN packets.  However, it is unclear how the
      X bit is updated in the\n   context.\n   INCOMPLETE RFC 3095 TEXT (RFC 3095-Section
      5.7.7.6):\n      \"X: Copy of X bit from RTP header (presumed 0 if RX = 0)\"\n
      \  CORRECTED TEXT:\n      \"X: X bit from RTP header.  If RX = 1, X is the X
      bit from the RTP\n          header and this value updates context(X).  If RX
      = 0,\n          context(X) is updated to zero.\"\n"
    title: 6.5.  RTP eXtension bit (X) in dynamic part
  title: 6.  Updating Properties
- contents:
  - '7.  Context management and CID/context Reuse

    '
  - contents:
    - "7.1.  Persistence of Decompressor Contexts\n   As part of the negotiated channel
      parameters, compressor and\n   decompressor have, through the MAX_CID parameter,
      agreed on the\n   highest context identification (CID) number to be used.  By
      agreeing\n   on MAX_CID, the decompressor also agrees to provide memory resources\n
      \  to host at least MAX_CID+1 contexts, and an established context with\n   a
      CID within this negotiated space MUST be kept by the decompressor\n   until
      either the CID gets reused, or the channel is taken down or\n   renegotiated.\n"
    title: 7.1.  Persistence of Decompressor Contexts
  - contents:
    - "7.2.  CID/Context Reuse\n   As part of the channel negotiation, the maximal
      number of active\n   contexts supported is negotiated between the compressor
      and the\n   decompressor through the MAX_CID parameter.  The value of MAX_CID
      can\n   differ significantly from one link application to another, as well as\n
      \  the load in terms of the number of packet streams to compress.  The\n   lifetime
      of a ROHC channel can also vary, from almost permanent to\n   rather short-lived.
      \ However, in general, it is not expected that\n   resources will be allocated
      for more contexts than what can\n   reasonably be expected to be active concurrently
      over the link.  As a\n   consequence hereof, context identifiers (CIDs) and
      context memory are\n   resources that will have to be reused by the compressor
      as part of\n   what can be considered normal operation.\n   How context resources
      are reused is left unspecified in RFC 3095 [1]\n   and subsequent 3095-based
      ROHC specifications.  This document does\n   not intend to change that, i.e.,
      ROHC resource management is still\n   considered an implementation detail.  However,
      reusing a CID and its\n   allocated memory is not always as simple as initiating
      a context with\n   a previously unused CID.  Because some profiles can be operating
      in\n   various modes where packet formats vary depending on current mode,\n
      \  care has to be taken to ensure that the old context data will be\n   completely
      and safely overwritten, eliminating the risk of undesired\n   side effects from
      interactions between old and new context data.\n   This document therefore points
      out some important core aspects to\n   consider when implementing resource management
      in ROHC compressors\n   and decompressors.\n   On a high level, CID/context
      reuse can be of two kinds, either reuse\n   for a new context based on the same
      profile as the old context, or\n   for a new context based on a different profile.
      \ These cases are\n   discussed separately in the following two sub-sections.\n"
    - contents:
      - "7.2.1.  Reusing a CID/Context with the Same Profile\n   For multi-mode profiles,
        such as those defined in RFC 3095 [1], mode\n   transitions are performed
        using a decompressor-initiated handshake\n   procedure, as defined in RFC
        3095-Section 5.6.  When a CID/context is\n   reused for a new context based
        on the same profile as the old\n   context, the current mode of operation
        SHOULD be inherited from the\n   old to the new context.  Specifically, the
        compressor SHOULD continue\n   to operate using the mode of operation of the
        old context also with\n   the new context.  The reason for this is that there
        is no reliable\n   way for the compressor to inform the decompressor that
        a CID/context\n   reuse is happening.  The decompressor can thus not be expected
        to\n   clear the context memory for the CID (see Section 6.3), and there is\n
        \  no way to trigger a safe mode switching (which requires the\n   decompressor-initiated
        handshake procedure).\n   The rule of mode inheritance applies also when the\n
        \  CONTEXT_REINITIALIZATION signal (RFC 3095-Section 6.3.1) is used to\n   reinitiate
        an entire context.\n"
      title: 7.2.1.  Reusing a CID/Context with the Same Profile
    - contents:
      - "7.2.2.  Reusing a CID/Context with a Different Profile\n   When a CID is
        reused for a new context based on a different profile\n   than the old context,
        both the compressor and the decompressor MUST\n   start operation with that
        context in the initial mode of the profile\n   (if it is a multi-mode profile).
        \ This applies both to IR-initiated\n   new contexts and profile downgrades
        with IR-DYN (e.g., the profile\n   0x0001 -> profile 0x0002 downgrade in RFC
        3095-Section 5.11.1).\n   Type 0 and type 1 packets have different formats
        in U/O- and R-mode,\n   and these R-mode packets have no CRC.  When initiating
        a new context\n   on a reused R-mode CID, there is a risk that the decompressor
        will\n   misinterpret compressed packets if the initiating IR packets are\n
        \  lost.\n   A CID for a context currently operating in R-mode SHOULD therefore\n
        \  not be reused for a new context based on a different profile than the\n
        \  old context.  A compressor doing otherwise should minimize the risk\n   for
        misinterpretation of R-0/R-1 by, e.g., not using packets of types\n   beginning
        with 00 or 10 before it is highly confident that the new\n   context has successfully
        been initiated at the decompressor.\n"
      title: 7.2.2.  Reusing a CID/Context with a Different Profile
    title: 7.2.  CID/Context Reuse
  title: 7.  Context management and CID/context Reuse
- contents:
  - '8.  Other Protocol Clarifications

    '
  - contents:
    - "8.1.  Meaning of NBO\n   In IPv4 dynamic part (RFC 3095-Section 5.7.7.4), if
      the 'NBO' bit is\n   set, it means that network byte order is used.\n"
    title: 8.1.  Meaning of NBO
  - contents:
    - "8.2.  IP-ID\n   According to RFC 3095-Section 5.7, IP-ID means the compressed
      value\n   of the IPv4 header's 'Identification' field.  Compressed packets\n
      \  contain this compressed value (IP-ID), while IR packets with dynamic\n   chain
      and IR-DYN packets transmit the original, uncompressed\n   Identification field
      value.  The IP-ID field always represents the\n   Identification value of the
      innermost IPv4 header whose corresponding\n   RND flag is not 1.\n   If RND
      or RND2 is set to 1, the corresponding IP-ID(s) is (are) sent\n   as 16-bit
      uncompressed Identification value(s) at the end of the\n   compressed base header,
      according to the IP-ID description (see the\n   beginning of RFC 3095-Section
      5.7).  When there is no compressed IP-\n   ID, i.e., for IPv6 or when all IP
      Identification information is sent\n   as is (as indicated by RND/RND2 being
      set to 1), the decompressor\n   ignores IP-ID bits sent within compressed base
      headers.\n   When RND=RND2=0, IP-ID is compressed, i.e., expressed as an SN
      offset\n   and byte-swapped if NBO=0.  This is the case also when 16 bits of\n
      \  IP-ID is sent in Extension 3.\n   When RND=0 but no IP-ID bits are sent in
      the compressed header, the\n   SN offset for IP-ID stays unchanged, meaning
      that Offset_m equals\n   Offset_ref, as described in Section 4.5.5.  This is
      further expressed\n   in a slightly different way (with the same meaning) in
      Section 5.7,\n   where it is said that \"default-slope(IP-ID offset) = 0\",
      meaning, if\n   no bits are sent for IP-ID, its SN offset slope defaults to
      0.\n"
    title: 8.2.  IP-ID
  - contents:
    - "8.3.  Extension-3 in UOR-2* Packets\n   Some flags of the IP header in the
      extension (e.g., NBO or RND) may\n   change the interpretation of fields in
      UOR-2* packets.  In such\n   cases, when a flag changes in Extension 3, a decompressor
      MUST re-\n   parse the UOR-2* packet.\n"
    title: 8.3.  Extension-3 in UOR-2* Packets
  - contents:
    - "8.4.  Multiple Occurrences of the M Bit\n   The RTP header part of Extension
      3, as defined by RFC 3095-Section\n   5.7.5, includes a one-bit field for the
      RTP Marker bit.  This field\n   is also present in all compressed base header
      formats except for UO-\n   1-ID; meaning, there may be two occurrences of the
      field within one\n   single compressed header.  In such cases, the two M fields
      must have\n   the same value.\n   FORMAL ADDITION TO RFC 3095:\n      \"When
      there are two occurrences of the M field in a compressed\n       header (both
      in the compressed base header and in the RTP part of\n       Extension 3), the
      compressor MUST set both these occurrences of\n       the M field to the same
      value.\n       At the decompressor, if the two M field values of such a packet\n
      \      are not identical, the packet MUST be discarded.\"\n"
    title: 8.4.  Multiple Occurrences of the M Bit
  - contents:
    - "8.5.  Multiple SN options in one feedback packet\n   The length of the sequence
      number field in the original ESP [12]\n   header is 32 bits.  The format of
      the SN feedback option (RFC 3095-\n   Section 5.7.6.6) allows for 8 additional
      SN bits to the 12 SN bits of\n   the FEEDBACK-2 format (RFC 3095-Section 5.7.6.1).
      \ One single SN\n   feedback option is thus not enough for the decompressor
      to send back\n   all the 32 bits of the ESP sequence number in a feedback packet,\n
      \  unless it uses multiple SN options in one feedback packet.\n   RFC 3095-Section
      5.7.6.1 declares that a FEEDBACK-2 packet can\n   contain a variable number
      of feedback options, and the options can\n   appear in any order.\n   When processing
      multiple SN options in one feedback packet, the SN\n   would be given by concatenating
      the fields.\n"
    title: 8.5.  Multiple SN options in one feedback packet
  - contents:
    - "8.6.  Multiple CRC Options in One Feedback Packet\n   Although it is not useful
      to have more than one single CRC option in\n   a feedback packet, having multiple
      CRC options is still allowed.  If\n   multiple CRC options are included, all
      such CRC options MUST be\n   identical, as they will be calculated over the
      same header; the\n   compressor MUST otherwise discard the feedback packet.\n"
    title: 8.6.  Multiple CRC Options in One Feedback Packet
  - contents:
    - "8.7.  Responding to Lost Feedback Links\n   Although this is neither desirable
      or expected, it may happen that a\n   link used to carry feedback between two
      associated instances becomes\n   unavailable.  If the compressor can be notified
      of such an event, the\n   compressor SHOULD restart compression for each flow
      that is operating\n   in R-mode.  When restarting compression, the compressor
      SHOULD use a\n   different CID for each flow being restarted; this is useful
      to avoid\n   the possibility of misinterpreting the type of the compressed header\n
      \  for the packet type identifiers that are common to both U/O-mode and\n   R-mode,
      when the flow is restarted in U-mode (see also Section 7.2).\n   Generally,
      feedback links are not expected to disappear once present,\n   but it should
      be noted that this might be the case for certain link\n   technologies.\n"
    title: 8.7.  Responding to Lost Feedback Links
  - contents:
    - "8.8.  UOR-2 in Profile 0x0002 (UDP) and Profile 0x0003 (ESP)\n   One single
      new format is defined for UOR-2 in profile 0x0002 and\n   profile 0x0003, which
      replaces all three (UOR-2, UOR-2-ID, UOR-2-TS)\n   formats from profile 0x0001.
      \ The same UOR-2 format is thus used\n   independent of whether or not there
      are IP headers with a\n   corresponding RND=1.  This also applies to the IP
      profile [4] and the\n   IP/UDP-Lite profile [5].\n"
    title: 8.8.  UOR-2 in Profile 0x0002 (UDP) and Profile 0x0003 (ESP)
  - contents:
    - "8.9.  Sequence Number LSB's in IP Extension Headers\n   In RFC 3095-Section
      5.8.5, formats are defined for compression of IP\n   extension header fields.
      \ These include compressed sequence number\n   fields, and these fields contain
      the \"LSB of sequence number\".  These\n   sequence numbers are not \"LSB-encoded\"
      as, e.g., the RTP sequence\n   number, but are the LSB's of the uncompressed
      fields.\n"
    title: 8.9.  Sequence Number LSB's in IP Extension Headers
  - contents:
    - "8.10.  Expecting UOR-2 ACKs in O-Mode\n   Usage of UOR-2 ACKs in O-mode, as
      discussed in RFC 3095-Section\n   5.4.1.1.2, is optional.  A decompressor can
      also send ACKs for\n   purposes other than to acknowledge the UOR-2, without
      having to\n   continue sending ACKs for all UOR-2.  Similarly, a compressor\n
      \  implementation can ignore UOR-2s ACKs for the purpose of adapting the\n   optimistic
      approach strategies.\n   It is thus NOT RECOMMENDED to use the optional ACK
      mechanism in O-\n   mode, either in compressor or in decompressor implementations.\n
      \  Using an incorrect expectation on UOR-2 ACKs as a basis for\n   compressor
      behavior will significantly degrade the compression\n   performance.  This is
      because UOR-2 ACKs can be sent from a\n   decompressor for other purposes than
      to acknowledge the UOR-2 packet,\n   e.g., to send feedback such as clock resolution,
      or to initiate a\n   mode transition.  If an implementation does use the optional\n
      \  acknowledgment algorithm described in Section 5.4.1.1.2, it must make\n   sure
      to set the k_3 and n_3 parameters to much larger values than 1\n   to ensure
      that the compressor performance is not degraded due to the\n   problem described
      above.\n"
    title: 8.10.  Expecting UOR-2 ACKs in O-Mode
  - contents:
    - "8.11.  Context Repairs, TS_STRIDE and TIME_STRIDE\n   The 7-bit CRC used to
      verify the outcome of the decompression attempt\n   covers the original uncompressed
      header.  The CRC verification thus\n   excludes TS_STRIDE and TIME_STRIDE, as
      these fields are not part of\n   the original uncompressed header.\n   The UOR-2
      packet type can be used to update the value of the\n   TS_STRIDE and/or the
      TIME_STRIDE, with the Extension 3.  However,\n   these fields are not used for
      decompression of the RTP TS field for\n   this packet type and their respective
      value is thus not verified,\n   either implicitly or explicitly.\n   When the
      compressor receives a negative acknowledgement, it thus\n   cannot determine
      whether the failure may be caused by an unsuccessful\n   update to the TS_STRIDE
      and/or the TIME_STRIDE field(s), for which a\n   previous header that last attempted
      to update their value had\n   previously been acknowledged.\n   FORMAL ADDITION
      TO RFC 3095:\n      \"When the compressor receives a NACK and uses the UOR-2
      header\n       type to repair the decompressor context, it SHOULD include fields\n
      \      that update the value of both the TS_STRIDE and the TIME_STRIDE\n       whose
      value it has updated at least once since the establishment\n       of that context,
      i.e., since the CID was first associated with\n       its current profile.\n
      \      When the compressor receives a static-NACK, it MUST include in\n       the
      IR header fields for both the TS_STRIDE and the TIME_STRIDE\n       whose value
      it has updated at least once since the establishment\n       of that context,
      i.e., since the CID was first associated with\n       its current profile.\"\n"
    title: 8.11.  Context Repairs, TS_STRIDE and TIME_STRIDE
  title: 8.  Other Protocol Clarifications
- contents:
  - "9.  ROHC Negotiation\n   RFC 3095-Section 4.1 states that the link layer must
    provide means to\n   negotiate, e.g., the channel parameters listed in RFC 3095-Section\n
    \  5.1.1.  One of these parameters is the PROFILES parameter, which is a\n   set
    of non-negative integers where each integer indicates a profile\n   supported
    by the decompressor.\n   Each profile is identified by a 16-bit value, where the
    8 LSB bits\n   indicate the actual profile, and the 8 MSB bits indicate the variant\n
    \  of that profile (see RFC 3095-Section 8).  In the ROHC headers sent\n   over
    the link, the profile used is identified only with the 8 LSB\n   bits, which means
    that the compressor and decompressor must have\n   agreed on which variant to
    use for each profile.\n   The negotiation protocol must thus be able to communicate
    to the\n   compressor the set of profiles supported by the decompressor.  When\n
    \  multiple variants of the same profile are available, the negotiation\n   protocol
    must provide the means for the decompressor to know which\n   variant will be
    used by the compressor.  This basically means that\n   the PROFILES set after
    negotiation MUST NOT include more than one\n   variant of a profile.\n"
  title: 9.  ROHC Negotiation
- contents:
  - "10.  PROFILES Sub-option in ROHC-over-PPP\n   The logical union of sub-options
    for IPCP and IPV6CP negotiations, as\n   specified by ROHC over PPP [2], cannot
    be used for the PROFILES\n   suboption, as the whole union would then have to
    be considered within\n   each of the two IPCP negotiations to avoid getting an
    ambiguous\n   profile set.  An implementation of RFC 3241 MUST therefore ensure\n
    \  that the same profile set is negotiated for both IPv4 and IPv6\n   (IPCP/IPV6CP).\n"
  title: 10.  PROFILES Sub-option in ROHC-over-PPP
- contents:
  - "11.  Constant IP-ID Encoding in IP-only and UPD-Lite Profiles\n   In the ROHC
    IP-only profile, Section 3.3 of RFC 3843 [4], a mechanism\n   for encoding of
    a constant Identification value in IPv4 (constant\n   IP-ID) is defined.  This
    mechanism is also used by the ROHC UDP-Lite\n   profiles, RFC 4019 [5].\n   The
    \"Constant IP-ID\" mechanism applies to both the inner and outer IP\n   header,
    when present, meaning that there will be both a SID and a\n   SID2 context value.\n"
  title: 11.  Constant IP-ID Encoding in IP-only and UPD-Lite Profiles
- contents:
  - "12.  Security Considerations\n   This document provides a number of corrections
    and clarifications to\n   [1], but it does not make any changes with regard to
    the security\n   aspects of the protocol.  As a consequence, the security\n   considerations
    of [1] apply without additions.\n"
  title: 12.  Security Considerations
- contents:
  - "13.  Acknowledgments\n   The authors would like to thank Vicknesan Ayadurai,
    Carsten Bormann,\n   Mikael Degermark, Zhigang Liu, Abigail Surtees, Mark West,
    Tommy\n   Lundemo, Alan Kennington, Remi Pelland, Lajos Zaccomer, Endre Szalai,\n
    \  Mark Kalmanczhelyi, and Arpad Szakacs for their contributions and\n   comments.
    \ Thanks also to the committed document reviewers, Carl\n   Knutsson and Biplab
    Sarkar, who reviewed the document during working\n   group last-call.\n"
  title: 13.  Acknowledgments
- contents:
  - '14.  References

    '
  - contents:
    - "14.1.  Normative References\n   [1]  Bormann, C., Burmeister, C., Degermark,
      M., Fukushima, H.,\n        Hannu, H., Jonsson, L-E., Hakenberg, R., Koren,
      T., Le, K., Liu,\n        Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke,
      T.,\n        Yoshimura, T., and H. Zheng, \"RObust Header Compression (ROHC):\n
      \       Framework and four profiles: RTP, UDP, ESP, and uncompressed\",\n        RFC
      3095, July 2001.\n   [2]  Bormann, C., \"Robust Header Compression (ROHC) over
      PPP\", RFC\n        3241, April 2002.\n   [3]  Simpson, W., \"PPP in HDLC-like
      Framing\", STD 51, RFC 1662, July\n        1994.\n   [4]  Jonsson, L-E. and
      G. Pelletier, \"RObust Header Compression\n        (ROHC): A Compression Profile
      for IP\", RFC 3843, June 2004.\n   [5]  Pelletier, G., \"RObust Header Compression
      (ROHC): Profiles for\n        User Datagram Protocol (UDP) Lite\", RFC 4019,
      April 2005.\n   [6]  Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n
      \       Levels\", BCP 14, RFC 2119, March 1997.\n"
    title: 14.1.  Normative References
  - contents:
    - "14.2.  Informative References\n   [7]  Jonsson, L-E., Pelletier, G., and K.
      Sandlund, \"RObust Header\n        Compression (ROHC): A Link-Layer Assisted
      Profile for\n        IP/UDP/RTP\", RFC 4362, January 2006.\n   [8]  Postel,
      J., \"Internet Protocol\", STD 5, RFC 791, September 1981.\n   [9]  Deering,
      S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6)\n        Specification\",
      RFC 2460, December 1998.\n   [10] Postel, J., \"User Datagram Protocol\", STD
      6, RFC 768, August\n        1980.\n   [11] Schulzrinne, H., Casner, S., Frederick,
      R., and V. Jacobson,\n        \"RTP: A Transport Protocol for Real-Time Applications\",
      STD 64,\n        RFC 3550, July 2003.\n   [12] Kent, S., \"IP Encapsulating
      Security Payload (ESP)\", RFC 4303,\n        December 2005.\n   [13] Glenn,
      R. and S. Kent, \"The NULL Encryption Algorithm and Its\n        Use With IPsec\",
      RFC 2410, November 1998.\n   [14] Kent, S., \"IP Authentication Header\", RFC
      4302, December 2005.\n   [15] Perkins, C., \"Minimal Encapsulation within IP\",
      RFC 2004,\n        October 1996.\n   [16] Farinacci, D., Li, T., Hanks, S.,
      Meyer, D., and P. Traina,\n        \"Generic Routing Encapsulation (GRE)\",
      RFC 2784, March 2000.\n   [17] Dommety, G., \"Key and Sequence Number Extensions
      to GRE\", RFC\n        2890, September 2000.\n"
    title: 14.2.  Informative References
  title: 14.  References
- contents:
  - "Appendix A.  Sample CRC Algorithm\n   #!/usr/bin/perl -w\n   use strict;\n   #=================================\n
    \  #\n   # ROHC CRC demo - Carsten Bormann cabo@tzi.org 2001-08-02\n   #\n   #
    This little demo shows the four types of CRCs in use in RFC 3095,\n   # the specification
    for robust header compression. Type your data in\n   # hexadecimal form and then
    press Control+D.\n   #\n   #---------------------------------\n   #\n   # utility\n
    \  #\n   sub dump_bytes($) {\n       my $x = shift;\n       my $i;\n       for
    ($i = 0; $i < length($x); ) {\n     printf(\"%02x \", ord(substr($x, $i, 1)));\n
    \    printf(\"\\n\") if (++$i % 16 == 0);\n       }\n       printf(\"\\n\") if
    ($i % 16 != 0);\n   }\n   #---------------------------------\n   #\n   # The CRC
    calculation algorithm.\n   #\n   sub do_crc($$$) {\n       my $nbits = shift;\n
    \      my $poly = shift;\n       my $string = shift;\n       my $crc = ($nbits
    == 32 ? 0xffffffff : (1 << $nbits) - 1);\n       for (my $i = 0; $i < length($string);
    ++$i) {\n         my $byte = ord(substr($string, $i, 1));\n         for( my $b
    = 0; $b < 8; $b++ ) {\n           if (($crc & 1) ^ ($byte & 1)) {\n             $crc
    >>= 1;\n             $crc ^= $poly;\n           } else {\n           $crc >>=
    1;\n           }\n           $byte >>= 1;\n         }\n       }\n       printf
    \"%2d bits, \", $nbits;\n       printf \"CRC: %02x\\n\", $crc;\n   }\n   #---------------------------------\n
    \  #\n   # Test harness\n   #\n   $/ = undef;\n   $_ = <>;         # read until
    EOF\n   my $string = \"\"; # extract all that looks hex:\n   s/([0-9a-fA-F][0-9a-fA-F])/$string
    .= chr(hex($1)), \"\"/eg;\n   dump_bytes($string);\n   #---------------------------------\n
    \  #\n   # 32-bit segmentation CRC\n   # Note that the text implies that this
    is complemented like for PPP\n   # (this differs from 8-, 7-, and 3-bit CRCs)\n
    \  #\n   #      C(x) = x^0 + x^1 + x^2 + x^4 + x^5 + x^7 + x^8 + x^10 +\n   #
    \            x^11 + x^12 + x^16 + x^22 + x^23 + x^26 + x^32\n   #\n   do_crc(32,
    0xedb88320, $string);\n   #---------------------------------\n   #\n   # 8-bit
    IR/IR-DYN CRC\n   #\n   #      C(x) = x^0 + x^1 + x^2 + x^8\n   #\n   do_crc(8,
    0xe0, $string);\n   #---------------------------------\n   #\n   # 7-bit FO/SO
    CRC\n   #\n   #      C(x) = x^0 + x^1 + x^2 + x^3 + x^6 + x^7\n   #\n   do_crc(7,
    0x79, $string);\n   #---------------------------------\n   #\n   # 3-bit FO/SO
    CRC\n   #\n   #      C(x) = x^0 + x^1 + x^3\n   #\n   do_crc(3, 0x6, $string);\n"
  title: Appendix A.  Sample CRC Algorithm
- contents:
  - "Authors' Addresses\n   Lars-Erik Jonsson\n   Optand 737\n   SE-831 92 Ostersund,
    Sweden\n   Phone: +46 70 365 20 58\n   EMail: lars-erik@lejonsson.com\n   Kristofer
    Sandlund\n   Ericsson AB\n   Box 920\n   SE-971 28 Lulea, Sweden\n   Phone: +46
    8 404 41 58\n   EMail: kristofer.sandlund@ericsson.com\n   Ghyslain Pelletier\n
    \  Ericsson AB\n   Box 920\n   SE-971 28 Lulea, Sweden\n   Phone: +46 8 404 29
    43\n   EMail: ghyslain.pelletier@ericsson.com\n   Peter Kremer\n   Conformance
    and Software Test Laboratory\n   Ericsson Hungary\n   H-1300 Bp. 3., P.O. Box
    107, HUNGARY\n   Phone: +36 1 437 7033\n   EMail: peter.kremer@ericsson.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
