- contents:
  - '                   MIKEY: Multimedia Internet KEYing

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes a key management scheme that can be used
    for\n   real-time applications (both for peer-to-peer communication and group\n
    \  communication).  In particular, its use to support the Secure Real-\n   time
    Transport Protocol is described in detail.\n   Security protocols for real-time
    multimedia applications have started\n   to appear.  This has brought forward
    the need for a key management\n   solution to support these protocols.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  3\n       1.1.  Existing Solutions . . . . . . . . . . . . . . .
    . . . .  4\n       1.2.  Notational Conventions . . . . . . . . . . . . . . .
    . .  4\n       1.3.  Definitions. . . . . . . . . . . . . . . . . . . . . . .
    \ 4\n       1.4.  Abbreviations. . . . . . . . . . . . . . . . . . . . . .  6\n
    \      1.5.  Outline. . . . . . . . . . . . . . . . . . . . . . . . .  6\n   2.
    \ Basic Overview . . . . . . . . . . . . . . . . . . . . . . . .  7\n       2.1.
    \ Scenarios. . . . . . . . . . . . . . . . . . . . . . . .  7\n       2.2.  Design
    Goals . . . . . . . . . . . . . . . . . . . . . .  8\n       2.3.  System Overview.
    . . . . . . . . . . . . . . . . . . . .  8\n       2.4.  Relation to GKMARCH.
    . . . . . . . . . . . . . . . . . . 10\n   3.  Basic Key Transport and Exchange
    Methods . . . . . . . . . . . 10\n       3.1.  Pre-shared Key . . . . . . . .
    . . . . . . . . . . . . . 12\n       3.2.  Public-Key Encryption. . . . . . .
    . . . . . . . . . . . 13\n       3.3.  Diffie-Hellman Key Exchange. . . . . .
    . . . . . . . . . 14\n   4.  Selected Key Management Functions. . . . . . . .
    . . . . . . . 15\n       4.1.  Key Calculation. . . . . . . . . . . . . . . .
    . . . . . 16\n             4.1.1.  Assumptions. . . . . . . . . . . . . . . .
    . . . 16\n             4.1.2.  Default PRF Description. . . . . . . . . . . .
    . 17\n             4.1.3.  Generating keys from TGK . . . . . . . . . . . . 18\n
    \            4.1.4.  Generating keys for MIKEY Messages from\n                     an
    Envelope/Pre-Shared Key . . . . . . . . . . . 19\n       4.2 Pre-defined Transforms
    and Timestamp Formats . . . . . . . 19\n             4.2.1.  Hash Functions .
    . . . . . . . . . . . . . . . . 19\n             4.2.2.  Pseudo-Random Number
    Generator and PRF . . . . . 20\n             4.2.3.  Key Data Transport Encryption.
    . . . . . . . . . 20\n             4.2.4.  MAC and Verification Message Function.
    . . . . . 21\n             4.2.5.  Envelope Key Encryption. . . . . . . . . .
    . . . 21\n             4.2.6.  Digital Signatures . . . . . . . . . . . . . .
    . 21\n             4.2.7.  Diffie-Hellman Groups. . . . . . . . . . . . . . 21\n
    \            4.2.8.  Timestamps . . . . . . . . . . . . . . . . . . . 21\n             4.2.9.
    \ Adding New Parameters to MIKEY . . . . . . . . . 22\n       4.3.  Certificates,
    Policies and Authorization . . . . . . . . 22\n             4.3.1.  Certificate
    Handling . . . . . . . . . . . . . . 22\n             4.3.2.  Authorization. .
    . . . . . . . . . . . . . . . . 23\n             4.3.3.  Data Policies. . . .
    . . . . . . . . . . . . . . 24\n       4.4.  Retrieving the Data SA . . . . .
    . . . . . . . . . . . . 24\n       4.5.  TGK Re-Keying and CSB Updating . . .
    . . . . . . . . . . 25\n   5.  Behavior and Message Handling. . . . . . . . .
    . . . . . . . . 26\n       5.1.  General. . . . . . . . . . . . . . . . . . .
    . . . . . . 26\n             5.1.1.  Capability Discovery . . . . . . . . . .
    . . . . 26\n             5.1.2.  Error Handling . . . . . . . . . . . . . . .
    . . 27\n       5.2.  Creating a Message . . . . . . . . . . . . . . . . . . .
    28\n       5.3.  Parsing a Message. . . . . . . . . . . . . . . . . . . . 29\n
    \      5.4.  Replay Handling and Timestamp Usage. . . . . . . . . . . 30\n   6.
    \ Payload Encoding . . . . . . . . . . . . . . . . . . . . . . . 32\n       6.1.
    \ Common Header Payload (HDR). . . . . . . . . . . . . . . 32\n             6.1.1.
    \ SRTP ID. . . . . . . . . . . . . . . . . . . . . 35\n       6.2.  Key Data Transport
    Payload (KEMAC) . . . . . . . . . . . 36\n       6.3.  Envelope Data Payload (PKE).
    . . . . . . . . . . . . . . 37\n       6.4.  DH Data Payload (DH) . . . . . .
    . . . . . . . . . . . . 38\n       6.5.  Signature Payload (SIGN) . . . . . .
    . . . . . . . . . . 39\n       6.6.  Timestamp Payload (T). . . . . . . . . .
    . . . . . . . . 39\n       6.7.  ID Payload (ID) / Certificate Payload (CERT)
    . . . . . . 40\n       6.8.  Cert Hash Payload (CHASH). . . . . . . . . . . .
    . . . . 41\n       6.9.  Ver msg payload (V). . . . . . . . . . . . . . . . .
    . . 42\n       6.10. Security Policy Payload (SP) . . . . . . . . . . . . . .
    42\n             6.10.1. SRTP Policy. . . . . . . . . . . . . . . . . . . 44\n
    \      6.11. RAND Payload (RAND). . . . . . . . . . . . . . . . . . . 45\n       6.12.
    Error Payload (ERR). . . . . . . . . . . . . . . . . . . 46\n       6.13. Key
    Data Sub-Payload . . . . . . . . . . . . . . . . . . 46\n       6.14. Key Validity
    Data. . . . . . . . . . . . . . . . . . . . 48\n       6.15. General Extension
    Payload. . . . . . . . . . . . . . . . 50\n   7.  Transport Protocols. . . . .
    . . . . . . . . . . . . . . . . . 50\n   8.  Groups . . . . . . . . . . . . .
    . . . . . . . . . . . . . . . 50\n       8.1.  Simple One-to-Many . . . . . .
    . . . . . . . . . . . . . 51\n       8.2.  Small-Size Interactive Group . . .
    . . . . . . . . . . . 51\n   9.  Security Considerations. . . . . . . . . . .
    . . . . . . . . . 52\n       9.1.  General. . . . . . . . . . . . . . . . . .
    . . . . . . . 52\n       9.2.  Key Lifetime . . . . . . . . . . . . . . . . .
    . . . . . 54\n       9.3.  Timestamps . . . . . . . . . . . . . . . . . . . .
    . . . 55\n       9.4.  Identity Protection. . . . . . . . . . . . . . . . . .
    . 55\n       9.5.  Denial of Service. . . . . . . . . . . . . . . . . . . . 56\n
    \      9.6.  Session Establishment. . . . . . . . . . . . . . . . . . 56\n   10.
    IANA Considerations. . . . . . . . . . . . . . . . . . . . . . 57\n       10.1.
    MIME Registration. . . . . . . . . . . . . . . . . . . . 59\n   11. Acknowledgments.
    . . . . . . . . . . . . . . . . . . . . . . . 59\n   12. References . . . . .
    . . . . . . . . . . . . . . . . . . . . . 60\n       12.1. Normative References
    . . . . . . . . . . . . . . . . . . 60\n       12.2. Informative References .
    . . . . . . . . . . . . . . . . 61\n   Appendix A. - MIKEY - SRTP Relation. .
    . . . . . . . . . . . . . . 63\n   Author's Addresses . . . . . . . . . . . .
    . . . . . . . . . . . . 65\n   Full Copyright Statement . . . . . . . . . . .
    . . . . . . . . . . 66\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   There has recently been work to define a security protocol
    for the\n   protection of real-time applications running over RTP, [SRTP].\n   However,
    a security protocol needs a key management solution to\n   exchange keys and related
    security parameters.  There are some\n   fundamental properties that such a key
    management scheme has to\n   fulfill to serve streaming and real-time applications
    (such as\n   unicast and multicast), particularly in heterogeneous (mix of wired\n
    \  and wireless) networks.\n   This document describes a key management solution
    that addresses\n   multimedia scenarios (e.g., SIP [SIP] calls and RTSP [RTSP]\n
    \  sessions).  The focus is on how to set up key management for secure\n   multimedia
    sessions such that requirements in a heterogeneous\n   environment are fulfilled.\n"
  - contents:
    - "1.1.  Existing Solutions\n   There is work done in the IETF to develop key
      management schemes.\n   For example, IKE [IKE] is a widely accepted unicast
      scheme for IPsec,\n   and the MSEC WG is developing other schemes to address
      group\n   communication [GDOI, GSAKMP].  However, for reasons discussed below,\n
      \  there is a need for a scheme with lower latency, suitable for\n   demanding
      cases such as real-time data over heterogeneous networks\n   and small interactive
      groups.\n   An option in some cases might be to use [SDP], as SDP defines one\n
      \  field to transport keys, the \"k=\" field.  However, this field cannot\n
      \  be used for more general key management purposes, as it cannot be\n   extended
      from the current definition.\n"
    title: 1.1.  Existing Solutions
  - contents:
    - "1.2.  Notational Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      BCP 14, RFC 2119\n   [RFC2119].\n"
    title: 1.2.  Notational Conventions
  - contents:
    - "1.3.  Definitions\n   (Data) Security Protocol: the security protocol used
      to protect the\n   actual data traffic.  Examples of security protocols are
      IPsec and\n   SRTP.\n   Data Security Association (Data SA): information for
      the security\n   protocol, including a TEK and a set of parameters/policies.\n
      \  Crypto Session (CS): uni- or bi-directional data stream(s), protected\n   by
      a single instance of a security protocol.  For example, when SRTP\n   is used,
      the Crypto Session will often contain two streams, an RTP\n   stream and the
      corresponding RTCP, which are both protected by a\n   single SRTP Cryptographic
      Context, i.e., they share key data and the\n   bulk of security parameters in
      the SRTP Cryptographic Context\n   (default behavior in [SRTP]).  In the case
      of IPsec, a Crypto Session\n   would represent an instantiation of an IPsec
      SA.  A Crypto Session\n   can be viewed as a Data SA (as defined in [GKMARCH])
      and could\n   therefore be mapped to other security protocols if necessary.\n
      \  Crypto Session Bundle (CSB): collection of one or more Crypto\n   Sessions,
      which can have common TGKs (see below) and security\n   parameters.\n   Crypto
      Session ID: unique identifier for the CS within a CSB.\n   Crypto Session Bundle
      ID (CSB ID): unique identifier for the CSB.\n   TEK Generation Key (TGK): a
      bit-string agreed upon by two or more\n   parties, associated with CSB.  From
      the TGK, Traffic-encrypting Keys\n   can then be generated without needing further
      communication.\n   Traffic-Encrypting Key (TEK): the key used by the security
      protocol\n   to protect the CS (this key may be used directly by the security\n
      \  protocol or may be used to derive further keys depending on the\n   security
      protocol).  The TEKs are derived from the CSB's TGK.\n   TGK re-keying: the
      process of re-negotiating/updating the TGK (and\n   consequently future TEK(s)).\n
      \  Initiator: the initiator of the key management protocol, not\n   necessarily
      the initiator of the communication.\n   Responder: the responder in the key
      management protocol.\n   Salting key: a random or pseudo-random (see [RAND,
      HAC]) string used\n   to protect against some off-line pre-computation attacks
      on the\n   underlying security protocol.\n   PRF(k,x):  a keyed pseudo-random
      function (see [HAC]).\n   E(k,m):    encryption of m with the key k.\n   PKx:
      \      the public key of x\n   []         an optional piece of information\n
      \  {}         denotes zero or more occurrences\n   ||         concatenation\n
      \  |          OR (selection operator)\n   ^          exponentiation\n   XOR
      \       exclusive or\n   Bit and byte ordering: throughout the document bits
      and bytes are\n   indexed, as usual, from left to right, with the leftmost bits/bytes\n
      \  being the most significant.\n"
    title: 1.3.  Definitions
  - contents:
    - "1.4.  Abbreviations\n   AES    Advanced Encryption Standard\n   CM     Counter
      Mode (as defined in [SRTP])\n   CS     Crypto Session\n   CSB    Crypto Session
      Bundle\n   DH     Diffie-Hellman\n   DoS    Denial of Service\n   MAC    Message
      Authentication Code\n   MIKEY  Multimedia Internet KEYing\n   PK     Public-Key\n
      \  PSK    Pre-Shared key\n   RTP    Real-time Transport Protocol\n   RTSP   Real
      Time Streaming Protocol\n   SDP    Session Description Protocol\n   SIP    Session
      Initiation Protocol\n   SRTP   Secure RTP\n   TEK    Traffic-encrypting key\n
      \  TGK    TEK Generation Key\n"
    title: 1.4.  Abbreviations
  - contents:
    - "1.5.  Outline\n   Section 2 describes the basic scenarios and the design goals
      for\n   which MIKEY is intended.  It also gives a brief overview of the\n   entire
      solution and its relation to the group key management\n   architecture [GKMARCH].\n
      \  The basic key transport/exchange mechanisms are explained in detail\n   in
      Section 3.  The key derivation, and other general key management\n   procedures
      are described in Section 4.\n   Section 5 describes the expected behavior of
      the involved parties.\n   This also includes message creation and parsing.\n
      \  All definitions of the payloads in MIKEY are described in Section 6.\n   Section
      7 deals with transport considerations, while Section 8\n   focuses on how MIKEY
      is used in group scenarios.\n   The Security Considerations section (Section
      9), gives a deeper\n   explanation of important security related topics.\n"
    title: 1.5.  Outline
  title: 1.  Introduction
- contents:
  - '2.  Basic Overview

    '
  - contents:
    - "2.1.  Scenarios\n   MIKEY is mainly intended to be used for peer-to-peer, simple
      one-to-\n   many, and small-size (interactive) groups.  One of the main\n   multimedia
      scenarios considered when designing MIKEY has been the\n   conversational multimedia
      scenario, where users may interact and\n   communicate in real-time.  In these
      scenarios it can be expected that\n   peers set up multimedia sessions between
      each other, where a\n   multimedia session may consist of one or more secured
      multimedia\n   streams (e.g., SRTP streams).\n   peer-to-peer/         many-to-many
      \          many-to-many\n    simple one-to-many           (distributed)          (centralized)\n
      \             ++++        ++++          ++++     ++++           ++++\n              |.
      |        |A |          |B |     |A |----   ----|B |\n            --| ++++      |
      \ |----------|  |     |  |    \\ /    |  |\n   ++++    /  ++|. |      ++++          ++++
      \    ++++    (S)    ++++\n   |A |---------| ++++       \\          /                 |\n
      \  |  |    \\    ++|B |        \\        /                  |\n   ++++     \\-----|
      \ |         \\ ++++ /                  ++++\n                  ++++          \\|C
      |/                   |C |\n                                 |  |                    |
      \ |\n                                 ++++                    ++++\n   Figure
      2.1: Examples of the four scenarios: peer-to-peer, simple\n   one-to-many, many-to-many
      without a centralized server (also denoted\n   as small interactive group),
      and many-to-many with a centralized\n   server.\n   We identify in the following
      some typical scenarios which involve the\n   multimedia applications we are
      dealing with (see also Figure 2.1).\n   a) peer-to-peer (unicast), e.g., a SIP-based
      [SIP] call between two\n      parties, where it may be desirable that the security
      is either set\n      up by mutual agreement or that each party sets up the security
      for\n      its own outgoing streams.\n   b) simple one-to-many (multicast),
      e.g., real-time presentations,\n      where the sender is in charge of setting
      up the security.\n   c) many-to-many, without a centralized control unit, e.g.,
      for\n      small-size interactive groups where each party may set up the\n      security
      for its own outgoing media.  Two basic models may be used\n      here.  In the
      first model, the Initiator of the group acts as the\n      group server (and
      is the only one authorized to include new\n      members).  In the second model,
      authorization information to\n      include new members can be delegated to
      other participants.\n   d) many-to-many, with a centralized control unit, e.g.,
      for larger\n      groups with some kind of Group Controller that sets up the\n
      \     security.\n   The key management solutions may be different in the above
      scenarios.\n   When designing MIKEY, the main focus has been on case a, b, and
      c.\n   For scenario c, only the first model is covered by this document.\n"
    title: 2.1.  Scenarios
  - contents:
    - "2.2.  Design Goals\n   The key management protocol is designed to have the
      following\n   characteristics:\n   *  End-to-end security.  Only the participants
      involved in the\n      communication have access to the generated key(s).\n
      \  *  Simplicity.\n   *  Efficiency.  Designed to have:\n      - low bandwidth
      consumption,\n      - low computational workload,\n      - small code size,
      and\n      - minimal number of roundtrips.\n   *  Tunneling.  Possibility to
      \"tunnel\"/integrate MIKEY in session\n      establishment protocols (e.g.,
      SDP and RTSP).\n   *  Independence from any specific security functionality
      of the\n      underlying transport.\n"
    title: 2.2.  Design Goals
  - contents:
    - "2.3.  System Overview\n   One objective of MIKEY is to produce a Data SA for
      the security\n   protocol, including a traffic-encrypting key (TEK), which is
      derived\n   from a TEK Generation Key (TGK), and used as input for the security\n
      \  protocol.\n   MIKEY supports the possibility of establishing keys and parameters\n
      \  for more than one security protocol (or for several instances of the\n   same
      security protocol) at the same time.  The concept of Crypto\n   Session Bundle
      (CSB) is used to denote a collection of one or more\n   Crypto Sessions that
      can have common TGK and security parameters, but\n   which obtain distinct TEKs
      from MIKEY.\n   The procedure of setting up a CSB and creating a TEK (and Data
      SA),\n   is done in accordance with Figure 2.2:\n   1. A set of security parameters
      and TGK(s) are agreed upon for the\n      Crypto Session Bundle (this is done
      by one of the three\n      alternative key transport/exchange mechanisms, see
      Section 3).\n   2. The TGK(s) is used to derive (in a cryptographically secure
      way) a\n      TEK for each Crypto Session.\n   3. The TEK, together with the
      security protocol parameters, represent\n      the Data SA, which is used as
      the input to the security protocol.\n        +-----------------+\n        |
      \      CSB       |\n        |  Key transport  |                      (see Section
      3)\n        |    /exchange    |\n        +-----------------+\n                 |
      \     :\n                 | TGK  :\n                 v      :\n           +----------+
      :\n   CS ID ->|   TEK    | : Security protocol      (see Section 4)\n           |derivation|
      : parameters (policies)\n           +----------+ :\n              TEK |     :\n
      \                 v     v\n                  Data SA\n                    |\n
      \                   v\n           +-------------------+\n           |  Crypto
      Session   |\n           |(Security Protocol)|\n           +-------------------+\n
      \  Figure 2.2: Overview of MIKEY key management procedure.\n   The security
      protocol can then either use the TEK directly, or, if\n   supported, derive
      further session keys from the TEK (e.g., see SRTP\n   [SRTP]).  It is however
      up to the security protocol to define how the\n   TEK is used.\n   MIKEY can
      be used to update TEKs and the Crypto Sessions in a current\n   Crypto Session
      Bundle (see Section 4.5).  This is done by executing\n   the transport/exchange
      phase once again to obtain a new TGK (and\n   consequently derive new TEKs)
      or to update some other specific CS\n   parameters.\n"
    title: 2.3.  System Overview
  - contents:
    - "2.4.  Relation to GKMARCH\n   The Group key management architecture (GKMARCH)
      [GKMARCH] describes a\n   general architecture for group key management protocols.
      \ MIKEY is a\n   part of this architecture, and can be used as a so-called\n
      \  Registration protocol.  The main entities involved in the\n   architecture
      are the group controller/key server (GCKS), the\n   receiver(s), and the sender(s).\n
      \  In MIKEY, the sender could act as GCKS and push keys down to the\n   receiver(s).\n
      \  Note that, for example, in a SIP-initiated call, the sender may also\n   be
      a receiver.  As MIKEY addresses small interactive groups, a member\n   may dynamically
      change between being a sender and receiver (or being\n   both simultaneously).\n"
    title: 2.4.  Relation to GKMARCH
  title: 2.  Basic Overview
- contents:
  - "3.  Basic Key Transport and Exchange Methods\n   The following sub-sections define
    three different methods of\n   transporting/establishing a TGK: with the use of
    a pre-shared key,\n   public-key encryption, and Diffie-Hellman (DH) key exchange.
    \ In the\n   following, we assume unicast communication for simplicity.  In\n
    \  addition to the TGK, a random \"nonce\", denoted RAND, is also\n   transported.
    \ In all three cases, the TGK and RAND values are then\n   used to derive TEKs
    as described in Section 4.1.3.  A timestamp is\n   also sent to avoid replay attacks
    (see Section 5.4).\n   The pre-shared key method and the public-key method are
    both based on\n   key transport mechanisms, where the actual TGK is pushed (securely)\n
    \  to the recipient(s).  In the Diffie-Hellman method, the actual TGK is\n   instead
    derived from the Diffie-Hellman values exchanged between the\n   peers.\n   The
    pre-shared case is, by far, the most efficient way to handle the\n   key transport
    due to the use of symmetric cryptography only.  This\n   approach also has the
    advantage that only a small amount of data has\n   to be exchanged.  Of course,
    the problematic issue is scalability as\n   it is not always feasible to share
    individual keys with a large group\n   of peers.  Therefore, this case mainly
    addresses scenarios such as\n   server-to-client and also those cases where the
    public-key modes have\n   already been used, thus allowing for the \"cache\" of
    a symmetric key\n   (see below and Section 3.2).\n   Public-key cryptography can
    be used to create a scalable system.  A\n   disadvantage with this approach is
    that it is more resource consuming\n   than the pre-shared key approach.  Another
    disadvantage is that in\n   most cases, a PKI (Public Key Infrastructure) is needed
    to handle the\n   distribution of public keys.  Of course, it is possible to use
    public\n   keys as pre-shared keys (e.g., by using self-signed certificates).\n
    \  It should also be noted that, as mentioned above, this method may be\n   used
    to establish a \"cached\" symmetric key that later can be used to\n   establish
    subsequent TGKs by using the pre-shared key method (hence,\n   the subsequent
    request can be executed more efficiently).\n   In general, the Diffie-Hellman
    (DH) key agreement method has a higher\n   resource consumption (both computationally
    and in bandwidth) than the\n   previous ones, and needs certificates as in the
    public-key case.\n   However, it has the advantage of providing perfect forward
    secrecy\n   (PFS) and flexibility by allowing implementation in several different\n
    \  finite groups.\n   Note that by using the DH method, the two involved parties
    will\n   generate a unique unpredictable random key.  Therefore, it is not\n   possible
    to use this DH method to establish a group TEK (as the\n   different parties in
    the group would end up with different TEKs).  It\n   is not the intention of the
    DH method to work in this scenario, but\n   to be a good alternative in the special
    peer-to-peer case.\n   The following general notation is used:\n   HDR:  The general
    MIKEY header, which includes MIKEY CSB related data\n   (e.g., CSB ID) and information
    mapping to the specific security\n   protocol used.  See Section 6.1 for payload
    definition.\n   T:    The timestamp, used mainly to prevent replay attacks.  See\n
    \  Section 6.6 for payload definition and also Section 5.4 for other\n   timestamp
    related information.\n   IDx:  The identity of entity x (IDi=Initiator, IDr=Responder).
    \ See\n   Section 6.7 for payload definition.\n   RAND: Random/pseudo-random byte-string,
    which is always included in\n   the first message from the Initiator.  RAND is
    used as a freshness\n   value for the key generation.  It is not included in update
    messages\n   of a CSB.  See Section 6.11 for payload definition.  For randomness\n
    \  recommendations for security, see [RAND].\n   SP:   The security policies for
    the data security protocol.  See\n   Section 6.10 for payload definition.\n"
  - contents:
    - "3.1.  Pre-shared key\n   In this method, the pre-shared secret key, s, is used
      to derive key\n   material for both the encryption (encr_key) and the integrity\n
      \  protection (auth_key) of the MIKEY messages, as described in Section\n   4.1.4.
      \ The encryption and authentication transforms are described in\n   Section
      4.2.\n   Initiator                                   Responder\n      I_MESSAGE
      =\n      HDR, T, RAND, [IDi],[IDr],\n           {SP}, KEMAC                --->\n
      \                                                 R_MESSAGE =\n                                     [<---]
      \      HDR, T, [IDr], V\n   The main objective of the Initiator's message (I_MESSAGE)
      is to\n   transport one or more TGKs (carried into KEMAC) and a set of security\n
      \  parameters (SPs) to the Responder in a secure manner.  As the\n   verification
      message from the Responder is optional, the Initiator\n   indicates in the HDR
      whether it requires a verification message or\n   not from the Responder.\n
      \  KEMAC = E(encr_key, {TGK}) || MAC\n   The KEMAC payload contains a set of
      encrypted sub-payloads and a MAC.\n   Each sub-payload includes a TGK randomly
      and independently chosen by\n   the Initiator (and other possible related parameters,
      e.g., the key\n   lifetime).  The MAC is a Message Authentication Code covering
      the\n   entire MIKEY message using the authentication key, auth_key.  See\n
      \  Section 6.2 for payload definition and Section 5.2 for an exact\n   definition
      of the MAC calculation.\n   The main objective of the verification message from
      the Responder is\n   to obtain mutual authentication.  The verification message,
      V, is a\n   MAC computed over the Responder's entire message, the timestamp
      (the\n   same as the one that was included in the Initiator's message), and\n
      \  the two parties identities, using the authentication key.  See also\n   Section
      5.2 for the exact definition of the Verification MAC\n   calculation and Section
      6.9 for payload definition.\n   The ID fields SHOULD be included, but they MAY
      be left out when it\n   can be expected that the peer already knows the other
      party's ID\n   (otherwise it cannot look up the pre-shared key).  For example,
      this\n   could be the case if the ID is extracted from SIP.\n   It is MANDATORY
      to implement this method.\n"
    title: 3.1.  Pre-shared key
  - contents:
    - "3.2.  Public-key encryption\n   Initiator                                        Responder\n
      \  I_MESSAGE =\n   HDR, T, RAND, [IDi|CERTi], [IDr], {SP},\n       KEMAC, [CHASH],
      PKE, SIGNi         --->\n                                                   R_MESSAGE
      =\n                                         [<---]    HDR, T, [IDr], V\n   As
      in the previous case, the main objective of the Initiator's\n   message is to
      transport one or more TGKs and a set of security\n   parameters to the Responder
      in a secure manner.  This is done using\n   an envelope approach where the TGKs
      are encrypted (and integrity\n   protected) with keys derived from a randomly/pseudo-randomly
      chosen\n   \"envelope key\".  The envelope key is sent to the Responder encrypted\n
      \  with the public key of the Responder.\n   The PKE contains the encrypted
      envelope key: PKE = E(PKr, env_key).\n   It is encrypted using the Responder's
      public key (PKr).  If the\n   Responder possesses several public keys, the Initiator
      can indicate\n   the key used in the CHASH payload (see Section 6.8).\n   The
      KEMAC contains a set of encrypted sub-payloads and a MAC:\n   KEMAC = E(encr_key,
      IDi || {TGK}) || MAC\n   The first payload (IDi) in KEMAC is the identity of
      the Initiator\n   (not a certificate, but generally the same ID as the one specified
      in\n   the certificate).  Each of the following payloads (TGK) includes a\n
      \  TGK randomly and independently chosen by the Initiator (and possible\n   other
      related parameters, e.g., the key lifetime).  The encrypted\n   part is then
      followed by a MAC, which is calculated over the KEMAC\n   payload.  The encr_key
      and the auth_key are derived from the envelope\n   key, env_key, as specified
      in Section 4.1.4.  See also Section 6.2\n   for payload definition.\n   The
      SIGNi is a signature covering the entire MIKEY message, using the\n   Initiator's
      signature key (see also Section 5.2 for the exact\n   definition).\n   The main
      objective of the verification message from the Responder is\n   to obtain mutual
      authentication.  As the verification message V from\n   the Responder is optional,
      the Initiator indicates in the HDR whether\n   it requires a verification message
      or not from the Responder.  V is\n   calculated in the same way as in the pre-shared
      key mode (see also\n   Section 5.2 for the exact definition).  See Section 6.9
      for payload\n   definition.\n   Note that there will be one encrypted IDi and
      possibly also one\n   unencrypted IDi.  The encrypted one is used together with
      the MAC as\n   a countermeasure for certain man-in-the-middle attacks, while
      the\n   unencrypted one is always useful for the Responder to immediately\n
      \  identify the Initiator.  The encrypted IDi MUST always be verified to\n   be
      equal with the expected IDi.\n   It is possible to cache the envelope key, so
      that it can be used as a\n   pre-shared key.  It is not recommended for this
      key to be cached\n   indefinitely (however it is up to the local policy to decide
      this).\n   This function may be very convenient during the lifetime of a CSB,
      if\n   a new crypto session needs to be added (or an expired one removed).\n
      \  Then, the pre-shared key can be used, instead of the public keys (see\n   also
      Section 4.5).  If the Initiator indicates that the envelope key\n   should be
      cached, the key is at least to be cached during the\n   lifetime of the entire
      CSB.\n   The cleartext ID fields and certificate SHOULD be included, but they\n
      \  MAY be left out when it can be expected that the peer already knows\n   the
      other party's ID, or can obtain the certificate in some other\n   manner.  For
      example, this could be the case if the ID is extracted\n   from SIP.\n   For
      certificate handling, authorization, and policies, see Section\n   4.3.\n   It
      is MANDATORY to implement this method.\n"
    title: 3.2.  Public-key encryption
  - contents:
    - "3.3.  Diffie-Hellman key exchange\n   For a fixed, agreed upon, cyclic group,
      (G,*), we let g denote a\n   generator for this group.  Choices for the parameters
      are given in\n   Section 4.2.7.  The other transforms below are described in
      Section\n   4.2.\n   This method creates a DH-key, which is used as the TGK.
      \ This method\n   cannot be used to create group keys; it can only be used to
      create\n   single peer-to-peer keys.  It is OPTIONAL to implement this method.\n
      \  Initiator                                          Responder\n   I_MESSAGE
      =\n   HDR, T, RAND, [IDi|CERTi],[IDr]\n        {SP}, DHi, SIGNi           --->\n
      \                                             R_MESSAGE =\n                                   <---
      \      HDR, T, [IDr|CERTr], IDi,\n                                              DHr,
      DHi, SIGNr\n   The main objective of the Initiator's message is to, in a secure
      way,\n   provide the Responder with its DH value (DHi) g^(xi), where xi MUST\n
      \  be randomly/pseudo-randomly and secretly chosen, and a set of\n   security
      protocol parameters.\n   The SIGNi is a signature covering the Initiator's MIKEY
      message,\n   I_MESSAGE, using the Initiator's signature key (see Section 5.2
      for\n   the exact definition).\n   The main objective of the Responder's message
      is to, in a secure way,\n   provide the Initiator with the Responder's value
      (DHr) g^(xr), where\n   xr MUST be randomly/pseudo-randomly and secretly chosen.
      \ The\n   timestamp that is included in the answer is the same as the one\n
      \  included in the Initiator's message.\n   The SIGNr is a signature covering
      the Responder's MIKEY message,\n   R_MESSAGE, using the Responder's signature
      key (see Section 5.2 for\n   the exact definition).\n   The DH group parameters
      (e.g., the group G, the generator g) are\n   chosen by the Initiator and signaled
      to the Responder.  Both parties\n   calculate the TGK, g^(xi*xr) from the exchanged
      DH-values.\n   Note that this approach does not require that the Initiator has
      to\n   possess any of the Responder's certificates before the setup.\n   Instead,
      it is sufficient that the Responder includes its signing\n   certificate in
      the response.\n   The ID fields and certificate SHOULD be included, but they
      MAY be\n   left out when it can be expected that the peer already knows the\n
      \  other party's ID (or can obtain the certificate in some other\n   manner).
      \ For example, this could be the case if the ID is extracted\n   from SIP.\n
      \  For certificate handling, authorization, and policies, see Section\n   4.3.\n"
    title: 3.3.  Diffie-Hellman key exchange
  title: 3.  Basic Key Transport and Exchange Methods
- contents:
  - "4.  Selected Key Management Functions\n   MIKEY manages symmetric keys in two
    main ways.  First, following key\n   transport or key exchange of TGK(s) (and
    other parameters) as defined\n   by any of the above three methods, MIKEY maintains
    a mapping between\n   Data SA identifiers and Data SAs, where the identifiers
    used depend\n   on the security protocol in question, see Section 4.4.  Thus,
    when\n   the security protocol requests a Data SA, given such a Data SA\n   identifier,
    an up-to-date Data SA will be obtained.  In particular,\n   correct keying material,
    TEK(s), might need to be derived.  The\n   derivation of TEK(s) (and other keying
    material) is done from a TGK\n   and is described in Section 4.1.3.\n   Second,
    for use within MIKEY itself, two key management procedures\n   are needed:\n   *
    \ in the pre-shared case, deriving encryption and authentication key\n      material
    from a single pre-shared key, and\n   *  in the public key case, deriving similar
    key material from the\n      transported envelope key.\n   These two key derivation
    methods are specified in section 4.1.4.\n   All the key derivation functionality
    mentioned above is based on a\n   pseudo-random function, defined next.\n"
  - contents:
    - "4.1.  Key Calculation\n   In the following, we define a general method (pseudo-random
      function)\n   to derive one or more keys from a \"master\" key.  This method
      is used\n   to derive:\n   *  TEKs from a TGK and the RAND value,\n   *  encryption,
      authentication, or salting key from a pre-shared/\n      envelope key and the
      RAND value.\n"
    - contents:
      - "4.1.1.  Assumptions\n   We assume that the following parameters are in place:\n
        \  csb_id : Crypto Session Bundle ID (32-bits unsigned integer)\n   cs_id
        \ : the Crypto Session ID (8-bits unsigned integer)\n   RAND   : (at least)
        128-bit (pseudo-)random bit-string sent by the\n            Initiator in the
        initial exchange.\n   The key derivation method has the following input parameters:\n
        \  inkey     : the input key to the derivation function\n   inkey_len : the
        length in bits of the input key\n   label     : a specific label, dependent
        on the type of the key to be\n               derived, the RAND, and the session
        IDs\n   outkey_len: desired length in bits of the output key.\n   The key
        derivation method has the following output:\n   outkey: the output key of
        desired length.\n"
      title: 4.1.1.  Assumptions
    - contents:
      - "4.1.2.  Default PRF Description\n   Let HMAC be the SHA-1 based message authentication
        function, see\n   [HMAC] [SHA-1].  Similarly to [TLS], we define:\n      P
        (s, label, m) = HMAC (s, A_1 || label) ||\n                        HMAC (s,
        A_2 || label) || ...\n                        HMAC (s, A_m || label)\n   where\n
        \     A_0 = label,\n      A_i = HMAC (s, A_(i-1))\n      s is a key (defined
        below)\n      m is a positive integer (also defined below).\n   Values of
        label depend on the case in which the PRF is invoked, and\n   values are specified
        in the following for the default PRF.  Thus,\n   note that other PRFs later
        added to MIKEY MAY specify different input\n   parameters.\n   The following
        procedure describes a pseudo-random function, denoted\n   PRF(inkey,label),
        based on the above P-function, applied to compute\n   the output key, outkey:\n
        \  *  let n = inkey_len / 256, rounded up to the nearest integer if not\n
        \     already an integer\n   *   split the inkey into n blocks, inkey = s_1
        || ... || s_n, where *\n      all s_i, except possibly s_n, are 256 bits each\n
        \  *  let m = outkey_len / 160, rounded up to the nearest integer if not\n
        \     already an integer\n   (The values \"256\" and \"160\" equals half the
        input block-size and full\n   output hash size, respectively, of the SHA-1
        hash as part of the P-\n   function.)\n   Then, the output key, outkey, is
        obtained as the outkey_len most\n   significant bits of\n   PRF(inkey, label)
        = P(s_1, label, m) XOR P(s_2, label, m) XOR ...\n                       XOR
        P(s_n, label, m).\n"
      title: 4.1.2.  Default PRF Description
    - contents:
      - "4.1.3.  Generating keys from TGK\n   In the following, we describe how keying
        material is derived from a\n   TGK, thus assuming that a mapping of the Data
        SA identifier to the\n   correct TGK has already been done according to Section
        4.4.\n   The key derivation method SHALL be executed using the above PRF with\n
        \  the following input parameters:\n   inkey       : TGK\n   inkey_len   :
        bit length of TGK\n   label       : constant || cs_id || csb_id || RAND\n
        \  outkey_len  : bit length of the output key.\n   The constant part of label
        depends on the type of key that is to be\n   generated.  The constant 0x2AD01C64
        is used to generate a TEK from\n   TGK.  If the security protocol itself does
        not support key derivation\n   for authentication and encryption from the
        TEK, separate\n   authentication and encryption keys MAY be created directly
        for the\n   security protocol by replacing 0x2AD01C64 with 0x1B5C7973 and\n
        \  0x15798CEF respectively, and outkey_len by the desired key-length(s)\n
        \  in each case.\n   A salt key can be derived from the TGK as well, by using
        the constant\n   0x39A2C14B.  Note that the Key data sub-payload (Section
        6.13) can\n   carry a salt.  The security protocol in need of the salt key
        SHALL\n   use the salt key carried in the Key data sub-payload (in the pre-\n
        \  shared and public-key case), when present.  If that is not sent, then\n
        \  it is possible to derive the salt key via the key derivation\n   function,
        as described above.\n   The table below summarizes the constant values, used
        to generate keys\n   from a TGK.\n   constant    | derived key from the TGK\n
        \  --------------------------------------\n   0x2AD01C64  | TEK\n   0x1B5C7973
        \ | authentication key\n   0x15798CEF  | encryption key\n   0x39A2C14B  |
        salting key\n   Table 4.1.3: Constant values for the derivation of keys from
        TGK.\n   Note that these 32-bit constant values (listed in the table above)\n
        \  are taken from the decimal digits of e (i.e., 2.7182...), where each\n
        \  constant consists of nine decimal digits (e.g., the first nine\n   decimal
        digits 718281828 = 0x2AD01C64).  The strings of nine\n   decimal digits are
        not chosen at random, but as consecutive \"chunks\"\n   from the decimal digits
        of e.\n"
      title: 4.1.3.  Generating keys from TGK
    - contents:
      - "4.1.4.  Generating keys for MIKEY messages from an envelope/pre-shared\n
        \       key\n   This derivation is to form the symmetric encryption key (and
        salting\n   key) for the encryption of the TGK in the pre-shared key and public\n
        \  key methods.  This is also used to derive the symmetric key used for\n
        \  the message authentication code in these messages, and the\n   corresponding
        verification messages.  Hence, this derivation is\n   needed in order to get
        different keys for the encryption and the MAC\n   (and in the case of the
        pre-shared key, it will result in fresh key\n   material for each new CSB).
        \ The parameters for the default PRF are\n   here:\n   inkey      : the envelope
        key or the pre-shared key\n   inkey_len  : the bit length of inkey\n   label
        \     : constant || 0xFF || csb_id || RAND\n   outkey_len : desired bit length
        of the output key.\n   The constant part of label depends on the type of key
        that is to be\n   generated from an envelope/pre-shared key, as summarized
        below.\n   constant    | derived key\n   --------------------------------------\n
        \  0x150533E1  | encryption key\n   0x2D22AC75  | authentication key\n   0x29B88916
        \ | salt key\n   Table 4.1.4: Constant values for the derivation of keys from
        an\n   envelope/pre-shared key.\n"
      title: 4.1.4.  Generating keys for MIKEY messages from an envelope/pre-shared
    title: 4.1.  Key Calculation
  - contents:
    - "4.2.  Pre-defined Transforms and Timestamp Formats\n   This section identifies
      default transforms for MIKEY.  It is\n   mandatory to implement and support
      the following transforms in the\n   respective case.  New transforms can be
      added in the future (see\n   Section 4.2.9 for further guidelines).\n"
    - contents:
      - "4.2.1.  Hash functions\n   In MIKEY, it is MANDATORY to implement SHA-1 as
        the default hash\n   function.\n"
      title: 4.2.1.  Hash functions
    - contents:
      - "4.2.2.  Pseudo-random number generator and PRF\n   A cryptographically secure
        random or pseudo-random number generator\n   MUST be used for the generation
        of the keying material and nonces,\n   e.g., [BMGL].  However, which one to
        use is implementation specific\n   (as the choice will not affect the interoperability).\n
        \  For the key derivations, it is MANDATORY to implement the PRF\n   specified
        in Section 4.1.  Other PRFs MAY be added by writing\n   standard-track RFCs
        specifying the PRF constructions and their exact\n   use within MIKEY.\n"
      title: 4.2.2.  Pseudo-random number generator and PRF
    - contents:
      - "4.2.3.  Key data transport encryption\n   The default and mandatory-to-implement
        key transport encryption is\n   AES in counter mode, as defined in [SRTP],
        using a 128-bit key as\n   derived in Section 4.1.4, SRTP_PREFIX_LENGTH set
        to zero, and using\n   the initialization vector\n   IV = (S XOR (0x0000 ||
        CSB ID || T)) || 0x0000,\n   where S is a 112-bit salting key, also derived
        as in Section 4.1.4,\n   and where T is the 64-bit timestamp sent by the Initiator.\n
        \  Note: this restricts the maximum size that can be encrypted to 2^23\n   bits,
        which is still enough for all practical purposes [SRTP].\n   The NULL encryption
        algorithm (i.e., no encryption) can be used (but\n   implementation is OPTIONAL).
        \ Note that this MUST NOT be used unless\n   the underlying protocols can
        guarantee security.  The main reason for\n   including this is for specific
        SIP scenarios, where SDP is protected\n   end-to-end.  For this scenario,
        MIKEY MAY be used with the pre-shared\n   key method, the NULL encryption,
        and NULL authentication algorithm\n   (see Section 4.2.4) while relying on
        the security of SIP.  Use this\n   option with caution!\n   The AES key wrap
        function [AESKW] is included as an OPTIONAL\n   implementation method.  If
        the key wrap function is used in the\n   public key method, the NULL MAC is
        RECOMMENDED to be used, as the key\n   wrap itself will provide integrity
        of the encrypted content (note\n   though that the NULL MAC SHOULD NOT be
        used in the pre-shared key\n   case, as the MAC in that case covers the entire
        message).  The 128-\n   bit key and a 64-bit salt, S, are derived in accordance
        to Section\n   4.1.4 and the key wrap IV is then set to S.\n"
      title: 4.2.3.  Key data transport encryption
    - contents:
      - "4.2.4.  MAC and Verification Message function\n   MIKEY uses a 160-bit authentication
        tag, generated by HMAC with SHA-1\n   as the MANDATORY implementation method,
        see [HMAC].  Authentication\n   keys are derived according to Section 4.1.4.
        \ Note that the\n   authentication key size SHOULD be equal to the size of
        the hash\n   function's output (e.g., for HMAC-SHA-1, a 160-bit authentication
        key\n   is used) [HMAC].\n   The NULL authentication algorithm (i.e., no MAC)
        can be used together\n   with the NULL encryption algorithm (but implementation
        is OPTIONAL).\n   Note that this MUST NOT be used unless the underlying protocols
        can\n   guarantee security.  The main reason for including this is for\n   specific
        SIP scenarios, where SDP is protected end-to-end.  For this\n   scenario,
        MIKEY MAY be used with the pre-shared key method and the\n   NULL encryption
        and authentication algorithm, while relying on the\n   security of SIP.  Use
        this option with caution!\n"
      title: 4.2.4.  MAC and Verification Message function
    - contents:
      - "4.2.5.  Envelope Key encryption\n   The public key encryption algorithm applied
        is defined by, and\n   dependent on the certificate used. It is MANDATORY
        to support RSA\n   PKCS#1, v1.5, and it is RECOMMENDED to also support RSA
        OAEP [PSS].\n"
      title: 4.2.5.  Envelope Key encryption
    - contents:
      - "4.2.6.  Digital Signatures\n   The signature algorithm applied is defined
        by, and dependent on the\n   certificate used. It is MANDATORY to support
        RSA PKCS#1, v1.5, and it\n   is RECOMMENDED to also support RSA PSS [PSS].\n"
      title: 4.2.6.  Digital Signatures
    - contents:
      - "4.2.7.  Diffie-Hellman Groups\n   The Diffie-Hellman key exchange, when supported,
        uses OAKLEY 5\n   [OAKLEY] as a mandatory implementation.  Both OAKLEY 1 and
        OAKLEY 2\n   MAY be used (but these are OPTIONAL implementations).\n   See
        Section 4.2.9 for the guidelines on specifying a new DH Group to\n   be used
        within MIKEY.\n"
      title: 4.2.7.  Diffie-Hellman Groups
    - contents:
      - "4.2.8.  Timestamps\n   The timestamp is as defined in NTP [NTP], i.e., a
        64-bit number in\n   seconds relative to 0h on 1 January 1900.  An implementation
        MUST be\n   aware of (and take into account) the fact that the counter will\n
        \  overflow approximately every 136th year.  It is RECOMMENDED that the\n
        \  time always be specified in UTC.\n"
      title: 4.2.8.  Timestamps
    - contents:
      - "4.2.9.  Adding new parameters to MIKEY\n   There are two different parameter
        sets that can be added to MIKEY.\n   The first is a set of MIKEY transforms
        (needed for the exchange\n   itself), and the second is the Data SAs.\n   New
        transforms and parameters (including new policies) SHALL be added\n   by registering
        with IANA (according to [RFC2434], see also Section\n   10) a new number for
        the concerned payload, and also if necessary,\n   documenting how the new
        transform/parameter is used.  Sometimes it\n   might be enough to point to
        an already specified document for the\n   usage, e.g., when adding a new,
        already standardized, hash function.\n   In the case of adding a new DH group,
        the group MUST be specified in\n   a companion standards-track RFC (it is
        RECOMMENDED that the specified\n   group use the same format as used in [OAKLEY]).
        \ A number can then be\n   assigned by IANA for such a group to be used in
        MIKEY.\n   When adding support for a new data security protocol, the following\n
        \  MUST be specified:\n   *  A map sub-payload (see Section 6.1).  This is
        used to be able to\n      map a crypto session to the right instance of the
        data security\n      protocol and possibly also to provide individual parameters
        for\n      each data security protocol.\n   *  A policy payload, i.e., specification
        of parameters and supported\n      values.\n   *  General guidelines of usage.\n"
      title: 4.2.9.  Adding new parameters to MIKEY
    title: 4.2.  Pre-defined Transforms and Timestamp Formats
  - contents:
    - '4.3.  Certificates, Policies and Authorization

      '
    - contents:
      - "4.3.1.  Certificate handling\n   Certificate handling may involve a number
        of additional tasks not\n   shown here, and effect the inclusion of certain
        parts of the message\n   (c.f. [X.509]).  However, the following observations
        can be made:\n   *  The Initiator typically has to find the certificate of
        the\n      Responder in order to send the first message.  If the Initiator\n
        \     does not already have the Responder's certificate, this may\n      involve
        one or more roundtrips to a central directory agent.\n   *  It will be possible
        for the Initiator to omit its own certificate\n      and rely on the Responder
        getting this certificate using other\n      means.  However, we only recommend
        doing this when it is\n      reasonable to expect that the Responder has cached
        the certificate\n      from a previous connection.  Otherwise accessing the
        certificate\n      would mean additional roundtrips for the Responder as well.\n
        \  *  Verification of the certificates using Certificate Revocation\n      Lists
        (CRLs) [X.509] or protocols such as OCSP [OCSP] may be\n      necessary.  All
        parties in a MIKEY exchange should have a local\n      policy which dictates
        whether such checks are made, how they are\n      made, and how often they
        are made.  Note that performing the\n      checks may imply additional messaging.\n"
      title: 4.3.1.  Certificate handling
    - contents:
      - "4.3.2.  Authorization\n   In general, there are two different models for
        making authorization\n   decisions for both the Initiator and the Responder,
        in the context of\n   the applications targeted by MIKEY:\n   *  Specific
        peer-to-peer configuration.  The user has configured the\n      application
        to trust a specific peer.\n      When pre-shared secrets are used, this is
        pretty much the only\n      available scheme.  Typically, the configuration/entering
        of the\n      pre-shared secret is taken to mean that authorization is implied.\n
        \     In some cases, one could also use this with public keys, e.g., if\n
        \     two peers exchange keys offline and configure them to be used for\n
        \     the purpose of running MIKEY.\n   *  Trusted root.  The user accepts
        all peers that prove to have a\n      certificate issued by a specific CA.
        \ The granularity of\n      authorization decisions is not very precise in
        this method.\n      In order to make this method possible, all participants
        in the\n      MIKEY protocol need to configure one or more trusted roots.
        \ The\n      participants also need to be capable of performing certificate\n
        \     chain validation, and possibly transfer more than a single\n      certificate
        in the MIKEY messages (see also Section 6.7).\n   In practice, a combination
        of both mentioned methods might be\n   advantageous.  Also, the possibility
        for a user to explicitly exclude\n   a specific peer (or sub-tree) in a trust
        chain might be needed.\n   These authorization policies address the MIKEY
        scenarios a-c of\n   Section 2.1, where the Initiator acts as the group owner
        and is also\n   the only one that can invite others.  This implies that for
        each\n   Responder, the distributed keys MUST NOT be re-distributed to other\n
        \  parties.\n   In a many-to-many situation, where the group control functions
        are\n   distributed (and/or where it is possible to delegate the group\n   control
        function to others), a means of distributing authorization\n   information
        about who may be added to the group MUST exist.  However,\n   it is out of
        scope of this document to specify how this should be\n   done.\n   For any
        broader communication situation, an external authorization\n   infrastructure
        may be used (following the assumptions of [GKMARCH]).\n"
      title: 4.3.2.  Authorization
    - contents:
      - "4.3.3.  Data Policies\n   Included in the message exchange, policies (i.e.,
        security\n   parameters) for the Data security protocol are transmitted.  The\n
        \  policies are defined in a separate payload and are specific to the\n   security
        protocol (see also Section 6.10).  Together with the keys,\n   the validity
        period of these can also be specified.  For example,\n   this can be done
        with an SPI (or SRTP MKI) or with an Interval (e.g.,\n   a sequence number
        interval for SRTP), depending on the security\n   protocol.\n   New parameters
        can be added to a policy by documenting how they\n   should be interpreted
        by MIKEY and by also registering new values in\n   the appropriate name space
        in IANA.  If a completely new policy is\n   needed, see Section 4.2.9 for
        guidelines.\n"
      title: 4.3.3.  Data Policies
    title: 4.3.  Certificates, Policies and Authorization
  - contents:
    - "4.4.  Retrieving the Data SA\n   The retrieval of a Data SA will depend on
      the security protocol, as\n   different security protocols will have different
      characteristics.\n   When adding support for a security protocol to MIKEY, some
      interface\n   of how the security protocol retrieves the Data SA from MIKEY
      MUST be\n   specified (together with policies that can be negotiated).\n   For
      SRTP, the SSRC (see [SRTP]) is one of the parameters used to\n   retrieve the
      Data SA (while the MKI may be used to indicate the\n   TGK/TEK used for the
      Data SA).  However, the SSRC is not sufficient.\n   For the retrieval of the
      Data SA from MIKEY, it is RECOMMENDED that\n   the MIKEY implementation support
      a lookup using destination network\n   address and port together with SSRC.
      \ Note that MIKEY does not send\n   network addresses or ports.  One reason
      for this is that they may not\n   be known in advance.  Also, if a NAT exists
      in-between, problems may\n   arise.  When SIP or RTSP is used, the local view
      of the destination\n   address and port can be obtained from either SIP or RTSP.
      \ MIKEY can\n   then use these addresses as the index for the Data SA lookup.\n"
    title: 4.4.  Retrieving the Data SA
  - contents:
    - "4.5.  TGK re-keying and CSB updating\n   MIKEY provides a means of updating
      the CSB (e.g., transporting a new\n   TGK/TEK or adding a new Crypto Session
      to the CSB).  The updating of\n   the CSB is done by executing MIKEY again,
      for example, before a TEK\n   expires, or when a new Crypto Session is added
      to the CSB.  Note that\n   MIKEY does not provide re-keying in the GKMARCH sense,
      only updating\n   of the keys by normal unicast messages.\n   When MIKEY is
      executed again to update the CSB, it is not necessary\n   to include certificates
      and other information that was provided in\n   the first exchange, for example,
      all payloads that are static or\n   optionally included may be left out (see
      Figure 4.1).\n   The new message exchange MUST use the same CSB ID as the initial\n
      \  exchange, but MUST use a new timestamp.  A new RAND MUST NOT be\n   included
      in the message exchange (the RAND will only have effect in\n   the Initial exchange).
      \ If desired, new Crypto Sessions are added in\n   the update message.  Note
      that a MIKEY update message does not need\n   to contain new keying material
      (e.g., new TGK).  In this case, the\n   crypto session continues to use the
      previously established keying\n   material, while updating the new information.\n
      \  As explained in Section 3.2, the envelope key can be \"cached\" as a\n   pre-shared
      key (this is indicated by the Initiator in the first\n   message sent).  If
      so, the update message is a pre-shared key message\n   with the cached envelope
      key as the pre-shared key; it MUST NOT be a\n   public key message.  If the
      public key message is used, but the\n   envelope key is not cached, the Initiator
      MUST provide a new\n   encrypted envelope key that can be used in the verification
      message.\n   However, the Initiator does not need to provide any other keys.\n
      \  Figure 4.1 visualizes the update messages that can be sent, including\n   the
      optional parts.  The main difference from the original message is\n   that it
      is optional to include TGKs (or DH values in the DH method).\n   Also see Section
      3 for more details on the specific methods.\n   By definition, a CSB can contain
      several CSs.  A problem that then\n   might occur is to synchronize the TGK
      re-keying if an SPI (or similar\n   functionality, e.g., MKI in [SRTP]) is not
      used.  It is therefore\n   RECOMMENDED that an SPI or MKI be used, if more than
      one CS is\n   present.\n     Initiator                                       Responder\n
      \    Pre-shared key method:\n     I_MESSAGE =\n     HDR, T, [IDi], [IDr], {SP},
      KEMAC   --->\n                                                    R_MESSAGE
      =\n                                        [<---]     HDR, T, [IDr], V\n     Public
      key method:\n     I_MESSAGE =\n     HDR, T, [IDi|CERTi], [IDr], {SP},\n          [KEMAC],
      [CHASH], PKE, SIGNi   --->\n                                                 R_MESSAGE
      =\n                                        [<---]   HDR, T, [IDr], V\n     DH
      method:\n     I_MESSAGE =\n     HDR, T, [IDi|CERTi], [IDr], {SP},\n          [DHi],
      SIGNi                   --->\n                                               R_MESSAGE
      =\n                                         <---  HDR, T, [IDr|CERTr], IDi,\n
      \                                                  [DHr, DHi], SIGNr\n   Figure
      4.1: Update messages.\n   Note that for the DH method, if the Initiator includes
      the DHi\n   payload, then the Responder MUST include DHr and DHi.  If the\n
      \  Initiator does not include DHi, the Responder MUST NOT include DHr or\n   DHi.\n"
    title: 4.5.  TGK re-keying and CSB updating
  title: 4.  Selected Key Management Functions
- contents:
  - "5.  Behavior and message handling\n   Each message that is sent by the Initiator
    or the Responder is built\n   by a set of payloads.  This section describes how
    messages are\n   created and also when they can be used.\n"
  - contents:
    - '5.1.  General

      '
    - contents:
      - "5.1.1.  Capability Discovery\n   The Initiator indicates the security policy
        to be used (i.e., in\n   terms of security protocol algorithms).  If the Responder
        does not\n   support it (for some reason), the Responder can together with
        an\n   error message (indicating that it does not support the parameters),\n
        \  send back its own capabilities (negotiation) to let the Initiator\n   choose
        a common set of parameters.  This is done by including one or\n   more security
        policy payloads in the error message sent in response\n   (see Section 5.1.2.).
        \ Multiple attributes can be provided in\n   sequence in the response.  This
        is done to reduce the number of\n   roundtrips as much as possible (i.e.,
        in most cases, where the policy\n   is accepted the first time, one roundtrip
        is enough).  If the\n   Responder does not accept the offer, the Initiator
        must go out with a\n   new MIKEY message.\n   If the Responder is not willing/capable
        of providing security or the\n   parties simply cannot agree, it is up to
        the parties' policies how to\n   behave, for example, accepting or rejecting
        an insecure\n   communication.\n   Note that it is not the intention of this
        protocol to have a broad\n   variety of options, as it is assumed that a denied
        offer should\n   rarely occur.\n   In the one-to-many and many-to-many scenarios
        using multicast\n   communication, one issue is of course that there MUST
        be a common\n   security policy for all the receivers.  This limits the possibility\n
        \  of negotiation.\n"
      title: 5.1.1.  Capability Discovery
    - contents:
      - "5.1.2.  Error Handling\n   Due to the key management protocol, all errors
        SHOULD be reported to\n   the peer(s) by an error message.  The Initiator
        SHOULD therefore\n   always be prepared to receive such a message from the
        Responder.\n   If the Responder does not support the set of parameters suggested
        by\n   the Initiator, the error message SHOULD include the supported\n   parameters
        (see also Section 5.1.1).\n   The error message is formed as:\n   HDR, T,
        {ERR}, {SP}, [V|SIGNr]\n   Note that if failure is due to the inability to
        authenticate the\n   peer, the error message is OPTIONAL, and does not need
        to be\n   authenticated.  It is up to local policy to determine how to treat\n
        \  this kind of message.  However, if in response to a failed\n   authentication
        a signed error message is returned, this can be used\n   for DoS purposes
        (against the Responder).  Similarly, an\n   unauthenticated error message
        could be sent to the Initiator in order\n   to fool the Initiator into tearing
        down the CSB.  It is highly\n   RECOMMENDED that the local policy take this
        into consideration.\n   Therefore, in case of authentication failure, one
        recommendation\n   would be not to authenticate such an error message, and
        when\n   receiving an unauthenticated error message view it only as a\n   recommendation
        of what may have gone wrong.\n"
      title: 5.1.2.  Error Handling
    title: 5.1.  General
  - contents:
    - "5.2.  Creating a message\n   To create a MIKEY message, a Common Header payload
      is first created.\n   This payload is then followed, depending on the message
      type, by a\n   set of information payloads (e.g., DH-value payload, Signature\n
      \  payload, Security Policy payload).  The defined payloads and the\n   exact
      encoding of each payload are described in Section 6.\n    0 1 2 3 4 5 6 7 8
      9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  !  version      !  data type    ! next payload  !               !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
      \           +\n   ~                   Common Header...                            ~\n
      \  !                                                               !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! next payload  !   Payload 1 ...                               !\n   +-+-+-+-+-+-+-+-+
      \                                              +\n   ~                                                               ~\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   :                             :
      \                                :\n   :                             :                                 :\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   ! next
      payload  !   Payload x ...                               !\n   +-+-+-+-+-+-+-+-+
      \                                              +\n   ~                                                               ~\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   !                   MAC/Signature
      \                              ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Figure 5.1. MIKEY payload message example.  Note that the payloads\n   are
      byte aligned and not 32-bit aligned.\n   The process of generating a MIKEY message
      consists of the following\n   steps:\n   *  Create an initial MIKEY message
      starting with the Common Header\n      payload.\n   *  Concatenate necessary
      payloads of the MIKEY message (see the\n      exchange definitions for payloads
      that may be included, and the\n      recommended order).\n   *  As a last step
      (for messages that must be authenticated, this also\n      includes the verification
      message), create and concatenate the\n      MAC/signature payload without the
      MAC/signature field filled in\n      (if a Next payload field is included in
      this payload, it is set to\n      Last payload).\n   *  Calculate the MAC/signature
      over the entire MIKEY message, except\n      the MAC/Signature field, and add
      the MAC/signature in the field.\n      In the case of the verification message,
      the Identity_i ||\n      Identity_r || Timestamp MUST directly follow the MIKEY
      message in\n      the Verification MAC calculation.  Note that the added identities\n
      \     and timestamp are identical to those transported in the ID and T\n      payloads.\n
      \  In the public key case, the Key data transport payload is generated\n   by
      concatenating the IDi with the TGKs.  This is then encrypted and\n   placed
      in the data field.  The MAC is calculated over the entire Key\n   data transport
      payload except the MAC field.  Before calculating the\n   MAC, the Next payload
      field is set to zero.\n   Note that all messages from the Initiator MUST use
      a unique\n   timestamp.  The Responder does not create a new timestamp, but
      uses\n   the timestamp used by the Initiator.\n"
    title: 5.2.  Creating a message
  - contents:
    - "5.3.  Parsing a message\n   In general, parsing of a MIKEY message is done
      by extracting payload\n   by payload and checking that no errors occur.  The
      exact procedure is\n   implementation specific; however, for the Responder,
      it is\n   RECOMMENDED that the following procedure be followed:\n   *  Extract
      the Timestamp and check that it is within the allowable\n      clock skew (if
      not, discard the message).  Also check the replay\n      cache (Section 5.4)
      so that the message is not replayed (see\n      Section 5.4).  If the message
      is replayed, discard it.\n   *  Extract the ID and authentication algorithm
      (if not included,\n      assume the default).\n   *  Verify the MAC/signature.\n
      \  *  If the authentication is not successful, an Auth failure Error\n      message
      MAY be sent to the Initiator.  The message is then\n      discarded from further
      processing.  See also Section 5.1.2 for\n      treatment of errors.\n   *  If
      the authentication is successful, the message is processed and\n      also added
      to the replay cache; processing is implementation\n      specific.  Note also
      that only successfully authenticated messages\n      are stored in the replay
      cache.\n   *  If any unsupported parameters or errors occur during the\n      processing,
      these MAY be reported to the Initiator by sending an\n      error message.  The
      processing is then aborted.  The error message\n      can also include payloads
      to describe the supported parameters.\n   *  If the processing was successful
      and in case the Initiator\n      requested it, a verification/response message
      MAY be created and\n      sent to the Initiator.\n"
    title: 5.3.  Parsing a message
  - contents:
    - "5.4.  Replay handling and timestamp usage\n   MIKEY does not use a challenge-response
      mechanism for replay\n   handling; instead, timestamps are used.  This requires
      that the\n   clocks are synchronized.  The required synchronization is dependent\n
      \  on the number of messages that can be cached (note though, that the\n   replay
      cache only contains messages that have been successfully\n   authenticated).
      \ If we could assume an unlimited cache, the terminals\n   would not need to
      be synchronized at all (as the cache could then\n   contain all previous messages).
      \ However, if there are restrictions\n   on the size of the replay cache, the
      clocks will need to be\n   synchronized to some extent.  In short, one can in
      general say that\n   it is a tradeoff between the size of the replay cache and
      the\n   required synchronization.\n   Timestamp usage prevents replay attacks
      under the following\n   assumptions:\n   *  Each host has a clock which is at
      least \"loosely synchronized\"\n      with the clocks of the other hosts.\n
      \  *  If the clocks are to be synchronized over the network, a secure\n      network
      clock synchronization protocol SHOULD be used, e.g.,\n      [ISO3].\n   *  Each
      Responder utilizes a replay cache in order to remember the\n      successfully
      authenticated messages presented within an allowable\n      clock skew (which
      is set by the local policy).\n   *  Replayed and outdated messages, for example,
      messages that can be\n      found in the replay cache or which have an outdated
      timestamp are\n      discarded and not processed.\n   *  If the host loses track
      of the incoming requests (e.g., due to\n      overload), it rejects all incoming
      requests until the clock skew\n      interval has passed.\n   In a client-server
      scenario, servers may encounter a high workload,\n   especially if a replay
      cache is necessary.  However, servers that\n   assume the role of MIKEY Initiators
      will not need to manage any\n   significant replay cache as they will refuse
      all incoming messages\n   that are not a response to a message previously sent
      by the server.\n   In general, a client may not expect a very high load of incoming\n
      \  messages and may therefore allow the degree of looseness to be on the\n   order
      of several minutes to hours.  If a (D)DoS attack is launched\n   and the replay
      cache grows too large, MIKEY MAY dynamically decrease\n   the looseness so that
      the replay cache becomes manageable.  However,\n   note that such (D)DoS attacks
      can only be performed by peers that can\n   authenticate themselves.  Hence,
      such an attack is very easy to trace\n   and mitigate.\n   The maximum number
      of messages that a client will need to cache may\n   vary depending on the capacity
      of the client itself and the network.\n   The number of expected messages should
      be taken into account.\n   For example, assume that we can at most spend 6kB
      on a replay cache.\n   Assume further that we need to store 30 bytes for each
      incoming\n   authenticated message (the hash of the message is 20 bytes).  This\n
      \  implies that it is possible to cache approximately 204 messages.  If\n   the
      expected number of messages per minute can be estimated, the\n   clock skew
      can easily be calculated.  For example, in a SIP scenario\n   where the client
      is expected, in the most extreme case, to receive 10\n   calls per minute, the
      clock skew needed is then approximately 20\n   minutes.  In a not so extreme
      setting, where one could expect an\n   incoming call every 5th minute, this
      would result in a clock skew on\n   the order of 16.5 hours (approx 1000 minutes).\n
      \  Consider a very extreme case, where the maximum number of incoming\n   messages
      are assumed to be on the order of 120 messages per minute,\n   and a requirement
      that the clock skew is on the order of 10 minutes,\n   a 48kB replay cache would
      be required.\n   Hence, one can note that the required clock skew will depend
      largely\n   on the setting in which MIKEY is used.  One recommendation is to
      fix\n   a size for the replay cache, allowing the clock skew to be large (the\n
      \  initial clock skew can be set depending on the application in which\n   it
      is used).  As the replay cache grows, the clock skew is decreased\n   depending
      on the percentage of the used replay cache.  Note that this\n   is locally handled,
      which will not require interaction with the peer\n   (even though it may indirectly
      effect the peer).  However, exactly\n   how to implement such functionality
      is out of the scope of this\n   document and considered implementation specific.\n
      \  In case of a DoS attack, the client will most likely be able to\n   handle
      the replay cache.  A more likely (and serious) DoS attack is a\n   CPU DoS attack
      where the attacker sends messages to the peer, which\n   then needs to expend
      resources on verifying the MACs/signatures of\n   the incoming messages.\n"
    title: 5.4.  Replay handling and timestamp usage
  title: 5.  Behavior and message handling
- contents:
  - "6.  Payload Encoding\n   This section describes, in detail, all the payloads.
    \ For all\n   encoding, network byte order is always used.  While defining\n   supported
    types (e.g., which hash functions are supported) the\n   mandatory-to-implement
    types are indicated (as Mandatory), as well as\n   the default types (note, default
    also implies mandatory\n   implementation).  Support for the other types are implicitly
    assumed\n   to be optional.\n   In the following, note that the support for SRTP
    [SRTP] as a security\n   protocol is defined.  This will help us better understand
    the purpose\n   of the different payloads and fields.  Other security protocols
    MAY\n   be specified for use within MIKEY, see Section 10.\n   In the following,
    the sign ~ indicates variable length field.\n"
  - contents:
    - "6.1.  Common Header payload (HDR)\n   The Common Header payload MUST always
      be present as the first payload\n   in each message.  The Common Header includes
      a general description of\n   the exchange message.\n                        1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  !  version      !  data type    ! next payload  !V! PRF func    !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  !                         CSB ID                                !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! #CS           ! CS ID map type! CS ID map info                ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  version (8 bits): the version number of MIKEY.\n      version = 0x01 refers
      to MIKEY as defined in this document.\n   *  data type (8 bits): describes the
      type of message (e.g., public-\n      key transport message, verification message,
      error message).\n      Data type     | Value | Comment\n      --------------------------------------\n
      \     Pre-shared    |     0 | Initiator's pre-shared key message\n      PSK
      ver msg   |     1 | Verification message of a Pre-shared\n                    |
      \      | key message\n      Public key    |     2 | Initiator's public-key transport
      message\n      PK ver msg    |     3 | Verification message of a public-key\n
      \                   |       | message\n      D-H init      |     4 | Initiator's
      DH exchange message\n      D-H resp      |     5 | Responder's DH exchange message\n
      \     Error         |     6 | Error message\n      Table 6.1.a\n   *  next payload
      (8 bits): identifies the payload that is added after\n      this payload.\n
      \     Next payload  | Value | Section\n      ------------------------------\n
      \     Last payload  |     0 | -\n      KEMAC         |     1 | 6.2\n      PKE
      \          |     2 | 6.3\n      DH            |     3 | 6.4\n      SIGN          |
      \    4 | 6.5\n      T             |     5 | 6.6\n      ID            |     6
      | 6.7\n      CERT          |     7 | 6.7\n      CHASH         |     8 | 6.8\n
      \     V             |     9 | 6.9\n      SP            |    10 | 6.10\n      RAND
      \         |    11 | 6.11\n      ERR           |    12 | 6.12\n      Key data
      \     |    20 | 6.13\n      General Ext.  |    21 | 6.15\n      Table 6.1.b\n
      \     Note that some of the payloads cannot directly follow the header\n      (such
      as \"Last payload\", \"Signature\").  However, the Next payload\n      field
      is generic for all payloads.  Therefore, a value is\n      allocated for each
      payload.  The Next payload field is set to zero\n      (Last payload) if the
      current payload is the last payload.\n   *  V (1 bit): flag to indicate whether
      a verification message is\n      expected or not (this only has meaning when
      it is set by the\n      Initiator).  The V flag SHALL be ignored by the receiver
      in the DH\n      method (as the response is MANDATORY).\n      V = 0  ==> no
      response expected\n      V = 1  ==> response expected\n   *  PRF func (7 bits):
      indicates the PRF function that has been/will\n      be used for key derivation.\n
      \     PRF func      | Value | Comments\n      --------------------------------------------------------\n
      \     MIKEY-1       |     0 | Mandatory (see Section 4.1.2)\n      Table 6.1.c\n
      \  *  CSB ID (32 bits): identifies the CSB.  It is RECOMMENDED that the\n      CSB
      ID be chosen at random by the Initiator.  This ID MUST be\n      unique between
      each Initiator-Responder pair, i.e., not globally\n      unique.  An Initiator
      MUST check for collisions when choosing the\n      ID (if the Initiator already
      has one or more established CSBs with\n      the Responder).  The Responder
      uses the same CSB ID in the\n      response.\n   *  #CS (8 bits): indicates
      the number of Crypto Sessions that will be\n      handled within the CBS.  Note
      that even though it is possible to\n      use 255 CSs, it is not likely that
      a CSB will include this many\n      CSs.  The integer 0 is interpreted as no
      CS included.  This may be\n      the case in an initial setup message.\n   *
      \ CS ID map type (8 bits): specifies the method of uniquely mapping\n      Crypto
      Sessions to the security protocol sessions.\n      CS ID map type | Value\n
      \     -----------------------\n      SRTP-ID        |     0\n      Table 6.1.d\n
      \  *  CS ID map info (16 bits): identifies the crypto session(s) for\n      which
      the SA should be created.  The currently defined map type is\n      the SRTP-ID
      (defined in Section 6.1.1).\n"
    - contents:
      - "6.1.1.  SRTP ID\n                        1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Policy_no_1   ! SSRC_1                                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! SSRC_1 (cont) ! ROC_1                                         !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! ROC_1 (cont)  ! Policy_no_2   ! SSRC_2                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! SSRC_2 (cont)                 ! ROC_2                         !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! ROC_2 (cont)                  !                               :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        ...\n   :                               :                               :\n
        \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   !
        Policy_no_#CS !           SSRC_#CS                            !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  !SSRC_#CS (cont)!           ROC_#CS                             !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! ROC_#CS (cont)!\n   +-+-+-+-+-+-+-+-+\n   *  Policy_no_i (8 bits): The
        security policy applied for the stream\n      with SSRC_i.  The same security
        policy may apply for all CSs.\n   *  SSRC_i (32 bits): specifies the SSRC
        that MUST be used for the\n      i-th SRTP stream.  Note that it is the sender
        of the streams that\n      chooses the SSRC.  Therefore, it is possible that
        the Initiator of\n      MIKEY cannot fill in all fields.  In this case, SSRCs
        that are not\n      chosen by the Initiator are set to zero and the Responder
        fills in\n      these fields in the response message.  Note that SRTP specifies\n
        \     requirements on the uniqueness of the SSRCs (to avoid two-time pad\n
        \     problems if the same TEK is used for more than one stream) [SRTP].\n
        \  *  ROC_i (32 bits): Current rollover counter used in SRTP.  If the\n      SRTP
        session has not started, this field is set to 0.  This field\n      is used
        to enable a member to join and synchronize with an already\n      started
        stream.\n   NOTE: The stream using SSRC_i will also have Crypto Session ID
        equal\n   to no i (NOT to the SSRC).\n"
      title: 6.1.1.  SRTP ID
    title: 6.1.  Common Header payload (HDR)
  - contents:
    - "6.2.  Key data transport payload (KEMAC)\n   The Key data transport payload
      contains encrypted Key data sub-\n   payloads (see Section 6.13 for the definition
      of the Key data sub-\n   payload).  It may contain one or more Key data payloads,
      each\n   including, for example, a TGK.  The last Key data payload has its\n
      \  Next payload field set to Last payload.  For an update message (see\n   also
      Section 4.5), it is allowed to skip the Key data sub-payloads\n   (which will
      result in the Encr data len being equal to 0).\n   Note that the MAC coverage
      depends on the method used, i.e., pre-\n   shared vs public key, see below.\n
      \  If the transport method used is the pre-shared key method, this Key\n   data
      transport payload is the last payload in the message (note that\n   the Next
      payload field is set to Last payload).  The MAC is then\n   calculated over
      the entire MIKEY message following the directives in\n   Section 5.2.\n   If
      the transport method used is the public-key method, the\n   Initiator's identity
      is added in the encrypted data.  This is done by\n   adding the ID payload as
      the first payload, which is then followed by\n   the Key data sub-payloads.
      \ Note that for an update message, the ID\n   is still sent encrypted to the
      Responder (this is to avoid certain\n   re-direction attacks) even though no
      Key data sub-payload is added\n   after.\n   In the public-key case, the coverage
      of the MAC field is over the Key\n   data transport payload only, instead of
      the complete MIKEY message,\n   as in the pre-shared case.  The MAC is therefore
      calculated over the\n   Key data transport payload, except for the MAC field
      and where the\n   Next payload field has been set to zero (see also Section
      5.2).\n                        1                   2                   3\n    0
      1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! Next payload  ! Encr alg      ! Encr data len                 !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  !                        Encr data                              ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! Mac alg       !        MAC                                    ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  Next payload (8 bits): identifies the payload that is added after\n      this
      payload.  See Section 6.1 for defined values.\n   *  Encr alg (8 bits): the
      encryption algorithm used to encrypt the\n      Encr data field.\n      Encr
      alg      | Value | Comment\n      -------------------------------------------\n
      \     NULL          |     0 | Very restricted usage, see Section 4.2.3!\n      AES-CM-128
      \   |     1 | Mandatory; AES-CM using a 128-bit key, see\n                               Section
      4.2.3)\n      AES-KW-128    |     2 | AES Key Wrap using a 128-bit key, see\n
      \                              Section 4.2.3\n      Table 6.2.a\n   *  Encr
      data len (16 bits): length of Encr data (in bytes).\n   *  Encr data (variable
      length): the encrypted key sub-payloads (see\n      Section 6.13).\n   *  MAC
      alg (8 bits): specifies the authentication algorithm used.\n      MAC alg        |
      Value | Comments          | Length (bits)\n      ----------------------------------------------------------\n
      \     NULL           |     0 | restricted usage  | 0\n                     |
      \      | Section 4.2.4     |\n      HMAC-SHA-1-160 |     1 | Mandatory,        |
      160\n                     |       | Section 4.2.4     |\n      Table 6.2.b\n
      \  *  MAC (variable length): the message authentication code of the\n      entire
      message.\n"
    title: 6.2.  Key data transport payload (KEMAC)
  - contents:
    - "6.3.  Envelope data payload (PKE)\n   The Envelope data payload contains the
      encrypted envelope key that is\n   used in the public-key transport to protect
      the data in the Key data\n   transport payload.  The encryption algorithm used
      is implicit from\n   the certificate/public key used.\n                        1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! Next Payload  ! C ! Data len                  ! Data          ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  Next payload (8 bits): identifies the payload that is added after\n      this
      payload.  See Section 6.1 for values.\n   *  C (2 bits): envelope key cache
      indicator (Section 3.2).\n      Cache type    | Value | Comments\n      --------------------------------------\n
      \     No cache      |     0 | The envelope key MUST NOT be cached\n      Cache
      \        |     1 | The envelope key MUST be cached\n      Cache for CSB |     2
      | The envelope key MUST be cached, but only\n                    |       | to
      be used for the specific CSB.\n      Table 6.3\n   *  Data len (14 bits): the
      length of the data field (in bytes).\n   *  Data (variable length): the encrypted
      envelope key.\n"
    title: 6.3.  Envelope data payload (PKE)
  - contents:
    - "6.4.  DH data payload (DH)\n   The DH data payload carries the DH-value and
      indicates the DH-group\n   used.  Notice that in this sub-section, \"MANDATORY\"
      is conditioned\n   upon DH being supported.\n                        1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  !  Next Payload ! DH-Group      !  DH-value                     ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! Reserv! KV    ! KV data (optional)                            ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  Next payload (8 bits): identifies the payload that is added after\n      this
      payload.  See Section 6.1 for values.\n   *  DH-Group (8 bits): identifies the
      DH group used.\n      DH-Group      | Value | Comment       | DH Value length
      (bits)\n      --------------------------------------|---------------------\n
      \     OAKLEY 5      |     0 | Mandatory     |  1536\n      OAKLEY 1      |     1
      |               |   768\n      OAKLEY 2      |     2 |               |  1024\n
      \     Table 6.4\n   *  DH-value (variable length): the public DH-value (the
      length is\n      implicit from the group used).\n   *  KV (4 bits): indicates
      the type of key validity period specified.\n      This may be done by using
      an SPI (alternatively an MKI in SRTP) or\n      by providing an interval in
      which the key is valid (e.g., in the\n      latter case, for SRTP this will
      be the index range where the key\n      is valid).  See Section 6.13 for pre-defined
      values.\n   *  KV data (variable length): This includes either the SPI/MKI or
      an\n      interval (see Section 6.14).  If KV is NULL, this field is not\n      included.\n"
    title: 6.4.  DH data payload (DH)
  - contents:
    - "6.5.  Signature payload (SIGN)\n   The Signature payload carries the signature
      and its related data.\n   The signature payload is always the last payload in
      the PK transport\n   and DH exchange messages.  The signature algorithm used
      is implicit\n   from the certificate/public key used.\n                        1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! S type| Signature len         ! Signature                     ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  S type (4 bits): indicates the signature algorithm applied by the\n      signer.\n
      \     S type        | Value | Comments\n      -------------------------------------\n
      \     RSA/PKCS#1/1.5|     0 | Mandatory, PKCS #1 version 1.5 signature\n                               [PSS]\n
      \     RSA/PSS       |     1 | RSASSA-PSS signature [PSS]\n      Table 6.5\n
      \  *  Signature len (12 bits): the length of the signature field (in\n      bytes).\n
      \  *  Signature (variable length): the signature (its formatting and\n      padding
      depend on the type of signature).\n"
    title: 6.5.  Signature payload (SIGN)
  - contents:
    - "6.6.  Timestamp payload (T)\n   The timestamp payload carries the timestamp
      information.\n                        1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! Next Payload  !   TS type     ! TS value                      ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  Next payload (8 bits): identifies the payload that is added after\n      this
      payload.  See Section 6.1 for values.\n   *  TS type (8 bits): specifies the
      timestamp type used.\n      TS type       | Value | Comments     | length of
      TS value\n      -------------------------------------|-------------------\n
      \     NTP-UTC       |     0 | Mandatory    |   64-bits\n      NTP           |
      \    1 | Mandatory    |   64-bits\n      COUNTER       |     2 | Optional     |
      \  32-bits\n      Table 6.6\n      Note: COUNTER SHALL be padded (with leading
      zeros) to a 64-bit\n      value when used as input for the default PRF.\n   *
      \ TS-value (variable length): The timestamp value of the specified\n      TS
      type.\n"
    title: 6.6.  Timestamp payload (T)
  - contents:
    - "6.7.  ID payload (ID) / Certificate Payload (CERT)\n   Note that the ID payload
      and the Certificate payload are two\n   completely different payloads (having
      different payload identifiers).\n   However, as they share the same payload
      structure, they are described\n   in the same section.\n   The ID payload carries
      a uniquely defined identifier.\n   The certificate payload contains an indicator
      of the certificate\n   provided as well as the certificate data.  If a certificate
      chain is\n   to be provided, each certificate in the chain should be included
      in a\n   separate CERT payload.\n                        1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  !  Next Payload ! ID/Cert Type  ! ID/Cert len                   !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  !                       ID/Certificate Data                     ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  Next payload (8 bits): identifies the payload that is added after\n      this
      payload.  See Section 6.1 for values.\n   If the payload is an ID payload, the
      following values apply for the\n   ID type field:\n   *  ID Type (8 bits): specifies
      the identifier type used.\n      ID Type       | Value | Comments\n      ----------------------------------------------\n
      \     NAI           |     0 | Mandatory (see [NAI])\n      URI           |     1
      | Mandatory (see [URI])\n      Table 6.7.a\n   If the payload is a Certificate
      payload, the following values applies\n   for the Cert type field:\n   *  Cert
      Type (8 bits): specifies the certificate type used.\n     Cert Type     | Value
      | Comments\n     ----------------------------------------------\n     X.509v3
      \      |     0 | Mandatory\n     X.509v3 URL   |     1 | plain ASCII URL to
      the location of the Cert\n     X.509v3 Sign  |     2 | Mandatory (used for signatures
      only)\n     X.509v3 Encr  |     3 | Mandatory (used for encryption only)\n     Table
      6.7.b\n   *  ID/Cert len (16 bits): the length of the ID or Certificate field\n
      \     (in bytes).\n   *  ID/Certificate (variable length): The ID or Certificate
      data.  The\n      X.509 [X.509] certificates are included as a bytes string
      using\n      DER encoding as specified in X.509.\n"
    title: 6.7.  ID payload (ID) / Certificate Payload (CERT)
  - contents:
    - "6.8.  Cert hash payload (CHASH)\n   The Cert hash payload contains the hash
      of the certificate used.\n                        1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! Next Payload  ! Hash func     ! Hash                          ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  Next payload (8 bits): identifies the payload that is added after\n      this
      payload.  See Section 6.1 for values.\n   *  Hash func (8 bits): indicates the
      hash function that is used (see\n      also Section 4.2.1).\n      Hash func
      \    | Value | Comment     | hash length (bits)\n      -------------------------------------------------\n
      \     SHA-1         |     0 | Mandatory   |  160\n      MD5           |     1
      |             |  128\n      Table 6.8\n   *  Hash (variable length): the hash
      data.  The hash length is\n      implicit from the hash function used.\n"
    title: 6.8.  Cert hash payload (CHASH)
  - contents:
    - "6.9.  Ver msg payload (V)\n   The Ver msg payload contains the calculated verification
      message in\n   the pre-shared key and the public-key transport methods.  Note
      that\n   the MAC is calculated over the entire MIKEY message, as well as the\n
      \  IDs and Timestamp (see also Section 5.2).\n                        1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! Next Payload  ! Auth alg      ! Ver data                      ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  Next payload (8 bits): identifies the payload that is added after\n      this
      payload.  See Section 6.1 for values.\n   *  Auth alg (8 bits): specifies the
      MAC algorithm used for the\n      verification message.  See Section 6.2 for
      defined values.\n   *  Ver data (variable length): the verification message
      data.  The\n      length is implicit from the authentication algorithm used.\n"
    title: 6.9.  Ver msg payload (V)
  - contents:
    - "6.10.  Security Policy payload (SP)\n   The Security Policy payload defines
      a set of policies that apply to a\n   specific security protocol.\n                        1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! Next payload  ! Policy no     ! Prot type     ! Policy param  ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ~ length (cont) ! Policy param                                  ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  Next payload (8 bits): identifies the payload that is added after\n      this
      payload.  See Section 6.1 for values.\n   *  Policy no (8 bits): each security
      policy payload must be given a\n      distinct number for the current MIKEY
      session by the local peer.\n      This number is used to map a crypto session
      to a specific policy\n      (see also Section 6.1.1).\n   *  Prot type (8 bits):
      defines the security protocol.\n      Prot type     | Value |\n      ---------------------------\n
      \     SRTP          |     0 |\n      Table 6.10\n   *  Policy param length (16
      bits): defines the total length of the\n      policy parameters for the specific
      security protocol.\n   *  Policy param (variable length): defines the policy
      for the\n      specific security protocol.\n      The Policy param part is built
      up by a set of Type/Length/Value\n      fields.  For each security protocol,
      a set of possible\n      types/values that can be negotiated is defined.\n                           1
      \                  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     ! Type          ! Length        ! Value                         ~\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  Type (8 bits): specifies the type of the parameter.\n   *  Length (8 bits):
      specifies the length of the Value field (in\n      bytes).\n   *  Value (variable
      length): specifies the value of the parameter.\n"
    - contents:
      - "6.10.1.  SRTP policy\n   This policy specifies the parameters for SRTP and
        SRTCP.  The\n   types/values that can be negotiated are defined by the following\n
        \  table:\n   Type | Meaning                     | Possible values\n   ----------------------------------------------------\n
        \     0 | Encryption algorithm        | see below\n      1 | Session Encr.
        key length    | depends on cipher used\n      2 | Authentication algorithm
        \   | see below\n      3 | Session Auth. key length    | depends on MAC used\n
        \     4 | Session Salt key length     | see [SRTP] for recommendations\n      5
        | SRTP Pseudo Random Function | see below\n      6 | Key derivation rate         |
        see [SRTP] for recommendations\n      7 | SRTP encryption off/on      | 0
        if off, 1 if on\n      8 | SRTCP encryption off/on     | 0 if off, 1 if on\n
        \     9 | sender's FEC order          | see below\n     10 | SRTP authentication
        off/on  | 0 if off, 1 if on\n     11 | Authentication tag length   | in bytes\n
        \    12 | SRTP prefix length          | in bytes\n   Table 6.10.1.a\n   Note
        that if a Type/Value is not set, the default is used (according\n   to SRTP's
        own criteria). Note also that, if \"Session Encr. key\n   length\" is set,
        this should also be seen as the Master key length\n   (otherwise, the SRTP
        default Master key length is used).\n   For the Encryption algorithm, a one
        byte length is enough.  The\n   currently defined possible Values are:\n     SRTP
        encr alg | Value\n     ---------------------\n     NULL          |     0\n
        \    AES-CM        |     1\n     AES-F8        |     2\n     Table 6.10.1.b\n
        \  where AES-CM is AES in CM, and AES-F8 is AES in f8 mode [SRTP].\n   For
        the Authentication algorithm, a one byte length is enough.  The\n   currently
        defined possible Values are:\n     SRTP auth alg | Value\n     ---------------------\n
        \    NULL          |     0\n     HMAC-SHA-1    |     1\n     Table 6.10.1.c\n
        \  For the SRTP pseudo-random function, a one byte length is also\n   enough.
        The currently defined possible Values are:\n     SRTP PRF      | Value\n     ---------------------\n
        \    AES-CM        |     0\n     Table 6.10.1.d\n   If FEC is used at the
        same time SRTP is used, MIKEY can negotiate the\n   order in which these should
        be applied at the sender side.\n      FEC order     | Value | Comments\n      --------------------------------\n
        \     FEC-SRTP      |     0 | First FEC, then SRTP\n      Table 6.10.1.e\n"
      title: 6.10.1.  SRTP policy
    title: 6.10.  Security Policy payload (SP)
  - contents:
    - "6.11.  RAND payload (RAND)\n   The RAND payload consists of a (pseudo-)random
      bit-string.  The RAND\n   MUST be independently generated per CSB (note that
      if the CSB has\n   several members, the Initiator MUST use the same RAND for
      all the\n   members).  For randomness recommendations for security, see [RAND].\n
      \                       1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! Next payload  ! RAND len      ! RAND                          ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  Next payload (8 bits): identifies the payload that is added after\n      this
      payload.  See Section 6.1 for values.\n   *  RAND len (8 bits): length of the
      RAND (in bytes).  It SHOULD be at\n      least 16.\n   *  RAND (variable length):
      a (pseudo-)randomly chosen bit-string.\n"
    title: 6.11.  RAND payload (RAND)
  - contents:
    - "6.12.  Error payload (ERR)\n   The Error payload is used to specify the error(s)
      that may have\n   occurred.\n                        1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  !  Next Payload ! Error no      !           Reserved            !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  Next payload (8 bits): identifies the payload that is added after\n      this
      payload.  See Section 6.1 for values.\n   *  Error no (8 bits): indicates the
      type of error that was\n      encountered.\n      Error no          | Value
      | Comment\n      -------------------------------------------------------\n      Auth
      failure      |     0 | Authentication failure\n      Invalid TS        |     1
      | Invalid timestamp\n      Invalid PRF       |     2 | PRF function not supported\n
      \     Invalid MAC       |     3 | MAC algorithm not supported\n      Invalid
      EA        |     4 | Encryption algorithm not supported\n      Invalid HA        |
      \    5 | Hash function not supported\n      Invalid DH        |     6 | DH group
      not supported\n      Invalid ID        |     7 | ID not supported\n      Invalid
      Cert      |     8 | Certificate not supported\n      Invalid SP        |     9
      | SP type not supported\n      Invalid SPpar     |    10 | SP parameters not
      supported\n      Invalid DT        |    11 | not supported Data type\n      Unspecified
      error |    12 | an unspecified error occurred\n      Table 6.12\n"
    title: 6.12.  Error payload (ERR)
  - contents:
    - "6.13.  Key data sub-payload\n   The Key data payload contains key material,
      e.g., TGKs.  The Key data\n   payloads are never included in clear, but as an
      encrypted part of the\n   Key data transport payload.\n   Note that a Key data
      transport payload can contain multiple Key data\n   sub-payloads.\n                        1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  !  Next Payload ! Type  ! KV    ! Key data len                  !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  !                         Key data                              ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! Salt len (optional)           ! Salt data (optional)          ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  !                        KV data (optional)                     ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  Next payload (8 bits): identifies the payload that is added after\n      this
      payload.  See Section 6.1 for values.\n   *  Type (4 bits): indicates the type
      of key included in the payload.\n      Type     | Value\n      -----------------\n
      \     TGK      |     0\n      TGK+SALT |     1\n      TEK      |     2\n      TEK+SALT
      |     3\n      Table 6.13.a\n      Note that the possibility of including a
      TEK (instead of using the\n      TGK) is provided.  When sent directly, the
      TEK can generally not\n      be shared between more than one Crypto Session
      (unless the\n      Security protocol allows for this, e.g., [SRTP]).  The recommended\n
      \     use of sending a TEK, instead of a TGK, is when pre-encrypted\n      material
      exists and therefore, the TEK must be known in advance.\n   *  KV (4 bits):
      indicates the type of key validity period specified.\n      This may be done
      by using an SPI (or MKI in the case of [SRTP]) or\n      by providing an interval
      in which the key is valid (e.g., in the\n      latter case, for SRTP this will
      be the index range where the key\n      is valid).\n      KV            | Value
      | Comments\n      -------------------------------------------\n      Null          |
      \    0 | No specific usage rule (e.g., a TEK\n                    |       |
      that has no specific lifetime)\n      SPI           |     1 | The key is associated
      with the SPI/MKI\n      Interval      |     2 | The key has a start and expiration
      time\n                    |       | (e.g., an SRTP TEK)\n      Table 6.13.b\n
      \     Note that when NULL is specified, any SPI or Interval is valid.\n      For
      an Interval, this means that the key is valid from the first\n      observed
      sequence number until the key is replaced (or the\n      security protocol is
      shutdown).\n   *  Key data len (16 bits): the length of the Key data field (in\n
      \     bytes).  Note that the sum of the overall length of all the Key\n      data
      payloads contained in a single Key data transport payload\n      (KEMAC) MUST
      be such that the KEMAC payload does not exceed a\n      length of 2^16 bytes
      (total length of KEMAC, see Section 6.2).\n   *  Key data (variable length):
      The TGK or TEK data.\n   *  Salt len (16 bits): The salt key length in bytes.
      \ Note that this\n      field is only included if the salt is specified in the
      Type-field.\n   *  Salt data (variable length): The salt key data.  Note that
      this\n      field is only included if the salt is specified in the Type-field.\n
      \     (For SRTP, this is the so-called master salt.)\n   *  KV data (variable
      length): This includes either the SPI or an\n      interval (see Section 6.14).
      \ If KV is NULL, this field is not\n      included.\n"
    title: 6.13.  Key data sub-payload
  - contents:
    - "6.14.  Key validity data\n   The Key validity data is not a standalone payload,
      but part of either\n   the Key data payload (see Section 6.13) or the DH payload
      (see\n   Section 6.4).  The Key validity data gives a guideline of when the\n
      \  key should be used.  There are two KV types defined (see Section\n   6.13),
      SPI/MKI (SPI) or a lifetime range (interval).\n   SPI/MKI\n                        1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! SPI Length    ! SPI                                           ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  SPI Length (8 bits): the length of the SPI (or MKI) in bytes.\n   *  SPI
      (variable length): the SPI (or MKI) value.\n   Interval\n                        1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! VF Length     ! Valid From                                    ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! VT Length     ! Valid To (expires)                            ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  VF Length (8 bits): length of the Valid From field in bytes.\n   *  Valid
      From (variable length): sequence number, index, timestamp,\n      or other start
      value that the security protocol uses to identify\n      the start position
      of the key usage.\n   *  VT Length (8 bits): length of the Valid To field in
      bytes.\n   *  Valid To (variable length): sequence number, index, timestamp,
      or\n      other expiration value that the security protocol can use to\n      identify
      the expiration of the key usage.\n      Note that for SRTP usage, the key validity
      period for a TGK/TEK\n      should be specified with either an interval, where
      the VF/VT\n      Length is equal to 6 bytes (i.e., the size of the index), or
      with\n      an MKI.  It is RECOMMENDED that if more than one SRTP stream is\n
      \     sharing the same keys and key update/re-keying is desired, this is\n      handled
      using MKI rather than the From-To method.\n"
    title: 6.14.  Key validity data
  - contents:
    - "6.15.  General Extension Payload\n   The General extensions payload is included
      to allow possible\n   extensions to MIKEY without the need for defining a completely
      new\n   payload each time.  This payload can be used in any MIKEY message and\n
      \  is part of the authenticated/signed data part.\n                        1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! Next payload  ! Type          ! Length                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  ! Data                                                          ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  *  Next payload (8 bits): identifies the payload that is added after\n      this
      payload.\n   *  Type (8 bits): identifies the type of general payload.\n      Type
      \     | Value | Comments\n      ---------------------------------------\n      Vendor
      ID |     0 | Vendor specific byte string\n      SDP IDs   |     1 | List of
      SDP key mgmt IDs (allocated for use in\n                           [KMASDP])\n
      \     Table 6.15\n   *  Length (16 bits): the length in bytes of the Data field.\n
      \  *  Data (variable length): the general payload data.\n"
    title: 6.15.  General Extension Payload
  title: 6.  Payload Encoding
- contents:
  - "7.  Transport protocols\n   MIKEY MAY be integrated within session establishment
    protocols.\n   Currently, integration of MIKEY within SIP/SDP and RTSP is defined
    in\n   [KMASDP].  MIKEY MAY use other transports, in which case how MIKEY is\n
    \  transported over such a transport protocol has to be defined.\n"
  title: 7.  Transport protocols
- contents:
  - "8.  Groups\n   What has been discussed up to now is not limited to single peer-to-\n
    \  peer communication (except for the DH method), but can be used to\n   distribute
    group keys for small-size interactive groups and simple\n   one-to-many scenarios.
    \ Section 2.1. describes the scenarios in the\n   focus of MIKEY.  This section
    describes how MIKEY is used in a group\n   scenario (though, see also Section
    4.3 for issues related to\n   authorization).\n"
  - contents:
    - "8.1.  Simple one-to-many\n                            ++++\n                            |S
      |\n                            |  |\n                            ++++\n                              |\n
      \                     --------+-------------- - -\n                      |       |
      \     |\n                      v       v      v\n                    ++++    ++++
      \  ++++\n                    |A |    |B |   |C |\n                    |  |    |
      \ |   |  |\n                    ++++    ++++   ++++\n   Figure 8.1. Simple one-to-many
      scenario.\n   In the simple one-to-many scenario, a server is streaming to a
      small\n   group of clients.  RTSP or SIP is used for the registration and the\n
      \  key management set up.  The streaming server acts as the Initiator of\n   MIKEY.
      \ In this scenario, the pre-shared key or public key transport\n   mechanism
      will be appropriate in transporting the same TGK to all the\n   clients (which
      will result in common TEKs for the group).\n   Note, if the same TGK/TEK(s)
      should be used by all the group members,\n   the streaming server MUST specify
      the same CSB_ID and CS_ID(s) for\n   the session to all the group members.\n
      \  As the communication may be performed using multicast, the members\n   need
      a common security policy if they want to be part of the group.\n   This limits
      the possibility of negotiation.\n   Furthermore, the Initiator should carefully
      consider whether to\n   request the verification message in reply from each
      receiver, as this\n   may result in a certain load for the Initiator itself
      as the group\n   size increases.\n"
    title: 8.1.  Simple one-to-many
  - contents:
    - "8.2.  Small-size interactive group\n   As described in the overview section,
      for small-size interactive\n   groups, one may expect that each client will
      be in charge for setting\n   up the security for its outgoing streams.  In these
      scenarios, the\n   pre-shared key or the public-key transport method is used.\n
      \                      ++++          ++++\n                       |A | ------->
      |B |\n                       |  | <------- |  |\n                       ++++
      \         ++++\n                        ^ |          | ^\n                        |
      |          | |\n                        | |   ++++   | |\n                        |
      --->|C |<--- |\n                        ------|  |------\n                              ++++\n
      \  Figure 8.2. Small-size group without a centralized controller.\n   One scenario
      may then be that the client sets up a three-part call,\n   using SIP.  Due to
      the small size of the group, unicast SRTP is used\n   between the clients.  Each
      client sets up the security for its\n   outgoing stream(s) to the others.\n
      \  As for the simple one-to-many case, the streaming client specifies\n   the
      same CSB_ID and CS_ID(s) for its outgoing sessions if the same\n   TGK/TEK(s)
      is used for all the group members.\n"
    title: 8.2.  Small-size interactive group
  title: 8.  Groups
- contents:
  - '9.  Security Considerations

    '
  - contents:
    - "9.1.  General\n   Key management protocols based on timestamps/counters and
      one-\n   roundtrip key transport have previously been standardized, for\n   example
      ISO [ISO1, ISO2].  The general security of these types of\n   protocols can
      be found in various articles and literature, c.f. [HAC,\n   AKE, LOA].\n   No
      chain is stronger than its weakest link.  If a given level of\n   protection
      is wanted, then the cryptographic functions protecting the\n   keys during transport/exchange
      MUST offer a security corresponding to\n   at least that level.\n   For instance,
      if a security against attacks with a complexity 2^96 is\n   wanted, then one
      should choose a secure symmetric cipher supporting\n   at least 96 bit keys
      (128 bits may be a practical choice) for the\n   actual media protection, and
      a key transport mechanism that provides\n   equivalent protection, e.g., MIKEY's
      pre-shared key transport with\n   128 bit TGK, or RSA with 1024 bit keys (which
      according to [LV]\n   corresponds to the desired 96 bit level, with some margin).\n
      \  In summary, key size for the key-exchange mechanism MUST be weighed\n   against
      the size of the exchanged TGK so that it at least offers the\n   required level.
      \ For efficiency reasons, one SHOULD also avoid a\n   security overkill, e.g.,
      by not using a public key transport with\n   public keys giving a security level
      that is orders of magnitude\n   higher than length of the transported TGK.  We
      refer to [LV] for\n   concrete key size recommendations.\n   Moreover, if the
      TGKs are not random (or pseudo-random), a brute\n   force search may be facilitated,
      again lowering the effective key\n   size.  Therefore, care MUST be taken when
      designing the (pseudo-)\n   random generators for TGK generation, see [FIPS][RAND].\n
      \  For the selection of the hash function, SHA-1 with 160-bit output is\n   the
      default one.  In general, hash sizes should be twice the\n   \"security level\",
      indicating that SHA-1-256, [SHA256], should be used\n   for the default 128-bit
      level.  However, due to the real-time aspects\n   in the scenarios we are treating,
      hash sizes slightly below 256 are\n   acceptable, as the normal \"existential\"
      collision probabilities would\n   be of secondary importance.\n   In a Crypto
      Session Bundle, the Crypto Sessions can share the same\n   TGK as discussed
      earlier.  From a security point of view, to satisfy\n   the criterion in case
      the TGK is shared, the encryption of the\n   individual Crypto Sessions are
      performed \"independently\".  In MIKEY,\n   this is accomplished by having unique
      Crypto Session identifiers (see\n   also Section 4.1) and a TEK derivation method
      that provides\n   cryptographically independent TEKs to distinct Crypto Sessions\n
      \  (within the Crypto Session Bundle), regardless of the security\n   protocol
      used.\n   Specifically, the key derivations, as specified in Section 4.1, are\n
      \  implemented by a pseudo-random function.  The one used here is a\n   simplified
      version of that used in TLS [TLS].  Here, only one single\n   hash function
      is used, whereas TLS uses two different functions.\n   This choice is motivated
      by the high confidence in the SHA-1 hash\n   function, and by efficiency and
      simplicity of design (complexity does\n   not imply security).  Indeed, as shown
      in [DBJ], if one of the two\n   hashes is severely broken, the TLS PRF is actually
      less secure than\n   as if a single hash had been used on the whole key, as
      is done in\n   MIKEY.\n   In the pre-shared key and public-key schemes, the
      TGK is generated by\n   a single party (Initiator).  This makes MIKEY somewhat
      more sensitive\n   if the Initiator uses a bad random number generator.  It
      should also\n   be noted that neither the pre-shared nor the public-key scheme\n
      \  provides perfect forward secrecy.  If mutual contribution or perfect\n   forward
      secrecy is desired, the Diffie-Hellman method is to be used.\n   Authentication
      (e.g., signatures) in the Diffie-Hellman method is\n   required to prevent man-in-the-middle
      attacks.\n   Forward/backward security: if the TGK is exposed, all generated
      TEKs\n   are compromised.  However, under the assumption that the derivation\n
      \  function is a pseudo-random function, disclosure of an individual TEK\n   does
      not compromise other (previous or later) TEKs derived from the\n   same TGK.
      \ The Diffie-Hellman mode can be considered by cautious\n   users, as it is
      the only one that supports so called perfect forward\n   secrecy (PFS).  This
      is in contrast to a compromise of the pre-shared\n   key (or the secret key
      of the public key mode), where future sessions\n   and recorded sessions from
      the past are then also compromised.\n   The use of random nonces (RANDs) in
      the key derivation is of utmost\n   importance to counter off-line pre-computation
      attacks.  Note however\n   that update messages re-use the old RAND.  This means
      that the total\n   effective key entropy (relative to pre-computation attacks)
      for k\n   consecutive key updates, assuming the TGKs and RAND are each n bits\n
      \  long, is about L = n*(k+1)/2 bits, compared to the theoretical\n   maximum
      of n*k bits.  In other words, a 2^L work effort MAY enable an\n   attacker to
      get all k n-bit keys, which is better than brute force\n   (except when k =
      1).  While this might seem like a defect, first note\n   that for a proper choice
      of n, the 2^L complexity of the attack is\n   way out of reach.  Moreover, the
      fact that more than one key can be\n   compromised in a single attack is inherent
      to the key exchange\n   problem.  Consider for instance a user who, using a
      fixed 1024-bit\n   RSA key, exchanges keys and communicates during a one or
      two year\n   lifetime of the public key.  Breaking this single RSA key will
      enable\n   access to all exchanged keys and consequently the entire\n   communication
      of that user over the whole period.\n   All the pre-defined transforms in MIKEY
      use state-of-the-art\n   algorithms that have undergone large amounts of public
      evaluation.\n   One of the reasons for using the AES-CM from SRTP [SRTP], is
      to have\n   the possibility of limiting the overall number of different\n   encryption
      modes and algorithms, while offering a high level of\n   security at the same
      time.\n"
    title: 9.1.  General
  - contents:
    - "9.2.  Key lifetime\n   Even if the lifetime of a TGK (or TEK) is not specified,
      it MUST be\n   taken into account that the encryption transform in the underlying\n
      \  security protocol can in some way degenerate after a certain amount\n   of
      encrypted data.  It is not possible to here state universally\n   applicable,
      general key lifetime bounds; each security protocol\n   should define such maximum
      amount and trigger a re-keying procedure\n   before the \"exhaustion\" of the
      key.  For example, according to SRTP\n   [SRTP] the TEK, together with the corresponding
      TGK, MUST be changed\n   at least every 2^48 SRTP packet.\n   Still, the following
      can be said as a rule of thumb.  If the security\n   protocol uses an \"ideal\"
      b-bit block cipher (in CBC mode, counter\n   mode, or a feedback mode, e.g.,
      OFB, with full b-bit feedback),\n   degenerate behavior in the crypto stream,
      possibly useful for an\n   attacker, is (with constant probability) expected
      to occur after a\n   total of roughly 2^(b/2) encrypted b-bit blocks (using
      random IVs).\n   For security margin, re-keying MUST be triggered well in advance\n
      \  compared to the above bound.  See [BDJR] for more details.\n   For use of
      a dedicated stream cipher, we refer to the analysis and\n   documentation of
      said cipher in each specific case.\n"
    title: 9.2.  Key lifetime
  - contents:
    - "9.3.  Timestamps\n   The use of timestamps, instead of challenge-responses,
      requires the\n   systems to have synchronized clocks.  Of course, if two clients
      are\n   not synchronized, they will have difficulties in setting up the\n   security.
      \ The current timestamp based solution has been selected to\n   allow a maximum
      of one roundtrip (i.e., two messages), but still\n   provide a reasonable replay
      protection.  A (secure) challenge-\n   response based version would require
      at least three messages.  For a\n   detailed description of the timestamp and
      replay handling in MIKEY,\n   see Section 5.4.\n   Practical experiences of
      Kerberos and other timestamp-based systems\n   indicate that it is not always
      necessary to synchronize the terminals\n   over the network.  Manual configuration
      could be a feasible\n   alternative in many cases (especially in scenarios where
      the degree\n   of looseness is high).  However, the choice must be made carefully\n
      \  with respect to the usage scenario.\n"
    title: 9.3.  Timestamps
  - contents:
    - "9.4.  Identity Protection\n   User privacy is a complex matter that to some
      extent can be enforced\n   by cryptographic mechanisms, but also requires policy
      enforcement and\n   various other functionalities.  One particular facet of
      privacy is\n   user identity protection.  However, identity protection was not
      a\n   main design goal for MIKEY.  Such a feature will add more complexity\n
      \  to the protocol and was therefore not chosen to be included.  As\n   MIKEY
      is anyway proposed to be transported over, e.g., SIP, the\n   identity may be
      exposed by this.  However, if the transporting\n   protocol is secured and also
      provides identity protection, MIKEY\n   might inherit the same feature.  How
      this should be done is for\n   future study.\n"
    title: 9.4.  Identity Protection
  - contents:
    - "9.5.  Denial of Service\n   This protocol is resistant to Denial of Service
      attacks in the sense\n   that a Responder does not construct any state (at the
      key management\n   protocol level) before it has authenticated the Initiator.
      \ However,\n   this protocol, like many others, is open to attacks that use
      spoofed\n   IP addresses to create a large number of fake requests.  This may
      for\n   example, be solved by letting the protocol transporting MIKEY do an\n
      \  IP address validity test.  The SIP protocol can provide this using\n   the
      anonymous authentication challenge mechanism (specified in\n   Section 22.1
      of [SIP]).\n   It is highly RECOMMENDED to include IDr in the Initiator's message.\n
      \  If not included, its absence can be used for DoS purposes (the\n   largest
      DoS-impact being on the public key and DH methods), where a\n   message intended
      for other entities is sent to the target.  In fact,\n   the target may verify
      the signature correctly due to the fact that\n   the Initiator's ID is correct
      and the message is actually signed by\n   the claimed Initiator (e.g., by re-directing
      traffic from another\n   session).\n   However, in the public key method, the
      envelop key and the MAC will\n   ensure that the message is not accepted (still,
      compared to a normal\n   faked message, where the signature verification would
      detect the\n   problem, one extra public key decryption is needed to detect
      the\n   problem in this case).\n   In the DH method, a message would be accepted
      (without detecting the\n   error) and a response (and state) would be created
      for the malicious\n   request.\n   As also discussed in Section 5.4, the tradeoff
      between time\n   synchronization and the size of the replay cache may be affected
      in\n   case of for example, a flooding DoS attack.  However, if the\n   recommendations
      of using a dynamic size of the replay cache are\n   followed, it is believed
      that the client will in most cases be able\n   to handle the replay cache.  Of
      course, as the replay cache decreases\n   in size, the required time synchronization
      is more restricted.\n   However, a bigger problem during such an attack would
      probably be to\n   process the messages (e.g., verify signatures/MACs) due to
      the\n   computational workload this implies.\n"
    title: 9.5.  Denial of Service
  - contents:
    - "9.6.  Session Establishment\n   It should be noted that if the session establishment
      protocol is\n   insecure, there may be attacks on this that will have indirect\n
      \  security implications on the secured media streams.  This however\n   only
      applies to groups (and is not specific to MIKEY).  The threat is\n   that one
      group member may re-direct a stream from one group member to\n   another.  This
      will have the same implication as when a member tries\n   to impersonate another
      member, e.g., by changing its IP address.  If\n   this is seen as a problem,
      it is RECOMMENDED that a Data Origin\n   Authentication (DOA) scheme (e.g.,
      digital signatures) be applied to\n   the security protocol.\n   Re-direction
      of streams can of course be done even if it is not a\n   group.  However, the
      effect will not be the same as compared to a\n   group where impersonation can
      be done if DOA is not used.  Instead,\n   re-direction will only deny the receiver
      the possibility of receiving\n   (or just delay) the data.\n"
    title: 9.6.  Session Establishment
  title: 9.  Security Considerations
- contents:
  - "10.  IANA Considerations\n   This document defines several new name spaces associated
    with the\n   MIKEY payloads.  This section summarizes the name spaces for which\n
    \  IANA is requested to manage the allocation of values.  IANA is\n   requested
    to record the pre-defined values defined in the given\n   sections for each name
    space.  IANA is also requested to manage the\n   definition of additional values
    in the future.  Unless explicitly\n   stated otherwise, values in the range 0-240
    for each name space\n   SHOULD be approved by the process of IETF consensus and
    values in the\n   range 241-255 are reserved for Private Use, according to [RFC2434].\n
    \  The name spaces for the following fields in the Common header payload\n   (from
    Section 6.1) are requested to be managed by IANA (in bracket is\n   the reference
    to the table with the initially registered values):\n   *  version\n   *  data
    type (Table 6.1.a)\n   *  Next payload (Table 6.1.b)\n   *  PRF func (Table 6.1.c).
    \ This name space is between 0-127, where\n      values between 0-111 should be
    approved by the process of IETF\n      consensus and values between 112-127 are
    reserved for Private Use.\n   *  CS ID map type (Table 6.1.d)\n   The name spaces
    for the following fields in the Key data transport\n   payload (from Section 6.2)
    are requested to be managed by IANA:\n   *  Encr alg (Table 6.2.a)\n   *  MAC
    alg (Table 6.2.b)\n   The name spaces for the following fields in the Envelope
    data payload\n   (from Section 6.3) are requested to be managed by IANA:\n   *
    \ C (Table 6.3)\n   The name spaces for the following fields in the DH data payload
    (from\n   Section 6.4) are requested to be managed by IANA:\n   *  DH-Group (Table
    6.4)\n   The name spaces for the following fields in the Signature payload\n   (from
    Section 6.5) are requested to be managed by IANA:\n   *  S type (Table 6.5)\n
    \  The name spaces for the following fields in the Timestamp payload\n   (from
    Section 6.6) are requested to be managed by IANA:\n   *  TS type (Table 6.6)\n
    \  The name spaces for the following fields in the ID payload and the\n   Certificate
    payload (from Section 6.7) are requested to be managed by\n   IANA:\n   *  ID
    type (Table 6.7.a)\n   *  Cert type (Table 6.7.b)\n   The name spaces for the
    following fields in the Cert hash payload\n   (from Section 6.8) are requested
    to be managed by IANA:\n   *  Hash func (Table 6.8)\n   The name spaces for the
    following fields in the Security policy\n   payload (from Section 6.10) are requested
    to be managed by IANA:\n   *  Prot type (Table 6.10)\n   For each security protocol
    that uses MIKEY, a set of unique\n   parameters MAY be registered.\n   From Section
    6.10.1.\n   *  SRTP Type (Table 6.10.1.a)\n   * SRTP encr alg (Table 6.10.1.b)\n
    \  * SRTP auth alg (Table 6.10.1.c)\n   * SRTP PRF (Table 6.10.1.d)\n   * FEC
    order (Table 6.10.1.e)\n   The name spaces for the following fields in the Error
    payload (from\n   Section 6.12) are requested to be managed by IANA:\n   *  Error
    no  (Table 6.12)\n   The name spaces for the following fields in the Key data
    payload\n   (from Section 6.13) are requested to be managed by IANA:\n   *  Type
    (Table 6.13.a).  This name space is between 0-16, which\n      should be approved
    by the process of IETF consensus.\n   *  KV (Table 6.13.b).  This name space is
    between 0-16, which should\n      be approved by the process of IETF consensus.\n
    \  The name spaces for the following fields in the General Extensions\n   payload
    (from Section 6.15) are requested to be managed by IANA:\n   *  Type (Table 6.15).\n"
  - contents:
    - "10.1.  MIME Registration\n   This section gives instructions to IANA to register
      the\n   application/mikey MIME media type.  This registration is as follows:\n
      \  MIME media type name              : application\n   MIME subtype name                 :
      mikey\n   Required parameters               : none\n   Optional parameters               :
      version\n             version: The MIKEY version number of the enclosed message\n
      \               (e.g., 1). If not present, the version defaults to 1.\n   Encoding
      Considerations           : binary, base64 encoded\n   Security Considerations
      \          : see section 9 in this memo\n   Interoperability considerations
      \  : none\n   Published specification           : this memo\n"
    title: 10.1.  MIME Registration
  title: 10.  IANA Considerations
- contents:
  - "11.  Acknowledgments\n   The authors would like to thank Mark Baugher, Ran Canetti,
    Martin\n   Euchner, Steffen Fries, Peter Barany, Russ Housley, Pasi Ahonen (with\n
    \  his group), Rolf Blom, Magnus Westerlund, Johan Bilien, Jon-Olov\n   Vatn,
    Erik Eliasson, and Gerhard Strangar for their valuable\n   feedback.\n"
  title: 11.  Acknowledgments
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [HMAC]    Krawczyk, H., Bellare, M., and R.
      Canetti, \"HMAC:  Keyed-\n             Hashing for Message Authentication\",
      RFC 2104, February\n             1997.\n   [NAI]     Aboba, B. and M. Beadles,
      \"The Network Access Identifier\",\n             RFC 2486, January 1999.\n   [OAKLEY]
      \ Orman, H., \"The OAKLEY Key Determination Protocol\", RFC\n             2412,
      November 1998.\n   [PSS]     PKCS #1 v2.1 - RSA Cryptography Standard, RSA Laboratories,\n
      \            June 14, 2002, www.rsalabs.com\n   [RFC2119] Bradner, S., \"Key
      words for use in RFCs to Indicate\n             Requirement Levels\", BCP 14,
      RFC 2119, March 1997.\n   [RFC2434] Narten, T. and H. Alvestrand, \"Guidelines
      for Writing an\n             IANA Considerations Section in RFCs\", BCP 26,
      RFC 2434,\n             October 1998.\n   [SHA-1]   NIST, FIPS PUB 180-1: Secure
      Hash Standard, April 1995.\n   [SRTP]    Baugher, M., McGrew, D., Naslund, M.,
      Carrara, E., and K.\n             Norrman, \"The Secure Real Time Transport
      Protocol\", RFC\n             3711, March 2004.\n   [URI]     Berners-Lee, T.,
      Fielding, R., and L. Masinter, \"Uniform\n             Resource Identifiers
      (URI): Generic Syntax\", RFC 2396,\n             August 1998.\n   [X.509]   Housley,
      R., Polk, W., Ford, W., and D. Solo, \"Internet\n             X.509 Public Key
      Infrastructure Certificate and Certificate\n             Revocation List (CRL)
      Profile\", RFC 3280, April 2002.\n   [AESKW]   Schaad, J. and R. Housley, \"Advanced
      Encryption Standard\n             (AES) Key Wrap Algorithm\", RFC 3394, September
      2002.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [AKE]     Canetti, R. and H. Krawczyk, \"Analysis
      of Key-Exchange\n             Protocols and their use for Building Secure Channels\",\n
      \            Eurocrypt 2001, LNCS 2054, pp. 453-474, 2001.\n   [BDJR]    Bellare,
      M., Desai, A., Jokipii, E., and P. Rogaway, \"A\n             Concrete Analysis
      of Symmetric Encryption: Analysis of the\n             DES Modes of Operation\",
      in Proceedings of the 38th\n             Symposium on Foundations of Computer
      Science, IEEE, 1997,\n             pp. 394-403.\n   [BMGL]    Hastad, J. and
      M. Naslund: \"Practical Construction and\n             Analysis of Pseduo-randomness
      Primitives\", Proceedings of\n             Asiacrypt 2001, LNCS. vol 2248, pp.
      442-459, 2001.\n   [DBJ]     Johnson, D.B., \"Theoretical Security Concerns
      with TLS use\n             of MD5\", Contribution to ANSI X9F1 WG, 2001.\n   [FIPS]
      \   \"Security Requirements for Cryptographic Modules\", Federal\n             Information
      Processing Standard Publications (FIPS PUBS)\n             140-2, December 2002.\n
      \  [GKMARCH] Baugher, M., Canetti, R., Dondeti, L., and F. Lindholm,\n             \"Group
      Key Management Architecture\", Work in Progress.\n   [GDOI]    Baugher, M.,
      Weis, B., Hardjono, T., and H. Harney, \"The\n             Group Domain of Interpretation\",
      RFC 3547, July 2003.\n   [GSAKMP]  Harney, H., Colegrove, A., Harder, E., Meth,
      U., and R.\n             Fleischer, \"Group Secure Association Key Management\n
      \            Protocol\", Work in Progress.\n   [HAC]     Menezes, A., van Oorschot,
      P., and S. Vanstone, \"Handbook\n             of Applied Cryptography\", CRC
      press, 1996.\n   [IKE]     Harkins, D. and D. Carrel, \"The Internet Key Exchange\n
      \            (IKE)\", RFC 2409, November 1998.\n   [ISO1]    ISO/IEC 9798-3:
      1997, Information technology - Security\n             techniques - Entity authentication
      - Part 3: Mechanisms\n             using digital signature techniques.\n   [ISO2]
      \   ISO/IEC 11770-3: 1997, Information technology - Security\n             techniques
      - Key management - Part 3: Mechanisms using\n             digital signature
      techniques.\n   [ISO3]    ISO/IEC 18014 Information technology - Security techniques\n
      \            - Time-stamping services, Part 1-3.\n   [KMASDP]  Arkko, J., Carrara,
      E., Lindholm, F., Naslund, M., and K.\n             Norrman, \"Key Management
      Extensions for SDP and RTSP\", Work\n             in Progress.\n   [LOA]     Burrows,
      Abadi, and Needham, \"A logic of authentication\",\n             ACM Transactions
      on Computer Systems 8 No.1 (Feb. 1990),\n             18-36.\n   [LV]      Lenstra,
      A. K. and E. R. Verheul, \"Suggesting Key Sizes for\n             Cryptosystems\",
      http://www.cryptosavvy.com/suggestions.htm\n   [NTP]     Mills, D., \"Network
      Time Protocol (Version 3)\n             Specification, Implementation and Analysis\",
      RFC 1305,\n             March 1992.\n   [OCSP]    Myers, M., Ankney, R., Malpani,
      A., Galperin, S., and C.\n             Adams, \"X.509 Internet Public Key Infrastructure
      Online\n             Certificate Status Protocol - OCSP\", RFC 2560, June 1999.\n
      \  [RAND]    Eastlake, 3rd, D., Crocker, S., and J. Schiller,\n             \"Randomness
      Requirements for Security\", RFC 1750, December\n             1994.\n   [RTSP]
      \   Schulzrinne, H., Rao, A., and R. Lanphier, \"Real Time\n             Streaming
      Protocol (RTSP)\", RFC 2326, April 1998.\n   [SDP]     Handley, M. and V. Jacobson,
      \"SDP: Session Description\n             Protocol\", RFC 2327, April 1998.\n
      \  [SHA256]  NIST, \"Description of SHA-256, SHA-384, and SHA-512\",\n             http://csrc.nist.gov/encryption/shs/sha256-384-512.pdf\n
      \  [SIP]     Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n             A.,
      Peterson, J., Sparks, R., Handley, M., and E. Schooler,\n             \"SIP:
      Session Initiation Protocol\", RFC 3261, June 2002.\n   [TLS]     Dierks, T.
      and C. Allen, \"The TLS Protocol - Version 1.0\",\n             RFC 2246, January
      1999.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Appendix A.  MIKEY - SRTP Relation\n   The terminology in MIKEY differs from
    the one used in SRTP as MIKEY\n   needs to be more general, nor is tight to SRTP
    only.  Therefore, it\n   might be hard to see the relations between keys and parameters\n
    \  generated in MIKEY and those used by SRTP.  This section provides\n   some
    hints on their relation.\n   MIKEY            | SRTP\n   -------------------------------------------------\n
    \  Crypto Session   | SRTP stream (typically with related SRTCP stream)\n   Data
    SA          | input to SRTP's crypto context\n   TEK              | SRTP master
    key\n   The Data SA is built up by a TEK and the security policy exchanged.\n
    \  SRTP may use an MKI to index the TEK or TGK (the TEK is then derived\n   from
    the TGK that is associated with the corresponding MKI), see\n   below.\n"
  - contents:
    - "A.1.  MIKEY-SRTP Interactions\n   In the following, we give a brief outline
      of the interface between\n   SRTP and MIKEY and the processing that takes place.
      \ We describe the\n   SRTP receiver side only, the sender side will require
      analogous\n   interfacing.\n   1. When an SRTP packet arrives at the receiver
      and is processed, the\n      triple <SSRC, destination address, destination
      port> is extracted\n      from the packet and used to retrieve the correct SRTP
      crypto\n      context, hence the Data SA.  (The actual retrieval can, for\n
      \     example, be done by an explicit request from the SRTP\n      implementation
      to MIKEY, or, by the SRTP implementation accessing\n      a \"database\", maintained
      by MIKEY.  The application will typically\n      decide which implementation
      is preferred.)\n   2. If an MKI is present in the SRTP packet, it is used to
      point to\n      the correct key within the SA.  Alternatively, if SRTP's <From,\n
      \     To> feature is used, the ROC||SEQ of the packet is used to\n      determine
      the correct key.\n   3. Depending on whether the key sent in MIKEY (as obtained
      in step 2)\n      was a TEK or a TGK, there are now two cases.\n      -  If
      the key obtained in step 2 is the TEK itself, it is used\n         directly
      by SRTP as a master key.\n      -  If the key instead is a TGK, the mapping
      with the CS_ID\n         (internal to MIKEY, Section 6.1.1) allows MIKEY to
      compute the\n         correct TEK from the TGK as described in Section 4.1 before\n
      \        SRTP uses it.\n   If multiple TGKs (or TEKs) are sent, it is RECOMMENDED
      that each TGK\n   (or TEK) be associated with a distinct MKI.  It is RECOMMENDED
      that\n   the use of <From, To> in this scenario be limited to very simple\n
      \  cases, e.g., one stream only.\n   Besides the actual master key, other information
      in the Data SA\n   (e.g., transform identifiers) will of course also be communicated\n
      \  from MIKEY to SRTP.\n"
    title: A.1.  MIKEY-SRTP Interactions
  title: Appendix A.  MIKEY - SRTP Relation
- contents:
  - "Authors' Addresses\n   Jari Arkko\n   Ericsson Research\n   02420 Jorvas\n   Finland\n
    \  Phone:  +358 40 5079256\n   EMail:  jari.arkko@ericsson.com\n   Elisabetta
    Carrara\n   Ericsson Research\n   SE-16480 Stockholm\n   Sweden\n   Phone:  +46
    8 50877040\n   EMail:  elisabetta.carrara@ericsson.com\n   Fredrik Lindholm\n
    \  Ericsson Research\n   SE-16480 Stockholm\n   Sweden\n   Phone:  +46 8 58531705\n
    \  EMail:  fredrik.lindholm@ericsson.com\n   Mats Naslund\n   Ericsson Research\n
    \  SE-16480 Stockholm\n   Sweden\n   Phone:  +46 8 58533739\n   EMail:  mats.naslund@ericsson.com\n
    \  Karl Norrman\n   Ericsson Research\n   SE-16480 Stockholm\n   Sweden\n   Phone:
    \ +46 8 4044502\n   EMail:  karl.norrman@ericsson.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2004).  This
    document is subject\n   to the rights, licenses and restrictions contained in
    BCP 78, and\n   except as set forth therein, the authors retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at ietf-\n   ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
