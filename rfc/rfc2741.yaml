- contents:
  - "                 Agent Extensibility (AgentX) Protocol\n                               Version
    1\n"
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This memo defines a standardized framework for extensible SNMP\n
    \  agents.  It defines processing entities called master agents and\n   subagents,
    a protocol (AgentX) used to communicate between them, and\n   the elements of
    procedure by which the extensible agent processes\n   SNMP protocol messages.
    This memo obsoletes RFC 2257.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction.....................................................4\n
    \  2. The SNMP Management Framework....................................4\n     2.1.
    A Note on Terminology........................................5\n   3. Extending
    the MIB................................................5\n     3.1. Motivation
    for AgentX........................................6\n   4. AgentX Framework.................................................6\n
    \    4.1. AgentX Roles.................................................7\n     4.2.
    Applicability................................................8\n     4.3. Design
    Features of AgentX....................................9\n     4.4. Non-Goals...................................................10\n
    \  5. AgentX Encodings................................................11\n     5.1.
    Object Identifier...........................................11\n     5.2. SearchRange.................................................13\n
    \    5.3. Octet String................................................14\n     5.4.
    Value Representation........................................15\n   6. Protocol
    Definitions............................................17\n     6.1. AgentX PDU
    Header...........................................17\n       6.1.1. Context.................................................20\n
    \    6.2. AgentX PDUs.................................................20\n       6.2.1.
    The agentx-Open-PDU.....................................20\n       6.2.2. The
    agentx-Close-PDU....................................22\n       6.2.3. The agentx-Register-PDU.................................23\n
    \      6.2.4. The agentx-Unregister-PDU...............................27\n       6.2.5.
    The agentx-Get-PDU......................................29\n       6.2.6. The
    agentx-GetNext-PDU..................................30\n       6.2.7. The agentx-GetBulk-PDU..................................32\n
    \      6.2.8. The agentx-TestSet-PDU..................................34\n       6.2.9.
    The agentx-CommitSet, -UndoSet, -CleanupSet PDUs........35\n       6.2.10. The
    agentx-Notify-PDU..................................36\n       6.2.11. The agentx-Ping-PDU....................................37\n
    \      6.2.12. The agentx-IndexAllocate-PDU...........................37\n       6.2.13.
    The agentx-IndexDeallocate-PDU.........................38\n       6.2.14. The
    agentx-AddAgentCaps-PDU............................39\n       6.2.15. The agentx-RemoveAgentCaps-PDU.........................41\n
    \      6.2.16. The agentx-Response-PDU................................43\n   7.
    Elements of Procedure...........................................45\n     7.1.
    Processing AgentX Administrative Messages...................45\n       7.1.1.
    Processing the agentx-Open-PDU..........................46\n       7.1.2. Processing
    the agentx-IndexAllocate-PDU.................47\n       7.1.3. Processing the
    agentx-IndexDeallocate-PDU...............49\n       7.1.4. Processing the agentx-Register-PDU......................50\n
    \        7.1.4.1. Handling Duplicate and Overlapping Subtrees.........50\n         7.1.4.2.
    Registering Stuff...................................51\n           7.1.4.2.1.
    Registration Priority...........................51\n           7.1.4.2.2. Index
    Allocation................................51\n           7.1.4.2.3. Examples........................................53\n
    \      7.1.5. Processing the agentx-Unregister-PDU....................55\n       7.1.6.
    Processing the agentx-AddAgentCaps-PDU..................55\n       7.1.7. Processing
    the agentx-RemoveAgentCaps-PDU...............55\n       7.1.8. Processing the
    agentx-Close-PDU.........................56\n       7.1.9. Detecting Connection
    Loss...............................56\n       7.1.10. Processing the agentx-Notify-PDU.......................56\n
    \      7.1.11. Processing the agentx-Ping-PDU.........................57\n     7.2.
    Processing Received SNMP Protocol Messages..................58\n       7.2.1.
    Dispatching AgentX PDUs.................................58\n         7.2.1.1.
    agentx-Get-PDU......................................61\n         7.2.1.2. agentx-GetNext-PDU..................................61\n
    \        7.2.1.3. agentx-GetBulk-PDU..................................62\n         7.2.1.4.
    agentx-TestSet-PDU..................................63\n         7.2.1.5. Dispatch............................................64\n
    \      7.2.2. Subagent Processing.....................................64\n       7.2.3.
    Subagent Processing of agentx-Get, GetNext, GetBulk-PDUs65\n         7.2.3.1.
    Subagent Processing of the agentx-Get-PDU...........65\n         7.2.3.2. Subagent
    Processing of the agentx-GetNext-PDU.......66\n         7.2.3.3. Subagent Processing
    of the agentx-GetBulk-PDU.......66\n       7.2.4. Subagent Processing of agentx-TestSet,
    -CommitSet,\n              -UndoSet, -CleanupSet-PDUs..............................67\n
    \        7.2.4.1. Subagent Processing of the agentx-TestSet-PDU.......68\n         7.2.4.2.
    Subagent Processing of the agentx-CommitSet-PDU.....69\n         7.2.4.3. Subagent
    Processing of the agentx-UndoSet-PDU.......69\n         7.2.4.4. Subagent Processing
    of the agentx-CleanupSet-PDU....70\n       7.2.5. Master Agent Processing of AgentX
    Responses.............70\n         7.2.5.1. Common Processing of All AgentX Response
    PDUs.......70\n         7.2.5.2. Processing of Responses to agentx-Get-PDUs..........70\n
    \        7.2.5.3. Processing of Responses to agentx-GetNext-PDU and\n                  agentx-GetBulk-PDU..................................71\n
    \        7.2.5.4. Processing of Responses to agentx-TestSet-PDUs......72\n         7.2.5.5.
    Processing of Responses to agentx-CommitSet-PDUs....73\n         7.2.5.6. Processing
    of Responses to agentx-UndoSet-PDUs......74\n       7.2.6. Sending the SNMP Response-PDU...........................74\n
    \      7.2.7. MIB Views...............................................74\n     7.3.
    State Transitions...........................................75\n       7.3.1.
    Set Transaction States..................................75\n       7.3.2. Transport
    Connection States.............................77\n       7.3.3. Session States..........................................78\n
    \  8. Transport Mappings..............................................79\n     8.1.
    AgentX over TCP.............................................79\n       8.1.1.
    Well-known Values.......................................79\n       8.1.2. Operation...............................................79\n
    \    8.2. AgentX over UNIX-domain Sockets.............................80\n       8.2.1.
    Well-known Values.......................................80\n       8.2.2. Operation...............................................80\n
    \  9. Security Considerations.........................................81\n   10.
    Acknowledgements...............................................82\n   11. Authors'
    and Editor's Addresses................................83\n   12. References.....................................................84\n
    \  13. Notices........................................................86\n   Appendix
    A. Changes relative to RFC 2257 ..........................87\n   Full Copyright
    Statement ..........................................91\n"
  title: Table of Contents
- contents:
  - "1. Introduction\n   This memo defines a standardized framework for extensible
    SNMP\n   agents.  It defines processing entities called master agents and\n   subagents,
    a protocol (AgentX) used to communicate between them, and\n   the elements of
    procedure by which the extensible agent processes\n   SNMP protocol messages.\n
    \  This memo obsoletes RFC 2257.  It is worth noting that most of the\n   changes
    are for the purpose of clarification.  The only changes\n   affecting AgentX protocol
    messages on the wire are:\n      -  The agentx-Notify-PDU and agentx-Close-PDU
    now generate an\n         agentx-Response-PDU\n      -  Three new error codes
    are available: parseFailed(266),\n         requestDenied(267), and processingError(268)\n
    \  Appendix A provides a detailed list of changes relative to RFC 2257.\n   The
    key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\",
    \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this\n   document
    are to be interpreted as described in [27].\n"
  title: 1. Introduction
- contents:
  - "2. The SNMP Management Framework\n   The SNMP Management Framework presently
    consists of five major\n   components:\n   An overall architecture, described
    in RFC 2571 [1].\n   Mechanisms for describing and naming objects and events for
    the\n   purpose of management. The first version of this Structure of\n   Management
    Information (SMI) is called SMIv1 and described in STD 16,\n   RFC 1155 [2], STD
    16, RFC 1212 [3] and RFC 1215 [4]. The second\n   version, called SMIv2, is described
    in STD 58, RFC 2578 [5], STD 58,\n   RFC 2579 [6] and STD 58, RFC 2580 [7].\n
    \  Message protocols for transferring management information. The first\n   version
    of the SNMP message protocol is called SNMPv1 and described\n   in STD 15, RFC
    1157 [8]. A second version of the SNMP message\n   protocol, which is not an Internet
    standards track protocol, is\n   called SNMPv2c and described in RFC 1901 [9]
    and RFC 1906 [10]. The\n   third version of the message protocol is called SNMPv3
    and described\n   in RFC 1906 [10], RFC 2572 [11] and RFC 2574 [12].\n   Protocol
    operations for accessing management information. The first\n   set of protocol
    operations and associated PDU formats is described in\n   STD 15, RFC 1157 [8].
    A second set of protocol operations and\n   associated PDU formats is described
    in RFC 1905 [13].\n   A set of fundamental applications described in RFC 2573
    [14] and the\n   view-based access control mechanism described in RFC 2575 [15].\n
    \  A more detailed introduction to the current SNMP Management Framework\n   can
    be found in RFC 2570 [16].\n   Managed objects are accessed via a virtual information
    store, termed\n   the Management Information Base or MIB.  Objects in the MIB
    are\n   defined using the mechanisms defined in the SMI.\n"
  - contents:
    - "2.1. A Note on Terminology\n   The term \"variable\" refers to an instance
      of a non-aggregate object\n   type defined according to the conventions set
      forth in the SMIv2 (STD\n   58, RFC 2578, [5]) or the textual conventions based
      on the SMIv2 (STD\n   58, RFC 2579 [6]).  The term \"variable binding\" normally
      refers to\n   the pairing of the name of a variable and its associated value.\n
      \  However, if certain kinds of exceptional conditions occur during\n   processing
      of a retrieval request, a variable binding will pair a\n   name and an indication
      of that exception.\n   A variable-binding list is a simple list of variable
      bindings.\n   The name of a variable is an OBJECT IDENTIFIER, which is the\n
      \  concatenation of the OBJECT IDENTIFIER of the corresponding object\n   type
      together with an OBJECT IDENTIFIER fragment identifying the\n   instance.  The
      OBJECT IDENTIFIER of the corresponding object-type is\n   called the OBJECT
      IDENTIFIER prefix of the variable.\n"
    title: 2.1. A Note on Terminology
  title: 2. The SNMP Management Framework
- contents:
  - "3. Extending the MIB\n   New MIB modules that extend the Internet-standard MIB
    are\n   continuously being defined by various IETF working groups.  It is\n   also
    common for enterprises or individuals to create or extend\n   enterprise-specific
    or experimental MIBs.\n   As a result, managed devices are frequently complex
    collections of\n   manageable components that have been independently installed
    on a\n   managed node.  Each component provides instrumentation for the\n   managed
    objects defined in the MIB module(s) it implements.\n   The SNMP framework does
    not describe how the set of managed objects\n   supported by a particular agent
    may be changed dynamically.\n"
  - contents:
    - "3.1. Motivation for AgentX\n   This very real need to dynamically extend the
      management objects\n   within a node has given rise to a variety of \"extensible
      agents\",\n   which typically comprise\n      -  a \"master\" agent that is
      available on the standard transport\n         address and that accepts SNMP
      protocol messages\n      -  a set of \"subagents\" that each contain management\n
      \        instrumentation\n      -  a protocol that operates between the master
      agent and\n         subagents, permitting subagents to \"connect\" to the master\n
      \        agent, and the master agent to multiplex received SNMP protocol\n         messages
      amongst the subagents.\n      -  a set of tools to aid subagent development,
      and a runtime (API)\n         environment that hides much of the protocol operation
      between a\n         subagent and the master agent.\n   The wide deployment of
      extensible SNMP agents, coupled with the lack\n   of Internet standards in this
      area, makes it difficult to field\n   SNMP-manageable applications.  A vendor
      may have to support several\n   different subagent environments (APIs) in order
      to support different\n   target platforms.\n   It can also become quite cumbersome
      to configure subagents and\n   (possibly multiple) master agents on a particular
      managed node.\n   Specifying a standard protocol for agent extensibility (AgentX)\n
      \  provides the technical foundation required to solve both of these\n   problems.
      \ Independently developed AgentX-capable master agents and\n   subagents will
      be able to interoperate at the protocol level.\n   Vendors can continue to differentiate
      their products in all other\n   respects.\n"
    title: 3.1. Motivation for AgentX
  title: 3. Extending the MIB
- contents:
  - "4. AgentX Framework\n   Within the SNMP framework, a managed node contains a
    processing\n   entity, called an agent, which has access to management information.\n
    \  Within the AgentX framework, an agent is further defined to consist\n   of:\n
    \     -  a single processing entity called the master agent, which sends\n         and
    receives SNMP protocol messages in an agent role (as\n         specified by the
    SNMP framework documents) but typically has\n         little or no direct access
    to management information.\n      -  zero or more processing entities called subagents,
    which are\n         \"shielded\" from the SNMP protocol messages processed by
    the\n         master agent, but which have access to management information.\n
    \  The master and subagent entities communicate via AgentX protocol\n   messages,
    as specified in this memo.  Other interfaces (if any) on\n   these entities, and
    their associated protocols, are outside the scope\n   of this document.  While
    some of the AgentX protocol messages appear\n   similar in syntax and semantics
    to the SNMP, bear in mind that AgentX\n   is not SNMP.\n   The internal operations
    of AgentX are invisible to an SNMP entity\n   operating in a manager role.  From
    a manager's point of view, an\n   extensible agent behaves exactly as would a
    non-extensible\n   (monolithic) agent that has access to the same management\n
    \  instrumentation.\n   This transparency to managers is a fundamental requirement
    of AgentX,\n   and is what differentiates AgentX subagents from SNMP proxy agents.\n"
  - contents:
    - "4.1. AgentX Roles\n   An entity acting in a master agent role performs the
      following\n   functions:\n      -  Accepts AgentX session establishment requests
      from subagents.\n      -  Accepts registration of MIB regions by subagents.\n
      \     -  Sends and accepts SNMP protocol messages on the agent's\n         specified
      transport addresses.\n      -  Implements the agent role Elements of Procedure
      specified for\n         the administrative framework applicable to the SNMP
      protocol\n         message, except where they specify performing management\n
      \        operations.  (The application of MIB views, and the access\n         control
      policy for the managed node, are implemented by the\n         master agent.)\n
      \     -  Provides instrumentation for the MIB objects defined in RFC\n         1907
      [17], and for any MIB objects relevant to any\n         administrative framework
      it supports.\n      -  Sends and receives AgentX protocol messages to access\n
      \        management information, based on the current registry of MIB\n         regions.\n
      \     -  Forwards notifications on behalf of subagents.\n   An entity acting
      in a subagent role performs the following functions:\n      -  Initiates AgentX
      sessions with the master agent.\n      -  Registers MIB regions with the master
      agent.\n      -  Instantiates managed objects.\n      -  Binds OIDs within its
      registered MIB regions to actual\n         variables.\n      -  Performs management
      operations on variables.\n      -  Initiates notifications.\n"
    title: 4.1. AgentX Roles
  - contents:
    - "4.2. Applicability\n   It is intended that this memo specify the smallest amount
      of required\n   behavior necessary to achieve the largest benefit, that is,
      to cover\n   a very large number of possible MIB implementations and\n   configurations
      with minimum complexity and low \"cost of entry\".\n   This section discusses
      several typical usage scenarios.\n   1) Subagents implement separate MIB modules
      -- for example, subagent\n      `A' implements \"mib-2\", subagent `B' implements
      \"host-resources\".\n      It is anticipated that this will be the most common
      subagent\n      configuration.\n   2) Subagents implement rows in a \"simple
      table\".  A simple table is\n      one in which row creation is not specified,
      and for which the MIB\n      does not define an object that counts entries in
      the table.\n      Examples of simple tables are rdbmsDbTable, udpTable, and\n
      \     hrSWRunTable.\n      This is the most commonly defined type of MIB table,
      and probably\n      represents the next most typical configuration that AgentX
      would\n      support.\n   3) Subagents share MIBs along non-row partitions.
      \ Subagents register\n      \"chunks\" of the MIB that represent multiple rows,
      due to the\n      nature of the MIB's index structure.  Examples include registering\n
      \     ipNetToMediaEntry.n, where n represents the ifIndex value for an\n      interface
      implemented by the subagent, and tcpConnEntry.a.b.c.d,\n      where a.b.c.d
      represents an IP address on an interface implemented\n      by the subagent.\n
      \  AgentX supports these three common configurations, and all\n   permutations
      of them, completely.  The consensus is that they\n   comprise a very large majority
      of current and likely future uses of\n   multi-vendor extensible agent configurations.\n
      \  4) Subagents implement rows in tables that permit row creation, for\n      example,
      the RMON historyControlTable.  To implement row creation\n      in such tables,
      at least one AgentX subagent must register at a\n      point \"higher\" in the
      OID tree than an individual row (per\n      AgentX's dispatching procedure).\n
      \  5) Subagents implement rows in tables whose MIB also defines an\n      object
      that counts entries in the table, for example the MIB-2\n      ifTable (due
      to ifNumber).  The subagent that implements such a\n      counter object (like
      ifNumber) must go beyond AgentX to correctly\n      implement it.  This is an
      implementation issue (and most new MIB\n      designs no longer include such
      objects).\n   Scenarios in these latter 2 categories were thought to occur somewhat\n
      \  rarely in configurations where subagents are independently\n   implemented
      by different vendors.  The focus of a standard protocol,\n   however, must be
      in just those areas where multi-vendor\n   interoperability must be assured.\n
      \  Note that it would be inefficient (due to AgentX registration\n   overhead)
      to share a table among AgentX subagents if the table\n   contains very dynamic
      instances, and each subagent registers fully\n   qualified instances.  ipRouteTable
      could be an example of such a\n   table in some environments.\n"
    title: 4.2. Applicability
  - contents:
    - "4.3. Design Features of AgentX\n   The primary features of the design described
      in this memo are:\n   1) A general architectural division of labor between master
      agent and\n      subagent: The master agent is MIB ignorant and SNMP omniscient,\n
      \     while the subagent is SNMP ignorant and MIB omniscient (for the\n      MIB
      variables it instantiates).  That is, master agents,\n      exclusively, are
      concerned with SNMP protocol operations and the\n      translations to and from
      AgentX protocol operations needed to\n      carry them out; subagents are exclusively
      concerned with\n      management instrumentation; and neither should intrude
      on the\n      other's territory.\n   2) A standard protocol and \"rules of engagement\"
      to enable\n      interoperability between management instrumentation and extensible\n
      \     agents.\n   3) Mechanisms for independently developed subagents to integrate
      into\n      the extensible agent on a particular managed node in such a way\n
      \     that they need not be aware of any other existing subagents.\n   4) A
      simple, deterministic registry and dispatching algorithm.  For a\n      given
      extensible agent configuration, there is a single subagent\n      who is \"authoritative\"
      for any particular region of the MIB (where\n      \"region\" may extend from
      an entire MIB down to a single object-\n      instance).\n   5) Performance
      considerations.  It is likely that the master agent\n      and all subagents
      will reside on the same host, and in such cases\n      AgentX is more a form
      of inter-process communication than a\n      traditional communications protocol.\n
      \     Some of the design decisions made with this in mind include:\n         -
      32-bit alignment of data within PDUs\n         - Native byte-order encoding
      by subagents\n         - Large AgentX PDU payload sizes.\n"
    title: 4.3. Design Features of AgentX
  - contents:
    - "4.4. Non-Goals\n   1) Subagent-to-subagent communication.  This is out of scope,
      due to\n      the security ramifications and complexity involved.\n   2) Subagent
      access (via the master agent) to MIB variables.  This is\n      not addressed,
      since various other mechanisms are available and it\n      was not a fundamental
      requirement.\n   3) The ability to accommodate every conceivable extensible
      agent\n      configuration option. This was the most contentious aspect in the\n
      \     development of this protocol.  In essence, certain features\n      currently
      available in some commercial extensible agent products\n      are not included
      in AgentX.  Although useful or even vital in some\n      implementation strategies,
      the rough consensus was that these\n      features were not appropriate for
      an Internet Standard, or not\n      typically required for independently developed
      subagents to\n      coexist.  The set of supported extensible agent configurations
      is\n      described above, in Section 4.2, \"Applicability\".\n   Some possible
      future version of the AgentX protocol may provide\n   coverage for one or more
      of these \"non-goals\" or for new goals that\n   might be identified after greater
      deployment experience.\n"
    title: 4.4. Non-Goals
  title: 4. AgentX Framework
- contents:
  - "5. AgentX Encodings\n   AgentX PDUs consist of a common header, followed by PDU-specific
    data\n   of variable length.  Unlike SNMP PDUs, AgentX PDUs are not encoded\n
    \  using the BER (as specified in ISO 8824 [18]), but are transmitted as\n   a
    contiguous byte stream.  The data within this stream is organized\n   to provide
    natural alignment with respect to the start of the PDU,\n   permitting direct
    (integer) access by the processing entities.\n   The first four fields in the
    header are single-byte values.  A bit\n   (NETWORK_BYTE_ORDER) in the third field
    (h.flags) is used to indicate\n   the byte ordering of all multi-byte integer
    values in the PDU,\n   including those which follow in the header itself.  This
    is described\n   in more detail in Section 6.1, \"AgentX PDU Header\", below.\n
    \  PDUs are depicted in this memo using the following convention (where\n   byte
    1 is the first transmitted byte):\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |  byte 1       |  byte 2       |  byte 3       |  byte 4       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |  byte 5       |  byte 6       |  byte 7       |  byte 8       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  Fields marked \"<reserved>\" are reserved for future use and must be\n   zero-filled.\n"
  - contents:
    - "5.1. Object Identifier\n   An object identifier is encoded as a 4-byte header,
      followed by a\n   variable number of contiguous 4-byte fields representing sub-\n
      \  identifiers.  This representation (termed Object Identifier) is as\n   follows:\n
      \  Object Identifier\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  n_subid      |  prefix       |  include      |  <reserved>   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                       sub-identifier #1                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                       sub-identifier
      #n_subid                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Object Identifier header fields:\n      n_subid\n         The number (0-128)
      of sub-identifiers in the object identifier.\n         An ordered list of \"n_subid\"
      4-byte sub-identifiers follows the\n         4-byte header.\n      prefix\n
      \        An unsigned value used to reduce the length of object\n         identifier
      encodings.  A non-zero value \"x\" is interpreted as\n         the first sub-identifier
      after \"internet\" (1.3.6.1), and\n         indicates an implicit prefix \"internet.x\"
      to the actual sub-\n         identifiers encoded in the Object Identifier.  For
      example, a\n         prefix field value 2 indicates an implicit prefix \"1.3.6.1.2\".\n
      \        A value of 0 in the prefix field indicates there is no prefix\n         to
      the sub-identifiers.\n      include\n         Used only when the Object Identifier
      is the start of a\n         SearchRange, as described in section 5.2, \"SearchRange\".\n
      \     sub-identifier 1, 2, ... n_subid\n         A 4-byte unsigned integer,
      encoded according to the header's\n         NETWORK_BYTE_ORDER bit.\n   A null
      Object Identifier consists of the 4-byte header with all bytes\n   set to 0.\n
      \  Examples:\n   sysDescr.0 (1.3.6.1.2.1.1.1.0)\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 4             | 2             | 0             | 0             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 1                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 1                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 1                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 0                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  1.2.3.4\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 4             | 0             | 0             | 0             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 1                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 2                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 3                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 4                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
    title: 5.1. Object Identifier
  - contents:
    - "5.2. SearchRange\n   A SearchRange consists of two Object Identifiers.  In
      its\n   communication with a subagent, the master agent uses a SearchRange to\n
      \  identify a requested variable binding, and, in GetNext and GetBulk\n   operations,
      to set an upper bound on the names of managed object\n   instances the subagent
      may send in reply.\n   The first Object Identifier in a SearchRange (called
      the starting\n   OID) indicates the beginning of the range.  It is frequently
      (but not\n   necessarily) the name of a requested variable binding.\n   The
      \"include\" field in this OID's header is a boolean value (0 or 1)\n   indicating
      whether or not the starting OID is included in the range.\n   The second object
      identifier (ending OID) indicates the non-inclusive\n   end of the range, and
      its \"include\" field is always 0.  A null value\n   for ending OID indicates
      an unbounded SearchRange.\n   Example:  To indicate a search range from 1.3.6.1.2.1.25.2\n
      \  (inclusive) to 1.3.6.1.2.1.25.2.1 (exclusive), the SearchRange would\n   be:\n
      \  (start)\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 3             | 2             | 1             |       0       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 1                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 25                                                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 2                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  (end)\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 4             | 2             | 0             |       0       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 1                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 25                                                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 2                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | 1                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  A SearchRangeList is a contiguous list of SearchRanges.\n"
    title: 5.2. SearchRange
  - contents:
    - "5.3. Octet String\n   An octet string is represented by a contiguous series
      of bytes,\n   beginning with a 4-byte integer (encoded according to the header's\n
      \  NETWORK_BYTE_ORDER bit) whose value is the number of octets in the\n   octet
      string, followed by the octets themselves.  This representation\n   is termed
      an Octet String.  If the last octet does not end on a 4-\n   byte offset from
      the start of the Octet String, padding bytes are\n   appended to achieve alignment
      of following data.  This padding must\n   be added even if the Octet String
      is the last item in the PDU.\n   Padding bytes must be zero filled.\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                     Octet String Length (L)                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  Octet 1      |  Octet 2      |   Octet 3     |   Octet 4     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Octet
      L - 1  |  Octet L      |       Padding (as required)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  A null Octet String consists of a 4-byte length field set to 0.\n"
    title: 5.3. Octet String
  - contents:
    - "5.4. Value Representation\n   Variable bindings may be encoded within the variable-length
      portion\n   of some PDUs.  The representation of a variable binding (termed
      a\n   VarBind) consists of a 2-byte type field, a name (Object Identifier),\n
      \  and the actual value data.\n   VarBind\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |          v.type               |          <reserved>           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  (v.name)\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  n_subid      |  prefix       |      0        |       0       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                       sub-identifier #1                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                       sub-identifier
      #n_subid                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  (v.data)\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                       data                                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                       data
      \                                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  VarBind fields:\n      v.type\n   Indicates the variable binding's syntax,
      and must be one of the\n   following values:\n              Integer                  (2),\n
      \             Octet String             (4),\n              Null                     (5),\n
      \             Object Identifier        (6),\n              IpAddress               (64),\n
      \             Counter32               (65),\n              Gauge32                 (66),\n
      \             TimeTicks               (67),\n              Opaque                  (68),\n
      \             Counter64               (70),\n              noSuchObject           (128),\n
      \             noSuchInstance         (129),\n              endOfMibView           (130)\n
      \     v.name\n         The Object Identifier which names the variable.\n      v.data\n
      \        The actual value, encoded as follows:\n         -  Integer, Counter32,
      Gauge32, and TimeTicks are encoded as 4\n            contiguous bytes, according
      to the header's\n            NETWORK_BYTE_ORDER bit.\n         -  Counter64
      is encoded as 8 contiguous bytes, according to\n            the header's NETWORK_BYTE_ORDER
      bit.\n         -  Object Identifiers are encoded as described in section 5.1,\n
      \           Object Identifier.\n         -  IpAddress, Opaque, and Octet String
      are all octet strings\n            and are encoded as described in section 5.3,
      \"Octet\n            String\", Octet String.  Note that the octets used to\n
      \           represent IpAddress are always ordered most significant to\n            least
      significant.\n            Value data always follows v.name whenever v.type is
      one of\n            the above types.  These data bytes are present even if they\n
      \           will not be used (as, for example, in certain types of\n            index
      allocation).\n         -  Null, noSuchObject, noSuchInstance, and endOfMibView
      do not\n            contain any encoded value.  Value data never follows v.name\n
      \           in these cases.\n         Note that the VarBind itself does not
      contain the value size.\n         That information is implied for the fixed-length
      types, and\n         explicitly contained in the encodings of variable-length
      types\n         Object Identifier and Octet String).\n   A VarBindList is a
      contiguous list of VarBinds.  Within a\n   VarBindList, a particular VarBind
      is identified by an index value.\n   The first VarBind in a VarBindList has
      index value 1, the second has\n   index value 2, and so on.\n"
    title: 5.4. Value Representation
  title: 5. AgentX Encodings
- contents:
  - '6. Protocol Definitions

    '
  - contents:
    - "6.1. AgentX PDU Header\n   The AgentX PDU header is a fixed-format, 20-octet
      structure:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |   h.version   |    h.type     |    h.flags    |  <reserved>   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                          h.sessionID                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                        h.transactionID                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                          h.packetID                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                        h.payload_length                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  An AgentX PDU header contains the following fields:\n      h.version\n         The
      version of the AgentX protocol (1 for this memo).\n      h.type\n         The
      PDU type; one of the following values:\n            agentx-Open-PDU             (1),\n
      \           agentx-Close-PDU            (2),\n            agentx-Register-PDU
      \        (3),\n            agentx-Unregister-PDU       (4),\n            agentx-Get-PDU
      \             (5),\n            agentx-GetNext-PDU          (6),\n            agentx-GetBulk-PDU
      \         (7),\n            agentx-TestSet-PDU          (8),\n            agentx-CommitSet-PDU
      \       (9),\n            agentx-UndoSet-PDU         (10),\n            agentx-CleanupSet-PDU
      \     (11),\n            agentx-Notify-PDU          (12),\n            agentx-Ping-PDU
      \           (13),\n            agentx-IndexAllocate-PDU   (14),\n            agentx-IndexDeallocate-PDU
      (15),\n            agentx-AddAgentCaps-PDU    (16),\n            agentx-RemoveAgentCaps-PDU
      (17),\n            agentx-Response-PDU        (18)\n            The set of PDU
      types for \"administrative processing\" are 1-4\n            and 12-17.  The
      set of PDU types for \"SNMP request\n            processing\" are 5-11.\n      h.flags\n
      \           A bitmask, with bit 0 the least significant bit.  The bit\n            definitions
      are as follows:\n                 Bit             Definition\n                 ---
      \            ----------\n                 0               INSTANCE_REGISTRATION\n
      \                1               NEW_INDEX\n                 2               ANY_INDEX\n
      \                3               NON_DEFAULT_CONTEXT\n                 4               NETWORK_BYTE_ORDER\n
      \                5-7             (reserved)\n            The NETWORK_BYTE_ORDER
      bit applies to all multi-byte integer\n            values in the entire AgentX
      packet, including the remaining\n            header fields.  If set, then network
      byte order (most\n            significant byte first; \"big endian\") is used.
      \ If not set,\n            then least significant byte first (\"little endian\")
      is used.\n            The NETWORK_BYTE_ORDER bit applies to all AgentX PDUs.\n
      \           The NON_DEFAULT_CONTEXT bit is used only in the AgentX PDUs\n            described
      in section 6.1.1, \"Context\".\n            The NEW_INDEX and ANY_INDEX bits
      are used only within the\n            agentx-IndexAllocate-, and -IndexDeallocate-PDUs.\n
      \           The INSTANCE_REGISTRATION bit is used only within the\n            agentx-Register-PDU.\n
      \     h.sessionID\n            The session ID uniquely identifies a session
      over which\n            AgentX PDUs are exchanged between a subagent and the
      master\n            agent.  The session ID has no significance and no defined\n
      \           value in the agentx-Open-PDU sent by a subagent to open a\n            session
      with the master agent; in this case, the master\n            agent will assign
      a unique session ID that it will pass back\n            in the corresponding
      agentx-Response-PDU.  From that point\n            on, that same session ID
      will appear in every AgentX PDU\n            exchanged over that session between
      the master and the\n            subagent.  A subagent may establish multiple
      AgentX sessions\n            by sending multiple agentx-Open-PDUs to the master
      agent.\n            In master agents that support multiple transport protocols,\n
      \           the sessionID should be globally unique rather than unique\n            just
      to a particular transport.\n      h.transactionID\n            The transaction
      ID uniquely identifies, for a given session,\n            the single SNMP management
      request (and single SNMP PDU)\n            with which an AgentX PDU is associated.
      \ If a single SNMP\n            management request results in multiple AgentX
      PDUs being\n            sent by the master agent with the same session ID, each
      of\n            these AgentX PDUs must contain the same transaction ID;\n            conversely,
      AgentX PDUs sent during a particular session,\n            that result from
      distinct SNMP management requests, must\n            have distinct transaction
      IDs within the limits of the 32-\n            bit field).\n            Note
      that the transaction ID is not the same as the SNMP\n            PDU's request-id
      (as described in section 4.1 of RFC 1905\n            [13], nor is it the same
      as the SNMP Message's msgID (as\n            described in section 6.2 of RFC
      2572 [11]), nor can it be,\n            since a master agent might receive SNMP
      requests with the\n            same request-ids or msgIDs from different managers.\n
      \           The transaction ID has no significance and no defined value\n            in
      AgentX administrative PDUs, i.e., AgentX PDUs that are\n            not associated
      with an SNMP management request.\n      h.packetID\n            A packet ID
      generated by the sender for all AgentX PDUs\n            except the agentx-Response-PDU.
      In an agentx-Response-PDU,\n            the packet ID must be the same as that
      in the received\n            AgentX PDU to which it is a response.  A master
      agent might\n            use this field to associate subagent response PDUs
      with\n            their corresponding request PDUs.  A subagent might use this\n
      \           field to correlate responses to multiple (batched)\n            registrations.\n
      \     h.payload_length\n            The size in octets of the PDU contents,
      excluding the 20-\n            byte header.  As a result of the encoding schemes
      and PDU\n            layouts, this value will always be either 0, or a multiple\n
      \           of 4.\n"
    - contents:
      - "6.1.1. Context\n   In the SNMPv1 or SNMPv2c, the community string may be
        used as an\n   index into a local repository of configuration information
        that may\n   include community profiles or more complex context information.
        In\n   SNMPv3 this notion of \"context\" is formalized (see section 3.3.1
        in\n   RFC 2571 [1].\n   AgentX provides a mechanism for transmitting a context
        specification\n   within relevant PDUs, but does not place any constraints
        on the\n   content of that specification.\n   An optional context field may
        be present in the agentx-Register-,\n   UnRegister-, AddAgentCaps-, RemoveAgentCaps-,
        Get-, GetNext-,\n   GetBulk-, IndexAllocate-, IndexDeallocate-, Notify-, TestSet-,
        and\n   Ping- PDUs.\n   If the NON_DEFAULT_CONTEXT bit in the AgentX header
        field h.flags is\n   clear, then there is no context field in the PDU, and
        the operation\n   refers to the default context.  (This does not mean there
        is a zero-\n   length Octet String, it means there is no Octet String present.)
        \ If\n   the NON_DEFAULT_CONTEXT bit is set, then a context field immediately\n
        \  follows the AgentX header, and the operation refers to that specific\n
        \  context.  The context is represented as an Octet String.  There are\n   no
        constraints on its length or contents.\n   Thus, all of these AgentX PDUs
        (that is, those listed immediately\n   above) refer to, or \"indicate\" a
        context, which is either the default\n   context, or a non-default context
        explicitly named in the PDU.\n"
      title: 6.1.1. Context
    title: 6.1. AgentX PDU Header
  - contents:
    - '6.2. AgentX PDUs

      '
    - contents:
      - "6.2.1. The agentx-Open-PDU\n   An agentx-Open-PDU is generated by a subagent
        to request\n   establishment of an AgentX session with the master agent.\n
        \  (AgentX header)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | h.version (1) |  h.type (1)   |    h.flags    |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                          h.sessionID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.transactionID                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                           h.packetID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.payload_length                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |
        \ o.timeout    |                     <reserved>                |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (o.id)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  n_subid      |  prefix       |       0       |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             subidentifier #1                                  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...                                                             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             subidentifier #n_subid                            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (o.descr)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Octet String Length (L)                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet 1      |  Octet 2      |   Octet 3     |   Octet 4     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet L - 1  |  Octet L      |       Padding (as required)   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  An agentx-Open-PDU contains the following fields:\n      o.timeout\n            The
        length of time, in seconds, that a master agent should\n            allow
        to elapse after dispatching a message on a session\n            before it
        regards the subagent as not responding.  This is\n            the default
        value for the session, and may be overridden by\n            values associated
        with specific registered MIB regions.  The\n            default value of 0
        indicates that there is no session-wide\n            default value.\n      o.id\n
        \           An Object Identifier that identifies the subagent.\n            Subagents
        that do not support such an notion may send a null\n            Object Identifier.\n
        \     o.descr\n            An Octet String containing a DisplayString describing
        the\n            subagent.\n"
      title: 6.2.1. The agentx-Open-PDU
    - contents:
      - "6.2.2. The agentx-Close-PDU\n   An agentx-Close-PDU issued by either a subagent
        or the master agent\n   terminates an AgentX session.\n   (AgentX header)\n
        \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |
        h.version (1) |  h.type (2)   |    h.flags    |  <reserved>   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                          h.sessionID                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                        h.transactionID                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                           h.packetID                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                        h.payload_length                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |
        \ c.reason     |                     <reserved>                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  An agentx-Close-PDU contains the following field:\n           c.reason\n
        \           An enumerated value that gives the reason that the master\n            agent
        or subagent closed the AgentX session.  This field may\n            take one
        of the following values:\n            reasonOther(1)\n                 None
        of the following reasons\n            reasonParseError(2)\n                 Too
        many AgentX parse errors from peer\n            reasonProtocolError(3)\n                 Too
        many AgentX protocol errors from peer\n            reasonTimeouts(4)\n                 Too
        many timeouts waiting for peer\n            reasonShutdown(5)\n                 Sending
        entity is shutting down\n            reasonByManager(6)\n                 Due
        to Set operation; this reason code can be used only\n                 by the
        master agent, in response to an SNMP management\n                 request.\n"
      title: 6.2.2. The agentx-Close-PDU
    - contents:
      - "6.2.3. The agentx-Register-PDU\n   An agentx-Register-PDU is generated by
        a subagent for each region of\n   the MIB variable naming tree (within one
        or more contexts) that it\n   wishes to support.\n    (AgentX header)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | h.version (1) |  h.type (3)   |    h.flags    |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                          h.sessionID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.transactionID                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                           h.packetID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.payload_length                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (r.context) (OPTIONAL)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Octet String Length (L)                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet 1      |  Octet 2      |   Octet 3     |   Octet 4     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet L - 1  |  Octet L      |       Padding (as required)   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |
        \ r.timeout    |  r.priority   | r.range_subid |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (r.subtree)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  n_subid      |  prefix       |      0        |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #1                                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #n_subid                           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (r.upper_bound)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             optional upper-bound sub-identifier               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  An agentx-Register-PDU contains the following fields:\n      r.context\n
        \           An optional non-default context.\n      r.timeout\n            The
        length of time, in seconds, that a master agent should\n            allow
        to elapse after dispatching a message on a session\n            before it
        regards the subagent as not responding.  r.timeout\n            applies only
        to messages that concern MIB objects within\n            r.subtree.  It overrides
        both the session's default value\n            (if any) indicated when the
        AgentX session with the master\n            agent was established, and the
        master agent's default\n            timeout.  The default value for r.timeout
        is 0 (no\n            override).\n      r.priority\n            A value between
        1 and 255, used to achieve a desired\n            configuration when different
        sessions register identical or\n            overlapping regions.  Subagents
        with no particular knowledge\n            of priority should register with
        the default value of 127.\n            In the master agent's dispatching algorithm,
        smaller values\n            of r.priority take precedence over larger values,
        as\n            described in section 7.1.4.1, \"Handling Duplicate and\n            Overlapping
        Subtrees\".\n      r.subtree\n            An Object Identifier that names
        the basic subtree of a MIB\n            region for which a subagent indicates
        its support. The term\n            \"subtree\" is used generically here, it
        may represent a\n            fully-qualified instance name, a partial instance
        name, a\n            MIB table, an entire MIB, etc.\n            The choice
        of what to register is implementation-specific;\n            this memo does
        not specify permissible values.  Standard\n            practice however is
        for a subagent to register at the\n            highest level of the naming
        tree that makes sense.\n            Registration of fully- qualified instances
        is typically done\n            only when a subagent can perform management
        operations only\n            on particular rows of a conceptual table.\n            If
        r.subtree is in fact a fully qualified instance name, the\n            INSTANCE_REGISTRATION
        bit in h.flags must be set, otherwise\n            it must be cleared.  The
        master agent may save this\n            information to optimize subsequent
        operational dispatching.\n      r.range_subid\n            Permits specifying
        a range in place of one of r.subtree's\n            sub-identifiers.  If this
        value is 0, no range is being\n            specified and there is no r.upper_bound
        field present in the\n            PDU. In this case the MIB region being registered
        is the\n            single subtree named by r.subtree.\n            Otherwise
        the \"r.range_subid\"-th sub-identifier in r.subtree\n            is a range
        lower bound, and the range upper bound sub-\n            identifier (r.upper_bound)
        immediately follows r.subtree.\n            In this case the MIB region being
        registered is the union of\n            the subtrees formed by enumerating
        this range.\n            Note that r.range_subid indicates the (1-based) index
        of\n            this sub-identifier within the OID represented by r.subtree,\n
        \           regardless of whether or not r.subtree is encoded using a\n            prefix.
        (See the example below.)\n      r.upper_bound\n            The upper bound
        of a sub-identifier's range.  This field is\n            present only if r.range_subid
        is not 0.\n            The use of r.range_subid and r.upper_bound provide
        a general\n            shorthand mechanism for specifying a MIB region. For\n
        \           example, if r.subtree is the OID 1.3.6.1.2.1.2.2.1.1.7,\n            r.range_subid
        is 10, and r.upper_bound is 22, the specified\n            MIB region can
        be denoted 1.3.6.1.2.1.2.2.1.[1-22].7.\n            Registering this region
        is equivalent to registering the\n            union of subtrees\n             1.3.6.1.2.1.2.2.1.1.7\n
        \            1.3.6.1.2.1.2.2.1.2.7\n             1.3.6.1.2.1.2.2.1.3.7\n             ...\n
        \            1.3.6.1.2.1.2.2.1.22.7\n            One expected use of this
        mechanism is registering a\n            conceptual row with a single PDU.
        \ In the example above, the\n            MIB region happens to be row 7 of
        the RFC 1573 ifTable.  The\n            actual PDU would be:\n   (AgentX header)\n
        \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |
        h.version (1) |  h.type (3)   |    h.flags    |  <reserved>   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                          h.sessionID                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                        h.transactionID                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                           h.packetID                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                        h.payload_length                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |
        \  r.timeout   |  r.priority   | 10            |  <reserved>   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  (r.subtree)\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  | 6             |  2            |  0            |  <reserved>   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  | 1                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  | 2                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  | 2                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  | 1                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  | 1                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  | 7                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  (r.upper_bound)\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  | 22                                                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Note again that here r.range_subid is 10, even though n_subid in\n   r.subtree
        is only 6.\n   r.range_subid may be used at any level within a subtree, it
        need not\n   represent row-level registration.  This mechanism may be used
        in any\n   way that is convenient for a subagent to achieve its registrations.\n"
      title: 6.2.3. The agentx-Register-PDU
    - contents:
      - "6.2.4. The agentx-Unregister-PDU\n   The agentx-Unregister-PDU is sent by
        a subagent to remove a MIB\n   region that was previously registered on this
        session.\n    (AgentX header)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | h.version (1) |  h.type (4)   |    h.flags    |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                          h.sessionID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.transactionID                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                           h.packetID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.payload_length                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (u.context) OPTIONAL\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Octet String Length (L)                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet 1      |  Octet 2      |   Octet 3     |   Octet 4     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet L - 1  |  Octet L      |       Padding (as required)   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |
        \   <reserved> |  u.priority   | u.range_subid |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (u.subtree)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  n_subid      |  prefix       |      0        |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #1                                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #n_subid                           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (u.upper_bound)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             optional upper-bound sub-identifier               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  An agentx-Unregister-PDU contains the following fields:\n      u.context\n
        \           An optional non-default context.\n      u.priority\n            The
        priority at which this region was originally registered.\n      u.subtree\n
        \           Indicates a previously-registered region of the MIB that a\n            subagent
        no longer wishes to support.\n      u.range_subid\n            Indicates a
        sub-identifier in u.subtree is a range lower\n            bound.\n      u.upper_bound\n
        \           The upper bound of the range sub-identifier.  This field is\n
        \           present in the PDU only if u.range_subid is not 0.\n"
      title: 6.2.4. The agentx-Unregister-PDU
    - contents:
      - "6.2.5. The agentx-Get-PDU\n    (AgentX header)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | h.version (1) |  h.type (5)   |    h.flags    |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                          h.sessionID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.transactionID                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                           h.packetID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.payload_length                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (g.context) OPTIONAL\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Octet String Length (L)                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet 1      |  Octet 2      |   Octet 3     |   Octet 4     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet L - 1  |  Octet L      |       Padding (as required)   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (g.sr)\n    (start 1)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  n_subid      |  prefix       |  include      |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #1                                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #n_subid                           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (end 1)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | 0             | 0             | 0             |       0       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    (start n)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  n_subid      |  prefix       |  include      |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #1                                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #n_subid                           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (end n)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | 0             | 0             | 0             |       0       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     An agentx-Get-PDU contains the following fields:\n      g.context\n
        \           An optional non-default context.\n      g.sr\n            A SearchRangeList
        containing the requested variables for\n            this session.  Within
        the agentx-Get-PDU, the Ending OIDs\n            within SearchRanges are null-valued
        Object Identifiers.\n"
      title: 6.2.5. The agentx-Get-PDU
    - contents:
      - "6.2.6. The agentx-GetNext-PDU\n    (AgentX header)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | h.version (1) |  h.type (6)   |    h.flags    |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                          h.sessionID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.transactionID                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                           h.packetID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.payload_length                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (g.context) OPTIONAL\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Octet String Length (L)                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet 1      |  Octet 2      |   Octet 3     |   Octet 4     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet L - 1  |  Octet L      |       Padding (as required)   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (g.sr)\n    (start 1)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  n_subid      |  prefix       |  include      |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #1                                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #n_subid                           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (end 1)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  n_subid      |  prefix       |      0        |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #1                                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #n_subid                           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    (start n)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  n_subid      |  prefix       |  include      |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #1                                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #n_subid                           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (end n)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  n_subid      |  prefix       |      0        |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #1                                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #n_subid                           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n     An agentx-GetNext-PDU contains the following fields:\n      g.context\n
        \           An optional non-default context.\n      g.sr\n            A SearchRangeList
        containing the requested variables for\n            this session.\n"
      title: 6.2.6. The agentx-GetNext-PDU
    - contents:
      - "6.2.7. The agentx-GetBulk-PDU\n   (AgentX header)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | h.version (1) |  h.type (7)   |    h.flags    |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                          h.sessionID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.transactionID                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                           h.packetID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.payload_length                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (g.context) OPTIONAL\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Octet String Length (L)                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet 1      |  Octet 2      |   Octet 3     |   Octet 4     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet L - 1  |  Octet L      |       Padding (as required)   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |
        \            g.non_repeaters   |     g.max_repetitions         |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (g.sr)\n    ...\n   An agentx-GetBulk-PDU contains the following fields:\n
        \     g.context\n            An optional non-default context.\n      g.non_repeaters\n
        \           The number of variables in the SearchRangeList that are not\n
        \           repeaters.\n      g.max_repetitions\n            The maximum number
        of repetitions requested for repeating\n            variables.\n      g.sr\n
        \           A SearchRangeList containing the requested variables for\n            this
        session.\n"
      title: 6.2.7. The agentx-GetBulk-PDU
    - contents:
      - "6.2.8. The agentx-TestSet-PDU\n    (AgentX header)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | h.version (1) |  h.type (8)   |    h.flags    |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                          h.sessionID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.transactionID                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                           h.packetID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.payload_length                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (t.context) OPTIONAL\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Octet String Length (L)                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet 1      |  Octet 2      |   Octet 3     |   Octet 4     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet L - 1  |  Octet L      |       Padding (as required)   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (t.vb)\n    (VarBind 1)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |          v.type               |        <reserved>             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  n_subid      |  prefix       |      0        |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                       sub-identifier #1                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                       sub-identifier #n_subid                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                       data                                    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                       data                                    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    (VarBind n)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |          v.type               |        <reserved>             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  n_subid      |  prefix       |      0        |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                       sub-identifier #1                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                       sub-identifier #n_subid                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                       data                                    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                       data                                    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  An agentx-TestSet-PDU contains the following fields:\n      t.context\n
        \           An optional non-default context.\n      t.vb\n            A VarBindList
        containing the requested VarBinds for this\n            subagent.\n"
      title: 6.2.8. The agentx-TestSet-PDU
    - contents:
      - "6.2.9. The agentx-CommitSet, -UndoSet, -CleanupSet PDUs\n   These PDUs consist
        of the AgentX header only.\n   The agentx-CommitSet-, -UndoSet-, and -Cleanup-PDUs
        are used in\n   processing an SNMP SetRequest operation.\n"
      title: 6.2.9. The agentx-CommitSet, -UndoSet, -CleanupSet PDUs
    - contents:
      - "6.2.10. The agentx-Notify-PDU\n   An agentx-Notify-PDU is sent by a subagent
        to cause the master agent\n   to forward a notification.\n    (AgentX header)\n
        \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |
        h.version (1) |  h.type (12)  |    h.flags    |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                          h.sessionID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.transactionID                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                           h.packetID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.payload_length                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (n.context) OPTIONAL\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Octet String Length (L)                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet 1      |  Octet 2      |   Octet 3     |   Octet 4     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet L - 1  |  Octet L      |       Padding (as required)   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (n.vb)\n    ...\n   An agentx-Notify-PDU contains the following fields:\n
        \     n.context\n            An optional non-default context.\n      n.vb\n
        \           A VarBindList whose contents define the actual PDU to be\n            sent.
        \ This memo places the following restrictions on its\n            contents:\n
        \              -  If the subagent supplies sysUpTime.0, it must be\n                  present
        as the first varbind.\n               -  snmpTrapOID.0 must be present, as
        the second varbind\n                  if sysUpTime.0 was supplied, as the
        first if it was\n                  not.\n"
      title: 6.2.10. The agentx-Notify-PDU
    - contents:
      - "6.2.11. The agentx-Ping-PDU\n   The agentx-Ping-PDU is sent by a subagent
        to the master agent to\n   monitor the master agent's ability to receive and
        send AgentX PDUs\n   over their AgentX session.\n    (AgentX header)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | h.version (1) |  h.type (13)  |    h.flags    |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                          h.sessionID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.transactionID                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                           h.packetID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.payload_length                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (p.context) OPTIONAL\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Octet String Length (L)                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet 1      |  Octet 2      |   Octet 3     |   Octet 4     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet L - 1  |  Octet L      |       Padding (as required)   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  An agentx-Ping-PDU may contain the following field:\n      p.context\n
        \           An optional non-default context.\n   Using p.context a subagent
        can retrieve the sysUpTime value for a\n   specific context, if required.\n"
      title: 6.2.11. The agentx-Ping-PDU
    - contents:
      - "6.2.12. The agentx-IndexAllocate-PDU\n   An agentx-IndexAllocate-PDU is sent
        by a subagent to request\n   allocation of a value for specific index objects.
        \ Refer to section\n   7.1.4.2, \"Registering Stuff\", for suggested usage.\n
        \   (AgentX header)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | h.version (1) |  h.type (14)  |    h.flags    |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                          h.sessionID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.transactionID                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                           h.packetID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.payload_length                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (i.context) OPTIONAL\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Octet String Length (L)                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet 1      |  Octet 2      |   Octet 3     |   Octet 4     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet L - 1  |  Octet L      |       Padding (as required)   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (i.vb)\n    ...\n   An agentx-IndexAllocate-PDU contains the following
        fields:\n      i.context\n            An optional non-default context.\n      i.vb\n
        \           A VarBindList containing the index names and values\n            requested
        for allocation.\n"
      title: 6.2.12. The agentx-IndexAllocate-PDU
    - contents:
      - "6.2.13. The agentx-IndexDeallocate-PDU\n   An agentx-IndexDeallocate-PDU
        is sent by a subagent to release\n   previously allocated index values.\n
        \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |
        h.version (1) |  h.type (15)  |    h.flags    |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                          h.sessionID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.transactionID                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                           h.packetID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.payload_length                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (i.context) OPTIONAL\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Octet String Length (L)                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet 1      |  Octet 2      |   Octet 3     |   Octet 4     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet L - 1  |  Octet L      |       Padding (as required)   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (i.vb)\n    ...\n   An agentx-IndexDeallocate-PDU contains the following
        fields:\n      i.context\n            An optional non-default context.\n      i.vb\n
        \           A VarBindList containing the index names and values to be\n            released.\n"
      title: 6.2.13. The agentx-IndexDeallocate-PDU
    - contents:
      - "6.2.14. The agentx-AddAgentCaps-PDU\n   An agentx-AddAgentCaps-PDU is generated
        by a subagent to inform the\n   master agent of agent capabilities for the
        specified session.\n    (AgentX header)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | h.version (1) |  h.type (16)  |    h.flags    |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                          h.sessionID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.transactionID                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                           h.packetID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.payload_length                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (a.context) (OPTIONAL)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Octet String Length (L)                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet 1      |  Octet 2      |   Octet 3     |   Octet 4     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet L - 1  |  Octet L      |       Optional Padding        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (a.id)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  n_subid      |  prefix       |      0        |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #1                                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #n_subid                           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (a.descr)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Octet String Length (L)                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet 1      |  Octet 2      |   Octet 3     |   Octet 4     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet L - 1  |  Octet L      |       Optional Padding        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  An agentx-AddAgentCaps-PDU contains the following fields:\n      a.context\n
        \           An optional non-default context.\n      a.id\n            An Object
        Identifier containing the value of an invocation\n            of the AGENT-CAPABILITIES
        macro, which the master agent\n            exports as a value of sysORID for
        the indicated context.\n            (Recall that the value of an invocation
        of an AGENT-\n            CAPABILITIES macro is an object identifier that
        describes a\n            precise level of support with respect to implemented
        MIB\n            modules.  A more complete discussion of the AGENT-\n            CAPABILITIES
        macro and related sysORID values can be found\n            in section 6 of
        STD 58, RFC 2580 [7].)\n      a.descr\n            An Octet String containing
        a DisplayString to be used as the\n            value of sysORDescr corresponding
        to the sysORID value\n            above.\n"
      title: 6.2.14. The agentx-AddAgentCaps-PDU
    - contents:
      - "6.2.15. The agentx-RemoveAgentCaps-PDU\n   An agentx-RemoveAgentCaps-PDU
        is generated by a subagent to request\n   that the master agent stop exporting
        a particular value of sysORID.\n   This value must have previously been advertised
        by the subagent in an\n   agentx-AddAgentCaps-PDU for this session.\n    (AgentX
        header)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | h.version (1) |  h.type (17)  |    h.flags    |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                          h.sessionID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.transactionID                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                           h.packetID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.payload_length                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (a.context) (OPTIONAL)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Octet String Length (L)                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet 1      |  Octet 2      |   Octet 3     |   Octet 4     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Octet L - 1  |  Octet L      |       Optional Padding        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   (a.id)\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  n_subid      |  prefix       |       0       |   <reserved>  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #1                                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             sub-identifier #n_subid                           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  An agentx-RemoveAgentCaps-PDU contains the following fields:\n      a.context\n
        \           An optional non-default context.\n      a.id\n            An ObjectIdentifier
        containing the value of sysORID that\n            should no longer be exported.\n"
      title: 6.2.15. The agentx-RemoveAgentCaps-PDU
    - contents:
      - "6.2.16. The agentx-Response-PDU\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   | h.version (1) |  h.type (18)  |    h.flags    |  <reserved>   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                          h.sessionID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.transactionID                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                           h.packetID                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                        h.payload_length                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |
        \                       res.sysUpTime                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |             res.error         |     res.index                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ...\n   An agentx-Response-PDU contains the following fields:\n       h.sessionID\n
        \           If this is a response to an agentx-Open-PDU, then it\n            contains
        the new and unique sessionID (as assigned by the\n            master agent)
        for this session.\n            Otherwise it must be identical to the h.sessionID
        value in\n            the PDU to which this PDU is a response.\n      h.transactionID\n
        \           Must be identical to the h.transactionID value in the PDU to\n
        \           which this PDU is a response.\n            In an agentx response
        PDU from the master agent to the\n            subagent, the value of h.transactionID
        has no significance\n            and can be ignored by the subagent.\n      h.packetID\n
        \           Must be identical to the h.packetID value in the PDU to\n            which
        this PDU is a response.\n      res.sysUpTime\n            This field contains
        the current value of sysUpTime for the\n            context indicated within
        the PDU to which this PDU is a\n            response.   It is relevant only
        in agentx response PDUs sent\n            from the master  agent to a subagent
        in response to the set\n            of administrative PDUs listed in section
        6.1, \"AgentX PDU\n            Header\".\n            In an agentx response
        PDU from the subagent to the master\n            agent, the value of res.sysUpTime
        has no significance and is\n            ignored by the master agent.\n      res.error\n
        \           Indicates error status.  Within responses to the set of\n            \"administrative\"
        PDU types listed in section 6.1, \"AgentX\n            PDU Header\", values
        are limited to the following:\n               noAgentXError              (0),\n
        \              openFailed                 (256),\n               notOpen                    (257),\n
        \              indexWrongType             (258),\n               indexAlreadyAllocated
        \     (259),\n               indexNoneAvailable         (260),\n               indexNotAllocated
        \         (261),\n               unsupportedContext         (262),\n               duplicateRegistration
        \     (263),\n               unknownRegistration        (264),\n               unknownAgentCaps
        \          (265),\n               parseError                 (266),\n               requestDenied
        \             (267),\n               processingError            (268)\n            Within
        responses to the set of \"SNMP request processing\" PDU\n            types
        listed in section 6.1, \"AgentX PDU Header\", values may\n            also
        include those defined for errors in the SNMPv2 PDU (RFC\n            1905
        [13]).\n      res.index\n            In error cases, this is the index of
        the failed variable\n            binding within a received request PDU.  (Note:
        As explained\n            in section 5.4, \"Value Representation\", the index
        values of\n            variable bindings within a variable binding list are
        1-\n            based.)\n   A VarBindList may follow res.index, depending
        on which AgentX PDU is\n   being responded to.  These data are specified in
        the subsequent\n   elements of procedure.\n"
      title: 6.2.16. The agentx-Response-PDU
    title: 6.2. AgentX PDUs
  title: 6. Protocol Definitions
- contents:
  - "7. Elements of Procedure\n   This section describes the actions of protocol entities
    (master\n   agents and subagents) implementing the AgentX protocol.  Note,\n   however,
    that it is not intended to constrain the internal\n   architecture of any conformant
    implementation.\n   The actions of AgentX protocol entities can be broadly categorized\n
    \  under two headings, each of which is described separately:\n   (1)  processing
    AgentX administrative messages (e.g., registration\n        requests from a subagent
    to a master agent); and\n   (2)  processing SNMP messages (the coordinated actions
    of a master\n        agent and one or more subagents in processing, for example,
    a\n        received SNMP GetRequest-PDU).\n"
  - contents:
    - "7.1. Processing AgentX Administrative Messages\n   This subsection describes
      the actions of AgentX protocol entities in\n   processing AgentX administrative
      messages.  Such messages include\n   those involved in establishing and terminating
      an AgentX session\n   between a subagent and a master agent, those by which
      a subagent\n   requests allocation of instance index values, and those by which
      a\n   subagent communicates to a master agent which MIB regions it\n   supports.\n
      \  Processing is defined specifically for each PDU type in its own\n   section.
      \ For the master agent, many of these PDU types require the\n   same initial
      processing steps.  This common processing is defined\n   here, and referenced
      as needed in the PDU type-specific descriptions.\n   Common Processing:\n   The
      master agent initially processes a received AgentX PDU as\n   follows:\n      1)
      An agentx-Response-PDU is created, res.sysUpTime is set to the\n         value
      of sysUpTime.0 for the default context, res.error is set\n         to `noAgentXError',
      and res.index is set to 0.\n      2) If the received PDU cannot be parsed, res.error
      is set to `\n         parseError'.  Examples of a parse error are:\n            -
      PDU length (h.payload) too short to contain current\n               construct
      (Object Identifier header indicates more sub-\n               identifiers, VarBind
      v.type indicates data follows, etc)\n            - An unrecognized value is
      encountered for h.type, v.type,\n               etc.\n      3) Otherwise, if
      h.sessionID does not correspond to a currently\n         established session
      with this subagent, res.error is set to\n         `notOpen'.\n      4) Otherwise,
      if the NON_DEFAULT_CONTEXT bit is set and the master\n         agent does not
      support the indicated context, res.error is set\n         to `unsupportedContext'.
      \ If the master agent does support the\n         indicated context, the value
      of res.sysUpTime is set to the\n         value of sysUpTime.0 for that context.\n
      \     Note: Non-default contexts might be added on the fly by the master\n            agent,
      or the master agent might require such non-default\n            contexts to
      be pre-configured.  The choice is\n            implementation-specific.\n      5)
      If resources cannot be allocated or some other condition\n         prevents
      processing, res.error is set to `processingError'.\n      6) At this point,
      if res.error is not `noAgentXError', the\n         received PDU is not processed
      further.  If the received PDU's\n         header was successfully parsed, the
      AgentX-Response-PDU is sent\n         in reply.  If the received PDU contained
      a VarBindList which\n         was successfully parsed, the AgentX-Response-PDU
      contains the\n         identical VarBindList.  If the received PDU's header
      was not\n         successfully parsed or for some other reason the master agent\n
      \        cannot send a reply, processing is complete.\n"
    - contents:
      - "7.1.1.  Processing the agentx-Open-PDU\n   When the master agent receives
        an agentx-Open-PDU, it processes it as\n   follows:\n   1) An agentx-Response-PDU
        is created, res.sysUpTime is set to the\n      value of sysUpTime.0 for the
        default context, res.error is set to\n      `noAgentXError', and res.index
        is set to 0.\n   2) If the received PDU cannot be parsed, res.error is set
        to\n      `parseError'.\n   3) Otherwise, if the master agent is unable to
        open an AgentX session\n      for any reason, res.error is set to `openFailed'.\n
        \  4) Otherwise:  The master agent assigns a sessionID to the new\n      session
        and puts the value in the h.sessionID field of the\n      agentx-Response-PDU.
        \ This value must be unique among all existing\n      open sessions.\n      The
        master agent retains session-specific information from the PDU\n      for
        this session:\n      -  The NETWORK_BYTE_ORDER value in h.flags is retained.
        \ All\n         subsequent AgentX protocol operations initiated by the master\n
        \        agent for this session must use this byte ordering and set this\n
        \        bit accordingly.\n      The subagent typically sets this bit to correspond
        to its native\n      byte ordering, and typically does not vary byte ordering
        for an\n      initiated session.  The master agent must be able to decode
        each\n      PDU according to the h.flag NETWORK_BYTE_ORDER bit in the PDU,
        but\n      does not need to toggle its retained value for the session if the\n
        \     subagent varies its byte ordering.\n      -  The o.timeout value is
        used in calculating response timeout\n         conditions for this session.
        This field is also referenced in\n         the AgentX MIB (a work-in-progress)
        by the agentxSessionTimeout\n         object.\n      -  The o.id and o.descr
        fields are used for informational\n         purposes.  These two fields are
        also referenced in the AgentX\n         MIB (a work-in-progress) by the agentxSessionObjectID
        object,\n         and by the agentxSessionDescr object.\n   5) The agentx-Response-PDU
        is sent with the res.error field\n      indicating the result of the session
        initiation.\n   If processing was successful, an AgentX session is considered\n
        \  established between the master agent and the subagent.  An AgentX\n   session
        is a distinct channel for the exchange of AgentX protocol\n   messages between
        a master agent and one subagent, qualified by the\n   session-specific attributes
        listed in 4) above.  AgentX session\n   establishment is initiated by the
        subagent.  An AgentX session can be\n   terminated by either the master agent
        or the subagent.\n"
      title: 7.1.1.  Processing the agentx-Open-PDU
    - contents:
      - "7.1.2. Processing the agentx-IndexAllocate-PDU\n   When the master agent
        receives an agentx-IndexAllocate-PDU, it\n   performs the common processing
        described in section 7.1, \"Processing\n   AgentX Administrative Messages\".
        \ If as a result res.error is\n   `noAgentXError', processing continues as
        follows:\n   1) Each VarBind in the VarBindList is processed until either
        all are\n      successful, or one fails.  If any VarBind fails, the agentx-\n
        \     Response-PDU is sent in reply containing the original VarBindList,\n
        \     with res.index set to indicate the failed VarBind, and with\n      res.error
        set as described subsequently.  All other VarBinds are\n      ignored; no
        index values are allocated.\n      VarBinds are processed as follows:\n      -
        \ v.name is the OID prefix of the MIB OBJECT-TYPE for which a\n         value
        is to be allocated.\n      - v.type is the syntax of the MIB OBJECT-TYPE for
        which a value is\n         to be allocated.\n      -  v.data indicates the
        specific index value requested.  If the\n         NEW_INDEX or the ANY_INDEX
        bit is set, the actual value in\n         v.data is ignored and an appropriate
        index value is generated.\n      a) If there are no currently allocated index
        values for v.name in\n         the indicated context, and v.type does not
        correspond to a\n         valid index type value, the VarBind fails and res.error
        is set\n         to `indexWrongType'.\n      b) If there are currently allocated
        index values for v.name in the\n         indicated context, but the syntax
        of those values does not\n         match v.type, the VarBind fails and res.error
        is set to\n         `indexWrongType'.\n      c) Otherwise, if both the NEW_INDEX
        and ANY_INDEX bits are clear,\n         allocation of a specific index value
        is being requested.  If\n         the requested index is already allocated
        for v.name in the\n         indicated context, the VarBind fails and res.error
        is set to\n         `indexAlreadyAllocated'.\n      d) Otherwise, if the NEW_INDEX
        bit is set, the master agent should\n         generate the next available
        index value for v.name in the\n         indicated context, with the constraint
        that this value must not\n         have been allocated (even if subsequently
        released) to any\n         subagent since the last re-initialization of the
        master agent.\n         If no such value can be generated, the VarBind fails
        and\n         res.error is set to `indexNoneAvailable'.\n      e) Otherwise,
        if the ANY_INDEX bit is set, the master agent should\n         generate an
        index value for v.name in the indicated context,\n         with the constraint
        that this value is not currently allocated\n         to any subagent.  If
        no such value can be generated, then the\n         VarBind fails and res.error
        is set to `indexNoneAvailable'.\n   2) If all VarBinds are processed successfully,
        the agentx-Response-\n      PDU is sent in reply with res.error set to `noAgentXError'.
        \ A\n      VarBindList is included that is identical to the one sent in the\n
        \     agentx-IndexAllocate-PDU, except that VarBinds requesting a\n      NEW_INDEX
        or ANY_INDEX value are generated with an appropriate\n      value.\n      See
        section 7.1.4.2, \"Registering Stuff\" for more information on\n      how
        subagents should perform index allocations.\n"
      title: 7.1.2. Processing the agentx-IndexAllocate-PDU
    - contents:
      - "7.1.3. Processing the agentx-IndexDeallocate-PDU\n   When the master agent
        receives an agentx-IndexDeallocate-PDU, it\n   performs the common processing
        described in section 7.1, \"Processing\n   AgentX Administrative Messages\".
        \ If as a result res.error is\n   `noAgentXError', processing continues as
        follows:\n   1) Each VarBind in the VarBindList is processed until either
        all are\n      successful, or one fails.  If any VarBind fails, the agentx-\n
        \     Response-PDU is sent in reply, containing the original\n      VarBindList,
        with res.index set to indicate the failed VarBind,\n      and with res.error
        set as described subsequently.  All other\n      VarBinds are ignored; no
        index values are released.\n      VarBinds are processed as follows:\n      -
        \ v.name is the name of the index for which a value is to be\n         released\n
        \     -  v.type is the syntax of the index object\n      -  v.data indicates
        the specific index value to be released.  The\n         NEW_INDEX and ANY_INDEX
        bits are ignored.\n      a) If the index value for the named index is not
        currently\n         allocated to this session, the VarBind fails and res.error
        is\n         set to `indexNotAllocated'.\n   2) If all VarBinds are processed
        successfully, res.error is set to\n      `noAgentXError' and the agentx-Response-PDU
        is sent.  A\n      VarBindList is included which is identical to the one sent
        in the\n      agentx-IndexDeallocate-PDU.\n   All released index values are
        now available, and may be used in\n   response to subsequent allocation requests
        for ANY_INDEX values and\n   in response to subsequent allocation requests
        for the particular\n   index value.\n"
      title: 7.1.3. Processing the agentx-IndexDeallocate-PDU
    - contents:
      - "7.1.4. Processing the agentx-Register-PDU\n   When the master agent receives
        an agentx-Register-PDU, it performs\n   the common processing described in
        section 7.1, \"Processing AgentX\n   Administrative Messages\".  If as a result
        res.error is\n   `noAgentXError', processing continues as follows:\n   If
        any of the union of subtrees defined by this MIB region is exactly\n   the
        same as any subtree defined by a MIB region currently registered\n   within
        the indicated context, those subtrees are termed \"duplicate\n   subtrees\".\n
        \  If any of the union of subtrees defined by this MIB region overlaps,\n
        \  or is itself overlapped by, any subtree defined by a MIB region\n   currently
        registered within the indicated context, those subtrees are\n   termed \"overlapping
        subtrees\".\n   1) If this registration would result in duplicate subtrees
        registered\n      with the same value of r.priority, the request fails and
        an\n      agentx-Response-PDU is returned with res.error set to\n      `duplicateRegistration'.\n
        \  2) Otherwise, if the master agent does not wish to permit this\n      registration
        for implementation-specific reasons, the request\n      fails and an agentx-Response-PDU
        is returned with res.error set to\n      `requestDenied'.\n   3) Otherwise,
        the agentx-Response-PDU is returned with res.error set\n      to `noAgentXError'.\n
        \     The master agent adds this MIB region to its registration data\n      store
        for the indicated context, to be considered during the\n      dispatching
        phase for subsequently received SNMP protocol\n      messages.\n"
      - contents:
        - "7.1.4.1.  Handling Duplicate and Overlapping Subtrees\n   As a result of
          this registration algorithm there are likely to be\n   duplicate and/or
          overlapping subtrees within the registration data\n   store of the master
          agent.  Whenever the master agent's dispatching\n   algorithm (see section
          7.2.1, \"Dispatching AgentX PDUs\") determines\n   that there are multiple
          subtrees that could potentially contain the\n   same MIB object instances,
          the master agent selects one to use,\n   termed the 'authoritative region',
          as follows:\n      1) Choose the one whose original agentx-Register-PDU
          r.subtree\n         contained the most subids, i.e., the most specific r.subtree.\n
          \        Note: The presence or absence of a range subid has no bearing\n
          \        on how \"specific\" one object identifier is compared to another.\n
          \     2) If still ambiguous, there were duplicate subtrees.  Choose the\n
          \        one whose original agentx-Register-PDU specified the smaller\n
          \        value of r.priority.\n"
        title: 7.1.4.1.  Handling Duplicate and Overlapping Subtrees
      - contents:
        - "7.1.4.2.  Registering Stuff\n   This section describes more fully how AgentX
          subagents use the\n   agentx-IndexAllocate-PDU and agentx-Register-PDU to
          achieve desired\n   configurations.\n"
        - contents:
          - "7.1.4.2.1.     Registration Priority\n   The r.priority field in the
            agentx-Register-PDU is intended to be\n   manipulated by human administrators
            to achieve a desired subagent\n   configuration.  Typically this would
            be needed where a legacy\n   application registers a specific subtree,
            and a different\n   (configurable) application may need to become authoritative
            for the\n   identical subtree.\n   The result of this configuration (the
            same subtree registered on\n   different sessions with different priorities)
            is that the session\n   using the better priority (see section 7.1.4.1,
            \"Handling Duplicate\n   and Overlapping Subtrees\") will be authoritative.
            \ The other session\n   will simply never be dispatched to.\n   This is
            useful in the case described above, but is NOT useful in\n   other cases,
            particularly when subagents share tables indexed by\n   arbitrary values
            (see below).  In general, subagents should register\n   using the default
            priority (127).\n"
          title: 7.1.4.2.1.     Registration Priority
        - contents:
          - "7.1.4.2.2.     Index Allocation\n   Index allocation is a service provided
            by an AgentX master agent.  It\n   provides generic support for sharing
            MIB conceptual tables among\n   subagents who are assumed to have no knowledge
            of each other.\n   The master agent maintains a database of index objects
            (OIDs), and,\n   for each index, the values that have been allocated for
            it.  It is\n   unaware of what MIB variables (if any) the index objects
            represent.\n   By convention, subagents use the MIB variable listed in
            the INDEX\n   clause as the index object for which values must be allocated.
            \ For\n   tables indexed by multiple variables, values may be allocated
            for\n   each index (although this is frequently unnecessary; see example
            2\n   below).  The subagent may request allocation of\n          a) a
            specific index value\n          b) an index value that is not currently
            allocated\n          c) an index value that has never been allocated\n
            \  The last two alternatives reflect the uniqueness and constancy\n   requirements
            present in many MIB specifications for arbitrary integer\n   indexes (e.g.,
            ifIndex in the IF-MIB (RFC 2233 [19]),\n   snmpFddiSMTIndex in the FDDI
            MIB (RFC 1285 [20]), or\n   sysApplInstallPkgIndex in the System Application
            MIB (RFC 2287\n   [21])).  The need for subagents to share tables using
            such indexes is\n   the main motivation for index allocation in AgentX.\n
            \  It is important to note that index allocation and MIB region\n   registration
            are not coupled in the master agent. The current state\n   of index allocations
            is not considered when processing registration\n   requests, and the current
            registry is not considered when processing\n   index allocation requests.
            \ (This is mainly to accommodate non-AgentX\n   subagents.)\n   AgentX
            subagents should follow the model of \"first request allocation\n   of
            an index, then register the corresponding region\".  Then a\n   successful
            index allocation request gives a subagent a good hint (but\n   no guarantee)
            of what it should be able to register.  The\n   registration may fail
            (with `duplicateRegistration') because some\n   other subagent session
            has already registered that row of the table.\n   The recommended mechanism
            for subagents to register conceptual rows\n   in a shared table is\n   1)
            Successfully allocate an index value.\n   2) Use that value to fully qualify
            the MIB region(s), and attempt to\n      register using the default priority.\n
            \  3) If the registration fails with `duplicateRegistration' deallocate\n
            \     the previously allocated index value(s) for this row and go to\n
            \     step 1).\n   Note that index allocation is necessary only when the
            index in\n   question is an arbitrary value, and hence the subagent has
            no other\n   reasonable way to determine which index values to use.  When
            index\n   values have intrinsic meaning it is not expected that subagents
            will\n   allocate their index values.\n   For example, RFC 1514's table
            of running software processes\n   (hrSWRunTable) is indexed by the system's
            native process identifier\n   (pid).  A subagent implementing the row
            of hrSWRunTable corresponding\n   to its own process would simply register
            the region defining that\n   row's object instances without allocating
            index values.\n"
          title: 7.1.4.2.2.     Index Allocation
        - contents:
          - "7.1.4.2.3.     Examples\n   Example 1:\n      A subagent implements an
            interface, and wishes to register a\n      single row of the RFC 2233
            ifTable.  It requests an allocation for\n      the index object \"ifIndex\",
            for a value that has never been\n      allocated (since ifIndex values
            must be unique).  The master agent\n      returns the value \"7\".\n      The
            subagent now attempts to register row 7 of ifTable, by\n      specifying
            a MIB region in the agentx-Register-PDU of\n      1.3.6.1.2.1.2.2.1.[1-22].7.
            \ If the registration succeeds, no\n      further processing is required.
            \ The master agent will dispatch to\n      this subagent correctly.\n
            \     If the registration failed with `duplicateRegistration', the\n      subagent
            should deallocate the failed index, request allocation of\n      a new
            index i, and attempt to register ifTable.[1-22].i, until\n      successful.\n
            \  Example 2:\n      This same subagent wishes to register ipNetToMediaTable
            rows\n      corresponding to its interface (ifIndex i).  Due to the structure\n
            \     of this table, no further index allocation need be done.  The\n
            \     subagent can register the MIB region ipNetToMediaTable.[1-4].i,
            It\n      is claiming responsibility for all rows of the table whose value\n
            \     of ipNetToMediaIfIndex is i.\n   Example 3:\n      A network device
            consists of a set of processors, each of which\n      accepts network
            connections for a unique set of IP addresses.\n      Further, each processor
            contains a subagent that implements\n      tcpConnTable.  In order to
            represent tcpConnTable for the entire\n      managed device, the subagents
            need to share tcpConnTable.\n      In this case, no index allocation need
            be done at all.  Each\n      subagent can register a MIB region of tcpConnTable.[1-5].a.b.c.d,\n
            \     where a.b.c.d represents an unique IP address of the individual\n
            \     processor.\n      Each subagent is claiming responsibility for the
            region of\n      tcpConnTable where the value of tcpConnLocalAddress is
            a.b.c.d.\n   Example 4:\n      The Application Management MIB (RFC 2564
            [22]) uses two objects to\n      index several tables.  A partial description
            of them is:\n      applSrvIndex     OBJECT-TYPE\n             SYNTAX      Unsigned32
            (1..'ffffffff'h)\n             MAX-ACCESS  read-only\n             STATUS
            \     current\n             DESCRIPTION\n                \"An applSrvIndex
            is the system-unique identifier\n                of an instance of a service.
            \ The value is unique\n                not only across all instances of
            a given service,\n                but also across all services in a system.\"\n
            \     applSrvName     OBJECT-TYPE\n             SYNTAX     SnmpAdminString\n
            \            MAX-ACCESS read-only\n             STATUS     current\n             DESCRIPTION\n
            \               \"The human-readable name of a service.  Where\n                appropriate,
            as in the case where a service can\n                be identified in terms
            of a single protocol, the\n                strings should be established
            names such as those\n                assigned by IANA and found in STD
            2 [23], or\n                defined by some other authority.  In some
            cases\n                private conventions apply and the string should\n
            \               in these cases be consistent with these\n                non-standard
            conventions. An applicability\n                statement may specify the
            service name(s) to be\n                used.\"\n      Since applSrvIndex
            is an arbitrary value, it would be reasonable\n      for subagents to
            allocate values for this index.  applSrvName\n      however has intrinsic
            meaning and any values a subagent would use\n      should be known a priori,
            hence it is not reasonable for subagents\n      to allocate values of
            this index.\n"
          title: 7.1.4.2.3.     Examples
        title: 7.1.4.2.  Registering Stuff
      title: 7.1.4. Processing the agentx-Register-PDU
    - contents:
      - "7.1.5. Processing the agentx-Unregister-PDU\n   When the master agent receives
        an agentx-Unregister-PDU, it performs\n   the common processing described
        in section 7.1, \"Processing AgentX\n   Administrative Messages\".  If as
        a result res.error is `\n   noAgentXError', processing continues as follows:\n
        \  1) If u.subtree, u.priority, u.range_subid (and if u.range_subid is\n      not
        0, u.upper_bound), and the indicated context do not match an\n      existing
        registration made during this session, the agentx-\n      Response-PDU is
        returned with res.error set to `\n      unknownRegistration'.\n   2) Otherwise,
        the agentx-Response-PDU is sent in reply with res.error\n      set to `noAgentXError',
        and the previous registration is removed\n      from the registration data
        store.\n"
      title: 7.1.5. Processing the agentx-Unregister-PDU
    - contents:
      - "7.1.6. Processing the agentx-AddAgentCaps-PDU\n   When the master agent receives
        an agentx-AddAgentCaps-PDU, it\n   performs the common processing described
        in section 7.1, \"Processing\n   AgentX Administrative Messages\".  If as
        a result res.error is `\n   noAgentXError', processing continues as follows:\n
        \  1) The master agent adds this agent capabilities information to the\n      sysORTable
        for the indicated context.  An agentx-Response-PDU is\n      sent in reply
        with res.error set to `noAgentXError'.\n"
      title: 7.1.6. Processing the agentx-AddAgentCaps-PDU
    - contents:
      - "7.1.7. Processing the agentx-RemoveAgentCaps-PDU\n   When the master agent
        receives an agentx-RemoveAgentCaps-PDU, it\n   performs the common processing
        described in section 7.1, \"Processing\n   AgentX Administrative Messages\".
        \ If as a result res.error is\n   `noAgentXError', processing continues as
        follows:\n   1) If the combination of a.id and the optional a.context does
        not\n      represent a sysORTable entry that was added by this subagent\n
        \     during this session, the agentx-Response-PDU is returned with\n      res.error
        set to `unknownAgentCaps'.\n   2) Otherwise the master agent deletes the corresponding
        sysORTable\n      entry and sends in reply the agentx-Response-PDU, with res.error\n
        \     set to `noAgentXError'.\n"
      title: 7.1.7. Processing the agentx-RemoveAgentCaps-PDU
    - contents:
      - "7.1.8. Processing the agentx-Close-PDU\n   When the master agent receives
        an agentx-Close-PDU, it performs the\n   common processing described in section
        7.1, \"Processing AgentX\n   Administrative Messages\", with the exception
        that step 4) is not\n   performed since the agentx-Close-PDU does may not
        contain a context\n   field. If as a result res.error is `noAgentXError',
        processing\n   continues as follows:\n   1) The master agent closes the AgentX
        session as described below, and\n      sends in reply the agentx-Response-PDU
        with res.error set to\n      `noAgentXError':\n      -  All MIB regions that
        have been registered during this session\n         are unregistered, as described
        in section 7.1.5, \"Processing\n         the agentx-Unregister-PDU\".\n      -
        \ All index values allocated during this session are freed, as\n         described
        in section 7.1.3, \"Processing the agentx-\n         IndexDeallocate-PDU\".\n
        \     -  All sysORID values that were registered during this session are\n
        \        removed, as described in section 7.1.7, \"Processing the\n         agentx-RemoveAgentCaps-PDU\".\n
        \  The master agent does not maintain state for closed sessions.  If a\n   subagent
        wishes to re-establish a session after it has been closed,\n   it needs to
        re-register MIB regions, agent capabilities, etc.\n"
      title: 7.1.8. Processing the agentx-Close-PDU
    - contents:
      - "7.1.9. Detecting Connection Loss\n   If a master agent is able to detect
        (from the underlying transport)\n   that a subagent cannot receive AgentX
        PDUs, it should close all\n   affected AgentX sessions as described in section
        7.1.8, \"Processing\n   the agentx-Close-PDU\", step 1).\n"
      title: 7.1.9. Detecting Connection Loss
    - contents:
      - "7.1.10. Processing the agentx-Notify-PDU\n   A subagent sending SNMPv1 trap
        information must map this into\n   (minimally) a value of snmpTrapOID.0, as
        described in 3.1.2 of RFC\n   1908 [24].\n   When the master agent receives
        an agentx-Notify-PDU, it performs the\n   common processing described in section
        7.1, \"Processing AgentX\n   Administrative Messages\".  If as a result res.error
        is\n   `noAgentXError',  processing continues as follows:\n   1) If the first
        VarBind is sysUpTime.0;\n      (a)  if the second VarBind is not snmpTrapOID.0,
        res.error is set\n           to `processingError' and res.index to 2\n      (b)
        \ otherwise these two VarBinds are used as the first two\n           VarBinds
        within the generated notification.\n   2) If the first VarBind is not sysUpTime.0;\n
        \     (a)  if the first VarBind is not snmpTrapOID.0, res.error is set\n           to
        `processingError' and res.index to 1\n      (b)  otherwise this VarBind is
        used for snmpTrapOID.0 within the\n           generated notification, and
        the master agent uses the current\n           value of sysUpTime.0 for the
        indicated context as sysUpTime.0\n           within the notification.\n   3)
        An agentx-Response-PDU is sent containing the original\n      VarBindList,
        and with res.error and res.index set as described\n      above.  If res.error
        is `noAgentXError', notifications are sent\n      according to the implementation-specific
        configuration of the\n      master agent.  If SNMPv1 Trap PDUs are generated,
        the recommended\n      mapping is as described in RFC 2089 [25].  If res.error
        indicates\n      an error in processing, no notifications are generated.\n
        \     Note that the master agent's successful response indicates the\n      agentx-Notify-PDU
        was received and validated.  It does not\n      indicate that any particular
        notifications were actually generated\n      or received by notification targets.\n"
      title: 7.1.10. Processing the agentx-Notify-PDU
    - contents:
      - "7.1.11. Processing the agentx-Ping-PDU\n   When the master agent receives
        an agentx-Ping-PDU, it performs the\n   common processing described in section
        7.1, \"Processing AgentX\n   Administrative Messages\".     If as a result
        res.error is `\n   noAgentXError', processing continues as follows:\n      1)
        An agentx-Response-PDU is sent in reply.\n   If a subagent does not receive
        a response to its pings, or if it is\n   able to detect (from the underlying
        transport) that the master agent\n   is not able to receive AgentX messages,
        then it eventually must\n   initiate a new AgentX session, re-register its
        MIB regions, etc.\n"
      title: 7.1.11. Processing the agentx-Ping-PDU
    title: 7.1. Processing AgentX Administrative Messages
  - contents:
    - "7.2. Processing Received SNMP Protocol Messages\n   When an SNMP GetRequest,
      GetNextRequest, GetBulkRequest, or\n   SetRequest protocol message is received
      by the master agent, the\n   master agent applies its access control policy.\n
      \  In particular, for SNMPv1 or SNMPv2c protocol messages, the master\n   agent
      applies the Elements of Procedure defined in section 4.1 of STD\n   15, RFC
      1157 [8] that apply to receiving entities.  For SNMPv3, the\n   master agent
      applies an Access Control Model, possibly the View-based\n   Access Control
      Model (see RFC 2575 [15]), as described in section\n   3.1.2 and section 4.3
      of RFC 2571 [1].\n   For SNMPv1 and SNMPv2c, the master agent uses the community
      string as\n   an index into a local repository of configuration information
      that\n   may include community profiles or more complex context information.\n
      \  For SNMPv3, the master agent uses the SNMP Context (see section 3.3.1\n   of
      RFC 2571 [1]) for these purposes.\n   If application of the access control policy
      results in a valid SNMP\n   request PDU, then an SNMP Response-PDU is constructed
      from\n   information gathered in the exchange of AgentX PDUs between the\n   master
      agent and one or more subagents.  Upon receipt and initial\n   validation of
      an SNMP request PDU, a master agent uses the procedures\n   described below
      to dispatch AgentX PDUs to the proper subagents,\n   marshal the subagent responses,
      and construct an SNMP response PDU.\n"
    - contents:
      - "7.2.1. Dispatching AgentX PDUs\n   Upon receipt and initial validation of
        an SNMP request PDU, a master\n   agent uses the procedures described below
        to dispatch AgentX PDUs to\n   the proper subagents.\n   General Rules of
        Procedure\n   While processing a particular SNMP request, the master agent
        may send\n   one or more AgentX PDUs on one or more subagent sessions.  The\n
        \  following rules of procedure apply in general to the AgentX master\n   agent.
        \ PDU-specific rules are listed in the applicable sections.\n   1) Honoring
        the registry\n      Because AgentX supports registration of duplicate and
        overlapping\n      regions, it is possible for the master agent to obtain
        a value for\n      a requested varbind from within multiple registered MIB
        regions.\n      The master agent must ensure that the value (or exception)\n
        \     actually returned in the SNMP response PDU is taken from the\n      authoritative
        region (as defined in section 7.1.4.1, \"Handling\n      Duplicate and Overlapping
        Subtrees\").\n   2) GetNext and GetBulk Processing\n      The master agent
        may choose to send agentx-Get-PDUs while\n      servicing an SNMP GetNextRequest-PDU.
        \ The master agent may choose\n      to send agentx-Get-PDUs or agentx-GetNext-PDUs
        while servicing an\n      SNMP GetBulkRequest-PDU.  One possible reason for
        this would be if\n      the current iteration has targeted instance-level
        registrations.\n      The master agent may choose to \"scope\" the possible
        instances\n      returned by a subagent by specifying an ending OID in the\n
        \     SearchRange.  If such scoping is used, typically the ending OID\n      would
        be the first lexicographical successor to the target region\n      that was
        registered on a session other than the target session.\n      Regardless of
        this choice, rule (1) must be obeyed.\n      The master agent may require
        multiple request-response iterations\n      on the same subagent session,
        to determine the final value of all\n      requested variables.\n      All
        AgentX PDUs sent on the session while processing a given SNMP\n      request
        must contain identical values of transactionID.  Each\n      different SNMP
        request processed by the master agent must present\n      a unique value of
        transactionID (within the limits of the 32-bit\n      field) to the session.\n
        \  3) Number and order of variables sent per AgentX PDU\n      For Get/GetNext/GetBulk
        operations, at any stage of the possibly\n      iterative process, the master
        agent may need to dispatch several\n      SearchRanges to a particular subagent
        session.  The master agent\n      may send one, some, or all of the SearchRanges
        in a single AgentX\n      PDU.\n      The master agent must ensure that the
        correct contents and\n      ordering of the VarBindList in the SNMP Response-PDU
        are\n      maintained.\n      The following rules govern the number of VarBinds
        in a given\n      AgentX PDU:\n         a) The subagent must support processing
        of AgentX PDUs with\n            multiple VarBinds.\n         b) When processing
        an SNMP Set request, the master agent must\n            send all of the VarBinds
        applicable to a particular subagent\n            session in a single agentx-TestSet-PDU.\n
        \        c) When processing an SNMP Get, GetNext, or GetBulk request,\n            the
        master agent may send a single AgentX PDU on the session\n            with
        all applicable VarBinds, or multiple PDUs with single\n            VarBinds,
        or something in between those extremes. The\n            determination of
        which method to use in a particular case is\n            implementation-specific.\n
        \  4) Timeout Values\n      The master agent chooses a timeout value for each
        MIB region being\n      queried, which is\n         a) the value specified
        during registration of the MIB region,\n            if it was non-zero\n         b)
        otherwise, the value specified during establishment of the\n            session
        in which this region was subsequently registered, if\n            that value
        was non-zero\n         c) otherwise, or, if the specified value is not practical,
        the\n            master agent's implementaton-specific default value\n      When
        an AgentX PDU that references multiple MIB regions is\n      dispatched, the
        timeout value used for the PDU is the maximum\n      value of the timeouts
        so determined for each of the referenced MIB\n      regions.\n   5) Context\n
        \     If the master agent has determined that a specific non-default\n      context
        is associated with the SNMP request PDU, that context is\n      encoded into
        the AgentX PDU's context field and the\n      NON_DEFAULT_CONTEXT bit is set
        in h.flags.\n      Otherwise, no context Octet String is added to the PDU,
        and the\n      NON_DEFAULT_CONTEXT bit is cleared.\n"
      - contents:
        - "7.2.1.1.  agentx-Get-PDU\n   Each variable binding in the SNMP request
          PDU is processed as\n   follows:\n   (1)  Identify the target MIB region.\n
          \       Within a lexicographically ordered set of registered MIB\n        regions,
          valid for the indicated context, locate the\n        authoritative region
          (according to section 7.1.4.1, \"Handling\n        Duplicate and Overlapping
          Subtrees\") that contains the binding's\n        name.\n   (2)  If no such
          region exists, the variable binding is not processed\n        further, and
          its value is set to `noSuchObject'.\n   (3)  Identify the subagent session
          in which this region was\n        registered, termed the target session.\n
          \  (4)  If this is the first variable binding to be dispatched over the\n
          \       target session in a request-response exchange entailed in the\n
          \       processing of this management request:\n         -  Create an agentx-Get-PDU
          for this session, with the header\n            fields initialized as described
          above (see section 6.1,\n            \"AgentX PDU Header\").\n   (5)  Add
          a SearchRange to the end of the target session's PDU for\n        this variable
          binding.\n        - The variable binding's name is encoded into the starting
          OID.\n        - The ending OID is encoded as null.\n"
        title: 7.2.1.1.  agentx-Get-PDU
      - contents:
        - "7.2.1.2.  agentx-GetNext-PDU\n   Each variable binding in the SNMP request
          PDU is processed as\n   follows:\n   (1)  Identify the target MIB region.\n
          \       Within a lexicographically ordered set of registered MIB\n        regions,
          valid for the indicated context, locate the\n        authoritative region
          (according to section 7.1.4.1, \"Handling\n        Duplicate and Overlapping
          Subtrees\") that\n        a) contains the variable binding's name and is
          not a fully\n           qualified instance, or\n        b) is the first
          lexicographical successor to the variable\n           binding's name.\n
          \  (2)  If no such region exists, the variable binding is not processed\n
          \       further, and its value is set to `endOfMibView'.\n   (3)  Identify
          the subagent session in which this region was\n        registered, termed
          the target session.\n   (4)  If this is the first variable binding to be
          dispatched over the\n        target session in a request-response exchange
          entailed in the\n        processing of this management request:\n        -
          \ Create an agentx-GetNext-PDU for the session, with the header\n           fields
          initialized as described above (see section 6.1,\n           \"AgentX PDU
          Header\").\n   (5)  Add a SearchRange to the end of the target session's
          agentx-\n        GetNext-PDU for this variable binding.\n        -  if (1a)
          applies, the variable binding's name is encoded into\n           the starting
          OID, and the OID's \"include\" field is set to 0.\n        -  if (1b) applies,
          the target region's r.subtree is encoded\n           into the starting OID,
          and its \"include\" field is set to 1.\n           (This is the recommended
          method.  An implementation may\n           choose to use a Starting OID
          value that precedes r.subtree,\n           in which case the include bit
          must be 0.  A starting OID\n           value that succeeds r.subtree is
          not permitted.)\n        -  the Ending OID for the SearchRange is encoded
          to be either\n           NULL, or a value that lexicographically succeeds
          the Starting\n           OID.  This is an implementation-specific choice
          depending on\n           how the master agent wishes to \"scope\" the possible
          returned\n           instances.\n"
        title: 7.2.1.2.  agentx-GetNext-PDU
      - contents:
        - "7.2.1.3.  agentx-GetBulk-PDU\n   (Note: The outline of the following procedure
          is based closely on\n   section 4.2.3, \"The GetBulkRequest-PDU\" of RFC
          1905 [13].  Please\n   refer to it for details on the format of the SNMP
          GetBulkRequest-PDU\n   itself.)\n   Each variable binding in the request
          PDU is processed as follows:\n   (1)  Identify the authoritative target
          region and target session,\n        exactly as described for the agentx-GetNext-PDU
          (see section\n        7.2.1.2, \"agentx-GetNext-PDU\").\n   (2)  If this
          is the first variable binding to be dispatched over the\n        target
          session in a request-response exchange entailed in the\n        processing
          of this management request:\n        -  Create an agentx-GetBulk-PDU for
          the session, with the header\n           fields initialized as described
          above (see section 6.1,\n           \"AgentX PDU Header\").\n   (3)  Add
          a SearchRange to the end of the target session's agentx-\n        GetBulk-PDU
          for this variable binding, as described for the\n        agentx-GetNext-PDU.
          \ If the variable binding was a non-repeater\n        in the original request
          PDU, it must be a non-repeater in the\n        agentx-GetBulk-PDU.\n   The
          value of g.max_repetitions in the agentx-GetBulk-PDU may be less\n   than
          (but not greater than) the value in the original request PDU.\n   The master
          agent may make such alterations due to simple sanity\n   checking, optimizations
          for the current iteration based on the\n   registry, the maximum possible
          size of a potential Response-PDU,\n   known constraints of the AgentX transport,
          or any other\n   implementation-specific constraint.\n"
        title: 7.2.1.3.  agentx-GetBulk-PDU
      - contents:
        - "7.2.1.4.  agentx-TestSet-PDU\n   AgentX employs test-commit-undo-cleanup
          phases to achieve \"as if\n   simultaneous\" semantics of the SNMP SetRequest-PDU
          within the\n   extensible agent.  The initial phase involves the agentx-TestSet-PDU.\n
          \  Each variable binding in the SNMP request PDU is processed in order,\n
          \  as follows:\n   (1)  Identify the target MIB region and target session
          exactly as\n        described in section 7.2.1.1, \"agentx-Get-PDU\", step
          1).\n        Within a lexicographically ordered set of OID ranges, valid
          for\n        the indicated context, locate the authoritative range that\n
          \       contains the variable binding's name.\n   (2)  If no such target
          region exists, this variable binding fails\n        with an error of `notWritable'.
          \ Processing is complete for this\n        request.\n   (3)  If this is
          the first variable binding to be dispatched over the\n        target session
          in a request-response exchange entailed in the\n        processing of this
          management request:\n        -  create an agentx-TestSet-PDU for the session,
          with the header\n           fields initialized as described above (see section
          6.1,\n           \"AgentX PDU Header\").\n   (4)  Add a VarBind to the end
          of the target session's PDU for this\n        variable binding, as described
          in section 5.4, \"Value\n        Representation\".\n   Note that all VarBinds
          applicable to a given session must be sent in\n   a single agentx-TestSet-PDU.\n"
        title: 7.2.1.4.  agentx-TestSet-PDU
      - contents:
        - "7.2.1.5.  Dispatch\n   A timeout value is calculated for each PDU to be
          sent, which is the\n   maximum value of the timeouts determined for each
          of the PDU's\n   SearchRanges (as described above in section 7.2.1, \"Dispatching\n
          \  AgentX PDUs\", item 4). Each pending PDU is mapped (via its\n   h.sessionID
          value) to a particular transport domain/endpoint, as\n   described in section
          8 (Transport Mappings).\n"
        title: 7.2.1.5.  Dispatch
      title: 7.2.1. Dispatching AgentX PDUs
    - contents:
      - "7.2.2. Subagent Processing\n   A subagent initially processes a received
        AgentX PDU as follows:\n   -  If the received PDU is an agentx-Response-PDU:\n
        \  1) If there are any errors parsing or interpreting the PDU, it is\n      silently
        dropped.\n   2) Otherwise the response is matched to the original request
        via\n      h.packetID, and handled in an implementation-specific manner.  For\n
        \     example, if this response indicates an error attempting to\n      register
        a MIB region, the subagent may wish to register a\n      different region,
        or log an error and halt, etc.\n   -  If the received PDU is any other type:\n
        \  1) an agentx-Response-PDU is created whose header fields are\n      identical
        to the received request PDU except that h.type is set to\n      Response,
        res.error to `noError', res.index to 0, and the\n      VarBindList to null.\n
        \  2) If the received PDU cannot be parsed, res.error is set to\n      `parseError'.\n
        \  3) Otherwise, if h.sessionID does not correspond to a currently\n      established
        session, res.error is set to `notOpen'.\n   4) At this point, if res.error
        is not `noError', the received PDU is\n      not processed further.  If the
        received PDU's header was\n      successfully parsed, the AgentX-Response-PDU
        is sent in reply.  If\n      the received PDU's header was not successfully
        parsed or for some\n      other reason the subagent cannot send a reply, processing
        is\n      complete.\n"
      title: 7.2.2. Subagent Processing
    - contents:
      - "7.2.3. Subagent Processing of agentx-Get, GetNext, GetBulk-PDUs\n   A conformant
        AgentX subagent must support the agentx-Get, -GetNext,\n   and -GetBulk PDUs,
        and must support multiple variables being supplied\n   in each PDU.\n   When
        a subagent receives an agentx-Get-, GetNext-, or GetBulk-PDU, it\n   performs
        the indicated management operations and returns an agentx-\n   Response-PDU.\n
        \  Each SearchRange in the request PDU's SearchRangeList is processed as\n
        \  described below, and a VarBind is added in the corresponding location\n
        \  of the agentx-Response-PDU's  VarbindList.  If processing should fail\n
        \  for any reason not described below, res.error is set to `genErr',\n   res.index
        to the index of the failed SearchRange, the VarBindList is\n   reset to null,
        and this agentx-Response-PDU is returned to the master\n   agent.\n"
      - contents:
        - "7.2.3.1.  Subagent Processing of the agentx-Get-PDU\n   Upon the subagent's
          receipt of an agentx-Get-PDU, each SearchRange in\n   the request is processed
          as follows:\n   (1)  The starting OID is copied to v.name.\n   (2)  If the
          starting OID exactly matches the name of a variable\n        instantiated
          by this subagent within the indicated context and\n        session, v.type
          and v.data are encoded to represent the\n        variable's syntax and value,
          as described in section 5.4, \"Value\n        Representation\".\n   (3)
          \ Otherwise, if the starting OID does not match the object\n        identifier
          prefix of any variable instantiated within the\n        indicated context
          and session, the VarBind is set to\n        `noSuchObject', in the manner
          described in section 5.4, \"Value\n        Representation\".\n   (4)  Otherwise,
          the VarBind is set to `noSuchInstance' in the manner\n        described
          in section 5.4, \"Value Representation\".\n"
        title: 7.2.3.1.  Subagent Processing of the agentx-Get-PDU
      - contents:
        - "7.2.3.2.  Subagent Processing of the agentx-GetNext-PDU\n   Upon the subagent's
          receipt of an agentx-GetNext-PDU, each\n   SearchRange in the request is
          processed as follows:\n   (1)  The subagent searches for a variable within
          the\n        lexicographically ordered list of variable names for all\n
          \       variables it instantiates (without regard to registration of\n        regions)
          within the indicated context and session, as follows:\n        -  if the
          \"include\" field of the starting OID is 0, the\n           variable's name
          is the closest lexicographical successor to\n           the starting OID.\n
          \       -  if the \"include\" field of the starting OID is 1, the\n           variable's
          name is either equal to, or the closest\n           lexicographical successor
          to, the starting OID.\n        -  If the ending OID is not null, the variable's
          name\n           lexicographically precedes the ending OID.\n        If
          a variable is successfully located, v.name is set to that\n        variable's
          name.  v.type and v.data are encoded to represent the\n        variable's
          syntax and value, as described in section 5.4, \"Value\n        Representation\".\n
          \  (2)  If the subagent cannot locate an appropriate variable, v.name is\n
          \       set to the starting OID, and the VarBind is set to `\n        endOfMibView',
          in the manner described in section 5.4, \"Value\n        Representation\".\n"
        title: 7.2.3.2.  Subagent Processing of the agentx-GetNext-PDU
      - contents:
        - "7.2.3.3.  Subagent Processing of the agentx-GetBulk-PDU\n   A maximum of
          N + (M * R) VarBinds are returned, where\n      N equals g.non_repeaters,\n
          \     M equals g.max_repetitions, and\n      R is (number of SearchRanges
          in the GetBulk request) - N.\n   The first N SearchRanges are processed
          exactly as for the agentx-\n   GetNext-PDU.\n   If M and R are both non-zero,
          the remaining R SearchRanges are\n   processed iteratively to produce potentially
          many VarBinds.  For each\n   iteration i, such that i is greater than zero
          and less than or equal\n   to M, and for each repeated SearchRange s, such
          that s is greater\n   than zero and less than or equal to R, the (N+((i-1)*R)+s)-th
          VarBind\n   is added to the agentx-Response-PDU as follows:\n      1) The
          subagent searches for a variable within the\n         lexicographically
          ordered list of variable names for all\n         variables it instantiates
          (without regard to registration of\n         regions) within the indicated
          context and session, for which\n         the following are all true:\n         -
          \ The variable's name is the (i)-th lexicographical successor\n            to
          the (N+s)-th requested OID.\n            (Note that if i is 0 and the \"include\"
          field is 1, the\n            variable's name may be equivalent to, or the
          first\n            lexicographical successor to, the (N+s)-th requested
          OID.)\n         -  If the ending OID is not null, the variable's name\n
          \           lexicographically precedes the ending OID.\n      If all of
          these conditions are met, v.name is set to the located\n      variable's
          name.  v.type and v.data are encoded to represent the\n      variable's
          syntax and value, as described in section 5.4, \"Value\n      Representation\".\n
          \     2) If no such variable exists, the VarBind is set to `\n         endOfMibView'
          as described in section 5.4, \"Value\n         Representation\".  v.name
          is set to v.name of the (N+((i-\n         2)*R)+s)-th VarBind unless i is
          currently 1, in which case it\n         is set to the value of the starting
          OID in the (N+s)-th\n         SearchRange.\n   Note that further iterative
          processing should stop if\n         -  For any iteration i, all s values
          of v.type are `\n            endOfMibView'.\n         -  An AgentX transport
          constraint or other implementation-\n            specific constraint is
          reached.\n"
        title: 7.2.3.3.  Subagent Processing of the agentx-GetBulk-PDU
      title: 7.2.3. Subagent Processing of agentx-Get, GetNext, GetBulk-PDUs
    - contents:
      - "7.2.4. Subagent Processing of agentx-TestSet, -CommitSet, -UndoSet,\n                   -CleanupSet-PDUs\n
        \  A conformant AgentX subagent must support the agentx-TestSet,\n   -CommitSet,
        -UndoSet, and -CleanupSet PDUs, and must support multiple\n   variables being
        supplied in the agentx-TestSet-PDU.\n   These four PDUs are used to collectively
        perform the indicated\n   management operation.  An agentx-Response-PDU is
        sent in reply to\n   each of the PDUs (except -CleanupSet), to inform the
        master agent of\n   the state of the operation.\n   The master agent must
        serialize Set transactions for each session.\n   That is, a session need not
        handle multiple concurrent Set\n   transactions.\n   These Response-PDUs do
        not contain a VarBindList.\n"
      - contents:
        - "7.2.4.1.  Subagent Processing of the agentx-TestSet-PDU\n   Upon the subagent's
          receipt of an agentx-TestSet-PDU, each VarBind in\n   the PDU is validated
          until they are all successful, or until one\n   fails, as described in section
          4.2.5 of RFC 1905 [13]. The subagent\n   validates variables with respect
          to the context and session indicated\n   in the testSet-PDU.\n   If each
          VarBind is successful, the subagent has a further\n   responsibility to
          ensure the availability of all resources (memory,\n   write access, etc.)
          required for successfully carrying out a\n   subsequent agentx-CommitSet
          operation.  If this cannot be guaranteed,\n   the subagent should set res.error
          to `resourceUnavailable'.  As a\n   result of this validation step, an agentx-Response-PDU
          is sent in\n   reply whose res.error field is set to one of the following
          SNMPv2 PDU\n   error-status values (see section 3, \"Definitions\", in RFC
          1905 [13]):\n            noError                    (0),\n            genErr
          \                    (5),\n            noAccess                   (6),\n
          \           wrongType                  (7),\n            wrongLength                (8),\n
          \           wrongEncoding              (9),\n            wrongValue                (10),\n
          \           noCreation                (11),\n            inconsistentValue
          \        (12),\n            resourceUnavailable       (13),\n            notWritable
          \              (17),\n            inconsistentName          (18)\n   If
          this value is not `noError', the res.index field must be set to\n   the
          index of the VarBind for which validation failed.\n   Implementation of
          rigorous validation code may be one of the most\n   demanding aspects of
          subagent development.  Implementors are strongly\n   encouraged to do this
          right, so as to avoid if at all possible the\n   extensible agent's having
          to return `commitFailed' or `undoFailed'\n   during subsequent processing.\n"
        title: 7.2.4.1.  Subagent Processing of the agentx-TestSet-PDU
      - contents:
        - "7.2.4.2.  Subagent Processing of the agentx-CommitSet-PDU\n   The agentx-CommitSet-PDU
          indicates that the subagent should actually\n   perform (as described in
          the post-validation sections of 4.2.5 of RFC\n   1905 [13]) the management
          operation indicated by the previous\n   TestSet-PDU.  After carrying out
          the management operation, the\n   subagent sends in reply an agentx-Response-PDU
          whose res.error field\n   is set to one of the following SNMPv2 PDU error-status
          values (see\n   section 3, \"Definitions\", in RFC 1905 [13]):\n            noError
          \                   (0),\n            commitFailed              (14)\n   If
          this value is `commitFailed', the res.index field must be set to\n   the
          index of the VarBind (as it occurred in the agentx-TestSet-PDU)\n   for
          which the operation failed.  Otherwise res.index is set to 0.\n"
        title: 7.2.4.2.  Subagent Processing of the agentx-CommitSet-PDU
      - contents:
        - "7.2.4.3.  Subagent Processing of the agentx-UndoSet-PDU\n   The agentx-UndoSet-PDU
          indicates that the subagent should undo the\n   management operation requested
          in a preceding CommitSet-PDU.  The\n   undo process is as described in section
          4.2.5 of RFC 1905 [13].\n   After carrying out the undo process, the subagent
          sends in reply an\n   agentx-Response-PDU whose res.error field is set to
          one of the\n   following SNMPv2 PDU error-status values (see section 3,\n
          \  \"Definitions\", in RFC 1905 [13]):\n            noError                    (0),\n
          \           undoFailed                (15)\n   If this value is `undoFailed',
          the res.index field must be set to the\n   index of the VarBind (as it occurred
          in the agentx-TestSet-PDU) for\n   which the operation failed.  Otherwise
          res.index is set to 0.\n   This PDU also signals the end of processing of
          the management\n   operation initiated by the previous TestSet-PDU.  The
          subagent should\n   release resources, etc. as described in section 7.2.4.4,
          \"Subagent\n   Processing of the agentx-CleanupSet-PDU\".\n"
        title: 7.2.4.3.  Subagent Processing of the agentx-UndoSet-PDU
      - contents:
        - "7.2.4.4.  Subagent Processing of the agentx-CleanupSet-PDU\n   The agentx-CleanupSet-PDU
          signals the end of processing of the\n   management operation requested
          in the previous TestSet-PDU.  This is\n   an indication to the subagent
          that it may now release any resources\n   it may have reserved in order
          to carry out the management request.\n   No response is sent by the subagent.\n"
        title: 7.2.4.4.  Subagent Processing of the agentx-CleanupSet-PDU
      title: 7.2.4. Subagent Processing of agentx-TestSet, -CommitSet, -UndoSet,
    - contents:
      - "7.2.5. Master Agent Processing of AgentX Responses\n   The master agent now
        marshals all subagent AgentX response PDUs and\n   builds an SNMP response
        PDU.  In the next several subsections, the\n   initial processing of all subagent
        AgentX response PDUs is described,\n   followed by descriptions of subsequent
        processing for each specific\n   subagent Response.\n"
      - contents:
        - "7.2.5.1.  Common Processing of All AgentX Response PDUs\n   1) If a response
          is not received on a session within the timeout\n      interval for this
          dispatch, it is treated as if the subagent had\n      returned `genErr'
          and processed as described below.\n      A timeout may be due to a variety
          of reasons, and does not\n      necessarily denote a failed or malfunctioning
          subagent.  As such,\n      the master agent's response to a subagent timeout
          is\n      implementation-specific, but with the following constraint:\n
          \     A session that times out on three consecutive AgentX requests is\n
          \     considered unable to respond, and the master agent must close the\n
          \     AgentX session as described in section 7.1.8, \"Processing the\n      agentx-Close-PDU\",
          step (2).\n   2) Otherwise, the h.packetID, h.sessionID, and h.transactionID
          fields\n      of the AgentX response PDU are used to correlate subagent\n
          \     responses.  If the response does not pertain to this SNMP\n      operation,
          it is ignored.\n   3) Otherwise, the responses are processed jointly to
          form the SNMP\n      response PDU.\n"
        title: 7.2.5.1.  Common Processing of All AgentX Response PDUs
      - contents:
        - "7.2.5.2.  Processing of Responses to agentx-Get-PDUs\n   After common processing
          of the subagent's response to an agentx-Get-\n   PDU (see section 7.2.5.1,
          \"Common Processing of All AgentX Response\n   PDUs\", above), processing
          continues with the following steps:\n   1) For any received AgentX response
          PDU, if res.error is not\n      `noError', the SNMP response PDU's error
          code is set to this\n      value.  If res.error contains an AgentX specific
          value (e.g.\n      `parseError'), the SNMP response PDU's error code is
          set to a\n      value of genErr instead.  Also, the SNMP response PDU's
          error\n      index is set to the index of the variable binding corresponding
          to\n      the failed VarBind in the subagent's AgentX response PDU.\n      All
          other AgentX response PDUs received due to processing this\n      SNMP request
          are ignored.  Processing is complete; the SNMP\n      Response PDU is ready
          to be sent (see section 7.2.6, \"Sending the\n      SNMP Response-PDU\").\n
          \  2) Otherwise, the content of each VarBind in the AgentX response PDU\n
          \     is used to update the corresponding variable binding in the SNMP\n
          \     Response-PDU.\n"
        title: 7.2.5.2.  Processing of Responses to agentx-Get-PDUs
      - contents:
        - "7.2.5.3.  Processing of Responses to agentx-GetNext-PDU and\n                agentx-GetBulk-PDU\n
          \  After common processing of the subagent's response to an agentx-\n   GetNext-PDU
          or agentx-GetBulk-PDU (see section 7.2.5.1, \"Common\n   Processing of All
          AgentX Response PDUs\", above), processing continues\n   with the following
          steps:\n   1) For any received AgentX response PDU, if res.error is not\n
          \     `noError', the SNMP response PDU's error code is set to this\n      value.
          \ If res.error contains an AgentX specific value (e.g.\n      `parseError'),
          the SNMP response PDU's error code is set to a\n      value of genErr instead.
          \ Also, the SNMP response PDU's error\n      index is set to the index of
          the variable binding corresponding to\n      the failed VarBind in the subagent's
          AgentX response PDU.\n      All other AgentX response PDUs received due
          to processing this\n      SNMP request are ignored.  Processing is complete;
          the SNMP\n      response PDU is ready to be sent (see section 7.2.6, \"Sending
          the\n      SNMP Response-PDU\").\n   2) Otherwise, the content of each VarBind
          in the AgentX response PDU\n      is used to update the corresponding VarBind
          in the SNMP response\n      PDU.\n   After all expected AgentX response
          PDUs have been processed, if any\n   VarBinds still contain the value `endOfMibView'
          in their v.type\n   fields, processing must continue:\n   3) A new iteration
          of AgentX request dispatching is initiated (as\n      described in section
          7.2.1.2, \"agentx-GetNext-PDU\"), in which only\n      those VarBinds whose
          v.type is `endOfMibView' are processed.\n   4) For each such VarBind, an
          authoritative target MIB region is\n      identified in which the master
          agent expects to find suitable MIB\n      variables.  The target session
          is the one on which this new target\n      region was registered.\n      The
          starting OID in each SearchRange is set to the value of v.name\n      for
          the corresponding VarBind, and its \"include\" field is set to\n      0.\n
          \  5) The value of transactionID must be identical to the value used\n      during
          the previous iteration.\n   6) The AgentX PDUs are sent on the target session(s),
          and the\n      responses are received and processed according to the steps\n
          \     described in section 7.2.5, \"Master Agent Processing of AgentX\n
          \     Responses\".\n   7) This process continues iteratively until a complete
          SNMP\n      Response-PDU has been built, or until there remain no\n      authoritative
          MIB regions to query.\n   Note that r.subtree for the new target region
          identified in step 4)\n   may not lexicographically succeed r.subtree for
          the region that has\n   returned `endOfMibView'.  For example, consider
          the following\n   registry:\n        session A   `mib-2' (1.3.6.1.2.1)\n
          \       session B   `ip'    (1.3.6.1.2.1.4)\n        session C   `tcp'   (1.3.6.1.2.1.6)\n
          \  If while processing a GetNext-Request-PDU session B returns\n   `endOfMibView'
          for a variable name within 1.3.6.1.2.1.4, the target\n   MIB region identified
          in step 4) would be 1.3.6.1.2.1 (since it may\n   contain variables whose
          names precede 1.3.6.1.2.1.6).\n   Note also that if session A returned variables
          from within\n   1.3.6.1.2.1.6, they must be discarded since session A is
          NOT\n   authoritative for that region.\n"
        title: 7.2.5.3.  Processing of Responses to agentx-GetNext-PDU and
      - contents:
        - "7.2.5.4.  Processing of Responses to agentx-TestSet-PDUs\n   After common
          processing of the subagent's response to an agentx-\n   TestSet-PDU (see
          section 7.2.5.1, \"Common Processing of All AgentX\n    Response PDUs\",
          above), processing continues with the further\n   exchange of AgentX PDUs.
          \ The value of h.transactionID in the\n   agentx-CommitSet, -UndoSet, and
          -CleanupSet-PDUs must be identical to\n   the value sent in the testSet-PDU.\n
          \  The state transitions and PDU sequences are depicted in section 7.3,\n
          \  \"State Transitions\".\n   The set of all sessions who have been sent
          an agentx-TestSet-PDU for\n   this particular transaction are referred to
          below as \"involved\n   sessions\".\n   1) If any target session's response
          is not `noError', all other\n      agentx-Response-PDUs received due to
          processing this SNMP request\n      are ignored.\n      An agentx-CleanupSet-PDU
          is sent to all involved sessions.\n      Processing is complete; the SNMP
          response PDU is constructed as\n      described below in 7.2.6, \"Sending
          the SNMP Response-PDU\".\n   2) Otherwise an agentx-CommitSet-PDU is sent
          to all involved\n      sessions.\n"
        title: 7.2.5.4.  Processing of Responses to agentx-TestSet-PDUs
      - contents:
        - "7.2.5.5.  Processing of Responses to agentx-CommitSet-PDUs\n   After common
          processing of the subagent's response to an agentx-\n   CommitSet-PDU (see
          section 7.2.5.1, \"Common Processing of All AgentX\n   Response PDUs\",
          above), processing continues with the following\n   steps:\n   1) If any
          response is not `noError', the SNMP response PDU's error\n      code is
          set to this value.  If res.error contains an AgentX\n      specific value
          (e.g. `parseError'), the SNMP response PDU's error\n      code is set to
          a value of genErr instead.  Also, the SNMP response\n      PDU's error index
          is set to the index of the VarBind corresponding\n      to the failed VarBind
          in the agentx-TestSet-PDU.\n      An agentx-UndoSet-PDU is sent to each
          target session that has been\n      sent an agentx-CommitSet-PDU.  An agentx-CleanupSet-PDU
          is sent to\n      the remainder of the involved sessions.\n   2) Otherwise
          an agentx-CleanupSet-PDU is sent to all involved\n      sessions.  Processing
          is complete; the SNMP response PDU is\n      constructed as described below
          in section 7.2.6, \"Sending the SNMP\n      Response-PDU\".\n"
        title: 7.2.5.5.  Processing of Responses to agentx-CommitSet-PDUs
      - contents:
        - "7.2.5.6.  Processing of Responses to agentx-UndoSet-PDUs\n   After common
          processing of the subagent's response to an agentx-\n   UndoSet-PDU (see
          section 7.2.5.1, \"Common Processing of All AgentX\n   Response PDUs\",
          above), processing continues with the following\n   steps:\n   1) If any
          response is `undoFailed' the SNMP response PDU's error code\n      is set
          to this value.  Also, the SNMP response PDU's error index\n      is set
          to 0.\n   2) Otherwise, if any response is not `noError' the SNMP response\n
          \     PDU's error code is set to this value.  Also, the SNMP response\n
          \     PDU's error index is set to the index of the VarBind corresponding\n
          \     to the failed VarBind in the agentx-TestSet-PDU. If res.error is\n
          \     an AgentX specific value (e.g. `parseError'), the SNMP response\n
          \     PDU's error code is set to a value of genErr instead.\n   3) Otherwise
          the SNMP response PDU's error code and error index were\n      set in section
          7.2.5.5 step 1)\n"
        title: 7.2.5.6.  Processing of Responses to agentx-UndoSet-PDUs
      title: 7.2.5. Master Agent Processing of AgentX Responses
    - contents:
      - "7.2.6. Sending the SNMP Response-PDU\n   Once the processing described in
        section 7.2.5, \"Master Agent\n   Processing of AgentX Responses\" is complete,
        there is an SNMP\n   response PDU available.  The master agent now implements
        the Elements\n   of Procedure for the applicable version of the SNMP protocol
        in order\n   to encapsulate the PDU into a message, and transmit it to the\n
        \  originator of the SNMP management request.  Note that this may\n   involve
        altering the PDU contents (for instance, to replace the\n   original VarBinds
        if an error condition is to be returned).\n   The response PDU may also be
        altered in order to support the SNMPv1\n   PDU.  In such cases the required
        PDU mapping is that defined in RFC\n   2089 [25].  (Note in particular that
        the rules for handling Counter64\n   syntax may require re-sending AgentX
        GetBulk or GetNext PDUs until a\n   VarBind of suitable syntax is returned.)\n"
      title: 7.2.6. Sending the SNMP Response-PDU
    - contents:
      - "7.2.7. MIB Views\n   AgentX subagents are not aware of MIB views, since view
        information\n   is not contained in AgentX PDUs.\n   As stated above, the
        descriptions of procedures in section 7,\n   \"Elements of Procedure\", of
        this memo are not intended to constrain\n   the internal architecture of any
        conformant implementation.  In\n   particular, the master agent procedures
        described in section 7.2.1,\n   \"Dispatching AgentX PDUs\" and in section
        7.2.5, \"Master Agent\n   Processing of AgentX Responses\" may be altered
        so as to optimize\n   AgentX exchanges when implementing MIB views.\n   Such
        optimizations are beyond the scope of this memo.  But note that\n   section
        7.2.3, \"Subagent Processing of agentx-Get, GetNext, GetBulk-\n   PDUs\",
        \ defines subagent behavior in such a way that alteration of\n   SearchRanges
        may be used in such optimizations.\n"
      title: 7.2.7. MIB Views
    title: 7.2. Processing Received SNMP Protocol Messages
  - contents:
    - "7.3. State Transitions\n   State diagrams are presented from the master agent's
      perspective for\n   transport connection and session establishment, and from
      the\n   subagent's perspective for Set transaction processing.\n"
    - contents:
      - "7.3.1. Set Transaction States\n   The following table presents, from the
        subagent's perspective, the\n   state transitions involved in Set transaction
        processing:\n                                       STATE\n            +---------------+--------------+---------+--------+--------\n
        \           |       A       |      B       |   C     |   D    |   E\n            |
        \  (Initial    |    TestOK    | Commit  | Test   | Commit\n            |     State)
        \   |              |  OK     | Fail   |  Fail\n            |               |
        \             |         |        |\n    EVENT   |               |              |
        \        |        |\n   ---------+---------------+--------------+---------+--------+--------\n
        \           | 7.2.4.1       |              |         |        |\n   Receive
        \ | All varbinds  |              |         |        |\n   TestSet  | OK?           |
        \     X       |    X    |   X    |    X\n   PDU      |   Yes ->B     |              |
        \        |        |\n            |   No  ->D     |              |         |
        \       |\n   ---------+---------------+--------------+---------+--------+--------\n
        \           |               |  7.2.4.2     |         |        |\n   Receive
        \ |               |  NoError?    |         |        |\n   Commit-  |       X
        \      |   Yes ->C    |    X    |   X    |    X\n   Set PDU  |               |
        \  No  ->E    |         |        |\n   ---------+---------------+--------------+---------+--------+--------\n
        \  Receive  |               |              | 7.2.4.3 |        |7.2.4.3\n   UndoSet
        \ |       X       |       X      | ->done  |   X    | ->done\n   PDU      |
        \              |              |         |        |\n   ---------+---------------+--------------+---------+--------+--------\n
        \  Receive  |               |  7.2.4.4     | 7.2.4.4 |7.2.4.4 |\n   Cleanup-
        |       X       |   ->done     | ->done  | ->done |   X\n   Set PDU  |               |
        \             |         |        |\n   ---------+---------------+--------------+---------+--------+--------\n
        \  Session  |               | rollback     | undo    |        |\n   Loss     |
        \ ->done       |  ->done      |  ->done | ->done | ->done\n   ---------+---------------+--------------+---------+--------+--------\n
        \  There are three possible sequences that a subagent may follow for a\n   particular
        set transaction:\n      1) TestSet CommitSet CleanupSet\n      2) TestSet
        CommitSet UndoSet\n      3) TestSet           CleanupSet\n   Note that a single
        PDU sequence may result in multiple paths through\n   the finite state machine
        (FSM).  For example, the sequence\n      TestSet CommitSet UndoSet\n   may
        walk through either of these two state sequences:\n      (initial) TestOK
        CommitOK   (done)\n      (initial) TestOK CommitFail (done)\n"
      title: 7.3.1. Set Transaction States
    - contents:
      - "7.3.2. Transport Connection States\n   The following table presents, from
        the master agent's perspective,\n   the state transitions involved in transport
        connection setup and\n   teardown:\n                    STATE\n                   +--------------+--------------\n
        \                  |      A       |      B\n                   | No transport
        |  Transport\n                   |              |  connected\n                   |
        \             |\n   EVENT           |              |\n   ----------------+--------------+--------------\n
        \  Transport       |              |\n   connect         |     ->B      |      X\n
        \  indication      |              |\n   ----------------+--------------+--------------\n
        \  Receive         |              | if no resources\n   Open-PDU        |
        \             | available\n                   |              | reject, else\n
        \                  |      X       | establish\n                   |              |
        session\n                   |              |\n                   |              |
        \    ->B\n   ----------------+--------------+--------------\n   Receive         |
        \             | if matching\n   Response-PDU    |              | session id,\n
        \                  |              | feed to that\n                   |      X
        \      | session's FSM\n                   |              | else ignore\n
        \                  |              |\n                   |              |     ->B\n
        \  ----------------+--------------+--------------\n   Receive other   |              |
        if matching\n   PDUs            |              | session id,\n                   |
        \             | feed to that\n                   |      X       | session's
        FSM\n                   |              | else reject\n                   |
        \             |\n                   |              |     ->B\n   ----------------+--------------+--------------\n
        \  Transport       |              |notify all\n   disconnect      |              |sessions
        on\n   indication      |      X       |this transport\n                   |
        \             |\n                   |              |     ->A\n   ----------------+--------------+--------------\n"
      title: 7.3.2. Transport Connection States
    - contents:
      - "7.3.3. Session States\n   The following table presents, from the master agent's
        perspective,\n   the state transitions involved in session setup and teardown:\n
        \                             STATE\n                  +-------------+----------------\n
        \                 |     A       |      B\n                  |  No session
        |  Session\n                  |             |  established\n   EVENT          |
        \            |\n   ---------------+-------------+----------------\n                  |
        \ 7.1.1      |\n   Receive        |             |      X\n   Open PDU       |
        \   ->B      |\n   ---------------+-------------+----------------\n                  |
        \            |  7.1.8\n   Receive        |      X      |\n   Close PDU      |
        \            |    ->A\n   ---------------+-------------+----------------\n
        \  Receive        |             |  7.1.4\n   Register PDU   |      X      |\n
        \                 |             |    ->B\n   ---------------+-------------+----------------\n
        \  Receive        |             |  7.1.5\n   Unregister     |      X      |\n
        \  PDU            |             |    ->B\n   ---------------+-------------+----------------\n
        \  Receive        |             |\n   Get PDU        |             |\n   GetNext
        PDU    |             |\n   GetBulk PDU    |      X      |       X\n   TestSet
        PDU    |             |\n   CommitSet PDU  |             |\n   UndoSet PDU
        \   |             |\n   CleanupSet PDU |             |\n   ---------------+-------------+----------------\n
        \  Receive        |             |  7.1.10\n   Notify PDU     |      X      |\n
        \                 |             |    ->B\n   ---------------+-------------+----------------\n
        \  Receive Ping   |             |  7.1.11\n   PDU            |      X      |\n
        \                 |             |    ->B\n   ---------------+-------------+----------------\n
        \  (continued next page)\n   ---------------+-------------+----------------\n
        \  Receive        |             |  7.1.2\n   IndexAllocate  |      X      |\n
        \  PDU            |             |    ->B\n   ---------------+-------------+----------------\n
        \  Receive        |             |  7.1.3\n   IndexDeallocate|      X      |\n
        \  PDU            |             |    ->B\n   ---------------+-------------+----------------\n
        \  Receive        |             |  7.1.6\n   AddAgentxCaps  |      X      |\n
        \  PDU            |             |    ->B\n   ---------------+-------------+----------------\n
        \  Receive        |             |  7.1.7\n   RemoveAgentxCap|      X      |\n
        \  PDU            |             |    ->B\n   ---------------+-------------+----------------\n
        \  Receive        |             |  7.2.5\n   Response PDU   |      X      |\n
        \                 |             |    ->B\n   ---------------+-------------+----------------\n
        \  Receive        |             |\n   Other PDU      |      X      |       X\n
        \  ---------------+-------------+----------------\n"
      title: 7.3.3. Session States
    title: 7.3. State Transitions
  title: 7. Elements of Procedure
- contents:
  - "8. Transport Mappings\n   The same AgentX PDU formats, encodings, and elements
    of procedure are\n   used regardless of the underlying transport.\n"
  - contents:
    - '8.1. AgentX over TCP

      '
    - contents:
      - "8.1.1. Well-known Values\n   The master agent accepts TCP connection requests
        for the well-known\n   port 705.  Subagents connect to the master agent using
        this port\n   number.\n"
      title: 8.1.1. Well-known Values
    - contents:
      - "8.1.2. Operation\n   Once a TCP connection has been established, the AgentX
        peers use this\n   connection to carry all AgentX PDUs. Multiple AgentX sessions
        may be\n   established using the same TCP connection.  AgentX PDUs are sent\n
        \  within an AgentX session.  AgentX peers are responsible for mapping\n   the
        h.sessionID to a particular TCP connection.\n   The AgentX entity must not
        \"interleave\" AgentX PDUs within the TCP\n   byte stream.  All the bytes
        of one PDU must be sent before any bytes\n   of a different PDU.  The receiving
        entity must be prepared for TCP to\n   deliver byte sequences that do not
        coincide with AgentX PDU\n   boundaries.\n"
      title: 8.1.2. Operation
    title: 8.1. AgentX over TCP
  - contents:
    - "8.2. AgentX over UNIX-domain Sockets\n   Many (BSD-derived) implementations
      of the UNIX operating system\n   support the UNIX pathname address family (AF_UNIX)
      for socket\n   communications.  This provides a convenient method of sending
      and\n   receiving data between processes on the same host.\n   Mapping AgentX
      to this transport is useful for environments that\n      -  wish to guarantee
      subagents are running on the same managed\n         node as the master agent,
      and where\n      -  sockets provide better performance than TCP or UDP, especially\n
      \        in the presence of heavy network I/O\n"
    - contents:
      - "8.2.1. Well-known Values\n   The master agent creates a well-known UNIX-domain
        socket endpoint\n   called \"/var/agentx/master\".  (It may create other,
        implementation-\n   specific endpoints.)\n   This endpoint name uses the character
        set encoding native to the\n   managed node, and represents a UNIX-domain
        stream (SOCK_STREAM)\n   socket.\n"
      title: 8.2.1. Well-known Values
    - contents:
      - "8.2.2. Operation\n   Once a connection has been established, the AgentX peers
        use this\n   connection to carry all AgentX PDUs.\n   Multiple AgentX sessions
        may be established using the same\n   connection.  AgentX PDUs are sent within
        an AgentX session.  AgentX\n   peers are responsible for mapping the h.sessionID
        to a particular\n   connection.\n   The AgentX entity must not \"interleave\"
        AgentX PDUs within the socket\n   byte stream.  All the bytes of one PDU must
        be sent before any bytes\n   of a different PDU.  The receiving entity must
        be prepared for the\n   socket to deliver byte sequences that do not coincide
        with AgentX PDU\n   boundaries.\n"
      title: 8.2.2. Operation
    title: 8.2. AgentX over UNIX-domain Sockets
  title: 8. Transport Mappings
- contents:
  - "9. Security Considerations\n   This memo defines a protocol between two processing
    entities, one of\n   which (the master agent) is assumed to perform authentication
    of\n   received SNMP requests and to control access to management\n   information.
    \ The master agent performs these security operations\n   independently of the
    other processing entity (the subagent).\n   Security considerations require three
    questions to be answered:\n      1. Is a particular subagent allowed to initiate
    a session with a\n         particular master agent?\n      2. During an AgentX
    session, is any SNMP security-related\n         information (for example, community
    names) passed from the\n         master agent to the subagent?\n      3. During
    an AgentX session, what part of the MIB tree is this\n         subagent allowed
    to register?\n   The answer to the third question is: A subagent can register
    any\n   subtree (subject to AgentX elements of procedure, section 7.1.4,\n   \"Processing
    the agentx-Register-PDU\").  Currently there is no access\n   control mechanism
    defined in AgentX. A concern here is that a\n   malicious subagent that registers
    an unauthorized \"sensitive\"\n   subtree, could see modification requests to
    those objects, or by\n   giving its own clever answer to NMS queries, could cause
    the NMS to\n   do something that leads to information disclosure or other damage.\n
    \  The answer to the second question is: No.\n   Now we can answer the first question.
    \ AgentX does not contain a\n   mechanism for authorizing/refusing session initiations.
    \ Thus,\n   controlling subagent access to the master agent may only be done at
    a\n   lower layer (e.g., transport).\n   An AgentX subagent can connect to a master
    agent using either a\n   network transport mechanism (e.g., TCP), or a \"local\"
    mechanism\n   (e.g., shared memory, named pipes).\n   In the case where a local
    transport mechanism is used and both\n   subagent and master agent are running
    on the same host, connection\n   authorization can be delegated to the operating
    system features.  The\n   answer to the first security question then becomes:
    \"If and only if\n   the subagent has sufficient privileges, then the operating
    system\n   will allow the connection\".\n   If a network transport is used, currently
    there is no inherent\n   security.  Transport Layer Security, SSL, or IPsec SHOULD
    be used to\n   control and protect subagent connections in this mode of operation.\n
    \  However, we RECOMMEND that subagents always run on the same host as\n   the
    master agent and that operating system features be used to ensure\n   that only
    properly authorized subagents can establish connections to\n   the master agent.\n"
  title: 9. Security Considerations
- contents:
  - "10. Acknowledgements\n   The initial development of this memo was heavily influenced
    by the\n   DPI 2.0 specification RFC 1592 [26].\n   This document was produced
    by the IETF Agent Extensibility (AgentX)\n   Working Group, and benefited especially
    from the contributions of the\n   following working group members:\n      David
    Battle, Uri Blumenthal, Jeff Case, Maria Greene, Lauren\n      Heintz, Dave Keeney,
    Harmen van der Linde, Bob Natale, Aleksey\n      Romanov, Don Ryan, and Juergen
    Schoenwaelder.\n   An honorable mention is extended to Randy Presuhn in recognition
    for\n   his numerous technical contributions to this specification; for his\n
    \  many answers provided on (and hosting of) the AgentX e-mail list and\n   ftp
    site, and, for the valued support and guidance Randy provided to\n   the Working
    Group chair.\n   The AgentX Working Group is chaired by:\n   Bob Natale\n   ACE*COMM
    Corporation\n   704 Quince Orchard Road\n   Gaithersburg, MD  20878\n   Phone:
    +1-301-721-3000\n   Fax:   +1-301-721-3001\n   EMail: bnatale@acecomm.com\n"
  title: 10. Acknowledgements
- contents:
  - "11. Authors' and Editor's Addresses\n   Mike Daniele\n   Compaq Computer Corporation\n
    \  110 Spit Brook Rd\n   Nashua, NH 03062\n   Phone: +1-603-881-1423\n   EMail:
    daniele@zk3.dec.com\n   Bert Wijnen\n   IBM T.J.Watson Research\n   Schagen 33\n
    \  3461 GL Linschoten\n   Netherlands\n   Phone: +31-348-432-794\n   EMail: wijnen@vnet.ibm.com\n
    \  Mark Ellison (WG editor)\n   Ellison Software Consulting, Inc.\n   38 Salem
    Road\n   Atkinson, NH  03811\n   Phone: +1-603-362-9270\n   EMail: ellison@world.std.com\n
    \  Dale Francisco (editor)\n   Cisco Systems\n   150 Castilian Dr\n   Goleta CA
    93117\n   Phone: +1-805-961-3642\n   Fax:   +1-805-961-3600\n   EMail: dfrancis@cisco.com\n"
  title: 11. Authors' and Editor's Addresses
- contents:
  - "12. References\n   [1]   Harrington, D., Presuhn, R. and B. Wijnen, \"An Architecture
    for\n         Describing SNMP Management Frameworks\", RFC 2571, April 1999.\n
    \  [2]   Rose, M. and K. McCloghrie, \"Structure and Identification of\n         Management
    Information for TCP/IP-based Internets\", STD 16, RFC\n         1155, May 1990.\n
    \  [3]   Rose, M. and K. McCloghrie, \"Concise MIB Definitions\", STD 16,\n         RFC
    1212, March 1991.\n   [4]   Rose, M., \"A Convention for Defining Traps for use
    with the\n         SNMP\", RFC 1215, March 1991.\n   [5]   McCloghrie, K., Perkins,
    D., Schoenwaelder, J., Case, J., Rose,\n         M. and S. Waldbusser, \"Structure
    of Management Information\n         Version 2 (SMIv2)\", STD 58, RFC 2578, April
    1999.\n   [6]   McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose,\n
    \        M. and S. Waldbusser, \"Textual Conventions for SMIv2\", STD 58,\n         RFC
    2579, April 1999.\n   [7]   McCloghrie, K., Perkins, D., Schoenwaelder, J., Case,
    J., Rose,\n         M. and S. Waldbusser, \"Conformance Statements for SMIv2\",
    STD\n         58, RFC 2580, April 1999.\n   [8]   Case, J., Fedor, M., Schoffstall,
    M. and J. Davin, \"Simple\n         Network Management Protocol\", STD 15, RFC
    1157, May 1990.\n   [9]   Case, J., McCloghrie, K., Rose, M. and S. Waldbusser,\n
    \        \"Introduction to Community-based SNMPv2\", RFC 1901, January\n         1996.\n
    \  [10]  Case, J., McCloghrie, K., Rose, M. and S. Waldbusser,\n         \"Transport
    Mappings for Version 2 of the Simple Network\n         Management Protocol (SNMPv2)\",
    RFC 1906, January 1996.\n   [11]  Case, J., Harrington D., Presuhn R. and B. Wijnen,
    \"Message\n         Processing and Dispatching for the Simple Network Management\n
    \        Protocol (SNMP)\", RFC 2572, April 1999.\n   [12]  Blumenthal, U. and
    B. Wijnen, \"User-based Security Model (USM)\n         for version 3 of the Simple
    Network Management Protocol\n         (SNMPv3)\", RFC 2574, April 1999.\n   [13]
    \ Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Protocol\n         Operations
    for Version 2 of the Simple Network Management\n         Protocol (SNMPv2)\",
    RFC 1905, January 1996.\n   [14]  Levi, D., Meyer, P. and B. Stewart, \"SNMPv3
    Applications\", RFC\n         2573, April 1999.\n   [15]  Wijnen, B., Presuhn,
    R. and K. McCloghrie, \"View-based Access\n         Control Model (VACM) for the
    Simple Network Management Protocol\n         (SNMP)\", RFC 2575, April 1999.\n
    \  [16]  Case, J., Mundy, R., Partain, D. and B. Stewart, \"Introduction\n         to
    Version 3 of the Internet-standard Network Management\n         Framework\", RFC
    2570, April 1999.\n   [17]  Case, J., McCloghrie, K., Rose, M. and S. Waldbusser,\n
    \        \"Management Information Base for Version 2 of the Simple\n         Network
    Management Protocol (SNMPv2)\", RFC 1907, January 1996.\n   [18]  Information
    processing systems - Open Systems Interconnection -\n         Specification of
    Abstract Syntax Notation One (ASN.1),\n         International Organization for
    Standardization.  International\n         Standard 8824, (December, 1987).\n   [19]
    \ McCloghrie, K. and F. Kastenholz, \"The Interfaces Group MIB\n         using
    SMIv2\", RFC 2233, November 1997.\n   [20]  Case, J., \"FDDI Management Information
    Base\", RFC 1285, January\n         1992.\n   [21]  Krupczak, C. and J. Saperia,
    \"Definitions of System-Level\n         Managed Objects for Applications\", RFC
    2287, April 1997.\n   [22]  Kalbfleisch, C., Krupczak, C., Presuhn, R. and J.
    Saperia,\n         \"Application Management MIB\", RFC 2564, May 1999.\n   [23]
    \ Reynolds, J. and J. Postel, \"Assigned Numbers\", STD 2, RFC\n         1700,
    October 1994.\n   [24]  Case, J., McCloghrie, K., Rose, M. and S. Waldbusser,\n
    \        \"Coexistence between Version 1 and Version 2 of the Internet-\n         standard
    Network Management Framework\", RFC 1908, January 1996.\n   [25]  Wijnen, B. and
    D. Levi, \"V2ToV1: Mapping SNMPv2 onto SNMPv1\n         Within a Bilingual SNMP
    Agent\", RFC 2089, January 1997.\n   [26]  Wijnen, B., Carpenter, G., Curran,
    K., Sehgal, A. and G.\n         Waters, \"Simple Network Management Protocol:
    Distributed\n         Protocol Interface, Version 2.0\", RFC 1592, March 1994.\n
    \  [27]  Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n         Levels\",
    BCP 14, RFC 2119, March 1997.\n"
  title: 12. References
- contents:
  - "13. Notices\n   The IETF takes no position regarding the validity or scope of
    any\n   intellectual property or other rights that might be claimed to\n   pertain
    to the implementation or use of the technology described in\n   this document
    or the extent to which any license under such rights\n   might or might not be
    available; neither does it represent that it\n   has made any effort to identify
    any such rights.  Information on the\n   IETF's procedures with respect to rights
    in standards-track and\n   standards-related documentation can be found in BCP-11.
    \ Copies of\n   claims of rights made available for publication and any assurances
    of\n   licenses to be made available, or the result of an attempt made to\n   obtain
    a general license or permission for the use of such\n   proprietary rights by
    implementors or users of this specification can\n   be obtained from the IETF
    Secretariat.\n   The IETF invites any interested party to bring to its attention
    any\n   copyrights, patents or patent applications, or other proprietary\n   rights
    which may cover technology that may be required to practice\n   this standard.
    \ Please address the information to the IETF Executive\n   Director.\n"
  title: 13. Notices
- contents:
  - "A. Changes relative to RFC 2257\n   Changes on the wire:\n      -  The agentx-Notify-PDU
    and agentx-Close-PDU now generate an\n         agentx-Response-PDU.\n      -  The
    res.error field may contain three new error codes:\n         parseFailed(266),
    requestDenied(267), and processingError(268).\n   Clarifications to the text of
    the memo:\n      -  Modified the text of step (4) in section 4.2, \"Applicability\"\n
    \        to separate the two concerns of row creation, and counters that\n         count
    rows.\n      -  The use of the r.range_subid field is more clearly defined in\n
    \        section 6.2.3, \"The agentx-Register-PDU\".\n      -  Default priority
    (127) for registration added to the\n         description of r.priority in section
    6.2.3, \"The agentx-\n         Register-PDU\".\n      -  Made the distinction
    of \"administrative processing\" PDUs and\n         \"SNMP request processing\"
    PDUs in section 6.1, \"AgentX PDU\n         Header\" description of h.type.  This
    distinction is used in the\n         Elements of Procedure relative to the res.sysuptime
    and\n         res.error fields.\n      -  Rewrote portions of text in section
    6.2.3, \"The agentx-\n         Register-PDU\" to be more explicit about the following
    points:\n            -  There is a default registration priority of 127.\n            -
    \ Improved the description of r.range_subid, independent of\n               the
    prefix in r.region.\n            -  Improved description and examples of how to
    use the\n               registration mechanism.\n            -  Added a description
    for r.upper_bound.\n            -  changed r.region to r.subtree (because the
    text used the\n               terms \"region\", \"range\", and \"OID range\" in
    too loose a\n               fashion.  r.subtree can not represent anything more
    by\n               itself than a simple subtree.  In conjunction with\n               r.range_subid
    and r.upper_bound, it can represent a\n               \"region\", that is, a union
    of subtrees)\n   -  Modified the text in section 6.2.4, \"The agentx-Unregister-PDU\"
    to\n      include a description of u.range_subid and u.upper_bound\n   -  Added
    use of the `requestDenied' error code in section 7.1.4,\n      \"Processing the
    agentx-Register-PDU\".\n   -  Removed text in section 7, \"Elements of Procedure\"
    on parse errors\n      and protocol errors.\n   -  Added a new section, 7.1, \"Processing
    AgentX Administrative\n      Messages\" which defines common processing and how
    to use the\n      `parseError' and `processingError' instead of closing a session,\n
    \     and how to handle context.\n   -  Removed the common processing text from
    the other administrative\n      processing Elements of Procedure sections, and
    added a reference\n      to section 7.1, \"Processing AgentX Administrative Messages\".
    \ The\n      affected sections are:\n            -  7.1.2,  \"Processing the agentx-IndexAllocate-PDU\"\n
    \           -  7.1.3,  \"Processing the agentx-IndexDeallocate-PDU\"\n            -
    \ 7.1.4,  \"Processing the agentx-Register-PDU\"\n            -  7.1.5,  \"Processing
    the agentx-Unregister-PDU\"\n            -  7.1.6,  \"Processing the agentx-AddAgentCaps-PDU\"\n
    \           -  7.1.7,  \"Processing the agentx-RemoveAgentCaps-PDU\"\n            -
    \ 7.1.8,  \"Processing the agentx-Close-PDU\"\n            -  7.1.10, \"Processing
    the agentx-Notify-PDU\"\n            -  7.1.11, \"Processing the agentx-Ping-PDU\"\n
    \  -  Reworked the text in section 7.1.1, \"Processing the\n      agentx-Open-PDU\"
    to include new error codes, and, to eliminate\n      reference to an indicated
    context.\n   -  Modified the text in Section 7.1.10, \"Processing the\n      agentx-Notify-PDU\"
    to state that context checking is performed.\n   -  Substantially modified the
    text in section 7.1.4.1, \"Handling\n      Duplicate and Overlapping Subtrees\".\n
    \  -  Removed the section on \"Using the agentx-IndexAllocate-PDU\" and\n      added
    section 7.1.4.2, \"Registering Stuff\".  This change is\n      intended to provide
    a more concise and a more cohesive\n      description of how things are supposed
    to work.\n   -  Modified the test in section 7.1.5, \"Processing the\n      agentx-Unregister-PDU\"
    to require a match on u.range_subid and\n      on u.upper_bound when these fields
    were applicable in the\n      corresponding agentx-Register-PDU.\n   -  Removed
    all references to \"splitting\", and all uses of the term\n      \"OID range\".
    \ The text now refers to regions or subtrees\n      directly, and relies on rule
    (1), \"Honoring the Registry\", in\n      section 7.2.1, \"Dispatching AgentX
    PDUs\".\n   -  Modified text in clause 4(c) of section 7.2.1, \"Dispatching\n
    \     AgentX PDUs\", clarifying that the master agent can use its\n      implementation-specific
    default timeout value when the timeout\n      value registered by the subagent
    is impractical.\n   -  Added text in section 7.2.2, \"Subagent Processing\" describing\n
    \     common processing.\n   -  Added an example to the text in section 7.2.5.3,
    \"Processing of\n      Responses to agentx-GetNext-PDU and       agentx-GetBulk-PDU\",\n
    \     and, removed the definition of \"contains\" from this section.\n   -  Modified
    text in step (1) of section 7.2.5.5, \"Processing of\n      Responses to agentx-CommitSet-PDUs\",
    eliminating directive for\n      master agent to ignore additional responses to\n
    \     agentx-CommitSet-PDUs after the first error response.\n   -  Modified text
    in section 7.2.5.6, \"Processing of Responses to\n      agentx-UndoSet-PDUs\",
    cleaning up commit/undo elements of\n      procedure per feedback received on
    the AgentX email list.\n   -  Modified the text in section 8.1.2, \"Operation\"
    to explicitly\n      prohibit interleaved sends, and, added a caution about\n
    \     exchanging AgentX messages via TCP.\n   -  Modified text to be more explicit
    that the OID in the\n      agentx-Allocate-PDU is an OBJECT-TYPE and does not
    contain any\n      instance sub-identifiers.\n   -  Replaced the term \"subagent\"
    with the term \"session\" in many\n      places throughout the text.\n   -  Modified
    the text relative to master agent processing of the\n      agentx-TestSet-PDU,
    agentx-CommitSet-PDU, and the\n      agentx-UndoSet-PDU to explicitly state that
    only \"involved\"\n      sessions receive an agentx-CommitSet-PDU, and possibly,
    an\n      agentx-UndoSet-PDU.\n   -  Modified the text to use the term \"transaction\",
    instead of\n      \"packet\" (and others), where appropriate.  This helps\n      distinguish
    the overall transaction from a particular sequence\n      of packets or PDUs.\n
    \  -  Modified the text to explicitly state that a session is not\n      required
    to support concurrent sets.\n   -  Added section 13, \"Notices\".\n   -  Added
    text to section 1, Introduction, relative to BCP 14 key\n      words.\n   -  Modified
    text to section 9, Security Considerations, to include\n      use of BCP 14 key
    words.\n   -  Modified text to section 9, Security Considerations, to include\n
    \     IPSEC as a suggested Transport Layer Security.\n"
  title: A. Changes relative to RFC 2257
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2000).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
