- title: __initial_text__
  contents:
  - '                        Token Binding over HTTP

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes a collection of mechanisms that allow HTTP\n\
    \   servers to cryptographically bind security tokens (such as cookies\n   and\
    \ OAuth tokens) to TLS connections.\n   We describe both first-party and federated\
    \ scenarios.  In a first-\n   party scenario, an HTTP server is able to cryptographically\
    \ bind the\n   security tokens that it issues to a client -- and that the client\n\
    \   subsequently returns to the server -- to the TLS connection between\n   the\
    \ client and the server.  Such bound security tokens are protected\n   from misuse,\
    \ since the server can generally detect if they are\n   replayed inappropriately,\
    \ e.g., over other TLS connections.\n   Federated Token Bindings, on the other\
    \ hand, allow servers to\n   cryptographically bind security tokens to a TLS connection\
    \ that the\n   client has with a different server than the one issuing the token.\n\
    \   This document is a companion document to \"The Token Binding Protocol\n  \
    \ Version 1.0\" (RFC 8471).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8473.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n     1.1.  Requirements Language . . . . . . . . . . . . . .\
    \ . . . .   3\n   2.  The Sec-Token-Binding HTTP Request Header Field . . . .\
    \ . . .   4\n     2.1.  HTTPS Token Binding Key-Pair Scoping  . . . . . . . .\
    \ . .   5\n   3.  TLS Renegotiation . . . . . . . . . . . . . . . . . . . . .\
    \ .   6\n   4.  First-Party Use Cases . . . . . . . . . . . . . . . . . . . .\
    \   7\n   5.  Federation Use Cases  . . . . . . . . . . . . . . . . . . . .  \
    \ 7\n     5.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .   7\n\
    \     5.2.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .   8\n  \
    \   5.3.  HTTP Redirects  . . . . . . . . . . . . . . . . . . . . .  10\n    \
    \ 5.4.  Negotiated Key Parameters . . . . . . . . . . . . . . . .  12\n     5.5.\
    \  Federation Example  . . . . . . . . . . . . . . . . . . .  13\n   6.  Implementation\
    \ Considerations . . . . . . . . . . . . . . . .  15\n   7.  Security Considerations\
    \ . . . . . . . . . . . . . . . . . . .  16\n     7.1.  Security Token Replay\
    \ . . . . . . . . . . . . . . . . . .  16\n     7.2.  Sensitivity of the Sec-Token-Binding\
    \ Header . . . . . . .  16\n     7.3.  Securing Federated Sign-On Protocols  .\
    \ . . . . . . . . .  17\n   8.  Privacy Considerations  . . . . . . . . . . .\
    \ . . . . . . . .  20\n     8.1.  Scoping of Token Binding Key Pairs  . . . .\
    \ . . . . . . .  20\n     8.2.  Lifetime of Token Binding Key Pairs . . . . .\
    \ . . . . . .  20\n     8.3.  Correlation . . . . . . . . . . . . . . . . . .\
    \ . . . . .  21\n   9.  IANA Considerations . . . . . . . . . . . . . . . . .\
    \ . . . .  22\n   10. References  . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .  22\n     10.1.  Normative References . . . . . . . . . . . . . . . .\
    \ . .  22\n     10.2.  Informative References . . . . . . . . . . . . . . . .\
    \ .  23\n   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .\
    \  25\n   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  25\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Token Binding protocol [RFC8471] defines a Token Binding\
    \ ID for a\n   TLS connection between a client and a server.  The Token Binding\
    \ ID\n   of a TLS connection is constructed using the public key of a\n   private-public\
    \ key pair.  The client proves possession of the\n   corresponding private key.\
    \  This Token Binding key pair is\n   long-lived.  That is, subsequent TLS connections\
    \ between the same\n   client and server have the same Token Binding ID, unless\
    \ specifically\n   reset, e.g., by the user.  When issuing a security token (e.g.,\
    \ an\n   HTTP cookie or an OAuth token [RFC6749]) to a client, the server can\n\
    \   include the Token Binding ID in the token, thus cryptographically\n   binding\
    \ the token to TLS connections between that particular client\n   and server,\
    \ and inoculating the token against abuse (reuse, attempted\n   impersonation,\
    \ etc.) by attackers.\n   While the Token Binding protocol [RFC8471] defines a\
    \ message format\n   for establishing a Token Binding ID, it does not specify\
    \ how this\n   message is embedded in higher-level protocols.  The purpose of\
    \ this\n   specification is to define how TokenBindingMessages are embedded in\n\
    \   HTTP (both versions 1.1 [RFC7230] and 2 [RFC7540]).  Note that\n   TokenBindingMessages\
    \ are only defined if the underlying transport\n   uses TLS.  This means that\
    \ Token Binding over HTTP is only defined\n   when HTTP is layered on top of TLS\
    \ (commonly referred to as HTTPS\n   [RFC2818]).\n   HTTP clients establish a\
    \ Token Binding ID with a server by including\n   a special HTTP header field\
    \ in HTTP requests.  The HTTP header field\n   value is a base64url-encoded TokenBindingMessage.\n\
    \   A TokenBindingMessage allows a client to establish multiple Token\n   Binding\
    \ IDs with the server by including multiple TokenBinding\n   structures.  By default,\
    \ a client will establish a Provided Token\n   Binding ID with the server, indicating\
    \ a Token Binding ID that the\n   client will persistently use with the server.\
    \  Under certain\n   conditions, the client can also include a Referred Token\
    \ Binding ID\n   in the TokenBindingMessage, indicating a Token Binding ID that\
    \ the\n   client is using with a different server than the one that the\n   TokenBindingMessage\
    \ is sent to.  This is useful in federation\n   scenarios.\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear\
    \ in all\n   capitals, as shown here.\n"
- title: 2.  The Sec-Token-Binding HTTP Request Header Field
  contents:
  - "2.  The Sec-Token-Binding HTTP Request Header Field\n   Once a client and server\
    \ have negotiated the Token Binding protocol\n   with HTTP/1.1 or HTTP/2 (see\
    \ [RFC8471] and [RFC8472]), clients MUST\n   include a Sec-Token-Binding header\
    \ field in their HTTP requests and\n   MUST include only one such header field\
    \ per HTTP request.  Also, the\n   Sec-Token-Binding header field MUST NOT be\
    \ included in HTTP\n   responses.  The ABNF of the Sec-Token-Binding header field\
    \ is (per\n   the style of [RFC7230]; see also Section 8.3 of [RFC7231]):\n  \
    \    Sec-Token-Binding = EncodedTokenBindingMessage\n   The header field name\
    \ is Sec-Token-Binding, and its single value,\n   EncodedTokenBindingMessage,\
    \ is a base64url encoding of a single\n   TokenBindingMessage, as defined in [RFC8471].\
    \  The base64url encoding\n   uses the URL and filename safe character set described\
    \ in Section 5\n   of [RFC4648], with all trailing padding characters (i.e., \"\
    =\")\n   omitted and without the inclusion of any line breaks, whitespace, or\n\
    \   other additional characters.\n   For example:\n  Sec-Token-Binding: AIkAAgBBQFzK4_bhAqLDwRQxqJWte33d7hZ0hZWHwk-miKPg4E\\\
    \n                     9fcgs7gBPoz-9RfuDfN9WCw6keHEw1ZPQMGs9CxpuHm-YAQM_j\\\n\
    \                     aOwwej6a-cQBGU7CJpUHOvXG4VvjNq8jDsvta9Y8_bPEPj25Gg\\\n \
    \                    mKiPjhJEtZA6mJ_9SNifLvVBTi7fR9wSAAAA\n   (Note that the backslashes\
    \ and line breaks are provided to ease\n   readability; they are not part of the\
    \ actual encoded message.)\n   If the server receives more than one Sec-Token-Binding\
    \ header field\n   in an HTTP request, then the server MUST reject the message\
    \ with a\n   400 (Bad Request) HTTP status code.  Additionally, the\n   Sec-Token-Binding\
    \ header field:\n   o  SHOULD NOT be stored by origin servers on PUT requests,\n\
    \   o  MAY be listed by a server in a Vary response header field, and\n   o  MUST\
    \ NOT be used in HTTP trailers.\n   The TokenBindingMessage MUST contain exactly\
    \ one TokenBinding\n   structure with a TokenBindingType value of provided_token_binding,\n\
    \   which MUST be signed with the Token Binding private key used by the\n   client\
    \ for connections between itself and the server that the HTTP\n   request is sent\
    \ to (clients use different Token Binding key pairs for\n   different servers;\
    \ see Section 2.1 below).  The Token Binding ID\n   established by this TokenBinding\
    \ is called a \"Provided Token\n   Binding ID\".\n   The TokenBindingMessage MAY\
    \ also contain exactly one TokenBinding\n   structure with a TokenBindingType\
    \ value of referred_token_binding, as\n   specified in Section 5.3.  In addition\
    \ to the latter, or rather than\n   the latter, the TokenBindingMessage MAY contain\
    \ other TokenBinding\n   structures.  This is specific to the use case in question;\
    \ such use\n   cases are outside the scope of this specification.\n   A TokenBindingMessage\
    \ is validated by the server as described in\n   Section 4.2 (\"Server Processing\
    \ Rules\") of [RFC8471].  If validation\n   fails and a Token Binding is rejected,\
    \ any associated bound tokens\n   MUST also be rejected by the server.  HTTP requests\
    \ containing\n   invalid tokens MUST be rejected.  In this case, the server\n\
    \   application MAY return HTTP status code 400 (Bad Request) or proceed\n   with\
    \ an application-specific \"invalid token\" response (e.g.,\n   directing the\
    \ client to re-authenticate and present a different\n   token), or terminate the\
    \ connection.\n   In HTTP/2, the client SHOULD use header compression [RFC7541]\
    \ to\n   avoid the overhead of repeating the same header field in subsequent\n\
    \   HTTP requests.\n"
- title: 2.1.  HTTPS Token Binding Key-Pair Scoping
  contents:
  - "2.1.  HTTPS Token Binding Key-Pair Scoping\n   HTTPS is used in conjunction with\
    \ various application protocols and\n   application contexts, in various ways.\
    \  For example, general-purpose\n   web browsing is one such HTTP-based application\
    \ context.  Within that\n   context, HTTP cookies [RFC6265] are typically utilized\
    \ for state\n   management, including client authentication.  A related, though\n\
    \   distinct, example of other HTTP-based application contexts is where\n   OAuth\
    \ tokens [RFC6749] are utilized to manage authorization for\n   third-party application\
    \ access to resources.  The token-scoping rules\n   of these two examples can\
    \ differ: the scoping rules for cookies are\n   concisely specified in [RFC6265],\
    \ whereas OAuth is a framework and\n   defines various token types with various\
    \ scopings, some of which are\n   determined by the encompassing application.\n\
    \   The scoping of Token Binding key pairs generated by web browsers for\n   the\
    \ purpose of binding HTTP cookies MUST be no wider than the\n   granularity of\
    \ a \"registered domain\" (also known as \"effective\n   top-level domain + 1\"\
    , or \"eTLD+1\").  An origin's \"registered domain\"\n   is the origin's host's\
    \ public suffix plus the label to its left\n   (where the term \"public suffix\"\
    \ is defined in the \"NOTE:\" paragraph\n   in Section 5.3 of [RFC6265] as \"\
    a domain that is controlled by a\n   public registry\").  For example, for \"\
    https://www.example.com\", the\n   public suffix (eTLD) is \"com\", and the registered\
    \ domain (eTLD+1) is\n   \"example.com\".  User Agents SHOULD use an up-to-date\
    \ public suffix\n   list, such as the one maintained by Mozilla [PSL].\n   This\
    \ means that in practice the scope of a Token Binding key pair is\n   no larger\
    \ than the scope of a cookie allowed by a web browser.  If a\n   web browser restricts\
    \ cookies to a narrower scope than registered\n   domains, the scope of Token\
    \ Binding key pairs MAY also be narrower.\n   This applies to the use of Token\
    \ Binding key pairs in first-party use\n   cases, as well as in federation use\
    \ cases defined in this\n   specification (Section 5).\n   Key pairs used to bind\
    \ other application tokens, such as OAuth tokens\n   or \"OpenID Connect\" ID\
    \ Tokens [OpenID.Core], SHOULD adhere to the\n   above eTLD+1 scoping requirement\
    \ for those tokens being employed in\n   first-party or federation scenarios.\
    \  Applications other than web\n   browsers MAY use different key-pair scoping\
    \ rules.  See also\n   Section 8.1 below.\n   Scoping rules for other HTTP-based\
    \ application contexts are outside\n   the scope of this specification.\n"
- title: 3.  TLS Renegotiation
  contents:
  - "3.  TLS Renegotiation\n   Token Binding over HTTP/1.1 [RFC7230] can be performed\
    \ in combination\n   with TLS renegotiation.  In this case, renegotiation MUST\
    \ only occur\n   between a client's HTTP request and the server's response, the\
    \ client\n   MUST NOT send any pipelined requests, and the client MUST NOT\n \
    \  initiate renegotiation.  (That is, the client may only send a\n   renegotiation\
    \ ClientHello in response to the server's HelloRequest.)\n   These conditions\
    \ ensure that both the client and the server can\n   clearly identify which TLS\
    \ Exported Keying Material value [RFC5705]\n   to use when generating or verifying\
    \ the TokenBindingMessage.  This\n   also prevents a TokenBindingMessage from\
    \ being split across TLS\n   renegotiation boundaries due to TLS message fragmentation;\
    \ see\n   Section 6.2.1 of [RFC5246].\n   (Note: This document deals with TLS\
    \ 1.2 and therefore refers to\n   RFC 5246 (which has been obsoleted by RFC 8446);\
    \ [TOKENBIND-TLS13]\n   addresses Token Binding in TLS 1.3.)\n"
- title: 4.  First-Party Use Cases
  contents:
  - "4.  First-Party Use Cases\n   In a first-party use case (also known as a \"same-site\"\
    \ use case), an\n   HTTP server issues a security token such as a cookie (or similar)\
    \ to\n   a client and expects the client to return the security token at a\n \
    \  later time, e.g., in order to authenticate.  Binding the security\n   token\
    \ to the TLS connection between the client and the server\n   protects the security\
    \ token from misuse, since the server can detect\n   if the security token is\
    \ replayed inappropriately, e.g., over other\n   TLS connections.\n   See Section\
    \ 5 of [RFC8471] for general guidance regarding the binding\n   of security tokens\
    \ and their subsequent validation.\n"
- title: 5.  Federation Use Cases
  contents:
  - '5.  Federation Use Cases

    '
- title: 5.1.  Introduction
  contents:
  - "5.1.  Introduction\n   For privacy reasons, clients use different Token Binding\
    \ key pairs to\n   establish Provided Token Binding IDs with different servers.\
    \  As a\n   result, a server cannot bind a security token (such as an OAuth token\n\
    \   or an OpenID Connect ID Token [OpenID.Core]) to a TLS connection that\n  \
    \ the client has with a different server.  This is, however, a common\n   requirement\
    \ in federation scenarios: for example, an Identity\n   Provider may wish to issue\
    \ an identity token to a client and\n   cryptographically bind that token to the\
    \ TLS connection between the\n   client and a Relying Party.\n   In this section,\
    \ we describe mechanisms to achieve this.  The common\n   idea among these mechanisms\
    \ is that a server (called the \"Token\n   Consumer\" in this document) signals\
    \ to the client that it should\n   reveal the Provided Token Binding ID that is\
    \ used between the client\n   and itself to another server (called the \"Token\
    \ Provider\" in this\n   document).  Also common across the mechanisms is how\
    \ the Token\n   Binding ID is revealed to the Token Provider: the client uses\
    \ the\n   Token Binding protocol [RFC8471] and includes a TokenBinding\n   structure\
    \ in the Sec-Token-Binding HTTP header field defined above.\n   What differs between\
    \ the various mechanisms is how the Token Consumer\n   signals to the client that\
    \ it should reveal the Token Binding ID to\n   the Token Provider.  Below, we\
    \ specify one such mechanism, which is\n   suitable for redirect-based interactions\
    \ between Token Consumers and\n   Token Providers.\n   Client                \
    \        Token Consumer         Token Provider\n   +--------+                \
    \        +----+                +-----+\n   | Client |                        |\
    \ TC |                | TP  |\n   +--------+                        +----+   \
    \             +-----+\n       |                               |              \
    \        |\n       |                               |                      |\n\
    \       |                               |                      |\n       | Client\
    \ interacts w/TC         |                      |\n       | using TokenBindingID\
    \ TBID1:   |                      |\n       | TBMSG[[provided_token_binding,|\
    \                      |\n       |        TBID1, signature]]     |           \
    \           |\n       |------------------------------>|                      |\n\
    \       |                               |                      |\n       | Client\
    \ interacts w/TP                                |\n       | using TokenBindingID\
    \ TBID2:                          |\n       | TBMSG[[provided_token_binding, \
    \                      |\n       |        TBID2, signature]]                 \
    \           |\n       |----------------------------------------------------->|\n\
    \       |                                                      |\n       |   \
    \                            |                      |\n       | TC signals permission\
    \ to      |                      |\n       | reveal TBID1 to TP            | \
    \                     |\n       |<------------------------------|            \
    \          |\n       |                               |                      |\n\
    \       |                                                      |\n       | Client\
    \ interacts w/TP                                |\n       | using TokenBindingID\
    \ TBID1 and TBID2:                |\n       | TBMSG[[provided_token_binding, \
    \                      |\n       |        TBID2, signature],                 \
    \           |\n       |       [referred_token_binding,                       |\n\
    \       |        TBID1, signature]]                            |\n       |----------------------------------------------------->|\n\
    \       |                                                      |\n       |   \
    \                            |                      |\n       |              \
    \                 |                      |\n"
- title: 5.2.  Overview
  contents:
  - "5.2.  Overview\n   In a federated sign-on protocol, an Identity Provider issues\
    \ an\n   identity token to a client, which sends the identity token to a\n   Relying\
    \ Party to authenticate itself.  Examples of this include\n   OpenID Connect (in\
    \ which the identity token is called an \"ID Token\")\n   and the Security Assertion\
    \ Markup Language (SAML)\n   [OASIS.saml-core-2.0-os] (in which the identity token\
    \ is a SAML\n   assertion).\n   To better protect the security of the identity\
    \ token, the Identity\n   Provider may wish to bind the identity token to the\
    \ TLS connection\n   between the client and the Relying Party, thus ensuring that\
    \ only\n   said client can use the identity token.  The Relying Party will\n \
    \  compare the Token Binding ID (or a cryptographic hash of it) in the\n   identity\
    \ token with the Token Binding ID (or a hash thereof) of the\n   TLS connection\
    \ between this Relying Party and the client.\n   This is an example of a federation\
    \ scenario, which more generally can\n   be described as follows:\n   o  A Token\
    \ Consumer causes the client to issue a token request to the\n      Token Provider.\
    \  The goal is for the client to obtain a token and\n      then use it with the\
    \ Token Consumer.\n   o  The client delivers the token request to the Token Provider.\n\
    \   o  The Token Provider issues the token.  The token is issued for the\n   \
    \   specific Token Consumer who requested it (thus preventing\n      malicious\
    \ Token Consumers from using tokens with other Token\n      Consumers).  The token\
    \ is, however, typically a bearer token,\n      meaning that any client can use\
    \ it with the Token Consumer -- not\n      just the client to which it was issued.\n\
    \   o  Therefore, in the previous step, the Token Provider may want to\n     \
    \ include in the token the Token Binding ID (or a cryptographic hash\n      of\
    \ it) that the client uses when communicating with the Token\n      Consumer,\
    \ thus binding the token to the client's Token Binding key\n      pair.  The client\
    \ proves possession of the private key when\n      communicating with the Token\
    \ Consumer through the Token Binding\n      protocol [RFC8471] and uses the corresponding\
    \ public key of this\n      key pair as a component of the Token Binding ID. \
    \ Comparing the\n      Token Binding ID from the token to the Token Binding ID\n\
    \      established with the client allows the Token Consumer to verify\n     \
    \ that the token was sent to it by the legitimate client.\n   o  To allow the\
    \ Token Provider to include the Token Binding ID in the\n      token, the Token\
    \ Binding ID between the client and the Token\n      Consumer must therefore be\
    \ communicated to the Token Provider\n      along with the token request.  Communicating\
    \ a Token Binding ID\n      involves proving possession of a private key and is\
    \ described in\n      the Token Binding protocol [RFC8471].\n   The client will\
    \ perform this last operation only if the Token\n   Consumer requests the client\
    \ to do so.\n   Below, we specify how Token Consumers can signal this request\
    \ in\n   redirect-based federation protocols.  Note that this assumes that the\n\
    \   federated sign-on flow starts at the Token Consumer or, at the very\n   least,\
    \ includes a redirect from the Token Consumer to the Token\n   Provider.  It is\
    \ outside the scope of this document to specify\n   similar mechanisms for flows\
    \ that do not include such redirects.\n"
- title: 5.3.  HTTP Redirects
  contents:
  - "5.3.  HTTP Redirects\n   When a Token Consumer redirects the client to a Token\
    \ Provider as a\n   means to deliver the token request, it SHOULD include an\n\
    \   Include-Referred-Token-Binding-ID HTTP response header field in its\n   HTTP\
    \ response.  The ABNF of the Include-Referred-Token-Binding-ID\n   header is (per\
    \ the style of [RFC7230]; see also Section 8.3 of\n   [RFC7231]):\n      Include-Referred-Token-Binding-ID\
    \ = \"true\"\n   Where the header field name is \"Include-Referred-Token-Binding-ID\"\
    \n   and the field value of \"true\" is case insensitive.  For example:\n    \
    \  Include-Referred-Token-Binding-ID: true\n   Including this response header\
    \ field signals to the client that it\n   should reveal, to the Token Provider,\
    \ the Token Binding ID used\n   between itself and the Token Consumer.  In the\
    \ absence of this\n   response header field, the client will not disclose any\
    \ information\n   about the Token Binding used between the client and the Token\n\
    \   Consumer to the Token Provider.\n   As illustrated in Section 5.5, when a\
    \ client receives this header\n   field, it should take the TokenBindingID [RFC8471]\
    \ of the provided\n   TokenBinding from the referrer and create a referred TokenBinding\n\
    \   with it to include in the TokenBindingMessage in the redirect\n   request.\
    \  In other words, the Token Binding message in the redirect\n   request to the\
    \ Token Provider now includes one provided binding and\n   one referred binding,\
    \ the latter constructed from the binding between\n   the client and the Token\
    \ Consumer.\n   When a client receives the Include-Referred-Token-Binding-ID header,\n\
    \   it includes the referred Token Binding even if both the Token\n   Provider\
    \ and the Token Consumer fall under the same eTLD+1 and the\n   provided and Referred\
    \ Token Binding IDs are the same.\n   The referred Token Binding is sent only\
    \ in the initial request\n   resulting from the HTTP response that included the\n\
    \   Include-Referred-Token-Binding-ID header.  Should the response to\n   that\
    \ initial request be a further redirect, the original referred\n   Token Binding\
    \ is no longer included in subsequent requests.  (A new\n   referred Token Binding\
    \ may be included if the redirecting endpoint\n   itself responded with an Include-Referred-Token-Binding-ID\
    \ response\n   header.)\n   If the Include-Referred-Token-Binding-ID header field\
    \ is\n   received in response to a request that did not include the\n   Sec-Token-Binding\
    \ header field, the client MUST ignore the\n   Include-Referred-Token-Binding-ID\
    \ header field.\n   This header field only has meaning if the HTTP status code\
    \ is a\n   redirection code (300-399) and MUST be ignored by the client for any\n\
    \   other status codes.  As described in Section 2, if the client\n   supports\
    \ the Token Binding protocol and has negotiated the Token\n   Binding protocol\
    \ with both the Token Consumer and the Token Provider,\n   it sends the Sec-Token-Binding\
    \ header field to the Token Provider\n   with each HTTP request.\n   The TokenBindingMessage\
    \ included in the redirect request to the Token\n   Provider SHOULD contain a\
    \ TokenBinding with a TokenBindingType value\n   of referred_token_binding.  If\
    \ included, this TokenBinding MUST be\n   signed with the Token Binding private\
    \ key used by the client for\n   connections between itself and the Token Consumer\
    \ (more specifically,\n   the server that issued the Include-Referred-Token-Binding-ID\
    \ response\n   header field).  The Token Binding ID established by this TokenBinding\n\
    \   is called a \"Referred Token Binding ID\".\n   As described above, the TokenBindingMessage\
    \ MUST additionally contain\n   a Provided Token Binding ID, i.e., a TokenBinding\
    \ structure with a\n   TokenBindingType value of provided_token_binding, which\
    \ MUST be\n   signed with the Token Binding private key used by the client for\n\
    \   connections between itself and the Token Provider (more specifically,\n  \
    \ the server that the token request is being sent to).\n   If, for some deployment-specific\
    \ reason, the initial Token Provider\n   (\"TP1\") needs to redirect the client\
    \ to another Token Provider\n   (\"TP2\") rather than directly back to the Token\
    \ Consumer, it can be\n   accommodated using the header fields defined in this\
    \ specification in\n   the following fashion (\"the redirect-chain approach\"\
    ):\n      Initially, the client is redirected to TP1 by the Token Consumer\n \
    \     (\"TC\"), as described above.  Upon receiving a client's request\n     \
    \ that contains a TokenBindingMessage that in turn contains both\n      provided\
    \ and referred TokenBindings (for TP1 and TC,\n      respectively), TP1 responds\
    \ to the client with a redirect response\n      that (1) contains the Include-Referred-Token-Binding-ID\
    \ header\n      field and (2) directs the client to send a request to TP2.  This\n\
    \      causes the client to follow the same pattern and send a request\n     \
    \ containing a TokenBindingMessage that contains both provided and\n      referred\
    \ TokenBindings (for TP2 and TP1, respectively) to TP2.\n      Note that this\
    \ pattern can continue to additional Token Providers.\n      In this case, TP2\
    \ issues a security token, bound to the client's\n      TokenBinding with TP1,\
    \ and sends a redirect response to the client\n      pointing to TP1.  TP1 in\
    \ turn constructs a security token for the\n      Token Consumer, bound to the\
    \ TC's referred TokenBinding that had\n      been conveyed earlier, and sends\
    \ a redirect response pointing to\n      the TC, containing the bound security\
    \ token, to the client.\n   The above is intended as only a non-normative example.\
    \  Details are\n   specific to deployment contexts.  Other approaches are possible\
    \ but\n   are outside the scope of this specification.\n"
- title: 5.4.  Negotiated Key Parameters
  contents:
  - "5.4.  Negotiated Key Parameters\n   The TLS extension for Token Binding protocol\
    \ negotiation [RFC8472]\n   allows the server and client to negotiate the parameters\
    \ (signature\n   algorithm, length) of the Token Binding key pair.  It is possible\n\
    \   that the Token Binding ID used between the client and the Token\n   Consumer,\
    \ and the Token Binding ID used between the client and the\n   Token Provider,\
    \ use different key parameters.  The client MUST use\n   the key parameters negotiated\
    \ with the Token Consumer in the\n   referred_token_binding TokenBinding of the\
    \ TokenBindingMessage, even\n   if those key parameters are different from the\
    \ ones negotiated with\n   the server that the header field is sent to.\n   Token\
    \ Providers SHOULD support all the Token Binding key parameters\n   specified\
    \ in [RFC8471].  If a Token Provider does not support the key\n   parameters specified\
    \ in the referred_token_binding TokenBinding in\n   the TokenBindingMessage, it\
    \ MUST NOT issue a bound token.\n"
- title: 5.5.  Federation Example
  contents:
  - "5.5.  Federation Example\n   The diagram below shows a typical HTTP redirect-based\
    \ web browser\n   single sign-on (SSO) profile (Section 4.1 of\n   [OASIS.saml-prof-2.0-os])\
    \ (no artifact, no callbacks), featuring the\n   binding of, for example, a TLS\
    \ Token Binding ID into an OpenID\n   Connect ID Token.\n                    \
    \              Legend:\n   +------------+------------------------------------------------------+\n\
    \   | EKM:       | TLS Exported Keying Material [RFC5705]               |\n  \
    \ |            |                                                      |\n   |\
    \ {EKMn}Ksm: | EKM for server \"n\", signed by the private key of     |\n   |\
    \            | TBID \"m\", where \"n\" must represent the server        |\n  \
    \ |            | receiving the ETBMSG.  If a conveyed TB's type is    |\n   |\
    \            | provided_token_binding, then m = n, else if TB's     |\n   |  \
    \          | type is referred_token_binding, then m != n.  For    |\n   |    \
    \        | example, see step 1b in the diagram below.           |\n   |      \
    \      |                                                      |\n   | ETBMSG:\
    \    | \"Sec-Token-Binding\" HTTP header field conveying an   |\n   |        \
    \    | EncodedTokenBindingMessage, in turn conveying        |\n   |          \
    \  | TokenBinding (TB)struct(s), e.g., ETBMSG[[TB]] or    |\n   |            |\
    \ ETBMSG[[TB1],[TB2]]                                  |\n   |            |  \
    \                                                    |\n   | ID Token:  | the\
    \ ID Token in OpenID Connect.  It is the semantic  |\n   |            | equivalent\
    \ of a SAML \"authentication assertion\".     |\n   |            | \"ID Token\
    \ w/TBIDn\" denotes a \"token bound\" ID Token  |\n   |            | containing\
    \ TBIDn.                                    |\n   |            |             \
    \                                         |\n   | Ks and Kp: | private (aka secret)\
    \ key and public key,             |\n   |            | respectively, of the client-side\
    \ Token Binding key   |\n   |            | pair                              \
    \                   |\n   |            |                                     \
    \                 |\n   | OIDC:      | OpenID Connect                        \
    \               |\n   |            |                                         \
    \             |\n   | TB:        | TokenBinding struct containing a signed EKM,\
    \ TBID,   |\n   |            | and TB type, e.g.,                            \
    \       |\n   |            | [{EKM1}Ks1,TBID1,provided_token_binding]        \
    \     |\n   |            |                                                   \
    \   |\n   | TBIDn:     | Token Binding ID for client and server n's token-   \
    \ |\n   |            | bound TLS association.  TBIDn contains Kpn.          |\n\
    \   +------------+------------------------------------------------------+\n"
- title: Client, aka                Token Consumer, aka    Token Provider, aka
  contents:
  - 'Client, aka                Token Consumer, aka    Token Provider, aka

    '
- title: User Agent                 OpenID Client,         OpenID Provider,
  contents:
  - "User Agent                 OpenID Client,         OpenID Provider,\n        \
    \                   OIDC Relying Party,    OIDC Provider,\n                  \
    \         SAML Relying Party     SAML Identity Provider\n                    \
    \       [ server \"1\" ]         [ server \"2\" ]\n"
- title: +--------+                       +----+                 +-----+
  contents:
  - '+--------+                       +----+                 +-----+

    '
- title: '| Client |                       | TC |                 | TP  |'
  contents:
  - '| Client |                       | TC |                 | TP  |

    '
- title: +--------+                       +----+                 +-----+
  contents:
  - "+--------+                       +----+                 +-----+\n    |      \
    \                         |                      |\n    |                    \
    \           |                      |\n    |                               |  \
    \                    |\n    | 0. Client interacts w/TC      |                \
    \      |\n    | over HTTPS, establishes Ks1 and Kp1, TBID1           |\n    |\
    \ ETBMSG[[{EKM1}Ks1,TBID1,provided_token_binding]]     |\n    |------------------------------>|\
    \                      |\n    |                               |              \
    \        |\n    |                               |                      |\n   \
    \ |                               |                      |\n    | 1a. OIDC ID\
    \ Token request, aka|                      |\n    | \"Authentication Request\"\
    , conveyed with              |\n    | an HTTP response header field of       \
    \              |\n    | Include-Referred-Token-Binding-ID:true.              |\n\
    \    | Any security-relevant cookies |                      |\n    | should contain\
    \ TBID1.         |                      |\n  +<- - - - - - - - - - - - - - - -\
    \ |                      |\n  . | (redirect to TP via 301, 302, |            \
    \          |\n  . |  303, 307, or 308)            |                      |\n \
    \ . |                               |                      |\n  +------------------------------------------------------->|\n\
    \    | 1b. opens HTTPS w/TP,                                |\n    | establishes\
    \ Ks2, Kp2, TBID2;                         |\n    | sends a GET or POST with \
    \                            |\n    | ETBMSG[[{EKM2}Ks2,TBID2,provided_token_binding],\
    \     |\n    |        [{EKM2}Ks1,TBID1,referred_token_binding]]     |\n    | as\
    \ well as the ID Token request                      |\n    |                 \
    \              |                      |\n    |                               |\
    \                      |\n    |                               |              \
    \        |\n    | 2. user authentication (if applicable;               |\n   \
    \ |    methods vary; particulars are out of scope)       |\n    |<====================================================>|\n\
    \    | (TP generates ID Token for TC containing TBID1; may  |\n    |  also set\
    \ cookie(s) containing TBID2 and/or TBID1;   |\n    |  details vary; particulars\
    \ are out of scope)         |\n    |                               |         \
    \             |\n    |                               |                      |\n\
    \    |                               |                      |\n    | 3a. ID Token\
    \ containing Kp1, issued for TC,          |\n    |    conveyed via OIDC \"Authentication\
    \ Response\"       |\n  +<- - - - - - - - - - - - - - - - - - - - - - - - - -\
    \ - -|\n  . |   (redirect to TC)            |                      |\n  . |  \
    \                             |                      |\n  . |                \
    \               |                      |\n  +-------------------------------->|\
    \                      |\n    | 3b. HTTPS GET or POST with                   \
    \        |\n    | ETBMSG[[{EKM1}Ks1,TBID1,provided_token_binding]]     |\n   \
    \ | conveying an Authentication Response containing      |\n    | an ID Token\
    \ w/TBID1, issued for TC                   |\n    |                          \
    \     |                      |\n    |                               |        \
    \              |\n    |                               |                      |\n\
    \    | 4. user is signed on; any security-relevant cookie(s)|\n    | that is set\
    \ SHOULD contain TBID1                     |\n    |<------------------------------|\
    \                      |\n    |                               |              \
    \        |\n    |                               |                      |\n"
- title: 6.  Implementation Considerations
  contents:
  - "6.  Implementation Considerations\n   HTTPS-based applications may have multi-party\
    \ use cases other than,\n   or in addition to, the HTTP redirect-based signaling\
    \ and conveyance\n   of referred Token Bindings, as presented above in Section\
    \ 5.3.\n   Thus, Token Binding implementations should provide APIs for such\n\
    \   applications to generate Token Binding messages containing Token\n   Binding\
    \ IDs of various application-specified Token Binding types, to\n   be conveyed\
    \ by the Sec-Token-Binding header field.\n   However, Token Binding implementations\
    \ MUST only convey Token Binding\n   IDs to servers if signaled to do so by an\
    \ application.  Signaling\n   mechanisms other than the Include-Referred-Token-Binding-ID\
    \ HTTP\n   response header field are possible, but these mechanisms are outside\n\
    \   the scope of this specification.\n   NOTE: See Section 8 (\"Privacy Considerations\"\
    ) for privacy guidance\n         regarding the use of this functionality.\n"
- title: 7.  Security Considerations
  contents:
  - '7.  Security Considerations

    '
- title: 7.1.  Security Token Replay
  contents:
  - "7.1.  Security Token Replay\n   The goal of the federated Token Binding mechanisms\
    \ is to prevent\n   attackers from exporting and replaying tokens used in protocols\n\
    \   between the client and the Token Consumer, thereby impersonating\n   legitimate\
    \ users and gaining access to protected resources.  Although\n   bound tokens\
    \ can still be replayed by any malware present in clients\n   (which may be undetectable\
    \ to a server), in order to export bound\n   tokens to other machines and successfully\
    \ replay them, attackers also\n   need to export the corresponding Token Binding\
    \ private keys.  Token\n   Binding private keys are therefore high-value assets\
    \ and SHOULD be\n   strongly protected, ideally by generating them in a hardware\
    \ security\n   module that prevents key export.\n   This consideration is a special\
    \ case of the scenario described in\n   Section 7.1 (\"Security Token Replay\"\
    ) of [RFC8471].\n"
- title: 7.2.  Sensitivity of the Sec-Token-Binding Header
  contents:
  - "7.2.  Sensitivity of the Sec-Token-Binding Header\n   The purpose of the Token\
    \ Binding protocol is to convince the server\n   that the client that initiated\
    \ the TLS connection controls a certain\n   key pair.  For the server to correctly\
    \ draw this conclusion after\n   processing the Sec-Token-Binding header field,\
    \ certain secrecy and\n   integrity requirements must be met.\n   For example,\
    \ the client must keep its Token Binding private key\n   secret.  If the private\
    \ key is not secret, then another actor in the\n   system could create a valid\
    \ Token Binding header field and thereby\n   impersonate the client.  This can\
    \ render the main purpose of the\n   protocol -- to bind bearer tokens to certain\
    \ clients -- moot.\n   Consider, for example, an attacker who obtained (perhaps\
    \ through a\n   network intrusion) an authentication cookie that a client uses\
    \ with a\n   certain server.  Consider further that the server bound that cookie\n\
    \   to the client's Token Binding ID precisely to thwart misuse of the\n   cookie.\
    \  If the attacker were to come into possession of the client's\n   private key,\
    \ they could then establish a TLS connection with the\n   server and craft a Sec-Token-Binding\
    \ header field that matches the\n   binding present in the cookie, thus successfully\
    \ authenticating as\n   the client and gaining access to the client's data at\
    \ the server.\n   The Token Binding protocol, in this case, did not successfully\
    \ bind\n   the cookie to the client.\n   Likewise, we need integrity protection\
    \ of the Sec-Token-Binding\n   header field.  A client should not be tricked into\
    \ sending to a\n   server a Sec-Token-Binding header field that contains Token\
    \ Bindings\n   signed with any Token Binding keys that the client does not control.\n\
    \   Consider an attacker A that somehow has knowledge of the Exported\n   Keying\
    \ Material (EKM) for a TLS connection between a client C and a\n   server S. \
    \ (While that is somewhat unlikely, it is also not entirely\n   out of the question,\
    \ since the client might not treat the EKM as a\n   secret -- after all, a pre-image-resistant\
    \ hash function has been\n   applied to the TLS master secret, making it impossible\
    \ for someone\n   knowing the EKM to recover the TLS master secret.  Such\n  \
    \ considerations might lead some clients to not treat the EKM as a\n   secret.)\
    \  Such an attacker A could craft a Sec-Token-Binding header\n   field with A's\
    \ key pair over C's EKM.  If the attacker could now\n   trick C into sending such\
    \ a header field to S, it would appear to S\n   as if C controls a certain key\
    \ pair, when in fact it does not (the\n   attacker A controls the key pair).\n\
    \   If A has a pre-existing relationship with S (e.g., perhaps has an\n   account\
    \ on S), it now appears to the server S as if A is connecting\n   to it, even\
    \ though it is really C.  (If the server S does not simply\n   use Token Binding\
    \ IDs to identify clients but also uses bound\n   authentication cookies, then\
    \ A would also have to trick C into\n   sending one of A's cookies to S, which\
    \ it can do through a variety of\n   means -- inserting cookies through JavaScript\
    \ APIs, setting cookies\n   through related-domain attacks, etc.)  In other words,\
    \ in this\n   scenario, A can trick C into logging into A's account on S.  This\n\
    \   could lead to a loss of privacy for C, since A presumably has some\n   other\
    \ way to also access the account and can thus indirectly observe\n   C's behavior\
    \ (for example, if S has a feature that lets account\n   holders see their activity\
    \ history on S).\n   Therefore, we need to protect the integrity of the Sec-Token-Binding\n\
    \   header field.  One eTLD+1 should not be able to set the\n   Sec-Token-Binding\
    \ header field (through a Document Object Model (DOM)\n   API [W3C.REC-DOM-Level-3-Core-20040407]\
    \ or otherwise) that the User\n   Agent uses with another eTLD+1.  Employing the\
    \ \"Sec-\" header field\n   prefix helps to meet this requirement by denoting\
    \ the header field\n   name as a \"forbidden header name\"; see [fetch-spec].\n"
- title: 7.3.  Securing Federated Sign-On Protocols
  contents:
  - "7.3.  Securing Federated Sign-On Protocols\n   As explained above, in a federated\
    \ sign-on scenario, a client will\n   prove possession of two different Token\
    \ Binding private keys to a\n   Token Provider: one private key corresponds to\
    \ the \"provided\" Token\n   Binding ID (which the client normally uses with the\
    \ Token Provider),\n   and the other is the Token Binding private key corresponding\
    \ to the\n   \"referred\" Token Binding ID (which the client normally uses with\
    \ the\n   Token Consumer).  The Token Provider is expected to issue a token\n\
    \   that is bound to the Referred Token Binding ID.\n   Both proofs (that of the\
    \ provided Token Binding private key and that\n   of the referred Token Binding\
    \ private key) are necessary.  To show\n   this, consider the following scenario:\n\
    \   o  The client has an authentication token with the Token Provider\n      that\
    \ is bound to the client's Token Binding ID used with that\n      Token Provider.\n\
    \   o  The client wants to establish a secure (i.e., free of men-in-the-\n   \
    \   middle) authenticated session with the Token Consumer but has not\n      yet\
    \ done so (in other words, we are about to run the federated\n      sign-on protocol).\n\
    \   o  A man-in-the-middle is allowed to intercept the connection between\n  \
    \    the client and the Token Consumer or between the client and the\n      Token\
    \ Provider (or both).\n   The goal is to detect the presence of the man-in-the-middle\
    \ in these\n   scenarios.\n   First, consider a man-in-the-middle between the\
    \ client and the Token\n   Provider.  Recall that we assume that the client possesses\
    \ a bound\n   authentication token (e.g., cookie) for the Token Provider.  The\n\
    \   man-in-the-middle can intercept and modify any message sent by the\n   client\
    \ to the Token Provider and any message sent by the Token\n   Provider to the\
    \ client.  (This means, among other things, that the\n   man-in-the-middle controls\
    \ the JavaScript running at the client in\n   the origin of the Token Provider.)\
    \  It is not, however, in possession\n   of the client's Token Binding private\
    \ key.  Therefore, it can choose\n   to either (1) replace the Token Binding ID\
    \ in requests from the\n   client to the Token Provider and create a Sec-Token-Binding\
    \ header\n   field that matches the TLS connection between the man-in-the-middle\n\
    \   and the Token Provider or (2) leave the Sec-Token-Binding header\n   field\
    \ unchanged.  If it chooses the latter, the signature in the\n   Token Binding\
    \ message (created by the original client on the EKM for\n   the connection between\
    \ the client and the man-in-the-middle) will not\n   match a signature on the\
    \ EKM between the man-in-the-middle and the\n   Token Provider.  If it chooses\
    \ the former (and creates its own\n   signature, using its own Token Binding private\
    \ key, over the EKM for\n   the connection between itself, the man-in-the-middle,\
    \ and the Token\n   Provider), then the Token Binding message will match the connection\n\
    \   between the man-in-the-middle and the Token Provider, but the Token\n   Binding\
    \ ID in the message will not match the Token Binding ID that\n   the client's\
    \ authentication token is bound to.  Either way, the\n   man-in-the-middle is\
    \ detected by the Token Provider, but only if the\n   proof of possession of the\
    \ provided Token Binding private key is\n   required in the protocol (as is done\
    \ above).\n   Next, consider the presence of a man-in-the-middle between the client\n\
    \   and the Token Consumer.  That man-in-the-middle can intercept and\n   modify\
    \ any message sent by the client to the Token Consumer and any\n   message sent\
    \ by the Token Consumer to the client.  The Token Consumer\n   is the party that\
    \ redirects the client to the Token Provider.  In\n   this case, the man-in-the-middle\
    \ controls the redirect URL and can\n   tamper with any redirect URL issued by\
    \ the Token Consumer (as well as\n   with any JavaScript running in the origin\
    \ of the Token Consumer).\n   The goal of the man-in-the-middle is to trick the\
    \ Token Provider into\n   issuing a token bound to its Token Binding ID and not\
    \ to the Token\n   Binding ID of the legitimate client.  To thwart this goal of\
    \ the\n   man-in-the-middle, the client's Referred Token Binding ID must be\n\
    \   communicated to the Token Provider in a manner that cannot be\n   affected\
    \ by the man-in-the-middle (who, as mentioned above, can\n   modify redirect URLs\
    \ and JavaScript at the client).  Including the\n   referred TokenBinding structure\
    \ in the Sec-Token-Binding header field\n   (as opposed to, say, including the\
    \ Referred Token Binding ID in an\n   application-level message as part of the\
    \ redirect URL) is one way to\n   assure that the man-in-the-middle between the\
    \ client and the Token\n   Consumer cannot affect the communication of the Referred\
    \ Token\n   Binding ID to the Token Provider.\n   Therefore, the Sec-Token-Binding\
    \ header field in the federated\n   sign-on use case contains both a proof of\
    \ possession of the provided\n   Token Binding key and a proof of possession of\
    \ the referred Token\n   Binding key.\n   Note that the presence of Token Binding\
    \ does not relieve the Token\n   Provider and Token Consumer from performing various\
    \ checks to ensure\n   the security of clients during the use of federated sign-on\n\
    \   protocols.  These include the following:\n   o  The Token Provider should\
    \ not issue tokens to Token Consumers that\n      have been shown to act maliciously.\
    \  To aid in this, the\n      federation protocol should identify the Token Consumer\
    \ to the\n      Token Provider (e.g., through OAuth client IDs or similar\n  \
    \    mechanisms), and the Token Provider should ensure that tokens are\n     \
    \ indeed issued to the Token Consumer identified in the token\n      request (e.g.,\
    \ by verifying that the redirect URI is associated\n      with the OAuth client\
    \ ID).\n   o  The Token Consumer should verify that the tokens were issued for\n\
    \      it and not for some other Token Consumer.  To aid in this, the\n      federation\
    \ protocol should include an audience parameter in the\n      token response or\
    \ apply equivalent mechanisms (the implicit OAuth\n      flow requires Token Consumers\
    \ to identify themselves when they\n      exchange OAuth authorization codes for\
    \ OAuth refresh tokens,\n      leaving it up to the Token Provider to verify that\
    \ the OAuth\n      authorization was delivered to the correct Token Consumer).\n"
- title: 8.  Privacy Considerations
  contents:
  - '8.  Privacy Considerations

    '
- title: 8.1.  Scoping of Token Binding Key Pairs
  contents:
  - "8.1.  Scoping of Token Binding Key Pairs\n   Clients use different Token Binding\
    \ key pairs for different servers,\n   so as to not allow Token Binding to become\
    \ a tracking tool across\n   different servers.  However, the scoping of the Token\
    \ Binding key\n   pairs to servers varies according to the scoping rules of the\n\
    \   application protocol (Section 4.1 of [RFC8471]).\n   In the case of HTTP cookies,\
    \ servers may use Token Binding to secure\n   their cookies.  These cookies can\
    \ be attached to any subdomain of\n   effective top-level domains (eTLDs), and\
    \ clients therefore should use\n   the same Token Binding key pair across such\
    \ subdomains.  This will\n   ensure that any server capable of receiving the cookie\
    \ will see the\n   same Token Binding ID from the client and thus be able to verify\
    \ the\n   Token Binding of the cookie.  See Section 2.1 above.\n   If the client\
    \ application is not a web browser, it may have\n   additional knowledge about\
    \ the relationship between different\n   servers.  For example, the client application\
    \ might be aware of the\n   fact that two servers play the roles of Relying Party\
    \ and Identity\n   Provider, respectively, in a federated sign-on protocol and\
    \ that they\n   therefore share the identity of the user.  In such cases, it is\n\
    \   permissible to use different Token Binding key-pair scoping rules,\n   such\
    \ as using the same Token Binding key pair for both the Relying\n   Party and\
    \ the Identity Provider.  Absent such special knowledge,\n   conservative key-pair\
    \ scoping rules should be used, assuring that\n   clients use different Token\
    \ Binding key pairs with different servers.\n"
- title: 8.2.  Lifetime of Token Binding Key Pairs
  contents:
  - "8.2.  Lifetime of Token Binding Key Pairs\n   Token Binding key pairs do not\
    \ have an expiration time.  This means\n   that they can potentially be used by\
    \ a server to track a user for an\n   extended period of time (similar to a long-lived\
    \ cookie).  HTTPS\n   clients such as web User Agents SHOULD therefore provide\
    \ a user\n   interface for discarding Token Binding key pairs (similar to the\n\
    \   controls provided for deleting cookies).\n   If a User Agent provides modes\
    \ such as private browsing mode in which\n   the user is promised that browsing\
    \ state such as cookies are\n   discarded after the session is over, the User\
    \ Agent MUST also discard\n   Token Binding key pairs from such modes after the\
    \ session is over.\n   Generally speaking, users should be given the same level\
    \ of control\n   over the lifetime of Token Binding key pairs as they have over\n\
    \   cookies or other potential tracking mechanisms.\n"
- title: 8.3.  Correlation
  contents:
  - "8.3.  Correlation\n   An application's various communicating endpoints that receive\
    \ Token\n   Binding IDs for TLS connections other than their own obtain\n   information\
    \ about the application's other TLS connections.  (In this\n   context, \"an application\"\
    \ is a combination of client-side and\n   server-side components, communicating\
    \ over HTTPS, where the client\n   side may be web-browser-based, native-application-based,\
    \ or both.)\n   These other Token Binding IDs can serve as correlation handles\
    \ for\n   the endpoints of the other connections.  If the receiving endpoints\n\
    \   are otherwise aware of these other connections, then no additional\n   information\
    \ is being exposed.  For instance, if in a redirect-based\n   federation protocol\
    \ the Identity Provider and Relying Party already\n   possess URLs for one another,\
    \ then also having Token Binding IDs for\n   these connections does not provide\
    \ additional correlation\n   information.  If not, by providing the other Token\
    \ Binding IDs,\n   additional information is then exposed that can be used to\
    \ correlate\n   the other endpoints.  In such cases, a privacy analysis of enabled\n\
    \   correlations and their potential privacy impacts should be performed\n   as\
    \ part of the application design decisions of how, and whether, to\n   utilize\
    \ Token Binding.\n   Also, Token Binding implementations must take care to only\
    \ reveal\n   Token Binding IDs to other endpoints if signaled to do so by the\n\
    \   application associated with a Token Binding ID; see Section 6\n   (\"Implementation\
    \ Considerations\").\n   Finally, care should be taken to ensure that unrelated\
    \ applications\n   do not obtain information about each other's Token Bindings.\
    \  For\n   instance, a Token Binding implementation shared between multiple\n\
    \   applications on a given system should prevent unrelated applications\n   from\
    \ obtaining each other's Token Binding information.  This may be\n   accomplished\
    \ by using techniques such as application isolation and\n   key segregation, depending\
    \ upon system capabilities.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   Below is the Internet Assigned Numbers Authority\
    \ (IANA) \"Permanent\n   Message Header Field Names\" registration information\
    \ per [RFC3864].\n      Header Field name:           Sec-Token-Binding\n     \
    \ Protocol:                    HTTP\n      Status:                      standard\n\
    \      Reference:                   This document\n      Header Field name:  \
    \         Include-Referred-Token-Binding-ID\n      Protocol:                 \
    \   HTTP\n      Status:                      standard\n      Reference:      \
    \             This document\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [PSL]      Mozilla, \"Public Suffix List\",\n\
    \              <https://publicsuffix.org/>.\n   [RFC2119]  Bradner, S., \"Key\
    \ words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14,\
    \ RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC2818]  Rescorla, E., \"HTTP Over TLS\", RFC 2818,\n              DOI 10.17487/RFC2818,\
    \ May 2000,\n              <https://www.rfc-editor.org/info/rfc2818>.\n   [RFC3864]\
    \  Klyne, G., Nottingham, M., and J. Mogul, \"Registration\n              Procedures\
    \ for Message Header Fields\", BCP 90, RFC 3864,\n              DOI 10.17487/RFC3864,\
    \ September 2004,\n              <https://www.rfc-editor.org/info/rfc3864>.\n\
    \   [RFC4648]  Josefsson, S., \"The Base16, Base32, and Base64 Data\n        \
    \      Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006,\n          \
    \    <https://www.rfc-editor.org/info/rfc4648>.\n   [RFC5246]  Dierks, T. and\
    \ E. Rescorla, \"The Transport Layer Security\n              (TLS) Protocol Version\
    \ 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August 2008,\n       \
    \       <https://www.rfc-editor.org/info/rfc5246>.\n   [RFC5705]  Rescorla, E.,\
    \ \"Keying Material Exporters for Transport\n              Layer Security (TLS)\"\
    , RFC 5705, DOI 10.17487/RFC5705,\n              March 2010, <https://www.rfc-editor.org/info/rfc5705>.\n\
    \   [RFC6265]  Barth, A., \"HTTP State Management Mechanism\", RFC 6265,\n   \
    \           DOI 10.17487/RFC6265, April 2011,\n              <https://www.rfc-editor.org/info/rfc6265>.\n\
    \   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n \
    \             Protocol (HTTP/1.1): Message Syntax and Routing\",\n           \
    \   RFC 7230, DOI 10.17487/RFC7230, June 2014,\n              <https://www.rfc-editor.org/info/rfc7230>.\n\
    \   [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n \
    \             Protocol (HTTP/1.1): Semantics and Content\", RFC 7231,\n      \
    \        DOI 10.17487/RFC7231, June 2014,\n              <https://www.rfc-editor.org/info/rfc7231>.\n\
    \   [RFC7541]  Peon, R. and H. Ruellan, \"HPACK: Header Compression for\n    \
    \          HTTP/2\", RFC 7541, DOI 10.17487/RFC7541, May 2015,\n             \
    \ <https://www.rfc-editor.org/info/rfc7541>.\n   [RFC8174]  Leiba, B., \"Ambiguity\
    \ of Uppercase vs Lowercase in RFC\n              2119 Key Words\", BCP 14, RFC\
    \ 8174, DOI 10.17487/RFC8174,\n              May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n\
    \   [RFC8471]  Popov, A., Ed., Nystroem, M., Balfanz, D., and J. Hodges,\n   \
    \           \"The Token Binding Protocol Version 1.0\", RFC 8471,\n          \
    \    DOI 10.17487/RFC8471, October 2018,\n              <https://www.rfc-editor.org/info/rfc8471>.\n\
    \   [RFC8472]  Popov, A., Ed., Nystroem, M., and D. Balfanz, \"Transport\n   \
    \           Layer Security (TLS) Extension for Token Binding Protocol\n      \
    \        Negotiation\", RFC 8472, DOI 10.17487/RFC8472, October\n            \
    \  2018, <https://www.rfc-editor.org/info/rfc8472>.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [fetch-spec]\n              WhatWG, \"Fetch\"\
    , Living Standard,\n              <https://fetch.spec.whatwg.org/>.\n   [OASIS.saml-core-2.0-os]\n\
    \              Cantor, S., Kemp, J., Philpott, R., and E. Maler,\n           \
    \   \"Assertions and Protocols for the OASIS Security Assertion\n            \
    \  Markup Language (SAML) V2.0\", OASIS Standard\n              saml-core-2.0-os,\
    \ March 2005, <http://docs.oasis-open.org/\n              security/saml/v2.0/saml-core-2.0-os.pdf>.\n\
    \   [OASIS.saml-prof-2.0-os]\n              Hughes, J., Ed., Cantor, S., Ed.,\
    \ Hodges, J., Ed., Hirsch,\n              F., Ed., Mishra, P., Ed., Philpott,\
    \ R., Ed., and E. Maler,\n              Ed., \"Profiles for the OASIS Security\
    \ Assertion Markup\n              Language (SAML) V2.0\", OASIS Standard\n   \
    \           OASIS.saml-profiles-2.0-os, March 2005,\n              <http://docs.oasis-open.org/security/\n\
    \              saml/v2.0/saml-profiles-2.0-os.pdf>.\n   [OpenID.Core]\n      \
    \        Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and\n        \
    \      C. Mortimore, \"OpenID Connect Core 1.0 incorporating\n              errata\
    \ set 1\", November 2014,\n              <http://openid.net/specs/openid-connect-core-1_0.html>.\n\
    \   [RFC6749]  Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\",\n  \
    \            RFC 6749, DOI 10.17487/RFC6749, October 2012,\n              <https://www.rfc-editor.org/info/rfc6749>.\n\
    \   [RFC7540]  Belshe, M., Peon, R., and M. Thomson, Ed., \"Hypertext\n      \
    \        Transfer Protocol Version 2 (HTTP/2)\", RFC 7540,\n              DOI\
    \ 10.17487/RFC7540, May 2015,\n              <https://www.rfc-editor.org/info/rfc7540>.\n\
    \   [TOKENBIND-TLS13]\n              Harper, N., \"Token Binding for Transport\
    \ Layer Security\n              (TLS) Version 1.3 Connections\", Work in Progress,\n\
    \              draft-ietf-tokbind-tls13-01, May 2018.\n   [W3C.REC-DOM-Level-3-Core-20040407]\n\
    \              Le Hors, A., Ed., Le Hegaret, P., Ed., Wood, L., Ed.,\n       \
    \       Nicol, G., Ed., Robie, J., Ed., Champion, M., Ed., and S.\n          \
    \    Byrne, Ed., \"Document Object Model (DOM) Level 3 Core\n              Specification\"\
    , World Wide Web Consortium Recommendation\n              REC-DOM-Level-3-Core-20040407,\
    \ April 2004,\n              <https://www.w3.org/TR/2004/\n              REC-DOM-Level-3-Core-20040407>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   This document incorporates comments and suggestions offered\
    \ by Eric\n   Rescorla, Gabriel Montenegro, Martin Thomson, Vinod Anupam, Anthony\n\
    \   Nadalin, Michael B. Jones, Bill Cox, Brian Campbell, and others.\n   This\
    \ document was produced under the chairmanship of John Bradley and\n   Leif Johansson.\
    \  The area directors included Eric Rescorla, Kathleen\n   Moriarty, and Stephen\
    \ Farrell.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Andrei Popov\n   Microsoft Corp.\n   United States of\
    \ America\n   Email: andreipo@microsoft.com\n   Magnus Nystroem\n   Microsoft\
    \ Corp.\n   United States of America\n   Email: mnystrom@microsoft.com\n   Dirk\
    \ Balfanz (editor)\n   Google Inc.\n   United States of America\n   Email: balfanz@google.com\n\
    \   Nick Harper\n   Google Inc.\n   United States of America\n   Email: nharper@google.com\n\
    \   Jeff Hodges\n   Kings Mountain Systems\n   United States of America\n   Email:\
    \ Jeff.Hodges@KingsMountain.com\n"
