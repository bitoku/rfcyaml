- contents:
  - '                   IPv6 Segment Routing Header (SRH)

    '
  title: __initial_text__
- contents:
  - "Abstract\n   Segment Routing can be applied to the IPv6 data plane using a new\n
    \  type of Routing Extension Header called the Segment Routing Header\n   (SRH).
    \ This document describes the SRH and how it is used by nodes\n   that are Segment
    Routing (SR) capable.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8754.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2020 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction\n     1.1.  Terminology\n     1.2.  Requirements
    Language\n   2.  Segment Routing Header\n     2.1.  SRH TLVs\n       2.1.1.  Padding
    TLVs\n       2.1.2.  HMAC TLV\n   3.  SR Nodes\n     3.1.  SR Source Node\n     3.2.
    \ Transit Node\n     3.3.  SR Segment Endpoint Node\n   4.  Packet Processing\n
    \    4.1.  SR Source Node\n       4.1.1.  Reduced SRH\n     4.2.  Transit Node\n
    \    4.3.  SR Segment Endpoint Node\n       4.3.1.  FIB Entry Is a Locally Instantiated
    SRv6 SID\n       4.3.2.  FIB Entry Is a Local Interface\n       4.3.3.  FIB Entry
    Is a Nonlocal Route\n       4.3.4.  FIB Entry Is a No Match\n   5.  Intra-SR-Domain
    Deployment Model\n     5.1.  Securing the SR Domain\n     5.2.  SR Domain as a
    Single System with Delegation among\n           Components\n     5.3.  MTU Considerations\n
    \    5.4.  ICMP Error Processing\n     5.5.  Load Balancing and ECMP\n     5.6.
    \ Other Deployments\n   6.  Illustrations\n     6.1.  Abstract Representation
    of an SRH\n     6.2.  Example Topology\n     6.3.  SR Source Node\n       6.3.1.
    \ Intra-SR-Domain Packet\n       6.3.2.  Inter-SR-Domain Packet -- Transit\n       6.3.3.
    \ Inter-SR-Domain Packet -- Internal to External\n     6.4.  Transit Node\n     6.5.
    \ SR Segment Endpoint Node\n     6.6.  Delegation of Function with HMAC Verification\n
    \      6.6.1.  SID List Verification\n   7.  Security Considerations\n     7.1.
    \ SR Attacks\n     7.2.  Service Theft\n     7.3.  Topology Disclosure\n     7.4.
    \ ICMP Generation\n     7.5.  Applicability of AH\n   8.  IANA Considerations\n
    \    8.1.  Segment Routing Header Flags Registry\n     8.2.  Segment Routing Header
    TLVs Registry\n   9.  References\n     9.1.  Normative References\n     9.2.  Informative
    References\n   Acknowledgements\n   Contributors\n   Authors' Addresses\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Segment Routing (SR) can be applied to the IPv6 data plane
    using a\n   new type of routing header called the Segment Routing Header (SRH).\n
    \  This document describes the SRH and how it is used by nodes that are\n   SR
    capable.\n   \"Segment Routing Architecture\" [RFC8402] describes Segment Routing\n
    \  and its instantiation in two data planes: MPLS and IPv6.\n   The encoding of
    IPv6 segments in the SRH is defined in this document.\n"
  - contents:
    - "1.1.  Terminology\n   This document uses the terms Segment Routing (SR), SR
      domain, SR over\n   IPv6 (SRv6), Segment Identifier (SID), SRv6 SID, Active
      Segment, and\n   SR Policy as defined in [RFC8402].\n"
    title: 1.1.  Terminology
  - contents:
    - "1.2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
      RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
      as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear
      in all\n   capitals, as shown here.\n"
    title: 1.2.  Requirements Language
  title: 1.  Introduction
- contents:
  - "2.  Segment Routing Header\n   Routing headers are defined in [RFC8200].  The
    Segment Routing Header\n   (SRH) has a new Routing Type (4).\n   The SRH is defined
    as follows:\n     0                   1                   2                   3\n
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    | Next
    Header   |  Hdr Ext Len  | Routing Type  | Segments Left |\n    |  Last Entry
    \  |     Flags     |              Tag              |\n    |            Segment
    List[0] (128-bit IPv6 address)             |\n    |            Segment List[n]
    (128-bit IPv6 address)             |\n    //         Optional Type Length Value
    objects (variable)       //\n   where:\n   Next Header:  Defined in [RFC8200],
    Section 4.4.\n   Hdr Ext Len:  Defined in [RFC8200], Section 4.4.\n   Routing
    Type:  4.\n   Segments Left:  Defined in [RFC8200], Section 4.4.\n   Last Entry:
    \ contains the index (zero based), in the Segment List, of\n      the last element
    of the Segment List.\n   Flags:  8 bits of flags.  Section 8.1 creates an IANA
    registry for\n      new flags to be defined.  The following flags are defined:\n
    \         0 1 2 3 4 5 6 7\n         +-+-+-+-+-+-+-+-+\n         |U U U U U U U
    U|\n         +-+-+-+-+-+-+-+-+\n      U: Unused and for future use.  MUST be 0
    on transmission and\n      ignored on receipt.\n   Tag:  Tag a packet as part
    of a class or group of packets -- e.g.,\n      packets sharing the same set of
    properties.  When Tag is not used\n      at the source, it MUST be set to zero
    on transmission.  When Tag\n      is not used during SRH processing, it SHOULD
    be ignored.  Tag is\n      not used when processing the SID defined in Section
    4.3.1.  It may\n      be used when processing other SIDs that are not defined
    in this\n      document.  The allocation and use of tag is outside the scope of\n
    \     this document.\n   Segment List[0..n]:  128-bit IPv6 addresses representing
    the nth\n      segment in the Segment List.  The Segment List is encoded starting\n
    \     from the last segment of the SR Policy.  That is, the first\n      element
    of the Segment List (Segment List[0]) contains the last\n      segment of the
    SR Policy, the second element contains the\n      penultimate segment of the SR
    Policy, and so on.\n   TLV:  Type Length Value (TLV) is described in Section 2.1.\n
    \  In the SRH, the Next Header, Hdr Ext Len, Routing Type, and Segments\n   Left
    fields are defined in Section 4.4 of [RFC8200].  Based on the\n   constraints
    in that section, Next Header, Header Ext Len, and Routing\n   Type are not mutable
    while Segments Left is mutable.\n   The mutability of the TLV value is defined
    by the most significant\n   bit in the type, as specified in Section 2.1.\n   Section
    4.3 defines the mutability of the remaining fields in the SRH\n   (Flags, Tag,
    Segment List) in the context of the SID defined in this\n   document.\n   New
    SIDs defined in the future MUST specify the mutability properties\n   of the Flags,
    Tag, and Segment List and indicate how the Hashed\n   Message Authentication Code
    (HMAC) TLV (Section 2.1.2) verification\n   works.  Note that, in effect, these
    fields are mutable.\n   Consistent with the SR model, the source of the SRH always
    knows how\n   to set the Segment List, Flags, Tag, and TLVs of the SRH for use\n
    \  within the SR domain.  How it achieves this is outside the scope of\n   this
    document but may be based on topology, available SIDs and their\n   mutability
    properties, the SRH mutability requirements of the\n   destination, or any other
    information.\n"
  - contents:
    - "2.1.  SRH TLVs\n   This section defines TLVs of the Segment Routing Header.\n
      \  A TLV provides metadata for segment processing.  The only TLVs\n   defined
      in this document are the HMAC (Section 2.1.2) and padding\n   TLVs (Section
      2.1.1).  While processing the SID defined in\n   Section 4.3.1, all TLVs are
      ignored unless local configuration\n   indicates otherwise (Section 4.3.1.1.1).
      \ Thus, TLV and HMAC support\n   is optional for any implementation; however,
      an implementation adding\n   or parsing TLVs MUST support PAD TLVs.  Other documents
      may define\n   additional TLVs and processing rules for them.\n   TLVs are present
      when the Hdr Ext Len is greater than (Last\n   Entry+1)*2.\n   While processing
      TLVs at a segment endpoint, TLVs MUST be fully\n   contained within the SRH
      as determined by the Hdr Ext Len.  Detection\n   of TLVs exceeding the boundary
      of the SRH Hdr Ext Len results in an\n   ICMP Parameter Problem, Code 0, message
      to the Source Address,\n   pointing to the Hdr Ext Len field of the SRH, and
      the packet being\n   discarded.\n   An implementation MAY limit the number and/or
      length of TLVs it\n   processes based on local configuration.  It MAY limit:\n
      \  *  the number of consecutive Pad1 (Section 2.1.1.1) options to 1.  If\n      padding
      of more than one byte is required, then PadN\n      (Section 2.1.1.2) should
      be used.\n   *  The length in PadN to 5.\n   *  The maximum number of non-Pad
      TLVs to be processed.\n   *  The maximum length of all TLVs to be processed.\n
      \  The implementation MAY stop processing additional TLVs in the SRH\n   when
      these configured limits are exceeded.\n    0                   1\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5\n   |     Type      |    Length     | Variable-length
      data\n   Type:  An 8-bit codepoint from the \"Segment Routing Header TLVs\"\n
      \     [IANA-SRHTLV].  Unrecognized Types MUST be ignored on receipt.\n   Length:
      \ The length of the variable-length data field in bytes.\n   Variable-length
      data:  data that is specific to the Type.\n   Type Length Value (TLV) entries
      contain OPTIONAL information that may\n   be used by the node identified in
      the Destination Address (DA) of the\n   packet.\n   Each TLV has its own length,
      format, and semantic.  The codepoint\n   allocated (by IANA) to each TLV Type
      defines both the format and the\n   semantic of the information carried in the
      TLV.  Multiple TLVs may be\n   encoded in the same SRH.\n   The highest-order
      bit of the TLV type (bit 0) specifies whether or\n   not the TLV data of that
      type can change en route to the packet's\n   final destination:\n      0: TLV
      data does not change en route\n      1: TLV data does change en route\n   All
      TLVs specify their alignment requirements using an xn+y format.\n   The xn+y
      format is defined as per [RFC8200].  The SR source nodes use\n   the xn+y alignment
      requirements of TLVs and Padding TLVs when\n   constructing an SRH.\n   The
      Length field of the TLV is used to skip the TLV while inspecting\n   the SRH
      in case the node doesn't support or recognize the Type.  The\n   Length defines
      the TLV length in octets, not including the Type and\n   Length fields.\n   The
      following TLVs are defined in this document:\n      Padding TLVs\n      HMAC
      TLV\n   Additional TLVs may be defined in the future.\n"
    - contents:
      - "2.1.1.  Padding TLVs\n   There are two types of Padding TLVs, Pad1 and PadN,
        and the following\n   applies to both:\n      Padding TLVs are used for meeting
        the alignment requirement of the\n      subsequent TLVs.\n      Padding TLVs
        are used to pad the SRH to a multiple of 8 octets.\n      Padding TLVs are
        ignored by a node processing the SRH TLV.\n      Multiple Padding TLVs MAY
        be used in one SRH.\n"
      - contents:
        - "2.1.1.1.  Pad1\n   Alignment requirement: none\n      0 1 2 3 4 5 6 7\n
          \    +-+-+-+-+-+-+-+-+\n     |     Type      |\n     +-+-+-+-+-+-+-+-+\n
          \  Type:  0\n   A single Pad1 TLV MUST be used when a single byte of padding
          is\n   required.  A Pad1 TLV MUST NOT be used if more than one consecutive\n
          \  byte of padding is required.\n"
        title: 2.1.1.1.  Pad1
      - contents:
        - "2.1.1.2.  PadN\n   Alignment requirement: none\n    0                   1
          \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2
          3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   |     Type      |    Length     |
          \     Padding (variable)       |\n   //                    Padding (variable)
          \                      //\n   Type:  4\n   Length:  0 to 5.  The length
          of the Padding field in bytes.\n   Padding:  Padding bits have no semantic.
          \ They MUST be set to 0 on\n      transmission and ignored on receipt.\n
          \  The PadN TLV MUST be used when more than one byte of padding is\n   required.\n"
        title: 2.1.1.2.  PadN
      title: 2.1.1.  Padding TLVs
    - contents:
      - "2.1.2.  HMAC TLV\n   Alignment requirement: 8n\n   The keyed Hashed Message
        Authentication Code (HMAC) TLV is OPTIONAL\n   and has the following format:\n
        \   0                   1                   2                   3\n    0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   |      Type
        \    |     Length    |D|        RESERVED             |\n   |                      HMAC
        Key ID (4 octets)                   |\n   |                      HMAC (variable)
        \                        //\n   where:\n   Type:  5.\n   Length:  The length
        of the variable-length data in bytes.\n   D:  1 bit. 1 indicates that the
        Destination Address verification is\n      disabled due to use of a reduced
        Segment List (see Section 4.1.1).\n   RESERVED:  15 bits.  MUST be 0 on transmission.\n
        \  HMAC Key ID:  A 4-octet opaque number that uniquely identifies the\n      pre-shared
        key and algorithm used to generate the HMAC.\n   HMAC:  Keyed HMAC, in multiples
        of 8 octets, at most 32 octets.\n   The HMAC TLV is used to verify that the
        SRH applied to a packet was\n   selected by an authorized party and to ensure
        that the segment list\n   is not modified after generation.  This also allows
        for verification\n   that the current segment (by virtue of being in the authorized\n
        \  Segment List) is authorized for use.  The SR domain ensures that the\n
        \  source node is permitted to use the source address in the packet via\n
        \  ingress filtering mechanisms as defined in BCP 84 [RFC3704] or other\n
        \  strategies as appropriate.\n"
      - contents:
        - "2.1.2.1.  HMAC Generation and Verification\n   Local configuration determines
          when to check for an HMAC.  This local\n   configuration is outside the
          scope of this document.  It may be based\n   on the active segment at an
          SR Segment endpoint node, the result of\n   an Access Control List (ACL)
          that considers incoming interface, HMAC\n   Key ID, or other packet fields.\n
          \  An implementation that supports the generation and verification of\n
          \  the HMAC supports the following default behavior, as defined in the\n
          \  remainder of this section.\n   The HMAC verification begins by checking
          that the current segment is\n   equal to the destination address of the
          IPv6 header.  The check is\n   successful when either:\n   *  HMAC D bit
          is 1 and Segments Left is greater than Last Entry, or\n   *  HMAC Segments
          Left is less than or equal to Last Entry, and the\n      destination address
          is equal to Segment List[Segments Left].\n   The HMAC field is the output
          of the HMAC computation as defined in\n   [RFC2104], using:\n   *  key:
          The pre-shared key identified by HMAC Key ID\n   *  HMAC algorithm: Identified
          by the HMAC Key ID\n   *  Text: A concatenation of the following fields
          from the IPv6 header\n      and the SRH, as it would be received at the
          node verifying the\n      HMAC:\n      -  IPv6 header: Source address (16
          octets)\n      -  SRH: Last Entry (1 octet)\n      -  SRH: Flags (1 octet)\n
          \     -  SRH: HMAC 16 bits following Length\n      -  SRH: HMAC Key ID (4
          octets)\n      -  SRH: All addresses in the Segment List (variable octets)\n
          \  The HMAC digest is truncated to 32 octets and placed in the HMAC\n   field
          of the HMAC TLV.\n   For HMAC algorithms producing digests less than 32
          octets long, the\n   digest is placed in the lowest-order octets of the
          HMAC field.\n   Subsequent octets MUST be set to zero such that the HMAC
          length is a\n   multiple of 8 octets.\n   If HMAC verification is successful,
          processing proceeds as normal.\n   If HMAC verification fails, an ICMP error
          message (parameter problem,\n   error code 0, pointing to the HMAC TLV)
          SHOULD be generated (but rate\n   limited) and logged, and the packet SHOULD
          be discarded.\n"
        title: 2.1.2.1.  HMAC Generation and Verification
      - contents:
        - "2.1.2.2.  HMAC Pre-shared Key Algorithm\n   The HMAC Key ID field allows
          for the simultaneous existence of\n   several hash algorithms (SHA-256,
          SHA3-256 ... or future ones) as\n   well as pre-shared keys.\n   The HMAC
          Key ID field is opaque -- i.e., it has neither syntax nor\n   semantic except
          as an identifier of the right combination of pre-\n   shared key and hash
          algorithm.\n   At the HMAC TLV generating and verification nodes, the Key
          ID\n   uniquely identifies the pre-shared key and HMAC algorithm.\n   At
          the HMAC TLV generating node, the Text for the HMAC computation is\n   set
          to the IPv6 header fields and SRH fields as they would appear at\n   the
          verification node(s), not necessarily the same as the source node\n   sending
          a packet with the HMAC TLV.\n   Pre-Shared key rollover is supported by
          having two key IDs in use\n   while the HMAC TLV generating node and verifying
          node converge to a\n   new key.\n   The HMAC TLV generating node may need
          to revoke an SRH for which it\n   previously generated an HMAC.  Revocation
          is achieved by allocating a\n   new key and key ID, then rolling over the
          key ID associated with the\n   SRH to be revoked.  The HMAC TLV verifying
          node drops packets with\n   the revoked SRH.\n   An implementation supporting
          HMAC can support multiple hash\n   functions.  An implementation supporting
          HMAC MUST implement SHA-2\n   [FIPS180-4] in its SHA-256 variant.\n   The
          selection of pre-shared key and algorithm and their distribution\n   is
          outside the scope of this document.  Some options may include:\n   *  setting
          these items in the configuration of the HMAC generating or\n      verifying
          nodes, either by static configuration or any SDN-\n      oriented approach\n
          \  *  dynamically using a trusted key distribution protocol such as\n      [RFC6407]\n
          \  While key management is outside the scope of this document, the\n   recommendations
          of BCP 107 [RFC4107] should be considered when\n   choosing the key management
          system.\n"
        title: 2.1.2.2.  HMAC Pre-shared Key Algorithm
      title: 2.1.2.  HMAC TLV
    title: 2.1.  SRH TLVs
  title: 2.  Segment Routing Header
- contents:
  - "3.  SR Nodes\n   There are different types of nodes that may be involved in segment\n
    \  routing networks: SR source nodes that originate packets with a\n   segment
    in the destination address of the IPv6 header, transit nodes\n   that forward
    packets destined to a remote segment, and SR segment\n   endpoint nodes that process
    a local segment in the destination\n   address of an IPv6 header.\n"
  - contents:
    - "3.1.  SR Source Node\n   A SR source node is any node that originates an IPv6
      packet with a\n   segment (i.e., SRv6 SID) in the destination address of the
      IPv6\n   header.  The packet leaving the SR source node may or may not contain\n
      \  an SRH.  This includes either:\n   *  A host originating an IPv6 packet,
      or\n   *  An SR domain ingress router encapsulating a received packet in an\n
      \     outer IPv6 header, followed by an optional SRH.\n   It is out of the scope
      of this document to describe the mechanism\n   through which a segment in the
      destination address of the IPv6 header\n   and the Segment List in the SRH are
      derived.\n"
    title: 3.1.  SR Source Node
  - contents:
    - "3.2.  Transit Node\n   A transit node is any node forwarding an IPv6 packet
      where the\n   destination address of that packet is not locally configured as
      a\n   segment or a local interface.  A transit node is not required to be\n
      \  capable of processing a segment or SRH.\n"
    title: 3.2.  Transit Node
  - contents:
    - "3.3.  SR Segment Endpoint Node\n   An SR segment endpoint node is any node
      receiving an IPv6 packet\n   where the destination address of that packet is
      locally configured as\n   a segment or local interface.\n"
    title: 3.3.  SR Segment Endpoint Node
  title: 3.  SR Nodes
- contents:
  - "4.  Packet Processing\n   This section describes SRv6 packet processing at the
    SR source,\n   Transit, and SR segment endpoint nodes.\n"
  - contents:
    - "4.1.  SR Source Node\n   A source node steers a packet into an SR Policy.  If
      the SR Policy\n   results in a Segment List containing a single segment, and
      there is\n   no need to add information to the SRH flag or add TLV; the DA is
      set\n   to the single Segment List entry, and the SRH MAY be omitted.\n   When
      needed, the SRH is created as follows:\n      The Next Header and Hdr Ext Len
      fields are set as specified in\n      [RFC8200].\n      The Routing Type field
      is set to 4.\n      The DA of the packet is set with the value of the first
      segment.\n      The first element of the SRH Segment List is the ultimate segment.\n
      \     The second element is the penultimate segment, and so on.\n      The Segments
      Left field is set to n-1, where n is the number of\n      elements in the SR
      Policy.\n      The Last Entry field is set to n-1, where n is the number of\n
      \     elements in the SR Policy.\n      TLVs (including HMAC) may be set according
      to their specification.\n      The packet is forwarded toward the packet's Destination
      Address\n      (the first segment).\n"
    - contents:
      - "4.1.1.  Reduced SRH\n   When a source does not require the entire SID list
        to be preserved in\n   the SRH, a reduced SRH may be used.\n   A reduced SRH
        does not contain the first segment of the related SR\n   Policy (the first
        segment is the one already in the DA of the IPv6\n   header), and the Last
        Entry field is set to n-2, where n is the\n   number of elements in the SR
        Policy.\n"
      title: 4.1.1.  Reduced SRH
    title: 4.1.  SR Source Node
  - contents:
    - "4.2.  Transit Node\n   As specified in [RFC8200], the only node allowed to
      inspect the\n   Routing Extension Header (and therefore the SRH) is the node\n
      \  corresponding to the DA of the packet.  Any other transit node MUST\n   NOT
      inspect the underneath routing header and MUST forward the packet\n   toward
      the DA according to its IPv6 routing table.\n   When a SID is in the destination
      address of an IPv6 header of a\n   packet, it's routed through an IPv6 network
      as an IPv6 address.\n   SIDs, or the prefix(es) covering SIDs, and their reachability
      may be\n   distributed by means outside the scope of this document.  For\n   example,
      [RFC5308] or [RFC5340] may be used to advertise a prefix\n   covering the SIDs
      on a node.\n"
    title: 4.2.  Transit Node
  - contents:
    - "4.3.  SR Segment Endpoint Node\n   Without constraining the details of an implementation,
      the SR segment\n   endpoint node creates Forwarding Information Base (FIB) entries
      for\n   its local SIDs.\n   When an SRv6-capable node receives an IPv6 packet,
      it performs a\n   longest-prefix-match lookup on the packet's destination address.\n
      \  This lookup can return any of the following:\n   *  A FIB entry that represents
      a locally instantiated SRv6 SID\n   *  A FIB entry that represents a local interface,
      not locally\n      instantiated as an SRv6 SID\n   *  A FIB entry that represents
      a nonlocal route\n   *  No Match\n"
    - contents:
      - "4.3.1.  FIB Entry Is a Locally Instantiated SRv6 SID\n   This document and
        section define a single SRv6 SID.  Future documents\n   may define additional
        SRv6 SIDs.  In such a case, the entire content\n   of this section will be
        defined in that document.\n   If the FIB entry represents a locally instantiated
        SRv6 SID, process\n   the next header chain of the IPv6 header as defined
        in Section 4 of\n   [RFC8200].  Section 4.3.1.1 describes how to process an
        SRH;\n   Section 4.3.1.2 describes how to process an upper-layer header or
        the\n   absence of a Next Header.\n   Processing this SID modifies the Segments
        Left and, if configured to\n   process TLVs, it may modify the \"variable-length
        data\" of TLV types\n   that change en route.  Therefore, Segments Left is
        mutable, and TLVs\n   that change en route are mutable.  The remainder of
        the SRH (Flags,\n   Tag, Segment List, and TLVs that do not change en route)
        are\n   immutable while processing this SID.\n"
      - contents:
        - "4.3.1.1.  SRH Processing\n   S01. When an SRH is processed {\n   S02.   If
          Segments Left is equal to zero {\n   S03.     Proceed to process the next
          header in the packet,\n            whose type is identified by the Next
          Header field in\n            the routing header.\n   S04.   }\n   S05.   Else
          {\n   S06.     If local configuration requires TLV processing {\n   S07.
          \      Perform TLV processing (see TLV Processing)\n   S08.     }\n   S09.
          \    max_last_entry  =  ( Hdr Ext Len /  2 ) - 1\n   S10.     If  ((Last
          Entry > max_last_entry) or\n   S11.          (Segments Left is greater than
          (Last Entry+1)) {\n   S12.       Send an ICMP Parameter Problem, Code 0,
          message to\n              the Source Address, pointing to the Segments Left\n
          \             field, and discard the packet.\n   S13.     }\n   S14.     Else
          {\n   S15.       Decrement Segments Left by 1.\n   S16.       Copy Segment
          List[Segments Left] from the SRH to the\n              destination address
          of the IPv6 header.\n   S17.       If the IPv6 Hop Limit is less than or
          equal to 1 {\n   S18.         Send an ICMP Time Exceeded -- Hop Limit Exceeded
          in\n                Transit message to the Source Address and discard\n
          \               the packet.\n   S19.       }\n   S20.       Else {\n   S21.
          \        Decrement the Hop Limit by 1\n   S22.         Resubmit the packet
          to the IPv6 module for transmission\n                to the new destination.\n
          \  S23.       }\n   S24.     }\n   S25.   }\n   S26. }\n"
        - contents:
          - "4.3.1.1.1.  TLV Processing\n   Local configuration determines how TLVs
            are to be processed when the\n   Active Segment is a local SID defined
            in this document.  The\n   definition of local configuration is outside
            the scope of this\n   document.\n   For illustration purposes only, two
            example local configurations that\n   may be associated with a SID are
            provided below.\n   Example 1:\n   For any packet received from interface
            I2\n     Skip TLV processing\n   Example 2:\n   For any packet received
            from interface I1\n     If first TLV is HMAC {\n       Process the HMAC
            TLV\n     }\n     Else {\n       Discard the packet\n     }\n"
          title: 4.3.1.1.1.  TLV Processing
        title: 4.3.1.1.  SRH Processing
      - contents:
        - "4.3.1.2.  Upper-Layer Header or No Next Header\n   When processing the
          upper-layer header of a packet matching a FIB\n   entry locally instantiated
          as an SRv6 SID defined in this document:\n   IF (Upper-layer Header is IPv4
          or IPv6) and\n       local configuration permits {\n     Perform IPv6 decapsulation\n
          \    Resubmit the decapsulated packet to the IPv4 or IPv6 module\n   }\n
          \  ELSE {\n     Send an ICMP parameter problem message to the Source Address
          and\n     discard the packet.  Error code (4) \"SR Upper-layer\n     Header
          Error\", pointer set to the offset of the upper-layer\n     header.\n   }\n
          \  A unique error code allows an SR source node to recognize an error in\n
          \  SID processing at an endpoint.\n"
        title: 4.3.1.2.  Upper-Layer Header or No Next Header
      title: 4.3.1.  FIB Entry Is a Locally Instantiated SRv6 SID
    - contents:
      - "4.3.2.  FIB Entry Is a Local Interface\n   If the FIB entry represents a
        local interface and is not locally\n   instantiated as an SRv6 SID, the SRH
        is processed as follows:\n      If Segments Left is zero, the node must ignore
        the routing header\n      and proceed to process the next header in the packet,
        whose type\n      is identified by the Next Header field in the routing header.\n
        \     If Segments Left is non-zero, the node must discard the packet and\n
        \     send an ICMP Parameter Problem, Code 0, message to the packet's\n      Source
        Address, pointing to the unrecognized Routing Type.\n"
      title: 4.3.2.  FIB Entry Is a Local Interface
    - contents:
      - "4.3.3.  FIB Entry Is a Nonlocal Route\n   Processing is not changed by this
        document.\n"
      title: 4.3.3.  FIB Entry Is a Nonlocal Route
    - contents:
      - "4.3.4.  FIB Entry Is a No Match\n   Processing is not changed by this document.\n"
      title: 4.3.4.  FIB Entry Is a No Match
    title: 4.3.  SR Segment Endpoint Node
  title: 4.  Packet Processing
- contents:
  - "5.  Intra-SR-Domain Deployment Model\n   The use of the SIDs exclusively within
    the SR domain and solely for\n   packets of the SR domain is an important deployment
    model.\n   This enables the SR domain to act as a single routing system.\n   This
    section covers:\n   *  securing the SR domain from external attempts to use its
    SIDs\n   *  using the SR domain as a single system with delegation between\n      components\n
    \  *  handling packets of the SR domain\n"
  - contents:
    - "5.1.  Securing the SR Domain\n   Nodes outside the SR domain are not trusted:
      they cannot directly use\n   the SIDs of the domain.  This is enforced by two
      levels of access\n   control lists:\n   1.  Any packet entering the SR domain
      and destined to a SID within\n       the SR domain is dropped.  This may be
      realized with the\n       following logic.  Other methods with equivalent outcome
      are\n       considered compliant:\n       *  Allocate all the SIDs from a block
      S/s\n       *  Configure each external interface of each edge node of the\n
      \         domain with an inbound infrastructure access list (IACL) that\n          drops
      any incoming packet with a destination address in S/s\n       *  Failure to
      implement this method of ingress filtering exposes\n          the SR domain
      to source-routing attacks, as described and\n          referenced in [RFC5095]\n
      \  2.  The distributed protection in #1 is complemented with per-node\n       protection,
      dropping packets to SIDs from source addresses\n       outside the SR domain.
      \ This may be realized with the following\n       logic.  Other methods with
      equivalent outcome are considered\n       compliant:\n       *  Assign all interface
      addresses from prefix A/a\n       *  At node k, all SIDs local to k are assigned
      from prefix Sk/sk\n       *  Configure each internal interface of each SR node
      k in the SR\n          domain with an inbound IACL that drops any incoming packet\n
      \         with a destination address in Sk/sk if the source address is\n          not
      in A/a.\n"
    title: 5.1.  Securing the SR Domain
  - contents:
    - "5.2.  SR Domain as a Single System with Delegation among Components\n   All
      intra-SR-domain packets are of the SR domain.  The IPv6 header is\n   originated
      by a node of the SR domain and is destined to a node of\n   the SR domain.\n
      \  All interdomain packets are encapsulated for the part of the packet\n   journey
      that is within the SR domain.  The outer IPv6 header is\n   originated by a
      node of the SR domain and is destined to a node of\n   the SR domain.\n   As
      a consequence, any packet within the SR domain is of the SR\n   domain.\n   The
      SR domain is a system in which the operator may want to\n   distribute or delegate
      different operations of the outermost header\n   to different nodes within the
      system.\n   An operator of an SR domain may choose to delegate SRH addition
      to a\n   host node within the SR domain and delegate validation of the\n   contents
      of any SRH to a more trusted router or switch attached to\n   the host.  Consider
      a top-of-rack switch T connected to host H via\n   interface I.  H receives
      an SRH (SRH1) with a computed HMAC via some\n   SDN method outside the scope
      of this document.  H classifies traffic\n   it sources and adds SRH1 to traffic
      requiring a specific Service\n   Level Agreement (SLA).  T is configured with
      an IACL on I requiring\n   verification of the SRH for any packet destined to
      the SID block of\n   the SR domain (S/s).  T checks and verifies that SRH1 is
      valid and\n   contains an HMAC TLV; T then verifies the HMAC.\n   An operator
      of the SR domain may choose to have all segments in the\n   SR domain verify
      the HMAC.  This mechanism would verify that the SRH\n   Segment List is not
      modified while traversing the SR domain.\n"
    title: 5.2.  SR Domain as a Single System with Delegation among Components
  - contents:
    - "5.3.  MTU Considerations\n   An SR domain ingress edge node encapsulates packets
      traversing the SR\n   domain and needs to consider the MTU of the SR domain.
      \ Within the SR\n   domain, well-known mitigation techniques are RECOMMENDED,
      such as\n   deploying a greater MTU value within the SR domain than at the\n
      \  ingress edges.\n   Encapsulation with an outer IPv6 header and SRH shares
      the same MTU\n   and fragmentation considerations as IPv6 tunnels described
      in\n   [RFC2473].  Further investigation on the limitation of various\n   tunneling
      methods (including IPv6 tunnels) is discussed in\n   [INTAREA-TUNNELS] and SHOULD
      be considered by operators when\n   considering MTU within the SR domain.\n"
    title: 5.3.  MTU Considerations
  - contents:
    - "5.4.  ICMP Error Processing\n   ICMP error packets generated within the SR
      domain are sent to source\n   nodes within the SR domain.  The invoking packet
      in the ICMP error\n   message may contain an SRH.  Since the destination address
      of a\n   packet with an SRH changes as each segment is processed, it may not\n
      \  be the destination used by the socket or application that generated\n   the
      invoking packet.\n   For the source of an invoking packet to process the ICMP
      error\n   message, the ultimate destination address of the IPv6 header may be\n
      \  required.  The following logic is used to determine the destination\n   address
      for use by protocol-error handlers.\n   *  Walk all extension headers of the
      invoking IPv6 packet to the\n      routing extension header preceding the upper-layer
      header.\n      -  If routing header is type 4 Segment Routing Header (SRH)\n
      \        o  The SID at Segment List[0] may be used as the destination\n            address
      of the invoking packet.\n   ICMP errors are then processed by upper-layer transports
      as defined\n   in [RFC4443].\n   For IP packets encapsulated in an outer IPv6
      header, ICMP error\n   handling is as defined in [RFC2473].\n"
    title: 5.4.  ICMP Error Processing
  - contents:
    - "5.5.  Load Balancing and ECMP\n   For any interdomain packet, the SR source
      node MUST impose a flow\n   label computed based on the inner packet.  The computation
      of the\n   flow label is as recommended in [RFC6438] for the sending Tunnel
      End\n   Point.\n   For any intradomain packet, the SR source node SHOULD impose
      a flow\n   label computed as described in [RFC6437] to assist ECMP load\n   balancing
      at transit nodes incapable of computing a 5-tuple beyond\n   the SRH.\n   At
      any transit node within an SR domain, the flow label MUST be used\n   as defined
      in [RFC6438] to calculate the ECMP hash toward the\n   destination address.
      \ If a flow label is not used, the transit node\n   would likely hash all packets
      between a pair of SR Edge nodes to the\n   same link.\n   At an SR segment endpoint
      node, the flow label MUST be used as\n   defined in [RFC6438] to calculate any
      ECMP hash used to forward the\n   processed packet to the next segment.\n"
    title: 5.5.  Load Balancing and ECMP
  - contents:
    - "5.6.  Other Deployments\n   Other deployment models and their implications
      on security, MTU,\n   HMAC, ICMP error processing, and interaction with other
      extension\n   headers are outside the scope of this document.\n"
    title: 5.6.  Other Deployments
  title: 5.  Intra-SR-Domain Deployment Model
- contents:
  - "6.  Illustrations\n   This section provides illustrations of SRv6 packet processing
    at SR\n   source, transit, and SR segment endpoint nodes.\n"
  - contents:
    - "6.1.  Abstract Representation of an SRH\n   For a node k, its IPv6 address
      is represented as Ak, and its SRv6 SID\n   is represented as Sk.\n   IPv6 headers
      are represented as the tuple of (source,destination).\n   For example, a packet
      with source address A1 and destination address\n   A2 is represented as (A1,A2).
      \ The payload of the packet is omitted.\n   An SR Policy is a list of segments.
      \ A list of segments is\n   represented as <S1,S2,S3> where S1 is the first
      SID to visit, S2 is\n   the second SID to visit, and S3 is the last SID to visit.\n
      \  (SA,DA) (S3,S2,S1; SL) represents an IPv6 packet with:\n   *  Source Address
      SA, Destination Addresses DA, and next header SRH.\n   *  SRH with SID list
      <S1,S2,S3> with SegmentsLeft = SL.\n   *  Note the difference between the <>
      and () symbols.  <S1,S2,S3>\n      represents a SID list where the leftmost
      segment is the first\n      segment.  In contrast, (S3,S2,S1; SL) represents
      the same SID list\n      but encoded in the SRH Segment List format where the
      leftmost\n      segment is the last segment.  When referring to an SR Policy
      in a\n      high-level use case, it is simpler to use the <S1,S2,S3> notation.\n
      \     When referring to an illustration of detailed behavior, the\n      (S3,S2,S1;
      SL) notation is more convenient.\n   At its SR Policy headend, the Segment List
      <S1,S2,S3> results in SRH\n   (S3,S2,S1; SL=2) represented fully as:\n       Segments
      Left=2\n       Last Entry=2\n       Flags=0\n       Tag=0\n       Segment List[0]=S3\n
      \      Segment List[1]=S2\n       Segment List[2]=S1\n"
    title: 6.1.  Abstract Representation of an SRH
  - contents:
    - "6.2.  Example Topology\n   The following topology is used in examples below:\n
      \          *         [8]                [9]          *\n   [1]----[3]--------[5]----------------[6]---------[4]---[2]\n
      \          + * * * * * * *  SR domain  * * * * * * * +\n   *  3 and 4 are SR
      domain edge routers\n   *  5, 6, and 7 are all SR domain routers\n   *  8 and
      9 are hosts within the SR domain\n   *  1 and 2 are hosts outside the SR domain\n
      \  *  The SR domain implements ingress filtering as per Section 5.1 and\n      no
      external packet can enter the domain with a destination address\n      equal
      to a segment of the domain.\n"
    title: 6.2.  Example Topology
  - contents:
    - '6.3.  SR Source Node

      '
    - contents:
      - "6.3.1.  Intra-SR-Domain Packet\n   When host 8 sends a packet to host 9 via
        an SR Policy <S7,A9> the\n   packet is\n   P1: (A8,S7)(A9,S7; SL=1)\n"
      - contents:
        - "6.3.1.1.  Reduced Variant\n   When host 8 sends a packet to host 9 via
          an SR Policy <S7,A9> and it\n   wants to use a reduced SRH, the packet is\n
          \  P2: (A8,S7)(A9; SL=1)\n"
        title: 6.3.1.1.  Reduced Variant
      title: 6.3.1.  Intra-SR-Domain Packet
    - contents:
      - "6.3.2.  Inter-SR-Domain Packet -- Transit\n   When host 1 sends a packet
        to host 2, the packet is\n   P3: (A1,A2)\n   The SR domain ingress router
        3 receives P3 and steers it to SR domain\n   egress router 4 via an SR Policy
        <S7,S4>.  Router 3 encapsulates the\n   received packet P3 in an outer header
        with an SRH.  The packet is\n   P4: (A3,S7)(S4,S7; SL=1)(A1,A2)\n   If the
        SR Policy contains only one segment (the egress router 4), the\n   ingress
        router 3 encapsulates P3 into an outer header (A3,S4) without\n   SRH.  The
        packet is\n   P5: (A3,S4)(A1,A2)\n"
      - contents:
        - "6.3.2.1.  Reduced Variant\n   The SR domain ingress router 3 receives P3
          and steers it to SR domain\n   egress router 4 via an SR Policy <S7,S4>.
          \ If router 3 wants to use a\n   reduced SRH, it encapsulates the received
          packet P3 in an outer\n   header with a reduced SRH.  The packet is\n   P6:
          (A3,S7)(S4; SL=1)(A1,A2)\n"
        title: 6.3.2.1.  Reduced Variant
      title: 6.3.2.  Inter-SR-Domain Packet -- Transit
    - contents:
      - "6.3.3.  Inter-SR-Domain Packet -- Internal to External\n   When host 8 sends
        a packet to host 1, the packet is encapsulated for\n   the portion of its
        journey within the SR domain.  From 8 to 3 the\n   packet is\n   P7: (A8,S3)(A8,A1)\n
        \  In the opposite direction, the packet generated from 1 to 8 is\n   P8:
        (A1,A8)\n   At node 3, P8 is encapsulated for the portion of its journey within\n
        \  the SR domain, with the outer header destined to segment S8.  This\n   results
        in\n   P9: (A3,S8)(A1,A8)\n   At node 8, the outer IPv6 header is removed
        by S8 processing, then\n   processed again when received by A8.\n"
      title: 6.3.3.  Inter-SR-Domain Packet -- Internal to External
    title: 6.3.  SR Source Node
  - contents:
    - "6.4.  Transit Node\n   Node 5 acts as transit node for packet P1 and sends
      packet\n   P1: (A8,S7)(A9,S7;SL=1)\n   on the interface toward node 7.\n"
    title: 6.4.  Transit Node
  - contents:
    - "6.5.  SR Segment Endpoint Node\n   Node 7 receives packet P1 and, using the
      logic in Section 4.3.1,\n   sends packet\n   P7: (A8,A9)(A9,S7; SL=0)\n   on
      the interface toward router 6.\n"
    title: 6.5.  SR Segment Endpoint Node
  - contents:
    - "6.6.  Delegation of Function with HMAC Verification\n   This section describes
      how a function may be delegated within the SR\n   domain.  In the following
      sections, consider a host 8 connected to a\n   top of rack 5.\n"
    - contents:
      - "6.6.1.  SID List Verification\n   An operator may prefer to apply the SRH
        at source 8, while 5 verifies\n   that the SID list is valid.\n   For illustration
        purposes, an SDN controller provides 8 an SRH\n   terminating at node 9, with
        Segment List <S5,S7,S6,A9>, and HMAC TLV\n   computed for the SRH.  The HMAC
        key ID and key associated with the\n   HMAC TLV is shared with 5.  Node 8
        does not know the key.  Node 5 is\n   configured with an IACL applied to the
        interface connected to 8,\n   requiring HMAC verification for any packet destined
        to S/s.\n   Node 8 originates packets with the received SRH, including HMAC
        TLV.\n   P15: (A8,S5)(A9,S6,S7,S5;SL=3;HMAC)\n   Node 5 receives and verifies
        the HMAC for the SRH, then forwards the\n   packet to the next segment\n   P16:
        (A8,S7)(A9,S6,S7,S5;SL=2;HMAC)\n   Node 6 receives\n   P17: (A8,S6)(A9,S6,S7,S5;SL=1;HMAC)\n
        \  Node 9 receives\n   P18: (A8,A9)(A9,S6,S7,S5;SL=0;HMAC)\n   This use of
        an HMAC is particularly valuable within an enterprise-\n   based SR domain
        [SRN].\n"
      title: 6.6.1.  SID List Verification
    title: 6.6.  Delegation of Function with HMAC Verification
  title: 6.  Illustrations
- contents:
  - "7.  Security Considerations\n   This section reviews security considerations
    related to the SRH,\n   given the SRH processing and deployment models discussed
    in this\n   document.\n   As described in Section 5, it is necessary to filter
    packets' ingress\n   to the SR domain, destined to SIDs within the SR domain (i.e.,\n
    \  bearing a SID in the destination address).  This ingress filtering is\n   via
    an IACL at SR domain ingress border nodes.  Additional protection\n   is applied
    via an IACL at each SR Segment Endpoint node, filtering\n   packets not from within
    the SR domain, destined to SIDs in the SR\n   domain.  ACLs are easily supported
    for small numbers of seldom\n   changing prefixes, making summarization important.\n
    \  Additionally, ingress filtering of IPv6 source addresses as\n   recommended
    in BCP 38 [RFC2827] SHOULD be used.\n"
  - contents:
    - "7.1.  SR Attacks\n   An SR domain implements distributed and per-node protection
      as\n   described in Section 5.1.  Additionally, domains deny traffic with\n
      \  spoofed addresses by implementing the recommendations in BCP 84\n   [RFC3704].\n
      \  Full implementation of the recommended protection blocks the attacks\n   documented
      in [RFC5095] from outside the SR domain, including\n   bypassing filtering devices,
      reaching otherwise-unreachable Internet\n   systems, network topology discovery,
      bandwidth exhaustion, and\n   defeating anycast.\n   Failure to implement distributed
      and per-node protection allows\n   attackers to bypass filtering devices and
      exposes the SR domain to\n   these attacks.\n   Compromised nodes within the
      SR domain may mount the attacks listed\n   above along with other known attacks
      on IP networks (e.g., DoS/DDoS,\n   topology discovery, man-in-the-middle, traffic
      interception/\n   siphoning).\n"
    title: 7.1.  SR Attacks
  - contents:
    - "7.2.  Service Theft\n   Service theft is defined as the use of a service offered
      by the SR\n   domain by a node not authorized to use the service.\n   Service
      theft is not a concern within the SR domain, as all SR source\n   nodes and
      SR segment endpoint nodes within the domain are able to\n   utilize the services
      of the domain.  If a node outside the SR domain\n   learns of segments or a
      topological service within the SR domain,\n   IACL filtering denies access to
      those segments.\n"
    title: 7.2.  Service Theft
  - contents:
    - "7.3.  Topology Disclosure\n   The SRH is unencrypted and may contain SIDs of
      some intermediate SR\n   nodes in the path towards the destination within the
      SR domain.  If\n   packets can be snooped within the SR domain, the SRH may
      reveal\n   topology, traffic flows, and service usage.\n   This is applicable
      within an SR domain, but the disclosure is less\n   relevant as an attacker
      has other means of learning topology, flows,\n   and service usage.\n"
    title: 7.3.  Topology Disclosure
  - contents:
    - "7.4.  ICMP Generation\n   The generation of ICMPv6 error messages may be used
      to attempt\n   denial-of-service attacks by sending an error-causing destination\n
      \  address or SRH in back-to-back packets.  An implementation that\n   correctly
      follows Section 2.4 of [RFC4443] would be protected by the\n   ICMPv6 rate-limiting
      mechanism.\n"
    title: 7.4.  ICMP Generation
  - contents:
    - "7.5.  Applicability of AH\n   The SR domain is a trusted domain, as defined
      in [RFC8402], Sections\n   2 and 8.2.  The SR source is trusted to add an SRH
      (optionally\n   verified as having been generated by a trusted source via the
      HMAC\n   TLV in this document), and segments advertised within the domain are\n
      \  trusted to be accurate and advertised by trusted sources via a secure\n   control
      plane.  As such, the SR domain does not rely on the\n   Authentication Header
      (AH) as defined in [RFC4302] to secure the SRH.\n   The use of SRH with AH by
      an SR source node and its processing at an\n   SR segment endpoint node are
      not defined in this document.  Future\n   documents may define use of SRH with
      AH and its processing.\n"
    title: 7.5.  Applicability of AH
  title: 7.  Security Considerations
- contents:
  - "8.  IANA Considerations\n   This document makes the following registrations in
    the \"Internet\n   Protocol Version 6 (IPv6) Parameters\" \"Routing Types\" subregistry\n
    \  maintained by IANA:\n         | Value | Description                  | Reference
    \    |\n         | 4     | Segment Routing Header (SRH) | This document |\n                        Table
    1: SRH Registration\n   This document makes the following registrations in the
    \"Type 4 -\n   Parameter Problem\" message of the \"Internet Control Message Protocol\n
    \  version 6 (ICMPv6) Parameters\" registry maintained by IANA:\n                  |
    Code | Name                        |\n                  | 4    | SR Upper-layer
    Header Error |\n                      Table 2: SR Upper-layer Header\n                            Error
    Registration\n"
  - contents:
    - "8.1.  Segment Routing Header Flags Registry\n   This document describes a new
      IANA-managed registry to identify SRH\n   Flags Bits.  The registration procedure
      is \"IETF Review\" [RFC8126].\n   The registry name is \"Segment Routing Header
      Flags\".  Flags are 8\n   bits.\n"
    title: 8.1.  Segment Routing Header Flags Registry
  - contents:
    - "8.2.  Segment Routing Header TLVs Registry\n   This document describes a new
      IANA-managed registry to identify SRH\n   TLVs.  The registration procedure
      is \"IETF Review\".  The registry\n   name is \"Segment Routing Header TLVs\".
      \ A TLV is identified through\n   an unsigned 8-bit codepoint value, with assigned
      values 0-127 for\n   TLVs that do not change en route and 128-255 for TLVs that
      may change\n   en route.  The following codepoints are defined in this document:\n
      \         | Value   | Description              | Reference     |\n          |
      0       | Pad1 TLV                 | This document |\n          | 1       |
      Reserved                 | This document |\n          | 2       | Reserved                 |
      This document |\n          | 3       | Reserved                 | This document
      |\n          | 4       | PadN TLV                 | This document |\n          |
      5       | HMAC TLV                 | This document |\n          | 6       |
      Reserved                 | This document |\n          | 124-126 | Experimentation
      and Test | This document |\n          | 127     | Reserved                 |
      This document |\n          | 252-254 | Experimentation and Test | This document
      |\n          | 255     | Reserved                 | This document |\n              Table
      3: Segment Routing Header TLVs Registry\n   Values 1, 2, 3, and 6 were defined
      in draft versions of this\n   specification and are Reserved for backwards compatibility
      with early\n   implementations and should not be reassigned.  Values 127 and
      255 are\n   Reserved to allow for expansion of the Type field in future\n   specifications,
      if needed.\n"
    title: 8.2.  Segment Routing Header TLVs Registry
  title: 8.  IANA Considerations
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [FIPS180-4]\n              National Institute
      of Standards and Technology (NIST),\n              \"Secure Hash Standard (SHS)\",
      FIPS PUB 180-4, DOI 10.6028/\n              NIST.FIPS.180-4, August 2015,\n
      \             <http://csrc.nist.gov/publications/fips/fips180-4/fips-\n              180-4.pdf>.\n
      \  [IANA-SRHTLV]\n              IANA, \"Segment Routing Header TLVs\",\n              <https://www.iana.org/assignments/ipv6-parameters/>.\n
      \  [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-\n              Hashing
      for Message Authentication\", RFC 2104,\n              DOI 10.17487/RFC2104,
      February 1997,\n              <https://www.rfc-editor.org/info/rfc2104>.\n   [RFC2119]
      \ Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n
      \             <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC2473]  Conta,
      A. and S. Deering, \"Generic Packet Tunneling in\n              IPv6 Specification\",
      RFC 2473, DOI 10.17487/RFC2473,\n              December 1998, <https://www.rfc-editor.org/info/rfc2473>.\n
      \  [RFC2827]  Ferguson, P. and D. Senie, \"Network Ingress Filtering:\n              Defeating
      Denial of Service Attacks which employ IP Source\n              Address Spoofing\",
      BCP 38, RFC 2827, DOI 10.17487/RFC2827,\n              May 2000, <https://www.rfc-editor.org/info/rfc2827>.\n
      \  [RFC3704]  Baker, F. and P. Savola, \"Ingress Filtering for Multihomed\n
      \             Networks\", BCP 84, RFC 3704, DOI 10.17487/RFC3704, March\n              2004,
      <https://www.rfc-editor.org/info/rfc3704>.\n   [RFC4107]  Bellovin, S. and R.
      Housley, \"Guidelines for Cryptographic\n              Key Management\", BCP
      107, RFC 4107, DOI 10.17487/RFC4107,\n              June 2005, <https://www.rfc-editor.org/info/rfc4107>.\n
      \  [RFC4302]  Kent, S., \"IP Authentication Header\", RFC 4302,\n              DOI
      10.17487/RFC4302, December 2005,\n              <https://www.rfc-editor.org/info/rfc4302>.\n
      \  [RFC5095]  Abley, J., Savola, P., and G. Neville-Neil, \"Deprecation\n              of
      Type 0 Routing Headers in IPv6\", RFC 5095,\n              DOI 10.17487/RFC5095,
      December 2007,\n              <https://www.rfc-editor.org/info/rfc5095>.\n   [RFC6407]
      \ Weis, B., Rowles, S., and T. Hardjono, \"The Group Domain\n              of
      Interpretation\", RFC 6407, DOI 10.17487/RFC6407,\n              October 2011,
      <https://www.rfc-editor.org/info/rfc6407>.\n   [RFC6437]  Amante, S., Carpenter,
      B., Jiang, S., and J. Rajahalme,\n              \"IPv6 Flow Label Specification\",
      RFC 6437,\n              DOI 10.17487/RFC6437, November 2011,\n              <https://www.rfc-editor.org/info/rfc6437>.\n
      \  [RFC6438]  Carpenter, B. and S. Amante, \"Using the IPv6 Flow Label\n              for
      Equal Cost Multipath Routing and Link Aggregation in\n              Tunnels\",
      RFC 6438, DOI 10.17487/RFC6438, November 2011,\n              <https://www.rfc-editor.org/info/rfc6438>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8200]  Deering, S. and R.
      Hinden, \"Internet Protocol, Version 6\n              (IPv6) Specification\",
      STD 86, RFC 8200,\n              DOI 10.17487/RFC8200, July 2017,\n              <https://www.rfc-editor.org/info/rfc8200>.\n
      \  [RFC8402]  Filsfils, C., Ed., Previdi, S., Ed., Ginsberg, L.,\n              Decraene,
      B., Litkowski, S., and R. Shakir, \"Segment\n              Routing Architecture\",
      RFC 8402, DOI 10.17487/RFC8402,\n              July 2018, <https://www.rfc-editor.org/info/rfc8402>.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [INTAREA-TUNNELS]\n              Touch, J.
      and M. Townsley, \"IP Tunnels in the Internet\n              Architecture\",
      Work in Progress, Internet-Draft, draft-\n              ietf-intarea-tunnels-10,
      12 September 2019,\n              <https://tools.ietf.org/html/draft-ietf-intarea-tunnels-\n
      \             10>.\n   [RFC4443]  Conta, A., Deering, S., and M. Gupta, Ed.,
      \"Internet\n              Control Message Protocol (ICMPv6) for the Internet\n
      \             Protocol Version 6 (IPv6) Specification\", STD 89,\n              RFC
      4443, DOI 10.17487/RFC4443, March 2006,\n              <https://www.rfc-editor.org/info/rfc4443>.\n
      \  [RFC5308]  Hopps, C., \"Routing IPv6 with IS-IS\", RFC 5308,\n              DOI
      10.17487/RFC5308, October 2008,\n              <https://www.rfc-editor.org/info/rfc5308>.\n
      \  [RFC5340]  Coltun, R., Ferguson, D., Moy, J., and A. Lindem, \"OSPF\n              for
      IPv6\", RFC 5340, DOI 10.17487/RFC5340, July 2008,\n              <https://www.rfc-editor.org/info/rfc5340>.\n
      \  [RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n              Writing
      an IANA Considerations Section in RFCs\", BCP 26,\n              RFC 8126, DOI
      10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n
      \  [SRN]      Lebrun, D., Jadin, M., Clad, F., Filsfils, C., and O.\n              Bonaventure,
      \"Software Resolved Networks: Rethinking\n              Enterprise Networks
      with IPv6 Segment Routing\", 2018,\n              <https://inl.info.ucl.ac.be/system/files/\n
      \             sosr18-final15-embedfonts.pdf>.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Acknowledgements\n   The authors would like to thank Ole Troan, Bob Hinden, Ron
    Bonica,\n   Fred Baker, Brian Carpenter, Alexandru Petrescu, Punit Kumar Jaiswal,\n
    \  David Lebrun, Benjamin Kaduk, Frank Xialiang, Mirja K\xFChlewind, Roman\n   Danyliw,
    Joe Touch, and Magnus Westerlund for their comments to this\n   document.\n"
  title: Acknowledgements
- contents:
  - "Contributors\n   Kamran Raza, Zafar Ali, Brian Field, Daniel Bernier, Ida Leung,
    Jen\n   Linkova, Ebben Aries, Tomoya Kosugi, \xC9ric Vyncke, David Lebrun, Dirk\n
    \  Steinberg, Robert Raszuk, Dave Barach, John Brzozowski, Pierre\n   Francois,
    Nagendra Kumar, Mark Townsley, Christian Martin, Roberta\n   Maglione, James Connolly,
    and Aloys Augustin contributed to the\n   content of this document.\n"
  title: Contributors
- contents:
  - "Authors' Addresses\n   Clarence Filsfils (editor)\n   Cisco Systems, Inc.\n   Brussels\n
    \  Belgium\n   Email: cfilsfil@cisco.com\n   Darren Dukes (editor)\n   Cisco Systems,
    Inc.\n   Ottawa\n   Canada\n   Email: ddukes@cisco.com\n   Stefano Previdi\n   Huawei\n
    \  Italy\n   Email: stefano@previdi.net\n   John Leddy\n   Individual\n   United
    States of America\n   Email: john@leddy.net\n   Satoru Matsushima\n   SoftBank\n
    \  Email: satoru.matsushima@g.softbank.co.jp\n   Daniel Voyer\n"
  title: Authors' Addresses
