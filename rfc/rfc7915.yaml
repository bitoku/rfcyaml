- title: __initial_text__
  contents:
  - '                     IP/ICMP Translation Algorithm

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes the Stateless IP/ICMP Translation Algorithm\n\
    \   (SIIT), which translates between IPv4 and IPv6 packet headers\n   (including\
    \ ICMP headers).  This document obsoletes RFC 6145.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7915.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction and Motivation . . . . . . . . . . . .\
    \ . . . . .   3\n     1.1.  IPv4-IPv6 Translation Model . . . . . . . . . . .\
    \ . . . .   3\n     1.2.  Applicability and Limitations . . . . . . . . . . .\
    \ . . .   3\n     1.3.  Stateless vs. Stateful Mode . . . . . . . . . . . . .\
    \ . .   4\n     1.4.  Path MTU Discovery and Fragmentation  . . . . . . . . .\
    \ .   5\n   2.  Changes from RFC 6145 . . . . . . . . . . . . . . . . . . . .\
    \   5\n   3.  Conventions . . . . . . . . . . . . . . . . . . . . . . . . .  \
    \ 5\n   4.  Translating from IPv4 to IPv6 . . . . . . . . . . . . . . . .   6\n\
    \     4.1.  Translating IPv4 Headers into IPv6 Headers  . . . . . . .   7\n  \
    \   4.2.  Translating ICMPv4 Headers into ICMPv6 Headers  . . . . .   9\n    \
    \ 4.3.  Translating ICMPv4 Error Messages into ICMPv6 . . . . . .  13\n     4.4.\
    \  Generation of ICMPv4 Error Message  . . . . . . . . . . .  14\n     4.5.  Transport-Layer\
    \ Header Translation  . . . . . . . . . . .  14\n     4.6.  Knowing When to Translate\
    \ . . . . . . . . . . . . . . . .  15\n   5.  Translating from IPv6 to IPv4 .\
    \ . . . . . . . . . . . . . . .  15\n     5.1.  Translating IPv6 Headers into\
    \ IPv4 Headers  . . . . . . .  17\n       5.1.1.  IPv6 Fragment Processing  .\
    \ . . . . . . . . . . . . .  19\n     5.2.  Translating ICMPv6 Headers into ICMPv4\
    \ Headers  . . . . .  19\n     5.3.  Translating ICMPv6 Error Messages into ICMPv4\
    \ . . . . . .  22\n     5.4.  Generation of ICMPv6 Error Messages . . . . . .\
    \ . . . . .  23\n     5.5.  Transport-Layer Header Translation  . . . . . . .\
    \ . . . .  23\n     5.6.  Knowing When to Translate . . . . . . . . . . . . .\
    \ . . .  24\n   6.  Mapping of IP Addresses . . . . . . . . . . . . . . . . .\
    \ . .  24\n   7.  Special Considerations for ICMPv6 Packet Too Big  . . . . .\
    \ .  24\n   8.  Security Considerations . . . . . . . . . . . . . . . . . . .\
    \  24\n   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  25\n\
    \     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  25\n  \
    \   9.2.  Informative References  . . . . . . . . . . . . . . . . .  27\n   Appendix\
    \ A.  Stateless Translation Workflow Example . . . . . . .  30\n     A.1.  H6\
    \ Establishes Communication with H4  . . . . . . . . . .  30\n     A.2.  H4 Establishes\
    \ Communication with H6  . . . . . . . . . .  32\n   Acknowledgements  . . . .\
    \ . . . . . . . . . . . . . . . . . . . .  33\n   Authors' Addresses  . . . .\
    \ . . . . . . . . . . . . . . . . . . .  33\n"
- title: 1.  Introduction and Motivation
  contents:
  - "1.  Introduction and Motivation\n   This document obsoletes [RFC6145].\n   Readers\
    \ of this document are expected to have read and understood the\n   framework\
    \ described in [RFC6144].  Implementations of this IPv4/IPv6\n   translation specification\
    \ MUST support one or more address mapping\n   algorithms, which are defined in\
    \ Section 6.\n"
- title: 1.1.  IPv4-IPv6 Translation Model
  contents:
  - "1.1.  IPv4-IPv6 Translation Model\n   The translation model consists of two or\
    \ more network domains\n   connected by one or more IP/ICMP translators (XLATs)\
    \ as shown in\n   Figure 1.\n               ---------          ---------\n   \
    \          //        \\\\       //         \\\\\n           /             +----+\
    \              \\\n          |              |XLAT|               | XLAT: IP/ICMP\n\
    \          |   IPv4       +----+   IPv6        |       Translator\n          |\
    \   Domain     |    |   Domain      |\n          |              |    |       \
    \        |\n           \\             |    |              /\n            \\\\\
    \         //      \\\\          //\n               --------          ---------\n\
    \                   Figure 1: IPv4-IPv6 Translation Model\n   The scenarios of\
    \ the translation model are discussed in [RFC6144].\n"
- title: 1.2.  Applicability and Limitations
  contents:
  - "1.2.  Applicability and Limitations\n   This document specifies the translation\
    \ algorithms between IPv4\n   packets and IPv6 packets.\n   As with [RFC6145],\
    \ the translating function specified in this\n   document does not translate any\
    \ IPv4 options, and it does not\n   translate IPv6 extension headers except the\
    \ Fragment Header.\n   The issues and algorithms in the translation of datagrams\
    \ containing\n   TCP segments are described in [RFC5382].\n   Fragmented IPv4\
    \ UDP packets that do not contain a UDP checksum (i.e.,\n   the UDP checksum field\
    \ is zero) are not of significant use on the\n   Internet, and in general will\
    \ not be translated by the IP/ICMP\n   translator (Section 4.5).  However, when\
    \ the translator is configured\n   to forward the packet without a UDP checksum,\
    \ the fragmented IPv4 UDP\n   packets will be translated.\n   Fragmented ICMP/ICMPv6\
    \ packets will not be translated by IP/ICMP\n   translators.\n   The IP/ICMP header\
    \ translation specified in this document is\n   consistent with requirements of\
    \ multicast IP/ICMP headers.  However,\n   IPv4 multicast addresses [RFC5771]\
    \ cannot be mapped to IPv6 multicast\n   addresses [RFC3307] based on the unicast\
    \ mapping rule [RFC6052].  An\n   example of experiments of the multicast address\
    \ mapping can be found\n   in [RFC6219].\n"
- title: 1.3.  Stateless vs. Stateful Mode
  contents:
  - "1.3.  Stateless vs. Stateful Mode\n   An IP/ICMP translator has two possible\
    \ modes of operation: stateless\n   and stateful [RFC6144].  In both cases, we\
    \ assume that a system (a\n   node or an application) that has an IPv4 address\
    \ but not an IPv6\n   address is communicating with a system that has an IPv6\
    \ address but\n   no IPv4 address, or that the two systems do not have contiguous\n\
    \   routing connectivity, or they might have contiguous routing\n   connectivity\
    \ but are interacting via masking addresses (i.e.,\n   hairpinning) [RFC4787],\
    \ and hence are forced to have their\n   communications translated.\n   In the\
    \ stateless mode, an IP/ICMP translator will convert IPv4\n   addresses to IPv6\
    \ and vice versa solely based on the configuration of\n   the stateless IP/ICMP\
    \ translator and information contained within the\n   packet being translated.\
    \  For example, for the default behavior\n   defined in [RFC6052], a specific\
    \ IPv6 address range will represent\n   IPv4 systems (IPv4-converted addresses),\
    \ and the IPv6 systems have\n   addresses (IPv4-translatable addresses) that can\
    \ be algorithmically\n   mapped to a subset of the service provider's IPv4 addresses.\
    \  Other\n   stateless translation algorithms are defined in Section 6.  The\n\
    \   stateless translator does not keep any dynamic session or binding\n   state,\
    \ thus there is no requirement that the packets in a single\n   session or flow\
    \ traverse a single translator.\n   In the stateful mode, a specific IPv6 address\
    \ range (consisting of\n   IPv4-converted IPv6 addresses) will typically represent\
    \ IPv4 systems.\n   The IPv6 nodes may use any IPv6 addresses [RFC4291] except\
    \ in that\n   range.  A stateful IP/ICMP translator continuously maintains a\n\
    \   dynamic translation table containing bindings between the IPv4 and\n   IPv6\
    \ addresses, and likely also the Layer-4 identifiers, that are\n   used in the\
    \ translated packets.  The exact address translations of\n   any given packet\
    \ thus become dependent on how packets belonging to\n   the same session or flow\
    \ have been translated.  For this reason,\n   stateful translation generally requires\
    \ that all packets belonging to\n   a single flow must traverse the same translator.\n\
    \   In order to be able to successfully translate a packet from IPv4 to\n   IPv6\
    \ or vice versa, the translator must implement an address mapping\n   algorithm.\
    \  This document does not specify any such algorithms,\n   instead these are referenced\
    \ from Section 6.\n"
- title: 1.4.  Path MTU Discovery and Fragmentation
  contents:
  - "1.4.  Path MTU Discovery and Fragmentation\n   Due to the different sizes of\
    \ the IPv4 and IPv6 header, which are 20+\n   octets and 40 octets respectively,\
    \ handling the maximum packet size\n   is critical for the operation of the IPv4/IPv6\
    \ translator.  There are\n   three mechanisms to handle this issue: path MTU discovery\
    \ (PMTUD),\n   fragmentation, and transport-layer negotiation such as the TCP\n\
    \   Maximum Segment Size (MSS) option [RFC6691].  Note that the\n   translator\
    \ MUST behave as a router, i.e., the translator MUST send a\n   Packet Too Big\
    \ error message or fragment the packet when the packet\n   size exceeds the MTU\
    \ of the next-hop interface.\n   Don't Fragment, ICMP Packet Too Big, and packet\
    \ fragmentation are\n   discussed in Sections 4 and 5 of this document.  The reassembling\
    \ of\n   fragmented packets in the stateful translator is discussed in\n   [RFC6146],\
    \ since it requires state maintenance in the translator.\n"
- title: 2.  Changes from RFC 6145
  contents:
  - "2.  Changes from RFC 6145\n   The changes from RFC 6145 are the following:\n\
    \   1.  Inserted the notes about IPv6 extension header handling:\n       [Err3059],\
    \ [Err3060], [Err3061], and [Err4090].\n   2.  Deprecated the algorithm that generates\
    \ the IPv6 atomic\n       fragments, as a result of the analysis in [ATOMIC] and\
    \ the\n       specification in [IPv6].\n   3.  Inserted the notes for stateless\
    \ source address mapping for\n       ICMPv6 packets [RFC6791].\n   4.  Supported\
    \ new address mapping algorithms and moved the discussion\n       of these algorithms\
    \ to Section 6.\n"
- title: 3.  Conventions
  contents:
  - "3.  Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
- title: 4.  Translating from IPv4 to IPv6
  contents:
  - "4.  Translating from IPv4 to IPv6\n   When an IP/ICMP translator receives an\
    \ IPv4 datagram addressed to a\n   destination towards the IPv6 domain, it translates\
    \ the IPv4 header of\n   that packet into an IPv6 header.  The original IPv4 header\
    \ on the\n   packet is removed and replaced by an IPv6 header, and the transport\n\
    \   checksum is updated as needed, if that transport is supported by the\n   translator.\
    \  The data portion of the packet is left unchanged.  The\n   IP/ICMP translator\
    \ then forwards the packet based on the IPv6\n   destination address.\n      \
    \        +-------------+                 +-------------+\n              |    IPv4\
    \     |                 |    IPv6     |\n              |   Header    |       \
    \          |   Header    |\n              +-------------+                 +-------------+\n\
    \              |  Transport- |                 |  Fragment   |\n             \
    \ |   Layer     |      ===>       |   Header    |\n              |   Header  \
    \  |                 | (if needed) |\n              +-------------+          \
    \       +-------------+\n              |             |                 |  Transport-\
    \ |\n              ~    Data     ~                 |   Layer     |\n         \
    \     |             |                 |   Header    |\n              +-------------+\
    \                 +-------------+\n                                          \
    \    |             |\n                                              ~    Data\
    \     ~\n                                              |             |\n     \
    \                                         +-------------+\n                  \
    \  Figure 2: IPv4-to-IPv6 Translation\n   Path MTU discovery is mandatory in IPv6,\
    \ but it is optional in IPv4.\n   IPv6 routers never fragment a packet -- only\
    \ the sender can do\n   fragmentation.\n   When an IPv4 node performs path MTU\
    \ discovery (by setting the Don't\n   Fragment (DF) bit in the header), path MTU\
    \ discovery can operate end-\n   to-end, i.e., across the translator.  In this\
    \ case, either IPv4 or\n   IPv6 routers (including the translator) might send\
    \ back ICMP Packet\n   Too Big messages to the sender.  When the IPv6 routers\
    \ send these\n   ICMPv6 errors, they will pass through a translator that will\n\
    \   translate the ICMPv6 error to a form that the IPv4 sender can\n   understand.\
    \  As a result, an IPv6 Fragment Header is only included if\n   the IPv4 packet\
    \ is already fragmented.\n   However, when the IPv4 sender does not set the DF\
    \ bit, the translator\n   MUST ensure that the packet does not exceed the path\
    \ MTU on the IPv6\n   side.  This is done by fragmenting the IPv4 packet (with\
    \ Fragment\n   Headers) so that it fits in 1280-byte IPv6 packets, since that\
    \ is the\n   minimum IPv6 MTU.  The IPv6 Fragment Header has been shown to cause\n\
    \   operational difficulties in practice due to limited firewall\n   fragmentation\
    \ support, etc.  In an environment where the network\n   owned/operated by the\
    \ same entity that owns/operates the translator,\n   the translator MUST provide\
    \ a configuration function for the network\n   administrator to adjust the threshold\
    \ of the minimum IPv6 MTU to a\n   value that reflects the real value of the minimum\
    \ IPv6 MTU in the\n   network (greater than 1280 bytes).  This will help reduce\
    \ the chance\n   of including the Fragment Header in the packets.\n   When the\
    \ IPv4 sender does not set the DF bit, the translator MUST NOT\n   include the\
    \ Fragment Header for the non-fragmented IPv6 packets.\n   The rules in Section\
    \ 4.1 ensure that when packets are fragmented,\n   either by the sender or by\
    \ IPv4 routers, the low-order 16 bits of the\n   fragment identification are carried\
    \ end-to-end, ensuring that packets\n   are correctly reassembled.\n   Other than\
    \ the special rules for handling fragments and path MTU\n   discovery, the actual\
    \ translation of the packet header consists of a\n   simple translation as defined\
    \ below.  Note that ICMPv4 packets\n   require special handling in order to translate\
    \ the content of ICMPv4\n   error messages and also to add the ICMPv6 pseudo-header\
    \ checksum.\n   The translator SHOULD make sure that the packets belonging to\
    \ the\n   same flow leave the translator in the same order in which they\n   arrived.\n"
- title: 4.1.  Translating IPv4 Headers into IPv6 Headers
  contents:
  - "4.1.  Translating IPv4 Headers into IPv6 Headers\n   If the DF flag is not set\
    \ and the IPv4 packet will result in an IPv6\n   packet larger than a user-defined\
    \ length (hereinafter referred to as\n   \"lowest-ipv6-mtu\", and which defaults\
    \ to 1280 bytes), the packet\n   SHOULD be fragmented so that the resulting IPv6\
    \ packet (with Fragment\n   Header added to each fragment) will be less than or\
    \ equal to lowest-\n   ipv6-mtu, For example, if the packet is fragmented prior\
    \ to the\n   translation, the IPv4 packets should be fragmented so that their\n\
    \   length, excluding the IPv4 header, is at most 1232 bytes (1280 minus\n   40\
    \ for the IPv6 header and 8 for the Fragment Header).  The\n   translator MUST\
    \ provide a configuration function for the network\n   administrator to adjust\
    \ the threshold of the minimum IPv6 MTU to a\n   value greater than 1280 bytes\
    \ if the real value of the minimum IPv6\n   MTU in the network is known to the\
    \ administrator.  The resulting\n   fragments are then translated independently\
    \ using the logic described\n   below.\n   If the DF bit is set and the MTU of\
    \ the next-hop interface is less\n   than the total length value of the IPv4 packet\
    \ plus 20, the\n   translator MUST send an ICMPv4 \"Fragmentation Needed\" error\
    \ message\n   to the IPv4 source address.\n   The IPv6 header fields are set as\
    \ follows:\n   Version:  6\n   Traffic Class:  By default, copied from the IP\
    \ Type Of Service (TOS)\n      octet.  According to [RFC2474], the semantics of\
    \ the bits are\n      identical in IPv4 and IPv6.  However, in some IPv4 environments\n\
    \      these fields might be used with the old semantics of \"Type Of\n      Service\
    \ and Precedence\".  An implementation of a translator SHOULD\n      support an\
    \ administratively configurable option to ignore the IPv4\n      TOS and always\
    \ set the IPv6 traffic class (TC) to zero.  In\n      addition, if the translator\
    \ is at an administrative boundary, the\n      filtering and update considerations\
    \ of [RFC2475] may be\n      applicable.\n   Flow Label:  0 (all zero bits)\n\
    \   Payload Length:  Total length value from the IPv4 header, minus the\n    \
    \  size of the IPv4 header and IPv4 options, if present.\n   Next Header:  For\
    \ ICMPv4 (1), it is changed to ICMPv6 (58);\n      otherwise, the protocol field\
    \ MUST be copied from the IPv4 header.\n   Hop Limit:  The hop limit is derived\
    \ from the TTL value in the IPv4\n      header.  Since the translator is a router,\
    \ as part of forwarding\n      the packet it needs to decrement either the IPv4\
    \ TTL (before the\n      translation) or the IPv6 Hop Limit (after the translation).\
    \  As\n      part of decrementing the TTL or Hop Limit, the translator (as any\n\
    \      router) MUST check for zero and send the ICMPv4 \"TTL Exceeded\" or\n \
    \     ICMPv6 \"Hop Limit Exceeded\" error.\n   Source Address:  Mapped to an IPv6\
    \ address based on the algorithms\n      presented in Section 6.\n      If the\
    \ translator gets an illegal source address (e.g., 0.0.0.0,\n      127.0.0.1,\
    \ etc.), the translator SHOULD silently discard the\n      packet (as discussed\
    \ in Section 5.3.7 of [RFC1812]).  Note when\n      translating ICMPv4 Error Messages\
    \ into ICMPv6, the \"illegal\"\n      source address will be translated for the\
    \ purpose of trouble\n      shooting.\n   Destination Address:  Mapped to an IPv6\
    \ address based on the\n      algorithms presented in Section 6.\n   If any IPv4\
    \ options are present in the IPv4 packet, they MUST be\n   ignored and the packet\
    \ translated normally; there is no attempt to\n   translate the options.  However,\
    \ if an unexpired source route option\n   is present, then the packet MUST instead\
    \ be discarded, and an ICMPv4\n   \"Destination Unreachable, Source Route Failed\"\
    \ (Type 3, Code 5) error\n   message SHOULD be returned to the sender.\n   If\
    \ there is a need to add a Fragment Header (the packet is a fragment\n   or the\
    \ DF bit is not set and the packet size is greater than the\n   minimum IPv6 MTU\
    \ in the network set by the translator configuration\n   function), the header\
    \ fields are set as above with the following\n   exceptions:\n   IPv6 fields:\n\
    \      Payload Length:  Total length value from the IPv4 header, plus 8\n    \
    \     for the Fragment Header, minus the size of the IPv4 header and\n       \
    \  IPv4 options, if present.\n      Next Header:  Fragment Header (44).\n   Fragment\
    \ Header fields:\n      Next Header:  For ICMPv4 (1), it is changed to ICMPv6\
    \ (58);\n         otherwise, the protocol field MUST be copied from the IPv4\n\
    \         header.\n      Fragment Offset:  Fragment Offset copied from the IPv4\
    \ header.\n      M flag:  More Fragments bit copied from the IPv4 header.\n  \
    \    Identification:  The low-order 16 bits copied from the\n         Identification\
    \ field in the IPv4 header.  The high-order 16\n         bits set to zero.\n"
- title: 4.2.  Translating ICMPv4 Headers into ICMPv6 Headers
  contents:
  - "4.2.  Translating ICMPv4 Headers into ICMPv6 Headers\n   All ICMPv4 messages\
    \ that are to be translated require that the ICMPv6\n   checksum field be calculated\
    \ as part of the translation since ICMPv6,\n   unlike ICMPv4, has a pseudo-header\
    \ checksum just like UDP and TCP.\n   In addition, all ICMPv4 packets MUST have\
    \ the Type translated and,\n   for ICMPv4 error messages, the included IP header\
    \ also MUST be\n   translated.\n   The actions needed to translate various ICMPv4\
    \ messages are as\n   follows:\n   ICMPv4 query messages:\n      Echo and Echo\
    \ Reply (Type 8 and Type 0):  Adjust the Type values\n         to 128 and 129,\
    \ respectively, and adjust the ICMP checksum both\n         to take the type change\
    \ into account and to include the ICMPv6\n         pseudo-header.\n      Information\
    \ Request/Reply (Type 15 and Type 16):  Obsoleted in\n         ICMPv6.  Silently\
    \ drop.\n      Timestamp and Timestamp Reply (Type 13 and Type 14):  Obsoleted\
    \ in\n         ICMPv6.  Silently drop.\n      Address Mask Request/Reply (Type\
    \ 17 and Type 18):  Obsoleted in\n         ICMPv6.  Silently drop.\n      ICMP\
    \ Router Advertisement (Type 9):  Single-hop message.  Silently\n         drop.\n\
    \      ICMP Router Solicitation (Type 10):  Single-hop message.  Silently\n  \
    \       drop.\n      Unknown ICMPv4 types:  Silently drop.\n      IGMP messages:\
    \  While the Multicast Listener Discovery (MLD)\n         messages specified in\
    \ [RFC2710], [RFC3590], and [RFC3810] are\n         the logical IPv6 counterparts\
    \ for the IPv4 IGMP messages, all\n         the \"normal\" IGMP messages are single-hop\
    \ messages and SHOULD\n         be silently dropped by the translator.  Other\
    \ IGMP messages\n         might be used by multicast routing protocols and, since\
    \ it\n         would be a configuration error to try to have router\n        \
    \ adjacencies across IP/ICMP translators, those packets SHOULD\n         also\
    \ be silently dropped.\n      ICMPv4 error messages:\n         Destination Unreachable\
    \ (Type 3):  Translate the Code as\n            described below, set the Type\
    \ to 1, and adjust the ICMP\n            checksum both to take the type/code change\
    \ into account and\n            to include the ICMPv6 pseudo-header.\n       \
    \     Translate the Code as follows:\n            Code 0, 1 (Net Unreachable,\
    \ Host Unreachable):  Set the Code\n               to 0 (No route to destination).\n\
    \            Code 2 (Protocol Unreachable):  Translate to an ICMPv6\n        \
    \       Parameter Problem (Type 4, Code 1) and make the Pointer\n            \
    \   point to the IPv6 Next Header field.\n            Code 3 (Port Unreachable):\
    \  Set the Code to 4 (Port\n               unreachable).\n            Code 4 (Fragmentation\
    \ Needed and DF was Set):  Translate to\n               an ICMPv6 Packet Too Big\
    \ message (Type 2) with Code set\n               to 0.  The MTU field MUST be\
    \ adjusted for the difference\n               between the IPv4 and IPv6 header\
    \ sizes, but MUST NOT be\n               set to a value smaller than the minimum\
    \ IPv6 MTU (1280\n               bytes).  That is, it should be set to\n     \
    \          maximum(1280,\n                 minimum((MTU value in the Packet Too\
    \ Big Message) + 20,\n                         MTU_of_IPv6_nexthop,\n        \
    \                 (MTU_of_IPv4_nexthop) + 20)).\n               Note that if the\
    \ IPv4 router set the MTU field to zero,\n               i.e., the router does\
    \ not implement [RFC1191], then the\n               translator MUST use the plateau\
    \ values specified in\n               [RFC1191] to determine a likely path MTU\
    \ and include that\n               path MTU in the ICMPv6 packet.  (Use the greatest\
    \ plateau\n               value that is less than the returned Total Length field,\n\
    \               but that is larger than or equal to 1280.)\n               See\
    \ also the requirements in Section 7.\n            Code 5 (Source Route Failed):\
    \  Set the Code to 0 (No route\n               to destination).  Note that this\
    \ error is unlikely since\n               source routes are not translated.\n\
    \            Code 6, 7, 8:  Set the Code to 0 (No route to destination).\n   \
    \         Code 9, 10  (Communication with Destination Host\n               Administratively\
    \ Prohibited): Set the Code to 1\n               (Communication with destination\
    \ administratively\n               prohibited).\n            Code 11, 12:  Set\
    \ the Code to 0 (No route to destination).\n            Code 13 (Communication\
    \ Administratively Prohibited):  Set\n               the Code to 1 (Communication\
    \ with destination\n               administratively prohibited).\n           \
    \ Code 14 (Host Precedence Violation):  Silently drop.\n            Code 15 (Precedence\
    \ cutoff in effect):  Set the Code to 1\n               (Communication with destination\
    \ administratively\n               prohibited).\n            Other Code values:\
    \  Silently drop.\n         Redirect (Type 5):  Single-hop message.  Silently\
    \ drop.\n         Alternative Host Address (Type 6):  Silently drop.\n       \
    \  Source Quench (Type 4):  Obsoleted in ICMPv6.  Silently drop.\n         Time\
    \ Exceeded (Type 11):  Set the Type to 3, and adjust the\n            ICMP checksum\
    \ both to take the type change into account and\n            to include the ICMPv6\
    \ pseudo-header.  The Code is unchanged.\n         Parameter Problem (Type 12):\
    \  Set the Type to 4, and adjust the\n            ICMP checksum both to take the\
    \ type/code change into account\n            and to include the ICMPv6 pseudo-header.\n\
    \            Translate the Code as follows:\n            Code 0 (Pointer indicates\
    \ the error):  Set the Code to 0\n               (Erroneous header field encountered)\
    \ and update the\n               pointer as defined in Figure 3.  (If the Original\
    \ IPv4\n               Pointer Value is not listed or the Translated IPv6\n  \
    \             Pointer Value is listed as \"n/a\", silently drop the\n        \
    \       packet.)\n            Code 1 (Missing a required option):  Silently drop.\n\
    \            Code 2 (Bad length):  Set the Code to 0 (Erroneous header\n     \
    \          field encountered) and update the pointer as defined in\n         \
    \      Figure 3.  (If the Original IPv4 Pointer Value is not\n               listed\
    \ or the Translated IPv6 Pointer Value is listed as\n               \"n/a\", silently\
    \ drop the packet.)\n            Other Code values:  Silently drop.\n        \
    \ Unknown ICMPv4 types:  Silently drop.\n    +--------------------------------+--------------------------------+\n\
    \    |   Original IPv4 Pointer Value  | Translated IPv6 Pointer Value  |\n   \
    \ +--------------------------------+--------------------------------+\n    | \
    \ 0  | Version/IHL              |  0  | Version/Traffic Class    |\n    |  1 \
    \ | Type Of Service          |  1  | Traffic Class/Flow Label |\n    | 2,3 | Total\
    \ Length             |  4  | Payload Length           |\n    | 4,5 | Identification\
    \           | n/a |                          |\n    |  6  | Flags/Fragment Offset\
    \    | n/a |                          |\n    |  7  | Fragment Offset         \
    \ | n/a |                          |\n    |  8  | Time to Live             | \
    \ 7  | Hop Limit                |\n    |  9  | Protocol                 |  6 \
    \ | Next Header              |\n    |10,11| Header Checksum          | n/a | \
    \                         |\n    |12-15| Source Address           |  8  | Source\
    \ Address           |\n    |16-19| Destination Address      | 24  | Destination\
    \ Address      |\n    +--------------------------------+--------------------------------+\n\
    \         Figure 3: Pointer Value for Translating from IPv4 to IPv6\n        \
    \ ICMP Error Payload:  If the received ICMPv4 packet contains an\n           \
    \ ICMPv4 Extension [RFC4884], the translation of the ICMPv4\n            packet\
    \ will cause the ICMPv6 packet to change length.  When\n            this occurs,\
    \ the ICMPv6 Extension length attribute MUST be\n            adjusted accordingly\
    \ (e.g., longer due to the translation\n            from IPv4 to IPv6).  If the\
    \ ICMPv4 Extension exceeds the\n            maximum size of an ICMPv6 message\
    \ on the outgoing interface,\n            the ICMPv4 extension SHOULD be simply\
    \ truncated.  For\n            extensions not defined in [RFC4884], the translator\
    \ passes\n            the extensions as opaque bit strings, and those containing\n\
    \            IPv4 address literals will not have their included addresses\n  \
    \          translated to IPv6 address literals; this may cause problems\n    \
    \        with processing of those ICMP extensions.\n"
- title: 4.3.  Translating ICMPv4 Error Messages into ICMPv6
  contents:
  - "4.3.  Translating ICMPv4 Error Messages into ICMPv6\n   There are some differences\
    \ between the ICMPv4 and the ICMPv6 error\n   message formats as detailed above.\
    \  The ICMP error messages\n   containing the packet in error MUST be translated\
    \ just like a normal\n   IP packet (except the TTL value of the inner IPv4/IPv6\
    \ packet).  If\n   the translation of this \"packet in error\" changes the length\
    \ of the\n   datagram, the Total Length field in the outer IPv6 header MUST be\n\
    \   updated.\n              +-------------+                 +-------------+\n\
    \              |    IPv4     |                 |    IPv6     |\n             \
    \ |   Header    |                 |   Header    |\n              +-------------+\
    \                 +-------------+\n              |   ICMPv4    |             \
    \    |   ICMPv6    |\n              |   Header    |                 |   Header\
    \    |\n              +-------------+                 +-------------+\n      \
    \        |    IPv4     |      ===>       |    IPv6     |\n              |   Header\
    \    |                 |   Header    |\n              +-------------+        \
    \         +-------------+\n              |   Partial   |                 |   Partial\
    \   |\n              |  Transport- |                 |  Transport- |\n       \
    \       |   Layer     |                 |   Layer     |\n              |   Header\
    \    |                 |   Header    |\n              +-------------+        \
    \         +-------------+\n               Figure 4: IPv4-to-IPv6 ICMP Error Translation\n\
    \   The translation of the inner IP header can be done by invoking the\n   function\
    \ that translated the outer IP headers.  This process MUST\n   stop at the first\
    \ embedded header and drop the packet if it contains\n   more embedded headers.\n"
- title: 4.4.  Generation of ICMPv4 Error Message
  contents:
  - "4.4.  Generation of ICMPv4 Error Message\n   If the IPv4 packet is discarded,\
    \ then the translator SHOULD be able\n   to send back an ICMPv4 error message\
    \ to the original sender of the\n   packet, unless the discarded packet is itself\
    \ an ICMPv4 error\n   message.  The ICMPv4 message, if sent, has a Type of 3 (Destination\n\
    \   Unreachable) and a Code of 13 (Communication Administratively\n   Prohibited),\
    \ unless otherwise specified in this document or in\n   [RFC6146].  The translator\
    \ SHOULD allow an administrator to configure\n   whether the ICMPv4 error messages\
    \ are sent, rate-limited, or not\n   sent.\n"
- title: 4.5.  Transport-Layer Header Translation
  contents:
  - "4.5.  Transport-Layer Header Translation\n   If the address translation algorithm\
    \ is not checksum neutral (see\n   Section 4.1 of [RFC6052]), the recalculation\
    \ and updating of the\n   transport-layer headers that contain pseudo-headers\
    \ need to be\n   performed.  Translators MUST do this for TCP and ICMP packets\
    \ and for\n   UDP packets that contain a UDP checksum (i.e., the UDP checksum\
    \ field\n   is not zero).\n   For UDP packets that do not contain a UDP checksum\
    \ (i.e., the UDP\n   checksum field is zero), the translator SHOULD provide a\n\
    \   configuration function to allow:\n   1.  Dropping the packet and generating\
    \ a system management event that\n       specifies at least the IP addresses and\
    \ port numbers of the\n       packet.\n   2.  Calculating an IPv6 checksum and\
    \ forwarding the packet (which has\n       performance implications).\n      \
    \ A stateless translator cannot compute the UDP checksum of\n       fragmented\
    \ packets, so when a stateless translator receives the\n       first fragment\
    \ of a fragmented UDP IPv4 packet and the checksum\n       field is zero, the\
    \ translator SHOULD drop the packet and generate\n       a system management event\
    \ that specifies at least the IP\n       addresses and port numbers in the packet.\n\
    \       For a stateful translator, the handling of fragmented UDP IPv4\n     \
    \  packets with a zero checksum is discussed in [RFC6146],\n       Section 3.4.\n\
    \   Other transport protocols (e.g., the Datagram Congestion Control\n   Protocol\
    \ (DCCP)) are OPTIONAL to support.  In order to ease debugging\n   and troubleshooting,\
    \ translators MUST forward all transport protocols\n   as described in the \"\
    Next Header\" step of Section 4.1.\n"
- title: 4.6.  Knowing When to Translate
  contents:
  - "4.6.  Knowing When to Translate\n   If the IP/ICMP translator also provides a\
    \ normal forwarding function,\n   and the destination IPv4 address is reachable\
    \ by a more specific\n   route without translation, the translator MUST forward\
    \ it without\n   translating it.  Otherwise, when an IP/ICMP translator receives\
    \ an\n   IPv4 datagram addressed to an IPv4 destination representing a host in\n\
    \   the IPv6 domain, the packet MUST be translated to IPv6.\n"
- title: 5.  Translating from IPv6 to IPv4
  contents:
  - "5.  Translating from IPv6 to IPv4\n   When an IP/ICMP translator receives an\
    \ IPv6 datagram addressed to a\n   destination towards the IPv4 domain, it translates\
    \ the IPv6 header of\n   the received IPv6 packet into an IPv4 header.  The original\
    \ IPv6\n   header on the packet is removed and replaced by an IPv4 header.\n \
    \  Since the ICMPv6 [RFC4443], TCP [RFC793], UDP [RFC768], and DCCP\n   [RFC4340]\
    \ headers contain checksums that cover the IP header, if the\n   address mapping\
    \ algorithm is not checksum neutral, the checksum MUST\n   be evaluated before\
    \ translation and the ICMP and transport-layer\n   headers MUST be updated.  The\
    \ data portion of the packet is left\n   unchanged.  The IP/ICMP translator then\
    \ forwards the packet based on\n   the IPv4 destination address.\n           \
    \   +-------------+                 +-------------+\n              |    IPv6 \
    \    |                 |    IPv4     |\n              |   Header    |        \
    \         |   Header    |\n              +-------------+                 +-------------+\n\
    \              |  Fragment   |                 |  Transport  |\n             \
    \ |   Header    |      ===>       |   Layer     |\n              |(if present)\
    \ |                 |   Header    |\n              +-------------+           \
    \      +-------------+\n              |  Transport  |                 |      \
    \       |\n              |   Layer     |                 ~    Data     ~\n   \
    \           |   Header    |                 |             |\n              +-------------+\
    \                 +-------------+\n              |             |\n           \
    \   ~    Data     ~\n              |             |\n              +-------------+\n\
    \                    Figure 5: IPv6-to-IPv4 Translation\n   There are some differences\
    \ between IPv6 and IPv4 (in the areas of\n   fragmentation and the minimum link\
    \ MTU) that affect the translation.\n   An IPv6 link has to have an MTU of 1280\
    \ bytes or greater.  The\n   corresponding limit for IPv4 is 68 bytes.  Path MTU\
    \ discovery across\n   a translator relies on ICMP Packet Too Big messages being\
    \ received\n   and processed by IPv6 hosts.\n   The difference in the minimum\
    \ MTUs of IPv4 and IPv6 is accommodated\n   as follows:\n   o  When translating\
    \ an ICMPv4 \"Fragmentation Needed\" packet, the\n      indicated MTU in the resulting\
    \ ICMPv6 \"Packet Too Big\" will never\n      be set to a value lower than 1280.\
    \  This ensures that the IPv6\n      nodes will never have to encounter or handle\
    \ Path MTU values lower\n      than the minimum IPv6 link MTU of 1280.  See Section\
    \ 4.2.\n   o  When the resulting IPv4 packet is smaller than or equal to 1260\n\
    \      bytes, the translator MUST send the packet with a cleared Don't\n     \
    \ Fragment bit.  Otherwise, the packet MUST be sent with the Don't\n      Fragment\
    \ bit set.  See Section 5.1.\n   This approach allows Path MTU Discovery to operate\
    \ end-to-end for\n   paths whose MTU are not smaller than the minimum IPv6 MTU\
    \ of 1280\n   (which corresponds to an MTU of 1260 in the IPv4 domain).  On paths\n\
    \   that have IPv4 links with MTU < 1260, the IPv4 router(s) connected to\n  \
    \ those links will fragment the packets in accordance with Section 2.3\n   of\
    \ [RFC791].\n   Other than the special rules for handling fragments and path MTU\n\
    \   discovery, the actual translation of the packet header consists of a\n   simple\
    \ translation as defined below.  Note that ICMPv6 packets\n   require special\
    \ handling in order to translate the contents of ICMPv6\n   error messages and\
    \ also to remove the ICMPv6 pseudo-header checksum.\n   The translator SHOULD\
    \ make sure that the packets belonging to the\n   same flow leave the translator\
    \ in the same order in which they\n   arrived.\n"
- title: 5.1.  Translating IPv6 Headers into IPv4 Headers
  contents:
  - "5.1.  Translating IPv6 Headers into IPv4 Headers\n   If there is no IPv6 Fragment\
    \ Header, the IPv4 header fields are set\n   as follows:\n   Version:  4\n   Internet\
    \ Header Length:  5 (no IPv4 options)\n   Type of Service (TOS) Octet:  By default,\
    \ copied from the IPv6\n      Traffic Class (all 8 bits).  According to [RFC2474],\
    \ the semantics\n      of the bits are identical in IPv4 and IPv6.  However, in\
    \ some IPv4\n      environments, these bits might be used with the old semantics\
    \ of\n      \"Type Of Service and Precedence\".  An implementation of a\n    \
    \  translator SHOULD provide the ability to ignore the IPv6 traffic\n      class\
    \ and always set the IPv4 TOS Octet to a specified value.  In\n      addition,\
    \ if the translator is at an administrative boundary, the\n      filtering and\
    \ update considerations of [RFC2475] may be\n      applicable.\n   Total Length:\
    \  Payload length value from the IPv6 header, plus the\n      size of the IPv4\
    \ header.\n   Identification:  Set according to a Fragment Identification generator\n\
    \      at the translator.\n   Flags:  The More Fragments flag is set to zero.\
    \  The Don't Fragment\n      (DF) flag is set as follows: If the size of the translated\
    \ IPv4\n      packet is less than or equal to 1260 bytes, it is set to zero;\n\
    \      otherwise, it is set to one.\n   Fragment Offset:  All zeros.\n   Time\
    \ to Live:  Time to Live is derived from the Hop Limit value in\n      the IPv6\
    \ header.  Since the translator is a router, as part of\n      forwarding the\
    \ packet it needs to decrement either the IPv6 Hop\n      Limit (before the translation)\
    \ or the IPv4 TTL (after the\n      translation).  As part of decrementing the\
    \ TTL or Hop Limit, the\n      translator (as any router) MUST check for zero\
    \ and send the ICMPv4\n      \"TTL Exceeded\" or ICMPv6 \"Hop Limit Exceeded\"\
    \ error.\n   Protocol:  The IPv6-Frag (44) header is handled as discussed in\n\
    \      Section 5.1.1.  ICMPv6 (58) is changed to ICMPv4 (1), and the\n      payload\
    \ is translated as discussed in Section 5.2.  The IPv6\n      headers HOPOPT (0),\
    \ IPv6-Route (43), and IPv6-Opts (60) are\n      skipped over during processing\
    \ as they have no meaning in IPv4.\n      For the first 'next header' that does\
    \ not match one of the cases\n      above, its Next Header value (which contains\
    \ the transport\n      protocol number) is copied to the protocol field in the\
    \ IPv4\n      header.  This means that all transport protocols are translated.\n\
    \      Note:  Some translated protocols will fail at the receiver for\n      \
    \   various reasons: some are known to fail when translated (e.g.,\n         IPsec\
    \ Authentication Header (51)), and others will fail\n         checksum validation\
    \ if the address translation is not checksum\n         neutral [RFC6052] and the\
    \ translator does not update the\n         transport protocol's checksum (because\
    \ the translator doesn't\n         support recalculating the checksum for that\
    \ transport protocol;\n         see Section 5.5).\n   Header Checksum:  Computed\
    \ once the IPv4 header has been created.\n   Source Address:  Mapped to an IPv4\
    \ address based on the algorithms\n      presented in Section 6.\n      If the\
    \ translator gets an illegal source address (e.g., ::1,\n      etc.), the translator\
    \ SHOULD silently drop the packet.\n   Destination Address:  Mapped to an IPv4\
    \ address based on the\n      algorithms presented in Section 6.\n   If any of\
    \ an IPv6 Hop-by-Hop Options header, Destination Options\n   header, or Routing\
    \ header with the Segments Left field equal to zero\n   are present in the IPv6\
    \ packet, those IPv6 extension headers MUST be\n   ignored (i.e., there is no\
    \ attempt to translate the extension\n   headers) and the packet translated normally.\
    \  However, the Total\n   Length field and the Protocol field are adjusted to\
    \ \"skip\" these\n   extension headers.\n   If a Routing header with a non-zero\
    \ Segments Left field is present,\n   then the packet MUST NOT be translated,\
    \ and an ICMPv6 \"parameter\n   problem/erroneous header field encountered\" (Type\
    \ 4, Code 0) error\n   message, with the Pointer field indicating the first byte\
    \ of the\n   Segments Left field, SHOULD be returned to the sender.\n"
- title: 5.1.1.  IPv6 Fragment Processing
  contents:
  - "5.1.1.  IPv6 Fragment Processing\n   If the IPv6 packet contains a Fragment Header,\
    \ the header fields are\n   set as above with the following exceptions:\n   Total\
    \ Length:  If the Next Header field of the Fragment Header is an\n      extension\
    \ header (except ESP, but including the Authentication\n      Header (AH)), then\
    \ the packet SHOULD be dropped and logged.  For\n      other cases, the Total\
    \ Length MUST be set to Payload Length value\n      from IPv6 header, minus the\
    \ length of the extension headers up to\n      the Fragmentation Header, minus\
    \ 8 for the Fragment Header, plus\n      the size of the IPv4 header.\n   Identification:\
    \  Copied from the low-order 16 bits in the\n      Identification field in the\
    \ Fragment Header.\n   Flags:  The IPv4 More Fragments (MF) flag is copied from\
    \ the M flag\n      in the IPv6 Fragment Header.  The IPv4 Don't Fragment (DF)\
    \ flag is\n      cleared (set to zero), allowing this packet to be further\n \
    \     fragmented by IPv4 routers.\n   Fragment Offset:  If the Next Header field\
    \ of the Fragment Header is\n      not an extension header (except ESP), then\
    \ Fragment Offset MUST be\n      copied from the Fragment Offset field of the\
    \ IPv6 Fragment Header.\n      If the Next Header field of the Fragment Header\
    \ is an extension\n      header (except ESP), then the packet SHOULD be dropped\
    \ and logged.\n   Protocol:  For ICMPv6 (58), it is changed to ICMPv4 (1); otherwise,\n\
    \      extension headers are skipped, and the Next Header field is copied\n  \
    \    from the last IPv6 header.\n   If an IPv6 packet that is smaller than or\
    \ equal to 1280 bytes results\n   (after translation) in an IPv4 packet that is\
    \ larger than the MTU of\n   the next-hop interface, then the translator MUST\
    \ perform IPv4\n   fragmentation on that packet such that it can be transferred\
    \ over the\n   constricting link.\n"
- title: 5.2.  Translating ICMPv6 Headers into ICMPv4 Headers
  contents:
  - "5.2.  Translating ICMPv6 Headers into ICMPv4 Headers\n   If a non-checksum-neutral\
    \ translation address is being used, ICMPv6\n   messages MUST have their ICMPv4\
    \ checksum field be updated as part of\n   the translation since ICMPv6 (unlike\
    \ ICMPv4) includes a pseudo-header\n   in the checksum just like UDP and TCP.\n\
    \   In addition, all ICMP packets MUST have the Type translated and, for\n   ICMP\
    \ error messages, the included IP header MUST also be translated.\n   The actions\
    \ needed to translate various ICMPv6 messages are:\n   ICMPv6 informational messages:\n\
    \      Echo Request and Echo Reply  (Type 128 and 129): Adjust the Type\n    \
    \     values to 8 and 0, respectively, and adjust the ICMP checksum\n        \
    \ both to take the type change into account and to exclude the\n         ICMPv6\
    \ pseudo-header.\n      MLD Multicast Listener Query/Report/Done  (Type 130, 131,\
    \ 132):\n         Single-hop message.  Silently drop.\n      Neighbor Discover\
    \ messages  (Type 133 through 137): Single-hop\n         message.  Silently drop.\n\
    \      Unknown informational messages:  Silently drop.\n   ICMPv6 error messages:\n\
    \      Destination Unreachable (Type 1)  Set the Type to 3, and adjust\n     \
    \    the ICMP checksum both to take the type/code change into\n         account\
    \ and to exclude the ICMPv6 pseudo-header.\n         Translate the Code as follows:\n\
    \         Code 0 (No route to destination):  Set the Code to 1 (Host\n       \
    \     unreachable).\n         Code 1  (Communication with destination administratively\n\
    \            prohibited): Set the Code to 10 (Communication with\n           \
    \ destination host administratively prohibited).\n         Code 2 (Beyond scope\
    \ of source address):  Set the Code to 1\n            (Host unreachable).  Note\
    \ that this error is very unlikely\n            since an IPv4-translatable source\
    \ address is typically\n            considered to have global scope.\n       \
    \  Code 3 (Address unreachable):  Set the Code to 1 (Host\n            unreachable).\n\
    \         Code 4 (Port unreachable):  Set the Code to 3 (Port\n            unreachable).\n\
    \         Other Code values:  Silently drop.\n      Packet Too Big (Type 2): \
    \ Translate to an ICMPv4 Destination\n         Unreachable (Type 3) with Code\
    \ 4, and adjust the ICMPv4\n         checksum both to take the type change into\
    \ account and to\n         exclude the ICMPv6 pseudo-header.  The MTU field MUST\
    \ be\n         adjusted for the difference between the IPv4 and IPv6 header\n\
    \         sizes, taking into account whether or not the packet in error\n    \
    \     includes a Fragment Header, i.e., minimum((MTU value in the\n         Packet\
    \ Too Big Message)-20, MTU_of_IPv4_nexthop,\n         (MTU_of_IPv6_nexthop)-20).\n\
    \         See also the requirements in Section 7.\n      Time Exceeded (Type 3):\
    \  Set the Type to 11, and adjust the ICMPv4\n         checksum both to take the\
    \ type change into account and to\n         exclude the ICMPv6 pseudo-header.\
    \  The Code is unchanged.\n      Parameter Problem (Type 4):  Translate the Type\
    \ and Code as\n         follows, and adjust the ICMPv4 checksum both to take the\
    \ type/\n         code change into account and to exclude the ICMPv6 pseudo-\n\
    \         header.\n         Translate the Code as follows:\n         Code 0 (Erroneous\
    \ header field encountered):  Set to Type 12,\n            Code 0, and update\
    \ the pointer as defined in Figure 6.  (If\n            the Original IPv6 Pointer\
    \ Value is not listed or the\n            Translated IPv4 Pointer Value is listed\
    \ as \"n/a\", silently\n            drop the packet.)\n         Code 1 (Unrecognized\
    \ Next Header type encountered):  Translate\n            this to an ICMPv4 protocol\
    \ unreachable (Type 3, Code 2).\n         Code 2 (Unrecognized IPv6 option encountered):\
    \  Silently drop.\n      Unknown error messages:  Silently drop.\n    +--------------------------------+--------------------------------+\n\
    \    |   Original IPv6 Pointer Value  | Translated IPv4 Pointer Value  |\n   \
    \ +--------------------------------+--------------------------------+\n    | \
    \ 0  | Version/Traffic Class    |  0  | Version/IHL, Type Of Ser |\n    |  1 \
    \ | Traffic Class/Flow Label |  1  | Type Of Service          |\n    | 2,3 | Flow\
    \ Label               | n/a |                          |\n    | 4,5 | Payload\
    \ Length           |  2  | Total Length             |\n    |  6  | Next Header\
    \              |  9  | Protocol                 |\n    |  7  | Hop Limit     \
    \           |  8  | Time to Live             |\n    | 8-23| Source Address   \
    \        | 12  | Source Address           |\n    |24-39| Destination Address \
    \     | 16  | Destination Address      |\n    +--------------------------------+--------------------------------+\n\
    \         Figure 6: Pointer Value for Translating from IPv6 to IPv4\n      ICMP\
    \ Error Payload:  If the received ICMPv6 packet contains an\n         ICMPv6 Extension\
    \ [RFC4884], the translation of the ICMPv6\n         packet will cause the ICMPv4\
    \ packet to change length.  When\n         this occurs, the ICMPv6 Extension length\
    \ attribute MUST be\n         adjusted accordingly (e.g., shorter due to the translation\
    \ from\n         IPv6 to IPv4).  For extensions not defined in [RFC4884], the\n\
    \         translator passes the extensions as opaque bit strings and any\n   \
    \      IPv6 address literals contained therein will not be translated\n      \
    \   to IPv4 address literals; this may cause problems with\n         processing\
    \ of those ICMP extensions.\n"
- title: 5.3.  Translating ICMPv6 Error Messages into ICMPv4
  contents:
  - "5.3.  Translating ICMPv6 Error Messages into ICMPv4\n   There are some differences\
    \ between the ICMPv4 and the ICMPv6 error\n   message formats as detailed above.\
    \  The ICMP error messages\n   containing the packet in error MUST be translated\
    \ just like a normal\n   IP packet (except that the TTL/Hop Limit value of the\
    \ inner IPv4/IPv6\n   packet are not decremented).  The translation of this \"\
    packet in\n   error\" is likely to change the length of the datagram; thus, the\n\
    \   Total Length field in the outer IPv4 header MUST be updated.\n           \
    \   +-------------+                 +-------------+\n              |    IPv6 \
    \    |                 |    IPv4     |\n              |   Header    |        \
    \         |   Header    |\n              +-------------+                 +-------------+\n\
    \              |   ICMPv6    |                 |   ICMPv4    |\n             \
    \ |   Header    |                 |   Header    |\n              +-------------+\
    \                 +-------------+\n              |    IPv6     |      ===>   \
    \    |    IPv4     |\n              |   Header    |                 |   Header\
    \    |\n              +-------------+                 +-------------+\n      \
    \        |   Partial   |                 |   Partial   |\n              |  Transport-\
    \ |                 |  Transport- |\n              |   Layer     |           \
    \      |   Layer     |\n              |   Header    |                 |   Header\
    \    |\n              +-------------+                 +-------------+\n      \
    \         Figure 7: IPv6-to-IPv4 ICMP Error Translation\n   The translation of\
    \ the inner IP header can be done by invoking the\n   function that translated\
    \ the outer IP headers.  This process MUST\n   stop at the first embedded header\
    \ and drop the packet if it contains\n   more embedded headers.\n"
- title: 5.4.  Generation of ICMPv6 Error Messages
  contents:
  - "5.4.  Generation of ICMPv6 Error Messages\n   If the IPv6 packet is discarded,\
    \ then the translator SHOULD send back\n   an ICMPv6 error message to the original\
    \ sender of the packet, unless\n   the discarded packet is itself an ICMPv6 message.\n\
    \   The ICMPv6 message MUST have Type 1 (Destination Unreachable) and\n   Code\
    \ 1 (Communication with destination administratively prohibited),\n   unless otherwise\
    \ specified in this document or [RFC6146].  The\n   translator SHOULD allow an\
    \ administrator to configure whether the\n   ICMPv6 error messages are sent, rate-limited,\
    \ or not sent.\n"
- title: 5.5.  Transport-Layer Header Translation
  contents:
  - "5.5.  Transport-Layer Header Translation\n   If the address translation algorithm\
    \ is not checksum neutral (see\n   Section 4.1 of [RFC6052]), the recalculation\
    \ and updating of the\n   transport-layer headers that contain pseudo-headers\
    \ need to be\n   performed.  Translators MUST do this for TCP, UDP, and ICMP.\n\
    \   Other transport protocols (e.g., DCCP) are OPTIONAL to support.  In\n   order\
    \ to ease debugging and troubleshooting, translators MUST forward\n   all transport\
    \ protocols as described in the \"Protocol\" step of\n   Section 5.1.\n"
- title: 5.6.  Knowing When to Translate
  contents:
  - "5.6.  Knowing When to Translate\n   If the IP/ICMP translator also provides a\
    \ normal forwarding function,\n   and the destination address is reachable by\
    \ a more specific route\n   without translation, the router MUST forward it without\
    \ translating\n   it.  When an IP/ICMP translator receives an IPv6 datagram addressed\n\
    \   to an IPv6 address representing a host in the IPv4 domain, the IPv6\n   packet\
    \ MUST be translated to IPv4.\n"
- title: 6.  Mapping of IP Addresses
  contents:
  - "6.  Mapping of IP Addresses\n   The translator MUST support the stateless address\
    \ mapping algorithm\n   defined in [RFC6052], which is the default behavior. \
    \ A workflow\n   example is shown in Appendix A of this document.  Note that [RFC7136]\n\
    \   updates [RFC4291], which allows the use of unicast addresses without\n   u-bit,\
    \ as long as they're not derived from an IEEE MAC-layer address.\n   Therefore,\
    \ the address mapping algorithm defined in [RFC6219] also\n   complies with the\
    \ IPv6 address architecture.\n   The stateless translator SHOULD support the explicit\
    \ address mapping\n   algorithm defined in [RFC7757].\n   The stateless translator\
    \ SHOULD support [RFC6791] for handling ICMP/\n   ICMPv6 packets.\n   Implementations\
    \ may support both stateless and stateful translation\n   modes (e.g., Network\
    \ Address and Protocol Translation from IPv6\n   Clients to IPv4 Servers (NAT64)\
    \ [RFC6146]).\n   Implementations may support stateless NAT64 function, e.g.,\
    \ MAP-T\n   Customer Edge (CE) or MAP-T Border Relay (BR) [RFC7599].\n"
- title: 7.  Special Considerations for ICMPv6 Packet Too Big
  contents:
  - "7.  Special Considerations for ICMPv6 Packet Too Big\n   A number of studies\
    \ [ATOMIC] indicate that it not unusual for\n   networks to drop ICMPv6 Packet\
    \ Too Big error messages.  Such packet\n   drops will result in PMTUD black holes\
    \ [RFC2923], which can only be\n   overcome with Packetization Layer Path MTU\
    \ Discovery (PLPMTUD)\n   [RFC4821].\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   The use of stateless IP/ICMP translators does\
    \ not introduce any new\n   security issues beyond the security issues that are\
    \ already present\n   in the IPv4 and IPv6 protocols and in the routing protocols\
    \ that are\n   used to make the packets reach the translator.\n   There are potential\
    \ issues that might arise by deriving an IPv4\n   address from an IPv6 address\
    \ -- particularly addresses like broadcast\n   or loopback addresses and the non-IPv4-translatable\
    \ IPv6 addresses,\n   etc.  [RFC6052] addresses these issues.\n   The IPsec Authentication\
    \ Header [RFC4302] cannot be used for NAT44 or\n   NAT64.\n   As with the network\
    \ address translation of IPv4 to IPv4, packets with\n   tunnel mode Encapsulating\
    \ Security Payload (ESP) can be translated\n   since tunnel mode ESP does not\
    \ depend on header fields prior to the\n   ESP header.  Similarly, transport mode\
    \ ESP will fail with IPv6-to-\n   IPv4 translation unless checksum-neutral addresses\
    \ are used.  In both\n   cases, the IPsec ESP endpoints will normally detect the\
    \ presence of\n   the translator and encapsulate ESP in UDP packets [RFC3948].\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC768]   Postel, J., \"User Datagram Protocol\"\
    , STD 6, RFC 768,\n              DOI 10.17487/RFC0768, August 1980,\n        \
    \      <http://www.rfc-editor.org/info/rfc768>.\n   [RFC791]   Postel, J., \"\
    Internet Protocol\", STD 5, RFC 791,\n              DOI 10.17487/RFC0791, September\
    \ 1981,\n              <http://www.rfc-editor.org/info/rfc791>.\n   [RFC793] \
    \  Postel, J., \"Transmission Control Protocol\", STD 7,\n              RFC 793,\
    \ DOI 10.17487/RFC0793, September 1981,\n              <http://www.rfc-editor.org/info/rfc793>.\n\
    \   [RFC1812]  Baker, F., Ed., \"Requirements for IP Version 4 Routers\",\n  \
    \            RFC 1812, DOI 10.17487/RFC1812, June 1995,\n              <http://www.rfc-editor.org/info/rfc1812>.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC3948]\
    \  Huttunen, A., Swander, B., Volpe, V., DiBurro, L., and M.\n              Stenberg,\
    \ \"UDP Encapsulation of IPsec ESP Packets\",\n              RFC 3948, DOI 10.17487/RFC3948,\
    \ January 2005,\n              <http://www.rfc-editor.org/info/rfc3948>.\n   [RFC4291]\
    \  Hinden, R. and S. Deering, \"IP Version 6 Addressing\n              Architecture\"\
    , RFC 4291, DOI 10.17487/RFC4291, February\n              2006, <http://www.rfc-editor.org/info/rfc4291>.\n\
    \   [RFC4340]  Kohler, E., Handley, M., and S. Floyd, \"Datagram\n           \
    \   Congestion Control Protocol (DCCP)\", RFC 4340,\n              DOI 10.17487/RFC4340,\
    \ March 2006,\n              <http://www.rfc-editor.org/info/rfc4340>.\n   [RFC4443]\
    \  Conta, A., Deering, S., and M. Gupta, Ed., \"Internet\n              Control\
    \ Message Protocol (ICMPv6) for the Internet\n              Protocol Version 6\
    \ (IPv6) Specification\", RFC 4443,\n              DOI 10.17487/RFC4443, March\
    \ 2006,\n              <http://www.rfc-editor.org/info/rfc4443>.\n   [RFC4884]\
    \  Bonica, R., Gan, D., Tappan, D., and C. Pignataro,\n              \"Extended\
    \ ICMP to Support Multi-Part Messages\", RFC 4884,\n              DOI 10.17487/RFC4884,\
    \ April 2007,\n              <http://www.rfc-editor.org/info/rfc4884>.\n   [RFC5382]\
    \  Guha, S., Ed., Biswas, K., Ford, B., Sivakumar, S., and P.\n              Srisuresh,\
    \ \"NAT Behavioral Requirements for TCP\", BCP 142,\n              RFC 5382, DOI\
    \ 10.17487/RFC5382, October 2008,\n              <http://www.rfc-editor.org/info/rfc5382>.\n\
    \   [RFC5771]  Cotton, M., Vegoda, L., and D. Meyer, \"IANA Guidelines for\n \
    \             IPv4 Multicast Address Assignments\", BCP 51, RFC 5771,\n      \
    \        DOI 10.17487/RFC5771, March 2010,\n              <http://www.rfc-editor.org/info/rfc5771>.\n\
    \   [RFC6052]  Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X.\n    \
    \          Li, \"IPv6 Addressing of IPv4/IPv6 Translators\", RFC 6052,\n     \
    \         DOI 10.17487/RFC6052, October 2010,\n              <http://www.rfc-editor.org/info/rfc6052>.\n\
    \   [RFC6145]  Li, X., Bao, C., and F. Baker, \"IP/ICMP Translation\n        \
    \      Algorithm\", RFC 6145, DOI 10.17487/RFC6145, April 2011,\n            \
    \  <http://www.rfc-editor.org/info/rfc6145>.\n   [RFC6146]  Bagnulo, M., Matthews,\
    \ P., and I. van Beijnum, \"Stateful\n              NAT64: Network Address and\
    \ Protocol Translation from IPv6\n              Clients to IPv4 Servers\", RFC\
    \ 6146, DOI 10.17487/RFC6146,\n              April 2011, <http://www.rfc-editor.org/info/rfc6146>.\n\
    \   [RFC6791]  Li, X., Bao, C., Wing, D., Vaithianathan, R., and G.\n        \
    \      Huston, \"Stateless Source Address Mapping for ICMPv6\n              Packets\"\
    , RFC 6791, DOI 10.17487/RFC6791, November 2012,\n              <http://www.rfc-editor.org/info/rfc6791>.\n\
    \   [RFC7757]  Anderson, T. and A. Leiva Popper, \"Explicit Address\n        \
    \      Mappings for Stateless IP/ICMP Translation\", RFC 7757,\n             \
    \ DOI 10.17487/RFC7757, February 2016,\n              <http://www.rfc-editor.org/info/rfc7757>.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [ATOMIC]   Gont, F., LIU, S., and T. Anderson,\
    \ \"Generation of IPv6\n              Atomic Fragments Considered Harmful\", Work\
    \ in Progress,\n              draft-ietf-6man-deprecate-atomfrag-generation-06,\
    \ April\n              2016.\n   [Err3059]  RFC Errata, Erratum ID 3059, RFC 6145.\n\
    \   [Err3060]  RFC Errata, Erratum ID 3060, RFC 6145.\n   [Err3061]  RFC Errata,\
    \ Erratum ID 3061, RFC 6145.\n   [Err4090]  RFC Errata, Erratum ID 4090, RFC 6145.\n\
    \   [IPv6]     Deering, S. and R. Hinden, \"Internet Protocol, Version 6\n   \
    \           (IPv6) Specification\", Work in Progress, draft-ietf-6man-\n     \
    \         rfc2460bis-04, March 2016.\n   [RFC1191]  Mogul, J. and S. Deering,\
    \ \"Path MTU discovery\", RFC 1191,\n              DOI 10.17487/RFC1191, November\
    \ 1990,\n              <http://www.rfc-editor.org/info/rfc1191>.\n   [RFC2474]\
    \  Nichols, K., Blake, S., Baker, F., and D. Black,\n              \"Definition\
    \ of the Differentiated Services Field (DS\n              Field) in the IPv4 and\
    \ IPv6 Headers\", RFC 2474,\n              DOI 10.17487/RFC2474, December 1998,\n\
    \              <http://www.rfc-editor.org/info/rfc2474>.\n   [RFC2475]  Blake,\
    \ S., Black, D., Carlson, M., Davies, E., Wang, Z.,\n              and W. Weiss,\
    \ \"An Architecture for Differentiated\n              Services\", RFC 2475, DOI\
    \ 10.17487/RFC2475, December 1998,\n              <http://www.rfc-editor.org/info/rfc2475>.\n\
    \   [RFC2710]  Deering, S., Fenner, W., and B. Haberman, \"Multicast\n       \
    \       Listener Discovery (MLD) for IPv6\", RFC 2710,\n              DOI 10.17487/RFC2710,\
    \ October 1999,\n              <http://www.rfc-editor.org/info/rfc2710>.\n   [RFC2923]\
    \  Lahey, K., \"TCP Problems with Path MTU Discovery\",\n              RFC 2923,\
    \ DOI 10.17487/RFC2923, September 2000,\n              <http://www.rfc-editor.org/info/rfc2923>.\n\
    \   [RFC3307]  Haberman, B., \"Allocation Guidelines for IPv6 Multicast\n    \
    \          Addresses\", RFC 3307, DOI 10.17487/RFC3307, August 2002,\n       \
    \       <http://www.rfc-editor.org/info/rfc3307>.\n   [RFC3590]  Haberman, B.,\
    \ \"Source Address Selection for the Multicast\n              Listener Discovery\
    \ (MLD) Protocol\", RFC 3590,\n              DOI 10.17487/RFC3590, September 2003,\n\
    \              <http://www.rfc-editor.org/info/rfc3590>.\n   [RFC3810]  Vida,\
    \ R., Ed. and L. Costa, Ed., \"Multicast Listener\n              Discovery Version\
    \ 2 (MLDv2) for IPv6\", RFC 3810,\n              DOI 10.17487/RFC3810, June 2004,\n\
    \              <http://www.rfc-editor.org/info/rfc3810>.\n   [RFC3849]  Huston,\
    \ G., Lord, A., and P. Smith, \"IPv6 Address Prefix\n              Reserved for\
    \ Documentation\", RFC 3849,\n              DOI 10.17487/RFC3849, July 2004,\n\
    \              <http://www.rfc-editor.org/info/rfc3849>.\n   [RFC4302]  Kent,\
    \ S., \"IP Authentication Header\", RFC 4302,\n              DOI 10.17487/RFC4302,\
    \ December 2005,\n              <http://www.rfc-editor.org/info/rfc4302>.\n  \
    \ [RFC4787]  Audet, F., Ed. and C. Jennings, \"Network Address\n             \
    \ Translation (NAT) Behavioral Requirements for Unicast\n              UDP\",\
    \ BCP 127, RFC 4787, DOI 10.17487/RFC4787, January\n              2007, <http://www.rfc-editor.org/info/rfc4787>.\n\
    \   [RFC4821]  Mathis, M. and J. Heffner, \"Packetization Layer Path MTU\n   \
    \           Discovery\", RFC 4821, DOI 10.17487/RFC4821, March 2007,\n       \
    \       <http://www.rfc-editor.org/info/rfc4821>.\n   [RFC5737]  Arkko, J., Cotton,\
    \ M., and L. Vegoda, \"IPv4 Address Blocks\n              Reserved for Documentation\"\
    , RFC 5737,\n              DOI 10.17487/RFC5737, January 2010,\n             \
    \ <http://www.rfc-editor.org/info/rfc5737>.\n   [RFC6144]  Baker, F., Li, X.,\
    \ Bao, C., and K. Yin, \"Framework for\n              IPv4/IPv6 Translation\"\
    , RFC 6144, DOI 10.17487/RFC6144,\n              April 2011, <http://www.rfc-editor.org/info/rfc6144>.\n\
    \   [RFC6219]  Li, X., Bao, C., Chen, M., Zhang, H., and J. Wu, \"The\n      \
    \        China Education and Research Network (CERNET) IVI\n              Translation\
    \ Design and Deployment for the IPv4/IPv6\n              Coexistence and Transition\"\
    , RFC 6219,\n              DOI 10.17487/RFC6219, May 2011,\n              <http://www.rfc-editor.org/info/rfc6219>.\n\
    \   [RFC6691]  Borman, D., \"TCP Options and Maximum Segment Size (MSS)\",\n \
    \             RFC 6691, DOI 10.17487/RFC6691, July 2012,\n              <http://www.rfc-editor.org/info/rfc6691>.\n\
    \   [RFC7136]  Carpenter, B. and S. Jiang, \"Significance of IPv6\n          \
    \    Interface Identifiers\", RFC 7136, DOI 10.17487/RFC7136,\n              February\
    \ 2014, <http://www.rfc-editor.org/info/rfc7136>.\n   [RFC7599]  Li, X., Bao,\
    \ C., Dec, W., Ed., Troan, O., Matsushima, S.,\n              and T. Murakami,\
    \ \"Mapping of Address and Port using\n              Translation (MAP-T)\", RFC\
    \ 7599, DOI 10.17487/RFC7599, July\n              2015, <http://www.rfc-editor.org/info/rfc7599>.\n"
- title: Appendix A.  Stateless Translation Workflow Example
  contents:
  - "Appendix A.  Stateless Translation Workflow Example\n   A stateless translation\
    \ workflow example is depicted in the following\n   figure.  The documentation\
    \ address blocks 2001:db8::/32 [RFC3849],\n   192.0.2.0/24, and 198.51.100.0/24\
    \ [RFC5737] are used in this example.\n            +--------------+          \
    \         +--------------+\n            | IPv4 network |                   | IPv6\
    \ network |\n            |              |     +-------+     |              |\n\
    \            |   +----+     |-----| XLAT  |---- |  +----+      |\n           \
    \ |   | H4 |-----|     +-------+     |--| H6 |      |\n            |   +----+\
    \     |                   |  +----+      |\n            +--------------+     \
    \              +--------------+\n                 Figure 8: Stateless Translation\
    \ Workflow\n   A translator (XLAT) connects the IPv6 network to the IPv4 network.\n\
    \   This XLAT uses the Network-Specific Prefix (NSP) 2001:db8:100::/40\n   defined\
    \ in [RFC6052] to represent IPv4 addresses in the IPv6 address\n   space (IPv4-converted\
    \ addresses) and to represent IPv6 addresses\n   (IPv4-translatable addresses)\
    \ in the IPv4 address space.  In this\n   example, 192.0.2.0/24 is the IPv4 block\
    \ of the corresponding\n   IPv4-translatable addresses.\n   Based on the address\
    \ mapping rule, the IPv6 node H6 has an\n   IPv4-translatable IPv6 address 2001:db8:1c0:2:21::\
    \ (address mapping\n   from 192.0.2.33).  The IPv4 node H4 has IPv4 address 198.51.100.2.\n\
    \   The IPv6 routing is configured in such a way that the IPv6 packets\n   addressed\
    \ to a destination address in 2001:db8:100::/40 are routed to\n   the IPv6 interface\
    \ of the XLAT.\n   The IPv4 routing is configured in such a way that the IPv4\
    \ packets\n   addressed to a destination address in 192.0.2.0/24 are routed to\
    \ the\n   IPv4 interface of the XLAT.\n"
- title: A.1.  H6 Establishes Communication with H4
  contents:
  - "A.1.  H6 Establishes Communication with H4\n   The steps by which H6 establishes\
    \ communication with H4 are:\n   1.  H6 performs the destination address mapping,\
    \ so the\n       IPv4-converted address 2001:db8:1c6:3364:2:: is formed from\n\
    \       198.51.100.2 based on the address mapping algorithm [RFC6052].\n   2.\
    \  H6 sends a packet to H4.  The packet is sent from a source\n       address\
    \ 2001:db8:1c0:2:21:: to a destination address\n       2001:db8:1c6:3364:2::.\n\
    \   3.  The packet is routed to the IPv6 interface of the XLAT (since\n      \
    \ IPv6 routing is configured that way).\n   4.  The XLAT receives the packet and\
    \ performs the following actions:\n       *  The XLAT translates the IPv6 header\
    \ into an IPv4 header using\n          the IP/ICMP Translation Algorithm defined\
    \ in this document.\n       *  The XLAT includes 192.0.2.33 as the source address\
    \ in the\n          packet and 198.51.100.2 as the destination address in the\n\
    \          packet.  Note that 192.0.2.33 and 198.51.100.2 are extracted\n    \
    \      directly from the source IPv6 address 2001:db8:1c0:2:21::\n          (IPv4-translatable\
    \ address) and destination IPv6 address\n          2001:db8:1c6:3364:2:: (IPv4-converted\
    \ address) of the received\n          IPv6 packet that is being translated.\n\
    \   5.  The XLAT sends the translated packet out of its IPv4 interface,\n    \
    \   and the packet arrives at H4.\n   6.  H4 node responds by sending a packet\
    \ with destination address\n       192.0.2.33 and source address 198.51.100.2.\n\
    \   7.  The packet is routed to the IPv4 interface of the XLAT (since\n      \
    \ IPv4 routing is configured that way).  The XLAT performs the\n       following\
    \ operations:\n       *  The XLAT translates the IPv4 header into an IPv6 header\
    \ using\n          the IP/ICMP Translation Algorithm defined in this document.\n\
    \       *  The XLAT includes 2001:db8:1c0:2:21:: as the destination\n        \
    \  address in the packet and 2001:db8:1c6:3364:2:: as the source\n          address\
    \ in the packet.  Note that 2001:db8:1c0:2:21:: and\n          2001:db8:1c6:3364:2::\
    \ are formed directly from the destination\n          IPv4 address 192.0.2.33\
    \ and the source IPv4 address\n          198.51.100.2 of the received IPv4 packet\
    \ that is being\n          translated.\n   8.  The translated packet is sent out\
    \ of the IPv6 interface to H6.\n   The packet exchange between H6 and H4 continues\
    \ until the session is\n   finished.\n"
- title: A.2.  H4 Establishes Communication with H6
  contents:
  - "A.2.  H4 Establishes Communication with H6\n   The steps by which H4 establishes\
    \ communication with H6 are:\n   1.  H4 performs the destination address mapping,\
    \ so 192.0.2.33 is\n       formed from the IPv4-translatable address 2001:db8:1c0:2:21::\n\
    \       based on the address mapping algorithm [RFC6052].\n   2.  H4 sends a packet\
    \ to H6.  The packet is sent from a source\n       address 198.51.100.2 to a destination\
    \ address 192.0.2.33.\n   3.  The packet is routed to the IPv4 interface of the\
    \ XLAT (since\n       IPv4 routing is configured that way).\n   4.  The XLAT receives\
    \ the packet and performs the following actions:\n       *  The XLAT translates\
    \ the IPv4 header into an IPv6 header using\n          the IP/ICMP Translation\
    \ Algorithm defined in this document.\n       *  The XLAT includes 2001:db8:1c6:3364:2::\
    \ as the source address\n          in the packet and 2001:db8:1c0:2:21:: as the\
    \ destination\n          address in the packet.  Note that 2001:db8:1c6:3364:2::\n\
    \          (IPv4-converted address) and 2001:db8:1c0:2:21::\n          (IPv4-translatable\
    \ address) are obtained directly from the\n          source IPv4 address 198.51.100.2\
    \ and destination IPv4 address\n          192.0.2.33 of the received IPv4 packet\
    \ that is being\n          translated.\n   5.  The XLAT sends the translated packet\
    \ out its IPv6 interface, and\n       the packet arrives at H6.\n   6.  H6 node\
    \ responds by sending a packet with destination address\n       2001:db8:1c6:3364:2::\
    \ and source address 2001:db8:1c0:2:21::.\n   7.  The packet is routed to the\
    \ IPv6 interface of the XLAT (since\n       IPv6 routing is configured that way).\
    \  The XLAT performs the\n       following operations:\n       *  The XLAT translates\
    \ the IPv6 header into an IPv4 header using\n          the IP/ICMP Translation\
    \ Algorithm defined in this document.\n       *  The XLAT includes 198.51.100.2\
    \ as the destination address in\n          the packet and 192.0.2.33 as the source\
    \ address in the packet.\n          Note that 198.51.100.2 and 192.0.2.33 are\
    \ formed directly from\n          the destination IPv6 address 2001:db8:1c6:3364:2::\
    \ and source\n          IPv6 address 2001:db8:1c0:2:21:: of the received IPv6\
    \ packet\n          that is being translated.\n   8.  The translated packet is\
    \ sent out the IPv4 interface to H4.\n   The packet exchange between H4 and H6\
    \ continues until the session is\n   finished.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Gandhar Gokhale, Wesley Eddy, and Fernando Gont submitted\
    \ and handled\n   the errata reports on [RFC6145].  Fernando Gont, Will (Shucheng)\
    \ Liu,\n   and Tore Anderson provided the security analysis and the suggestions\n\
    \   for updates concerning atomic fragments.  In addition, Tore Anderson\n   and\
    \ Alberto Leiva provided the proposal of the Explicit Address\n   Mapping (EAM)\
    \ algorithm.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Congxiao Bao\n   CERNET Center/Tsinghua University\n \
    \  Room 225, Main Building, Tsinghua University\n   Beijing  100084\n   China\n\
    \   Phone: +86 10-62785983\n   Email: congxiao@cernet.edu.cn\n   Xing Li\n   CERNET\
    \ Center/Tsinghua University\n   Room 225, Main Building, Tsinghua University\n\
    \   Beijing  100084\n   China\n   Phone: +86 10-62785983\n   Email: xing@cernet.edu.cn\n\
    \   Fred Baker\n   Cisco Systems\n   Santa Barbara, California  93117\n   United\
    \ States\n   Phone: +1-408-526-4257\n   Email: fred@cisco.com\n   Tore Anderson\n\
    \   Redpill Linpro\n   Vitaminveien 1A\n   0485 Oslo\n   Norway\n   Phone: +47\
    \ 959 31 212\n   Email: tore@redpill-linpro.com\n   URI:   http://www.redpill-linpro.com\n\
    \   Fernando Gont\n   Huawei Technologies\n   Evaristo Carriego 2644\n   Haedo,\
    \ Provincia de Buenos Aires  1706\n   Argentina\n   Phone: +54 11 4650 8472\n\
    \   Email: fgont@si6networks.com\n   URI:   http://www.si6networks.com\n"
