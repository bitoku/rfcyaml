- title: __initial_text__
  contents:
  - '              US Secure Hash Algorithms (SHA and HMAC-SHA)

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   The United States of America has adopted a suite of Secure Hash\n\
    \   Algorithms (SHAs), including four beyond SHA-1, as part of a Federal\n   Information\
    \ Processing Standard (FIPS), specifically SHA-224 (RFC\n   3874), SHA-256, SHA-384,\
    \ and SHA-512.  The purpose of this document\n   is to make source code performing\
    \ these hash functions conveniently\n   available to the Internet community. \
    \ The sample code supports input\n   strings of arbitrary bit length.  SHA-1's\
    \ sample code from RFC 3174\n   has also been updated to handle input strings\
    \ of arbitrary bit\n   length.  Most of the text herein was adapted by the authors\
    \ from FIPS\n   180-2.\n   Code to perform SHA-based HMACs, with arbitrary bit\
    \ length text, is\n   also included.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Overview of Contents ............................................3\n\
    \      1.1. License ....................................................4\n  \
    \ 2. Notation for Bit Strings and Integers ...........................4\n   3.\
    \ Operations on Words .............................................5\n   4. Message\
    \ Padding and Parsing .....................................6\n      4.1. SHA-224\
    \ and SHA-256 ........................................7\n      4.2. SHA-384 and\
    \ SHA-512 ........................................8\n   5. Functions and Constants\
    \ Used ....................................9\n      5.1. SHA-224 and SHA-256 ........................................9\n\
    \      5.2. SHA-384 and SHA-512 .......................................10\n  \
    \ 6. Computing the Message Digest ...................................11\n    \
    \  6.1. SHA-224 and SHA-256 Initialization ........................11\n      6.2.\
    \ SHA-224 and SHA-256 Processing ............................11\n      6.3. SHA-384\
    \ and SHA-512 Initialization ........................13\n      6.4. SHA-384 and\
    \ SHA-512 Processing ............................14\n   7. SHA-Based HMACs ................................................15\n\
    \   8. C Code for SHAs ................................................15\n  \
    \    8.1. The .h File ...............................................18\n    \
    \  8.2. The SHA Code ..............................................24\n      \
    \     8.2.1. sha1.c .............................................24\n        \
    \   8.2.2. sha224-256.c .......................................33\n          \
    \ 8.2.3. sha384-512.c .......................................45\n           8.2.4.\
    \ usha.c .............................................67\n           8.2.5. sha-private.h\
    \ ......................................72\n      8.3. The HMAC Code .............................................73\n\
    \      8.4. The Test Driver ...........................................78\n  \
    \ 9. Security Considerations .......................................106\n   10.\
    \ Normative References .........................................106\n   11. Informative\
    \ References .......................................106\n"
- title: 1.  Overview of Contents
  contents:
  - "1.  Overview of Contents\n   NOTE: Much of the text below is taken from [FIPS180-2]\
    \ and assertions\n   therein of the security of the algorithms described are made\
    \ by the\n   US Government, the author of [FIPS180-2], and not by the authors\
    \ of\n   this document.\n   The text below specifies Secure Hash Algorithms, SHA-224\
    \ [RFC3874],\n   SHA-256, SHA-384, and SHA-512, for computing a condensed\n  \
    \ representation of a message or a data file. (SHA-1 is specified in\n   [RFC3174].)\
    \  When a message of any length < 2^64 bits (for SHA-224\n   and SHA-256) or <\
    \ 2^128 bits (for SHA-384 and SHA-512) is input to\n   one of these algorithms,\
    \ the result is an output called a message\n   digest.  The message digests range\
    \ in length from 224 to 512 bits,\n   depending on the algorithm.  Secure hash\
    \ algorithms are typically\n   used with other cryptographic algorithms, such\
    \ as digital signature\n   algorithms and keyed hash authentication codes, or\
    \ in the generation\n   of random numbers [RFC4086].\n   The four algorithms specified\
    \ in this document are called secure\n   because it is computationally infeasible\
    \ to (1) find a message that\n   corresponds to a given message digest, or (2)\
    \ find two different\n   messages that produce the same message digest.  Any change\
    \ to a\n   message in transit will, with very high probability, result in a\n\
    \   different message digest.  This will result in a verification failure\n  \
    \ when the secure hash algorithm is used with a digital signature\n   algorithm\
    \ or a keyed-hash message authentication algorithm.\n   The code provided herein\
    \ supports input strings of arbitrary bit\n   length.  SHA-1's sample code from\
    \ [RFC3174] has also been updated to\n   handle input strings of arbitrary bit\
    \ length.  See Section 1.1 for\n   license information for this code.\n   Section\
    \ 2 below defines the terminology and functions used as\n   building blocks to\
    \ form these algorithms.  Section 3 describes the\n   fundamental operations on\
    \ words from which these algorithms are\n   built.  Section 4 describes how messages\
    \ are padded up to an integral\n   multiple of the required block size and then\
    \ parsed into blocks.\n   Section 5 defines the constants and the composite functions\
    \ used to\n   specify these algorithms.  Section 6 gives the actual specification\n\
    \   for the SHA-224, SHA-256, SHA-384, and SHA-512 functions.  Section 7\n   provides\
    \ pointers to the specification of HMAC keyed message\n   authentication codes\
    \ based on the SHA algorithms.  Section 8 gives\n   sample code for the SHA algorithms\
    \ and Section 9 code for SHA-based\n   HMACs.  The SHA-based HMACs will accept\
    \ arbitrary bit length text.\n"
- title: 1.1.  License
  contents:
  - "1.1.  License\n   Permission is granted for all uses, commercial and non-commercial,\
    \ of\n   the sample code found in Section 8.  Royalty free license to use,\n \
    \  copy, modify and distribute the software found in Section 8 is\n   granted,\
    \ provided that this document is identified in all material\n   mentioning or\
    \ referencing this software, and provided that\n   redistributed derivative works\
    \ do not contain misleading author or\n   version information.\n   The authors\
    \ make no representations concerning either the\n   merchantability of this software\
    \ or the suitability of this software\n   for any particular purpose.  It is provided\
    \ \"as is\" without express\n   or implied warranty of any kind.\n"
- title: 2.  Notation for Bit Strings and Integers
  contents:
  - "2.  Notation for Bit Strings and Integers\n   The following terminology related\
    \ to bit strings and integers will be\n   used:\n    a.  A hex digit is an element\
    \ of the set {0, 1, ... , 9, A, ... ,\n        F}.  A hex digit is the representation\
    \ of a 4-bit string.\n        Examples: 7 = 0111, A = 1010.\n    b.  A word equals\
    \ a 32-bit or 64-bit string, which may be\n        represented as a sequence of\
    \ 8 or 16 hex digits, respectively.\n        To convert a word to hex digits,\
    \ each 4-bit string is converted\n        to its hex equivalent as described in\
    \ (a) above.  Example:\n        1010 0001 0000 0011 1111 1110 0010 0011 = A103FE23.\n\
    \        Throughout this document, the \"big-endian\" convention is used\n   \
    \     when expressing both 32-bit and 64-bit words, so that within\n        each\
    \ word the most significant bit is shown in the left-most bit\n        position.\n\
    \    c.  An integer may be represented as a word or pair of words.\n        An\
    \ integer between 0 and 2^32 - 1 inclusive may be represented\n        as a 32-bit\
    \ word.  The least significant four bits of the\n        integer are represented\
    \ by the right-most hex digit of the word\n        representation.  Example: the\
    \ integer 291 = 2^8+2^5+2^1+2^0 =\n        256+32+2+1 is represented by the hex\
    \ word 00000123.\n        The same holds true for an integer between 0 and 2^64-1\n\
    \        inclusive, which may be represented as a 64-bit word.\n        If Z is\
    \ an integer, 0 <= z < 2^64, then z = (2^32)x + y where 0\n        <= x < 2^32\
    \ and 0 <= y < 2^32.  Since x and y can be represented\n        as words X and\
    \ Y, respectively, z can be represented as the pair\n        of words (X,Y).\n\
    \    d.  block = 512-bit or 1024-bit string.  A block (e.g., B) may be\n     \
    \   represented as a sequence of 32-bit or 64-bit words.\n"
- title: 3.  Operations on Words
  contents:
  - "3.  Operations on Words\n   The following logical operators will be applied to\
    \ words in all four\n   hash operations specified herein.  SHA-224 and SHA-256\
    \ operate on\n   32-bit words, while SHA-384 and SHA-512 operate on 64-bit words.\n\
    \   In the operations below, x<<n is obtained as follows: discard the\n   left-most\
    \ n bits of x and then pad the result with n zeroed bits on\n   the right (the\
    \ result will still be the same number of bits).\n    a.  Bitwise logical word\
    \ operations\n        X AND Y  =  bitwise logical \"and\" of  X and Y.\n     \
    \   X OR Y   =  bitwise logical \"inclusive-or\" of X and Y.\n        X XOR Y\
    \  =  bitwise logical \"exclusive-or\" of X and Y.\n        NOT X    =  bitwise\
    \ logical \"complement\" of X.\n        Example:\n                 01101100101110011101001001111011\n\
    \           XOR   01100101110000010110100110110111\n                 --------------------------------\n\
    \             =   00001001011110001011101111001100\n    b.  The operation X +\
    \ Y is defined as follows: words X and Y\n        represent w-bit integers x and\
    \ y, where 0 <= x < 2^w and\n        0 <= y < 2^w.  For positive integers n and\
    \ m, let\n             n mod m\n        be the remainder upon dividing n by m.\
    \  Compute\n             z  =  (x + y) mod 2^w.\n        Then 0 <= z < 2^w.  Convert\
    \ z to a word, Z, and define Z = X +\n        Y.\n    c.  The right shift operation\
    \ SHR^n(x), where x is a w-bit word and\n        n is an integer with 0 <= n <\
    \ w, is defined by\n             SHR^n(x) = x>>n\n    d.  The rotate right (circular\
    \ right shift) operation ROTR^n(x),\n        where x is a w-bit word and n is\
    \ an integer with 0 <= n < w, is\n        defined by\n             ROTR^n(x) =\
    \ (x>>n) OR (x<<(w-n))\n    e.  The rotate left (circular left shift) operation\
    \ ROTL^n(x), where\n        x is a w-bit word and n is an integer with 0 <= n\
    \ < w, is\n        defined by\n             ROTL^n(X)  =  (x<<n) OR (x>>w-n)\n\
    \        Note the following equivalence relationships, where w is fixed\n    \
    \    in each relationship:\n             ROTL^n(x) = ROTR^(w-x)(x)\n         \
    \    ROTR^n(x) = ROTL^(w-n)(x)\n"
- title: 4.  Message Padding and Parsing
  contents:
  - "4.  Message Padding and Parsing\n   The hash functions specified herein are used\
    \ to compute a message\n   digest for a message or data file that is provided\
    \ as input.  The\n   message or data file should be considered to be a bit string.\
    \  The\n   length of the message is the number of bits in the message (the empty\n\
    \   message has length 0).  If the number of bits in a message is a\n   multiple\
    \ of 8, for compactness we can represent the message in hex.\n   The purpose of\
    \ message padding is to make the total length of a\n   padded message a multiple\
    \ of 512 for SHA-224 and SHA-256 or a\n   multiple of 1024 for SHA-384 and SHA-512.\n\
    \   The following specifies how this padding shall be performed.  As a\n   summary,\
    \ a \"1\" followed by a number of \"0\"s followed by a 64-bit or\n   128-bit integer\
    \ are appended to the end of the message to produce a\n   padded message of length\
    \ 512*n or 1024*n.  The minimum number of \"0\"s\n   necessary to meet this criterion\
    \ is used.  The appended integer is\n   the length of the original message.  The\
    \ padded message is then\n   processed by the hash function as n 512-bit or 1024-bit\
    \ blocks.\n"
- title: 4.1.  SHA-224 and SHA-256
  contents:
  - "4.1.  SHA-224 and SHA-256\n   Suppose a message has length L < 2^64.  Before\
    \ it is input to the\n   hash function, the message is padded on the right as\
    \ follows:\n    a.  \"1\" is appended.  Example: if the original message is\n\
    \        \"01010000\", this is padded to \"010100001\".\n    b.  K \"0\"s are\
    \ appended where K is the smallest, non-negative\n        solution to the equation\n\
    \             L + 1 + K = 448 (mod 512)\n    c.  Then append the 64-bit block\
    \ that is L in binary representation.\n        After appending this block, the\
    \ length of the message will be a\n        multiple of 512 bits.\n        Example:\
    \  Suppose the original message is the bit string\n             01100001 01100010\
    \ 01100011 01100100 01100101\n        After step (a), this gives\n           \
    \  01100001 01100010 01100011 01100100 01100101 1\n        Since L = 40, the number\
    \ of bits in the above is 41 and K = 407\n        \"0\"s are appended, making\
    \ the total now 448.  This gives the\n        following in hex:\n            \
    \ 61626364 65800000 00000000 00000000\n             00000000 00000000 00000000\
    \ 00000000\n             00000000 00000000 00000000 00000000\n             00000000\
    \ 00000000\n        The 64-bit representation of L = 40 is hex 00000000 00000028.\n\
    \        Hence the final padded message is the following hex:\n             61626364\
    \ 65800000 00000000 00000000\n             00000000 00000000 00000000 00000000\n\
    \             00000000 00000000 00000000 00000000\n             00000000 00000000\
    \ 00000000 00000028\n"
- title: 4.2.  SHA-384 and SHA-512
  contents:
  - "4.2.  SHA-384 and SHA-512\n   Suppose a message has length L < 2^128.  Before\
    \ it is input to the\n   hash function, the message is padded on the right as\
    \ follows:\n    a.  \"1\" is appended.  Example: if the original message is\n\
    \        \"01010000\", this is padded to \"010100001\".\n    b.  K \"0\"s are\
    \ appended where K is the smallest, non-negative\n        solution to the equation\n\
    \             L + 1 + K = 896 (mod 1024)\n    c.  Then append the 128-bit block\
    \ that is L in binary\n        representation.  After appending this block, the\
    \ length of the\n        message will be a multiple of 1024 bits.\n        Example:\
    \  Suppose the original message is the bit string\n             01100001 01100010\
    \ 01100011 01100100 01100101\n        After step (a) this gives\n            \
    \ 01100001 01100010 01100011 01100100 01100101 1\n        Since L = 40, the number\
    \ of bits in the above is 41 and K = 855\n        \"0\"s are appended, making\
    \ the total now 896.  This gives the\n        following in hex:\n            \
    \ 61626364 65800000 00000000 00000000\n             00000000 00000000 00000000\
    \ 00000000\n             00000000 00000000 00000000 00000000\n             00000000\
    \ 00000000 00000000 00000000\n             00000000 00000000 00000000 00000000\n\
    \             00000000 00000000 00000000 00000000\n             00000000 00000000\
    \ 00000000 00000000\n        The 128-bit representation of L = 40 is hex 00000000\
    \ 00000000\n        00000000 00000028.  Hence the final padded message is the\n\
    \        following hex:\n             61626364 65800000 00000000 00000000\n  \
    \           00000000 00000000 00000000 00000000\n             00000000 00000000\
    \ 00000000 00000000\n             00000000 00000000 00000000 00000000\n      \
    \       00000000 00000000 00000000 00000000\n             00000000 00000000 00000000\
    \ 00000000\n             00000000 00000000 00000000 00000000\n             00000000\
    \ 00000000 00000000 00000028\n"
- title: 5.  Functions and Constants Used
  contents:
  - "5.  Functions and Constants Used\n   The following subsections give the six logical\
    \ functions and the\n   table of constants used in each of the hash functions.\n"
- title: 5.1.  SHA-224 and SHA-256
  contents:
  - "5.1.  SHA-224 and SHA-256\n   SHA-224 and SHA-256 use six logical functions,\
    \ where each function\n   operates on 32-bit words, which are represented as x,\
    \ y, and z.  The\n   result of each function is a new 32-bit word.\n        CH(\
    \ x, y, z) = (x AND y) XOR ( (NOT x) AND z)\n        MAJ( x, y, z) = (x AND y)\
    \ XOR (x AND z) XOR (y AND z)\n        BSIG0(x) = ROTR^2(x) XOR ROTR^13(x) XOR\
    \ ROTR^22(x)\n        BSIG1(x) = ROTR^6(x) XOR ROTR^11(x) XOR ROTR^25(x)\n   \
    \     SSIG0(x) = ROTR^7(x) XOR ROTR^18(x) XOR SHR^3(x)\n        SSIG1(x) = ROTR^17(x)\
    \ XOR ROTR^19(x) XOR SHR^10(x)\n   SHA-224 and SHA-256 use the same sequence of\
    \ sixty-four constant\n   32-bit words, K0, K1, ..., K63.  These words represent\
    \ the first\n   thirty-two bits of the fractional parts of the cube roots of the\n\
    \   first sixty-four prime numbers.  In hex, these constant words are as\n   follows\
    \ (from left to right):\n        428a2f98 71374491 b5c0fbcf e9b5dba5\n       \
    \ 3956c25b 59f111f1 923f82a4 ab1c5ed5\n        d807aa98 12835b01 243185be 550c7dc3\n\
    \        72be5d74 80deb1fe 9bdc06a7 c19bf174\n        e49b69c1 efbe4786 0fc19dc6\
    \ 240ca1cc\n        2de92c6f 4a7484aa 5cb0a9dc 76f988da\n        983e5152 a831c66d\
    \ b00327c8 bf597fc7\n        c6e00bf3 d5a79147 06ca6351 14292967\n        27b70a85\
    \ 2e1b2138 4d2c6dfc 53380d13\n        650a7354 766a0abb 81c2c92e 92722c85\n  \
    \      a2bfe8a1 a81a664b c24b8b70 c76c51a3\n        d192e819 d6990624 f40e3585\
    \ 106aa070\n        19a4c116 1e376c08 2748774c 34b0bcb5\n        391c0cb3 4ed8aa4a\
    \ 5b9cca4f 682e6ff3\n        748f82ee 78a5636f 84c87814 8cc70208\n        90befffa\
    \ a4506ceb bef9a3f7 c67178f2\n"
- title: 5.2.  SHA-384 and SHA-512
  contents:
  - "5.2.  SHA-384 and SHA-512\n   SHA-384 and SHA-512 each use six logical functions,\
    \ where each\n   function operates on 64-bit words, which are represented as x,\
    \ y, and\n   z.  The result of each function is a new 64-bit word.\n        CH(\
    \ x, y, z) = (x AND y) XOR ( (NOT x) AND z)\n        MAJ( x, y, z) = (x AND y)\
    \ XOR (x AND z) XOR (y AND z)\n        BSIG0(x) = ROTR^28(x) XOR ROTR^34(x) XOR\
    \ ROTR^39(x)\n        BSIG1(x) = ROTR^14(x) XOR ROTR^18(x) XOR ROTR^41(x)\n  \
    \      SSIG0(x) = ROTR^1(x) XOR ROTR^8(x) XOR SHR^7(x)\n        SSIG1(x) = ROTR^19(x)\
    \ XOR ROTR^61(x) XOR SHR^6(x)\n   SHA-384 and SHA-512 use the same sequence of\
    \ eighty constant 64-bit\n   words, K0, K1, ... K79.  These words represent the\
    \ first sixty-four\n   bits of the fractional parts of the cube roots of the first\
    \ eighty\n   prime numbers.  In hex, these constant words are as follows (from\n\
    \   left to right):\n   428a2f98d728ae22 7137449123ef65cd b5c0fbcfec4d3b2f e9b5dba58189dbbc\n\
    \   3956c25bf348b538 59f111f1b605d019 923f82a4af194f9b ab1c5ed5da6d8118\n   d807aa98a3030242\
    \ 12835b0145706fbe 243185be4ee4b28c 550c7dc3d5ffb4e2\n   72be5d74f27b896f 80deb1fe3b1696b1\
    \ 9bdc06a725c71235 c19bf174cf692694\n   e49b69c19ef14ad2 efbe4786384f25e3 0fc19dc68b8cd5b5\
    \ 240ca1cc77ac9c65\n   2de92c6f592b0275 4a7484aa6ea6e483 5cb0a9dcbd41fbd4 76f988da831153b5\n\
    \   983e5152ee66dfab a831c66d2db43210 b00327c898fb213f bf597fc7beef0ee4\n   c6e00bf33da88fc2\
    \ d5a79147930aa725 06ca6351e003826f 142929670a0e6e70\n   27b70a8546d22ffc 2e1b21385c26c926\
    \ 4d2c6dfc5ac42aed 53380d139d95b3df\n   650a73548baf63de 766a0abb3c77b2a8 81c2c92e47edaee6\
    \ 92722c851482353b\n   a2bfe8a14cf10364 a81a664bbc423001 c24b8b70d0f89791 c76c51a30654be30\n\
    \   d192e819d6ef5218 d69906245565a910 f40e35855771202a 106aa07032bbd1b8\n   19a4c116b8d2d0c8\
    \ 1e376c085141ab53 2748774cdf8eeb99 34b0bcb5e19b48a8\n   391c0cb3c5c95a63 4ed8aa4ae3418acb\
    \ 5b9cca4f7763e373 682e6ff3d6b2b8a3\n   748f82ee5defb2fc 78a5636f43172f60 84c87814a1f0ab72\
    \ 8cc702081a6439ec\n   90befffa23631e28 a4506cebde82bde9 bef9a3f7b2c67915 c67178f2e372532b\n\
    \   ca273eceea26619c d186b8c721c0c207 eada7dd6cde0eb1e f57d4f7fee6ed178\n   06f067aa72176fba\
    \ 0a637dc5a2c898a6 113f9804bef90dae 1b710b35131c471b\n   28db77f523047d84 32caab7b40c72493\
    \ 3c9ebe0a15c9bebc 431d67c49c100d4c\n   4cc5d4becb3e42b6 597f299cfc657e2a 5fcb6fab3ad6faec\
    \ 6c44198c4a475817\n"
- title: 6.  Computing the Message Digest
  contents:
  - "6.  Computing the Message Digest\n   The output of each of the secure hash functions,\
    \ after being applied\n   to a message of N blocks, is the hash quantity H(N).\
    \  For SHA-224 and\n   SHA-256, H(i) can be considered to be eight 32-bit words,\
    \ H(i)0,\n   H(i)1, ... H(i)7.  For SHA-384 and SHA-512, it can be considered\
    \ to\n   be eight 64-bit words, H(i)0, H(i)1, ..., H(i)7.\n   As described below,\
    \ the hash words are initialized, modified as each\n   message block is processed,\
    \ and finally concatenated after processing\n   the last block to yield the output.\
    \  For SHA-256 and SHA-512, all of\n   the H(N) variables are concatenated while\
    \ the SHA-224 and SHA-384\n   hashes are produced by omitting some from the final\
    \ concatenation.\n"
- title: 6.1.  SHA-224 and SHA-256 Initialization
  contents:
  - "6.1.  SHA-224 and SHA-256 Initialization\n   For SHA-224, the initial hash value,\
    \ H(0), consists of the following\n   32-bit words in hex:\n        H(0)0 = c1059ed8\n\
    \        H(0)1 = 367cd507\n        H(0)2 = 3070dd17\n        H(0)3 = f70e5939\n\
    \        H(0)4 = ffc00b31\n        H(0)5 = 68581511\n        H(0)6 = 64f98fa7\n\
    \        H(0)7 = befa4fa4\n   For SHA-256, the initial hash value, H(0), consists\
    \ of the following\n   eight 32-bit words, in hex.  These words were obtained\
    \ by taking the\n   first thirty-two bits of the fractional parts of the square\
    \ roots of\n   the first eight prime numbers.\n        H(0)0 = 6a09e667\n    \
    \    H(0)1 = bb67ae85\n        H(0)2 = 3c6ef372\n        H(0)3 = a54ff53a\n  \
    \      H(0)4 = 510e527f\n        H(0)5 = 9b05688c\n        H(0)6 = 1f83d9ab\n\
    \        H(0)7 = 5be0cd19\n"
- title: 6.2.  SHA-224 and SHA-256 Processing
  contents:
  - "6.2.  SHA-224 and SHA-256 Processing\n   SHA-224 and SHA-256 perform identical\
    \ processing on messages blocks\n   and differ only in how H(0) is initialized\
    \ and how they produce their\n   final output.  They may be used to hash a message,\
    \ M, having a length\n   of L bits, where 0 <= L < 2^64.  The algorithm uses (1)\
    \ a message\n   schedule of sixty-four 32-bit words, (2) eight working variables\
    \ of\n   32 bits each, and (3) a hash value of eight 32-bit words.\n   The words\
    \ of the message schedule are labeled W0, W1, ..., W63.  The\n   eight working\
    \ variables are labeled a, b, c, d, e, f, g, and h.  The\n   words of the hash\
    \ value are labeled H(i)0, H(i)1, ..., H(i)7, which\n   will hold the initial\
    \ hash value, H(0), replaced by each successive\n   intermediate hash value (after\
    \ each message block is processed),\n   H(i), and ending with the final hash value,\
    \ H(N), after all N blocks\n   are processed.  They also use two temporary words,\
    \ T1 and T2.\n   The input message is padded as described in Section 4.1 above\
    \ then\n   parsed into 512-bit blocks, which are considered to be composed of\
    \ 16\n   32-bit words M(i)0, M(i)1, ..., M(i)15.  The following computations\n\
    \   are then performed for each of the N message blocks.  All addition is\n  \
    \ performed modulo 2^32.\n   For i = 1 to N\n      1. Prepare the message schedule\
    \ W:\n         For t = 0 to 15\n            Wt = M(i)t\n         For t = 16 to\
    \ 63\n            Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(t-15) + W(t-16)\n      2.\
    \ Initialize the working variables:\n         a = H(i-1)0\n         b = H(i-1)1\n\
    \         c = H(i-1)2\n         d = H(i-1)3\n         e = H(i-1)4\n         f\
    \ = H(i-1)5\n         g = H(i-1)6\n         h = H(i-1)7\n      3. Perform the\
    \ main hash computation:\n         For t = 0 to 63\n            T1 = h + BSIG1(e)\
    \ + CH(e,f,g) + Kt + Wt\n            T2 = BSIG0(a) + MAJ(a,b,c)\n            h\
    \ = g\n            g = f\n            f = e\n            e = d + T1\n        \
    \    d = c\n            c = b\n            b = a\n            a = T1 + T2\n  \
    \    4. Compute the intermediate hash value H(i):\n         H(i)0 = a + H(i-1)0\n\
    \         H(i)1 = b + H(i-1)1\n         H(i)2 = c + H(i-1)2\n         H(i)3 =\
    \ d + H(i-1)3\n         H(i)4 = e + H(i-1)4\n         H(i)5 = f + H(i-1)5\n  \
    \       H(i)6 = g + H(i-1)6\n         H(i)7 = h + H(i-1)7\n   After the above\
    \ computations have been sequentially performed for all\n   of the blocks in the\
    \ message, the final output is calculated.  For\n   SHA-256, this is the concatenation\
    \ of all of H(N)0, H(N)1, through\n   H(N)7.  For SHA-224, this is the concatenation\
    \ of H(N)0, H(N)1,\n   through H(N)6.\n"
- title: 6.3.  SHA-384 and SHA-512 Initialization
  contents:
  - "6.3.  SHA-384 and SHA-512 Initialization\n   For SHA-384, the initial hash value,\
    \ H(0), consists of the following\n   eight 64-bit words, in hex.  These words\
    \ were obtained by taking the\n   first sixty-four bits of the fractional parts\
    \ of the square roots of\n   the ninth through sixteenth prime numbers.\n    \
    \    H(0)0 = cbbb9d5dc1059ed8\n        H(0)1 = 629a292a367cd507\n        H(0)2\
    \ = 9159015a3070dd17\n        H(0)3 = 152fecd8f70e5939\n        H(0)4 = 67332667ffc00b31\n\
    \        H(0)5 = 8eb44a8768581511\n        H(0)6 = db0c2e0d64f98fa7\n        H(0)7\
    \ = 47b5481dbefa4fa4\n   For SHA-512, the initial hash value, H(0), consists of\
    \ the following\n   eight 64-bit words, in hex.  These words were obtained by\
    \ taking the\n   first sixty-four bits of the fractional parts of the square roots\
    \ of\n   the first eight prime numbers.\n        H(0)0 = 6a09e667f3bcc908\n  \
    \      H(0)1 = bb67ae8584caa73b\n        H(0)2 = 3c6ef372fe94f82b\n        H(0)3\
    \ = a54ff53a5f1d36f1\n        H(0)4 = 510e527fade682d1\n        H(0)5 = 9b05688c2b3e6c1f\n\
    \        H(0)6 = 1f83d9abfb41bd6b\n        H(0)7 = 5be0cd19137e2179\n"
- title: 6.4.  SHA-384 and SHA-512 Processing
  contents:
  - "6.4.  SHA-384 and SHA-512 Processing\n   SHA-384 and SHA-512 perform identical\
    \ processing on message blocks\n   and differ only in how H(0) is initialized\
    \ and how they produce their\n   final output.  They may be used to hash a message,\
    \ M, having a length\n   of L bits, where 0 <= L < 2^128.  The algorithm uses\
    \ (1) a message\n   schedule of eighty 64-bit words, (2) eight working variables\
    \ of 64\n   bits each, and (3) a hash value of eight 64-bit words.\n   The words\
    \ of the message schedule are labeled W0, W1, ..., W79.  The\n   eight working\
    \ variables are labeled a, b, c, d, e, f, g, and h.  The\n   words of the hash\
    \ value are labeled H(i)0, H(i)1, ..., H(i)7, which\n   will hold the initial\
    \ hash value, H(0), replaced by each successive\n   intermediate hash value (after\
    \ each message block is processed),\n   H(i), and ending with the final hash value,\
    \ H(N) after all N blocks\n   are processed.\n   The input message is padded as\
    \ described in Section 4.2 above, then\n   parsed into 1024-bit blocks, which\
    \ are considered to be composed of\n   16 64-bit words M(i)0, M(i)1, ..., M(i)15.\
    \  The following\n   computations are then performed for each of the N message\
    \ blocks.\n   All addition is performed modulo 2^64.\n   For i = 1 to N\n    \
    \  1. Prepare the message schedule W:\n         For t = 0 to 15\n            Wt\
    \ = M(i)t\n         For t = 16 to 79\n            Wt = SSIG1(W(t-2)) + W(t-7)\
    \ + SSIG0(t-15) + W(t-16)\n      2. Initialize the working variables:\n      \
    \   a = H(i-1)0\n         b = H(i-1)1\n         c = H(i-1)2\n         d = H(i-1)3\n\
    \         e = H(i-1)4\n         f = H(i-1)5\n         g = H(i-1)6\n         h\
    \ = H(i-1)7\n      3. Perform the main hash computation:\n         For t = 0 to\
    \ 79\n            T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt\n            T2 = BSIG0(a)\
    \ + MAJ(a,b,c)\n            h = g\n            g = f\n            f = e\n    \
    \        e = d + T1\n            d = c\n            c = b\n            b = a\n\
    \            a = T1 + T2\n      4. Compute the intermediate hash value H(i):\n\
    \         H(i)0 = a + H(i-1)0\n         H(i)1 = b + H(i-1)1\n         H(i)2 =\
    \ c + H(i-1)2\n         H(i)3 = d + H(i-1)3\n         H(i)4 = e + H(i-1)4\n  \
    \       H(i)5 = f + H(i-1)5\n         H(i)6 = g + H(i-1)6\n         H(i)7 = h\
    \ + H(i-1)7\n   After the above computations have been sequentially performed\
    \ for all\n   of the blocks in the message, the final output is calculated.  For\n\
    \   SHA-512, this is the concatenation of all of H(N)0, H(N)1, through\n   H(N)7.\
    \  For SHA-384, this is the concatenation of H(N)0, H(N)1,\n   through H(N)5.\n"
- title: 7.  SHA-Based HMACs
  contents:
  - "7.  SHA-Based HMACs\n   HMAC is a method for computing a keyed MAC (message authentication\n\
    \   code) using a hash function as described in [RFC2104].  It uses a key\n  \
    \ to mix in with the input text to produce the final hash.\n   Sample code is\
    \ also provided, in Section 8.3 below, to perform HMAC\n   based on any of the\
    \ SHA algorithms described herein.  The sample code\n   found in [RFC2104] was\
    \ written in terms of a specified text size.\n   Since SHA is defined in terms\
    \ of an arbitrary number of bits, the\n   sample HMAC code has been written to\
    \ allow the text input to HMAC to\n   have an arbitrary number of octets and bits.\
    \  A fixed-length\n   interface is also provided.\n"
- title: 8.  C Code for SHAs
  contents:
  - "8.  C Code for SHAs\n   Below is a demonstration implementation of these secure\
    \ hash\n   functions in C.  Section 8.1 contains the header file sha.h, which\n\
    \   declares all constants, structures, and functions used by the sha and\n  \
    \ hmac functions.  Section 8.2 contains the C code for sha1.c,\n   sha224-256.c,\
    \ sha384-512.c, and usha.c along with sha-private.h,\n   which provides some declarations\
    \ common to all the sha functions.\n   Section 8.3 contains the C code for the\
    \ hmac functions.  Section 8.4\n   contains a test driver to exercise the code.\n\
    \   For each of the digest length $$$, there is the following set of\n   constants,\
    \ a structure, and functions:\n   Constants:\n      SHA$$$HashSize      number\
    \ of octets in the hash\n      SHA$$$HashSizeBits  number of bits in the hash\n\
    \      SHA$$$_Message_Block_Size\n                          number of octets used\
    \ in the intermediate\n                          message blocks\n      shaSuccess\
    \ = 0      constant returned by each function on success\n      shaNull = 1  \
    \       constant returned by each function when\n                          presented\
    \ with a null pointer parameter\n      shaInputTooLong = 2  constant returned\
    \ by each function when the\n                          input data is too long\n\
    \      shaStateError       constant returned by each function when\n         \
    \                 SHA$$$Input is called after SHA$$$FinalBits or\n           \
    \               SHA$$$Result.\n   Structure:\n      typedef SHA$$$Context\n  \
    \                        an opaque structure holding the complete state\n    \
    \                      for producing the hash\n   Functions:\n               \
    \   int SHA$$$Reset(SHA$$$Context *);\n            Reset the hash context state\n\
    \      int SHA$$$Input(SHA$$$Context *, const uint8_t *octets,\n             \
    \     unsigned int bytecount);\n            Incorporate bytecount octets into\
    \ the hash.\n      int SHA$$$FinalBits(SHA$$$Context *, const uint8_t octet,\n\
    \                  unsigned int bitcount);\n            Incorporate bitcount bits\
    \ into the hash.  The bits are in\n            the upper portion of the octet.\
    \  SHA$$$Input() cannot be\n            called after this.\n      int SHA$$$Result(SHA$$$Context\
    \ *,\n                  uint8_t Message_Digest[SHA$$$HashSize]);\n           \
    \ Do the final calculations on the hash and copy the value\n            into Message_Digest.\n\
    \   In addition, functions with the prefix USHA are provided that take a\n   SHAversion\
    \ value (SHA$$$) to select the SHA function suite.  They add\n   the following\
    \ constants, structure, and functions:\n   Constants:\n      shaBadParam     \
    \    constant returned by USHA functions when\n                          presented\
    \ with a bad SHAversion (SHA$$$)\n                          parameter\n      SHA$$$\
    \              SHAversion enumeration values, used by usha\n                 \
    \         and hmac functions to select the SHA function\n                    \
    \      suite\n   Structure:\n      typedef USHAContext\n                     \
    \     an opaque structure holding the complete state\n                       \
    \   for producing the hash\n   Functions:\n      int USHAReset(USHAContext *,\
    \ SHAversion whichSha);\n            Reset the hash context state.\n      int\
    \ USHAInput(USHAContext *,\n                  const uint8_t *bytes, unsigned int\
    \ bytecount);\n            Incorporate bytecount octets into the hash.\n     \
    \ int USHAFinalBits(USHAContext *,\n                  const uint8_t bits, unsigned\
    \ int bitcount);\n                  Incorporate bitcount bits into the hash.\n\
    \      int USHAResult(USHAContext *,\n                  uint8_t Message_Digest[USHAMaxHashSize]);\n\
    \            Do the final calculations on the hash and copy the value\n      \
    \      into Message_Digest.  Octets in Message_Digest beyond\n      USHAHashSize(whichSha)\
    \ are left untouched.\n                  int USHAHashSize(enum SHAversion whichSha);\n\
    \            The number of octets in the given hash.\n      int USHAHashSizeBits(enum\
    \ SHAversion whichSha);\n            The number of bits in the given hash.\n \
    \     int USHABlockSize(enum SHAversion whichSha);\n            The internal block\
    \ size for the given hash.\n   The hmac functions follow the same pattern to allow\
    \ any length of\n   text input to be used.\n   Structure:\n      typedef HMACContext\
    \ an opaque structure holding the complete state\n                          for\
    \ producing the hash\n   Functions:\n      int hmacReset(HMACContext *ctx, enum\
    \ SHAversion whichSha,\n                  const unsigned char *key, int key_len);\n\
    \            Reset the hash context state.\n      int hmacInput(HMACContext *ctx,\
    \ const unsigned char *text,\n                  int text_len);\n            Incorporate\
    \ text_len octets into the hash.\n      int hmacFinalBits(HMACContext *ctx, const\
    \ uint8_t bits,\n                  unsigned int bitcount);\n            Incorporate\
    \ bitcount bits into the hash.\n      int hmacResult(HMACContext *ctx,\n     \
    \             uint8_t Message_Digest[USHAMaxHashSize]);\n            Do the final\
    \ calculations on the hash and copy the value\n            into Message_Digest.\
    \  Octets in Message_Digest beyond\n            USHAHashSize(whichSha) are left\
    \ untouched.\n   In addition, a combined interface is provided, similar to that\
    \ shown\n   in RFC 2104, that allows a fixed-length text input to be used.\n \
    \     int hmac(SHAversion whichSha,\n                  const unsigned char *text,\
    \ int text_len,\n                  const unsigned char *key, int key_len,\n  \
    \                uint8_t Message_Digest[USHAMaxHashSize]);\n            Calculate\
    \ the given digest for the given text and key, and\n            return the resulting\
    \ hash.  Octets in Message_Digest beyond\n            USHAHashSize(whichSha) are\
    \ left untouched.\n"
- title: 8.1.  The .h File
  contents:
  - '8.1.  The .h File

    '
- title: /**************************** sha.h ****************************/
  contents:
  - '/**************************** sha.h ****************************/

    '
- title: /******************* See RFC 4634 for details ******************/
  contents:
  - '/******************* See RFC 4634 for details ******************/

    '
- title: '#ifndef _SHA_H_'
  contents:
  - '#ifndef _SHA_H_

    '
- title: '#define _SHA_H_'
  contents:
  - '#define _SHA_H_

    '
- title: /*
  contents:
  - "/*\n *  Description:\n *      This file implements the Secure Hash Signature\
    \ Standard\n *      algorithms as defined in the National Institute of Standards\n\
    \ *      and Technology Federal Information Processing Standards\n *      Publication\
    \ (FIPS PUB) 180-1 published on April 17, 1995, 180-2\n *      published on August\
    \ 1, 2002, and the FIPS PUB 180-2 Change\n *      Notice published on February\
    \ 28, 2004.\n *\n *      A combined document showing all algorithms is available\
    \ at\n *              http://csrc.nist.gov/publications/fips/\n *            \
    \  fips180-2/fips180-2withchangenotice.pdf\n *\n *      The five hashes are defined\
    \ in these sizes:\n *              SHA-1           20 byte / 160 bit\n *     \
    \         SHA-224         28 byte / 224 bit\n *              SHA-256         32\
    \ byte / 256 bit\n *              SHA-384         48 byte / 384 bit\n *      \
    \        SHA-512         64 byte / 512 bit\n */\n"
- title: '#include <stdint.h>'
  contents:
  - '#include <stdint.h>

    '
- title: /*
  contents:
  - "/*\n * If you do not have the ISO standard stdint.h header file, then you\n *\
    \ must typedef the following:\n *    name              meaning\n *  uint64_t \
    \        unsigned 64 bit integer\n *  uint32_t         unsigned 32 bit integer\n\
    \ *  uint8_t          unsigned 8 bit integer (i.e., unsigned char)\n *  int_least16_t\
    \    integer of >= 16 bits\n *\n */\n"
- title: '#ifndef _SHA_enum_'
  contents:
  - '#ifndef _SHA_enum_

    '
- title: '#define _SHA_enum_'
  contents:
  - '#define _SHA_enum_

    '
- title: /*
  contents:
  - "/*\n *  All SHA functions return one of these values.\n */\n"
- title: enum {
  contents:
  - "enum {\n    shaSuccess = 0,\n    shaNull,            /* Null pointer parameter\
    \ */\n    shaInputTooLong,    /* input data too long */\n    shaStateError,  \
    \    /* called Input after FinalBits or Result */\n    shaBadParam         /*\
    \ passed a bad parameter */\n"
- title: '};'
  contents:
  - '};

    '
- title: '#endif /* _SHA_enum_ */'
  contents:
  - '#endif /* _SHA_enum_ */

    '
- title: /*
  contents:
  - "/*\n *  These constants hold size information for each of the SHA\n *  hashing\
    \ operations\n */\n"
- title: enum {
  contents:
  - "enum {\n    SHA1_Message_Block_Size = 64, SHA224_Message_Block_Size = 64,\n \
    \   SHA256_Message_Block_Size = 64, SHA384_Message_Block_Size = 128,\n    SHA512_Message_Block_Size\
    \ = 128,\n    USHA_Max_Message_Block_Size = SHA512_Message_Block_Size,\n    SHA1HashSize\
    \ = 20, SHA224HashSize = 28, SHA256HashSize = 32,\n    SHA384HashSize = 48, SHA512HashSize\
    \ = 64,\n    USHAMaxHashSize = SHA512HashSize,\n    SHA1HashSizeBits = 160, SHA224HashSizeBits\
    \ = 224,\n    SHA256HashSizeBits = 256, SHA384HashSizeBits = 384,\n    SHA512HashSizeBits\
    \ = 512, USHAMaxHashSizeBits = SHA512HashSizeBits\n"
- title: '};'
  contents:
  - '};

    '
- title: /*
  contents:
  - "/*\n *  These constants are used in the USHA (unified sha) functions.\n */\n"
- title: typedef enum SHAversion {
  contents:
  - "typedef enum SHAversion {\n    SHA1, SHA224, SHA256, SHA384, SHA512\n"
- title: '} SHAversion;'
  contents:
  - '} SHAversion;

    '
- title: /*
  contents:
  - "/*\n *  This structure will hold context information for the SHA-1\n *  hashing\
    \ operation.\n */\n"
- title: typedef struct SHA1Context {
  contents:
  - "typedef struct SHA1Context {\n    uint32_t Intermediate_Hash[SHA1HashSize/4];\
    \ /* Message Digest */\n    uint32_t Length_Low;                /* Message length\
    \ in bits */\n    uint32_t Length_High;               /* Message length in bits\
    \ */\n    int_least16_t Message_Block_Index;  /* Message_Block array index */\n\
    \                                        /* 512-bit message blocks */\n    uint8_t\
    \ Message_Block[SHA1_Message_Block_Size];\n    int Computed;                 \
    \      /* Is the digest computed? */\n    int Corrupted;                     \
    \ /* Is the digest corrupted? */\n"
- title: '} SHA1Context;'
  contents:
  - '} SHA1Context;

    '
- title: /*
  contents:
  - "/*\n *  This structure will hold context information for the SHA-256\n *  hashing\
    \ operation.\n */\n"
- title: typedef struct SHA256Context {
  contents:
  - "typedef struct SHA256Context {\n    uint32_t Intermediate_Hash[SHA256HashSize/4];\
    \ /* Message Digest */\n    uint32_t Length_Low;                /* Message length\
    \ in bits */\n    uint32_t Length_High;               /* Message length in bits\
    \ */\n    int_least16_t Message_Block_Index;  /* Message_Block array index */\n\
    \                                        /* 512-bit message blocks */\n    uint8_t\
    \ Message_Block[SHA256_Message_Block_Size];\n    int Computed;               \
    \        /* Is the digest computed? */\n    int Corrupted;                   \
    \   /* Is the digest corrupted? */\n"
- title: '} SHA256Context;'
  contents:
  - '} SHA256Context;

    '
- title: /*
  contents:
  - "/*\n *  This structure will hold context information for the SHA-512\n *  hashing\
    \ operation.\n */\n"
- title: typedef struct SHA512Context {
  contents:
  - 'typedef struct SHA512Context {

    '
- title: '#ifdef USE_32BIT_ONLY'
  contents:
  - "#ifdef USE_32BIT_ONLY\n    uint32_t Intermediate_Hash[SHA512HashSize/4]; /* Message\
    \ Digest  */\n    uint32_t Length[4];                 /* Message length in bits\
    \ */\n"
- title: '#else /* !USE_32BIT_ONLY */'
  contents:
  - "#else /* !USE_32BIT_ONLY */\n    uint64_t Intermediate_Hash[SHA512HashSize/8];\
    \ /* Message Digest */\n    uint64_t Length_Low, Length_High;   /* Message length\
    \ in bits */\n"
- title: '#endif /* USE_32BIT_ONLY */'
  contents:
  - "#endif /* USE_32BIT_ONLY */\n    int_least16_t Message_Block_Index;  /* Message_Block\
    \ array index */\n                                        /* 1024-bit message\
    \ blocks */\n    uint8_t Message_Block[SHA512_Message_Block_Size];\n    int Computed;\
    \                       /* Is the digest computed?*/\n    int Corrupted;     \
    \                 /* Is the digest corrupted? */\n"
- title: '} SHA512Context;'
  contents:
  - '} SHA512Context;

    '
- title: /*
  contents:
  - "/*\n *  This structure will hold context information for the SHA-224\n *  hashing\
    \ operation. It uses the SHA-256 structure for computation.\n */\n"
- title: typedef struct SHA256Context SHA224Context;
  contents:
  - 'typedef struct SHA256Context SHA224Context;

    '
- title: /*
  contents:
  - "/*\n *  This structure will hold context information for the SHA-384\n *  hashing\
    \ operation. It uses the SHA-512 structure for computation.\n */\n"
- title: typedef struct SHA512Context SHA384Context;
  contents:
  - 'typedef struct SHA512Context SHA384Context;

    '
- title: /*
  contents:
  - "/*\n *  This structure holds context information for all SHA\n *  hashing operations.\n\
    \ */\n"
- title: typedef struct USHAContext {
  contents:
  - "typedef struct USHAContext {\n    int whichSha;               /* which SHA is\
    \ being used */\n    union {\n      SHA1Context sha1Context;\n      SHA224Context\
    \ sha224Context; SHA256Context sha256Context;\n      SHA384Context sha384Context;\
    \ SHA512Context sha512Context;\n    } ctx;\n"
- title: '} USHAContext;'
  contents:
  - '} USHAContext;

    '
- title: /*
  contents:
  - "/*\n *  This structure will hold context information for the HMAC\n *  keyed\
    \ hashing operation.\n */\n"
- title: typedef struct HMACContext {
  contents:
  - "typedef struct HMACContext {\n    int whichSha;               /* which SHA is\
    \ being used */\n    int hashSize;               /* hash size of SHA being used\
    \ */\n    int blockSize;              /* block size of SHA being used */\n   \
    \ USHAContext shaContext;     /* SHA context */\n    unsigned char k_opad[USHA_Max_Message_Block_Size];\n\
    \                        /* outer padding - key XORd with opad */\n"
- title: '} HMACContext;'
  contents:
  - '} HMACContext;

    '
- title: /*
  contents:
  - "/*\n *  Function Prototypes\n */\n"
- title: /* SHA-1 */
  contents:
  - '/* SHA-1 */

    '
- title: extern int SHA1Reset(SHA1Context *);
  contents:
  - 'extern int SHA1Reset(SHA1Context *);

    '
- title: extern int SHA1Input(SHA1Context *, const uint8_t *bytes,
  contents:
  - "extern int SHA1Input(SHA1Context *, const uint8_t *bytes,\n                 \
    \    unsigned int bytecount);\n"
- title: extern int SHA1FinalBits(SHA1Context *, const uint8_t bits,
  contents:
  - "extern int SHA1FinalBits(SHA1Context *, const uint8_t bits,\n               \
    \          unsigned int bitcount);\n"
- title: extern int SHA1Result(SHA1Context *,
  contents:
  - "extern int SHA1Result(SHA1Context *,\n                      uint8_t Message_Digest[SHA1HashSize]);\n"
- title: /* SHA-224 */
  contents:
  - '/* SHA-224 */

    '
- title: extern int SHA224Reset(SHA224Context *);
  contents:
  - 'extern int SHA224Reset(SHA224Context *);

    '
- title: extern int SHA224Input(SHA224Context *, const uint8_t *bytes,
  contents:
  - "extern int SHA224Input(SHA224Context *, const uint8_t *bytes,\n             \
    \          unsigned int bytecount);\n"
- title: extern int SHA224FinalBits(SHA224Context *, const uint8_t bits,
  contents:
  - "extern int SHA224FinalBits(SHA224Context *, const uint8_t bits,\n           \
    \                unsigned int bitcount);\n"
- title: extern int SHA224Result(SHA224Context *,
  contents:
  - "extern int SHA224Result(SHA224Context *,\n                        uint8_t Message_Digest[SHA224HashSize]);\n"
- title: /* SHA-256 */
  contents:
  - '/* SHA-256 */

    '
- title: extern int SHA256Reset(SHA256Context *);
  contents:
  - 'extern int SHA256Reset(SHA256Context *);

    '
- title: extern int SHA256Input(SHA256Context *, const uint8_t *bytes,
  contents:
  - "extern int SHA256Input(SHA256Context *, const uint8_t *bytes,\n             \
    \          unsigned int bytecount);\n"
- title: extern int SHA256FinalBits(SHA256Context *, const uint8_t bits,
  contents:
  - "extern int SHA256FinalBits(SHA256Context *, const uint8_t bits,\n           \
    \                unsigned int bitcount);\n"
- title: extern int SHA256Result(SHA256Context *,
  contents:
  - "extern int SHA256Result(SHA256Context *,\n                        uint8_t Message_Digest[SHA256HashSize]);\n"
- title: /* SHA-384 */
  contents:
  - '/* SHA-384 */

    '
- title: extern int SHA384Reset(SHA384Context *);
  contents:
  - 'extern int SHA384Reset(SHA384Context *);

    '
- title: extern int SHA384Input(SHA384Context *, const uint8_t *bytes,
  contents:
  - "extern int SHA384Input(SHA384Context *, const uint8_t *bytes,\n             \
    \          unsigned int bytecount);\n"
- title: extern int SHA384FinalBits(SHA384Context *, const uint8_t bits,
  contents:
  - "extern int SHA384FinalBits(SHA384Context *, const uint8_t bits,\n           \
    \                unsigned int bitcount);\n"
- title: extern int SHA384Result(SHA384Context *,
  contents:
  - "extern int SHA384Result(SHA384Context *,\n                        uint8_t Message_Digest[SHA384HashSize]);\n"
- title: /* SHA-512 */
  contents:
  - '/* SHA-512 */

    '
- title: extern int SHA512Reset(SHA512Context *);
  contents:
  - 'extern int SHA512Reset(SHA512Context *);

    '
- title: extern int SHA512Input(SHA512Context *, const uint8_t *bytes,
  contents:
  - "extern int SHA512Input(SHA512Context *, const uint8_t *bytes,\n             \
    \          unsigned int bytecount);\n"
- title: extern int SHA512FinalBits(SHA512Context *, const uint8_t bits,
  contents:
  - "extern int SHA512FinalBits(SHA512Context *, const uint8_t bits,\n           \
    \                unsigned int bitcount);\n"
- title: extern int SHA512Result(SHA512Context *,
  contents:
  - "extern int SHA512Result(SHA512Context *,\n                        uint8_t Message_Digest[SHA512HashSize]);\n"
- title: /* Unified SHA functions, chosen by whichSha */
  contents:
  - '/* Unified SHA functions, chosen by whichSha */

    '
- title: extern int USHAReset(USHAContext *, SHAversion whichSha);
  contents:
  - 'extern int USHAReset(USHAContext *, SHAversion whichSha);

    '
- title: extern int USHAInput(USHAContext *,
  contents:
  - "extern int USHAInput(USHAContext *,\n                     const uint8_t *bytes,\
    \ unsigned int bytecount);\n"
- title: extern int USHAFinalBits(USHAContext *,
  contents:
  - "extern int USHAFinalBits(USHAContext *,\n                         const uint8_t\
    \ bits, unsigned int bitcount);\n"
- title: extern int USHAResult(USHAContext *,
  contents:
  - "extern int USHAResult(USHAContext *,\n                      uint8_t Message_Digest[USHAMaxHashSize]);\n"
- title: extern int USHABlockSize(enum SHAversion whichSha);
  contents:
  - 'extern int USHABlockSize(enum SHAversion whichSha);

    '
- title: extern int USHAHashSize(enum SHAversion whichSha);
  contents:
  - 'extern int USHAHashSize(enum SHAversion whichSha);

    '
- title: extern int USHAHashSizeBits(enum SHAversion whichSha);
  contents:
  - 'extern int USHAHashSizeBits(enum SHAversion whichSha);

    '
- title: /*
  contents:
  - "/*\n * HMAC Keyed-Hashing for Message Authentication, RFC2104,\n * for all SHAs.\n\
    \ * This interface allows a fixed-length text input to be used.\n */\n"
- title: extern int hmac(SHAversion whichSha, /* which SHA algorithm to use */
  contents:
  - "extern int hmac(SHAversion whichSha, /* which SHA algorithm to use */\n    const\
    \ unsigned char *text,     /* pointer to data stream */\n    int text_len,   \
    \               /* length of data stream */\n    const unsigned char *key,   \
    \   /* pointer to authentication key */\n    int key_len,                   /*\
    \ length of authentication key */\n    uint8_t digest[USHAMaxHashSize]); /* caller\
    \ digest to fill in */\n"
- title: /*
  contents:
  - "/*\n * HMAC Keyed-Hashing for Message Authentication, RFC2104,\n * for all SHAs.\n\
    \ * This interface allows any length of text input to be used.\n */\n"
- title: extern int hmacReset(HMACContext *ctx, enum SHAversion whichSha,
  contents:
  - "extern int hmacReset(HMACContext *ctx, enum SHAversion whichSha,\n          \
    \           const unsigned char *key, int key_len);\n"
- title: extern int hmacInput(HMACContext *ctx, const unsigned char *text,
  contents:
  - "extern int hmacInput(HMACContext *ctx, const unsigned char *text,\n         \
    \            int text_len);\n"
- title: extern int hmacFinalBits(HMACContext *ctx, const uint8_t bits,
  contents:
  - "extern int hmacFinalBits(HMACContext *ctx, const uint8_t bits,\n            \
    \             unsigned int bitcount);\n"
- title: extern int hmacResult(HMACContext *ctx,
  contents:
  - "extern int hmacResult(HMACContext *ctx,\n                      uint8_t digest[USHAMaxHashSize]);\n"
- title: '#endif /* _SHA_H_ */'
  contents:
  - '#endif /* _SHA_H_ */

    '
- title: 8.2.  The SHA Code
  contents:
  - "8.2.  The SHA Code\n   This code is primarily intended as expository and could\
    \ be optimized\n   further.  For example, the assignment rotations through the\
    \ variables\n   a, b, ..., h could be treated as a cycle and the loop unrolled,\n\
    \   rather than doing the explicit copying.\n   Note that there are alternative\
    \ representations of the Ch() and Maj()\n   functions controlled by an ifdef.\n"
- title: 8.2.1.  sha1.c
  contents:
  - '8.2.1.  sha1.c

    '
- title: /**************************** sha1.c ****************************/
  contents:
  - '/**************************** sha1.c ****************************/

    '
- title: /******************** See RFC 4634 for details ******************/
  contents:
  - '/******************** See RFC 4634 for details ******************/

    '
- title: /*
  contents:
  - "/*\n *  Description:\n *      This file implements the Secure Hash Signature\
    \ Standard\n *      algorithms as defined in the National Institute of Standards\n\
    \ *      and Technology Federal Information Processing Standards\n *      Publication\
    \ (FIPS PUB) 180-1 published on April 17, 1995, 180-2\n *      published on August\
    \ 1, 2002, and the FIPS PUB 180-2 Change\n *      Notice published on February\
    \ 28, 2004.\n *\n *      A combined document showing all algorithms is available\
    \ at\n *              http://csrc.nist.gov/publications/fips/\n *            \
    \  fips180-2/fips180-2withchangenotice.pdf\n *\n *      The SHA-1 algorithm produces\
    \ a 160-bit message digest for a\n *      given data stream.  It should take about\
    \ 2**n steps to find a\n *      message with the same digest as a given message\
    \ and\n *      2**(n/2) to find any two messages with the same digest,\n *   \
    \   when n is the digest size in bits.  Therefore, this\n *      algorithm can\
    \ serve as a means of providing a\n *      \"fingerprint\" for a message.\n *\n\
    \ *  Portability Issues:\n *      SHA-1 is defined in terms of 32-bit \"words\"\
    .  This code\n *      uses <stdint.h> (included via \"sha.h\") to define 32 and\
    \ 8\n *      bit unsigned integer types.  If your C compiler does not\n *    \
    \  support 32 bit unsigned integers, this code is not\n *      appropriate.\n\
    \ *\n *  Caveats:\n *      SHA-1 is designed to work with messages less than 2^64\
    \ bits\n *      long. This implementation uses SHA1Input() to hash the bits\n\
    \ *      that are a multiple of the size of an 8-bit character, and then\n * \
    \     uses SHA1FinalBits() to hash the final few bits of the input.\n */\n"
- title: '#include "sha.h"'
  contents:
  - '#include "sha.h"

    '
- title: '#include "sha-private.h"'
  contents:
  - '#include "sha-private.h"

    '
- title: /*
  contents:
  - "/*\n *  Define the SHA1 circular left shift macro\n */\n"
- title: '#define SHA1_ROTL(bits,word) \'
  contents:
  - "#define SHA1_ROTL(bits,word) \\\n                (((word) << (bits)) | ((word)\
    \ >> (32-(bits))))\n"
- title: /*
  contents:
  - "/*\n * add \"length\" to the length\n */\n"
- title: static uint32_t addTemp;
  contents:
  - 'static uint32_t addTemp;

    '
- title: '#define SHA1AddLength(context, length)                     \'
  contents:
  - "#define SHA1AddLength(context, length)                     \\\n    (addTemp =\
    \ (context)->Length_Low,                      \\\n     (context)->Corrupted =\
    \                                \\\n        (((context)->Length_Low += (length))\
    \ < addTemp) && \\\n        (++(context)->Length_High == 0) ? 1 : 0)\n"
- title: /* Local Function Prototypes */
  contents:
  - '/* Local Function Prototypes */

    '
- title: static void SHA1Finalize(SHA1Context *context, uint8_t Pad_Byte);
  contents:
  - 'static void SHA1Finalize(SHA1Context *context, uint8_t Pad_Byte);

    '
- title: static void SHA1PadMessage(SHA1Context *, uint8_t Pad_Byte);
  contents:
  - 'static void SHA1PadMessage(SHA1Context *, uint8_t Pad_Byte);

    '
- title: static void SHA1ProcessMessageBlock(SHA1Context *);
  contents:
  - 'static void SHA1ProcessMessageBlock(SHA1Context *);

    '
- title: /*
  contents:
  - "/*\n *  SHA1Reset\n *\n *  Description:\n *      This function will initialize\
    \ the SHA1Context in preparation\n *      for computing a new SHA1 message digest.\n\
    \ *\n *  Parameters:\n *      context: [in/out]\n *          The context to reset.\n\
    \ *\n *  Returns:\n *      sha Error Code.\n *\n */\n"
- title: int SHA1Reset(SHA1Context *context)
  contents:
  - 'int SHA1Reset(SHA1Context *context)

    '
- title: '{'
  contents:
  - "{\n    if (!context)\n        return shaNull;\n    context->Length_Low      \
    \       = 0;\n    context->Length_High            = 0;\n    context->Message_Block_Index\
    \    = 0;\n    /* Initial Hash Values: FIPS-180-2 section 5.3.1 */\n    context->Intermediate_Hash[0]\
    \   = 0x67452301;\n    context->Intermediate_Hash[1]   = 0xEFCDAB89;\n    context->Intermediate_Hash[2]\
    \   = 0x98BADCFE;\n    context->Intermediate_Hash[3]   = 0x10325476;\n    context->Intermediate_Hash[4]\
    \   = 0xC3D2E1F0;\n    context->Computed   = 0;\n    context->Corrupted  = 0;\n\
    \    return shaSuccess;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n *  SHA1Input\n *\n *  Description:\n *      This function accepts an array\
    \ of octets as the next portion\n *      of the message.\n *\n *  Parameters:\n\
    \ *      context: [in/out]\n *          The SHA context to update\n *      message_array:\
    \ [in]\n *          An array of characters representing the next portion of\n\
    \ *          the message.\n *      length: [in]\n *          The length of the\
    \ message in message_array\n *\n *  Returns:\n *      sha Error Code.\n *\n */\n"
- title: int SHA1Input(SHA1Context *context,
  contents:
  - "int SHA1Input(SHA1Context *context,\n    const uint8_t *message_array, unsigned\
    \ length)\n"
- title: '{'
  contents:
  - "{\n  if (!length)\n    return shaSuccess;\n  if (!context || !message_array)\n\
    \    return shaNull;\n  if (context->Computed) {\n    context->Corrupted = shaStateError;\n\
    \    return shaStateError;\n  }\n  if (context->Corrupted)\n     return context->Corrupted;\n\
    \  while (length-- && !context->Corrupted) {\n    context->Message_Block[context->Message_Block_Index++]\
    \ =\n      (*message_array & 0xFF);\n    if (!SHA1AddLength(context, 8) &&\n \
    \     (context->Message_Block_Index == SHA1_Message_Block_Size))\n      SHA1ProcessMessageBlock(context);\n\
    \    message_array++;\n  }\n  return shaSuccess;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA1FinalBits\n *\n * Description:\n *   This function will add in any\
    \ final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n * \
    \    The SHA context to update\n *   message_bits: [in]\n *     The final bits\
    \ of the message, in the upper portion of the\n *     byte. (Use 0b###00000 instead\
    \ of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n * \
    \    The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *\
    \   sha Error Code.\n */\n"
- title: int SHA1FinalBits(SHA1Context *context, const uint8_t message_bits,
  contents:
  - "int SHA1FinalBits(SHA1Context *context, const uint8_t message_bits,\n    unsigned\
    \ int length)\n"
- title: '{'
  contents:
  - "{\n  uint8_t masks[8] = {\n      /* 0 0b00000000 */ 0x00, /* 1 0b10000000 */\
    \ 0x80,\n      /* 2 0b11000000 */ 0xC0, /* 3 0b11100000 */ 0xE0,\n      /* 4 0b11110000\
    \ */ 0xF0, /* 5 0b11111000 */ 0xF8,\n      /* 6 0b11111100 */ 0xFC, /* 7 0b11111110\
    \ */ 0xFE\n  };\n  uint8_t markbit[8] = {\n      /* 0 0b10000000 */ 0x80, /* 1\
    \ 0b01000000 */ 0x40,\n      /* 2 0b00100000 */ 0x20, /* 3 0b00010000 */ 0x10,\n\
    \      /* 4 0b00001000 */ 0x08, /* 5 0b00000100 */ 0x04,\n      /* 6 0b00000010\
    \ */ 0x02, /* 7 0b00000001 */ 0x01\n  };\n  if (!length)\n    return shaSuccess;\n\
    \  if (!context)\n    return shaNull;\n  if (context->Computed || (length >= 8)\
    \ || (length == 0)) {\n    context->Corrupted = shaStateError;\n    return shaStateError;\n\
    \  }\n  if (context->Corrupted)\n     return context->Corrupted;\n  SHA1AddLength(context,\
    \ length);\n  SHA1Finalize(context,\n    (uint8_t) ((message_bits & masks[length])\
    \ | markbit[length]));\n  return shaSuccess;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA1Result\n *\n * Description:\n *   This function will return the 160-bit\
    \ message digest into the\n *   Message_Digest array provided by the caller.\n\
    \ *   NOTE: The first octet of hash is stored in the 0th element,\n *      the\
    \ last octet of hash in the 19th element.\n *\n * Parameters:\n *   context: [in/out]\n\
    \ *     The context to use to calculate the SHA-1 hash.\n *   Message_Digest:\
    \ [out]\n *     Where the digest is returned.\n *\n * Returns:\n *   sha Error\
    \ Code.\n *\n */\n"
- title: int SHA1Result(SHA1Context *context,
  contents:
  - "int SHA1Result(SHA1Context *context,\n    uint8_t Message_Digest[SHA1HashSize])\n"
- title: '{'
  contents:
  - "{\n  int i;\n  if (!context || !Message_Digest)\n    return shaNull;\n  if (context->Corrupted)\n\
    \    return context->Corrupted;\n  if (!context->Computed)\n    SHA1Finalize(context,\
    \ 0x80);\n  for (i = 0; i < SHA1HashSize; ++i)\n    Message_Digest[i] = (uint8_t)\
    \ (context->Intermediate_Hash[i>>2]\n              >> 8 * ( 3 - ( i & 0x03 ) ));\n\
    \  return shaSuccess;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA1Finalize\n *\n * Description:\n *   This helper function finishes\
    \ off the digest calculations.\n *\n * Parameters:\n *   context: [in/out]\n *\
    \     The SHA context to update\n *   Pad_Byte: [in]\n *     The last byte to\
    \ add to the digest before the 0-padding\n *     and length. This will contain\
    \ the last bits of the message\n *     followed by another single bit. If the\
    \ message was an\n *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n\
    \ *\n * Returns:\n *   sha Error Code.\n *\n */\n"
- title: static void SHA1Finalize(SHA1Context *context, uint8_t Pad_Byte)
  contents:
  - 'static void SHA1Finalize(SHA1Context *context, uint8_t Pad_Byte)

    '
- title: '{'
  contents:
  - "{\n  int i;\n  SHA1PadMessage(context, Pad_Byte);\n  /* message may be sensitive,\
    \ clear it out */\n  for (i = 0; i < SHA1_Message_Block_Size; ++i)\n    context->Message_Block[i]\
    \ = 0;\n  context->Length_Low = 0;  /* and clear length */\n  context->Length_High\
    \ = 0;\n  context->Computed = 1;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA1PadMessage\n *\n * Description:\n *   According to the standard, the\
    \ message must be padded to an\n *   even 512 bits. The first padding bit must\
    \ be a '1'. The last\n *   64 bits represent the length of the original message.\
    \ All bits\n *   in between should be 0. This helper function will pad the\n *\
    \   message according to those rules by filling the Message_Block\n *   array\
    \ accordingly. When it returns, it can be assumed that the\n *   message digest\
    \ has been computed.\n *\n * Parameters:\n *   context: [in/out]\n *     The context\
    \ to pad\n *   Pad_Byte: [in]\n *     The last byte to add to the digest before\
    \ the 0-padding\n *     and length. This will contain the last bits of the message\n\
    \ *     followed by another single bit. If the message was an\n *     exact multiple\
    \ of 8-bits long, Pad_Byte will be 0x80.\n *\n * Returns:\n *   Nothing.\n */\n"
- title: static void SHA1PadMessage(SHA1Context *context, uint8_t Pad_Byte)
  contents:
  - 'static void SHA1PadMessage(SHA1Context *context, uint8_t Pad_Byte)

    '
- title: '{'
  contents:
  - "{\n  /*\n   * Check to see if the current message block is too small to hold\n\
    \   * the initial padding bits and length. If so, we will pad the\n   * block,\
    \ process it, and then continue padding into a second\n   * block.\n   */\n  if\
    \ (context->Message_Block_Index >= (SHA1_Message_Block_Size - 8)) {\n    context->Message_Block[context->Message_Block_Index++]\
    \ = Pad_Byte;\n    while (context->Message_Block_Index < SHA1_Message_Block_Size)\n\
    \      context->Message_Block[context->Message_Block_Index++] = 0;\n    SHA1ProcessMessageBlock(context);\n\
    \  } else\n    context->Message_Block[context->Message_Block_Index++] = Pad_Byte;\n\
    \  while (context->Message_Block_Index < (SHA1_Message_Block_Size - 8))\n    context->Message_Block[context->Message_Block_Index++]\
    \ = 0;\n  /*\n   * Store the message length as the last 8 octets\n   */\n  context->Message_Block[56]\
    \ = (uint8_t) (context->Length_High >> 24);\n  context->Message_Block[57] = (uint8_t)\
    \ (context->Length_High >> 16);\n  context->Message_Block[58] = (uint8_t) (context->Length_High\
    \ >> 8);\n  context->Message_Block[59] = (uint8_t) (context->Length_High);\n \
    \ context->Message_Block[60] = (uint8_t) (context->Length_Low >> 24);\n  context->Message_Block[61]\
    \ = (uint8_t) (context->Length_Low >> 16);\n  context->Message_Block[62] = (uint8_t)\
    \ (context->Length_Low >> 8);\n  context->Message_Block[63] = (uint8_t) (context->Length_Low);\n\
    \  SHA1ProcessMessageBlock(context);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA1ProcessMessageBlock\n *\n * Description:\n *   This helper function\
    \ will process the next 512 bits of the\n *   message stored in the Message_Block\
    \ array.\n *\n * Parameters:\n *   None.\n *\n * Returns:\n *   Nothing.\n *\n\
    \ * Comments:\n *   Many of the variable names in this code, especially the\n\
    \ *   single character names, were used because those were the\n *   names used\
    \ in the publication.\n */\n"
- title: static void SHA1ProcessMessageBlock(SHA1Context *context)
  contents:
  - 'static void SHA1ProcessMessageBlock(SHA1Context *context)

    '
- title: '{'
  contents:
  - "{\n  /* Constants defined in FIPS-180-2, section 4.2.1 */\n  const uint32_t K[4]\
    \ = {\n      0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6\n  };\n  int     \
    \   t;               /* Loop counter */\n  uint32_t   temp;            /* Temporary\
    \ word value */\n  uint32_t   W[80];           /* Word sequence */\n  uint32_t\
    \   A, B, C, D, E;   /* Word buffers */\n  /*\n   * Initialize the first 16 words\
    \ in the array W\n   */\n  for (t = 0; t < 16; t++) {\n    W[t]  = ((uint32_t)context->Message_Block[t\
    \ * 4]) << 24;\n    W[t] |= ((uint32_t)context->Message_Block[t * 4 + 1]) << 16;\n\
    \    W[t] |= ((uint32_t)context->Message_Block[t * 4 + 2]) << 8;\n    W[t] |=\
    \ ((uint32_t)context->Message_Block[t * 4 + 3]);\n  }\n  for (t = 16; t < 80;\
    \ t++)\n    W[t] = SHA1_ROTL(1, W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);\n  A = context->Intermediate_Hash[0];\n\
    \  B = context->Intermediate_Hash[1];\n  C = context->Intermediate_Hash[2];\n\
    \  D = context->Intermediate_Hash[3];\n  E = context->Intermediate_Hash[4];\n\
    \  for (t = 0; t < 20; t++) {\n    temp = SHA1_ROTL(5,A) + SHA_Ch(B, C, D) + E\
    \ + W[t] + K[0];\n    E = D;\n    D = C;\n    C = SHA1_ROTL(30,B);\n    B = A;\n\
    \    A = temp;\n  }\n  for (t = 20; t < 40; t++) {\n    temp = SHA1_ROTL(5,A)\
    \ + SHA_Parity(B, C, D) + E + W[t] + K[1];\n    E = D;\n    D = C;\n    C = SHA1_ROTL(30,B);\n\
    \    B = A;\n    A = temp;\n  }\n  for (t = 40; t < 60; t++) {\n    temp = SHA1_ROTL(5,A)\
    \ + SHA_Maj(B, C, D) + E + W[t] + K[2];\n    E = D;\n    D = C;\n    C = SHA1_ROTL(30,B);\n\
    \    B = A;\n    A = temp;\n  }\n  for (t = 60; t < 80; t++) {\n    temp = SHA1_ROTL(5,A)\
    \ + SHA_Parity(B, C, D) + E + W[t] + K[3];\n    E = D;\n    D = C;\n    C = SHA1_ROTL(30,B);\n\
    \    B = A;\n    A = temp;\n  }\n  context->Intermediate_Hash[0] += A;\n  context->Intermediate_Hash[1]\
    \ += B;\n  context->Intermediate_Hash[2] += C;\n  context->Intermediate_Hash[3]\
    \ += D;\n  context->Intermediate_Hash[4] += E;\n  context->Message_Block_Index\
    \ = 0;\n"
- title: '}'
  contents:
  - '}

    '
- title: 8.2.2.  sha224-256.c
  contents:
  - '8.2.2.  sha224-256.c

    '
- title: /*************************** sha224-256.c ***************************/
  contents:
  - '/*************************** sha224-256.c ***************************/

    '
- title: /********************* See RFC 4634 for details *********************/
  contents:
  - '/********************* See RFC 4634 for details *********************/

    '
- title: /*
  contents:
  - "/*\n * Description:\n *   This file implements the Secure Hash Signature Standard\n\
    \ *   algorithms as defined in the National Institute of Standards\n *   and Technology\
    \ Federal Information Processing Standards\n *   Publication (FIPS PUB) 180-1\
    \ published on April 17, 1995, 180-2\n *   published on August 1, 2002, and the\
    \ FIPS PUB 180-2 Change\n *   Notice published on February 28, 2004.\n *\n * \
    \  A combined document showing all algorithms is available at\n *       http://csrc.nist.gov/publications/fips/\n\
    \ *       fips180-2/fips180-2withchangenotice.pdf\n *\n *   The SHA-224 and SHA-256\
    \ algorithms produce 224-bit and 256-bit\n *   message digests for a given data\
    \ stream. It should take about\n *   2**n steps to find a message with the same\
    \ digest as a given\n *   message and 2**(n/2) to find any two messages with the\
    \ same\n *   digest, when n is the digest size in bits. Therefore, this\n *  \
    \ algorithm can serve as a means of providing a\n *   \"fingerprint\" for a message.\n\
    \ *\n * Portability Issues:\n *   SHA-224 and SHA-256 are defined in terms of\
    \ 32-bit \"words\".\n *   This code uses <stdint.h> (included via \"sha.h\") to\
    \ define 32\n *   and 8 bit unsigned integer types. If your C compiler does not\n\
    \ *   support 32 bit unsigned integers, this code is not\n *   appropriate.\n\
    \ *\n * Caveats:\n *   SHA-224 and SHA-256 are designed to work with messages\
    \ less\n *   than 2^64 bits long. This implementation uses SHA224/256Input()\n\
    \ *   to hash the bits that are a multiple of the size of an 8-bit\n *   character,\
    \ and then uses SHA224/256FinalBits() to hash the\n *   final few bits of the\
    \ input.\n */\n"
- title: '#include "sha.h"'
  contents:
  - '#include "sha.h"

    '
- title: '#include "sha-private.h"'
  contents:
  - '#include "sha-private.h"

    '
- title: /* Define the SHA shift, rotate left and rotate right macro */
  contents:
  - '/* Define the SHA shift, rotate left and rotate right macro */

    '
- title: '#define SHA256_SHR(bits,word)      ((word) >> (bits))'
  contents:
  - '#define SHA256_SHR(bits,word)      ((word) >> (bits))

    '
- title: '#define SHA256_ROTL(bits,word)                         \'
  contents:
  - "#define SHA256_ROTL(bits,word)                         \\\n  (((word) << (bits))\
    \ | ((word) >> (32-(bits))))\n"
- title: '#define SHA256_ROTR(bits,word)                         \'
  contents:
  - "#define SHA256_ROTR(bits,word)                         \\\n  (((word) >> (bits))\
    \ | ((word) << (32-(bits))))\n"
- title: /* Define the SHA SIGMA and sigma macros */
  contents:
  - '/* Define the SHA SIGMA and sigma macros */

    '
- title: '#define SHA256_SIGMA0(word)   \'
  contents:
  - "#define SHA256_SIGMA0(word)   \\\n  (SHA256_ROTR( 2,word) ^ SHA256_ROTR(13,word)\
    \ ^ SHA256_ROTR(22,word))\n"
- title: '#define SHA256_SIGMA1(word)   \'
  contents:
  - "#define SHA256_SIGMA1(word)   \\\n  (SHA256_ROTR( 6,word) ^ SHA256_ROTR(11,word)\
    \ ^ SHA256_ROTR(25,word))\n"
- title: '#define SHA256_sigma0(word)   \'
  contents:
  - "#define SHA256_sigma0(word)   \\\n  (SHA256_ROTR( 7,word) ^ SHA256_ROTR(18,word)\
    \ ^ SHA256_SHR( 3,word))\n"
- title: '#define SHA256_sigma1(word)   \'
  contents:
  - "#define SHA256_sigma1(word)   \\\n  (SHA256_ROTR(17,word) ^ SHA256_ROTR(19,word)\
    \ ^ SHA256_SHR(10,word))\n"
- title: /*
  contents:
  - "/*\n * add \"length\" to the length\n */\n"
- title: static uint32_t addTemp;
  contents:
  - 'static uint32_t addTemp;

    '
- title: '#define SHA224_256AddLength(context, length)               \'
  contents:
  - "#define SHA224_256AddLength(context, length)               \\\n  (addTemp = (context)->Length_Low,\
    \ (context)->Corrupted = \\\n    (((context)->Length_Low += (length)) < addTemp)\
    \ &&     \\\n    (++(context)->Length_High == 0) ? 1 : 0)\n"
- title: /* Local Function Prototypes */
  contents:
  - '/* Local Function Prototypes */

    '
- title: static void SHA224_256Finalize(SHA256Context *context,
  contents:
  - "static void SHA224_256Finalize(SHA256Context *context,\n  uint8_t Pad_Byte);\n"
- title: static void SHA224_256PadMessage(SHA256Context *context,
  contents:
  - "static void SHA224_256PadMessage(SHA256Context *context,\n  uint8_t Pad_Byte);\n"
- title: static void SHA224_256ProcessMessageBlock(SHA256Context *context);
  contents:
  - 'static void SHA224_256ProcessMessageBlock(SHA256Context *context);

    '
- title: static int SHA224_256Reset(SHA256Context *context, uint32_t *H0);
  contents:
  - 'static int SHA224_256Reset(SHA256Context *context, uint32_t *H0);

    '
- title: static int SHA224_256ResultN(SHA256Context *context,
  contents:
  - "static int SHA224_256ResultN(SHA256Context *context,\n  uint8_t Message_Digest[],\
    \ int HashSize);\n"
- title: '/* Initial Hash Values: FIPS-180-2 Change Notice 1 */'
  contents:
  - '/* Initial Hash Values: FIPS-180-2 Change Notice 1 */

    '
- title: static uint32_t SHA224_H0[SHA256HashSize/4] = {
  contents:
  - "static uint32_t SHA224_H0[SHA256HashSize/4] = {\n    0xC1059ED8, 0x367CD507,\
    \ 0x3070DD17, 0xF70E5939,\n    0xFFC00B31, 0x68581511, 0x64F98FA7, 0xBEFA4FA4\n"
- title: '};'
  contents:
  - '};

    '
- title: '/* Initial Hash Values: FIPS-180-2 section 5.3.2 */'
  contents:
  - '/* Initial Hash Values: FIPS-180-2 section 5.3.2 */

    '
- title: static uint32_t SHA256_H0[SHA256HashSize/4] = {
  contents:
  - "static uint32_t SHA256_H0[SHA256HashSize/4] = {\n  0x6A09E667, 0xBB67AE85, 0x3C6EF372,\
    \ 0xA54FF53A,\n  0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\n"
- title: '};'
  contents:
  - '};

    '
- title: /*
  contents:
  - "/*\n * SHA224Reset\n *\n * Description:\n *   This function will initialize the\
    \ SHA384Context in preparation\n *   for computing a new SHA224 message digest.\n\
    \ *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *\n\
    \ * Returns:\n *   sha Error Code.\n */\n"
- title: int SHA224Reset(SHA224Context *context)
  contents:
  - 'int SHA224Reset(SHA224Context *context)

    '
- title: '{'
  contents:
  - "{\n  return SHA224_256Reset(context, SHA224_H0);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA224Input\n *\n * Description:\n *   This function accepts an array\
    \ of octets as the next portion\n *   of the message.\n *\n * Parameters:\n *\
    \   context: [in/out]\n *     The SHA context to update\n *   message_array: [in]\n\
    \ *     An array of characters representing the next portion of\n *     the message.\n\
    \ *   length: [in]\n *     The length of the message in message_array\n *\n *\
    \ Returns:\n *   sha Error Code.\n *\n */\n"
- title: int SHA224Input(SHA224Context *context, const uint8_t *message_array,
  contents:
  - "int SHA224Input(SHA224Context *context, const uint8_t *message_array,\n    unsigned\
    \ int length)\n"
- title: '{'
  contents:
  - "{\n  return SHA256Input(context, message_array, length);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA224FinalBits\n *\n * Description:\n *   This function will add in any\
    \ final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n * \
    \    The SHA context to update\n *   message_bits: [in]\n *     The final bits\
    \ of the message, in the upper portion of the\n *     byte. (Use 0b###00000 instead\
    \ of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n * \
    \    The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *\
    \   sha Error Code.\n */\n"
- title: int SHA224FinalBits( SHA224Context *context,
  contents:
  - "int SHA224FinalBits( SHA224Context *context,\n    const uint8_t message_bits,\
    \ unsigned int length)\n"
- title: '{'
  contents:
  - "{\n  return SHA256FinalBits(context, message_bits, length);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA224Result\n *\n * Description:\n *   This function will return the\
    \ 224-bit message\n *   digest into the Message_Digest array provided by the caller.\n\
    \ *   NOTE: The first octet of hash is stored in the 0th element,\n *      the\
    \ last octet of hash in the 28th element.\n *\n * Parameters:\n *   context: [in/out]\n\
    \ *     The context to use to calculate the SHA hash.\n *   Message_Digest: [out]\n\
    \ *     Where the digest is returned.\n *\n * Returns:\n *   sha Error Code.\n\
    \ */\n"
- title: int SHA224Result(SHA224Context *context,
  contents:
  - "int SHA224Result(SHA224Context *context,\n    uint8_t Message_Digest[SHA224HashSize])\n"
- title: '{'
  contents:
  - "{\n  return SHA224_256ResultN(context, Message_Digest, SHA224HashSize);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA256Reset\n *\n * Description:\n *   This function will initialize the\
    \ SHA256Context in preparation\n *   for computing a new SHA256 message digest.\n\
    \ *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *\n\
    \ * Returns:\n *   sha Error Code.\n */\n"
- title: int SHA256Reset(SHA256Context *context)
  contents:
  - 'int SHA256Reset(SHA256Context *context)

    '
- title: '{'
  contents:
  - "{\n  return SHA224_256Reset(context, SHA256_H0);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA256Input\n *\n * Description:\n *   This function accepts an array\
    \ of octets as the next portion\n *   of the message.\n *\n * Parameters:\n *\
    \   context: [in/out]\n *     The SHA context to update\n *   message_array: [in]\n\
    \ *     An array of characters representing the next portion of\n *     the message.\n\
    \ *   length: [in]\n *     The length of the message in message_array\n *\n *\
    \ Returns:\n *   sha Error Code.\n */\n"
- title: int SHA256Input(SHA256Context *context, const uint8_t *message_array,
  contents:
  - "int SHA256Input(SHA256Context *context, const uint8_t *message_array,\n    unsigned\
    \ int length)\n"
- title: '{'
  contents:
  - "{\n  if (!length)\n    return shaSuccess;\n  if (!context || !message_array)\n\
    \    return shaNull;\n  if (context->Computed) {\n    context->Corrupted = shaStateError;\n\
    \    return shaStateError;\n  }\n  if (context->Corrupted)\n     return context->Corrupted;\n\
    \  while (length-- && !context->Corrupted) {\n    context->Message_Block[context->Message_Block_Index++]\
    \ =\n            (*message_array & 0xFF);\n    if (!SHA224_256AddLength(context,\
    \ 8) &&\n      (context->Message_Block_Index == SHA256_Message_Block_Size))\n\
    \      SHA224_256ProcessMessageBlock(context);\n    message_array++;\n  }\n  return\
    \ shaSuccess;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA256FinalBits\n *\n * Description:\n *   This function will add in any\
    \ final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n * \
    \    The SHA context to update\n *   message_bits: [in]\n *     The final bits\
    \ of the message, in the upper portion of the\n *     byte. (Use 0b###00000 instead\
    \ of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n * \
    \    The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *\
    \   sha Error Code.\n */\n"
- title: int SHA256FinalBits(SHA256Context *context,
  contents:
  - "int SHA256FinalBits(SHA256Context *context,\n    const uint8_t message_bits,\
    \ unsigned int length)\n"
- title: '{'
  contents:
  - "{\n  uint8_t masks[8] = {\n      /* 0 0b00000000 */ 0x00, /* 1 0b10000000 */\
    \ 0x80,\n      /* 2 0b11000000 */ 0xC0, /* 3 0b11100000 */ 0xE0,\n      /* 4 0b11110000\
    \ */ 0xF0, /* 5 0b11111000 */ 0xF8,\n      /* 6 0b11111100 */ 0xFC, /* 7 0b11111110\
    \ */ 0xFE\n  };\n  uint8_t markbit[8] = {\n      /* 0 0b10000000 */ 0x80, /* 1\
    \ 0b01000000 */ 0x40,\n      /* 2 0b00100000 */ 0x20, /* 3 0b00010000 */ 0x10,\n\
    \      /* 4 0b00001000 */ 0x08, /* 5 0b00000100 */ 0x04,\n      /* 6 0b00000010\
    \ */ 0x02, /* 7 0b00000001 */ 0x01\n  };\n  if (!length)\n    return shaSuccess;\n\
    \  if (!context)\n    return shaNull;\n  if ((context->Computed) || (length >=\
    \ 8) || (length == 0)) {\n    context->Corrupted = shaStateError;\n    return\
    \ shaStateError;\n  }\n  if (context->Corrupted)\n    return context->Corrupted;\n\
    \  SHA224_256AddLength(context, length);\n  SHA224_256Finalize(context, (uint8_t)\n\
    \    ((message_bits & masks[length]) | markbit[length]));\n  return shaSuccess;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA256Result\n *\n * Description:\n *   This function will return the\
    \ 256-bit message\n *   digest into the Message_Digest array provided by the caller.\n\
    \ *   NOTE: The first octet of hash is stored in the 0th element,\n *      the\
    \ last octet of hash in the 32nd element.\n *\n * Parameters:\n *   context: [in/out]\n\
    \ *     The context to use to calculate the SHA hash.\n *   Message_Digest: [out]\n\
    \ *     Where the digest is returned.\n *\n * Returns:\n *   sha Error Code.\n\
    \ */\n"
- title: int SHA256Result(SHA256Context *context, uint8_t Message_Digest[])
  contents:
  - 'int SHA256Result(SHA256Context *context, uint8_t Message_Digest[])

    '
- title: '{'
  contents:
  - "{\n  return SHA224_256ResultN(context, Message_Digest, SHA256HashSize);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA224_256Finalize\n *\n * Description:\n *   This helper function finishes\
    \ off the digest calculations.\n *\n * Parameters:\n *   context: [in/out]\n *\
    \     The SHA context to update\n *   Pad_Byte: [in]\n *     The last byte to\
    \ add to the digest before the 0-padding\n *     and length. This will contain\
    \ the last bits of the message\n *     followed by another single bit. If the\
    \ message was an\n *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n\
    \ *\n * Returns:\n *   sha Error Code.\n */\n"
- title: static void SHA224_256Finalize(SHA256Context *context,
  contents:
  - "static void SHA224_256Finalize(SHA256Context *context,\n    uint8_t Pad_Byte)\n"
- title: '{'
  contents:
  - "{\n  int i;\n  SHA224_256PadMessage(context, Pad_Byte);\n  /* message may be\
    \ sensitive, so clear it out */\n  for (i = 0; i < SHA256_Message_Block_Size;\
    \ ++i)\n    context->Message_Block[i] = 0;\n  context->Length_Low = 0;  /* and\
    \ clear length */\n  context->Length_High = 0;\n  context->Computed = 1;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA224_256PadMessage\n *\n * Description:\n *   According to the standard,\
    \ the message must be padded to an\n *   even 512 bits. The first padding bit\
    \ must be a '1'. The\n *   last 64 bits represent the length of the original message.\n\
    \ *   All bits in between should be 0. This helper function will pad\n *   the\
    \ message according to those rules by filling the\n *   Message_Block array accordingly.\
    \ When it returns, it can be\n *   assumed that the message digest has been computed.\n\
    \ *\n * Parameters:\n *   context: [in/out]\n *     The context to pad\n *   Pad_Byte:\
    \ [in]\n *     The last byte to add to the digest before the 0-padding\n *   \
    \  and length. This will contain the last bits of the message\n *     followed\
    \ by another single bit. If the message was an\n *     exact multiple of 8-bits\
    \ long, Pad_Byte will be 0x80.\n *\n * Returns:\n *   Nothing.\n */\n"
- title: static void SHA224_256PadMessage(SHA256Context *context,
  contents:
  - "static void SHA224_256PadMessage(SHA256Context *context,\n    uint8_t Pad_Byte)\n"
- title: '{'
  contents:
  - "{\n  /*\n   * Check to see if the current message block is too small to hold\n\
    \   * the initial padding bits and length. If so, we will pad the\n   * block,\
    \ process it, and then continue padding into a second\n   * block.\n   */\n  if\
    \ (context->Message_Block_Index >= (SHA256_Message_Block_Size-8)) {\n    context->Message_Block[context->Message_Block_Index++]\
    \ = Pad_Byte;\n    while (context->Message_Block_Index < SHA256_Message_Block_Size)\n\
    \      context->Message_Block[context->Message_Block_Index++] = 0;\n    SHA224_256ProcessMessageBlock(context);\n\
    \  } else\n    context->Message_Block[context->Message_Block_Index++] = Pad_Byte;\n\
    \  while (context->Message_Block_Index < (SHA256_Message_Block_Size-8))\n    context->Message_Block[context->Message_Block_Index++]\
    \ = 0;\n  /*\n   * Store the message length as the last 8 octets\n   */\n  context->Message_Block[56]\
    \ = (uint8_t)(context->Length_High >> 24);\n  context->Message_Block[57] = (uint8_t)(context->Length_High\
    \ >> 16);\n  context->Message_Block[58] = (uint8_t)(context->Length_High >> 8);\n\
    \  context->Message_Block[59] = (uint8_t)(context->Length_High);\n  context->Message_Block[60]\
    \ = (uint8_t)(context->Length_Low >> 24);\n  context->Message_Block[61] = (uint8_t)(context->Length_Low\
    \ >> 16);\n  context->Message_Block[62] = (uint8_t)(context->Length_Low >> 8);\n\
    \  context->Message_Block[63] = (uint8_t)(context->Length_Low);\n  SHA224_256ProcessMessageBlock(context);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA224_256ProcessMessageBlock\n *\n * Description:\n *   This function\
    \ will process the next 512 bits of the message\n *   stored in the Message_Block\
    \ array.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to\
    \ update\n *\n * Returns:\n *   Nothing.\n *\n * Comments:\n *   Many of the variable\
    \ names in this code, especially the\n *   single character names, were used because\
    \ those were the\n *   names used in the publication.\n */\n"
- title: static void SHA224_256ProcessMessageBlock(SHA256Context *context)
  contents:
  - 'static void SHA224_256ProcessMessageBlock(SHA256Context *context)

    '
- title: '{'
  contents:
  - "{\n  /* Constants defined in FIPS-180-2, section 4.2.2 */\n  static const uint32_t\
    \ K[64] = {\n      0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,\n\
    \      0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,\n      0x243185be,\
    \ 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,\n      0xc19bf174, 0xe49b69c1,\
    \ 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n      0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc,\
    \ 0x76f988da, 0x983e5152,\n      0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3,\
    \ 0xd5a79147,\n      0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n\
    \      0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n      0xa2bfe8a1,\
    \ 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n      0xd6990624, 0xf40e3585,\
    \ 0x106aa070, 0x19a4c116, 0x1e376c08,\n      0x2748774c, 0x34b0bcb5, 0x391c0cb3,\
    \ 0x4ed8aa4a, 0x5b9cca4f,\n      0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814,\
    \ 0x8cc70208,\n      0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n  };\n  int\
    \        t, t4;                   /* Loop counter */\n  uint32_t   temp1, temp2;\
    \            /* Temporary word value */\n  uint32_t   W[64];                 \
    \  /* Word sequence */\n  uint32_t   A, B, C, D, E, F, G, H;  /* Word buffers\
    \ */\n  /*\n   * Initialize the first 16 words in the array W\n   */\n  for (t\
    \ = t4 = 0; t < 16; t++, t4 += 4)\n    W[t] = (((uint32_t)context->Message_Block[t4])\
    \ << 24) |\n           (((uint32_t)context->Message_Block[t4 + 1]) << 16) |\n\
    \           (((uint32_t)context->Message_Block[t4 + 2]) << 8) |\n           (((uint32_t)context->Message_Block[t4\
    \ + 3]));\n  for (t = 16; t < 64; t++)\n    W[t] = SHA256_sigma1(W[t-2]) + W[t-7]\
    \ +\n        SHA256_sigma0(W[t-15]) + W[t-16];\n  A = context->Intermediate_Hash[0];\n\
    \  B = context->Intermediate_Hash[1];\n  C = context->Intermediate_Hash[2];\n\
    \  D = context->Intermediate_Hash[3];\n  E = context->Intermediate_Hash[4];\n\
    \  F = context->Intermediate_Hash[5];\n  G = context->Intermediate_Hash[6];\n\
    \  H = context->Intermediate_Hash[7];\n  for (t = 0; t < 64; t++) {\n    temp1\
    \ = H + SHA256_SIGMA1(E) + SHA_Ch(E,F,G) + K[t] + W[t];\n    temp2 = SHA256_SIGMA0(A)\
    \ + SHA_Maj(A,B,C);\n    H = G;\n    G = F;\n    F = E;\n    E = D + temp1;\n\
    \    D = C;\n    C = B;\n    B = A;\n    A = temp1 + temp2;\n  }\n  context->Intermediate_Hash[0]\
    \ += A;\n  context->Intermediate_Hash[1] += B;\n  context->Intermediate_Hash[2]\
    \ += C;\n  context->Intermediate_Hash[3] += D;\n  context->Intermediate_Hash[4]\
    \ += E;\n  context->Intermediate_Hash[5] += F;\n  context->Intermediate_Hash[6]\
    \ += G;\n  context->Intermediate_Hash[7] += H;\n  context->Message_Block_Index\
    \ = 0;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA224_256Reset\n *\n * Description:\n *   This helper function will initialize\
    \ the SHA256Context in\n *   preparation for computing a new SHA256 message digest.\n\
    \ *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *\
    \   H0\n *     The initial hash value to use.\n *\n * Returns:\n *   sha Error\
    \ Code.\n */\n"
- title: static int SHA224_256Reset(SHA256Context *context, uint32_t *H0)
  contents:
  - 'static int SHA224_256Reset(SHA256Context *context, uint32_t *H0)

    '
- title: '{'
  contents:
  - "{\n  if (!context)\n    return shaNull;\n  context->Length_Low           = 0;\n\
    \  context->Length_High          = 0;\n  context->Message_Block_Index  = 0;\n\
    \  context->Intermediate_Hash[0] = H0[0];\n  context->Intermediate_Hash[1] = H0[1];\n\
    \  context->Intermediate_Hash[2] = H0[2];\n  context->Intermediate_Hash[3] = H0[3];\n\
    \  context->Intermediate_Hash[4] = H0[4];\n  context->Intermediate_Hash[5] = H0[5];\n\
    \  context->Intermediate_Hash[6] = H0[6];\n  context->Intermediate_Hash[7] = H0[7];\n\
    \  context->Computed  = 0;\n  context->Corrupted = 0;\n  return shaSuccess;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA224_256ResultN\n *\n * Description:\n *   This helper function will\
    \ return the 224-bit or 256-bit message\n *   digest into the Message_Digest array\
    \ provided by the caller.\n *   NOTE: The first octet of hash is stored in the\
    \ 0th element,\n *      the last octet of hash in the 28th/32nd element.\n *\n\
    \ * Parameters:\n *   context: [in/out]\n *     The context to use to calculate\
    \ the SHA hash.\n *   Message_Digest: [out]\n *     Where the digest is returned.\n\
    \ *   HashSize: [in]\n *     The size of the hash, either 28 or 32.\n *\n * Returns:\n\
    \ *   sha Error Code.\n */\n"
- title: static int SHA224_256ResultN(SHA256Context *context,
  contents:
  - "static int SHA224_256ResultN(SHA256Context *context,\n    uint8_t Message_Digest[],\
    \ int HashSize)\n"
- title: '{'
  contents:
  - "{\n  int i;\n  if (!context || !Message_Digest)\n    return shaNull;\n  if (context->Corrupted)\n\
    \    return context->Corrupted;\n  if (!context->Computed)\n    SHA224_256Finalize(context,\
    \ 0x80);\n  for (i = 0; i < HashSize; ++i)\n    Message_Digest[i] = (uint8_t)\n\
    \      (context->Intermediate_Hash[i>>2] >> 8 * ( 3 - ( i & 0x03 ) ));\n  return\
    \ shaSuccess;\n"
- title: '}'
  contents:
  - '}

    '
- title: 8.2.3.  sha384-512.c
  contents:
  - '8.2.3.  sha384-512.c

    '
- title: /*************************** sha384-512.c ***************************/
  contents:
  - '/*************************** sha384-512.c ***************************/

    '
- title: /********************* See RFC 4634 for details *********************/
  contents:
  - '/********************* See RFC 4634 for details *********************/

    '
- title: /*
  contents:
  - "/*\n * Description:\n *   This file implements the Secure Hash Signature Standard\n\
    \ *   algorithms as defined in the National Institute of Standards\n *   and Technology\
    \ Federal Information Processing Standards\n *   Publication (FIPS PUB) 180-1\
    \ published on April 17, 1995, 180-2\n *   published on August 1, 2002, and the\
    \ FIPS PUB 180-2 Change\n *   Notice published on February 28, 2004.\n *\n * \
    \  A combined document showing all algorithms is available at\n *       http://csrc.nist.gov/publications/fips/\n\
    \ *       fips180-2/fips180-2withchangenotice.pdf\n *\n *   The SHA-384 and SHA-512\
    \ algorithms produce 384-bit and 512-bit\n *   message digests for a given data\
    \ stream. It should take about\n *   2**n steps to find a message with the same\
    \ digest as a given\n *   message and 2**(n/2) to find any two messages with the\
    \ same\n *   digest, when n is the digest size in bits. Therefore, this\n *  \
    \ algorithm can serve as a means of providing a\n *   \"fingerprint\" for a message.\n\
    \ *\n * Portability Issues:\n *   SHA-384 and SHA-512 are defined in terms of\
    \ 64-bit \"words\",\n *   but if USE_32BIT_ONLY is #defined, this code is implemented\
    \ in\n *   terms of 32-bit \"words\". This code uses <stdint.h> (included\n *\
    \   via \"sha.h\") to define the 64, 32 and 8 bit unsigned integer\n *   types.\
    \ If your C compiler does not support 64 bit unsigned\n *   integers, and you\
    \ do not #define USE_32BIT_ONLY, this code is\n *   not appropriate.\n *\n * Caveats:\n\
    \ *   SHA-384 and SHA-512 are designed to work with messages less\n *   than 2^128\
    \ bits long. This implementation uses\n *   SHA384/512Input() to hash the bits\
    \ that are a multiple of the\n *   size of an 8-bit character, and then uses SHA384/256FinalBits()\n\
    \ *   to hash the final few bits of the input.\n *\n */\n"
- title: '#include "sha.h"'
  contents:
  - '#include "sha.h"

    '
- title: '#include "sha-private.h"'
  contents:
  - '#include "sha-private.h"

    '
- title: '#ifdef USE_32BIT_ONLY'
  contents:
  - '#ifdef USE_32BIT_ONLY

    '
- title: /*
  contents:
  - "/*\n * Define 64-bit arithmetic in terms of 32-bit arithmetic.\n * Each 64-bit\
    \ number is represented in a 2-word array.\n * All macros are defined such that\
    \ the result is the last parameter.\n */\n"
- title: /*
  contents:
  - "/*\n * Define shift, rotate left and rotate right functions\n */\n"
- title: '#define SHA512_SHR(bits, word, ret) (                          \'
  contents:
  - "#define SHA512_SHR(bits, word, ret) (                          \\\n    /* (((uint64_t)((word)))\
    \ >> (bits)) */                     \\\n    (ret)[0] = (((bits) < 32) && ((bits)\
    \ >= 0)) ?              \\\n      ((word)[0] >> (bits)) : 0,                 \
    \              \\\n    (ret)[1] = ((bits) > 32) ? ((word)[0] >> ((bits) - 32))\
    \ :  \\\n      ((bits) == 32) ? (word)[0] :                             \\\n \
    \     ((bits) >= 0) ?                                          \\\n        (((word)[0]\
    \ << (32 - (bits))) |                        \\\n        ((word)[1] >> (bits)))\
    \ : 0 )\n"
- title: '#define SHA512_SHL(bits, word, ret) (                          \'
  contents:
  - "#define SHA512_SHL(bits, word, ret) (                          \\\n    /* (((uint64_t)(word))\
    \ << (bits)) */                       \\\n    (ret)[0] = ((bits) > 32) ? ((word)[1]\
    \ << ((bits) - 32)) :  \\\n         ((bits) == 32) ? (word)[1] :             \
    \             \\\n         ((bits) >= 0) ?                                   \
    \    \\\n           (((word)[0] << (bits)) |                            \\\n \
    \          ((word)[1] >> (32 - (bits)))) :                     \\\n         0,\
    \                                                    \\\n    (ret)[1] = (((bits)\
    \ < 32) && ((bits) >= 0)) ?              \\\n        ((word)[1] << (bits)) : 0\
    \ )\n"
- title: /*
  contents:
  - "/*\n * Define 64-bit OR\n */\n"
- title: '#define SHA512_OR(word1, word2, ret) (                         \'
  contents:
  - "#define SHA512_OR(word1, word2, ret) (                         \\\n    (ret)[0]\
    \ = (word1)[0] | (word2)[0],                        \\\n    (ret)[1] = (word1)[1]\
    \ | (word2)[1] )\n"
- title: /*
  contents:
  - "/*\n * Define 64-bit XOR\n */\n"
- title: '#define SHA512_XOR(word1, word2, ret) (                        \'
  contents:
  - "#define SHA512_XOR(word1, word2, ret) (                        \\\n    (ret)[0]\
    \ = (word1)[0] ^ (word2)[0],                        \\\n    (ret)[1] = (word1)[1]\
    \ ^ (word2)[1] )\n"
- title: /*
  contents:
  - "/*\n * Define 64-bit AND\n */\n"
- title: '#define SHA512_AND(word1, word2, ret) (                        \'
  contents:
  - "#define SHA512_AND(word1, word2, ret) (                        \\\n    (ret)[0]\
    \ = (word1)[0] & (word2)[0],                        \\\n    (ret)[1] = (word1)[1]\
    \ & (word2)[1] )\n"
- title: /*
  contents:
  - "/*\n * Define 64-bit TILDA\n */\n"
- title: '#define SHA512_TILDA(word, ret)                                \'
  contents:
  - "#define SHA512_TILDA(word, ret)                                \\\n  ( (ret)[0]\
    \ = ~(word)[0], (ret)[1] = ~(word)[1] )\n"
- title: /*
  contents:
  - "/*\n * Define 64-bit ADD\n */\n"
- title: '#define SHA512_ADD(word1, word2, ret) (                        \'
  contents:
  - "#define SHA512_ADD(word1, word2, ret) (                        \\\n    (ret)[1]\
    \ = (word1)[1], (ret)[1] += (word2)[1],             \\\n    (ret)[0] = (word1)[0]\
    \ + (word2)[0] + ((ret)[1] < (word1)[1]) )\n"
- title: /*
  contents:
  - "/*\n * Add the 4word value in word2 to word1.\n */\n"
- title: static uint32_t ADDTO4_temp, ADDTO4_temp2;
  contents:
  - 'static uint32_t ADDTO4_temp, ADDTO4_temp2;

    '
- title: '#define SHA512_ADDTO4(word1, word2) (                          \'
  contents:
  - "#define SHA512_ADDTO4(word1, word2) (                          \\\n    ADDTO4_temp\
    \ = (word1)[3],                                  \\\n    (word1)[3] += (word2)[3],\
    \                                  \\\n    ADDTO4_temp2 = (word1)[2],        \
    \                         \\\n    (word1)[2] += (word2)[2] + ((word1)[3] < ADDTO4_temp),\
    \     \\\n    ADDTO4_temp = (word1)[1],                                  \\\n\
    \    (word1)[1] += (word2)[1] + ((word1)[2] < ADDTO4_temp2),    \\\n    (word1)[0]\
    \ += (word2)[0] + ((word1)[1] < ADDTO4_temp) )\n"
- title: /*
  contents:
  - "/*\n * Add the 2word value in word2 to word1.\n */\n"
- title: static uint32_t ADDTO2_temp;
  contents:
  - 'static uint32_t ADDTO2_temp;

    '
- title: '#define SHA512_ADDTO2(word1, word2) (                          \'
  contents:
  - "#define SHA512_ADDTO2(word1, word2) (                          \\\n    ADDTO2_temp\
    \ = (word1)[1],                                  \\\n    (word1)[1] += (word2)[1],\
    \                                  \\\n    (word1)[0] += (word2)[0] + ((word1)[1]\
    \ < ADDTO2_temp) )\n"
- title: /*
  contents:
  - "/*\n * SHA rotate   ((word >> bits) | (word << (64-bits)))\n */\n"
- title: static uint32_t ROTR_temp1[2], ROTR_temp2[2];
  contents:
  - 'static uint32_t ROTR_temp1[2], ROTR_temp2[2];

    '
- title: '#define SHA512_ROTR(bits, word, ret) (                         \'
  contents:
  - "#define SHA512_ROTR(bits, word, ret) (                         \\\n    SHA512_SHR((bits),\
    \ (word), ROTR_temp1),                    \\\n    SHA512_SHL(64-(bits), (word),\
    \ ROTR_temp2),                 \\\n    SHA512_OR(ROTR_temp1, ROTR_temp2, (ret))\
    \ )\n"
- title: /*
  contents:
  - "/*\n * Define the SHA SIGMA and sigma macros\n *  SHA512_ROTR(28,word) ^ SHA512_ROTR(34,word)\
    \ ^ SHA512_ROTR(39,word)\n */\n"
- title: static uint32_t SIGMA0_temp1[2], SIGMA0_temp2[2],
  contents:
  - "static uint32_t SIGMA0_temp1[2], SIGMA0_temp2[2],\n  SIGMA0_temp3[2], SIGMA0_temp4[2];\n"
- title: '#define SHA512_SIGMA0(word, ret) (                             \'
  contents:
  - "#define SHA512_SIGMA0(word, ret) (                             \\\n    SHA512_ROTR(28,\
    \ (word), SIGMA0_temp1),                     \\\n    SHA512_ROTR(34, (word), SIGMA0_temp2),\
    \                     \\\n    SHA512_ROTR(39, (word), SIGMA0_temp3),         \
    \            \\\n    SHA512_XOR(SIGMA0_temp2, SIGMA0_temp3, SIGMA0_temp4),   \
    \   \\\n    SHA512_XOR(SIGMA0_temp1, SIGMA0_temp4, (ret)) )\n"
- title: /*
  contents:
  - "/*\n * SHA512_ROTR(14,word) ^ SHA512_ROTR(18,word) ^ SHA512_ROTR(41,word)\n */\n"
- title: static uint32_t SIGMA1_temp1[2], SIGMA1_temp2[2],
  contents:
  - "static uint32_t SIGMA1_temp1[2], SIGMA1_temp2[2],\n  SIGMA1_temp3[2], SIGMA1_temp4[2];\n"
- title: '#define SHA512_SIGMA1(word, ret) (                             \'
  contents:
  - "#define SHA512_SIGMA1(word, ret) (                             \\\n    SHA512_ROTR(14,\
    \ (word), SIGMA1_temp1),                     \\\n    SHA512_ROTR(18, (word), SIGMA1_temp2),\
    \                     \\\n    SHA512_ROTR(41, (word), SIGMA1_temp3),         \
    \            \\\n    SHA512_XOR(SIGMA1_temp2, SIGMA1_temp3, SIGMA1_temp4),   \
    \   \\\n    SHA512_XOR(SIGMA1_temp1, SIGMA1_temp4, (ret)) )\n"
- title: /*
  contents:
  - "/*\n * (SHA512_ROTR( 1,word) ^ SHA512_ROTR( 8,word) ^ SHA512_SHR( 7,word))\n\
    \ */\n"
- title: static uint32_t sigma0_temp1[2], sigma0_temp2[2],
  contents:
  - "static uint32_t sigma0_temp1[2], sigma0_temp2[2],\n  sigma0_temp3[2], sigma0_temp4[2];\n"
- title: '#define SHA512_sigma0(word, ret) (                             \'
  contents:
  - "#define SHA512_sigma0(word, ret) (                             \\\n    SHA512_ROTR(\
    \ 1, (word), sigma0_temp1),                     \\\n    SHA512_ROTR( 8, (word),\
    \ sigma0_temp2),                     \\\n    SHA512_SHR( 7, (word), sigma0_temp3),\
    \                      \\\n    SHA512_XOR(sigma0_temp2, sigma0_temp3, sigma0_temp4),\
    \      \\\n    SHA512_XOR(sigma0_temp1, sigma0_temp4, (ret)) )\n"
- title: /*
  contents:
  - "/*\n * (SHA512_ROTR(19,word) ^ SHA512_ROTR(61,word) ^ SHA512_SHR( 6,word))\n\
    \ */\n"
- title: static uint32_t sigma1_temp1[2], sigma1_temp2[2],
  contents:
  - "static uint32_t sigma1_temp1[2], sigma1_temp2[2],\n  sigma1_temp3[2], sigma1_temp4[2];\n"
- title: '#define SHA512_sigma1(word, ret) (                             \'
  contents:
  - "#define SHA512_sigma1(word, ret) (                             \\\n    SHA512_ROTR(19,\
    \ (word), sigma1_temp1),                     \\\n    SHA512_ROTR(61, (word), sigma1_temp2),\
    \                     \\\n    SHA512_SHR( 6, (word), sigma1_temp3),          \
    \            \\\n    SHA512_XOR(sigma1_temp2, sigma1_temp3, sigma1_temp4),   \
    \   \\\n    SHA512_XOR(sigma1_temp1, sigma1_temp4, (ret)) )\n"
- title: '#undef SHA_Ch'
  contents:
  - '#undef SHA_Ch

    '
- title: '#undef SHA_Maj'
  contents:
  - '#undef SHA_Maj

    '
- title: '#ifndef USE_MODIFIED_MACROS'
  contents:
  - '#ifndef USE_MODIFIED_MACROS

    '
- title: /*
  contents:
  - "/*\n * These definitions are the ones used in FIPS-180-2, section 4.1.3\n * \
    \ Ch(x,y,z)   ((x & y) ^ (~x & z))\n */\n"
- title: static uint32_t Ch_temp1[2], Ch_temp2[2], Ch_temp3[2];
  contents:
  - 'static uint32_t Ch_temp1[2], Ch_temp2[2], Ch_temp3[2];

    '
- title: '#define SHA_Ch(x, y, z, ret) (                                 \'
  contents:
  - "#define SHA_Ch(x, y, z, ret) (                                 \\\n    SHA512_AND(x,\
    \ y, Ch_temp1),                                \\\n    SHA512_TILDA(x, Ch_temp2),\
    \                                 \\\n    SHA512_AND(Ch_temp2, z, Ch_temp3), \
    \                        \\\n    SHA512_XOR(Ch_temp1, Ch_temp3, (ret)) )\n"
- title: /*
  contents:
  - "/*\n *  Maj(x,y,z)  (((x)&(y)) ^ ((x)&(z)) ^ ((y)&(z)))\n */\n"
- title: static uint32_t Maj_temp1[2], Maj_temp2[2],
  contents:
  - "static uint32_t Maj_temp1[2], Maj_temp2[2],\n  Maj_temp3[2], Maj_temp4[2];\n"
- title: '#define SHA_Maj(x, y, z, ret) (                                \'
  contents:
  - "#define SHA_Maj(x, y, z, ret) (                                \\\n    SHA512_AND(x,\
    \ y, Maj_temp1),                               \\\n    SHA512_AND(x, z, Maj_temp2),\
    \                               \\\n    SHA512_AND(y, z, Maj_temp3),         \
    \                      \\\n    SHA512_XOR(Maj_temp2, Maj_temp3, Maj_temp4),  \
    \             \\\n    SHA512_XOR(Maj_temp1, Maj_temp4, (ret)) )\n"
- title: '#else /* !USE_32BIT_ONLY */'
  contents:
  - '#else /* !USE_32BIT_ONLY */

    '
- title: /*
  contents:
  - "/*\n * These definitions are potentially faster equivalents for the ones\n *\
    \ used in FIPS-180-2, section 4.1.3.\n *   ((x & y) ^ (~x & z)) becomes\n *  \
    \ ((x & (y ^ z)) ^ z)\n */\n"
- title: '#define SHA_Ch(x, y, z, ret) (                                 \'
  contents:
  - "#define SHA_Ch(x, y, z, ret) (                                 \\\n   (ret)[0]\
    \ = (((x)[0] & ((y)[0] ^ (z)[0])) ^ (z)[0]),         \\\n   (ret)[1] = (((x)[1]\
    \ & ((y)[1] ^ (z)[1])) ^ (z)[1]) )\n"
- title: /*
  contents:
  - "/*\n *   ((x & y) ^ (x & z) ^ (y & z)) becomes\n *   ((x & (y | z)) | (y & z))\n\
    \ */\n"
- title: '#define SHA_Maj(x, y, z, ret) (                                 \'
  contents:
  - "#define SHA_Maj(x, y, z, ret) (                                 \\\n   ret[0]\
    \ = (((x)[0] & ((y)[0] | (z)[0])) | ((y)[0] & (z)[0])), \\\n   ret[1] = (((x)[1]\
    \ & ((y)[1] | (z)[1])) | ((y)[1] & (z)[1])) )\n"
- title: '#endif /* USE_MODIFIED_MACROS */'
  contents:
  - '#endif /* USE_MODIFIED_MACROS */

    '
- title: /*
  contents:
  - "/*\n * add \"length\" to the length\n */\n"
- title: static uint32_t addTemp[4] = { 0, 0, 0, 0 };
  contents:
  - 'static uint32_t addTemp[4] = { 0, 0, 0, 0 };

    '
- title: '#define SHA384_512AddLength(context, length) (                        \'
  contents:
  - "#define SHA384_512AddLength(context, length) (                        \\\n  \
    \  addTemp[3] = (length), SHA512_ADDTO4((context)->Length, addTemp), \\\n    (context)->Corrupted\
    \ = (((context)->Length[3] == 0) &&            \\\n       ((context)->Length[2]\
    \ == 0) && ((context)->Length[1] == 0) &&  \\\n       ((context)->Length[0] <\
    \ 8)) ? 1 : 0 )\n"
- title: /* Local Function Prototypes */
  contents:
  - '/* Local Function Prototypes */

    '
- title: static void SHA384_512Finalize(SHA512Context *context,
  contents:
  - "static void SHA384_512Finalize(SHA512Context *context,\n  uint8_t Pad_Byte);\n"
- title: static void SHA384_512PadMessage(SHA512Context *context,
  contents:
  - "static void SHA384_512PadMessage(SHA512Context *context,\n  uint8_t Pad_Byte);\n"
- title: static void SHA384_512ProcessMessageBlock(SHA512Context *context);
  contents:
  - 'static void SHA384_512ProcessMessageBlock(SHA512Context *context);

    '
- title: static int SHA384_512Reset(SHA512Context *context, uint32_t H0[]);
  contents:
  - 'static int SHA384_512Reset(SHA512Context *context, uint32_t H0[]);

    '
- title: static int SHA384_512ResultN( SHA512Context *context,
  contents:
  - "static int SHA384_512ResultN( SHA512Context *context,\n  uint8_t Message_Digest[],\
    \ int HashSize);\n"
- title: '/* Initial Hash Values: FIPS-180-2 sections 5.3.3 and 5.3.4 */'
  contents:
  - '/* Initial Hash Values: FIPS-180-2 sections 5.3.3 and 5.3.4 */

    '
- title: static uint32_t SHA384_H0[SHA512HashSize/4] = {
  contents:
  - "static uint32_t SHA384_H0[SHA512HashSize/4] = {\n    0xCBBB9D5D, 0xC1059ED8,\
    \ 0x629A292A, 0x367CD507, 0x9159015A,\n    0x3070DD17, 0x152FECD8, 0xF70E5939,\
    \ 0x67332667, 0xFFC00B31,\n    0x8EB44A87, 0x68581511, 0xDB0C2E0D, 0x64F98FA7,\
    \ 0x47B5481D,\n    0xBEFA4FA4\n"
- title: '};'
  contents:
  - '};

    '
- title: static uint32_t SHA512_H0[SHA512HashSize/4] = {
  contents:
  - "static uint32_t SHA512_H0[SHA512HashSize/4] = {\n    0x6A09E667, 0xF3BCC908,\
    \ 0xBB67AE85, 0x84CAA73B, 0x3C6EF372,\n    0xFE94F82B, 0xA54FF53A, 0x5F1D36F1,\
    \ 0x510E527F, 0xADE682D1,\n    0x9B05688C, 0x2B3E6C1F, 0x1F83D9AB, 0xFB41BD6B,\
    \ 0x5BE0CD19,\n    0x137E2179\n"
- title: '};'
  contents:
  - '};

    '
- title: '#else /* !USE_32BIT_ONLY */'
  contents:
  - '#else /* !USE_32BIT_ONLY */

    '
- title: /* Define the SHA shift, rotate left and rotate right macro */
  contents:
  - '/* Define the SHA shift, rotate left and rotate right macro */

    '
- title: '#define SHA512_SHR(bits,word)  (((uint64_t)(word)) >> (bits))'
  contents:
  - '#define SHA512_SHR(bits,word)  (((uint64_t)(word)) >> (bits))

    '
- title: '#define SHA512_ROTR(bits,word) ((((uint64_t)(word)) >> (bits)) | \'
  contents:
  - "#define SHA512_ROTR(bits,word) ((((uint64_t)(word)) >> (bits)) | \\\n       \
    \                         (((uint64_t)(word)) << (64-(bits))))\n"
- title: /* Define the SHA SIGMA and sigma macros */
  contents:
  - '/* Define the SHA SIGMA and sigma macros */

    '
- title: '#define SHA512_SIGMA0(word)   \'
  contents:
  - "#define SHA512_SIGMA0(word)   \\\n (SHA512_ROTR(28,word) ^ SHA512_ROTR(34,word)\
    \ ^ SHA512_ROTR(39,word))\n"
- title: '#define SHA512_SIGMA1(word)   \'
  contents:
  - "#define SHA512_SIGMA1(word)   \\\n (SHA512_ROTR(14,word) ^ SHA512_ROTR(18,word)\
    \ ^ SHA512_ROTR(41,word))\n"
- title: '#define SHA512_sigma0(word)   \'
  contents:
  - "#define SHA512_sigma0(word)   \\\n (SHA512_ROTR( 1,word) ^ SHA512_ROTR( 8,word)\
    \ ^ SHA512_SHR( 7,word))\n"
- title: '#define SHA512_sigma1(word)   \'
  contents:
  - "#define SHA512_sigma1(word)   \\\n (SHA512_ROTR(19,word) ^ SHA512_ROTR(61,word)\
    \ ^ SHA512_SHR( 6,word))\n"
- title: /*
  contents:
  - "/*\n * add \"length\" to the length\n */\n"
- title: static uint64_t addTemp;
  contents:
  - 'static uint64_t addTemp;

    '
- title: '#define SHA384_512AddLength(context, length)                   \'
  contents:
  - "#define SHA384_512AddLength(context, length)                   \\\n   (addTemp\
    \ = context->Length_Low, context->Corrupted =        \\\n    ((context->Length_Low\
    \ += length) < addTemp) &&             \\\n    (++context->Length_High == 0) ?\
    \ 1 : 0)\n"
- title: /* Local Function Prototypes */
  contents:
  - '/* Local Function Prototypes */

    '
- title: static void SHA384_512Finalize(SHA512Context *context,
  contents:
  - "static void SHA384_512Finalize(SHA512Context *context,\n  uint8_t Pad_Byte);\n"
- title: static void SHA384_512PadMessage(SHA512Context *context,
  contents:
  - "static void SHA384_512PadMessage(SHA512Context *context,\n  uint8_t Pad_Byte);\n"
- title: static void SHA384_512ProcessMessageBlock(SHA512Context *context);
  contents:
  - 'static void SHA384_512ProcessMessageBlock(SHA512Context *context);

    '
- title: static int SHA384_512Reset(SHA512Context *context, uint64_t H0[]);
  contents:
  - 'static int SHA384_512Reset(SHA512Context *context, uint64_t H0[]);

    '
- title: static int SHA384_512ResultN(SHA512Context *context,
  contents:
  - "static int SHA384_512ResultN(SHA512Context *context,\n  uint8_t Message_Digest[],\
    \ int HashSize);\n"
- title: '/* Initial Hash Values: FIPS-180-2 sections 5.3.3 and 5.3.4 */'
  contents:
  - '/* Initial Hash Values: FIPS-180-2 sections 5.3.3 and 5.3.4 */

    '
- title: static uint64_t SHA384_H0[] = {
  contents:
  - "static uint64_t SHA384_H0[] = {\n    0xCBBB9D5DC1059ED8ll, 0x629A292A367CD507ll,\
    \ 0x9159015A3070DD17ll,\n    0x152FECD8F70E5939ll, 0x67332667FFC00B31ll, 0x8EB44A8768581511ll,\n\
    \    0xDB0C2E0D64F98FA7ll, 0x47B5481DBEFA4FA4ll\n"
- title: '};'
  contents:
  - '};

    '
- title: static uint64_t SHA512_H0[] = {
  contents:
  - "static uint64_t SHA512_H0[] = {\n    0x6A09E667F3BCC908ll, 0xBB67AE8584CAA73Bll,\
    \ 0x3C6EF372FE94F82Bll,\n    0xA54FF53A5F1D36F1ll, 0x510E527FADE682D1ll, 0x9B05688C2B3E6C1Fll,\n\
    \    0x1F83D9ABFB41BD6Bll, 0x5BE0CD19137E2179ll\n"
- title: '};'
  contents:
  - '};

    '
- title: '#endif /* USE_32BIT_ONLY */'
  contents:
  - '#endif /* USE_32BIT_ONLY */

    '
- title: /*
  contents:
  - "/*\n * SHA384Reset\n *\n * Description:\n *   This function will initialize the\
    \ SHA384Context in preparation\n *   for computing a new SHA384 message digest.\n\
    \ *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *\n\
    \ * Returns:\n *   sha Error Code.\n *\n */\n"
- title: int SHA384Reset(SHA384Context *context)
  contents:
  - 'int SHA384Reset(SHA384Context *context)

    '
- title: '{'
  contents:
  - "{\n  return SHA384_512Reset(context, SHA384_H0);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA384Input\n *\n * Description:\n *   This function accepts an array\
    \ of octets as the next portion\n *   of the message.\n *\n * Parameters:\n *\
    \   context: [in/out]\n *     The SHA context to update\n *   message_array: [in]\n\
    \ *     An array of characters representing the next portion of\n *     the message.\n\
    \ *   length: [in]\n *     The length of the message in message_array\n *\n *\
    \ Returns:\n *   sha Error Code.\n *\n */\n"
- title: int SHA384Input(SHA384Context *context,
  contents:
  - "int SHA384Input(SHA384Context *context,\n    const uint8_t *message_array, unsigned\
    \ int length)\n"
- title: '{'
  contents:
  - "{\n  return SHA512Input(context, message_array, length);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA384FinalBits\n *\n * Description:\n *   This function will add in any\
    \ final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n * \
    \    The SHA context to update\n *   message_bits: [in]\n *     The final bits\
    \ of the message, in the upper portion of the\n *     byte. (Use 0b###00000 instead\
    \ of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n * \
    \    The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *\
    \   sha Error Code.\n *\n */\n"
- title: int SHA384FinalBits(SHA384Context *context,
  contents:
  - "int SHA384FinalBits(SHA384Context *context,\n    const uint8_t message_bits,\
    \ unsigned int length)\n"
- title: '{'
  contents:
  - "{\n  return SHA512FinalBits(context, message_bits, length);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA384Result\n *\n * Description:\n *   This function will return the\
    \ 384-bit message\n *   digest into the Message_Digest array provided by the caller.\n\
    \ *   NOTE: The first octet of hash is stored in the 0th element,\n *      the\
    \ last octet of hash in the 48th element.\n *\n * Parameters:\n *   context: [in/out]\n\
    \ *     The context to use to calculate the SHA hash.\n *   Message_Digest: [out]\n\
    \ *     Where the digest is returned.\n *\n * Returns:\n *   sha Error Code.\n\
    \ *\n */\n"
- title: int SHA384Result(SHA384Context *context,
  contents:
  - "int SHA384Result(SHA384Context *context,\n    uint8_t Message_Digest[SHA384HashSize])\n"
- title: '{'
  contents:
  - "{\n  return SHA384_512ResultN(context, Message_Digest, SHA384HashSize);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA512Reset\n *\n * Description:\n *   This function will initialize the\
    \ SHA512Context in preparation\n *   for computing a new SHA512 message digest.\n\
    \ *\n * Parameters:\n *   context: [in/out]\n *     The context to reset.\n *\n\
    \ * Returns:\n *   sha Error Code.\n *\n */\n"
- title: int SHA512Reset(SHA512Context *context)
  contents:
  - 'int SHA512Reset(SHA512Context *context)

    '
- title: '{'
  contents:
  - "{\n  return SHA384_512Reset(context, SHA512_H0);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA512Input\n *\n * Description:\n *   This function accepts an array\
    \ of octets as the next portion\n *   of the message.\n *\n * Parameters:\n *\
    \   context: [in/out]\n *     The SHA context to update\n *   message_array: [in]\n\
    \ *     An array of characters representing the next portion of\n *     the message.\n\
    \ *   length: [in]\n *     The length of the message in message_array\n *\n *\
    \ Returns:\n *   sha Error Code.\n *\n */\n"
- title: int SHA512Input(SHA512Context *context,
  contents:
  - "int SHA512Input(SHA512Context *context,\n        const uint8_t *message_array,\n\
    \        unsigned int length)\n"
- title: '{'
  contents:
  - "{\n  if (!length)\n    return shaSuccess;\n  if (!context || !message_array)\n\
    \    return shaNull;\n  if (context->Computed) {\n    context->Corrupted = shaStateError;\n\
    \    return shaStateError;\n  }\n  if (context->Corrupted)\n     return context->Corrupted;\n\
    \  while (length-- && !context->Corrupted) {\n    context->Message_Block[context->Message_Block_Index++]\
    \ =\n            (*message_array & 0xFF);\n    if (!SHA384_512AddLength(context,\
    \ 8) &&\n      (context->Message_Block_Index == SHA512_Message_Block_Size))\n\
    \      SHA384_512ProcessMessageBlock(context);\n    message_array++;\n  }\n  return\
    \ shaSuccess;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA512FinalBits\n *\n * Description:\n *   This function will add in any\
    \ final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n * \
    \    The SHA context to update\n *   message_bits: [in]\n *     The final bits\
    \ of the message, in the upper portion of the\n *     byte. (Use 0b###00000 instead\
    \ of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n * \
    \    The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *\
    \   sha Error Code.\n *\n */\n"
- title: int SHA512FinalBits(SHA512Context *context,
  contents:
  - "int SHA512FinalBits(SHA512Context *context,\n    const uint8_t message_bits,\
    \ unsigned int length)\n"
- title: '{'
  contents:
  - "{\n  uint8_t masks[8] = {\n      /* 0 0b00000000 */ 0x00, /* 1 0b10000000 */\
    \ 0x80,\n      /* 2 0b11000000 */ 0xC0, /* 3 0b11100000 */ 0xE0,\n      /* 4 0b11110000\
    \ */ 0xF0, /* 5 0b11111000 */ 0xF8,\n      /* 6 0b11111100 */ 0xFC, /* 7 0b11111110\
    \ */ 0xFE\n  };\n  uint8_t markbit[8] = {\n      /* 0 0b10000000 */ 0x80, /* 1\
    \ 0b01000000 */ 0x40,\n      /* 2 0b00100000 */ 0x20, /* 3 0b00010000 */ 0x10,\n\
    \      /* 4 0b00001000 */ 0x08, /* 5 0b00000100 */ 0x04,\n      /* 6 0b00000010\
    \ */ 0x02, /* 7 0b00000001 */ 0x01\n  };\n  if (!length)\n    return shaSuccess;\n\
    \  if (!context)\n    return shaNull;\n  if ((context->Computed) || (length >=\
    \ 8) || (length == 0)) {\n    context->Corrupted = shaStateError;\n    return\
    \ shaStateError;\n  }\n  if (context->Corrupted)\n     return context->Corrupted;\n\
    \  SHA384_512AddLength(context, length);\n  SHA384_512Finalize(context, (uint8_t)\n\
    \    ((message_bits & masks[length]) | markbit[length]));\n  return shaSuccess;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA384_512Finalize\n *\n * Description:\n *   This helper function finishes\
    \ off the digest calculations.\n *\n * Parameters:\n *   context: [in/out]\n *\
    \     The SHA context to update\n *   Pad_Byte: [in]\n *     The last byte to\
    \ add to the digest before the 0-padding\n *     and length. This will contain\
    \ the last bits of the message\n *     followed by another single bit. If the\
    \ message was an\n *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n\
    \ *\n * Returns:\n *   sha Error Code.\n *\n */\n"
- title: static void SHA384_512Finalize(SHA512Context *context,
  contents:
  - "static void SHA384_512Finalize(SHA512Context *context,\n    uint8_t Pad_Byte)\n"
- title: '{'
  contents:
  - "{\n  int_least16_t i;\n  SHA384_512PadMessage(context, Pad_Byte);\n  /* message\
    \ may be sensitive, clear it out */\n  for (i = 0; i < SHA512_Message_Block_Size;\
    \ ++i)\n    context->Message_Block[i] = 0;\n"
- title: '#ifdef USE_32BIT_ONLY    /* and clear length */'
  contents:
  - "#ifdef USE_32BIT_ONLY    /* and clear length */\n  context->Length[0] = context->Length[1]\
    \ = 0;\n  context->Length[2] = context->Length[3] = 0;\n"
- title: '#else /* !USE_32BIT_ONLY */'
  contents:
  - "#else /* !USE_32BIT_ONLY */\n  context->Length_Low = 0;\n  context->Length_High\
    \ = 0;\n"
- title: '#endif /* USE_32BIT_ONLY */'
  contents:
  - "#endif /* USE_32BIT_ONLY */\n  context->Computed = 1;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA512Result\n *\n * Description:\n *   This function will return the\
    \ 512-bit message\n *   digest into the Message_Digest array provided by the caller.\n\
    \ *   NOTE: The first octet of hash is stored in the 0th element,\n *      the\
    \ last octet of hash in the 64th element.\n *\n * Parameters:\n *   context: [in/out]\n\
    \ *     The context to use to calculate the SHA hash.\n *   Message_Digest: [out]\n\
    \ *     Where the digest is returned.\n *\n * Returns:\n *   sha Error Code.\n\
    \ *\n */\n"
- title: int SHA512Result(SHA512Context *context,
  contents:
  - "int SHA512Result(SHA512Context *context,\n    uint8_t Message_Digest[SHA512HashSize])\n"
- title: '{'
  contents:
  - "{\n  return SHA384_512ResultN(context, Message_Digest, SHA512HashSize);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA384_512PadMessage\n *\n * Description:\n *   According to the standard,\
    \ the message must be padded to an\n *   even 1024 bits. The first padding bit\
    \ must be a '1'. The\n *   last 128 bits represent the length of the original\
    \ message.\n *   All bits in between should be 0. This helper function will\n\
    \ *   pad the message according to those rules by filling the\n *   Message_Block\
    \ array accordingly. When it returns, it can be\n *   assumed that the message\
    \ digest has been computed.\n *\n * Parameters:\n *   context: [in/out]\n *  \
    \   The context to pad\n *   Pad_Byte: [in]\n *     The last byte to add to the\
    \ digest before the 0-padding\n *     and length. This will contain the last bits\
    \ of the message\n *     followed by another single bit. If the message was an\n\
    \ *     exact multiple of 8-bits long, Pad_Byte will be 0x80.\n *\n * Returns:\n\
    \ *   Nothing.\n *\n */\n"
- title: static void SHA384_512PadMessage(SHA512Context *context,
  contents:
  - "static void SHA384_512PadMessage(SHA512Context *context,\n    uint8_t Pad_Byte)\n"
- title: '{'
  contents:
  - "{\n  /*\n   * Check to see if the current message block is too small to hold\n\
    \   * the initial padding bits and length. If so, we will pad the\n   * block,\
    \ process it, and then continue padding into a second\n   * block.\n   */\n  if\
    \ (context->Message_Block_Index >= (SHA512_Message_Block_Size-16)) {\n    context->Message_Block[context->Message_Block_Index++]\
    \ = Pad_Byte;\n    while (context->Message_Block_Index < SHA512_Message_Block_Size)\n\
    \      context->Message_Block[context->Message_Block_Index++] = 0;\n    SHA384_512ProcessMessageBlock(context);\n\
    \  } else\n    context->Message_Block[context->Message_Block_Index++] = Pad_Byte;\n\
    \  while (context->Message_Block_Index < (SHA512_Message_Block_Size-16))\n   \
    \ context->Message_Block[context->Message_Block_Index++] = 0;\n  /*\n   * Store\
    \ the message length as the last 16 octets\n   */\n"
- title: '#ifdef USE_32BIT_ONLY'
  contents:
  - "#ifdef USE_32BIT_ONLY\n  context->Message_Block[112] = (uint8_t)(context->Length[0]\
    \ >> 24);\n  context->Message_Block[113] = (uint8_t)(context->Length[0] >> 16);\n\
    \  context->Message_Block[114] = (uint8_t)(context->Length[0] >> 8);\n  context->Message_Block[115]\
    \ = (uint8_t)(context->Length[0]);\n  context->Message_Block[116] = (uint8_t)(context->Length[1]\
    \ >> 24);\n  context->Message_Block[117] = (uint8_t)(context->Length[1] >> 16);\n\
    \  context->Message_Block[118] = (uint8_t)(context->Length[1] >> 8);\n  context->Message_Block[119]\
    \ = (uint8_t)(context->Length[1]);\n  context->Message_Block[120] = (uint8_t)(context->Length[2]\
    \ >> 24);\n  context->Message_Block[121] = (uint8_t)(context->Length[2] >> 16);\n\
    \  context->Message_Block[122] = (uint8_t)(context->Length[2] >> 8);\n  context->Message_Block[123]\
    \ = (uint8_t)(context->Length[2]);\n  context->Message_Block[124] = (uint8_t)(context->Length[3]\
    \ >> 24);\n  context->Message_Block[125] = (uint8_t)(context->Length[3] >> 16);\n\
    \  context->Message_Block[126] = (uint8_t)(context->Length[3] >> 8);\n  context->Message_Block[127]\
    \ = (uint8_t)(context->Length[3]);\n"
- title: '#else /* !USE_32BIT_ONLY */'
  contents:
  - "#else /* !USE_32BIT_ONLY */\n  context->Message_Block[112] = (uint8_t)(context->Length_High\
    \ >> 56);\n  context->Message_Block[113] = (uint8_t)(context->Length_High >> 48);\n\
    \  context->Message_Block[114] = (uint8_t)(context->Length_High >> 40);\n  context->Message_Block[115]\
    \ = (uint8_t)(context->Length_High >> 32);\n  context->Message_Block[116] = (uint8_t)(context->Length_High\
    \ >> 24);\n  context->Message_Block[117] = (uint8_t)(context->Length_High >> 16);\n\
    \  context->Message_Block[118] = (uint8_t)(context->Length_High >> 8);\n  context->Message_Block[119]\
    \ = (uint8_t)(context->Length_High);\n  context->Message_Block[120] = (uint8_t)(context->Length_Low\
    \ >> 56);\n  context->Message_Block[121] = (uint8_t)(context->Length_Low >> 48);\n\
    \  context->Message_Block[122] = (uint8_t)(context->Length_Low >> 40);\n  context->Message_Block[123]\
    \ = (uint8_t)(context->Length_Low >> 32);\n  context->Message_Block[124] = (uint8_t)(context->Length_Low\
    \ >> 24);\n  context->Message_Block[125] = (uint8_t)(context->Length_Low >> 16);\n\
    \  context->Message_Block[126] = (uint8_t)(context->Length_Low >> 8);\n  context->Message_Block[127]\
    \ = (uint8_t)(context->Length_Low);\n"
- title: '#endif /* USE_32BIT_ONLY */'
  contents:
  - "#endif /* USE_32BIT_ONLY */\n  SHA384_512ProcessMessageBlock(context);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA384_512ProcessMessageBlock\n *\n * Description:\n *   This helper function\
    \ will process the next 1024 bits of the\n *   message stored in the Message_Block\
    \ array.\n *\n * Parameters:\n *   context: [in/out]\n *     The SHA context to\
    \ update\n *\n * Returns:\n *   Nothing.\n *\n * Comments:\n *   Many of the variable\
    \ names in this code, especially the\n *   single character names, were used because\
    \ those were the\n *   names used in the publication.\n *\n *\n */\n"
- title: static void SHA384_512ProcessMessageBlock(SHA512Context *context)
  contents:
  - 'static void SHA384_512ProcessMessageBlock(SHA512Context *context)

    '
- title: '{'
  contents:
  - "{\n  /* Constants defined in FIPS-180-2, section 4.2.3 */\n"
- title: '#ifdef USE_32BIT_ONLY'
  contents:
  - "#ifdef USE_32BIT_ONLY\n  static const uint32_t K[80*2] = {\n      0x428A2F98,\
    \ 0xD728AE22, 0x71374491, 0x23EF65CD, 0xB5C0FBCF,\n      0xEC4D3B2F, 0xE9B5DBA5,\
    \ 0x8189DBBC, 0x3956C25B, 0xF348B538,\n      0x59F111F1, 0xB605D019, 0x923F82A4,\
    \ 0xAF194F9B, 0xAB1C5ED5,\n      0xDA6D8118, 0xD807AA98, 0xA3030242, 0x12835B01,\
    \ 0x45706FBE,\n      0x243185BE, 0x4EE4B28C, 0x550C7DC3, 0xD5FFB4E2, 0x72BE5D74,\n\
    \      0xF27B896F, 0x80DEB1FE, 0x3B1696B1, 0x9BDC06A7, 0x25C71235,\n      0xC19BF174,\
    \ 0xCF692694, 0xE49B69C1, 0x9EF14AD2, 0xEFBE4786,\n      0x384F25E3, 0x0FC19DC6,\
    \ 0x8B8CD5B5, 0x240CA1CC, 0x77AC9C65,\n      0x2DE92C6F, 0x592B0275, 0x4A7484AA,\
    \ 0x6EA6E483, 0x5CB0A9DC,\n      0xBD41FBD4, 0x76F988DA, 0x831153B5, 0x983E5152,\
    \ 0xEE66DFAB,\n      0xA831C66D, 0x2DB43210, 0xB00327C8, 0x98FB213F, 0xBF597FC7,\n\
    \      0xBEEF0EE4, 0xC6E00BF3, 0x3DA88FC2, 0xD5A79147, 0x930AA725,\n      0x06CA6351,\
    \ 0xE003826F, 0x14292967, 0x0A0E6E70, 0x27B70A85,\n      0x46D22FFC, 0x2E1B2138,\
    \ 0x5C26C926, 0x4D2C6DFC, 0x5AC42AED,\n      0x53380D13, 0x9D95B3DF, 0x650A7354,\
    \ 0x8BAF63DE, 0x766A0ABB,\n      0x3C77B2A8, 0x81C2C92E, 0x47EDAEE6, 0x92722C85,\
    \ 0x1482353B,\n      0xA2BFE8A1, 0x4CF10364, 0xA81A664B, 0xBC423001, 0xC24B8B70,\n\
    \      0xD0F89791, 0xC76C51A3, 0x0654BE30, 0xD192E819, 0xD6EF5218,\n      0xD6990624,\
    \ 0x5565A910, 0xF40E3585, 0x5771202A, 0x106AA070,\n      0x32BBD1B8, 0x19A4C116,\
    \ 0xB8D2D0C8, 0x1E376C08, 0x5141AB53,\n      0x2748774C, 0xDF8EEB99, 0x34B0BCB5,\
    \ 0xE19B48A8, 0x391C0CB3,\n      0xC5C95A63, 0x4ED8AA4A, 0xE3418ACB, 0x5B9CCA4F,\
    \ 0x7763E373,\n      0x682E6FF3, 0xD6B2B8A3, 0x748F82EE, 0x5DEFB2FC, 0x78A5636F,\n\
    \      0x43172F60, 0x84C87814, 0xA1F0AB72, 0x8CC70208, 0x1A6439EC,\n      0x90BEFFFA,\
    \ 0x23631E28, 0xA4506CEB, 0xDE82BDE9, 0xBEF9A3F7,\n      0xB2C67915, 0xC67178F2,\
    \ 0xE372532B, 0xCA273ECE, 0xEA26619C,\n      0xD186B8C7, 0x21C0C207, 0xEADA7DD6,\
    \ 0xCDE0EB1E, 0xF57D4F7F,\n      0xEE6ED178, 0x06F067AA, 0x72176FBA, 0x0A637DC5,\
    \ 0xA2C898A6,\n      0x113F9804, 0xBEF90DAE, 0x1B710B35, 0x131C471B, 0x28DB77F5,\n\
    \      0x23047D84, 0x32CAAB7B, 0x40C72493, 0x3C9EBE0A, 0x15C9BEBC,\n      0x431D67C4,\
    \ 0x9C100D4C, 0x4CC5D4BE, 0xCB3E42B6, 0x597F299C,\n      0xFC657E2A, 0x5FCB6FAB,\
    \ 0x3AD6FAEC, 0x6C44198C, 0x4A475817\n  };\n  int     t, t2, t8;             \
    \     /* Loop counter */\n  uint32_t  temp1[2], temp2[2],       /* Temporary word\
    \ values */\n        temp3[2], temp4[2], temp5[2];\n  uint32_t  W[2*80];     \
    \             /* Word sequence */\n  uint32_t  A[2], B[2], C[2], D[2],   /* Word\
    \ buffers */\n        E[2], F[2], G[2], H[2];\n  /* Initialize the first 16 words\
    \ in the array W */\n  for (t = t2 = t8 = 0; t < 16; t++, t8 += 8) {\n    W[t2++]\
    \ = ((((uint32_t)context->Message_Block[t8    ])) << 24) |\n              ((((uint32_t)context->Message_Block[t8\
    \ + 1])) << 16) |\n              ((((uint32_t)context->Message_Block[t8 + 2]))\
    \ << 8) |\n              ((((uint32_t)context->Message_Block[t8 + 3])));\n   \
    \ W[t2++] = ((((uint32_t)context->Message_Block[t8 + 4])) << 24) |\n         \
    \     ((((uint32_t)context->Message_Block[t8 + 5])) << 16) |\n              ((((uint32_t)context->Message_Block[t8\
    \ + 6])) << 8) |\n              ((((uint32_t)context->Message_Block[t8 + 7])));\n\
    \  }\n  for (t = 16; t < 80; t++, t2 += 2) {\n    /* W[t] = SHA512_sigma1(W[t-2])\
    \ + W[t-7] +\n      SHA512_sigma0(W[t-15]) + W[t-16]; */\n    uint32_t *Wt2 =\
    \ &W[t2-2*2];\n    uint32_t *Wt7 = &W[t2-7*2];\n    uint32_t *Wt15 = &W[t2-15*2];\n\
    \    uint32_t *Wt16 = &W[t2-16*2];\n    SHA512_sigma1(Wt2, temp1);\n    SHA512_ADD(temp1,\
    \ Wt7, temp2);\n    SHA512_sigma0(Wt15, temp1);\n    SHA512_ADD(temp1, Wt16, temp3);\n\
    \    SHA512_ADD(temp2, temp3, &W[t2]);\n  }\n  A[0] = context->Intermediate_Hash[0];\n\
    \  A[1] = context->Intermediate_Hash[1];\n  B[0] = context->Intermediate_Hash[2];\n\
    \  B[1] = context->Intermediate_Hash[3];\n  C[0] = context->Intermediate_Hash[4];\n\
    \  C[1] = context->Intermediate_Hash[5];\n  D[0] = context->Intermediate_Hash[6];\n\
    \  D[1] = context->Intermediate_Hash[7];\n  E[0] = context->Intermediate_Hash[8];\n\
    \  E[1] = context->Intermediate_Hash[9];\n  F[0] = context->Intermediate_Hash[10];\n\
    \  F[1] = context->Intermediate_Hash[11];\n  G[0] = context->Intermediate_Hash[12];\n\
    \  G[1] = context->Intermediate_Hash[13];\n  H[0] = context->Intermediate_Hash[14];\n\
    \  H[1] = context->Intermediate_Hash[15];\n  for (t = t2 = 0; t < 80; t++, t2\
    \ += 2) {\n    /*\n     * temp1 = H + SHA512_SIGMA1(E) + SHA_Ch(E,F,G) + K[t]\
    \ + W[t];\n     */\n    SHA512_SIGMA1(E,temp1);\n    SHA512_ADD(H, temp1, temp2);\n\
    \    SHA_Ch(E,F,G,temp3);\n    SHA512_ADD(temp2, temp3, temp4);\n    SHA512_ADD(&K[t2],\
    \ &W[t2], temp5);\n    SHA512_ADD(temp4, temp5, temp1);\n    /*\n     * temp2\
    \ = SHA512_SIGMA0(A) + SHA_Maj(A,B,C);\n     */\n    SHA512_SIGMA0(A,temp3);\n\
    \    SHA_Maj(A,B,C,temp4);\n    SHA512_ADD(temp3, temp4, temp2);\n    H[0] = G[0];\
    \ H[1] = G[1];\n    G[0] = F[0]; G[1] = F[1];\n    F[0] = E[0]; F[1] = E[1];\n\
    \    SHA512_ADD(D, temp1, E);\n    D[0] = C[0]; D[1] = C[1];\n    C[0] = B[0];\
    \ C[1] = B[1];\n    B[0] = A[0]; B[1] = A[1];\n    SHA512_ADD(temp1, temp2, A);\n\
    \  }\n  SHA512_ADDTO2(&context->Intermediate_Hash[0], A);\n  SHA512_ADDTO2(&context->Intermediate_Hash[2],\
    \ B);\n  SHA512_ADDTO2(&context->Intermediate_Hash[4], C);\n  SHA512_ADDTO2(&context->Intermediate_Hash[6],\
    \ D);\n  SHA512_ADDTO2(&context->Intermediate_Hash[8], E);\n  SHA512_ADDTO2(&context->Intermediate_Hash[10],\
    \ F);\n  SHA512_ADDTO2(&context->Intermediate_Hash[12], G);\n  SHA512_ADDTO2(&context->Intermediate_Hash[14],\
    \ H);\n"
- title: '#else /* !USE_32BIT_ONLY */'
  contents:
  - "#else /* !USE_32BIT_ONLY */\n  static const uint64_t K[80] = {\n      0x428A2F98D728AE22ll,\
    \ 0x7137449123EF65CDll, 0xB5C0FBCFEC4D3B2Fll,\n      0xE9B5DBA58189DBBCll, 0x3956C25BF348B538ll,\
    \ 0x59F111F1B605D019ll,\n      0x923F82A4AF194F9Bll, 0xAB1C5ED5DA6D8118ll, 0xD807AA98A3030242ll,\n\
    \      0x12835B0145706FBEll, 0x243185BE4EE4B28Cll, 0x550C7DC3D5FFB4E2ll,\n   \
    \   0x72BE5D74F27B896Fll, 0x80DEB1FE3B1696B1ll, 0x9BDC06A725C71235ll,\n      0xC19BF174CF692694ll,\
    \ 0xE49B69C19EF14AD2ll, 0xEFBE4786384F25E3ll,\n      0x0FC19DC68B8CD5B5ll, 0x240CA1CC77AC9C65ll,\
    \ 0x2DE92C6F592B0275ll,\n      0x4A7484AA6EA6E483ll, 0x5CB0A9DCBD41FBD4ll, 0x76F988DA831153B5ll,\n\
    \      0x983E5152EE66DFABll, 0xA831C66D2DB43210ll, 0xB00327C898FB213Fll,\n   \
    \   0xBF597FC7BEEF0EE4ll, 0xC6E00BF33DA88FC2ll, 0xD5A79147930AA725ll,\n      0x06CA6351E003826Fll,\
    \ 0x142929670A0E6E70ll, 0x27B70A8546D22FFCll,\n      0x2E1B21385C26C926ll, 0x4D2C6DFC5AC42AEDll,\
    \ 0x53380D139D95B3DFll,\n      0x650A73548BAF63DEll, 0x766A0ABB3C77B2A8ll, 0x81C2C92E47EDAEE6ll,\n\
    \      0x92722C851482353Bll, 0xA2BFE8A14CF10364ll, 0xA81A664BBC423001ll,\n   \
    \   0xC24B8B70D0F89791ll, 0xC76C51A30654BE30ll, 0xD192E819D6EF5218ll,\n      0xD69906245565A910ll,\
    \ 0xF40E35855771202All, 0x106AA07032BBD1B8ll,\n      0x19A4C116B8D2D0C8ll, 0x1E376C085141AB53ll,\
    \ 0x2748774CDF8EEB99ll,\n      0x34B0BCB5E19B48A8ll, 0x391C0CB3C5C95A63ll, 0x4ED8AA4AE3418ACBll,\n\
    \      0x5B9CCA4F7763E373ll, 0x682E6FF3D6B2B8A3ll, 0x748F82EE5DEFB2FCll,\n   \
    \   0x78A5636F43172F60ll, 0x84C87814A1F0AB72ll, 0x8CC702081A6439ECll,\n      0x90BEFFFA23631E28ll,\
    \ 0xA4506CEBDE82BDE9ll, 0xBEF9A3F7B2C67915ll,\n      0xC67178F2E372532Bll, 0xCA273ECEEA26619Cll,\
    \ 0xD186B8C721C0C207ll,\n      0xEADA7DD6CDE0EB1Ell, 0xF57D4F7FEE6ED178ll, 0x06F067AA72176FBAll,\n\
    \      0x0A637DC5A2C898A6ll, 0x113F9804BEF90DAEll, 0x1B710B35131C471Bll,\n   \
    \   0x28DB77F523047D84ll, 0x32CAAB7B40C72493ll, 0x3C9EBE0A15C9BEBCll,\n      0x431D67C49C100D4Cll,\
    \ 0x4CC5D4BECB3E42B6ll, 0x597F299CFC657E2All,\n      0x5FCB6FAB3AD6FAECll, 0x6C44198C4A475817ll\n\
    \  };\n  int        t, t8;                   /* Loop counter */\n  uint64_t  \
    \ temp1, temp2;            /* Temporary word value */\n  uint64_t   W[80];   \
    \                /* Word sequence */\n  uint64_t   A, B, C, D, E, F, G, H;  /*\
    \ Word buffers */\n  /*\n   * Initialize the first 16 words in the array W\n \
    \  */\n  for (t = t8 = 0; t < 16; t++, t8 += 8)\n    W[t] = ((uint64_t)(context->Message_Block[t8\
    \  ]) << 56) |\n           ((uint64_t)(context->Message_Block[t8 + 1]) << 48)\
    \ |\n           ((uint64_t)(context->Message_Block[t8 + 2]) << 40) |\n       \
    \    ((uint64_t)(context->Message_Block[t8 + 3]) << 32) |\n           ((uint64_t)(context->Message_Block[t8\
    \ + 4]) << 24) |\n           ((uint64_t)(context->Message_Block[t8 + 5]) << 16)\
    \ |\n           ((uint64_t)(context->Message_Block[t8 + 6]) << 8) |\n        \
    \   ((uint64_t)(context->Message_Block[t8 + 7]));\n  for (t = 16; t < 80; t++)\n\
    \    W[t] = SHA512_sigma1(W[t-2]) + W[t-7] +\n        SHA512_sigma0(W[t-15]) +\
    \ W[t-16];\n  A = context->Intermediate_Hash[0];\n  B = context->Intermediate_Hash[1];\n\
    \  C = context->Intermediate_Hash[2];\n  D = context->Intermediate_Hash[3];\n\
    \  E = context->Intermediate_Hash[4];\n  F = context->Intermediate_Hash[5];\n\
    \  G = context->Intermediate_Hash[6];\n  H = context->Intermediate_Hash[7];\n\
    \  for (t = 0; t < 80; t++) {\n    temp1 = H + SHA512_SIGMA1(E) + SHA_Ch(E,F,G)\
    \ + K[t] + W[t];\n    temp2 = SHA512_SIGMA0(A) + SHA_Maj(A,B,C);\n    H = G;\n\
    \    G = F;\n    F = E;\n    E = D + temp1;\n    D = C;\n    C = B;\n    B = A;\n\
    \    A = temp1 + temp2;\n  }\n  context->Intermediate_Hash[0] += A;\n  context->Intermediate_Hash[1]\
    \ += B;\n  context->Intermediate_Hash[2] += C;\n  context->Intermediate_Hash[3]\
    \ += D;\n  context->Intermediate_Hash[4] += E;\n  context->Intermediate_Hash[5]\
    \ += F;\n  context->Intermediate_Hash[6] += G;\n  context->Intermediate_Hash[7]\
    \ += H;\n"
- title: '#endif /* USE_32BIT_ONLY */'
  contents:
  - "#endif /* USE_32BIT_ONLY */\n  context->Message_Block_Index = 0;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA384_512Reset\n *\n * Description:\n *   This helper function will initialize\
    \ the SHA512Context in\n *   preparation for computing a new SHA384 or SHA512\
    \ message\n *   digest.\n *\n * Parameters:\n *   context: [in/out]\n *     The\
    \ context to reset.\n *   H0\n *     The initial hash value to use.\n *\n * Returns:\n\
    \ *   sha Error Code.\n *\n */\n"
- title: '#ifdef USE_32BIT_ONLY'
  contents:
  - '#ifdef USE_32BIT_ONLY

    '
- title: static int SHA384_512Reset(SHA512Context *context, uint32_t H0[])
  contents:
  - 'static int SHA384_512Reset(SHA512Context *context, uint32_t H0[])

    '
- title: '#else /* !USE_32BIT_ONLY */'
  contents:
  - '#else /* !USE_32BIT_ONLY */

    '
- title: static int SHA384_512Reset(SHA512Context *context, uint64_t H0[])
  contents:
  - 'static int SHA384_512Reset(SHA512Context *context, uint64_t H0[])

    '
- title: '#endif /* USE_32BIT_ONLY */'
  contents:
  - '#endif /* USE_32BIT_ONLY */

    '
- title: '{'
  contents:
  - "{\n  int i;\n  if (!context)\n    return shaNull;\n  context->Message_Block_Index\
    \ = 0;\n"
- title: '#ifdef USE_32BIT_ONLY'
  contents:
  - "#ifdef USE_32BIT_ONLY\n  context->Length[0] = context->Length[1] = 0;\n  context->Length[2]\
    \ = context->Length[3] = 0;\n  for (i = 0; i < SHA512HashSize/4; i++)\n    context->Intermediate_Hash[i]\
    \ = H0[i];\n"
- title: '#else /* !USE_32BIT_ONLY */'
  contents:
  - "#else /* !USE_32BIT_ONLY */\n  context->Length_High = context->Length_Low = 0;\n\
    \  for (i = 0; i < SHA512HashSize/8; i++)\n    context->Intermediate_Hash[i] =\
    \ H0[i];\n"
- title: '#endif /* USE_32BIT_ONLY */'
  contents:
  - "#endif /* USE_32BIT_ONLY */\n  context->Computed = 0;\n  context->Corrupted =\
    \ 0;\n  return shaSuccess;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * SHA384_512ResultN\n *\n * Description:\n *   This helper function will\
    \ return the 384-bit or 512-bit message\n *   digest into the Message_Digest array\
    \ provided by the caller.\n *   NOTE: The first octet of hash is stored in the\
    \ 0th element,\n *      the last octet of hash in the 48th/64th element.\n *\n\
    \ * Parameters:\n *   context: [in/out]\n *     The context to use to calculate\
    \ the SHA hash.\n *   Message_Digest: [out]\n *     Where the digest is returned.\n\
    \ *   HashSize: [in]\n *     The size of the hash, either 48 or 64.\n *\n * Returns:\n\
    \ *   sha Error Code.\n *\n */\n"
- title: static int SHA384_512ResultN(SHA512Context *context,
  contents:
  - "static int SHA384_512ResultN(SHA512Context *context,\n    uint8_t Message_Digest[],\
    \ int HashSize)\n"
- title: '{'
  contents:
  - "{\n  int i;\n"
- title: '#ifdef USE_32BIT_ONLY'
  contents:
  - "#ifdef USE_32BIT_ONLY\n  int i2;\n"
- title: '#endif /* USE_32BIT_ONLY */'
  contents:
  - "#endif /* USE_32BIT_ONLY */\n  if (!context || !Message_Digest)\n    return shaNull;\n\
    \  if (context->Corrupted)\n    return context->Corrupted;\n  if (!context->Computed)\n\
    \    SHA384_512Finalize(context, 0x80);\n"
- title: '#ifdef USE_32BIT_ONLY'
  contents:
  - "#ifdef USE_32BIT_ONLY\n  for (i = i2 = 0; i < HashSize; ) {\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>24);\n\
    \    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>16);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>8);\n\
    \    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2++]);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>24);\n\
    \    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>16);\n    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2]>>8);\n\
    \    Message_Digest[i++]=(uint8_t)(context->Intermediate_Hash[i2++]);\n  }\n"
- title: '#else /* !USE_32BIT_ONLY */'
  contents:
  - "#else /* !USE_32BIT_ONLY */\n  for (i = 0; i < HashSize; ++i)\n    Message_Digest[i]\
    \ = (uint8_t)\n      (context->Intermediate_Hash[i>>3] >> 8 * ( 7 - ( i % 8 )\
    \ ));\n"
- title: '#endif /* USE_32BIT_ONLY */'
  contents:
  - "#endif /* USE_32BIT_ONLY */\n  return shaSuccess;\n"
- title: '}'
  contents:
  - '}

    '
- title: 8.2.4.  usha.c
  contents:
  - '8.2.4.  usha.c

    '
- title: /**************************** usha.c ****************************/
  contents:
  - '/**************************** usha.c ****************************/

    '
- title: /******************** See RFC 4634 for details ******************/
  contents:
  - '/******************** See RFC 4634 for details ******************/

    '
- title: /*
  contents:
  - "/*\n *  Description:\n *     This file implements a unified interface to the\
    \ SHA algorithms.\n */\n"
- title: '#include "sha.h"'
  contents:
  - '#include "sha.h"

    '
- title: /*
  contents:
  - "/*\n *  USHAReset\n *\n *  Description:\n *      This function will initialize\
    \ the SHA Context in preparation\n *      for computing a new SHA message digest.\n\
    \ *\n *  Parameters:\n *      context: [in/out]\n *          The context to reset.\n\
    \ *      whichSha: [in]\n *          Selects which SHA reset to call\n *\n * \
    \ Returns:\n *      sha Error Code.\n *\n */\n"
- title: int USHAReset(USHAContext *ctx, enum SHAversion whichSha)
  contents:
  - 'int USHAReset(USHAContext *ctx, enum SHAversion whichSha)

    '
- title: '{'
  contents:
  - "{\n  if (ctx) {\n    ctx->whichSha = whichSha;\n    switch (whichSha) {\n   \
    \   case SHA1:   return SHA1Reset((SHA1Context*)&ctx->ctx);\n      case SHA224:\
    \ return SHA224Reset((SHA224Context*)&ctx->ctx);\n      case SHA256: return SHA256Reset((SHA256Context*)&ctx->ctx);\n\
    \      case SHA384: return SHA384Reset((SHA384Context*)&ctx->ctx);\n      case\
    \ SHA512: return SHA512Reset((SHA512Context*)&ctx->ctx);\n      default: return\
    \ shaBadParam;\n    }\n  } else {\n    return shaNull;\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n *  USHAInput\n *\n *  Description:\n *      This function accepts an array\
    \ of octets as the next portion\n *      of the message.\n *\n *  Parameters:\n\
    \ *      context: [in/out]\n *          The SHA context to update\n *      message_array:\
    \ [in]\n *          An array of characters representing the next portion of\n\
    \ *          the message.\n *      length: [in]\n *          The length of the\
    \ message in message_array\n *\n *  Returns:\n *      sha Error Code.\n *\n */\n"
- title: int USHAInput(USHAContext *ctx,
  contents:
  - "int USHAInput(USHAContext *ctx,\n              const uint8_t *bytes, unsigned\
    \ int bytecount)\n"
- title: '{'
  contents:
  - "{\n  if (ctx) {\n    switch (ctx->whichSha) {\n      case SHA1:\n        return\
    \ SHA1Input((SHA1Context*)&ctx->ctx, bytes, bytecount);\n      case SHA224:\n\
    \        return SHA224Input((SHA224Context*)&ctx->ctx, bytes,\n            bytecount);\n\
    \      case SHA256:\n        return SHA256Input((SHA256Context*)&ctx->ctx, bytes,\n\
    \            bytecount);\n      case SHA384:\n        return SHA384Input((SHA384Context*)&ctx->ctx,\
    \ bytes,\n            bytecount);\n      case SHA512:\n        return SHA512Input((SHA512Context*)&ctx->ctx,\
    \ bytes,\n            bytecount);\n      default: return shaBadParam;\n    }\n\
    \  } else {\n    return shaNull;\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * USHAFinalBits\n *\n * Description:\n *   This function will add in any\
    \ final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n * \
    \    The SHA context to update\n *   message_bits: [in]\n *     The final bits\
    \ of the message, in the upper portion of the\n *     byte. (Use 0b###00000 instead\
    \ of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n * \
    \    The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *\
    \   sha Error Code.\n */\n"
- title: int USHAFinalBits(USHAContext *ctx,
  contents:
  - "int USHAFinalBits(USHAContext *ctx,\n                  const uint8_t bits, unsigned\
    \ int bitcount)\n"
- title: '{'
  contents:
  - "{\n  if (ctx) {\n    switch (ctx->whichSha) {\n      case SHA1:\n        return\
    \ SHA1FinalBits((SHA1Context*)&ctx->ctx, bits, bitcount);\n      case SHA224:\n\
    \        return SHA224FinalBits((SHA224Context*)&ctx->ctx, bits,\n           \
    \ bitcount);\n      case SHA256:\n        return SHA256FinalBits((SHA256Context*)&ctx->ctx,\
    \ bits,\n            bitcount);\n      case SHA384:\n        return SHA384FinalBits((SHA384Context*)&ctx->ctx,\
    \ bits,\n            bitcount);\n      case SHA512:\n        return SHA512FinalBits((SHA512Context*)&ctx->ctx,\
    \ bits,\n            bitcount);\n      default: return shaBadParam;\n    }\n \
    \ } else {\n    return shaNull;\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * USHAResult\n *\n * Description:\n *   This function will return the 160-bit\
    \ message digest into the\n *   Message_Digest array provided by the caller.\n\
    \ *   NOTE: The first octet of hash is stored in the 0th element,\n *      the\
    \ last octet of hash in the 19th element.\n *\n * Parameters:\n *   context: [in/out]\n\
    \ *     The context to use to calculate the SHA-1 hash.\n *   Message_Digest:\
    \ [out]\n *     Where the digest is returned.\n *\n * Returns:\n *   sha Error\
    \ Code.\n *\n */\n"
- title: int USHAResult(USHAContext *ctx,
  contents:
  - "int USHAResult(USHAContext *ctx,\n               uint8_t Message_Digest[USHAMaxHashSize])\n"
- title: '{'
  contents:
  - "{\n  if (ctx) {\n    switch (ctx->whichSha) {\n      case SHA1:\n        return\
    \ SHA1Result((SHA1Context*)&ctx->ctx, Message_Digest);\n      case SHA224:\n \
    \       return SHA224Result((SHA224Context*)&ctx->ctx, Message_Digest);\n    \
    \  case SHA256:\n        return SHA256Result((SHA256Context*)&ctx->ctx, Message_Digest);\n\
    \      case SHA384:\n        return SHA384Result((SHA384Context*)&ctx->ctx, Message_Digest);\n\
    \      case SHA512:\n        return SHA512Result((SHA512Context*)&ctx->ctx, Message_Digest);\n\
    \      default: return shaBadParam;\n    }\n  } else {\n    return shaNull;\n\
    \  }\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * USHABlockSize\n *\n * Description:\n *   This function will return the\
    \ blocksize for the given SHA\n *   algorithm.\n *\n * Parameters:\n *   whichSha:\n\
    \ *     which SHA algorithm to query\n *\n * Returns:\n *   block size\n *\n */\n"
- title: int USHABlockSize(enum SHAversion whichSha)
  contents:
  - 'int USHABlockSize(enum SHAversion whichSha)

    '
- title: '{'
  contents:
  - "{\n  switch (whichSha) {\n    case SHA1:   return SHA1_Message_Block_Size;\n\
    \    case SHA224: return SHA224_Message_Block_Size;\n    case SHA256: return SHA256_Message_Block_Size;\n\
    \    case SHA384: return SHA384_Message_Block_Size;\n    default:\n    case SHA512:\
    \ return SHA512_Message_Block_Size;\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * USHAHashSize\n *\n * Description:\n *   This function will return the\
    \ hashsize for the given SHA\n *   algorithm.\n *\n * Parameters:\n *   whichSha:\n\
    \ *     which SHA algorithm to query\n *\n * Returns:\n *   hash size\n *\n */\n"
- title: int USHAHashSize(enum SHAversion whichSha)
  contents:
  - 'int USHAHashSize(enum SHAversion whichSha)

    '
- title: '{'
  contents:
  - "{\n  switch (whichSha) {\n    case SHA1:   return SHA1HashSize;\n    case SHA224:\
    \ return SHA224HashSize;\n    case SHA256: return SHA256HashSize;\n    case SHA384:\
    \ return SHA384HashSize;\n    default:\n    case SHA512: return SHA512HashSize;\n\
    \  }\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * USHAHashSizeBits\n *\n * Description:\n *   This function will return\
    \ the hashsize for the given SHA\n *   algorithm, expressed in bits.\n *\n * Parameters:\n\
    \ *   whichSha:\n *     which SHA algorithm to query\n *\n * Returns:\n *   hash\
    \ size in bits\n *\n */\n"
- title: int USHAHashSizeBits(enum SHAversion whichSha)
  contents:
  - 'int USHAHashSizeBits(enum SHAversion whichSha)

    '
- title: '{'
  contents:
  - "{\n  switch (whichSha) {\n    case SHA1:   return SHA1HashSizeBits;\n    case\
    \ SHA224: return SHA224HashSizeBits;\n    case SHA256: return SHA256HashSizeBits;\n\
    \    case SHA384: return SHA384HashSizeBits;\n    default:\n    case SHA512: return\
    \ SHA512HashSizeBits;\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: 8.2.5.  sha-private.h
  contents:
  - '8.2.5.  sha-private.h

    '
- title: /*************************** sha-private.h ***************************/
  contents:
  - '/*************************** sha-private.h ***************************/

    '
- title: /********************** See RFC 4634 for details *********************/
  contents:
  - '/********************** See RFC 4634 for details *********************/

    '
- title: '#ifndef _SHA_PRIVATE__H'
  contents:
  - '#ifndef _SHA_PRIVATE__H

    '
- title: '#define _SHA_PRIVATE__H'
  contents:
  - '#define _SHA_PRIVATE__H

    '
- title: /*
  contents:
  - "/*\n * These definitions are defined in FIPS-180-2, section 4.1.\n * Ch() and\
    \ Maj() are defined identically in sections 4.1.1,\n * 4.1.2 and 4.1.3.\n *\n\
    \ * The definitions used in FIPS-180-2 are as follows:\n */\n"
- title: '#ifndef USE_MODIFIED_MACROS'
  contents:
  - '#ifndef USE_MODIFIED_MACROS

    '
- title: '#define SHA_Ch(x,y,z)        (((x) & (y)) ^ ((~(x)) & (z)))'
  contents:
  - '#define SHA_Ch(x,y,z)        (((x) & (y)) ^ ((~(x)) & (z)))

    '
- title: '#define SHA_Maj(x,y,z)       (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))'
  contents:
  - '#define SHA_Maj(x,y,z)       (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))

    '
- title: '#else /* USE_MODIFIED_MACROS */'
  contents:
  - '#else /* USE_MODIFIED_MACROS */

    '
- title: /*
  contents:
  - "/*\n * The following definitions are equivalent and potentially faster.\n */\n"
- title: '#define SHA_Ch(x, y, z)      (((x) & ((y) ^ (z))) ^ (z))'
  contents:
  - '#define SHA_Ch(x, y, z)      (((x) & ((y) ^ (z))) ^ (z))

    '
- title: '#define SHA_Maj(x, y, z)     (((x) & ((y) | (z))) | ((y) & (z)))'
  contents:
  - '#define SHA_Maj(x, y, z)     (((x) & ((y) | (z))) | ((y) & (z)))

    '
- title: '#endif /* USE_MODIFIED_MACROS */'
  contents:
  - '#endif /* USE_MODIFIED_MACROS */

    '
- title: '#define SHA_Parity(x, y, z)  ((x) ^ (y) ^ (z))'
  contents:
  - '#define SHA_Parity(x, y, z)  ((x) ^ (y) ^ (z))

    '
- title: '#endif /* _SHA_PRIVATE__H */'
  contents:
  - '#endif /* _SHA_PRIVATE__H */

    '
- title: 8.3 The HMAC Code
  contents:
  - '8.3 The HMAC Code

    '
- title: /**************************** hmac.c ****************************/
  contents:
  - '/**************************** hmac.c ****************************/

    '
- title: /******************** See RFC 4634 for details ******************/
  contents:
  - '/******************** See RFC 4634 for details ******************/

    '
- title: /*
  contents:
  - "/*\n *  Description:\n *      This file implements the HMAC algorithm (Keyed-Hashing\
    \ for\n *      Message Authentication, RFC2104), expressed in terms of the\n *\
    \      various SHA algorithms.\n */\n"
- title: '#include "sha.h"'
  contents:
  - '#include "sha.h"

    '
- title: /*
  contents:
  - "/*\n *  hmac\n *\n *  Description:\n *      This function will compute an HMAC\
    \ message digest.\n *\n *  Parameters:\n *      whichSha: [in]\n *          One\
    \ of SHA1, SHA224, SHA256, SHA384, SHA512\n *      key: [in]\n *          The\
    \ secret shared key.\n *      key_len: [in]\n *          The length of the secret\
    \ shared key.\n *      message_array: [in]\n *          An array of characters\
    \ representing the message.\n *      length: [in]\n *          The length of the\
    \ message in message_array\n *      digest: [out]\n *          Where the digest\
    \ is returned.\n *          NOTE: The length of the digest is determined by\n\
    \ *              the value of whichSha.\n *\n *  Returns:\n *      sha Error Code.\n\
    \ *\n */\n"
- title: int hmac(SHAversion whichSha, const unsigned char *text, int text_len,
  contents:
  - "int hmac(SHAversion whichSha, const unsigned char *text, int text_len,\n    const\
    \ unsigned char *key, int key_len,\n    uint8_t digest[USHAMaxHashSize])\n"
- title: '{'
  contents:
  - "{\n  HMACContext ctx;\n  return hmacReset(&ctx, whichSha, key, key_len) ||\n\
    \         hmacInput(&ctx, text, text_len) ||\n         hmacResult(&ctx, digest);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n *  hmacReset\n *\n *  Description:\n *      This function will initialize\
    \ the hmacContext in preparation\n *      for computing a new HMAC message digest.\n\
    \ *\n *  Parameters:\n *      context: [in/out]\n *          The context to reset.\n\
    \ *      whichSha: [in]\n *          One of SHA1, SHA224, SHA256, SHA384, SHA512\n\
    \ *      key: [in]\n *          The secret shared key.\n *      key_len: [in]\n\
    \ *          The length of the secret shared key.\n *\n *  Returns:\n *      sha\
    \ Error Code.\n *\n */\n"
- title: int hmacReset(HMACContext *ctx, enum SHAversion whichSha,
  contents:
  - "int hmacReset(HMACContext *ctx, enum SHAversion whichSha,\n    const unsigned\
    \ char *key, int key_len)\n"
- title: '{'
  contents:
  - "{\n  int i, blocksize, hashsize;\n  /* inner padding - key XORd with ipad */\n\
    \  unsigned char k_ipad[USHA_Max_Message_Block_Size];\n  /* temporary buffer when\
    \ keylen > blocksize */\n  unsigned char tempkey[USHAMaxHashSize];\n  if (!ctx)\
    \ return shaNull;\n  blocksize = ctx->blockSize = USHABlockSize(whichSha);\n \
    \ hashsize = ctx->hashSize = USHAHashSize(whichSha);\n  ctx->whichSha = whichSha;\n\
    \  /*\n   * If key is longer than the hash blocksize,\n   * reset it to key =\
    \ HASH(key).\n   */\n  if (key_len > blocksize) {\n    USHAContext tctx;\n   \
    \ int err = USHAReset(&tctx, whichSha) ||\n              USHAInput(&tctx, key,\
    \ key_len) ||\n              USHAResult(&tctx, tempkey);\n    if (err != shaSuccess)\
    \ return err;\n    key = tempkey;\n    key_len = hashsize;\n  }\n  /*\n   * The\
    \ HMAC transform looks like:\n   *\n   * SHA(K XOR opad, SHA(K XOR ipad, text))\n\
    \   *\n   * where K is an n byte key.\n   * ipad is the byte 0x36 repeated blocksize\
    \ times\n   * opad is the byte 0x5c repeated blocksize times\n   * and text is\
    \ the data being protected.\n   */\n  /* store key into the pads, XOR'd with ipad\
    \ and opad values */\n  for (i = 0; i < key_len; i++) {\n    k_ipad[i] = key[i]\
    \ ^ 0x36;\n    ctx->k_opad[i] = key[i] ^ 0x5c;\n  }\n  /* remaining pad bytes\
    \ are '\\0' XOR'd with ipad and opad values */\n  for ( ; i < blocksize; i++)\
    \ {\n    k_ipad[i] = 0x36;\n    ctx->k_opad[i] = 0x5c;\n  }\n  /* perform inner\
    \ hash */\n  /* init context for 1st pass */\n  return USHAReset(&ctx->shaContext,\
    \ whichSha) ||\n         /* and start with inner pad */\n         USHAInput(&ctx->shaContext,\
    \ k_ipad, blocksize);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n *  hmacInput\n *\n *  Description:\n *      This function accepts an array\
    \ of octets as the next portion\n *      of the message.\n *\n *  Parameters:\n\
    \ *      context: [in/out]\n *          The HMAC context to update\n *      message_array:\
    \ [in]\n *          An array of characters representing the next portion of\n\
    \ *          the message.\n *      length: [in]\n *          The length of the\
    \ message in message_array\n *\n *  Returns:\n *      sha Error Code.\n *\n */\n"
- title: int hmacInput(HMACContext *ctx, const unsigned char *text,
  contents:
  - "int hmacInput(HMACContext *ctx, const unsigned char *text,\n    int text_len)\n"
- title: '{'
  contents:
  - "{\n  if (!ctx) return shaNull;\n  /* then text of datagram */\n  return USHAInput(&ctx->shaContext,\
    \ text, text_len);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * HMACFinalBits\n *\n * Description:\n *   This function will add in any\
    \ final bits of the message.\n *\n * Parameters:\n *   context: [in/out]\n * \
    \    The HMAC context to update\n *   message_bits: [in]\n *     The final bits\
    \ of the message, in the upper portion of the\n *     byte. (Use 0b###00000 instead\
    \ of 0b00000### to input the\n *     three bits ###.)\n *   length: [in]\n * \
    \    The number of bits in message_bits, between 1 and 7.\n *\n * Returns:\n *\
    \   sha Error Code.\n */\n"
- title: int hmacFinalBits(HMACContext *ctx,
  contents:
  - "int hmacFinalBits(HMACContext *ctx,\n    const uint8_t bits,\n    unsigned int\
    \ bitcount)\n"
- title: '{'
  contents:
  - "{\n  if (!ctx) return shaNull;\n  /* then final bits of datagram */\n  return\
    \ USHAFinalBits(&ctx->shaContext, bits, bitcount);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * HMACResult\n *\n * Description:\n *   This function will return the N-byte\
    \ message digest into the\n *   Message_Digest array provided by the caller.\n\
    \ *   NOTE: The first octet of hash is stored in the 0th element,\n *      the\
    \ last octet of hash in the Nth element.\n *\n * Parameters:\n *   context: [in/out]\n\
    \ *     The context to use to calculate the HMAC hash.\n *   digest: [out]\n *\
    \     Where the digest is returned.\n *   NOTE 2: The length of the hash is determined\
    \ by the value of\n *      whichSha that was passed to hmacReset().\n *\n * Returns:\n\
    \ *   sha Error Code.\n *\n */\n"
- title: int hmacResult(HMACContext *ctx, uint8_t *digest)
  contents:
  - 'int hmacResult(HMACContext *ctx, uint8_t *digest)

    '
- title: '{'
  contents:
  - "{\n  if (!ctx) return shaNull;\n  /* finish up 1st pass */\n  /* (Use digest\
    \ here as a temporary buffer.) */\n  return USHAResult(&ctx->shaContext, digest)\
    \ ||\n         /* perform outer SHA */\n         /* init context for 2nd pass\
    \ */\n         USHAReset(&ctx->shaContext, ctx->whichSha) ||\n         /* start\
    \ with outer pad */\n         USHAInput(&ctx->shaContext, ctx->k_opad, ctx->blockSize)\
    \ ||\n         /* then results of 1st hash */\n         USHAInput(&ctx->shaContext,\
    \ digest, ctx->hashSize) ||\n         /* finish up 2nd pass */\n         USHAResult(&ctx->shaContext,\
    \ digest);\n"
- title: '}'
  contents:
  - '}

    '
- title: 8.4.  The Test Driver
  contents:
  - "8.4.  The Test Driver\n   The following code is a main program test driver to\
    \ exercise the code\n   in sha1.c, sha224-256.c, and sha384-512.c.  The test driver\
    \ can also\n   be used as a stand-alone program for generating the hashes.\n \
    \  See also [RFC2202], [RFC4231], and [SHAVS].\n"
- title: /**************************** shatest.c ****************************/
  contents:
  - '/**************************** shatest.c ****************************/

    '
- title: /********************* See RFC 4634 for details ********************/
  contents:
  - '/********************* See RFC 4634 for details ********************/

    '
- title: /*
  contents:
  - "/*\n *  Description:\n *    This file will exercise the SHA code performing\n\
    \ *      the three tests documented in FIPS PUB 180-2\n *        (http://csrc.nist.gov/publications/fips/\n\
    \ *         fips180-2/fips180-2withchangenotice.pdf)\n *      one that calls SHAInput\
    \ with an exact multiple of 512 bits\n *      the seven tests documented for each\
    \ algorithm in\n *        \"The Secure Hash Algorithm Validation System (SHAVS)\"\
    ,\n *        three of which are bit-level tests\n *        (http://csrc.nist.gov/cryptval/shs/SHAVS.pdf)\n\
    \ *\n *    This file will exercise the HMAC SHA1 code performing\n *      the\
    \ seven tests documented in RFCs 2202 and 4231.\n *\n *    To run the tests and\
    \ just see PASSED/FAILED, use the -p option.\n *\n *    Other options exercise:\n\
    \ *      hashing an arbitrary string\n *      hashing a file's contents\n *  \
    \    a few error test checks\n *      printing the results in raw format\n *\n\
    \ *  Portability Issues:\n *    None.\n *\n */\n"
- title: '#include <stdint.h>'
  contents:
  - '#include <stdint.h>

    '
- title: '#include <stdio.h>'
  contents:
  - '#include <stdio.h>

    '
- title: '#include <stdlib.h>'
  contents:
  - '#include <stdlib.h>

    '
- title: '#include <string.h>'
  contents:
  - '#include <string.h>

    '
- title: '#include <ctype.h>'
  contents:
  - '#include <ctype.h>

    '
- title: '#include "sha.h"'
  contents:
  - '#include "sha.h"

    '
- title: static int xgetopt(int argc, char **argv, const char *optstring);
  contents:
  - 'static int xgetopt(int argc, char **argv, const char *optstring);

    '
- title: extern char *xoptarg;
  contents:
  - 'extern char *xoptarg;

    '
- title: static int scasecmp(const char *s1, const char *s2);
  contents:
  - 'static int scasecmp(const char *s1, const char *s2);

    '
- title: /*
  contents:
  - "/*\n *  Define patterns for testing\n */\n"
- title: '#define TEST1    "abc"'
  contents:
  - '#define TEST1    "abc"

    '
- title: '#define TEST2_1  \'
  contents:
  - "#define TEST2_1  \\\n        \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\
    \n"
- title: '#define TEST2_2a \'
  contents:
  - "#define TEST2_2a \\\n        \"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn\"\
    \n"
- title: '#define TEST2_2b \'
  contents:
  - "#define TEST2_2b \\\n        \"hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\"\
    \n"
- title: '#define TEST2_2  TEST2_2a TEST2_2b'
  contents:
  - '#define TEST2_2  TEST2_2a TEST2_2b

    '
- title: '#define TEST3    "a"                            /* times 1000000 */'
  contents:
  - '#define TEST3    "a"                            /* times 1000000 */

    '
- title: '#define TEST4a   "01234567012345670123456701234567"'
  contents:
  - '#define TEST4a   "01234567012345670123456701234567"

    '
- title: '#define TEST4b   "01234567012345670123456701234567"'
  contents:
  - "#define TEST4b   \"01234567012345670123456701234567\"\n    /* an exact multiple\
    \ of 512 bits */\n"
- title: '#define TEST4   TEST4a TEST4b                   /* times 10 */'
  contents:
  - '#define TEST4   TEST4a TEST4b                   /* times 10 */

    '
- title: '#define TEST7_1 \'
  contents:
  - "#define TEST7_1 \\\n  \"\\x49\\xb2\\xae\\xc2\\x59\\x4b\\xbe\\x3a\\x3b\\x11\\\
    x75\\x42\\xd9\\x4a\\xc8\"\n"
- title: '#define TEST8_1 \'
  contents:
  - "#define TEST8_1 \\\n  \"\\x9a\\x7d\\xfd\\xf1\\xec\\xea\\xd0\\x6e\\xd6\\x46\\\
    xaa\\x55\\xfe\\x75\\x71\\x46\"\n"
- title: '#define TEST9_1 \'
  contents:
  - "#define TEST9_1 \\\n  \"\\x65\\xf9\\x32\\x99\\x5b\\xa4\\xce\\x2c\\xb1\\xb4\\\
    xa2\\xe7\\x1a\\xe7\\x02\\x20\" \\\n  \"\\xaa\\xce\\xc8\\x96\\x2d\\xd4\\x49\\x9c\\\
    xbd\\x7c\\x88\\x7a\\x94\\xea\\xaa\\x10\" \\\n  \"\\x1e\\xa5\\xaa\\xbc\\x52\\x9b\\\
    x4e\\x7e\\x43\\x66\\x5a\\x5a\\xf2\\xcd\\x03\\xfe\" \\\n  \"\\x67\\x8e\\xa6\\xa5\\\
    x00\\x5b\\xba\\x3b\\x08\\x22\\x04\\xc2\\x8b\\x91\\x09\\xf4\" \\\n  \"\\x69\\xda\\\
    xc9\\x2a\\xaa\\xb3\\xaa\\x7c\\x11\\xa1\\xb3\\x2a\"\n"
- title: '#define TEST10_1 \'
  contents:
  - "#define TEST10_1 \\\n  \"\\xf7\\x8f\\x92\\x14\\x1b\\xcd\\x17\\x0a\\xe8\\x9b\\\
    x4f\\xba\\x15\\xa1\\xd5\\x9f\" \\\n  \"\\x3f\\xd8\\x4d\\x22\\x3c\\x92\\x51\\xbd\\\
    xac\\xbb\\xae\\x61\\xd0\\x5e\\xd1\\x15\" \\\n  \"\\xa0\\x6a\\x7c\\xe1\\x17\\xb7\\\
    xbe\\xea\\xd2\\x44\\x21\\xde\\xd9\\xc3\\x25\\x92\" \\\n  \"\\xbd\\x57\\xed\\xea\\\
    xe3\\x9c\\x39\\xfa\\x1f\\xe8\\x94\\x6a\\x84\\xd0\\xcf\\x1f\" \\\n  \"\\x7b\\xee\\\
    xad\\x17\\x13\\xe2\\xe0\\x95\\x98\\x97\\x34\\x7f\\x67\\xc8\\x0b\\x04\" \\\n  \"\
    \\x00\\xc2\\x09\\x81\\x5d\\x6b\\x10\\xa6\\x83\\x83\\x6f\\xd5\\x56\\x2a\\x56\\\
    xca\" \\\n  \"\\xb1\\xa2\\x8e\\x81\\xb6\\x57\\x66\\x54\\x63\\x1c\\xf1\\x65\\x66\\\
    xb8\\x6e\\x3b\" \\\n  \"\\x33\\xa1\\x08\\xb0\\x53\\x07\\xc0\\x0a\\xff\\x14\\xa7\\\
    x68\\xed\\x73\\x50\\x60\" \\\n  \"\\x6a\\x0f\\x85\\xe6\\xa9\\x1d\\x39\\x6f\\x5b\\\
    x5c\\xbe\\x57\\x7f\\x9b\\x38\\x80\" \\\n  \"\\x7c\\x7d\\x52\\x3d\\x6d\\x79\\x2f\\\
    x6e\\xbc\\x24\\xa4\\xec\\xf2\\xb3\\xa4\\x27\" \\\n  \"\\xcd\\xbb\\xfb\"\n"
- title: '#define TEST7_224 \'
  contents:
  - "#define TEST7_224 \\\n  \"\\xf0\\x70\\x06\\xf2\\x5a\\x0b\\xea\\x68\\xcd\\x76\\\
    xa2\\x95\\x87\\xc2\\x8d\"\n"
- title: '#define TEST8_224 \'
  contents:
  - "#define TEST8_224 \\\n  \"\\x18\\x80\\x40\\x05\\xdd\\x4f\\xbd\\x15\\x56\\x29\\\
    x9d\\x6f\\x9d\\x93\\xdf\\x62\"\n"
- title: '#define TEST9_224 \'
  contents:
  - "#define TEST9_224 \\\n  \"\\xa2\\xbe\\x6e\\x46\\x32\\x81\\x09\\x02\\x94\\xd9\\\
    xce\\x94\\x82\\x65\\x69\\x42\" \\\n  \"\\x3a\\x3a\\x30\\x5e\\xd5\\xe2\\x11\\x6c\\\
    xd4\\xa4\\xc9\\x87\\xfc\\x06\\x57\\x00\" \\\n  \"\\x64\\x91\\xb1\\x49\\xcc\\xd4\\\
    xb5\\x11\\x30\\xac\\x62\\xb1\\x9d\\xc2\\x48\\xc7\" \\\n  \"\\x44\\x54\\x3d\\x20\\\
    xcd\\x39\\x52\\xdc\\xed\\x1f\\x06\\xcc\\x3b\\x18\\xb9\\x1f\" \\\n  \"\\x3f\\x55\\\
    x63\\x3e\\xcc\\x30\\x85\\xf4\\x90\\x70\\x60\\xd2\"\n"
- title: '#define TEST10_224 \'
  contents:
  - "#define TEST10_224 \\\n  \"\\x55\\xb2\\x10\\x07\\x9c\\x61\\xb5\\x3a\\xdd\\x52\\\
    x06\\x22\\xd1\\xac\\x97\\xd5\" \\\n  \"\\xcd\\xbe\\x8c\\xb3\\x3a\\xa0\\xae\\x34\\\
    x45\\x17\\xbe\\xe4\\xd7\\xba\\x09\\xab\" \\\n  \"\\xc8\\x53\\x3c\\x52\\x50\\x88\\\
    x7a\\x43\\xbe\\xbb\\xac\\x90\\x6c\\x2e\\x18\\x37\" \\\n  \"\\xf2\\x6b\\x36\\xa5\\\
    x9a\\xe3\\xbe\\x78\\x14\\xd5\\x06\\x89\\x6b\\x71\\x8b\\x2a\" \\\n  \"\\x38\\x3e\\\
    xcd\\xac\\x16\\xb9\\x61\\x25\\x55\\x3f\\x41\\x6f\\xf3\\x2c\\x66\\x74\" \\\n  \"\
    \\xc7\\x45\\x99\\xa9\\x00\\x53\\x86\\xd9\\xce\\x11\\x12\\x24\\x5f\\x48\\xee\\\
    x47\" \\\n  \"\\x0d\\x39\\x6c\\x1e\\xd6\\x3b\\x92\\x67\\x0c\\xa5\\x6e\\xc8\\x4d\\\
    xee\\xa8\\x14\" \\\n  \"\\xb6\\x13\\x5e\\xca\\x54\\x39\\x2b\\xde\\xdb\\x94\\x89\\\
    xbc\\x9b\\x87\\x5a\\x8b\" \\\n  \"\\xaf\\x0d\\xc1\\xae\\x78\\x57\\x36\\x91\\x4a\\\
    xb7\\xda\\xa2\\x64\\xbc\\x07\\x9d\" \\\n  \"\\x26\\x9f\\x2c\\x0d\\x7e\\xdd\\xd8\\\
    x10\\xa4\\x26\\x14\\x5a\\x07\\x76\\xf6\\x7c\" \\\n  \"\\x87\\x82\\x73\"\n"
- title: '#define TEST7_256 \'
  contents:
  - "#define TEST7_256 \\\n  \"\\xbe\\x27\\x46\\xc6\\xdb\\x52\\x76\\x5f\\xdb\\x2f\\\
    x88\\x70\\x0f\\x9a\\x73\"\n"
- title: '#define TEST8_256 \'
  contents:
  - "#define TEST8_256 \\\n  \"\\xe3\\xd7\\x25\\x70\\xdc\\xdd\\x78\\x7c\\xe3\\x88\\\
    x7a\\xb2\\xcd\\x68\\x46\\x52\"\n"
- title: '#define TEST9_256 \'
  contents:
  - "#define TEST9_256 \\\n  \"\\x3e\\x74\\x03\\x71\\xc8\\x10\\xc2\\xb9\\x9f\\xc0\\\
    x4e\\x80\\x49\\x07\\xef\\x7c\" \\\n  \"\\xf2\\x6b\\xe2\\x8b\\x57\\xcb\\x58\\xa3\\\
    xe2\\xf3\\xc0\\x07\\x16\\x6e\\x49\\xc1\" \\\n  \"\\x2e\\x9b\\xa3\\x4c\\x01\\x04\\\
    x06\\x91\\x29\\xea\\x76\\x15\\x64\\x25\\x45\\x70\" \\\n  \"\\x3a\\x2b\\xd9\\x01\\\
    xe1\\x6e\\xb0\\xe0\\x5d\\xeb\\xa0\\x14\\xeb\\xff\\x64\\x06\" \\\n  \"\\xa0\\x7d\\\
    x54\\x36\\x4e\\xff\\x74\\x2d\\xa7\\x79\\xb0\\xb3\"\n"
- title: '#define TEST10_256 \'
  contents:
  - "#define TEST10_256 \\\n  \"\\x83\\x26\\x75\\x4e\\x22\\x77\\x37\\x2f\\x4f\\xc1\\\
    x2b\\x20\\x52\\x7a\\xfe\\xf0\" \\\n  \"\\x4d\\x8a\\x05\\x69\\x71\\xb1\\x1a\\xd5\\\
    x71\\x23\\xa7\\xc1\\x37\\x76\\x00\\x00\" \\\n  \"\\xd7\\xbe\\xf6\\xf3\\xc1\\xf7\\\
    xa9\\x08\\x3a\\xa3\\x9d\\x81\\x0d\\xb3\\x10\\x77\" \\\n  \"\\x7d\\xab\\x8b\\x1e\\\
    x7f\\x02\\xb8\\x4a\\x26\\xc7\\x73\\x32\\x5f\\x8b\\x23\\x74\" \\\n  \"\\xde\\x7a\\\
    x4b\\x5a\\x58\\xcb\\x5c\\x5c\\xf3\\x5b\\xce\\xe6\\xfb\\x94\\x6e\\x5b\" \\\n  \"\
    \\xd6\\x94\\xfa\\x59\\x3a\\x8b\\xeb\\x3f\\x9d\\x65\\x92\\xec\\xed\\xaa\\x66\\\
    xca\" \\\n  \"\\x82\\xa2\\x9d\\x0c\\x51\\xbc\\xf9\\x33\\x62\\x30\\xe5\\xd7\\x84\\\
    xe4\\xc0\\xa4\" \\\n  \"\\x3f\\x8d\\x79\\xa3\\x0a\\x16\\x5c\\xba\\xbe\\x45\\x2b\\\
    x77\\x4b\\x9c\\x71\\x09\" \\\n  \"\\xa9\\x7d\\x13\\x8f\\x12\\x92\\x28\\x96\\x6f\\\
    x6c\\x0a\\xdc\\x10\\x6a\\xad\\x5a\" \\\n  \"\\x9f\\xdd\\x30\\x82\\x57\\x69\\xb2\\\
    xc6\\x71\\xaf\\x67\\x59\\xdf\\x28\\xeb\\x39\" \\\n  \"\\x3d\\x54\\xd6\"\n"
- title: '#define TEST7_384 \'
  contents:
  - "#define TEST7_384 \\\n  \"\\x8b\\xc5\\x00\\xc7\\x7c\\xee\\xd9\\x87\\x9d\\xa9\\\
    x89\\x10\\x7c\\xe0\\xaa\"\n"
- title: '#define TEST8_384 \'
  contents:
  - "#define TEST8_384 \\\n  \"\\xa4\\x1c\\x49\\x77\\x79\\xc0\\x37\\x5f\\xf1\\x0a\\\
    x7f\\x4e\\x08\\x59\\x17\\x39\"\n"
- title: '#define TEST9_384 \'
  contents:
  - "#define TEST9_384 \\\n  \"\\x68\\xf5\\x01\\x79\\x2d\\xea\\x97\\x96\\x76\\x70\\\
    x22\\xd9\\x3d\\xa7\\x16\\x79\" \\\n  \"\\x30\\x99\\x20\\xfa\\x10\\x12\\xae\\xa3\\\
    x57\\xb2\\xb1\\x33\\x1d\\x40\\xa1\\xd0\" \\\n  \"\\x3c\\x41\\xc2\\x40\\xb3\\xc9\\\
    xa7\\x5b\\x48\\x92\\xf4\\xc0\\x72\\x4b\\x68\\xc8\" \\\n  \"\\x75\\x32\\x1a\\xb8\\\
    xcf\\xe5\\x02\\x3b\\xd3\\x75\\xbc\\x0f\\x94\\xbd\\x89\\xfe\" \\\n  \"\\x04\\xf2\\\
    x97\\x10\\x5d\\x7b\\x82\\xff\\xc0\\x02\\x1a\\xeb\\x1c\\xcb\\x67\\x4f\" \\\n  \"\
    \\x52\\x44\\xea\\x34\\x97\\xde\\x26\\xa4\\x19\\x1c\\x5f\\x62\\xe5\\xe9\\xa2\\\
    xd8\" \\\n  \"\\x08\\x2f\\x05\\x51\\xf4\\xa5\\x30\\x68\\x26\\xe9\\x1c\\xc0\\x06\\\
    xce\\x1b\\xf6\" \\\n  \"\\x0f\\xf7\\x19\\xd4\\x2f\\xa5\\x21\\xc8\\x71\\xcd\\x23\\\
    x94\\xd9\\x6e\\xf4\\x46\" \\\n  \"\\x8f\\x21\\x96\\x6b\\x41\\xf2\\xba\\x80\\xc2\\\
    x6e\\x83\\xa9\"\n"
- title: '#define TEST10_384 \'
  contents:
  - "#define TEST10_384 \\\n  \"\\x39\\x96\\x69\\xe2\\x8f\\x6b\\x9c\\x6d\\xbc\\xbb\\\
    x69\\x12\\xec\\x10\\xff\\xcf\" \\\n  \"\\x74\\x79\\x03\\x49\\xb7\\xdc\\x8f\\xbe\\\
    x4a\\x8e\\x7b\\x3b\\x56\\x21\\xdb\\x0f\" \\\n  \"\\x3e\\x7d\\xc8\\x7f\\x82\\x32\\\
    x64\\xbb\\xe4\\x0d\\x18\\x11\\xc9\\xea\\x20\\x61\" \\\n  \"\\xe1\\xc8\\x4a\\xd1\\\
    x0a\\x23\\xfa\\xc1\\x72\\x7e\\x72\\x02\\xfc\\x3f\\x50\\x42\" \\\n  \"\\xe6\\xbf\\\
    x58\\xcb\\xa8\\xa2\\x74\\x6e\\x1f\\x64\\xf9\\xb9\\xea\\x35\\x2c\\x71\" \\\n  \"\
    \\x15\\x07\\x05\\x3c\\xf4\\xe5\\x33\\x9d\\x52\\x86\\x5f\\x25\\xcc\\x22\\xb5\\\
    xe8\" \\\n  \"\\x77\\x84\\xa1\\x2f\\xc9\\x61\\xd6\\x6c\\xb6\\xe8\\x95\\x73\\x19\\\
    x9a\\x2c\\xe6\" \\\n  \"\\x56\\x5c\\xbd\\xf1\\x3d\\xca\\x40\\x38\\x32\\xcf\\xcb\\\
    x0e\\x8b\\x72\\x11\\xe8\" \\\n  \"\\x3a\\xf3\\x2a\\x11\\xac\\x17\\x92\\x9f\\xf1\\\
    xc0\\x73\\xa5\\x1c\\xc0\\x27\\xaa\" \\\n  \"\\xed\\xef\\xf8\\x5a\\xad\\x7c\\x2b\\\
    x7c\\x5a\\x80\\x3e\\x24\\x04\\xd9\\x6d\\x2a\" \\\n  \"\\x77\\x35\\x7b\\xda\\x1a\\\
    x6d\\xae\\xed\\x17\\x15\\x1c\\xb9\\xbc\\x51\\x25\\xa4\" \\\n  \"\\x22\\xe9\\x41\\\
    xde\\x0c\\xa0\\xfc\\x50\\x11\\xc2\\x3e\\xcf\\xfe\\xfd\\xd0\\x96\" \\\n  \"\\x76\\\
    x71\\x1c\\xf3\\xdb\\x0a\\x34\\x40\\x72\\x0e\\x16\\x15\\xc1\\xf2\\x2f\\xbc\" \\\
    \n  \"\\x3c\\x72\\x1d\\xe5\\x21\\xe1\\xb9\\x9b\\xa1\\xbd\\x55\\x77\\x40\\x86\\\
    x42\\x14\" \\\n  \"\\x7e\\xd0\\x96\"\n"
- title: '#define TEST7_512 \'
  contents:
  - "#define TEST7_512 \\\n  \"\\x08\\xec\\xb5\\x2e\\xba\\xe1\\xf7\\x42\\x2d\\xb6\\\
    x2b\\xcd\\x54\\x26\\x70\"\n"
- title: '#define TEST8_512 \'
  contents:
  - "#define TEST8_512 \\\n  \"\\x8d\\x4e\\x3c\\x0e\\x38\\x89\\x19\\x14\\x91\\x81\\\
    x6e\\x9d\\x98\\xbf\\xf0\\xa0\"\n"
- title: '#define TEST9_512 \'
  contents:
  - "#define TEST9_512 \\\n  \"\\x3a\\xdd\\xec\\x85\\x59\\x32\\x16\\xd1\\x61\\x9a\\\
    xa0\\x2d\\x97\\x56\\x97\\x0b\" \\\n  \"\\xfc\\x70\\xac\\xe2\\x74\\x4f\\x7c\\x6b\\\
    x27\\x88\\x15\\x10\\x28\\xf7\\xb6\\xa2\" \\\n  \"\\x55\\x0f\\xd7\\x4a\\x7e\\x6e\\\
    x69\\xc2\\xc9\\xb4\\x5f\\xc4\\x54\\x96\\x6d\\xc3\" \\\n  \"\\x1d\\x2e\\x10\\xda\\\
    x1f\\x95\\xce\\x02\\xbe\\xb4\\xbf\\x87\\x65\\x57\\x4c\\xbd\" \\\n  \"\\x6e\\x83\\\
    x37\\xef\\x42\\x0a\\xdc\\x98\\xc1\\x5c\\xb6\\xd5\\xe4\\xa0\\x24\\x1b\" \\\n  \"\
    \\xa0\\x04\\x6d\\x25\\x0e\\x51\\x02\\x31\\xca\\xc2\\x04\\x6c\\x99\\x16\\x06\\\
    xab\" \\\n  \"\\x4e\\xe4\\x14\\x5b\\xee\\x2f\\xf4\\xbb\\x12\\x3a\\xab\\x49\\x8d\\\
    x9d\\x44\\x79\" \\\n  \"\\x4f\\x99\\xcc\\xad\\x89\\xa9\\xa1\\x62\\x12\\x59\\xed\\\
    xa7\\x0a\\x5b\\x6d\\xd4\" \\\n  \"\\xbd\\xd8\\x77\\x78\\xc9\\x04\\x3b\\x93\\x84\\\
    xf5\\x49\\x06\"\n"
- title: '#define TEST10_512 \'
  contents:
  - "#define TEST10_512 \\\n  \"\\xa5\\x5f\\x20\\xc4\\x11\\xaa\\xd1\\x32\\x80\\x7a\\\
    x50\\x2d\\x65\\x82\\x4e\\x31\" \\\n  \"\\xa2\\x30\\x54\\x32\\xaa\\x3d\\x06\\xd3\\\
    xe2\\x82\\xa8\\xd8\\x4e\\x0d\\xe1\\xde\" \\\n  \"\\x69\\x74\\xbf\\x49\\x54\\x69\\\
    xfc\\x7f\\x33\\x8f\\x80\\x54\\xd5\\x8c\\x26\\xc4\" \\\n  \"\\x93\\x60\\xc3\\xe8\\\
    x7a\\xf5\\x65\\x23\\xac\\xf6\\xd8\\x9d\\x03\\xe5\\x6f\\xf2\" \\\n  \"\\xf8\\x68\\\
    x00\\x2b\\xc3\\xe4\\x31\\xed\\xc4\\x4d\\xf2\\xf0\\x22\\x3d\\x4b\\xb3\" \\\n  \"\
    \\xb2\\x43\\x58\\x6e\\x1a\\x7d\\x92\\x49\\x36\\x69\\x4f\\xcb\\xba\\xf8\\x8d\\\
    x95\" \\\n  \"\\x19\\xe4\\xeb\\x50\\xa6\\x44\\xf8\\xe4\\xf9\\x5e\\xb0\\xea\\x95\\\
    xbc\\x44\\x65\" \\\n  \"\\xc8\\x82\\x1a\\xac\\xd2\\xfe\\x15\\xab\\x49\\x81\\x16\\\
    x4b\\xbb\\x6d\\xc3\\x2f\" \\\n  \"\\x96\\x90\\x87\\xa1\\x45\\xb0\\xd9\\xcc\\x9c\\\
    x67\\xc2\\x2b\\x76\\x32\\x99\\x41\" \\\n  \"\\x9c\\xc4\\x12\\x8b\\xe9\\xa0\\x77\\\
    xb3\\xac\\xe6\\x34\\x06\\x4e\\x6d\\x99\\x28\" \\\n  \"\\x35\\x13\\xdc\\x06\\xe7\\\
    x51\\x5d\\x0d\\x73\\x13\\x2e\\x9a\\x0d\\xc6\\xd3\\xb1\" \\\n  \"\\xf8\\xb2\\x46\\\
    xf1\\xa9\\x8a\\x3f\\xc7\\x29\\x41\\xb1\\xe3\\xbb\\x20\\x98\\xe8\" \\\n  \"\\xbf\\\
    x16\\xf2\\x68\\xd6\\x4f\\x0b\\x0f\\x47\\x07\\xfe\\x1e\\xa1\\xa1\\x79\\x1b\" \\\
    \n  \"\\xa2\\xf3\\xc0\\xc7\\x58\\xe5\\xf5\\x51\\x86\\x3a\\x96\\xc9\\x49\\xad\\\
    x47\\xd7\" \\\n  \"\\xfb\\x40\\xd2\"\n"
- title: '#define SHA1_SEED "\xd0\x56\x9c\xb3\x66\x5a\x8a\x43\xeb\x6e\xa2\x3d" \'
  contents:
  - "#define SHA1_SEED \"\\xd0\\x56\\x9c\\xb3\\x66\\x5a\\x8a\\x43\\xeb\\x6e\\xa2\\\
    x3d\" \\\n  \"\\x75\\xa3\\xc4\\xd2\\x05\\x4a\\x0d\\x7d\"\n"
- title: '#define SHA224_SEED "\xd0\x56\x9c\xb3\x66\x5a\x8a\x43\xeb\x6e\xa2" \'
  contents:
  - "#define SHA224_SEED \"\\xd0\\x56\\x9c\\xb3\\x66\\x5a\\x8a\\x43\\xeb\\x6e\\xa2\"\
    \ \\\n  \"\\x3d\\x75\\xa3\\xc4\\xd2\\x05\\x4a\\x0d\\x7d\\x66\\xa9\\xca\\x99\\\
    xc9\\xce\\xb0\" \\\n  \"\\x27\"\n"
- title: '#define SHA256_SEED "\xf4\x1e\xce\x26\x13\xe4\x57\x39\x15\x69\x6b" \'
  contents:
  - "#define SHA256_SEED \"\\xf4\\x1e\\xce\\x26\\x13\\xe4\\x57\\x39\\x15\\x69\\x6b\"\
    \ \\\n  \"\\x5a\\xdc\\xd5\\x1c\\xa3\\x28\\xbe\\x3b\\xf5\\x66\\xa9\\xca\\x99\\\
    xc9\\xce\\xb0\" \\\n  \"\\x27\\x9c\\x1c\\xb0\\xa7\"\n"
- title: '#define SHA384_SEED "\x82\x40\xbc\x51\xe4\xec\x7e\xf7\x6d\x18\xe3" \'
  contents:
  - "#define SHA384_SEED \"\\x82\\x40\\xbc\\x51\\xe4\\xec\\x7e\\xf7\\x6d\\x18\\xe3\"\
    \ \\\n  \"\\x52\\x04\\xa1\\x9f\\x51\\xa5\\x21\\x3a\\x73\\xa8\\x1d\\x6f\\x94\\\
    x46\\x80\\xd3\" \\\n  \"\\x07\\x59\\x48\\xb7\\xe4\\x63\\x80\\x4e\\xa3\\xd2\\x6e\\\
    x13\\xea\\x82\\x0d\\x65\" \\\n  \"\\xa4\\x84\\xbe\\x74\\x53\"\n"
- title: '#define SHA512_SEED "\x47\x3f\xf1\xb9\xb3\xff\xdf\xa1\x26\x69\x9a" \'
  contents:
  - "#define SHA512_SEED \"\\x47\\x3f\\xf1\\xb9\\xb3\\xff\\xdf\\xa1\\x26\\x69\\x9a\"\
    \ \\\n  \"\\xc7\\xef\\x9e\\x8e\\x78\\x77\\x73\\x09\\x58\\x24\\xc6\\x42\\x55\\\
    x7c\\x13\\x99\" \\\n  \"\\xd9\\x8e\\x42\\x20\\x44\\x8d\\xc3\\x5b\\x99\\xbf\\xdd\\\
    x44\\x77\\x95\\x43\\x92\" \\\n  \"\\x4c\\x1c\\xe9\\x3b\\xc5\\x94\\x15\\x38\\x89\\\
    x5d\\xb9\\x88\\x26\\x1b\\x00\\x77\" \\\n  \"\\x4b\\x12\\x27\\x20\\x39\"\n"
- title: '#define TESTCOUNT 10'
  contents:
  - '#define TESTCOUNT 10

    '
- title: '#define HASHCOUNT 5'
  contents:
  - '#define HASHCOUNT 5

    '
- title: '#define RANDOMCOUNT 4'
  contents:
  - '#define RANDOMCOUNT 4

    '
- title: '#define HMACTESTCOUNT 7'
  contents:
  - '#define HMACTESTCOUNT 7

    '
- title: '#define PRINTNONE 0'
  contents:
  - '#define PRINTNONE 0

    '
- title: '#define PRINTTEXT 1'
  contents:
  - '#define PRINTTEXT 1

    '
- title: '#define PRINTRAW 2'
  contents:
  - '#define PRINTRAW 2

    '
- title: '#define PRINTHEX 3'
  contents:
  - '#define PRINTHEX 3

    '
- title: '#define PRINTBASE64 4'
  contents:
  - '#define PRINTBASE64 4

    '
- title: '#define PRINTPASSFAIL 1'
  contents:
  - '#define PRINTPASSFAIL 1

    '
- title: '#define PRINTFAIL 2'
  contents:
  - '#define PRINTFAIL 2

    '
- title: '#define length(x) (sizeof(x)-1)'
  contents:
  - '#define length(x) (sizeof(x)-1)

    '
- title: /* Test arrays for hashes. */
  contents:
  - '/* Test arrays for hashes. */

    '
- title: struct hash {
  contents:
  - "struct hash {\n    const char *name;\n    SHAversion whichSha;\n    int hashsize;\n\
    \    struct {\n        const char *testarray;\n        int length;\n        long\
    \ repeatcount;\n        int extrabits;\n        int numberExtrabits;\n       \
    \ const char *resultarray;\n    } tests[TESTCOUNT];\n    const char *randomtest;\n\
    \    const char *randomresults[RANDOMCOUNT];\n"
- title: '} hashes[HASHCOUNT] = {'
  contents:
  - "} hashes[HASHCOUNT] = {\n  { \"SHA1\", SHA1, SHA1HashSize,\n    {\n      /* 1\
    \ */ { TEST1, length(TEST1), 1, 0, 0,\n        \"A9993E364706816ABA3E25717850C26C9CD0D89D\"\
    \ },\n      /* 2 */ { TEST2_1, length(TEST2_1), 1, 0, 0,\n        \"84983E441C3BD26EBAAE4AA1F95129E5E54670F1\"\
    \ },\n      /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,\n        \"34AA973CD4C4DAA4F61EEB2BDBAD27316534016F\"\
    \ },\n      /* 4 */ { TEST4, length(TEST4), 10, 0, 0,\n        \"DEA356A2CDDD90C7A7ECEDC5EBB563934F460452\"\
    \ },\n      /* 5 */ { \"\", 0, 0, 0x98, 5,\n        \"29826B003B906E660EFF4027CE98AF3531AC75BA\"\
    \ },\n      /* 6 */ { \"\\x5e\", 1, 1, 0, 0,\n        \"5E6F80A34A9798CAFC6A5DB96CC57BA4C4DB59C2\"\
    \ },\n      /* 7 */ { TEST7_1, length(TEST7_1), 1, 0x80, 3,\n        \"6239781E03729919C01955B3FFA8ACB60B988340\"\
    \ },\n      /* 8 */ { TEST8_1, length(TEST8_1), 1, 0, 0,\n        \"82ABFF6605DBE1C17DEF12A394FA22A82B544A35\"\
    \ },\n      /* 9 */ { TEST9_1, length(TEST9_1), 1, 0xE0, 3,\n        \"8C5B2A5DDAE5A97FC7F9D85661C672ADBF7933D4\"\
    \ },\n      /* 10 */ { TEST10_1, length(TEST10_1), 1, 0, 0,\n        \"CB0082C8F197D260991BA6A460E76E202BAD27B3\"\
    \ }\n    }, SHA1_SEED, { \"E216836819477C7F78E0D843FE4FF1B6D6C14CD4\",\n     \
    \   \"A2DBC7A5B1C6C0A8BCB7AAA41252A6A7D0690DBC\",\n        \"DB1F9050BB863DFEF4CE37186044E2EEB17EE013\"\
    ,\n        \"127FDEDF43D372A51D5747C48FBFFE38EF6CDF7B\"\n     } },\n  { \"SHA224\"\
    , SHA224, SHA224HashSize,\n    {\n      /* 1 */ { TEST1, length(TEST1), 1, 0,\
    \ 0,\n        \"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\" },\n\
    \      /* 2 */ { TEST2_1, length(TEST2_1), 1, 0, 0,\n        \"75388B16512776CC5DBA5DA1FD890150B0C6455CB4F58B1952522525\"\
    \ },\n      /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,\n        \"20794655980C91D8BBB4C1EA97618A4BF03F42581948B2EE4EE7AD67\"\
    \ },\n      /* 4 */ { TEST4, length(TEST4), 10, 0, 0,\n        \"567F69F168CD7844E65259CE658FE7AADFA25216E68ECA0EB7AB8262\"\
    \ },\n      /* 5 */ { \"\", 0, 0, 0x68, 5,\n        \"E3B048552C3C387BCAB37F6EB06BB79B96A4AEE5FF27F51531A9551C\"\
    \ },\n      /* 6 */ { \"\\x07\", 1, 1, 0, 0,\n        \"00ECD5F138422B8AD74C9799FD826C531BAD2FCABC7450BEE2AA8C2A\"\
    \ },\n      /* 7 */ { TEST7_224, length(TEST7_224), 1, 0xA0, 3,\n        \"1B01DB6CB4A9E43DED1516BEB3DB0B87B6D1EA43187462C608137150\"\
    \ },\n      /* 8 */ { TEST8_224, length(TEST8_224), 1, 0, 0,\n        \"DF90D78AA78821C99B40BA4C966921ACCD8FFB1E98AC388E56191DB1\"\
    \ },\n      /* 9 */ { TEST9_224, length(TEST9_224), 1, 0xE0, 3,\n        \"54BEA6EAB8195A2EB0A7906A4B4A876666300EEFBD1F3B8474F9CD57\"\
    \ },\n      /* 10 */ { TEST10_224, length(TEST10_224), 1, 0, 0,\n        \"0B31894EC8937AD9B91BDFBCBA294D9ADEFAA18E09305E9F20D5C3A4\"\
    \ }\n    }, SHA224_SEED, { \"100966A5B4FDE0B42E2A6C5953D4D7F41BA7CF79FD\"\n  \
    \      \"2DF431416734BE\", \"1DCA396B0C417715DEFAAE9641E10A2E99D55A\"\n      \
    \  \"BCB8A00061EB3BE8BD\", \"1864E627BDB2319973CD5ED7D68DA71D8B\"\n        \"\
    F0F983D8D9AB32C34ADB34\", \"A2406481FC1BCAF24DD08E6752E844\"\n        \"709563FB916227FED598EB621F\"\
    \n     } },\n  { \"SHA256\", SHA256, SHA256HashSize,\n  {\n      /* 1 */ { TEST1,\
    \ length(TEST1), 1, 0, 0, \"BA7816BF8F01CFEA4141\"\n        \"40DE5DAE2223B00361A396177A9CB410FF61F20015AD\"\
    \ },\n      /* 2 */ { TEST2_1, length(TEST2_1), 1, 0, 0, \"248D6A61D20638B8\"\n\
    \        \"E5C026930C3E6039A33CE45964FF2167F6ECEDD419DB06C1\" },\n      /* 3 */\
    \ { TEST3, length(TEST3), 1000000, 0, 0, \"CDC76E5C9914FB92\"\n        \"81A1C7E284D73E67F1809A48A497200E046D39CCC7112CD0\"\
    \ },\n      /* 4 */ { TEST4, length(TEST4), 10, 0, 0, \"594847328451BDFA\"\n \
    \       \"85056225462CC1D867D877FB388DF0CE35F25AB5562BFBB5\" },\n      /* 5 */\
    \ { \"\", 0, 0, 0x68, 5, \"D6D3E02A31A84A8CAA9718ED6C2057BE\"\n        \"09DB45E7823EB5079CE7A573A3760F95\"\
    \ },\n      /* 6 */ { \"\\x19\", 1, 1, 0, 0, \"68AA2E2EE5DFF96E3355E6C7EE373E3D\"\
    \n        \"6A4E17F75F9518D843709C0C9BC3E3D4\" },\n      /* 7 */ { TEST7_256,\
    \ length(TEST7_256), 1, 0x60, 3, \"77EC1DC8\"\n        \"9C821FF2A1279089FA091B35B8CD960BCAF7DE01C6A7680756BEB972\"\
    \ },\n      /* 8 */ { TEST8_256, length(TEST8_256), 1, 0, 0, \"175EE69B02BA\"\n\
    \        \"9B58E2B0A5FD13819CEA573F3940A94F825128CF4209BEABB4E8\" },\n      /*\
    \ 9 */ { TEST9_256, length(TEST9_256), 1, 0xA0, 3, \"3E9AD646\"\n        \"8BBBAD2AC3C2CDC292E018BA5FD70B960CF1679777FCE708FDB066E9\"\
    \ },\n      /* 10 */ { TEST10_256, length(TEST10_256), 1, 0, 0, \"97DBCA7D\"\n\
    \        \"F46D62C8A422C941DD7E835B8AD3361763F7E9B2D95F4F0DA6E1CCBC\" },\n   \
    \ }, SHA256_SEED, { \"83D28614D49C3ADC1D6FC05DB5F48037C056F8D2A4CE44\"\n     \
    \   \"EC6457DEA5DD797CD1\", \"99DBE3127EF2E93DD9322D6A07909EB33B6399\"\n     \
    \   \"5E529B3F954B8581621BB74D39\", \"8D4BE295BB64661CA3C7EFD129A2F7\"\n     \
    \   \"25B33072DBDDE32385B9A87B9AF88EA76F\", \"40AF5D3F9716B040DF9408\"\n     \
    \   \"E31536B70FF906EC51B00447CA97D7DD97C12411F4\"\n    } },\n  { \"SHA384\",\
    \ SHA384, SHA384HashSize,\n    {\n      /* 1 */ { TEST1, length(TEST1), 1, 0,\
    \ 0,\n        \"CB00753F45A35E8BB5A03D699AC65007272C32AB0EDED163\"\n        \"\
    1A8B605A43FF5BED8086072BA1E7CC2358BAECA134C825A7\" },\n      /* 2 */ { TEST2_2,\
    \ length(TEST2_2), 1, 0, 0,\n        \"09330C33F71147E83D192FC782CD1B4753111B173B3B05D2\"\
    \n        \"2FA08086E3B0F712FCC7C71A557E2DB966C3E9FA91746039\" },\n      /* 3\
    \ */ { TEST3, length(TEST3), 1000000, 0, 0,\n        \"9D0E1809716474CB086E834E310A4A1CED149E9C00F24852\"\
    \n        \"7972CEC5704C2A5B07B8B3DC38ECC4EBAE97DDD87F3D8985\" },\n      /* 4\
    \ */ { TEST4, length(TEST4), 10, 0, 0,\n        \"2FC64A4F500DDB6828F6A3430B8DD72A368EB7F3A8322A70\"\
    \n        \"BC84275B9C0B3AB00D27A5CC3C2D224AA6B61A0D79FB4596\" },\n      /* 5\
    \ */ { \"\", 0, 0, 0x10, 5,\n        \"8D17BE79E32B6718E07D8A603EB84BA0478F7FCFD1BB9399\"\
    \n        \"5F7D1149E09143AC1FFCFC56820E469F3878D957A15A3FE4\" },\n      /* 6\
    \ */ { \"\\xb9\", 1, 1, 0, 0,\n        \"BC8089A19007C0B14195F4ECC74094FEC64F01F90929282C\"\
    \n        \"2FB392881578208AD466828B1C6C283D2722CF0AD1AB6938\" },\n      /* 7\
    \ */ { TEST7_384, length(TEST7_384), 1, 0xA0, 3,\n        \"D8C43B38E12E7C42A7C9B810299FD6A770BEF30920F17532\"\
    \n        \"A898DE62C7A07E4293449C0B5FA70109F0783211CFC4BCE3\" },\n      /* 8\
    \ */ { TEST8_384, length(TEST8_384), 1, 0, 0,\n        \"C9A68443A005812256B8EC76B00516F0DBB74FAB26D66591\"\
    \n        \"3F194B6FFB0E91EA9967566B58109CBC675CC208E4C823F7\" },\n      /* 9\
    \ */ { TEST9_384, length(TEST9_384), 1, 0xE0, 3,\n        \"5860E8DE91C21578BB4174D227898A98E0B45C4C760F0095\"\
    \n        \"49495614DAEDC0775D92D11D9F8CE9B064EEAC8DAFC3A297\" },\n      /* 10\
    \ */ { TEST10_384, length(TEST10_384), 1, 0, 0,\n        \"4F440DB1E6EDD2899FA335F09515AA025EE177A79F4B4AAF\"\
    \n        \"38E42B5C4DE660F5DE8FB2A5B2FBD2A3CBFFD20CFF1288C0\" }\n    }, SHA384_SEED,\
    \ { \"CE44D7D63AE0C91482998CF662A51EC80BF6FC68661A3C\"\n        \"57F87566112BD635A743EA904DEB7D7A42AC808CABE697F38F\"\
    , \"F9C6D2\"\n        \"61881FEE41ACD39E67AA8D0BAD507C7363EB67E2B81F45759F9C0FD7B503\"\
    \n        \"DF1A0B9E80BDE7BC333D75B804197D\", \"D96512D8C9F4A7A4967A366C01\"\n\
    \        \"C6FD97384225B58343A88264847C18E4EF8AB7AEE4765FFBC3E30BD485D3\"\n  \
    \      \"638A01418F\", \"0CA76BD0813AF1509E170907A96005938BC985628290B2\"\n  \
    \      \"5FEF73CF6FAD68DDBA0AC8920C94E0541607B0915A7B4457F7\"\n    } },\n  { \"\
    SHA512\", SHA512, SHA512HashSize,\n    {\n      /* 1 */ { TEST1, length(TEST1),\
    \ 1, 0, 0,\n        \"DDAF35A193617ABACC417349AE20413112E6FA4E89A97EA2\"\n   \
    \     \"0A9EEEE64B55D39A2192992A274FC1A836BA3C23A3FEEBBD\"\n        \"454D4423643CE80E2A9AC94FA54CA49F\"\
    \ },\n      /* 2 */ { TEST2_2, length(TEST2_2), 1, 0, 0,\n        \"8E959B75DAE313DA8CF4F72814FC143F8F7779C6EB9F7FA1\"\
    \n        \"7299AEADB6889018501D289E4900F7E4331B99DEC4B5433A\"\n        \"C7D329EEB6DD26545E96E55B874BE909\"\
    \ },\n       /* 3 */ { TEST3, length(TEST3), 1000000, 0, 0,\n        \"E718483D0CE769644E2E42C7BC15B4638E1F98B13B204428\"\
    \n        \"5632A803AFA973EBDE0FF244877EA60A4CB0432CE577C31B\"\n        \"EB009C5C2C49AA2E4EADB217AD8CC09B\"\
    \ },\n      /* 4 */ { TEST4, length(TEST4), 10, 0, 0,\n        \"89D05BA632C699C31231DED4FFC127D5A894DAD412C0E024\"\
    \n        \"DB872D1ABD2BA8141A0F85072A9BE1E2AA04CF33C765CB51\"\n        \"0813A39CD5A84C4ACAA64D3F3FB7BAE9\"\
    \ },\n      /* 5 */ { \"\", 0, 0, 0xB0, 5,\n        \"D4EE29A9E90985446B913CF1D1376C836F4BE2C1CF3CADA0\"\
    \n        \"720A6BF4857D886A7ECB3C4E4C0FA8C7F95214E41DC1B0D2\"\n        \"1B22A84CC03BF8CE4845F34DD5BDBAD4\"\
    \ },\n      /* 6 */ { \"\\xD0\", 1, 1, 0, 0,\n        \"9992202938E882E73E20F6B69E68A0A7149090423D93C81B\"\
    \n        \"AB3F21678D4ACEEEE50E4E8CAFADA4C85A54EA8306826C4A\"\n        \"D6E74CECE9631BFA8A549B4AB3FBBA15\"\
    \ },\n      /* 7 */ { TEST7_512, length(TEST7_512), 1, 0x80, 3,\n        \"ED8DC78E8B01B69750053DBB7A0A9EDA0FB9E9D292B1ED71\"\
    \n        \"5E80A7FE290A4E16664FD913E85854400C5AF05E6DAD316B\"\n        \"7359B43E64F8BEC3C1F237119986BBB6\"\
    \ },\n      /* 8 */ { TEST8_512, length(TEST8_512), 1, 0, 0,\n        \"CB0B67A4B8712CD73C9AABC0B199E9269B20844AFB75ACBD\"\
    \n        \"D1C153C9828924C3DDEDAAFE669C5FDD0BC66F630F677398\"\n        \"8213EB1B16F517AD0DE4B2F0C95C90F8\"\
    \ },\n      /* 9 */ { TEST9_512, length(TEST9_512), 1, 0x80, 3,\n        \"32BA76FC30EAA0208AEB50FFB5AF1864FDBF17902A4DC0A6\"\
    \n        \"82C61FCEA6D92B783267B21080301837F59DE79C6B337DB2\"\n        \"526F8A0A510E5E53CAFED4355FE7C2F1\"\
    \ },\n      /* 10 */ { TEST10_512, length(TEST10_512), 1, 0, 0,\n        \"C665BEFB36DA189D78822D10528CBF3B12B3EEF726039909\"\
    \n        \"C1A16A270D48719377966B957A878E720584779A62825C18\"\n        \"DA26415E49A7176A894E7510FD1451F5\"\
    \ }\n    }, SHA512_SEED, { \"2FBB1E7E00F746BA514FBC8C421F36792EC0E11FF5EFC3\"\n\
    \        \"78E1AB0C079AA5F0F66A1E3EDBAEB4F9984BE14437123038A452004A5576\"\n  \
    \      \"8C1FD8EED49E4A21BEDCD0\", \"25CBE5A4F2C7B1D7EF07011705D50C62C5\"\n  \
    \      \"000594243EAFD1241FC9F3D22B58184AE2FEE38E171CF8129E29459C9BC2\"\n    \
    \    \"EF461AF5708887315F15419D8D17FE7949\", \"5B8B1F2687555CE2D7182B\"\n    \
    \    \"92E5C3F6C36547DA1C13DBB9EA4F73EA4CBBAF89411527906D35B1B06C1B\"\n      \
    \  \"6A8007D05EC66DF0A406066829EAB618BDE3976515AAFC\", \"46E36B007D\"\n      \
    \  \"19876CDB0B29AD074FE3C08CDD174D42169D6ABE5A1414B6E79707DF5877\"\n        \"\
    6A98091CF431854147BB6D3C66D43BFBC108FD715BDE6AA127C2B0E79F\"\n    }\n  }\n"
- title: '};'
  contents:
  - '};

    '
- title: /* Test arrays for HMAC. */
  contents:
  - '/* Test arrays for HMAC. */

    '
- title: struct hmachash {
  contents:
  - "struct hmachash {\n    const char *keyarray[5];\n    int keylength[5];\n    const\
    \ char *dataarray[5];\n    int datalength[5];\n    const char *resultarray[5];\n\
    \    int resultlength[5];\n"
- title: '} hmachashes[HMACTESTCOUNT] = {'
  contents:
  - "} hmachashes[HMACTESTCOUNT] = {\n  { /* 1 */ {\n      \"\\x0b\\x0b\\x0b\\x0b\\\
    x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\"\n      \"\\x0b\\x0b\\\
    x0b\\x0b\\x0b\"\n    }, { 20 }, {\n      \"\\x48\\x69\\x20\\x54\\x68\\x65\\x72\\\
    x65\" /* \"Hi There\" */\n    }, { 8 }, {\n      /* HMAC-SHA-1 */\n      \"B617318655057264E28BC0B6FB378C8EF146BE00\"\
    ,\n      /* HMAC-SHA-224 */\n      \"896FB1128ABBDF196832107CD49DF33F47B4B1169912BA4F53684B22\"\
    ,\n      /* HMAC-SHA-256 */\n      \"B0344C61D8DB38535CA8AFCEAF0BF12B881DC200C9833DA726E9376C2E32\"\
    \n      \"CFF7\",\n      /* HMAC-SHA-384 */\n      \"AFD03944D84895626B0825F4AB46907F15F9DADBE4101EC682AA034C7CEB\"\
    \n      \"C59CFAEA9EA9076EDE7F4AF152E8B2FA9CB6\",\n      /* HMAC-SHA-512 */\n\
    \      \"87AA7CDEA5EF619D4FF0B4241A1D6CB02379F4E2CE4EC2787AD0B30545E1\"\n    \
    \  \"7CDEDAA833B7D6B8A702038B274EAEA3F4E4BE9D914EEB61F1702E696C20\"\n      \"\
    3A126854\"\n    }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n      SHA384HashSize,\
    \ SHA512HashSize }\n  },\n  { /* 2 */ {\n      \"\\x4a\\x65\\x66\\x65\" /* \"\
    Jefe\" */\n    }, { 4 }, {\n      \"\\x77\\x68\\x61\\x74\\x20\\x64\\x6f\\x20\\\
    x79\\x61\\x20\\x77\\x61\\x6e\\x74\"\n      \"\\x20\\x66\\x6f\\x72\\x20\\x6e\\\
    x6f\\x74\\x68\\x69\\x6e\\x67\\x3f\"\n      /* \"what do ya want for nothing?\"\
    \ */\n    }, { 28 }, {\n      /* HMAC-SHA-1 */\n      \"EFFCDF6AE5EB2FA2D27416D5F184DF9C259A7C79\"\
    ,\n      /* HMAC-SHA-224 */\n      \"A30E01098BC6DBBF45690F3A7E9E6D0F8BBEA2A39E6148008FD05E44\"\
    ,\n      /* HMAC-SHA-256 */\n      \"5BDCC146BF60754E6A042426089575C75A003F089D2739839DEC58B964EC\"\
    \n      \"3843\",\n      /* HMAC-SHA-384 */\n      \"AF45D2E376484031617F78D2B58A6B1B9C7EF464F5A01B47E42EC3736322\"\
    \n      \"445E8E2240CA5E69E2C78B3239ECFAB21649\",\n      /* HMAC-SHA-512 */\n\
    \      \"164B7A7BFCF819E2E395FBE73B56E0A387BD64222E831FD610270CD7EA25\"\n    \
    \  \"05549758BF75C05A994A6D034F65F8F0E6FDCAEAB1A34D4A6B4B636E070A\"\n      \"\
    38BCE737\"\n    }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n      SHA384HashSize,\
    \ SHA512HashSize }\n  },\n  { /* 3 */\n    {\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\\
    xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\\
    xaa\\xaa\"\n    }, { 20 }, {\n      \"\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\\
    xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\"\n      \"\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\\
    xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\"\n      \"\\xdd\\xdd\\xdd\\xdd\\\
    xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\\xdd\"\n      \"\\xdd\\xdd\\\
    xdd\\xdd\\xdd\"\n    }, { 50 }, {\n      /* HMAC-SHA-1 */\n      \"125D7342B9AC11CD91A39AF48AA17B4F63F175D3\"\
    ,\n      /* HMAC-SHA-224 */\n      \"7FB3CB3588C6C1F6FFA9694D7D6AD2649365B0C1F65D69D1EC8333EA\"\
    ,\n      /* HMAC-SHA-256 */\n      \"773EA91E36800E46854DB8EBD09181A72959098B3EF8C122D9635514CED5\"\
    \n      \"65FE\",\n      /* HMAC-SHA-384 */\n      \"88062608D3E6AD8A0AA2ACE014C8A86F0AA635D947AC9FEBE83EF4E55966\"\
    \n      \"144B2A5AB39DC13814B94E3AB6E101A34F27\",\n      /* HMAC-SHA-512 */\n\
    \      \"FA73B0089D56A284EFB0F0756C890BE9B1B5DBDD8EE81A3655F83E33B227\"\n    \
    \  \"9D39BF3E848279A722C806B485A47E67C807B946A337BEE8942674278859\"\n      \"\
    E13292FB\"\n    }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n      SHA384HashSize,\
    \ SHA512HashSize }\n  },\n  { /* 4 */ {\n      \"\\x01\\x02\\x03\\x04\\x05\\x06\\\
    x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\"\n      \"\\x10\\x11\\x12\\x13\\\
    x14\\x15\\x16\\x17\\x18\\x19\"\n    }, { 25 }, {\n      \"\\xcd\\xcd\\xcd\\xcd\\\
    xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\"\n      \"\\xcd\\xcd\\\
    xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\"\n      \"\\\
    xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\\xcd\"\n\
    \      \"\\xcd\\xcd\\xcd\\xcd\\xcd\"\n    }, { 50 }, {\n      /* HMAC-SHA-1 */\n\
    \      \"4C9007F4026250C6BC8414F9BF50C86C2D7235DA\",\n      /* HMAC-SHA-224 */\n\
    \      \"6C11506874013CAC6A2ABC1BB382627CEC6A90D86EFC012DE7AFEC5A\",\n      /*\
    \ HMAC-SHA-256 */\n      \"82558A389A443C0EA4CC819899F2083A85F0FAA3E578F8077A2E3FF46729\"\
    \n      \"665B\",\n      /* HMAC-SHA-384 */\n      \"3E8A69B7783C25851933AB6290AF6CA77A9981480850009CC5577C6E1F57\"\
    \n      \"3B4E6801DD23C4A7D679CCF8A386C674CFFB\",\n      /* HMAC-SHA-512 */\n\
    \      \"B0BA465637458C6990E5A8C5F61D4AF7E576D97FF94B872DE76F8050361E\"\n    \
    \  \"E3DBA91CA5C11AA25EB4D679275CC5788063A5F19741120C4F2DE2ADEBEB\"\n      \"\
    10A298DD\"\n    }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n      SHA384HashSize,\
    \ SHA512HashSize }\n  },\n  { /* 5 */ {\n      \"\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\\
    x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\"\n      \"\\x0c\\x0c\\x0c\\x0c\\\
    x0c\"\n    }, { 20 }, {\n      \"Test With Truncation\"\n    }, { 20 }, {\n  \
    \    /* HMAC-SHA-1 */\n      \"4C1A03424B55E07FE7F27BE1\",\n      /* HMAC-SHA-224\
    \ */\n      \"0E2AEA68A90C8D37C988BCDB9FCA6FA8\",\n      /* HMAC-SHA-256 */\n\
    \      \"A3B6167473100EE06E0C796C2955552B\",\n      /* HMAC-SHA-384 */\n     \
    \ \"3ABF34C3503B2A23A46EFC619BAEF897\",\n      /* HMAC-SHA-512 */\n      \"415FAD6271580A531D4179BC891D87A6\"\
    \n    }, { 12, 16, 16, 16, 16 }\n  },\n  { /* 6 */ {\n      \"\\xaa\\xaa\\xaa\\\
    xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\\
    xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n     \
    \ \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\
    \n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\\
    xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\\
    xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\\
    xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\\
    xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\\
    xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\\
    xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n    }, { 80, 131 }, {\n      \"Test\
    \ Using Larger Than Block-Size Key - Hash Key First\"\n    }, { 54 }, {\n    \
    \  /* HMAC-SHA-1 */\n      \"AA4AE5E15272D00E95705637CE8A3B55ED402112\",\n   \
    \   /* HMAC-SHA-224 */\n      \"95E9A0DB962095ADAEBE9B2D6F0DBCE2D499F112F2D2B7273FA6870E\"\
    ,\n      /* HMAC-SHA-256 */\n      \"60E431591EE0B67F0D8A26AACBF5B77F8E0BC6213728C5140546040F0EE3\"\
    \n      \"7F54\",\n      /* HMAC-SHA-384 */\n      \"4ECE084485813E9088D2C63A041BC5B44F9EF1012A2B588F3CD11F05033A\"\
    \n      \"C4C60C2EF6AB4030FE8296248DF163F44952\",\n      /* HMAC-SHA-512 */\n\
    \      \"80B24263C7C1A3EBB71493C1DD7BE8B49B46D1F41B4AEEC1121B013783F8\"\n    \
    \  \"F3526B56D037E05F2598BD0FD2215D6A1E5295E64F73F63F0AEC8B915A98\"\n      \"\
    5D786598\"\n    }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n      SHA384HashSize,\
    \ SHA512HashSize }\n  },\n  { /* 7 */ {\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\\
    xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\\
    xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\\
    xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\\
    xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n\
    \      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\\
    xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\\
    xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\\
    xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\\
    xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\"\n      \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\\
    xaa\\xaa\\xaa\\xaa\\xaa\"\n    }, { 80, 131 }, {\n      \"Test Using Larger Than\
    \ Block-Size Key and \"\n      \"Larger Than One Block-Size Data\",\n      \"\\\
    x54\\x68\\x69\\x73\\x20\\x69\\x73\\x20\\x61\\x20\\x74\\x65\\x73\\x74\\x20\"\n\
    \      \"\\x75\\x73\\x69\\x6e\\x67\\x20\\x61\\x20\\x6c\\x61\\x72\\x67\\x65\\x72\\\
    x20\"\n      \"\\x74\\x68\\x61\\x6e\\x20\\x62\\x6c\\x6f\\x63\\x6b\\x2d\\x73\\\
    x69\\x7a\\x65\"\n      \"\\x20\\x6b\\x65\\x79\\x20\\x61\\x6e\\x64\\x20\\x61\\\
    x20\\x6c\\x61\\x72\\x67\"\n      \"\\x65\\x72\\x20\\x74\\x68\\x61\\x6e\\x20\\\
    x62\\x6c\\x6f\\x63\\x6b\\x2d\\x73\"\n      \"\\x69\\x7a\\x65\\x20\\x64\\x61\\\
    x74\\x61\\x2e\\x20\\x54\\x68\\x65\\x20\\x6b\"\n      \"\\x65\\x79\\x20\\x6e\\\
    x65\\x65\\x64\\x73\\x20\\x74\\x6f\\x20\\x62\\x65\\x20\"\n      \"\\x68\\x61\\\
    x73\\x68\\x65\\x64\\x20\\x62\\x65\\x66\\x6f\\x72\\x65\\x20\\x62\"\n      \"\\\
    x65\\x69\\x6e\\x67\\x20\\x75\\x73\\x65\\x64\\x20\\x62\\x79\\x20\\x74\\x68\"\n\
    \      \"\\x65\\x20\\x48\\x4d\\x41\\x43\\x20\\x61\\x6c\\x67\\x6f\\x72\\x69\\x74\\\
    x68\"\n      \"\\x6d\\x2e\"\n      /* \"This is a test using a larger than block-size\
    \ key and a \"\n          \"larger than block-size data. The key needs to be hashed\
    \ \"\n          \"before being used by the HMAC algorithm.\" */\n    }, { 73,\
    \ 152 }, {\n      /* HMAC-SHA-1 */\n      \"E8E99D0F45237D786D6BBAA7965C7808BBFF1A91\"\
    ,\n      /* HMAC-SHA-224 */\n      \"3A854166AC5D9F023F54D517D0B39DBD946770DB9C2B95C9F6F565D1\"\
    ,\n      /* HMAC-SHA-256 */\n      \"9B09FFA71B942FCB27635FBCD5B0E944BFDC63644F0713938A7F51535C3A\"\
    \n      \"35E2\",\n      /* HMAC-SHA-384 */\n      \"6617178E941F020D351E2F254E8FD32C602420FEB0B8FB9ADCCEBB82461E\"\
    \n      \"99C5A678CC31E799176D3860E6110C46523E\",\n      /* HMAC-SHA-512 */\n\
    \      \"E37B6A775DC87DBAA4DFA9F96E5E3FFDDEBD71F8867289865DF5A32D20CD\"\n    \
    \  \"C944B6022CAC3C4982B10D5EEB55C3E4DE15134676FB6DE0446065C97440\"\n      \"\
    FA8C6A58\"\n    }, { SHA1HashSize, SHA224HashSize, SHA256HashSize,\n      SHA384HashSize,\
    \ SHA512HashSize }\n  }\n"
- title: '};'
  contents:
  - '};

    '
- title: /*
  contents:
  - "/*\n * Check the hash value against the expected string, expressed in hex\n */\n"
- title: static const char hexdigits[] = "0123456789ABCDEF";
  contents:
  - 'static const char hexdigits[] = "0123456789ABCDEF";

    '
- title: int checkmatch(const unsigned char *hashvalue,
  contents:
  - "int checkmatch(const unsigned char *hashvalue,\n  const char *hexstr, int hashsize)\n"
- title: '{'
  contents:
  - "{\n  int i;\n  for (i = 0; i < hashsize; ++i) {\n    if (*hexstr++ != hexdigits[(hashvalue[i]\
    \ >> 4) & 0xF])\n      return 0;\n    if (*hexstr++ != hexdigits[hashvalue[i]\
    \ & 0xF]) return 0;\n  }\n  return 1;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * Print the string, converting non-printable characters to \".\"\n */\n"
- title: void printstr(const char *str, int len)
  contents:
  - 'void printstr(const char *str, int len)

    '
- title: '{'
  contents:
  - "{\n  for ( ; len-- > 0; str++)\n    putchar(isprint((unsigned char)*str) ? *str\
    \ : '.');\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * Print the string, converting non-printable characters to hex \"## \".\n\
    \ */\n"
- title: void printxstr(const char *str, int len)
  contents:
  - 'void printxstr(const char *str, int len)

    '
- title: '{'
  contents:
  - "{\n  for ( ; len-- > 0; str++)\n    printf(\"%c%c \", hexdigits[(*str >> 4) &\
    \ 0xF],\n      hexdigits[*str & 0xF]);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * Print a usage message.\n */\n"
- title: void usage(const char *argv0)
  contents:
  - 'void usage(const char *argv0)

    '
- title: '{'
  contents:
  - "{\n  fprintf(stderr,\n    \"Usage:\\n\"\n    \"Common options: [-h hash] [-w|-x]\
    \ [-H]\\n\"\n    \"Standard tests:\\n\"\n      \"\\t%s [-m] [-l loopcount] [-t\
    \ test#] [-e]\\n\"\n      \"\\t\\t[-r randomseed] [-R randomloop-count] \"\n \
    \       \"[-p] [-P|-X]\\n\"\n    \"Hash a string:\\n\"\n      \"\\t%s [-S expectedresult]\
    \ -s hashstr [-k key]\\n\"\n    \"Hash a file:\\n\"\n      \"\\t%s [-S expectedresult]\
    \ -f file [-k key]\\n\"\n    \"Hash a file, ignoring whitespace:\\n\"\n      \"\
    \\t%s [-S expectedresult] -F file [-k key]\\n\"\n    \"Additional bits to add\
    \ in: [-B bitcount -b bits]\\n\"\n    \"-h\\thash to test: \"\n      \"0|SHA1,\
    \ 1|SHA224, 2|SHA256, 3|SHA384, 4|SHA512\\n\"\n    \"-m\\tperform hmac test\\\
    n\"\n    \"-k\\tkey for hmac test\\n\"\n    \"-t\\ttest case to run, 1-10\\n\"\
    \n    \"-l\\thow many times to run the test\\n\"\n    \"-e\\ttest error returns\\\
    n\"\n    \"-p\\tdo not print results\\n\"\n    \"-P\\tdo not print PASSED/FAILED\\\
    n\"\n    \"-X\\tprint FAILED, but not PASSED\\n\"\n    \"-r\\tseed for random\
    \ test\\n\"\n    \"-R\\thow many times to run random test\\n\"\n    \"-s\\tstring\
    \ to hash\\n\"\n    \"-S\\texpected result of hashed string, in hex\\n\"\n   \
    \ \"-w\\toutput hash in raw format\\n\"\n    \"-x\\toutput hash in hex format\\\
    n\"\n    \"-B\\t# extra bits to add in after string or file input\\n\"\n    \"\
    -b\\textra bits to add (high order bits of #, 0# or 0x#)\\n\"\n    \"-H\\tinput\
    \ hashstr or randomseed is in hex\\n\"\n    , argv0, argv0, argv0, argv0);\n \
    \ exit(1);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * Print the results and PASS/FAIL.\n */\n"
- title: void printResult(uint8_t *Message_Digest, int hashsize,
  contents:
  - "void printResult(uint8_t *Message_Digest, int hashsize,\n    const char *hashname,\
    \ const char *testtype, const char *testname,\n    const char *resultarray, int\
    \ printResults, int printPassFail)\n"
- title: '{'
  contents:
  - "{\n  int i, k;\n  if (printResults == PRINTTEXT) {\n    putchar('\\t');\n   \
    \ for (i = 0; i < hashsize ; ++i) {\n      putchar(hexdigits[(Message_Digest[i]\
    \ >> 4) & 0xF]);\n      putchar(hexdigits[Message_Digest[i] & 0xF]);\n      putchar('\
    \ ');\n    }\n    putchar('\\n');\n  } else if (printResults == PRINTRAW) {\n\
    \    fwrite(Message_Digest, 1, hashsize, stdout);\n  } else if (printResults ==\
    \ PRINTHEX) {\n    for (i = 0; i < hashsize ; ++i) {\n      putchar(hexdigits[(Message_Digest[i]\
    \ >> 4) & 0xF]);\n      putchar(hexdigits[Message_Digest[i] & 0xF]);\n    }\n\
    \    putchar('\\n');\n  }\n  if (printResults && resultarray) {\n    printf(\"\
    \    Should match:\\n\\t\");\n    for (i = 0, k = 0; i < hashsize; i++, k += 2)\
    \ {\n      putchar(resultarray[k]);\n      putchar(resultarray[k+1]);\n      putchar('\
    \ ');\n    }\n    putchar('\\n');\n  }\n  if (printPassFail && resultarray) {\n\
    \    int ret = checkmatch(Message_Digest, resultarray, hashsize);\n    if ((printPassFail\
    \ == PRINTPASSFAIL) || !ret)\n      printf(\"%s %s %s: %s\\n\", hashname, testtype,\
    \ testname,\n        ret ? \"PASSED\" : \"FAILED\");\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * Exercise a hash series of functions. The input is the testarray,\n * repeated\
    \ repeatcount times, followed by the extrabits. If the\n * result is known, it\
    \ is in resultarray in uppercase hex.\n */\n"
- title: int hash(int testno, int loopno, int hashno,
  contents:
  - "int hash(int testno, int loopno, int hashno,\n  const char *testarray, int length,\
    \ long repeatcount,\n  int numberExtrabits, int extrabits, const unsigned char\
    \ *keyarray,\n  int keylen, const char *resultarray, int hashsize, int printResults,\n\
    \  int printPassFail)\n"
- title: '{'
  contents:
  - "{\n  USHAContext sha;\n  HMACContext hmac;\n  int err, i;\n  uint8_t Message_Digest[USHAMaxHashSize];\n\
    \  char buf[20];\n  if (printResults == PRINTTEXT) {\n    printf(\"\\nTest %d:\
    \ Iteration %d, Repeat %ld\\n\\t'\", testno+1,\n      loopno, repeatcount);\n\
    \    printstr(testarray, length);\n    printf(\"'\\n\\t'\");\n    printxstr(testarray,\
    \ length);\n    printf(\"'\\n\");\n    printf(\"    Length=%d bytes (%d bits),\
    \ \", length, length * 8);\n    printf(\"ExtraBits %d: %2.2x\\n\", numberExtrabits,\
    \ extrabits);\n  }\n  memset(&sha, '\\343', sizeof(sha)); /* force bad data into\
    \ struct */\n  memset(&hmac, '\\343', sizeof(hmac));\n  err = keyarray ? hmacReset(&hmac,\
    \ hashes[hashno].whichSha,\n                             keyarray, keylen) :\n\
    \                   USHAReset(&sha, hashes[hashno].whichSha);\n  if (err != shaSuccess)\
    \ {\n    fprintf(stderr, \"hash(): %sReset Error %d.\\n\",\n            keyarray\
    \ ? \"hmac\" : \"sha\", err);\n    return err;\n  }\n  for (i = 0; i < repeatcount;\
    \ ++i) {\n    err = keyarray ? hmacInput(&hmac, (const uint8_t *) testarray,\n\
    \                               length) :\n                     USHAInput(&sha,\
    \ (const uint8_t *) testarray,\n                               length);\n    if\
    \ (err != shaSuccess) {\n      fprintf(stderr, \"hash(): %sInput Error %d.\\n\"\
    ,\n              keyarray ? \"hmac\" : \"sha\", err);\n      return err;\n   \
    \ }\n  }\n  if (numberExtrabits > 0) {\n    err = keyarray ? hmacFinalBits(&hmac,\
    \ (uint8_t) extrabits,\n                                   numberExtrabits) :\n\
    \                     USHAFinalBits(&sha, (uint8_t) extrabits,\n             \
    \                      numberExtrabits);\n    if (err != shaSuccess) {\n     \
    \ fprintf(stderr, \"hash(): %sFinalBits Error %d.\\n\",\n              keyarray\
    \ ? \"hmac\" : \"sha\", err);\n      return err;\n    }\n  }\n  err = keyarray\
    \ ? hmacResult(&hmac, Message_Digest) :\n                   USHAResult(&sha, Message_Digest);\n\
    \  if (err != shaSuccess) {\n    fprintf(stderr, \"hash(): %s Result Error %d,\
    \ could not \"\n      \"compute message digest.\\n\", keyarray ? \"hmac\" : \"\
    sha\", err);\n    return err;\n  }\n  sprintf(buf, \"%d\", testno+1);\n  printResult(Message_Digest,\
    \ hashsize, hashes[hashno].name,\n    keyarray ? \"hmac standard test\" : \"sha\
    \ standard test\", buf,\n    resultarray, printResults, printPassFail);\n  return\
    \ err;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * Exercise a hash series of functions. The input is a filename.\n * If the\
    \ result is known, it is in resultarray in uppercase hex.\n */\n"
- title: int hashfile(int hashno, const char *hashfilename, int bits,
  contents:
  - "int hashfile(int hashno, const char *hashfilename, int bits,\n  int bitcount,\
    \ int skipSpaces, const unsigned char *keyarray,\n  int keylen, const char *resultarray,\
    \ int hashsize,\n  int printResults, int printPassFail)\n"
- title: '{'
  contents:
  - "{\n  USHAContext sha;\n  HMACContext hmac;\n  int err, nread, c;\n  unsigned\
    \ char buf[4096];\n  uint8_t Message_Digest[USHAMaxHashSize];\n  unsigned char\
    \ cc;\n  FILE *hashfp = (strcmp(hashfilename, \"-\") == 0) ? stdin :\n    fopen(hashfilename,\
    \ \"r\");\n  if (!hashfp) {\n    fprintf(stderr, \"cannot open file '%s'\\n\"\
    , hashfilename);\n    return shaStateError;\n  }\n  memset(&sha, '\\343', sizeof(sha));\
    \ /* force bad data into struct */\n  memset(&hmac, '\\343', sizeof(hmac));\n\
    \  err = keyarray ? hmacReset(&hmac, hashes[hashno].whichSha,\n              \
    \               keyarray, keylen) :\n                   USHAReset(&sha, hashes[hashno].whichSha);\n\
    \  if (err != shaSuccess) {\n    fprintf(stderr, \"hashfile(): %sReset Error %d.\\\
    n\",\n            keyarray ? \"hmac\" : \"sha\", err);\n    return err;\n  }\n\
    \  if (skipSpaces)\n    while ((c = getc(hashfp)) != EOF) {\n      if (!isspace(c))\
    \ {\n        cc = (unsigned char)c;\n        err = keyarray ? hmacInput(&hmac,\
    \ &cc, 1) :\n                         USHAInput(&sha, &cc, 1);\n        if (err\
    \ != shaSuccess) {\n          fprintf(stderr, \"hashfile(): %sInput Error %d.\\\
    n\",\n                  keyarray ? \"hmac\" : \"sha\", err);\n          if (hashfp\
    \ != stdin) fclose(hashfp);\n          return err;\n        }\n      }\n    }\n\
    \  else\n    while ((nread = fread(buf, 1, sizeof(buf), hashfp)) > 0) {\n    \
    \  err = keyarray ? hmacInput(&hmac, buf, nread) :\n                       USHAInput(&sha,\
    \ buf, nread);\n      if (err != shaSuccess) {\n        fprintf(stderr, \"hashfile():\
    \ %s Error %d.\\n\",\n                keyarray ? \"hmacInput\" : \"shaInput\"\
    , err);\n        if (hashfp != stdin) fclose(hashfp);\n        return err;\n \
    \     }\n    }\n  if (bitcount > 0)\n    err = keyarray ? hmacFinalBits(&hmac,\
    \ bits, bitcount) :\n                   USHAFinalBits(&sha, bits, bitcount);\n\
    \  if (err != shaSuccess) {\n    fprintf(stderr, \"hashfile(): %s Error %d.\\\
    n\",\n            keyarray ? \"hmacResult\" : \"shaResult\", err);\n    if (hashfp\
    \ != stdin) fclose(hashfp);\n    return err;\n  }\n  err = keyarray ? hmacResult(&hmac,\
    \ Message_Digest) :\n                   USHAResult(&sha, Message_Digest);\n  if\
    \ (err != shaSuccess) {\n    fprintf(stderr, \"hashfile(): %s Error %d.\\n\",\n\
    \            keyarray ? \"hmacResult\" : \"shaResult\", err);\n    if (hashfp\
    \ != stdin) fclose(hashfp);\n    return err;\n  }\n  printResult(Message_Digest,\
    \ hashsize, hashes[hashno].name, \"file\",\n    hashfilename, resultarray, printResults,\
    \ printPassFail);\n  if (hashfp != stdin) fclose(hashfp);\n  return err;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * Exercise a hash series of functions through multiple permutations.\n *\
    \ The input is an initial seed. That seed is replicated 3 times.\n * For 1000\
    \ rounds, the previous three results are used as the input.\n * This result is\
    \ then checked, and used to seed the next cycle.\n * If the result is known, it\
    \ is in resultarrays in uppercase hex.\n */\n"
- title: void randomtest(int hashno, const char *seed, int hashsize,
  contents:
  - "void randomtest(int hashno, const char *seed, int hashsize,\n    const char **resultarrays,\
    \ int randomcount,\n    int printResults, int printPassFail)\n"
- title: '{'
  contents:
  - "{\n  int i, j; char buf[20];\n  unsigned char SEED[USHAMaxHashSize], MD[1003][USHAMaxHashSize];\n\
    \  /* INPUT: Seed - A random seed n bits long */\n  memcpy(SEED, seed, hashsize);\n\
    \  if (printResults == PRINTTEXT) {\n    printf(\"%s random test seed= '\", hashes[hashno].name);\n\
    \    printxstr(seed, hashsize);\n    printf(\"'\\n\");\n  }\n  for (j = 0; j <\
    \ randomcount; j++) {\n    /* MD0 = MD1 = MD2 = Seed; */\n    memcpy(MD[0], SEED,\
    \ hashsize);\n    memcpy(MD[1], SEED, hashsize);\n    memcpy(MD[2], SEED, hashsize);\n\
    \    for (i=3; i<1003; i++) {\n      /* Mi = MDi-3 || MDi-2 || MDi-1; */\n   \
    \   USHAContext Mi;\n      memset(&Mi, '\\343', sizeof(Mi)); /* force bad data\
    \ into struct */\n      USHAReset(&Mi, hashes[hashno].whichSha);\n      USHAInput(&Mi,\
    \ MD[i-3], hashsize);\n      USHAInput(&Mi, MD[i-2], hashsize);\n      USHAInput(&Mi,\
    \ MD[i-1], hashsize);\n      /* MDi = SHA(Mi); */\n      USHAResult(&Mi, MD[i]);\n\
    \    }\n    /* MDj = Seed = MDi; */\n    memcpy(SEED, MD[i-1], hashsize);\n  \
    \  /* OUTPUT: MDj */\n    sprintf(buf, \"%d\", j);\n    printResult(SEED, hashsize,\
    \ hashes[hashno].name, \"random test\",\n      buf, resultarrays ? resultarrays[j]\
    \ : 0, printResults,\n      (j < RANDOMCOUNT) ? printPassFail : 0);\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * Look up a hash name.\n */\n"
- title: int findhash(const char *argv0, const char *opt)
  contents:
  - 'int findhash(const char *argv0, const char *opt)

    '
- title: '{'
  contents:
  - "{\n  int i;\n  const char *names[HASHCOUNT][2] = {\n    { \"0\", \"sha1\" },\
    \ { \"1\", \"sha224\" }, { \"2\", \"sha256\" },\n    { \"3\", \"sha384\" }, {\
    \ \"4\", \"sha512\" }\n  };\n  for (i = 0; i < HASHCOUNT; i++)\n    if ((strcmp(opt,\
    \ names[i][0]) == 0) ||\n        (scasecmp(opt, names[i][1]) == 0))\n      return\
    \ i;\n  fprintf(stderr, \"%s: Unknown hash name: '%s'\\n\", argv0, opt);\n  usage(argv0);\n\
    \  return 0;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * Run some tests that should invoke errors.\n */\n"
- title: void testErrors(int hashnolow, int hashnohigh, int printResults,
  contents:
  - "void testErrors(int hashnolow, int hashnohigh, int printResults,\n    int printPassFail)\n"
- title: '{'
  contents:
  - "{\n  USHAContext usha;\n  uint8_t Message_Digest[USHAMaxHashSize];\n  int hashno,\
    \ err;\n  for (hashno = hashnolow; hashno <= hashnohigh; hashno++) {\n    memset(&usha,\
    \ '\\343', sizeof(usha)); /* force bad data */\n    USHAReset(&usha, hashno);\n\
    \    USHAResult(&usha, Message_Digest);\n    err = USHAInput(&usha, (const unsigned\
    \ char *)\"foo\", 3);\n    if (printResults == PRINTTEXT)\n      printf (\"\\\
    nError %d. Should be %d.\\n\", err, shaStateError);\n    if ((printPassFail ==\
    \ PRINTPASSFAIL) ||\n        ((printPassFail == PRINTFAIL) && (err != shaStateError)))\n\
    \      printf(\"%s se: %s\\n\", hashes[hashno].name,\n        (err == shaStateError)\
    \ ? \"PASSED\" : \"FAILED\");\n    err = USHAFinalBits(&usha, 0x80, 3);\n    if\
    \ (printResults == PRINTTEXT)\n      printf (\"\\nError %d. Should be %d.\\n\"\
    , err, shaStateError);\n    if ((printPassFail == PRINTPASSFAIL) ||\n        ((printPassFail\
    \ == PRINTFAIL) && (err != shaStateError)))\n      printf(\"%s se: %s\\n\", hashes[hashno].name,\n\
    \        (err == shaStateError) ? \"PASSED\" : \"FAILED\");\n    err = USHAReset(0,\
    \ hashes[hashno].whichSha);\n    if (printResults == PRINTTEXT)\n       printf(\"\
    \\nError %d. Should be %d.\\n\", err, shaNull);\n    if ((printPassFail == PRINTPASSFAIL)\
    \ ||\n        ((printPassFail == PRINTFAIL) && (err != shaNull)))\n       printf(\"\
    %s usha null: %s\\n\", hashes[hashno].name,\n        (err == shaNull) ? \"PASSED\"\
    \ : \"FAILED\");\n    switch (hashno) {\n      case SHA1: err = SHA1Reset(0);\
    \ break;\n      case SHA224: err = SHA224Reset(0); break;\n      case SHA256:\
    \ err = SHA256Reset(0); break;\n      case SHA384: err = SHA384Reset(0); break;\n\
    \      case SHA512: err = SHA512Reset(0); break;\n    }\n    if (printResults\
    \ == PRINTTEXT)\n       printf(\"\\nError %d. Should be %d.\\n\", err, shaNull);\n\
    \    if ((printPassFail == PRINTPASSFAIL) ||\n        ((printPassFail == PRINTFAIL)\
    \ && (err != shaNull)))\n       printf(\"%s sha null: %s\\n\", hashes[hashno].name,\n\
    \        (err == shaNull) ? \"PASSED\" : \"FAILED\");\n  }\n"
- title: '}'
  contents:
  - '}

    '
- title: /* replace a hex string in place with its value */
  contents:
  - '/* replace a hex string in place with its value */

    '
- title: int unhexStr(char *hexstr)
  contents:
  - 'int unhexStr(char *hexstr)

    '
- title: '{'
  contents:
  - "{\n  char *o = hexstr;\n  int len = 0, nibble1 = 0, nibble2 = 0;\n  if (!hexstr)\
    \ return 0;\n  for ( ; *hexstr; hexstr++) {\n    if (isalpha((int)(unsigned char)(*hexstr)))\
    \ {\n      nibble1 = tolower(*hexstr) - 'a' + 10;\n    } else if (isdigit((int)(unsigned\
    \ char)(*hexstr))) {\n      nibble1 = *hexstr - '0';\n    } else {\n      printf(\"\
    \\nError: bad hex character '%c'\\n\", *hexstr);\n    }\n    if (!*++hexstr) break;\n\
    \    if (isalpha((int)(unsigned char)(*hexstr))) {\n      nibble2 = tolower(*hexstr)\
    \ - 'a' + 10;\n    } else if (isdigit((int)(unsigned char)(*hexstr))) {\n    \
    \  nibble2 = *hexstr - '0';\n    } else {\n      printf(\"\\nError: bad hex character\
    \ '%c'\\n\", *hexstr);\n    }\n    *o++ = (char)((nibble1 << 4) | nibble2);\n\
    \    len++;\n  }\n  return len;\n"
- title: '}'
  contents:
  - '}

    '
- title: int main(int argc, char **argv)
  contents:
  - 'int main(int argc, char **argv)

    '
- title: '{'
  contents:
  - "{\n  int i, err;\n  int loopno, loopnohigh = 1;\n  int hashno, hashnolow = 0,\
    \ hashnohigh = HASHCOUNT - 1;\n  int testno, testnolow = 0, testnohigh;\n  int\
    \ ntestnohigh = 0;\n  int printResults = PRINTTEXT;\n  int printPassFail = 1;\n\
    \  int checkErrors = 0;\n  char *hashstr = 0;\n  int hashlen = 0;\n  const char\
    \ *resultstr = 0;\n  char *randomseedstr = 0;\n  int runHmacTests = 0;\n  char\
    \ *hmacKey = 0;\n  int hmaclen = 0;\n  int randomcount = RANDOMCOUNT;\n  const\
    \ char *hashfilename = 0;\n  const char *hashFilename = 0;\n  int extrabits =\
    \ 0, numberExtrabits = 0;\n  int strIsHex = 0;\n  while ((i = xgetopt(argc, argv,\
    \ \"b:B:ef:F:h:Hk:l:mpPr:R:s:S:t:wxX\"))\n         != -1)\n    switch (i) {\n\
    \      case 'b': extrabits = strtol(xoptarg, 0, 0); break;\n      case 'B': numberExtrabits\
    \ = atoi(xoptarg); break;\n      case 'e': checkErrors = 1; break;\n      case\
    \ 'f': hashfilename = xoptarg; break;\n      case 'F': hashFilename = xoptarg;\
    \ break;\n      case 'h': hashnolow = hashnohigh = findhash(argv[0], xoptarg);\n\
    \        break;\n      case 'H': strIsHex = 1; break;\n      case 'k': hmacKey\
    \ = xoptarg; hmaclen = strlen(xoptarg); break;\n      case 'l': loopnohigh = atoi(xoptarg);\
    \ break;\n      case 'm': runHmacTests = 1; break;\n      case 'P': printPassFail\
    \ = 0; break;\n      case 'p': printResults = PRINTNONE; break;\n      case 'R':\
    \ randomcount = atoi(xoptarg); break;\n      case 'r': randomseedstr = xoptarg;\
    \ break;\n      case 's': hashstr = xoptarg; hashlen = strlen(hashstr); break;\n\
    \      case 'S': resultstr = xoptarg; break;\n      case 't': testnolow = ntestnohigh\
    \ = atoi(xoptarg) - 1; break;\n      case 'w': printResults = PRINTRAW; break;\n\
    \      case 'x': printResults = PRINTHEX; break;\n      case 'X': printPassFail\
    \ = 2; break;\n      default: usage(argv[0]);\n      }\n  if (strIsHex) {\n  \
    \  hashlen = unhexStr(hashstr);\n    unhexStr(randomseedstr);\n    hmaclen = unhexStr(hmacKey);\n\
    \  }\n  testnohigh = (ntestnohigh != 0) ? ntestnohigh:\n               runHmacTests\
    \ ? (HMACTESTCOUNT-1) : (TESTCOUNT-1);\n  if ((testnolow < 0) ||\n      (testnohigh\
    \ >= (runHmacTests ? HMACTESTCOUNT : TESTCOUNT)) ||\n      (hashnolow < 0) ||\
    \ (hashnohigh >= HASHCOUNT) ||\n      (hashstr && (testnolow == testnohigh)) ||\n\
    \      (randomcount < 0) ||\n      (resultstr && (!hashstr && !hashfilename &&\
    \ !hashFilename)) ||\n      ((runHmacTests || hmacKey) && randomseedstr) ||\n\
    \      (hashfilename && hashFilename))\n    usage(argv[0]);\n  /*\n   *  Perform\
    \ SHA/HMAC tests\n   */\n  for (hashno = hashnolow; hashno <= hashnohigh; ++hashno)\
    \ {\n    if (printResults == PRINTTEXT)\n      printf(\"Hash %s\\n\", hashes[hashno].name);\n\
    \    err = shaSuccess;\n    for (loopno = 1; (loopno <= loopnohigh) && (err ==\
    \ shaSuccess);\n         ++loopno) {\n      if (hashstr)\n        err = hash(0,\
    \ loopno, hashno, hashstr, hashlen, 1,\n          numberExtrabits, extrabits,\
    \ (const unsigned char *)hmacKey,\n          hmaclen, resultstr, hashes[hashno].hashsize,\
    \ printResults,\n          printPassFail);\n      else if (randomseedstr)\n  \
    \      randomtest(hashno, randomseedstr, hashes[hashno].hashsize, 0,\n       \
    \   randomcount, printResults, printPassFail);\n      else if (hashfilename)\n\
    \        err = hashfile(hashno, hashfilename, extrabits,\n                   \
    \    numberExtrabits, 0,\n                       (const unsigned char *)hmacKey,\
    \ hmaclen,\n                       resultstr, hashes[hashno].hashsize,\n     \
    \                  printResults, printPassFail);\n      else if (hashFilename)\n\
    \        err = hashfile(hashno, hashFilename, extrabits,\n                   \
    \    numberExtrabits, 1,\n                       (const unsigned char *)hmacKey,\
    \ hmaclen,\n                       resultstr, hashes[hashno].hashsize,\n     \
    \                  printResults, printPassFail);\n      else /* standard tests\
    \ */ {\n        for (testno = testnolow;\n             (testno <= testnohigh)\
    \ && (err == shaSuccess); ++testno) {\n          if (runHmacTests) {\n       \
    \     err = hash(testno, loopno, hashno,\n                       hmachashes[testno].dataarray[hashno]\
    \ ?\n                       hmachashes[testno].dataarray[hashno] :\n         \
    \              hmachashes[testno].dataarray[1] ?\n                       hmachashes[testno].dataarray[1]\
    \ :\n                       hmachashes[testno].dataarray[0],\n               \
    \        hmachashes[testno].datalength[hashno] ?\n                       hmachashes[testno].datalength[hashno]\
    \ :\n                       hmachashes[testno].datalength[1] ?\n             \
    \          hmachashes[testno].datalength[1] :\n                       hmachashes[testno].datalength[0],\n\
    \                       1, 0, 0,\n                       (const unsigned char\
    \ *)(\n                        hmachashes[testno].keyarray[hashno] ?\n       \
    \                 hmachashes[testno].keyarray[hashno] :\n                    \
    \    hmachashes[testno].keyarray[1] ?\n                        hmachashes[testno].keyarray[1]\
    \ :\n                        hmachashes[testno].keyarray[0]),\n              \
    \         hmachashes[testno].keylength[hashno] ?\n                       hmachashes[testno].keylength[hashno]\
    \ :\n                       hmachashes[testno].keylength[1] ?\n              \
    \         hmachashes[testno].keylength[1] :\n                       hmachashes[testno].keylength[0],\n\
    \                       hmachashes[testno].resultarray[hashno],\n            \
    \           hmachashes[testno].resultlength[hashno],\n                       printResults,\
    \ printPassFail);\n          } else {\n            err = hash(testno, loopno,\
    \ hashno,\n                       hashes[hashno].tests[testno].testarray,\n  \
    \                     hashes[hashno].tests[testno].length,\n                 \
    \      hashes[hashno].tests[testno].repeatcount,\n                       hashes[hashno].tests[testno].numberExtrabits,\n\
    \                       hashes[hashno].tests[testno].extrabits, 0, 0,\n      \
    \                 hashes[hashno].tests[testno].resultarray,\n                \
    \       hashes[hashno].hashsize,\n                       printResults, printPassFail);\n\
    \          }\n        }\n        if (!runHmacTests) {\n          randomtest(hashno,\
    \ hashes[hashno].randomtest,\n            hashes[hashno].hashsize, hashes[hashno].randomresults,\n\
    \            RANDOMCOUNT, printResults, printPassFail);\n        }\n      }\n\
    \    }\n  }\n  /* Test some error returns */\n  if (checkErrors) {\n    testErrors(hashnolow,\
    \ hashnohigh, printResults, printPassFail);\n  }\n  return 0;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * Compare two strings, case independently.\n * Equivalent to strcasecmp()\
    \ found on some systems.\n */\n"
- title: int scasecmp(const char *s1, const char *s2)
  contents:
  - 'int scasecmp(const char *s1, const char *s2)

    '
- title: '{'
  contents:
  - "{\n  for (;;) {\n    char u1 = tolower(*s1++);\n    char u2 = tolower(*s2++);\n\
    \    if (u1 != u2)\n      return u1 - u2;\n    if (u1 == '\\0')\n      return\
    \ 0;\n   }\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * This is a copy of getopt provided for those systems that do not\n * have\
    \ it. The name was changed to xgetopt to not conflict on those\n * systems that\
    \ do have it. Similarly, optarg, optind and opterr\n * were renamed to xoptarg,\
    \ xoptind and xopterr.\n *\n * Copyright 1990, 1991, 1992 by the Massachusetts\
    \ Institute of\n * Technology and UniSoft Group Limited.\n *\n * Permission to\
    \ use, copy, modify, distribute, and sell this software\n * and its documentation\
    \ for any purpose is hereby granted without fee,\n * provided that the above copyright\
    \ notice appear in all copies and\n * that both that copyright notice and this\
    \ permission notice appear in\n * supporting documentation, and that the names\
    \ of MIT and UniSoft not\n * be used in advertising or publicity pertaining to\
    \ distribution of\n * the software without specific, written prior permission.\
    \  MIT and\n * UniSoft make no representations about the suitability of this\n\
    \ * software for any purpose.  It is provided \"as is\" without express\n * or\
    \ implied warranty.\n *\n * $XConsortium: getopt.c,v 1.2 92/07/01 11:59:04 rws\
    \ Exp $\n * NB: Reformatted to match above style.\n */\n"
- title: char    *xoptarg;
  contents:
  - 'char    *xoptarg;

    '
- title: int     xoptind = 1;
  contents:
  - 'int     xoptind = 1;

    '
- title: int     xopterr = 1;
  contents:
  - 'int     xopterr = 1;

    '
- title: static int xgetopt(int argc, char **argv, const char *optstring)
  contents:
  - 'static int xgetopt(int argc, char **argv, const char *optstring)

    '
- title: '{'
  contents:
  - "{\n  static int avplace;\n  char    *ap;\n  char    *cp;\n  int     c;\n  if\
    \ (xoptind >= argc)\n    return EOF;\n  ap = argv[xoptind] + avplace;\n  /* At\
    \ beginning of arg but not an option */\n  if (avplace == 0) {\n    if (ap[0]\
    \ != '-')\n      return EOF;\n    else if (ap[1] == '-') {\n      /* Special end\
    \ of options option */\n      xoptind++;\n      return EOF;\n    } else if (ap[1]\
    \ == '\\0')\n      return EOF;  /* single '-' is not allowed */\n  }\n  /* Get\
    \ next letter */\n  avplace++;\n  c = *++ap;\n  cp = strchr(optstring, c);\n \
    \ if (cp == NULL || c == ':') {\n    if (xopterr)\n      fprintf(stderr, \"Unrecognised\
    \ option -- %c\\n\", c);\n    return '?';\n  }\n  if (cp[1] == ':') {\n    /*\
    \ There should be an option arg */\n    avplace = 0;\n    if (ap[1] == '\\0')\
    \ {\n      /* It is a separate arg */\n      if (++xoptind >= argc) {\n      \
    \  if (xopterr)\n          fprintf(stderr, \"Option requires an argument\\n\"\
    );\n        return '?';\n      }\n      xoptarg = argv[xoptind++];\n    } else\
    \ {\n      /* is attached to option letter */\n      xoptarg = ap + 1;\n     \
    \ ++xoptind;\n    }\n  } else {\n    /* If we are out of letters then go to next\
    \ arg */\n    if (ap[1] == '\\0') {\n      ++xoptind;\n      avplace = 0;\n  \
    \  }\n    xoptarg = NULL;\n  }\n  return c;\n"
- title: '}'
  contents:
  - '}

    '
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   This document is intended to provides the Internet\
    \ community\n   convenient access to source code that implements the United States\
    \ of\n   America Federal Information Processing Standard Secure Hash\n   Algorithms\
    \ (SHAs) [FIPS180-2] and HMACs based upon these one-way hash\n   functions.  See\
    \ license in Section 1.1.  No independent assertion of\n   the security of this\
    \ hash function by the authors for any particular\n   use is intended.\n"
- title: 10.  Normative References
  contents:
  - "10.  Normative References\n   [FIPS180-2] \"Secure Hash Standard\", United States\
    \ of America,\n               National Institute of Standards and Technology,\
    \ Federal\n               Information Processing Standard (FIPS) 180-2,\n    \
    \           http://csrc.nist.gov/publications/fips/fips180-2/\n              \
    \ fips180-2withchangenotice.pdf.\n   [RFC2104]   Krawczyk, H., Bellare, M., and\
    \ R. Canetti, \"HMAC: Keyed-\n               Hashing for Message Authentication\"\
    , RFC 2104, February\n               1997.\n"
- title: 11.  Informative References
  contents:
  - "11.  Informative References\n   [RFC2202]   Cheng, P. and R. Glenn, \"Test Cases\
    \ for HMAC-MD5 and\n               HMAC-SHA-1\", RFC 2202, September 1997.\n \
    \  [RFC3174]   Eastlake 3rd, D. and P. Jones, \"US Secure Hash Algorithm\n   \
    \            1 (SHA1)\", RFC 3174, September 2001.\n   [RFC3874]   Housley, R.,\
    \ \"A 224-bit One-way Hash Function: SHA-224\",\n               RFC 3874, September\
    \ 2004.\n   [RFC4086]   Eastlake, D., 3rd, Schiller, J., and S. Crocker,\n   \
    \            \"Randomness Requirements for Security\", BCP 106, RFC\n        \
    \       4086, June 2005.\n   [RFC4231]   Nystrom, M., \"Identifiers and Test Vectors\
    \ for HMAC-SHA-\n               224, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512\"\
    , RFC\n               4231, December 2005.\n   [SHAVS]     \"The Secure Hash Algorithm\
    \ Validation System (SHAVS)\",\n               http://csrc.nist.gov/cryptval/shs/SHAVS.pdf.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Donald E. Eastlake, 3rd\n   Motorola Laboratories\n  \
    \ 155 Beaver Street\n   Milford, MA 01757 USA\n   Phone: +1-508-786-7554 (w)\n\
    \   EMail: donald.eastlake@motorola.com\n   Tony Hansen\n   AT&T Laboratories\n\
    \   200 Laurel Ave.\n   Middletown, NJ 07748 USA\n   Phone: +1-732-420-8934 (w)\n\
    \   EMail: tony+shs@maillennium.att.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
