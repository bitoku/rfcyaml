- title: __initial_text__
  contents:
  - '                        RSVP Security Properties

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document summarizes the security properties of RSVP.  The goal\n\
    \   of this analysis is to benefit from previous work done on RSVP and to\n  \
    \ capture knowledge about past activities.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.   Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n   2.   Terminology and Architectural Assumptions  . . . . .\
    \ . . . .   3\n   3.   Overview . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   5\n        3.1.  The RSVP INTEGRITY Object  . . . . . . . . . . . .\
    \ . .   5\n        3.2.  Security Associations  . . . . . . . . . . . . . . .\
    \ .   8\n        3.3.  RSVP Key Management Assumptions  . . . . . . . . . . .\
    \   8\n        3.4.  Identity Representation  . . . . . . . . . . . . . . .  \
    \ 9\n        3.5.  RSVP Integrity Handshake   . . . . . . . . . . . . . .  13\n\
    \   4.   Detailed Security Property Discussion  . . . . . . . . . . .  15\n  \
    \      4.1.  Network Topology   . . . . . . . . . . . . . . . . . .  15\n    \
    \    4.2.  Host/Router  . . . . . . . . . . . . . . . . . . . . .  15\n      \
    \  4.3.  User to PEP/PDP  . . . . . . . . . . . . . . . . . . .  19\n        4.4.\
    \  Communication between RSVP-Aware Routers . . . . . . .  28\n   5.   Miscellaneous\
    \ Issues . . . . . . . . . . . . . . . . . . . .  29\n        5.1.  First-Hop\
    \ Issue  . . . . . . . . . . . . . . . . . . .  30\n        5.2.  Next-Hop Problem\
    \ . . . . . . . . . . . . . . . . . . .  30\n        5.3.  Last-Hop Issue   .\
    \ . . . . . . . . . . . . . . . . . .  33\n        5.4.  RSVP- and IPsec-protected\
    \ data traffic . . . . . . . .  34\n        5.5.  End-to-End Security Issues and\
    \ RSVP  . . . . . . . . .  36\n        5.6.  IPsec protection of RSVP signaling\
    \ messages  . . . . .  36\n        5.7.  Authorization  . . . . . . . . . . .\
    \ . . . . . . . . .  37\n   6.   Conclusions  . . . . . . . . . . . . . . . .\
    \ . . . . . . . .  38\n   7.   Security Considerations  . . . . . . . . . . .\
    \ . . . . . . .  40\n   8.   Acknowledgements . . . . . . . . . . . . . . . .\
    \ . . . . . .  40\n   9.   References . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  40\n        9.1.  Normative References . . . . . . . . . . . . .\
    \ . . . .  40\n        9.2.  Informative References . . . . . . . . . . . . .\
    \ . . .  41\n   A.   Dictionary Attacks and Kerberos  . . . . . . . . . . . .\
    \ . .  45\n   B.   Example of User-to-PDP Authentication  . . . . . . . . . .\
    \ .  45\n   C.   Literature on RSVP Security  . . . . . . . . . . . . . . . .\
    \  46\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   As the work of the NSIS working group began, concerns about\
    \ security\n   and its implications for the design of a signaling protocol were\n\
    \   raised.  In order to understand the security properties and available\n  \
    \ options of RSVP, a number of documents have to be read.  This\n   document summarizes\
    \ the security properties of RSVP and is part of\n   the overall process of analyzing\
    \ other signaling protocols and\n   learning from their design considerations.\
    \  This document should also\n   provide a starting point for further discussions.\n\
    \   The content of this document is organized as follows.  Section 2\n   introduces\
    \ the terminology used throughout the document.  Section 3\n   provides an overview\
    \ of the security mechanisms provided by RSVP\n   including the INTEGRITY object,\
    \ a description of the identity\n   representation within the POLICY_DATA object\
    \ (i.e., user\n   authentication), and the RSVP Integrity Handshake mechanism.\
    \  Section\n   4 provides a more detailed discussion of the mechanisms used and\n\
    \   tries to describe in detail the mechanisms provided.  Several\n   miscellaneous\
    \ issues are covered in Section 5.\n   RSVP also supports multicast, but this\
    \ document does not address\n   security aspects for supporting multicast QoS\
    \ signaling.  Multicast\n   is currently outside the scope of the NSIS working\
    \ group.\n   Although a variation of RSVP, namely RSVP-TE, is used in the context\n\
    \   of MPLS to distribute labels for a label switched path, its usage is\n   different\
    \ from the usage scenarios envisioned for NSIS.  Hence, this\n   document does\
    \ not address RSVP-TE or its security properties.\n"
- title: 2.  Terminology and Architectural Assumptions
  contents:
  - "2.  Terminology and Architectural Assumptions\n   This section describes some\
    \ important terms and explains some\n   architectural assumptions.\n   o  Chain-of-Trust:\n\
    \      The security mechanisms supported by RSVP [1] heavily rely on\n      optional\
    \ hop-by-hop protection, using the built-in INTEGRITY\n      object.  Hop-by-hop\
    \ security with the INTEGRITY object inside the\n      RSVP message thereby refers\
    \ to the protection between RSVP-\n      supporting network elements.  Additionally,\
    \ there is the notion of\n      policy-aware nodes that understand the POLICY_DATA\
    \ element within\n      the RSVP message.  Because this element also includes\
    \ an INTEGRITY\n      object, there is an additional hop-by-hop security mechanism\
    \ that\n      provides security between policy-aware nodes.  Policy-ignorant\n\
    \      nodes are not affected by the inclusion of this object in the\n      POLICY_DATA\
    \ element, because they do not try to interpret it.\n      To protect signaling\
    \ messages that are possibly modified by each\n      RSVP router along the path,\
    \ it must be assumed that each incoming\n      request is authenticated, integrity\
    \ protected, and replay\n      protected.  This provides protection against bogus\
    \ messages\n      injected by unauthorized nodes.  Furthermore, each RSVP-aware\n\
    \      router is assumed to behave in the expected manner.  Outgoing\n      messages\
    \ transmitted to the next-hop network element receive new\n      protection according\
    \ to RSVP security processing.\n      Using the mechanisms described above, a\
    \ chain-of-trust is created\n      whereby a signaling message that is transmitted\
    \ by router A via\n      router B and received by router C is supposed to be secure\
    \ if\n      routers A and B and routers B and C share security associations\n\
    \      and all routers behave as expected.  Hence, router C trusts router\n  \
    \    A although router C does not have a direct security association\n      with\
    \ router A.  We can therefore conclude that the protection\n      achieved with\
    \ this hop-by-hop security for the chain-of-trust is\n      no better than the\
    \ weakest link in the chain.\n      If one router is malicious (for example, because\
    \ an adversary has\n      control over this router), then it can arbitrarily modify\n\
    \      messages, cause unexpected behavior, and mount a number of attacks\n  \
    \    that are not limited to QoS signaling.  Additionally, it must be\n      mentioned\
    \ that some protocols demand more protection than others\n      (which depends,\
    \ in part, on which nodes are executing these\n      protocols).  For example,\
    \ edge devices, where end-users are\n      attached, may be more likely to be\
    \ attacked in comparison with the\n      more secure core network of a service\
    \ provider.  In some cases, a\n      network service provider may choose not to\
    \ use the RSVP-provided\n      security mechanisms inside the core network because\
    \ a different\n      security protection is deployed.\n      Section 6 of [2]\
    \ mentions the term chain-of-trust in the context\n      of RSVP integrity protection.\
    \  In Section 6 of [14] the same term\n      is used in the context of user authentication\
    \ with the INTEGRITY\n      object inside the POLICY_DATA element.  Unfortunately,\
    \ the term is\n      not explained in detail and the assumptions behind it are\
    \ not\n      clearly specified.\n   o  Host and User Authentication:\n      The\
    \ presence of RSVP protection and a separate user identity\n      representation\
    \ leads to the fact that both user-identity and host-\n      identity are used\
    \ for RSVP protection.  Therefore, user-based\n      security and host-based security\
    \ are covered separately, because\n      of the different authentication mechanisms\
    \ provided.  To avoid\n      confusion about the different concepts, Section 3.4\
    \ describes the\n      concept of user authentication in more detail.\n   o  Key\
    \ Management:\n      It is assumed that most of the security associations required\
    \ for\n      the protection of RSVP signaling messages are already available,\n\
    \      and hence key management was done in advance.  There is, however,\n   \
    \   an exception with respect to support for Kerberos.  Using\n      Kerberos,\
    \ an entity is able to distribute a session key used for\n      RSVP signaling\
    \ protection.\n   o  RSVP INTEGRITY and POLICY_DATA INTEGRITY Objects:\n     \
    \ RSVP uses an INTEGRITY object in two places in a message.  The\n      first\
    \ is in the RSVP message itself and covers the entire RSVP\n      message as defined\
    \ in [1].  The second is included in the\n      POLICY_DATA object and defined\
    \ in [2].  To differentiate the two\n      objects by their scope of protection,\
    \ the two terms RSVP INTEGRITY\n      and POLICY_DATA INTEGRITY object are used,\
    \ respectively.  The data\n      structure of the two objects, however, is the\
    \ same.\n   o  Hop versus Peer:\n      In the past, the terminology for nodes\
    \ addressed by RSVP has been\n      discussed considerably.  In particular, two\
    \ favorite terms have\n      been used: hop and peer.  This document uses the\
    \ term hop, which\n      is different from an IP hop.  Two neighboring RSVP nodes\n\
    \      communicating with each other are not necessarily neighboring IP\n    \
    \  nodes (i.e., they may be more than one IP hop away).\n"
- title: 3.  Overview
  contents:
  - "3.  Overview\n   This section describes the security mechanisms provided by RSVP.\n\
    \   Although use of IPsec is mentioned in Section 10 of [1], the other\n   security\
    \ mechanisms primarily envisioned for RSVP are described.\n"
- title: 3.1.  The RSVP INTEGRITY Object
  contents:
  - "3.1.  The RSVP INTEGRITY Object\n   The RSVP INTEGRITY object is the major component\
    \ of RSVP security\n   protection.  This object is used to provide integrity and\
    \ replay\n   protection for the content of the signaling message between two RSVP\n\
    \   participating routers or between an RSVP router and host.\n   Furthermore,\
    \ the RSVP INTEGRITY object provides data origin\n   authentication.  The attributes\
    \ of the object are briefly described:\n   o  Flags field:\n       The Handshake\
    \ Flag is the only defined flag.  It is used to\n       synchronize sequence numbers\
    \ if the communication gets out of\n       sync (e.g., it allows a restarting\
    \ host to recover the most\n       recent sequence number).  Setting this flag\
    \ to one indicates that\n       the sender is willing to respond to an Integrity\
    \ Challenge\n       message.  This flag can therefore be seen as a negotiation\n\
    \       capability transmitted within each INTEGRITY object.\n   o  Key Identifier:\n\
    \       The Key Identifier selects the key used for verification of the\n    \
    \   Keyed Message Digest field and, hence, must be unique for the\n       sender.\
    \  It has a fixed 48-bit length.  The generation of this\n       Key Identifier\
    \ field is mostly a decision of the local host. [1]\n       describes this field\
    \ as a combination of an address, sending\n       interface, and key number. \
    \ We assume that the Key Identifier is\n       simply a (keyed) hash value computed\
    \ over a number of fields,\n       with the requirement to be unique if more than\
    \ one security\n       association is used in parallel between two hosts (e.g.,\
    \ as is\n       the case with security associations having overlapping\n     \
    \  lifetimes).  A receiving system uniquely identifies a security\n       association\
    \ based on the Key Identifier and the sender's IP\n       address.  The sender's\
    \ IP address may be obtained from the\n       RSVP_HOP object or from the source\
    \ IP address of the packet if\n       the RSVP_HOP object is not present.  The\
    \ sender uses the outgoing\n       interface to determine which security association\
    \ to use.  The\n       term \"outgoing interface\" may be confusing.  The sender\
    \ selects\n       the security association based on the receiver's IP address\n\
    \       (i.e., the address of the next RSVP-capable router).  The process\n  \
    \     of determining which node is the next RSVP-capable router is not\n     \
    \  further specified and is likely to be statically configured.\n   o  Sequence\
    \ Number:\n       The sequence number used by the INTEGRITY object is 64 bits\
    \ in\n       length, and the starting value can be selected arbitrarily.  The\n\
    \       length of the sequence number field was chosen to avoid\n       exhaustion\
    \ during the lifetime of a security association as\n       stated in Section 3\
    \ of [1].  In order for the receiver to\n       distinguish between a new and\
    \ a replayed message, the sequence\n       number must be monotonically incremented\
    \ (modulo 2^64) for each\n       message.  We assume that the first sequence number\
    \ seen (i.e.,\n       the starting sequence number) is stored somewhere.  The\
    \ modulo-\n       operation is required because the starting sequence number may\
    \ be\n       an arbitrary number.  The receiver therefore only accepts packets\n\
    \       with a sequence number larger (modulo 2^64) than the previous\n      \
    \ packet.  As explained in [1] this process is started by\n       handshaking\
    \ and agreeing on an initial sequence number.  If no\n       such handshaking\
    \ is available then the initial sequence number\n       must be part of the establishment\
    \ of the security association.\n       The generation and storage of sequence\
    \ numbers is an important\n       step in preventing replay attacks and is largely\
    \ determined by\n       the capabilities of the system in the presence of system\
    \ crashes,\n       failures, and restarts.  Section 3 of [1] explains some of\
    \ the\n       most important considerations.  However, the description of how\n\
    \       the receiver distinguishes proper from improper sequence numbers\n   \
    \    is incomplete: it implicitly assumes that gaps large enough to\n       cause\
    \ the sequence number to wrap around cannot occur.\n       If delivery in order\
    \ were guaranteed, the following procedure\n       would work: the receiver keeps\
    \ track of the first sequence number\n       received, INIT-SEQ, and the most\
    \ recent sequence number received,\n       LAST-SEQ, for each key identifier in\
    \ a security association.\n       When the first message is received, set INIT-SEQ\
    \ = LAST-SEQ =\n       value received and accept.  When a subsequent message is\n\
    \       received, if its sequence number is strictly between LAST-SEQ and\n  \
    \     INIT-SEQ, (modulo 2^64), accept and update LAST-SEQ with the\n       value\
    \ just received.  If it is between INIT-SEQ and LAST-SEQ,\n       inclusive, (modulo\
    \ 2^64), reject and leave the value of LAST-SEQ\n       unchanged.  Because delivery\
    \ in order is not guaranteed, the\n       above rules need to be combined with\
    \ a method of allowing a fixed\n       sized window in the neighborhood of LAST-SEQ\
    \ for out-of-order\n       delivery, for example, as described in Appendix C of\
    \ [3].\n   o  Keyed Message Digest:\n       The Keyed Message Digest is a security\
    \ mechanism built into RSVP\n       that used to provide integrity protection\
    \ of a signaling message\n       (including its sequence number).  Prior to computing\
    \ the value\n       for the Keyed Message Digest field, the Keyed Message Digest\n\
    \       field itself must be set to zero and a keyed hash computed over\n    \
    \   the entire RSVP packet.  The Keyed Message Digest field is\n       variable\
    \ in length but must be a multiple of four octets.  If\n       HMAC-MD5 is used,\
    \ then the output value is 16 bytes long.  The\n       keyed hash function HMAC-MD5\
    \ [4] is required for an RSVP\n       implementation, as noted in Section 1 of\
    \ [1].  Hash algorithms\n       other than MD5 [5], like SHA-1 [15], may also\
    \ be supported.\n       The key used for computing this Keyed Message Digest may\
    \ be\n       obtained from the pre-shared secret, which is either manually\n \
    \      distributed or the result of a key management protocol.  No key\n     \
    \  management protocol, however, is specified to create the desired\n       security\
    \ associations.  Also, no guidelines for key length are\n       given.  It should\
    \ be recommended that HMAC-MD5 keys be 128 bits\n       and SHA-1 keys 160 bits,\
    \ as in IPsec AH [16] and ESP [17].\n"
- title: 3.2.  Security Associations
  contents:
  - "3.2.  Security Associations\n   Different attributes are stored for security\
    \ associations of sending\n   and receiving systems (i.e., unidirectional security\
    \ associations).\n   The sending system needs to maintain the following attributes\
    \ in such\n   a security association [1]:\n      o  Authentication algorithm and\
    \ algorithm mode\n      o  Key\n      o  Key Lifetime\n      o  Sending Interface\n\
    \      o  Latest sequence number (received with this key identifier)\n   The receiving\
    \ system has to store the following fields:\n      o  Authentication algorithm\
    \ and algorithm mode\n      o  Key\n      o  Key Lifetime\n      o  Source address\
    \ of the sending system\n      o  List of last n sequence numbers (received with\
    \ this key\n         identifier)\n   Note that the security associations need\
    \ to have additional fields to\n   indicate their state.  It is necessary to have\
    \ overlapping lifetimes\n   of security associations to avoid interrupting an\
    \ ongoing\n   communication because of expired security associations.  During\
    \ such\n   a period of overlapping lifetime it is necessary to authenticate with\n\
    \   either one or both active keys.  As mentioned in [1], a sender and a\n   receiver\
    \ may have multiple active keys simultaneously.  If more than\n   one algorithm\
    \ is supported, then the algorithm used must be specified\n   for a security association.\n"
- title: 3.3.  RSVP Key Management Assumptions
  contents:
  - "3.3.  RSVP Key Management Assumptions\n   RFC 2205 [6] assumes that security\
    \ associations are already\n   available.  An implementation must support manual\
    \ key distribution as\n   noted in Section 5.2 of [1].  Manual key distribution,\
    \ however, has\n   different requirements for key storage; a simple plaintext\
    \ ASCII file\n   may be sufficient in some cases.  If multiple security associations\n\
    \   with different lifetimes need to be supported at the same time, then\n   a\
    \ key engine would be more appropriate.  Further security\n   requirements listed\
    \ in Section 5.2 of [1] are the following:\n   o  The manual deletion of security\
    \ associations must be supported.\n   o  The key storage should persist during\
    \ a system restart.\n   o  Each key must be assigned a specific lifetime and a\
    \ specific Key\n      Identifier.\n"
- title: 3.4.  Identity Representation
  contents:
  - "3.4.  Identity Representation\n   In addition to host-based authentication with\
    \ the INTEGRITY object\n   inside the RSVP message, user-based authentication\
    \ is available as\n   introduced in [2].  Section 2 of [7] states that \"Providing\
    \ policy\n   based admission control mechanism based on user identities or\n \
    \  application is one of the prime requirements.\"  To identify the user\n   or\
    \ the application, a policy element called AUTH_DATA, which is\n   contained in\
    \ the POLICY_DATA object, is created by the RSVP daemon at\n   the user's host\
    \ and transmitted inside the RSVP message.  The\n   structure of the POLICY_DATA\
    \ element is described in [2].  Network\n   nodes acting as policy decision points\
    \ (PDPs) then use the\n   information contained in the AUTH_DATA element to authenticate\
    \ the\n   user and to allow policy-based admission control to be executed.  As\n\
    \   mentioned in [7], the policy element is processed and the PDP\n   replaces\
    \ the old element with a new one for forwarding to the next\n   hop router.\n\
    \   A detailed description of the POLICY_DATA element can be found in\n   [2].\
    \  The attributes contained in the authentication data policy\n   element AUTH_DATA,\
    \ which is defined in [7], are briefly explained in\n   this Section.  Figure\
    \ 1 shows the abstract structure of the RSVP\n   message with its security-relevant\
    \ objects and the scope of\n   protection.  The RSVP INTEGRITY object (outer object)\
    \ covers the\n   entire RSVP message, whereas the POLICY_DATA INTEGRITY object\
    \ only\n   covers objects within the POLICY_DATA element.\n   +--------------------------------------------------------+\n\
    \   | RSVP Message                                           |\n   +--------------------------------------------------------+\n\
    \   | Object    |POLICY_DATA Object                         ||\n   |         \
    \  +-------------------------------------------+|\n   |           | INTEGRITY\
    \ +------------------------------+||\n   |           | Object    | AUTH_DATA Object\
    \             |||\n   |           |           +------------------------------+||\n\
    \   |           |           | Various Authentication       |||\n   |         \
    \  |           | Attributes                   |||\n   |           |          \
    \ +------------------------------+||\n   |           +-------------------------------------------+|\n\
    \   +--------------------------------------------------------+\n             \
    \  Figure 1: Security Relevant Objects and Elements\n                        \
    \ within the RSVP Message.\n   The AUTH_DATA object contains information for identifying\
    \ users and\n   applications together with credentials for those identities. \
    \ The\n   main purpose of these identities seems to be usage for policy-based\n\
    \   admission control and not authentication and key management.  As\n   noted\
    \ in Section 6.1 of [7], an RSVP message may contain more than\n   one POLICY_DATA\
    \ object and each of them may contain more than one\n   AUTH_DATA object.  As\
    \ indicated in Figure 1 and in [7], one AUTH_DATA\n   object may contain more\
    \ than one authentication attribute.  A typical\n   configuration for Kerberos-based\
    \ user authentication includes at\n   least the Policy Locator and an attribute\
    \ containing the Kerberos\n   session ticket.\n   Successful user authentication\
    \ is the basis for executing policy-\n   based admission control.  Additionally,\
    \ other information such as\n   time-of-day, application type, location information,\
    \ group\n   membership, etc. may be relevant to the implementation of an access\n\
    \   control policy.\n   The following attributes are defined for use in the AUTH_DATA\
    \ object:\n      o  Policy Locator\n         *  ASCII_DN\n         *  UNICODE_DN\n\
    \         *  ASCII_DN_ENCRYPT\n         *  UNICODE_DN_ENCRYPT\n         The policy\
    \ locator string is an X.500 distinguished name (DN)\n         used to locate\
    \ user or application-specific policy information.\n         The four types of\
    \ X.500 DNs are listed above.  The first two\n         types are the ASCII and\
    \ the Unicode representation of the user\n         or application DN identity.\
    \  The two \"encrypted\" distinguished\n         name types are either encrypted\
    \ with the Kerberos session key\n         or with the private key of the user's\
    \ digital certificate\n         (i.e., digitally signed).  The term \"encrypted\
    \ together with a\n         digital signature\" is easy to misconceive.  If user\
    \ identity\n         confidentiality is provided, then the policy locator has\
    \ to be\n         encrypted with the public key of the recipient.  How to obtain\n\
    \         this public key is not described in the document.  This detail\n   \
    \      may be specified in a concrete architecture in which RSVP is\n        \
    \ used.\n      o  Credentials\n         Two cryptographic credentials are currently\
    \ defined for a user:\n         authentication with Kerberos V5 [8], and authentication\
    \ with\n         the help of digital signatures based on X.509 [18] and PGP\n\
    \         [19].  The following list contains all defined credential types\n  \
    \       currently available and defined in [7]:\n         +--------------+--------------------------------+\n\
    \         | Credential   |  Description                   |\n         |    Type\
    \      |                                |\n         +===============================================|\n\
    \         | ASCII_ID     |  User or application identity  |\n         |      \
    \        |  encoded as an ASCII string    |\n         +--------------+--------------------------------+\n\
    \         | UNICODE_ID   |  User or application identity  |\n         |      \
    \        |  encoded as a Unicode string   |\n         +--------------+--------------------------------+\n\
    \         | KERBEROS_TKT |  Kerberos V5 session ticket    |\n         +--------------+--------------------------------+\n\
    \         | X509_V3_CERT |  X.509 V3 certificate          |\n         +--------------+--------------------------------+\n\
    \         | PGP_CERT     |  PGP certificate               |\n         +--------------+--------------------------------+\n\
    \                    Figure 2: Credentials Supported in RSVP.\n         The first\
    \ two credentials contain only a plaintext string, and\n         therefore they\
    \ do not provide cryptographic user\n         authentication.  These plaintext\
    \ strings may be used to\n         identify applications, that are included for\
    \ policy-based\n         admission control.  Note that these plain-text identifiers\
    \ may,\n         however, be protected if either the RSVP INTEGRITY or the\n \
    \        INTEGRITY object of the POLICY_DATA element is present.  Note\n     \
    \    that the two INTEGRITY objects can terminate at different\n         entities\
    \ depending on the network structure.  The digital\n         signature may also\
    \ provide protection of application\n         identifiers.  A protected application\
    \ identity (and the entire\n         content of the POLICY_DATA element) cannot\
    \ be modified as long\n         as no policy-ignorant nodes are encountered in\
    \ between.\n         A Kerberos session ticket, as previously mentioned, is the\n\
    \         ticket of a Kerberos AP_REQ message [8] without the\n         Authenticator.\
    \  Normally, the AP_REQ message is used by a\n         client to authenticate\
    \ to a server.  The INTEGRITY object\n         (e.g., of the POLICY_DATA element)\
    \ provides the functionality\n         of the Kerberos Authenticator, namely protecting\
    \ against replay\n         and showing that the user was able to retrieve the\
    \ session key\n         following the Kerberos protocol.  This is, however, only\
    \ the\n         case if the Kerberos session was used for the keyed message\n\
    \         digest field of the INTEGRITY object.  Section 7 of [1]\n         discusses\
    \ some issues for establishment of keys for the\n         INTEGRITY object.  The\
    \ establishment of the security\n         association for the RSVP INTEGRITY object\
    \ with the inclusion of\n         the Kerberos Ticket within the AUTH_DATA element\
    \ may be\n         complicated by the fact that the ticket can be decrypted by\n\
    \         node B, whereas the RSVP INTEGRITY object terminates at a\n        \
    \ different host C.\n         The Kerberos session ticket contains, among many\
    \ other fields,\n         the session key.  The Policy Locator may also be encrypted\
    \ with\n         the same session key.  The protocol steps that need to be\n \
    \        executed to obtain such a Kerberos service ticket are not\n         described\
    \ in [7] and may involve several roundtrips, depending\n         on many Kerberos-related\
    \ factors.  As an optimization, the\n         Kerberos ticket does not need to\
    \ be included in every RSVP\n         message, as described in Section 7.1 of\
    \ [1].  Thus, the\n         receiver must store the received service ticket. \
    \ If the\n         lifetime of the ticket has expired, then a new service ticket\n\
    \         must be sent.  If the receiver lost its state information\n        \
    \ (because of a crash or restart) then it may transmit an\n         Integrity\
    \ Challenge message to force the sender to re-transmit\n         a new service\
    \ ticket.\n         If either the X.509 V3 or the PGP certificate is included\
    \ in\n         the policy element, then a digital signature must be added.\n \
    \        The digital signature computed over the entire AUTH_DATA object\n   \
    \      provides authentication and integrity protection.  The SubType\n      \
    \   of the digital signature authentication attribute is set to\n         zero\
    \ before computing the digital signature.  Whether or not a\n         guarantee\
    \ of freshness with replay protection (either\n         timestamps or sequence\
    \ numbers) is provided by the digital\n         signature is an open issue as\
    \ discussed in Section 4.3.\n      o  Digital Signature\n         The digital\
    \ signature computed over the contents of the\n         AUTH_DATA object must\
    \ be the last attribute.  The algorithm\n         used to compute the digital\
    \ signature depends on the\n         authentication mode listed in the credential.\
    \  This is only\n         partially true, because, for example, PGP again allows\n\
    \         different algorithms to be used for computing a digital\n         signature.\
    \  The algorithm identifier used for computing the\n         digital signature\
    \ is not included in the certificate itself.\n         The algorithm identifier\
    \ included in the certificate only\n         serves the purpose of allowing the\
    \ verification of the\n         signature computed by the certificate authority\
    \ (except for the\n         case of self-signed certificates).\n      o  Policy\
    \ Error Object\n         The Policy Error Object is used in the case of a failure\
    \ of\n         policy-based admission control or other credential\n         verification.\
    \  Currently available error messages allow\n         notification if the credentials\
    \ are expired\n         (EXPIRED_CREDENTIALS), if the authorization process disallowed\n\
    \         the resource request (INSUFFICIENT_PRIVILEGES), or if the given\n  \
    \       set of credentials is not supported\n         (UNSUPPORTED_CREDENTIAL_TYPE).\
    \  The last error message returned\n         by the network allows the user's\
    \ host to discover the type of\n         credentials supported.  Particularly\
    \ for mobile environments\n         this might be quite inefficient.  Furthermore,\
    \ it is unlikely\n         that a user supports different types of credentials.\
    \  The\n         purpose of the error message IDENTITY_CHANGED is unclear.\n \
    \        Also, the protection of the error message is not discussed in\n     \
    \    [7].\n"
- title: 3.5.  RSVP Integrity Handshake
  contents:
  - "3.5.  RSVP Integrity Handshake\n   The Integrity Handshake protocol was designed\
    \ to allow a crashed or\n   restarted host to obtain the latest valid challenge\
    \ value stored at\n   the receiving host.  Due to the absence of key management,\
    \ it must be\n   guaranteed that two messages do not use the same sequence number\
    \ with\n   the same key.  A host stores the latest sequence number of a\n   cryptographically\
    \ verified message.  An adversary can replay\n   eavesdropped packets if the crashed\
    \ host has lost its sequence\n   numbers.  A signaling message from the real sender\
    \ with a new\n   sequence number would therefore allow the crashed host to update\
    \ the\n   sequence number field and prevent further replays.  Hence, if there\n\
    \   is a steady flow of RSVP-protected messages between the two hosts, an\n  \
    \ attacker may find it difficult to inject old messages, because new,\n   authenticated\
    \ messages with higher sequence numbers arrive and get\n   stored immediately.\n\
    \   The following description explains the details of an RSVP Integrity\n   Handshake\
    \ that is started by Node A after recovering from a\n   synchronization failure:\n\
    \                     Integrity Challenge\n                  (1) Message (including\n\
    \    +----------+      a Cookie)            +----------+\n    |          |-------------------------->|\
    \          |\n    |  Node A  |                           |  Node B  |\n    | \
    \         |<--------------------------|          |\n    +----------+      Integrity\
    \ Response   +----------+\n                  (2) Message (including\n        \
    \              the Cookie and the\n                      INTEGRITY object)\n \
    \                   Figure 3: RSVP Integrity Handshake.\n   The details of the\
    \ messages are as follows:\n      CHALLENGE:=(Key Identifier, Challenge Cookie)\n\
    \      Integrity Challenge Message:=(Common Header, CHALLENGE)\n      Integrity\
    \ Response Message:=(Common Header, INTEGRITY, CHALLENGE)\n   The \"Challenge\
    \ Cookie\" is suggested to be a MD5 hash of a local\n   secret and a timestamp\
    \ [1].\n   The Integrity Challenge message is not protected with an INTEGRITY\n\
    \   object as shown in the protocol flow above.  As explained in Section\n   10\
    \ of [1] this was done to avoid problems in situations where both\n   communicating\
    \ parties do not have a valid starting sequence number.\n   Using the RSVP Integrity\
    \ Handshake protocol is recommended although\n   it is not mandatory (because\
    \ it may not be needed in all network\n   environments).\n"
- title: 4.  Detailed Security Property Discussion
  contents:
  - "4.  Detailed Security Property Discussion\n   This section describes the protection\
    \ of the RSVP-provided mechanisms\n   for authentication, authorization, integrity\
    \ and replay protection\n   individually, user identity confidentiality, and confidentiality\
    \ of\n   the signaling messages,\n"
- title: 4.1.  Network Topology
  contents:
  - "4.1.  Network Topology\n   This paragraph shows the basic interfaces in a simple\
    \ RSVP network\n   architecture.  The architecture below assumes that there is\
    \ only a\n   single domain and that the two routers are RSVP- and policy-aware.\n\
    \   These assumptions are relaxed in the individual paragraphs, as\n   necessary.\
    \  Layer 2 devices between the clients and their\n   corresponding first-hop routers\
    \ are not shown.  Other network\n   elements like a Kerberos Key Distribution\
    \ Center and, for example, an\n   LDAP server from which the PDP retrieves its\
    \ policies are also\n   omitted.  The security of various interfaces to the individual\n\
    \   servers (KDC, PDP, etc.) depends very much on the security policy of\n   a\
    \ specific network service provider.\n                            +--------+\n\
    \                            | Policy |\n                       +----|Decision|\n\
    \                       |    | Point  +---+\n                       |    +--------+\
    \   |\n                       |                 |\n                       |  \
    \               |\n     +------+       +-+----+        +---+--+          +------+\n\
    \     |Client|       |Router|        |Router|          |Client|\n     |  A   +-------+\
    \  1   +--------+  2   +----------+  B   |\n     +------+       +------+     \
    \   +------+          +------+\n                     Figure 4: Simple RSVP Architecture.\n"
- title: 4.2.  Host/Router
  contents:
  - "4.2.  Host/Router\n   When considering authentication in RSVP, it is important\
    \ to make a\n   distinction between user and host authentication of the signaling\n\
    \   messages.  The host is authenticated using the RSVP INTEGRITY object,\n  \
    \ whereas credentials inside the AUTH_DATA object can be used to\n   authenticate\
    \ the user.  In this section, the focus is on host\n   authentication, whereas\
    \ the next section covers user authentication.\n   (1) Authentication\n      \
    \ The term \"host authentication\" is used above, because the\n       selection\
    \ of the security association is bound to the host's IP\n       address, as mentioned\
    \ in Section 3.1 and Section 3.2.  Depending\n       on the key management protocol\
    \ used to create this security\n       association and the identity used, it is\
    \ also possible to bind a\n       user identity to this security association.\
    \  Because the key\n       management protocol is not specified, it is difficult\
    \ to evaluate\n       this part, and hence we speak about data-origin authentication\n\
    \       based on the host's identity for RSVP INTEGRITY objects.  The\n      \
    \ fact that the host identity is used for selecting the security\n       association\
    \ has already been described in Section 3.1.\n       Data-origin authentication\
    \ is provided with a keyed hash value\n       computed over the entire RSVP message,\
    \ excluding the keyed\n       message digest field itself.  The security association\
    \ used\n       between the user's host and the first-hop router is, as\n     \
    \  previously mentioned, not established by RSVP, and it must\n       therefore\
    \ be available before signaling is started.\n       *  Kerberos for the RSVP INTEGRITY\
    \ object\n          As described in Section 7 of [1], Kerberos may be used to\n\
    \          create the key for the RSVP INTEGRITY object.  How to learn\n     \
    \     the principal name (and realm information) of the other node\n         \
    \ is outside the scope of [1]. [20] describes a way to\n          distribute principal\
    \ and realm information via DNS, which can\n          be used for this purpose\
    \ (assuming that the FQDN or the IP\n          address of the other node for which\
    \ this information is\n          desired is known).  All that is required is to\
    \ encapsulate the\n          Kerberos ticket inside the policy element.  It is\
    \ furthermore\n          mentioned that Kerberos tickets with expired lifetime\
    \ must not\n          be used, and the initiator is responsible for requesting\
    \ and\n          exchanging a new service ticket before expiration.\n        \
    \  RSVP multicast processing in combination with Kerberos\n          involves\
    \ additional considerations.  Section 7 of [1] states\n          that in the multicast\
    \ case all receivers must share a single\n          key with the Kerberos Authentication\
    \ Server (i.e., a single\n          principal used for all receivers).  From a\
    \ personal discussion\n          with Rodney Hess, it seems that there is currently\
    \ no other\n          solution available in the context of Kerberos.  Multicast\n\
    \          handling therefore leaves some open questions in this context.\n  \
    \        In the case where one entity crashed, the established security\n    \
    \      association is lost and therefore the other node must\n          retransmit\
    \ the service ticket.  The crashed entity can use an\n          Integrity Challenge\
    \ message to request a new Kerberos ticket\n          to be retransmitted by the\
    \ other node.  If a node receives\n          such a request, then a reply message\
    \ must be returned.\n   (2) Integrity protection\n       Integrity protection\
    \ between the user's host and the first-hop\n       router is based on the RSVP\
    \ INTEGRITY object.  HMAC-MD5 is\n       preferred, although other keyed hash\
    \ functions may also be used\n       within the RSVP INTEGRITY object.  In any\
    \ case, both\n       communicating entities must have a security association that\n\
    \       indicates the algorithm to use.  This may, however, be difficult,\n  \
    \     because no negotiation protocol is defined to agree on a specific\n    \
    \   algorithm.  Hence, if RSVP is used in a mobile environment, it is\n      \
    \ likely that HMAC-MD5 is the only usable algorithm for the RSVP\n       INTEGRITY\
    \ object.  Only in local environments may it be useful to\n       switch to a\
    \ different keyed hash algorithm.  The other possible\n       alternative is that\
    \ every implementation support the most\n       important keyed hash algorithms.\
    \ e.g., MD5, SHA-1, RIPEMD-160,\n       etc.  HMAC-MD5 was chosen mainly because\
    \ of its performance\n       characteristics.  The weaknesses of MD5 [21] are\
    \ known and were\n       initially described in [22].  Other algorithms like SHA-1\
    \ [15]\n       and RIPEMD-160 [21] have stronger security properties.\n   (3)\
    \ Replay Protection\n       The main mechanism used for replay protection in RSVP\
    \ is based on\n       sequence numbers, whereby the sequence number is included\
    \ in the\n       RSVP INTEGRITY object.  The properties of this sequence number\n\
    \       mechanism are described in Section 3.1 of [1].  The fact that the\n  \
    \     receiver stores a list of sequence numbers is an indicator for a\n     \
    \  window mechanism.  This somehow conflicts with the requirement\n       that\
    \ the receiver only has to store the highest number given in\n       Section 3\
    \ of [1].  We assume that this is an oversight.  Section\n       4.2 of [1] gives\
    \ a few comments about the out-of-order delivery\n       and the ability of an\
    \ implementation to specify the replay\n       window.  Appendix C of [3] describes\
    \ a window mechanism for\n       handling out-of-sequence delivery.\n   (4) Integrity\
    \ Handshake\n       The mechanism of the Integrity Handshake is explained in Section\n\
    \       3.5.  The Cookie value is suggested to be a hash of a local\n       secret\
    \ and a timestamp.  The Cookie value is not verified by the\n       receiver.\
    \  The mechanism used by the Integrity Handshake is a\n       simple Challenge/Response\
    \ message, which assumes that the key\n       shared between the two hosts survives\
    \ the crash.  If, however,\n       the security association is dynamically created,\
    \ then this\n       assumption may not be true.\n       In Section 10 of [1],\
    \ the authors note that an adversary can\n       create a faked Integrity Handshake\
    \ message that includes\n       challenge cookies.  Subsequently, it could store\
    \ the received\n       response and later try to replay these responses while\
    \ a\n       responder recovers from a crash or restart.  If this replayed\n  \
    \     Integrity Response value is valid and has a lower sequence number\n    \
    \   than actually used, then this value is stored at the recovering\n       host.\
    \  In order for this attack to be successful, the adversary\n       must either\
    \ have collected a large number of challenge/response\n       value pairs or have\
    \ \"discovered\" the cookie generation mechanism\n       (for example by knowing\
    \ the local secret).  The collection of\n       Challenge/Response pairs is even\
    \ more difficult, because they\n       depend on the Cookie value, the sequence\
    \ number included in the\n       response message, and the shared key used by\
    \ the INTEGRITY\n       object.\n   (5) Confidentiality\n       Confidentiality\
    \ is not considered to be a security requirement\n       for RSVP.  Hence, it\
    \ is not supported by RSVP, except as\n       described in paragraph d) of Section\
    \ 4.3.  This assumption may\n       not hold, however, for enterprises or carriers\
    \ who want to\n       protect billing data, network usage patterns, or network\n\
    \       configurations, in addition to users' identities, from\n       eavesdropping\
    \ and traffic analysis.  Confidentiality may also\n       help make certain other\
    \ attacks more difficult.  For example, the\n       PathErr attack described in\
    \ Section 5.2 is harder to carry out if\n       the attacker cannot observe the\
    \ Path message to which the PathErr\n       corresponds.\n   (6) Authorization\n\
    \       The task of authorization consists of two subcategories: network\n   \
    \    access authorization and RSVP request authorization.  Access\n       authorization\
    \ is provided when a node is authenticated to the\n       network, e.g., using\
    \ EAP [23] in combination with AAA protocols\n       (for example, RADIUS [24]\
    \ or DIAMETER [9]).  Issues related to\n       network access authentication and\
    \ authorization are outside the\n       scope of RSVP.\n       The second authorization\
    \ refers to RSVP itself.  Depending on the\n       network configuration:\n  \
    \     *  the router either forwards the received RSVP request to the\n       \
    \   policy decision point (e.g., using COPS [10] and [11]) to\n          request\
    \ that an admission control procedure be executed, or\n       *  the router supports\
    \ the functionality of a PDP and, therefore,\n          there is no need to forward\
    \ the request, or\n       *  the router may already be configured with the appropriate\n\
    \          policy information to decide locally whether to grant this\n      \
    \    request.\n       Based on the result of the admission control, the request\
    \ may be\n       granted or rejected.  Information about the resource-requesting\n\
    \       entity must be available to provide policy-based admission\n       control.\n\
    \   (7) Performance\n       The computation of the keyed message digest for an\
    \ RSVP INTEGRITY\n       object does not represent a performance problem.  The\
    \ protection\n       of signaling messages is usually not a problem, because these\n\
    \       messages are transmitted at a low rate.  Even a high volume of\n     \
    \  messages does not cause performance problems for an RSVP router\n       due\
    \ to the efficiency of the keyed message digest routine.\n       Dynamic key management,\
    \ which is computationally more demanding,\n       is more important for scalability.\
    \  Because RSVP does not specify\n       a particular key exchange protocol, it\
    \ is difficult to estimate\n       the effort needed to create the required security\
    \ associations.\n       Furthermore, the number of key exchanges to be triggered\
    \ depends\n       on security policy issues like lifetime of a security\n    \
    \   association, required security properties of the key exchange\n       protocol,\
    \ authentication mode used by the key exchange protocol,\n       etc.  In a stationary\
    \ environment with a single administrative\n       domain, manual security association\
    \ establishment may be\n       acceptable and may provide the best performance\
    \ characteristics.\n       In a mobile environment, asymmetric authentication\
    \ methods are\n       likely to be used with a key exchange protocol, and some\
    \ sort of\n       public key or certificate verification needs to be supported.\n"
- title: 4.3.  User to PEP/PDP
  contents:
  - "4.3.  User to PEP/PDP\n   As noted in the previous section, RSVP supports both\
    \ user-based and\n   host-based authentication.  Using RSVP, a user may authenticate\
    \ to\n   the first hop router or to the PDP as specified in [1], depending on\n\
    \   the infrastructure provided by the network domain or the architecture\n  \
    \ used (e.g., the integration of RSVP and Kerberos V5 into the Windows\n   2000\
    \ Operating System [25]).  Another architecture in which RSVP is\n   tightly integrated\
    \ is the one specified by the PacketCable\n   organization.  The interested reader\
    \ is referred to [26] for a\n   discussion of their security architecture.\n \
    \  (1) Authentication\n       When a user sends an RSVP PATH or RESV message,\
    \ this message may\n       include some information to authenticate the user.\
    \ [7] describes\n       how user and application information is embedded into\
    \ the RSVP\n       message (AUTH_DATA object) and how to protect it.  A router\n\
    \       receiving such a message can use this information to authenticate\n  \
    \     the client and forward the user or application information to the\n    \
    \   policy decision point (PDP).  Optionally, the PDP itself can\n       authenticate\
    \ the user, which is described in the next section.\n       To be able to authenticate\
    \ the user, to verify the integrity, and\n       to check for replays, the entire\
    \ POLICY_DATA element has to be\n       forwarded from the router to the PDP (e.g.,\
    \ by including the\n       element into a COPS message).  It is assumed, although\
    \ not\n       clearly specified in [7], that the INTEGRITY object within the\n\
    \       POLICY_DATA element is sent to the PDP along with all other\n       attributes.\n\
    \       *  Certificate Verification\n          Using the policy element as described\
    \ in [7], it is not\n          possible to provide a certificate revocation list\
    \ or other\n          information to prove the validity of the certificate inside\n\
    \          the policy element.  A specific mechanism for certificate\n       \
    \   verification is not discussed in [7] and hence a number of\n          them\
    \ can be used for this purpose.  For certificate\n          verification, the\
    \ network element (a router or the policy\n          decision point) that has\
    \ to authenticate the user could\n          frequently download certificate revocation\
    \ lists or use a\n          protocol like the Online Certificate Status Protocol\
    \ (OCSP)\n          [27] and the Simple Certificate Validation Protocol (SCVP)\n\
    \          [28] to determine the current status of a digital certificate.\n  \
    \     *  User Authentication to the PDP\n          This alternative authentication\
    \ procedure uses the PDP to\n          authenticate the user instead of the first-hop\
    \ router.  In\n          Section 4.2.1 of [7], the choice is given for the user\
    \ to\n          obtain a session ticket either for the next hop router or for\n\
    \          the PDP.  As noted in the same section, the identity of the\n     \
    \     PDP or the next hop router is statically configured or\n          dynamically\
    \ retrieved.  Subsequently, user authentication to\n          the PDP is considered.\n\
    \       *  Kerberos-based Authentication to the PDP\n          If Kerberos is\
    \ used to authenticate the user, then a session\n          ticket for the PDP\
    \ must be requested first.  A user who roams\n          between different routers\
    \ in the same administrative domain\n          does not need to request a new\
    \ service ticket, because the\n          same PDP is likely to be used by most\
    \ or all first-hop routers\n          within the same administrative domain. \
    \ This is different from\n          the case in which a session ticket for a router\
    \ has to be\n          obtained and authentication to a router is required.  The\n\
    \          router therefore plays a passive role of simply forwarding the\n  \
    \        request to the PDP and executing the policy decision returned\n     \
    \     by the PDP.  Appendix B describes one example of user-to-PDP\n         \
    \ authentication.\n          User authentication with the policy element provides\
    \ only\n          unilateral authentication, whereby the client authenticates\
    \ to\n          the router or to the PDP.  If an RSVP message is sent to the\n\
    \          user's host and public-key-based authentication is not used,\n    \
    \      then the message does not contain a certificate and digital\n         \
    \ signature.  Hence, no mutual authentication can be assumed.\n          In case\
    \ of Kerberos, mutual authentication may be accomplished\n          if the PDP\
    \ or the router transmits a policy element with an\n          INTEGRITY object\
    \ computed with the session key retrieved from\n          the Kerberos ticket,\
    \ or if the Kerberos ticket included in the\n          policy element is also\
    \ used for the RSVP INTEGRITY object as\n          described in Section 4.2. \
    \ This procedure only works if a\n          previous message was transmitted from\
    \ the end host to the\n          network and such key is already established.\
    \  Reference [7]\n          does not discuss this issue, and therefore there is\
    \ no\n          particular requirement for transmitting network-specific\n   \
    \       credentials back to the end-user's host.\n   (2) Integrity Protection\n\
    \          Integrity protection is applied separately to the RSVP message\n  \
    \        and the POLICY_DATA element, as shown in Figure 1.  In case of\n    \
    \      a policy-ignorant node along the path, the RSVP INTEGRITY\n          object\
    \ and the INTEGRITY object inside the policy element\n          terminate at different\
    \ nodes.  Basically, the same is true for\n          the user credentials if they\
    \ are verified at the policy\n          decision point instead of the first hop\
    \ router.\n       *  Kerberos\n          If Kerberos is used to authenticate the\
    \ user to the first hop\n          router, then the session key included in the\
    \ Kerberos ticket\n          may be used to compute the INTEGRITY object of the\
    \ policy\n          element.  It is the keyed message digest that provides the\n\
    \          authentication.  The existence of the Kerberos service ticket\n   \
    \       inside the AUTH_DATA object does not provide authentication or\n     \
    \     a guarantee of freshness for the receiving host.\n          Authentication\
    \ and guarantee of freshness are provided by the\n          keyed hash value of\
    \ the INTEGRITY object inside the\n          POLICY_DATA element.  This shows\
    \ that the user actively\n          participated in the Kerberos protocol and\
    \ was able to obtain\n          the session key to compute the keyed message digest.\
    \  The\n          Authenticator used in the Kerberos V5 protocol provides\n  \
    \        similar functionality, but replay protection is based on\n          timestamps\
    \ (or on a sequence number if the optional seq-number\n          field inside\
    \ the Authenticator is used for KRB_PRIV/KRB_SAFE\n          messages as described\
    \ in Section 5.3.2 of [8]).\n       *  Digital Signature\n          If public-key-based\
    \ authentication is provided, then user\n          authentication is accomplished\
    \ with a digital signature.  As\n          explained in Section 3.3.3 of [7],\
    \ the DIGITAL_SIGNATURE\n          attribute must be the last attribute in the\
    \ AUTH_DATA object,\n          and the digital signature covers the entire AUTH_DATA\
    \ object.\n          In the case of PGP, which hash algorithm and public key\n\
    \          algorithm are used for the digital signature computation is\n     \
    \     described in [19].  In the case of X.509 credentials, the\n          situation\
    \ is more complex because different mechanisms like\n          CMS [29] or PKCS#7\
    \ [30] may be used for digitally signing the\n          message element.  X.509\
    \ only provides the standard for the\n          certificate layout, which seems\
    \ to provide insufficient\n          information for this purpose.  Therefore,\
    \ X.509 certificates\n          are supported, for example, by CMS or PKCS#7.\
    \ [7], however,\n          does not make any statements about the usage of CMS\
    \ or PKCS#7.\n          Currently, there is no support for CMS or for PKCS#7 [7],\n\
    \          which provides more than just public-key-based authentication\n   \
    \       (e.g., CRL distribution, key transport, key agreement, etc.).\n      \
    \    Furthermore, the use of PGP in RSVP is vaguely defined,\n          because\
    \ there are different versions of PGP (including OpenPGP\n          [19]), and\
    \ no indication is given as to which should be used.\n          Supporting public-key-based\
    \ mechanisms in RSVP might increase\n          the risks of denial-of-service\
    \ attacks.  The large processing,\n          memory, and bandwidth requirements\
    \ should also be considered.\n          Fragmentation might also be an issue here.\n\
    \          If the INTEGRITY object is not included in the POLICY_DATA\n      \
    \    element or not sent to the PDP, then we have to make the\n          following\
    \ observations:\n             For the digital signature case, only the replay\
    \ protection\n             provided by the digital signature algorithm can be\
    \ used.\n             It is not clear, however, whether this usage was\n     \
    \        anticipated or not.  Hence, we might assume that replay\n           \
    \  protection is based on the availability of the RSVP\n             INTEGRITY\
    \ object used with a security association that is\n             established by\
    \ other means.\n             Including only the Kerberos session ticket is insufficient,\n\
    \             because freshness is not provided (because the Kerberos\n      \
    \       Authenticator is missing).  Obviously there is no guarantee\n        \
    \     that the user actually followed the Kerberos protocol and\n            \
    \ was able to decrypt the received TGS_REP (or, in rare\n             cases, the\
    \ AS_REP if a session ticket is requested with the\n             initial AS_REQ).\n\
    \   (3) Replay Protection\n       Figure 5 shows the interfaces relevant for replay\
    \ protection of\n       signaling messages in a more complicated architecture.\
    \  In this\n       case, the client uses the policy data element with PEP2, because\n\
    \       PEP1 is not policy-aware.  The interfaces between the client and\n   \
    \    PEP1 and between PEP1 and PEP2 are protected with the RSVP\n       INTEGRITY\
    \ object.  The link between the PEP2 and the PDP is\n       protected, for example,\
    \ by using the COPS built-in INTEGRITY\n       object.  The dotted line between\
    \ the Client and the PDP indicates\n       the protection provided by the AUTH_DATA\
    \ element, which has no\n       RSVP INTEGRITY object included.\n            \
    \            AUTH_DATA                         +----+\n      +---------------------------------------------------+PDP\
    \ +-+\n      |                                                   +----+ |\n  \
    \    |                                                          |\n      |   \
    \                                                       |\n      |           \
    \                                      COPS     |\n      |                   \
    \                              INTEGRITY|\n      |                           \
    \                               |\n      |                                   \
    \                       |\n      |                                           \
    \               |\n   +--+---+   RSVP INTEGRITY  +----+    RSVP INTEGRITY    +----+\
    \ |\n   |Client+-------------------+PEP1+----------------------+PEP2+-+\n   +--+---+\
    \                   +----+                      +-+--+\n      |              \
    \                                       |\n      +-----------------------------------------------------+\n\
    \                       POLICY_DATA INTEGRITY\n                       Figure 5:\
    \ Replay Protection.\n       Host authentication with the RSVP INTEGRITY object\
    \ and user\n       authentication with the INTEGRITY object inside the POLICY_DATA\n\
    \       element both use the same anti-replay mechanism.  The length of\n    \
    \   the Sequence Number field, sequence number rollover, and the\n       Integrity\
    \ Handshake have already been explained in Section 3.1.\n       Section 9 of [7]\
    \ states: \"RSVP INTEGRITY object is used to\n       protect the policy object\
    \ containing user identity information\n       from security (replay) attacks.\"\
    \  When using public-key-based\n       authentication, RSVP-based replay protection\
    \ is not supported,\n       because the digital signature does not cover the POLICY_DATA\n\
    \       INTEGRITY object with its Sequence Number field.  The digital\n      \
    \ signature covers only the entire AUTH_DATA object.\n       The use of public\
    \ key cryptography within the AUTH_DATA object\n       complicates replay protection.\
    \  Digital signature computation\n       with PGP is described in [31] and in\
    \ [19].  The data structure\n       preceding the signed message digest includes\
    \ information about\n       the message digest algorithm used and a 32-bit timestamp\
    \ of when\n       the signature was created (\"Signature creation time\").  The\n\
    \       timestamp is included in the computation of the message digest.\n    \
    \   The IETF standardized version of OpenPGP [19] contains more\n       information\
    \ and describes the different hash algorithms (MD2,\n       MD5, SHA-1, RIPEMD-160)\
    \ supported. [7] does not make any\n       statements as to whether the \"Signature\
    \ creation time\" field is\n       used for replay protection.  Using timestamps\
    \ for replay\n       protection requires different synchronization mechanisms\
    \ in the\n       case of clock-skew.  Traditionally, these cases assume \"loosely\n\
    \       synchronized\" clocks but also require specifying a replay window.\n \
    \      If the \"Signature creation time\" is not used for replay\n       protection,\
    \ then a malicious, policy-ignorant node can use this\n       weakness to replace\
    \ the AUTH_DATA object without destroying the\n       digital signature.  If this\
    \ was not simply an oversight, it is\n       therefore assumed that replay protection\
    \ of the user credentials\n       was not considered an important security requirement,\
    \ because the\n       hop-by-hop processing of the RSVP message protects the message\n\
    \       against modification by an adversary between two communicating\n     \
    \  nodes.\n       The lifetime of the Kerberos ticket is based on the fields\n\
    \       starttime and endtime of the EncTicketPart structure in the\n       ticket,\
    \ as described in Section 5.3.1 of [8].  Because the ticket\n       is created\
    \ by the KDC located at the network of the verifying\n       entity, it is not\
    \ difficult to have the clocks roughly\n       synchronized for the purpose of\
    \ lifetime verification.\n       Additional information about clock-synchronization\
    \ and Kerberos\n       can be found in [32].\n       If the lifetime of the Kerberos\
    \ ticket expires, then a new ticket\n       must be requested and used.  Rekeying\
    \ is implemented with this\n       procedure.\n   (4) (User Identity) Confidentiality\n\
    \       This section discusses privacy protection of identity information\n  \
    \     transmitted inside the policy element.  User identity\n       confidentiality\
    \ is of particular interest because there is no\n       built-in RSVP mechanism\
    \ for encrypting the POLICY_DATA object or\n       the AUTH_DATA elements.  Encryption\
    \ of one of the attributes\n       inside the AUTH_DATA element, the POLICY_LOCATOR\
    \ attribute, is\n       discussed.\n       To protect the user's privacy, it is\
    \ important not to reveal the\n       user's identity to an adversary located\
    \ between the user's host\n       and the first-hop router (e.g., on a wireless\
    \ link).\n       Furthermore, user identities should not be transmitted outside\n\
    \       the domain of the visited network provider.  That is, the user\n     \
    \  identity information inside the policy data element should be\n       removed\
    \ or modified by the PDP to prevent revealing its contents\n       to other (unauthorized)\
    \ entities along the signaling path.  It is\n       not possible (with the offered\
    \ mechanisms) to hide the user's\n       identity in such a way that it is not\
    \ visible to the first\n       policy-aware RSVP node (or to the attached network\
    \ in general).\n       The ASCII or Unicode distinguished name of the user or\n\
    \       application inside the POLICY_LOCATOR attribute of the AUTH_DATA\n   \
    \    element may be encrypted as specified in Section 3.3.1 of [7].\n       The\
    \ user (or application) identity is then encrypted with either\n       the Kerberos\
    \ session key or with the private key in case of\n       public-key-based authentication.\
    \  When the private key is used,\n       we usually speak of a digital signature\
    \ that can be verified by\n       everyone possessing the public key.  Because\
    \ the certificate with\n       the public key is included in the message itself,\
    \ decryption is\n       no obstacle.  Furthermore, the included certificate together\
    \ with\n       the additional (unencrypted) information in the RSVP message\n\
    \       provides enough identity information for an eavesdropper.  Hence,\n  \
    \     the possibility of encrypting the policy locator in case of\n       public-key-based\
    \ authentication is problematic.  To encrypt the\n       identities using asymmetric\
    \ cryptography, the user's host must be\n       able somehow to retrieve the public\
    \ key of the entity verifying\n       the policy element (i.e., the first policy-aware\
    \ router or the\n       PDP).  Then, this public key could be used to encrypt\
    \ a symmetric\n       key, which in turn encrypts the user's identity and certificate,\n\
    \       as is done, e.g., by PGP.  Currently, no such mechanism is\n       defined\
    \ in [7].\n       The algorithm used to encrypt the POLICY_LOCATOR with the\n\
    \       Kerberos session key is assumed to be the same as the one used\n     \
    \  for encrypting the service ticket.  The information about the\n       algorithm\
    \ used is available in the etype field of the\n       EncryptedData ASN.1 encoded\
    \ message part.  Section 6.3 of [8]\n       lists the supported algorithms. [33]\
    \ defines newer encryption\n       algorithms (Rijndael, Serpent, and Twofish).\n\
    \       Evaluating user identity confidentiality also requires looking at\n  \
    \     protocols executed outside of RSVP (for example, the Kerberos\n       protocol).\
    \  The ticket included in the CREDENTIAL attribute may\n       provide user identity\
    \ protection by not including the optional\n       cname attribute inside the\
    \ unencrypted part of the Ticket.\n       Because the Authenticator is not transmitted\
    \ with the RSVP\n       message, the cname and the crealm of the unencrypted part\
    \ of the\n       Authenticator are not revealed.  In order for the user to request\n\
    \       the Kerberos session ticket for inclusion in the CREDENTIAL\n       attribute,\
    \ the Kerberos protocol exchange must be executed.  Then\n       the Authenticator\
    \ sent with the TGS_REQ reveals the identity of\n       the user.  The AS_REQ\
    \ must also include the user's identity to\n       allow the Kerberos Authentication\
    \ Server to respond with an\n       AS_REP message that is encrypted with the\
    \ user's secret key.\n       Using Kerberos, it is therefore only possible to\
    \ hide the content\n       of the encrypted policy locator, which is only useful\
    \ if this\n       value differs from the Kerberos principal name.  Hence, using\n\
    \       Kerberos it is not \"entirely\" possible to provide user identity\n  \
    \     confidentiality.\n       It is important to note that information stored\
    \ in the policy\n       element may be changed by a policy-aware router or by\
    \ the policy\n       decision point.  Which parts are changed depends upon whether\n\
    \       multicast or unicast is used, how the policy server reacts, where\n  \
    \     the user is authenticated, whether the user needs to be re-\n       authenticated\
    \ in other network nodes, etc.  Hence, user-specific\n       and application-specific\
    \ information can leak after the messages\n       leave the first hop within the\
    \ network where the user's host is\n       attached.  As mentioned at the beginning\
    \ of this section, this\n       information leakage is assumed to be intentional.\n\
    \   (5) Authorization\n       In addition to the description of the authorization\
    \ steps of the\n       Host-to-Router interface, user-based authorization is performed\n\
    \       with the policy element providing user credentials.  The\n       inclusion\
    \ of user and application specific information enables\n       policy-based admission\
    \ control with special user policies that\n       are likely to be stored at a\
    \ dedicated server.  Hence, a Policy\n       Decision Point can query, for example,\
    \ an LDAP server for a\n       service level agreement that states the amount\
    \ of resources a\n       certain user is allowed to request.  In addition to the\
    \ user\n       identity information, group membership and other non-security-\n\
    \       related information may contribute to the evaluation of the final\n  \
    \     policy decision.  If the user is not registered to the currently\n     \
    \  attached domain, then there is the question of how much\n       information\
    \ the home domain of the user is willing to exchange.\n       This also impacts\
    \ the user's privacy policy.\n       In general, the user may not want to distribute\
    \ much of this\n       policy information.  Furthermore, the lack of a standardized\n\
    \       authorization data format may create interoperability problems\n     \
    \  when exchanging policy information.  Hence, we can assume that\n       the\
    \ policy decision point may use information from an initial\n       authentication\
    \ and key agreement protocol (which may have already\n       required cross-realm\
    \ communication with the user's home domain,\n       if only to show that the\
    \ home domain knows the user and that the\n       user is entitled to roam), to\
    \ forward accounting messages to this\n       domain.  This represents the traditional\
    \ subscriber-based\n       accounting scenario.  Non-traditional or alternative\
    \ means of\n       access might be deployed in the near future that do not require\n\
    \       any type of inter-domain communication.\n       Additional discussions\
    \ are required to determine the expected\n       authorization procedures. [34]\
    \ and [35] discuss authorization\n       issues for QoS signaling protocols. \
    \ Furthermore, a number of\n       mobility implications for policy handling in\
    \ RSVP are described\n       in [36].\n   (6) Performance\n       If Kerberos\
    \ is used for user authentication, then a Kerberos\n       ticket must be included\
    \ in the CREDENTIAL Section of the\n       AUTH_DATA element.  The Kerberos ticket\
    \ has a size larger than\n       500 bytes, but it only needs to be sent once\
    \ because a\n       performance optimization allows the session key to be cached\
    \ as\n       noted in Section 7.1 of [1].  It is assumed that subsequent RSVP\n\
    \       messages only include the POLICY_DATA INTEGRITY object with a\n      \
    \ keyed message digest that uses the Kerberos session key.\n       However, this\
    \ assumes that the security association required for\n       the POLICY_DATA INTEGRITY\
    \ object is created (or modified) to\n       allow the selection of the correct\
    \ key.  Otherwise, it difficult\n       to say which identifier is used to index\
    \ the security\n       association.\n       If Kerberos is used as an authentication\
    \ system then, from a\n       performance perspective, the message exchange to\
    \ obtain the\n       session key needs to be considered, although the exchange\
    \ only\n       needs to be done once in the lifetime of the session ticket.\n\
    \       This is particularly true in a mobile environment with a fast\n      \
    \ roaming user's host.\n       Public-key-based authentication usually provides\
    \ the best\n       scalability characteristics for key distribution, but the\n\
    \       protocols are performance demanding.  A major disadvantage of the\n  \
    \     public-key-based user authentication in RSVP is the lack of a\n       method\
    \ to derive a session key.  Hence, every RSVP PATH or RESV\n       message includes\
    \ the certificate and a digital signature, which\n       is a huge performance\
    \ and bandwidth penalty.  For a mobile\n       environment with low power devices,\
    \ high latency, channel noise,\n       and low-bandwidth links, this seems to\
    \ be less encouraging.  Note\n       that a public key infrastructure is required\
    \ to allow the PDP (or\n       the first-hop router) to verify the digital signature\
    \ and the\n       certificate.  To check for revoked certificates, certificate\n\
    \       revocation lists or protocols like the Online Certificate Status\n   \
    \    Protocol [27] and the Simple Certificate Validation Protocol [28]\n     \
    \  are needed.  Then the integrity of the AUTH_DATA object can be\n       verified\
    \ via the digital signature.\n"
- title: 4.4.  Communication between RSVP-Aware Routers
  contents:
  - "4.4.  Communication between RSVP-Aware Routers\n   (1) Authentication\n     \
    \  RSVP signaling messages have data origin authentication and are\n       protected\
    \ against modification and replay with the RSVP INTEGRITY\n       object.  The\
    \ RSVP message flow between routers is protected based\n       on the chain of\
    \ trust, and hence each router needs only a\n       security association with\
    \ its neighboring routers.  This\n       assumption was made because of performance\
    \ advantages and because\n       of special security characteristics of the core\
    \ network to which\n       no user hosts are directly attached.  In the core network\
    \ the\n       network structure does not change frequently and the manual\n  \
    \     distribution of shared secrets for the RSVP INTEGRITY object may\n     \
    \  be acceptable.  The shared secrets may be either manually\n       configured\
    \ or distributed by using appropriately secured network\n       management protocols\
    \ like SNMPv3.\n       Independent of the key distribution mechanism, host\n \
    \      authentication with built-in RSVP mechanisms is accomplished\n       using\
    \ the keyed message digest in the RSVP INTEGRITY object,\n       computed using\
    \ the previously exchanged symmetric key.\n   (2) Integrity Protection\n     \
    \  Integrity protection is accomplished with the RSVP INTEGRITY\n       object\
    \ with the variable length Keyed Message Digest field.\n   (3) Replay Protection\n\
    \       Replay protection with the RSVP INTEGRITY object is extensively\n    \
    \   described in previous sections.  To enable crashed hosts to learn\n      \
    \ the latest sequence number used, the Integrity Handshake\n       mechanism is\
    \ provided in RSVP.\n   (4) Confidentiality\n       Confidentiality is not provided\
    \ by RSVP.\n   (5) Authorization\n       Depending on the RSVP network, QoS resource\
    \ authorization at\n       different routers may need to contact the PDP again.\
    \  Because the\n       PDP is allowed to modify the policy element, a token may\
    \ be added\n       to the policy element to increase the efficiency of the re-\n\
    \       authorization procedure.  This token is used to refer to an\n       already\
    \ computed policy decision.  The communications interface\n       from the PEP\
    \ to the PDP must be properly secured.\n   (6) Performance\n       The performance\
    \ characteristics for the protection of the RSVP\n       signaling messages is\
    \ largely determined by the key exchange\n       protocol, because the RSVP INTEGRITY\
    \ object is only used to\n       compute a keyed message digest of the transmitted\
    \ signaling\n       messages.\n       The security associations within the core\
    \ network, that is,\n       between individual routers (in comparison with the\
    \ security\n       association between the user's host and the first-hop router\
    \ or\n       with the attached network in general), can be established more\n\
    \       easily because of the normally strong trust assumptions.\n       Furthermore,\
    \ it is possible to use security associations with an\n       increased lifetime\
    \ to avoid frequent rekeying.  Hence, there is\n       less impact on the performance\
    \ compared with the user-to-network\n       interface.  The security association\
    \ storage requirements are\n       also less problematic.\n"
- title: 5.  Miscellaneous Issues
  contents:
  - "5.  Miscellaneous Issues\n   This section describes a number of issues that illustrate\
    \ some of the\n   shortcomings of RSVP with respect to security.\n"
- title: 5.1.  First-Hop Issue
  contents:
  - "5.1.  First-Hop Issue\n   In case of end-to-end signaling, an end host starts\
    \ signaling to its\n   attached network.  The first-hop communication is often\
    \ more\n   difficult to secure because of the different requirements and a\n \
    \  missing trust relationship.  An end host must therefore obtain some\n   information\
    \ to start RSVP signaling:\n       o  Does this network support RSVP signaling?\n\
    \       o  Which node supports RSVP signaling?\n       o  To which node is authentication\
    \ required?\n       o  Which security mechanisms are used for authentication?\n\
    \       o  Which algorithms are required?\n       o  Where should the keys and\
    \ security associations come from?\n       o  Should a security association be\
    \ established?\n   RSVP, as specified today, is used as a building block.  Hence,\
    \ these\n   questions have to be answered as part of overall architectural\n \
    \  considerations.  Without answers to these questions, ad hoc RSVP\n   communication\
    \ by an end host roaming to an unknown network is not\n   possible.  A negotiation\
    \ of security mechanisms and algorithms is not\n   supported for RSVP.\n"
- title: 5.2.  Next-Hop Problem
  contents:
  - "5.2.  Next-Hop Problem\n   Throughout the document it was assumed that the next\
    \ RSVP node along\n   the path is always known.  Knowing the next hop is important\
    \ to be\n   able to select the correct key for the RSVP Integrity object and to\n\
    \   apply the proper protection.  In the case in which an RSVP node\n   assumes\
    \ it knows which node is the next hop, the following protocol\n   exchange can\
    \ occur:\n                      Integrity\n                          (A<->C) \
    \              +------+\n                                      (3)       | RSVP\
    \ |\n                                 +------------->+ Node |\n              \
    \                   |              |  B   |\n                    Integrity   \
    \ |              +--+---+\n                     (A<->C)     |                \
    \ |\n          +------+    (2)     +--+----+            |\n     (1)  | RSVP +----------->+Router\
    \ |            |  Error\n    ----->| Node |            | or    +<-----------+\
    \ (I am B)\n          |  A   +<-----------+Network|       (4)\n          +------+\
    \    (5)     +--+----+\n                     Error       .\n                 \
    \   (I am B)     .              +------+\n                                 . \
    \             | RSVP |\n                                 ...............+ Node\
    \ |\n                                                |  C   |\n              \
    \                                  +------+\n                         Figure 6:\
    \ Next-Hop Issue.\n   When RSVP node A in Figure 6 receives an incoming RSVP Path\
    \ message,\n   standard RSVP message processing takes place.  Node A then has\
    \ to\n   decide which key to select to protect the signaling message.  We\n  \
    \ assume that some unspecified mechanism is used to make this decision.\n   In\
    \ this example, node A assumes that the message will travel to RSVP\n   node C.\
    \  However, for some reasons (e.g., a route change, inability\n   to learn the\
    \ next RSVP hop along the path, etc.) the message travels\n   to node B via a\
    \ non-RSVP supporting router that cannot verify the\n   integrity of the message\
    \ (or cannot decrypt the Kerberos service\n   ticket).  The processing failure\
    \ causes a PathErr message to be\n   returned to the originating sender of the\
    \ Path message.  This error\n   message also contains information about the node\
    \ that recognized the\n   error.  In many cases, a security association might\
    \ not be available.\n   Node A receiving the PathErr message might use the information\n\
    \   returned with the PathErr message to select a different security\n   association\
    \ (or to establish one).\n   Figure 6 describes a behavior that might help node\
    \ A learn that an\n   error occurred.  However, the description in Section 4.2\
    \ of [1]\n   states in step (5) that a signaling message is silently discarded\
    \ if\n   the receiving host cannot properly verify the message: \"If the\n   calculated\
    \ digest does not match the received digest, the message is\n   discarded without\
    \ further processing.\"  For RSVP Path and similar\n   messages, this functionality\
    \ is not really helpful.\n   The RSVP Path message therefore provides a number\
    \ of functions: path\n   discovery, detecting route changes, discovery of QoS\
    \ capabilities\n   along the path using the Adspec object (with some interpretation),\n\
    \   next-hop discovery, and possibly security association establishment\n   (for\
    \ example, in the case of Kerberos).\n   From a security point of view, there\
    \ are conflicts between:\n   o  Idempotent message delivery and efficiency\n \
    \     The RSVP Path message especially performs a number of functions.\n     \
    \ Supporting idempotent message delivery somehow contradicts with\n      security\
    \ association establishment, efficient message delivery,\n      and message size.\
    \  For example, a \"real\" idempotent signaling\n      message would contain enough\
    \ information to perform security\n      processing without depending on a previously\
    \ executed message\n      exchange.  Adding a Kerberos ticket with every signaling\
    \ message\n      is, however, inefficient.  Using public-key-based mechanisms\
    \ is\n      even more inefficient when included in every signaling message.\n\
    \      With public-key-based protection for idempotent messages, there is\n  \
    \    the additional risk of introducing denial-of-service attacks.\n   o  RSVP\
    \ Path message functionality and next-hop discovery\n      To protect an RSVP\
    \ signaling message (and an RSVP Path message in\n      particular) it is necessary\
    \ to know the identity of the next\n      RSVP-aware node (and some other parameters).\
    \  Without a mechanism\n      for next-hop discovery, an RSVP Path message is\
    \ also responsible\n      for this task.  Without knowing the identity of the\
    \ next hop, the\n      Kerberos principal name is also unknown.  The so-called\
    \ Kerberos\n      user-to-user authentication mechanism, which would allow the\n\
    \      receiver to trigger the process of establishing Kerberos\n      authentication,\
    \ is not supported.  This issue will again be\n      discussed in relationship\
    \ with the last-hop problem.\n      It is fair to assume that an RSVP-supporting\
    \ node might not have\n      security associations with all immediately neighboring\
    \ RSVP nodes.\n      Especially for inter-domain signaling, IntServ over DiffServ,\
    \ or\n      some new applications such as firewall signaling, the next RSVP-\n\
    \      aware node might not be known in advance.  The number of next RSVP\n  \
    \    nodes might be considerably large if they are separated by a large\n    \
    \  number of non-RSVP aware nodes.  Hence, a node transmitting an\n      RSVP\
    \ Path message might experience difficulties in properly\n      protecting the\
    \ message if it serves as a mechanism to detect both\n      the next RSVP node\
    \ (i.e., Router Alert Option added to the\n      signaling message and addressed\
    \ to the destination address) and to\n      detect route changes.  It is fair\
    \ to note that, in the intra-\n      domain case with a dense distribution of\
    \ RSVP nodes, protection\n      might be possible with manual configuration.\n\
    \      Nothing prevents an adversary from continuously flooding an RSVP\n    \
    \  node with bogus PathErr messages, although it might be possible to\n      protect\
    \ the PathErr message with an existing, available security\n      association.\
    \  A legitimate RSVP node would believe that a change\n      in the path took\
    \ place.  Hence, this node might try to select a\n      different security association\
    \ or try to create one with the\n      indicated node.  If an adversary is located\
    \ somewhere along the\n      path, and either authentication or authorization\
    \ is not performed\n      with the necessary strength and accuracy, then it might\
    \ also be\n      possible to act as a man-in-the-middle.  One method of reducing\n\
    \      susceptibility to this attack is as follows: when a PathErr\n      message\
    \ is received from a node with which no security association\n      exists, attempt\
    \ to establish a security association and then\n      repeat the action that led\
    \ to the PathErr message.\n"
- title: 5.3.  Last-Hop Issue
  contents:
  - "5.3.  Last-Hop Issue\n   This section tries to address practical difficulties\
    \ when\n   authentication and key establishment are accomplished with a two-\n\
    \   party protocol that shows some asymmetry in message processing.\n   Kerberos\
    \ is such a protocol and also the only supported protocol that\n   provides dynamic\
    \ session key establishment for RSVP.  For first-hop\n   communication, authentication\
    \ is typically done between a user and\n   some router (for example the access\
    \ router).  Especially in a mobile\n   environment, it is not feasible to authenticate\
    \ end hosts based on\n   their IP or MAC address.  To illustrate this problem,\
    \ the typical\n   processing steps for Kerberos are shown for first-hop communication:\n\
    \   (1) The end host A learns the identity (i.e., Kerberos principal\n       name)\
    \ of some entity B.  This entity B is either the next RSVP\n       node, a PDP,\
    \ or the next policy-aware RSVP node.\n   (2) Entity A then requests a ticket\
    \ granting ticket for the network\n       domain.  This assumes that the identity\
    \ of the network domain is\n       known.\n   (3) Entity A then requests a service\
    \ ticket for entity B, whose name\n       was learned in step (1).\n   (4) Entity\
    \ A includes the service ticket with the RSVP signaling\n       message (inside\
    \ the policy object).  The Kerberos session key is\n       used to protect the\
    \ integrity of the entire RSVP signaling\n       message.\n   For last-hop communication,\
    \ this processing theoretically has to be\n   reversed: entity A is then a node\
    \ in the network (for example, the\n   access router) and entity B is the other\
    \ end host (under the\n   assumption that RSVP signaling is accomplished between\
    \ two end hosts\n   and not between an end host and an application server).  However,\
    \ the\n   access router in step (1) might not be able to learn the user's\n  \
    \ principal name because this information might not be available.\n   Entity A\
    \ could reverse the process by triggering an IAKERB exchange.\n   This would cause\
    \ entity B to request a service ticket for A as\n   described above.  However,\
    \ IAKERB is not supported in RSVP.\n"
- title: 5.4.  RSVP- and IPsec-Protected Data Traffic
  contents:
  - "5.4.  RSVP- and IPsec-Protected Data Traffic\n   QoS signaling requires flow\
    \ information to be established at routers\n   along a path.  This flow identifier\
    \ installed at each device tells\n   the router which data packets should receive\
    \ QoS treatment.  RSVP\n   typically establishes a flow identifier based on the\
    \ 5-tuple (source\n   IP address, destination IP address, transport protocol type,\
    \ source\n   port, and destination port).  If this 5-tuple information is not\n\
    \   available, then other identifiers have to be used.  ESP-encrypted\n   data\
    \ traffic is such an example where the transport protocol and the\n   port numbers\
    \ are not accessible.  Hence, the IPsec SPI is used as a\n   substitute for them.\
    \ [12] considers these IPsec implications for RSVP\n   and is based on three assumptions:\n\
    \   (1) An end host that initiates the RSVP signaling message exchange\n     \
    \  has to be able to retrieve the SPI for a given flow.  This\n       requires\
    \ some interaction with the IPsec security association\n       database (SAD)\
    \ and security policy database (SPD) [3].  An\n       application usually does\
    \ not know the SPI of the protected flow\n       and cannot provide the desired\
    \ values.  It can provide the\n       signaling protocol daemon with flow identifiers.\
    \  The signaling\n       daemon would then need to query the SAD by providing\
    \ the flow\n       identifiers as input parameters and receiving the SPI as an\n\
    \       output parameter.\n   (2) [12] assumes end-to-end IPsec protection of\
    \ the data traffic.  If\n       IPsec is applied in a nested fashion, then parts\
    \ of the path do\n       not experience QoS treatment.  This can be treated as\
    \ a problem\n       of tunneling that is initiated by the end host.  The following\n\
    \       figure better illustrates the problem in the case of enforcing\n     \
    \  secure network access:\n    +------+          +---------------+      +--------+\
    \          +-----+\n    | Host |          | Security      |      | Router |  \
    \        | Host|\n    |  A   |          | Gateway (SGW) |      |   Rx   |    \
    \      |  B  |\n    +--+---+          +-------+-------+      +----+---+      \
    \    +--+--+\n       |                      |                   |            \
    \     |\n       |IPsec-Data(           |                   |                 |\n\
    \       | OuterSrc=A,          |                   |                 |\n     \
    \  | OuterDst=SGW,        |                   |                 |\n       | SPI=SPI1,\
    \            |                   |                 |\n       | InnerSrc=A,   \
    \       |                   |                 |\n       | InnerDst=B,        \
    \  |                   |                 |\n       | Protocol=X,          |IPsec-Data(\
    \        |                 |\n       | SrcPort=Y,           | SrcIP=A,       \
    \   |                 |\n       | DstPort=Z)           | DstIP=B,          | \
    \                |\n       |=====================>| Protocol=X,       |IPsec-Data(\
    \      |\n       |                      | SrcPort=Y,        | SrcIP=A,       \
    \ |\n       | --IPsec protected->  | DstPort=Z)        | DstIP=B,        |\n \
    \      |    data traffic      |------------------>| Protocol=X,     |\n      \
    \ |                      |                   | SrcPort=Y,      |\n       |   \
    \                   |                   | DstPort=Z)      |\n       |        \
    \              |                   |---------------->|\n       |             \
    \         |                   |                 |\n       |                  \
    \    |     --Unprotected data traffic--->  |\n       |                      |\
    \                   |                 |\n              Figure 7: RSVP and IPsec\
    \ protected data traffic.\n       Host A, transmitting data traffic, would either\
    \ indicate a 3-\n       tuple <A, SGW, SPI1> or a 5-tuple <A, B, X, Y, Z>.  In\
    \ any case,\n       it is not possible to make a QoS reservation for the entire\
    \ path.\n       Two similar examples are remote access using a VPN and protection\n\
    \       of data traffic between a home agent (or a security gateway in\n     \
    \  the home network) and a mobile node.  The same problem occurs\n       with\
    \ a nested application of IPsec (for example, IPsec between A\n       and SGW\
    \ and between A and B).\n       One possible solution to this problem is to change\
    \ the flow\n       identifier along the path to capture the new flow identifier\n\
    \       after an IPsec endpoint.\n       IPsec tunnels that neither start nor\
    \ terminate at one of the\n       signaling end points (for example between two\
    \ networks) should be\n       addressed differently by recursively applying an\
    \ RSVP signaling\n       exchange for the IPsec tunnel.  RSVP signaling within\
    \ tunnels is\n       addressed in [13].\n   (3) It is assumed that SPIs do not\
    \ change during the lifetime of the\n       established QoS reservation.  If a\
    \ new IPsec SA is created, then\n       a new SPI is allocated for the security\
    \ association.  To reflect\n       this change, either a new reservation has to\
    \ be established or\n       the flow identifier of the existing reservation has\
    \ to be\n       updated.  Because IPsec SAs usually have a longer lifetime, this\n\
    \       does not seem to be a major issue.  IPsec protection of SCTP data\n  \
    \     traffic might more often require an IPsec SA (and SPI) change to\n     \
    \  reflect added and removed IP addresses from an SCTP association.\n"
- title: 5.5.   End-to-End Security Issues and RSVP
  contents:
  - "5.5.   End-to-End Security Issues and RSVP\n   End-to-end security for RSVP has\
    \ not been discussed throughout the\n   document.  In this context, end-to-end\
    \ security refers to credentials\n   transmitted between the two end hosts using\
    \ RSVP.  It is obvious that\n   care must be taken to ensure that routers along\
    \ the path are able to\n   process and modify the signaling messages according\
    \ to prescribed\n   processing procedures.  However, some objects or mechanisms\
    \ could be\n   used for end-to-end protection.  The main question, however, is\
    \ the\n   benefit of such end-to-end security.  First, there is the question of\n\
    \   how to establish the required security association.  Between two\n   arbitrary\
    \ hosts on the Internet, this might turn out to be quite\n   difficult.  Second,\
    \ the usefulness of end-to-end security depends on\n   the architecture in which\
    \ RSVP is deployed.  If RSVP is used only to\n   signal QoS information into the\
    \ network, and other protocols have to\n   be executed beforehand to negotiate\
    \ the parameters and to decide\n   which entity is charged for the QoS reservation,\
    \ then no end-to-end\n   security is likely to be required.  Introducing end-to-end\
    \ security\n   to RSVP would then cause problems with extensions like RSVP proxy\n\
    \   [37], Localized RSVP [38], and others that terminate RSVP signaling\n   somewhere\
    \ along the path without reaching the destination end host.\n   Such a behavior\
    \ could then be interpreted as a man-in-the-middle\n   attack.\n"
- title: 5.6.  IPsec Protection of RSVP Signaling Messages
  contents:
  - "5.6.  IPsec Protection of RSVP Signaling Messages\n   It is assumed throughout\
    \ that RSVP signaling messages can also be\n   protected by IPsec [3] in a hop-by-hop\
    \ fashion between two adjacent\n   RSVP nodes.  RSVP, however, uses special processing\
    \ of signaling\n   messages, which complicates IPsec protection.  As explained\
    \ in this\n   section, IPsec should only be used for protection of RSVP signaling\n\
    \   messages in a point-to-point communication environment (i.e., an RSVP\n  \
    \ message can only reach one RSVP router and not possibly more than\n   one).\
    \  This restriction is caused by the combination of signaling\n   message delivery\
    \ and discovery into a single message.  Furthermore,\n   end-to-end addressing\
    \ complicates IPsec handling considerably.  This\n   section describes at least\
    \ some of these complications.\n   RSVP messages are transmitted as raw IP packets\
    \ with protocol number\n   46.  It might be possible to encapsulate them in UDP\
    \ as described in\n   Appendix C of [6].  Some RSVP messages (Path, PathTear,\
    \ and ResvConf)\n   must have the Router Alert IP Option set in the IP header.\
    \  These\n   messages are addressed to the (unicast or multicast) destination\n\
    \   address and not to the next RSVP node along the path.  Hence, an\n   IPsec\
    \ traffic selector can only use these fields for IPsec SA\n   selection.  If there\
    \ is only a single path (and possibly all traffic\n   along it is protected) then\
    \ there is no problem for IPsec protection\n   of signaling messages.  This type\
    \ of protection is not common and\n   might only be used to secure network access\
    \ between an end host and\n   its first-hop router.  Because the described RSVP\
    \ messages are\n   addressed to the destination address instead of the next RSVP\
    \ node,\n   it is not possible to use IPsec ESP [17] or AH [16] in transport\n\
    \   mode--only IPsec in tunnel mode is possible.\n   If an RSVP message can taket\
    \ more than one possible path, then the\n   IPsec engine will experience difficulties\
    \ protecting the message.\n   Even if the RSVP daemon installs a traffic selector\
    \ with the\n   destination IP address, still, no distinguishing element allows\n\
    \   selection of the correct security association for one of the possible\n  \
    \ RSVP nodes along the path.  Even if it possible to apply IPsec\n   protection\
    \ (in tunnel mode) for RSVP signaling messages by\n   incorporating some additional\
    \ information, there is still the\n   possibility that the tunneled messages do\
    \ not recognize a path change\n   in a non-RSVP router.  In this case the signaling\
    \ messages would\n   simply follow a different path than the data.\n   RSVP messages\
    \ like RESV can be protected by IPsec, because they\n   contain enough information\
    \ to create IPsec traffic selectors that\n   allow differentiation between various\
    \ next RSVP nodes.  The traffic\n   selector would then contain the protocol number\
    \ and the source and\n   destination address pair of the two communicating RSVP\
    \ nodes.\n   One benefit of using IPsec is the availability of key management\n\
    \   using either IKE [39], KINK [40] or IKEv2 [41].\n"
- title: 5.7.  Authorization
  contents:
  - "5.7.  Authorization\n   [34] describes two trust models (NJ Turnpike and NJ Parkway)\
    \ and two\n   authorization models (per-session and per-channel financial\n  \
    \ settlement).  The NJ Turnpike model gives a justification for hop-by-\n   hop\
    \ security protection.  RSVP focuses on the NJ Turnpike model,\n   although the\
    \ different trust models are not described in detail.\n   RSVP supports the NJ\
    \ Parkway model and per-channel financial\n   settlement only to a certain extent.\
    \  Authentication of the user (or\n   end host) can be provided with the user\
    \ identity representation\n   mechanism, but authentication might, in many cases,\
    \ be insufficient\n   for authorization.  The communication procedures defined\
    \ for policy\n   objects [42] can be improved to support the more efficient per-\n\
    \   channel financial settlement model by avoiding policy handling\n   between\
    \ inter-domain networks at a signaling message granularity.\n   Additional information\
    \ about expected behavior of policy handling in\n   RSVP can also be obtained\
    \ from [43].\n   [35] and [36] provide additional information on authorization.\
    \  No\n   good and agreed mechanism for dealing with authorization of QoS\n  \
    \ reservations in roaming environments is provided.  Price distribution\n   mechanisms\
    \ are only described in papers and never made their way\n   through standardization.\
    \  RSVP focuses on receiver-initiated\n   reservations with authorization for\
    \ the QoS reservation by the data\n   receiver, which introduces a fair amount\
    \ of complexity for mobility\n   handling as described, for example, in [36].\n"
- title: 6.  Conclusions
  contents:
  - "6.  Conclusions\n   RSVP was the first QoS signaling protocol that provided some\
    \ security\n   protection.  Whether RSVP provides appropriate security protection\n\
    \   heavily depends on the environment where it is deployed.  RSVP as\n   specified\
    \ today should be viewed as a building block that has to be\n   adapted to a given\
    \ architecture.\n   This document aims to provide more insight into the security\
    \ of RSVP.\n   It cannot be interpreted as a pass or fail evaluation of the security\n\
    \   provided by RSVP.\n   Certainly this document is not a complete description\
    \ of all security\n   issues related to RSVP.  Some issues that require further\n\
    \   consideration are RSVP extensions (for example [12]), multicast\n   issues,\
    \ and other security properties like traffic analysis.\n   Additionally, the interaction\
    \ with mobility protocols (micro- and\n   macro-mobility) demands further investigation\
    \ from a security point\n   of view.\n   What can be learned from practical protocol\
    \ experience and from the\n   increased awareness regarding security is that some\
    \ of the available\n   credential types have received more acceptance than others.\
    \  Kerberos\n   is a system that is integrated into many IETF protocols today.\n\
    \   Public-key-based authentication techniques are, however, still\n   considered\
    \ to be too heavy-weight (computationally and from a\n   bandwidth perspective)\
    \ to be used for per-flow signaling.  The\n   increased focus on denial of service\
    \ attacks puts additional demands\n   on the design of public-key-based authentication.\n\
    \   The following list briefly summarizes a few security or architectural\n  \
    \ issues that deserve improvement:\n   o  Discovery and signaling message delivery\
    \ should be separated.\n   o  For some applications and scenarios, it cannot be\
    \ assumed that\n      neighboring RSVP-aware nodes know each other.  Hence, some\
    \ in-path\n      discovery mechanism should be provided.\n   o  Addressing for\
    \ signaling messages should be done in a hop-by-hop\n      fashion.\n   o  Standard\
    \ security protocols (IPsec, TLS, or CMS) should be used\n      whenever possible.\
    \  Authentication and key exchange should be\n      separated from signaling message\
    \ protection.  In general, it is\n      necessary to provide key management to\
    \ establish security\n      associations dynamically for signaling message protection.\n\
    \      Relying on manually configured keys between neighboring RSVP nodes\n  \
    \    is insufficient.  A separate, less frequently executed key\n      management\
    \ and security association establishment protocol is a\n      good place to perform\
    \ entity authentication, security service\n      negotiation and selection, and\
    \ agreement on mechanisms,\n      transforms, and options.\n   o  The use of public\
    \ key cryptography in authorization tokens,\n      identity representations, selective\
    \ object protection, etc. is\n      likely to cause fragmentation, the need to\
    \ protect against denial\n      of service attacks, and other problems.\n   o\
    \  Public key authentication and user identity confidentiality\n      provided\
    \ with RSVP require some improvement.\n   o  Public-key-based user authentication\
    \ only provides entity\n      authentication.  An additional security association\
    \ is required to\n      protect signaling messages.\n   o  Data origin authentication\
    \ should not be provided by non-RSVP\n      nodes (such as the PDP).  Such a procedure\
    \ could be accomplished\n      by entity authentication during the authentication\
    \ and key\n      exchange phase.\n   o  Authorization and charging should be better\
    \ integrated into the\n      base protocol.\n   o  Selective message protection\
    \ should be provided.  A protected\n      message should be recognizable from\
    \ a flag in the header.\n   o  Confidentiality protection is missing and should\
    \ therefore be\n      added to the protocol.  The general principle is that protocol\n\
    \      designers can seldom foresee all of the environments in which\n      protocols\
    \ will be run, so they should allow users to select from a\n      full range of\
    \ security services, as the needs of different user\n      communities vary.\n\
    \   o  Parameter and mechanism negotiation should be provided.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   This document discusses security properties of\
    \ RSVP and, as such, it\n   is concerned entirely with security.\n"
- title: 8.  Acknowledgements
  contents:
  - "8.  Acknowledgements\n   We would like to thank Jorge Cuellar, Robert Hancock,\
    \ Xiaoming Fu,\n   Guenther Schaefer, Marc De Vuyst, Bob Grillo, and Jukka Manner\
    \ for\n   their comments.  Additionally, Hannes would like to thank Robert and\n\
    \   Jorge for their time discussing various issues.\n   Finally, we would like\
    \ to thank Allison Mankin and John Loughney for\n   their guidance and input.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [1]   Baker, F., Lindell, B., and M. Talwar, \"\
    RSVP Cryptographic\n         Authentication\", RFC 2747, January 2000.\n   [2]\
    \   Herzog, S., \"RSVP Extensions for Policy Control\", RFC 2750,\n         January\
    \ 2000.\n   [3]   Kent, S. and R. Atkinson, \"Security Architecture for the\n\
    \         Internet Protocol\", RFC 2401, November 1998.\n   [4]   Krawczyk, H.,\
    \ Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing\n         for Message Authentication\"\
    , RFC 2104, February 1997.\n   [5]   Rivest, R., \"The MD5 Message-Digest Algorithm\"\
    , RFC 1321, April\n         1992.\n   [6]   Braden, B., Zhang, L., Berson, S.,\
    \ Herzog, S., and S. Jamin,\n         \"Resource ReSerVation Protocol (RSVP) --\
    \ Version 1 Functional\n         Specification\", RFC 2205, September 1997.\n\
    \   [7]   Yadav, S., Yavatkar, R., Pabbati, R., Ford, P., Moore, T.,\n       \
    \  Herzog, S., and R. Hess, \"Identity Representation for RSVP\",\n         RFC\
    \ 3182, October 2001.\n   [8]   Kohl, J. and C. Neuman, \"The Kerberos Network\
    \ Authentication\n         Service (V5)\", RFC 1510, September 1993.  Obsoleted\
    \ by RFC\n         4120.\n   [9]   Calhoun, P., Loughney, J., Guttman, E., Zorn,\
    \ G., and J. Arkko,\n         \"Diameter Base Protocol\", RFC 3588, September\
    \ 2003.\n   [10]  Durham, D., Boyle, J., Cohen, R., Herzog, S., Rajan, R., and\
    \ A.\n         Sastry, \"The COPS (Common Open Policy Service) Protocol\", RFC\n\
    \         2748, January 2000.\n   [11]  Herzog, S., Boyle, J., Cohen, R., Durham,\
    \ D., Rajan, R., and A.\n         Sastry, \"COPS usage for RSVP\", RFC 2749, January\
    \ 2000.\n   [12]  Berger, L. and T. O'Malley, \"RSVP Extensions for IPSEC Data\n\
    \         Flows\", RFC 2207, September 1997.\n   [13]  Terzis, A., Krawczyk, J.,\
    \ Wroclawski, J., and L. Zhang, \"RSVP\n         Operation Over IP Tunnels\",\
    \ RFC 2746, January 2000.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [14]  Hess, R. and S. Herzog, \"RSVP Extensions\
    \ for Policy Control\",\n         Work in Progress, June 2001.\n   [15]  \"Secure\
    \ Hash Standard, NIST, FIPS PUB 180-1\", Federal\n         Information Processing\
    \ Society, April 1995.\n   [16]  Kent, S. and R. Atkinson, \"IP Authentication\
    \ Header\", RFC 2402,\n         November 1998.\n   [17]  Kent, S. and R. Atkinson,\
    \ \"IP Encapsulating Security Payload\n         (ESP)\", RFC 2406, November 1998.\n\
    \   [18]  Fowler, D., \"Definitions of Managed Objects for the DS1, E1,\n    \
    \     DS2 and E2 Interface Types\", RFC 2495, January 1999.\n   [19]  Callas,\
    \ J., Donnerhacke, L., Finney, H., and R. Thayer,\n         \"OpenPGP Message\
    \ Format\", RFC 2440, November 1998.\n   [20]  Hornstein, K. and J. Altman, \"\
    Distributing Kerberos KDC and\n         Realm Information with DNS\", Work in\
    \ Progress, July 2002.\n   [21]  Dobbertin, H., Bosselaers, A., and B. Preneel,\
    \ \"RIPEMD-160: A\n         strengthened version of RIPEMD in Fast Software Encryption\"\
    ,\n         LNCS vol. 1039, pp. 71-82, 1996.\n   [22]  Dobbertin, H., \"The Status\
    \ of MD5 After a Recent Attack\", RSA\n         Laboratories CryptoBytes, vol.\
    \ 2, no. 2, 1996.\n   [23]  Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J.,\
    \ and H.\n         Levkowetz, \"Extensible Authentication Protocol (EAP)\", RFC\n\
    \         3748, June 2004.\n   [24]  Rigney, C., Willens, S., Rubens, A., and\
    \ W. Simpson, \"Remote\n         Authentication Dial In User Service (RADIUS)\"\
    , RFC 2865, June\n         2000.\n   [25]  \"Microsoft Authorization Data Specification\
    \ v. 1.0 for\n         Microsoft Windows 2000 Operating Systems\", April 2000.\n\
    \   [26]  Cable Television Laboratories, Inc., \"PacketCable Security\n      \
    \   Specification, PKT-SP-SEC-I01-991201\", website:\n         http://www.PacketCable.com/,\
    \ June 2003.\n   [27]  Myers, M., Ankney, R., Malpani, A., Galperin, S., and C.\
    \ Adams,\n         \"X.509 Internet Public Key Infrastructure Online Certificate\n\
    \         Status Protocol - OCSP\", RFC 2560, June 1999.\n   [28]  Malpani, A.,\
    \ Housley, R., and T. Freeman, \"Simple Certificate\n         Validation Protocol\
    \ (SCVP)\", Work in Progress, October 2005.\n   [29]  Housley, R., \"Cryptographic\
    \ Message Syntax (CMS)\", RFC 3369,\n         August 2002.\n   [30]  Kaliski,\
    \ B., \"PKCS #7: Cryptographic Message Syntax Version\n         1.5\", RFC 2315,\
    \ March 1998.\n   [31]  \"Specifications and standard documents\", website:\n\
    \         http://www.PacketCable.com/, March 2002.\n   [32]  Davis, D. and D.\
    \ Geer, \"Kerberos With Clocks Adrift: History,\n         Protocols and Implementation\"\
    , USENIX Computing Systems, vol 9\n         no. 1, Winter 1996.\n   [33]  Raeburn,\
    \ K., \"Encryption and Checksum Specifications for\n         Kerberos 5\", RFC\
    \ 3961, February 2005.\n   [34]  Tschofenig, H., Buechli, M., Van den Bosch, S.,\
    \ and H.\n         Schulzrinne, \"NSIS Authentication, Authorization and Accounting\n\
    \         Issues\", Work in Progress, March 2003.\n   [35]  Tschofenig, H., Buechli,\
    \ M., Van den Bosch, S., Schulzrinne,\n         H., and T. Chen, \"QoS NSLP Authorization\
    \ Issues\", Work in\n         Progress, June 2003.\n   [36]  Thomas, M., \"Analysis\
    \ of Mobile IP and RSVP Interactions\", Work\n         in Progress, October 2002.\n\
    \   [37]  Gai, S., Gaitonde, S., Elfassy, N., and Y. Bernet, \"RSVP\n        \
    \ Proxy\", Work in Progress, March 2002.\n   [38]  Manner, J., Suihko, T., Kojo,\
    \ M., Liljeberg, M., and K.\n         Raatikainen, \"Localized RSVP\", Work in\
    \ Progress, September\n         2004.\n   [39]  Harkins, D. and D. Carrel, \"\
    The Internet Key Exchange (IKE)\",\n         RFC 2409, November 1998.\n   [40]\
    \  Thomas, M., \"Kerberized Internet Negotiation of Keys (KINK)\",\n         Work\
    \ in Progress, October 2005.\n   [41]  Kaufman, C., \"Internet Key Exchange (IKEv2)\
    \ Protocol\", RFC\n         4306, November 2005.\n   [42]  Herzog, S., \"Accounting\
    \ and Access Control in RSVP\", PhD\n         Dissertation, USC, Work in Progress,\
    \ November 1995.\n   [43]  Herzog, S., \"Accounting and Access Control for Multicast\n\
    \         Distributions: Models and Mechanisms\", June 1996.\n   [44]  Pato, J.,\
    \ \"Using Pre-Authentication to Avoid Password Guessing\n         Attacks\", Open\
    \ Software Foundation DCE Request for Comments,\n         December 1992.\n   [45]\
    \  Tung, B. and L. Zhu, \"Public Key Cryptography for Initial\n         Authentication\
    \ in Kerberos\", Work in Progress, November 2005.\n   [46]  Wu, T., \"A Real-World\
    \ Analysis of Kerberos Password Security\",\n         in Proceedings of the 1999\
    \ Internet Society Network and\n         Distributed System Security Symposium,\
    \ San Diego, February\n         1999.\n   [47]  Wu, T., Wu, F., and F. Gong, \"\
    Securing QoS: Threats to RSVP\n         Messages and Their Countermeasures\",\
    \ IEEE IWQoS, pp. 62-64,\n         1999.\n   [48]  Talwar, V., Nahrstedt, K.,\
    \ and F. Gong, \"Securing RSVP For\n         Multimedia Applications\", Proc ACM\
    \ Multimedia 2000 (Multimedia\n         Security Workshop), November 2000.\n \
    \  [49]  Talwar, V., Nahrstedt, K., and S. Nath, \"RSVP-SQoS: A Secure\n     \
    \    RSVP Protocol\", International Conf on Multimedia and\n         Exposition,\
    \ Tokyo, Japan, August 2001.\n   [50]  Jablon, D., \"Strong Password-only Authenticated\
    \ Key Exchange\",\n         ACM Computer Communication Review, 26(5), pp. 5-26,\
    \ October\n         1996.\n"
- title: Appendix A.  Dictionary Attacks and Kerberos
  contents:
  - "Appendix A.  Dictionary Attacks and Kerberos\n   Kerberos might be used with\
    \ RSVP as described in this document.\n   Because dictionary attacks are often\
    \ mentioned in relationship with\n   Kerberos, a few issues are addressed here.\n\
    \   The initial Kerberos AS_REQ request (without pre-authentication,\n   without\
    \ various extensions, and without PKINIT) is unprotected.  The\n   response message\
    \ AS_REP is encrypted with the client's long-term key.\n   An adversary can take\
    \ advantage of this fact by requesting AS_REP\n   messages to mount an off-line\
    \ dictionary attack.  Pre-authentication\n   ([44]) can be used to reduce this\
    \ problem.  However, pre-\n   authentication does not entirely prevent dictionary\
    \ attacks by an\n   adversary who can still eavesdrop on Kerberos messages along\
    \ the path\n   between a mobile node and a KDC.  With mandatory pre-authentication\n\
    \   for the initial request, an adversary cannot request a Ticket\n   Granting\
    \ Ticket for an arbitrary user.  On-line password guessing\n   attacks are still\
    \ possible by choosing a password (e.g., from a\n   dictionary) and then transmitting\
    \ an initial request that includes a\n   pre-authentication data field.  An unsuccessful\
    \ authentication by the\n   KDC results in an error message and thus gives the\
    \ adversary a hint\n   to restart the protocol and try a new password.\n   There\
    \ are, however, some proposals that prevent dictionary attacks.\n   The use of\
    \ Public Key Cryptography for initial authentication [45]\n   (PKINIT) is one\
    \ such solution.  Other proposals use strong-password-\n   based authenticated\
    \ key agreement protocols to protect the user's\n   password during the initial\
    \ Kerberos exchange. [46] discusses the\n   security of Kerberos and also discusses\
    \ mechanisms to prevent\n   dictionary attacks.\n"
- title: Appendix B.  Example of User-to-PDP Authentication
  contents:
  - "Appendix B.  Example of User-to-PDP Authentication\n   The following Section\
    \ describes an example of user-to-PDP\n   authentication.  Note that the description\
    \ below is not fully covered\n   by the RSVP specification and hence it should\
    \ only be viewed as an\n   example.\n   Windows 2000, which integrates Kerberos\
    \ into RSVP, uses a\n   configuration with the user authentication to the PDP\
    \ as described in\n   [25].  The steps for authenticating the user to the PDP\
    \ in an intra-\n   realm scenario are the following:\n   o  Windows 2000 requires\
    \ the user to contact the KDC and to request a\n      Kerberos service ticket\
    \ for the PDP account AcsService in the\n      local realm.\n   o  This ticket\
    \ is then embedded into the AUTH_DATA element and\n      included in either the\
    \ PATH or the RESV message.  In the case of\n      Microsoft's implementation,\
    \ the user identity encoded as a\n      distinguished name is encrypted with the\
    \ session key provided with\n      the Kerberos ticket.  The Kerberos ticket is\
    \ sent without the\n      Kerberos authdata element that contains authorization\
    \ information,\n      as explained in [25].\n   o  The RSVP message is then intercepted\
    \ by the PEP, which forwards it\n      to the PDP. [25] does not state which protocol\
    \ is used to forward\n      the RSVP message to the PDP.\n   o  The PDP that finally\
    \ receives the message and decrypts the\n      received service ticket.  The ticket\
    \ contains the session key used\n      by the user's host to\n      *  Encrypt\
    \ the principal name inside the policy locator field of\n         the AUTH_DATA\
    \ object and to\n      *  Create the integrity-protected Keyed Message Digest\
    \ field in\n         the INTEGRITY object of the POLICY_DATA element.  The\n \
    \        protection described here is between the user's host and the\n      \
    \   PDP.  The RSVP INTEGRITY object on the other hand is used to\n         protect\
    \ the path between the user's host and the first-hop\n         router, because\
    \ the two message parts terminate at different\n         nodes, and different\
    \ security associations must be used.  The\n         interface between the message-intercepting,\
    \ first-hop router\n         and the PDP must be protected as well.\n      * \
    \ The PDP does not maintain a user database, and [25] describes\n         how\
    \ the PDP may query the Active Directory (a LDAP based\n         directory service)\
    \ for user policy information.\n"
- title: Appendix C.  Literature on RSVP Security
  contents:
  - "Appendix C.  Literature on RSVP Security\n   Few documents address the security\
    \ of RSVP signaling.  This section\n   briefly describes some important documents.\n\
    \   Improvements to RSVP are proposed in [47] to deal with insider\n   attacks.\
    \  Insider attacks are caused by malicious RSVP routers that\n   modify RSVP signaling\
    \ messages in such a way that they cause harm to\n   the nodes participating in\
    \ the signaling message exchange.\n   As a solution, non-mutable RSVP objects\
    \ are digitally signed by the\n   sender.  This digital signature is added to\
    \ the RSVP PATH message.\n   Additionally, the receiver attaches an object to\
    \ the RSVP RESV\n   message containing a \"signed\" history.  This value allows\n\
    \   intermediate RSVP routers (by examining the previously signed value)\n   to\
    \ detect a malicious RSVP node.\n   A few issues are, however, left open in this\
    \ document.  Replay\n   attacks are not covered, and it is therefore assumed that\
    \ timestamp-\n   based replay protection is used.  To identify a malicious node,\
    \ it is\n   necessary that all routers along the path are able to verify the\n\
    \   digital signature.  This may require a global public key\n   infrastructure\
    \ and also client-side certificates.  Furthermore, the\n   bandwidth and computational\
    \ requirements to compute, transmit, and\n   verify digital signatures for each\
    \ signaling message might place a\n   burden on a real-world deployment.\n   Authorization\
    \ is not considered in the document, which might have an\n   influence on the\
    \ implications of signaling message modification.\n   Hence, the chain-of-trust\
    \ relationship (or this step in a different\n   direction) should be considered\
    \ in relationship with authorization.\n   In [48], the above-described idea of\
    \ detecting malicious RSVP nodes\n   is improved by addressing performance aspects.\
    \  The proposed solution\n   is somewhere between hop-by-hop security and the\
    \ approach in [47],\n   insofar as it separates the end-to-end path into individual\
    \ networks.\n   Furthermore, some additional RSVP messages (e.g., feedback messages)\n\
    \   are introduced to implement a mechanism called \"delayed integrity\n   checking.\"\
    \  In [49], the approach presented in [48] is enhanced.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Hannes Tschofenig\n   Siemens\n   Otto-Hahn-Ring 6\n \
    \  Munich, Bavaria  81739\n   Germany\n   EMail: Hannes.Tschofenig@siemens.com\n\
    \   Richard Graveman\n   RFG Security\n   15 Park Avenue\n   Morristown, NJ  07960\n\
    \   USA\n   EMail: rfg@acm.org\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
