- title: __initial_text__
  contents:
  - '                Real-Time Streaming Protocol Version 2.0

    '
- title: Abstract
  contents:
  - "Abstract\n   This memorandum defines the Real-Time Streaming Protocol (RTSP)\n\
    \   version 2.0, which obsoletes RTSP version 1.0 defined in RFC 2326.\n   RTSP\
    \ is an application-layer protocol for the setup and control of\n   the delivery\
    \ of data with real-time properties.  RTSP provides an\n   extensible framework\
    \ to enable controlled, on-demand delivery of\n   real-time data, such as audio\
    \ and video.  Sources of data can include\n   both live data feeds and stored\
    \ clips.  This protocol is intended to\n   control multiple data delivery sessions;\
    \ provide a means for choosing\n   delivery channels such as UDP, multicast UDP,\
    \ and TCP; and provide a\n   means for choosing delivery mechanisms based upon\
    \ RTP (RFC 3550).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7826.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ...................................................10\n\
    \   2. Protocol Overview ..............................................11\n  \
    \    2.1. Presentation Description ..................................12\n    \
    \  2.2. Session Establishment .....................................12\n      2.3.\
    \ Media Delivery Control ....................................14\n      2.4. Session\
    \ Parameter Manipulations ...........................15\n      2.5. Media Delivery\
    \ ............................................16\n           2.5.1. Media Delivery\
    \ Manipulations .......................16\n      2.6. Session Maintenance and\
    \ Termination .......................19\n      2.7. Extending RTSP ............................................20\n\
    \   3. Document Conventions ...........................................21\n  \
    \    3.1. Notational Conventions ....................................21\n    \
    \  3.2. Terminology ...............................................21\n   4. Protocol\
    \ Parameters ............................................25\n      4.1. RTSP Version\
    \ ..............................................25\n      4.2. RTSP IRI and URI\
    \ ..........................................25\n      4.3. Session Identifiers\
    \ .......................................28\n      4.4. Media-Time Formats ........................................28\n\
    \           4.4.1. SMPTE-Relative Timestamps ..........................28\n  \
    \         4.4.2. Normal Play Time ...................................29\n    \
    \       4.4.3. Absolute Time ......................................30\n      4.5.\
    \ Feature Tags ..............................................31\n      4.6. Message\
    \ Body Tags .........................................32\n      4.7. Media Properties\
    \ ..........................................32\n           4.7.1. Random Access\
    \ and Seeking ..........................33\n           4.7.2. Retention ..........................................34\n\
    \           4.7.3. Content Modifications ..............................34\n  \
    \         4.7.4. Supported Scale Factors ............................34\n    \
    \       4.7.5. Mapping to the Attributes ..........................35\n   5. RTSP\
    \ Message ...................................................35\n      5.1. Message\
    \ Types .............................................36\n      5.2. Message Headers\
    \ ...........................................36\n      5.3. Message Body ..............................................37\n\
    \      5.4. Message Length ............................................37\n  \
    \ 6. General-Header Fields ..........................................37\n   7.\
    \ Request ........................................................39\n      7.1.\
    \ Request Line ..............................................40\n      7.2. Request-Header\
    \ Fields .....................................42\n   8. Response .......................................................43\n\
    \      8.1. Status-Line ...............................................43\n  \
    \         8.1.1. Status Code and Reason Phrase ......................43\n    \
    \  8.2. Response Headers ..........................................47\n   9. Message\
    \ Body ...................................................47\n      9.1. Message\
    \ Body Header Fields ................................48\n      9.2. Message Body\
    \ ..............................................49\n      9.3. Message Body Format\
    \ Negotiation ...........................49\n   10. Connections ...................................................50\n\
    \      10.1. Reliability and Acknowledgements .........................50\n  \
    \    10.2. Using Connections ........................................51\n    \
    \  10.3. Closing Connections ......................................54\n      10.4.\
    \ Timing Out Connections and RTSP Messages .................56\n      10.5. Showing\
    \ Liveness .........................................57\n      10.6. Use of IPv6\
    \ ..............................................58\n      10.7. Overload Control\
    \ .........................................58\n   11. Capability Handling ...........................................60\n\
    \      11.1. Feature Tag: play.basic ..................................62\n  \
    \ 12. Pipelining Support ............................................62\n   13.\
    \ Method Definitions ............................................63\n      13.1.\
    \ OPTIONS ..................................................65\n      13.2. DESCRIBE\
    \ .................................................66\n      13.3. SETUP ....................................................68\n\
    \           13.3.1. Changing Transport Parameters .....................71\n  \
    \    13.4. PLAY .....................................................72\n    \
    \       13.4.1. General Usage .....................................72\n      \
    \     13.4.2. Aggregated Sessions ...............................77\n        \
    \   13.4.3. Updating Current PLAY Requests ....................78\n          \
    \ 13.4.4. Playing On-Demand Media ...........................81\n           13.4.5.\
    \ Playing Dynamic On-Demand Media ...................81\n           13.4.6. Playing\
    \ Live Media ................................81\n           13.4.7. Playing Live\
    \ with Recording .......................82\n           13.4.8. Playing Live with\
    \ Time-Shift ......................83\n      13.5. PLAY_NOTIFY ..............................................83\n\
    \           13.5.1. End-of-Stream .....................................84\n  \
    \         13.5.2. Media-Properties-Update ...........................86\n    \
    \       13.5.3. Scale-Change ......................................87\n      13.6.\
    \ PAUSE ....................................................89\n      13.7. TEARDOWN\
    \ .................................................92\n           13.7.1. Client\
    \ to Server ..................................92\n           13.7.2. Server to\
    \ Client ..................................93\n      13.8. GET_PARAMETER ............................................94\n\
    \      13.9. SET_PARAMETER ............................................96\n  \
    \    13.10. REDIRECT ................................................98\n   14.\
    \ Embedded (Interleaved) Binary Data ...........................101\n   15. Proxies\
    \ ......................................................103\n      15.1. Proxies\
    \ and Protocol Extensions .........................104\n      15.2. Multiplexing\
    \ and Demultiplexing of Messages .............105\n   16. Caching ......................................................106\n\
    \      16.1. Validation Model ........................................107\n  \
    \         16.1.1. Last-Modified Dates ..............................108\n    \
    \       16.1.2. Message Body Tag Cache Validators ................108\n      \
    \     16.1.3. Weak and Strong Validators .......................108\n        \
    \   16.1.4. Rules for When to Use Message Body Tags\n                   and Last-Modified\
    \ Dates ..........................110\n           16.1.5. Non-validating Conditionals\
    \ ......................112\n      16.2. Invalidation after Updates or Deletions\
    \ .................112\n   17. Status Code Definitions ......................................113\n\
    \      17.1. Informational 1xx .......................................113\n  \
    \         17.1.1. 100 Continue .....................................113\n    \
    \  17.2. Success 2xx .............................................113\n      \
    \     17.2.1. 200 OK ...........................................113\n      17.3.\
    \ Redirection 3xx .........................................113\n           17.3.1.\
    \ 300 ..............................................114\n           17.3.2. 301\
    \ Moved Permanently ............................114\n           17.3.3. 302 Found\
    \ ........................................114\n           17.3.4. 303 See Other\
    \ ....................................115\n           17.3.5. 304 Not Modified\
    \ .................................115\n           17.3.6. 305 Use Proxy ....................................115\n\
    \      17.4. Client Error 4xx ........................................116\n  \
    \         17.4.1. 400 Bad Request ..................................116\n    \
    \       17.4.2. 401 Unauthorized .................................116\n      \
    \     17.4.3. 402 Payment Required .............................116\n        \
    \   17.4.4. 403 Forbidden ....................................116\n          \
    \ 17.4.5. 404 Not Found ....................................116\n           17.4.6.\
    \ 405 Method Not Allowed ...........................117\n           17.4.7. 406\
    \ Not Acceptable ...............................117\n           17.4.8. 407 Proxy\
    \ Authentication Required ................117\n           17.4.9. 408 Request\
    \ Timeout ..............................117\n           17.4.10. 410 Gone ........................................118\n\
    \           17.4.11. 412 Precondition Failed .........................118\n  \
    \         17.4.12. 413 Request Message Body Too Large ..............118\n    \
    \       17.4.13. 414 Request-URI Too Long ........................118\n      \
    \     17.4.14. 415 Unsupported Media Type ......................119\n        \
    \   17.4.15. 451 Parameter Not Understood ....................119\n          \
    \ 17.4.16. 452 Illegal Conference Identifier ...............119\n           17.4.17.\
    \ 453 Not Enough Bandwidth ........................119\n           17.4.18. 454\
    \ Session Not Found ...........................119\n           17.4.19. 455 Method\
    \ Not Valid in This State ..............119\n           17.4.20. 456 Header Field\
    \ Not Valid for Resource .........119\n           17.4.21. 457 Invalid Range ...............................120\n\
    \           17.4.22. 458 Parameter Is Read-Only ......................120\n  \
    \         17.4.23. 459 Aggregate Operation Not Allowed .............120\n    \
    \       17.4.24. 460 Only Aggregate Operation Allowed ............120\n      \
    \     17.4.25. 461 Unsupported Transport .......................120\n        \
    \   17.4.26. 462 Destination Unreachable .....................120\n          \
    \ 17.4.27. 463 Destination Prohibited ......................120\n           17.4.28.\
    \ 464 Data Transport Not Ready Yet ................121\n           17.4.29. 465\
    \ Notification Reason Unknown .................121\n           17.4.30. 466 Key\
    \ Management Error ........................121\n           17.4.31. 470 Connection\
    \ Authorization Required ...........121\n           17.4.32. 471 Connection Credentials\
    \ Not Accepted .........121\n           17.4.33. 472 Failure to Establish Secure\
    \ Connection ......121\n      17.5. Server Error 5xx ........................................122\n\
    \           17.5.1. 500 Internal Server Error ........................122\n  \
    \         17.5.2. 501 Not Implemented ..............................122\n    \
    \       17.5.3. 502 Bad Gateway ..................................122\n      \
    \     17.5.4. 503 Service Unavailable ..........................122\n        \
    \   17.5.5. 504 Gateway Timeout ..............................123\n          \
    \ 17.5.6. 505 RTSP Version Not Supported ...................123\n           17.5.7.\
    \ 551 Option Not Supported .........................123\n           17.5.8. 553\
    \ Proxy Unavailable ............................123\n   18. Header Field Definitions\
    \ .....................................124\n      18.1. Accept ..................................................134\n\
    \      18.2. Accept-Credentials ......................................135\n  \
    \    18.3. Accept-Encoding .........................................135\n    \
    \  18.4. Accept-Language .........................................136\n      18.5.\
    \ Accept-Ranges ...........................................137\n      18.6. Allow\
    \ ...................................................138\n      18.7. Authentication-Info\
    \ .....................................138\n      18.8. Authorization ...........................................138\n\
    \      18.9. Bandwidth ...............................................139\n  \
    \    18.10. Blocksize ..............................................140\n    \
    \  18.11. Cache-Control ..........................................140\n      18.12.\
    \ Connection .............................................143\n      18.13. Connection-Credentials\
    \ .................................143\n      18.14. Content-Base ...........................................144\n\
    \      18.15. Content-Encoding .......................................145\n  \
    \    18.16. Content-Language .......................................145\n    \
    \  18.17. Content-Length .........................................146\n      18.18.\
    \ Content-Location .......................................146\n      18.19. Content-Type\
    \ ...........................................148\n      18.20. CSeq ...................................................148\n\
    \      18.21. Date ...................................................150\n  \
    \    18.22. Expires ................................................151\n    \
    \  18.23. From ...................................................151\n      18.24.\
    \ If-Match ...............................................152\n      18.25. If-Modified-Since\
    \ ......................................152\n      18.26. If-None-Match ..........................................153\n\
    \      18.27. Last-Modified ..........................................154\n  \
    \    18.28. Location ...............................................154\n    \
    \  18.29. Media-Properties .......................................154\n      18.30.\
    \ Media-Range ............................................156\n      18.31. MTag\
    \ ...................................................157\n      18.32. Notify-Reason\
    \ ..........................................158\n      18.33. Pipelined-Requests\
    \ .....................................158\n      18.34. Proxy-Authenticate .....................................159\n\
    \      18.35. Proxy-Authentication-Info ..............................159\n  \
    \    18.36. Proxy-Authorization ....................................159\n    \
    \  18.37. Proxy-Require ..........................................160\n      18.38.\
    \ Proxy-Supported ........................................160\n      18.39. Public\
    \ .................................................161\n      18.40. Range ..................................................162\n\
    \      18.41. Referrer ...............................................164\n  \
    \    18.42. Request-Status .........................................164\n    \
    \  18.43. Require ................................................165\n      18.44.\
    \ Retry-After ............................................166\n      18.45. RTP-Info\
    \ ...............................................167\n      18.46. Scale ..................................................169\n\
    \      18.47. Seek-Style .............................................170\n  \
    \    18.48. Server .................................................171\n    \
    \  18.49. Session ................................................172\n      18.50.\
    \ Speed ..................................................173\n      18.51. Supported\
    \ ..............................................174\n      18.52. Terminate-Reason\
    \ .......................................175\n      18.53. Timestamp ..............................................175\n\
    \      18.54. Transport ..............................................176\n  \
    \    18.55. Unsupported ............................................183\n    \
    \  18.56. User-Agent .............................................184\n      18.57.\
    \ Via ....................................................184\n      18.58. WWW-Authenticate\
    \ .......................................185\n   19. Security Framework ...........................................185\n\
    \      19.1. RTSP and HTTP Authentication ............................185\n  \
    \         19.1.1. Digest Authentication ............................186\n    \
    \  19.2. RTSP over TLS ...........................................187\n      19.3.\
    \ Security and Proxies ....................................188\n           19.3.1.\
    \ Accept-Credentials ...............................189\n           19.3.2. User-Approved\
    \ TLS Procedure ......................190\n   20. Syntax .......................................................192\n\
    \      20.1. Base Syntax .............................................193\n  \
    \    20.2. RTSP Protocol Definition ................................195\n    \
    \       20.2.1. Generic Protocol Elements ........................195\n      \
    \     20.2.2. Message Syntax ...................................198\n        \
    \   20.2.3. Header Syntax ....................................201\n      20.3.\
    \ SDP Extension Syntax ....................................209\n   21. Security\
    \ Considerations ......................................209\n      21.1. Signaling\
    \ Protocol Threats ..............................210\n      21.2. Media Stream\
    \ Delivery Threats ...........................213\n           21.2.1. Remote DoS\
    \ Attack ................................215\n           21.2.2. RTP Security\
    \ Analysis ............................216\n   22. IANA Considerations ..........................................217\n\
    \      22.1. Feature Tags ............................................218\n  \
    \         22.1.1. Description ......................................218\n    \
    \       22.1.2. Registering New Feature Tags with IANA ...........218\n      \
    \     22.1.3. Registered Entries ...............................219\n      22.2.\
    \ RTSP Methods ............................................219\n           22.2.1.\
    \ Description ......................................219\n           22.2.2. Registering\
    \ New Methods with IANA ................219\n           22.2.3. Registered Entries\
    \ ...............................220\n      22.3. RTSP Status Codes .......................................220\n\
    \           22.3.1. Description ......................................220\n  \
    \         22.3.2. Registering New Status Codes with IANA ...........220\n    \
    \       22.3.3. Registered Entries ...............................221\n      22.4.\
    \ RTSP Headers ............................................221\n           22.4.1.\
    \ Description ......................................221\n           22.4.2. Registering\
    \ New Headers with IANA ................221\n           22.4.3. Registered Entries\
    \ ...............................222\n      22.5. Accept-Credentials ......................................223\n\
    \           22.5.1. Accept-Credentials Policies ......................223\n  \
    \         22.5.2. Accept-Credentials Hash Algorithms ...............224\n    \
    \  22.6. Cache-Control Cache Directive Extensions ................224\n      22.7.\
    \ Media Properties ........................................225\n           22.7.1.\
    \ Description ......................................225\n           22.7.2. Registration\
    \ Rules ...............................226\n           22.7.3. Registered Values\
    \ ................................226\n      22.8. Notify-Reason Values ....................................226\n\
    \           22.8.1. Description ......................................226\n  \
    \         22.8.2. Registration Rules ...............................226\n    \
    \       22.8.3. Registered Values ................................227\n      22.9.\
    \ Range Header Formats ....................................227\n           22.9.1.\
    \ Description ......................................227\n           22.9.2. Registration\
    \ Rules ...............................227\n           22.9.3. Registered Values\
    \ ................................228\n      22.10. Terminate-Reason Header ................................228\n\
    \           22.10.1. Redirect Reasons ................................228\n  \
    \         22.10.2. Terminate-Reason Header Parameters ..............229\n    \
    \  22.11. RTP-Info Header Parameters .............................229\n      \
    \     22.11.1. Description .....................................229\n        \
    \   22.11.2. Registration Rules ..............................229\n          \
    \ 22.11.3. Registered Values ...............................230\n      22.12.\
    \ Seek-Style Policies ....................................230\n           22.12.1.\
    \ Description .....................................230\n           22.12.2. Registration\
    \ Rules ..............................230\n           22.12.3. Registered Values\
    \ ...............................230\n      22.13. Transport Header Registries\
    \ ............................231\n           22.13.1. Transport Protocol Identifier\
    \ ...................231\n           22.13.2. Transport Modes .................................233\n\
    \           22.13.3. Transport Parameters ............................233\n  \
    \    22.14. URI Schemes ............................................234\n    \
    \       22.14.1. The \"rtsp\" URI Scheme ...........................234\n    \
    \       22.14.2. The \"rtsps\" URI Scheme ..........................235\n    \
    \       22.14.3. The \"rtspu\" URI Scheme ..........................237\n    \
    \  22.15. SDP Attributes .........................................238\n      22.16.\
    \ Media Type Registration for text/parameters ............238\n   23. References\
    \ ...................................................240\n      23.1. Normative\
    \ References ....................................240\n      23.2. Informative\
    \ References ..................................245\n   Appendix A. Examples .............................................248\n\
    \      A.1. Media on Demand (Unicast) ................................248\n  \
    \    A.2. Media on Demand Using Pipelining .........................251\n    \
    \  A.3. Secured Media Session for On-Demand Content ..............254\n      A.4.\
    \ Media on Demand (Unicast) ................................257\n      A.5. Single-Stream\
    \ Container Files ............................260\n      A.6. Live Media Presentation\
    \ Using Multicast ..................263\n      A.7. Capability Negotiation ...................................264\n\
    \   Appendix B. RTSP Protocol State Machine ..........................265\n  \
    \    B.1. States ...................................................266\n    \
    \  B.2. State Variables ..........................................266\n      B.3.\
    \ Abbreviations ............................................266\n      B.4. State\
    \ Tables .............................................267\n   Appendix C. Media-Transport\
    \ Alternatives .........................272\n      C.1. RTP ......................................................272\n\
    \        C.1.1. AVP ..................................................272\n  \
    \      C.1.2. AVP/UDP ..............................................273\n    \
    \    C.1.3. AVPF/UDP .............................................274\n      \
    \  C.1.4. SAVP/UDP .............................................275\n        C.1.5.\
    \ SAVPF/UDP ............................................277\n        C.1.6. RTCP\
    \ Usage with RTSP .................................278\n      C.2. RTP over TCP\
    \ .............................................279\n        C.2.1. Interleaved\
    \ RTP over TCP .............................280\n        C.2.2. RTP over Independent\
    \ TCP .............................280\n      C.3. Handling Media-Clock Time Jumps\
    \ in the RTP Media Layer ...284\n      C.4. Handling RTP Timestamps after PAUSE\
    \ ......................287\n      C.5. RTSP/RTP Integration  ....................................290\n\
    \      C.6. Scaling with RTP .........................................290\n  \
    \    C.7. Maintaining NPT Synchronization with RTP Timestamps ......290\n    \
    \  C.8. Continuous Audio .........................................290\n      C.9.\
    \ Multiple Sources in an RTP Session .......................290\n      C.10. Usage\
    \ of SSRCs and the RTCP BYE Message during an RTSP\n            Session .................................................290\n\
    \      C.11. Future Additions ........................................291\n  \
    \ Appendix D. Use of SDP for RTSP Session Descriptions .............292\n    \
    \  D.1. Definitions  .............................................292\n      \
    \  D.1.1. Control URI ..........................................292\n        D.1.2.\
    \ Media Streams ........................................294\n        D.1.3. Payload\
    \ Type(s) ......................................294\n        D.1.4. Format-Specific\
    \ Parameters ...........................294\n        D.1.5. Directionality of\
    \ Media Stream .......................295\n        D.1.6. Range of Presentation\
    \ ................................295\n        D.1.7. Time of Availability .................................296\n\
    \        D.1.8. Connection Information ...............................297\n  \
    \      D.1.9. Message Body Tag .....................................297\n    \
    \  D.2. Aggregate Control Not Available ..........................298\n      D.3.\
    \ Aggregate Control Available ..............................298\n      D.4. Grouping\
    \ of Media Lines in SDP ...........................299\n      D.5. RTSP External\
    \ SDP Delivery ...............................300\n   Appendix E. RTSP Use Cases\
    \ .......................................300\n      E.1. On-Demand Playback of\
    \ Stored Content .....................300\n      E.2. Unicast Distribution of\
    \ Live Content .....................302\n      E.3. On-Demand Playback Using Multicast\
    \ .......................303\n      E.4. Inviting an RTSP Server into a Conference\
    \ ................303\n      E.5. Live Content Using Multicast .............................304\n\
    \   Appendix F. Text Format for Parameters ...........................305\n  \
    \ Appendix G. Requirements for Unreliable Transport of RTSP ........305\n   Appendix\
    \ H. Backwards-Compatibility Considerations ...............306\n      H.1. Play\
    \ Request in Play State ...............................307\n      H.2. Using Persistent\
    \ Connections .............................307\n   Appendix I. Changes ..............................................307\n\
    \      I.1. Brief Overview ...........................................308\n  \
    \    I.2. Detailed List of Changes .................................309\n   Acknowledgements\
    \ .................................................316\n   Contributors  ....................................................317\n\
    \   Authors' Addresses ...............................................318\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This memo defines version 2.0 of the Real-Time Streaming\
    \ Protocol\n   (RTSP 2.0).  RTSP 2.0 is an application-layer protocol for the\
    \ setup\n   and control over the delivery of data with real-time properties,\n\
    \   typically streaming media.  Streaming media is, for instance, video\n   on\
    \ demand or audio live streaming.  Put simply, RTSP acts as a\n   \"network remote\
    \ control\" for multimedia servers.\n   The protocol operates between RTSP 2.0\
    \ clients and servers, but it\n   also supports the use of proxies placed between\
    \ clients and servers.\n   Clients can request information about streaming media\
    \ from servers by\n   asking for a description of the media or use media description\n\
    \   provided externally.  The media delivery protocol is used to\n   establish\
    \ the media streams described by the media description.\n   Clients can then request\
    \ to play out the media, pause it, or stop it\n   completely.  The requested media\
    \ can consist of multiple audio and\n   video streams that are delivered as time-synchronized\
    \ streams from\n   servers to clients.\n   RTSP 2.0 is a replacement of RTSP 1.0\
    \ [RFC2326] and this document\n   obsoletes that specification.  This protocol\
    \ is based on RTSP 1.0 but\n   is not backwards compatible other than in the basic\
    \ version\n   negotiation mechanism.  The changes between the two documents are\n\
    \   listed in Appendix I.  There are many reasons why RTSP 2.0 can't be\n   backwards\
    \ compatible with RTSP 1.0; some of the main ones are as\n   follows:\n   o  Most\
    \ headers that needed to be extensible did not define the\n      allowed syntax,\
    \ preventing safe deployment of extensions;\n   o  the changed behavior of the\
    \ PLAY method when received in Play\n      state;\n   o  the changed behavior\
    \ of the extensibility model and its mechanism;\n      and\n   o  the change of\
    \ syntax for some headers.\n   There are so many small updates that changing versions\
    \ became\n   necessary to enable clarification and consistent behavior.  Anyone\n\
    \   implementing RTSP for a new use case in which they have not installed\n  \
    \ RTSP 1.0 should only implement RTSP 2.0 to avoid having to deal with\n   RTSP\
    \ 1.0 inconsistencies.\n   This document is structured as follows.  It begins\
    \ with an overview\n   of the protocol operations and its functions in an informal\
    \ way.\n   Then, a set of definitions of terms used and document conventions is\n\
    \   introduced.  These are followed by the actual RTSP 2.0 core protocol\n   specification.\
    \  The appendices describe and define some\n   functionalities that are not part\
    \ of the core RTSP specification, but\n   which are still important to enable\
    \ some usages.  Among them, the RTP\n   usage is defined in Appendix C, the Session\
    \ Description Protocol\n   (SDP) usage with RTSP is defined in Appendix D, and\
    \ the \"text/\n   parameters\" file format Appendix F, are three normative specification\n\
    \   appendices.  Other appendices include a number of informational parts\n  \
    \ discussing the changes, use cases, different considerations or\n   motivations.\n"
- title: 2.  Protocol Overview
  contents:
  - "2.  Protocol Overview\n   This section provides an informative overview of the\
    \ different\n   mechanisms in the RTSP 2.0 protocol to give the reader a high-level\n\
    \   understanding before getting into all the specific details.  In case\n   of\
    \ conflict with this description and the later sections, the later\n   sections\
    \ take precedence.  For more information about use cases\n   considered for RTSP,\
    \ see Appendix E.\n   RTSP 2.0 is a bidirectional request and response protocol\
    \ that first\n   establishes a context including content resources (the media)\
    \ and\n   then controls the delivery of these content resources from the\n   provider\
    \ to the consumer.  RTSP has three fundamental parts: Session\n   Establishment,\
    \ Media Delivery Control, and an extensibility model\n   described below.  The\
    \ protocol is based on some assumptions about\n   existing functionality to provide\
    \ a complete solution for client-\n   controlled real-time media delivery.\n \
    \  RTSP uses text-based messages, requests and responses, that may\n   contain\
    \ a binary message body.  An RTSP request starts with a method\n   line that identifies\
    \ the method, the protocol, and version and the\n   resource on which to act.\
    \  The resource is identified by a URI and\n   the hostname part of the URI is\
    \ used by RTSP client to resolve the\n   IPv4 or IPv6 address of the RTSP server.\
    \  Following the method line\n   are a number of RTSP headers.  These lines are\
    \ ended by two\n   consecutive carriage return line feed (CRLF) character pairs.\
    \  The\n   message body, if present, follows the two CRLF character pairs, and\n\
    \   the body's length is described by a message header.  RTSP responses\n   are\
    \ similar, but they start with a response line with the protocol\n   and version\
    \ followed by a status code and a reason phrase.  RTSP\n   messages are sent over\
    \ a reliable transport protocol between the\n   client and server.  RTSP 2.0 requires\
    \ clients and servers to\n   implement TCP and TLS over TCP as mandatory transports\
    \ for RTSP\n   messages.\n"
- title: 2.1.  Presentation Description
  contents:
  - "2.1.  Presentation Description\n   RTSP exists to provide access to multimedia\
    \ presentations and content\n   but tries to be agnostic about the media type\
    \ or the actual media\n   delivery protocol that is used.  To enable a client\
    \ to implement a\n   complete system, an RTSP-external mechanism for describing\
    \ the\n   presentation and the delivery protocol(s) is used.  RTSP assumes that\n\
    \   this description is either delivered completely out of band or as a\n   data\
    \ object in the response to a client's request using the DESCRIBE\n   method (Section\
    \ 13.2).\n   Parameters that commonly have to be included in the presentation\n\
    \   description are the following:\n   o  The number of media streams;\n   o \
    \ the resource identifier for each media stream/resource that is to\n      be\
    \ controlled by RTSP;\n   o  the protocol that will be used to deliver each media\
    \ stream;\n   o  the transport protocol parameters that are not negotiated or\
    \ vary\n      with each client;\n   o  the media-encoding information enabling\
    \ a client to correctly\n      decode the media upon reception; and\n   o  an\
    \ aggregate control resource identifier.\n   RTSP uses its own URI schemes (\"\
    rtsp\" and \"rtsps\") to reference media\n   resources and aggregates under common\
    \ control (see Section 4.2).\n   This specification describes in Appendix D how\
    \ one uses SDP [RFC4566]\n   for describing the presentation.\n"
- title: 2.2.  Session Establishment
  contents:
  - "2.2.  Session Establishment\n   The RTSP client can request the establishment\
    \ of an RTSP session\n   after having used the presentation description to determine\
    \ which\n   media streams are available, which media delivery protocol is used,\n\
    \   and the resource identifiers of the media streams.  The RTSP session\n   is\
    \ a common context between the client and the server that consists\n   of one\
    \ or more media resources that are to be under common media\n   delivery control.\n\
    \   The client creates an RTSP session by sending a request using the\n   SETUP\
    \ method (Section 13.3) to the server.  In the Transport header\n   (Section 18.54)\
    \ of the SETUP request, the client also includes all\n   the transport parameters\
    \ necessary to enable the media delivery\n   protocol to function.  This includes\
    \ parameters that are\n   preestablished by the presentation description but necessary\
    \ for any\n   middlebox to correctly handle the media delivery protocols.  The\n\
    \   Transport header in a request may contain multiple alternatives for\n   media\
    \ delivery in a prioritized list, which the server can select\n   from.  These\
    \ alternatives are typically based on information in the\n   presentation description.\n\
    \   When receiving a SETUP request, the server determines if the media\n   resource\
    \ is available and if one or more of the of the transport\n   parameter specifications\
    \ are acceptable.  If that is successful, an\n   RTSP session context is created\
    \ and the relevant parameters and state\n   is stored.  An identifier is created\
    \ for the RTSP session and\n   included in the response in the Session header\
    \ (Section 18.49).  The\n   SETUP response includes a Transport header that specifies\
    \ which of\n   the alternatives has been selected and relevant parameters.\n \
    \  A SETUP request that references an existing RTSP session but\n   identifies\
    \ a new media resource is a request to add that media\n   resource under common\
    \ control with the already-present media\n   resources in an aggregated session.\
    \  A client can expect this to work\n   for all media resources under RTSP control\
    \ within a multimedia\n   content container.  However, a server will likely refuse\
    \ to aggregate\n   resources from different content containers.  Even if an RTSP\
    \ session\n   contains only a single media stream, the RTSP session can be\n \
    \  referenced by the aggregate control URI.\n   To avoid an extra round trip in\
    \ the session establishment of\n   aggregated RTSP sessions, RTSP 2.0 supports\
    \ pipelined requests; i.e.,\n   the client can send multiple requests back-to-back\
    \ without waiting\n   first for the completion of any of them.  The client uses\
    \ a client-\n   selected identifier in the Pipelined-Requests header (Section\
    \ 18.33)\n   to instruct the server to bind multiple requests together as if they\n\
    \   included the session identifier.\n   The SETUP response also provides additional\
    \ information about the\n   established sessions in a couple of different headers.\
    \  The Media-\n   Properties header (Section 18.29) includes a number of properties\n\
    \   that apply for the aggregate that is valuable when doing media\n   delivery\
    \ control and configuring user interface.  The Accept-Ranges\n   header (Section\
    \ 18.5) informs the client about range formats that the\n   server supports for\
    \ these media resources.  The Media-Range header\n   (Section 18.30) informs the\
    \ client about the time range of the media\n   currently available.\n"
- title: 2.3.  Media Delivery Control
  contents:
  - "2.3.  Media Delivery Control\n   After having established an RTSP session, the\
    \ client can start\n   controlling the media delivery.  The basic operations are\
    \ \"begin\n   playback\", using the PLAY method (Section 13.4) and \"suspend (pause)\n\
    \   playback\" by using the PAUSE method (Section 13.6).  PLAY also allows\n \
    \  for choosing the starting media position from which the server should\n   deliver\
    \ the media.  The positioning is done by using the Range header\n   (Section 18.40)\
    \ that supports several different time formats: Normal\n   Play Time (NPT) (Section\
    \ 4.4.2), Society of Motion Picture and\n   Television Engineers (SMPTE) Timestamps\
    \ (Section 4.4.1), and absolute\n   time (Section 4.4.3).  The Range header also\
    \ allows the client to\n   specify a position where delivery should end, thus\
    \ allowing a\n   specific interval to be delivered.\n   The support for positioning/searching\
    \ within media content depends on\n   the content's media properties.  Content\
    \ exists in a number of\n   different types, such as on-demand, live, and live\
    \ with simultaneous\n   recording.  Even within these categories, there are differences\
    \ in\n   how the content is generated and distributed, which affect how it can\n\
    \   be accessed for playback.  The properties applicable for the RTSP\n   session\
    \ are provided by the server in the SETUP response using the\n   Media-Properties\
    \ header (Section 18.29).  These are expressed using\n   one or several independent\
    \ attributes.  A first attribute is Random-\n   Access, which indicates whether\
    \ positioning is possible, and with\n   what granularity.  Another aspect is whether\
    \ the content will change\n   during the lifetime of the session.  While on-demand\
    \ content will be\n   provided in full from the beginning, a live stream being\
    \ recorded\n   results in the length of the accessible content growing as the\n\
    \   session goes on.  There also exists content that is dynamically built\n  \
    \ by a protocol other than RTSP and, thus, also changes in steps during\n   the\
    \ session, but maybe not continuously.  Furthermore, when content\n   is recorded,\
    \ there are cases where the complete content is not\n   maintained, but, for example,\
    \ only the last hour.  All of these\n   properties result in the need for mechanisms\
    \ that will be discussed\n   below.\n   When the client accesses on-demand content\
    \ that allows random access,\n   the client can issue the PLAY request for any\
    \ point in the content\n   between the start and the end.  The server will deliver\
    \ media from\n   the closest random access point prior to the requested point\
    \ and\n   indicate that in its PLAY response.  If the client issues a PAUSE,\n\
    \   the delivery will be halted and the point at which the server stopped\n  \
    \ will be reported back in the response.  The client can later resume\n   by sending\
    \ a PLAY request without a Range header.  When the server is\n   about to complete\
    \ the PLAY request by delivering the end of the\n   content or the requested range,\
    \ the server will send a PLAY_NOTIFY\n   request (Section 13.5) indicating this.\n\
    \   When playing live content with no extra functions, such as recording,\n  \
    \ the client will receive the live media from the server after having\n   sent\
    \ a PLAY request.  Seeking in such content is not possible as the\n   server does\
    \ not store it, but only forwards it from the source of the\n   session.  Thus,\
    \ delivery continues until the client sends a PAUSE\n   request, tears down the\
    \ session, or the content ends.\n   For live sessions that are being recorded,\
    \ the client will need to\n   keep track of how the recording progresses.  Upon\
    \ session\n   establishment, the client will learn the current duration of the\n\
    \   recording from the Media-Range header.  Because the recording is\n   ongoing,\
    \ the content grows in direct relation to the time passed.\n   Therefore, each\
    \ server's response to a PLAY request will contain the\n   current Media-Range\
    \ header.  The server should also regularly send\n   (approximately every 5 minutes)\
    \ the current media range in a\n   PLAY_NOTIFY request (Section 13.5.2).  If the\
    \ live transmission ends,\n   the server must send a PLAY_NOTIFY request with\
    \ the updated Media-\n   Properties indicating that the content stopped being\
    \ a recorded live\n   session and instead became on-demand content; the request\
    \ also\n   contains the final media range.  While the live delivery continues,\n\
    \   the client can request to play the current live point by using the\n   NPT\
    \ timescale symbol \"now\", or it can request a specific point in the\n   available\
    \ content by an explicit range request for that point.  If\n   the requested point\
    \ is outside of the available interval, the server\n   will adjust the position\
    \ to the closest available point, i.e., either\n   at the beginning or the end.\n\
    \   A special case of recording is that where the recording is not\n   retained\
    \ longer than a specific time period; thus, as the live\n   delivery continues,\
    \ the client can access any media within a moving\n   window that covers, for\
    \ example, \"now\" to \"now\" minus 1 hour.  A\n   client that pauses on a specific\
    \ point within the content may not be\n   able to retrieve the content anymore.\
    \  If the client waits too long\n   before resuming the pause point, the content\
    \ may no longer be\n   available.  In this case, the pause point will be adjusted\
    \ to the\n   closest point in the available media.\n"
- title: 2.4.  Session Parameter Manipulations
  contents:
  - "2.4.  Session Parameter Manipulations\n   A session may have additional state\
    \ or functionality that affects how\n   the server or client treats the session\
    \ or content, how it functions,\n   or feedback on how well the session works.\
    \  Such extensions are not\n   defined in this specification, but they may be\
    \ covered in various\n   extensions.  RTSP has two methods for retrieving and\
    \ setting\n   parameter values on either the client or the server: GET_PARAMETER\n\
    \   (Section 13.8) and SET_PARAMETER (Section 13.9).  These methods carry\n  \
    \ the parameters in a message body of the appropriate format.  One can\n   also\
    \ use headers to query state with the GET_PARAMETER method.  As an\n   example,\
    \ clients needing to know the current media range for a time-\n   progressing\
    \ session can use the GET_PARAMETER method and include the\n   media range.  Furthermore,\
    \ synchronization information can be\n   requested by using a combination of RTP-Info\
    \ (Section 18.45) and\n   Range (Section 18.40).\n   RTSP 2.0 does not have a\
    \ strong mechanism for negotiating the headers\n   or parameters and their formats.\
    \  However, responses will indicate\n   request-headers or parameters that are\
    \ not supported.  A priori\n   determination of what features are available needs\
    \ to be done through\n   out-of-band mechanisms, like the session description,\
    \ or through the\n   usage of feature tags (Section 4.5).\n"
- title: 2.5.  Media Delivery
  contents:
  - "2.5.  Media Delivery\n   This document specifies how media is delivered with\
    \ RTP [RFC3550]\n   over UDP [RFC768], TCP [RFC793], or the RTSP connection. \
    \ Additional\n   protocols may be specified in the future as needed.\n   The usage\
    \ of RTP as a media delivery protocol requires some\n   additional information\
    \ to function well.  The PLAY response contains\n   information to enable reliable\
    \ and timely delivery of how a client\n   should synchronize different sources\
    \ in the different RTP sessions.\n   It also provides a mapping between RTP timestamps\
    \ and the content-\n   time scale.  When the server wants to notify the client\
    \ about the\n   completion of the media delivery, it sends a PLAY_NOTIFY request\
    \ to\n   the client.  The PLAY_NOTIFY request includes information about the\n\
    \   stream end, including the last RTP sequence number for each stream,\n   thus\
    \ enabling the client to empty the buffer smoothly.\n"
- title: 2.5.1.  Media Delivery Manipulations
  contents:
  - "2.5.1.  Media Delivery Manipulations\n   The basic playback functionality of\
    \ RTSP enables delivery of a range\n   of requested content to the client at the\
    \ pace intended by the\n   content's creator.  However, RTSP can also manipulate\
    \ the delivery to\n   the client in two ways.\n   Scale:  The ratio of media-content\
    \ time delivered per unit of\n      playback time.\n   Speed:  The ratio of playback\
    \ time delivered per unit of wallclock\n      time.\n   Both affect the media\
    \ delivery per time unit.  However, they\n   manipulate two independent timescales\
    \ and the effects are possible to\n   combine.\n   Scale (Section 18.46) is used\
    \ for fast-forward or slow-motion control\n   as it changes the amount of content\
    \ timescale that should be played\n   back per time unit.  Scale > 1.0, means\
    \ fast forward, e.g., scale =\n   2.0 results in that 2 seconds of content being\
    \ played back every\n   second of playback.  Scale = 1.0 is the default value\
    \ that is used if\n   no scale is specified, i.e., playback at the content's original\
    \ rate.\n   Scale values between 0 and 1.0 provide for slow motion.  Scale can\
    \ be\n   negative to allow for reverse playback in either regular pace\n   (scale\
    \ = -1.0), fast backwards (scale < -1.0), or slow-motion\n   backwards (-1.0 <\
    \ scale < 0).  Scale = 0 would be equal to pause and\n   is not allowed.\n   In\
    \ most cases, the realization of scale means server-side\n   manipulation of the\
    \ media to ensure that the client can actually play\n   it back.  The nature of\
    \ these media manipulations and when they are\n   needed is highly media-type\
    \ dependent.  Let's consider two common\n   media types, audio and video.\n  \
    \ It is very difficult to modify the playback rate of audio.\n   Typically, no\
    \ more than a factor of two is possible while maintaining\n   intelligibility\
    \ by changing the pitch and rate of speech.  Music goes\n   out of tune if one\
    \ tries to manipulate the playback rate by\n   resampling it.  This is a well-known\
    \ problem, and audio is commonly\n   muted or played back in short segments with\
    \ skips to keep up with the\n   current playback point.\n   For video, it is possible\
    \ to manipulate the frame rate, although the\n   rendering capabilities are often\
    \ limited to certain frame rates.\n   Also, the allowed bitrates in decoding,\
    \ the structure used in the\n   encoding, and the dependency between frames and\
    \ other capabilities of\n   the rendering device limits the possible manipulations.\
    \  Therefore,\n   the basic fast-forward capabilities often are implemented by\n\
    \   selecting certain subsets of frames.\n   Due to the media restrictions, the\
    \ possible scale values are commonly\n   restricted to the set of realizable scale\
    \ ratios.  To enable the\n   clients to select from the possible scale values,\
    \ RTSP can signal the\n   supported scale ratios for the content.  To support\
    \ aggregated or\n   dynamic content, where this may change during the ongoing\
    \ session and\n   dependent on the location within the content, a mechanism for\n\
    \   updating the media properties and the scale factor currently in use,\n   exists.\n\
    \   Speed (Section 18.50) affects how much of the playback timeline is\n   delivered\
    \ in a given wallclock period.  The default is Speed = 1\n   which means to deliver\
    \ at the same rate the media is consumed.\n   Speed > 1 means that the receiver\
    \ will get content faster than it\n   regularly would consume it.  Speed < 1 means\
    \ that delivery is slower\n   than the regular media rate.  Speed values of 0\
    \ or lower have no\n   meaning and are not allowed.  This mechanism enables two\
    \ general\n   functionalities.  One is client-side scale operations, i.e., the\n\
    \   client receives all the frames and makes the adjustment to the\n   playback\
    \ locally.  The second is delivery control for the buffering\n   of media.  By\
    \ specifying a speed over 1.0, the client can build up\n   the amount of playback\
    \ time it has present in its buffers to a level\n   that is sufficient for its\
    \ needs.\n   A naive implementation of Speed would only affect the transmission\n\
    \   schedule of the media and has a clear impact on the needed bandwidth.\n  \
    \ This would result in the data rate being proportional to the speed\n   factor.\
    \  Speed = 1.5, i.e., 50% faster than normal delivery, would\n   result in a 50%\
    \ increase in the data-transport rate.  Whether or not\n   that can be supported\
    \ depends solely on the underlying network path.\n   Scale may also have some\
    \ impact on the required bandwidth due to the\n   manipulation of the content\
    \ in the new playback schedule.  An example\n   is fast forward where only the\
    \ independently decodable intra-frames\n   are included in the media stream. \
    \ This usage of solely intra-frames\n   increases the data rate significantly\
    \ compared to a normal sequence\n   with the same number of frames, where most\
    \ frames are encoded using\n   prediction.\n   This potential increase of the\
    \ data rate needs to be handled by the\n   media sender.  The client has requested\
    \ that the media be delivered\n   in a specific way, which should be honored.\
    \  However, the media\n   sender cannot ignore if the network path between the\
    \ sender and the\n   receiver can't handle the resulting media stream.  In that\
    \ case, the\n   media stream needs to be adapted to fit the available resources\
    \ of\n   the path.  This can result in a reduced media quality.\n   The need for\
    \ bitrate adaptation becomes especially problematic in\n   connection with the\
    \ Speed semantics.  If the goal is to fill up the\n   buffer, the client may not\
    \ want to do that at the cost of reduced\n   quality.  If the client wants to\
    \ make local playout changes, then it\n   may actually require that the requested\
    \ speed be honored.  To resolve\n   this issue, Speed uses a range so that both\
    \ cases can be supported.\n   The server is requested to use the highest possible\
    \ speed value\n   within the range, which is compatible with the available bandwidth.\n\
    \   As long as the server can maintain a speed value within the range, it\n  \
    \ shall not change the media quality, but instead modify the actual\n   delivery\
    \ rate in response to available bandwidth and reflect this in\n   the Speed value\
    \ in the response.  However, if this is not possible,\n   the server should instead\
    \ modify the media quality to respect the\n   lowest speed value and the available\
    \ bandwidth.\n   This functionality enables the local scaling implementation to\
    \ use a\n   tight range, or even a range where the lower bound equals the upper\n\
    \   bound, to identify that it requires the server to deliver the\n   requested\
    \ amount of media time per delivery time, independent of how\n   much it needs\
    \ to adapt the media quality to fit within the available\n   path bandwidth. \
    \ For buffer filling, it is suitable to use a range\n   with a reasonable span\
    \ and with a lower bound at the nominal media\n   rate 1.0, such as 1.0 - 2.5.\
    \  If the client wants to reduce the\n   buffer, it can specify an upper bound\
    \ that is below 1.0 to force the\n   server to deliver slower than the nominal\
    \ media rate.\n"
- title: 2.6.  Session Maintenance and Termination
  contents:
  - "2.6.  Session Maintenance and Termination\n   The session context that has been\
    \ established is kept alive by having\n   the client show liveness.  This is done\
    \ in two main ways:\n   o  Media-transport protocol keep-alive.  RTP Control Protocol\
    \ (RTCP)\n      may be used when using RTP.\n   o  Any RTSP request referencing\
    \ the session context.\n   Section 10.5 discusses the methods for showing liveness\
    \ in more\n   depth.  If the client fails to show liveness for more than the\n\
    \   established session timeout value (normally 60 seconds), the server\n   may\
    \ terminate the context.  Other values may be selected by the\n   server through\
    \ the inclusion of the timeout parameter in the session\n   header.\n   The session\
    \ context is normally terminated by the client sending a\n   TEARDOWN request\
    \ (Section 13.7) to the server referencing the\n   aggregated control URI.  An\
    \ individual media resource can be removed\n   from a session context by a TEARDOWN\
    \ request referencing that\n   particular media resource.  If all media resources\
    \ are removed from a\n   session context, the session context is terminated.\n\
    \   A client may keep the session alive indefinitely if allowed by the\n   server;\
    \ however, a client is advised to release the session context\n   when an extended\
    \ period of time without media delivery activity has\n   passed.  The client can\
    \ re-establish the session context if required\n   later.  What constitutes an\
    \ extended period of time is dependent on\n   the client, server, and their usage.\
    \  It is recommended that the\n   client terminate the session before ten times\
    \ the session timeout\n   value has passed.  A server may terminate the session\
    \ after one\n   session timeout period without any client activity beyond keep-alive.\n\
    \   When a server terminates the session context, it does so by sending a\n  \
    \ TEARDOWN request indicating the reason.\n   A server can also request that the\
    \ client tear down the session and\n   re-establish it at an alternative server,\
    \ as may be needed for\n   maintenance.  This is done by using the REDIRECT method\n\
    \   (Section 13.10).  The Terminate-Reason header (Section 18.52) is used\n  \
    \ to indicate when and why.  The Location header indicates where it\n   should\
    \ connect if there is an alternative server available.  When the\n   deadline\
    \ expires, the server simply stops providing the service.  To\n   achieve a clean\
    \ closure, the client needs to initiate session\n   termination prior to the deadline.\
    \  In case the server has no other\n   server to redirect to, and it wants to\
    \ close the session for\n   maintenance, it shall use the TEARDOWN method with\
    \ a Terminate-Reason\n   header.\n"
- title: 2.7.  Extending RTSP
  contents:
  - "2.7.  Extending RTSP\n   RTSP is quite a versatile protocol that supports extensions\
    \ in many\n   different directions.  Even this core specification contains several\n\
    \   blocks of functionality that are optional to implement.  The use case\n  \
    \ and need for the protocol deployment should determine what parts are\n   implemented.\
    \  Allowing for extensions makes it possible for RTSP to\n   address additional\
    \ use cases.  However, extensions will affect the\n   interoperability of the\
    \ protocol; therefore, it is important that\n   they can be added in a structured\
    \ way.\n   The client can learn the capability of a server by using the OPTIONS\n\
    \   method (Section 13.1) and the Supported header (Section 18.51).  It\n   can\
    \ also try and possibly fail using new methods or require that\n   particular\
    \ features be supported using the Require (Section 18.43) or\n   Proxy-Require\
    \ (Section 18.37) header.\n   The RTSP, in itself, can be extended in three ways,\
    \ listed here in\n   increasing order of the magnitude of changes supported:\n\
    \   o  Existing methods can be extended with new parameters, for example,\n  \
    \    headers, as long as these parameters can be safely ignored by the\n     \
    \ recipient.  If the client needs negative acknowledgment when a\n      method\
    \ extension is not supported, a tag corresponding to the\n      extension may\
    \ be added in the field of the Require or Proxy-\n      Require headers.\n   o\
    \  New methods can be added.  If the recipient of the message does\n      not\
    \ understand the request, it must respond with error code 501\n      (Not Implemented)\
    \ so that the sender can avoid using this method\n      again.  A client may also\
    \ use the OPTIONS method to inquire about\n      methods supported by the server.\
    \  The server must list the methods\n      it supports using the Public response-header.\n\
    \   o  A new version of the protocol can be defined, allowing almost all\n   \
    \   aspects (except the position of the protocol version number) to\n      change.\
    \  A new version of the protocol must be registered through\n      a Standards\
    \ Track document.\n   The basic capability discovery mechanism can be used to\
    \ both discover\n   support for a certain feature and to ensure that a feature\
    \ is\n   available when performing a request.  For a detailed explanation of\n\
    \   this, see Section 11.\n   New media delivery protocols may be added and negotiated\
    \ at session\n   establishment, in addition to extensions to the core protocol.\n\
    \   Certain types of protocol manipulations can be done through parameter\n  \
    \ formats using SET_PARAMETER and GET_PARAMETER.\n"
- title: 3.  Document Conventions
  contents:
  - '3.  Document Conventions

    '
- title: 3.1.  Notational Conventions
  contents:
  - "3.1.  Notational Conventions\n   All the mechanisms specified in this document\
    \ are described in both\n   prose and the Augmented Backus-Naur form (ABNF) described\
    \ in detail\n   in [RFC5234].\n   Indented paragraphs are used to provide informative\
    \ background and\n   motivation.  This is intended to give readers who were not\
    \ involved\n   with the formulation of the specification an understanding of why\n\
    \   things are the way they are in RTSP.\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be\
    \ interpreted as described in\n   [RFC2119].\n   The word, \"unspecified\" is\
    \ used to indicate functionality or features\n   that are not defined in this\
    \ specification.  Such functionality\n   cannot be used in a standardized manner\
    \ without further definition in\n   an extension specification to RTSP.\n"
- title: 3.2.  Terminology
  contents:
  - "3.2.  Terminology\n   Aggregate control:  The concept of controlling multiple\
    \ streams using\n      a single timeline, generally one maintained by the server.\
    \  A\n      client, for example, uses aggregate control when it issues a\n   \
    \   single play or pause message to simultaneously control both the\n      audio\
    \ and video in a movie.  A session that is under aggregate\n      control is referred\
    \ to as an \"aggregated session\".\n   Aggregate control URI:  The URI used in\
    \ an RTSP request to refer to\n      and control an aggregated session.  It normally,\
    \ but not always,\n      corresponds to the presentation URI specified in the\
    \ session\n      description.  See Section 13.3 for more information.\n   Client:\
    \  The client is the requester of media service from the media\n      server.\n\
    \   Connection:  A transport-layer virtual circuit established between\n     \
    \ two programs for the purpose of communication.\n   Container file:  A file that\
    \ may contain multiple media streams that\n      often constitute a presentation\
    \ when played together.  The concept\n      of a container file is not embedded\
    \ in the protocol.  However,\n      RTSP servers may offer aggregate control on\
    \ the media streams\n      within these files.\n   Continuous media:  Data where\
    \ there is a timing relationship between\n      source and sink; that is, the\
    \ sink needs to reproduce the timing\n      relationship that existed at the source.\
    \  The most common examples\n      of continuous media are audio and motion video.\
    \  Continuous media\n      can be real time (interactive or conversational), where\
    \ there is a\n      \"tight\" timing relationship between source and sink or it\
    \ can be\n      streaming where the relationship is less strict.\n   Feature tag:\
    \  A tag representing a certain set of functionality,\n      i.e., a feature.\n\
    \   IRI:  An Internationalized Resource Identifier is similar to a URI\n     \
    \ but allows characters from the whole Universal Character Set\n      (Unicode/ISO\
    \ 10646), rather than the US-ASCII only.  See [RFC3987]\n      for more information.\n\
    \   Live:  A live presentation or session originates media from an event\n   \
    \   taking place at the same time as the media delivery.  Live\n      sessions\
    \ often have an unbound or only loosely defined duration\n      and seek operations\
    \ may not be possible.\n   Media initialization:  The datatype- or codec-specific\n\
    \      initialization.  This includes such things as clock rates, color\n    \
    \  tables, etc.  Any transport-independent information that is\n      required\
    \ by a client for playback of a media stream occurs in the\n      media initialization\
    \ phase of stream setup.\n   Media parameter:  A parameter specific to a media\
    \ type that may be\n      changed before or during stream delivery.\n   Media\
    \ server:  The server providing media-delivery services for one\n      or more\
    \ media streams.  Different media streams within a\n      presentation may originate\
    \ from different media servers.  A media\n      server may reside on the same\
    \ host or on a different host from\n      which the presentation is invoked.\n\
    \   (Media) Stream:  A single media instance, e.g., an audio stream or a\n   \
    \   video stream as well as a single whiteboard or shared application\n      group.\
    \  When using RTP, a stream consists of all RTP and RTCP\n      packets created\
    \ by a media source within an RTP session.\n   Message:  The basic unit of RTSP\
    \ communication, consisting of a\n      structured sequence of octets matching\
    \ the syntax defined in\n      Section 20 and transmitted over a transport between\
    \ RTSP agents.\n      A message is either a request or a response.\n   Message\
    \ body:  The information transferred as the payload of a\n      message (request\
    \ or response).  A message body consists of meta-\n      information in the form\
    \ of message body headers and content in the\n      form of an arbitrary number\
    \ of data octets, as described in\n      Section 9.\n   Non-aggregated control:\
    \  Control of a single media stream.\n   Presentation:  A set of one or more streams\
    \ presented to the client\n      as a complete media feed and described by a presentation\n\
    \      description as defined below.  Presentations with more than one\n     \
    \ media stream are often handled in RTSP under aggregate control.\n   Presentation\
    \ description:  A presentation description contains\n      information about one\
    \ or more media streams within a presentation,\n      such as the set of encodings,\
    \ network addresses, and information\n      about the content.  Other IETF protocols,\
    \ such as SDP ([RFC4566]),\n      use the term \"session\" for a presentation.\
    \  The presentation\n      description may take several different formats, including\
    \ but not\n      limited to SDP format.\n   Response:  An RTSP response to a request.\
    \  One type of RTSP message.\n      If an HTTP response is meant, it is indicated\
    \ explicitly.\n   Request:  An RTSP request.  One type of RTSP message.  If an\
    \ HTTP\n      request is meant, it is indicated explicitly.\n   Request-URI: \
    \ The URI used in a request to indicate the resource on\n      which the request\
    \ is to be performed.\n   RTSP agent:  Either an RTSP client, an RTSP server,\
    \ or an RTSP proxy.\n      In this specification, there are many capabilities\
    \ that are common\n      to these three entities such as the capability to send\
    \ requests or\n      receive responses.  This term will be used when describing\n\
    \      functionality that is applicable to all three of these entities.\n   RTSP\
    \ session:  A stateful abstraction upon which the main control\n      methods\
    \ of RTSP operate.  An RTSP session is a common context; it\n      is created\
    \ and maintained on a client's request and can be\n      destroyed by either the\
    \ client or server.  It is established by an\n      RTSP server upon the completion\
    \ of a successful SETUP request\n      (when a 200 OK response is sent) and is\
    \ labeled with a session\n      identifier at that time.  The session exists until\
    \ timed out by\n      the server or explicitly removed by a TEARDOWN request.\
    \  An RTSP\n      session is a stateful entity; an RTSP server maintains an explicit\n\
    \      session state machine (see Appendix B) where most state\n      transitions\
    \ are triggered by client requests.  The existence of a\n      session implies\
    \ the existence of state about the session's media\n      streams and their respective\
    \ transport mechanisms.  A given\n      session can have one or more media streams\
    \ associated with it.  An\n      RTSP server uses the session to aggregate control\
    \ over multiple\n      media streams.\n   Origin server:  The server on which\
    \ a given resource resides.\n   Seeking:  Requesting playback from a particular\
    \ point in the content\n      time line.\n   Transport initialization:  The negotiation\
    \ of transport information\n      (e.g., port numbers, transport protocols) between\
    \ the client and\n      the server.\n   URI:  A Universal Resource Identifier;\
    \ see [RFC3986].  The URIs used\n      in RTSP are generally URLs as they give\
    \ a location for the\n      resource.  As URLs are a subset of URIs, they will\
    \ be referred to\n      as URIs to cover also the cases when an RTSP URI would\
    \ not be a\n      URL.\n   URL:  A Universal Resource Locator is a URI that identifies\
    \ the\n      resource through its primary access mechanism rather than\n     \
    \ identifying the resource by name or by some other attribute(s) of\n      that\
    \ resource.\n"
- title: 4.  Protocol Parameters
  contents:
  - '4.  Protocol Parameters

    '
- title: 4.1.  RTSP Version
  contents:
  - "4.1.  RTSP Version\n   This specification defines version 2.0 of RTSP.\n   RTSP\
    \ uses a \"<major>.<minor>\" numbering scheme to indicate versions\n   of the\
    \ protocol.  The protocol versioning policy is intended to allow\n   the sender\
    \ to indicate the format of a message and its capacity for\n   understanding further\
    \ RTSP communication rather than the features\n   obtained via that communication.\
    \  No change is made to the version\n   number for the addition of message components\
    \ that do not affect\n   communication behavior or that only add to extensible\
    \ field values.\n   The <minor> number is incremented when the changes made to\
    \ the\n   protocol add features that do not change the general message parsing\n\
    \   algorithm but that may add to the message semantics and imply\n   additional\
    \ capabilities of the sender.  The <major> number is\n   incremented when the\
    \ format of a message within the protocol is\n   changed.  The version of an RTSP\
    \ message is indicated by an RTSP-\n   Version field in the first line of the\
    \ message.  Note that the major\n   and minor numbers MUST be treated as separate\
    \ integers and that each\n   MAY be incremented higher than a single digit.  Thus,\
    \ RTSP/2.4 is a\n   lower version than RTSP/2.13, which, in turn, is lower than\n\
    \   RTSP/12.3.  Leading zeros SHALL NOT be sent and MUST be ignored by\n   recipients.\n"
- title: 4.2.  RTSP IRI and URI
  contents:
  - "4.2.  RTSP IRI and URI\n   RTSP 2.0 defines and registers or updates three URI\
    \ schemes \"rtsp\",\n   \"rtsps\", and \"rtspu\".  The usage of the last, \"rtspu\"\
    , is unspecified\n   in RTSP 2.0 and is defined here to register the URI scheme\
    \ that was\n   defined in RTSP 1.0.  The \"rtspu\" scheme indicates unspecified\n\
    \   transport of the RTSP messages over unreliable transport means (UDP\n   in\
    \ RTSP 1.0).  An RTSP server MUST respond with an error code\n   indicating the\
    \ \"rtspu\" scheme is not implemented (501) to a request\n   that carries a \"\
    rtspu\" URI scheme.\n   The details of the syntax of \"rtsp\" and \"rtsps\" URIs\
    \ have been\n   changed from RTSP 1.0.  These changes include the addition of:\n\
    \   o  Support for an IPv6 literal in the host part and future IP\n      literals\
    \ through a mechanism defined in [RFC3986].\n   o  A new relative format to use\
    \ in the RTSP elements that is not\n      required to start with \"/\".\n   Neither\
    \ should have any significant impact on interoperability.  If\n   IPv6 literals\
    \ are needed in the RTSP URI, then that RTSP server must\n   be IPv6 capable,\
    \ and RTSP 1.0 is not a fully IPv6 capable protocol.\n   If an RTSP 1.0 client\
    \ attempts to process the URI, the URI will not\n   match the allowed syntax,\
    \ it will be considered invalid, and\n   processing will be stopped.  This is\
    \ clearly a failure to reach the\n   resource; however, it is not a signification\
    \ issue as RTSP 2.0\n   support was needed anyway in both server and client. \
    \ Thus, failure\n   will only occur in a later step when there is an RTSP version\n\
    \   mismatch between client and server.  The second change will only\n   occur\
    \ inside RTSP message headers, as the Request-URI must be an\n   absolute URI.\
    \  Thus, such usages will only occur after an agent has\n   accepted and started\
    \ processing RTSP 2.0 messages, and an agent using\n   RTSP 1.0 only will not\
    \ be required to parse such types of relative\n   URIs.\n   This specification\
    \ also defines the format of RTSP IRIs [RFC3987]\n   that can be used as RTSP\
    \ resource identifiers and locators on web\n   pages, user interfaces, on paper,\
    \ etc.  However, the RTSP request\n   message format only allows usage of the\
    \ absolute URI format.  The\n   RTSP IRI format MUST use the rules and transformation\
    \ for IRIs to\n   URIs, as defined in [RFC3987].  This allows a URI that matches\
    \ the\n   RTSP 2.0 specification, and so is suitable for use in a request, to\n\
    \   be created from an RTSP IRI.\n   The RTSP IRI and URI are both syntax restricted\
    \ compared to the\n   generic syntax defined in [RFC3986] and [RFC3987]:\n   o\
    \  An absolute URI requires the authority part; i.e., a host identity\n      MUST\
    \ be provided.\n   o  Parameters in the path element are prefixed with the reserved\n\
    \      separator \";\".\n   The \"scheme\" and \"host\" parts of all URIs [RFC3986]\
    \ and IRIs\n   [RFC3987] are case insensitive.  All other parts of RTSP URIs and\n\
    \   IRIs are case sensitive, and they MUST NOT be case mapped.\n   The fragment\
    \ identifier is used as defined in Sections 3.5 and 4.3 of\n   [RFC3986], i.e.,\
    \ the fragment is to be stripped from the IRI by the\n   requester and not included\
    \ in the Request-URI.  The user agent needs\n   to interpret the value of the\
    \ fragment based on the media type the\n   request relates to; i.e., the media\
    \ type indicated in Content-Type\n   header in the response to a DESCRIBE request.\n\
    \   The syntax of any URI query string is unspecified and responder\n   (usually\
    \ the server) specific.  The query is, from the requester's\n   perspective, an\
    \ opaque string and needs to be handled as such.\n   Please note that relative\
    \ URIs with queries are difficult to handle\n   due to the relative URI handling\
    \ rules of RFC 3986.  Any change of\n   the path element using a relative URI\
    \ results in the stripping of the\n   query, which means the relative part needs\
    \ to contain the query.\n   The URI scheme \"rtsp\" requires that commands be\
    \ issued via a reliable\n   protocol (within the Internet, TCP), while the scheme\
    \ \"rtsps\"\n   identifies a reliable transport using secure transport (TLS\n\
    \   [RFC5246]); see Section 19.\n   For the scheme \"rtsp\", if no port number\
    \ is provided in the authority\n   part of the URI, the port number 554 MUST be\
    \ used.  For the scheme\n   \"rtsps\", if no port number is provided in the authority\
    \ part of the\n   URI port number, the TCP port 322 MUST be used.\n   A presentation\
    \ or a stream is identified by a textual media\n   identifier, using the character\
    \ set and escape conventions of URIs\n   [RFC3986].  URIs may refer to a stream\
    \ or an aggregate of streams;\n   i.e., a presentation.  Accordingly, requests\
    \ described in Section 13\n   can apply to either the whole presentation or an\
    \ individual stream\n   within the presentation.  Note that some request methods\
    \ can only be\n   applied to streams, not presentations, and vice versa.\n   For\
    \ example, the RTSP URI:\n      rtsp://media.example.com:554/twister/audiotrack\n\
    \   may identify the audio stream within the presentation \"twister\",\n   which\
    \ can be controlled via RTSP requests issued over a TCP\n   connection to port\
    \ 554 of host media.example.com.\n   Also, the RTSP URI:\n      rtsp://media.example.com:554/twister\n\
    \   identifies the presentation \"twister\", which may be composed of audio\n\
    \   and video streams, but could also be something else, such as a random\n  \
    \ media redirector.\n      This does not imply a standard way to reference streams\
    \ in URIs.\n      The presentation description defines the hierarchical\n    \
    \  relationships in the presentation and the URIs for the individual\n      streams.\
    \  A presentation description may name a stream \"a.mov\" and\n      the whole\
    \ presentation \"b.mov\".\n   The path components of the RTSP URI are opaque to\
    \ the client and do\n   not imply any particular file system structure for the\
    \ server.\n      This decoupling also allows presentation descriptions to be used\n\
    \      with non-RTSP media control protocols simply by replacing the\n      scheme\
    \ in the URI.\n"
- title: 4.3.  Session Identifiers
  contents:
  - "4.3.  Session Identifiers\n   Session identifiers are strings of a length between\
    \ 8-128 characters.\n   A session identifier MUST be generated using methods that\
    \ make it\n   cryptographically random (see [RFC4086]).  It is RECOMMENDED that\
    \ a\n   session identifier contain 128 bits of entropy, i.e., approximately\n\
    \   22 characters from a high-quality generator (see Section 21).\n   However,\
    \ note that the session identifier does not provide any\n   security against session\
    \ hijacking unless it is kept confidential by\n   the client, server, and trusted\
    \ proxies.\n"
- title: 4.4.  Media-Time Formats
  contents:
  - "4.4.  Media-Time Formats\n   RTSP currently supports three different media-time\
    \ formats defined\n   below.  Additional time formats may be specified in the\
    \ future.\n   These time formats can be used with the Range header (Section 18.40)\n\
    \   to request playback and specify at which media position protocol\n   requests\
    \ actually will or have taken place.  They are also used in\n   description of\
    \ the media's properties using the Media-Range header\n   (Section 18.30).  The\
    \ unqualified format identifier is used on its\n   own in Accept-Ranges header\
    \ (Section 18.5) to declare supported time\n   formats and also in the Range header\
    \ (Section 18.40) to request the\n   time format used in the response.\n"
- title: 4.4.1.  SMPTE-Relative Timestamps
  contents:
  - "4.4.1.  SMPTE-Relative Timestamps\n   A timestamp may use a format derived from\
    \ a Society of Motion Picture\n   and Television Engineers (SMPTE) specification\
    \ and expresses time\n   offsets anchored at the start of the media clip.  Relative\
    \ timestamps\n   are expressed as SMPTE time codes [SMPTE-TC] for frame-level\
    \ access\n   accuracy.  The time code has the format:\n      hours:minutes:seconds:frames.subframes\n\
    \   with the origin at the start of the clip.  The default SMPTE format\n   is\
    \ \"SMPTE 30 drop\" format, with a frame rate of 29.97 frames per\n   second.\
    \  Other SMPTE codes MAY be supported (such as \"SMPTE 25\")\n   through the use\
    \ of \"smpte-type\".  For SMPTE 30, the \"frames\" field in\n   the time value\
    \ can assume the values 0 through 29.  The difference\n   between 30 and 29.97\
    \ frames per second is handled by dropping the\n   first two frame indices (values\
    \ 00 and 01) of every minute, except\n   every tenth minute.  If the frame and\
    \ the subframe values are zero,\n   they may be omitted.  Subframes are measured\
    \ in hundredths of a\n   frame.\n   Examples:\n     smpte=10:12:33:20-\n     smpte=10:07:33-\n\
    \     smpte=10:07:00-10:07:33:05.01\n     smpte-25=10:07:00-10:07:33:05.01\n"
- title: 4.4.2.  Normal Play Time
  contents:
  - "4.4.2.  Normal Play Time\n   Normal Play Time (NPT) indicates the stream-absolute\
    \ position\n   relative to the beginning of the presentation.  The timestamp\n\
    \   consists of two parts: The mandatory first part may be expressed in\n   either\
    \ seconds only or in hours, minutes, and seconds.  The optional\n   second part\
    \ consists of a decimal point and decimal figures and\n   indicates fractions\
    \ of a second.\n   The beginning of a presentation corresponds to 0.0 seconds.\
    \  Negative\n   values are not defined.\n   The special constant \"now\" is defined\
    \ as the current instant of a\n   live event.  It MAY only be used for live events\
    \ and MUST NOT be used\n   for on-demand (i.e., non-live) content.\n   NPT is\
    \ defined as in Digital Storage Media Command and Control\n   (DSMb;CC) [ISO.13818-6.1995]:\n\
    \      Intuitively, NPT is the clock the viewer associates with a\n      program.\
    \  It is often digitally displayed on a DVD player.  NPT\n      advances normally\
    \ when in normal play mode (scale = 1), advances\n      at a faster rate when\
    \ in fast-scan forward (high positive scale\n      ratio), decrements when in\
    \ scan reverse (negative scale ratio) and\n      is fixed in pause mode.  NPT\
    \ is (logically) equivalent to SMPTE\n      time codes.\n   Examples:\n     npt=123.45-125\n\
    \     npt=12:05:35.3-\n     npt=now-\n   The syntax is based on ISO 8601 [ISO.8601.2000]\
    \ and expresses the\n   time elapsed since presentation start, with two different\
    \ notations\n   allowed:\n   o  The npt-hhmmss notation uses an ISO 8601 extended\
    \ complete\n      representation of the time of the day format (Section 5.3.1.1\
    \ of\n      [ISO.8601.2000] ) using colons (\":\") as separators between hours,\n\
    \      minutes, and seconds (hh:mm:ss).  The hour counter is not limited\n   \
    \   to 0-24 hours; up to nineteen (19) hour digits are allowed.\n      *  In accordance\
    \ with the requirements of the ISO 8601 time\n         format, the hours, minutes,\
    \ and seconds MUST all be present,\n         with two digits used for minutes\
    \ and for seconds and with at\n         least two digits for hours.  An NPT of\
    \ 7 minutes and 0 seconds\n         is represented as \"00:07:00\", and an NPT\
    \ of 392 hours, 0\n         minutes, and 6 seconds is represented as \"392:00:06\"\
    .\n      *  RTSP 1.0 allowed NPT in the npt-hhmmss notation without any\n    \
    \     leading zeros to ensure that implementations don't fail; for\n         backward\
    \ compatibility, all RTSP 2.0 implementations are\n         REQUIRED to support\
    \ receiving NPT values, hours, minutes, or\n         seconds, without leading\
    \ zeros.\n   o  The npt-sec notation expresses the time in seconds, using between\n\
    \      one and nineteen (19) digits.\n   Both notations allow decimal fractions\
    \ of seconds as specified in\n   Section 5.3.1.3 of [ISO.8601.2000], using at\
    \ most nine digits, and\n   allowing only \".\" (full stop) as the decimal separator.\n\
    \   The npt-sec notation is optimized for automatic generation; the npt-\n   hhmmss\
    \ notation is optimized for consumption by human readers.  The\n   \"now\" constant\
    \ allows clients to request to receive the live feed\n   rather than the stored\
    \ or time-delayed version.  This is needed since\n   neither absolute time nor\
    \ zero time are appropriate for this case.\n"
- title: 4.4.3.  Absolute Time
  contents:
  - "4.4.3.  Absolute Time\n   Absolute time is expressed using a timestamp based\
    \ on ISO 8601\n   [ISO.8601.2000].  The date is a complete representation of the\n\
    \   calendar date in basic format (YYYYMMDD) without separators (per\n   Section\
    \ 5.2.1.1 of [ISO.8601.2000]).  The time of day is provided in\n   the complete\
    \ representation basic format (hhmmss) as specified in\n   Section 5.3.1.1 of\
    \ [ISO.8601.2000], allowing decimal fractions of\n   seconds following Section\
    \ 5.3.1.3 requiring \".\" (full stop) as\n   decimal separator and limiting the\
    \ number of digits to no more than\n   nine.  The time expressed MUST use UTC\
    \ (GMT), i.e., no time zone\n   offsets are allowed.  The full date and time specification\
    \ is the\n   eight-digit date followed by a \"T\" followed by the six-digit time\n\
    \   value, optionally followed by a full stop followed by one to nine\n   fractions\
    \ of a second and ended by \"Z\", e.g., YYYYMMDDThhmmss.ssZ.\n      The reasons\
    \ for this time format rather than using \"Date and Time\n      on the Internet:\
    \ Timestamps\" [RFC3339] are historic.  We continue\n      to use the format specified\
    \ in RTSP 1.0.  The motivations raised\n      in RFC 3339 apply to why a selection\
    \ from ISO 8601 was made;\n      however, a different and even more restrictive\
    \ selection was\n      applied in this case.\n   Below are three examples of media\
    \ time formats, first, a request for\n   a clock format range request for a starting\
    \ time of November 8, 1996\n   at 14 h 37 min and 20 1/4 seconds UTC playing for\
    \ 10 min and 5\n   seconds, followed by a Media-Properties header's \"Time-Limited\"\
    \ UTC\n   property for the 24th of December 2014 at 15 hours and 00 minutes,\n\
    \   and finally a Terminate-Reason header \"time\" property for the 18th of\n\
    \   June 2013 at 16 hours, 12 minutes, and 56 seconds:\n     clock=19961108T143720.25Z-19961108T144725.25Z\n\
    \     Time-Limited=20141224T1500Z\n     time=20130618T161256Z\n"
- title: 4.5.  Feature Tags
  contents:
  - "4.5.  Feature Tags\n   Feature tags are unique identifiers used to designate\
    \ features in\n   RTSP.  These tags are used in Require (Section 18.43), Proxy-Require\n\
    \   (Section 18.37), Proxy-Supported (Section 18.38), Supported\n   (Section 18.51),\
    \ and Unsupported (Section 18.55) header fields.\n   A feature tag definition\
    \ MUST indicate which combination of clients,\n   servers, or proxies to which\
    \ it applies.\n   The creator of a new RTSP feature tag should either prefix the\n\
    \   feature tag with a reverse domain name (e.g.,\n   \"com.example.mynewfeature\"\
    \ is an apt name for a feature whose\n   inventor can be reached at \"example.com\"\
    ) or register the new feature\n   tag with the Internet Assigned Numbers Authority\
    \ (IANA).  (See\n   Section 22, \"IANA Considerations\".)\n   The usage of feature\
    \ tags is further described in Section 11, which\n   deals with capability handling.\n"
- title: 4.6.  Message Body Tags
  contents:
  - "4.6.  Message Body Tags\n   Message body tags are opaque strings that are used\
    \ to compare two\n   message bodies from the same resource, for example, in caches\
    \ or to\n   optimize setup after a redirect.  Message body tags can be carried\
    \ in\n   the MTag header (see Section 18.31) or in SDP (see Appendix D.1.9).\n\
    \   MTag is similar to ETag in HTTP/1.1 (see Section 3.11 of [RFC2068]).\n   A\
    \ message body tag MUST be unique across all versions of all message\n   bodies\
    \ associated with a particular resource.  A given message body\n   tag value MAY\
    \ be used for message bodies obtained by requests on\n   different URIs.  The\
    \ use of the same message body tag value in\n   conjunction with message bodies\
    \ obtained by requests on different\n   URIs does not imply the equivalence of\
    \ those message bodies.\n   Message body tags are used in RTSP to make some methods\
    \ conditional.\n   The methods are made conditional through the inclusion of headers;\n\
    \   see Section 18.24 and Section 18.26 for information on the If-Match\n   and\
    \ If-None-Match headers, respectively.  Note that RTSP message body\n   tags apply\
    \ to the complete presentation, i.e., both the presentation\n   description and\
    \ the individual media streams.  Thus, message body\n   tags can be used to verify\
    \ at setup time after a redirect that the\n   same session description applies\
    \ to the media at the new location\n   using the If-Match header.\n"
- title: 4.7.  Media Properties
  contents:
  - "4.7.  Media Properties\n   When an RTSP server handles media, it is important\
    \ to consider the\n   different properties a media instance for delivery and playback\
    \ can\n   have.  This specification considers the media properties listed below\n\
    \   in its protocol operations.  They are derived from the differences\n   between\
    \ a number of supported usages.\n   On-demand:  Media that has a fixed (given)\
    \ duration that doesn't\n      change during the lifetime of the RTSP session\
    \ and is known at the\n      time of the creation of the session.  It is expected\
    \ that the\n      content of the media will not change, even if the representation,\n\
    \      such as encoding, or quality, may change.  Generally, one can\n      seek,\
    \ i.e., request any range, within the media.\n   Dynamic On-demand:  This is a\
    \ variation of the on-demand case where\n      external methods are used to manipulate\
    \ the actual content of the\n      media setup for the RTSP session.  The main\
    \ example is content\n      defined by a playlist.\n   Live:  Live media represents\
    \ a progressing content stream (such as\n      broadcast TV) where the duration\
    \ may or may not be known.  It is\n      not seekable, only the content presently\
    \ being delivered can be\n      accessed.\n   Live with Recording:  A live stream\
    \ that is combined with a server-\n      side capability to store and retain the\
    \ content of the live\n      session and allow for random access delivery within\
    \ the part of\n      the already-recorded content.  The actual behavior of the\
    \ media\n      stream is very much dependent on the retention policy for the\n\
    \      media stream; either the server will be able to capture the\n      complete\
    \ media stream or it will have a limitation in how much\n      will be retained.\
    \  The media range will dynamically change as the\n      session progress.  For\
    \ servers with a limited amount of storage\n      available for recording, there\
    \ will typically be a sliding window\n      that moves forward while new data\
    \ is made available and older data\n      is discarded.\n   To cover the above\
    \ usages, the following media properties with\n   appropriate values are specified.\n"
- title: 4.7.1.  Random Access and Seeking
  contents:
  - "4.7.1.  Random Access and Seeking\n   Random access is the ability to specify\
    \ and get media delivered\n   starting from any time (instant) within the content,\
    \ an operation\n   called \"seeking\".  The Media-Properties header will indicate\
    \ the\n   general capability for a media resource to perform random access.\n\
    \   Random-Access:  The media is seekable to any out of a large number of\n  \
    \    points within the media.  Due to media-encoding limitations, a\n      particular\
    \ point may not be reachable, but seeking to a point\n      close by is enabled.\
    \  A floating-point number of seconds may be\n      provided to express the worst-case\
    \ distance between random access\n      points.\n   Beginning-Only:  Seeking is\
    \ only possible to the beginning of the\n      content.\n   No-Seeking:  Seeking\
    \ is not possible at all.\n   If random access is possible, as indicated by the\
    \ Media-Properties\n   header, the actual behavior policy when seeking can be\
    \ controlled\n   using the Seek-Style header (Section 18.47).\n"
- title: 4.7.2.  Retention
  contents:
  - "4.7.2.  Retention\n   The following retention policies are used by media to limit\
    \ possible\n   protocol operations:\n   Unlimited:  The media will not be removed\
    \ as long as the RTSP session\n      is in existence.\n   Time-Limited:  The media\
    \ will not be removed before the given\n      wallclock time.  After that time,\
    \ it may or may not be available\n      anymore.\n   Time-Duration:  The media\
    \ (on fragment or unit basis) will be\n      retained for the specified duration.\n"
- title: 4.7.3.  Content Modifications
  contents:
  - "4.7.3.  Content Modifications\n   The media content and its timeline can be of\
    \ different types, e.g.\n   pre-produced content on demand, a live source that\
    \ is being generated\n   as time progresses, or something that is dynamically\
    \ altered or\n   recomposed during playback.  Therefore, a media property for\
    \ content\n   modifications is needed and the following initial values are defined:\n\
    \   Immutable:  The content of the media will not change, even if the\n      representation,\
    \ such as encoding or quality changes.\n   Dynamic:  The content can change due\
    \ to external methods or triggers,\n      such as playlists, but this will be\
    \ announced by explicit updates.\n   Time-Progressing:  As time progresses, new\
    \ content will become\n      available.  If the content is also retained, it will\
    \ become longer\n      as everything between the start point and the point currently\n\
    \      being made available can be accessed.  If the media server uses a\n   \
    \   sliding-window policy for retention, the start point will also\n      change\
    \ as time progresses.\n"
- title: 4.7.4.  Supported Scale Factors
  contents:
  - "4.7.4.  Supported Scale Factors\n   A particular media content item often supports\
    \ only a limited set or\n   range of scales when delivering the media.  To enable\
    \ the client to\n   know what values or ranges of scale operations that the whole\
    \ content\n   or the current position supports, a media properties attribute for\n\
    \   this is defined that contains a list with the values or ranges that\n   are\
    \ supported.  The attribute is named \"Scales\".  The \"Scales\"\n   attribute\
    \ may be updated at any point in the content due to content\n   consisting of\
    \ spliced pieces or content being dynamically updated by\n   out-of-band mechanisms.\n"
- title: 4.7.5.  Mapping to the Attributes
  contents:
  - "4.7.5.  Mapping to the Attributes\n   This section shows examples of how one\
    \ would map the above usages to\n   the properties and their values.\n   Example\
    \ of On-Demand:\n      Random Access: Random-Access=5.0, Content Modifications:\n\
    \      Immutable, Retention: Unlimited or Time-Limited.\n   Example of Dynamic\
    \ On-Demand:\n      Random Access: Random-Access=3.0, Content Modifications: Dynamic,\n\
    \      Retention: Unlimited or Time-Limited.\n   Example of Live:\n      Random\
    \ Access: No-Seeking, Content Modifications: Time-\n      Progressing, Retention:\
    \ Time-Duration=0.0\n   Example of Live with Recording:\n      Random Access:\
    \ Random-Access=3.0, Content Modifications: Time-\n      Progressing, Retention:\
    \ Time-Duration=7200.0\n"
- title: 5.  RTSP Message
  contents:
  - "5.  RTSP Message\n   RTSP is a text-based protocol that uses the ISO 10646 character\
    \ set\n   in UTF-8 encoding per RFC 3629 [RFC3629].  Lines MUST be terminated\n\
    \   by a CRLF.\n      Text-based protocols make it easier to add optional parameters\
    \ in\n      a self-describing manner.  Since the number of parameters and the\n\
    \      frequency of commands is low, processing efficiency is not a\n      concern.\
    \  Text-based protocols, if used carefully, also allow easy\n      implementation\
    \ of research prototypes in scripting languages such\n      as Python, PHP, Perl\
    \ and TCL.\n   The ISO 10646 character set avoids character-set switching, but\
    \ is\n   invisible to the application as long as US-ASCII is being used.  This\n\
    \   is also the encoding used for text fields in RTCP [RFC3550].\n   A request\
    \ contains a method, the object the method is operating upon,\n   and parameters\
    \ to further describe the method.  Methods are\n   idempotent unless otherwise\
    \ noted.  Methods are also designed to\n   require little or no state maintenance\
    \ at the media server.\n"
- title: 5.1.  Message Types
  contents:
  - "5.1.  Message Types\n   RTSP messages are either requests from client to server\
    \ or from\n   server to client, and responses in the reverse direction.  Request\n\
    \   (Section 7) and response (Section 8) messages use a format based on\n   the\
    \ generic message format of RFC 5322 [RFC5322] for transferring\n   bodies (the\
    \ payload of the message).  Both types of messages consist\n   of a start-line,\
    \ zero or more header fields (also known as\n   \"headers\"), an empty line (i.e.,\
    \ a line with nothing preceding the\n   CRLF) indicating the end of the headers,\
    \ and possibly the data of the\n   message body.  The ABNF [RFC5234] below is\
    \ for illustration only; the\n   formal message specification is presented in\
    \ Section 20.2.2.\n   generic-message = start-line\n                   *(rtsp-header\
    \ CRLF)\n                     CRLF\n                   [ message-body-data ]\n\
    \   start-line = Request-Line / Status-Line\n   In the interest of robustness,\
    \ agents MUST ignore any empty line(s)\n   received where a Request-Line or Status-Line\
    \ is expected.  In other\n   words, if the agent is reading the protocol stream\
    \ at the beginning\n   of a message and receives any number of CRLFs first, it\
    \ MUST ignore\n   all of the CRLFs.\n"
- title: 5.2.  Message Headers
  contents:
  - "5.2.  Message Headers\n   RTSP header fields (see Section 18) include general-header,\
    \ request-\n   header, response-header, and message body header fields.\n   The\
    \ order in which header fields with differing field names are\n   received is\
    \ not significant.  However, it is \"good practice\" to send\n   general-header\
    \ fields first, followed by a request-header or\n   response-header field, and\
    \ ending with the message body header\n   fields.\n   Multiple header fields with\
    \ the same field-name MAY be present in a\n   message if and only if the entire\
    \ field-value for that header field\n   is defined as a comma-separated list.\
    \  It MUST be possible to combine\n   the multiple header fields into one \"field-name:\
    \ field-value\" pair,\n   without changing the semantics of the message, by appending\
    \ each\n   subsequent field-value to the first, each separated by a comma.  The\n\
    \   order in which header fields with the same field-name are received is\n  \
    \ therefore significant to the interpretation of the combined field\n   value;\
    \ thus, a proxy MUST NOT change the order of these field-values\n   when a message\
    \ is forwarded.\n   Unknown message headers MUST be ignored (skipping over the\
    \ header to\n   the next protocol element, and not causing an error) by an RTSP\n\
    \   server or client.  An RTSP proxy MUST forward unknown message\n   headers.\
    \  Message headers defined outside of this specification that\n   are required\
    \ to be interpreted by the RTSP agent will need to use\n   feature tags (Section\
    \ 4.5) and include them in the appropriate\n   Require (Section 18.43) or Proxy-Require\
    \ (Section 18.37) header.\n"
- title: 5.3.  Message Body
  contents:
  - "5.3.  Message Body\n   The message body (if any) of an RTSP message is used to\
    \ carry further\n   information for a particular resource associated with the\
    \ request or\n   response.  An example of a message body is an SDP message.\n\
    \   The presence of a message body in either a request or a response MUST\n  \
    \ be signaled by the inclusion of a Content-Length header (see\n   Section 18.17)\
    \ and Content-Type header (see Section 18.19).  A\n   message body MUST NOT be\
    \ included in a request or response if the\n   specification of the particular\
    \ method (see Method Definitions\n   (Section 13)) does not allow sending a message\
    \ body.  In case a\n   message body is received in a message when not expected,\
    \ the message\n   body data SHOULD be discarded.  This is to allow future extensions\
    \ to\n   define optional use of a message body.\n"
- title: 5.4.  Message Length
  contents:
  - "5.4.  Message Length\n   An RTSP message that does not contain any message body\
    \ is terminated\n   by the first empty line after the header fields (note: an\
    \ empty line\n   is a line with nothing preceding the CRLF.).  In RTSP messages\
    \ that\n   contain message bodies, the empty line is followed by the message\n\
    \   body.  The length of that body is determined by the value of the\n   Content-Length\
    \ header (Section 18.17).  The value in the header\n   represents the length of\
    \ the message body in octets.  If this header\n   field is not present, a value\
    \ of zero is assumed, i.e., no message\n   body present in the message.  Unlike\
    \ an HTTP message, an RTSP message\n   MUST contain a Content-Length header whenever\
    \ it contains a message\n   body.  Note that RTSP does not support the HTTP/1.1\
    \ \"chunked\"\n   transfer coding (see Section 4.1 of [RFC7230]).\n      Given\
    \ the moderate length of presentation descriptions returned,\n      the server\
    \ should always be able to determine its length, even if\n      it is generated\
    \ dynamically, making the chunked transfer encoding\n      unnecessary.\n"
- title: 6.  General-Header Fields
  contents:
  - "6.  General-Header Fields\n   General headers are headers that may be used in\
    \ both requests and\n   responses.  The general-headers are listed in Table 1:\n\
    \                  +--------------------+----------------+\n                 \
    \ | Header Name        | Defined in     |\n                  +--------------------+----------------+\n\
    \                  | Accept-Ranges      | Section 18.5   |\n                 \
    \ |                    |                |\n                  | Cache-Control \
    \     | Section 18.11  |\n                  |                    |           \
    \     |\n                  | Connection         | Section 18.12  |\n         \
    \         |                    |                |\n                  | CSeq  \
    \             | Section 18.20  |\n                  |                    |   \
    \             |\n                  | Date               | Section 18.21  |\n \
    \                 |                    |                |\n                  |\
    \ Media-Properties   | Section 18.29  |\n                  |                 \
    \   |                |\n                  | Media-Range        | Section 18.30\
    \  |\n                  |                    |                |\n            \
    \      | Pipelined-Requests | Section 18.33  |\n                  |          \
    \          |                |\n                  | Proxy-Supported    | Section\
    \ 18.38  |\n                  |                    |                |\n      \
    \            | Range              | Section 18.40  |\n                  |    \
    \                |                |\n                  | RTP-Info           |\
    \ Section 18.45  |\n                  |                    |                |\n\
    \                  | Scale              | Section 18.46  |\n                 \
    \ |                    |                |\n                  | Seek-Style    \
    \     | Section 18.47  |\n                  |                    |           \
    \     |\n                  | Server             | Section 18.48  |\n         \
    \         |                    |                |\n                  | Session\
    \            | Section 18.49  |\n                  |                    |    \
    \            |\n                  | Speed              | Section 18.50  |\n  \
    \                |                    |                |\n                  |\
    \ Supported          | Section 18.51  |\n                  |                 \
    \   |                |\n                  | Timestamp          | Section 18.53\
    \  |\n                  |                    |                |\n            \
    \      | Transport          | Section 18.54  |\n                  |          \
    \          |                |\n                  | User-Agent         | Section\
    \ 18.56  |\n                  |                    |                |\n      \
    \            | Via                | Section 18.57  |\n                  +--------------------+----------------+\n\
    \                 Table 1: The General Headers Used in RTSP\n"
- title: 7.  Request
  contents:
  - "7.  Request\n   A request message uses the format outlined below regardless of\
    \ the\n   direction of a request, whether client to server or server to client:\n\
    \   o  Request line, containing the method to be applied to the resource,\n  \
    \    the identifier of the resource, and the protocol version in use;\n   o  Zero\
    \ or more Header lines, which can be of the following types:\n      general-headers\
    \ (Section 6), request-headers (Section 7.2), or\n      message body headers (Section\
    \ 9.1);\n   o  One empty line (CRLF) to indicate the end of the header section;\n\
    \   o  Optionally, a message body, consisting of one or more lines.  The\n   \
    \   length of the message body in octets is indicated by the Content-\n      Length\
    \ message header.\n"
- title: 7.1.  Request Line
  contents:
  - "7.1.  Request Line\n   The request line provides the key information about the\
    \ request: what\n   method, on what resources, and using which RTSP version. \
    \ The methods\n   that are defined by this specification are listed in Table 2.\n\
    \                    +---------------+----------------+\n                    |\
    \ Method        | Defined in     |\n                    +---------------+----------------+\n\
    \                    | DESCRIBE      | Section 13.2   |\n                    |\
    \               |                |\n                    | GET_PARAMETER | Section\
    \ 13.8   |\n                    |               |                |\n         \
    \           | OPTIONS       | Section 13.1   |\n                    |        \
    \       |                |\n                    | PAUSE         | Section 13.6\
    \   |\n                    |               |                |\n              \
    \      | PLAY          | Section 13.4   |\n                    |             \
    \  |                |\n                    | PLAY_NOTIFY   | Section 13.5   |\n\
    \                    |               |                |\n                    |\
    \ REDIRECT      | Section 13.10  |\n                    |               |    \
    \            |\n                    | SETUP         | Section 13.3   |\n     \
    \               |               |                |\n                    | SET_PARAMETER\
    \ | Section 13.9   |\n                    |               |                |\n\
    \                    | TEARDOWN      | Section 13.7   |\n                    +---------------+----------------+\n\
    \                         Table 2: The RTSP Methods\n   The syntax of the RTSP\
    \ request line has the following:\n      <Method> SP <Request-URI> SP <RTSP-Version>\
    \ CRLF\n   Note: This syntax cannot be freely changed in future versions of\n\
    \   RTSP.  This line needs to remain parsable by older RTSP\n   implementations\
    \ since it indicates the RTSP version of the message.\n   In contrast to HTTP/1.1\
    \ [RFC7230], RTSP requests identify the\n   resource through an absolute RTSP\
    \ URI (including scheme, host, and\n   port) (see Section 4.2) rather than just\
    \ the absolute path.\n      HTTP/1.1 requires servers to understand the absolute\
    \ URI, but\n      clients are supposed to use the Host request-header.  This is\n\
    \      purely needed for backward compatibility with HTTP/1.0 servers, a\n   \
    \   consideration that does not apply to RTSP.\n   An asterisk \"*\" can be used\
    \ instead of an absolute URI in the\n   Request-URI part to indicate that the\
    \ request does not apply to a\n   particular resource but to the server or proxy\
    \ itself, and is only\n   allowed when the request method does not necessarily\
    \ apply to a\n   resource.\n   For example:\n      OPTIONS * RTSP/2.0\n   An OPTIONS\
    \ in this form will determine the capabilities of the server\n   or the proxy\
    \ that first receives the request.  If the capability of\n   the specific server\
    \ needs to be determined, without regard to the\n   capability of an intervening\
    \ proxy, the server should be addressed\n   explicitly with an absolute URI that\
    \ contains the server's address.\n   For example:\n      OPTIONS rtsp://example.com\
    \ RTSP/2.0\n"
- title: 7.2.  Request-Header Fields
  contents:
  - "7.2.  Request-Header Fields\n   The RTSP headers in Table 3 can be included in\
    \ a request, as request-\n   headers, to modify the specifics of the request.\n\
    \                 +---------------------+----------------+\n                 |\
    \ Header              | Defined in     |\n                 +---------------------+----------------+\n\
    \                 | Accept              | Section 18.1   |\n                 |\
    \                     |                |\n                 | Accept-Credentials\
    \  | Section 18.2   |\n                 |                     |              \
    \  |\n                 | Accept-Encoding     | Section 18.3   |\n            \
    \     |                     |                |\n                 | Accept-Language\
    \     | Section 18.4   |\n                 |                     |           \
    \     |\n                 | Authorization       | Section 18.8   |\n         \
    \        |                     |                |\n                 | Bandwidth\
    \           | Section 18.9   |\n                 |                     |     \
    \           |\n                 | Blocksize           | Section 18.10  |\n   \
    \              |                     |                |\n                 | From\
    \                | Section 18.23  |\n                 |                     |\
    \                |\n                 | If-Match            | Section 18.24  |\n\
    \                 |                     |                |\n                 |\
    \ If-Modified-Since   | Section 18.25  |\n                 |                 \
    \    |                |\n                 | If-None-Match       | Section 18.26\
    \  |\n                 |                     |                |\n            \
    \     | Notify-Reason       | Section 18.32  |\n                 |           \
    \          |                |\n                 | Proxy-Authorization | Section\
    \ 18.36  |\n                 |                     |                |\n      \
    \           | Proxy-Require       | Section 18.37  |\n                 |     \
    \                |                |\n                 | Referrer            |\
    \ Section 18.41  |\n                 |                     |                |\n\
    \                 | Request-Status      | Section 18.42  |\n                 |\
    \                     |                |\n                 | Require         \
    \    | Section 18.43  |\n                 |                     |            \
    \    |\n                 | Terminate-Reason    | Section 18.52  |\n          \
    \       +---------------------+----------------+\n                     Table 3:\
    \ The RTSP Request-Headers\n   Detailed header definitions are provided in Section\
    \ 18.\n   New request-headers may be defined.  If the receiver of the request\n\
    \   is required to understand the request-header, the request MUST\n   include\
    \ a corresponding feature tag in a Require or Proxy-Require\n   header to ensure\
    \ the processing of the header.\n"
- title: 8.  Response
  contents:
  - "8.  Response\n   After receiving and interpreting a request message, the recipient\n\
    \   responds with an RTSP response message.  Normally, there is only one,\n  \
    \ final, response.  Responses using the response code class 1xx is the\n   only\
    \ class for which there MAY be sent one or more responses prior to\n   the final\
    \ response message.\n   The valid response codes and the methods they can be used\
    \ with are\n   listed in Table 4.\n"
- title: 8.1.  Status-Line
  contents:
  - "8.1.  Status-Line\n   The first line of a response message is the Status-Line,\
    \ consisting\n   of the protocol version followed by a numeric status code and\
    \ the\n   textual phrase associated with the status code, with each element\n\
    \   separated by SP characters.  No CR or LF is allowed except in the\n   final\
    \ CRLF sequence.\n   <RTSP-Version> SP <Status-Code> SP <Reason Phrase> CRLF\n"
- title: 8.1.1.  Status Code and Reason Phrase
  contents:
  - "8.1.1.  Status Code and Reason Phrase\n   The Status-Code element is a 3-digit\
    \ integer result code of the\n   attempt to understand and satisfy the request.\
    \  These codes are fully\n   defined in Section 17.  The reason phrase is intended\
    \ to give a short\n   textual description of the Status-Code.  The Status-Code\
    \ is intended\n   for use by automata and the reason phrase is intended for the\
    \ human\n   user.  The client is not required to examine or display the reason\n\
    \   phrase.\n   The first digit of the Status-Code defines the class of response.\n\
    \   The last two digits do not have any categorization role.  There are\n   five\
    \ values for the first digit:\n   1xx:  Informational - Request received, continuing\
    \ process\n   2xx:  Success - The action was successfully received, understood,\
    \ and\n         accepted\n   3rr:  Redirection - Further action needs to be taken\
    \ in order to\n         complete the request (3rr rather than 3xx is used as 304\
    \ is\n         excluded; see Section 17.3)\n   4xx:  Client Error - The request\
    \ contains bad syntax or cannot be\n         fulfilled\n   5xx:  Server Error\
    \ - The server failed to fulfill an apparently valid\n         request\n   The\
    \ individual values of the numeric status codes defined for RTSP\n   2.0, and\
    \ an example set of corresponding reason phrases, are\n   presented in Table 4.\
    \  The reason phrases listed here are only\n   recommended; they may be replaced\
    \ by local equivalents without\n   affecting the protocol.  Note that RTSP adopted\
    \ most HTTP/1.1\n   [RFC2068] status codes and then added RTSP-specific status\
    \ codes\n   starting at x50 to avoid conflicts with future HTTP status codes that\n\
    \   are desirable to import into RTSP.  All these codes are RTSP specific\n  \
    \ and RTSP has its own registry separate from HTTP for status codes.\n   RTSP\
    \ status codes are extensible.  RTSP applications are not required\n   to understand\
    \ the meaning of all registered status codes, though such\n   understanding is\
    \ obviously desirable.  However, applications MUST\n   understand the class of\
    \ any status code, as indicated by the first\n   digit, and treat any unrecognized\
    \ response as being equivalent to the\n   x00 status code of that class, with\
    \ an exception for unknown 3xx\n   codes, which MUST be treated as a 302 (Found).\
    \  The reason for that\n   exception is that the status code 300 (Multiple Choices\
    \ in HTTP) is\n   not defined for RTSP.  A response with an unrecognized status\
    \ code\n   MUST NOT be cached.  For example, if an unrecognized status code of\n\
    \   431 is received by the client, it can safely assume that there was\n   something\
    \ wrong with its request and treat the response as if it had\n   received a 400\
    \ status code.  In such cases, user agents SHOULD\n   present to the user the\
    \ message body returned with the response,\n   since that message body is likely\
    \ to include human-readable\n   information that will explain the unusual status.\n\
    \   +------+---------------------------------+--------------------------+\n  \
    \ | Code | Reason                          | Method                   |\n   +------+---------------------------------+--------------------------+\n\
    \   | 100  | Continue                        | all                      |\n  \
    \ |      |                                 |                          |\n   |\
    \ 200  | OK                              | all                      |\n   |  \
    \    |                                 |                          |\n   | 301\
    \  | Moved Permanently               | all                      |\n   |      |\
    \                                 |                          |\n   | 302  | Found\
    \                           | all                      |\n   |      |        \
    \                         |                          |\n   | 303  | See Other\
    \                       | n/a                      |\n   |      |            \
    \                     |                          |\n   | 304  | Not Modified \
    \                   | all                      |\n   |      |                \
    \                 |                          |\n   | 305  | Use Proxy        \
    \               | all                      |\n   |      |                    \
    \             |                          |\n   | 400  | Bad Request          \
    \           | all                      |\n   |      |                        \
    \         |                          |\n   | 401  | Unauthorized             \
    \       | all                      |\n   |      |                            \
    \     |                          |\n   | 402  | Payment Required             \
    \   | all                      |\n   |      |                                \
    \ |                          |\n   | 403  | Forbidden                       |\
    \ all                      |\n   |      |                                 |  \
    \                        |\n   | 404  | Not Found                       | all\
    \                      |\n   |      |                                 |      \
    \                    |\n   | 405  | Method Not Allowed              | all    \
    \                  |\n   |      |                                 |          \
    \                |\n   | 406  | Not Acceptable                  | all        \
    \              |\n   |      |                                 |              \
    \            |\n   | 407  | Proxy Authentication Required   | all            \
    \          |\n   |      |                                 |                  \
    \        |\n   | 408  | Request Timeout                 | all                \
    \      |\n   |      |                                 |                      \
    \    |\n   | 410  | Gone                            | all                    \
    \  |\n   |      |                                 |                          |\n\
    \   | 412  | Precondition Failed             | DESCRIBE, SETUP          |\n  \
    \ |      |                                 |                          |\n   |\
    \ 413  | Request Message Body Too Large  | all                      |\n   |  \
    \    |                                 |                          |\n   | 414\
    \  | Request-URI Too Long            | all                      |\n   |      |\
    \                                 |                          |\n   | 415  | Unsupported\
    \ Media Type          | all                      |\n   |      |              \
    \                   |                          |\n   | 451  | Parameter Not Understood\
    \        | SET_PARAMETER,           |\n   |      |                           \
    \      | GET_PARAMETER            |\n   |      |                             \
    \    |                          |\n   | 452  | reserved                      \
    \  | n/a                      |\n   |      |                                 |\
    \                          |\n   | 453  | Not Enough Bandwidth            | SETUP\
    \                    |\n   |      |                                 |        \
    \                  |\n   | 454  | Session Not Found               | all      \
    \                |\n   |      |                                 |            \
    \              |\n   | 455  | Method Not Valid in This State  | all          \
    \            |\n   |      |                                 |                \
    \          |\n   | 456  | Header Field Not Valid for      | all              \
    \        |\n   |      | Resource                        |                    \
    \      |\n   |      |                                 |                      \
    \    |\n   | 457  | Invalid Range                   | PLAY, PAUSE            \
    \  |\n   |      |                                 |                          |\n\
    \   | 458  | Parameter Is Read-Only          | SET_PARAMETER            |\n  \
    \ |      |                                 |                          |\n   |\
    \ 459  | Aggregate Operation Not Allowed | all                      |\n   |  \
    \    |                                 |                          |\n   | 460\
    \  | Only Aggregate Operation        | all                      |\n   |      |\
    \ Allowed                         |                          |\n   |      |  \
    \                               |                          |\n   | 461  | Unsupported\
    \ Transport           | all                      |\n   |      |              \
    \                   |                          |\n   | 462  | Destination Unreachable\
    \         | all                      |\n   |      |                          \
    \       |                          |\n   | 463  | Destination Prohibited     \
    \     | SETUP                    |\n   |      |                              \
    \   |                          |\n   | 464  | Data Transport Not Ready Yet   \
    \ | PLAY                     |\n   |      |                                 |\
    \                          |\n   | 465  | Notification Reason Unknown     | PLAY_NOTIFY\
    \              |\n   |      |                                 |              \
    \            |\n   | 466  | Key Management Error            | all            \
    \          |\n   |      |                                 |                  \
    \        |\n   | 470  | Connection Authorization        | all                \
    \      |\n   |      | Required                        |                      \
    \    |\n   |      |                                 |                        \
    \  |\n   | 471  | Connection Credentials Not      | all                      |\n\
    \   |      | Accepted                        |                          |\n  \
    \ |      |                                 |                          |\n   |\
    \ 472  | Failure to Establish Secure     | all                      |\n   |  \
    \    | Connection                      |                          |\n   |    \
    \  |                                 |                          |\n   | 500  |\
    \ Internal Server Error           | all                      |\n   |      |  \
    \                               |                          |\n   | 501  | Not\
    \ Implemented                 | all                      |\n   |      |      \
    \                           |                          |\n   | 502  | Bad Gateway\
    \                     | all                      |\n   |      |              \
    \                   |                          |\n   | 503  | Service Unavailable\
    \             | all                      |\n   |      |                      \
    \           |                          |\n   | 504  | Gateway Timeout        \
    \         | all                      |\n   |      |                          \
    \       |                          |\n   | 505  | RTSP Version Not Supported \
    \     | all                      |\n   |      |                              \
    \   |                          |\n   | 551  | Option Not Supported           \
    \ | all                      |\n   |      |                                 |\
    \                          |\n   | 553  | Proxy Unavailable               | all\
    \                      |\n   +------+---------------------------------+--------------------------+\n\
    \          Table 4: Status Codes and Their Usage with RTSP Methods\n"
- title: 8.2.  Response Headers
  contents:
  - "8.2.  Response Headers\n   The response-headers allow the request recipient to\
    \ pass additional\n   information about the response that cannot be placed in\
    \ the Status-\n   Line.  This header gives information about the server and about\n\
    \   further access to the resource identified by the Request-URI.  All\n   headers\
    \ currently classified as response-headers are listed in\n   Table 5.\n      \
    \          +------------------------+----------------+\n                | Header\
    \                 | Defined in     |\n                +------------------------+----------------+\n\
    \                | Authentication-Info    | Section 18.7   |\n               \
    \ |                        |                |\n                | Connection-Credentials\
    \ | Section 18.13  |\n                |                        |             \
    \   |\n                | Location               | Section 18.28  |\n         \
    \       |                        |                |\n                | MTag  \
    \                 | Section 18.31  |\n                |                      \
    \  |                |\n                | Proxy-Authenticate     | Section 18.34\
    \  |\n                |                        |                |\n          \
    \      | Public                 | Section 18.39  |\n                |        \
    \                |                |\n                | Retry-After           \
    \ | Section 18.44  |\n                |                        |             \
    \   |\n                | Unsupported            | Section 18.55  |\n         \
    \       |                        |                |\n                | WWW-Authenticate\
    \       | Section 18.58  |\n                +------------------------+----------------+\n\
    \                    Table 5: The RTSP Response Headers\n   Response-header names\
    \ can be extended reliably only in combination\n   with a change in the protocol\
    \ version.  However, the usage of feature\n   tags in the request allows the responding\
    \ party to learn the\n   capability of the receiver of the response.  A new or\
    \ experimental\n   header can be given the semantics of response-header if all\
    \ parties\n   in the communication recognize them to be a response-header.\n \
    \  Unrecognized headers in responses MUST be ignored.\n"
- title: 9.  Message Body
  contents:
  - "9.  Message Body\n   Some request and response messages include a message body,\
    \ if not\n   otherwise restricted by the request method or response status code.\n\
    \   The message body consists of the content data itself (see also\n   Section\
    \ 5.3).\n   The SET_PARAMETER and GET_PARAMETER requests and responses, and the\n\
    \   DESCRIBE response as defined by this specification, can have a\n   message\
    \ body; the purpose of the message body is defined in each\n   case.  All 4xx\
    \ and 5xx responses MAY also have a message body to\n   carry additional response\
    \ information.  Generally, a message body MAY\n   be attached to any RTSP 2.0\
    \ request or response, but the content of\n   the message body MAY be ignored\
    \ by the receiver.  Extensions to this\n   specification can specify the purpose\
    \ and content of message bodies,\n   including requiring their inclusion.\n  \
    \ In this section, both sender and recipient refer to either the client\n   or\
    \ the server, depending on who sends and who receives the message\n   body.\n"
- title: 9.1.  Message Body Header Fields
  contents:
  - "9.1.  Message Body Header Fields\n   Message body header fields define meta-information\
    \ about the content\n   data in the message body.  The message body header fields\
    \ are listed\n   in Table 6.\n                   +------------------+----------------+\n\
    \                   | Header           | Defined in     |\n                  \
    \ +------------------+----------------+\n                   | Allow          \
    \  | Section 18.6   |\n                   |                  |               \
    \ |\n                   | Content-Base     | Section 18.14  |\n              \
    \     |                  |                |\n                   | Content-Encoding\
    \ | Section 18.15  |\n                   |                  |                |\n\
    \                   | Content-Language | Section 18.16  |\n                  \
    \ |                  |                |\n                   | Content-Length \
    \  | Section 18.17  |\n                   |                  |               \
    \ |\n                   | Content-Location | Section 18.18  |\n              \
    \     |                  |                |\n                   | Content-Type\
    \     | Section 18.19  |\n                   |                  |            \
    \    |\n                   | Expires          | Section 18.22  |\n           \
    \        |                  |                |\n                   | Last-Modified\
    \    | Section 18.27  |\n                   +------------------+----------------+\n\
    \                  Table 6: The RTSP Message Body Headers\n   The extension-header\
    \ mechanism allows additional message body header\n   fields to be defined without\
    \ changing the protocol, but these fields\n   cannot be assumed to be recognizable\
    \ by the recipient.  Unrecognized\n   header fields MUST be ignored by the recipient\
    \ and forwarded by\n   proxies.\n"
- title: 9.2.  Message Body
  contents:
  - "9.2.  Message Body\n   An RTSP message with a message body MUST include the Content-Type\
    \ and\n   Content-Length headers.  When a message body is included with a\n  \
    \ message, the data type of that content data is determined via the\n   Content-Type\
    \ and Content-Encoding header fields.\n   Content-Type specifies the media type\
    \ of the underlying data.  There\n   is no default media format and the actual\
    \ format used in the body is\n   required to be explicitly stated in the Content-Type\
    \ header.  By\n   being explicit and always requiring the inclusion of the Content-Type\n\
    \   header with accurate information, one avoids the many pitfalls in a\n   heuristic-based\
    \ interpretation of the body content.  The user\n   experience of HTTP and email\
    \ have suffered from relying on such\n   heuristics.\n   Content-Encoding may\
    \ be used to indicate any additional content-\n   codings applied to the data,\
    \ usually for the purpose of data\n   compression, that are a property of the\
    \ requested resource.  The\n   default encoding is 'identity', i.e. no transformation\
    \ of the message\n   body.\n   The Content-Length of a message is the length of\
    \ the content,\n   measured in octets.\n"
- title: 9.3.  Message Body Format Negotiation
  contents:
  - "9.3.  Message Body Format Negotiation\n   The content format of the message body\
    \ is provided using the Content-\n   Type header (Section 18.19).  To enable the\
    \ responder of a request to\n   determine which media type it should use, the\
    \ requester may include\n   the Accept header (Section 18.1) in a request to identify\
    \ supported\n   media types or media type ranges suitable to the response.  In\
    \ case\n   the responder is not supporting any of the specified formats, then\n\
    \   the request response will be a 406 (Not Acceptable) error code.\n   The media\
    \ types that may be used on requests with message bodies need\n   to be determined\
    \ through the use of feature tags, specification\n   requirement, or trial and\
    \ error.  Trial and error works because when\n   the responder does not support\
    \ the media type of the message body, it\n   will respond with a 415 (Unsupported\
    \ Media Type).\n   The formats supported and their negotiation is done individually\
    \ on a\n   per method and direction (request or response body) direction.\n  \
    \ Requirements on supporting particular media types for use as message\n   bodies\
    \ in requests and response SHALL also be specified on a per-\n   method and per-direction\
    \ basis.\n"
- title: 10.  Connections
  contents:
  - "10.  Connections\n   RTSP messages are transferred between RTSP agents and proxies\
    \ using a\n   transport connection.  This transport connection uses TCP or TCP/TLS.\n\
    \   This transport connection is referred to as the \"connection\" or \"RTSP\n\
    \   connection\" within this document.\n   RTSP requests can be transmitted using\
    \ the two different connection\n   scenarios listed below:\n   o  persistent -\
    \ a transport connection is used for several request/\n      response transactions;\n\
    \   o  transient - a transport connection is used for each single\n      request/response\
    \ transaction.\n   RFC 2326 attempted to specify an optional mechanism for transmitting\n\
    \   RTSP messages in connectionless mode over a transport protocol such\n   as\
    \ UDP.  However, it was not specified in sufficient detail to allow\n   for interoperable\
    \ implementations.  In an attempt to reduce\n   complexity and scope, and due\
    \ to lack of interest, RTSP 2.0 does not\n   attempt to define a mechanism for\
    \ supporting RTSP over UDP or other\n   connectionless transport protocols.  A\
    \ side effect of this is that\n   RTSP requests MUST NOT be sent to multicast\
    \ groups since no\n   connection can be established with a specific receiver in\
    \ multicast\n   environments.\n   Certain RTSP headers, such as the CSeq header\
    \ (Section 18.20), which\n   may appear to be relevant only to connectionless\
    \ transport scenarios,\n   are still retained and MUST be implemented according\
    \ to this\n   specification.  In the case of CSeq, it is quite useful for matching\n\
    \   responses to requests if the requests are pipelined (see Section 12).\n  \
    \ It is also useful in proxies for keeping track of the different\n   requests\
    \ when aggregating several client requests on a single TCP\n   connection.\n"
- title: 10.1.  Reliability and Acknowledgements
  contents:
  - "10.1.  Reliability and Acknowledgements\n   Since RTSP messages are transmitted\
    \ using reliable transport\n   protocols, they MUST NOT be retransmitted at the\
    \ RTSP level.\n   Instead, the implementation must rely on the underlying transport\
    \ to\n   provide reliability.  The RTSP implementation may use any indication\n\
    \   of reception acknowledgment of the message from the underlying\n   transport\
    \ protocols to optimize the RTSP behavior.\n      If both the underlying reliable\
    \ transport, such as TCP, and the\n      RTSP application retransmit requests,\
    \ each packet loss or message\n      loss may result in two retransmissions. \
    \ The receiver typically\n      cannot take advantage of the application-layer\
    \ retransmission\n      since the transport stack will not deliver the application-layer\n\
    \      retransmission before the first attempt has reached the receiver.\n   \
    \   If the packet loss is caused by congestion, multiple\n      retransmissions\
    \ at different layers will exacerbate the\n      congestion.\n   Lack of acknowledgment\
    \ of an RTSP request should be handled within\n   the constraints of the connection\
    \ timeout considerations described\n   below (Section 10.4).\n"
- title: 10.2.  Using Connections
  contents:
  - "10.2.  Using Connections\n   A TCP transport can be used for both persistent\
    \ connections (for\n   several message exchanges) and transient connections (for\
    \ a single\n   message exchange).  Implementations of this specification MUST\n\
    \   support RTSP over TCP.  The scheme of the RTSP URI (Section 4.2)\n   allows\
    \ the client to specify the port it will contact the server on,\n   and defines\
    \ the default port to use if one is not explicitly given.\n   In addition to the\
    \ registered default ports, i.e., 554 (rtsp) and 322\n   (rtsps), there is an\
    \ alternative port 8554 registered.  This port may\n   provide some benefits over\
    \ non-registered ports if an RTSP server is\n   unable to use the default ports.\
    \  The benefits may include\n   preconfigured security policies as well as classifiers\
    \ in network\n   monitoring tools.\n   An RTSP client opening a TCP connection\
    \ to access a particular\n   resource as identified by a URI uses the IP address\
    \ and port derived\n   from the host and port parts of the URI.  The IP address\
    \ is either\n   the explicit address provided in the URI or any of the addresses\n\
    \   provided when performing A and AAAA record DNS lookups of the\n   hostname\
    \ in the URI.\n   A server MUST handle both persistent and transient connections.\n\
    \      Transient connections facilitate mechanisms for fault tolerance.\n    \
    \  They also allow for application-layer mobility.  A server-and-\n      client\
    \ pair that supports transient connections can survive the\n      loss of a TCP\
    \ connection; e.g., due to a NAT timeout.  When the\n      client has discovered\
    \ that the TCP connection has been lost, it\n      can set up a new one when there\
    \ is need to communicate again.\n   A persistent connection is RECOMMENDED to\
    \ be used for all\n   transactions between the server and client, including messages\
    \ for\n   multiple RTSP sessions.  However, a persistent connection MAY be\n \
    \  closed after a few message exchanges.  For example, a client may use\n   a\
    \ persistent connection for the initial SETUP and PLAY message\n   exchanges in\
    \ a session and then close the connection.  Later, when\n   the client wishes\
    \ to send a new request, such as a PAUSE for the\n   session, a new connection\
    \ would be opened.  This connection may be\n   either transient or persistent.\n\
    \   An RTSP agent MAY use one connection to handle multiple RTSP sessions\n  \
    \ on the same server.  The RTSP agent SHALL NOT use more than one\n   connection\
    \ per RTSP session at any given point.\n      Having only one connection in use\
    \ at any time avoids confusion\n      regarding on which connection any server-to-client\
    \ requests shall\n      be sent.  Using a single connection for multiple RTSP\
    \ sessions\n      also saves complexity by enabling the server to maintain less\n\
    \      state about its connection resources on the server.  Not using\n      more\
    \ than one connection at a time for a particular RTSP session\n      avoids wasting\
    \ connection resources and allows the server to track\n      only the most recently\
    \ used client-to-server connection for each\n      RTSP session as being the currently\
    \ valid server-to-client\n      connection.\n   RTSP allows a server to send requests\
    \ to a client.  However, this can\n   be supported only if a client establishes\
    \ a persistent connection\n   with the server.  In cases where a persistent connection\
    \ does not\n   exist between a server and its client, due to the lack of a signaling\n\
    \   channel, the server may be forced to silently discard RTSP messages,\n   and\
    \ it may even drop an RTSP session without notifying the client.\n   An example\
    \ of such a case is when the server desires to send a\n   REDIRECT request for\
    \ an RTSP session to the client but is not able to\n   do so because it cannot\
    \ reach the client.  A server that attempts to\n   send a request to a client\
    \ that has no connection currently to the\n   server SHALL discard the request.\n\
    \      Without a persistent connection between the client and the server,\n  \
    \    the media server has no reliable way of reaching the client.\n      Because\
    \ of the likely failure of server-to-client established\n      connections, the\
    \ server will not even attempt establishing any\n      connection.\n      Queuing\
    \ of server-to-client requests has been considered.\n      However, a security\
    \ issue exists as to how it might be possible to\n      authorize a client establishing\
    \ a new connection as being a\n      legitimate receiver of a request related\
    \ to a particular RTSP\n      session, without the client first issuing requests\
    \ related to the\n      pending request.  Thus, it would be likely to make any\
    \ such\n      requests even more delayed and less useful.\n   The sending of client\
    \ and server requests can be asynchronous events.\n   To avoid deadlock situations,\
    \ both client and server MUST be able to\n   send and receive requests simultaneously.\
    \  As an RTSP response may be\n   queued up for transmission, reception or processing\
    \ behind the peer\n   RTSP agent's own requests, all RTSP agents are required\
    \ to have a\n   certain capability of handling outstanding messages.  A potential\n\
    \   issue is that outstanding requests may time out despite being\n   processed\
    \ by the peer; this can be due to the response being caught\n   in the queue behind\
    \ a number of requests that the RTSP agent is\n   processing but that take some\
    \ time to complete.  To avoid this\n   problem, an RTSP agent should buffer incoming\
    \ messages locally so\n   that any response messages can be processed immediately\
    \ upon\n   reception.  If responses are separated from requests and directly\n\
    \   forwarded for processing, not only can the result be used\n   immediately,\
    \ the state associated with that outstanding request can\n   also be released.\
    \  However, buffering a number of requests on the\n   receiving RTSP agent consumes\
    \ resources and enables a resource\n   exhaustion attack on the agent.  Therefore,\
    \ this buffer should be\n   limited so that an unreasonable number of requests\
    \ or total message\n   size is not allowed to consume the receiving agent's resources.\
    \  In\n   most APIs, having the receiving agent stop reading from the TCP\n  \
    \ socket will result in TCP's window being clamped, thus forcing the\n   buffering\
    \ onto the sending agent when the load is larger than\n   expected.  However,\
    \ as both RTSP message sizes and frequency may be\n   changed in the future by\
    \ protocol extensions, an agent should be\n   careful about taking harsher measurements\
    \ against a potential attack.\n   When under attack, an RTSP agent can close TCP\
    \ connections and\n   release state associated with that TCP connection.\n   To\
    \ provide some guidance on what is reasonable, the following\n   guidelines are\
    \ given.  It is RECOMMENDED that:\n   o  an RTSP agent should not have more than\
    \ 10 outstanding requests\n      per RTSP session;\n   o  an RTSP agent should\
    \ not have more than 10 outstanding requests\n      that are not related to an\
    \ RTSP session or that are requesting to\n      create an RTSP session.\n   In\
    \ light of the above, it is RECOMMENDED that clients use persistent\n   connections\
    \ whenever possible.  A client that supports persistent\n   connections MAY \"\
    pipeline\" its requests (see Section 12).\n   RTSP agents can send requests to\
    \ multiple different destinations,\n   either server or client contexts over the\
    \ same connection to a proxy.\n   Then, the proxy forks the message to the different\
    \ destinations over\n   proxy-to-agent connections.  In these cases when multiple\
    \ requests\n   are outstanding, the requesting agent MUST be ready to receive\
    \ the\n   responses out of order compared to the order they where sent on the\n\
    \   connection.  The order between multiple messages for each destination\n  \
    \ will be maintained; however, the order between response from\n   different destinations\
    \ can be different.\n      The reason for this is to avoid a head-of-line blocking\
    \ situation.\n      In a sequence of requests, an early outstanding request may\
    \ take\n      time to be processed at one destination.  Simultaneously, a\n  \
    \    response from any other destination that was later in the sequence\n    \
    \  of requests may have arrived at the proxy; thus, allowing out-of-\n      order\
    \ responses avoids forcing the proxy to buffer this response\n      and instead\
    \ deliver it as soon as possible.  Note, this will not\n      affect the order\
    \ in which the messages sent to each separate\n      destination were processed\
    \ at the request destination.\n   This scenario can occur in two cases involving\
    \ proxies.  The first is\n   a client issuing requests for sessions on different\
    \ servers using a\n   common client-to-proxy connection.  The second is for server-to-\n\
    \   client requests, like REDIRECT being sent by the server over a common\n  \
    \ transport connection the proxy created for its different connecting\n   clients.\n"
- title: 10.3.  Closing Connections
  contents:
  - "10.3.  Closing Connections\n   The client MAY close a connection at any point\
    \ when no outstanding\n   request/response transactions exist for any RTSP session\
    \ being\n   managed through the connection.  The server, however, SHOULD NOT\n\
    \   close a connection until all RTSP sessions being managed through the\n   connection\
    \ have been timed out (Section 18.49).  A server SHOULD NOT\n   close a connection\
    \ immediately after responding to a session-level\n   TEARDOWN request for the\
    \ last RTSP session being controlled through\n   the connection.  Instead, the\
    \ server should wait for a reasonable\n   amount of time for the client to receive\
    \ and act upon the TEARDOWN\n   response and then initiate the connection closing.\
    \  The server SHOULD\n   wait at least 10 seconds after sending the TEARDOWN response\
    \ before\n   closing the connection.\n      This is to ensure that the client\
    \ has time to issue a SETUP for a\n      new session on the existing connection\
    \ after having torn the last\n      one down.  Ten seconds should give the client\
    \ ample opportunity to\n      get its message to the server.\n   A server SHOULD\
    \ NOT close the connection directly as a result of\n   responding to a request\
    \ with an error code.\n      Certain error responses such as 460 (Only Aggregate\
    \ Operation\n      Allowed) (Section 17.4.24) are used for negotiating capabilities\n\
    \      of a server with respect to content or other factors.  In such\n      cases,\
    \ it is inefficient for the server to close a connection on\n      an error response.\
    \  Also, such behavior would prevent\n      implementation of advanced or special\
    \ types of requests or result\n      in extra overhead for the client when testing\
    \ for new features.\n      On the other hand, keeping connections open after sending\
    \ an error\n      response poses a Denial-of-Service (DoS) security risk\n   \
    \   (Section 21).\n   The server MAY close a connection if it receives an incomplete\n\
    \   message and if the message is not completed within a reasonable\n   amount\
    \ of time.  It is RECOMMENDED that the server wait at least 10\n   seconds for\
    \ the completion of a message or for the next part of the\n   message to arrive\
    \ (which is an indication that the transport and the\n   client are still alive).\
    \  Servers believing they are under attack or\n   that are otherwise starved for\
    \ resources during that event MAY\n   consider using a shorter timeout.\n   If\
    \ a server closes a connection while the client is attempting to\n   send a new\
    \ request, the client will have to close its current\n   connection, establish\
    \ a new connection, and send its request over the\n   new connection.\n   An RTSP\
    \ message SHOULD NOT be terminated by closing the connection.\n   Such a message\
    \ MAY be considered to be incomplete by the receiver and\n   discarded.  An RTSP\
    \ message is properly terminated as defined in\n   Section 5.\n"
- title: 10.4.  Timing Out Connections and RTSP Messages
  contents:
  - "10.4.  Timing Out Connections and RTSP Messages\n   Receivers of a request (responders)\
    \ SHOULD respond to requests in a\n   timely manner even when a reliable transport\
    \ such as TCP is used.\n   Similarly, the sender of a request (requester) SHOULD\
    \ wait for a\n   sufficient time for a response before concluding that the responder\n\
    \   will not be acting upon its request.\n   A responder SHOULD respond to all\
    \ requests within 5 seconds.  If the\n   responder recognizes that the processing\
    \ of a request will take\n   longer than 5 seconds, it SHOULD send a 100 (Continue)\
    \ response as\n   soon as possible.  It SHOULD continue sending a 100 response\
    \ every 5\n   seconds thereafter until it is ready to send the final response\
    \ to\n   the requester.  After sending a 100 response, the responder MUST send\n\
    \   a final response indicating the success or failure of the request.\n   A requester\
    \ SHOULD wait at least 10 seconds for a response before\n   concluding that the\
    \ responder will not be responding to its request.\n   After receiving a 100 response,\
    \ the requester SHOULD continue waiting\n   for further responses.  If more than\
    \ 10 seconds elapse without\n   receiving any response, the requester MAY assume\
    \ that the responder\n   is unresponsive and abort the connection by closing the\
    \ TCP\n   connection.\n   In some cases, multiple RTSP sessions share the same\
    \ transport\n   connection; abandoning a request and closing the connection may\
    \ have\n   significant impact on those other sessions.  First of all, other RTSP\n\
    \   requests may have become queued up due to the request taking a long\n   time\
    \ to process.  Secondly, those sessions also lose the possibility\n   to receive\
    \ server-to-client requests.  To mitigate that situation,\n   the RTSP client\
    \ or server SHOULD establish a new connection and send\n   any requests that are\
    \ queued up or that haven't received a response\n   on this new connection.  Thirdly,\
    \ to ensure that the RTSP server\n   knows which connection is valid for a particular\
    \ RTSP session, the\n   RTSP agent SHOULD send a keep-alive request, if no other\
    \ request will\n   be sent immediately for that RTSP session, for each RTSP session\
    \ on\n   the old connection.  The keep-alive request will normally be a\n   SET_PARAMETER\
    \ with a session header to inform the server that this\n   agent cares about this\
    \ RTSP session.\n   A requester SHOULD wait longer than 10 seconds for a response\
    \ if it\n   is experiencing significant transport delays on its connection to\
    \ the\n   responder.  The requester is capable of determining the Round-Trip\n\
    \   Time (RTT) of the request/response cycle using the Timestamp header\n   (Section\
    \ 18.53) in any RTSP request.\n      The 10-second wait was chosen for the following\
    \ reasons.  It gives\n      TCP time to perform a couple of retransmissions, even\
    \ if operating\n      on default values.  It is short enough that users may not\
    \ abandon\n      the process themselves.  However, it should be noted that 10\n\
    \      seconds can be aggressive on certain types of networks.  The\n      5-second\
    \ value for 1xx messages is half the timeout giving a\n      reasonable chance\
    \ of successful delivery before timeout happens on\n      the requester side.\n"
- title: 10.5.  Showing Liveness
  contents:
  - "10.5.  Showing Liveness\n   RTSP requires the client to periodically show its\
    \ liveness to the\n   server or the server may terminate any session state.  Several\n\
    \   different protocol mechanism include in their usage a liveness proof\n   from\
    \ the client.  These mechanisms are RTSP requests with a Session\n   header to\
    \ the server; if RTP & RTCP is used for media data transport\n   and the transport\
    \ is established, the RTCP message proves liveness;\n   or through any other used\
    \ media-transport protocol capable of\n   indicating liveness of the RTSP client.\
    \  It is RECOMMENDED that a\n   client not wait to the last second of the timeout\
    \ before trying to\n   send a liveness message.  The RTSP message may take some\
    \ time to\n   arrive safely at the receiver, due to packet loss and TCP\n   retransmissions.\
    \  To show liveness between RTSP requests being issued\n   to accomplish other\
    \ things, the following mechanisms can be used, in\n   descending order of preference:\n\
    \   RTCP: If RTP is used for media transport, RTCP SHOULD be used.  If\n     \
    \    RTCP is used to report transport statistics, it will\n         necessarily\
    \ also function as a keep-alive.  The server can\n         determine the client\
    \ by network address and port together with\n         the fact that the client\
    \ is reporting on the server's RTP\n         sender sources (synchronization source\
    \ (SSRCs)).  A downside of\n         using RTCP is that it only gives statistical\
    \ guarantees of\n         reaching the server.  However, the probability of a\
    \ false\n         client timeout is so low that it can be ignored in most cases.\n\
    \         For example, assume a session with a 60-second timeout and\n       \
    \  enough bitrate assigned to RTCP messages to send a message from\n         client\
    \ to server on average every 5 seconds.  That client has,\n         for a network\
    \ with 5% packet loss, a probability of failing to\n         confirm liveness\
    \ within the timeout interval for that session\n         of 2.4*E-16.  Sessions\
    \ with shorter timeouts, much higher\n         packet loss, or small RTCP bandwidths\
    \ SHOULD also implement one\n         or more of the mechanisms below.\n   SET_PARAMETER:\
    \  When using SET_PARAMETER for keep-alives, a body\n         SHOULD NOT be included.\
    \  This method is the RECOMMENDED RTSP\n         method to use for a request intended\
    \ only to perform keep-\n         alives.  RTSP servers MUST support the SET_PARAMETER\
    \ method, so\n         that clients can always use this mechanism.\n   GET_PARAMETER:\
    \  When using GET_PARAMETER for keep-alives, a body\n         SHOULD NOT be included,\
    \ dependent on implementation support in\n         the server.  Use the OPTIONS\
    \ method to determine if there is\n         method support or simply try.\n  \
    \ OPTIONS:  This method is also usable, but it causes the server to\n        \
    \ perform more unnecessary processing and results in bigger\n         responses\
    \ than necessary for the task.  The reason is that the\n         server needs\
    \ to determine the capabilities associated with the\n         media resource to\
    \ correctly populate the Public and Allow\n         headers.\n   The timeout parameter\
    \ of the Session header (Section 18.49) MAY be\n   included in a SETUP response\
    \ and MUST NOT be included in requests.\n   The server uses it to indicate to\
    \ the client how long the server is\n   prepared to wait between RTSP commands\
    \ or other signs of life before\n   closing the session due to lack of activity\
    \ (see Appendix B).  The\n   timeout is measured in seconds, with a default of\
    \ 60 seconds.  The\n   length of the session timeout MUST NOT be changed in an\
    \ established\n   session.\n"
- title: 10.6.  Use of IPv6
  contents:
  - "10.6.  Use of IPv6\n   Explicit IPv6 [RFC2460] support was not present in RTSP\
    \ 1.0.  RTSP\n   2.0 has been updated for explicit IPv6 support.  Implementations\
    \ of\n   RTSP 2.0 MUST understand literal IPv6 addresses in URIs and RTSP\n  \
    \ headers.  Although the general URI format envisages potential future\n   new\
    \ versions of the literal IP address, usage of any such new version\n   would\
    \ require other modifications to the RTSP specification (e.g.,\n   address fields\
    \ in the Transport header (Section 18.54)).\n"
- title: 10.7.  Overload Control
  contents:
  - "10.7.  Overload Control\n   Overload in RTSP can occur when servers and proxies\
    \ have insufficient\n   resources to complete the processing of a request.  An\
    \ improper\n   handling of such an overload situation at proxies and servers can\n\
    \   impact the operation of the RTSP deployment, and probably worsen the\n   situation.\
    \  RTSP defines the 503 (Service Unavailable) response\n   (Section 17.5.4) to\
    \ let servers and proxies notify requesting proxies\n   and RTSP clients about\
    \ an overload situation.  In conjunction with\n   the Retry-After header (Section\
    \ 18.44), the server or proxy can\n   indicate the time after which the requesting\
    \ entity can send another\n   request to the proxy or server.\n   There are two\
    \ scopes of such 503 answers.  The first scope is for an\n   established RTSP\
    \ session, where the request resulting in the 503\n   response as well as the\
    \ response itself carries a Session header\n   identifying the session that is\
    \ suffering overload.  This response\n   only applies to this particular session.\
    \  The other scope is the\n   general RTSP server as identified by the host in\
    \ the Request-URI.\n   Such a 503 answer with any Retry-After header applies to\
    \ all requests\n   that are not session specific to that server, including a SETUP\n\
    \   request intended to create a new RTSP session.\n   Another scope for overload\
    \ situations exists: the RTSP proxy.  To\n   enable an RTSP proxy to signal that\
    \ it is overloaded, or otherwise\n   unavailable and unable to handle the request,\
    \ a 553 response code has\n   been defined with the meaning \"Proxy Unavailable\"\
    .  As with servers,\n   there is a separation in response scopes between requests\
    \ associated\n   with existing RTSP sessions and requests to create new sessions\
    \ or\n   general proxy requests.\n   Simply implementing and using the 503 (Service\
    \ Unavailable) and 553\n   (Proxy Unavailable) response codes is not sufficient\
    \ for properly\n   handling overload situations.  For instance, a simplistic approach\n\
    \   would be to send the 503 response with a Retry-After header set to a\n   fixed\
    \ value.  However, this can cause a situation in which multiple\n   RTSP clients\
    \ again send requests to a proxy or server at roughly the\n   same time, which\
    \ may again cause an overload situation.  Another\n   situation would be if the\
    \ \"old\" overload situation is not yet\n   resolved, i.e., the length indicated\
    \ in the Retry-After header was\n   too short for the overload situation to subside.\n\
    \   An RTSP server or proxy in an overload situation must select the\n   value\
    \ of the Retry-After header carefully, bearing in mind its\n   current load situation.\
    \  It is REQUIRED to increase the timeout\n   period in proportion to the current\
    \ load on the server, i.e., an\n   increasing workload should result in an increased\
    \ length of the\n   indicated unavailability.  It is REQUIRED not to send the\
    \ same value\n   in the Retry-After header to all requesting proxies and clients,\
    \ but\n   to add a variation to the mean value of the Retry-After header.\n  \
    \ A more complex case may arise when a load-balancing RTSP proxy is in\n   use.\
    \  This is the case when an RTSP proxy is used to select amongst a\n   set of\
    \ RTSP servers to handle the requests or when multiple server\n   addresses are\
    \ available for a given server name.  The proxy or client\n   may receive a 503\
    \ (Service Unavailable) or 553 (Proxy Unavailable)\n   response code from one\
    \ of its RTSP servers or proxies, or a TCP\n   timeout (if the server is even\
    \ unable to handle the request message).\n   The proxy or client simply retries\
    \ the other addresses or configured\n   proxies, but it may also receive a 503\
    \ (Service Unavailable) or 553\n   (Proxy Unavailable) response or TCP timeouts\
    \ from those addresses.\n   In such a situation, where none of the RTSP servers/proxies/addresses\n\
    \   can handle the request, the RTSP agent has to wait before it can send\n  \
    \ any new requests to the RTSP server.  Any additional request to a\n   specific\
    \ address MUST be delayed according to the Retry-After headers\n   received. \
    \ For addresses where no response was received or TCP\n   timeout occurred, an\
    \ initial wait timer SHOULD be set to 5 seconds.\n   That timer MUST be doubled\
    \ for each additional failure to connect or\n   receive response until the value\
    \ exceeds 30 minutes when the timer's\n   mean value may be set to 30 minutes.\
    \  It is REQUIRED not to set the\n   same value in the timer for each scheduling,\
    \ but instead to add a\n   variation to the mean value, resulting in picking a\
    \ random value\n   within the range of 0.5 to 1.5 times the mean value.\n"
- title: 11.  Capability Handling
  contents:
  - "11.  Capability Handling\n   This section describes the available capability-handling\
    \ mechanism\n   that allows RTSP to be extended.  Extensions to this version of\
    \ the\n   protocol are basically done in two ways.  Firstly, new headers can be\n\
    \   added.  Secondly, new methods can be added.  The capability-handling\n   mechanism\
    \ is designed to handle both cases.\n   When a method is added, the involved parties\
    \ can use the OPTIONS\n   method to discover whether it is supported.  This is\
    \ done by issuing\n   an OPTIONS request to the other party.  Depending on the\
    \ URI, it will\n   either apply in regard to a certain media resource, the whole\
    \ server\n   in general, or simply the next hop.  The OPTIONS response MUST\n\
    \   contain a Public header that declares all methods supported for the\n   indicated\
    \ resource.\n   It is not necessary to use OPTIONS to discover support of a method,\n\
    \   as the client could simply try the method.  If the receiver of the\n   request\
    \ does not support the method, it will respond with an error\n   code indicating\
    \ the method is either not implemented (501) or does\n   not apply for the resource\
    \ (405).  The choice between the two\n   discovery methods depends on the requirements\
    \ of the service.\n   Feature tags are defined to handle functionality additions\
    \ that are\n   not new methods.  Each feature tag represents a certain block of\n\
    \   functionality.  The amount of functionality that a feature tag\n   represents\
    \ can vary significantly.  For example, a feature tag can\n   represent the functionality\
    \ a single RTSP header provides.  Another\n   feature tag can represent much more\
    \ functionality, such as the\n   \"play.basic\" feature tag (Section 11.1), which\
    \ represents the minimal\n   media delivery for playback implementation.\n   Feature\
    \ tags are used to determine whether the client, server, or\n   proxy supports\
    \ the functionality that is necessary to achieve the\n   desired service.  To\
    \ determine support of a feature tag, several\n   different headers can be used,\
    \ each explained below:\n   Supported:  This header is used to determine the complete\
    \ set of\n         functionality that both client and server have, in general,\
    \ and\n         is not dependent on a specific resource.  The intended usage is\n\
    \         to determine before one needs to use a functionality that it is\n  \
    \       supported.  It can be used in any method, but OPTIONS is the\n       \
    \  most suitable as it simultaneously determines all methods that\n         are\
    \ implemented.  When sending a request, the requester\n         declares all its\
    \ capabilities by including all supported\n         feature tags.  This results\
    \ in the receiver learning the\n         requester's feature support.  The receiver\
    \ then includes its\n         set of features in the response.\n   Proxy-Supported:\
    \  This header is used in a similar fashion as the\n         Supported header,\
    \ but instead of giving the supported\n         functionality of the client or\
    \ server, it provides both the\n         requester and the responder a view of\
    \ the common functionality\n         supported in general by all members of the\
    \ proxy chain between\n         the client and server; it does not depend on the\
    \ resource.\n         Proxies are required to add this header whenever the Supported\n\
    \         header is present, but proxies may also add it independently of\n  \
    \       the requester.\n   Require:  This header can be included in any request\
    \ where the\n         endpoint, i.e., the client or server, is required to understand\n\
    \         the feature to correctly perform the request.  This can, for\n     \
    \    example, be a SETUP request, where the server is required to\n         understand\
    \ a certain parameter to be able to set up the media\n         delivery correctly.\
    \  Ignoring this parameter would not have the\n         desired effect and is\
    \ not acceptable.  Therefore, the endpoint\n         receiving a request containing\
    \ a Require MUST negatively\n         acknowledge any feature that it does not\
    \ understand and not\n         perform the request.  The response in cases where\
    \ features are\n         not supported is 551 (Option Not Supported).  Also, the\n\
    \         features that are not supported are given in the Unsupported\n     \
    \    header in the response.\n   Proxy-Require:  This header has the same purpose\
    \ and behavior as\n         Require except that it only applies to proxies and\
    \ not the\n         endpoint.  Features that need to be supported by both proxies\n\
    \         and endpoints need to be included in both the Require and\n        \
    \ Proxy-Require header.\n   Unsupported:  This header is used in a 551 (Option\
    \ Not Supported)\n         error response, to indicate which features were not\
    \ supported.\n         Such a response is only the result of the usage of the\
    \ Require\n         or Proxy-Require headers where one or more features were not\n\
    \         supported.  This information allows the requester to make the\n    \
    \     best of situations as it knows which features are not\n         supported.\n"
- title: '11.1.  Feature Tag: play.basic'
  contents:
  - "11.1.  Feature Tag: play.basic\n   An implementation supporting all normative\
    \ parts of this\n   specification for the setup and control of playback of media\
    \ uses the\n   feature tag \"play.basic\" to indicate this support.  The appendices\n\
    \   (starting with letters) are not part of the functionality included in\n  \
    \ the feature tag unless the appendix is explicitly specified in a main\n   section\
    \ as being a required appendix.\n      Note: This feature tag does not mandate\
    \ any media delivery\n      protocol, such as RTP.\n      In RTSP 1.0, there was\
    \ a minimal implementation section.  However,\n      that was not consistent with\
    \ the rest of the specification.  So,\n      rather than making an attempt to\
    \ explicitly enumerate the features\n      for play.basic, this specification\
    \ has to be taken as a whole and\n      the necessary features normatively defined\
    \ as being required are\n      included.\n"
- title: 12.  Pipelining Support
  contents:
  - "12.  Pipelining Support\n   Pipelining is a general method to improve performance\
    \ of request/\n   response protocols by allowing the requesting agent to have\
    \ more than\n   one request outstanding and to send them over the same persistent\n\
    \   connection.  For RTSP, where the relative order of requests will\n   matter,\
    \ it is important to maintain the order of the requests.\n   Because of this,\
    \ the responding agent MUST process the incoming\n   requests in their sending\
    \ order.  The sending order can be determined\n   by the CSeq header and its sequence\
    \ number.  For TCP, the delivery\n   order will be the same, between two agents,\
    \ as the sending order.\n   The processing of the request MUST also have been\
    \ finished before\n   processing the next request from the same agent.  The responses\
    \ MUST\n   be sent in the order the requests were processed.\n   RTSP 2.0 has\
    \ extended support for pipelining beyond the capabilities\n   in RTSP 1.0.  As\
    \ a major improvement, all requests involved in\n   setting up and initiating\
    \ media delivery can now be pipelined,\n   indicated by the Pipelined-Request\
    \ header (see Section 18.33).  This\n   header allows a client to request that\
    \ two or more requests be\n   processed in the same RTSP session context that\
    \ the first request\n   creates.  In other words, a client can request that two\
    \ or more media\n   streams be set up and then played without needing to wait\
    \ for a\n   single response.  This speeds up the initial start-up time for an\n\
    \   RTSP session by at least one RTT.\n   If a pipelined request builds on the\
    \ successful completion of one or\n   more prior requests, the requester must\
    \ verify that all requests were\n   executed as expected.  A common example will\
    \ be two SETUP requests\n   and a PLAY request.  In case one of the SETUP requests\
    \ fails\n   unexpectedly, the PLAY request can still be successfully executed.\n\
    \   However, the resulting presentation will not be as expected by the\n   requesting\
    \ client, as only a single media instead of two will be\n   played.  In this case,\
    \ the client can send a PAUSE request, correct\n   the failing SETUP request,\
    \ and then request it be played.\n"
- title: 13.  Method Definitions
  contents:
  - "13.  Method Definitions\n   The method indicates what is to be performed on the\
    \ resource\n   identified by the Request-URI.  The method name is case sensitive.\n\
    \   New methods may be defined in the future.  Method names MUST NOT\n   start\
    \ with a $ character (decimal 36) and MUST be a token as defined\n   by the ABNF\
    \ [RFC5234] in Section 20.  The methods are summarized in\n   Table 7.\n    +---------------+-----------+--------+-------------+-------------+\n\
    \    | method        | direction | object | Server req. | Client req. |\n    +---------------+-----------+--------+-------------+-------------+\n\
    \    | DESCRIBE      | C -> S    | P,S    | recommended | recommended |\n    |\
    \               |           |        |             |             |\n    | GET_PARAMETER\
    \ | C -> S    | P,S    | optional    | optional    |\n    |               |  \
    \         |        |             |             |\n    |               | S -> C\
    \    | P,S    | optional    | optional    |\n    |               |           |\
    \        |             |             |\n    | OPTIONS       | C -> S    | P,S\
    \    | required    | required    |\n    |               |           |        |\
    \             |             |\n    |               | S -> C    | P,S    | optional\
    \    | optional    |\n    |               |           |        |             |\
    \             |\n    | PAUSE         | C -> S    | P,S    | required    | required\
    \    |\n    |               |           |        |             |             |\n\
    \    | PLAY          | C -> S    | P,S    | required    | required    |\n    |\
    \               |           |        |             |             |\n    | PLAY_NOTIFY\
    \   | S -> C    | P,S    | required    | required    |\n    |               |\
    \           |        |             |             |\n    | REDIRECT      | S ->\
    \ C    | P,S    | optional    | required    |\n    |               |         \
    \  |        |             |             |\n    | SETUP         | C -> S    | S\
    \      | required    | required    |\n    |               |           |      \
    \  |             |             |\n    | SET_PARAMETER | C -> S    | P,S    | required\
    \    | optional    |\n    |               |           |        |             |\
    \             |\n    |               | S -> C    | P,S    | optional    | optional\
    \    |\n    |               |           |        |             |             |\n\
    \    | TEARDOWN      | C -> S    | P,S    | required    | required    |\n    |\
    \               |           |        |             |             |\n    |    \
    \           | S -> C    | P      | required    | required    |\n    +---------------+-----------+--------+-------------+-------------+\n\
    \                     Table 7: Overview of RTSP Methods\n      Note on Table 7:\
    \ This table covers RTSP methods, their direction,\n      and on what objects\
    \ (P: presentation, S: stream) they operate.\n      Further, it indicates whether\
    \ a server or a client implementation\n      is required (mandatory), recommended,\
    \ or optional.\n      Further note on Table 7: the GET_PARAMETER is optional.\
    \  For\n      example, a fully functional server can be built to deliver media\n\
    \      without any parameters.  However, SET_PARAMETER is required, i.e.,\n  \
    \    mandatory to implement for the server; this is due to its usage\n      for\
    \ keep-alive.  PAUSE is required because it is the only way of\n      leaving\
    \ the Play state without terminating the whole session.\n   If an RTSP agent does\
    \ not support a particular method, it MUST return\n   a 501 (Not Implemented)\
    \ response code and the requesting RTSP agent,\n   in turn, SHOULD NOT try this\
    \ method again for the given agent/\n   resource combination.  An RTSP proxy whose\
    \ main function is to log or\n   audit and not modify transport or media handling\
    \ in any way MAY\n   forward RTSP messages with unknown methods.  Note that the\
    \ proxy\n   still needs to perform the minimal required processing, like adding\n\
    \   the Via header.\n"
- title: 13.1.  OPTIONS
  contents:
  - "13.1.  OPTIONS\n   The semantics of the RTSP OPTIONS method is similar to that\
    \ of the\n   HTTP OPTIONS method described in Section 4.3.7 of [RFC7231].\n  \
    \ However, in RTSP, OPTIONS is bidirectional in that a client can send\n   the\
    \ request to a server and vice versa.  A client MUST implement the\n   capability\
    \ to send an OPTIONS request and a server or a proxy MUST\n   implement the capability\
    \ to respond to an OPTIONS request.  In\n   addition to this \"MUST-implement\"\
    \ functionality, clients, servers and\n   proxies MAY provide support both for\
    \ sending OPTIONS requests and for\n   generating responses to the requests.\n\
    \   An OPTIONS request may be issued at any time.  Such a request does\n   not\
    \ modify the session state.  However, it may prolong the session\n   lifespan\
    \ (see below).  The URI in an OPTIONS request determines the\n   scope of the\
    \ request and the corresponding response.  If the Request-\n   URI refers to a\
    \ specific media resource on a given host, the scope is\n   limited to the set\
    \ of methods supported for that media resource by\n   the indicated RTSP agent.\
    \  A Request-URI with only the host address\n   limits the scope to the specified\
    \ RTSP agent's general capabilities\n   without regard to any specific media.\
    \  If the Request-URI is an\n   asterisk (\"*\"), the scope is limited to the\
    \ general capabilities of\n   the next hop (i.e., the RTSP agent in direct communication\
    \ with the\n   request sender).\n   Regardless of the scope of the request, the\
    \ Public header MUST always\n   be included in the OPTIONS response, listing the\
    \ methods that are\n   supported by the responding RTSP agent.  In addition, if\
    \ the scope of\n   the request is limited to a media resource, the Allow header\
    \ MUST be\n   included in the response to enumerate the set of methods that are\n\
    \   allowed for that resource unless the set of methods completely\n   matches\
    \ the set in the Public header.  If the given resource is not\n   available, the\
    \ RTSP agent SHOULD return an appropriate response code,\n   such as 3rr or 4xx.\
    \  The Supported header MAY be included in the\n   request to query the set of\
    \ features that are supported by the\n   responding RTSP agent.\n   The OPTIONS\
    \ method can be used to keep an RTSP session alive.\n   However, this is not the\
    \ preferred way of session keep-alive\n   signaling; see Section 18.49.  An OPTIONS\
    \ request intended for\n   keeping alive an RTSP session MUST include the Session\
    \ header with\n   the associated session identifier.  Such a request SHOULD also\
    \ use\n   the media or the aggregated control URI as the Request-URI.\n   Example:\n\
    \     C->S:  OPTIONS rtsp://server.example.com RTSP/2.0\n            CSeq: 1\n\
    \            User-Agent: PhonyClient/1.2\n            Proxy-Require: gzipped-messages\n\
    \            Supported: play.basic\n     S->C:  RTSP/2.0 200 OK\n            CSeq:\
    \ 1\n            Public: DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE, OPTIONS\n   \
    \         Supported: play.basic, setup.rtp.rtcp.mux, play.scale\n            Server:\
    \ PhonyServer/1.1\n   Note that the \"gzipped-messages\" feature tag in the Proxy-Require\
    \ is\n   a fictitious feature.\n"
- title: 13.2.  DESCRIBE
  contents:
  - "13.2.  DESCRIBE\n   The DESCRIBE method is used to retrieve the description of\
    \ a\n   presentation or media object from a server.  The Request-URI of the\n\
    \   DESCRIBE request identifies the media resource of interest.  The\n   client\
    \ MAY include the Accept header in the request to list the\n   description formats\
    \ that it understands.  The server MUST respond\n   with a description of the\
    \ requested resource and return the\n   description in the message body of the\
    \ response, if the DESCRIBE\n   method request can be successfully fulfilled.\
    \  The DESCRIBE reply-\n   response pair constitutes the media initialization\
    \ phase of RTSP.\n   The DESCRIBE response SHOULD contain all media initialization\n\
    \   information for the resource(s) that it describes.  Servers SHOULD\n   NOT\
    \ use the DESCRIBE response as a means of media indirection by\n   having the\
    \ description point at another server; instead, using the\n   3rr responses is\
    \ RECOMMENDED.\n      By forcing a DESCRIBE response to contain all media initialization\n\
    \      information for the set of streams that it describes, and\n      discouraging\
    \ the use of DESCRIBE for media indirection, any\n      looping problems can be\
    \ avoided that might have resulted from\n      other approaches.\n   Example:\n\
    \     C->S: DESCRIBE rtsp://server.example.com/fizzle/foo RTSP/2.0\n         \
    \  CSeq: 312\n           User-Agent: PhonyClient/1.2\n           Accept: application/sdp,\
    \ application/example\n     S->C: RTSP/2.0 200 OK\n           CSeq: 312\n    \
    \       Date: Thu, 23 Jan 1997 15:35:06 GMT\n           Server: PhonyServer/1.1\n\
    \           Content-Base: rtsp://server.example.com/fizzle/foo/\n           Content-Type:\
    \ application/sdp\n           Content-Length: 358\n           v=0\n          \
    \ o=MNobody 2890844526 2890842807 IN IP4 192.0.2.46\n           s=SDP Seminar\n\
    \           i=A Seminar on the session description protocol\n           u=http://www.example.com/lectures/sdp.ps\n\
    \           e=seminar@example.com (Seminar Management)\n           c=IN IP4 0.0.0.0\n\
    \           a=control:*\n           t=2873397496 2873404696\n           m=audio\
    \ 3456 RTP/AVP 0\n           a=control:audio\n           m=video 2232 RTP/AVP\
    \ 31\n           a=control:video\n   Media initialization is a requirement for\
    \ any RTSP-based system, but\n   the RTSP specification does not dictate that\
    \ this is required to be\n   done via the DESCRIBE method.  There are three ways\
    \ that an RTSP\n   client may receive initialization information:\n   o  via an\
    \ RTSP DESCRIBE request\n   o  via some other protocol (HTTP, email attachment,\
    \ etc.)\n   o  via some form of user interface\n   If a client obtains a valid\
    \ description from an alternate source, the\n   client MAY use this description\
    \ for initialization purposes without\n   issuing a DESCRIBE request for the same\
    \ media.  The client should use\n   any MTag to either validate the presentation\
    \ description or make the\n   session establishment conditional on being valid.\n\
    \   It is RECOMMENDED that minimal servers support the DESCRIBE method,\n   and\
    \ highly recommended that minimal clients support the ability to\n   act as \"\
    helper applications\" that accept a media initialization file\n   from a user\
    \ interface, or other means that are appropriate to the\n   operating environment\
    \ of the clients.\n"
- title: 13.3.  SETUP
  contents:
  - "13.3.  SETUP\n   The description below uses the following states in a protocol\
    \ state\n   machine that is related to a specific session when that session has\n\
    \   been created.  The state transitions are driven by protocol\n   interactions.\
    \  For additional information about the state machine,\n   see Appendix B.\n \
    \  Init: Initial state.  No session exists.\n   Ready:  Session is ready to start\
    \ playing.\n   Play: Session is playing, i.e., sending media-stream data in the\n\
    \         direction S->C.\n   The SETUP request for a URI specifies the transport\
    \ mechanism to be\n   used for the streamed media.  The SETUP method may be used\
    \ in two\n   different cases, namely, creating an RTSP session and changing the\n\
    \   transport parameters of media streams that are already set up.  SETUP\n  \
    \ can be used in all three states, Init, Ready, and Play, to change the\n   transport\
    \ parameters.  Additionally, Init and Ready can also be used\n   for the creation\
    \ of the RTSP session.  The usage of the SETUP method\n   in the Play state to\
    \ add a media resource to the session is\n   unspecified.\n   The Transport header,\
    \ see Section 18.54, specifies the media-\n   transport parameters acceptable\
    \ to the client for data transmission;\n   the response will contain the transport\
    \ parameters selected by the\n   server.  This allows the client to enumerate,\
    \ in descending order of\n   preference, the transport mechanisms and parameters\
    \ acceptable to it,\n   so the server can select the most appropriate.  It is\
    \ expected that\n   the session description format used will enable the client\
    \ to select\n   a limited number of possible configurations that are offered as\n\
    \   choices to the server.  All transport-related parameters SHALL be\n   included\
    \ in the Transport header; the use of other headers for this\n   purpose is NOT\
    \ RECOMMENDED due to middleboxes, such as firewalls or\n   NATs.\n   For the benefit\
    \ of any intervening firewalls, a client MUST indicate\n   the known transport\
    \ parameters, even if it has no influence over\n   these parameters, for example,\
    \ where the server advertises a fixed-\n   multicast address as destination.\n\
    \      Since SETUP includes all transport initialization information,\n      firewalls\
    \ and other intermediate network devices (which need this\n      information)\
    \ are spared the more arduous task of parsing the\n      DESCRIBE response, which\
    \ has been reserved for media\n      initialization.\n   The client MUST include\
    \ the Accept-Ranges header in the request,\n   indicating all supported unit formats\
    \ in the Range header.  This\n   allows the server to know which formats it may\
    \ use in future session-\n   related responses, such as a PLAY response without\
    \ any range in the\n   request.  If the client does not support a time format\
    \ necessary for\n   the presentation, the server MUST respond using 456 (Header\
    \ Field Not\n   Valid for Resource) and include the Accept-Ranges header with\
    \ the\n   range unit formats supported for the resource.\n   In a SETUP response,\
    \ the server MUST include the Accept-Ranges header\n   (see Section 18.5) to indicate\
    \ which time formats are acceptable to\n   use for this media resource.\n   The\
    \ SETUP 200 OK response MUST include the Media-Properties header\n   (see Section\
    \ 18.29).  The combination of the parameters of the Media-\n   Properties header\
    \ indicates the nature of the content present in the\n   session (see also Section\
    \ 4.7).  For example, a live stream with time\n   shifting is indicated by\n \
    \  o  Random access set to Random-Access,\n   o  Content Modifications set to\
    \ Time-Progressing, and\n   o  Retention set to Time-Duration (with specific recording\
    \ window\n      time value).\n   The SETUP 200 OK response MUST include the Media-Range\
    \ header (see\n   Section 18.30) if the media is Time-Progressing.\n   A basic\
    \ example for SETUP:\n     C->S: SETUP rtsp://example.com/foo/bar/baz.rm RTSP/2.0\n\
    \           CSeq: 302\n           Transport: RTP/AVP;unicast;dest_addr=\":4588\"\
    /\":4589\",\n                      RTP/AVP/TCP;unicast;interleaved=0-1\n     \
    \      Accept-Ranges: npt, clock\n           User-Agent: PhonyClient/1.2\n   \
    \  S->C: RTSP/2.0 200 OK\n           CSeq: 302\n           Date: Thu, 23 Jan 1997\
    \ 15:35:06 GMT\n           Server: PhonyServer/1.1\n           Session: QKyjN8nt2WqbWw4tIYof52;timeout=60\n\
    \           Transport: RTP/AVP;unicast;dest_addr=\"192.0.2.53:4588\"/\n      \
    \                \"192.0.2.53:4589\"; src_addr=\"198.51.100.241:6256\"/\n    \
    \                  \"198.51.100.241:6257\"; ssrc=2A3F93ED\n           Accept-Ranges:\
    \ npt\n           Media-Properties: Random-Access=3.2, Time-Progressing,\n   \
    \                          Time-Duration=3600.0\n           Media-Range: npt=0-2893.23\n\
    \   In the above example, the client wants to create an RTSP session\n   containing\
    \ the media resource \"rtsp://example.com/foo/bar/baz.rm\".\n   The transport\
    \ parameters acceptable to the client are either RTP/AVP/\n   UDP (UDP per default)\
    \ to be received on client port 4588 and 4589 at\n   the address the RTSP setup\
    \ connection comes from or RTP/AVP\n   interleaved on the RTSP control channel.\
    \  The server selects the\n   RTP/AVP/UDP transport and adds the address and ports\
    \ it will send and\n   receive RTP and RTCP from, and the RTP SSRC that will be\
    \ used by the\n   server.\n   The server MUST generate a session identifier in\
    \ response to a\n   successful SETUP request unless a SETUP request to a server\
    \ includes\n   a session identifier or a Pipelined-Requests header referencing\
    \ an\n   existing session context.  In that latter case, the server MUST\n   bundle\
    \ this SETUP request into the existing session (aggregated\n   session) or return\
    \ a 459 (Aggregate Operation Not Allowed) error code\n   (see Section 17.4.23).\
    \  An aggregate control URI MUST be used to\n   control an aggregated session.\
    \  This URI MUST be different from the\n   stream control URIs of the individual\
    \ media streams included in the\n   aggregate (see Section 13.4.2 for aggregated\
    \ sessions and for the\n   particular URIs see Appendix D.1.1).  The aggregate\
    \ control URI is to\n   be specified by the session description if the server\
    \ supports\n   aggregated control and aggregated control is desired for the session.\n\
    \   However, even if aggregated control is offered, the client MAY choose\n  \
    \ not to set up the session in aggregated control.  If an aggregate\n   control\
    \ URI is not specified in the session description, it is\n   normally an indication\
    \ that non-aggregated control should be used.\n   The SETUP of media streams in\
    \ an aggregate that has not been given an\n   aggregated control URI is unspecified.\n\
    \      While the session ID sometimes carries enough information for\n      aggregate\
    \ control of a session, the aggregate control URI is still\n      important for\
    \ some methods such as SET_PARAMETER where the control\n      URI enables the\
    \ resource in question to be easily identified.  The\n      aggregate control\
    \ URI is also useful for proxies, enabling them to\n      route the request to\
    \ the appropriate server, and for logging,\n      where it is useful to note the\
    \ actual resource on which a request\n      was operating.\n   A session will\
    \ exist until it is either removed by a TEARDOWN request\n   or is timed out by\
    \ the server.  The server MAY remove a session that\n   has not demonstrated liveness\
    \ signs from the client(s) within a\n   certain timeout period.  The default timeout\
    \ value is 60 seconds; the\n   server MAY set this to a different value and indicate\
    \ so in the\n   timeout field of the Session header in the SETUP response.  For\n\
    \   further discussion, see Section 18.49.  Signs of liveness for an RTSP\n  \
    \ session include any RTSP requests from a client that contain a\n   Session header\
    \ with the ID for that session, as well as RTCP sender\n   or receiver reports\
    \ if RTP is used to transport the underlying media\n   stream.  RTCP sender reports\
    \ may, for example, be received in session\n   where the server is invited into\
    \ a conference session and are thus\n   valid as a liveness indicator.\n   If\
    \ a SETUP request on a session fails for any reason, the session\n   state, as\
    \ well as transport and other parameters for associated\n   streams, MUST remain\
    \ unchanged from their values as if the SETUP\n   request had never been received\
    \ by the server.\n"
- title: 13.3.1.  Changing Transport Parameters
  contents:
  - "13.3.1.  Changing Transport Parameters\n   A client MAY issue a SETUP request\
    \ for a stream that is already set\n   up or playing in the session to change\
    \ transport parameters, which a\n   server MAY allow.  If it does not allow the\
    \ changing of parameters,\n   it MUST respond with error 455 (Method Not Valid\
    \ in This State).  The\n   reasons to support changing transport parameters include\
    \ allowing\n   application-layer mobility and flexibility to utilize the best\n\
    \   available transport as it becomes available.  If a client receives a\n   455\
    \ error when trying to change transport parameters while the server\n   is in\
    \ Play state, it MAY try to put the server in Ready state using\n   PAUSE before\
    \ issuing the SETUP request again.  If that also fails,\n   the changing of transport\
    \ parameters will require that the client\n   perform a TEARDOWN of the affected\
    \ media and then set it up again.\n   For an aggregated session, not tearing down\
    \ all the media at the same\n   time will avoid the creation of a new session.\n\
    \   All transport parameters MAY be changed.  However, the primary usage\n   expected\
    \ is to either change the transport protocol completely, like\n   switching from\
    \ Interleaved TCP mode to UDP or vice versa, or to\n   change the delivery address.\n\
    \   In a SETUP response for a request to change the transport parameters\n   while\
    \ in Play state, the server MUST include the Range header to\n   indicate at what\
    \ point the new transport parameters will be used.\n   Further, if RTP is used\
    \ for delivery, the server MUST also include\n   the RTP-Info header to indicate\
    \ at what timestamp and RTP sequence\n   number the change will take place.  If\
    \ both RTP-Info and Range are\n   included in the response, the \"rtp_time\" parameter\
    \ and start point in\n   the Range header MUST be for the corresponding time,\
    \ i.e., be used in\n   the same way as for PLAY to ensure the correct synchronization\n\
    \   information is available.\n   If the transport-parameters change that happened\
    \ while in Play state\n   results in a change of synchronization-related information,\
    \ for\n   example, changing RTP SSRC, the server MUST include the necessary\n\
    \   synchronization information in the SETUP response.  However, the\n   server\
    \ SHOULD avoid changing the synchronization information if\n   possible.\n"
- title: 13.4.  PLAY
  contents:
  - "13.4.  PLAY\n   This section describes the usage of the PLAY method in general,\
    \ for\n   aggregated sessions, and in different usage scenarios.\n"
- title: 13.4.1.  General Usage
  contents:
  - "13.4.1.  General Usage\n   The PLAY method tells the server to start sending\
    \ data via the\n   mechanism specified in SETUP and which part of the media should\
    \ be\n   played out.  PLAY requests are valid when the session is in Ready or\n\
    \   Play state.  A PLAY request MUST include a Session header to indicate\n  \
    \ to which session the request applies.\n   Upon receipt of the PLAY request,\
    \ the server MUST position the normal\n   play time to the beginning of the range\
    \ specified in the received\n   Range header, within the limits of the media resource\
    \ and in\n   accordance with the Seek-Style header (Section 18.47).  It MUST\n\
    \   deliver stream data until the end of the range if given, until a new\n   PLAY\
    \ request is received, until a PAUSE request (Section 13.5) is\n   received, or\
    \ until the end of the media is reached.  If no Range\n   header is present in\
    \ the PLAY request, the server SHALL play from\n   current pause point until the\
    \ end of media.  The pause point defaults\n   at session start to the beginning\
    \ of the media.  For media that is\n   time-progressing and has no retention,\
    \ the pause point will always be\n   set equal to NPT \"now\", i.e., the current\
    \ delivery point.  The pause\n   point may also be set to a particular point in\
    \ the media by the PAUSE\n   method; see Section 13.6.  The pause point for media\
    \ that is\n   currently playing is equal to the current media position.  For time-\n\
    \   progressing media with time-limited retention, if the pause point\n   represents\
    \ a position that is older than what is retained by the\n   server, the pause\
    \ point will be moved to the oldest retained\n   position.\n   What range values\
    \ are valid depends on the type of content.  For\n   content that isn't time-progressing,\
    \ the range value is valid if the\n   given range is part of any media within\
    \ the aggregate.  In other\n   words, the valid media range for the aggregate\
    \ is the union of all of\n   the media components in the aggregate.  If a given\
    \ range value points\n   outside of the media, the response MUST be the 457 (Invalid\
    \ Range)\n   error code and include the Media-Range header (Section 18.30) with\n\
    \   the valid range for the media.  Except for time-progressing content\n   where\
    \ the client requests a start point prior to what is retained,\n   the start point\
    \ is adjusted to the oldest retained content.  For a\n   start point that is beyond\
    \ the media front edge, i.e., beyond the\n   current value for \"now\", the server\
    \ SHALL adjust the start value to\n   the current front edge.  The Range header's\
    \ stop point value may\n   point beyond the current media edge.  In that case,\
    \ the server SHALL\n   deliver media from the requested (and possibly adjusted)\
    \ start point\n   until the first of either the provided stop point or the end\
    \ of the\n   media.  Please note that if one simply wants to play from a\n   particular\
    \ start point until the end of media, using a Range header\n   with an implicit\
    \ stop point is RECOMMENDED.\n   If a client requests to start playing at the\
    \ end of media, either\n   explicitly with a Range header or implicitly with a\
    \ pause point that\n   is at the end of media, a 457 (Invalid Range) error MUST\
    \ be sent and\n   include the Media-Range header (Section 18.30).  It is specified\n\
    \   below that the Range header also must be included in the response and\n  \
    \ that it will carry the pause point in the media, in the case of the\n   session\
    \ being in Ready State.  Note that this also applies if the\n   pause point or\
    \ requested start point is at the beginning of the media\n   and a Scale header\
    \ (Section 18.46) is included with a negative value\n   (playing backwards).\n\
    \   For media with random access properties, a client may indicate which\n   policy\
    \ for start point selection the server should use.  This is done\n   by including\
    \ the Seek-Style header (Section 18.47) in the PLAY\n   request.  The Seek-Style\
    \ applied will affect the content of the Range\n   header as it will be adjusted\
    \ to indicate from what point the media\n   actually is delivered.\n   A client\
    \ desiring to play the media from the beginning MUST send a\n   PLAY request with\
    \ a Range header pointing at the beginning, e.g.,\n   \"npt=0-\".  If a PLAY request\
    \ is received without a Range header and\n   media delivery has stopped at the\
    \ end, the server SHOULD respond with\n   a 457 (Invalid Range) error response.\
    \  In that response, the current\n   pause point MUST be included in a Range header.\n\
    \   All range specifiers in this specification allow for ranges with an\n   implicit\
    \ start point (e.g., \"npt=-30\").  When used in a PLAY request,\n   the server\
    \ treats this as a request to start or resume delivery from\n   the current pause\
    \ point, ending at the end time specified in the\n   Range header.  If the pause\
    \ point is located later than the given end\n   value, a 457 (Invalid Range) response\
    \ MUST be returned.\n   The example below will play seconds 10 through 25.  It\
    \ also requests\n   that the server deliver media from the first random access\
    \ point\n   prior to the indicated start point.\n     C->S: PLAY rtsp://audio.example.com/audio\
    \ RTSP/2.0\n           CSeq: 835\n           Session: ULExwZCXh2pd0xuFgkgZJW\n\
    \           Range: npt=10-25\n           Seek-Style: RAP\n           User-Agent:\
    \ PhonyClient/1.2\n   Servers MUST include a Range header in any PLAY response,\
    \ even if no\n   Range header was present in the request.  The response MUST use\
    \ the\n   same format as the request's Range header contained.  If no Range\n\
    \   header was in the request, the format used in any previous PLAY\n   request\
    \ within the session SHOULD be used.  If no format has been\n   indicated in a\
    \ previous request, the server MAY use any time format\n   supported by the media\
    \ and indicated in the Accept-Ranges header in\n   the SETUP request.  It is RECOMMENDED\
    \ that NPT is used if supported\n   by the media.\n   For any error response to\
    \ a PLAY request, the server's response\n   depends on the current session state.\
    \  If the session is in Ready\n   state, the current pause point is returned using\
    \ a Range header with\n   the pause point as the explicit start point and an implicit\
    \ stop\n   point.  For time-progressing content, where the pause-point moves\n\
    \   with real-time due to limited retention, the current pause point is\n   returned.\
    \  For sessions in Play state, the current playout point and\n   the remaining\
    \ parts of the range request are returned.  For any media\n   with retention longer\
    \ than 0 seconds, the currently valid Media-Range\n   header SHALL also be included\
    \ in the response.\n   A PLAY response MAY include a header carrying synchronization\n\
    \   information.  As the information necessary is dependent on the media-\n  \
    \ transport format, further rules specifying the header and its usage\n   are\
    \ needed.  For RTP the RTP-Info header is specified, see\n   Section 18.45, and\
    \ used in the following example.\n   Here is a simple example for a single audio\
    \ stream where the client\n   requests the media starting from 3.52 seconds and\
    \ to the end.  The\n   server sends a 200 OK response with the actual play time,\
    \ which is 10\n   ms prior (3.51), and the RTP-Info header that contains the necessary\n\
    \   parameters for the RTP stack.\n   C->S: PLAY rtsp://example.com/audio RTSP/2.0\n\
    \         CSeq: 836\n         Session: ULExwZCXh2pd0xuFgkgZJW\n         Range:\
    \ npt=3.52-\n         User-Agent: PhonyClient/1.2\n   S->C: RTSP/2.0 200 OK\n\
    \         CSeq: 836\n         Date: Thu, 23 Jan 1997 15:35:06 GMT\n         Server:\
    \ PhonyServer/1.0\n         Range: npt=3.51-324.39\n         Seek-Style: First-Prior\n\
    \             Session: ULExwZCXh2pd0xuFgkgZJW\n         RTP-Info:url=\"rtsp://example.com/audio\"\
    \n            ssrc=0D12F123:seq=14783;rtptime=2345962545\n   S->C: RTP Packet\
    \ TS=2345962545 => NPT=3.51\n         Media duration=0.16 seconds\n   The server\
    \ replies with the actual start point that will be\n   delivered.  This may differ\
    \ from the requested range if alignment of\n   the requested range to valid frame\
    \ boundaries is required for the\n   media source.  Note that some media streams\
    \ in an aggregate may need\n   to be delivered from even earlier points.  Also,\
    \ some media formats\n   have a very long duration per individual data unit; therefore,\
    \ it\n   might be necessary for the client to parse the data unit, and select\n\
    \   where to start.  The server SHALL also indicate which policy it uses\n   for\
    \ selecting the actual start point by including a Seek-Style\n   header.\n   In\
    \ the following example, the client receives the first media packet\n   that stretches\
    \ all the way up and past the requested playtime.  Thus,\n   it is the client's\
    \ decision whether to render to the user the time\n   between 3.52 and 7.05 or\
    \ to skip it.  In most cases, it is probably\n   most suitable not to render that\
    \ time period.\n   C->S: PLAY rtsp://example.com/audio RTSP/2.0\n         CSeq:\
    \ 836\n         Session: ZGGyCJOs8xaLkdNK2dmxQO\n         Range: npt=7.05-\n \
    \        User-Agent: PhonyClient/1.2\n   S->C: RTSP/2.0 200 OK\n         CSeq:\
    \ 836\n         Date: Thu, 23 Jan 1997 15:35:06 GMT\n         Server: PhonyServer/1.0\n\
    \             Session: ZGGyCJOs8xaLkdNK2dmxQO\n         Range: npt=3.52-\n   \
    \      Seek-Style: First-Prior\n         RTP-Info:url=\"rtsp://example.com/audio\"\
    \n            ssrc=0D12F123:seq=14783;rtptime=2345962545\n   S->C: RTP Packet\
    \ TS=2345962545 => NPT=3.52\n         Duration=4.15 seconds\n   After playing\
    \ the desired range, the presentation does NOT change to\n   the Ready state,\
    \ media delivery simply stops.  If it is necessary to\n   put the stream into\
    \ the Ready state, a PAUSE request MUST be issued.\n   A PLAY request while the\
    \ stream is still in the Play state is legal\n   and can be issued without an\
    \ intervening PAUSE request.  Such a\n   request MUST replace the current PLAY\
    \ action with the new one\n   requested, i.e., being handled in the same way as\
    \ if as the request\n   was received in Ready state.  In the case that the range\
    \ in the Range\n   header has an implicit start time (\"-endtime\"), the server\
    \ MUST\n   continue to play from where it currently was until the specified\n\
    \   endpoint.  This is useful to change the end to at another point than\n   in\
    \ the previous request.\n   The following example plays the whole presentation\
    \ starting at SMPTE\n   time code 0:10:20 until the end of the clip.  Note: the\
    \ RTP-Info\n   headers have been broken into several lines, where subsequent lines\n\
    \   start with whitespace as allowed by the syntax.\n   C->S: PLAY rtsp://audio.example.com/twister.en\
    \ RTSP/2.0\n         CSeq: 833\n         Session: N465Wvsv0cjUy6tLqINkcf\n   \
    \      Range: smpte=0:10:20-\n         User-Agent: PhonyClient/1.2\n   S->C: RTSP/2.0\
    \ 200 OK\n         CSeq: 833\n         Date: Thu, 23 Jan 1997 15:35:06 GMT\n \
    \        Session: N465Wvsv0cjUy6tLqINkcf\n         Server: PhonyServer/1.0\n \
    \        Range: smpte=0:10:22-0:15:45\n         Seek-Style: Next\n         RTP-Info:url=\"\
    rtsp://example.com/twister.en\"\n            ssrc=0D12F123:seq=14783;rtptime=2345962545\n\
    \   For playing back a recording of a live presentation, it may be\n   desirable\
    \ to use clock units:\n   C->S: PLAY rtsp://audio.example.com/meeting.en RTSP/2.0\n\
    \         CSeq: 835\n         Session: N465Wvsv0cjUy6tLqINkcf\n         Range:\
    \ clock=19961108T142300Z-19961108T143520Z\n         User-Agent: PhonyClient/1.2\n\
    \   S->C: RTSP/2.0 200 OK\n         CSeq: 835\n         Date: Thu, 23 Jan 1997\
    \ 15:35:06 GMT\n         Session: N465Wvsv0cjUy6tLqINkcf\n         Server: PhonyServer/1.0\n\
    \         Range: clock=19961108T142300Z-19961108T143520Z\n         Seek-Style:\
    \ Next\n         RTP-Info:url=\"rtsp://example.com/meeting.en\"\n            ssrc=0D12F123:seq=53745;rtptime=484589019\n"
- title: 13.4.2.  Aggregated Sessions
  contents:
  - "13.4.2.  Aggregated Sessions\n   PLAY requests can operate on sessions controlling\
    \ a single media\n   stream and on aggregated sessions controlling multiple media\
    \ streams.\n   In an aggregated session, the PLAY request MUST contain an aggregated\n\
    \   control URI.  A server MUST respond with a 460 error (Only Aggregate\n   Operation\
    \ Allowed) if the client PLAY Request-URI is for a single\n   media.  The media\
    \ in an aggregate MUST be played in sync.  If a\n   client wants individual control\
    \ of the media, it needs to use\n   separate RTSP sessions for each media.\n \
    \  For aggregated sessions where the initial SETUP request (creating a\n   session)\
    \ is followed by one or more additional SETUP requests, a PLAY\n   request MAY\
    \ be pipelined (Section 12) after those additional SETUP\n   requests without\
    \ awaiting their responses.  This procedure can reduce\n   the delay from the\
    \ start of session establishment until media playout\n   has started with one\
    \ RTT.  However, a client needs to be aware that\n   using this procedure will\
    \ result in the playout of the server state\n   established at the time of processing\
    \ the PLAY, i.e., after the\n   processing of all the requests prior to the PLAY\
    \ request in the\n   pipeline.  This state may not be the intended one due to\
    \ failure of\n   any of the prior requests.  A client can easily determine this\
    \ based\n   on the responses from those requests.  In case of failure, the client\n\
    \   can halt the media playout using PAUSE and try to establish the\n   intended\
    \ state again before issuing another PLAY request.\n"
- title: 13.4.3.  Updating Current PLAY Requests
  contents:
  - "13.4.3.  Updating Current PLAY Requests\n   Clients can issue PLAY requests while\
    \ the stream is in Play state and\n   thus updating their request.\n   The important\
    \ difference compared to a PLAY request in Ready state is\n   the handling of\
    \ the current play point and how the Range header in\n   the request is constructed.\
    \  The session is actively playing media\n   and the play point will be moving,\
    \ making the exact time a request\n   will take effect hard to predict.  Depending\
    \ on how the PLAY header\n   appears, two different cases exist: total replacement\
    \ or\n   continuation.  A total replacement is signaled by having the first\n\
    \   range specification have an explicit start value, e.g., \"npt=45-\" or\n \
    \  \"npt=45-60\", in which case the server stops playout at the current\n   playout\
    \ point and then starts delivering media according to the Range\n   header.  This\
    \ is equivalent to having the client first send a PAUSE\n   and then a new PLAY\
    \ request that isn't based on the pause point.  In\n   the case of continuation,\
    \ the first range specifier has an implicit\n   start point and an explicit stop\
    \ value (Z), e.g., \"npt=-60\", which\n   indicate that it MUST convert the range\
    \ specifier being played prior\n   to this PLAY request (X to Y) into (X to Z)\
    \ and continue as if this\n   was the request originally played.  If the current\
    \ delivery point is\n   beyond the stop point, the server SHALL immediately pause\
    \ delivery.\n   As the request has been completed successfully, it shall be responded\n\
    \   to with a 200 OK response.  A PLAY_NOTIFY with end-of-stream is also\n   sent\
    \ to indicate the actual stop point.  The pause point is set to\n   the requested\
    \ stop point.\n   The following is an example of this behavior: The server has\
    \ received\n   requests to play ranges 10 to 15.  If the new PLAY request arrives\
    \ at\n   the server 4 seconds after the previous one, it will take effect\n  \
    \ while the server still plays the first range (10-15).  The server\n   changes\
    \ the current play to continue to 25 seconds, i.e., the\n   equivalent single\
    \ request would be PLAY with \"range: npt=10-25\".\n     C->S: PLAY rtsp://example.com/fizzle/foo\
    \ RTSP/2.0\n           CSeq: 834\n           Session: apzA8LnjQ5KWTdw0kUkiRh\n\
    \           Range: npt=10-15\n           User-Agent: PhonyClient/1.2\n     S->C:\
    \ RTSP/2.0 200 OK\n           CSeq: 834\n           Date: Thu, 23 Jan 1997 15:35:06\
    \ GMT\n           Session: apzA8LnjQ5KWTdw0kUkiRh\n           Server: PhonyServer/1.0\n\
    \           Range: npt=10-15\n           Seek-Style: Next\n           RTP-Info:url=\"\
    rtsp://example.com/fizzle/audiotrack\"\n                   ssrc=0D12F123:seq=5712;rtptime=934207921,\n\
    \                   url=\"rtsp://example.com/fizzle/videotrack\"\n           \
    \        ssrc=789DAF12:seq=57654;rtptime=2792482193\n     C->S: PLAY rtsp://example.com/fizzle/foo\
    \ RTSP/2.0\n           CSeq: 835\n           Session: apzA8LnjQ5KWTdw0kUkiRh\n\
    \           Range: npt=-25\n           User-Agent: PhonyClient/1.2\n     S->C:\
    \ RTSP/2.0 200 OK\n           CSeq: 835\n           Date: Thu, 23 Jan 1997 15:35:09\
    \ GMT\n           Session: apzA8LnjQ5KWTdw0kUkiRh\n           Server: PhonyServer/1.0\n\
    \           Range: npt=14-25\n           Seek-Style: Next\n           RTP-Info:url=\"\
    rtsp://example.com/fizzle/audiotrack\"\n                   ssrc=0D12F123:seq=5712;rtptime=934239921,\n\
    \                   url=\"rtsp://example.com/fizzle/videotrack\"\n           \
    \        ssrc=789DAF12:seq=57654;rtptime=2792842193\n   A common use of a PLAY\
    \ request while in Play state is changing the\n   scale of the media, i.e., entering\
    \ or leaving fast forward or fast\n   rewind.  The client can issue an updating\
    \ PLAY request that is either\n   a continuation or a complete replacement, as\
    \ discussed above this\n   section.  Below is an example of a client that is requesting\
    \ a fast\n   forward (scale = 2) without giving a stop point and then a change\n\
    \   from fast forward to regular playout (scale = 1).  In the second PLAY\n  \
    \ request, the time is set explicitly to be wherever the server\n   currently\
    \ plays out (npt=now-) and the server responds with the\n   actual playback point\
    \ where the new scale actually takes effect\n   (npt=02:17:27.144-).\n     C->S:\
    \ PLAY rtsp://example.com/fizzle/foo RTSP/2.0\n           CSeq: 2034\n       \
    \    Session: apzA8LnjQ5KWTdw0kUkiRh\n           Range: npt=now-\n           Scale:\
    \ 2.0\n           User-Agent: PhonyClient/1.2\n     S->C: RTSP/2.0 200 OK\n  \
    \         CSeq: 2034\n           Date: Thu, 23 Jan 1997 15:35:06 GMT\n       \
    \    Session: apzA8LnjQ5KWTdw0kUkiRh\n           Server: PhonyServer/1.0\n   \
    \        Range: npt=02:17:21.394-\n           Seek-Style: Next\n           Scale:\
    \ 2.0\n           RTP-Info:url=\"rtsp://example.com/fizzle/audiotrack\"\n    \
    \               ssrc=0D12F123:seq=5712;rtptime=934207921,\n                  \
    \ url=\"rtsp://example.com/fizzle/videotrack\"\n                   ssrc=789DAF12:seq=57654;rtptime=2792482193\n\
    \   [playing in fast forward and now returning to scale = 1]\n     C->S: PLAY\
    \ rtsp://example.com/fizzle/foo RTSP/2.0\n           CSeq: 2035\n           Session:\
    \ apzA8LnjQ5KWTdw0kUkiRh\n           Range: npt=now-\n           Scale: 1.0\n\
    \           User-Agent: PhonyClient/1.2\n     S->C: RTSP/2.0 200 OK\n        \
    \   CSeq: 2035\n           Date: Thu, 23 Jan 1997 15:35:09 GMT\n           Session:\
    \ apzA8LnjQ5KWTdw0kUkiRh\n           Server: PhonyServer/1.0\n           Range:\
    \ npt=02:17:27.144-\n           Seek-Style: Next\n           Scale: 1.0\n    \
    \       RTP-Info:url=\"rtsp://example.com/fizzle/audiotrack\"\n              \
    \     ssrc=0D12F123:seq=5712;rtptime=934239921,\n                   url=\"rtsp://example.com/fizzle/videotrack\"\
    \n                   ssrc=789DAF12:seq=57654;rtptime=2792842193\n"
- title: 13.4.4.  Playing On-Demand Media
  contents:
  - "13.4.4.  Playing On-Demand Media\n   On-demand media is indicated by the content\
    \ of the Media-Properties\n   header in the SETUP response when (see also Section\
    \ 18.29):\n   o  the Random Access property is set to Random-Access;\n   o  the\
    \ Content Modifications property is set to Immutable;\n   o  the Retention property\
    \ is set to Unlimited or Time-Limited.\n   Playing on-demand media follows the\
    \ general usage as described in\n   Section 13.4.1.\n"
- title: 13.4.5.  Playing Dynamic On-Demand Media
  contents:
  - "13.4.5.  Playing Dynamic On-Demand Media\n   Dynamic on-demand media is indicated\
    \ by the content of the Media-\n   Properties header in the SETUP response when\
    \ (see also\n   Section 18.29):\n   o  the Random Access property is set to Random-Access;\n\
    \   o  the Content Modifications property is set to Dynamic;\n   o  the Retention\
    \ property is set to Unlimited or Time-Limited.\n   Playing on-demand media follows\
    \ the general usage as described in\n   Section 13.4.1 as long as the media has\
    \ not been changed.\n   There are two ways for the client to be informed about\
    \ changes of\n   media resources in Play state.  The first being that the client\
    \ will\n   receive a PLAY_NOTIFY request with the Notify-Reason header set to\n\
    \   media-properties-update (see Section 13.5.2).  The client can use the\n  \
    \ value of the Media-Range header to decide further actions, if the\n   Media-Range\
    \ header is present in the PLAY_NOTIFY request.  The second\n   way is that the\
    \ client issues a GET_PARAMETER request without a body\n   but including a Media-Range\
    \ header.  The 200 OK response MUST include\n   the current Media-Range header\
    \ (see Section 18.30).\n"
- title: 13.4.6.  Playing Live Media
  contents:
  - "13.4.6.  Playing Live Media\n   Live media is indicated by the content of the\
    \ Media-Properties header\n   in the SETUP response when (see also Section 18.29):\n\
    \   o  the Random Access property is set to No-Seeking;\n   o  the Content Modifications\
    \ property is set to Time-Progressing;\n   o  the Retention property's Time-Duration\
    \ is set to 0.0.\n   For live media, the SETUP 200 OK response MUST include the\
    \ Media-\n   Range header (see Section 18.30).\n   A client MAY send PLAY requests\
    \ without the Range header.  If the\n   request includes the Range header, it\
    \ MUST use a symbolic value\n   representing \"now\".  For NPT, that range specification\
    \ is \"npt=now-\".\n   The server MUST include the Range header in the response,\
    \ and it MUST\n   indicate an explicit time value and not a symbolic value.  In\
    \ other\n   words, \"npt=now-\" cannot be used in the response.  Instead, the\
    \ time\n   since session start is recommended, expressed as an open interval,\n\
    \   e.g., \"npt=96.23-\".  An absolute time value (clock) for the\n   corresponding\
    \ time MAY be given, i.e., \"clock=20030213T143205Z-\".\n   The Absolute Time\
    \ format can only be used if the client has shown\n   support for it using the\
    \ Accept-Ranges header.\n"
- title: 13.4.7.  Playing Live with Recording
  contents:
  - "13.4.7.  Playing Live with Recording\n   Certain media servers may offer recording\
    \ services of live sessions\n   to their clients.  This recording would normally\
    \ be from the\n   beginning of the media session.  Clients can randomly access\
    \ the\n   media between now and the beginning of the media session.  This live\n\
    \   media with recording is indicated by the content of the Media-\n   Properties\
    \ header in the SETUP response when (see also\n   Section 18.29):\n   o  the Random\
    \ Access property is set to Random-Access;\n   o  the Content Modifications property\
    \ is set to Time-Progressing;\n   o  the Retention property is set to Time-Limited\
    \ or Unlimited\n   The SETUP 200 OK response MUST include the Media-Range header\
    \ (see\n   Section 18.30) for this type of media.  For live media with\n   recording,\
    \ the Range header indicates the current delivery point in\n   the media and the\
    \ Media-Range header indicates the currently\n   available media window around\
    \ the current time.  This window can\n   cover recorded content in the past (seen\
    \ from current time in the\n   media) or recorded content in the future (seen\
    \ from current time in\n   the media).  The server adjusts the delivery point\
    \ to the requested\n   border of the window.  If the client requests a delivery\
    \ point that\n   is located outside the recording window, e.g., if the requested\
    \ point\n   is too far in the past, the server selects the oldest point in the\n\
    \   recording.  The considerations in Section 13.5.3 apply if a client\n   requests\
    \ delivery with scale (Section 18.46) values other than 1.0\n   (normal playback\
    \ rate) while delivering live media with recording.\n"
- title: 13.4.8.  Playing Live with Time-Shift
  contents:
  - "13.4.8.  Playing Live with Time-Shift\n   Certain media servers may offer time-shift\
    \ services to their clients.\n   This time shift records a fixed interval in the\
    \ past, i.e., a sliding\n   window recording mechanism, but not past this interval.\
    \  Clients can\n   randomly access the media between now and the interval.  This\
    \ live\n   media with recording is indicated by the content of the Media-\n  \
    \ Properties header in the SETUP response when (see also\n   Section 18.29):\n\
    \   o  the Random Access property is set to Random-Access;\n   o  the Content\
    \ Modifications property is set to Time-Progressing;\n   o  the Retention property\
    \ is set to Time-Duration and a value\n      indicating the recording interval\
    \ (>0).\n   The SETUP 200 OK response MUST include the Media-Range header (see\n\
    \   Section 18.30) for this type of media.  For live media with\n   recording,\
    \ the Range header indicates the current time in the media\n   and the Media-Range\
    \ header indicates a window around the current\n   time.  This window can cover\
    \ recorded content in the past (seen from\n   current time in the media) or recorded\
    \ content in the future (seen\n   from current time in the media).  The server\
    \ adjusts the play point\n   to the requested border of the window, if the client\
    \ requests a play\n   point that is located outside the recording windows, e.g.,\
    \ if\n   requested too far in the past, the server selects the oldest range in\n\
    \   the recording.  The considerations in Section 13.5.3 apply if a\n   client\
    \ requests delivery using a scale (Section 18.46) value other\n   than 1.0 (normal\
    \ playback rate) while delivering live media with\n   time-shift.\n"
- title: 13.5.  PLAY_NOTIFY
  contents:
  - "13.5.  PLAY_NOTIFY\n   The PLAY_NOTIFY method is issued by a server to inform\
    \ a client about\n   an asynchronous event for a session in Play state.  The Session\n\
    \   header MUST be presented in a PLAY_NOTIFY request and indicates the\n   scope\
    \ of the request.  Sending of PLAY_NOTIFY requests requires a\n   persistent connection\
    \ between server and client; otherwise, there is\n   no way for the server to\
    \ send this request method to the client.\n   PLAY_NOTIFY requests have an end-to-end\
    \ (i.e., server-to-client)\n   scope, as they carry the Session header, and apply\
    \ only to the given\n   session.  The client SHOULD immediately return a response\
    \ to the\n   server.\n   PLAY_NOTIFY requests MAY use both an aggregate control\
    \ URI and\n   individual media resource URIs, depending on the scope of the\n\
    \   notification.  This scope may have important distinctions for\n   aggregated\
    \ sessions, and each reason for a PLAY_NOTIFY request needs\n   to specify the\
    \ interpretation as well as if aggregated control URIs\n   or individual URIs\
    \ may be used in requests.\n   PLAY_NOTIFY requests can be used with a message\
    \ body, depending on\n   the value of the Notify-Reason header.  It is described\
    \ in the\n   particular section for each Notify-Reason if a message body is used.\n\
    \   However, currently there is no Notify-Reason that allows the use of a\n  \
    \ message body.  In this case, there is a need to obey some limitations\n   when\
    \ adding new Notify-Reasons that intend to use a message body: the\n   server\
    \ can send any type of message body, but it is not ensured that\n   the client\
    \ can understand the received message body.  This is related\n   to DESCRIBE (see\
    \ Section 13.2 ); but, in this particular case, the\n   client can state its acceptable\
    \ message bodies by using the Accept\n   header.  In the case of PLAY_NOTIFY,\
    \ the server does not know which\n   message bodies are understood by the client.\n\
    \   The Notify-Reason header (see Section 18.32) specifies the reason why\n  \
    \ the server sends the PLAY_NOTIFY request.  This is extensible and new\n   reasons\
    \ can be added in the future (see Section 22.8).  In case the\n   client does\
    \ not understand the reason for the notification, it MUST\n   respond with a 465\
    \ (Notification Reason Unknown) (Section 17.4.29)\n   error code.  This document\
    \ defines how servers can send PLAY_NOTIFY\n   with Notify-Reason values of these\
    \ types:\n   o  end-of-stream (see Section 13.5.1);\n   o  media-properties-update\
    \ (see Section 13.5.2);\n   o  scale-change (see Section 13.5.3).\n"
- title: 13.5.1.  End-of-Stream
  contents:
  - "13.5.1.  End-of-Stream\n   A PLAY_NOTIFY request with the Notify-Reason header\
    \ set to end-of-\n   stream indicates the completion or near completion of the\
    \ PLAY\n   request and the ending delivery of the media stream(s).  The request\n\
    \   MUST NOT be issued unless the server is in the Play state.  The end\n   of\
    \ the media stream delivery notification may be used either to\n   indicate a\
    \ successful completion of the PLAY request currently being\n   served or to indicate\
    \ some error resulting in failure to complete the\n   request.  The Request-Status\
    \ header (Section 18.42) MUST be included\n   to indicate which request the notification\
    \ is for and its completion\n   status.  The message response status codes (Section\
    \ 8.1.1) are used\n   to indicate how the PLAY request concluded.  The sender\
    \ of a\n   PLAY_NOTIFY MAY issue an updated PLAY_NOTIFY, in the case of a\n  \
    \ PLAY_NOTIFY sent with wrong information.  For instance, a PLAY_NOTIFY\n   was\
    \ issued before reaching the end-of-stream, but some error occurred\n   resulting\
    \ in that the previously sent PLAY_NOTIFY contained a wrong\n   time when the\
    \ stream will end.  In this case, a new PLAY_NOTIFY MUST\n   be sent including\
    \ the correct status for the completion and all\n   additional information.\n\
    \   PLAY_NOTIFY requests with the Notify-Reason header set to end-of-\n   stream\
    \ MUST include a Range header and the Scale header if the scale\n   value is not\
    \ 1.  The Range header indicates the point in the stream\n   or streams where\
    \ delivery is ending with the timescale that was used\n   by the server in the\
    \ PLAY response for the request being fulfilled.\n   The server MUST NOT use the\
    \ \"now\" constant in the Range header; it\n   MUST use the actual numeric end\
    \ position in the proper timescale.\n   When end-of-stream notifications are issued\
    \ prior to having sent the\n   last media packets, this is made evident because\
    \ the end time in the\n   Range header is beyond the current time in the media\
    \ being received\n   by the client, e.g., \"npt=-15\", if npt is currently at\
    \ 14.2 seconds.\n   The Scale header is to be included so that it is evident if\
    \ the media\n   timescale is moving backwards or has a non-default pace.  The\
    \ end-of-\n   stream notification does not prevent the client from sending a new\n\
    \   PLAY request.\n   If RTP is used as media transport, an RTP-Info header MUST\
    \ be\n   included, and the RTP-Info header MUST indicate the last sequence\n \
    \  number in the sequence parameter.\n   For an RTSP Session where media resources\
    \ are under aggregated\n   control, the media resources will normally end at approximately\
    \ the\n   same time, although some small differences may exist, on the scale of\n\
    \   a few hundred milliseconds.  In those cases, an RTSP session under\n   aggregated\
    \ control SHOULD send only a single PLAY_NOTIFY request.  By\n   using the aggregate\
    \ control URI in the PLAY_NOTIFY request, the RTSP\n   server indicates that this\
    \ applies to all media resources within the\n   session.  In cases in which RTP\
    \ is used for media delivery,\n   corresponding RTP-Info needs to be included\
    \ for all media resources.\n   In cases where one or more media resources have\
    \ a significantly\n   shorter duration than some other resources in the aggregated\
    \ session,\n   the server MAY send end-of-stream notifications using individual\n\
    \   media resource URIs to indicate to agents that there will be no more\n   media\
    \ for this particular media resource related to the current\n   active PLAY request.\
    \  In such cases, when the remaining media\n   resources come to the end of the\
    \ stream, they MUST send a PLAY_NOTIFY\n   request using the aggregate control\
    \ URI to indicate that no more\n   resources remain.\n   A PLAY_NOTIFY request\
    \ with Notify-Reason header set to end-of-stream\n   MUST NOT carry a message\
    \ body.\n   This example request notifies the client about a future end-of-stream\n\
    \   event:\n     S->C: PLAY_NOTIFY rtsp://example.com/fizzle/foo RTSP/2.0\n  \
    \         CSeq: 854\n           Notify-Reason: end-of-stream\n           Request-Status:\
    \ cseq=853 status=200 reason=\"OK\"\n           Range: npt=-145\n           RTP-Info:url=\"\
    rtsp://example.com/fizzle/foo/audio\"\n              ssrc=0D12F123:seq=14783;rtptime=2345962545,\n\
    \              url=\"rtsp://example.com/fizzle/video\"\n              ssrc=789DAF12:seq=57654;rtptime=2792482193\n\
    \           Session: CDtUJfDQXJWtJ7Iqua2xOi\n           Date: Mon, 08 Mar 2010\
    \ 13:37:16 GMT\n     C->S: RTSP/2.0 200 OK\n           CSeq: 854\n           User-Agent:\
    \ PhonyClient/1.2\n           Session: CDtUJfDQXJWtJ7Iqua2xOi\n"
- title: 13.5.2.  Media-Properties-Update
  contents:
  - "13.5.2.  Media-Properties-Update\n   A PLAY_NOTIFY request with a Notify-Reason\
    \ header set to media-\n   properties-update indicates an update of the media\
    \ properties for the\n   given session (see Section 18.29) or the available media\
    \ range that\n   can be played as indicated by the Media-Range header (Section\
    \ 18.30).\n   PLAY_NOTIFY requests with Notify-Reason header set to media-\n \
    \  properties-update MUST include a Media-Properties and Date header and\n   SHOULD\
    \ include a Media-Range header.  The Media-Properties header has\n   session scope;\
    \ thus, for aggregated sessions, the PLAY_NOTIFY request\n   MUST use the aggregated\
    \ control URI.\n   This notification MUST be sent for media that are time-progressing\n\
    \   every time an event happens that changes the basis for making\n   estimates\
    \ on how the available for play-back media range will\n   progress with wall clock\
    \ time.  In addition, it is RECOMMENDED that\n   the server send these notifications\
    \ approximately every 5 minutes for\n   time-progressing content to ensure the\
    \ long-term stability of the\n   client estimation and allow for clock skew detection\
    \ by the client.\n   The time between notifications should be greater than 1 minute\
    \ and\n   less than 2 hours.  For the reasons just explained, requests MUST\n\
    \   include a Media-Range header to provide current Media duration and a\n   Range\
    \ header to indicate the current playing point and any remaining\n   parts of\
    \ the requested range.\n      The recommendation for sending updates every 5 minutes\
    \ is due to\n      any clock skew issues.  In 5 minutes, the clock skew should\
    \ not\n      become too significant as this is not used for media playback and\n\
    \      synchronization, it is only for determining which content is\n      available\
    \ to the user.\n   A PLAY_NOTIFY request with Notify-Reason header set to media-\n\
    \   properties-update MUST NOT carry a message body.\n    S->C: PLAY_NOTIFY rtsp://example.com/fizzle/foo\
    \ RTSP/2.0\n           Date: Tue, 14 Apr 2008 15:48:06 GMT\n           CSeq: 854\n\
    \           Notify-Reason: media-properties-update\n           Session: CDtUJfDQXJWtJ7Iqua2xOi\n\
    \           Media-Properties: Time-Progressing,\n                 Time-Limited=20080415T153919.36Z,\
    \ Random-Access=5.0\n           Media-Range: npt=00:00:00-01:37:21.394\n     \
    \      Range: npt=01:15:49.873-\n     C->S: RTSP/2.0 200 OK\n           CSeq:\
    \ 854\n           User-Agent: PhonyClient/1.2\n           Session: CDtUJfDQXJWtJ7Iqua2xOi\n"
- title: 13.5.3.  Scale-Change
  contents:
  - "13.5.3.  Scale-Change\n   The server may be forced to change the rate of media\
    \ time per\n   playback time when a client requests delivery using a scale\n \
    \  (Section 18.46) value other than 1.0 (normal playback rate).  For\n   time-progressing\
    \ media with some retention, i.e., the server stores\n   already-sent content,\
    \ a client requesting to play with scale values\n   larger than 1 may catch up\
    \ with the front end of the media.  The\n   server will then be unable to continue\
    \ to provide content at scale\n   larger than 1 as content is only made available\
    \ by the server at\n   scale = 1.  Another case is when scale < 1 and the media\
    \ retention is\n   Time-Duration limited.  In this case, the delivery point can\
    \ reach\n   the oldest media unit available, and further playback at this scale\n\
    \   becomes impossible as there will be no media available.  To avoid\n   having\
    \ the client lose any media, the scale will need to be adjusted\n   to the same\
    \ rate at which the media is removed from the storage\n   buffer, commonly scale\
    \ = 1.0.\n   Another case is when the content itself consists of spliced pieces\
    \ or\n   is dynamically updated.  In these cases, the server may be required\n\
    \   to change from one supported scale value (different than scale = 1.0)\n  \
    \ to another.  In this case, the server will pick the closest value and\n   inform\
    \ the client of what it has picked.  In these cases, the media\n   properties\
    \ will also be sent, updating the supported scale values.\n   This enables a client\
    \ to adjust the scale value used.\n   To minimize impact on playback in any of\
    \ the above cases, the server\n   MUST modify the playback properties, set scale\
    \ to a supportable\n   value, and continue delivery of the media.  When doing\
    \ this\n   modification, it MUST send a PLAY_NOTIFY message with the Notify-\n\
    \   Reason header set to \"scale-change\".  The request MUST contain a\n   Range\
    \ header with the media time when the change took effect, a Scale\n   header with\
    \ the new value in use, a Session header with the\n   identifier for the session\
    \ to which it applies, and a Date header\n   with the server wallclock time of\
    \ the change.  For time-progressing\n   content, the Media-Range and the Media-Properties\
    \ headers at this\n   point in time also MUST be included.  The Media-Properties\
    \ header\n   MUST be included if the scale change was due to the content changing\n\
    \   what scale values (\"Scales\") are supported.\n   For media streams delivered\
    \ using RTP, an RTP-Info header MUST also\n   be included.  It MUST contain the\
    \ rtptime parameter with a value\n   corresponding to the point of change in that\
    \ media and optionally the\n   sequence number.\n   PLAY_NOTIFY requests for aggregated\
    \ sessions MUST use the aggregated\n   control URI in the request.  The scale\
    \ change for any aggregated\n   session applies to all media streams that are\
    \ part of the aggregate.\n   A PLAY_NOTIFY request with Notify-Reason header set\
    \ to \"Scale-Change\"\n   MUST NOT carry a message body.\n     S->C: PLAY_NOTIFY\
    \ rtsp://example.com/fizzle/foo RTSP/2.0\n           Date: Tue, 14 Apr 2008 15:48:06\
    \ GMT\n           CSeq: 854\n           Notify-Reason: scale-change\n        \
    \   Session: CDtUJfDQXJWtJ7Iqua2xOi\n           Media-Properties: Time-Progressing,\n\
    \                 Time-Limited=20080415T153919.36Z, Random-Access=5.0\n      \
    \     Media-Range: npt=00:00:00-01:37:21.394\n           Range: npt=01:37:21.394-\n\
    \           Scale: 1\n           RTP-Info: url=\"rtsp://example.com/fizzle/foo/audio\"\
    \n               ssrc=0D12F123:rtptime=2345962545,\n               url=\"rtsp://example.com/fizzle/foo/videotrack\"\
    \n               ssrc=789DAF12:seq=57654;rtptime=2792482193\n     C->S: RTSP/2.0\
    \ 200 OK\n           CSeq: 854\n           User-Agent: PhonyClient/1.2\n     \
    \      Session: CDtUJfDQXJWtJ7Iqua2xOi\n"
- title: 13.6.  PAUSE
  contents:
  - "13.6.  PAUSE\n   The PAUSE request causes the stream delivery to immediately\
    \ be\n   interrupted (halted).  A PAUSE request MUST be made either with the\n\
    \   aggregated control URI for aggregated sessions, resulting in all\n   media\
    \ being halted, or with the media URI for non-aggregated\n   sessions.  Any attempt\
    \ to mute a single media with a PAUSE request in\n   an aggregated session MUST\
    \ be responded to with a 460 (Only Aggregate\n   Operation Allowed) error.  After\
    \ resuming playback, synchronization\n   of the tracks MUST be maintained.  Any\
    \ server resources are kept,\n   though servers MAY close the session and free\
    \ resources after being\n   paused for the duration specified with the timeout\
    \ parameter of the\n   Session header in the SETUP message.\n   Example:\n   \
    \  C->S: PAUSE rtsp://example.com/fizzle/foo RTSP/2.0\n           CSeq: 834\n\
    \           Session: OoOUPyUwt0VeY9fFRHuZ6L\n           User-Agent: PhonyClient/1.2\n\
    \     S->C: RTSP/2.0 200 OK\n           CSeq: 834\n           Date: Thu, 23 Jan\
    \ 1997 15:35:06 GMT\n                   Session: OoOUPyUwt0VeY9fFRHuZ6L\n    \
    \       Range: npt=45.76-75.00\n   The PAUSE request causes stream delivery to\
    \ be interrupted\n   immediately on receipt of the message, and the pause point\
    \ is set to\n   the current point in the presentation.  That pause point in the\
    \ media\n   stream needs to be maintained.  A subsequent PLAY request without\
    \ a\n   Range header resumes from the pause point and plays until media end.\n\
    \   The pause point after any PAUSE request MUST be returned to the\n   client\
    \ by adding a Range header with what remains unplayed of the\n   PLAY request's\
    \ range.  For media with random access properties, if\n   one desires to resume\
    \ playing a ranged request, one simply includes\n   the Range header from the\
    \ PAUSE response and includes the Seek-Style\n   header with the Next policy in\
    \ the PLAY request.  For media that is\n   time-progressing and has retention\
    \ duration=0, the follow-up PLAY\n   request to start media delivery again MUST\
    \ use \"npt=now-\" and not the\n   answer given in the response to PAUSE.\n  \
    \   C->S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0\n           CSeq: 834\n\
    \           Session: OccldOFFq23KwjYpAnBbUr\n           Range: npt=10-30\n   \
    \        User-Agent: PhonyClient/1.2\n     S->C: RTSP/2.0 200 OK\n           CSeq:\
    \ 834\n           Date: Thu, 23 Jan 1997 15:35:06 GMT\n           Server: PhonyServer/1.0\n\
    \           Range: npt=10-30\n           Seek-Style: First-Prior\n           RTP-Info:url=\"\
    rtsp://example.com/fizzle/audiotrack\"\n                   ssrc=0D12F123:seq=5712;rtptime=934207921,\n\
    \                   url=\"rtsp://example.com/fizzle/videotrack\"\n           \
    \        ssrc=4FAD8726:seq=57654;rtptime=2792482193\n           Session: OccldOFFq23KwjYpAnBbUr\n\
    \   After 11 seconds, i.e., at 21 seconds into the presentation:\n     C->S: PAUSE\
    \ rtsp://example.com/fizzle/foo RTSP/2.0\n           CSeq: 835\n           Session:\
    \ OccldOFFq23KwjYpAnBbUr\n           User-Agent: PhonyClient/1.2\n     S->C: RTSP/2.0\
    \ 200 OK\n           CSeq: 835\n           Date: 23 Jan 1997 15:35:17 GMT\n  \
    \         Server: PhonyServer/1.0\n           Range: npt=21-30\n           Session:\
    \ OccldOFFq23KwjYpAnBbUr\n   If a client issues a PAUSE request and the server\
    \ acknowledges and\n   enters the Ready state, the proper server response, if\
    \ the player\n   issues another PAUSE, is still 200 OK.  The 200 OK response MUST\n\
    \   include the Range header with the current pause point.  See examples\n   below:\n\
    \     C->S: PAUSE rtsp://example.com/fizzle/foo RTSP/2.0\n           CSeq: 834\n\
    \           Session: OccldOFFq23KwjYpAnBbUr\n           User-Agent: PhonyClient/1.2\n\
    \     S->C: RTSP/2.0 200 OK\n           CSeq: 834\n           Session: OccldOFFq23KwjYpAnBbUr\n\
    \           Date: Thu, 23 Jan 1997 15:35:06 GMT\n           Range: npt=45.76-98.36\n\
    \     C->S: PAUSE rtsp://example.com/fizzle/foo RTSP/2.0\n           CSeq: 835\n\
    \           Session: OccldOFFq23KwjYpAnBbUr\n           User-Agent: PhonyClient/1.2\n\
    \     S->C: RTSP/2.0 200 OK\n           CSeq: 835\n           Session: OccldOFFq23KwjYpAnBbUr\n\
    \           Date: 23 Jan 1997 15:35:07 GMT\n           Range: npt=45.76-98.36\n"
- title: 13.7.  TEARDOWN
  contents:
  - '13.7.  TEARDOWN

    '
- title: 13.7.1.  Client to Server
  contents:
  - "13.7.1.  Client to Server\n   The TEARDOWN client-to-server request stops the\
    \ stream delivery for\n   the given URI, freeing the resources associated with\
    \ it.  A TEARDOWN\n   request can be performed on either an aggregated or a media\
    \ control\n   URI.  However, some restrictions apply depending on the current\n\
    \   state.  The TEARDOWN request MUST contain a Session header indicating\n  \
    \ to what session the request applies.  The TEARDOWN request MUST NOT\n   include\
    \ a Terminate-Reason header.\n   A TEARDOWN using the aggregated control URI or\
    \ the media URI in a\n   session under non-aggregated control (single media session)\
    \ MAY be\n   done in any state (Ready and Play).  A successful request MUST result\n\
    \   in that media delivery being immediately halted and the session state\n  \
    \ being destroyed.  This MUST be indicated through the lack of a\n   Session header\
    \ in the response.\n   A TEARDOWN using a media URI in an aggregated session can\
    \ only be\n   done in Ready state.  Such a request only removes the indicated\
    \ media\n   stream and associated resources from the session.  This may result\
    \ in\n   a session returning to non-aggregated control, because it only\n   contains\
    \ a single media after the request's completion.  A session\n   that will exist\
    \ after the processing of the TEARDOWN request MUST, in\n   the response to that\
    \ TEARDOWN request, contain a Session header.\n   Thus, the presence of the Session\
    \ header indicates to the receiver of\n   the response if the session is still\
    \ extant or has been removed.\n   Example:\n     C->S: TEARDOWN rtsp://example.com/fizzle/foo\
    \ RTSP/2.0\n           CSeq: 892\n           Session: OccldOFFq23KwjYpAnBbUr\n\
    \           User-Agent: PhonyClient/1.2\n     S->C: RTSP/2.0 200 OK\n        \
    \   CSeq: 892\n           Server: PhonyServer/1.0\n"
- title: 13.7.2.  Server to Client
  contents:
  - "13.7.2.  Server to Client\n   The server can send TEARDOWN requests in the server-to-client\n\
    \   direction to indicate that the server has been forced to terminate\n   the\
    \ ongoing session.  This may happen for several reasons, such as\n   server maintenance\
    \ without available backup, or that the session has\n   been inactive for extended\
    \ periods of time.  The reason is provided\n   in the Terminate-Reason header\
    \ (Section 18.52).\n   When an RTSP client has maintained an RTSP session that\
    \ otherwise is\n   inactive for an extended period of time, the server may reclaim\
    \ the\n   resources.  That is done by issuing a TEARDOWN request with the\n  \
    \ Terminate-Reason set to \"Session-Timeout\".  This MAY be done when the\n  \
    \ client has been inactive in the RTSP session for more than one\n   Session Timeout\
    \ period (Section 18.49).  However, the server is NOT\n   RECOMMENDED to perform\
    \ this operation until an extended period of\n   inactivity of 10 times the Session-Timeout\
    \ period has passed.  It is\n   up to the operator of the RTSP server to actually\
    \ configure how long\n   this extended period of inactivity is.  An operator should\
    \ take into\n   account, when doing this configuration, what the served content\
    \ is\n   and what this means for the extended period of inactivity.\n   In case\
    \ the server needs to stop providing service to the established\n   sessions and\
    \ there is no server to point at in a REDIRECT request,\n   then TEARDOWN SHALL\
    \ be used to terminate the session.  This method\n   can also be used when non-recoverable\
    \ internal errors have happened\n   and the server has no other option than to\
    \ terminate the sessions.\n   The TEARDOWN request MUST be made only on the session\
    \ aggregate\n   control URI (i.e., it is not allowed to terminate individual media\n\
    \   streams, if it is a session aggregate), and it MUST include the\n   following\
    \ headers: Session and Terminate-Reason.  The request only\n   applies to the\
    \ session identified in the Session header.  The server\n   may include a message\
    \ to the client's user with the \"user-msg\"\n   parameter.\n   The TEARDOWN request\
    \ may alternatively be done on the wildcard URI\n   \"*\" and without any session\
    \ header.  The scope of such a request is\n   limited to the next-hop (i.e., the\
    \ RTSP agent in direct communication\n   with the server) and applies, as well,\
    \ to the RTSP connection between\n   the next-hop RTSP agent and the server. \
    \ This request indicates that\n   all sessions and pending requests being managed\
    \ via the connection\n   are terminated.  Any intervening proxies SHOULD do all\
    \ of the\n   following in the order listed:\n   1.  respond to the TEARDOWN request\n\
    \   2.  disconnect the control channel from the requesting server\n   3.  pass\
    \ the TEARDOWN request to each applicable client (typically\n       those clients\
    \ with an active session or an unanswered request)\n      Note: The proxy is responsible\
    \ for accepting TEARDOWN responses\n      from its clients; these responses MUST\
    \ NOT be passed on to either\n      the original server or the target server in\
    \ the redirect.\n"
- title: 13.8.  GET_PARAMETER
  contents:
  - "13.8.  GET_PARAMETER\n   The GET_PARAMETER request retrieves the value of any\
    \ specified\n   parameter or parameters for a presentation or stream specified\
    \ in the\n   URI.  If the Session header is present in a request, the value of\
    \ a\n   parameter MUST be retrieved in the specified session context.  There\n\
    \   are two ways of specifying the parameters to be retrieved.\n   The first approach\
    \ includes headers that have been defined to be\n   usable for this purpose. \
    \ Headers for this purpose should allow\n   empty, or stripped value parts to\
    \ avoid having to specify bogus data\n   when indicating the desire to retrieve\
    \ a value.  The successful\n   completion of the request should also be evident\
    \ from any filled out\n   values in the response.  The headers in this specification\
    \ that MAY\n   be used for retrieving their current value using GET_PARAMETER\
    \ are\n   listed below; additional headers MAY be specified in the future:\n \
    \  o  Accept-Ranges\n   o  Media-Range\n   o  Media-Properties\n   o  Range\n\
    \   o  RTP-Info\n   The other way is to specify a message body that lists the\n\
    \   parameter(s) that are desired to be retrieved.  The Content-Type\n   header\
    \ (Section 18.19) is used to specify which format the message\n   body has.  If\
    \ the receiver of the request does not support the media\n   type used for the\
    \ message body, it SHALL respond using the error code\n   415 (Unsupported Media\
    \ Type).  The responder to a GET_PARAMETER\n   request MUST use the media type\
    \ of the request for the response.  For\n   additional considerations regarding\
    \ message body negotiation, see\n   Section 9.3.\n   RTSP agents implementing\
    \ support for responding to GET_PARAMETER\n   requests SHALL implement the \"\
    text/parameters\" format (Appendix F).\n   This to ensure that at least one known\
    \ format for parameters is\n   implemented and, thus, prevent parameter format\
    \ negotiation failure.\n   Parameters specified within the body of the message\
    \ must all be\n   understood by the request-receiving agent.  If one or more parameters\n\
    \   are not understood a 451 (Parameter Not Understood) MUST be sent\n   including\
    \ a body listing the parameters that weren't understood.  If\n   all parameters\
    \ are understood, their values are filled in and\n   returned in the response\
    \ message body.\n   The method can also be used without a message body or any\
    \ header that\n   requests parameters for keep-alive purposes.  The keep-alive\
    \ timer\n   has been updated for any request that is successful, i.e., a 200 OK\n\
    \   response is received.  Any non-required header present in such a\n   request\
    \ may or may not have been processed.  Normally, the presence\n   of filled-out\
    \ values in the header will be indication that the header\n   has been processed.\
    \  However, for cases when this is difficult to\n   determine, it is recommended\
    \ to use a feature tag and the Require\n   header.  For this reason, it is usually\
    \ easier if any parameters to\n   be retrieved are sent in the body, rather than\
    \ using any header.\n   Example:\n     S->C: GET_PARAMETER rtsp://example.com/fizzle/foo\
    \ RTSP/2.0\n           CSeq: 431\n           User-Agent: PhonyClient/1.2\n   \
    \        Session: OccldOFFq23KwjYpAnBbUr\n           Content-Length: 26\n    \
    \       Content-Type: text/parameters\n           packets_received\n         \
    \  jitter\n     C->S: RTSP/2.0 200 OK\n           CSeq: 431\n           Session:\
    \ OccldOFFq23KwjYpAnBbUr\n           Server: PhonyServer/1.1\n           Date:\
    \ Mon, 08 Mar 2010 13:43:23 GMT\n           Content-Length: 38\n           Content-Type:\
    \ text/parameters\n           packets_received: 10\n           jitter: 0.3838\n"
- title: 13.9.  SET_PARAMETER
  contents:
  - "13.9.  SET_PARAMETER\n   This method requests the setting of the value of a parameter\
    \ or a set\n   of parameters for a presentation or stream specified by the URI.\
    \  If\n   the Session header is present in a request, the value of a parameter\n\
    \   MUST be retrieved in the specified session context.  The method MAY\n   also\
    \ be used without a message body.  It is the RECOMMENDED method to\n   be used\
    \ in a request sent for the sole purpose of updating the keep-\n   alive timer.\
    \  If this request is successful, i.e., a 200 OK response\n   is received, then\
    \ the keep-alive timer has been updated.  Any non-\n   required header present\
    \ in such a request may or may not have been\n   processed.  To allow a client\
    \ to determine if any such header has\n   been processed, it is necessary to use\
    \ a feature tag and the Require\n   header.  Due to this reason it is RECOMMENDED\
    \ that any parameters are\n   sent in the body rather than using any header.\n\
    \   When using a message body to list the parameter(s) desired to be set,\n  \
    \ the Content-Type header (Section 18.19) is used to specify which\n   format\
    \ the message body has.  If the receiver of the request is not\n   supporting\
    \ the media type used for the message body, it SHALL respond\n   using the error\
    \ code 415 (Unsupported Media Type).  For additional\n   considerations regarding\
    \ message body negotiation, see Section 9.3.\n   The responder to a SET_PARAMETER\
    \ request MUST use the media type of\n   the request for the response.  For additional\
    \ considerations\n   regarding message body negotiation, see Section 9.3.\n  \
    \ RTSP agents implementing support for responding to SET_PARAMETER\n   requests\
    \ SHALL implement the text/parameters format (Appendix F).\n   This is to ensure\
    \ that at least one known format for parameters is\n   implemented and, thus,\
    \ prevent parameter format negotiation failure.\n   A request is RECOMMENDED to\
    \ only contain a single parameter to allow\n   the client to determine why a particular\
    \ request failed.  If the\n   request contains several parameters, the server\
    \ MUST only act on the\n   request if all of the parameters can be set successfully.\
    \  A server\n   MUST allow a parameter to be set repeatedly to the same value,\
    \ but it\n   MAY disallow changing parameter values.  If the receiver of the\n\
    \   request does not understand or cannot locate a parameter, error 451\n   (Parameter\
    \ Not Understood) MUST be used.  When a parameter is not\n   allowed to change,\
    \ the error code is 458 (Parameter Is Read-Only).\n   The response body MUST contain\
    \ only the parameters that have errors.\n   Otherwise, a body MUST NOT be returned.\
    \  The response body MUST use\n   the media type of the request for the response.\n\
    \   Note: transport parameters for the media stream MUST only be set with\n  \
    \ the SETUP command.\n      Restricting setting transport parameters to SETUP\
    \ is for the\n      benefit of firewalls connected to border RTSP proxies.\n \
    \     The parameters are split in a fine-grained fashion so that there\n     \
    \ can be more meaningful error indications.  However, it may make\n      sense\
    \ to allow the setting of several parameters if an atomic\n      setting is desirable.\
    \  Imagine device control where the client\n      does not want the camera to\
    \ pan unless it can also tilt to the\n      right angle at the same time.\n  \
    \ Example:\n     C->S: SET_PARAMETER rtsp://example.com/fizzle/foo RTSP/2.0\n\
    \           CSeq: 421\n           User-Agent: PhonyClient/1.2\n           Session:\
    \ iixT43KLc\n           Date: Mon, 08 Mar 2010 14:45:04 GMT\n           Content-length:\
    \ 20\n           Content-type: text/parameters\n           barparam: barstuff\n\
    \     S->C: RTSP/2.0 451 Parameter Not Understood\n           CSeq: 421\n    \
    \       Session: iixT43KLc\n           Server: PhonyServer/1.0\n           Date:\
    \ Mon, 08 Mar 2010 14:44:56 GMT\n           Content-length: 20\n           Content-type:\
    \ text/parameters\n           barparam: barstuff\n"
- title: 13.10.  REDIRECT
  contents:
  - "13.10.  REDIRECT\n   The REDIRECT method is issued by a server to inform a client\
    \ that the\n   service provided will be terminated and where a corresponding service\n\
    \   can be provided instead.  This may happen for different reasons.  One\n  \
    \ is that the server is being administered such that it must stop\n   providing\
    \ service.  Thus, the client is required to connect to\n   another server location\
    \ to access the resource indicated by the\n   Request-URI.\n   The REDIRECT request\
    \ SHALL contain a Terminate-Reason header\n   (Section 18.52) to inform the client\
    \ of the reason for the request.\n   Additional parameters related to the reason\
    \ may also be included.\n   The intention here is to allow a server administrator\
    \ to do a\n   controlled shutdown of the RTSP server.  That requires sufficient\n\
    \   time to inform all entities having associated state with the server\n   and\
    \ for them to perform a controlled migration from this server to a\n   fall-back\
    \ server.\n   A REDIRECT request with a Session header has end-to-end (i.e.,\n\
    \   server-to-client) scope and applies only to the given session.  Any\n   intervening\
    \ proxies SHOULD NOT disconnect the control channel while\n   there are other\
    \ remaining end-to-end sessions.  The REQUIRED Location\n   header MUST contain\
    \ a complete absolute URI pointing to the resource\n   to which the client SHOULD\
    \ reconnect.  Specifically, the Location\n   MUST NOT contain just the host and\
    \ port.  A client may receive a\n   REDIRECT request with a Session header, if\
    \ and only if, an end-to-end\n   session has been established.\n   A client may\
    \ receive a REDIRECT request without a Session header at\n   any time when it\
    \ has communication or a connection established with a\n   server.  The scope\
    \ of such a request is limited to the next-hop\n   (i.e., the RTSP agent in direct\
    \ communication with the server) and\n   applies to all sessions controlled, as\
    \ well as the connection between\n   the next-hop RTSP agent and the server. \
    \ A REDIRECT request without a\n   Session header indicates that all sessions\
    \ and pending requests being\n   managed via the connection MUST be redirected.\
    \  The Location header,\n   if included in such a request, SHOULD contain an absolute\
    \ URI with\n   only the host address and the OPTIONAL port number of the server\
    \ to\n   which the RTSP agent SHOULD reconnect.  Any intervening proxies\n   SHOULD\
    \ do all of the following in the order listed:\n   1.  respond to the REDIRECT\
    \ request\n   2.  disconnect the control channel from the requesting server\n\
    \   3.  connect to the server at the given host address\n   4.  pass the REDIRECT\
    \ request to each applicable client (typically\n       those clients with an active\
    \ session or an unanswered request)\n      Note: The proxy is responsible for\
    \ accepting REDIRECT responses\n      from its clients; these responses MUST NOT\
    \ be passed on to either\n      the original server or the redirected server.\n\
    \   A server that needs to terminate a session or all its sessions and\n   lacks\
    \ an alternative server to redirect to, SHALL instead use\n   TEARDOWN requests.\n\
    \   When no Terminate-Reason \"time\" parameter is included in a REDIRECT\n  \
    \ request, the client SHALL perform the redirection immediately and\n   return\
    \ a response to the server.  The server shall consider the\n   session to be terminated\
    \ and can free any associated state after it\n   receives the successful (2xx)\
    \ response.  The server MAY close the\n   signaling connection upon receiving\
    \ the response, and the client\n   SHOULD close the signaling connection after\
    \ sending the 2xx response.\n   The exception to this is when the client has several\
    \ sessions on the\n   server being managed by the given signaling connection.\
    \  In this\n   case, the client SHOULD close the connection when it has received\
    \ and\n   responded to REDIRECT requests for all the sessions managed by the\n\
    \   signaling connection.\n   The Terminate-Reason header \"time\" parameter MAY\
    \ be used to indicate\n   the wallclock time by which the redirection MUST have\
    \ taken place.\n   To allow a client to determine that redirect time without being\
    \ time\n   synchronized with the server, the server MUST include a Date header\n\
    \   in the request.  The client should have terminated the session and\n   closed\
    \ the connection before the redirection time-line terminated.\n   The server MAY\
    \ simply cease to provide service when the deadline time\n   has been reached,\
    \ or it can issue a TEARDOWN requests to the\n   remaining sessions.\n   If the\
    \ REDIRECT request times out following the rules in\n   Section 10.4, the server\
    \ MAY terminate the session or transport\n   connection that would be redirected\
    \ by the request.  This is a\n   safeguard against misbehaving clients that refuse\
    \ to respond to a\n   REDIRECT request.  This action removes any incentive of\
    \ not\n   acknowledging the reception of a REDIRECT request.\n   After a REDIRECT\
    \ request has been processed, a client that wants to\n   continue to receive media\
    \ for the resource identified by the Request-\n   URI will have to establish a\
    \ new session with the designated host.\n   If the URI given in the Location header\
    \ is a valid resource URI, a\n   client SHOULD issue a DESCRIBE request for the\
    \ URI.\n      Note: The media resource indicated by the Location header can be\n\
    \      identical, slightly different, or totally different.  This is the\n   \
    \   reason why a new DESCRIBE request SHOULD be issued.\n   If the Location header\
    \ contains only a host address, the client may\n   assume that the media on the\
    \ new server is identical to the media on\n   the old server, i.e., all media\
    \ configuration information from the\n   old session is still valid except for\
    \ the host address.  However, the\n   usage of conditional SETUP using MTag identifiers\
    \ is RECOMMENDED as a\n   means to verify the assumption.\n   This example request\
    \ redirects traffic for this session to the new\n   server at the given absolute\
    \ time:\n     S->C: REDIRECT rtsp://example.com/fizzle/foo RTSP/2.0\n        \
    \   CSeq: 732\n           Location: rtsp://s2.example.com:8001/fizzle/foo\n  \
    \         Terminate-Reason: Server-Admin ;time=19960213T143205Z\n           Session:\
    \ uZ3ci0K+Ld-M\n           Date: Thu, 13 Feb 1996 14:30:43 GMT\n     C->S: RTSP/2.0\
    \ 200 OK\n           CSeq: 732\n           User-Agent: PhonyClient/1.2\n     \
    \      Session: uZ3ci0K+Ld-M\n"
- title: 14.  Embedded (Interleaved) Binary Data
  contents:
  - "14.  Embedded (Interleaved) Binary Data\n   In order to fulfill certain requirements\
    \ on the network side, e.g.,\n   in conjunction with network address translators\
    \ that block RTP\n   traffic over UDP, it may be necessary to interleave RTSP\
    \ messages and\n   media-stream data.  This interleaving should generally be avoided\n\
    \   unless necessary since it complicates client and server operation and\n  \
    \ imposes additional overhead.  Also, head-of-line blocking may cause\n   problems.\
    \  Interleaved binary data SHOULD only be used if RTSP is\n   carried over TCP.\
    \  Interleaved data is not allowed inside RTSP\n   messages.\n   Stream data,\
    \ such as RTP packets, is encapsulated by an ASCII dollar\n   sign (36 decimal)\
    \ followed by a one-octet channel identifier and the\n   length of the encapsulated\
    \ binary data as a binary, two-octet\n   unsigned integer in network octet order\
    \ (Appendix B of [RFC791]).\n   The stream data follows immediately afterwards,\
    \ without a CRLF, but\n   including the upper-layer protocol headers.  Each dollar\
    \ sign block\n   MUST contain exactly one upper-layer protocol data unit, e.g.,\
    \ one\n   RTP packet.\n      Note that this mechanism does not support PDUs larger\
    \ than 65535\n      octets, which matches the maximum payload size of regular,\
    \ non-\n      jumbo IPv4 and IPv6 packets.  If the media delivery protocol\n \
    \     intended to be used has larger PDUs than that, a definition of a\n     \
    \ PDU fragmentation mechanism will be required to support embedded\n      binary\
    \ data.\n       0                   1                   2                   3\n\
    \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \ \"$\" = 36      | Channel ID    | Length in octets              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      : Binary data (Length according to Length field)                :\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \       Figure 1: Embedded Interleaved Binary Data Format\n   The channel identifier\
    \ is defined in the Transport header with the\n   interleaved parameter (Section\
    \ 18.54).\n   When the transport choice is RTP, RTCP messages are also interleaved\n\
    \   by the server over the TCP connection.  The usage of RTCP messages is\n  \
    \ indicated by including an interval containing a second channel in the\n   interleaved\
    \ parameter of the Transport header (see Section 18.54).\n   If RTCP is used,\
    \ packets MUST be sent on the first available channel\n   that is higher than\
    \ the RTP channel.  The channels are bidirectional,\n   using the same Channel\
    \ ID in both directions; therefore, RTCP traffic\n   is sent on the second channel\
    \ in both directions.\n      RTCP is sometimes needed for synchronization when\
    \ two or more\n      streams are interleaved in such a fashion.  Also, this provides\
    \ a\n      convenient way to tunnel RTP/RTCP packets through the RTSP\n      connection\
    \ (TCP or TCP/TLS) when required by the network\n      configuration and to transfer\
    \ them onto UDP when possible.\n     C->S: SETUP rtsp://example.com/bar.file RTSP/2.0\n\
    \           CSeq: 2\n           Transport: RTP/AVP/TCP;unicast;interleaved=0-1\n\
    \           Accept-Ranges: npt, smpte, clock\n           User-Agent: PhonyClient/1.2\n\
    \     S->C: RTSP/2.0 200 OK\n           CSeq: 2\n           Date: Thu, 05 Jun\
    \ 1997 18:57:18 GMT\n           Transport: RTP/AVP/TCP;unicast;interleaved=5-6\n\
    \           Session: OccldOFFq23KwjYpAnBbUr\n           Accept-Ranges: npt\n \
    \          Media-Properties: Random-Access=0.2, Immutable, Unlimited\n     C->S:\
    \ PLAY rtsp://example.com/bar.file RTSP/2.0\n           CSeq: 3\n           Session:\
    \ OccldOFFq23KwjYpAnBbUr\n           User-Agent: PhonyClient/1.2\n     S->C: RTSP/2.0\
    \ 200 OK\n           CSeq: 3\n           Session: OccldOFFq23KwjYpAnBbUr\n   \
    \        Date: Thu, 05 Jun 1997 18:57:19 GMT\n           RTP-Info: url=\"rtsp://example.com/bar.file\"\
    \n             ssrc=0D12F123:seq=232433;rtptime=972948234\n           Range: npt=0-56.8\n\
    \           Seek-Style: RAP\n     S->C: $005{2 octet length}{\"length\" octets\
    \ data, w/RTP header}\n     S->C: $005{2 octet length}{\"length\" octets data,\
    \ w/RTP header}\n     S->C: $006{2 octet length}{\"length\" octets  RTCP packet}\n"
- title: 15.  Proxies
  contents:
  - "15.  Proxies\n   RTSP Proxies are RTSP agents that are located in between a client\
    \ and\n   a server.  A proxy can take on the roles of both client and server\n\
    \   depending on what it tries to accomplish.  RTSP proxies use two\n   transport-layer\
    \ connections: one from the RTSP client to the RTSP\n   proxy and a second from\
    \ the RTSP proxy to the RTSP server.  Proxies\n   are introduced for several different\
    \ reasons; those listed below are\n   often combined.\n   Caching Proxy:  This\
    \ type of proxy is used to reduce the workload on\n         servers and connections.\
    \  By caching the description and media\n         streams, i.e., the presentation,\
    \ the proxy can serve a client\n         with content, but without requesting\
    \ it from the server once it\n         has been cached and has not become stale.\
    \  See Section 16.\n         This type of proxy is also expected to understand\
    \ RTSP endpoint\n         functionality, i.e., functionality identified in the\
    \ Require\n         header in addition to what Proxy-Require demands.\n   Translator\
    \ Proxy:  This type of proxy is used to ensure that an RTSP\n         client gets\
    \ access to servers and content on an external\n         network or gets access\
    \ by using content encodings not supported\n         by the client.  The proxy\
    \ performs the necessary translation of\n         addresses, protocols, or encodings.\
    \  This type of proxy is\n         expected also to understand RTSP endpoint functionality,\
    \ i.e.,\n         functionality identified in the Require header in addition to\n\
    \         what Proxy-Require demands.\n   Access Proxy:  This type of proxy is\
    \ used to ensure that an RTSP\n         client gets access to servers on an external\
    \ network.  Thus,\n         this proxy is placed on the border between two domains,\
    \ e.g., a\n         private address space and the public Internet.  The proxy\n\
    \         performs the necessary translation, usually addresses.  This\n     \
    \    type of proxy is required to redirect the media to itself or a\n        \
    \ controlled gateway that performs the translation before the\n         media\
    \ can reach the client.\n   Security Proxy:  This type of proxy is used to help\
    \ facilitate\n         security functions around RTSP.  For example, in the case\
    \ of a\n         firewalled network, the security proxy requests that the\n  \
    \       necessary pinholes in the firewall are opened when a client in\n     \
    \    the protected network wants to access media streams on the\n         external\
    \ side.  This proxy can perform its function without\n         redirecting the\
    \ media between the server and client.  However,\n         in deployments with\
    \ private address spaces, this proxy is\n         likely to be combined with the\
    \ access proxy.  The functionality\n         of this proxy is usually closely\
    \ tied into understanding all\n         aspects of the media transport.\n   Auditing\
    \ Proxy:  RTSP proxies can also provide network owners with a\n         logging\
    \ and auditing point for RTSP sessions, e.g., for\n         corporations that\
    \ track their employees usage of the network.\n         This type of proxy can\
    \ perform its function without inserting\n         itself or any other node in\
    \ the media transport.  This proxy\n         type can also accept unknown methods\
    \ as it doesn't interfere\n         with the clients' requests.\n   All types\
    \ of proxies can also be used when using secured\n   communication with TLS, as\
    \ RTSP 2.0 allows the client to approve\n   certificate chains used for connection\
    \ establishment from a proxy;\n   see Section 19.3.2.  However, that trust model\
    \ may not be suitable\n   for all types of deployment.  In those cases, the secured\
    \ sessions do\n   bypass the proxies.\n   Access proxies SHOULD NOT be used in\
    \ equipment like NATs and\n   firewalls that aren't expected to be regularly maintained,\
    \ like home\n   or small office equipment.  In these cases, it is better to use\
    \ the\n   NAT traversal procedures defined for RTSP 2.0 [RFC7825].  The reason\n\
    \   for these recommendations is that any extensions of RTSP resulting in\n  \
    \ new media-transport protocols or profiles, new parameters, etc., may\n   fail\
    \ in a proxy that isn't maintained.  This would impede RTSP's\n   future development\
    \ and usage.\n"
- title: 15.1.  Proxies and Protocol Extensions
  contents:
  - "15.1.  Proxies and Protocol Extensions\n   The existence of proxies must always\
    \ be considered when developing\n   new RTSP extensions.  Most types of proxies\
    \ will need to implement\n   any new method to operate correctly in the presence\
    \ of that\n   extension.  New headers can be introduced and will not be blocked\
    \ by\n   older proxies.  However, it is important to consider if this header\n\
    \   and its function are required to be understood by the proxy or if it\n   can\
    \ be simply forwarded.  If the header needs to be understood, a\n   feature tag\
    \ representing the functionality MUST be included in the\n   Proxy-Require header.\
    \  Below are guidelines for analysis whether the\n   header needs to be understood.\
    \  The Transport header and its\n   parameters are extensible, which requires\
    \ handling rules for a proxy\n   in order to ensure a correct interpretation.\n\
    \   Whether or not a proxy needs to understand a header is not easy to\n   determine\
    \ as they serve a broad variety of functions.  When\n   evaluating if a header\
    \ needs to be understood, one can divide the\n   functionality into three main\
    \ categories:\n   Media modifying:  The caching and translator proxies modify\
    \ the\n      actual media and therefore need also to understand the request\n\
    \      directed to the server that affects how the media is rendered.\n      Thus,\
    \ this type of proxy also needs to understand the server-side\n      functionality.\n\
    \   Transport modifying:  The access and the security proxy both need to\n   \
    \   understand how the media transport is performed, either for\n      opening\
    \ pinholes or translating the outer headers, e.g., IP and\n      UDP or TCP.\n\
    \   Non-modifying:  The audit proxy is special in that it does not modify\n  \
    \    the messages in other ways than to insert the Via header.  That\n      makes\
    \ it possible for this type to forward RTSP messages that\n      contain different\
    \ types of unknown methods, headers, or header\n      parameters.\n   An extension\
    \ has to be classified as mandatory to be implemented for\n   a proxy, if an extension\
    \ has to be understood by a \"Transport\n   modifying\" type of proxy.\n"
- title: 15.2.  Multiplexing and Demultiplexing of Messages
  contents:
  - "15.2.  Multiplexing and Demultiplexing of Messages\n   RTSP proxies may have\
    \ to multiplex several RTSP sessions from their\n   clients towards RTSP servers.\
    \  This requires that RTSP requests from\n   multiple clients be multiplexed onto\
    \ a common connection for requests\n   outgoing to an RTSP server, and, on the\
    \ way back, the responses be\n   demultiplexed from the server to per-client responses.\
    \  On the\n   protocol level, this requires that request and response messages\
    \ be\n   handled in both directions, requiring that there be a mechanism to\n\
    \   correlate which request/response pair exchanged between proxy and\n   server\
    \ is mapped to which client (or client request).\n   This multiplexing of requests\
    \ and demultiplexing of responses is done\n   by using the CSeq header field.\
    \  The proxy has to rewrite the CSeq in\n   requests to the server and responses\
    \ from the server and remember\n   which CSeq is mapped to which client.  The\
    \ proxy also needs to ensure\n   that the order of the message related to each\
    \ client is maintained.\n   Section 18.20 defines the handling of how requests\
    \ and responses are\n   rewritten.\n"
- title: 16.  Caching
  contents:
  - "16.  Caching\n   In HTTP, request/response pairs are cached.  RTSP differs\n\
    \   significantly in that respect.  Responses are not cacheable, with the\n  \
    \ exception of the presentation description returned by DESCRIBE.\n   (Since the\
    \ responses for anything but DESCRIBE and GET_PARAMETER do\n   not return any\
    \ data, caching is not really an issue for these\n   requests.)  However, it is\
    \ desirable for the continuous media data,\n   typically delivered out-of-band\
    \ with respect to RTSP, to be cached,\n   as well as the session description.\n\
    \   On receiving a SETUP or PLAY request, a proxy ascertains whether it\n   has\
    \ an up-to-date copy of the continuous media content and its\n   description.\
    \  It can determine whether the copy is up to date by\n   issuing a SETUP or DESCRIBE\
    \ request, respectively, and comparing the\n   Last-Modified header with that\
    \ of the cached copy.  If the copy is\n   not up to date, it modifies the SETUP\
    \ transport parameters as\n   appropriate and forwards the request to the origin\
    \ server.\n   Subsequent control commands such as PLAY or PAUSE then pass the\
    \ proxy\n   unmodified.  The proxy delivers the continuous media data to the\n\
    \   client, while possibly making a local copy for later reuse.  The\n   exact\
    \ allowed behavior of the cache is given by the cache-response\n   directives\
    \ described in Section 18.11.  A cache MUST answer any\n   DESCRIBE requests if\
    \ it is currently serving the stream to the\n   requester, as it is possible that\
    \ low-level details of the stream\n   description may have changed on the origin\
    \ server.\n   Note that an RTSP cache is of the \"cut-through\" variety.  Rather\
    \ than\n   retrieving the whole resource from the origin server, the cache\n \
    \  simply copies the streaming data as it passes by on its way to the\n   client.\
    \  Thus, it does not introduce additional latency.\n   To the client, an RTSP\
    \ proxy cache appears like a regular media\n   server.  To the media origin server,\
    \ an RTSP proxy cache appears like\n   a client.  Just as an HTTP cache has to\
    \ store the content type,\n   content language, and so on for the objects it caches,\
    \ a media cache\n   has to store the presentation description.  Typically, a cache\n\
    \   eliminates all transport references (e.g., multicast information)\n   from\
    \ the presentation description, since these are independent of the\n   data delivery\
    \ from the cache to the client.  Information on the\n   encodings remains the\
    \ same.  If the cache is able to translate the\n   cached media data, it would\
    \ create a new presentation description\n   with all the encoding possibilities\
    \ it can offer.\n"
- title: 16.1.  Validation Model
  contents:
  - "16.1.  Validation Model\n   When a cache has a stale entry that it would like\
    \ to use as a\n   response to a client's request, it first has to check with the\
    \ origin\n   server (or possibly an intermediate cache with a fresh response)\
    \ to\n   see if its cached entry is still usable.  This is called \"validating\"\
    \n   the cache entry.  To avoid having to pay the overhead of\n   retransmitting\
    \ the full response if the cached entry is good, and at\n   the same time avoiding\
    \ having to pay the overhead of an extra round\n   trip if the cached entry is\
    \ invalid, RTSP supports the use of\n   conditional methods.\n   The key protocol\
    \ features for supporting conditional methods are\n   those concerned with \"\
    cache validators.\"  When an origin server\n   generates a full response, it attaches\
    \ some sort of validator to it,\n   which is kept with the cache entry.  When\
    \ a client (user agent or\n   proxy cache) makes a conditional request for a resource\
    \ for which it\n   has a cache entry, it includes the associated validator in\
    \ the\n   request.\n   The server then checks that validator against the current\
    \ validator\n   for the requested resource, and, if they match (see Section 16.1.3),\n\
    \   it responds with a special status code (usually, 304 (Not Modified))\n   and\
    \ no message body.  Otherwise, it returns a full response\n   (including message\
    \ body).  Thus, avoiding transmitting the full\n   response if the validator matches\
    \ and avoiding an extra round trip if\n   it does not match.\n   In RTSP, a conditional\
    \ request looks exactly the same as a normal\n   request for the same resource,\
    \ except that it carries a special\n   header (which includes the validator) that\
    \ implicitly turns the\n   method (usually DESCRIBE or SETUP) into a conditional.\n\
    \   The protocol includes both positive and negative senses of cache-\n   validating\
    \ conditions.  That is, it is possible to request that a\n   method be performed\
    \ either if and only if a validator matches or if\n   and only if no validators\
    \ match.\n      Note: a response that lacks a validator may still be cached, and\n\
    \      served from cache until it expires, unless this is explicitly\n      prohibited\
    \ by a cache directive (see Section 18.11).  However, a\n      cache cannot perform\
    \ a conditional retrieval if it does not have a\n      validator for the resource,\
    \ which means it will not be refreshable\n      after it expires.\n   Media streams\
    \ that are being adapted based on the transport capacity\n   between the server\
    \ and the cache make caching more difficult.  A\n   server needs to consider how\
    \ it views the caching of media streams\n   that it adapts and potentially instruct\
    \ any caches not to cache such\n   streams.\n"
- title: 16.1.1.  Last-Modified Dates
  contents:
  - "16.1.1.  Last-Modified Dates\n   The Last-Modified header (Section 18.27) value\
    \ is often used as a\n   cache validator.  In simple terms, a cache entry is considered\
    \ to be\n   valid if the cache entry was created after the Last-Modified time.\n"
- title: 16.1.2.  Message Body Tag Cache Validators
  contents:
  - "16.1.2.  Message Body Tag Cache Validators\n   The MTag response-header field-value,\
    \ a message body tag, provides\n   for an \"opaque\" cache validator.  This might\
    \ allow more reliable\n   validation in situations where it is inconvenient to\
    \ store\n   modification dates, where the one-second resolution of RTSP-date\n\
    \   values is not sufficient, or where the origin server wishes to avoid\n   certain\
    \ paradoxes that might arise from the use of modification\n   dates.\n   Message\
    \ body tags are described in Section 4.6\n"
- title: 16.1.3.  Weak and Strong Validators
  contents:
  - "16.1.3.  Weak and Strong Validators\n   Since both origin servers and caches\
    \ will compare two validators to\n   decide if they represent the same or different\
    \ entities, one normally\n   would expect that if the message body (i.e., the\
    \ presentation\n   description) or any associated message body headers changes\
    \ in any\n   way, then the associated validator would change as well.  If this\
    \ is\n   true, then this validator is a \"strong validator\".  The Message body\n\
    \   (i.e., the presentation description) or any associated message body\n   headers\
    \ is named an entity for a better understanding.\n   However, there might be cases\
    \ when a server prefers to change the\n   validator only on semantically significant\
    \ changes and not when\n   insignificant aspects of the entity change.  A validator\
    \ that does\n   not always change when the resource changes is a \"weak validator\"\
    .\n   Message body tags are normally strong validators, but the protocol\n   provides\
    \ a mechanism to tag a message body tag as \"weak\".  One can\n   think of a strong\
    \ validator as one that changes whenever the bits of\n   an entity changes, while\
    \ a weak value changes whenever the meaning of\n   an entity changes.  Alternatively,\
    \ one can think of a strong\n   validator as part of an identifier for a specific\
    \ entity, while a\n   weak validator is part of an identifier for a set of semantically\n\
    \   equivalent entities.\n      Note: One example of a strong validator is an\
    \ integer that is\n      incremented in stable storage every time an entity is\
    \ changed.\n      An entity's modification time, if represented with one-second\n\
    \      resolution, could be a weak validator, since it is possible that\n    \
    \  the resource might be modified twice during a single second.\n      Support\
    \ for weak validators is optional.  However, weak validators\n      allow for\
    \ more efficient caching of equivalent objects.\n   A \"use\" of a validator is\
    \ either when a client generates a request\n   and includes the validator in a\
    \ validating header field or when a\n   server compares two validators.\n   Strong\
    \ validators are usable in any context.  Weak validators are\n   only usable in\
    \ contexts that do not depend on exact equality of an\n   entity.  For example,\
    \ either kind is usable for a conditional\n   DESCRIBE of a full entity.  However,\
    \ only a strong validator is\n   usable for a subrange retrieval, since otherwise\
    \ the client might end\n   up with an internally inconsistent entity.\n   Clients\
    \ MAY issue DESCRIBE requests with either weak or strong\n   validators.  Clients\
    \ MUST NOT use weak validators in other forms of\n   requests.\n   The only function\
    \ that RTSP defines on validators is comparison.\n   There are two validator comparison\
    \ functions, depending on whether or\n   not the comparison context allows the\
    \ use of weak validators:\n   o  The strong comparison function: in order to be\
    \ considered equal,\n      both validators MUST be identical in every way, and\
    \ both MUST NOT\n      be weak.\n   o  The weak comparison function: in order\
    \ to be considered equal,\n      both validators MUST be identical in every way,\
    \ but either or both\n      of them MAY be tagged as \"weak\" without affecting\
    \ the result.\n   A message body tag is strong unless it is explicitly tagged\
    \ as weak.\n   A Last-Modified time, when used as a validator in a request, is\n\
    \   implicitly weak unless it is possible to deduce that it is strong,\n   using\
    \ the following rules:\n   o  The validator is being compared by an origin server\
    \ to the actual\n      current validator for the entity and,\n   o  That origin\
    \ server reliably knows that the associated entity did\n      not change more\
    \ than once during the second covered by the\n      presented validator.\n   OR\n\
    \   o  The validator is about to be used by a client in an If-Modified-\n    \
    \  Since, because the client has a cache entry for the associated\n      entity,\
    \ and\n   o  That cache entry includes a Date value, which gives the time when\n\
    \      the origin server sent the original response, and\n   o  The presented\
    \ Last-Modified time is at least 60 seconds before the\n      Date value.\n  \
    \ OR\n   o  The validator is being compared by an intermediate cache to the\n\
    \      validator stored in its cache entry for the entity, and\n   o  That cache\
    \ entry includes a Date value, which gives the time when\n      the origin server\
    \ sent the original response, and\n   o  The presented Last-Modified time is at\
    \ least 60 seconds before the\n      Date value.\n   This method relies on the\
    \ fact that if two different responses were\n   sent by the origin server during\
    \ the same second, but both had the\n   same Last-Modified time, then at least\
    \ one of those responses would\n   have a Date value equal to its Last-Modified\
    \ time.  The arbitrary\n   60-second limit guards against the possibility that\
    \ the Date and\n   Last-Modified values are generated from different clocks or\
    \ at\n   somewhat different times during the preparation of the response.  An\n\
    \   implementation MAY use a value larger than 60 seconds, if it is\n   believed\
    \ that 60 seconds is too short.\n   If a client wishes to perform a subrange retrieval\
    \ on a value for\n   which it has only a Last-Modified time and no opaque validator,\
    \ it\n   MAY do this only if the Last-Modified time is strong in the sense\n \
    \  described here.\n"
- title: 16.1.4.  Rules for When to Use Message Body Tags and Last-Modified Dates
  contents:
  - "16.1.4.  Rules for When to Use Message Body Tags and Last-Modified Dates\n  \
    \ This document adopts a set of rules and recommendations for origin\n   servers,\
    \ clients, and caches regarding when various validator types\n   ought to be used,\
    \ and for what purposes.\n   RTSP origin servers:\n   o  SHOULD send a message\
    \ body tag validator unless it is not feasible\n      to generate one.\n   o \
    \ MAY send a weak message body tag instead of a strong message body\n      tag,\
    \ if performance considerations support the use of weak message\n      body tags,\
    \ or if it is unfeasible to send a strong message body\n      tag.\n   o  SHOULD\
    \ send a Last-Modified value if it is feasible to send one,\n      unless the\
    \ risk of a breakdown in semantic transparency that could\n      result from using\
    \ this date in an If-Modified-Since header would\n      lead to serious problems.\n\
    \   In other words, the preferred behavior for an RTSP origin server is\n   to\
    \ send both a strong message body tag and a Last-Modified value.\n   In order\
    \ to be legal, a strong message body tag MUST change whenever\n   the associated\
    \ entity value changes in any way.  A weak message body\n   tag SHOULD change\
    \ whenever the associated entity changes in a\n   semantically significant way.\n\
    \      Note: in order to provide semantically transparent caching, an\n      origin\
    \ server MUST avoid reusing a specific strong message body\n      tag value for\
    \ two different entities or reusing a specific weak\n      message body tag value\
    \ for two semantically different entities.\n      Cache entries might persist\
    \ for arbitrarily long periods,\n      regardless of expiration times, so it might\
    \ be inappropriate to\n      expect that a cache will never again attempt to validate\
    \ an entry\n      using a validator that it obtained at some point in the past.\n\
    \   RTSP clients:\n   o  If a message body tag has been provided by the origin\
    \ server, MUST\n      use that message body tag in any cache-conditional request\
    \ (using\n      If-Match or If-None-Match).\n   o  If only a Last-Modified value\
    \ has been provided by the origin\n      server, SHOULD use that value in non-subrange\
    \ cache-conditional\n      requests (using If-Modified-Since).\n   o  If both\
    \ a message body tag and a Last-Modified value have been\n      provided by the\
    \ origin server, SHOULD use both validators in\n      cache-conditional requests.\n\
    \   An RTSP origin server, upon receiving a conditional request that\n   includes\
    \ both a Last-Modified date (e.g., in an If-Modified-Since\n   header) and one\
    \ or more message body tags (e.g., in an If-Match,\n   If-None-Match, or If-Range\
    \ header field) as cache validators, MUST\n   NOT return a response status of\
    \ 304 (Not Modified) unless doing so is\n   consistent with all of the conditional\
    \ header fields in the request.\n      Note: The general principle behind these\
    \ rules is that RTSP\n      servers and clients should transmit as much non-redundant\n\
    \      information as is available in their responses and requests.  RTSP\n  \
    \    systems receiving this information will make the most conservative\n    \
    \  assumptions about the validators they receive.\n"
- title: 16.1.5.  Non-validating Conditionals
  contents:
  - "16.1.5.  Non-validating Conditionals\n   The principle behind message body tags\
    \ is that only the service\n   author knows the semantics of a resource well enough\
    \ to select an\n   appropriate cache validation mechanism, and the specification\
    \ of any\n   validator comparison function more complex than octet equality would\n\
    \   open up a can of worms.  Thus, comparisons of any other headers are\n   never\
    \ used for purposes of validating a cache entry.\n"
- title: 16.2.  Invalidation after Updates or Deletions
  contents:
  - "16.2.  Invalidation after Updates or Deletions\n   The effect of certain methods\
    \ performed on a resource at the origin\n   server might cause one or more existing\
    \ cache entries to become non-\n   transparently invalid.  That is, although they\
    \ might continue to be\n   \"fresh,\" they do not accurately reflect what the\
    \ origin server would\n   return for a new request on that resource.\n   There\
    \ is no way for RTSP to guarantee that all such cache entries are\n   marked invalid.\
    \  For example, the request that caused the change at\n   the origin server might\
    \ not have gone through the proxy where a cache\n   entry is stored.  However,\
    \ several rules help reduce the likelihood\n   of erroneous behavior.\n   In this\
    \ section, the phrase \"invalidate an entity\" means that the\n   cache will either\
    \ remove all instances of that entity from its\n   storage or mark these as \"\
    invalid\" and in need of a mandatory\n   revalidation before they can be returned\
    \ in response to a subsequent\n   request.\n   Some RTSP methods MUST cause a\
    \ cache to invalidate an entity.  This\n   is either the entity referred to by\
    \ the Request-URI or by the\n   Location or Content-Location headers (if present).\
    \  These methods\n   are:\n   o  DESCRIBE\n   o  SETUP\n   In order to prevent\
    \ DoS attacks, an invalidation based on the URI in\n   a Location or Content-Location\
    \ header MUST only be performed if the\n   host part is the same as in the Request-URI.\n\
    \   A cache that passes through requests for methods it does not\n   understand\
    \ SHOULD invalidate any entities referred to by the Request-\n   URI.\n"
- title: 17.  Status Code Definitions
  contents:
  - "17.  Status Code Definitions\n   Where applicable, HTTP status codes (see Section\
    \ 6 of [RFC7231]) are\n   reused.  See Table 4 in Section 8.1 for a listing of\
    \ which status\n   codes may be returned by which requests.  All error messages,\
    \ 4xx and\n   5xx, MAY return a body containing further information about the\n\
    \   error.\n"
- title: 17.1.  Informational 1xx
  contents:
  - '17.1.  Informational 1xx

    '
- title: 17.1.1.  100 Continue
  contents:
  - "17.1.1.  100 Continue\n   The requesting agent SHOULD continue with its request.\
    \  This interim\n   response is used to inform the requesting agent that the initial\
    \ part\n   of the request has been received and has not yet been rejected by the\n\
    \   responding agent.  The requesting agent SHOULD continue by sending\n   the\
    \ remainder of the request or, if the request has already been\n   completed,\
    \ continue to wait for a final response (see Section 10.4).\n   The responding\
    \ agent MUST send a final response after the request has\n   been completed.\n"
- title: 17.2.  Success 2xx
  contents:
  - "17.2.  Success 2xx\n   This class of status code indicates that the agent's request\
    \ was\n   successfully received, understood, and accepted.\n"
- title: 17.2.1.  200 OK
  contents:
  - "17.2.1.  200 OK\n   The request has succeeded.  The information returned with\
    \ the\n   response is dependent on the method used in the request.\n"
- title: 17.3.  Redirection 3xx
  contents:
  - "17.3.  Redirection 3xx\n   The notation \"3xx\" indicates response codes from\
    \ 300 to 399 inclusive\n   that are meant for redirection.  We use the notation\
    \ \"3rr\" to\n   indicate all 3xx codes used for redirection, i.e., excluding\
    \ 304.\n   The 304 response code appears here, rather than a 2xx response code,\n\
    \   which would have been appropriate; 304 has also been used in RTSP 1.0\n  \
    \ [RFC2326].\n   Within RTSP, redirection may be used for load-balancing or\n\
    \   redirecting stream requests to a server topologically closer to the\n   agent.\
    \  Mechanisms to determine topological proximity are beyond the\n   scope of this\
    \ specification.\n   A 3rr code MAY be used to respond to any request.  The Location\n\
    \   header MUST be included in any 3rr response.  It is RECOMMENDED that\n   they\
    \ are used if necessary before a session is established, i.e., in\n   response\
    \ to DESCRIBE or SETUP.  However, in cases where a server is\n   not able to send\
    \ a REDIRECT request to the agent, the server MAY need\n   to resort to using\
    \ 3rr responses to inform an agent with an\n   established session about the need\
    \ for redirecting the session.  If a\n   3rr response is received for a request\
    \ in relation to an established\n   session, the agent SHOULD send a TEARDOWN\
    \ request for the session and\n   MAY reestablish the session using the resource\
    \ indicated by the\n   Location.\n   If the Location header is used in a response,\
    \ it MUST contain an\n   absolute URI pointing out the media resource the agent\
    \ is redirected\n   to; the URI MUST NOT only contain the hostname.\n   In the\
    \ event that an unknown 3rr status code is received, the agent\n   SHOULD behave\
    \ as if a 302 response code had been received\n   (Section 17.3.3).\n"
- title: 17.3.1.  300
  contents:
  - "17.3.1.  300\n   The 300 response code is not used in RTSP 2.0.\n"
- title: 17.3.2.  301 Moved Permanently
  contents:
  - "17.3.2.  301 Moved Permanently\n   The requested resource is moved permanently\
    \ and resides now at the\n   URI given by the Location header.  The user agent\
    \ SHOULD redirect\n   automatically to the given URI.  This response MUST NOT\
    \ contain a\n   message body.  The Location header MUST be included in the response.\n"
- title: 17.3.3.  302 Found
  contents:
  - "17.3.3.  302 Found\n   The requested resource resides temporarily at the URI\
    \ given by the\n   Location header.  This response is intended to be used for\
    \ many types\n   of temporary redirects, e.g., load balancing.  It is RECOMMENDED\
    \ that\n   the server set the reason phrase to something more meaningful than\n\
    \   \"Found\" in these cases.  The Location header MUST be included in the\n \
    \  response.  The user agent SHOULD redirect automatically to the given\n   URI.\
    \  This response MUST NOT contain a message body.\n   This example shows a client\
    \ being redirected to a different server:\n     C->S: SETUP rtsp://example.com/fizzle/foo\
    \ RTSP/2.0\n           CSeq: 2\n           Transport: RTP/AVP/TCP;unicast;interleaved=0-1\n\
    \           Accept-Ranges: npt, smpte, clock\n           User-Agent: PhonyClient/1.2\n\
    \     S->C: RTSP/2.0 302 Try Other Server\n           CSeq: 2\n           Location:\
    \ rtsp://s2.example.com:8001/fizzle/foo\n"
- title: 17.3.4.  303 See Other
  contents:
  - "17.3.4.  303 See Other\n   This status code MUST NOT be used in RTSP 2.0.  However,\
    \ it was\n   allowed in RTSP 1.0 [RFC2326].\n"
- title: 17.3.5.  304 Not Modified
  contents:
  - "17.3.5.  304 Not Modified\n   If the agent has performed a conditional DESCRIBE\
    \ or SETUP (see\n   Sections 18.25 and 18.26) and the requested resource has not\
    \ been\n   modified, the server SHOULD send a 304 response.  This response MUST\n\
    \   NOT contain a message body.\n   The response MUST include the following header\
    \ fields:\n   o  Date\n   o  MTag or Content-Location, if the headers would have\
    \ been sent in a\n      200 response to the same request.\n   o  Expires and Cache-Control\
    \ if the field-value might differ from\n      that sent in any previous response\
    \ for the same variant.\n   This response is independent for the DESCRIBE and\
    \ SETUP requests.\n   That is, a 304 response to DESCRIBE does NOT imply that\
    \ the resource\n   content is unchanged (only the session description) and a 304\n\
    \   response to SETUP does NOT imply that the resource description is\n   unchanged.\
    \  The MTag and If-Match header (Section 18.24) may be used\n   to link the DESCRIBE\
    \ and SETUP in this manner.\n"
- title: 17.3.6.  305 Use Proxy
  contents:
  - "17.3.6.  305 Use Proxy\n   The requested resource MUST be accessed through the\
    \ proxy given by\n   the Location header that MUST be included.  The Location\
    \ header\n   field-value gives the URI of the proxy.  The recipient is expected\
    \ to\n   repeat this single request via the proxy. 305 responses MUST only be\n\
    \   generated by origin servers.\n"
- title: 17.4.  Client Error 4xx
  contents:
  - '17.4.  Client Error 4xx

    '
- title: 17.4.1.  400 Bad Request
  contents:
  - "17.4.1.  400 Bad Request\n   The request could not be understood by the agent\
    \ due to malformed\n   syntax.  The agent SHOULD NOT repeat the request without\n\
    \   modifications.  If the request does not have a CSeq header, the agent\n  \
    \ MUST NOT include a CSeq in the response.\n"
- title: 17.4.2.  401 Unauthorized
  contents:
  - "17.4.2.  401 Unauthorized\n   The request requires user authentication using\
    \ the HTTP\n   authentication mechanism [RFC7235].  The usage of the error code\
    \ is\n   defined in [RFC7235] and any applicable HTTP authentication scheme,\n\
    \   such as Digest [RFC7616].  The response is to include a WWW-\n   Authenticate\
    \ header (Section 18.58) field containing a challenge\n   applicable to the requested\
    \ resource.  The agent can repeat the\n   request with a suitable Authorization\
    \ header field.  If the request\n   already included authorization credentials,\
    \ then the 401 response\n   indicates that authorization has been refused for\
    \ those credentials.\n   If the 401 response contains the same challenge as the\
    \ prior\n   response, and the user agent has already attempted authentication\
    \ at\n   least once, then the user SHOULD be presented the message body that\n\
    \   was given in the response, since that message body might include\n   relevant\
    \ diagnostic information.\n"
- title: 17.4.3.  402 Payment Required
  contents:
  - "17.4.3.  402 Payment Required\n   This code is reserved for future use.\n"
- title: 17.4.4.  403 Forbidden
  contents:
  - "17.4.4.  403 Forbidden\n   The agent understood the request, but is refusing\
    \ to fulfill it.\n   Authorization will not help, and the request SHOULD NOT be\
    \ repeated.\n   If the agent wishes to make public why the request has not been\n\
    \   fulfilled, it SHOULD describe the reason for the refusal in the\n   message\
    \ body.  If the agent does not wish to make this information\n   available to\
    \ the agent, the status code 404 (Not Found) can be used\n   instead.\n"
- title: 17.4.5.  404 Not Found
  contents:
  - "17.4.5.  404 Not Found\n   The agent has not found anything matching the Request-URI.\
    \  No\n   indication is given of whether the condition is temporary or\n   permanent.\
    \  The 410 (Gone) status code SHOULD be used if the agent\n   knows, through some\
    \ internally configurable mechanism, that an old\n   resource is permanently unavailable\
    \ and has no forwarding address.\n   This status code is commonly used when the\
    \ agent does not wish to\n   reveal exactly why the request has been refused,\
    \ or when no other\n   response is applicable.\n"
- title: 17.4.6.  405 Method Not Allowed
  contents:
  - "17.4.6.  405 Method Not Allowed\n   The method specified in the request is not\
    \ allowed for the resource\n   identified by the Request-URI.  The response MUST\
    \ include an Allow\n   header containing a list of valid methods for the requested\
    \ resource.\n   This status code is also to be used if a request attempts to use\
    \ a\n   method not indicated during SETUP.\n"
- title: 17.4.7.  406 Not Acceptable
  contents:
  - "17.4.7.  406 Not Acceptable\n   The resource identified by the request is only\
    \ capable of generating\n   response message bodies that have content characteristics\
    \ not\n   acceptable according to the Accept headers sent in the request.\n  \
    \ The response SHOULD include a message body containing a list of\n   available\
    \ message body characteristics and location(s) from which the\n   user or user\
    \ agent can choose the one most appropriate.  The message\n   body format is specified\
    \ by the media type given in the Content-Type\n   header field.  Depending upon\
    \ the format and the capabilities of the\n   user agent, selection of the most\
    \ appropriate choice MAY be performed\n   automatically.  However, this specification\
    \ does not define any\n   standard for such automatic selection.\n   If the response\
    \ could be unacceptable, a user agent SHOULD\n   temporarily stop receipt of more\
    \ data and query the user for a\n   decision on further actions.\n"
- title: 17.4.8.  407 Proxy Authentication Required
  contents:
  - "17.4.8.  407 Proxy Authentication Required\n   This code is similar to 401 (Unauthorized)\
    \ (Section 17.4.2), but it\n   indicates that the client must first authenticate\
    \ itself with the\n   proxy.  The usage of this error code is defined in [RFC7235]\
    \ and any\n   applicable HTTP authentication scheme, such as Digest [RFC7616].\
    \  The\n   proxy MUST return a Proxy-Authenticate header field (Section 18.34)\n\
    \   containing a challenge applicable to the proxy for the requested\n   resource.\n"
- title: 17.4.9.  408 Request Timeout
  contents:
  - "17.4.9.  408 Request Timeout\n   The agent did not produce a request within the\
    \ time that the agent\n   was prepared to wait.  The agent MAY repeat the request\
    \ without\n   modifications at any later time.\n"
- title: 17.4.10.  410 Gone
  contents:
  - "17.4.10.  410 Gone\n   The requested resource is no longer available at the server\
    \ and the\n   forwarding address is not known.  This condition is expected to\
    \ be\n   considered permanent.  If the server does not know, or has no\n   facility\
    \ to determine, whether or not the condition is permanent, the\n   status code\
    \ 404 (Not Found) SHOULD be used instead.  This response is\n   cacheable unless\
    \ indicated otherwise.\n   The 410 response is primarily intended to assist the\
    \ task of\n   repository maintenance by notifying the recipient that the resource\n\
    \   is intentionally unavailable and that the server owners desire that\n   remote\
    \ links to that resource be removed.  Such an event is common\n   for limited-time,\
    \ promotional services and for resources belonging to\n   individuals no longer\
    \ working at the server's site.  It is not\n   necessary to mark all permanently\
    \ unavailable resources as \"gone\" or\n   to keep the mark for any length of\
    \ time -- that is left to the\n   discretion of the owner of the server.\n"
- title: 17.4.11.  412 Precondition Failed
  contents:
  - "17.4.11.  412 Precondition Failed\n   The precondition given in one or more of\
    \ the 'if-' request-header\n   fields evaluated to false when it was tested on\
    \ the agent.  See these\n   sections for the 'if-' headers: If-Match Section 18.24,\
    \ If-Modified-\n   Since Section 18.25, and If-None-Match Section 18.26.  This\
    \ response\n   code allows the agent to place preconditions on the current resource\n\
    \   meta-information (header field data) and, thus, prevent the requested\n  \
    \ method from being applied to a resource other than the one intended.\n"
- title: 17.4.12.  413 Request Message Body Too Large
  contents:
  - "17.4.12.  413 Request Message Body Too Large\n   The agent is refusing to process\
    \ a request because the request\n   message body is larger than the agent is willing\
    \ or able to process.\n   The agent MAY close the connection to prevent the requesting\
    \ agent\n   from continuing the request.\n   If the condition is temporary, the\
    \ agent SHOULD include a Retry-After\n   header field to indicate that it is temporary\
    \ and after what time the\n   requesting agent MAY try again.\n"
- title: 17.4.13.  414 Request-URI Too Long
  contents:
  - "17.4.13.  414 Request-URI Too Long\n   The responding agent is refusing to service\
    \ the request because the\n   Request-URI is longer than the agent is willing\
    \ to interpret.  This\n   rare condition is only likely to occur when an agent\
    \ has used a\n   request with long query information, when the agent has descended\n\
    \   into a URI \"black hole\" of redirection (e.g., a redirected URI prefix\n\
    \   that points to a suffix of itself), or when the agent is under attack\n  \
    \ by an agent attempting to exploit security holes present in some\n   agents\
    \ using fixed-length buffers for reading or manipulating the\n   Request-URI.\n"
- title: 17.4.14.  415 Unsupported Media Type
  contents:
  - "17.4.14.  415 Unsupported Media Type\n   The server is refusing to service the\
    \ request because the message\n   body of the request is in a format not supported\
    \ by the requested\n   resource for the requested method.\n"
- title: 17.4.15.  451 Parameter Not Understood
  contents:
  - "17.4.15.  451 Parameter Not Understood\n   The recipient of the request does\
    \ not support one or more parameters\n   contained in the request.  When returning\
    \ this error message the\n   agent SHOULD return a message body containing the\
    \ offending\n   parameter(s).\n"
- title: 17.4.16.  452 Illegal Conference Identifier
  contents:
  - "17.4.16.  452 Illegal Conference Identifier\n   This status code MUST NOT be\
    \ used in RTSP 2.0.  However, it was\n   allowed in RTSP 1.0 [RFC2326].\n"
- title: 17.4.17.  453 Not Enough Bandwidth
  contents:
  - "17.4.17.  453 Not Enough Bandwidth\n   The request was refused because there\
    \ was insufficient bandwidth.\n   This may, for example, be the result of a resource\
    \ reservation\n   failure.\n"
- title: 17.4.18.  454 Session Not Found
  contents:
  - "17.4.18.  454 Session Not Found\n   The RTSP session identifier in the Session\
    \ header is missing, is\n   invalid, or has timed out.\n"
- title: 17.4.19.  455 Method Not Valid in This State
  contents:
  - "17.4.19.  455 Method Not Valid in This State\n   The agent cannot process this\
    \ request in its current state.  The\n   response MUST contain an Allow header\
    \ to make error recovery\n   possible.\n"
- title: 17.4.20.  456 Header Field Not Valid for Resource
  contents:
  - "17.4.20.  456 Header Field Not Valid for Resource\n   The targeted agent could\
    \ not act on a required request-header.  For\n   example, if PLAY request contains\
    \ the Range header field but the\n   stream does not allow seeking.  This error\
    \ message may also be used\n   for specifying when the time format in Range is\
    \ impossible for the\n   resource.  In that case, the Accept-Ranges header MUST\
    \ be returned to\n   inform the agent of which formats are allowed.\n"
- title: 17.4.21.  457 Invalid Range
  contents:
  - "17.4.21.  457 Invalid Range\n   The Range value given is out of bounds, e.g.,\
    \ beyond the end of the\n   presentation.\n"
- title: 17.4.22.  458 Parameter Is Read-Only
  contents:
  - "17.4.22.  458 Parameter Is Read-Only\n   The parameter to be set by SET_PARAMETER\
    \ can be read but not\n   modified.  When returning this error message, the sender\
    \ SHOULD\n   return a message body containing the offending parameter(s).\n"
- title: 17.4.23.  459 Aggregate Operation Not Allowed
  contents:
  - "17.4.23.  459 Aggregate Operation Not Allowed\n   The requested method may not\
    \ be applied on the URI in question since\n   it is an aggregate (presentation)\
    \ URI.  The method may be applied on\n   a media URI.\n"
- title: 17.4.24.  460 Only Aggregate Operation Allowed
  contents:
  - "17.4.24.  460 Only Aggregate Operation Allowed\n   The requested method may not\
    \ be applied on the URI in question since\n   it is not an aggregate control (presentation)\
    \ URI.  The method may be\n   applied on the aggregate control URI.\n"
- title: 17.4.25.  461 Unsupported Transport
  contents:
  - "17.4.25.  461 Unsupported Transport\n   The Transport field did not contain a\
    \ supported transport\n   specification.\n"
- title: 17.4.26.  462 Destination Unreachable
  contents:
  - "17.4.26.  462 Destination Unreachable\n   The data transmission channel could\
    \ not be established because the\n   agent address could not be reached.  This\
    \ error will most likely be\n   the result of an agent attempt to place an invalid\
    \ dest_addr\n   parameter in the Transport field.\n"
- title: 17.4.27.  463 Destination Prohibited
  contents:
  - "17.4.27.  463 Destination Prohibited\n   The data transmission channel was not\
    \ established because the server\n   prohibited access to the agent address. \
    \ This error is most likely\n   the result of an agent attempt to redirect media\
    \ traffic to another\n   destination with a dest_addr parameter in the Transport\
    \ header.\n"
- title: 17.4.28.  464 Data Transport Not Ready Yet
  contents:
  - "17.4.28.  464 Data Transport Not Ready Yet\n   The data transmission channel\
    \ to the media destination is not yet\n   ready for carrying data.  However, the\
    \ responding agent still expects\n   that the data transmission channel will be\
    \ established at some point\n   in time.  Note, however, that this may result\
    \ in a permanent failure\n   like 462 (Destination Unreachable).\n   An example\
    \ of when this error may occur is in the case in which a\n   client sends a PLAY\
    \ request to a server prior to ensuring that the\n   TCP connections negotiated\
    \ for carrying media data were successfully\n   established (in violation of this\
    \ specification).  The server would\n   use this error code to indicate that the\
    \ requested action could not\n   be performed due to the failure of completing\
    \ the connection\n   establishment.\n"
- title: 17.4.29.  465 Notification Reason Unknown
  contents:
  - "17.4.29.  465 Notification Reason Unknown\n   This indicates that the client\
    \ has received a PLAY_NOTIFY\n   (Section 13.5) with a Notify-Reason header (Section\
    \ 18.32) unknown to\n   the client.\n"
- title: 17.4.30.  466 Key Management Error
  contents:
  - "17.4.30.  466 Key Management Error\n   This indicates that there has been an\
    \ error in a Key Management\n   function used in conjunction with a request. \
    \ For example, usage of\n   Multimedia Internet KEYing (MIKEY) [RFC3830] according\
    \ to\n   Appendix C.1.4.1 may result in this error.\n"
- title: 17.4.31.  470 Connection Authorization Required
  contents:
  - "17.4.31.  470 Connection Authorization Required\n   The secured connection attempt\
    \ needs user or client authorization\n   before proceeding.  The next hop's certificate\
    \ is included in this\n   response in the Accept-Credentials header.\n"
- title: 17.4.32.  471 Connection Credentials Not Accepted
  contents:
  - "17.4.32.  471 Connection Credentials Not Accepted\n   When performing a secure\
    \ connection over multiple connections, an\n   intermediary has refused to connect\
    \ to the next hop and carry out the\n   request due to unacceptable credentials\
    \ for the used policy.\n"
- title: 17.4.33.  472 Failure to Establish Secure Connection
  contents:
  - "17.4.33.  472 Failure to Establish Secure Connection\n   A proxy fails to establish\
    \ a secure connection to the next-hop RTSP\n   agent.  This is primarily caused\
    \ by a fatal failure at the TLS\n   handshake, for example, due to the agent not\
    \ accepting any cipher\n   suites.\n"
- title: 17.5.  Server Error 5xx
  contents:
  - "17.5.  Server Error 5xx\n   Response status codes beginning with the digit \"\
    5\" indicate cases in\n   which the server is aware that it has erred or is incapable\
    \ of\n   performing the request.  The server SHOULD include a message body\n \
    \  containing an explanation of the error situation and whether it is a\n   temporary\
    \ or permanent condition.  User agents SHOULD display any\n   included message\
    \ body to the user.  These response codes are\n   applicable to any request method.\n"
- title: 17.5.1.  500 Internal Server Error
  contents:
  - "17.5.1.  500 Internal Server Error\n   The agent encountered an unexpected condition\
    \ that prevented it from\n   fulfilling the request.\n"
- title: 17.5.2.  501 Not Implemented
  contents:
  - "17.5.2.  501 Not Implemented\n   The agent does not support the functionality\
    \ required to fulfill the\n   request.  This is the appropriate response when\
    \ the agent does not\n   recognize the request method and is not capable of supporting\
    \ it for\n   any resource.\n"
- title: 17.5.3.  502 Bad Gateway
  contents:
  - "17.5.3.  502 Bad Gateway\n   The agent, while acting as a gateway or proxy, received\
    \ an invalid\n   response from the upstream agent it accessed in attempting to\
    \ fulfill\n   the request.\n"
- title: 17.5.4.  503 Service Unavailable
  contents:
  - "17.5.4.  503 Service Unavailable\n   The server is currently unable to handle\
    \ the request due to a\n   temporary overloading or maintenance of the server.\
    \  The implication\n   is that this is a temporary condition that will be alleviated\
    \ after\n   some delay.  If known, the length of the delay MAY be indicated in\
    \ a\n   Retry-After header.  If no Retry-After is given, the agent SHOULD\n  \
    \ handle the response as it would for a 500 response.  The agent MUST\n   honor\
    \ the length, if given, in the Retry-After header.\n         Note: The existence\
    \ of the 503 status code does not imply that\n         a server must use it when\
    \ becoming overloaded.  Some servers\n         may wish to simply refuse the transport\
    \ connection.\n   The response scope is dependent on the request.  If the request\
    \ was\n   in relation to an existing RTSP session, the scope of the overload\n\
    \   response is to this individual RTSP session.  If the request was not\n   session\
    \ specific or intended to form an RTSP session, it applies to\n   the RTSP server\
    \ identified by the hostname in the Request-URI.\n"
- title: 17.5.5.  504 Gateway Timeout
  contents:
  - "17.5.5.  504 Gateway Timeout\n   The agent, while acting as a proxy, did not\
    \ receive a timely response\n   from the upstream agent specified by the URI or\
    \ some other auxiliary\n   server (e.g., DNS) that it needed to access in attempting\
    \ to complete\n   the request.\n"
- title: 17.5.6.  505 RTSP Version Not Supported
  contents:
  - "17.5.6.  505 RTSP Version Not Supported\n   The agent does not support, or refuses\
    \ to support, the RTSP version\n   that was used in the request message.  The\
    \ agent is indicating that\n   it is unable or unwilling to complete the request\
    \ using the same\n   major version as the agent other than with this error message.\
    \  The\n   response SHOULD contain a message body describing why that version\
    \ is\n   not supported and what other protocols are supported by that agent.\n"
- title: 17.5.7.  551 Option Not Supported
  contents:
  - "17.5.7.  551 Option Not Supported\n   A feature tag given in the Require or the\
    \ Proxy-Require fields was\n   not supported.  The Unsupported header MUST be\
    \ returned stating the\n   feature for which there is no support.\n"
- title: 17.5.8.  553 Proxy Unavailable
  contents:
  - "17.5.8.  553 Proxy Unavailable\n   The proxy is currently unable to handle the\
    \ request due to a\n   temporary overloading or maintenance of the proxy.  The\
    \ implication\n   is that this is a temporary condition that will be alleviated\
    \ after\n   some delay.  If known, the length of the delay MAY be indicated in\
    \ a\n   Retry-After header.  If no Retry-After is given, the agent SHOULD\n  \
    \ handle the response as it would for a 500 response.  The agent MUST\n   honor\
    \ the length, if given in the Retry-After header.\n         Note: The existence\
    \ of the 553 status code does not imply that\n         a proxy must use it when\
    \ becoming overloaded.  Some proxies may\n         wish to simply refuse the connection.\n\
    \   The response scope is dependent on the Request.  If the request was\n   in\
    \ relation to an existing RTSP session, the scope of the overload\n   response\
    \ is to this individual RTSP session.  If the request was non-\n   session specific\
    \ or intended to form an RTSP session, it applies to\n   all such requests to\
    \ this proxy.\n"
- title: 18.  Header Field Definitions
  contents:
  - "18.  Header Field Definitions\n       +---------------+----------------+--------+---------+------+\n\
    \       | method        | direction      | object | acronym | Body |\n       +---------------+----------------+--------+---------+------+\n\
    \       | DESCRIBE      | C -> S         | P,S    | DES     | r    |\n       |\
    \               |                |        |         |      |\n       | GET_PARAMETER\
    \ | C -> S, S -> C | P,S    | GPR     | R,r  |\n       |               |     \
    \           |        |         |      |\n       | OPTIONS       | C -> S, S ->\
    \ C | P,S    | OPT     |      |\n       |               |                |   \
    \     |         |      |\n       | PAUSE         | C -> S         | P,S    | PSE\
    \     |      |\n       |               |                |        |         | \
    \     |\n       | PLAY          | C -> S         | P,S    | PLY     |      |\n\
    \       |               |                |        |         |      |\n       |\
    \ PLAY_NOTIFY   | S -> C         | P,S    | PNY     | R    |\n       |       \
    \        |                |        |         |      |\n       | REDIRECT     \
    \ | S -> C         | P,S    | RDR     |      |\n       |               |     \
    \           |        |         |      |\n       | SETUP         | C -> S     \
    \    | S      | STP     |      |\n       |               |                |  \
    \      |         |      |\n       | SET_PARAMETER | C -> S, S -> C | P,S    |\
    \ SPR     | R,r  |\n       |               |                |        |       \
    \  |      |\n       | TEARDOWN      | C -> S         | P,S    | TRD     |    \
    \  |\n       |               |                |        |         |      |\n  \
    \     |               | S -> C         | P      | TRD     |      |\n       +---------------+----------------+--------+---------+------+\n\
    \   This table is an overview of RTSP methods, their direction, and what\n   objects\
    \ (P: presentation, S: stream) they operate on.  \"Body\" denotes\n     if a method\
    \ is allowed to carry body and in which direction; R =\n    request, r=response.\
    \  Note: All error messages for statuses 4xx and\n                     5xx are\
    \ allowed to carry a body.\n                     Table 8: Overview of RTSP Methods\n\
    \   The general syntax for header fields is covered in Section 5.2.  This\n  \
    \ section lists the full set of header fields along with notes on\n   meaning\
    \ and usage.  The syntax definitions for header fields are\n   present in Section\
    \ 20.2.3.  Examples of each header field are given.\n   Information about header\
    \ fields in relation to methods and proxy\n   processing is summarized in Figures\
    \ 2, 3, 4, and 5.\n   The \"where\" column describes the request and response\
    \ types in which\n   the header field can be used.  Values in this column are:\n\
    \   R:                header field may only appear in requests;\n   r:       \
    \         header field may only appear in responses;\n   2xx, 4xx, etc.:   numerical\
    \ value or range indicates response codes\n                     with which the\
    \ header field can be used;\n   c:                header field is copied from\
    \ the request to the\n                     response.\n   G:                header\
    \ field is a general-header and may be present\n                     in both requests\
    \ and responses.\n   Note: General headers do not always use the \"G\" value in\
    \ the \"where\"\n   column.  This is due to differences when the header may be\
    \ applied in\n   requests compared to responses.  When such differences exist,\
    \ they\n   are expressed using two different rows: one with \"where\" being \"\
    R\"\n   and one with it being \"r\".\n   The \"proxy\" column describes the operations\
    \ a proxy may perform on a\n   header field.  An empty proxy column indicates\
    \ that the proxy MUST\n   NOT make any changes to that header, all allowed operations\
    \ are\n   explicitly stated:\n   a:    A proxy can add or concatenate the header\
    \ field if not present.\n   m:    A proxy can modify an existing header field\
    \ value.\n   d:    A proxy can delete a header field-value.\n   r:    A proxy\
    \ needs to be able to read the header field; thus, this\n         header field\
    \ cannot be encrypted.\n   The rest of the columns relate to the presence of a\
    \ header field in a\n   method.  The method names when abbreviated, are according\
    \ to Table 8:\n   c:    Conditional; requirements on the header field depend on\
    \ the\n         context of the message.\n   m:    The header field is mandatory.\n\
    \   m*:   The header field SHOULD be sent, but agents need to be prepared\n  \
    \       to receive messages without that header field.\n   o:    The header field\
    \ is optional.\n   *:    The header field MUST be present if the message body\
    \ is not\n         empty.  See Sections 18.17, 18.19 and 5.3 for details.\n  \
    \ -:    The header field is not applicable.\n   \"Optional\" means that an agent\
    \ MAY include the header field in a\n   request or response.  The agent behavior\
    \ when receiving such headers\n   varies; for some, it may ignore the header field.\
    \  In other cases, it\n   is a request to process the header.  This is regulated\
    \ by the method\n   and header descriptions.  Examples of headers that require\
    \ processing\n   are the Require and Proxy-Require header fields discussed in\
    \ Sections\n   18.43 and 18.37.  A \"mandatory\" header field MUST be present\
    \ in a\n   request, and it MUST be understood by the agent receiving the\n   request.\
    \  A mandatory response-header field MUST be present in the\n   response, and\
    \ the header field MUST be understood by the processing\n   the response.  \"\
    Not applicable\" means that the header field MUST NOT\n   be present in a request.\
    \  If one is placed in a request by mistake,\n   it MUST be ignored by the agent\
    \ receiving the request.  Similarly, a\n   header field labeled \"not applicable\"\
    \ for a response means that the\n   agent MUST NOT place the header field in the\
    \ response, and the agent\n   MUST ignore the header field in the response.\n\
    \   An RTSP agent MUST ignore extension headers that are not understood.\n   The\
    \ From and Location header fields contain a URI.  If the URI\n   contains a comma\
    \ (') or semicolon (;), the URI MUST be enclosed in\n   double quotes (\").  Any\
    \ URI parameters are contained within these\n   quotes.  If the URI is not enclosed\
    \ in double quotes, any semicolon-\n   delimited parameters are header-parameters,\
    \ not URI parameters.\n   +-------------------+------+------+----+----+-----+-----+-----+-----+\n\
    \   | Header            |Where |Proxy |DES | OPT| STP | PLY | PSE | TRD |\n  \
    \ +-------------------+------+------+----+----+-----+-----+-----+-----+\n   |\
    \ Accept            | R    |      | o  | -  | -   | -   | -   | -   |\n   | Accept-\
    \           | R    | rm   | o  | o  | o   | o   | o   | o   |\n   | Credentials\
    \       |      |      |    |    |     |     |     |     |\n   | Accept-Encoding\
    \   | R    | r    | o  | -  | -   | -   | -   | -   |\n   | Accept-Language  \
    \ | R    | r    | o  | -  | -   | -   | -   | -   |\n   | Accept-Ranges     |\
    \ G    | r    | -  | -  | m   | -   | -   | -   |\n   | Accept-Ranges     | 456\
    \  | r    | -  | -  | -   | m   | -   | -   |\n   | Allow             | r    |\
    \ am   | c  | c  | c   | -   | -   | -   |\n   | Allow             | 405  | am\
    \   | m  | m  | m   | m   | m   | m   |\n   | Authentication-   | r    |     \
    \ | o  | o  | o   | o   | o   | o/- |\n   | Info              |      |      |\
    \    |    |     |     |     |     |\n   | Authorization     | R    |      | o\
    \  | o  | o   | o   | o   | o/- |\n   | Bandwidth         | R    |      | o  |\
    \ o  | o   | o   | -   | -   |\n   | Blocksize         | R    |      | o  | -\
    \  | o   | o   | -   | -   |\n   | Cache-Control     | G    | r    | o  | -  |\
    \ o   | -   | -   | -   |\n   | Connection        | G    | ad   | o  | o  | o\
    \   | o   | o   | o   |\n   | Connection-       | 470, | ar   | o  | o  | o  \
    \ | o   | o   | o   |\n   | Credentials       | 407  |      |    |    |     |\
    \     |     |     |\n   | Content-Base      | r    |      | o  | -  | -   | -\
    \   | -   | -   |\n   | Content-Base      | 4xx, |      | o  | o  | o   | o  \
    \ | o   | o   |\n   |                   | 5xx  |      |    |    |     |     |\
    \     |     |\n   | Content-Encoding  | R    | r    | -  | -  | -   | -   | -\
    \   | -   |\n   | Content-Encoding  | r    | r    | o  | -  | -   | -   | -  \
    \ | -   |\n   | Content-Encoding  | 4xx, | r    | o  | o  | o   | o   | o   |\
    \ o   |\n   |                   | 5xx  |      |    |    |     |     |     |  \
    \   |\n   | Content-Language  | R    | r    | -  | -  | -   | -   | -   | -  \
    \ |\n   | Content-Language  | r    | r    | o  | -  | -   | -   | -   | -   |\n\
    \   | Content-Language  | 4xx, | r    | o  | o  | o   | o   | o   | o   |\n  \
    \ |                   | 5xx  |      |    |    |     |     |     |     |\n   |\
    \ Content-Length    | r    | r    | *  | -  | -   | -   | -   | -   |\n   | Content-Length\
    \    | 4xx, | r    | *  | *  | *   | *   | *   | *   |\n   |                 \
    \  | 5xx  |      |    |    |     |     |     |     |\n   | Content-Location  |\
    \ r    | r    | o  | -  | -   | -   | -   | -   |\n   | Content-Location  | 4xx,\
    \ | r    | o  | o  | o   | o   | o   | o   |\n   |                   | 5xx  |\
    \      |    |    |     |     |     |     |\n   | Content-Type      | r    | r\
    \    | *  | -  | -   | -   | -   | -   |\n   | Content-Type      | 4xx, | ar \
    \  | *  | *  | *   | *   | *   | *   |\n   |                   | 5xx  |      |\
    \    |    |     |     |     |     |\n   | CSeq              | Gc   | rm   | m\
    \  | m  | m   | m   | m   | m   |\n   | Date              | G    | am   | o/*|\
    \ o/*| o/* | o/* | o/* | o/* |\n   | Expires           | r    | r    | o  | -\
    \  | o   | -   | -   | -   |\n   | From              | R    | r    | o  | o  |\
    \ o   | o   | o   | o   |\n   | If-Match          | R    | r    | -  | -  | o\
    \   | -   | -   | -   |\n   | If-Modified-Since | R    | r    | o  | -  | o  \
    \ | -   | -   | -   |\n   | If-None-Match     | R    | r    | o  | -  | o   |\
    \ -   | -   | -   |\n   | Last-Modified     | r    | r    | o  | -  | o   | -\
    \   | -   | -   |\n   | Location          | 3rr  |      | m  | m  | m   | m  \
    \ | m   | m   |\n   +-------------------+------+------+----+----+-----+-----+-----+-----+\n\
    \   | Header            |Where |Proxy |DES | OPT| STP | PLY | PSE | TRD |\n  \
    \ +-------------------+------+------+----+----+-----+-----+-----+-----+\n    \
    \ Figure 2: Overview of RTSP Header Fields (A-L) Related to Methods\n        \
    \    DESCRIBE, OPTIONS, SETUP, PLAY, PAUSE, and TEARDOWN\n   +------------------+---------+-----+----+----+----+-----+-----+-----+\n\
    \   | Header           | Where   |Proxy|DES |OPT |STP | PLY | PSE | TRD |\n  \
    \ +------------------+---------+-----+----+----+----+-----+-----+-----+\n   |\
    \ Media-Properties | r       |     | -  | -  | m  | o   | o   | -   |\n   | Media-Range\
    \      | r       |     | -  | -  | c  | c   | c   | -   |\n   | MTag         \
    \    | r       | r   | o  | -  | o  | -   | -   | -   |\n   | Pipelined-     \
    \  | G       | amd | -  | o  | o  | o   | o   | o   |\n   | Requests         |\
    \         | r   |    |    |    |     |     |     |\n   | Proxy-           | 407\
    \     | amr | m  | m  | m  | m   | m   | m   |\n   | Authenticate     |      \
    \   |     |    |    |    |     |     |     |\n   | Proxy-           | r      \
    \ | amd | o  | o  | o  | o   | o   | o/- |\n   | Authentication-  |         |\
    \ r   |    |    |    |     |     |     |\n   | Info             |         |  \
    \   |    |    |    |     |     |     |\n   | Proxy-           | R       | rd \
    \ | o  | o  | o  | o   | o   | o   |\n   | Authorization    |         |     |\
    \    |    |    |     |     |     |\n   | Proxy-Require    | R       | ar  | o\
    \  | o  | o  | o   | o   | o   |\n   | Proxy-Require    | r       | r   | c  |\
    \ c  | c  | c   | c   | c   |\n   | Proxy-Supported  | R       | amr | c  | c\
    \  | c  | c   | c   | c   |\n   | Proxy-Supported  | r       |     | c  | c  |\
    \ c  | c   | c   | c   |\n   | Public           | r       | amr | -  | m  | -\
    \  | -   | -   | -   |\n   | Public           | 501     | amr | m  | m  | m  |\
    \ m   | m   | m   |\n   | Range            | R       |     | -  | -  | -  | o\
    \   | -   | -   |\n   | Range            | r       |     | -  | -  | c  | m  \
    \ | m   | -   |\n   | Referrer         | R       |     | o  | o  | o  | o   |\
    \ o   | o   |\n   | Request-Status   | R       |     | -  | -  | -  | -   | -\
    \   | -   |\n   | Require          | R       |     | o  | o  | o  | o   | o  \
    \ | o   |\n   | Retry-After      | 3rr,503 |     | o  | o  | o  | o   | o   |\
    \ -   |\n   |                  | ,553    |     |    |    |    |     |     |  \
    \   |\n   | Retry-After      | 413     |     | o  | -  | -  | -   | -   | -  \
    \ |\n   | RTP-Info         | r       |     | -  | -  | c  | c   | -   | -   |\n\
    \   | Scale            | R       | r   | -  | -  | -  | o   | -   | -   |\n  \
    \ | Scale            | r       | amr | -  | -  | c  | c   | c   | -   |\n   |\
    \ Seek-Style       | R       |     | -  | -  | -  | o   | -   | -   |\n   | Seek-Style\
    \       | r       |     | -  | -  | -  | m   | -   | -   |\n   | Server      \
    \     | R       | r   | -  | o  | -  | -   | -   | o   |\n   | Server        \
    \   | r       | r   | o  | o  | o  | o   | o   | o   |\n   | Session         \
    \ | R       | r   | -  | o  | o  | m   | m   | m   |\n   | Session          |\
    \ r       | r   | -  | c  | m  | m   | m   | o   |\n   | Speed            | R\
    \       | admr| -  | -  | -  | o   | -   | -   |\n   | Speed            | r  \
    \     | admr| -  | -  | -  | c   | -   | -   |\n   | Supported        | R    \
    \   | r   | o  | o  | o  | o   | o   | o   |\n   | Supported        | r      \
    \ | r   | c  | c  | c  | c   | c   | c   |\n   | Terminate-Reason | R       |\
    \ r   | -  | -  | -  | -   | -   | -/o |\n   | Timestamp        | R       | admr|\
    \ o  | o  | o  | o   | o   | o   |\n   | Timestamp        | c       | admr| m\
    \  | m  | m  | m   | m   | m   |\n   | Transport        | G       | mr  | -  |\
    \ -  | m  | -   | -   | -   |\n   | Unsupported      | r       |     | c  | c\
    \  | c  | c   | c   | c   |\n   | User-Agent       | R       |     | m* | m* |\
    \ m* | m*  | m*  | m*  |\n   | Via              | R       | amr | c  | c  | c\
    \  | c   | c   | c   |\n   | Via              | r       | amr | c  | c  | c  |\
    \ c   | c   | c   |\n   | WWW-Authenticate | 401     |     | m  | m  | m  | m\
    \   | m   | m   |\n   +------------------+---------+-----+----+----+----+-----+-----+-----+\n\
    \   | Header           | Where   |Proxy|DES |OPT |STP | PLY | PSE | TRD |\n  \
    \ +------------------+---------+-----+----+----+----+-----+-----+-----+\n    \
    \ Figure 3: Overview of RTSP Header Fields (M-W) Related to Methods\n        \
    \    DESCRIBE, OPTIONS, SETUP, PLAY, PAUSE, and TEARDOWN\n   +---------------------------+-------+-------+-----+-----+-----+-----+\n\
    \   | Header                    | Where | Proxy | GPR | SPR | RDR | PNY |\n  \
    \ +---------------------------+-------+-------+-----+-----+-----+-----+\n   |\
    \ Accept-Credentials        | R     | rm    | o   | o   | o   | -   |\n   | Accept-Encoding\
    \           | R     | r     | o   | o   | o   | -   |\n   | Accept-Language  \
    \         | R     | r     | o   | o   | o   | -   |\n   | Accept-Ranges      \
    \       | G     | rm    | o   | -   | -   | -   |\n   | Allow                \
    \     | 405   | amr   | m   | m   | m   | m   |\n   | Authentication-Info    \
    \   | r     |       | o/- | o/- | -   | -   |\n   | Authorization            \
    \ | R     |       | o   | o   | o   | -   |\n   | Bandwidth                 |\
    \ R     |       | -   | o   | -   | -   |\n   | Blocksize                 | R\
    \     |       | -   | o   | -   | -   |\n   | Cache-Control             | G  \
    \   | r     | o   | o   | -   | -   |\n   | Connection                | G    \
    \ |       | o   | o   | o   | o   |\n   | Connection-Credentials    | 470,  |\
    \ ar    | o   | o   | o   | -   |\n   |                           | 407   |  \
    \     |     |     |     |     |\n   | Content-Base              | R     |    \
    \   | o   | o   | -   | o   |\n   | Content-Base              | r     |      \
    \ | o   | o   | -   | -   |\n   | Content-Base              | 4xx,  |       |\
    \ o   | o   | o   | o   |\n   |                           | 5xx   |       |  \
    \   |     |     |     |\n   | Content-Encoding          | R     | r     | o  \
    \ | o   | -   | o   |\n   | Content-Encoding          | r     | r     | o   |\
    \ o   | -   | -   |\n   | Content-Encoding          | 4xx,  | r     | o   | o\
    \   | o   | o   |\n   |                           | 5xx   |       |     |    \
    \ |     |     |\n   | Content-Language          | R     | r     | o   | o   |\
    \ -   | o   |\n   | Content-Language          | r     | r     | o   | o   | -\
    \   | -   |\n   | Content-Language          | 4xx,  | r     | o   | o   | o  \
    \ | o   |\n   |                           | 5xx   |       |     |     |     |\
    \     |\n   | Content-Length            | R     | r     | *   | *   | -   | *\
    \   |\n   | Content-Length            | r     | r     | *   | *   | -   | -  \
    \ |\n   | Content-Length            | 4xx,  | r     | *   | *   | *   | *   |\n\
    \   |                           | 5xx   |       |     |     |     |     |\n  \
    \ | Content-Location          | R     |       | o   | o   | -   | o   |\n   |\
    \ Content-Location          | r     |       | o   | o   | -   | -   |\n   | Content-Location\
    \          | 4xx,  |       | o   | o   | o   | o   |\n   |                   \
    \        | 5xx   |       |     |     |     |     |\n   | Content-Type        \
    \      | R     |       | *   | *   | -   | *   |\n   | Content-Type          \
    \    | r     |       | *   | *   | -   | -   |\n   | Content-Type            \
    \  | 4xx,  |       | *   | *   | *   | *   |\n   |                           |\
    \ 5xx   |       |     |     |     |     |\n   | CSeq                      | R,c\
    \   | mr    | m   | m   | m   | m   |\n   | Date                      | R    \
    \ | a     | o/* | o/* | m   | o/* |\n   | Date                      | r     |\
    \ am    | o/* | o/* | o/* | o/* |\n   | Expires                   | r     | r\
    \     | -   | -   | -   | -   |\n   | From                      | R     | r  \
    \   | o   | o   | o   | -   |\n   | If-Match                  | R     | r    \
    \ | -   | -   | -   | -   |\n   | If-Modified-Since         | R     | am    |\
    \ o   | -   | -   | -   |\n   | If-None-Match             | R     | am    | o\
    \   | -   | -   | -   |\n   | Last-Modified             | R     | r     | -  \
    \ | -   | -   | -   |\n   | Last-Modified             | r     | r     | o   |\
    \ -   | -   | -   |\n   | Location                  | 3rr   |       | m   | m\
    \   | m   | -   |\n   | Location                  | R     |       | -   | -  \
    \ | m   | -   |\n   +---------------------------+-------+-------+-----+-----+-----+-----+\n\
    \   | Header                    | Where | Proxy | GPR | SPR | RDR | PNY |\n  \
    \ +---------------------------+-------+-------+-----+-----+-----+-----+\n    \
    \ Figure 4: Overview of RTSP Header Fields (A-L) Related to Methods\n        \
    \  GET_PARAMETER, SET_PARAMETER, REDIRECT, and PLAY_NOTIFY\n +---------------------------+---------+-------+-----+-----+-----+-----+\n\
    \ | Header                    |  Where  | Proxy | GPR | SPR | RDR | PNY |\n +---------------------------+---------+-------+-----+-----+-----+-----+\n\
    \ | Media-Properties          | R       | amr   | o   | -   | -   | c   |\n |\
    \ Media-Properties          | r       | mr    | c   | -   | -   | -   |\n | Media-Range\
    \               | R       |       | o   | -   | -   | c   |\n | Media-Range  \
    \             | r       |       | c   | -   | -   | -   |\n | MTag           \
    \           | r       | r     | o   | -   | -   | -   |\n | Notify-Reason    \
    \         | R       |       | -   | -   | -   | m   |\n | Pipelined-Requests \
    \       | R       | amdr  | o   | o   | -   | -   |\n | Proxy-Authenticate   \
    \     | 407     | amdr  | m   | m   | m   | -   |\n | Proxy-Authentication-Info\
    \ | r       | amdr  | o/- | o/- | -   | -   |\n | Proxy-Authorization       |\
    \ R       | amdr  | o   | o   | o   | -   |\n | Proxy-Require             | R\
    \       | ar    | o   | o   | o   | -   |\n | Proxy-Supported           | R  \
    \     | amr   | c   | c   | c   | -   |\n | Proxy-Supported           | r    \
    \   |       | c   | c   | c   | -   |\n | Public                    | 501    \
    \ | admr  | m   | m   | m   | -   |\n | Range                     | R       |\
    \       | o   | -   | -   | m   |\n | Range                     | r       |  \
    \     | c   | -   | -   | -   |\n | Referrer                  | R       |    \
    \   | o   | o   | o   | -   |\n | Request-Status            | R       | mr   \
    \ | -   | -   | -   | c   |\n | Require                   | R       | r     |\
    \ o   | o   | o   | o   |\n | Retry-After               | 3rr,503,|       | o\
    \   | o   | -   | -   |\n |                           | 553     |       |    \
    \ |     |     |     |\n | Retry-After               | 413     |       | o   |\
    \ o   | -   | -   |\n | RTP-Info                  | R       | r     | o   | -\
    \   | -   | C   |\n | RTP-Info                  | r       | r     | c   | -  \
    \ | -   | -   |\n | Scale                     | G       |       | c   | -   |\
    \ c   | c   |\n | Seek-Style                | G       |       | -   | -   | -\
    \   | -   |\n | Server                    | R       | r     | o   | o   | o  \
    \ | o   |\n | Server                    | r       | r     | o   | o   | -   |\
    \ -   |\n | Session                   | R       | r     | o   | o   | o   | m\
    \   |\n | Session                   | r       | r     | c   | c   | o   | m  \
    \ |\n | Speed                     | G       |       | -   | -   | -   | -   |\n\
    \ | Supported                 | R       | r     | o   | o   | o   | -   |\n |\
    \ Supported                 | r       | r     | c   | c   | c   | -   |\n | Terminate-Reason\
    \          | R       | r     | -   | -   | m   | -   |\n | Timestamp         \
    \        | R       | adrm  | o   | o   | o   | o   |\n | Timestamp           \
    \      | c       | adrm  | m   | m   | m   | m   |\n | Transport             \
    \    | G       | mr    | -   | -   | -   | -   |\n | Unsupported             \
    \  | r       | arm   | c   | c   | c   | c   |\n | User-Agent                |\
    \ R       | r     | m*  | m*  | -   | -   |\n | User-Agent                | r\
    \       | r     | m*  | m*  | m*  | m*  |\n | Via                       | R  \
    \     | amr   | c   | c   | c   | c   |\n | Via                       | r    \
    \   | amr   | c   | c   | c   | c   |\n | WWW-Authenticate          | 401    \
    \ |       | m   | m   | m   | -   |\n +---------------------------+---------+-------+-----+-----+-----+-----+\n\
    \ | Header                    |  Where  | Proxy | GPR | SPR | RDR | PNY |\n +---------------------------+---------+-------+-----+-----+-----+-----+\n\
    \     Figure 5: Overview of RTSP Header Fields (M-W) Related to Methods\n    \
    \      GET_PARAMETER, SET_PARAMETER, REDIRECT, and PLAY_NOTIFY\n"
- title: 18.1.  Accept
  contents:
  - "18.1.  Accept\n   The Accept request-header field can be used to specify certain\n\
    \   presentation description and parameter media types [RFC6838] that are\n  \
    \ acceptable for the response to the DESCRIBE request.\n   See Section 20.2.3\
    \ for the syntax.\n   The asterisk \"*\" character is used to group media types\
    \ into ranges,\n   with \"*/*\" indicating all media types and \"type/*\" indicating\
    \ all\n   subtypes of that type.  The range MAY include media type parameters\n\
    \   that are generally applicable to that range.\n   Each media type or range\
    \ MAY be followed by one or more accept-\n   params, beginning with the \"q\"\
    \ parameter to indicate a relative\n   quality factor.  The first \"q\" parameter\
    \ (if any) separates the media\n   type or range's parameters from the accept-params.\
    \  Quality factors\n   allow the user or user agent to indicate the relative degree\
    \ of\n   preference for that media type, using the qvalue scale from 0 to 1\n\
    \   (Section 5.3.1 of [RFC7231]).  The default value is q=1.\n   Example of use:\n\
    \     Accept: application/example ;q=0.7, application/sdp\n   Indicates that the\
    \ requesting agent prefers the media type\n   application/sdp through the default\
    \ 1.0 rating but also accepts the\n   application/example media type with a 0.7\
    \ quality rating.\n   If no Accept header field is present, then it is assumed\
    \ that the\n   client accepts all media types.  If an Accept header field is\n\
    \   present, and if the server cannot send a response that is acceptable\n   according\
    \ to the combined Accept field-value, then the server SHOULD\n   send a 406 (Not\
    \ Acceptable) response.\n"
- title: 18.2.  Accept-Credentials
  contents:
  - "18.2.  Accept-Credentials\n   The Accept-Credentials header is a request-header\
    \ used to indicate to\n   any trusted intermediary how to handle further secured\
    \ connections to\n   proxies or servers.  It MUST NOT be included in server-to-client\n\
    \   requests.  See Section 19 for the usage of this header\n   In a request, the\
    \ header MUST contain the method (User, Proxy, or\n   Any) for approving credentials\
    \ selected by the requester.  The method\n   MUST NOT be changed by any proxy,\
    \ unless it is \"Proxy\" when a proxy\n   MAY change it to \"user\" to take the\
    \ role of user approving each\n   further hop.  If the method is \"User\", the\
    \ header contains zero or\n   more of the credentials that the client accepts.\
    \  The header may\n   contain zero credentials in the first RTSP request to an\
    \ RTSP server\n   via a proxy when using the \"User\" method.  This is because\
    \ the client\n   has not yet received any credentials to accept.  Each credential\
    \ MUST\n   consist of one URI identifying the proxy or server, the hash\n   algorithm\
    \ identifier, and the hash over that agent's ASN.1 DER-\n   encoded certificate\
    \ [RFC5280] in Base64, according to Section 4 of\n   [RFC4648] and where the padding\
    \ bits are set to zero.  All RTSP\n   clients and proxies MUST implement the SHA-256\
    \ [FIPS180-4] algorithm\n   for computation of the hash of the DER-encoded certificate.\
    \  The\n   SHA-256 algorithm is identified by the token \"sha-256\".\n   The intention\
    \ of allowing for other hash algorithms is to enable the\n   future retirement\
    \ of algorithms that are not implemented somewhere\n   other than here.  Thus,\
    \ the definition of future algorithms for this\n   purpose is intended to be extremely\
    \ limited.  A feature tag can be\n   used to ensure that support for the replacement\
    \ algorithm exists.\n   Example:\n   Accept-Credentials:User\n     \"rtsps://proxy2.example.com/\"\
    ;sha-256;exaIl9VMbQMOFGClx5rXnPJKVNI=,\n     \"rtsps://server.example.com/\";sha-256;lurbjj5khhB0NhIuOXtt4bBRH1M=\n"
- title: 18.3.  Accept-Encoding
  contents:
  - "18.3.  Accept-Encoding\n   The Accept-Encoding request-header field is similar\
    \ to Accept, but it\n   restricts the content-codings (see Section 18.15), i.e.,\n\
    \   transformation codings of the message body, such as gzip compression,\n  \
    \ that are acceptable in the response.\n   A server tests whether a content-coding\
    \ is acceptable, according to\n   an Accept-Encoding field, using these rules:\n\
    \   1.  If the content-coding is one of the content-codings listed in the\n  \
    \     Accept-Encoding field, then it is acceptable, unless it is\n       accompanied\
    \ by a qvalue of 0.  (As defined in Section 5.3.1 of\n       [RFC7231], a qvalue\
    \ of 0 means \"not acceptable.\")\n   2.  The special \"*\" symbol in an Accept-Encoding\
    \ field matches any\n       available content-coding not explicitly listed in\
    \ the header\n       field.\n   3.  If multiple content-codings are acceptable,\
    \ then the acceptable\n       content-coding with the highest non-zero qvalue\
    \ is preferred.\n   4.  The \"identity\" content-coding is always acceptable,\
    \ i.e., no\n       transformation at all, unless specifically refused because\
    \ the\n       Accept-Encoding field includes \"identity;q=0\" or because the\n\
    \       field includes \"*;q=0\" and does not explicitly include the\n       \"\
    identity\" content-coding.  If the Accept-Encoding field-value is\n       empty,\
    \ then only the \"identity\" encoding is acceptable.\n   If an Accept-Encoding\
    \ field is present in a request, and if the\n   server cannot send a response\
    \ that is acceptable according to the\n   Accept-Encoding header, then the server\
    \ SHOULD send an error response\n   with the 406 (Not Acceptable) status code.\n\
    \   If no Accept-Encoding field is present in a request, the server MAY\n   assume\
    \ that the client will accept any content-coding.  In this case,\n   if \"identity\"\
    \ is one of the available content-codings, then the\n   server SHOULD use the\
    \ \"identity\" content-coding, unless it has\n   additional information that a\
    \ different content-coding is meaningful\n   to the client.\n"
- title: 18.4.  Accept-Language
  contents:
  - "18.4.  Accept-Language\n   The Accept-Language request-header field is similar\
    \ to Accept, but\n   restricts the set of natural languages that are preferred\
    \ as a\n   response to the request.  Note that the language specified applies\
    \ to\n   the presentation description (response message body) and any reason\n\
    \   phrases, but not the media content.\n   A language tag identifies a natural\
    \ language spoken, written, or\n   otherwise conveyed by human beings for communication\
    \ of information\n   to other human beings.  Computer languages are explicitly\
    \ excluded.\n   The syntax and registry of RTSP 2.0 language tags are the same\
    \ as\n   those defined by [RFC5646].\n   Each language-range MAY be given an associated\
    \ quality value that\n   represents an estimate of the user's preference for the\
    \ languages\n   specified by that range.  The quality value defaults to \"q=1\"\
    .  For\n   example:\n      Accept-Language: da, en-gb;q=0.8, en;q=0.7\n   would\
    \ mean: \"I prefer Danish, but will accept British English and\n   other types\
    \ of English.\"  A language-range matches a language tag if\n   it exactly equals\
    \ the full tag or if it exactly equals a prefix of\n   the tag, i.e., the primary-tag\
    \ in the ABNF, such that the character\n   following primary-tag is \"-\".  The\
    \ special range \"*\", if present in\n   the Accept-Language field, matches every\
    \ tag not matched by any other\n   range present in the Accept-Language field.\n\
    \      Note: This use of a prefix matching rule does not imply that\n      language\
    \ tags are assigned to languages in such a way that it is\n      always true that\
    \ if a user understands a language with a certain\n      tag, then this user will\
    \ also understand all languages with tags\n      for which this tag is a prefix.\
    \  The prefix rule simply allows the\n      use of prefix tags if this is the\
    \ case.\n   In the process of selecting a language, each language tag is assigned\n\
    \   a qualification factor, i.e., if a language being supported by the\n   client\
    \ is actually supported by the server and what \"preference\"\n   level the language\
    \ achieves.  The quality value (q-value) of the\n   longest language-range in\
    \ the field that matches the language tag is\n   assigned as the qualification\
    \ factor for a particular language tag.\n   If no language-range in the field\
    \ matches the tag, the language\n   qualification factor assigned is 0.  If no\
    \ Accept-Language header is\n   present in the request, the server SHOULD assume\
    \ that all languages\n   are equally acceptable.  If an Accept-Language header\
    \ is present,\n   then all languages that are assigned a qualification factor\
    \ greater\n   than 0 are acceptable.\n"
- title: 18.5.  Accept-Ranges
  contents:
  - "18.5.  Accept-Ranges\n   The Accept-Ranges general-header field allows indication\
    \ of the\n   format supported in the Range header.  The client MUST include the\n\
    \   header in SETUP requests to indicate which formats are acceptable\n   when\
    \ received in PLAY and PAUSE responses and REDIRECT requests.  The\n   server\
    \ MUST include the header in SETUP responses and 456 (Header\n   Field Not Valid\
    \ for Resource) error responses to indicate the formats\n   supported for the\
    \ resource indicated by the Request-URI.  The header\n   MAY be included in GET_PARAMETER\
    \ request and response pairs.  The\n   GET_PARAMETER request MUST contain a Session\
    \ header to identify the\n   session context the request is related to.  The requester\
    \ and\n   responder will indicate their capabilities regarding Range formats\n\
    \   respectively.\n      Accept-Ranges: npt, smpte, clock\n   The syntax is defined\
    \ in Section 20.2.3.\n"
- title: 18.6.  Allow
  contents:
  - "18.6.  Allow\n   The Allow message body header field lists the methods supported\
    \ by\n   the resource identified by the Request-URI.  The purpose of this\n  \
    \ field is to inform the recipient of the complete set of valid methods\n   associated\
    \ with the resource.  An Allow header field MUST be present\n   in a 405 (Method\
    \ Not Allowed) response.  The Allow header MUST also\n   be present in all OPTIONS\
    \ responses where the content of the header\n   will not include exactly the same\
    \ methods as listed in the Public\n   header.\n   The Allow message body header\
    \ MUST also be included in SETUP and\n   DESCRIBE responses, if the methods allowed\
    \ for the resource are\n   different from the complete set of methods defined\
    \ in this memo.\n   Example of use:\n      Allow: SETUP, PLAY, SET_PARAMETER,\
    \ DESCRIBE\n"
- title: 18.7.  Authentication-Info
  contents:
  - "18.7.  Authentication-Info\n   The Authentication-Info response-header is used\
    \ by the server to\n   communicate some information regarding the successful HTTP\n\
    \   authentication [RFC7235] in the response message.  The definition of\n   the\
    \ header is in [RFC7615], and any applicable HTTP authentication\n   schemes appear\
    \ in other RFCs, such as Digest [RFC7616].  This header\n   MUST only be used\
    \ in response messages related to client to server\n   requests.\n"
- title: 18.8.  Authorization
  contents:
  - "18.8.  Authorization\n   An RTSP client that wishes to authenticate itself with\
    \ a server using\n   the authentication mechanism from HTTP [RFC7235], usually\
    \ (but not\n   necessarily) after receiving a 401 response, does so by including\
    \ an\n   Authorization request-header field with the request.  The\n   Authorization\
    \ field-value consists of credentials containing the\n   authentication information\
    \ of the user agent for the realm of the\n   resource being requested.  The definition\
    \ of the header is in\n   [RFC7235], and any applicable HTTP authentication schemes\
    \ appear in\n   other RFCs, such as Digest [RFC7616] and Basic [RFC7617].  This\n\
    \   header MUST only be used in client-to-server requests.\n   If a request is\
    \ authenticated and a realm specified, the same\n   credentials SHOULD be valid\
    \ for all other requests within this realm\n   (assuming that the authentication\
    \ scheme itself does not require\n   otherwise, such as credentials that vary\
    \ according to a challenge\n   value or using synchronized clocks).  Each client-to-server\
    \ request\n   MUST be individually authorized by including the Authorization header\n\
    \   with the information.\n   When a shared cache (see Section 16) receives a\
    \ request containing an\n   Authorization field, it MUST NOT return the corresponding\
    \ response as\n   a reply to any other request, unless one of the following specific\n\
    \   exceptions holds:\n   1.  If the response includes the \"max-age\" cache directive,\
    \ the cache\n       MAY use that response in replying to a subsequent request.\
    \  But\n       (if the specified maximum age has passed) a proxy cache MUST\n\
    \       first revalidate it with the origin server, using the request-\n     \
    \  headers from the new request to allow the origin server to\n       authenticate\
    \ the new request.  (This is the defined behavior for\n       max-age.)  If the\
    \ response includes \"max-age=0\", the proxy MUST\n       always revalidate it\
    \ before reusing it.\n   2.  If the response includes the \"must-revalidate\"\
    \ cache-control\n       directive, the cache MAY use that response in replying\
    \ to a\n       subsequent request.  But if the response is stale, all caches\n\
    \       MUST first revalidate it with the origin server, using the\n       request-headers\
    \ from the new request to allow the origin server\n       to authenticate the\
    \ new request.\n   3.  If the response includes the \"public\" cache directive,\
    \ it MAY be\n       returned in reply to any subsequent request.\n"
- title: 18.9.  Bandwidth
  contents:
  - "18.9.  Bandwidth\n   The Bandwidth request-header field describes the estimated\
    \ bandwidth\n   available to the client, expressed as a positive integer and measured\n\
    \   in kilobits per second.  The bandwidth available to the client may\n   change\
    \ during an RTSP session, e.g., due to mobility, congestion,\n   etc.\n   Clients\
    \ may not be able to accurately determine the available\n   bandwidth, for example,\
    \ because the first hop is not a bottleneck.\n   Such a case is when the local\
    \ area network (LAN) is not the\n   bottleneck, instead the LAN's Internet access\
    \ link is, if the server\n   is not in the same LAN.  Thus, link speeds of WLAN\
    \ or Ethernet\n   networks are normally not a basis for estimating the available\n\
    \   bandwidth.  Cellular devices or other devices directly connected to a\n  \
    \ modem or connection-enabling device may more accurately estimate the\n   bottleneck\
    \ bandwidth and what is a reasonable share of it for RTSP-\n   controlled media.\
    \  The client will also need to take into account\n   other traffic sharing the\
    \ bottleneck.  For example, by only assigning\n   a certain fraction to RTSP and\
    \ its media streams.  It is RECOMMENDED\n   that only clients that have accurate\
    \ and explicit information about\n   bandwidth bottlenecks use this header.\n\
    \   This header is not a substitute for proper congestion control.  It is\n  \
    \ only a method providing an initial estimate and coarsely determines\n   if the\
    \ selected content can be delivered at all.\n   Example:\n     Bandwidth: 62360\n"
- title: 18.10.  Blocksize
  contents:
  - "18.10.  Blocksize\n   The Blocksize request-header field is sent from the client\
    \ to the\n   media server asking the server for a particular media packet size.\n\
    \   This packet size does not include lower-layer headers such as IP,\n   UDP,\
    \ or RTP.  The server is free to use a blocksize that is lower\n   than the one\
    \ requested.  The server MAY truncate this packet size to\n   the closest multiple\
    \ of the minimum, media-specific block size or\n   override it with the media-specific\
    \ size, if necessary.  The block\n   size MUST be a positive decimal number measured\
    \ in octets.  The\n   server only returns an error (4xx) if the value is syntactically\n\
    \   invalid.\n"
- title: 18.11.  Cache-Control
  contents:
  - "18.11.  Cache-Control\n   The Cache-Control general-header field is used to specify\
    \ directives\n   that MUST be obeyed by all caching mechanisms along the request/\n\
    \   response chain.\n   Cache directives MUST be passed through by a proxy or\
    \ gateway\n   application, regardless of their significance to that application,\n\
    \   since the directives may be applicable to all recipients along the\n   request/response\
    \ chain.  It is not possible to specify a cache-\n   directive for a specific\
    \ cache.\n   Cache-Control should only be specified in a DESCRIBE, GET_PARAMETER,\n\
    \   SET_PARAMETER, and SETUP request and its response.  Note: Cache-\n   Control\
    \ does not govern only the caching of responses for the RTSP\n   messages, instead\
    \ it also applies to the media stream identified by\n   the SETUP request.  The\
    \ RTSP requests are generally not cacheable;\n   for further information, see\
    \ Section 16.  Below are the descriptions\n   of the cache directives that can\
    \ be included in the Cache-Control\n   header.\n   no-cache:  Indicates that the\
    \ media stream or RTSP response MUST NOT\n         be cached anywhere.  This allows\
    \ an origin server to prevent\n         caching even by caches that have been\
    \ configured to return\n         stale responses to client requests.  Note: there\
    \ is no security\n         function preventing the caching of content.\n   public:\
    \  Indicates that the media stream or RTSP response is\n         cacheable by\
    \ any cache.\n   private:  Indicates that the media stream or RTSP response is\n\
    \         intended for a single user and MUST NOT be cached by a shared\n    \
    \     cache.  A private (non-shared) cache may cache the media\n         streams.\n\
    \   no-transform:  An intermediate cache (proxy) may find it useful to\n     \
    \    convert the media type of a certain stream.  A proxy might, for\n       \
    \  example, convert between video formats to save cache space or\n         to\
    \ reduce the amount of traffic on a slow link.  Serious\n         operational\
    \ problems may occur, however, when these\n         transformations have been\
    \ applied to streams intended for\n         certain kinds of applications.  For\
    \ example, applications for\n         medical imaging, scientific data analysis\
    \ and those using end-\n         to-end authentication all depend on receiving\
    \ a stream that is\n         bit-for-bit identical to the original media stream\
    \ or RTSP\n         response.  Therefore, if a response includes the no-transform\n\
    \         directive, an intermediate cache or proxy MUST NOT change the\n    \
    \     encoding of the stream or response.  Unlike HTTP, RTSP does not\n      \
    \   provide for partial transformation at this point, e.g.,\n         allowing\
    \ translation into a different language.\n   only-if-cached:  In some cases, such\
    \ as times of extremely poor\n         network connectivity, a client may want\
    \ a cache to return only\n         those media streams or RTSP responses that\
    \ it currently has\n         stored and not to receive these from the origin server.\
    \  To do\n         this, the client may include the only-if-cached directive in\
    \ a\n         request.  If the cache receives this directive, it SHOULD\n    \
    \     either respond using a cached media stream or response that is\n       \
    \  consistent with the other constraints of the request or respond\n         with\
    \ a 504 (Gateway Timeout) status.  However, if a group of\n         caches is\
    \ being operated as a unified system with good internal\n         connectivity,\
    \ such a request MAY be forwarded within that group\n         of caches.\n   max-stale:\
    \  Indicates that the client is willing to accept a media\n         stream or\
    \ RTSP response that has exceeded its expiration time.\n         If max-stale\
    \ is assigned a value, then the client is willing to\n         accept a response\
    \ that has exceeded its expiration time by no\n         more than the specified\
    \ number of seconds.  If no value is\n         assigned to max-stale, then the\
    \ client is willing to accept a\n         stale response of any age.\n   min-fresh:\
    \  Indicates that the client is willing to accept a media\n         stream or\
    \ RTSP response whose freshness lifetime is no less\n         than its current\
    \ age plus the specified time in seconds.  That\n         is, the client wants\
    \ a response that will still be fresh for at\n         least the specified number\
    \ of seconds.\n   must-revalidate:  When the must-revalidate directive is present\
    \ in a\n         SETUP response received by a cache, that cache MUST NOT use the\n\
    \         cache entry after it becomes stale to respond to a subsequent\n    \
    \     request without first revalidating it with the origin server.\n        \
    \ That is, the cache is required to do an end-to-end revalidation\n         every\
    \ time, if, based solely on the origin server's Expires,\n         the cached\
    \ response is stale.\n   proxy-revalidate:  The proxy-revalidate directive has\
    \ the same\n         meaning as the must-revalidate directive, except that it\
    \ does\n         not apply to non-shared user agent caches.  It can be used on\
    \ a\n         response to an authenticated request to permit the user's cache\n\
    \         to store and later return the response without needing to\n        \
    \ revalidate it (since it has already been authenticated once by\n         that\
    \ user), while still requiring proxies that service many\n         users to revalidate\
    \ each time (in order to make sure that each\n         user has been authenticated).\
    \  Note that such authenticated\n         responses also need the \"public\" cache\
    \ directive in order to\n         allow them to be cached at all.\n   max-age:\
    \  When an intermediate cache is forced, by means of a max-\n         age=0 directive,\
    \ to revalidate its own cache entry, and the\n         client has supplied its\
    \ own validator in the request, the\n         supplied validator might differ\
    \ from the validator currently\n         stored with the cache entry.  In this\
    \ case, the cache MAY use\n         either validator in making its own request\
    \ without affecting\n         semantic transparency.\n         However, the choice\
    \ of validator might affect performance.  The\n         best approach is for the\
    \ intermediate cache to use its own\n         validator when making its request.\
    \  If the server replies with\n         304 (Not Modified), then the cache can\
    \ return its now validated\n         copy to the client with a 200 (OK) response.\
    \  If the server\n         replies with a new message body and cache validator,\
    \ however,\n         the intermediate cache can compare the returned validator\
    \ with\n         the one provided in the client's request, using the strong\n\
    \         comparison function.  If the client's validator is equal to the\n  \
    \       origin server's, then the intermediate cache simply returns 304\n    \
    \     (Not Modified).  Otherwise, it returns the new message body\n         with\
    \ a 200 (OK) response.\n"
- title: 18.12.  Connection
  contents:
  - "18.12.  Connection\n   The Connection general-header field allows the sender\
    \ to specify\n   options that are desired for that particular connection.  It\
    \ MUST NOT\n   be communicated by proxies over further connections.\n   RTSP 2.0\
    \ proxies MUST parse the Connection header field before a\n   message is forwarded\
    \ and, for each connection-token in this field,\n   remove any header field(s)\
    \ from the message with the same name as the\n   connection-token.  Connection\
    \ options are signaled by the presence of\n   a connection-token in the Connection\
    \ header field, not by any\n   corresponding additional header field(s), since\
    \ the additional header\n   field may not be sent if there are no parameters associated\
    \ with that\n   connection option.\n   Message headers listed in the Connection\
    \ header MUST NOT include end-\n   to-end headers, such as Cache-Control.\n  \
    \ RTSP 2.0 defines the \"close\" connection option for the sender to\n   signal\
    \ that the connection will be closed after completion of the\n   response.  For\
    \ example, \"Connection: close in either the request or\n   the response-header\
    \ fields\" indicates that the connection SHOULD NOT\n   be considered \"persistent\"\
    \ (Section 10.2) after the current request/\n   response is complete.\n   The\
    \ use of the connection option \"close\" in RTSP messages SHOULD be\n   limited\
    \ to error messages when the server is unable to recover and\n   therefore sees\
    \ it necessary to close the connection.  The reason\n   being that the client\
    \ has the choice of continuing using a connection\n   indefinitely, as long as\
    \ it sends valid messages.\n"
- title: 18.13.  Connection-Credentials
  contents:
  - "18.13.  Connection-Credentials\n   The Connection-Credentials response-header\
    \ is used to carry the chain\n   of credentials for any next hop that needs to\
    \ be approved by the\n   requester.  It MUST only be used in server-to-client\
    \ responses.\n   The Connection-Credentials header in an RTSP response MUST, if\n\
    \   included, contain the credential information (in the form of a list\n   of\
    \ certificates providing the chain of certification) of the next hop\n   to which\
    \ an intermediary needs to securely connect.  The header MUST\n   include the\
    \ URI of the next hop (proxy or server) and a\n   Base64-encoded (according to\
    \ Section 4 of [RFC4648] and where the\n   padding bits are set to zero) binary\
    \ structure containing a sequence\n   of DER-encoded X.509v3 certificates [RFC5280].\n\
    \   The binary structure starts with the number of certificates\n   (NR_CERTS)\
    \ included as a 16-bit unsigned integer.  This is followed\n   by an NR_CERTS\
    \ number of 16-bit unsigned integers providing the size,\n   in octets, of each\
    \ DER-encoded certificate.  This is followed by an\n   NR_CERTS number of DER-encoded\
    \ X.509v3 certificates in a sequence\n   (chain).  This format is exemplified\
    \ in Figure 6.  The certificate of\n   the proxy or server must come first in\
    \ the structure.  Each following\n   certificate must directly certify the one\
    \ preceding it.  Because\n   certificate validation requires that root keys be\
    \ distributed\n   independently, the self-signed certificate that specifies the\
    \ root\n   certificate authority may optionally be omitted from the chain, under\n\
    \   the assumption that the remote end must already possess it in order\n   to\
    \ validate it in any case.\n   Example:\n   Connection-Credentials:\"rtsps://proxy2.example.com/\"\
    ;MIIDNTCC...\n   Where MIIDNTCC... is a Base64 encoding of the following structure:\n\
    \        0                   1                   2                   3\n     \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  Number of certificates       | Size of certificate #1        |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   | Size of certificate #2        | Size of certificate #3        |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       :\
    \ DER Encoding of Certificate #1                                :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       : DER Encoding of Certificate #2                                :\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   : DER Encoding of Certificate #3                                :\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Figure\
    \ 6: Format Example of Connection-Credentials Header Certificate\n"
- title: 18.14.  Content-Base
  contents:
  - "18.14.  Content-Base\n   The Content-Base message body header field may be used\
    \ to specify the\n   base URI for resolving relative URIs within the message body.\n\
    \   Content-Base: rtsp://media.example.com/movie/twister/\n   If no Content-Base\
    \ field is present, the base URI of a message body\n   is defined by either its\
    \ Content-Location (if that Content-Location\n   URI is an absolute URI) or the\
    \ URI used to initiate the request, in\n   that order of precedence.  Note, however,\
    \ that the base URI of the\n   contents within the message body may be redefined\
    \ within that message\n   body.\n"
- title: 18.15.  Content-Encoding
  contents:
  - "18.15.  Content-Encoding\n   The Content-Encoding message body header field is\
    \ used as a modifier\n   of the media-type.  When present, its value indicates\
    \ what additional\n   content-codings have been applied to the message body, and\
    \ thus what\n   decoding mechanisms must be applied in order to obtain the media-type\n\
    \   referenced by the Content-Type header field.  Content-Encoding is\n   primarily\
    \ used to allow a document to be compressed without losing\n   the identity of\
    \ its underlying media type.\n   The content-coding is a characteristic of the\
    \ message body identified\n   by the Request-URI.  Typically, the message body\
    \ is stored with this\n   encoding and is only decoded before rendering or analogous\
    \ usage.\n   However, an RTSP proxy MAY modify the content-coding if the new\n\
    \   coding is known to be acceptable to the recipient, unless the \"no-\n   transform\"\
    \ cache directive is present in the message.\n   If the content-coding of a message\
    \ body is not \"identity\", then the\n   message MUST include a Content-Encoding\
    \ message body header that\n   lists the non-identity content-coding(s) used.\n\
    \   If the content-coding of a message body in a request message is not\n   acceptable\
    \ to the origin server, the server SHOULD respond with a\n   status code of 415\
    \ (Unsupported Media Type).\n   If multiple encodings have been applied to a message\
    \ body, the\n   content-codings MUST be listed in the order in which they were\n\
    \   applied, first to last from left to right.  Additional information\n   about\
    \ the encoding parameters MAY be provided by other header fields\n   not defined\
    \ by this specification.\n"
- title: 18.16.  Content-Language
  contents:
  - "18.16.  Content-Language\n   The Content-Language message body header field describes\
    \ the natural\n   language(s) of the intended audience for the enclosed message\
    \ body.\n   Note that this might not be equivalent to all the languages used\n\
    \   within the message body.\n   Language tags are mentioned in Section 18.4.\
    \  The primary purpose of\n   Content-Language is to allow a user to identify\
    \ and differentiate\n   entities according to the user's own preferred language.\
    \  Thus, if\n   the body content is intended only for a Danish-literate audience,\
    \ the\n   appropriate field is\n      Content-Language: da\n   If no Content-Language\
    \ is specified, the default is that the content\n   is intended for all language\
    \ audiences.  This might mean that the\n   sender does not consider it to be specific\
    \ to any natural language or\n   that the sender does not know for which language\
    \ it is intended.\n   Multiple languages MAY be listed for content that is intended\
    \ for\n   multiple audiences.  For example, a rendition of the \"Treaty of\n \
    \  Waitangi\", presented simultaneously in the original Maori and English\n  \
    \ versions, would call for\n      Content-Language: mi, en\n   However, just because\
    \ multiple languages are present within a message\n   body does not mean that\
    \ it is intended for multiple linguistic\n   audiences.  An example would be a\
    \ beginner's language primer, such as\n   \"A First Lesson in Latin\", which is\
    \ clearly intended to be used by an\n   English-literate audience.  In this case,\
    \ the Content-Language would\n   properly only include \"en\".\n   Content-Language\
    \ MAY be applied to any media type -- it is not\n   limited to textual documents.\n"
- title: 18.17.  Content-Length
  contents:
  - "18.17.  Content-Length\n   The Content-Length message body header field contains\
    \ the length of\n   the message body of the RTSP message (i.e., after the double\
    \ CRLF\n   following the last header) in octets of bits.  Unlike HTTP, it MUST\n\
    \   be included in all messages that carry a message body beyond the\n   header\
    \ portion of the RTSP message.  If it is missing, a default\n   value of zero\
    \ is assumed.  Any Content-Length greater than or equal\n   to zero is a valid\
    \ value.\n"
- title: 18.18.  Content-Location
  contents:
  - "18.18.  Content-Location\n   The Content-Location message body header field MAY\
    \ be used to supply\n   the resource location for the message body enclosed in\
    \ the message\n   when that body is accessible from a location separate from the\n\
    \   requested resource's URI.  A server SHOULD provide a Content-Location\n  \
    \ for the variant corresponding to the response message body;\n   especially in\
    \ the case where a resource has multiple variants\n   associated with it, and\
    \ those entities actually have separate\n   locations by which they might be individually\
    \ accessed, the server\n   SHOULD provide a Content-Location for the particular\
    \ variant that is\n   returned.\n   As an example, if an RTSP client performs\
    \ a DESCRIBE request on a\n   given resource, e.g., \"rtsp://a.example.com/movie/\n\
    \   Plan9FromOuterSpace\", then the server may use additional information,\n \
    \  such as the User-Agent header, to determine the capabilities of the\n   agent.\
    \  The server will then return a media description tailored to\n   that class\
    \ of RTSP agents.  To indicate which specific description\n   the agent receives,\
    \ the resource identifier\n   (\"rtsp://a.example.com/movie/Plan9FromOuterSpace/FullHD.sdp\"\
    ) is\n   provided in Content-Location, while the description is still a valid\n\
    \   response for the generic resource identifier, thus enabling both\n   debugging\
    \ and cache operation as discussed below.\n   The Content-Location value is not\
    \ a replacement for the original\n   requested URI; it is only a statement of\
    \ the location of the resource\n   corresponding to this particular variant at\
    \ the time of the request.\n   Future requests MAY specify the Content-Location\
    \ URI as the Request-\n   URI if the desire is to identify the source of that\
    \ particular\n   variant.  This is useful if the RTSP agent desires to verify\
    \ if the\n   resource variant is current through a conditional request.\n   A\
    \ cache cannot assume that a message body with a Content-Location\n   different\
    \ from the URI used to retrieve it can be used to respond to\n   later requests\
    \ on that Content-Location URI.  However, the Content-\n   Location can be used\
    \ to differentiate between multiple variants\n   retrieved from a single requested\
    \ resource.\n   If the Content-Location is a relative URI, the relative URI is\n\
    \   interpreted relative to the Request-URI.\n   Note that Content-Location can\
    \ be used in some cases to derive the\n   base-URI for relative URI(s) present\
    \ in session description formats.\n   This needs to be taken into account when\
    \ Content-Location is used.\n   The easiest way to avoid needing to consider that\
    \ issue is to include\n   the Content-Base whenever the Content-Location is included.\n\
    \   Note also, when using Media Tags in conjunction with Content-\n   Location,\
    \ it is important that the different versions have different\n   MTags, even if\
    \ provided under different Content-Location URIs.  This\n   is because the different\
    \ content variants still have been provided in\n   response to the same request\
    \ URI.\n   Note also, as in most cases, the URIs used in the DESCRIBE and the\n\
    \   SETUP requests are different: the URI provided in a DESCRIBE Content-\n  \
    \ Location response can't directly be used in a SETUP request.\n   Instead, the\
    \ steps of deriving the media resource URIs are necessary.\n   This commonly involves\
    \ combing the media description's relative URIs,\n   e.g., from the SDP's a=control\
    \ attribute, with the base-URI to create\n   the absolute URIs needed in the SETUP\
    \ request.\n"
- title: 18.19.  Content-Type
  contents:
  - "18.19.  Content-Type\n   The Content-Type message body header indicates the media\
    \ type of the\n   message body sent to the recipient.  Note that the content types\n\
    \   suitable for RTSP are likely to be restricted in practice to\n   presentation\
    \ descriptions and parameter-value types.\n"
- title: 18.20.  CSeq
  contents:
  - "18.20.  CSeq\n   The CSeq general-header field specifies the sequence number\
    \ (integer)\n   for an RTSP request/response pair.  This field MUST be present\
    \ in all\n   requests and responses.  RTSP agents maintain a sequence number\n\
    \   series for each responder to which they have an open message\n   transport\
    \ channel.  For each new RTSP request an agent originates on\n   a particular\
    \ RTSP message transport, the CSeq value MUST be\n   incremented by one.  The\
    \ initial sequence number can be any number;\n   however, it is RECOMMENDED to\
    \ start at 0.  Each sequence number\n   series is unique between each requester\
    \ and responder, i.e., the\n   client has one series for its requests to a server\
    \ and the server has\n   another when sending requests to the client.  Each requester\
    \ and\n   responder is identified by its socket address (IP address and port\n\
    \   number), i.e., per direction of a TCP connection.  Any retransmitted\n   request\
    \ MUST contain the same sequence number as the original, i.e.,\n   the sequence\
    \ number is not incremented for retransmissions of the\n   same request.  The\
    \ RTSP agent receiving requests MUST process the\n   requests arriving on a particular\
    \ transport in the order of the\n   sequence numbers.  Responses are sent in the\
    \ order that they are\n   generated.  The RTSP response MUST have the same sequence\
    \ number as\n   was present in the corresponding request.  An RTSP agent receiving\
    \ a\n   response MAY receive the responses out of order compared to the order\n\
    \   of the requests it sent.  Thus, the agent MUST use the sequence\n   number\
    \ in the response to pair it with the corresponding request.\n      The main purpose\
    \ of the sequence number is to map responses to\n      requests.\n      The requirement\
    \ to use a sequence-number increment of one for each\n      new request is to\
    \ support any future specification of RTSP message\n      transport over a protocol\
    \ that does not provide in-order delivery\n      or is unreliable.\n      The\
    \ above rules relating to the initial sequence number may appear\n      unnecessarily\
    \ loose.  The reason for this is to cater to some\n      common behavior of existing\
    \ implementations: when using multiple\n      reliable connections in sequence,\
    \ it may still be easiest to use a\n      single sequence-number series for a\
    \ client connecting with a\n      particular server.  Thus, the initial sequence\
    \ number may be\n      arbitrary depending on the number of previous requests.\
    \  For any\n      unreliable transport, a stricter definition or other solution\
    \ will\n      be required to enable detection of any loss of the first request.\n\
    \      When using multiple sequential transport connections, there is no\n   \
    \   protocol mechanism to ensure in-order processing as the sequence\n      number\
    \ is scoped on the individual transport connection and its\n      five tuple.\
    \  Thus, there are potential issues with opening a new\n      transport connection\
    \ to the same host for which there already\n      exists a transport connection\
    \ with outstanding requests and\n      previously dispatched requests related\
    \ to the same RTSP session.\n   RTSP Proxies also need to follow the above rules.\
    \  This implies that\n   proxies that aggregate requests from multiple clients\
    \ onto a single\n   transport towards a server or a next-hop proxy need to renumber\
    \ these\n   requests to form a unified sequence on that transport, fulfilling\
    \ the\n   above rules.  A proxy capable of fulfilling some agent's request\n \
    \  without emitting its own request (e.g., a caching proxy that fulfills\n   a\
    \ request from its cache) also causes a need to renumber as the\n   number of\
    \ received requests with a particular target may not be the\n   same as the number\
    \ of emitted requests towards that target agent.  A\n   proxy that needs to renumber\
    \ needs to perform the corresponding\n   renumbering back to the original sequence\
    \ number for any received\n   response before forwarding it back to the originator\
    \ of the request.\n      A client connected to a proxy, and using that transport\
    \ to send\n      requests to multiple servers, creates a situation where it is\n\
    \      quite likely to receive the responses out of order.  This is\n      because\
    \ the proxy will establish separate transports from the\n      proxy to the servers\
    \ on which to forward the client's requests.\n      When the responses arrive\
    \ from the different servers, they will be\n      forwarded to the client in the\
    \ order they arrive at the proxy and\n      can be processed, not the order of\
    \ the client's original sequence\n      numbers.  This is intentional to avoid\
    \ some session's requests\n      being blocked by another server's slow processing\
    \ of requests.\n"
- title: 18.21.  Date
  contents:
  - "18.21.  Date\n   The Date general-header field represents the date and time at\
    \ which\n   the message was originated.  The inclusion of the Date header in an\n\
    \   RTSP message follows these rules:\n   o  An RTSP message, sent by either the\
    \ client or the server,\n      containing a body MUST include a Date header, if\
    \ the sending host\n      has a clock;\n   o  Clients and servers are RECOMMENDED\
    \ to include a Date header in\n      all other RTSP messages, if the sending host\
    \ has a clock;\n   o  If the server does not have a clock that can provide a reasonable\n\
    \      approximation of the current time, its responses MUST NOT include\n   \
    \   a Date header field.  In this case, this rule MUST be followed:\n      some\
    \ origin-server implementations might not have a clock\n      available.  An origin\
    \ server without a clock MUST NOT assign\n      Expires or Last-Modified values\
    \ to a response, unless these values\n      were associated with the resource\
    \ by a system or user with a\n      reliable clock.  It MAY assign an Expires\
    \ value that is known, at\n      or before server-configuration time, to be in\
    \ the past (this\n      allows \"pre-expiration\" of responses without storing\
    \ separate\n      Expires values for each resource).\n   A received message that\
    \ does not have a Date header field MUST be\n   assigned one by the recipient\
    \ if the message will be cached by that\n   recipient.  An RTSP implementation\
    \ without a clock MUST NOT cache\n   responses without revalidating them on every\
    \ use.  An RTSP cache,\n   especially a shared cache, SHOULD use a mechanism,\
    \ such as the\n   Network Time Protocol (NTP) [RFC5905], to synchronize its clock\
    \ with\n   a reliable external standard.\n   The RTSP-date, a full date as specified\
    \ by Section 3.3 of [RFC5322],\n   sent in a Date header SHOULD NOT represent\
    \ a date and time subsequent\n   to the generation of the message.  It SHOULD\
    \ represent the best\n   available approximation of the date and time of message\
    \ generation,\n   unless the implementation has no means of generating a reasonably\n\
    \   accurate date and time.  In theory, the date ought to represent the\n   moment\
    \ just before the message body is generated.  In practice, the\n   date can be\
    \ generated at any time during the message origination\n   without affecting its\
    \ semantic value.\n      Note: The RTSP 2.0 date format is defined to be the full-date\n\
    \      format in RFC 5322.  This format is more flexible than the date\n     \
    \ format in RFC 1123 used by RTSP 1.0.  Thus, implementations should\n      use\
    \ single spaces as separators, as recommended by RFC 5322, and\n      support\
    \ receiving the obsolete format.\n      Further, note that the syntax allows for\
    \ a comment to be added at\n      the end of the date.\n"
- title: 18.22.  Expires
  contents:
  - "18.22.  Expires\n   The Expires message body header field gives a date and time\
    \ after\n   which the description or media-stream should be considered stale.\n\
    \   The interpretation depends on the method:\n   DESCRIBE response:  The Expires\
    \ header indicates a date and time\n         after which the presentation description\
    \ (body) SHOULD be\n         considered stale.\n   SETUP response:  The Expires\
    \ header indicates a date and time after\n         which the media stream SHOULD\
    \ be considered stale.\n   A stale cache entry should not be returned by a cache\
    \ (either a proxy\n   cache or a user agent cache) unless it is first validated\
    \ with the\n   origin server (or with an intermediate cache that has a fresh copy\
    \ of\n   the message body).  See Section 16 for further discussion of the\n  \
    \ expiration model.\n   The presence of an Expires field does not imply that the\
    \ original\n   resource will change or cease to exist at, before, or after that\n\
    \   time.\n   The format is an absolute date and time as defined by RTSP-date.\
    \  An\n   example of its use is\n     Expires: Wed, 23 Jan 2013 15:36:52 +0000\n\
    \   RTSP 2.0 clients and caches MUST treat other invalid date formats,\n   especially\
    \ those including the value \"0\", as having occurred in the\n   past (i.e., already\
    \ expired).\n   To mark a response as \"already expired,\" an origin server should\
    \ use\n   an Expires date that is equal to the Date header value.  To mark a\n\
    \   response as \"never expires\", an origin server SHOULD use an Expires\n  \
    \ date approximately one year from the time the response is sent.  RTSP\n   2.0\
    \ servers SHOULD NOT send Expires dates that are more than one year\n   in the\
    \ future.\n"
- title: 18.23.  From
  contents:
  - "18.23.  From\n   The From request-header field, if given, SHOULD contain an Internet\n\
    \   email address for the human user who controls the requesting user\n   agent.\
    \  The address SHOULD be machine usable, as defined by \"mailbox\"\n   in [RFC1123].\n\
    \   This header field MAY be used for logging purposes and as a means for\n  \
    \ identifying the source of invalid or unwanted requests.  It SHOULD\n   NOT be\
    \ used as an insecure form of access protection.  The\n   interpretation of this\
    \ field is that the request is being performed\n   on behalf of the person given,\
    \ who accepts responsibility for the\n   method performed.  In particular, robot\
    \ agents SHOULD include this\n   header so that the person responsible for running\
    \ the robot can be\n   contacted if problems occur on the receiving end.\n   The\
    \ Internet email address in this field MAY be separate from the\n   Internet host\
    \ that issued the request.  For example, when a request\n   is passed through\
    \ a proxy, the original issuer's address SHOULD be\n   used.\n   The client SHOULD\
    \ NOT send the From header field without the user's\n   approval, as it might\
    \ conflict with the user's privacy interests or\n   their site's security policy.\
    \  It is strongly recommended that the\n   user be able to disable, enable, and\
    \ modify the value of this field\n   at any time prior to a request.\n"
- title: 18.24.  If-Match
  contents:
  - "18.24.  If-Match\n   The If-Match request-header field is especially useful for\
    \ ensuring\n   the integrity of the presentation description, independent of how\
    \ the\n   presentation description was received.  The presentation description\n\
    \   can be fetched via means external to RTSP (such as HTTP) or via the\n   DESCRIBE\
    \ message.  In the case of retrieving the presentation\n   description via RTSP,\
    \ the server implementation is guaranteeing the\n   integrity of the description\
    \ between the time of the DESCRIBE message\n   and the SETUP message.  By including\
    \ the MTag given in or with the\n   session description in an If-Match header\
    \ part of the SETUP request,\n   the client ensures that resources set up are\
    \ matching the\n   description.  A SETUP request with the If-Match header for\
    \ which the\n   MTag validation check fails MUST generate a response using 412\n\
    \   (Precondition Failed).\n   This validation check is also very useful if a\
    \ session has been\n   redirected from one server to another.\n"
- title: 18.25.  If-Modified-Since
  contents:
  - "18.25.  If-Modified-Since\n   The If-Modified-Since request-header field is used\
    \ with the DESCRIBE\n   and SETUP methods to make them conditional.  If the requested\
    \ variant\n   has not been modified since the time specified in this field, a\n\
    \   description will not be returned from the server (DESCRIBE) or a\n   stream\
    \ will not be set up (SETUP).  Instead, a 304 (Not Modified)\n   response MUST\
    \ be returned without any message body.\n   An example of the field is:\n    \
    \ If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n"
- title: 18.26.  If-None-Match
  contents:
  - "18.26.  If-None-Match\n   This request-header can be used with one or several\
    \ message body tags\n   to make DESCRIBE requests conditional.  A client that\
    \ has one or more\n   message bodies previously obtained from the resource can\
    \ verify that\n   none of those entities is current by including a list of their\n\
    \   associated message body tags in the If-None-Match header field.  The\n   purpose\
    \ of this feature is to allow efficient updates of cached\n   information with\
    \ a minimum amount of transaction overhead.  As a\n   special case, the value\
    \ \"*\" matches any current entity of the\n   resource.\n   If any of the message\
    \ body tags match the message body tag of the\n   message body that would have\
    \ been returned in the response to a\n   similar DESCRIBE request (without the\
    \ If-None-Match header) on that\n   resource, or if \"*\" is given and any current\
    \ entity exists for that\n   resource, then the server MUST NOT perform the requested\
    \ method,\n   unless required to do so because the resource's modification date\n\
    \   fails to match that supplied in an If-Modified-Since header field in\n   the\
    \ request.  Instead, if the request method was DESCRIBE, the server\n   SHOULD\
    \ respond with a 304 (Not Modified) response, including the\n   cache-related\
    \ header fields (particularly MTag) of one of the message\n   bodies that matched.\
    \  For all other request methods, the server MUST\n   respond with a status of\
    \ 412 (Precondition Failed).\n   See Section 16.1.3 for rules on how to determine\
    \ if two message body\n   tags match.\n   If none of the message body tags match,\
    \ then the server MAY perform\n   the requested method as if the If-None-Match\
    \ header field did not\n   exist, but MUST also ignore any If-Modified-Since header\
    \ field(s) in\n   the request.  That is, if no message body tags match, then the\
    \ server\n   MUST NOT return a 304 (Not Modified) response.\n   If the request\
    \ would, without the If-None-Match header field, result\n   in anything other\
    \ than a 2xx or 304 status, then the If-None-Match\n   header MUST be ignored.\
    \  (See Section 16.1.4 for a discussion of\n   server behavior when both If-Modified-Since\
    \ and If-None-Match appear\n   in the same request.)\n   The result of a request\
    \ having both an If-None-Match header field and\n   an If-Match header field is\
    \ unspecified and MUST be considered an\n   illegal request.\n"
- title: 18.27.  Last-Modified
  contents:
  - "18.27.  Last-Modified\n   The Last-Modified message body header field indicates\
    \ the date and\n   time at which the origin server believes the presentation description\n\
    \   or media stream was last modified.  For the DESCRIBE method, the\n   header\
    \ field indicates the last modification date and time of the\n   description,\
    \ for the SETUP of the media stream.\n   An origin server MUST NOT send a Last-Modified\
    \ date that is later\n   than the server's time of message origination.  In such\
    \ cases, where\n   the resource's last modification would indicate some time in\
    \ the\n   future, the server MUST replace that date with the message\n   origination\
    \ date.\n   An origin server SHOULD obtain the Last-Modified value of the message\n\
    \   body as close as possible to the time that it generates the Date\n   value\
    \ of its response.  This allows a recipient to make an accurate\n   assessment\
    \ of the message body's modification time, especially if the\n   message body\
    \ changes near the time that the response is generated.\n   RTSP servers SHOULD\
    \ send Last-Modified whenever feasible.\n"
- title: 18.28.  Location
  contents:
  - "18.28.  Location\n   The Location response-header field is used to redirect the\
    \ recipient\n   to a location other than the Request-URI for completion of the\n\
    \   request or identification of a new resource.  For 3rr responses, the\n   location\
    \ SHOULD indicate the server's preferred URI for automatic\n   redirection to\
    \ the resource.  The field-value consists of a single\n   absolute URI.\n   Note:\
    \ The Content-Location header field (Section 18.18) differs from\n   Location\
    \ in that the Content-Location identifies the original\n   location of the message\
    \ body enclosed in the request.  Therefore, it\n   is possible for a response\
    \ to contain header fields for both Location\n   and Content-Location.  Also,\
    \ see Section 16.2 for cache requirements\n   of some methods.\n"
- title: 18.29.  Media-Properties
  contents:
  - "18.29.  Media-Properties\n   This general-header is used in SETUP responses or\
    \ PLAY_NOTIFY\n   requests to indicate the media's properties that currently are\n\
    \   applicable to the RTSP session.  PLAY_NOTIFY MAY be used to modify\n   these\
    \ properties at any point.  However, the client SHOULD have\n   received the update\
    \ prior to any action related to the new media\n   properties taking effect. \
    \ For aggregated sessions, the Media-\n   Properties header will be returned in\
    \ each SETUP response.  The\n   header received in the latest response is the\
    \ one that applies on the\n   whole session from this point until any future update.\
    \  The header\n   MAY be included without value in GET_PARAMETER requests to the\
    \ server\n   with a Session header included to query the current Media-Properties\n\
    \   for the session.  The responder MUST include the current session's\n   media\
    \ properties.\n   The media properties expressed by this header are the ones applicable\n\
    \   to all media in the RTSP session.  For aggregated sessions, the\n   header\
    \ expressed the combined media-properties.  As a result,\n   aggregation of media\
    \ MAY result in a change of the media properties\n   and, thus, the content of\
    \ the Media-Properties header contained in\n   subsequent SETUP responses.\n \
    \  The header contains a list of property values that are applicable to\n   the\
    \ currently setup media or aggregate of media as indicated by the\n   RTSP URI\
    \ in the request.  No ordering is enforced within the header.\n   Property values\
    \ should be placed into a single group that handles a\n   particular orthogonal\
    \ property.  Values or groups that express\n   multiple properties SHOULD NOT\
    \ be used.  The list of properties that\n   can be expressed MAY be extended at\
    \ any time.  Unknown property\n   values MUST be ignored.\n   This specification\
    \ defines the following four groups and their\n   property values:\n   Random\
    \ Access:\n      Random-Access:  Indicates that random access is possible.  May\n\
    \         optionally include a floating-point value in seconds indicating\n  \
    \       the longest duration between any two random access points in\n       \
    \  the media.\n      Beginning-Only:  Seeking is limited to the beginning only.\n\
    \      No-Seeking:  No seeking is possible.\n   Content Modifications:\n     \
    \ Immutable:  The content will not be changed during the lifetime of\n       \
    \  the RTSP session.\n      Dynamic:  The content may be changed based on external\
    \ methods or\n         triggers.\n      Time-Progressing:  The media accessible\
    \ progresses as wallclock\n         time progresses.\n   Retention:\n      Unlimited:\
    \  Content will be retained for the duration of the\n         lifetime of the\
    \ RTSP session.\n      Time-Limited:  Content will be retained at least until\
    \ the\n         specified wallclock time.  The time must be provided in the\n\
    \         absolute time format specified in Section 4.4.3.\n      Time-Duration:\
    \  Each individual media unit is retained for at\n         least the specified\
    \ Time-Duration.  This definition allows for\n         retaining data with a time-based\
    \ sliding window.  The time\n         duration is expressed as floating-point\
    \ number in seconds.  The\n         value 0.0 is a valid as this indicates that\
    \ no data is retained\n         in a time-progressing session.\n   Supported Scale:\n\
    \      Scales:  A quoted comma-separated list of one or more decimal\n       \
    \  values or ranges of scale values supported by the content in\n         arbitrary\
    \ order.  A range has a start and stop value separated\n         by a colon. \
    \ A range indicates that the content supports a\n         fine-grained selection\
    \ of scale values.  Fine-graining allows\n         for steps at least as small\
    \ as one tenth of a scale value.\n         Content is considered to support fine-grained\
    \ selection when\n         the server in response to a given scale value can produce\n\
    \         content with an actual scale that is less than one tenth of\n      \
    \   scale unit, i.e., 0.1, from the requested value.  Negative\n         values\
    \ are supported.  The value 0 has no meaning and MUST NOT\n         be used.\n\
    \   Examples of this header for on-demand content and a live stream\n   without\
    \ recording are:\n   On-demand:\n   Media-Properties: Random-Access=2.5, Unlimited,\
    \ Immutable,\n        Scales=\"-20, -10, -4, 0.5:1.5, 4, 8, 10, 15, 20\"\n   Live\
    \ stream without recording/timeshifting:\n   Media-Properties: No-Seeking, Time-Progressing,\
    \ Time-Duration=0.0\n"
- title: 18.30.  Media-Range
  contents:
  - "18.30.  Media-Range\n   The Media-Range general-header is used to give the range\
    \ of the media\n   at the time of sending the RTSP message.  This header MUST\
    \ be\n   included in the SETUP response, PLAY and PAUSE responses for media\n\
    \   that are time-progressing, PLAY and PAUSE responses after any change\n   for\
    \ media that are Dynamic, and in PLAY_NOTIFY requests that are sent\n   due to\
    \ Media-Property-Update.  A Media-Range header without any range\n   specifications\
    \ MAY be included in GET_PARAMETER requests to the\n   server to request the current\
    \ range.  In this case, the server MUST\n   include the current range at the time\
    \ of sending the response.\n   The header MUST include range specifications for\
    \ all time formats\n   supported for the media, as indicated in Accept-Ranges\
    \ header\n   (Section 18.5) when setting up the media.  The server MAY include\n\
    \   more than one range specification of any given time format to\n   indicate\
    \ media that has non-continuous range.  The range\n   specifications SHALL be\
    \ ordered with the range with the lowest value\n   or earliest start time first,\
    \ followed by ranges with increasingly\n   higher values or later start time.\n\
    \   For media that has the time-progressing property, the Media-Range\n   header\
    \ values will only be valid for the particular point in time\n   when it was issued.\
    \  As the wallclock progresses, so will the media\n   range.  However, it shall\
    \ be assumed that media time progresses in\n   direct relationship to wallclock\
    \ time (with the exception of clock\n   skew) so that a reasonably accurate estimation\
    \ of the media range can\n   be calculated.\n"
- title: 18.31.  MTag
  contents:
  - "18.31.  MTag\n   The MTag response-header MAY be included in DESCRIBE, GET_PARAMETER,\n\
    \   or SETUP responses.  The message body tags (Section 4.6) returned in\n   a\
    \ DESCRIBE response and the one in SETUP refer to the presentation,\n   i.e.,\
    \ both the returned session description and the media stream.\n   This allows\
    \ for verification that one has the right session\n   description to a media resource\
    \ at the time of the SETUP request.\n   However, it has the disadvantage that\
    \ a change in any of the parts\n   results in invalidation of all the parts.\n\
    \   If the MTag is provided both inside the message body, e.g., within\n   the\
    \ \"a=mtag\" attribute in SDP, and in the response message, then both\n   tags\
    \ MUST be identical.  It is RECOMMENDED that the MTag be primarily\n   given in\
    \ the RTSP response message, to ensure that caches can use the\n   MTag without\
    \ requiring content inspection.  However, for session\n   descriptions that are\
    \ distributed outside of RTSP, for example, using\n   HTTP, etc., it will be necessary\
    \ to include the message body tag in\n   the session description as specified\
    \ in Appendix D.1.9.\n   SETUP and DESCRIBE requests can be made conditional upon\
    \ the MTag\n   using the headers If-Match (Section 18.24) and If-None-Match\n\
    \   (Section 18.26).\n"
- title: 18.32.  Notify-Reason
  contents:
  - "18.32.  Notify-Reason\n   The Notify-Reason response-header is solely used in\
    \ the PLAY_NOTIFY\n   method.  It indicates the reason why the server has sent\
    \ the\n   asynchronous PLAY_NOTIFY request (see Section 13.5).\n"
- title: 18.33.  Pipelined-Requests
  contents:
  - "18.33.  Pipelined-Requests\n   The Pipelined-Requests general-header is used\
    \ to indicate that a\n   request is to be executed in the context created by a\
    \ previous\n   request(s).  The primary usage of this header is to allow pipelining\n\
    \   of SETUP requests so that any additional SETUP request after the\n   first\
    \ one does not need to wait for the session ID to be sent back to\n   the requesting\
    \ agent.  The header contains a unique identifier that\n   is scoped by the persistent\
    \ connection used to send the requests.\n   Upon receiving a request with the\
    \ Pipelined-Requests, the responding\n   agent MUST look up if there exists a\
    \ binding between this Pipelined-\n   Requests identifier for the current persistent\
    \ connection and an RTSP\n   session ID.  If the binding exists, then the received\
    \ request is\n   processed the same way as if it contained the Session header\
    \ with the\n   found session ID.  If there does not exist a mapping and no Session\n\
    \   header is included in the request, the responding agent MUST create a\n  \
    \ binding upon the successful completion of a session creating request,\n   i.e.,\
    \ SETUP.  A binding MUST NOT be created, if the request failed to\n   create an\
    \ RTSP session.  In case the request contains both a Session\n   header and the\
    \ Pipelined-Requests header, the Pipelined-Requests\n   header MUST be ignored.\n\
    \   Note: Based on the above definition, at least the first request\n   containing\
    \ a new unique Pipelined-Requests header will be required to\n   be a SETUP request\
    \ (unless the protocol is extended with new methods\n   of creating a session).\
    \  After that first one, additional SETUP\n   requests or requests of any type\
    \ using the RTSP session context may\n   include the Pipelined-Requests header.\n\
    \   When responding to any request that contained the Pipelined-Requests\n   header,\
    \ the server MUST also include the Session header when a\n   binding to a session\
    \ context exists.  An RTSP agent that knows the\n   session identifier SHOULD\
    \ NOT use the Pipelined-Requests header in\n   any request and only use the Session\
    \ header.  This as the Session\n   identifier is persistent across transport contexts,\
    \ like TCP\n   connections, which the Pipelined-Requests identifier is not.\n\
    \   The RTSP agent sending the request with a Pipelined-Requests header\n   has\
    \ the responsibility for using a unique and previously unused\n   identifier within\
    \ the transport context.  Currently, only a TCP\n   connection is defined as such\
    \ a transport context.  A server MUST\n   delete the Pipelined-Requests identifier\
    \ and its binding to a session\n   upon the termination of that session.  Despite\
    \ the previous mandate,\n   RTSP agents are RECOMMENDED not to reuse identifiers\
    \ to allow for\n   better error handling and logging.\n   RTSP Proxies may need\
    \ to translate Pipelined-Requests identifier\n   values from incoming requests\
    \ to outgoing to allow for aggregation of\n   requests onto a persistent connection.\n"
- title: 18.34.  Proxy-Authenticate
  contents:
  - "18.34.  Proxy-Authenticate\n   The Proxy-Authenticate response-header field MUST\
    \ be included as part\n   of a 407 (Proxy Authentication Required) response. \
    \ The field-value\n   consists of a challenge that indicates the authentication\
    \ scheme and\n   parameters applicable to the proxy for this Request-URI.  The\n\
    \   definition of the header is in [RFC7235], and any applicable HTTP\n   authentication\
    \ schemes appear in other RFCs, such as Digest [RFC7616]\n   and Basic [RFC7617].\n\
    \   The HTTP access authentication process is described in [RFC7235].\n   This\
    \ header MUST only be used in response messages related to client-\n   to-server\
    \ requests.\n"
- title: 18.35.  Proxy-Authentication-Info
  contents:
  - "18.35.  Proxy-Authentication-Info\n   The Proxy-Authentication-Info response-header\
    \ is used by the proxy to\n   communicate some information regarding the successful\
    \ authentication\n   to the proxy in the message response in some authentication\
    \ schemes,\n   such as the Digest scheme [RFC7616].  The definition of the header\
    \ is\n   in [RFC7615], and any applicable HTTP authentication schemes appear\n\
    \   in other RFCs.  This header MUST only be used in response messages\n   related\
    \ to client-to-server requests.  This header has hop-by-hop\n   scope.\n"
- title: 18.36.  Proxy-Authorization
  contents:
  - "18.36.  Proxy-Authorization\n   The Proxy-Authorization request-header field\
    \ allows the client to\n   identify itself (or its user) to a proxy that requires\n\
    \   authentication.  The Proxy-Authorization field-value consists of\n   credentials\
    \ containing the authentication information of the user\n   agent for the proxy\
    \ or realm of the resource being requested.  The\n   definition of the header\
    \ is in [RFC7235], and any applicable HTTP\n   authentication schemes appear in\
    \ other RFCs, such as Digest [RFC7616]\n   and Basic [RFC7617].\n   The HTTP access\
    \ authentication process is described in [RFC7235].\n   Unlike Authorization,\
    \ the Proxy-Authorization header field applies\n   only to the next-hop proxy.\
    \  This header MUST only be used in client-\n   to-server requests.\n"
- title: 18.37.  Proxy-Require
  contents:
  - "18.37.  Proxy-Require\n   The Proxy-Require request-header field is used to indicate\
    \ proxy-\n   sensitive features that MUST be supported by the proxy.  Any Proxy-\n\
    \   Require header features that are not supported by the proxy MUST be\n   negatively\
    \ acknowledged by the proxy to the client using the\n   Unsupported header.  The\
    \ proxy MUST use the 551 (Option Not\n   Supported) status code in the response.\
    \  Any feature tag included in\n   the Proxy-Require does not apply to the endpoint\
    \ (server or client).\n   To ensure that a feature is supported by both proxies\
    \ and servers,\n   the tag needs to be included in also a Require header.\n  \
    \ See Section 18.43 for more details on the mechanics of this message\n   and\
    \ a usage example.  See discussion in the proxies section\n   (Section 15.1) about\
    \ when to consider that a feature requires proxy\n   support.\n   Example of use:\n\
    \      Proxy-Require: play.basic\n"
- title: 18.38.  Proxy-Supported
  contents:
  - "18.38.  Proxy-Supported\n   The Proxy-Supported general-header field enumerates\
    \ all the\n   extensions supported by the proxy using feature tags.  The header\n\
    \   carries the intersection of extensions supported by the forwarding\n   proxies.\
    \  The Proxy-Supported header MAY be included in any request\n   by a proxy. \
    \ It MUST be added by any proxy if the Supported header is\n   present in a request.\
    \  When present in a request, the receiver MUST\n   copy the received Proxy-Supported\
    \ header in the response.\n   The Proxy-Supported header field contains a list\
    \ of feature tags\n   applicable to proxies, as described in Section 4.5.  The\
    \ list is the\n   intersection of all feature tags understood by the proxies.\
    \  To\n   achieve an intersection, the proxy adding the Proxy-Supported header\n\
    \   includes all proxy feature tags it understands.  Any proxy receiving\n   a\
    \ request with the header MUST check the list and remove any feature\n   tag(s)\
    \ it does not support.  A Proxy-Supported header present in the\n   response MUST\
    \ NOT be modified by the proxies.  These feature tags are\n   the ones the proxy\
    \ chains support in general and are not specific to\n   the request resource.\n\
    \   Example:\n     C->P1: OPTIONS rtsp://example.com/ RTSP/2.0\n            Supported:\
    \ foo, bar, blech\n            User-Agent: PhonyClient/1.2\n    P1->P2: OPTIONS\
    \ rtsp://example.com/ RTSP/2.0\n            Supported: foo, bar, blech\n     \
    \       Proxy-Supported: proxy-foo, proxy-bar, proxy-blech\n            Via: 2.0\
    \ pro.example.com\n    P2->S:  OPTIONS rtsp://example.com/ RTSP/2.0\n        \
    \    Supported: foo, bar, blech\n            Proxy-Supported: proxy-foo, proxy-blech\n\
    \            Via: 2.0 pro.example.com, 2.0 prox2.example.com\n     S->C:  RTSP/2.0\
    \ 200 OK\n            Supported: foo, bar, baz\n            Proxy-Supported: proxy-foo,\
    \ proxy-blech\n            Public: OPTIONS, SETUP, PLAY, PAUSE, TEARDOWN\n   \
    \         Via: 2.0 pro.example.com, 2.0 prox2.example.com\n"
- title: 18.39.  Public
  contents:
  - "18.39.  Public\n   The Public response-header field lists the set of methods\
    \ supported\n   by the response sender.  This header applies to the general\n\
    \   capabilities of the sender, and its only purpose is to indicate the\n   sender's\
    \ capabilities to the recipient.  The methods listed may or\n   may not be applicable\
    \ to the Request-URI; the Allow header field\n   (Section 18.6) MAY be used to\
    \ indicate methods allowed for a\n   particular URI.\n   Example of use:\n   \
    \   Public: OPTIONS, SETUP, PLAY, PAUSE, TEARDOWN\n   In the event that there\
    \ are proxies between the sender and the\n   recipient of a response, each intervening\
    \ proxy MUST modify the\n   Public header field to remove any methods that are\
    \ not supported via\n   that proxy.  The resulting Public header field will contain\
    \ an\n   intersection of the sender's methods and the methods allowed through\n\
    \   by the intervening proxies.\n      In general, proxies should allow all methods\
    \ to transparently pass\n      through from the sending RTSP agent to the receiving\
    \ RTSP agent,\n      but there may be cases where this is not desirable for a\
    \ given\n      proxy.  Modification of the Public response-header field by the\n\
    \      intervening proxies ensures that the request sender gets an\n      accurate\
    \ response indicating the methods that can be used on the\n      target agent\
    \ via the proxy chain.\n"
- title: 18.40.  Range
  contents:
  - "18.40.  Range\n   The Range general-header specifies a time range in PLAY\n \
    \  (Section 13.4), PAUSE (Section 13.6), SETUP (Section 13.3), and\n   PLAY_NOTIFY\
    \ (Section 13.5) requests and responses.  It MAY be\n   included in GET_PARAMETER\
    \ requests from the client to the server with\n   only a Range format and no value\
    \ to request the current media\n   position, whether the session is in Play or\
    \ Ready state in the\n   included format.  The server SHALL, if supporting the\
    \ range format,\n   respond with the current playing point or pause point as the\
    \ start of\n   the range.  If an explicit stop point was used in the previous\
    \ PLAY\n   request, then that value shall be included as stop point.  Note that\n\
    \   if the server is currently under any type of media playback\n   manipulation\
    \ affecting the interpretation of the Range header, like\n   scale value other\
    \ than 1, that fact is also required to be included\n   in any GET_PARAMETER response\
    \ by including the Scale header to\n   provide complete information.\n   The range\
    \ can be specified in a number of units.  This specification\n   defines smpte\
    \ (Section 4.4.1), npt (Section 4.4.2), and clock\n   (Section 4.4.3) range units.\
    \  While octet ranges (Byte Ranges) (see\n   Section 2.1 of [RFC7233]) and other\
    \ extended units MAY be used, their\n   behavior is unspecified since they are\
    \ not normally meaningful in\n   RTSP.  Servers supporting the Range header MUST\
    \ understand the NPT\n   range format and SHOULD understand the SMPTE range format.\
    \  If the\n   Range header is sent in a time format that is not understood, the\n\
    \   recipient SHOULD return 456 (Header Field Not Valid for Resource) and\n  \
    \ include an Accept-Ranges header indicating the supported time formats\n   for\
    \ the given resource.\n   Example:\n     Range: clock=19960213T143205Z-\n   The\
    \ Range header contains a range of one single range format.  A\n   range is a\
    \ half-open interval with a start and an end point,\n   including the start point\
    \ but excluding the end point.  A range may\n   either be fully specified with\
    \ explicit values for start point and\n   end point or have either the start or\
    \ end point be implicit.  An\n   implicit start point indicates the session's\
    \ pause point, and if no\n   pause point is set, the start of the content.  An\
    \ implicit end point\n   indicates the end of the content.  The usage of both\
    \ implicit start\n   and end points is not allowed in the same Range header; however,\
    \ the\n   omission of the Range header has that meaning, i.e., from pause point\n\
    \   (or start) until end of content.\n      As noted, Range headers define half-open\
    \ intervals.  A range of\n      A-B starts exactly at time A, but ends just before\
    \ B.  Only the\n      start time of a media unit such as a video or audio frame\
    \ is\n      relevant.  For example, assume that video frames are generated\n \
    \     every 40 ms.  A range of 10.0-10.1 would include a video frame\n      starting\
    \ at 10.0 or later time and would include a video frame\n      starting at 10.08,\
    \ even though it lasted beyond the interval.  A\n      range of 10.0-10.08, on\
    \ the other hand, would exclude the frame at\n      10.08.\n      Please note\
    \ the difference between NPT timescales' \"now\" and an\n      implicit start\
    \ value.  Implicit values reference the current\n      pause-point, while \"now\"\
    \ is the current time.  In a time-\n      progressing session with recording (retention\
    \ for some or full\n      time), the pause point may be 2 min into the session\
    \ while now\n      could be 1 hour into the session.\n   By default, range intervals\
    \ increase, where the second point is\n   larger than the first point.\n   Example:\n\
    \       Range: npt=10-15\n   However, range intervals can also decrease if the\
    \ Scale header (see\n   Section 18.46) indicates a negative scale value.  For\
    \ example, this\n   would be the case when a playback in reverse is desired.\n\
    \   Example:\n       Scale: -1\n       Range: npt=15-10\n   Decreasing ranges\
    \ are still half-open intervals as described above.\n   Thus, for range A-B, A\
    \ is closed and B is open.  In the above\n   example, 15 is closed and 10 is open.\
    \  An exception to this rule is\n   the case when B=0 is in a decreasing range.\
    \  In this case, the range\n   is closed on both ends, as otherwise there would\
    \ be no way to reach 0\n   on a reverse playback for formats that have such a\
    \ notion, like NPT\n   and SMPTE.\n   Example:\n       Scale: -1\n       Range:\
    \ npt=15-0\n   In this range, both 15 and 0 are closed.\n   A decreasing range\
    \ interval without a corresponding negative value in\n   the Scale header is not\
    \ valid.\n"
- title: 18.41.  Referrer
  contents:
  - "18.41.  Referrer\n   The Referrer request-header field allows the client to specify,\
    \ for\n   the server's benefit, the address (URI) of the resource from which\n\
    \   the Request-URI was obtained.  The URI refers to that of the\n   presentation\
    \ description, typically retrieved via HTTP.  The Referrer\n   request-header\
    \ allows a server to generate lists of back-links to\n   resources for interest,\
    \ logging, optimized caching, etc.  It also\n   allows obsolete or mistyped links\
    \ to be traced for maintenance.  The\n   Referrer field MUST NOT be sent if the\
    \ Request-URI was obtained from\n   a source that does not have its own URI, such\
    \ as input from the user\n   keyboard.\n   If the field-value is a relative URI,\
    \ it SHOULD be interpreted\n   relative to the Request-URI.  The URI MUST NOT\
    \ include a fragment\n   identifier.\n   Because the source of a link might be\
    \ private information or might\n   reveal an otherwise private information source,\
    \ it is strongly\n   recommended that the user be able to select whether or not\
    \ the\n   Referrer field is sent.  For example, a streaming client could have\
    \ a\n   toggle switch for openly/anonymously, which would respectively\n   enable/disable\
    \ the sending of Referrer and From information.\n   Clients SHOULD NOT include\
    \ a Referrer header field in an (non-secure)\n   RTSP request if the referring\
    \ page was transferred with a secure\n   protocol.\n"
- title: 18.42.  Request-Status
  contents:
  - "18.42.  Request-Status\n   This request-header is used to indicate the end result\
    \ for requests\n   that take time to complete, such as PLAY (Section 13.4).  It\
    \ is sent\n   in PLAY_NOTIFY (Section 13.5) with the end-of-stream reason to report\n\
    \   how the PLAY request concluded, either in success or in failure.  The\n  \
    \ header carries a reference to the request it reports on using the\n   CSeq number\
    \ and the Session ID used in the request reported on.  This\n   is not ensured\
    \ to be unambiguous due to the fact that the CSeq number\n   is scoped by the\
    \ transport connection.  Agents originating requests\n   can reduce the issue\
    \ by using a monotonically increasing counter\n   across all sequential transports\
    \ used.  The header provides both a\n   numerical status code (according to Section\
    \ 8.1.1) and a human-\n   readable reason phrase.\n   Example:\n   Request-Status:\
    \ cseq=63 status=500 reason=\"Media data unavailable\"\n   Proxies that renumber\
    \ the CSeq header need to perform corresponding\n   remapping of the cseq parameter\
    \ in this header when forwarding the\n   request to the next-hop agent.\n"
- title: 18.43.  Require
  contents:
  - "18.43.  Require\n   The Require request-header field is used by agents to ensure\
    \ that the\n   other endpoint supports features that are required in respect to\
    \ this\n   request.  It can also be used to query if the other endpoint supports\n\
    \   certain features; however, the use of the Supported general-header\n   (Section\
    \ 18.51) is much more effective in this purpose.  In case any\n   of the feature\
    \ tags listed by the Require header are not supported by\n   the server or client\
    \ receiving the request, it MUST respond to the\n   request using the error code\
    \ 551 (Option Not Supported) and include\n   the Unsupported header listing those\
    \ feature tags that are NOT\n   supported.  This header does not apply to proxies;\
    \ for the same\n   functionality with respect to proxies, see the Proxy-Require\
    \ header\n   (Section 18.37) with the exception of media-modifying proxies.\n\
    \   Media-modifying proxies, due to their nature of handling media in a\n   way\
    \ that is very similar to a server, do need to understand also the\n   server's\
    \ features to correctly serve the client.\n      This is to make sure that the\
    \ client-server interaction will\n      proceed without delay when all features\
    \ are understood by both\n      sides and only slow down if features are not understood\
    \ (as in the\n      example below).  For a well-matched client-server pair, the\n\
    \      interaction proceeds quickly, saving a round trip often required\n    \
    \  by negotiation mechanisms.  In addition, it also removes state\n      ambiguity\
    \ when the client requires features that the server does\n      not understand.\n\
    \   Example (Not complete):\n   C->S:   SETUP rtsp://server.com/foo/bar/baz.rm\
    \ RTSP/2.0\n           CSeq: 302\n           Require: funky-feature\n        \
    \   Funky-Parameter: funkystuff\n   S->C:   RTSP/2.0 551 Option not supported\n\
    \           CSeq: 302\n           Unsupported: funky-feature\n   In this example,\
    \ \"funky-feature\" is the feature tag that indicates to\n   the client that the\
    \ fictional Funky-Parameter field is required.  The\n   relationship between \"\
    funky-feature\" and Funky-Parameter is not\n   communicated via the RTSP exchange,\
    \ since that relationship is an\n   immutable property of \"funky-feature\" and\
    \ thus should not be\n   transmitted with every exchange.\n   Proxies and other\
    \ intermediary devices MUST ignore this header.  If a\n   particular extension\
    \ requires that intermediate devices support it,\n   the extension should be tagged\
    \ in the Proxy-Require field instead\n   (see Section 18.37).  See discussion\
    \ in the proxies section\n   (Section 15.1) about when to consider that a feature\
    \ requires proxy\n   support.\n"
- title: 18.44.  Retry-After
  contents:
  - "18.44.  Retry-After\n   The Retry-After response-header field can be used with\
    \ a 503 (Service\n   Unavailable) or 553 (Proxy Unavailable) response to indicate\
    \ how long\n   the service is expected to be unavailable to the requesting client.\n\
    \   This field MAY also be used with any 3rr (Redirection) response to\n   indicate\
    \ the minimum time the user agent is asked to wait before\n   issuing the redirected\
    \ request.  A response using 413 (Request\n   Message Body Too Large) when the\
    \ restriction is temporary MAY also\n   include the Retry-After header.  The value\
    \ of this field can be\n   either an RTSP-date or an integer number of seconds\
    \ (in decimal)\n   after the time of the response.\n   Example:\n   Retry-After:\
    \ Fri, 31 Dec 1999 23:59:59 GMT\n   Retry-After: 120\n   In the latter example,\
    \ the delay is 2 minutes.\n"
- title: 18.45.  RTP-Info
  contents:
  - "18.45.  RTP-Info\n   The RTP-Info general-header field is used to set RTP-specific\n\
    \   parameters in the PLAY and GET_PARAMETER responses or PLAY_NOTIFY and\n  \
    \ GET_PARAMETER requests.  For streams using RTP as transport protocol,\n   the\
    \ RTP-Info header SHOULD be part of a 200 response to PLAY.\n      The exclusion\
    \ of the RTP-Info in a PLAY response for RTP-\n      transported media will result\
    \ in a client needing to synchronize\n      the media streams using RTCP.  This\
    \ may have negative impact as\n      the RTCP can be lost and does not need to\
    \ be particularly timely\n      in its arrival.  Also, functionality that informs\
    \ the client from\n      which packet a seek has occurred is affected.\n   The\
    \ RTP-Info MAY be included in SETUP responses to provide\n   synchronization information\
    \ when changing transport parameters, see\n   Section 13.3.  The RTP-Info header\
    \ and the Range header MAY be\n   included in a GET_PARAMETER request from client\
    \ to server without any\n   values to request the current playback point and corresponding\
    \ RTP\n   synchronization information.  When the RTP-Info header is included in\n\
    \   a Request, the Range header MUST also be included.  The server\n   response\
    \ SHALL include both the Range header and the RTP-Info header.\n   If the session\
    \ is in Play state, then the value of the Range header\n   SHALL be filled in\
    \ with the current playback point and with the\n   corresponding RTP-Info values.\
    \  If the server is in another state, no\n   values are included in the RTP-Info\
    \ header.  The header is included\n   in PLAY_NOTIFY requests with the Notify-Reason\
    \ of the end of stream\n   to provide RTP information about the end of the stream.\n\
    \   The header can carry the following parameters:\n   url:  Indicates the stream\
    \ URI for which the following RTP parameters\n         correspond; this URI MUST\
    \ be the same as used in the SETUP\n         request for this media stream.  Any\
    \ relative URI MUST use the\n         Request-URI as base URI.  This parameter\
    \ MUST be present.\n   ssrc: The SSRC to which the RTP timestamp and sequence\
    \ number\n         provided applies.  This parameter MUST be present.\n   seq:\
    \  Indicates the sequence number of the first packet of the stream\n         that\
    \ is direct result of the request.  This allows clients to\n         gracefully\
    \ deal with packets when seeking.  The client uses\n         this value to differentiate\
    \ packets that originated before the\n         seek from packets that originated\
    \ after the seek.  Note that a\n         client may not receive the packet with\
    \ the expressed sequence\n         number and instead may receive packets with\
    \ a higher sequence\n         number due to packet loss or reordering.  This parameter\
    \ is\n         RECOMMENDED to be present.\n   rtptime:  MUST indicate the RTP\
    \ timestamp value corresponding to the\n         start time value in the Range\
    \ response-header or, if not\n         explicitly given, the implied start point.\
    \  The client uses\n         this value to calculate the mapping of RTP time to\
    \ NPT or other\n         media timescale.  This parameter SHOULD be present to\
    \ ensure\n         inter-media synchronization is achieved.  There exists no\n\
    \         requirement that any received RTP packet will have the same RTP\n  \
    \       timestamp value as the one in the parameter used to establish\n      \
    \   synchronization.\n      A mapping from RTP timestamps to NTP format timestamps\
    \ (wallclock)\n      is available via RTCP.  However, this information is not\n\
    \      sufficient to generate a mapping from RTP timestamps to media\n      clock\
    \ time (NPT, etc.).  Furthermore, in order to ensure that this\n      information\
    \ is available at the necessary time (immediately at\n      startup or after a\
    \ seek), and that it is delivered reliably, this\n      mapping is placed in the\
    \ RTSP control channel.\n      In order to compensate for drift for long, uninterrupted\n\
    \      presentations, RTSP clients should additionally map NPT to NTP,\n     \
    \ using initial RTCP sender reports to do the mapping, and later\n      reports\
    \ to check drift against the mapping.\n   Example:\n   Range:npt=3.25-15\n   RTP-Info:url=\"\
    rtsp://example.com/foo/audio\" ssrc=0A13C760:seq=45102;\n            rtptime=12345678,url=\"\
    rtsp://example.com/foo/video\"\n            ssrc=9A9DE123:seq=30211;rtptime=29567112\n\
    \   Lets assume that Audio uses a 16 kHz RTP timestamp clock and Video\n   a 90\
    \ kHz RTP timestamp clock.  Then, the media synchronization is\n   depicted in\
    \ the following way.\n   NPT    3.0---3.1---3.2-X-3.3---3.4---3.5---3.6\n   Audio\
    \               PA A\n   Video                  V    PV\n   X: NPT time value\
    \ = 3.25, from Range header.\n   A: RTP timestamp value for Audio from RTP-Info\
    \ header (12345678).\n   V: RTP timestamp value for Video from RTP-Info header\
    \ (29567112).\n   PA: RTP audio packet carrying an RTP timestamp of 12344878,\
    \ which\n       corresponds to NPT = (12344878 - A) / 16000 + 3.25 = 3.2\n   PV:\
    \ RTP video packet carrying an RTP timestamp of 29573412, which\n       corresponds\
    \ to NPT = (29573412 - V) / 90000 + 3.25 = 3.32\n"
- title: 18.46.  Scale
  contents:
  - "18.46.  Scale\n   The Scale general-header indicates the requested or used view\
    \ rate\n   for the media resource being played back.  A scale value of 1\n   indicates\
    \ normal play at the normal forward viewing rate.  If not 1,\n   the value corresponds\
    \ to the rate with respect to normal viewing\n   rate.  For example, a value of\
    \ 2 indicates twice the normal viewing\n   rate (\"fast forward\") and a value\
    \ of 0.5 indicates half the normal\n   viewing rate.  In other words, a value\
    \ of 2 has content time increase\n   at twice the playback time.  For every second\
    \ of elapsed (wallclock)\n   time, 2 seconds of content time will be delivered.\
    \  A negative value\n   indicates reverse direction.  For certain media transports,\
    \ this may\n   require certain considerations to work consistently; see Appendix\
    \ C.1\n   for description on how RTP handles this.\n   The transmitted-data rate\
    \ SHOULD NOT be changed by selection of a\n   different scale value.  The resulting\
    \ bitrate should be reasonably\n   close to the nominal bitrate of the content\
    \ for scale = 1.  The\n   server has to actively manipulate the data when needed\
    \ to meet the\n   bitrate constraints.  Implementation of scale changes depends\
    \ on the\n   server and media type.  For video, a server may, for example, deliver\n\
    \   only key frames or selected frames.  For audio, it may time-scale the\n  \
    \ audio while preserving pitch or, less desirably, deliver fragments of\n   audio,\
    \ or completely mute the audio.\n   The server and content may restrict the range\
    \ of scale values that it\n   supports.  The supported values are indicated by\
    \ the Media-Properties\n   header (Section 18.29).  The client SHOULD only indicate\
    \ request\n   values to be supported.  However, as the values may change as the\n\
    \   content progresses, a requested value may no longer be valid when the\n  \
    \ request arrives.  Thus, a non-supported value in a request does not\n   generate\
    \ an error, it only forces the server to choose the closest\n   value.  The response\
    \ MUST always contain the actual scale value\n   chosen by the server.\n   If\
    \ the server does not implement the possibility to scale, it will\n   not return\
    \ a Scale header.  A server supporting scale operations for\n   PLAY MUST indicate\
    \ this with the use of the \"play.scale\" feature tag.\n   When indicating a negative\
    \ scale for a reverse playback, the Range\n   header MUST indicate a decreasing\
    \ range as described in\n   Section 18.40.\n   Example of playing in reverse at\
    \ 3.5 times normal rate:\n     Scale: -3.5\n     Range: npt=15-10\n"
- title: 18.47.  Seek-Style
  contents:
  - "18.47.  Seek-Style\n   When a client sends a PLAY request with a Range header\
    \ to perform a\n   random access to the media, the client does not know if the\
    \ server\n   will pick the first media samples or the first random access point\n\
    \   prior to the request range.  Depending on the use case, the client\n   may\
    \ have a strong preference.  To express this preference and provide\n   the client\
    \ with information on how the server actually acted on that\n   preference, the\
    \ Seek-Style general-header is defined.\n   Seek-Style is a general-header that\
    \ MAY be included in any PLAY\n   request to indicate the client's preference\
    \ for any media stream that\n   has the random access properties.  The server\
    \ MUST always include the\n   header in any PLAY response for media with random\
    \ access properties\n   to indicate what policy was applied.  A server that receives\
    \ an\n   unknown Seek-Style policy MUST ignore it and select the server\n   default\
    \ policy.  A client receiving an unknown policy MUST ignore it\n   and use the\
    \ Range header and any media synchronization information as\n   basis to determine\
    \ what the server did.\n   This specification defines the following seek policies\
    \ that may be\n   requested (see also Section 4.7.1):\n   RAP:  Random Access\
    \ Point (RAP) is the behavior of requesting the\n      server to locate the closest\
    \ previous random access point that\n      exists in the media aggregate and deliver\
    \ from that.  By\n      requesting a RAP, media quality will be the best possible\
    \ as all\n      media will be delivered from a point where full media state can\
    \ be\n      established in the media decoder.\n   CoRAP:  Conditional Random Access\
    \ Point (CoRAP) is a variant of the\n      above RAP behavior.  This policy is\
    \ primarily intended for cases\n      where there is larger distance between the\
    \ random access points in\n      the media.  CoRAP uses the RAP policy if the\
    \ condition that there\n      is a Random Access Point closer to the requested\
    \ start point than\n      to the current pause point is fulfilled.  Otherwise,\
    \ no seeking is\n      performed and playback will continue from the current pause\
    \ point.\n      This policy assumes that the media state existing prior to the\n\
    \      pause is usable if delivery is continued.  If the client or server\n  \
    \    knows that this is not the fact, the RAP policy should be used.\n      In\
    \ other words, in most cases when the client requests a start\n      point prior\
    \ to the current pause point, a valid decoding\n      dependency chain from the\
    \ media delivered prior to the pause and\n      to the requested media unit will\
    \ not exist.  If the server\n      searched to a random access point, the server\
    \ MUST return the\n      CoRAP policy in the Seek-Style header and adjust the\
    \ Range header\n      to reflect the position of the selected RAP.  In case the\
    \ random\n      access point is farther away and the server chooses to continue\n\
    \      from the current pause point, it MUST include the \"Next\" policy in\n\
    \      the Seek-Style header and adjust the Range header start point to\n    \
    \  the current pause point.\n   First-Prior:  The first-prior policy will start\
    \ delivery with the\n      media unit that has a playout time first prior to the\
    \ requested\n      time.  For discrete media, that would only include media units\n\
    \      that would still be rendered at the request time.  For continuous\n   \
    \   media, that is media that will be rendered during the requested\n      start\
    \ time of the range.\n   Next:  The next media units after the provided start\
    \ time of the\n      range: for continuous framed media, that would mean the first\
    \ next\n      frame after the provided time and for discrete media, the first\n\
    \      unit that is to be rendered after the provided time.  The main\n      usage\
    \ for this case is when the client knows it has all media up\n      to a certain\
    \ point and would like to continue delivery so that a\n      complete uninterrupted\
    \ media playback can be achieved.  An example\n      of such a scenario would\
    \ be switching from a broadcast/multicast\n      delivery to a unicast-based delivery.\
    \  This policy MUST only be\n      used on the client's explicit request.\n  \
    \ Please note that these expressed preferences exist for optimizing the\n   startup\
    \ time or the media quality.  The \"Next\" policy breaks the\n   normal definition\
    \ of the Range header to enable a client to request\n   media with minimal overlap,\
    \ although some may still occur for\n   aggregated sessions.  RAP and First-Prior\
    \ both fulfill the\n   requirement of providing media from the requested range\
    \ and forward.\n   However, unless RAP is used, the media quality for many media\
    \ codecs\n   using predictive methods can be severely degraded unless additional\n\
    \   data is available as, for example, already buffered, or through other\n  \
    \ side channels.\n"
- title: 18.48.  Server
  contents:
  - "18.48.  Server\n   The Server general-header field contains information about\
    \ the\n   software used by the origin server to create or handle the request.\n\
    \   This field can contain multiple product tokens and comments\n   identifying\
    \ the server and any significant subproducts.  The product\n   tokens are listed\
    \ in order of their significance for identifying the\n   application.\n   Example:\n\
    \   Server: PhonyServer/1.0\n   If the response is being forwarded through a proxy,\
    \ the proxy\n   application MUST NOT modify the Server response-header.  Instead,\
    \ it\n   SHOULD include a Via field (Section 18.57).  If the response is\n   generated\
    \ by the proxy, the proxy application MUST return the Server\n   response-header\
    \ as previously returned by the server.\n"
- title: 18.49.  Session
  contents:
  - "18.49.  Session\n   The Session general-header field identifies an RTSP session.\
    \  An RTSP\n   session is created by the server as a result of a successful SETUP\n\
    \   request, and in the response, the session identifier is given to the\n   client.\
    \  The RTSP session exists until destroyed by a TEARDOWN or a\n   REDIRECT or\
    \ is timed out by the server.\n   The session identifier is chosen by the server\
    \ (see Section 4.3) and\n   MUST be returned in the SETUP response.  Once a client\
    \ receives a\n   session identifier, it MUST be included in any request related\
    \ to\n   that session.  This means that the Session header MUST be included in\n\
    \   a request, using the following methods: PLAY, PAUSE, PLAY_NOTIFY and\n   TEARDOWN.\
    \  It MAY be included in SETUP, OPTIONS, SET_PARAMETER,\n   GET_PARAMETER, and\
    \ REDIRECT.  It MUST NOT be included in DESCRIBE.\n   The Session header MUST\
    \ NOT be included in the following methods, if\n   these requests are pipelined\
    \ and if the session identifier is not yet\n   known: PLAY, PAUSE, TEARDOWN, SETUP,\
    \ OPTIONS SET_PARAMETER, and\n   GET_PARAMETER.\n   In an RTSP response, the session\
    \ header MUST be included in methods,\n   SETUP, PLAY, PAUSE, and PLAY_NOTIFY,\
    \ and it MAY be included in\n   methods TEARDOWN and REDIRECT.  If included in\
    \ the request of the\n   following methods it MUST also be included in the response:\
    \ OPTIONS,\n   GET_PARAMETER, and SET_PARAMETER.  It MUST NOT be included in\n\
    \   DESCRIBE responses.\n   Note that a session identifier identifies an RTSP\
    \ session across\n   transport sessions or connections.  RTSP requests for a given\
    \ session\n   can use different URIs (Presentation and media URIs).  Note, that\n\
    \   there are restrictions depending on the session as to which URIs are\n   acceptable\
    \ for a given method.  However, multiple \"user\" sessions for\n   the same URI\
    \ from the same client will require use of different\n   session identifiers.\n\
    \      The session identifier is needed to distinguish several delivery\n    \
    \  requests for the same URI coming from the same client.\n   The response 454\
    \ (Session Not Found) MUST be returned if the session\n   identifier is invalid.\n\
    \   The header MAY include a parameter for session timeout period.  If\n   not\
    \ explicitly provided, this value is set to 60 seconds.  As this\n   affects how\
    \ often session keep-alives are needed, values smaller than\n   30 seconds are\
    \ not recommended.  However, larger-than-default values\n   can be useful in applications\
    \ of RTSP that have inactive but\n   established sessions for longer time periods.\n\
    \      The 60-second value was chosen as the session timeout value as it\n   \
    \   results in keep-alive messages that are not too frequent and low\n      sensitivity\
    \ to variations in request/response timing.  If one\n      reduces the timeout\
    \ value to below 30 seconds, the corresponding\n      request/response timeout\
    \ becomes a significant part of the session\n      timeout.  The 60-second value\
    \ also allows for reasonably rapid\n      recovery of committed server resources\
    \ in case of client failure.\n"
- title: 18.50.  Speed
  contents:
  - "18.50.  Speed\n   The Speed general-header field requests the server to deliver\n\
    \   specific amounts of nominal media time per unit of delivery time,\n   contingent\
    \ on the server's ability and desire to serve the media\n   stream at the given\
    \ speed.  The client requests the delivery speed to\n   be within a given range\
    \ with a lower and upper bound.  The server\n   SHALL deliver at the highest possible\
    \ speed within the range, but not\n   faster than the upper bound, for which the\
    \ underlying network path\n   can support the resulting transport data rates.\
    \  As long as any speed\n   value within the given range can be provided, the\
    \ server SHALL NOT\n   modify the media quality.  Only if the server is unable\
    \ to deliver\n   media at the speed value provided by the lower bound shall it\
    \ reduce\n   the media quality.\n   Implementation of the Speed functionality\
    \ by the server is OPTIONAL.\n   The server can indicate its support through a\
    \ feature tag,\n   play.speed.  The lack of a Speed header in the response is\
    \ an\n   indication of lack of support of this functionality.\n   The speed parameter\
    \ values are expressed as a positive decimal value,\n   e.g., a value of 2.0 indicates\
    \ that data is to be delivered twice as\n   fast as normal.  A speed value of\
    \ zero is invalid.  The range is\n   specified in the form \"lower bound - upper\
    \ bound\".  The lower-bound\n   value may be smaller or equal to the upper bound.\
    \  All speeds may not\n   be possible to support.  Therefore, the server MAY modify\
    \ the\n   requested values to the closest supported.  The actual supported\n \
    \  speed MUST be included in the response.  However, note that the use\n   cases\
    \ may vary and that Speed value ranges such as 0.7-0.8, 0.3-2.0,\n   1.0-2.5,\
    \ and 2.5-2.5 all have their usages.\n   Example:\n     Speed: 1.0-2.5\n   Use\
    \ of this header changes the bandwidth used for data delivery.  It\n   is meant\
    \ for use in specific circumstances where delivery of the\n   presentation at\
    \ a higher or lower rate is desired.  The main use\n   cases are buffer operations\
    \ or local scale operations.  Implementers\n   should keep in mind that bandwidth\
    \ for the session may be negotiated\n   beforehand (by means other than RTSP)\
    \ and, therefore, renegotiation\n   may be necessary.  To perform Speed operations,\
    \ the server needs to\n   ensure that the network path can support the resulting\
    \ bitrate.\n   Thus, the media transport needs to support feedback so that the\n\
    \   server can react and adapt to the available bitrate.\n"
- title: 18.51.  Supported
  contents:
  - "18.51.  Supported\n   The Supported general-header enumerates all the extensions\
    \ supported\n   by the client or server using feature tags.  The header carries\
    \ the\n   extensions supported by the message-sending client or server.  The\n\
    \   Supported header MAY be included in any request.  When present in a\n   request,\
    \ the receiver MUST respond with its corresponding Supported\n   header.  Note\
    \ that the Supported header is also included in 4xx and\n   5xx responses.\n \
    \  The Supported header contains a list of feature tags, described in\n   Section\
    \ 4.5, that are understood by the client or server.  These\n   feature tags are\
    \ the ones the server or client supports in general\n   and are not specific to\
    \ the request resource.\n   Example:\n     C->S:  OPTIONS rtsp://example.com/\
    \ RTSP/2.0\n            Supported: foo, bar, blech\n            User-Agent: PhonyClient/1.2\n\
    \     S->C:  RTSP/2.0 200 OK\n            Supported: bar, blech, baz\n"
- title: 18.52.  Terminate-Reason
  contents:
  - "18.52.  Terminate-Reason\n   The Terminate-Reason request-header allows the server,\
    \ when sending a\n   REDIRECT or TEARDOWN request, to provide a reason for the\
    \ session\n   termination and any additional information.  This specification\n\
    \   identifies three reasons for Redirections and may be extended in the\n   future:\n\
    \   Server-Admin:  The server needs to be shut down for some\n      administrative\
    \ reason.\n   Session-Timeout:  A client's session has been kept alive for extended\n\
    \      periods of time and the server has determined that it needs to\n      reclaim\
    \ the resources associated with this session.\n   Internal-Error  An internal\
    \ error that is impossible to recover from\n      has occurred, forcing the server\
    \ to terminate the session.\n   The Server may provide additional parameters containing\
    \ information\n   around the redirect.  This specification defines the following\
    \ ones.\n   time:  Provides a wallclock time when the server will stop providing\n\
    \      any service.\n   user-msg:  A UTF-8 text string with a message from the\
    \ server to the\n      user.  This message SHOULD be displayed to the user.\n"
- title: 18.53.  Timestamp
  contents:
  - "18.53.  Timestamp\n   The Timestamp general-header describes when the agent sent\
    \ the\n   request.  The value of the timestamp is of significance only to the\n\
    \   agent and may use any timescale.  The responding agent MUST echo the\n   exact\
    \ same value and MAY, if it has accurate information about this,\n   add a floating-point\
    \ number indicating the number of seconds that has\n   elapsed since it has received\
    \ the request.  The timestamp can be used\n   by the agent to compute the round-trip\
    \ time to the responding agent\n   so that it can adjust the timeout value for\
    \ retransmissions when\n   running over an unreliable protocol.  It also resolves\
    \ retransmission\n   ambiguities for unreliable transport of RTSP.\n   Note that\
    \ the present specification provides only for reliable\n   transport of RTSP messages.\
    \  The Timestamp general-header is\n   specified in case the protocol is extended\
    \ in the future to use\n   unreliable transport.\n"
- title: 18.54.  Transport
  contents:
  - "18.54.  Transport\n   The Transport general-header indicates which transport\
    \ protocol is to\n   be used and configures its parameters such as destination\
    \ address,\n   compression, multicast time-to-live and destination port for a\
    \ single\n   stream.  It sets those values not already determined by a\n   presentation\
    \ description.\n   A Transport request-header MAY contain a list of transport\
    \ options\n   acceptable to the client, in the form of multiple transport\n  \
    \ specification entries.  Transport specifications are comma separated\n   and\
    \ listed in decreasing order of preference.  Each transport\n   specification\
    \ consists of a transport protocol identifier, followed\n   by any number of parameters\
    \ separated by semicolons.  A Transport\n   request-header MAY contain multiple\
    \ transport specifications using\n   the same transport protocol identifier. \
    \ The server MUST return a\n   Transport response-header in the response to indicate\
    \ the values\n   actually chosen, if any.  If no transport specification is supported,\n\
    \   no transport header is returned and the response MUST use the status\n   code\
    \ 461 (Unsupported Transport) (Section 17.4.25).  In case more\n   than one transport\
    \ specification was present in the request, the\n   server MUST return the single\
    \ transport specification (transport-\n   spec) that was actually chosen, if any.\
    \  The number of transport-spec\n   entries is expected to be limited as the client\
    \ will receive guidance\n   on what configurations are possible from the presentation\n\
    \   description.\n   The Transport header MAY also be used in subsequent SETUP\
    \ requests to\n   change transport parameters.  A server MAY refuse to change\n\
    \   parameters of an existing stream.\n   The transport protocol identifier defines,\
    \ for each transport\n   specification, which transport protocol to use and any\
    \ related rules.\n   Each transport protocol identifier defines the parameters\
    \ that are\n   required to occur; additional optional parameters MAY occur.  This\n\
    \   flexibility is provided as parameters may be different and provide\n   different\
    \ options to the RTSP agent.  A transport specification may\n   only contain one\
    \ of any given parameter within it.  A parameter\n   consists of a name and optionally\
    \ a value string.  Parameters MAY be\n   given in any order.  Additionally, a\
    \ transport specification may only\n   contain either the unicast or the multicast\
    \ transport type parameter.\n   The transport protocol identifier, and all parameters,\
    \ need to be\n   understood in a transport specification; if not, the transport\n\
    \   specification MUST be ignored.  An RTSP proxy of any type that uses\n   or\
    \ modifies the transport specification, e.g., access proxy or\n   security proxy,\
    \ MUST remove specifications with unknown parameters\n   before forwarding the\
    \ RTSP message.  If that results in no remaining\n   transport specification,\
    \ the proxy SHALL send a 461 (Unsupported\n   Transport) (Section 17.4.25) response\
    \ without any Transport header.\n      The Transport header is restricted to describing\
    \ a single media\n      stream.  (RTSP can also control multiple streams as a\
    \ single\n      entity.)  Making it part of RTSP rather than relying on a\n  \
    \    multitude of session description formats greatly simplifies\n      designs\
    \ of firewalls.\n   The general syntax for the transport protocol identifier is\
    \ a list of\n   slash-separated tokens:\n   Value1/Value2/Value3...\n   Which,\
    \ for RTP transports, takes the form:\n   RTP/profile/lower-transport.\n   The\
    \ default value for the \"lower-transport\" parameters is specific to\n   the\
    \ profile.  For RTP/AVP, the default is UDP.\n   There are two different methods\
    \ for how to specify where the media\n   should be delivered for unicast transport:\n\
    \   dest_addr:  The presence of this parameter and its values indicates\n    \
    \     the destination address or addresses (host address and port\n         pairs\
    \ for IP flows) necessary for the media transport.\n   No dest_addr:  The lack\
    \ of the dest_addr parameter indicates that the\n         server MUST send media\
    \ to the same address from which the RTSP\n         messages originates.\n   The\
    \ choice of method for indicating where the media is to be\n   delivered depends\
    \ on the use case.  In some cases, the only allowed\n   method will be to use\
    \ no explicit address indication and have the\n   server deliver media to the\
    \ source of the RTSP messages.\n   For multicast, there are several methods for\
    \ specifying addresses,\n   but they are different in how they work compared with\
    \ unicast:\n   dest_addr with client picked address:  The address and relevant\n\
    \         parameters, like TTL (scope), for the actual multicast group to\n  \
    \       deliver the media to.  There are security implications\n         (Section\
    \ 21) with this method that need to be addressed because\n         an RTSP server\
    \ can be used as a DoS attacker on an existing\n         multicast group.\n  \
    \ dest_addr using Session Description Information:  The information\n        \
    \ included in the transport header can all be coming from the\n         session\
    \ description, e.g., the SDP \"c=\" and \"m=\" lines.  This\n         mitigates\
    \ some of the security issues of the previous methods\n         as it is the session\
    \ provider that picks the multicast group\n         and scope.  The client MUST\
    \ include the information if it is\n         available in the session description.\n\
    \   No dest_addr:  The behavior when no explicit multicast group is\n        \
    \ present in a request is not defined.\n   An RTSP proxy will need to take care.\
    \  If the media is not desired to\n   be routed through the proxy, the proxy will\
    \ need to introduce the\n   destination indication.\n   Below are the configuration\
    \ parameters associated with transport:\n   General parameters:\n   unicast /\
    \ multicast:  This parameter is a mutually exclusive\n         indication of whether\
    \ unicast or multicast delivery will be\n         attempted.  One of the two values\
    \ MUST be specified.  Clients\n         that are capable of handling both unicast\
    \ and multicast\n         transmission need to indicate such capability by including\
    \ two\n         full transport-specs with separate parameters for each.\n   layers:\
    \  The number of multicast layers to be used for this media\n         stream.\
    \  The layers are sent to consecutive addresses starting\n         at the dest_addr\
    \ address.  If the parameter is not included, it\n         defaults to a single\
    \ layer.\n   dest_addr:  A general destination address parameter that can contain\n\
    \         one or more address specifications.  Each combination of\n         protocol/profile/lower\
    \ transport needs to have the format and\n         interpretation of its address\
    \ specification defined.  For\n         RTP/AVP/UDP and RTP/AVP/TCP, the address\
    \ specification is a\n         tuple containing a host address and port.  Note,\
    \ only a single\n         destination parameter per transport spec is intended.\
    \  The\n         usage of multiple destinations to distribute a single media to\n\
    \         multiple entities is unspecified.\n         The client originating the\
    \ RTSP request MAY specify the\n         destination address of the stream recipient\
    \ with the host\n         address as part of the tuple.  When the destination\
    \ address is\n         specified, the recipient may be a different party than\
    \ the\n         originator of the request.  To avoid becoming the unwitting\n\
    \         perpetrator of a remote-controlled DoS attack, a server MUST\n     \
    \    perform security checks (see Section 21.2.1) and SHOULD log\n         such\
    \ attempts before allowing the client to direct a media\n         stream to a\
    \ recipient address not chosen by the server.\n         Implementations cannot\
    \ rely on TCP as a reliable means of\n         client identification.  If the\
    \ server does not allow the host\n         address part of the tuple to be set,\
    \ it MUST return 463\n         (Destination Prohibited).\n         The host address\
    \ part of the tuple MAY be empty, for example\n         \":58044\", in cases when\
    \ it is desired to specify only the\n         destination port.  Responses to\
    \ requests including the\n         Transport header with a dest_addr parameter\
    \ SHOULD include the\n         full destination address that is actually used\
    \ by the server.\n         The server MUST NOT remove address information that\
    \ is already\n         present in the request when responding, unless the protocol\n\
    \         requires it.\n   src_addr:  A general source address parameter that\
    \ can contain one or\n         more address specifications.  Each combination\
    \ of\n         protocol/profile/lower transport needs to have the format and\n\
    \         interpretation of its address specification defined.  For\n        \
    \ RTP/AVP/UDP and RTP/AVP/TCP, the address specification is a\n         tuple\
    \ containing a host address and port.\n         This parameter MUST be specified\
    \ by the server if it transmits\n         media packets from an address other\
    \ than the one RTSP messages\n         are sent to.  This will allow the client\
    \ to verify the source\n         address and give it a destination address for\
    \ its RTCP feedback\n         packets, if RTP is used.  The address or addresses\
    \ indicated in\n         the src_addr parameter SHOULD be used both for the sending\
    \ and\n         receiving of the media stream's data packets.  The main reasons\n\
    \         are threefold: First, indicating the port and source address(s)\n  \
    \       lets the receiver know where from the packets is expected to\n       \
    \  originate.  Second, traversal of NATs is greatly simplified\n         when\
    \ traffic is flowing symmetrically over a NAT binding.\n         Third, certain\
    \ NAT traversal mechanisms need to know to which\n         address and port to\
    \ send so-called \"binding packets\" from the\n         receiver to the sender,\
    \ thus creating an address binding in the\n         NAT that the sender-to-receiver\
    \ packet flow can use.\n            This information may also be available through\
    \ SDP.\n            However, since this is more a feature of transport than\n\
    \            media initialization, the authoritative source for this\n       \
    \     information should be in the SETUP response.\n   mode: The mode parameter\
    \ indicates the methods to be supported for\n         this session.  The currently\
    \ defined valid value is \"PLAY\".  If\n         not provided, the default is\
    \ \"PLAY\".  The \"RECORD\" value was\n         defined in RFC 2326; in this specification,\
    \ it is unspecified\n         but reserved.  RECORD and other values may be specified\
    \ in the\n         future.\n   interleaved:  The interleaved parameter implies\
    \ mixing the media\n         stream with the control stream in whatever protocol\
    \ is being\n         used by the control stream, using the mechanism defined in\n\
    \         Section 14.  The argument provides the channel number to be\n      \
    \   used in the $ block (see Section 14) and MUST be present.  This\n        \
    \ parameter MAY be specified as an interval, e.g.,\n         interleaved=4-5 in\
    \ cases where the transport choice for the\n         media stream requires it,\
    \ e.g., for RTP with RTCP.  The channel\n         number given in the request\
    \ is only a guidance from the client\n         to the server on what channel number(s)\
    \ to use.  The server MAY\n         set any valid channel number in the response.\
    \  The declared\n         channels are bidirectional, so both end parties MAY\
    \ send data\n         on the given channel.  One example of such usage is the\
    \ second\n         channel used for RTCP, where both server and client send RTCP\n\
    \         packets on the same channel.\n            This allows RTP/RTCP to be\
    \ handled similarly to the way that\n            it is done with UDP, i.e., one\
    \ channel for RTP and the other\n            for RTCP.\n   MIKEY:  This parameter\
    \ is used in conjunction with transport\n         specifications that can utilize\
    \ MIKEY [RFC3830] for security\n         context establishment.  So far, only\
    \ the SRTP-based RTP\n         profiles SAVP and SAVPF can utilize MIKEY, and\
    \ this is defined\n         in Appendix C.1.4.1.  This parameter can be included\
    \ both in\n         request and response messages.  The binary MIKEY message SHALL\n\
    \         be Base64-encoded [RFC4648] before being included in the value\n   \
    \      part of the parameter, where the encoding adheres to the\n         definition\
    \ in Section 4 of RFC 4648 and where the padding bits\n         are set to zero.\n\
    \   Multicast-specific:\n   ttl:  multicast time-to-live for IPv4.  When included\
    \ in requests,\n         the value indicates the TTL value that the client requests\
    \ the\n         server to use.  In a response, the value actually being used by\n\
    \         the server is returned.  A server will need to consider what\n     \
    \    values that are reasonable and also the authority of the user\n         to\
    \ set this value.  Corresponding functions are not needed for\n         IPv6 as\
    \ the scoping is part of the IPv6 multicast address\n         [RFC4291].\n   RTP-specific:\n\
    \   These parameters MAY only be used if the media-transport protocol is\n   RTP.\n\
    \   ssrc: The ssrc parameter, if included in a SETUP response, indicates\n   \
    \      the RTP SSRC [RFC3550] value(s) that will be used by the media\n      \
    \   server for RTP packets within the stream.  The values are\n         expressed\
    \ as a slash-separated sequence of SSRC values, each\n         SSRC expressed\
    \ as an eight-digit hexadecimal value.\n         The ssrc parameter MUST NOT be\
    \ specified in requests.  The\n         functionality of specifying the ssrc parameter\
    \ in a SETUP\n         request is deprecated as it is incompatible with the\n\
    \         specification of RTP [RFC3550].  If the parameter is included\n    \
    \     in the Transport header of a SETUP request, the server SHOULD\n        \
    \ ignore it, and choose appropriate SSRCs for the stream.  The\n         server\
    \ SHOULD set the ssrc parameter in the Transport header of\n         the response.\n\
    \   RTCP-mux:  Used to negotiate the usage of RTP and RTCP multiplexing\n    \
    \     [RFC5761] on a single underlying transport stream/flow.  The\n         presence\
    \ of this parameter in a SETUP request indicates the\n         client's support\
    \ and requires the server to use RTP and RTCP\n         multiplexing.  The client\
    \ SHALL only include one transport\n         stream in the Transport header specification.\
    \  To provide the\n         server with a choice between using RTP/RTCP multiplexing\
    \ or\n         not, two different transport header specifications must be\n  \
    \       included.\n   The parameter setup and connection defined below MAY only\
    \ be used if\n   the media-transport protocol of the lower-level transport is\n\
    \   connection oriented (such as TCP).  However, these parameters MUST\n   NOT\
    \ be used when interleaving data over the RTSP connection.\n   setup:  Clients\
    \ use the setup parameter on the Transport line in a\n         SETUP request to\
    \ indicate the roles it wishes to play in a TCP\n         connection.  This parameter\
    \ is adapted from [RFC4145].  The use\n         of this parameter in RTP/AVP/TCP\
    \ non-interleaved transport is\n         discussed in Appendix C.2.2; the discussion\
    \ below is limited to\n         syntactic issues.  Clients may specify the following\
    \ values for\n         the setup parameter:\n         active:  The client will\
    \ initiate an outgoing connection.\n         passive:  The client will accept\
    \ an incoming connection.\n         actpass:  The client is willing to accept\
    \ an incoming\n            connection or to initiate an outgoing connection.\n\
    \         If a client does not specify a setup value, the \"active\" value\n \
    \        is assumed.\n         In response to a client SETUP request where the\
    \ setup parameter\n         is set to \"active\", a server's 2xx reply MUST assign\
    \ the setup\n         parameter to \"passive\" on the Transport header line.\n\
    \         In response to a client SETUP request where the setup parameter\n  \
    \       is set to \"passive\", a server's 2xx reply MUST assign the setup\n  \
    \       parameter to \"active\" on the Transport header line.\n         In response\
    \ to a client SETUP request where the setup parameter\n         is set to \"actpass\"\
    , a server's 2xx reply MUST assign the setup\n         parameter to \"active\"\
    \ or \"passive\" on the Transport header\n         line.\n         Note that the\
    \ \"holdconn\" value for setup is not defined for\n         RTSP use, and MUST\
    \ NOT appear on a Transport line.\n   connection:  Clients use the connection\
    \ parameter in a transport\n         specification part of the Transport header\
    \ in a SETUP request\n         to indicate the client's preference for either\
    \ reusing an\n         existing connection between client and server (in which\
    \ case\n         the client sets the \"connection\" parameter to \"existing\"\
    ) or\n         requesting the creation of a new connection between client and\n\
    \         server (in which cast the client sets the \"connection\"\n         parameter\
    \ to \"new\").  Typically, clients use the \"new\" value\n         for the first\
    \ SETUP request for a URL, and \"existing\" for\n         subsequent SETUP requests\
    \ for a URL.\n         If a client SETUP request assigns the \"new\" value to\n\
    \         \"connection\", the server response MUST also assign the \"new\"\n \
    \        value to \"connection\" on the Transport line.\n         If a client\
    \ SETUP request assigns the \"existing\" value to\n         \"connection\", the\
    \ server response MUST assign a value of\n         \"existing\" or \"new\" to\
    \ \"connection\" on the Transport line, at\n         its discretion.\n       \
    \  The default value of \"connection\" is \"existing\", for all SETUP\n      \
    \   requests (initial and subsequent).\n   The combination of transport protocol,\
    \ profile and lower transport\n   needs to be defined.  A number of combinations\
    \ are defined in the\n   Appendix C.\n   Below is a usage example, showing a client\
    \ advertising the capability\n   to handle multicast or unicast, preferring multicast.\
    \  Since this is\n   a unicast-only stream, the server responds with the proper\
    \ transport\n   parameters for unicast.\n     C->S: SETUP rtsp://example.com/foo/bar/baz.rm\
    \ RTSP/2.0\n           CSeq: 302\n           Transport: RTP/AVP;multicast;mode=\"\
    PLAY\",\n               RTP/AVP;unicast;dest_addr=\"192.0.2.5:3456\"/\n      \
    \         \"192.0.2.5:3457\";mode=\"PLAY\"\n           Accept-Ranges: npt, smpte,\
    \ clock\n           User-Agent: PhonyClient/1.2\n     S->C: RTSP/2.0 200 OK\n\
    \           CSeq: 302\n           Date: Fri, 20 Dec 2013 10:20:32 +0000\n    \
    \       Session: rQi1hBrGlFdiYld241FxUO\n           Transport: RTP/AVP;unicast;dest_addr=\"\
    192.0.2.5:3456\"/\n              \"192.0.2.5:3457\";src_addr=\"192.0.2.224:6256\"\
    /\n              \"192.0.2.224:6257\";mode=\"PLAY\"\n           Accept-Ranges:\
    \ npt\n           Media-Properties: Random-Access=0.6, Dynamic,\n            \
    \                 Time-Limited=20081128T165900\n"
- title: 18.55.  Unsupported
  contents:
  - "18.55.  Unsupported\n   The Unsupported response-header lists the features not\
    \ supported by\n   the responding RTSP agent.  In the case where the feature was\n\
    \   specified via the Proxy-Require field (Section 18.37), if there is a\n   proxy\
    \ on the path between the client and the server, the proxy MUST\n   send a response\
    \ message with a status code of 551 (Option Not\n   Supported).  The request MUST\
    \ NOT be forwarded.\n   See Section 18.43 for a usage example.\n"
- title: 18.56.  User-Agent
  contents:
  - "18.56.  User-Agent\n   The User-Agent general-header field contains information\
    \ about the\n   user agent originating the request or producing a response.  This\
    \ is\n   for statistical purposes, the tracing of protocol violations, and\n \
    \  automated recognition of user agents for the sake of tailoring\n   responses\
    \ to avoid particular user agent limitations.  User agents\n   SHOULD include\
    \ this field with requests.  The field can contain\n   multiple product tokens\
    \ and comments identifying the agent and any\n   subproducts which form a significant\
    \ part of the user agent.  By\n   convention, the product tokens are listed in\
    \ order of their\n   significance for identifying the application.\n   Example:\n\
    \   User-Agent: PhonyClient/1.2\n"
- title: 18.57.  Via
  contents:
  - "18.57.  Via\n   The Via general-header field MUST be used by proxies to indicate\
    \ the\n   intermediate protocols and recipients between the user agent and the\n\
    \   server on requests and between the origin server and the client on\n   responses.\
    \  The field is intended to be used for tracking message\n   forwards, avoiding\
    \ request loops, and identifying the protocol\n   capabilities of all senders\
    \ along the request/response chain.\n   Each of multiple values in the Via field\
    \ represents each proxy that\n   has forwarded the message.  Each recipient MUST\
    \ append its\n   information such that the end result is ordered according to\
    \ the\n   sequence of forwarding applications.  So messages originating with\n\
    \   the client or server do not include the Via header.  The first proxy\n   or\
    \ other intermediate adds the header and its information into the\n   field. \
    \ Any additional intermediate adds additional field-values.\n   Resulting in the\
    \ server seeing the chains of intermediates in a\n   client-to-server request\
    \ and the client seeing the full chain in the\n   response message.\n   Proxies\
    \ (e.g., Access Proxy or Translator Proxy) SHOULD NOT, by\n   default, forward\
    \ the names and ports of hosts within the private/\n   protected region.  This\
    \ information SHOULD only be propagated if\n   explicitly enabled.  If not enabled,\
    \ the via-received of any host\n   behind the firewall/NAT SHOULD be replaced\
    \ by an appropriate\n   pseudonym for that host.\n   For organizations that have\
    \ strong privacy requirements for hiding\n   internal structures, a proxy MAY\
    \ combine an ordered subsequence of\n   Via header field entries with identical\
    \ sent-protocol values into a\n   single such entry.  Applications MUST NOT combine\
    \ entries that have\n   different received-protocol values.\n"
- title: 18.58.  WWW-Authenticate
  contents:
  - "18.58.  WWW-Authenticate\n   The WWW-Authenticate header is specified in [RFC7235];\
    \ its usage\n   depends on the used authentication schemes, such as Digest [RFC7616]\n\
    \   and Basic [RFC7617].  The WWW-Authenticate response-header field MUST\n  \
    \ be included in 401 (Unauthorized) response messages.  The field-value\n   consists\
    \ of at least one challenge that indicates the authentication\n   scheme(s) and\
    \ parameters applicable to the Request-URI.  This header\n   MUST only be used\
    \ in response messages related to client to server\n   requests.\n   The HTTP\
    \ access authentication process is described in [RFC7235] with\n   some clarification\
    \ in Section 19.1.  User agents are advised to take\n   special care in parsing\
    \ the WWW-Authenticate field-value as it might\n   contain more than one challenge,\
    \ or if more than one WWW-Authenticate\n   header field is provided, the contents\
    \ of a challenge itself can\n   contain a comma-separated list of authentication\
    \ parameters.\n"
- title: 19.  Security Framework
  contents:
  - "19.  Security Framework\n   The RTSP security framework consists of two high-level\
    \ components:\n   the pure authentication mechanisms based on HTTP authentication\
    \ and\n   the message transport protection based on TLS, which is independent\n\
    \   of RTSP.  Because of the similarity in syntax and usage between RTSP\n   servers\
    \ and HTTP servers, the security for HTTP is reused to a large\n   extent.\n"
- title: 19.1.  RTSP and HTTP Authentication
  contents:
  - "19.1.  RTSP and HTTP Authentication\n   RTSP and HTTP share common authentication\
    \ schemes; thus, they follow\n   the same framework as specified in [RFC7235].\
    \  RTSP uses the\n   corresponding RTSP error codes (401 and 407) and headers\
    \ (WWW-\n   Authenticate, Authorization, Proxy-Authenticate, Proxy-Authorization)\n\
    \   by importing the definitions from [RFC7235].  Servers SHOULD\n   implement\
    \ both the Basic [RFC7617] and the Digest [RFC7616]\n   authentication schemes.\
    \  Clients MUST implement both the Basic and\n   the Digest authentication schemes\
    \ so that a server that requires the\n   client to authenticate can trust that\
    \ the capability is present.  If\n   implementing the Digest authentication scheme,\
    \ then the additional\n   considerations specified below in Section 19.1.1 MUST\
    \ be followed.\n   It should be stressed that using the HTTP authentication alone\
    \ does\n   not provide full RTSP message security.  Therefore, TLS SHOULD be\n\
    \   used; see Section 19.2.  Any RTSP message containing an Authorization\n  \
    \ header using the Basic authentication scheme MUST be using a TLS\n   connection\
    \ with confidentiality protection enabled, i.e., no NULL\n   encryption.\n   In\
    \ cases where there is a chain of proxies between the client and the\n   server,\
    \ each proxy may individually request the client or previous\n   proxy to authenticate\
    \ itself.  This is done using the Proxy-\n   Authenticate (Section 18.34), the\
    \ Proxy-Authorization\n   (Section 18.36), and the Proxy-Authentication-Info (Section\
    \ 18.35)\n   headers.  These headers are hop-by-hop headers and are only scoped\
    \ to\n   the current connection and hop.  Thus, if a proxy chain exists, a\n \
    \  proxy connecting to another proxy will have to act as a client to\n   authorize\
    \ itself towards the next proxy.  The WWW-Authenticate\n   (Section 18.58), Authorization\
    \ (Section 18.8), and Authentication-\n   Info (Section 18.7) headers are end-to-end\
    \ and MUST NOT be modified\n   by proxies.\n   This authentication mechanism works\
    \ only for client-to-server\n   requests as currently defined.  This leaves server-to-client\
    \ request\n   outside of the context of TLS-based communication more vulnerable\
    \ to\n   message-injection attacks on the client.  Based on the server-to-\n \
    \  client methods that exist, the potential risks are various: hijacking\n   (REDIRECT),\
    \ denial of service (TEARDOWN and PLAY_NOTIFY), or attacks\n   with uncertain\
    \ results (SET_PARAMETER).\n"
- title: 19.1.1.  Digest Authentication
  contents:
  - "19.1.1.  Digest Authentication\n   This section describes the modifications and\
    \ clarifications required\n   to apply the HTTP Digest authentication scheme to\
    \ RTSP.  The RTSP\n   scheme usage is almost completely identical to that for\
    \ HTTP\n   [RFC7616].  These modifications are based on the procedures defined\n\
    \   for SIP 2.0 [RFC3261] (in Section 22.4) but updated to use RFC 7235,\n   RFC\
    \ 7616 and RFC 7615 instead of RFC 2617.\n   Digest authentication uses two additional\
    \ headers, Authentication-\n   Info and Proxy-Authentication-Info, that are defined\
    \ as in [RFC7615].\n   The rules for Digest authentication follow those defined\
    \ in\n   [RFC7616], with \"HTTP/1.1\" replaced by \"RTSP/2.0\" in addition to\
    \ the\n   following differences:\n   1.  Use the ABNF specified in the referenced\
    \ documents, with the\n       difference that the URI parameter uses the request\
    \ URI format for\n       RTSP, i.e. the ABNF element: Request-URI (see Section\
    \ 20.2.1).\n       The domain parameter uses the RTSP-URI-Ref element for absolute\n\
    \       and relative URIs.\n   2.  If MTags are used, then the example procedure\
    \ for choosing a\n       nonce based on ETag can work, based on replacing the\
    \ ETag with\n       the MTag.\n   3.  As a clarification to the calculation of\
    \ the A2 value for message\n       integrity assurance in the Digest authentication\
    \ scheme,\n       implementers should assume, when the entity-body is empty (that\n\
    \       is, when the RTSP messages have no message body) that the hash of\n  \
    \     the message body resolves to the hash of an empty string, or:\n       H(entity-body),\
    \ example MD5(\"\") =\n       \"d41d8cd98f00b204e9800998ecf8427e\".\n"
- title: 19.2.  RTSP over TLS
  contents:
  - "19.2.  RTSP over TLS\n   RTSP agents MUST implement RTSP over TLS as defined\
    \ in this section\n   and the next Section 19.3.  RTSP MUST follow the same guidelines\
    \ with\n   regard to TLS [RFC5246] usage as specified for HTTP; see [RFC2818].\n\
    \   RTSP over TLS is separated from unsecured RTSP both on the URI level\n   and\
    \ the port level.  Instead of using the \"rtsp\" scheme identifier in\n   the\
    \ URI, the \"rtsps\" scheme identifier MUST be used to signal RTSP\n   over TLS.\
    \  If no port is given in a URI with the \"rtsps\" scheme, port\n   322 MUST be\
    \ used for TLS over TCP/IP.\n   When a client tries to set up an insecure channel\
    \ to the server\n   (using the \"rtsp\" URI), and the policy for the resource\
    \ requires a\n   secure channel, the server MUST redirect the client to the secure\n\
    \   service by sending a 301 redirect response code together with the\n   correct\
    \ Location URI (using the \"rtsps\" scheme).  A user or client\n   MAY upgrade\
    \ a non secured URI to a secured by changing the scheme\n   from \"rtsp\" to \"\
    rtsps\".  A server implementing support for \"rtsps\"\n   MUST allow this.\n \
    \  It should be noted that TLS allows for mutual authentication (when\n   using\
    \ both server and client certificates).  Still, one of the more\n   common ways\
    \ TLS is used is to provide only server-side authentication\n   (often to avoid\
    \ client certificates).  TLS is then used in addition\n   to HTTP authentication,\
    \ providing transport security and server\n   authentication, while HTTP Authentication\
    \ is used to authenticate the\n   client.\n   RTSP includes the possibility to\
    \ keep a TCP session up between the\n   client and server, throughout the RTSP\
    \ session lifetime.  It may be\n   convenient to keep the TCP session, not only\
    \ to save the extra setup\n   time for TCP, but also the extra setup time for\
    \ TLS (even if TLS uses\n   the resume function, there will be almost two extra\
    \ round trips).\n   Still, when TLS is used, such behavior introduces extra active\
    \ state\n   in the server, not only for TCP and RTSP, but also for TLS.  This\
    \ may\n   increase the vulnerability to DoS attacks.\n   There exists a potential\
    \ security vulnerability when reusing TCP and\n   TLS state for different resources\
    \ (URIs).  If two different hostnames\n   point at the same IP address, it can\
    \ be desirable to reuse the TCP/\n   TLS connection to that server.  In that case,\
    \ the RTSP agent having\n   the TCP/TLS connection MUST verify that the server\
    \ certificate\n   associated with the connection has a SubjectAltName matching\
    \ the\n   hostname present in the URI for the resource an RTSP request is to be\n\
    \   issued.\n   In addition to these recommendations, Section 19.3 gives further\n\
    \   recommendations of TLS usage with proxies.\n"
- title: 19.3.  Security and Proxies
  contents:
  - "19.3.  Security and Proxies\n   The nature of a proxy is often to act as a \"\
    man in the middle\", while\n   security is often about preventing the existence\
    \ of one.  This\n   section provides clients with the possibility to use proxies\
    \ even\n   when applying secure transports (TLS) between the RTSP agents.  The\n\
    \   TLS proxy mechanism allows for server and proxy identification using\n   certificates.\
    \  However, the client cannot be identified based on\n   certificates.  The client\
    \ needs to select between using the procedure\n   specified below or using a TLS\
    \ connection directly (bypassing any\n   proxies) to the server.  The choice may\
    \ be dependent on policies.\n   In general, there are two categories of proxies:\
    \ the transparent\n   proxies (of which the client is not aware) and the non-transparent\n\
    \   proxies (of which the client is aware).  This memo specifies only\n   non-transparent\
    \ RTSP proxies, i.e., proxies visible to the RTSP\n   client and RTSP server.\
    \  An infrastructure based on proxies requires\n   that the trust model be such\
    \ that both client and server can trust\n   the proxies to handle the RTSP messages\
    \ correctly.  To be able to\n   trust a proxy, the client and server also need\
    \ to be aware of the\n   proxy.  Hence, transparent proxies cannot generally be\
    \ seen as\n   trusted and will not work well with security (unless they work only\n\
    \   at the transport layer).  In the rest of this section, any reference\n   to\
    \ \"proxy\" will be to a non-transparent proxy, which inspects or\n   manipulates\
    \ the RTSP messages.\n   HTTP Authentication is built on the assumption of proxies\
    \ and can\n   provide user-proxy authentication and proxy-proxy/server\n   authentication\
    \ in addition to the client-server authentication.\n   When TLS is applied and\
    \ a proxy is used, the client will connect to\n   the proxy's address when connecting\
    \ to any RTSP server.  This implies\n   that for TLS, the client will authenticate\
    \ the proxy server and not\n   the end server.  Note that when the client checks\
    \ the server\n   certificate in TLS, it MUST check the proxy's identity (URI or\n\
    \   possibly other known identity) against the proxy's identity as\n   presented\
    \ in the proxy's Certificate message.\n   The problem is that for a proxy accepted\
    \ by the client, the proxy\n   needs to be provided information on which grounds\
    \ it should accept\n   the next-hop certificate.  Both the proxy and the user\
    \ may have rules\n   for this, and the user should have the possibility to select\
    \ the\n   desired behavior.  To handle this case, the Accept-Credentials header\n\
    \   (see Section 18.2) is used, where the client can request the proxy or\n  \
    \ proxies to relay back the chain of certificates used to authenticate\n   any\
    \ intermediate proxies as well as the server.  The assumption that\n   the proxies\
    \ are viewed as trusted gives the user a possibility to\n   enforce policies on\
    \ each trusted proxy of whether it should accept\n   the next agent in the chain.\
    \  However, it should be noted that not\n   all deployments will return the chain\
    \ of certificates used to\n   authenticate any intermediate proxies as well as\
    \ the server.  An\n   operator of such a deployment may want to hide its topology\
    \ from the\n   client.  It should be noted well that the client does not have\
    \ any\n   insight into the proxy's operation.  Even if the proxy is trusted, it\n\
    \   can still return an incomplete chain of certificates.\n   A proxy MUST use\
    \ TLS for the next hop if the RTSP request includes an\n   \"rtsps\" URI.  TLS\
    \ MAY be applied on intermediate links (e.g., between\n   client and proxy or\
    \ between proxy and proxy) even if the resource and\n   the end server are not\
    \ required to use it.  The chain of proxies used\n   by a client to reach a server\
    \ and its TLS sessions MUST have\n   commensurate security.  Therefore, a proxy\
    \ MUST, when initiating the\n   next-hop TLS connection, use the incoming TLS\
    \ connections cipher-\n   suite list, only modified by removing any cipher suites\
    \ that the\n   proxy does not support.  In case a proxy fails to establish a TLS\n\
    \   connection due to cipher-suite mismatch between proxy and next-hop\n   proxy\
    \ or server, this is indicated using error code 472 (Failure to\n   Establish\
    \ Secure Connection).\n"
- title: 19.3.1.  Accept-Credentials
  contents:
  - "19.3.1.  Accept-Credentials\n   The Accept-Credentials header can be used by\
    \ the client to distribute\n   simple authorization policies to intermediate proxies.\
    \  The client\n   includes the Accept-Credentials header to dictate how the proxy\n\
    \   treats the server / next proxy certificate.  There are currently\n   three\
    \ methods defined:\n   Any:  With \"any\", the proxy (or proxies) MUST accept\
    \ whatever\n         certificate is presented.  Of course, this is not a recommended\n\
    \         option to use, but it may be useful in certain circumstances\n     \
    \    (such as testing).\n   Proxy:  For the \"proxy\" method, the proxy (or proxies)\
    \ MUST use its\n         own policies to validate the certificate and decide whether\
    \ or\n         not to accept it.  This is convenient in cases where the user\n\
    \         has a strong trust relation with the proxy.  Reasons why a\n       \
    \  strong trust relation may exist are personal/company proxy or\n         the\
    \ proxy has an out-of-band policy configuration mechanism.\n   User: For the \"\
    user\" method, the proxy (or proxies) MUST send\n         credential information\
    \ about the next hop to the client for\n         authorization.  The client can\
    \ then decide whether or not the\n         proxy should accept the certificate.\
    \  See Section 19.3.2 for\n         further details.\n   If the Accept-Credentials\
    \ header is not included in the RTSP request\n   from the client, then the \"\
    Proxy\" method MUST be used as default.  If\n   a method other than the \"Proxy\"\
    \ is to be used, then the Accept-\n   Credentials header MUST be included in all\
    \ of the RTSP requests from\n   the client.  This is because it cannot be assumed\
    \ that the proxy\n   always keeps the TLS state or the user's previous preference\
    \ between\n   different RTSP messages (in particular, if the time interval between\n\
    \   the messages is long).\n   With the \"Any\" and \"Proxy\" methods, the proxy\
    \ will apply the policy\n   as defined for each method.  If the policy does not\
    \ accept the\n   credentials of the next hop, the proxy MUST respond with a message\n\
    \   using status code 471 (Connection Credentials Not Accepted).\n   An RTSP request\
    \ in the direction server to client MUST NOT include\n   the Accept-Credentials\
    \ header.  As for the non-secured communication,\n   the possibility for these\
    \ requests depends on the presence of a\n   client established connection.  However,\
    \ if the server-to-client\n   request is in relation to a session established\
    \ over a TLS secured\n   channel, it MUST be sent in a TLS secured connection.\
    \  That secured\n   connection MUST also be the one used by the last client-to-server\n\
    \   request.  If no such transport connection exists at the time when the\n  \
    \ server desires to send the request, the server MUST discard the\n   message.\n\
    \   Further policies MAY be defined and registered, but this should be\n   done\
    \ with caution.\n"
- title: 19.3.2.  User-Approved TLS Procedure
  contents:
  - "19.3.2.  User-Approved TLS Procedure\n   For the \"User\" method, each proxy\
    \ MUST perform the following\n   procedure for each RTSP request:\n   o  Set up\
    \ the TLS session to the next hop if not already present\n      (i.e., run the\
    \ TLS handshake, but do not send the RTSP request).\n   o  Extract the peer certificate\
    \ chain for the TLS session.\n   o  Check if a matching identity and hash of the\
    \ peer certificate are\n      present in the Accept-Credentials header.  If present,\
    \ send the\n      message to the next hop and conclude these procedures.  If not,\
    \ go\n      to the next step.\n   o  The proxy responds to the RTSP request with\
    \ a 470 or 407 response\n      code.  The 407 response code MAY be used when the\
    \ proxy requires\n      both user and connection authorization from user or client.\
    \  In\n      this message the proxy MUST include a Connection-Credentials\n  \
    \    header, see Section 18.13, with the next hop's identity and\n      certificate.\n\
    \   The client MUST upon receiving a 470 (Connection Authorization\n   Required)\
    \ or 407 (Proxy Authentication Required) response with\n   Connection-Credentials\
    \ header take the decision on whether or not to\n   accept the certificate (if\
    \ it cannot do so, the user SHOULD be\n   consulted).  Using IP addresses in the\
    \ next-hop URI and certificates\n   rather than domain names makes it very difficult\
    \ for a user to\n   determine whether or not it should approve the next hop. \
    \ Proxies are\n   RECOMMENDED to use domain names to identify themselves in URIs\
    \ and in\n   the certificates.  If the certificate is accepted, the client has\
    \ to\n   again send the RTSP request.  In that request, the client has to\n  \
    \ include the Accept-Credentials header including the hash over the\n   DER-encoded\
    \ certificate for all trusted proxies in the chain.\n   Example:\n   C->P: SETUP\
    \ rtsps://test.example.org/secret/audio RTSP/2.0\n         CSeq: 2\n         Transport:\
    \ RTP/AVP;unicast;dest_addr=\"192.0.2.5:4588\"/\n                    \"192.0.2.5:4589\"\
    \n         Accept-Ranges: npt, smpte, clock\n         Accept-Credentials: User\n\
    \   P->C: RTSP/2.0 470 Connection Authorization Required\n         CSeq: 2\n \
    \        Connection-Credentials: \"rtsps://test.example.org\";\n         MIIDNTCCAp...\n\
    \   C->P: SETUP rtsps://test.example.org/secret/audio RTSP/2.0\n         CSeq:\
    \ 3\n         Transport: RTP/AVP;unicast;dest_addr=\"192.0.2.5:4588\"/\n     \
    \               \"192.0.2.5:4589\"\n         Accept-Credentials: User \"rtsps://test.example.org\"\
    ;sha-256;\n         dPYD7txpoGTbAqZZQJ+vaeOkyH4=\n         Accept-Ranges: npt,\
    \ smpte, clock\n   P->S: SETUP rtsps://test.example.org/secret/audio RTSP/2.0\n\
    \         CSeq: 3\n         Transport: RTP/AVP;unicast;dest_addr=\"192.0.2.5:4588\"\
    /\n                    \"192.0.2.5:4589\"\n         Via: RTSP/2.0 proxy.example.org\n\
    \         Accept-Credentials: User \"rtsps://test.example.org\";sha-256;\n   \
    \      dPYD7txpoGTbAqZZQJ+vaeOkyH4=\n         Accept-Ranges: npt, smpte, clock\n\
    \   One implication of this process is that the connection for secured\n   RTSP\
    \ messages may take significantly more round-trip times for the\n   first message.\
    \  A complete extra message exchange between the proxy\n   connecting to the next\
    \ hop and the client results because of the\n   process for approval for each\
    \ hop.  However, if each message contains\n   the chain of proxies that the requester\
    \ accepts, the remaining\n   message exchange should not be delayed.  The procedure\
    \ of including\n   the credentials in each request rather than building state\
    \ in each\n   proxy avoids the need for revocation procedures.\n"
- title: 20.  Syntax
  contents:
  - "20.  Syntax\n   The RTSP syntax is described in an Augmented Backus-Naur Form\
    \ (ABNF)\n   as defined in RFC 5234 [RFC5234].  It uses the basic definitions\n\
    \   present in RFC 5234.\n   Please note that ABNF strings, e.g., \"Accept\",\
    \ are case insensitive\n   as specified in Section 2.3 of RFC 5234.\n   The RTSP\
    \ syntax makes use of the ISO 10646 character set in UTF-8\n   encoding [RFC3629].\n"
- title: 20.1.  Base Syntax
  contents:
  - "20.1.  Base Syntax\n   RTSP header values can be folded onto multiple lines if\
    \ the\n   continuation line begins with a space or horizontal tab.  All linear\n\
    \   whitespace, including folding, has the same semantics as SP.  A\n   recipient\
    \ MAY replace any linear whitespace with a single SP before\n   interpreting the\
    \ field-value or forwarding the message downstream.\n   The SWS construct is used\
    \ when linear whitespace is optional,\n   generally between tokens and separators.\n\
    \   To separate the header name from the rest of value, a colon is used,\n   which,\
    \ by the above rule, allows whitespace before, but no line\n   break, and whitespace\
    \ after, including a line break.  The HCOLON\n   defines this construct.\n   OCTET\
    \           =  %x00-FF ; any 8-bit sequence of data\n   CHAR            =  %x01-7F\
    \ ; any US-ASCII character (octets 1 - 127)\n   UPALPHA         =  %x41-5A ; any\
    \ US-ASCII uppercase letter \"A\"..\"Z\"\n   LOALPHA         =  %x61-7A ; any\
    \ US-ASCII lowercase letter \"a\"..\"z\"\n   ALPHA           =  UPALPHA / LOALPHA\n\
    \   DIGIT           =  %x30-39 ; any US-ASCII digit \"0\"..\"9\"\n   CTL     \
    \        =  %x00-1F / %x7F  ; any US-ASCII control character\n               \
    \       ; (octets 0 - 31) and DEL (127)\n   CR              =  %x0D ; US-ASCII\
    \ CR, carriage return (13)\n   LF              =  %x0A  ; US-ASCII LF, linefeed\
    \ (10)\n   SP              =  %x20  ; US-ASCII SP, space (32)\n   HT         \
    \     =  %x09  ; US-ASCII HT, horizontal-tab (9)\n   BACKSLASH       =  %x5C \
    \ ; US-ASCII backslash (92)\n   CRLF            =  CR LF\n   LWS             =\
    \  [CRLF] 1*( SP / HT ) ; Line-breaking whitespace\n   SWS             =  [LWS]\
    \ ; Separating whitespace\n   HCOLON          =  *( SP / HT ) \":\" SWS\n   TEXT\
    \            =  %x20-7E / %x80-FF  ; any OCTET except CTLs\n   tspecials     \
    \  =  \"(\" / \")\" / \"<\" / \">\" / \"@\"\n                   /  \",\" / \"\
    ;\" / \":\" / BACKSLASH / DQUOTE\n                   /  \"/\" / \"[\" / \"]\"\
    \ / \"?\" / \"=\"\n                   /  \"{\" / \"}\" / SP / HT\n   token   \
    \        =  1*(%x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39\n                \
    \   /  %x41-5A / %x5E-7A / %x7C / %x7E)\n                      ; 1*<any CHAR except\
    \ CTLs or tspecials>\n   quoted-string   =  ( DQUOTE *qdtext DQUOTE )\n   qdtext\
    \          = %x20-21 / %x23-5B / %x5D-7E / quoted-pair\n                   / UTF8-NONASCII\n\
    \                   ; No DQUOTE and no \"\\\"\n   quoted-pair     = \"\\\\\" /\
    \ ( \"\\\" DQUOTE )\n   ctext           =  %x20-27 / %x2A-7E\n               \
    \    /  %x80-FF  ; any OCTET except CTLs, \"(\" and \")\"\n   generic-param  \
    \ =  token [ EQUAL gen-value ]\n   gen-value       =  token / host / quoted-string\n\
    \   safe            =  \"$\" / \"-\" / \"_\" / \".\" / \"+\"\n   extra       \
    \    =  \"!\" / \"*\" / \"'\" / \"(\" / \")\" / \",\"\n   rtsp-extra      =  \"\
    !\" / \"*\" / \"'\" / \"(\" / \")\"\n   HEX             =  DIGIT / \"A\" / \"\
    B\" / \"C\" / \"D\" / \"E\" / \"F\"\n                   /  \"a\" / \"b\" / \"\
    c\" / \"d\" / \"e\" / \"f\"\n   LHEX            =  DIGIT /  \"a\" / \"b\" / \"\
    c\" / \"d\" / \"e\" / \"f\"\n                      ; lowercase \"a-f\" Hex\n \
    \  reserved        =  \";\" / \"/\" / \"?\" / \":\" / \"@\" / \"&\" / \"=\"\n\
    \   unreserved      =  ALPHA / DIGIT / safe / extra\n   rtsp-unreserved  =  ALPHA\
    \ / DIGIT / safe / rtsp-extra\n   base64          =  *base64-unit [base64-pad]\n\
    \   base64-unit     =  4base64-char\n   base64-pad      =  (2base64-char \"==\"\
    ) / (3base64-char \"=\")\n   base64-char     =  ALPHA / DIGIT / \"+\" / \"/\"\n\
    \   SLASH    =  SWS \"/\" SWS ; slash\n   EQUAL    =  SWS \"=\" SWS ; equal\n\
    \   LPAREN   =  SWS \"(\" SWS ; left parenthesis\n   RPAREN   =  SWS \")\" SWS\
    \ ; right parenthesis\n   COMMA    =  SWS \",\" SWS ; comma\n   SEMI     =  SWS\
    \ \";\" SWS ; semicolon\n   COLON    =  SWS \":\" SWS ; colon\n   MINUS    = \
    \ SWS \"-\" SWS ; minus/dash\n   LDQUOT   =  SWS DQUOTE ; open double quotation\
    \ mark\n   RDQUOT   =  DQUOTE SWS ; close double quotation mark\n   RAQUOT   =\
    \  \">\" SWS ; right angle quote\n   LAQUOT   =  SWS \"<\" ; left angle quote\n\
    \   TEXT-UTF8char    =  %x21-7E / UTF8-NONASCII\n   UTF8-NONASCII    = UTF8-2\
    \ / UTF8-3 / UTF8-4\n   UTF8-1           = <As defined in RFC 3629>\n   UTF8-2\
    \           = <As defined in RFC 3629>\n   UTF8-3           = <As defined in RFC\
    \ 3629>\n   UTF8-4           = <As defined in RFC 3629>\n   UTF8-tail        =\
    \ <As defined in RFC 3629>\n   POS-FLOAT        = 1*12DIGIT [\".\" 1*9DIGIT]\n\
    \   FLOAT            = [\"-\"] POS-FLOAT\n"
- title: 20.2.  RTSP Protocol Definition
  contents:
  - '20.2.  RTSP Protocol Definition

    '
- title: 20.2.1.  Generic Protocol Elements
  contents:
  - "20.2.1.  Generic Protocol Elements\n   RTSP-IRI       =  schemes \":\" IRI-rest\n\
    \   IRI-rest       =  ihier-part [ \"?\" iquery ]\n   ihier-part     =  \"//\"\
    \ iauthority ipath-abempty\n   RTSP-IRI-ref   =  RTSP-IRI / irelative-ref\n  \
    \ irelative-ref  =  irelative-part [ \"?\" iquery ]\n   irelative-part =  \"//\"\
    \ iauthority ipath-abempty\n                     / ipath-absolute\n          \
    \           / ipath-noscheme\n                     / ipath-empty\n   iauthority\
    \     =  < As defined in RFC 3987>\n   ipath          =  ipath-abempty   ; begins\
    \ with \"/\" or is empty\n                     / ipath-absolute  ; begins with\
    \ \"/\" but not \"//\"\n                     / ipath-noscheme  ; begins with a\
    \ non-colon segment\n                     / ipath-rootless  ; begins with a segment\n\
    \                     / ipath-empty     ; zero characters\n   ipath-abempty  \
    \ =  *( \"/\" isegment )\n   ipath-absolute  =  \"/\" [ isegment-nz *( \"/\" isegment\
    \ ) ]\n   ipath-noscheme  =  isegment-nz-nc *( \"/\" isegment )\n   ipath-rootless\
    \  =  isegment-nz *( \"/\" isegment )\n   ipath-empty     =  0<ipchar>\n   isegment\
    \        =  *ipchar [\";\" *ipchar]\n   isegment-nz     =  1*ipchar [\";\" *ipchar]\n\
    \                      / \";\" *ipchar\n   isegment-nz-nc  =  (1*ipchar-nc [\"\
    ;\" *ipchar-nc])\n                      / \";\" *ipchar-nc\n                 \
    \     ; non-zero-length segment without any colon \":\"\n                    \
    \  ; No parameter (; delimited) inside path.\n   ipchar         =  iunreserved\
    \ / pct-encoded / sub-delims / \":\" / \"@\"\n   ipchar-nc      =  iunreserved\
    \ / pct-encoded / sub-delims / \"@\"\n                     ; sub-delims is different\
    \ from RFC 3987\n                     ; not including \";\"\n   iquery       \
    \  =  < As defined in RFC 3987>\n   iunreserved    =  < As defined in RFC 3987>\n\
    \   pct-encoded    =  < As defined in RFC 3987>\n   RTSP-URI       =  schemes\
    \ \":\" URI-rest\n   RTSP-REQ-URI   =  schemes \":\" URI-req-rest\n   RTSP-URI-Ref\
    \   =  RTSP-URI / RTSP-Relative\n   RTSP-REQ-Ref   =  RTSP-REQ-URI / RTSP-REQ-Rel\n\
    \   schemes        =  \"rtsp\" / \"rtsps\" / scheme\n   scheme         =  < As\
    \ defined in RFC 3986>\n   URI-rest       =  hier-part [ \"?\" query ]\n   URI-req-rest\
    \   =  hier-part [ \"?\" query ]\n                     ; Note fragment part not\
    \ allowed in requests\n   hier-part      =  \"//\" authority path-abempty\n  \
    \ RTSP-Relative  =  relative-part [ \"?\" query ]\n   RTSP-REQ-Rel   =  relative-part\
    \ [ \"?\" query ]\n   relative-part  =  \"//\" authority path-abempty\n      \
    \               / path-absolute\n                     / path-noscheme\n      \
    \               / path-empty\n   authority      =  < As defined in RFC 3986>\n\
    \   query          =  < As defined in RFC 3986>\n   path           =  path-abempty\
    \    ; begins with \"/\" or is empty\n                     / path-absolute ; begins\
    \ with \"/\" but not \"//\"\n                     / path-noscheme ; begins with\
    \ a non-colon segment\n                     / path-rootless ; begins with a segment\n\
    \                     / path-empty    ; zero characters\n   path-abempty   = \
    \ *( \"/\" segment )\n   path-absolute  =  \"/\" [ segment-nz *( \"/\" segment\
    \ ) ]\n   path-noscheme  =  segment-nz-nc *( \"/\" segment )\n   path-rootless\
    \  =  segment-nz *( \"/\" segment )\n   path-empty     =  0<pchar>\n   segment\
    \        =  *pchar [\";\" *pchar]\n   segment-nz     =  ( 1*pchar [\";\" *pchar])\
    \ / (\";\" *pchar)\n   segment-nz-nc  =  ( 1*pchar-nc [\";\" *pchar-nc]) / (\"\
    ;\" *pchar-nc)\n                     ; non-zero-length segment without any colon\
    \ \":\"\n                     ; No parameter (; delimited) inside path.\n   pchar\
    \          =  unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n   pchar-nc\
    \       =  unreserved / pct-encoded / sub-delims / \"@\"\n   sub-delims     =\
    \  \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n                     / \"*\"\
    \ / \"+\" / \",\" / \"=\"\n                     ; sub-delims is different from\
    \ RFC 3986/3987\n                     ; not including \";\"\n   smpte-range  \
    \      =  smpte-type [EQUAL smpte-range-spec]\n                         ; See\
    \ section 4.4\n   smpte-range-spec   =  ( smpte-time \"-\" [ smpte-time ] )\n\
    \                      /  ( \"-\" smpte-time )\n   smpte-type         =  \"smpte\"\
    \ / \"smpte-30-drop\"\n                      /  \"smpte-25\" / smpte-type-extension\n\
    \                      ; other timecodes may be added\n   smpte-type-extension\
    \  =  \"smpte\" token\n   smpte-time         =  1*2DIGIT \":\" 1*2DIGIT \":\"\
    \ 1*2DIGIT\n                         [ \":\" 1*2DIGIT [ \".\" 1*2DIGIT ] ]\n \
    \  npt-range        =  \"npt\" [EQUAL npt-range-spec]\n   npt-range-spec   = \
    \ ( npt-time \"-\" [ npt-time ] ) / ( \"-\" npt-time )\n   npt-time         =\
    \  \"now\" / npt-sec / npt-hhmmss / npt-hhmmss-comp\n   npt-sec          =  1*19DIGIT\
    \ [ \".\" 1*9DIGIT ]\n   npt-hhmmss       =  npt-hh \":\" npt-mm \":\" npt-ss\
    \ [ \".\" 1*9DIGIT ]\n   npt-hh           =  2*19DIGIT   ; any positive number\n\
    \   npt-mm           =  2*2DIGIT  ; 0-59\n   npt-ss           =  2*2DIGIT  ; 0-59\n\
    \   npt-hhmmss-comp  =  npt-hh-comp \":\" npt-mm-comp \":\" npt-ss-comp\n    \
    \                   [ \".\" 1*9DIGIT ] ; Compatibility format\n   npt-hh-comp\
    \      =  1*19DIGIT   ; any positive number\n   npt-mm-comp      =  1*2DIGIT \
    \ ; 0-59\n   npt-ss-comp      =  1*2DIGIT  ; 0-59\n   utc-range        =  \"clock\"\
    \ [EQUAL utc-range-spec]\n   utc-range-spec   =  ( utc-time \"-\" [ utc-time ]\
    \ ) / ( \"-\" utc-time )\n   utc-time         =  utc-date \"T\" utc-clock \"Z\"\
    \n   utc-date         =  8DIGIT\n   utc-clock        =  6DIGIT [ \".\" 1*9DIGIT\
    \ ]\n   feature-tag       =  token\n   session-id        =  1*256( ALPHA / DIGIT\
    \ / safe )\n   extension-header  =  header-name HCOLON header-value\n   header-name\
    \       =  token\n   header-value      =  *(TEXT-UTF8char / LWS)\n"
- title: 20.2.2.  Message Syntax
  contents:
  - "20.2.2.  Message Syntax\n   RTSP-message  = Request / Response  ; RTSP/2.0 messages\n\
    \   Request       = Request-Line\n                   *((general-header\n     \
    \              /  request-header\n                   /  message-body-header) CRLF)\n\
    \                   CRLF\n                   [ message-body-data ]\n   Response\
    \     = Status-Line\n                  *((general-header\n                  /\
    \  response-header\n                  /  message-body-header) CRLF)\n        \
    \          CRLF\n                  [ message-body-data ]\n   Request-Line = Method\
    \ SP Request-URI SP RTSP-Version CRLF\n   Status-Line  = RTSP-Version SP Status-Code\
    \ SP Reason-Phrase CRLF\n   Method  =  \"DESCRIBE\"\n           /  \"GET_PARAMETER\"\
    \n           /  \"OPTIONS\"\n           /  \"PAUSE\"\n           /  \"PLAY\"\n\
    \           /  \"PLAY_NOTIFY\"\n           /  \"REDIRECT\"\n           /  \"SETUP\"\
    \n           /  \"SET_PARAMETER\"\n           /  \"TEARDOWN\"\n           /  extension-method\n\
    \   extension-method  =  token\n   Request-URI  =  \"*\" / RTSP-REQ-URI\n   RTSP-Version\
    \ =  \"RTSP/\" 1*DIGIT \".\" 1*DIGIT\n   message-body-data = 1*OCTET\n   Status-Code\
    \  =  \"100\"  ; Continue\n                /  \"200\"  ; OK\n                /\
    \  \"301\"  ; Moved Permanently\n                /  \"302\"  ; Found\n       \
    \         /  \"303\"  ; See Other\n                /  \"304\"  ; Not Modified\n\
    \                /  \"305\"  ; Use Proxy\n                /  \"400\"  ; Bad Request\n\
    \                /  \"401\"  ; Unauthorized\n                /  \"402\"  ; Payment\
    \ Required\n                /  \"403\"  ; Forbidden\n                /  \"404\"\
    \  ; Not Found\n                /  \"405\"  ; Method Not Allowed\n           \
    \     /  \"406\"  ; Not Acceptable\n                /  \"407\"  ; Proxy Authentication\
    \ Required\n                /  \"408\"  ; Request Timeout\n                / \
    \ \"410\"  ; Gone\n                /  \"412\"  ; Precondition Failed\n       \
    \         /  \"413\"  ; Request Message Body Too Large\n                /  \"\
    414\"  ; Request-URI Too Long\n                /  \"415\"  ; Unsupported Media\
    \ Type\n                /  \"451\"  ; Parameter Not Understood\n             \
    \   /  \"452\"  ; reserved\n                /  \"453\"  ; Not Enough Bandwidth\n\
    \                /  \"454\"  ; Session Not Found\n                /  \"455\" \
    \ ; Method Not Valid In This State\n                /  \"456\"  ; Header Field\
    \ Not Valid for Resource\n                /  \"457\"  ; Invalid Range\n      \
    \          /  \"458\"  ; Parameter Is Read-Only\n                /  \"459\"  ;\
    \ Aggregate Operation Not Allowed\n                /  \"460\"  ; Only Aggregate\
    \ Operation Allowed\n                /  \"461\"  ; Unsupported Transport\n   \
    \             /  \"462\"  ; Destination Unreachable\n                /  \"463\"\
    \  ; Destination Prohibited\n                /  \"464\"  ; Data Transport Not\
    \ Ready Yet\n                /  \"465\"  ; Notification Reason Unknown\n     \
    \           /  \"466\"  ; Key Management Error\n                /  \"470\"  ;\
    \ Connection Authorization Required\n                /  \"471\"  ; Connection\
    \ Credentials Not Accepted\n                /  \"472\"  ; Failure to Establish\
    \ Secure Connection\n                /  \"500\"  ; Internal Server Error\n   \
    \             /  \"501\"  ; Not Implemented\n                /  \"502\"  ; Bad\
    \ Gateway\n                /  \"503\"  ; Service Unavailable\n               \
    \ /  \"504\"  ; Gateway Timeout\n                /  \"505\"  ; RTSP Version Not\
    \ Supported\n                /  \"551\"  ; Option Not Supported\n            \
    \    /  \"553\"  ; Proxy Unavailable\n                /  extension-code\n   extension-code\
    \  =  3DIGIT\n   Reason-Phrase   =  1*(TEXT-UTF8char / HT / SP)\n   rtsp-header\
    \     = general-header\n                   / request-header\n                \
    \   / response-header\n                   / message-body-header\n   general-header\
    \  =  Accept-Ranges\n                   /  Cache-Control\n                   /\
    \  Connection\n                   /  CSeq\n                   /  Date\n      \
    \             /  Media-Properties\n                   /  Media-Range\n       \
    \            /  Pipelined-Requests\n                   /  Proxy-Supported\n  \
    \                 /  Range\n                   /  RTP-Info\n                 \
    \  /  Scale\n                   /  Seek-Style\n                   /  Server\n\
    \                   /  Session\n                   /  Speed\n                \
    \   /  Supported\n                   /  Timestamp\n                   /  Transport\n\
    \                   /  User-Agent\n                   /  Via\n               \
    \    /  extension-header\n   request-header  =  Accept\n                   / \
    \ Accept-Credentials\n                   /  Accept-Encoding\n                \
    \   /  Accept-Language\n                   /  Authorization\n                \
    \   /  Bandwidth\n                   /  Blocksize\n                   /  From\n\
    \                   /  If-Match\n                   /  If-Modified-Since\n   \
    \                /  If-None-Match\n                   /  Notify-Reason\n     \
    \              /  Proxy-Authorization\n                   /  Proxy-Require\n \
    \                  /  Referrer\n                   /  Request-Status\n       \
    \            /  Require\n                   /  Terminate-Reason\n            \
    \       /  extension-header\n   response-header  =  Authentication-Info\n    \
    \                /  Connection-Credentials\n                    /  Location\n\
    \                    /  MTag\n                    /  Proxy-Authenticate\n    \
    \                /  Proxy-Authentication-Info\n                    /  Public\n\
    \                    /  Retry-After\n                    /  Unsupported\n    \
    \                /  WWW-Authenticate\n                    /  extension-header\n\
    \   message-body-header    =  Allow\n                    /  Content-Base\n   \
    \                 /  Content-Encoding\n                    /  Content-Language\n\
    \                    /  Content-Length\n                    /  Content-Location\n\
    \                    /  Content-Type\n                    /  Expires\n       \
    \             /  Last-Modified\n                    /  extension-header\n"
- title: 20.2.3.  Header Syntax
  contents:
  - "20.2.3.  Header Syntax\n   Accept            =  \"Accept\" HCOLON\n         \
    \               [ accept-range *(COMMA accept-range) ]\n   accept-range      =\
    \  media-type-range [SEMI accept-params]\n   media-type-range  =  ( \"*/*\"\n\
    \                        / ( m-type SLASH \"*\" )\n                        / (\
    \ m-type SLASH m-subtype )\n                       ) *( SEMI m-parameter )\n \
    \  accept-params     =  \"q\" EQUAL qvalue *(SEMI generic-param )\n   qvalue \
    \           =  ( \"0\" [ \".\" *3DIGIT ] )\n                     /  ( \"1\" [\
    \ \".\" *3(\"0\") ] )\n   Accept-Credentials =  \"Accept-Credentials\" HCOLON\
    \ cred-decision\n   cred-decision     =  (\"User\" [LWS cred-info])\n        \
    \             /  \"Proxy\"\n                     /  \"Any\"\n                \
    \     /  (token [LWS 1*header-value])\n                                     ;\
    \ For future extensions\n   cred-info         =  cred-info-data *(COMMA cred-info-data)\n\
    \   cred-info-data    =  DQUOTE RTSP-REQ-URI DQUOTE SEMI hash-alg\n          \
    \              SEMI base64\n   hash-alg          =  \"sha-256\" / extension-alg\n\
    \   extension-alg     =  token\n   Accept-Encoding   =  \"Accept-Encoding\" HCOLON\n\
    \                        [ encoding *(COMMA encoding) ]\n   encoding         \
    \ =  codings [SEMI accept-params]\n   codings           =  content-coding / \"\
    *\"\n   content-coding    =  \"identity\" / token\n   Accept-Language   =  \"\
    Accept-Language\" HCOLON\n                        language *(COMMA language)\n\
    \   language          =  language-range [SEMI accept-params]\n   language-range\
    \    =  language-tag / \"*\"\n   language-tag      =  primary-tag *( \"-\" subtag\
    \ )\n   primary-tag       =  1*8ALPHA\n   subtag            =  1*8ALPHA\n   Accept-Ranges\
    \     =  \"Accept-Ranges\" HCOLON acceptable-ranges\n   acceptable-ranges =  (range-unit\
    \ *(COMMA range-unit))\n   range-unit        =  \"npt\" / \"smpte\" / \"smpte-30-drop\"\
    \ / \"smpte-25\"\n                        / \"clock\" / extension-format\n   extension-format\
    \  =  token\n   Allow             =  \"Allow\" HCOLON Method *(COMMA Method)\n\
    \   Authentication-Info = \"Authentication-Info\" HCOLON auth-param-list\n   auth-param-list\
    \   =  <As the Authentication-Info element in RFC 7615>\n   Authorization    \
    \ =  \"Authorization\" HCOLON credentials\n   credentials       =  <As defined\
    \ by RFC 7235>\n   Bandwidth         =  \"Bandwidth\" HCOLON 1*19DIGIT\n   Blocksize\
    \         =  \"Blocksize\" HCOLON 1*9DIGIT\n   Cache-Control     =  \"Cache-Control\"\
    \ HCOLON cache-directive\n                        *(COMMA cache-directive)\n \
    \  cache-directive   =  cache-rqst-directive\n                     /  cache-rspns-directive\n\
    \   cache-rqst-directive =  \"no-cache\"\n                        /  \"max-stale\"\
    \ [EQUAL delta-seconds]\n                        /  \"min-fresh\" EQUAL delta-seconds\n\
    \                        /  \"only-if-cached\"\n                        /  cache-extension\n\
    \   cache-rspns-directive =  \"public\"\n                            /  \"private\"\
    \n                            /  \"no-cache\"\n                            / \
    \ \"no-transform\"\n                            /  \"must-revalidate\"\n     \
    \                       /  \"proxy-revalidate\"\n                            /\
    \  \"max-age\" EQUAL delta-seconds\n                            /  cache-extension\n\
    \   cache-extension   =  token [EQUAL (token / quoted-string)]\n   delta-seconds\
    \     =  1*19DIGIT\n   Connection         =  \"Connection\" HCOLON connection-token\n\
    \                         *(COMMA connection-token)\n   connection-token   = \
    \ \"close\" / token\n   Connection-Credentials = \"Connection-Credentials\" HCOLON\
    \ cred-chain\n   cred-chain         =  DQUOTE RTSP-REQ-URI DQUOTE SEMI base64\n\
    \   Content-Base       =  \"Content-Base\" HCOLON RTSP-URI\n   Content-Encoding\
    \   =  \"Content-Encoding\" HCOLON\n                         content-coding *(COMMA\
    \ content-coding)\n   Content-Language   =  \"Content-Language\" HCOLON\n    \
    \                     language-tag *(COMMA language-tag)\n   Content-Length  \
    \   =  \"Content-Length\" HCOLON 1*19DIGIT\n   Content-Location   =  \"Content-Location\"\
    \ HCOLON RTSP-REQ-Ref\n   Content-Type       =  \"Content-Type\" HCOLON media-type\n\
    \   media-type         =  m-type SLASH m-subtype *(SEMI m-parameter)\n   m-type\
    \             =  discrete-type / composite-type\n   discrete-type      =  \"text\"\
    \ / \"image\" / \"audio\" / \"video\"\n                      /  \"application\"\
    \ / extension-token\n   composite-type   =  \"message\" / \"multipart\" / extension-token\n\
    \   extension-token  =  ietf-token / x-token\n   ietf-token       =  token\n \
    \  x-token          =  \"x-\" token\n   m-subtype        =  extension-token /\
    \ iana-token\n   iana-token       =  token\n   m-parameter      =  m-attribute\
    \ EQUAL m-value\n   m-attribute      =  token\n   m-value          =  token /\
    \ quoted-string\n   CSeq           =  \"CSeq\" HCOLON cseq-nr\n   cseq-nr    \
    \    =  1*9DIGIT\n   Date           =  \"Date\" HCOLON RTSP-date\n   RTSP-date\
    \      =  date-time ;\n   date-time      =  <As defined in RFC 5322>\n   Expires\
    \        =  \"Expires\" HCOLON RTSP-date\n   From           =  \"From\" HCOLON\
    \ from-spec\n   from-spec      =  ( name-addr / addr-spec ) *( SEMI from-param\
    \ )\n   name-addr      =  [ display-name ] LAQUOT addr-spec RAQUOT\n   addr-spec\
    \      =  RTSP-REQ-URI / absolute-URI\n   absolute-URI   =  < As defined in RFC\
    \ 3986>\n   display-name   =  *(token LWS) / quoted-string\n   from-param    \
    \ =  tag-param / generic-param\n   tag-param      =  \"tag\" EQUAL token\n   If-Match\
    \       =  \"If-Match\" HCOLON (\"*\" / message-tag-list)\n   message-tag-list\
    \ =  message-tag *(COMMA message-tag)\n   message-tag      =  [ weak ] opaque-tag\n\
    \   weak             =  \"W/\"\n   opaque-tag       =  quoted-string\n   If-Modified-Since\
    \  =  \"If-Modified-Since\" HCOLON RTSP-date\n   If-None-Match    =  \"If-None-Match\"\
    \ HCOLON (\"*\" / message-tag-list)\n   Last-Modified    =  \"Last-Modified\"\
    \ HCOLON RTSP-date\n   Location         =  \"Location\" HCOLON RTSP-REQ-URI\n\
    \   Media-Properties = \"Media-Properties\" HCOLON [media-prop-list]\n   media-prop-list\
    \  = media-prop-value *(COMMA media-prop-value)\n   media-prop-value = (\"Random-Access\"\
    \ [EQUAL POS-FLOAT])\n                    / \"Beginning-Only\"\n             \
    \       / \"No-Seeking\"\n                    / \"Immutable\"\n              \
    \      / \"Dynamic\"\n                    / \"Time-Progressing\"\n           \
    \         / \"Unlimited\"\n                    / (\"Time-Limited\" EQUAL utc-time)\n\
    \                    / (\"Time-Duration\" EQUAL POS-FLOAT)\n                 \
    \   / (\"Scales\" EQUAL scale-value-list)\n                    / media-prop-ext\n\
    \   media-prop-ext   = token [EQUAL (1*rtsp-unreserved / quoted-string)]\n   scale-value-list\
    \ = DQUOTE scale-entry *(COMMA scale-entry) DQUOTE\n   scale-entry      = scale-value\
    \ / (scale-value COLON scale-value)\n   scale-value      = FLOAT\n   Media-Range\
    \      = \"Media-Range\" HCOLON [ranges-list]\n   ranges-list      =  ranges-spec\
    \ *(COMMA ranges-spec)\n   MTag             =  \"MTag\" HCOLON message-tag\n \
    \  Notify-Reason    = \"Notify-Reason\" HCOLON Notify-Reas-val\n   Notify-Reas-val\
    \  = \"end-of-stream\"\n                    / \"media-properties-update\"\n  \
    \                  / \"scale-change\"\n                    / Notify-Reason-extension\n\
    \   Notify-Reason-extension  = token\n   Pipelined-Requests = \"Pipelined-Requests\"\
    \ HCOLON startup-id\n   startup-id  = 1*8DIGIT\n   Proxy-Authenticate =  \"Proxy-Authenticate\"\
    \ HCOLON challenge-list\n   challenge-list     = <As defined by the WWW-Authenticate\
    \ in RFC 7235>\n   Proxy-Authentication-Info = \"Proxy-Authentication-Info\" HCOLON\n\
    \                         auth-param-list\n   Proxy-Authorization = \"Proxy-Authorization\"\
    \ HCOLON credentials\n   Proxy-Require      =  \"Proxy-Require\" HCOLON feature-tag-list\n\
    \   feature-tag-list   =  feature-tag *(COMMA feature-tag)\n   Proxy-Supported\
    \    =  \"Proxy-Supported\" HCOLON [feature-tag-list]\n   Public             =\
    \  \"Public\" HCOLON Method *(COMMA Method)\n   Range              =  \"Range\"\
    \ HCOLON ranges-spec\n   ranges-spec        =  npt-range / utc-range / smpte-range\n\
    \                      /  range-ext\n   range-ext          =  extension-format\
    \ [EQUAL range-value]\n   range-value        =  1*(rtsp-unreserved / quoted-string\
    \ / \":\" )\n   Referrer           =  \"Referrer\" HCOLON (absolute-URI / RTSP-URI-Ref)\n\
    \   Request-Status     =  \"Request-Status\" HCOLON req-status-info\n   req-status-info\
    \    =  cseq-info LWS status-info LWS reason-info\n   cseq-info          =  \"\
    cseq\" EQUAL cseq-nr\n   status-info        =  \"status\" EQUAL Status-Code\n\
    \   reason-info        =  \"reason\" EQUAL DQUOTE Reason-Phrase DQUOTE\n   Require\
    \            =  \"Require\" HCOLON feature-tag-list\n   RTP-Info         =  \"\
    RTP-Info\" HCOLON [rtsp-info-spec\n                       *(COMMA rtsp-info-spec)]\n\
    \   rtsp-info-spec   =  stream-url 1*ssrc-parameter\n   stream-url       =  \"\
    url\" EQUAL DQUOTE RTSP-REQ-Ref DQUOTE\n   ssrc-parameter   =  LWS \"ssrc\" EQUAL\
    \ ssrc HCOLON\n                       ri-parameter *(SEMI ri-parameter)\n   ri-parameter\
    \     =  (\"seq\" EQUAL 1*5DIGIT)\n                    /  (\"rtptime\" EQUAL 1*10DIGIT)\n\
    \                    /  generic-param\n   Retry-After      =  \"Retry-After\"\
    \ HCOLON (RTSP-date / delta-seconds)\n   Scale            =  \"Scale\" HCOLON\
    \ scale-value\n   Seek-Style       =  \"Seek-Style\" HCOLON Seek-S-values\n  \
    \ Seek-S-values    =  \"RAP\"\n                    /  \"CoRAP\"\n            \
    \        /  \"First-Prior\"\n                    /  \"Next\"\n               \
    \     /  Seek-S-value-ext\n   Seek-S-value-ext =  token\n   Server           =\
    \  \"Server\" HCOLON ( product / comment )\n                       *(LWS (product\
    \ / comment))\n   product          =  token [SLASH product-version]\n   product-version\
    \  =  token\n   comment          =  LPAREN *( ctext / quoted-pair) RPAREN\n  \
    \ Session          =  \"Session\" HCOLON session-id\n                       [\
    \ SEMI \"timeout\" EQUAL delta-seconds ]\n   Speed            =  \"Speed\" HCOLON\
    \ lower-bound MINUS upper-bound\n   lower-bound      =  POS-FLOAT\n   upper-bound\
    \      =  POS-FLOAT\n   Supported        =  \"Supported\" HCOLON [feature-tag-list]\n\
    \   Terminate-Reason      =  \"Terminate-Reason\" HCOLON TR-Info\n   TR-Info \
    \             =  TR-Reason *(SEMI TR-Parameter)\n   TR-Reason            =  \"\
    Session-Timeout\"\n                        /  \"Server-Admin\"\n             \
    \           /  \"Internal-Error\"\n                        /  token\n   TR-Parameter\
    \         =  TR-time / TR-user-msg / generic-param\n   TR-time              =\
    \  \"time\" EQUAL utc-time\n   TR-user-msg          =  \"user-msg\" EQUAL quoted-string\n\
    \   Timestamp        =  \"Timestamp\" HCOLON timestamp-value [LWS delay]\n   timestamp-value\
    \  =  *19DIGIT [ \".\" *9DIGIT ]\n   delay            =  *9DIGIT [ \".\" *9DIGIT\
    \ ]\n   Transport        =  \"Transport\" HCOLON transport-spec\n            \
    \           *(COMMA transport-spec)\n   transport-spec   =  transport-id *trns-parameter\n\
    \   transport-id     =  trans-id-rtp / other-trans\n   trans-id-rtp     =  \"\
    RTP/\" profile [\"/\" lower-transport]\n                       ; no LWS is allowed\
    \ inside transport-id\n   other-trans      =  token *(\"/\" token)\n   profile\
    \           = \"AVP\" / \"SAVP\" / \"AVPF\" / \"SAVPF\" / token\n   lower-transport\
    \   = \"TCP\" / \"UDP\" / token\n   trns-parameter    = (SEMI ( \"unicast\" /\
    \ \"multicast\" ))\n                     / (SEMI \"interleaved\" EQUAL channel\
    \ [\"-\" channel])\n                     / (SEMI \"ttl\" EQUAL ttl)\n        \
    \             / (SEMI \"layers\" EQUAL 1*DIGIT)\n                     / (SEMI\
    \ \"ssrc\" EQUAL ssrc *(SLASH ssrc))\n                     / (SEMI \"mode\" EQUAL\
    \ mode-spec)\n                     / (SEMI \"dest_addr\" EQUAL addr-list)\n  \
    \                   / (SEMI \"src_addr\" EQUAL addr-list)\n                  \
    \   / (SEMI \"setup\" EQUAL contrans-setup)\n                     / (SEMI \"connection\"\
    \ EQUAL contrans-con)\n                     / (SEMI \"RTCP-mux\")\n          \
    \           / (SEMI \"MIKEY\" EQUAL MIKEY-Value)\n                     / (SEMI\
    \ trn-param-ext)\n   contrans-setup    = \"active\" / \"passive\" / \"actpass\"\
    \n   contrans-con      = \"new\" / \"existing\"\n   trn-param-ext     = par-name\
    \ [EQUAL trn-par-value]\n   par-name          = token\n   trn-par-value     =\
    \ *(rtsp-unreserved / quoted-string)\n   ttl               = 1*3DIGIT ; 0 to 255\n\
    \   ssrc              = 8HEX\n   channel           = 1*3DIGIT ; 0 to 255\n   MIKEY-Value\
    \       = base64\n   mode-spec         = ( DQUOTE mode *(COMMA mode) DQUOTE )\n\
    \   mode              = \"PLAY\" / token\n   addr-list         = quoted-addr *(SLASH\
    \ quoted-addr)\n   quoted-addr       = DQUOTE (host-port / extension-addr) DQUOTE\n\
    \   host-port         = ( host [\":\" port] )\n                     / ( \":\"\
    \ port )\n   extension-addr    = 1*qdtext\n   host              = < As defined\
    \ in RFC 3986>\n   port              = < As defined in RFC 3986>\n   Unsupported\
    \     = \"Unsupported\" HCOLON feature-tag-list\n   User-Agent      = \"User-Agent\"\
    \ HCOLON ( product / comment )\n                     *(LWS (product / comment))\n\
    \   Via             = \"Via\" HCOLON via-parm *(COMMA via-parm)\n   via-parm \
    \       = sent-protocol LWS sent-by *( SEMI via-params )\n   via-params      =\
    \ via-ttl / via-maddr\n                   / via-received / via-extension\n   via-ttl\
    \         = \"ttl\" EQUAL ttl\n   via-maddr       = \"maddr\" EQUAL host\n   via-received\
    \    = \"received\" EQUAL (IPv4address / IPv6address)\n   IPv4address     = <\
    \ As defined in RFC 3986>\n   IPv6address     = < As defined in RFC 3986>\n  \
    \ via-extension   = generic-param\n   sent-protocol   = protocol-name SLASH protocol-version\n\
    \                     SLASH transport-prot\n   protocol-name   = \"RTSP\" / token\n\
    \   protocol-version = token\n   transport-prot  = \"UDP\" / \"TCP\" / \"TLS\"\
    \ / other-transport\n   other-transport = token\n   sent-by         = host [ COLON\
    \ port ]\n   WWW-Authenticate = \"WWW-Authenticate\" HCOLON challenge-list\n"
- title: 20.3.  SDP Extension Syntax
  contents:
  - "20.3.  SDP Extension Syntax\n   This section defines in ABNF the SDP extensions\
    \ defined for RTSP.\n   See Appendix D for the definition of the extensions in\
    \ text.\n   control-attribute   =  \"a=control:\" *SP RTSP-REQ-Ref CRLF\n   a-range-def\
    \         =  \"a=range:\" ranges-spec CRLF\n   a-mtag-def          =  \"a=mtag:\"\
    \ message-tag CRLF\n"
- title: 21.  Security Considerations
  contents:
  - "21.  Security Considerations\n   The security considerations and threats around\
    \ RTSP and its usage can\n   be divided into considerations around the signaling\
    \ protocol itself\n   and the issues related to the media-stream delivery.  However,\
    \ when\n   it comes to mitigation of security threats, a threat depending on the\n\
    \   media-stream delivery may in fact be mitigated by a mechanism in the\n   signaling\
    \ protocol.\n   There are several chapters and an appendix in this document that\n\
    \   define security solutions for the protocol.  These sections will be\n   referenced\
    \ when discussing the threats below.  However, the reader\n   should take special\
    \ notice of the Security Framework (Section 19) and\n   the specification of how\
    \ to use SRTP and its key-management\n   (Appendix C.1.4) to achieve certain aspects\
    \ of the media security.\n"
- title: 21.1.  Signaling Protocol Threats
  contents:
  - "21.1.  Signaling Protocol Threats\n   This section focuses on issues related\
    \ to the signaling protocol.\n   Because of the similarity in syntax and usage\
    \ between RTSP servers\n   and HTTP servers, the security considerations outlined\
    \ in [RFC7230],\n   [RFC7231], [RFC7232], [RFC7233], [RFC7234], and [RFC7235]\
    \ apply as\n   well.\n   Specifically, please note the following:\n   Abuse of\
    \ Server Log Information:  A server is in the position to save\n         personal\
    \ data about a user's requests that might identify their\n         media consumption\
    \ patterns or subjects of interest.  This\n         information is clearly confidential\
    \ in nature, and its handling\n         can be constrained by law in certain countries.\
    \  Log\n         information needs to be securely stored and appropriate\n   \
    \      guidelines followed for its analysis.  See Section 9.8 of\n         [RFC7230]\
    \ for additional guidelines.\n   Transfer of Sensitive Information:  There is\
    \ no reason to believe\n         that information transferred in RTSP message,\
    \ such as the URI\n         and the content of headers, especially the Server,\
    \ Via,\n         Referrer, and From headers, may be any less sensitive than when\n\
    \         used in HTTP.  Therefore, all of the precautions regarding the\n   \
    \      protection of data privacy and user privacy apply to\n         implementers\
    \ of RTSP clients, servers, and proxies.  See\n         Sections 9.3-9.6 of [RFC7231]\
    \ for further details.\n         The RTSP methods defined in this document are\
    \ primarily used to\n         establish and control the delivery of the media\
    \ data\n         represented by the URI; thus, the RTSP message bodies are\n \
    \        generally less sensitive than the ones in HTTP.  Where HTTP\n       \
    \  bodies could contain, for example, your medical records, in\n         RTSP,\
    \ the sensitive video of your medical operation would be in\n         the media\
    \ stream over the media-transport protocol, not in the\n         RTSP message.\
    \  Still, one has to take note of what potential\n         sensitive information\
    \ is included in RTSP.  The protection of\n         the media data is separate,\
    \ can be applied directly between\n         client and server, and is dependent\
    \ on the media-transport\n         protocol in use.  See Section 21.2 for further\
    \ discussion.\n         This possibility for separation of security between media-\n\
    \         resource content and the signaling protocol mitigates the risk\n   \
    \      of exposing the media content when using hop-by-hop security\n        \
    \ for RTSP signaling using proxies (Section 19.3).\n   Attacks Based On File and\
    \ Path Names:  Though RTSP URIs are opaque\n         handles that do not necessarily\
    \ have file-system semantics, it\n         is anticipated that many implementations\
    \ will translate\n         portions of the Request-URIs directly to file-system\
    \ calls.  In\n         such cases, file systems SHOULD follow the precautions\
    \ outlined\n         in Section 9.1 of [RFC7231], such as checking for \"..\"\
    \ in path\n         components.\n   Personal Information:  RTSP clients are often\
    \ privy to the same\n         information that HTTP clients are (username, location,\
    \ etc.)\n         and thus should be equally sensitive.  See Section 9.8 of\n\
    \         [RFC7230], Sections 9.3-9.7 of [RFC7231], and Section 8 of\n       \
    \  [RFC7234] for further recommendations.\n   Privacy Issues Connected to Accept\
    \ Headers:  Since similar usages of\n         the \"Accept\" headers exist in\
    \ RTSP as in HTTP, the same caveats\n         outlined in Section 9.4 of [RFC7231]\
    \ with regard to their use\n         should be followed.\n   Establishing Authority:\
    \  RTSP shares with HTTP the question of how a\n         client communicates with\
    \ the authoritative source for media\n         streams (Section 9.1 of [RFC7230]).\
    \  The used DNS servers, the\n         security of the communication, and any\
    \ possibility of a man in\n         the middle, and the trust in any RTSP proxies\
    \ all affect the\n         possibility that a client has received a non-authoritative\n\
    \         response to a request.  Ensuring that a client receives an\n       \
    \  authoritative response is challenging, although using the\n         secure\
    \ communication for RTSP signaling (rtsps) simplifies it\n         significantly\
    \ as the server can provide a hostname identity\n         assertion in the TLS\
    \ handshake.\n   Location Headers and Spoofing:  If a single server supports multiple\n\
    \         organizations that do not trust each another, then it MUST\n       \
    \  check the values of the Content-Location header fields in\n         responses\
    \ that are generated under control of said\n         organizations to make sure\
    \ that they do not attempt to\n         invalidate resources over which they have\
    \ no authority (see\n         Section 15.4 of [RFC2616]).\n   In addition to the\
    \ recommendations in the current HTTP specifications\n   ([RFC7230], [RFC7231],\
    \ [RFC7232], [RFC7233], [RFC7234], and [RFC7235]\n   as of this writing) and also\
    \ those of the previous relevant RFCs\n   [RFC2068] [RFC2616], future HTTP specifications\
    \ may provide\n   additional guidance on security issues.\n   The following are\
    \ added considerations for RTSP implementations.\n   Session Hijacking:  Since\
    \ there is no or little relation between a\n         transport-layer connection\
    \ and an RTSP session, it is possible\n         for a malicious client to issue\
    \ requests with random session\n         identifiers that could affect other clients\
    \ of an unsuspecting\n         server.  To mitigate this, the server SHALL use\
    \ a large, random\n         and non-sequential session identifier to minimize\
    \ the\n         possibility of this kind of attack.  However, unless the RTSP\n\
    \         signaling is always confidentiality protected, e.g., using TLS,\n  \
    \       an on-path attacker will be able to hijack a session.  Another\n     \
    \    choice for preventing session hijacking is to use client\n         authentication\
    \ and only allow the authenticated client creating\n         the session to access\
    \ that session.\n   Authentication:  Servers SHOULD implement both basic and Digest\n\
    \         [RFC2617] authentication.  In environments requiring tighter\n     \
    \    security for the control messages, the transport-layer\n         mechanism\
    \ TLS [RFC5246] SHOULD be used.\n   Suspicious Behavior:  Upon detecting instances\
    \ of behavior that is\n         deemed a security risk, RTSP servers SHOULD return\
    \ error code\n         403 (Forbidden).  RTSP servers SHOULD also be aware of\
    \ attempts\n         to probe the server for weaknesses and entry points and MAY\n\
    \         arbitrarily disconnect and ignore further requests from clients\n  \
    \       that are deemed to be in violation of local security policy.\n   TLS through\
    \ Proxies:  If one uses the possibility to connect TLS in\n         multiple legs\
    \ (Section 19.3), one really needs to be aware of\n         the trust model. \
    \ This procedure requires trust in all proxies\n         part of the path to the\
    \ server.  The proxies one connects\n         through are identified, assuming\
    \ the proxies so far connected\n         through are well behaved and fulfilling\
    \ the trust.  The\n         accepted proxies are men in the middle and have access\
    \ to all\n         that goes on over the TLS connection.  Thus, it is important\
    \ to\n         consider if that trust model is acceptable in the actual\n    \
    \     application.  Further discussion of the actual trust model is\n        \
    \ in Section 19.3.  It is important to note what difference in\n         security\
    \ properties, if any, may exist with the used media-\n         transport protocol\
    \ and its security mechanism.  Using SRTP and\n         the MIKEY-based key-establishment\
    \ defined in Appendix C.1.4.1\n         enables media key-establishment to be\
    \ done end-to-end without\n         revealing the keys to the proxies.\n   Resource\
    \ Exhaustion:  As RTSP is a stateful protocol and establishes\n         resource\
    \ usage on the server, there is a clear possibility to\n         attack the server\
    \ by trying to overbook these resources to\n         perform a DoS attack.  This\
    \ attack can be both against ongoing\n         sessions and to prevent others\
    \ from establishing sessions.\n         RTSP agents will need to have mechanisms\
    \ to prevent single\n         peers from consuming extensive amounts of resources.\
    \  The\n         methods for guarding against this are varied and depend on the\n\
    \         agent's role and capabilities and policies.  Each\n         implementation\
    \ has to carefully consider its methods and\n         policies to mitigate this\
    \ threat.  There are recommendations\n         regarding the handling of connections\
    \ in Section 10.7.\n   The above threats and considerations have resulted in a\
    \ set of\n   security functions and mechanisms built into or used by the protocol.\n\
    \   The signaling protocol relies on two security features defined in the\n  \
    \ Security Framework (Section 19): namely client authentication using\n   HTTP\
    \ authentication and TLS-based transport protection of the\n   signaling messages.\
    \  Both of these mechanisms are required to be\n   implemented by any RTSP agent.\n\
    \   A number of different security mitigations have been designed into\n   the\
    \ protocol and will be instantiated if the specification is\n   implemented as\
    \ written, for example, by ensuring sufficient amounts\n   of entropy in the randomly\
    \ generated session identifiers when not\n   using client authentication to minimize\
    \ the risk of session\n   hijacking.  When client authentication is used, protection\
    \ against\n   hijacking will be greatly improved by scoping the accessible sessions\n\
    \   to the one this client identity has created.  Some of the above\n   threats\
    \ are such that the implementation of the RTSP functionality\n   itself needs\
    \ to consider which policy and strategy it uses to\n   mitigate them.\n"
- title: 21.2.  Media Stream Delivery Threats
  contents:
  - "21.2.  Media Stream Delivery Threats\n   The fact that RTSP establishes and controls\
    \ a media-stream delivery\n   results in a set of security issues related to the\
    \ media streams.\n   This section will attempt to analyze general threats; however,\
    \ the\n   choice of media-stream transport protocol, such as RTP, will result\n\
    \   in some differences in threats and what mechanisms exist to mitigate\n   them.\
    \  Thus, it becomes important that each specification of a new\n   media-stream\
    \ transport and delivery protocol usable by RTSP requires\n   its own security\
    \ analysis.  This section includes one for RTP.\n   The set of general threats\
    \ from or by the media-stream delivery\n   itself are:\n   Concentrated Denial-of-Service\
    \ Attack:  The protocol offers the\n      opportunity for a remote-controlled\
    \ DoS attack, where the media\n      stream is the hammer in that DoS attack.\
    \  See Section 21.2.1.\n   Media Confidentiality:  The media delivery may contain\
    \ content of any\n      type, and it is not possible, in general, to determine\
    \ how\n      sensitive this content is from a confidentiality point.  Thus, it\n\
    \      is a strong requirement that any media delivery protocol supply a\n   \
    \   method for providing confidentiality of the actual media content.\n      In\
    \ addition to the media-level confidentiality, it becomes\n      critical that\
    \ no resource identifiers used in the signaling be\n      exposed to an attacker\
    \ as they may have human-understandable names\n      or may be available to the\
    \ attacker, allowing it to determine the\n      content the user received.  Thus,\
    \ the signaling protocol must also\n      provide confidentiality protection of\
    \ any information related to\n      the media resource.\n   Media Integrity and\
    \ Authentication:  There are several reasons why an\n      attacker will be interested\
    \ in substituting the media stream sent\n      out from the RTSP server with one\
    \ of the attacker's creation or\n      selection, such as discrediting the target\
    \ and misinformation\n      about the target.  Therefore, it is important that\
    \ the media\n      protocol provide mechanisms to verify the source authentication\n\
    \      and integrity and to prevent replay attacks on the media stream.\n   Scope\
    \ of Multicast:  If RTSP is used to control the transmission of\n      media onto\
    \ a multicast network, the scope of the delivery must be\n      considered.  RTSP\
    \ supports the TTL Transport header parameter to\n      indicate this scope for\
    \ IPv4.  IPv6 has a different mechanism for\n      the scope boundary.  However,\
    \ such scope control has risks, as it\n      may be set too large and distribute\
    \ media beyond the intended\n      scope.\n   Below (Section 21.2.2) a protocol-specific\
    \ analysis of security\n   considerations for RTP-based media transport is included.\
    \  In that\n   section, the requirements on implementing security functions for\
    \ RTSP\n   agents supporting media delivery over RTP are made clear.\n"
- title: 21.2.1.  Remote DoS Attack
  contents:
  - "21.2.1.  Remote DoS Attack\n   The attacker may initiate traffic flows to one\
    \ or more IP addresses\n   by specifying them as the destination in SETUP requests.\
    \  While the\n   attacker's IP address may be known in this case, this is not\
    \ always\n   useful in the prevention of more attacks or ascertaining the\n  \
    \ attacker's identity.  Thus, an RTSP server MUST only allow client-\n   specified\
    \ destinations for RTSP-initiated traffic flows if the server\n   has ensured\
    \ that the specified destination address accepts receiving\n   media through different\
    \ security mechanisms.  Security mechanisms\n   that are acceptable in order of\
    \ increasing generality are:\n   o  Verification of the client's identity against\
    \ a database of known\n      users using RTSP authentication mechanisms (preferably\
    \ Digest\n      authentication or stronger)\n   o  A list of addresses that have\
    \ consented to be media destinations,\n      especially considering user identity\n\
    \   o  Verification based on media path\n   The server SHOULD NOT allow the destination\
    \ field to be set unless a\n   mechanism exists in the system to authorize the\
    \ request originator to\n   direct streams to the recipient.  It is preferred\
    \ that this\n   authorization be performed by the media recipient (destination)\n\
    \   itself and the credentials be passed along to the server.  However,\n   in\
    \ certain cases, such as when the recipient address is a multicast\n   group or\
    \ when the recipient is unable to communicate with the server\n   in an out-of-band\
    \ manner, this may not be possible.  In these cases,\n   the server may choose\
    \ another method such as a server-resident\n   authorization list to ensure that\
    \ the request originator has the\n   proper credentials to request stream delivery\
    \ to the recipient.\n   One solution that performs the necessary verification\
    \ of acceptance\n   of media suitable for unicast-based delivery is the NAT traversal\n\
    \   method based on Interactive Connectivity Establishment (ICE)\n   [RFC5245]\
    \ described in [RFC7825].  This mechanism uses random\n   passwords and a username\
    \ so that the probability of unintended\n   indication as a valid media destination\
    \ is very low.  In addition,\n   the server includes in its Session Traversal\
    \ Utilities for NAT (STUN)\n   [RFC5389] requests a cookie (consisting of random\
    \ material) that the\n   destination echoes back; thus, the solution also safeguards\
    \ against\n   having an off-path attacker being able to spoof the STUN checks.\n\
    \   This leaves this solution vulnerable only to on-path attackers that\n   can\
    \ see the STUN requests go to the target of attack and thus forge a\n   response.\n\
    \   For delivery to multicast addresses, there is a need for another\n   solution\
    \ that is not specified in this memo.\n"
- title: 21.2.2.  RTP Security Analysis
  contents:
  - "21.2.2.  RTP Security Analysis\n   RTP is a commonly used media-transport protocol\
    \ and has been the most\n   common choice for RTSP 1.0 implementations.  The core\
    \ RTP protocol\n   has been in use for a long time, and it has well-known security\n\
    \   properties and the RTP security consideration (Section 9 of\n   [RFC3550])\
    \ needs to be reviewed.  In perspective of the usage of RTP\n   in the context\
    \ of RTSP, the following properties should be noted:\n   Stream Additions:  RTP\
    \ has support for multiple simultaneous media\n      streams in each RTP session.\
    \  As some use cases require support\n      for non-synchronized adding and removal\
    \ of media streams and their\n      identifiers, an attacker can easily insert\
    \ additional media\n      streams into a session context that, according to protocol\
    \ design,\n      is intended to be played out.  Another threat vector is one of\
    \ DoS\n      by exhausting the resources of the RTP session receiver, for\n  \
    \    example, by using a large number of SSRC identifiers\n      simultaneously.\
    \  The strong mitigation of this is to ensure that\n      one cryptographically\
    \ authenticates any incoming packet flow to\n      the RTP session.  Weak mitigations\
    \ like blocking additional media\n      streams in session contexts easily lead\
    \ to a DoS vulnerability in\n      addition to preventing certain RTP extensions\
    \ or use cases that\n      rely on multiple media streams, such as RTP retransmission\n\
    \      [RFC4588] to function.\n   Forged Feedback:  The built-in RTCP also offers\
    \ a large attack\n      surface for a couple of different types of attacks.  One\
    \ venue is\n      to send RTCP feedback to the media sender indicating large amounts\n\
    \      of packet loss and thus trigger a media bitrate adaptation\n      response\
    \ from the sender resulting in lowered media quality and\n      potentially a\
    \ shutdown of the media stream.  Another attack is to\n      perform a resource-exhaustion\
    \ attack on the receiver by using many\n      SSRC identifiers to create large\
    \ state tables and increase the\n      RTCP-related processing demands.\n   RTP/RTCP\
    \ Extensions:  RTP and RTCP extensions generally provide\n      additional and\
    \ sometimes extremely powerful tools for DoS attacks\n      or service disruption.\
    \  For example, the Code Control Message\n      [RFC5104] RTCP extensions enables\
    \ both the lock down of the\n      bitrate to low values and disruption of video\
    \ quality by\n      requesting intra-frames.\n   Taking into account the above\
    \ general discussion in Section 21.2 and\n   the RTP-specific discussion in this\
    \ section, it is clear that it is\n   necessary that a strong security mechanism\
    \ be supported to protect\n   RTP.  Therefore, this specification has the following\
    \ requirements on\n   RTP security functions for all RTSP agents that handle media\
    \ streams\n   and where media-stream transport is completed using RTP.\n   RTSP\
    \ agents supporting RTP MUST implement Secure RTP (SRTP) [RFC3711]\n   and, thus,\
    \ SAVP.  In addition, SAVPF [RFC5124] MUST also be supported\n   if AVPF is implemented.\
    \  This specification requires no additional\n   cryptographic transforms or configuration\
    \ values beyond those\n   specified as mandatory to implement in RFC 3711, i.e.,\
    \ AES-CM and\n   HMAC-SHA1.  The default key-management mechanism that MUST be\n\
    \   implemented is the one defined in MIKEY Key Establishment\n   (Appendix C.1.4.1).\
    \  The MIKEY implementation MUST implement the\n   necessary functions for MIKEY-RSA-R\
    \ mode [RFC4738] and the SRTP\n   parameter negotiation necessary to negotiate\
    \ the supported SRTP\n   transforms and parameters.\n"
- title: 22.  IANA Considerations
  contents:
  - "22.  IANA Considerations\n   This section describes a number of registries for\
    \ RTSP 2.0 that have\n   been established and are maintained by IANA.  These registries\
    \ are\n   separate from any registries existing for RTSP 1.0.  For each\n   registry,\
    \ there is a description of the required content, the\n   registration procedures,\
    \ and the entries that this document\n   registers.  For more information on extending\
    \ RTSP, see Section 2.7.\n   In addition, this document registers three SDP attributes.\n\
    \   Registries or entries in registries that have been made for RTSP 1.0\n   are\
    \ not moved to RTSP 2.0: the registries and entries of RTSP 1.0 and\n   RTSP 2.0\
    \ are independent.  If any registry or entry in a registry is\n   also required\
    \ in RTSP 2.0, it MUST follow the procedure defined below\n   to allocate the\
    \ registry or entry in a registry.\n   The sections describing how to register\
    \ an item use some of the\n   registration policies described in [RFC5226] --\
    \ namely, \"First Come\n   First Served\", \"Expert Review\", \"Specification\
    \ Required\", and\n   \"Standards Action\".\n   In case a registry requires a\
    \ contact person, the authors (with\n   Magnus Westerlund <magnus.westerlund@ericsson.com>\
    \ as primary) are\n   the contact persons for any entries created by this document.\n\
    \   IANA will request the following information for any registration\n   request:\n\
    \   o  A name of the item to register according to the rules specified by\n  \
    \    the intended registry\n   o  Indication of who has change control over the\
    \ feature (for\n      example, the IETF, ISO, ITU-T, other international standardization\n\
    \      bodies, a consortium, a particular company or group of companies,\n   \
    \   or an individual)\n   o  A reference to a further description, if available,\
    \ for example\n      (in decreasing order of preference), an RFC, a published\
    \ standard,\n      a published paper, a patent filing, a technical report, documented\n\
    \      source code or a computer manual\n   o  For proprietary features, contact\
    \ information (postal and email\n      address)\n"
- title: 22.1.  Feature Tags
  contents:
  - '22.1.  Feature Tags

    '
- title: 22.1.1.  Description
  contents:
  - "22.1.1.  Description\n   When a client and server try to determine what part\
    \ and functionality\n   of the RTSP specification and any future extensions that\
    \ its\n   counterpart implements, there is need for a namespace.  This registry\n\
    \   contains named entries representing certain functionality.\n   The usage of\
    \ feature tags is explained in Section 11 and\n   Section 13.1.\n"
- title: 22.1.2.  Registering New Feature Tags with IANA
  contents:
  - "22.1.2.  Registering New Feature Tags with IANA\n   The registering of feature\
    \ tags is done on a First Come, First Served\n   [RFC5226] basis.\n   The registry\
    \ entry for a feature tag has the following information:\n   o  The name of the\
    \ feature tag\n      *  If the registrant indicates that the feature is proprietary,\n\
    \         IANA should request a vendor \"prefix\" portion of the name.  The\n\
    \         name will then be the vendor prefix followed by a \".\" followed\n \
    \        by the rest of the provided feature name.\n      *  If the feature is\
    \ not proprietary, then IANA need not collect a\n         prefix for the name.\n\
    \   o  A one-paragraph description of what the feature tag represents\n   o  The\
    \ applicability (server, client, proxy, or some combination)\n   o  A reference\
    \ to a specification, if applicable\n   Feature tag names (including the vendor\
    \ prefix) may contain any non-\n   space and non-control characters.  There is\
    \ no length limit on\n   feature tags.\n   Examples for a vendor tag describing\
    \ a proprietary feature are:\n         vendorA.specfeat01\n         vendorA.specfeat02\n"
- title: 22.1.3.  Registered Entries
  contents:
  - "22.1.3.  Registered Entries\n   The following feature tags are defined in this\
    \ specification and\n   hereby registered.  The change control belongs to the\
    \ IETF.\n   play.basic:  The implementation for delivery and playback operations\n\
    \         according to the core RTSP specification, as defined in this\n     \
    \    memo.  Applies for clients, servers, and proxies.  See\n         Section\
    \ 11.1.\n   play.scale:  Support of scale operations for media playback.  Applies\n\
    \         only for servers.  See Section 18.46.\n   play.speed:  Support of the\
    \ speed functionality for media delivery.\n         Applies only for servers.\
    \  See Section 18.50.\n   setup.rtp.rtcp.mux:  Support of the RTP and RTCP multiplexing\
    \ as\n         discussed in Appendix C.1.6.4.  Applies for both client and\n \
    \        servers and any media caching proxy.\n   The IANA registry is a table\
    \ with the name, description, and\n   reference for each feature tag.\n"
- title: 22.2.  RTSP Methods
  contents:
  - '22.2.  RTSP Methods

    '
- title: 22.2.1.  Description
  contents:
  - "22.2.1.  Description\n   Methods are described in Section 13.  Extending the\
    \ protocol with new\n   methods allows for totally new functionality.\n"
- title: 22.2.2.  Registering New Methods with IANA
  contents:
  - "22.2.2.  Registering New Methods with IANA\n   A new method is registered through\
    \ a Standards Action [RFC5226]\n   because new methods may radically change the\
    \ protocol's behavior and\n   purpose.\n   A specification for a new RTSP method\
    \ consists of the following\n   items:\n   o  A method name that follows the ABNF\
    \ rules for methods.\n   o  A clear specification of what a request using the\
    \ method does and\n      what responses are expected.  In which directions the\
    \ method is\n      used: C->S, S->C, or both.  How the use of headers, if any,\n\
    \      modifies the behavior and effect of the method.\n   o  A list or table\
    \ specifying which of the IANA-registered headers\n      that are allowed to be\
    \ used with the method in the request or/and\n      response.  The list or table\
    \ SHOULD follow the format of tables in\n      Section 18.\n   o  Describe how\
    \ the method relates to network proxies.\n"
- title: 22.2.3.  Registered Entries
  contents:
  - "22.2.3.  Registered Entries\n   This specification, RFC 7826, registers 10 methods:\
    \ DESCRIBE,\n   GET_PARAMETER, OPTIONS, PAUSE, PLAY, PLAY_NOTIFY, REDIRECT, SETUP,\n\
    \   SET_PARAMETER, and TEARDOWN.  The initial table of the registry is\n   provided\
    \ below.\n   Method         Directionality           Reference\n   -----------------------------------------------------\n\
    \   DESCRIBE       C->S                     RFC 7826\n   GET_PARAMETER  C->S,\
    \ S->C               RFC 7826\n   OPTIONS        C->S, S->C               RFC\
    \ 7826\n   PAUSE          C->S                     RFC 7826\n   PLAY         \
    \  C->S                     RFC 7826\n   PLAY_NOTIFY    S->C                 \
    \    RFC 7826\n   REDIRECT       S->C                     RFC 7826\n   SETUP \
    \         C->S                     RFC 7826\n   SET_PARAMETER  C->S, S->C    \
    \           RFC 7826\n   TEARDOWN       C->S, S->C               RFC 7826\n"
- title: 22.3.  RTSP Status Codes
  contents:
  - '22.3.  RTSP Status Codes

    '
- title: 22.3.1.  Description
  contents:
  - "22.3.1.  Description\n   A status code is the three-digit number used to convey\
    \ information in\n   RTSP response messages; see Section 8.  The number space\
    \ is limited,\n   and care should be taken not to fill the space.\n"
- title: 22.3.2.  Registering New Status Codes with IANA
  contents:
  - "22.3.2.  Registering New Status Codes with IANA\n   A new status code registration\
    \ follows the policy of IETF Review\n   [RFC5226].  New RTSP functionality requiring\
    \ Status Codes should\n   first be registered in the range of x50-x99.  Only when\
    \ the range is\n   full should registrations be made in the x00-x49 range, unless\
    \ it is\n   to adopt an HTTP extension to RTSP.  This is done to enable any HTTP\n\
    \   extension to be adopted to RTSP without needing to renumber any\n   related\
    \ status codes.  A specification for a new status code must\n   include the following:\n\
    \   o  The registered number.\n   o  A description of what the status code means\
    \ and the expected\n      behavior of the sender and receiver of the code.\n"
- title: 22.3.3.  Registered Entries
  contents:
  - "22.3.3.  Registered Entries\n   RFC 7826 (this document) registers the numbered\
    \ status code defined\n   in the ABNF entry \"Status-Code\", except \"extension-code\"\
    \ (that\n   defines the syntax allowed for future extensions) in Section 20.2.2.\n"
- title: 22.4.  RTSP Headers
  contents:
  - '22.4.  RTSP Headers

    '
- title: 22.4.1.  Description
  contents:
  - "22.4.1.  Description\n   By specifying new headers, one or more methods can be\
    \ enhanced in\n   many different ways.  An unknown header will be ignored by the\n\
    \   receiving agent.  If the new header is vital for certain\n   functionality,\
    \ a feature tag for the functionality can be created and\n   demanded to be used\
    \ by the counterpart with the inclusion of a\n   Require header carrying the feature\
    \ tag.\n"
- title: 22.4.2.  Registering New Headers with IANA
  contents:
  - "22.4.2.  Registering New Headers with IANA\n   Registrations can be made following\
    \ the Expert Review policy\n   [RFC5226].  A specification is recommended to be\
    \ provided, preferably\n   an RFC or other specification from a Standards Developing\n\
    \   Organization.  The minimal information in a registration request is\n   the\
    \ header name and the contact information.\n   The expert reviewer verifies that\
    \ the registration request contains\n   the following information:\n   o  The\
    \ name of the header.\n   o  An ABNF specification of the header syntax.\n   o\
    \  A list or table specifying when the header may be used,\n      encompassing\
    \ all methods, their request or response, and the\n      direction (C->S or S->C).\n\
    \   o  How the header is to be handled by proxies.\n   o  A description of the\
    \ purpose of the header.\n"
- title: 22.4.3.  Registered Entries
  contents:
  - "22.4.3.  Registered Entries\n   All headers specified in Section 18 in RFC 7826\
    \ have been registered.\n   The registry includes the header name and reference.\n\
    \   Furthermore, the following legacy RTSP headers defined in other\n   specifications\
    \ are registered with header name, and reference\n   according to below list.\
    \  Note: these references may not fulfill all\n   of the above rules for registrations\
    \ due to their legacy status.\n   o  x-wap-profile defined in [TS-26234].  The\
    \ x-wap-profile request-\n      header contains one or more absolute URLs to the\
    \ requesting\n      agent's device-capability profile.\n   o  x-wap-profile-diff\
    \ defined in [TS-26234].  The x-wap-profile-diff\n      request-header contains\
    \ a subset of a device-capability profile.\n   o  x-wap-profile-warning defined\
    \ in [TS-26234].  The x-wap-profile-\n      warning is a response-header that\
    \ contains error codes explaining\n      to what extent the server has been able\
    \ to match the terminal\n      request in regard to device-capability profiles,\
    \ as described\n      using x-wap-profile and x-wap-profile-diff headers.\n  \
    \ o  x-predecbufsize defined in [TS-26234].  This response-header\n      provides\
    \ an RTSP agent with the TS 26.234 Annex G hypothetical\n      pre-decoder buffer\
    \ size.\n   o  x-initpredecbufperiod defined in [TS-26234].  This response-header\n\
    \      provides an RTSP agent with the TS 26.234 Annex G hypothetical\n      pre-decoder\
    \ buffering period.\n   o  x-initpostdecbufperiod defined in [TS-26234].  This\
    \ response-\n      header provides an RTSP agent with the TS 26.234 Annex G post-\n\
    \      decoder buffering period.\n   o  3gpp-videopostdecbufsize defined in [TS-26234].\
    \  This response-\n      header provides an RTSP agent with the TS 26.234 defined\
    \ post-\n      decoder buffer size usable for H.264 (AVC) video streams.\n   o\
    \  3GPP-Link-Char defined in [TS-26234].  This request-header\n      provides\
    \ the RTSP server with the RTSP client's link\n      characteristics as determined\
    \ from the radio interface.  The\n      information that can be provided are guaranteed\
    \ bitrate, maximum\n      bitrate and maximum transfer delay.\n   o  3GPP-Adaptation\
    \ defined in [TS-26234].  This general-header is\n      part of the bitrate adaptation\
    \ solution specified for the Packet-\n      switched Streaming Service (PSS).\
    \  It provides the RTSP client's\n      buffer sizes and target buffer levels\
    \ to the server, and responses\n      are used to acknowledge the support and\
    \ values.\n   o  3GPP-QoE-Metrics defined in [TS-26234].  This general-header\
    \ is\n      used by PSS RTSP agents to negotiate the quality of experience\n \
    \     metrics that a client should gather and report to the server.\n   o  3GPP-QoE-Feedback\
    \ defined in [TS-26234].  This request-header is\n      used by RTSP clients supporting\
    \ PSS to report the actual values of\n      the metrics gathered in its quality\
    \ of experience metering.\n   The use of \"x-\" is NOT RECOMMENDED, but the above\
    \ headers in the list\n   were defined prior to the clarification.\n"
- title: 22.5.  Accept-Credentials
  contents:
  - "22.5.  Accept-Credentials\n   The security framework's TLS connection mechanism\
    \ has two\n   registerable entities.\n"
- title: 22.5.1.  Accept-Credentials Policies
  contents:
  - "22.5.1.  Accept-Credentials Policies\n   This registry is for policies for an\
    \ RTSP proxy's handling and\n   verification of TLS certificates when establishing\
    \ an outbound TLS\n   connection on behalf of a client.  In Section 19.3.1, three\
    \ policies\n   for how to handle certificates are specified.  Further policies\
    \ may\n   be defined; registration is made through Standards Action [RFC5226].\n\
    \   A registration request is required to contain the following\n   information:\n\
    \   o  Name of the policy.\n   o  Text that describes how the policy works for\
    \ handling the\n      certificates.\n   o  A contact person.\n   This specification\
    \ registers the following values:\n   Any:  A policy requiring the proxy to accept\
    \ any received\n         certificate.\n   Proxy:  A policy where the proxy applies\
    \ its own policies to\n         determine which certificates are accepted.\n \
    \  User: A policy where the certificate is required to be forwarded down\n   \
    \      the proxy chain to the client, thus allowing the user to\n         decided\
    \ to accept or refuse a certificate.\n"
- title: 22.5.2.  Accept-Credentials Hash Algorithms
  contents:
  - "22.5.2.  Accept-Credentials Hash Algorithms\n   The Accept-Credentials header\
    \ (see Section 18.2) allows for the usage\n   of other algorithms for hashing\
    \ the DER records of accepted entities.\n   The registration of any future algorithm\
    \ is expected to be extremely\n   rare and could also cause interoperability problems.\
    \  Therefore, the\n   bar for registering new algorithms is intentionally placed\
    \ high.\n   Any registration of a new hash algorithm requires Standards Action\n\
    \   [RFC5226].  The registration needs to fulfill the following\n   requirement:\n\
    \   o  The algorithms identifier meeting the \"token\" ABNF requirement.\n   o\
    \  Provide a definition of the algorithm.\n   The registered value is:\n   Hash\
    \ Alg. ID   Reference\n   ------------------------\n   sha-256        RFC 7826\n"
- title: 22.6.  Cache-Control Cache Directive Extensions
  contents:
  - "22.6.  Cache-Control Cache Directive Extensions\n   There exist a number of cache\
    \ directives that can be sent in the\n   Cache-Control header.  A registry for\
    \ these cache directives has been\n   established by IANA.  New registrations\
    \ in this registry require\n   Standards Action or IESG Approval [RFC5226].  A\
    \ registration request\n   needs to contain the following information.\n   o \
    \ The name of the cache directive.\n   o  A definition of the parameter value,\
    \ if any is allowed.\n   o  The specification if it is a request or response directive.\n\
    \   o  Text that explains how the cache directive is used for RTSP-\n      controlled\
    \ media streams.\n   o  A contact person.\n   This specification registers the\
    \ following values:\n      no-cache:\n      public:\n      private:\n      no-transform:\n\
    \      only-if-cached:\n      max-stale:\n      min-fresh:\n      must-revalidate:\n\
    \      proxy-revalidate:\n      max-age:\n   The registry contains the name of\
    \ the directive and the reference.\n"
- title: 22.7.  Media Properties
  contents:
  - '22.7.  Media Properties

    '
- title: 22.7.1.  Description
  contents:
  - "22.7.1.  Description\n   The media streams being controlled by RTSP can have\
    \ many different\n   properties.  The media properties required to cover the use\
    \ cases\n   that were in mind when writing the specification are defined.\n  \
    \ However, it can be expected that further innovation will result in\n   new use\
    \ cases or media streams with properties not covered by the\n   ones specified\
    \ here.  Thus, new media properties can be specified.\n   As new media properties\
    \ may need a substantial amount of new\n   definitions to correctly specify behavior\
    \ for this property, the bar\n   is intended to be high.\n"
- title: 22.7.2.  Registration Rules
  contents:
  - "22.7.2.  Registration Rules\n   Registering a new media property is done following\
    \ the Specification\n   Required policy [RFC5226].  The expert reviewer verifies\
    \ that a\n   registration request fulfills the following requirements.\n   o \
    \ An ABNF definition of the media property value name that meets\n      \"media-prop-ext\"\
    \ definition is included.\n   o  A definition of which media property group it\
    \ belongs to or define\n      a new group is included.\n   o  A description of\
    \ all changes to the behavior of RTSP as result of\n      these changes is included.\n\
    \   o  A contact person for the registration is listed.\n"
- title: 22.7.3.  Registered Values
  contents:
  - "22.7.3.  Registered Values\n   This specification registers the ten values listed\
    \ in Section 18.29.\n   The registry contains the property group, the name of\
    \ the media\n   property, and the reference.\n"
- title: 22.8.  Notify-Reason Values
  contents:
  - '22.8.  Notify-Reason Values

    '
- title: 22.8.1.  Description
  contents:
  - "22.8.1.  Description\n   Notify-Reason values are used to indicate the reason\
    \ the notification\n   was sent.  Each reason has its associated rules on what\
    \ headers and\n   information may or must be included in the notification.  New\n\
    \   notification behaviors need to be specified to enable interoperable\n   usage;\
    \ thus, a specification of each new value is required.\n"
- title: 22.8.2.  Registration Rules
  contents:
  - "22.8.2.  Registration Rules\n   Registrations for new Notify-Reason values follow\
    \ the Specification\n   Required policy [RFC5226].  The expert reviewer verifies\
    \ that the\n   request fulfills the following requirements:\n   o  An ABNF definition\
    \ of the Notify-Reason value name that meets\n      \"Notify-Reason-extension\"\
    \ definition is included.\n   o  A description of which headers shall be included\
    \ in the request\n      and response, when it should be sent, and any effect it\
    \ has on the\n      server client state is made clear.\n   o  A contact person\
    \ for the registration is listed.\n"
- title: 22.8.3.  Registered Values
  contents:
  - "22.8.3.  Registered Values\n   This specification registers three values defined\
    \ in the Notify-Reas-\n   val ABNF, Section 20.2.3:\n   end-of-stream:  This Notify-Reason\
    \ value indicates the end of a media\n      stream.\n   media-properties-update:\
    \  This Notify-Reason value allows the server\n      to indicate that the properties\
    \ of the media have changed during\n      the playout.\n   scale-change:  This\
    \ Notify-Reason value allows the server to notify\n      the client about a change\
    \ in the scale of the media.\n   The registry contains the name, description,\
    \ and reference.\n"
- title: 22.9.  Range Header Formats
  contents:
  - '22.9.  Range Header Formats

    '
- title: 22.9.1.  Description
  contents:
  - "22.9.1.  Description\n   The Range header (Section 18.40) allows for different\
    \ range formats.\n   These range formats also need an identifier to be used in\
    \ the Accept-\n   Ranges header (Section 18.5).  New range formats may be registered,\n\
    \   but moderation should be applied as it makes interoperability more\n   difficult.\n"
- title: 22.9.2.  Registration Rules
  contents:
  - "22.9.2.  Registration Rules\n   A registration follows the Specification Required\
    \ policy [RFC5226].\n   The expert reviewer verifies that the request fulfills\
    \ the following\n   requirements:\n   o  An ABNF definition of the range format\
    \ that fulfills the \"range-\n      ext\" definition is included.\n   o  The range\
    \ format identifier used in Accept-Ranges header according\n      to the \"extension-format\"\
    \ definition is defined.\n   o  Rules for how one handles the range when using\
    \ a negative Scale\n      are included.\n   o  A contact person for the registration\
    \ is listed.\n"
- title: 22.9.3.  Registered Values
  contents:
  - "22.9.3.  Registered Values\n   The registry contains the Range header format\
    \ identifier, the name of\n   the range format, and the reference.  This specification\
    \ registers\n   the following values.\n   npt:  Normal Play Time\n   clock:  UTC\
    \ Absolute Time format\n   smpte:  SMPTE Timestamps\n   smpte-30-drop:  SMPTE\
    \ Timestamps 29.97 Frames/sec (30 Hz with Drop)\n   smpte-25:  SMPTE Timestamps\
    \ 25 Frames/sec\n"
- title: 22.10.  Terminate-Reason Header
  contents:
  - "22.10.  Terminate-Reason Header\n   The Terminate-Reason header (Section 18.52)\
    \ has two registries for\n   extensions.\n"
- title: 22.10.1.  Redirect Reasons
  contents:
  - "22.10.1.  Redirect Reasons\n   This registry contains reasons for session termination\
    \ that can be\n   included in a Terminate-Reason header (Section 18.52).  Registrations\n\
    \   follow the Expert Review policy [RFC5226].  The expert reviewer\n   verifies\
    \ that the registration request contains the following\n   information:\n   o\
    \  That the value follows the Terminate-Reason ABNF, i.e., be a\n      token.\n\
    \   o  That the specification provide a definition of what procedures are\n  \
    \    to be followed when a client receives this redirect reason.\n   o  A contact\
    \ person\n   This specification registers three values:\n   o  Session-Timeout\n\
    \   o  Server-Admin\n   o  Internal-Error\n   The registry contains the name of\
    \ the Redirect Reason and the\n   reference.\n"
- title: 22.10.2.  Terminate-Reason Header Parameters
  contents:
  - "22.10.2.  Terminate-Reason Header Parameters\n   This registry contains parameters\
    \ that may be included in the\n   Terminate-Reason header (Section 18.52) in addition\
    \ to a reason.\n   Registrations are made under the Specification Required policy\n\
    \   [RFC5226].  The expert reviewer verifies that the registration\n   request\
    \ contains the following:\n   o  A parameter name.\n   o  A parameter following\
    \ the syntax allowed by the RTSP 2.0\n      specification.\n   o  A reference\
    \ to the specification.\n   o  A contact person.\n   This specification registers:\n\
    \   o  time\n   o  user-msg\n   The registry contains the name of the Terminate\
    \ Reason and the\n   reference.\n"
- title: 22.11.  RTP-Info Header Parameters
  contents:
  - '22.11.  RTP-Info Header Parameters

    '
- title: 22.11.1.  Description
  contents:
  - "22.11.1.  Description\n   The RTP-Info header (Section 18.45) carries one or\
    \ more parameter\n   value pairs with information about a particular point in\
    \ the RTP\n   stream.  RTP extensions or new usages may need new types of\n  \
    \ information.  As RTP information that could be needed is likely to be\n   generic\
    \ enough, and to maximize the interoperability, new\n   registration is made under\
    \ the Specification Required policy.\n"
- title: 22.11.2.  Registration Rules
  contents:
  - "22.11.2.  Registration Rules\n   Registrations for new RTP-Info values follow\
    \ the policy of\n   Specification Required [RFC5226].  The expert reviewer verifies\
    \ that\n   the registration request contains the following information.\n   o\
    \  An ABNF definition that meets the \"generic-param\" definition.\n   o  A reference\
    \ to the specification.\n   o  A contact person for the registration.\n"
- title: 22.11.3.  Registered Values
  contents:
  - "22.11.3.  Registered Values\n   This specification registers the following parameter\
    \ value pairs:\n   o  url\n   o  ssrc\n   o  seq\n   o  rtptime\n   The registry\
    \ contains the name of the parameter and the reference.\n"
- title: 22.12.  Seek-Style Policies
  contents:
  - '22.12.  Seek-Style Policies

    '
- title: 22.12.1.  Description
  contents:
  - "22.12.1.  Description\n   Seek-Style policy defines how the RTSP agent seeks\
    \ in media content\n   when given a position within the media content.  New seek\
    \ policies\n   may be registered; however, a large number of these will complicate\n\
    \   implementation substantially.  The impact of unknown policies is that\n  \
    \ the server will not honor the unknown and will use the server default\n   policy\
    \ instead.\n"
- title: 22.12.2.  Registration Rules
  contents:
  - "22.12.2.  Registration Rules\n   Registrations of new Seek-Style policies follow\
    \ the Specification\n   Required policy [RFC5226].  The expert reviewer verifies\
    \ that the\n   registration request fulfills the following requirements:\n   o\
    \  Has an ABNF definition of the Seek-Style policy name that meets\n      \"Seek-S-value-ext\"\
    \ definition.\n   o  Includes a short description.\n   o  Lists a contact person\
    \ for the registration.\n   o  Includes a description of which headers shall be\
    \ included in the\n      request and response, when it should be sent, and any\
    \ affect it\n      has on the server-client state.\n"
- title: 22.12.3.  Registered Values
  contents:
  - "22.12.3.  Registered Values\n   This specification registers four values (Name\
    \ - Short Description):\n   o  RAP - Using the closest Random Access Point prior\
    \ to or at the\n      requested start position.\n   o  CoRAP - Conditional Random\
    \ Access Point is like RAP, but only if\n      the RAP is closer prior to the\
    \ requested start position than\n      current pause point.\n   o  First-Prior\
    \ - The first-prior policy will start delivery with the\n      media unit that\
    \ has a playout time first prior to the requested\n      start position.\n   o\
    \  Next - The next media units after the provided start position.\n   The registry\
    \ contains the name of the Seek-Style policy, the\n   description, and the reference.\n"
- title: 22.13.  Transport Header Registries
  contents:
  - "22.13.  Transport Header Registries\n   The transport header (Section 18.54)\
    \ contains a number of parameters\n   that have possibilities for future extensions.\
    \  Therefore, registries\n   for these are defined below.\n"
- title: 22.13.1.  Transport Protocol Identifier
  contents:
  - "22.13.1.  Transport Protocol Identifier\n   A Transport Protocol specification\
    \ consists of a transport protocol\n   identifier, representing some combination\
    \ of transport protocols, and\n   any number of transport header parameters required\
    \ or optional to use\n   with the identified protocol specification.  This registry\
    \ contains\n   the identifiers used by registered transport protocol identifiers.\n\
    \   A registration for the parameter transport protocol identifier\n   follows\
    \ the Specification Required policy [RFC5226].  The expert\n   reviewer verifies\
    \ that the registration request fulfills the\n   following requirements:\n   o\
    \  A contact person or organization with address and email.\n   o  A value definition\
    \ that follows the ABNF syntax definition of\n      \"transport-id\" Section 20.2.3.\n\
    \   o  A descriptive text that explains how the registered values are\n      used\
    \ in RTSP, which underlying transport protocols are used, and\n      any required\
    \ Transport header parameters.\n   The registry contains the protocol ID string\
    \ and the reference.\n   This specification registers the following values:\n\
    \   RTP/AVP:  Use of the RTP [RFC3550] protocol for media transport in\n     \
    \    combination with the \"RTP Profile for Audio and Video\n         Conferences\
    \ with Minimal Control\" [RFC3551] over UDP.  The\n         usage is explained\
    \ in RFC 7826, Appendix C.1.\n   RTP/AVP/UDP:  the same as RTP/AVP.\n   RTP/AVPF:\
    \  Use of the RTP [RFC3550] protocol for media transport in\n         combination\
    \ with the \"Extended RTP Profile for RTCP-based\n         Feedback (RTP/AVPF)\"\
    \ [RFC4585] over UDP.  The usage is\n         explained in RFC 7826, Appendix\
    \ C.1.\n   RTP/AVPF/UDP:  the same as RTP/AVPF.\n   RTP/SAVP:  Use of the RTP\
    \ [RFC3550] protocol for media transport in\n         combination with the \"\
    The Secure Real-time Transport Protocol\n         (SRTP)\" [RFC3711] over UDP.\
    \  The usage is explained in RFC\n         7826, Appendix C.1.\n   RTP/SAVP/UDP:\
    \  the same as RTP/SAVP.\n   RTP/SAVPF:  Use of the RTP [RFC3550] protocol for\
    \ media transport in\n         combination with the \"Extended Secure RTP Profile\
    \ for Real-time\n         Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)\"\
    \n         [RFC5124] over UDP.  The usage is explained in RFC 7826,\n        \
    \ Appendix C.1.\n   RTP/SAVPF/UDP:  the same as RTP/SAVPF.\n   RTP/AVP/TCP:  Use\
    \ of the RTP [RFC3550] protocol for media transport\n         in combination with\
    \ the \"RTP profile for audio and video\n         conferences with minimal control\"\
    \ [RFC3551] over TCP.  The\n         usage is explained in RFC 7826, Appendix\
    \ C.2.2.\n   RTP/AVPF/TCP:  Use of the RTP [RFC3550] protocol for media transport\n\
    \         in combination with the \"Extended RTP Profile for Real-time\n     \
    \    Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)\"\n         [RFC4585]\
    \ over TCP.  The usage is explained in RFC 7826,\n         Appendix C.2.2.\n \
    \  RTP/SAVP/TCP:  Use of the RTP [RFC3550] protocol for media transport\n    \
    \     in combination with the \"The Secure Real-time Transport\n         Protocol\
    \ (SRTP)\" [RFC3711] over TCP.  The usage is explained in\n         RFC 7826,\
    \ Appendix C.2.2.\n   RTP/SAVPF/TCP:  Use of the RTP [RFC3550] protocol for media\
    \ transport\n         in combination with the \"Extended Secure RTP Profile for\
    \ Real-\n         time Transport Control Protocol (RTCP)-Based Feedback (RTP/\n\
    \         SAVPF)\" [RFC5124] over TCP.  The usage is explained in RFC\n      \
    \   7826, Appendix C.2.2.\n"
- title: 22.13.2.  Transport Modes
  contents:
  - "22.13.2.  Transport Modes\n   The Transport Mode is a Transport header (Section\
    \ 18.54) parameter.\n   It is used to identify the general mode of media transport.\
    \  The PLAY\n   value registered defines a PLAYBACK mode, where media flows from\n\
    \   server to client.\n   A registration for the transport parameter mode follows\
    \ the Standards\n   Action policy [RFC5226].  The registration request needs to\
    \ meet the\n   following requirements:\n   o  A value definition that follows\
    \ the ABNF \"token\" definition\n      Section 20.2.3.\n   o  Text that explains\
    \ how the registered value is used in RTSP.\n   This specification registers one\
    \ value:\n   PLAY: See RFC 7826.\n   The registry contains the transport mode\
    \ value and the reference.\n"
- title: 22.13.3.  Transport Parameters
  contents:
  - "22.13.3.  Transport Parameters\n   Transport Parameters are different parameters\
    \ used in a Transport\n   header's transport specification (Section 18.54) to\
    \ provide\n   additional information required beyond the transport protocol\n\
    \   identifier to establish a functioning transport.\n   A registration for parameters\
    \ that may be included in the Transport\n   header follows the Specification Required\
    \ policy [RFC5226].  The\n   expert reviewer verifies that the registration request\
    \ fulfills the\n   following requirements:\n   o  A Transport Parameter Name following\
    \ the \"token\" ABNF definition.\n   o  A value definition, if the parameter takes\
    \ a value, that follows\n      the ABNF definition of \"trn-par-value\" Section\
    \ 20.2.3.\n   o  Text that explains how the registered value is used in RTSP.\n\
    \   This specification registers all the transport parameters defined in\n   Section\
    \ 18.54.  This is a copy of that list:\n   o  unicast\n   o  multicast\n   o \
    \ interleaved\n   o  ttl\n   o  layers\n   o  ssrc\n   o  mode\n   o  dest_addr\n\
    \   o  src_addr\n   o  setup\n   o  connection\n   o  RTCP-mux\n   o  MIKEY\n\
    \   The registry contains the transport parameter name and the reference.\n"
- title: 22.14.  URI Schemes
  contents:
  - "22.14.  URI Schemes\n   This specification updates two URI schemes: one previously\n\
    \   registered, \"rtsp\", and one missing in the registry, \"rtspu\"\n   (previously\
    \ only defined in RTSP 1.0 [RFC2326]).  One new URI scheme,\n   \"rtsps\", is\
    \ also registered.  These URI schemes are registered in an\n   existing registry\
    \ (\"Uniform Resource Identifier (URI) Schemes\") not\n   created by this memo.\
    \  Registrations follow [RFC7595].\n"
- title: 22.14.1.  The "rtsp" URI Scheme
  contents:
  - "22.14.1.  The \"rtsp\" URI Scheme\n   URI scheme name:  rtsp\n   Status:  Permanent\n\
    \   URI scheme syntax:  See Section 20.2.1 of RFC 7826.\n   URI scheme semantics:\
    \  The rtsp scheme is used to indicate resources\n         accessible through\
    \ the usage of the Real-Time Streaming\n         Protocol (RTSP).  RTSP allows\
    \ different operations on the\n         resource identified by the URI, but the\
    \ primary purpose is the\n         streaming delivery of the resource to a client.\
    \  However, the\n         operations that are currently defined are DESCRIBE,\n\
    \         GET_PARAMETER, OPTIONS, PLAY, PLAY_NOTIFY, PAUSE, REDIRECT,\n      \
    \   SETUP, SET_PARAMETER, and TEARDOWN.\n   Encoding considerations:  IRIs in\
    \ this scheme are defined and need to\n         be encoded as RTSP URIs when used\
    \ within RTSP.  That encoding\n         is done according to RFC 3987.\n   Applications/protocols\
    \ that use this URI scheme name:  RTSP 1.0 (RFC\n         2326), RTSP 2.0 (RFC\
    \ 7826).\n   Interoperability considerations:  The extensions in the URI syntax\n\
    \         performed between RTSP 1.0 and 2.0 can create interoperability\n   \
    \      issues.  The changes are:\n            Support for IPv6 literals in the\
    \ host part and future IP\n            literals through a mechanism as defined\
    \ in RFC 3986.\n            A new relative format to use in RTSP elements that\
    \ is not\n            required to start with \"/\".\n         The above changes\
    \ should have no impact on interoperability as\n         discussed in detail in\
    \ Section 4.2 of RFC 7826.\n   Security considerations:  All the security threats\
    \ identified in\n         Section 7 of RFC 3986 also apply to this scheme.  They\
    \ need to\n         be reviewed and considered in any implementation utilizing\
    \ this\n         scheme.\n   Contact:  Magnus Westerlund, magnus.westerlund@ericsson.com\n\
    \   Author/Change controller:  IETF\n   References:  RFC 2326, RFC 3986, RFC 3987,\
    \ and RFC 7826\n"
- title: 22.14.2.  The "rtsps" URI Scheme
  contents:
  - "22.14.2.  The \"rtsps\" URI Scheme\n   URI scheme name:  rtsps\n   Status:  Permanent\n\
    \   URI scheme syntax:  See Section 20.2.1 of RFC 7826.\n   URI scheme semantics:\
    \  The rtsps scheme is used to indicate resources\n         accessible through\
    \ the usage of the Real-Time Streaming\n         Protocol (RTSP) over TLS.  RTSP\
    \ allows different operations on\n         the resource identified by the URI,\
    \ but the primary purpose is\n         the streaming delivery of the resource\
    \ to a client.  However,\n         the operations that are currently defined are\
    \ DESCRIBE,\n         GET_PARAMETER, OPTIONS, PLAY, PLAY_NOTIFY, PAUSE, REDIRECT,\n\
    \         SETUP, SET_PARAMETER, and TEARDOWN.\n   Encoding considerations:  IRIs\
    \ in this scheme are defined and need to\n         be encoded as RTSP URIs when\
    \ used within RTSP.  That encoding\n         is done according to RFC 3987.\n\
    \   Applications/protocols that use this URI scheme name:  RTSP 1.0 (RFC\n   \
    \      2326), RTSP 2.0 (RFC 7826).\n   Interoperability considerations:  The \"\
    rtsps\" scheme was never\n         officially defined for RTSP 1.0; however, it\
    \ has seen\n         widespread use in actual deployments of RTSP 1.0.  Therefore,\n\
    \         this section discusses the believed changes between the\n         unspecified\
    \ RTSP 1.0 \"rtsps\" scheme and RTSP 2.0 definition.\n         The extensions\
    \ in the URI syntax performed between RTSP 1.0 and\n         2.0 can create interoperability\
    \ issues.  The changes are:\n            Support for IPv6 literals in the host\
    \ part and future IP\n            literals through a mechanism as defined by RFC\
    \ 3986.\n            A new relative format to use in RTSP elements that is not\n\
    \            required to start with \"/\".\n         The above changes should\
    \ have no impact on interoperability as\n         discussed in detail in Section\
    \ 4.2 of RFC 7826.\n   Security considerations:  All the security threats identified\
    \ in\n         Section 7 of RFC 3986 also apply to this scheme.  They need to\n\
    \         be reviewed and considered in any implementation utilizing this\n  \
    \       scheme.\n   Contact:  Magnus Westerlund, magnus.westerlund@ericsson.com\n\
    \   Author/Change controller:  IETF\n   References:  RFC 2326, RFC 3986, RFC 3987,\
    \ and RFC 7826\n"
- title: 22.14.3.  The "rtspu" URI Scheme
  contents:
  - "22.14.3.  The \"rtspu\" URI Scheme\n   URI scheme name:  rtspu\n   Status:  Permanent\n\
    \   URI scheme syntax:  See Section 3.2 of RFC 2326.\n   URI scheme semantics:\
    \  The rtspu scheme is used to indicate resources\n         accessible through\
    \ the usage of the Real-Time Streaming\n         Protocol (RTSP) over unreliable\
    \ datagram transport.  RTSP\n         allows different operations on the resource\
    \ identified by the\n         URI, but the primary purpose is the streaming delivery\
    \ of the\n         resource to a client.  However, the operations that are\n \
    \        currently defined are DESCRIBE, GET_PARAMETER, OPTIONS,\n         REDIRECT,PLAY,\
    \ PLAY_NOTIFY, PAUSE, SETUP, SET_PARAMETER, and\n         TEARDOWN.\n   Encoding\
    \ considerations:  This scheme is not intended to be used with\n         characters\
    \ outside the US-ASCII repertoire.\n   Applications/protocols that use this URI\
    \ scheme name:  RTSP 1.0 (RFC\n         2326).\n   Interoperability considerations:\
    \  The definition of the transport\n         mechanism of RTSP over UDP has interoperability\
    \ issues.  That\n         makes the usage of this scheme problematic.\n   Security\
    \ considerations:  All the security threats identified in\n         Section 7\
    \ of RFC 3986 also apply to this scheme.  They need to\n         be reviewed and\
    \ considered in any implementation utilizing this\n         scheme.\n   Contact:\
    \  Magnus Westerlund, magnus.westerlund@ericsson.com\n   Author/Change controller:\
    \  IETF\n   References:  RFC 2326\n"
- title: 22.15.  SDP Attributes
  contents:
  - "22.15.  SDP Attributes\n   This specification defines three SDP [RFC4566] attributes\
    \ that have\n   been registered by IANA.\n   SDP Attribute (\"att-field\"):\n\
    \        Attribute name:     range\n        Long form:          Media Range Attribute\n\
    \        Type of name:       att-field\n        Type of attribute:  both session\
    \ and media level\n        Subject to charset: No\n        Purpose:          \
    \  RFC 7826\n        Reference:          RFC 2326, RFC 7826\n        Values: \
    \            See ABNF definition.\n        Attribute name:     control\n     \
    \   Long form:          RTSP control URI\n        Type of name:       att-field\n\
    \        Type of attribute:  both session and media level\n        Subject to\
    \ charset: No\n        Purpose:            RFC 7826\n        Reference:      \
    \    RFC 2326, RFC 7826\n        Values:             Absolute or Relative URIs.\n\
    \        Attribute name:     mtag\n        Long form:          Message Tag\n \
    \       Type of name:       att-field\n        Type of attribute:  both session\
    \ and media level\n        Subject to charset: No\n        Purpose:          \
    \  RFC 7826\n        Reference:          RFC 7826\n        Values:           \
    \  See ABNF definition\n"
- title: 22.16.  Media Type Registration for text/parameters
  contents:
  - "22.16.  Media Type Registration for text/parameters\n   Type name:  text\n  \
    \ Subtype name:  parameters\n   Required parameters:\n   Optional parameters:\
    \  charset: The charset parameter is applicable to\n      the encoding of the\
    \ parameter values.  The default charset is\n      UTF-8, if the 'charset' parameter\
    \ is not present.\n   Encoding considerations:  8bit\n   Security considerations:\
    \  This format may carry any type of\n      parameters.  Some can have security\
    \ requirements, like privacy,\n      confidentiality, or integrity requirements.\
    \  The format has no\n      built-in security protection.  For the usage, the\
    \ transport can be\n      protected between server and client using TLS.  However,\
    \ care must\n      be taken to consider if the proxies are also trusted with the\n\
    \      parameters in case hop-by-hop security is used.  If stored as a\n     \
    \ file in a file system, the necessary precautions need to be taken\n      in\
    \ relation to the parameter requirements including object\n      security such\
    \ as S/MIME [RFC5751].\n   Interoperability considerations:  This media type was\
    \ mentioned as a\n      fictional example in [RFC2326], but was not formally specified.\n\
    \      This has resulted in usage of this media type that may not match\n    \
    \  its formal definition.\n   Published specification:  RFC 7826, Appendix F.\n\
    \   Applications that use this media type:  Applications that use RTSP\n     \
    \ and have additional parameters they like to read and set using the\n      RTSP\
    \ GET_PARAMETER and SET_PARAMETER methods.\n   Additional information:\n   Magic\
    \ number(s):  N/A\n   File extension(s):  N/A\n   Macintosh file type code(s):\
    \  N/A\n   Person & email address to contact for further information:\n      Magnus\
    \ Westerlund (magnus.westerlund@ericsson.com)\n   Intended usage:   Common\n \
    \  Restrictions on usage:   None\n   Author:  Magnus Westerlund (magnus.westerlund@ericsson.com)\n\
    \   Change controller:  IETF\n   Addition Notes:\n"
- title: 23.  References
  contents:
  - '23.  References

    '
- title: 23.1.  Normative References
  contents:
  - "23.1.  Normative References\n   [FIPS180-4]\n              National Institute\
    \ of Standards and Technology (NIST),\n              \"Federal Information Processing\
    \ Standards Publication:\n              Secure Hash Standard (SHS)\", DOI 10.6028/NIST.FIPS.180-4,\n\
    \              August 2015, <http://nvlpubs.nist.gov/nistpubs/FIPS/\n        \
    \      NIST.FIPS.180-4.pdf>.\n   [RFC768]   Postel, J., \"User Datagram Protocol\"\
    , STD 6, RFC 768,\n              DOI 10.17487/RFC0768, August 1980,\n        \
    \      <http://www.rfc-editor.org/info/rfc768>.\n   [RFC793]   Postel, J., \"\
    Transmission Control Protocol\", STD 7,\n              RFC 793, DOI 10.17487/RFC0793,\
    \ September 1981,\n              <http://www.rfc-editor.org/info/rfc793>.\n  \
    \ [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n          \
    \    Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC2460]\
    \  Deering, S. and R. Hinden, \"Internet Protocol, Version 6\n              (IPv6)\
    \ Specification\", RFC 2460, DOI 10.17487/RFC2460,\n              December 1998,\
    \ <http://www.rfc-editor.org/info/rfc2460>.\n   [RFC2616]  Fielding, R., Gettys,\
    \ J., Mogul, J., Frystyk, H.,\n              Masinter, L., Leach, P., and T. Berners-Lee,\
    \ \"Hypertext\n              Transfer Protocol -- HTTP/1.1\", RFC 2616,\n    \
    \          DOI 10.17487/RFC2616, June 1999,\n              <http://www.rfc-editor.org/info/rfc2616>.\n\
    \   [RFC2617]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,\n  \
    \            Leach, P., Luotonen, A., and L. Stewart, \"HTTP\n              Authentication:\
    \ Basic and Digest Access Authentication\",\n              RFC 2617, DOI 10.17487/RFC2617,\
    \ June 1999,\n              <http://www.rfc-editor.org/info/rfc2617>.\n   [RFC2818]\
    \  Rescorla, E., \"HTTP Over TLS\", RFC 2818,\n              DOI 10.17487/RFC2818,\
    \ May 2000,\n              <http://www.rfc-editor.org/info/rfc2818>.\n   [RFC3550]\
    \  Schulzrinne, H., Casner, S., Frederick, R., and V.\n              Jacobson,\
    \ \"RTP: A Transport Protocol for Real-Time\n              Applications\", STD\
    \ 64, RFC 3550, DOI 10.17487/RFC3550,\n              July 2003, <http://www.rfc-editor.org/info/rfc3550>.\n\
    \   [RFC3551]  Schulzrinne, H. and S. Casner, \"RTP Profile for Audio and\n  \
    \            Video Conferences with Minimal Control\", STD 65, RFC 3551,\n   \
    \           DOI 10.17487/RFC3551, July 2003,\n              <http://www.rfc-editor.org/info/rfc3551>.\n\
    \   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n        \
    \      10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November\n           \
    \   2003, <http://www.rfc-editor.org/info/rfc3629>.\n   [RFC3711]  Baugher, M.,\
    \ McGrew, D., Naslund, M., Carrara, E., and K.\n              Norrman, \"The Secure\
    \ Real-time Transport Protocol (SRTP)\",\n              RFC 3711, DOI 10.17487/RFC3711,\
    \ March 2004,\n              <http://www.rfc-editor.org/info/rfc3711>.\n   [RFC3830]\
    \  Arkko, J., Carrara, E., Lindholm, F., Naslund, M., and K.\n              Norrman,\
    \ \"MIKEY: Multimedia Internet KEYing\", RFC 3830,\n              DOI 10.17487/RFC3830,\
    \ August 2004,\n              <http://www.rfc-editor.org/info/rfc3830>.\n   [RFC3986]\
    \  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource\
    \ Identifier (URI): Generic Syntax\", STD 66,\n              RFC 3986, DOI 10.17487/RFC3986,\
    \ January 2005,\n              <http://www.rfc-editor.org/info/rfc3986>.\n   [RFC3987]\
    \  Duerst, M. and M. Suignard, \"Internationalized Resource\n              Identifiers\
    \ (IRIs)\", RFC 3987, DOI 10.17487/RFC3987,\n              January 2005, <http://www.rfc-editor.org/info/rfc3987>.\n\
    \   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,\n             \
    \ \"Randomness Requirements for Security\", BCP 106, RFC 4086,\n             \
    \ DOI 10.17487/RFC4086, June 2005,\n              <http://www.rfc-editor.org/info/rfc4086>.\n\
    \   [RFC4291]  Hinden, R. and S. Deering, \"IP Version 6 Addressing\n        \
    \      Architecture\", RFC 4291, DOI 10.17487/RFC4291, February\n            \
    \  2006, <http://www.rfc-editor.org/info/rfc4291>.\n   [RFC7595]  Thaler, D.,\
    \ Ed., Hansen, T., and T. Hardie, \"Guidelines\n              and Registration\
    \ Procedures for URI Schemes\", BCP 35, RFC\n              7595, DOI 10.17487/RFC7595,\
    \ June 2015, <http://www.rfc-\n              editor.org/info/rfc7595>.\n   [RFC4566]\
    \  Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session\n              Description\
    \ Protocol\", RFC 4566, DOI 10.17487/RFC4566,\n              July 2006, <http://www.rfc-editor.org/info/rfc4566>.\n\
    \   [RFC4571]  Lazzaro, J., \"Framing Real-time Transport Protocol (RTP)\n   \
    \           and RTP Control Protocol (RTCP) Packets over Connection-\n       \
    \       Oriented Transport\", RFC 4571, DOI 10.17487/RFC4571, July\n         \
    \     2006, <http://www.rfc-editor.org/info/rfc4571>.\n   [RFC4585]  Ott, J.,\
    \ Wenger, S., Sato, N., Burmeister, C., and J. Rey,\n              \"Extended\
    \ RTP Profile for Real-time Transport Control\n              Protocol (RTCP)-Based\
    \ Feedback (RTP/AVPF)\", RFC 4585,\n              DOI 10.17487/RFC4585, July 2006,\n\
    \              <http://www.rfc-editor.org/info/rfc4585>.\n   [RFC4648]  Josefsson,\
    \ S., \"The Base16, Base32, and Base64 Data\n              Encodings\", RFC 4648,\
    \ DOI 10.17487/RFC4648, October 2006,\n              <http://www.rfc-editor.org/info/rfc4648>.\n\
    \   [RFC4738]  Ignjatic, D., Dondeti, L., Audet, F., and P. Lin, \"MIKEY-\n  \
    \            RSA-R: An Additional Mode of Key Distribution in\n              Multimedia\
    \ Internet KEYing (MIKEY)\", RFC 4738,\n              DOI 10.17487/RFC4738, November\
    \ 2006,\n              <http://www.rfc-editor.org/info/rfc4738>.\n   [RFC5124]\
    \  Ott, J. and E. Carrara, \"Extended Secure RTP Profile for\n              Real-time\
    \ Transport Control Protocol (RTCP)-Based Feedback\n              (RTP/SAVPF)\"\
    , RFC 5124, DOI 10.17487/RFC5124, February\n              2008, <http://www.rfc-editor.org/info/rfc5124>.\n\
    \   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n   \
    \           IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n       \
    \       DOI 10.17487/RFC5226, May 2008,\n              <http://www.rfc-editor.org/info/rfc5226>.\n\
    \   [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n \
    \             Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234,\
    \ January 2008,\n              <http://www.rfc-editor.org/info/rfc5234>.\n   [RFC5246]\
    \  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)\
    \ Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August\
    \ 2008,\n              <http://www.rfc-editor.org/info/rfc5246>.\n   [RFC5280]\
    \  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n              Housley,\
    \ R., and W. Polk, \"Internet X.509 Public Key\n              Infrastructure Certificate\
    \ and Certificate Revocation List\n              (CRL) Profile\", RFC 5280, DOI\
    \ 10.17487/RFC5280, May 2008,\n              <http://www.rfc-editor.org/info/rfc5280>.\n\
    \   [RFC5322]  Resnick, P., Ed., \"Internet Message Format\", RFC 5322,\n    \
    \          DOI 10.17487/RFC5322, October 2008,\n              <http://www.rfc-editor.org/info/rfc5322>.\n\
    \   [RFC5646]  Phillips, A., Ed. and M. Davis, Ed., \"Tags for Identifying\n \
    \             Languages\", BCP 47, RFC 5646, DOI 10.17487/RFC5646,\n         \
    \     September 2009, <http://www.rfc-editor.org/info/rfc5646>.\n   [RFC5751]\
    \  Ramsdell, B. and S. Turner, \"Secure/Multipurpose Internet\n              Mail\
    \ Extensions (S/MIME) Version 3.2 Message\n              Specification\", RFC\
    \ 5751, DOI 10.17487/RFC5751, January\n              2010, <http://www.rfc-editor.org/info/rfc5751>.\n\
    \   [RFC5761]  Perkins, C. and M. Westerlund, \"Multiplexing RTP Data and\n  \
    \            Control Packets on a Single Port\", RFC 5761,\n              DOI\
    \ 10.17487/RFC5761, April 2010,\n              <http://www.rfc-editor.org/info/rfc5761>.\n\
    \   [RFC5888]  Camarillo, G. and H. Schulzrinne, \"The Session Description\n \
    \             Protocol (SDP) Grouping Framework\", RFC 5888,\n              DOI\
    \ 10.17487/RFC5888, June 2010,\n              <http://www.rfc-editor.org/info/rfc5888>.\n\
    \   [RFC6838]  Freed, N., Klensin, J., and T. Hansen, \"Media Type\n         \
    \     Specifications and Registration Procedures\", BCP 13,\n              RFC\
    \ 6838, DOI 10.17487/RFC6838, January 2013,\n              <http://www.rfc-editor.org/info/rfc6838>.\n\
    \   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n \
    \             Protocol (HTTP/1.1): Message Syntax and Routing\",\n           \
    \   RFC 7230, DOI 10.17487/RFC7230, June 2014,\n              <http://www.rfc-editor.org/info/rfc7230>.\n\
    \   [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n \
    \             Protocol (HTTP/1.1): Semantics and Content\", RFC 7231,\n      \
    \        DOI 10.17487/RFC7231, June 2014,\n              <http://www.rfc-editor.org/info/rfc7231>.\n\
    \   [RFC7232]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n \
    \             Protocol (HTTP/1.1): Conditional Requests\", RFC 7232,\n       \
    \       DOI 10.17487/RFC7232, June 2014,\n              <http://www.rfc-editor.org/info/rfc7232>.\n\
    \   [RFC7233]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,\n     \
    \         \"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\",\n      \
    \        RFC 7233, DOI 10.17487/RFC7233, June 2014,\n              <http://www.rfc-editor.org/info/rfc7233>.\n\
    \   [RFC7234]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,\n     \
    \         Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Caching\",\n        \
    \      RFC 7234, DOI 10.17487/RFC7234, June 2014,\n              <http://www.rfc-editor.org/info/rfc7234>.\n\
    \   [RFC7235]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n \
    \             Protocol (HTTP/1.1): Authentication\", RFC 7235,\n             \
    \ DOI 10.17487/RFC7235, June 2014,\n              <http://www.rfc-editor.org/info/rfc7235>.\n\
    \   [RFC7615]  Reschke, J., \"HTTP Authentication-Info and Proxy-\n          \
    \    Authentication-Info Response Header Fields\", RFC 7615,\n              DOI\
    \ 10.17487/RFC7615, September 2015,\n              <http://www.rfc-editor.org/info/rfc7615>.\n\
    \   [RFC7616]  Shekh-Yusef, R., Ed., Ahrens, D., and S. Bremer, \"HTTP\n     \
    \         Digest Access Authentication\", RFC 7616,\n              DOI 10.17487/RFC7616,\
    \ September 2015,\n              <http://www.rfc-editor.org/info/rfc7616>.\n \
    \  [RFC7617]  Reschke, J., \"The 'Basic' HTTP Authentication Scheme\",\n     \
    \         RFC 7617, DOI 10.17487/RFC7617, September 2015,\n              <http://www.rfc-editor.org/info/rfc7617>.\n\
    \   [RFC7825]  Goldberg, J., Westerlund, M., and T. Zeng, \"A Network\n      \
    \        Address Translator (NAT) Traversal Mechanism for Media\n            \
    \  Controlled by Real-Time Streaming Protocol (RTSP)\",\n              RFC 7825,\
    \ DOI 10.17487/RFC7825, December 2016,\n              <http://www.rfc-editor.org/info/rfc7825>.\n\
    \   [RTP-CIRCUIT-BREAKERS]\n              Perkins, C. and V. Singh, \"Multimedia\
    \ Congestion Control:\n              Circuit Breakers for Unicast RTP Sessions\"\
    , Work in\n              Progress, draft-ietf-avtcore-rtp-circuit-breakers-13,\n\
    \              February 2016.\n   [SMPTE-TC] Society of Motion Picture and Television\
    \ Engineers, \"ST\n              12-1:2008 For Television -- Time and Control\
    \ Code\",\n              DOI 10.5594/SMPTE.ST12-1.2008, February 2008,\n     \
    \         <http://ieeexplore.ieee.org/servlet/\n              opac?punumber=7289818>.\n\
    \   [TS-26234] 3rd Generation Partnership Project (3GPP), \"Transparent\n    \
    \          end-to-end Packet-switched Streaming Service (PSS);\n             \
    \ Protocols and codecs\", Technical Specification 26.234,\n              Release\
    \ 13, September 2015,\n              <http://www.3gpp.org/DynaReport/26234.htm>.\n"
- title: 23.2.  Informative References
  contents:
  - "23.2.  Informative References\n   [ISO.13818-6.1995]\n              International\
    \ Organization for Standardization,\n              \"Information technology --\
    \ Generic coding of moving\n              pictures and associated audio information\
    \ - part 6:\n              Extension for DSM-CC\", ISO Draft Standard 13818-6:1998,\n\
    \              October 1998,\n              <http://www.iso.org/iso/home/store/catalogue_tc/\n\
    \              catalogue_detail.htm?csnumber=25039>.\n   [ISO.8601.2000]\n   \
    \           International Organization for Standardization, \"Data\n         \
    \     elements and interchange formats - Information interchange\n           \
    \   - Representation of dates and times\", ISO/IEC Standard\n              8601,\
    \ December 2000.\n   [RFC791]   Postel, J., \"Internet Protocol\", STD 5, RFC\
    \ 791,\n              DOI 10.17487/RFC0791, September 1981,\n              <http://www.rfc-editor.org/info/rfc791>.\n\
    \   [RFC1123]  Braden, R., Ed., \"Requirements for Internet Hosts -\n        \
    \      Application and Support\", STD 3, RFC 1123,\n              DOI 10.17487/RFC1123,\
    \ October 1989,\n              <http://www.rfc-editor.org/info/rfc1123>.\n   [RFC2068]\
    \  Fielding, R., Gettys, J., Mogul, J., Frystyk, H., and T.\n              Berners-Lee,\
    \ \"Hypertext Transfer Protocol -- HTTP/1.1\",\n              RFC 2068, DOI 10.17487/RFC2068,\
    \ January 1997,\n              <http://www.rfc-editor.org/info/rfc2068>.\n   [RFC2326]\
    \  Schulzrinne, H., Rao, A., and R. Lanphier, \"Real Time\n              Streaming\
    \ Protocol (RTSP)\", RFC 2326,\n              DOI 10.17487/RFC2326, April 1998,\n\
    \              <http://www.rfc-editor.org/info/rfc2326>.\n   [RFC2663]  Srisuresh,\
    \ P. and M. Holdrege, \"IP Network Address\n              Translator (NAT) Terminology\
    \ and Considerations\",\n              RFC 2663, DOI 10.17487/RFC2663, August\
    \ 1999,\n              <http://www.rfc-editor.org/info/rfc2663>.\n   [RFC2974]\
    \  Handley, M., Perkins, C., and E. Whelan, \"Session\n              Announcement\
    \ Protocol\", RFC 2974, DOI 10.17487/RFC2974,\n              October 2000, <http://www.rfc-editor.org/info/rfc2974>.\n\
    \   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n    \
    \          A., Peterson, J., Sparks, R., Handley, M., and E.\n              Schooler,\
    \ \"SIP: Session Initiation Protocol\", RFC 3261,\n              DOI 10.17487/RFC3261,\
    \ June 2002,\n              <http://www.rfc-editor.org/info/rfc3261>.\n   [RFC3264]\
    \  Rosenberg, J. and H. Schulzrinne, \"An Offer/Answer Model\n              with\
    \ Session Description Protocol (SDP)\", RFC 3264,\n              DOI 10.17487/RFC3264,\
    \ June 2002,\n              <http://www.rfc-editor.org/info/rfc3264>.\n   [RFC3339]\
    \  Klyne, G. and C. Newman, \"Date and Time on the Internet:\n              Timestamps\"\
    , RFC 3339, DOI 10.17487/RFC3339, July 2002,\n              <http://www.rfc-editor.org/info/rfc3339>.\n\
    \   [RFC4145]  Yon, D. and G. Camarillo, \"TCP-Based Media Transport in\n    \
    \          the Session Description Protocol (SDP)\", RFC 4145,\n             \
    \ DOI 10.17487/RFC4145, September 2005,\n              <http://www.rfc-editor.org/info/rfc4145>.\n\
    \   [RFC4567]  Arkko, J., Lindholm, F., Naslund, M., Norrman, K., and E.\n   \
    \           Carrara, \"Key Management Extensions for Session\n              Description\
    \ Protocol (SDP) and Real Time Streaming\n              Protocol (RTSP)\", RFC\
    \ 4567, DOI 10.17487/RFC4567, July\n              2006, <http://www.rfc-editor.org/info/rfc4567>.\n\
    \   [RFC4588]  Rey, J., Leon, D., Miyazaki, A., Varsa, V., and R.\n          \
    \    Hakenberg, \"RTP Retransmission Payload Format\", RFC 4588,\n           \
    \   DOI 10.17487/RFC4588, July 2006,\n              <http://www.rfc-editor.org/info/rfc4588>.\n\
    \   [RFC4855]  Casner, S., \"Media Type Registration of RTP Payload\n        \
    \      Formats\", RFC 4855, DOI 10.17487/RFC4855, February 2007,\n           \
    \   <http://www.rfc-editor.org/info/rfc4855>.\n   [RFC4856]  Casner, S., \"Media\
    \ Type Registration of Payload Formats in\n              the RTP Profile for Audio\
    \ and Video Conferences\",\n              RFC 4856, DOI 10.17487/RFC4856, February\
    \ 2007,\n              <http://www.rfc-editor.org/info/rfc4856>.\n   [RFC5104]\
    \  Wenger, S., Chandra, U., Westerlund, M., and B. Burman,\n              \"Codec\
    \ Control Messages in the RTP Audio-Visual Profile\n              with Feedback\
    \ (AVPF)\", RFC 5104, DOI 10.17487/RFC5104,\n              February 2008, <http://www.rfc-editor.org/info/rfc5104>.\n\
    \   [RFC5245]  Rosenberg, J., \"Interactive Connectivity Establishment\n     \
    \         (ICE): A Protocol for Network Address Translator (NAT)\n           \
    \   Traversal for Offer/Answer Protocols\", RFC 5245,\n              DOI 10.17487/RFC5245,\
    \ April 2010,\n              <http://www.rfc-editor.org/info/rfc5245>.\n   [RFC5389]\
    \  Rosenberg, J., Mahy, R., Matthews, P., and D. Wing,\n              \"Session\
    \ Traversal Utilities for NAT (STUN)\", RFC 5389,\n              DOI 10.17487/RFC5389,\
    \ October 2008,\n              <http://www.rfc-editor.org/info/rfc5389>.\n   [RFC5583]\
    \  Schierl, T. and S. Wenger, \"Signaling Media Decoding\n              Dependency\
    \ in the Session Description Protocol (SDP)\",\n              RFC 5583, DOI 10.17487/RFC5583,\
    \ July 2009,\n              <http://www.rfc-editor.org/info/rfc5583>.\n   [RFC5905]\
    \  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,\n              \"Network\
    \ Time Protocol Version 4: Protocol and Algorithms\n              Specification\"\
    , RFC 5905, DOI 10.17487/RFC5905, June 2010,\n              <http://www.rfc-editor.org/info/rfc5905>.\n\
    \   [RFC6298]  Paxson, V., Allman, M., Chu, J., and M. Sargent,\n            \
    \  \"Computing TCP's Retransmission Timer\", RFC 6298,\n              DOI 10.17487/RFC6298,\
    \ June 2011,\n              <http://www.rfc-editor.org/info/rfc6298>.\n   [Stevens98]\n\
    \              Stevens, W., Fenner, B., and A. Rudoff, \"Unix Networking\n   \
    \           Programming, Volume 1: The Sockets Networking API (3rd\n         \
    \     Edition)\", 1998.\n"
- title: Appendix A.  Examples
  contents:
  - "Appendix A.  Examples\n   This section contains several different examples trying\
    \ to illustrate\n   possible ways of using RTSP.  The examples can also help with\
    \ the\n   understanding of how functions of RTSP work.  However, remember that\n\
    \   these are examples and the normative and syntax descriptions in the\n   other\
    \ sections take precedence.  Please also note that many of the\n   examples have\
    \ been broken into several lines, where following lines\n   start with whitespace\
    \ as allowed by the syntax.\n"
- title: A.1.  Media on Demand (Unicast)
  contents:
  - "A.1.  Media on Demand (Unicast)\n   This is an example of media-on-demand streaming\
    \ of media stored in a\n   container file.  For the purposes of this example,\
    \ a container file\n   is a storage entity in which multiple continuous media\
    \ types\n   pertaining to the same end-user presentation are present.  In effect,\n\
    \   the container file represents an RTSP presentation, with each of its\n   components\
    \ being RTSP-controlled media streams.  Container files are\n   a widely used\
    \ means to store such presentations.  While the\n   components are transported\
    \ as independent streams, it is desirable to\n   maintain a common context for\
    \ those streams at the server end.\n      This enables the server to keep a single\
    \ storage handle open\n      easily.  It also allows treating all the streams\
    \ equally in case\n      of any prioritization of streams by the server.\n   It\
    \ is also possible that the presentation author may wish to prevent\n   selective\
    \ retrieval of the streams by the client in order to preserve\n   the artistic\
    \ effect of the combined media presentation.  Similarly,\n   in such a tightly\
    \ bound presentation, it is desirable to be able to\n   control all the streams\
    \ via a single control message using an\n   aggregate URI.\n   The following is\
    \ an example of using a single RTSP session to control\n   multiple streams. \
    \ It also illustrates the use of aggregate URIs.  In\n   a container file, it\
    \ is also desirable not to write any URI parts\n   that are not kept when the\
    \ container is distributed, like the host\n   and most of the path element.  Therefore,\
    \ this example also uses the\n   \"*\" and relative URI in the delivered SDP.\n\
    \   Also, this presentation description (SDP) is not cacheable, as the\n   Expires\
    \ header is set to an equal value with date indicating\n   immediate expiration\
    \ of its validity.\n   Client C requests a presentation from media server M. \
    \ The movie is\n   stored in a container file.  The client has obtained an RTSP\
    \ URI to\n   the container file.\n   C->M: DESCRIBE rtsp://example.com/twister.3gp\
    \ RTSP/2.0\n         CSeq: 1\n         User-Agent: PhonyClient/1.2\n   M->C: RTSP/2.0\
    \ 200 OK\n         CSeq: 1\n         Server: PhonyServer/1.0\n         Date: Fri,\
    \ 20 Dec 2013 10:20:32 +0000\n         Content-Type: application/sdp\n       \
    \  Content-Length: 271\n         Content-Base: rtsp://example.com/twister.3gp/\n\
    \         Expires: Fri, 20 Dec 2013 12:20:32 +0000\n         v=0\n         o=-\
    \ 2890844256 2890842807 IN IP4 198.51.100.5\n         s=RTSP Session\n       \
    \  i=An Example of RTSP Session Usage\n         e=adm@example.com\n         c=IN\
    \ IP4 0.0.0.0\n         a=control: *\n         a=range:npt=00:00:00-00:10:34.10\n\
    \         t=0 0\n         m=audio 0 RTP/AVP 0\n         a=control: trackID=1\n\
    \         m=video 0 RTP/AVP 26\n         a=control: trackID=4\n   C->M: SETUP\
    \ rtsp://example.com/twister.3gp/trackID=1 RTSP/2.0\n         CSeq: 2\n      \
    \   User-Agent: PhonyClient/1.2\n         Require: play.basic\n         Transport:\
    \ RTP/AVP;unicast;dest_addr=\":8000\"/\":8001\"\n         Accept-Ranges: npt,\
    \ smpte, clock\n   M->C: RTSP/2.0 200 OK\n         CSeq: 2\n         Server: PhonyServer/1.0\n\
    \         Transport: RTP/AVP;unicast; ssrc=93CB001E;\n                    dest_addr=\"\
    192.0.2.53:8000\"/\"192.0.2.53:8001\";\n                    src_addr=\"198.51.100.5:9000\"\
    /\"198.51.100.5:9001\"\n         Session: OccldOFFq23KwjYpAnBbUr\n         Expires:\
    \ Fri, 20 Dec 2013 12:20:33 +0000\n         Date: Fri, 20 Dec 2013 10:20:33 +0000\n\
    \         Accept-Ranges: npt\n         Media-Properties: Random-Access=0.02, Immutable,\
    \ Unlimited\n   C->M: SETUP rtsp://example.com/twister.3gp/trackID=4 RTSP/2.0\n\
    \         CSeq: 3\n         User-Agent: PhonyClient/1.2\n         Require: play.basic\n\
    \         Transport: RTP/AVP;unicast;dest_addr=\":8002\"/\":8003\"\n         Session:\
    \ OccldOFFq23KwjYpAnBbUr\n         Accept-Ranges: npt, smpte, clock\n   M->C:\
    \ RTSP/2.0 200 OK\n         CSeq: 3\n         Server: PhonyServer/1.0\n      \
    \   Transport: RTP/AVP;unicast; ssrc=A813FC13;\n                    dest_addr=\"\
    192.0.2.53:8002\"/\"192.0.2.53:8003\";\n                    src_addr=\"198.51.100.5:9002\"\
    /\"198.51.100.5:9003\";\n         Session: OccldOFFq23KwjYpAnBbUr\n         Expires:\
    \ Fri, 20 Dec 2013 12:20:33 +0000\n         Date: Fri, 20 Dec 2013 10:20:33 +0000\n\
    \         Accept-Range: NPT\n         Media-Properties: Random-Access=0.8, Immutable,\
    \ Unlimited\n   C->M: PLAY rtsp://example.com/twister.3gp/ RTSP/2.0\n        \
    \ CSeq: 4\n         User-Agent: PhonyClient/1.2\n         Range: npt=30-\n   \
    \      Seek-Style: RAP\n         Session: OccldOFFq23KwjYpAnBbUr\n   M->C: RTSP/2.0\
    \ 200 OK\n         CSeq: 4\n         Server: PhonyServer/1.0\n         Date: Fri,\
    \ 20 Dec 2013 10:20:34 +0000\n         Session: OccldOFFq23KwjYpAnBbUr\n     \
    \    Range: npt=30-634.10\n         Seek-Style: RAP\n         RTP-Info: url=\"\
    rtsp://example.com/twister.3gp/trackID=4\"\n            ssrc=0D12F123:seq=12345;rtptime=3450012,\n\
    \           url=\"rtsp://example.com/twister.3gp/trackID=1\"\n            ssrc=4F312DD8:seq=54321;rtptime=2876889\n\
    \   C->M: PAUSE rtsp://example.com/twister.3gp/ RTSP/2.0\n         CSeq: 5\n \
    \        User-Agent: PhonyClient/1.2\n         Session: OccldOFFq23KwjYpAnBbUr\n\
    \   # Pause happens 0.87 seconds after starting to play\n   M->C: RTSP/2.0 200\
    \ OK\n         CSeq: 5\n         Server: PhonyServer/1.0\n         Date: Fri,\
    \ 20 Dec 2013 10:20:35 +0000\n         Session: OccldOFFq23KwjYpAnBbUr\n     \
    \    Range: npt=30.87-634.10\n   C->M: PLAY rtsp://example.com/twister.3gp/ RTSP/2.0\n\
    \         CSeq: 6\n         User-Agent: PhonyClient/1.2\n         Range: npt=30.87-634.10\n\
    \         Seek-Style: Next\n         Session: OccldOFFq23KwjYpAnBbUr\n   M->C:\
    \ RTSP/2.0 200 OK\n         CSeq: 6\n         Server: PhonyServer/1.0\n      \
    \   Date: Fri, 20 Dec 2013 10:22:13 +0000\n         Session: OccldOFFq23KwjYpAnBbUr\n\
    \         Range: npt=30.87-634.10\n         Seek-Style: Next\n         RTP-Info:\
    \ url=\"rtsp://example.com/twister.3gp/trackID=4\"\n            ssrc=0D12F123:seq=12555;rtptime=6330012,\n\
    \           url=\"rtsp://example.com/twister.3gp/trackID=1\"\n            ssrc=4F312DD8:seq=55021;rtptime=3132889\n\
    \   C->M: TEARDOWN rtsp://example.com/twister.3gp/ RTSP/2.0\n         CSeq: 7\n\
    \         User-Agent: PhonyClient/1.2\n         Session: OccldOFFq23KwjYpAnBbUr\n\
    \   M->C: RTSP/2.0 200 OK\n         CSeq: 7\n         Server: PhonyServer/1.0\n\
    \         Date: Fri, 20 Dec 2013 10:31:53 +0000\n"
- title: A.2.  Media on Demand Using Pipelining
  contents:
  - "A.2.  Media on Demand Using Pipelining\n   This example is basically the example\
    \ above (Appendix A.1), but now\n   utilizing pipelining to speed up the setup.\
    \  It requires only two\n   round-trip times until the media starts flowing. \
    \ First of all, the\n   session description is retrieved to determine what media\
    \ resources\n   need to be set up.  In the second step, one sends the necessary\
    \ SETUP\n   requests and the PLAY request to initiate media delivery.\n   Client\
    \ C requests a presentation from media server M.  The movie is\n   stored in a\
    \ container file.  The client has obtained an RTSP URI to\n   the container file.\n\
    \   C->M: DESCRIBE rtsp://example.com/twister.3gp RTSP/2.0\n         CSeq: 1\n\
    \         User-Agent: PhonyClient/1.2\n   M->C: RTSP/2.0 200 OK\n         CSeq:\
    \ 1\n         Server: PhonyServer/1.0\n         Date: Fri, 20 Dec 2013 10:20:32\
    \ +0000\n         Content-Type: application/sdp\n         Content-Length: 271\n\
    \         Content-Base: rtsp://example.com/twister.3gp/\n         Expires: Fri,\
    \ 20 Dec 2013 12:20:32 +0000\n         v=0\n         o=- 2890844256 2890842807\
    \ IN IP4 192.0.2.5\n         s=RTSP Session\n         i=An Example of RTSP Session\
    \ Usage\n         e=adm@example.com\n         c=IN IP4 0.0.0.0\n         a=control:\
    \ *\n         a=range:npt=00:00:00-00:10:34.10\n         t=0 0\n         m=audio\
    \ 0 RTP/AVP 0\n         a=control: trackID=1\n         m=video 0 RTP/AVP 26\n\
    \         a=control: trackID=4\n   C->M: SETUP rtsp://example.com/twister.3gp/trackID=1\
    \ RTSP/2.0\n         CSeq: 2\n         User-Agent: PhonyClient/1.2\n         Require:\
    \ play.basic\n         Transport: RTP/AVP;unicast;dest_addr=\":8000\"/\":8001\"\
    \n         Accept-Ranges: npt, smpte, clock\n         Pipelined-Requests: 7654\n\
    \   C->M: SETUP rtsp://example.com/twister.3gp/trackID=4 RTSP/2.0\n         CSeq:\
    \ 3\n         User-Agent: PhonyClient/1.2\n         Require: play.basic\n    \
    \     Transport: RTP/AVP;unicast;dest_addr=\":8002\"/\":8003\"\n         Accept-Ranges:\
    \ npt, smpte, clock\n         Pipelined-Requests: 7654\n   C->M: PLAY rtsp://example.com/twister.3gp/\
    \ RTSP/2.0\n         CSeq: 4\n         User-Agent: PhonyClient/1.2\n         Range:\
    \ npt=0-\n         Seek-Style: RAP\n         Pipelined-Requests: 7654\n   M->C:\
    \ RTSP/2.0 200 OK\n         CSeq: 2\n         Server: PhonyServer/1.0\n      \
    \   Transport: RTP/AVP;unicast;\n                    dest_addr=\"192.0.2.53:8000\"\
    /\"192.0.2.53:8001\";\n                    src_addr=\"198.51.100.5:9000\"/\"198.51.100.5:9001\"\
    ;\n                    ssrc=93CB001E\n         Session: OccldOFFq23KwjYpAnBbUr\n\
    \         Expires: Fri, 20 Dec 2013 12:20:32 +0000\n         Date: Fri, 20 Dec\
    \ 2013 10:20:32 +0000\n         Accept-Ranges: npt\n         Pipelined-Requests:\
    \ 7654\n         Media-Properties: Random-Access=0.2, Immutable, Unlimited\n \
    \  M->C: RTSP/2.0 200 OK\n         CSeq: 3\n         Server: PhonyServer/1.0\n\
    \         Transport: RTP/AVP;unicast;\n                    dest_addr=\"192.0.2.53:8002\"\
    /\"192.0.2.53:8003;\n                    src_addr=\"198.51.100.5:9002\"/\"198.51.100.5:9003\"\
    ;\n                    ssrc=A813FC13\n         Session: OccldOFFq23KwjYpAnBbUr\n\
    \         Expires: Sat, 21 Dec 2013 10:20:32 +0000\n         Date: Fri, 20 Dec\
    \ 2013 10:20:32 +0000\n         Accept-Range: NPT\n         Pipelined-Requests:\
    \ 7654\n         Media-Properties: Random-Access=0.8, Immutable, Unlimited\n \
    \  M->C: RTSP/2.0 200 OK\n         CSeq: 4\n         Server: PhonyServer/1.0\n\
    \         Date: Fri, 20 Dec 2013 10:20:32 +0000\n         Session: OccldOFFq23KwjYpAnBbUr\n\
    \         Range: npt=0-623.10\n         Seek-Style: RAP\n         RTP-Info: url=\"\
    rtsp://example.com/twister.3gp/trackID=4\"\n            ssrc=0D12F123:seq=12345;rtptime=3450012,\n\
    \           url=\"rtsp://example.com/twister.3gp/trackID=1\"\n            ssrc=4F312DD8:seq=54321;rtptime=2876889\n\
    \         Pipelined-Requests: 7654\n"
- title: A.3.  Secured Media Session for On-Demand Content
  contents:
  - "A.3.  Secured Media Session for On-Demand Content\n   This example is basically\
    \ the above example (Appendix A.2), but now\n   including establishment of SRTP\
    \ crypto contexts to get a secured\n   media delivery.  First of all, the client\
    \ attempts to fetch this\n   insecurely, but the server redirects to a URI indicating\
    \ a\n   requirement on using a secure connection for the RTSP messages.  The\n\
    \   client establishes a TCP/TLS connection, and the session description\n   is\
    \ retrieved to determine what media resources need to be set up.  In\n   the this\
    \ session description, secure media (SRTP) is indicated.  In\n   the next step,\
    \ the client sends the necessary SETUP requests\n   including MIKEY messages.\
    \  This is pipelined with a PLAY request to\n   initiate media delivery.\n   Client\
    \ C requests a presentation from media server M.  The movie is\n   stored in a\
    \ container file.  The client has obtained an RTSP URI to\n   the container file.\n\
    \   Note: The MIKEY messages below are not valid MIKEY messages and are\n   Base64-encoded\
    \ random data to represent where the MIKEY messages\n   would go.\n   C->M: DESCRIBE\
    \ rtsp://example.com/twister.3gp RTSP/2.0\n         CSeq: 1\n         User-Agent:\
    \ PhonyClient/1.2\n   M->C: RTSP/2.0 301 Moved Permanently\n         CSeq: 1\n\
    \         Server: PhonyServer/1.0\n         Date: Fri, 20 Dec 2013 10:25:32 +0000\n\
    \         Location: rtsps://example.com/twister.3gp\n   C->M: Establish TCP/TLS\
    \ connection and verify server's\n         certificate that represents example.com.\n\
    \         Used for all below RTSP messages.\n   C->M: DESCRIBE rtsps://example.com/twister.3gp\
    \ RTSP/2.0\n         CSeq: 2\n         User-Agent: PhonyClient/1.2\n   M->C: RTSP/2.0\
    \ 200 OK\n         CSeq: 2\n         Server: PhonyServer/1.0\n         Date: Fri,\
    \ 20 Dec 2013 10:25:33 +0000\n         Content-Type: application/sdp\n       \
    \  Content-Length: 271\n         Content-Base: rtsps://example.com/twister.3gp/\n\
    \         Expires: Fri, 20 Dec 2013 12:25:33 +0000\n         v=0\n         o=-\
    \ 2890844256 2890842807 IN IP4 192.0.2.5\n         s=RTSP Session\n         i=An\
    \ Example of RTSP Session Usage\n         e=adm@example.com\n         c=IN IP4\
    \ 0.0.0.0\n         a=control: *\n         a=range:npt=00:00:00-00:10:34.10\n\
    \         t=0 0\n         m=audio 0 RTP/SAVP 0\n         a=control: trackID=1\n\
    \         m=video 0 RTP/SAVP 26\n         a=control: trackID=4\n   C->M: SETUP\
    \ rtsps://example.com/twister.3gp/trackID=1 RTSP/2.0\n         CSeq: 3\n     \
    \    User-Agent: PhonyClient/1.2\n         Require: play.basic\n         Transport:\
    \ RTP/SAVP;unicast;dest_addr=\":8000\"/\":8001\";\n            MIKEY=VGhpcyBpcyB0aGUgZmlyc3Qgc3RyZWFtcyBNSUtFWSBtZXNzYWdl\n\
    \         Accept-Ranges: npt, smpte, clock\n         Pipelined-Requests: 7654\n\
    \   C->M: SETUP rtsps://example.com/twister.3gp/trackID=4 RTSP/2.0\n         CSeq:\
    \ 4\n         User-Agent: PhonyClient/1.2\n         Require: play.basic\n    \
    \     Transport: RTP/SAVP;unicast;dest_addr=\":8002\"/\":8003\";\n           \
    \ MIKEY=TUlLRVkgZm9yIHN0cmVhbSB0d2lzdGVyLjNncC90cmFja0lEPTQ=\n         Accept-Ranges:\
    \ npt, smpte, clock\n         Pipelined-Requests: 7654\n   C->M: PLAY rtsps://example.com/twister.3gp/\
    \ RTSP/2.0\n         CSeq: 5\n         User-Agent: PhonyClient/1.2\n         Range:\
    \ npt=0-\n         Seek-Style: RAP\n         Pipelined-Requests: 7654\n   M->C:\
    \ RTSP/2.0 200 OK\n         CSeq: 3\n         Server: PhonyServer/1.0\n      \
    \   Transport: RTP/SAVP;unicast;\n            dest_addr=\"192.0.2.53:8000\"/\"\
    192.0.2.53:8001\";\n            src_addr=\"198.51.100.5:9000\"/\"198.51.100.5:9001\"\
    ;\n            ssrc=93CB001E;\n            MIKEY=TUlLRVkgUmVzcG9uc2UgdHdpc3Rlci4zZ3AvdHJhY2tJRD0x\n\
    \         Session: OccldOFFq23KwjYpAnBbUr\n         Expires: Fri, 20 Dec 2013\
    \ 12:25:34 +0000\n         Date: Fri, 20 Dec 2013 10:25:34 +0000\n         Accept-Ranges:\
    \ npt\n         Pipelined-Requests: 7654\n         Media-Properties: Random-Access=0.2,\
    \ Immutable, Unlimited\n   M->C: RTSP/2.0 200 OK\n         CSeq: 4\n         Server:\
    \ PhonyServer/1.0\n         Transport: RTP/SAVP;unicast;\n            dest_addr=\"\
    192.0.2.53:8002\"/\"192.0.2.53:8003;\n            src_addr=\"198.51.100.5:9002\"\
    /\"198.51.100.5:9003\";\n            ssrc=A813FC13;\n            MIKEY=TUlLRVkgUmVzcG9uc2UgdHdpc3Rlci4zZ3AvdHJhY2tJRD00\n\
    \         Session: OccldOFFq23KwjYpAnBbUr\n         Expires: Fri, 20 Dec 2013\
    \ 12:25:34 +0000\n         Date: Fri, 20 Dec 2013 10:25:34 +0000\n         Accept-Range:\
    \ NPT\n         Pipelined-Requests: 7654\n         Media-Properties: Random-Access=0.8,\
    \ Immutable, Unlimited\n   M->C: RTSP/2.0 200 OK\n         CSeq: 5\n         Server:\
    \ PhonyServer/1.0\n         Date: Fri, 20 Dec 2013 10:25:34 +0000\n         Session:\
    \ OccldOFFq23KwjYpAnBbUr\n         Range: npt=0-623.10\n         Seek-Style: RAP\n\
    \         RTP-Info: url=\"rtsps://example.com/twister.3gp/trackID=4\"\n      \
    \      ssrc=0D12F123:seq=12345;rtptime=3450012,\n           url=\"rtsps://example.com/twister.3gp/trackID=1\"\
    \n            ssrc=4F312DD8:seq=54321;rtptime=2876889;\n         Pipelined-Requests:\
    \ 7654\n"
- title: A.4.  Media on Demand (Unicast)
  contents:
  - "A.4.  Media on Demand (Unicast)\n   An alternative example of media on demand\
    \ with a few more tweaks is\n   the following.  Client C requests a movie distributed\
    \ from two\n   different media servers A (audio.example.com) and V\n   (video.example.com).\
    \  The media description is stored on a web server\n   W.  The media description\
    \ contains descriptions of the presentation\n   and all its streams, including\
    \ the codecs that are available and the\n   protocol stack.\n   In this example,\
    \ the client is only interested in the last part of\n   the movie.\n   C->W: GET\
    \ /twister.sdp HTTP/1.1\n         Host: www.example.com\n         Accept: application/sdp\n\
    \   W->C: HTTP/1.1 200 OK\n         Date: Wed, 23 Jan 2013 15:35:06 GMT\n    \
    \     Content-Type: application/sdp\n         Content-Length: 278\n         Expires:\
    \ Thu, 24 Jan 2013 15:35:06 GMT\n         v=0\n         o=- 2890844526 2890842807\
    \ IN IP4 198.51.100.5\n         s=RTSP Session\n         e=adm@example.com\n \
    \        c=IN IP4 0.0.0.0\n         a=range:npt=00:00:00-01:49:34\n         t=0\
    \ 0\n         m=audio 0 RTP/AVP 0\n         a=control:rtsp://audio.example.com/twister/audio.en\n\
    \         m=video 0 RTP/AVP 31\n         a=control:rtsp://video.example.com/twister/video\n\
    \   C->A: SETUP rtsp://audio.example.com/twister/audio.en RTSP/2.0\n         CSeq:\
    \ 1\n         User-Agent: PhonyClient/1.2\n         Transport: RTP/AVP/UDP;unicast;dest_addr=\"\
    :3056\"/\":3057\",\n                    RTP/AVP/TCP;unicast;interleaved=0-1\n\
    \         Accept-Ranges: npt, smpte, clock\n   A->C: RTSP/2.0 200 OK\n       \
    \  CSeq: 1\n         Session: OccldOFFq23KwjYpAnBbUr\n         Transport: RTP/AVP/UDP;unicast;\n\
    \                    dest_addr=\"192.0.2.53:3056\"/\"192.0.2.53:3057\";\n    \
    \                src_addr=\"198.51.100.5:5000\"/\"198.51.100.5:5001\"\n      \
    \   Date: Wed, 23 Jan 2013 15:35:12 +0000\n         Server: PhonyServer/1.0\n\
    \         Expires: Thu, 24 Jan 2013 15:35:12 +0000\n         Cache-Control: public\n\
    \         Accept-Ranges: npt, smpte\n         Media-Properties: Random-Access=0.02,\
    \ Immutable, Unlimited\n   C->V: SETUP rtsp://video.example.com/twister/video\
    \ RTSP/2.0\n         CSeq: 1\n         User-Agent: PhonyClient/1.2\n         Transport:\
    \ RTP/AVP/UDP;unicast;\n                    dest_addr=\"192.0.2.53:3058\"/\"192.0.2.53:3059\"\
    ,\n                    RTP/AVP/TCP;unicast;interleaved=0-1\n         Accept-Ranges:\
    \ npt, smpte, clock\n   V->C: RTSP/2.0 200 OK\n         CSeq: 1\n         Session:\
    \ P5it3pMo6xHkjUcDrNkBjf\n         Transport: RTP/AVP/UDP;unicast;\n         \
    \   dest_addr=\"192.0.2.53:3058\"/\"192.0.2.53:3059\";\n            src_addr=\"\
    198.51.100.5:5002\"/\"198.51.100.5:5003\"\n         Date: Wed, 23 Jan 2013 15:35:12\
    \ +0000\n         Server: PhonyServer/1.0\n         Cache-Control: public\n  \
    \       Expires: Thu, 24 Jan 2013 15:35:12 +0000\n         Accept-Ranges: npt,\
    \ smpte\n         Media-Properties: Random-Access=1.2, Immutable, Unlimited\n\
    \   C->V: PLAY rtsp://video.example.com/twister/video RTSP/2.0\n         CSeq:\
    \ 2\n         User-Agent: PhonyClient/1.2\n         Session: P5it3pMo6xHkjUcDrNkBjf\n\
    \         Range: smpte=0:10:00-\n   V->C: RTSP/2.0 200 OK\n         CSeq: 2\n\
    \         Session: P5it3pMo6xHkjUcDrNkBjf\n         Range: smpte=0:10:00-1:49:23\n\
    \         Seek-Style: First-Prior\n         RTP-Info: url=\"rtsp://video.example.com/twister/video\"\
    \n                   ssrc=A17E189D:seq=12312232;rtptime=78712811\n         Server:\
    \ PhonyServer/2.0\n         Date: Wed, 23 Jan 2013 15:35:13 +0000\n   C->A: PLAY\
    \ rtsp://audio.example.com/twister/audio.en RTSP/2.0\n         CSeq: 2\n     \
    \    User-Agent: PhonyClient/1.2\n         Session: OccldOFFq23KwjYpAnBbUr\n \
    \        Range: smpte=0:10:00-\n   A->C: RTSP/2.0 200 OK\n         CSeq: 2\n \
    \        Session: OccldOFFq23KwjYpAnBbUr\n         Range: smpte=0:10:00-1:49:23\n\
    \         Seek-Style: First-Prior\n         RTP-Info: url=\"rtsp://audio.example.com/twister/audio.en\"\
    \n                   ssrc=3D124F01:seq=876655;rtptime=1032181\n         Server:\
    \ PhonyServer/1.0\n         Date: Wed, 23 Jan 2013 15:35:13 +0000\n   C->A: TEARDOWN\
    \ rtsp://audio.example.com/twister/audio.en RTSP/2.0\n         CSeq: 3\n     \
    \    User-Agent: PhonyClient/1.2\n         Session: OccldOFFq23KwjYpAnBbUr\n \
    \  A->C: RTSP/2.0 200 OK\n         CSeq: 3\n         Server: PhonyServer/1.0\n\
    \         Date: Wed, 23 Jan 2013 15:36:52 +0000\n   C->V: TEARDOWN rtsp://video.example.com/twister/video\
    \ RTSP/2.0\n         CSeq: 3\n         User-Agent: PhonyClient/1.2\n         Session:\
    \ P5it3pMo6xHkjUcDrNkBjf\n   V->C: RTSP/2.0 200 OK\n         CSeq: 3\n       \
    \  Server: PhonyServer/2.0\n         Date: Wed, 23 Jan 2013 15:36:52 +0000\n \
    \  Even though the audio and video track are on two different servers\n   that\
    \ may start at slightly different times and may drift with respect\n   to each\
    \ other over time, the client can perform initial\n   synchronization of the two\
    \ media using RTP-Info and Range received in\n   the PLAY responses.  If the two\
    \ servers are time synchronized, the\n   RTCP packets can also be used to maintain\
    \ synchronization.\n"
- title: A.5.  Single-Stream Container Files
  contents:
  - "A.5.  Single-Stream Container Files\n   Some RTSP servers may treat all files\
    \ as though they are \"container\n   files\", yet other servers may not support\
    \ such a concept.  Because of\n   this, clients needs to use the rules set forth\
    \ in the session\n   description for Request-URIs rather than assuming that a\
    \ consistent\n   URI may always be used throughout.  Below is an example of how\
    \ a\n   multi-stream server might expect a single-stream file to be served:\n\
    \   C->S: DESCRIBE rtsp://foo.example.com/test.wav RTSP/2.0\n         Accept:\
    \ application/x-rtsp-mh, application/sdp\n         CSeq: 1\n         User-Agent:\
    \ PhonyClient/1.2\n   S->C: RTSP/2.0 200 OK\n         CSeq: 1\n         Content-base:\
    \ rtsp://foo.example.com/test.wav/\n         Content-type: application/sdp\n \
    \        Content-length: 163\n         Server: PhonyServer/1.0\n         Date:\
    \ Wed, 23 Jan 2013 15:36:52 +0000\n         Expires: Thu, 24 Jan 2013 15:36:52\
    \ +0000\n         v=0\n         o=- 872653257 872653257 IN IP4 192.0.2.5\n   \
    \      s=mu-law wave file\n         i=audio test\n         c=IN IP4 0.0.0.0\n\
    \         t=0 0\n         a=control: *\n         m=audio 0 RTP/AVP 0\n       \
    \  a=control:streamid=0\n   C->S: SETUP rtsp://foo.example.com/test.wav/streamid=0\
    \ RTSP/2.0\n         Transport: RTP/AVP/UDP;unicast;\n            dest_addr=\"\
    :6970\"/\":6971\";mode=\"PLAY\"\n         CSeq: 2\n         User-Agent: PhonyClient/1.2\n\
    \         Accept-Ranges: npt, smpte, clock\n   S->C: RTSP/2.0 200 OK\n       \
    \  Transport: RTP/AVP/UDP;unicast;\n             dest_addr=\"192.0.2.53:6970\"\
    /\"192.0.2.53:6971\";\n             src_addr=\"198.51.100.5:6970\"/\"198.51.100.5:6971\"\
    ;\n             mode=\"PLAY\";ssrc=EAB98712\n         CSeq: 2\n         Session:\
    \ NYkqQYKk0bb12BY3goyoyO\n         Expires: Thu, 24 Jan 2013 15:36:52 +0000\n\
    \         Server: PhonyServer/1.0\n         Date: Wed, 23 Jan 2013 15:36:52 +0000\n\
    \         Accept-Ranges: npt\n         Media-Properties: Random-Access=0.5, Immutable,\
    \ Unlimited\n   C->S: PLAY rtsp://foo.example.com/test.wav/ RTSP/2.0\n       \
    \  CSeq: 3\n         User-Agent: PhonyClient/1.2\n         Session: NYkqQYKk0bb12BY3goyoyO\n\
    \   S->C: RTSP/2.0 200 OK\n         CSeq: 3\n         Server: PhonyServer/1.0\n\
    \         Date: Wed, 23 Jan 2013 15:36:52 +0000\n         Session: NYkqQYKk0bb12BY3goyoyO\n\
    \         Range: npt=0-600\n         Seek-Style: RAP\n         RTP-Info: url=\"\
    rtsp://foo.example.com/test.wav/streamid=0\"\n            ssrc=0D12F123:seq=981888;rtptime=3781123\n\
    \   Note the different URI in the SETUP command and then the switch back\n   to\
    \ the aggregate URI in the PLAY command.  This makes complete sense\n   when there\
    \ are multiple streams with aggregate control, but it is\n   less than intuitive\
    \ in the special case where the number of streams\n   is one.  However, the server\
    \ has declared the aggregated control URI\n   in the SDP; therefore, this is legal.\n\
    \   In this case, it is also required that servers accept implementations\n  \
    \ that use the non-aggregated interpretation and use the individual\n   media\
    \ URI, like this:\n   C->S: PLAY rtsp://example.com/test.wav/streamid=0 RTSP/2.0\n\
    \         CSeq: 3\n         User-Agent: PhonyClient/1.2\n         Session: NYkqQYKk0bb12BY3goyoyO\n"
- title: A.6.  Live Media Presentation Using Multicast
  contents:
  - "A.6.  Live Media Presentation Using Multicast\n   The media server M chooses\
    \ the multicast address and port.  Here, it\n   is assumed that the web server\
    \ only contains a pointer to the full\n   description, while the media server\
    \ M maintains the full description.\n   C->W: GET /sessions.html HTTP/1.1\n  \
    \       Host: www.example.com\n   W->C: HTTP/1.1 200 OK\n         Content-Type:\
    \ text/html\n         <html>\n           ...\n           <a href \"rtsp://live.example.com/concert/audio\"\
    >\n              Streamed Live Music performance </a>\n           ...\n      \
    \   </html>\n   C->M: DESCRIBE rtsp://live.example.com/concert/audio RTSP/2.0\n\
    \         CSeq: 1\n         Supported: play.basic, play.scale\n         User-Agent:\
    \ PhonyClient/1.2\n   M->C: RTSP/2.0 200 OK\n         CSeq: 1\n         Content-Type:\
    \ application/sdp\n         Content-Length: 183\n         Server: PhonyServer/1.0\n\
    \         Date: Wed, 23 Jan 2013 15:36:52 +0000\n         Supported: play.basic\n\
    \         v=0\n         o=- 2890844526 2890842807 IN IP4 192.0.2.5\n         s=RTSP\
    \ Session\n         t=0 0\n         m=audio 3456 RTP/AVP 0\n         c=IN IP4\
    \ 233.252.0.54/16\n         a=control: rtsp://live.example.com/concert/audio\n\
    \         a=range:npt=0-\n   C->M: SETUP rtsp://live.example.com/concert/audio\
    \ RTSP/2.0\n         CSeq: 2\n         Transport: RTP/AVP;multicast;\n       \
    \       dest_addr=\"233.252.0.54:3456\"/\"233.252.0.54:3457\";ttl=16\n       \
    \  Accept-Ranges: npt, smpte, clock\n         User-Agent: PhonyClient/1.2\n  \
    \ M->C: RTSP/2.0 200 OK\n         CSeq: 2\n         Server: PhonyServer/1.0\n\
    \         Date: Wed, 23 Jan 2013 15:36:52 +0000\n         Transport: RTP/AVP;multicast;\n\
    \              dest_addr=\"233.252.0.54:3456\"/\"233.252.0.54:3457\";ttl=16\n\
    \              ;ssrc=4D12AB92/0DF876A3\n         Session: qHj4jidpmF6zy9v9tNbtxr\n\
    \         Accept-Ranges: npt, clock\n         Media-Properties: No-Seeking, Time-Progressing,\
    \ Time-Duration=0\n   C->M: PLAY rtsp://live.example.com/concert/audio RTSP/2.0\n\
    \         CSeq: 3\n         Session: qHj4jidpmF6zy9v9tNbtxr\n         User-Agent:\
    \ PhonyClient/1.2\n   M->C: RTSP/2.0 200 OK\n         CSeq: 3\n         Server:\
    \ PhonyServer/1.0\n         Date: Wed, 23 Jan 2013 15:36:52 +0000\n         Session:\
    \ qHj4jidpmF6zy9v9tNbtxr\n         Seek-Style: Next\n         Range:npt=1256-\n\
    \         RTP-Info: url=\"rtsp://live.example.com/concert/audio\"\n          \
    \         ssrc=0D12F123:seq=1473; rtptime=80000\n"
- title: A.7.  Capability Negotiation
  contents:
  - "A.7.  Capability Negotiation\n   This example illustrates how the client and\
    \ server determine their\n   capability to support a special feature, in this\
    \ case, \"play.scale\".\n   The server, through the client request and the included\
    \ Supported\n   header, learns that the client supports RTSP 2.0 and also supports\n\
    \   the playback time scaling feature of RTSP.  The server's response\n   contains\
    \ the following feature-related information to the client; it\n   supports the\
    \ basic media delivery functions (play.basic), the\n   extended functionality\
    \ of time scaling of content (play.scale), and\n   one \"example.com\" proprietary\
    \ feature (com.example.flight).  The\n   client also learns the methods supported\
    \ (Public header) by the\n   server for the indicated resource.\n   C->S: OPTIONS\
    \ rtsp://media.example.com/movie/twister.3gp RTSP/2.0\n         CSeq: 1\n    \
    \     Supported: play.basic, play.scale\n         User-Agent: PhonyClient/1.2\n\
    \   S->C: RTSP/2.0 200 OK\n         CSeq: 1\n         Public:OPTIONS,SETUP,PLAY,PAUSE,TEARDOWN,DESCRIBE,GET_PARAMETER\n\
    \         Allow: OPTIONS, SETUP, PLAY, PAUSE, TEARDOWN, DESCRIBE\n         Server:\
    \ PhonyServer/2.0\n         Supported: play.basic, play.scale, com.example.flight\n\
    \   When the client sends its SETUP request, it tells the server that it\n   requires\
    \ support of the play.scale feature for this session by\n   including the Require\
    \ header.\n   C->S: SETUP rtsp://media.example.com/twister.3gp/trackID=1 RTSP/2.0\n\
    \         CSeq: 3\n         User-Agent: PhonyClient/1.2\n         Transport: RTP/AVP/UDP;unicast;\n\
    \                    dest_addr=\"192.0.2.53:3056\"/\"192.0.2.53:3057\",\n    \
    \                RTP/AVP/TCP;unicast;interleaved=0-1\n         Require: play.scale\n\
    \         Accept-Ranges: npt, smpte, clock\n         User-Agent: PhonyClient/1.2\n\
    \   S->C: RTSP/2.0 200 OK\n         CSeq: 3\n         Session: OccldOFFq23KwjYpAnBbUr\n\
    \         Transport: RTP/AVP/UDP;unicast;\n            dest_addr=\"192.0.2.53:3056\"\
    /\"192.0.2.53:3057\";\n            src_addr=\"198.51.100.5:5000\"/\"198.51.100.5:5001\"\
    \n         Server: PhonyServer/2.0\n         Accept-Ranges: npt, smpte\n     \
    \    Media-Properties: Random-Access=0.8, Immutable, Unlimited\n"
- title: Appendix B.  RTSP Protocol State Machine
  contents:
  - "Appendix B.  RTSP Protocol State Machine\n   The RTSP session state machine describes\
    \ the behavior of the protocol\n   from RTSP session initialization through RTSP\
    \ session termination.\n   It is probably easiest to think of this as the server's\
    \ state and\n   then view the client as needing to track what it believes the\n\
    \   server's state will be based on sent or received RTSP messages.\n   Thus,\
    \ in most cases, the state tables below can be read as: if the\n   client does\
    \ X, and assuming it fulfills any prerequisite(s), the\n   (server) state will\
    \ move to the new state and the indicated response\n   will returned.  However,\
    \ there are also server-to-client\n   notifications or requests, where the action\
    \ describes what\n   notification or request will occur, its requisites, what\
    \ new state\n   will result after the server has received the response, as well\
    \ as\n   describing the client's response to the action.\n   The State machine\
    \ is defined on a per-session basis, which is\n   uniquely identified by the RTSP\
    \ session identifier.  The session may\n   contain one or more media streams depending\
    \ on state.  If a single\n   media stream is part of the session, it is in non-aggregated\
    \ control.\n   If two or more are part of the session, it is in aggregated control.\n\
    \   The below state machine is an informative description of the\n   protocol's\
    \ behavior.  In case of ambiguity with the earlier parts of\n   this specification,\
    \ the description in the earlier parts take\n   precedence.\n"
- title: B.1.  States
  contents:
  - "B.1.  States\n   The state machine contains three states, described below.  For\
    \ each\n   state, there exists a table that shows which requests and events are\n\
    \   allowed and whether they will result in a state change.\n   Init: Initial\
    \ state, no session exists.\n   Ready:  Session is ready to start playing.\n \
    \  Play: Session is playing, i.e., sending media-stream data in the\n        \
    \ direction S->C.\n"
- title: B.2.  State Variables
  contents:
  - "B.2.  State Variables\n   This representation of the state machine needs more\
    \ than its state to\n   work.  A small number of variables are also needed, and\
    \ they are\n   explained below.\n   NRM:  The number of media streams that are\
    \ part of this session.\n   RP:   Resume point, the point in the presentation\
    \ time line at which\n         a request to continue playing will resume from.\
    \  A time format\n         for the variable is not mandated.\n"
- title: B.3.  Abbreviations
  contents:
  - "B.3.  Abbreviations\n   To make the state tables more compact, a number of abbreviations\
    \ are\n   used, which are explained below.\n   IFI:  IF Implemented.\n   md: \
    \  Media\n   PP:   Pause Point, the point in the presentation timeline at which\n\
    \         the presentation was paused.\n   Prs:  Presentation, the complete multimedia\
    \ presentation.\n   RedP: Redirect Point, the point in the presentation timeline\
    \ at which\n         a REDIRECT was specified to occur.\n   SES:  Session.\n"
- title: B.4.  State Tables
  contents:
  - "B.4.  State Tables\n   This section contains a table for each state.  The table\
    \ contains all\n   the requests and events on which this state is allowed to act.\
    \  The\n   events that are method names are, unless noted, requests with the\n\
    \   given method in the direction client to server (C->S).  In some\n   cases,\
    \ there exists one or more requisites.  The response column\n   tells what type\
    \ of response actions should be performed.  Possible\n   actions that are requested\
    \ for an event include: response codes,\n   e.g., 200, headers that need to be\
    \ included in the response, setting\n   of state variables, or settings of other\
    \ session-related parameters.\n   The new state column tells which state the state\
    \ machine changes to.\n   The response to a valid request meeting the requisites\
    \ is normally a\n   2xx (SUCCESS) unless otherwise noted in the response column.\
    \  The\n   exceptions need to be given a response according to the response\n\
    \   column.  If the request does not meet the requisite, is erroneous, or\n  \
    \ some other type of error occurs, the appropriate response code is to\n   be\
    \ sent.  If the response code is a 4xx, the session state is\n   unchanged.  A\
    \ response code of 3rr will result in that the session\n   being ended and its\
    \ state changed to Init.  A response code of 304\n   results in no state change.\
    \  However, there are restrictions to when\n   a 3rr response may be used.  A\
    \ 5xx response does not result in any\n   change of the session state, except\
    \ if the error is not possible to\n   recover from.  An unrecoverable error results\
    \ in the ending of the\n   session.  In the general case, if it can't be determined\
    \ whether or\n   not it was an unrecoverable error, the client will be required\
    \ to\n   test.  In the case that the next request after a 5xx is responded to\n\
    \   with a 454 (Session Not Found), the client knows that the session has\n  \
    \ ended.  For any request message that cannot be responded to within\n   the time\
    \ defined in Section 10.4, a 100 response must be sent.\n   The server will time\
    \ out the session after the period of time\n   specified in the SETUP response,\
    \ if no activity from the client is\n   detected.  Therefore, there exists a timeout\
    \ event for all states\n   except Init.\n   In the case that NRM = 1, the presentation\
    \ URI is equal to the media\n   URI or a specified presentation URI.  For NRM\
    \ > 1, the presentation\n   URI needs to be other than any of the media that are\
    \ part of the\n   session.  This applies to all states.\n   +---------------+-----------------+---------------------------------+\n\
    \   | Event         | Prerequisite    | Response                        |\n  \
    \ +---------------+-----------------+---------------------------------+\n   |\
    \ DESCRIBE      | Needs REDIRECT  | 3rr, Redirect                   |\n   |  \
    \             |                 |                                 |\n   | DESCRIBE\
    \      |                 | 200, Session description        |\n   |           \
    \    |                 |                                 |\n   | OPTIONS     \
    \  | Session ID      | 200, Reset session timeout      |\n   |               |\
    \                 | timer                           |\n   |               |  \
    \               |                                 |\n   | OPTIONS       |    \
    \             | 200                             |\n   |               |      \
    \           |                                 |\n   | SET_PARAMETER | Valid parameter\
    \ | 200, change value of parameter  |\n   |               |                 |\
    \                                 |\n   | GET_PARAMETER | Valid parameter | 200,\
    \ return value of parameter  |\n   +---------------+-----------------+---------------------------------+\n\
    \                Table 9: Non-State-Machine Changing Events\n   The methods in\
    \ Table 9 do not have any effect on the state machine or\n   the state variables.\
    \  However, some methods do change other session-\n   related parameters, for\
    \ example, SET_PARAMETER, which will set the\n   parameter(s) specified in its\
    \ body.  Also, all of these methods that\n   allow the Session header will also\
    \ update the keep-alive timer for\n   the session.\n   +------------------+----------------+-----------+-------------------+\n\
    \   | Action           | Requisite      | New State | Response          |\n  \
    \ +------------------+----------------+-----------+-------------------+\n   |\
    \ SETUP            |                | Ready     | NRM=1, RP=0.0     |\n   |  \
    \                |                |           |                   |\n   | SETUP\
    \            | Needs Redirect | Init      | 3rr Redirect      |\n   |        \
    \          |                |           |                   |\n   | S -> C: REDIRECT\
    \ | No Session hdr | Init      | Terminate all SES |\n   +------------------+----------------+-----------+-------------------+\n\
    \                           Table 10: State: Init\n   The initial state of the\
    \ state machine (Table 10) can only be left by\n   processing a correct SETUP\
    \ request.  As seen in the table, the two\n   state variables are also set by\
    \ a correct request.  This table also\n   shows that a correct SETUP can in some\
    \ cases be redirected to another\n   URI or server by a 3rr response.\n   +-------------+------------------------+---------+------------------+\n\
    \   | Action      | Requisite              | New     | Response         |\n  \
    \ |             |                        | State   |                  |\n   +-------------+------------------------+---------+------------------+\n\
    \   | SETUP       | New URI                | Ready   | NRM +=1          |\n  \
    \ |             |                        |         |                  |\n   |\
    \ SETUP       | URI Setup prior        | Ready   | Change transport |\n   |  \
    \           |                        |         | param            |\n   |    \
    \         |                        |         |                  |\n   | TEARDOWN\
    \    | Prs URI,               | Init    | No session hdr,  |\n   |           \
    \  |                        |         | NRM = 0          |\n   |             |\
    \                        |         |                  |\n   | TEARDOWN    | md\
    \ URI,NRM=1           | Init    | No Session hdr,  |\n   |             |     \
    \                   |         | NRM = 0          |\n   |             |       \
    \                 |         |                  |\n   | TEARDOWN    | md URI,NRM>1\
    \           | Ready   | Session hdr, NRM |\n   |             |               \
    \         |         | -= 1             |\n   |             |                 \
    \       |         |                  |\n   | PLAY        | Prs URI, No range \
    \     | Play    | Play from RP     |\n   |             |                     \
    \   |         |                  |\n   | PLAY        | Prs URI, Range        \
    \ | Play    | According to     |\n   |             |                        |\
    \         | range            |\n   |             |                        |  \
    \       |                  |\n   | PLAY        | md URI, NRM=1, Range   | Play\
    \    | According to     |\n   |             |                        |       \
    \  | range            |\n   |             |                        |         |\
    \                  |\n   | PLAY        | md URI, NRM=1          | Play    | Play\
    \ from RP     |\n   |             |                        |         |       \
    \           |\n   | PAUSE       | Prs URI                | Ready   | Return PP\
    \        |\n   |             |                        |         |            \
    \      |\n   | SC:REDIRECT | Terminate-Reason       | Ready   | Set RedP     \
    \    |\n   |             |                        |         |                \
    \  |\n   | SC:REDIRECT | No Terminate-Reason    | Init    | Session is       |\n\
    \   |             | time parameter         |         | removed          |\n  \
    \ |             |                        |         |                  |\n   |\
    \ Timeout     |                        | Init    |                  |\n   |  \
    \           |                        |         |                  |\n   | RedP\
    \        |                        | Init    | TEARDOWN of      |\n   | reached\
    \     |                        |         | session          |\n   +-------------+------------------------+---------+------------------+\n\
    \                          Table 11: State: Ready\n   In the Ready state (Table\
    \ 11), some of the actions depend on the\n   number of media streams (NRM) in\
    \ the session, i.e., aggregated or\n   non-aggregated control.  A SETUP request\
    \ in the Ready state can\n   either add one more media stream to the session or,\
    \ if the media\n   stream (same URI) already is part of the session, change the\n\
    \   transport parameters.  TEARDOWN depends on both the Request-URI and\n   the\
    \ number of media streams within the session.  If the Request-URI\n   is the presentation\
    \ URI, the whole session is torn down.  If a media\n   URI is used in the TEARDOWN\
    \ request and more than one media exists in\n   the session, the session will\
    \ remain and a session header is returned\n   in the response.  If only a single\
    \ media stream remains in the\n   session when performing a TEARDOWN with a media\
    \ URI, the session is\n   removed.  The number of media streams remaining after\
    \ tearing down a\n   media stream determines the new state.\n   +----------------+-----------------------+--------+-----------------+\n\
    \   | Action         | Requisite             | New    | Response        |\n  \
    \ |                |                       | State  |                 |\n   +----------------+-----------------------+--------+-----------------+\n\
    \   | PAUSE          | Prs URI               | Ready  | Set RP to       |\n  \
    \ |                |                       |        | present point   |\n   |\
    \                |                       |        |                 |\n   | End\
    \ of media   | All media             | Play   | Set RP = End of |\n   |      \
    \          |                       |        | media           |\n   |        \
    \        |                       |        |                 |\n   | End of range\
    \   |                       | Play   | Set RP = End of |\n   |               \
    \ |                       |        | range           |\n   |                |\
    \                       |        |                 |\n   | PLAY           | Prs\
    \ URI, No range     | Play   | Play from       |\n   |                |      \
    \                 |        | present point   |\n   |                |        \
    \               |        |                 |\n   | PLAY           | Prs URI, Range\
    \        | Play   | According to    |\n   |                |                 \
    \      |        | range           |\n   |                |                   \
    \    |        |                 |\n   | SC:PLAY_NOTIFY |                     \
    \  | Play   | 200             |\n   |                |                       |\
    \        |                 |\n   | SETUP          | New URI               | Play\
    \   | 455             |\n   |                |                       |       \
    \ |                 |\n   | SETUP          | md URI                | Play   |\
    \ 455             |\n   |                |                       |        |  \
    \               |\n   | SETUP          | md URI, IFI           | Play   | Change\
    \          |\n   |                |                       |        | transport\
    \ param.|\n   |                |                       |        |            \
    \     |\n   | TEARDOWN       | Prs URI               | Init   | No session hdr\
    \  |\n   |                |                       |        |                 |\n\
    \   | TEARDOWN       | md URI,NRM=1          | Init   | No Session hdr, |\n  \
    \ |                |                       |        | NRM=0           |\n   |\
    \                |                       |        |                 |\n   | TEARDOWN\
    \       | md URI                | Play   | 455             |\n   |           \
    \     |                       |        |                 |\n   | SC:REDIRECT \
    \   | Terminate Reason with | Play   | Set RedP        |\n   |               \
    \ | Time parameter        |        |                 |\n   |                |\
    \                       |        |                 |\n   | SC:REDIRECT    |  \
    \                     | Init   | Session is      |\n   |                |    \
    \                   |        | removed         |\n   |                |      \
    \                 |        |                 |\n   | RedP reached   |        \
    \               | Init   | TEARDOWN of     |\n   |                |          \
    \             |        | session         |\n   |                |            \
    \           |        |                 |\n   | Timeout        |              \
    \         | Init   | Stop Media      |\n   |                |                \
    \       |        | playout         |\n   +----------------+-----------------------+--------+-----------------+\n\
    \                           Table 12: State: Play\n   The Play state table (Table\
    \ 12) contains a number of requests that\n   need a presentation URI (labeled\
    \ as Prs URI) to work on (i.e., the\n   presentation URI has to be used as the\
    \ Request-URI).  This is due to\n   the exclusion of non-aggregated stream control\
    \ in sessions with more\n   than one media stream.\n   To avoid inconsistencies\
    \ between the client and server, automatic\n   state transitions are avoided.\
    \  This can be seen at, for example, an\n   \"End of media\" event when all media\
    \ has finished playing but the\n   session still remains in Play state.  An explicit\
    \ PAUSE request needs\n   to be sent to change the state to Ready.  It may appear\
    \ that there\n   exist automatic transitions in \"RedP reached\" and \"PP reached\"\
    .\n   However, they are requested and acknowledged before they take place.\n \
    \  The time at which the transition will happen is known by looking at\n   the\
    \ Terminate-Reason header's time parameter and Range header,\n   respectively.\
    \  If the client sends a request close in time to these\n   transitions, it needs\
    \ to be prepared for receiving error messages, as\n   the state may or may not\
    \ have changed.\n"
- title: Appendix C.  Media-Transport Alternatives
  contents:
  - "Appendix C.  Media-Transport Alternatives\n   This section defines how certain\
    \ combinations of protocols, profiles,\n   and lower transports are used.  This\
    \ includes the usage of the\n   Transport header's source and destination address\
    \ parameters:\n   \"src_addr\" and \"dest_addr\".\n"
- title: C.1.  RTP
  contents:
  - "C.1.  RTP\n   This section defines the interaction of RTSP with respect to the\
    \ RTP\n   protocol [RFC3550].  It also defines any necessary media-transport\n\
    \   signaling with regard to RTP.\n   The available RTP profiles and lower-layer\
    \ transports are described\n   below along with rules on signaling the available\
    \ combinations.\n"
- title: C.1.1.  AVP
  contents:
  - "C.1.1.  AVP\n   The usage of the \"RTP Profile for Audio and Video Conferences\
    \ with\n   Minimal Control\" [RFC3551] when using RTP for media transport over\n\
    \   different lower-layer transport protocols is defined below in regard\n   to\
    \ RTSP.\n   One such case is defined within this document: the use of embedded\n\
    \   (interleaved) binary data as defined in Section 14.  The usage of\n   this\
    \ method is indicated by including the \"interleaved\" parameter.\n   When using\
    \ embedded binary data, \"src_addr\" and \"dest_addr\" MUST NOT\n   be used. \
    \ This addressing and multiplexing is used as defined with\n   use of channel\
    \ numbers and the interleaved parameter.\n"
- title: C.1.2.  AVP/UDP
  contents:
  - "C.1.2.  AVP/UDP\n   This part describes the sending of RTP [RFC3550] over lower-\n\
    \   transport-layer UDP [RFC768] according to the profile \"RTP Profile\n   for\
    \ Audio and Video Conferences with Minimal Control\" defined in\n   [RFC3551].\
    \  Implementations of RTP/AVP/UDP MUST implement RTCP\n   (Appendix C.1.6).  This\
    \ profile requires one or two unidirectional or\n   bidirectional UDP flows per\
    \ media stream.  The first UDP flow is for\n   RTP and the second is for RTCP.\
    \  Multiplexing of RTP and RTCP\n   (Appendix C.1.6.4) MAY be used, in which case,\
    \ a single UDP flow is\n   used for both parts.  Embedding of RTP data with the\
    \ RTSP messages,\n   in accordance with Section 14, SHOULD NOT be performed when\
    \ RTSP\n   messages are transported over unreliable transport protocols, like\n\
    \   UDP [RFC768].\n   The RTP/UDP and RTCP/UDP flows can be established using\
    \ the Transport\n   header's \"src_addr\" and \"dest_addr\" parameters.\n   In\
    \ RTSP PLAY mode, the transmission of RTP packets from client to\n   server is\
    \ unspecified.  The behavior in regard to such RTP packets\n   MAY be defined\
    \ in future.\n   The \"src_addr\" and \"dest_addr\" parameters are used in the\
    \ following\n   way for media delivery and playback mode, i.e., Mode=PLAY:\n \
    \  o  The \"src_addr\" and \"dest_addr\" parameters MUST contain either 1 or\n\
    \      2 address specifications.  Note that two address specifications\n     \
    \ MAY be provided even if RTP and RTCP multiplexing is negotiated.\n   o  Each\
    \ address specification for RTP/AVP/UDP or RTP/AVP/TCP MUST\n      contain either:\n\
    \      *  both an address and a port number, or\n      *  a port number without\
    \ an address.\n   o  The first address specification given in either of the parameters\n\
    \      applies to the RTP stream.  The second specification, if present,\n   \
    \   applies to the RTCP stream, unless in the case RTP and RTCP\n      multiplexing\
    \ is negotiated where both RTP and RTCP will use the\n      first specification.\n\
    \   o  The RTP/UDP packets from the server to the client MUST be sent to\n   \
    \   the address and port given by the first address specification of\n      the\
    \ \"dest_addr\" parameter.\n   o  The RTCP/UDP packets from the server to the\
    \ client MUST be sent to\n      the address and port given by the second address\
    \ specification of\n      the \"dest_addr\" parameter, unless RTP and RTCP multiplexing\
    \ has\n      been negotiated, in which case RTCP MUST be sent to the first\n \
    \     address specification.  If no second pair is specified and RTP and\n   \
    \   RTCP multiplexing has not been negotiated, RTCP MUST NOT be sent.\n   o  The\
    \ RTCP/UDP packets from the client to the server MUST be sent to\n      the address\
    \ and port given by the second address specification of\n      the \"src_addr\"\
    \ parameter, unless RTP and RTCP multiplexing has\n      been negotiated, in which\
    \ case RTCP MUST be sent to the first\n      address specification.  If no second\
    \ pair is specified and RTP and\n      RTCP multiplexing has not been negotiated,\
    \ RTCP MUST NOT be sent.\n   o  The RTP/UDP packets from the client to the server\
    \ MUST be sent to\n      the address and port given by the first address specification\
    \ of\n      the \"src_addr\" parameter.\n   o  RTP and RTCP packets SHOULD be\
    \ sent from the corresponding\n      receiver port, i.e., RTCP packets from the\
    \ server should be sent\n      from the \"src_addr\" parameters second address\
    \ port pair, unless\n      RTP and RTCP multiplexing has been negotiated in which\
    \ case the\n      first address port pair is used.\n"
- title: C.1.3.  AVPF/UDP
  contents:
  - "C.1.3.  AVPF/UDP\n   The RTP profile \"Extended RTP Profile for RTCP-based Feedback\
    \ (RTP/\n   AVPF)\" [RFC4585] MAY be used as RTP profiles in sessions using RTP.\n\
    \   All that is defined for AVP MUST also apply for AVPF.\n   The usage of AVPF\
    \ is indicated by the media initialization protocol\n   used.  In the case of\
    \ SDP, it is indicated by media lines (\"m=\")\n   containing the profile RTP/AVPF.\
    \  That SDP MAY also contain further\n   AVPF-related SDP attributes configuring\
    \ the AVPF session regarding\n   reporting interval and feedback messages to be\
    \ used [RFC4585].  This\n   configuration MUST be followed.\n"
- title: C.1.4.  SAVP/UDP
  contents:
  - "C.1.4.  SAVP/UDP\n   The RTP profile \"The Secure Real-time Transport Protocol\
    \ (SRTP)\"\n   [RFC3711] is an RTP profile (SAVP) that MAY be used in RTSP sessions\n\
    \   using RTP.  All that is defined for AVP MUST also apply for SAVP.\n   The\
    \ usage of SRTP requires that a security context be established.\n   The default\
    \ key-management unless otherwise signaled SHALL be MIKEY\n   in RSA-R mode as\
    \ defined in Appendix C.1.4.1 and not according to the\n   procedure defined in\
    \ \"Key Management Extensions for Session\n   Description Protocol (SDP) and Real\
    \ Time Streaming Protocol (RTSP)\"\n   [RFC4567].  The reason is that RFC 4567\
    \ sends the initial MIKEY\n   message in SDP, thus, both requiring the usage of\
    \ the DESCRIBE method\n   and forcing the server to keep state for clients performing\
    \ DESCRIBE\n   in anticipation that they might require key management.\n   MIKEY\
    \ is selected as the default method for establishing SRTP\n   cryptographic context\
    \ within an RTSP session as it can be embedded in\n   the RTSP messages while\
    \ still ensuring confidentiality of content of\n   the keying material, even when\
    \ using hop-by-hop TLS security for the\n   RTSP messages.  This method also supports\
    \ pipelining of the RTSP\n   messages.\n"
- title: C.1.4.1.  MIKEY Key Establishment
  contents:
  - "C.1.4.1.  MIKEY Key Establishment\n   This method for using MIKEY [RFC3830] to\
    \ establish the SRTP\n   cryptographic context is initiated in the client's SETUP\
    \ request, and\n   the server's response to the SETUP carries the MIKEY response.\
    \  This\n   ensures that the crypto context establishment happens simultaneously\n\
    \   with the establishment of the media stream being protected.  By using\n  \
    \ MIKEY's RSA-R mode [RFC4738] the client can be the initiator and\n   still allow\
    \ the server to set the parameters in accordance with the\n   actual media stream.\n\
    \   The SRTP cryptographic context establishment is done according to the\n  \
    \ following process:\n   1.   The client determines that SAVP or SAVPF shall be\
    \ used from the\n        media-description format, e.g., SDP.  If no other key-management\n\
    \        method is explicitly signaled, then MIKEY SHALL be used as\n        defined\
    \ herein.  The use of SRTP with RTSP is only defined with\n        MIKEY with\
    \ keys established as defined in this section.  Future\n        documents may\
    \ define how an RTSP implementation treats SDP that\n        indicates some other\
    \ key mechanism to be used.  The need for\n        such specification includes\
    \ [RFC4567], which is not defined for\n        use in RTSP 2.0 within this document.\n\
    \   2.   The client SHALL establish a TLS connection for RTSP messages,\n    \
    \    directly or hop-by-hop with the server.  If hop-by-hop TLS\n        security\
    \ is used, the User method SHALL be indicated in the\n        Accept-Credentials\
    \ header.  Note that using hop-by-hop does\n        allow the proxy to insert\
    \ itself as a man in the middle.  This\n        can also occur in the MIKEY exchange\
    \ by the proxy providing one\n        of its certificates rather than the server's\
    \ in the Connection-\n        Credentials header.  Therefore, the client SHALL\
    \ validate the\n        server certificate.\n   3.   The client retrieves the\
    \ server's certificate from a direct TLS\n        connection or hop-by-hop from\
    \ a Connection-Credentials header.\n        The client then checks that the server\
    \ certificate is valid and\n        belongs to the server.\n   4.   The client\
    \ forms the MIKEY Initiator message using RSA-R mode in\n        unicast mode\
    \ as specified in [RFC4738].  The client SHOULD use\n        the same certificate\
    \ for TLS and MIKEY to enable the server to\n        bind the two together.  The\
    \ client's certificate SHALL be\n        included in the MIKEY message.  The client\
    \ SHALL indicate its\n        SRTP capabilities in the message.\n   5.   The MIKEY\
    \ message from the previous step is base64-encoded\n        [RFC4648] and becomes\
    \ the value of the MIKEY parameter that is\n        included in the transport\
    \ specification(s) that specifies an\n        SRTP-based profile (SAVP, SAVPF)\
    \ in the SETUP request.\n   6.   Any proxy encountering the MIKEY parameter SHALL\
    \ forward it\n        without modification.  A proxy that is required to understand\n\
    \        the Transport specifications will need to understand SAVP/SAVPF\n   \
    \     with MIKEY to enable the default keying for SRTP-protected media\n     \
    \   streams.  If such a proxy does not support SAVP/SAVPF with\n        MIKEY,\
    \ it will discard the whole transport specification.  Most\n        types of proxies\
    \ can easily support SAVP and SAVPF with MIKEY.\n        If a client encounters\
    \ a proxy not supporting SAVP/SAVPF with\n        MIKEY, the client should attempt\
    \ bypassing that proxy.\n   7.   The server, upon receiving the SETUP request,\
    \ will need to\n        decide upon the transport specification to use, if multiple\
    \ are\n        included by the client.  In the determination of which transport\n\
    \        specifications are supported and preferred, the server SHOULD\n     \
    \   decode the MIKEY message to take the embedded SRTP parameters\n        into\
    \ account.  If all transport spec require SRTP but no MIKEY\n        parameter\
    \ or other supported keying method is included, the\n        server SHALL respond\
    \ with 403 (Forbidden).\n   8.   Upon generating a response, the following outcomes\
    \ can occur:\n        *  A transport spec not using SRTP and MIKEY is selected.\
    \  Thus,\n           the response will not contain any MIKEY parameters.\n   \
    \     *  A transport spec using SRTP and MIKEY is selected but an\n          \
    \ error is encountered in the MIKEY processing.  In this case,\n           an\
    \ RTSP error response code of 466 (Key Management Error)\n           SHALL be\
    \ used.  A MIKEY message describing the error MAY be\n           included.\n \
    \       *  A transport spec using SRTP and MIKEY is selected and a MIKEY\n   \
    \        response message can be created.  The server SHOULD use the\n       \
    \    same certificate for TLS and in MIKEY to enable the client to\n         \
    \  bind the two together.  If a different certificate is used,\n           it\
    \ SHALL be included in the MIKEY message.  It is RECOMMENDED\n           that\
    \ the envelope key-cache type be set to 'Cache' and that a\n           single\
    \ envelope key is reused for all MIKEY messages to the\n           client.  That\
    \ message is included in the MIKEY parameter part\n           of the single selected\
    \ transport specification in the SETUP\n           response.  The server will\
    \ set the SRTP parameters as\n           preferred for this media stream within\
    \ the supported range by\n           the client.\n   9.   The server transmits\
    \ the SETUP response back to the client.\n   10.  The client receives the SETUP\
    \ response and, if the response code\n        indicates a successful request,\
    \ it decodes the MIKEY message and\n        establishes the SRTP cryptographic\
    \ context from the parameters\n        in the MIKEY response.\n   In the above\
    \ method, the client's certificate may be self signed in\n   cases where the client's\
    \ identity is not necessary to authenticate\n   and the security goal is only\
    \ to ensure that the RTSP signaling\n   client is the same as the one receiving\
    \ the SRTP security context.\n"
- title: C.1.5.  SAVPF/UDP
  contents:
  - "C.1.5.  SAVPF/UDP\n   The RTP profile \"Extended Secure RTP Profile for Real-time\
    \ Transport\n   Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)\" [RFC5124]\
    \ is an\n   RTP profile (SAVPF) that MAY be used in RTSP sessions using RTP. \
    \ All\n   that is defined for AVPF MUST also apply for SAVPF.\n   The usage of\
    \ SRTP requires that a cryptographic context be\n   established.  The default\
    \ mechanism for establishing that security\n   association is to use MIKEY[RFC3830]\
    \ with RTSP as defined in\n   Appendix C.1.4.1.\n"
- title: C.1.6.  RTCP Usage with RTSP
  contents:
  - "C.1.6.  RTCP Usage with RTSP\n   RTCP has several usages when RTP is implemented\
    \ for media transport\n   as explained below.  Thus, RTCP MUST be supported if\
    \ an RTSP agent\n   handles RTP.\n"
- title: C.1.6.1.  Media Synchronization
  contents:
  - "C.1.6.1.  Media Synchronization\n   RTCP provides media synchronization and clock-drift\
    \ compensation.\n   The initial media synchronization is available from RTP-Info\
    \ header.\n   However, to be able to handle any clock drift between the media\n\
    \   streams, RTCP is needed.\n"
- title: C.1.6.2.  RTSP Session Keep-Alive
  contents:
  - "C.1.6.2.  RTSP Session Keep-Alive\n   RTCP traffic from the RTSP client to the\
    \ RTSP server MUST function as\n   keep-alive.  This requires an RTSP server supporting\
    \ RTP to use the\n   received RTCP packets as indications that the client desires\
    \ the\n   related RTSP session to be kept alive.\n"
- title: C.1.6.3.  Bitrate Adaption
  contents:
  - "C.1.6.3.  Bitrate Adaption\n   RTCP Receiver reports and any additional feedback\
    \ from the client\n   MUST be used to adapt the bitrate used over the transport\
    \ for all\n   cases when RTP is sent over UDP.  An RTP sender without reserved\n\
    \   resources MUST NOT use more than its fair share of the available\n   resources.\
    \  This can be determined by comparing on short-to-medium\n   terms (some seconds)\
    \ the used bitrate and adapting it so that the RTP\n   sender sends at a bitrate\
    \ comparable to what a TCP sender would\n   achieve on average over the same path.\n\
    \   To ensure that the implementation's adaptation mechanism has a well-\n   defined\
    \ outer envelope, all implementations using a non-congestion-\n   controlled unicast\
    \ transport protocol, like UDP, MUST implement\n   \"Multimedia Congestion Control:\
    \ Circuit Breakers for Unicast RTP\n   Sessions\" [RTP-CIRCUIT-BREAKERS].\n"
- title: C.1.6.4.  RTP and RTCP Multiplexing
  contents:
  - "C.1.6.4.  RTP and RTCP Multiplexing\n   RTSP can be used to negotiate the usage\
    \ of RTP and RTCP multiplexing\n   as described in [RFC5761].  This allows servers\
    \ and client to reduce\n   the amount of resources required for the session by\
    \ only requiring\n   one underlying transport stream per media stream instead\
    \ of two when\n   using RTP and RTCP.  This lessens the server-port consumption\
    \ and\n   also the necessary state and keep-alive work when operating across\n\
    \   NATs [RFC2663].\n   Content must be prepared with some consideration for RTP\
    \ and RTCP\n   multiplexing, mainly ensuring that the RTP payload types used do\
    \ not\n   collide with the ones used for RTCP packet types.  This option likely\n\
    \   needs explicit support from the content unless the RTP payload types\n   can\
    \ be remapped by the server and that is correctly reflected in the\n   session\
    \ description.  Beyond that, support of this feature should\n   come at little\
    \ cost and much gain.\n   It is recommended that, if the content and server support\
    \ RTP and\n   RTCP multiplexing, this is indicated in the session description,\
    \ for\n   example, using the SDP attribute \"a=rtcp-mux\".  If the SDP message\n\
    \   contains the \"a=rtcp-mux\" attribute for a media stream, the server\n   MUST\
    \ support RTP and RTCP multiplexing.  If indicated or otherwise\n   desired by\
    \ the client, it can include the Transport parameter \"RTCP-\n   mux\" in any\
    \ transport specification where it desires to use \"RTCP-\n   mux\".  The server\
    \ will indicate if it supports \"RTCP-mux\".  Servers\n   and Clients SHOULD support\
    \ RTP and RTCP multiplexing.\n   For capability exchange, an RTSP feature tag\
    \ for RTP and RTCP\n   multiplexing is defined: \"setup.rtp.rtcp.mux\".\n   To\
    \ minimize the risk of negotiation failure while using RTP and RTCP\n   multiplexing,\
    \ some recommendations are here provided.  If the session\n   description includes\
    \ explicit indication of support (\"a=rtcp-mux\" in\n   SDP), then an RTSP agent\
    \ can safely create a SETUP request with a\n   transport specification with only\
    \ a single \"dest_addr\" parameter\n   address specification.  If no such explicit\
    \ indication is provided,\n   then even if the feature tag \"setup.rtp.rtcp.mux\"\
    \ is provided in a\n   Supported header by the RTSP server or the feature tag\
    \ included in\n   the Required header in the SETUP request, the media resource\
    \ may not\n   support RTP and RTCP multiplexing.  Thus, to maximize the probability\n\
    \   of successful negotiation, the RTSP agent is recommended to include\n   two\
    \ \"dest_addr\" parameter address specifications in the first or\n   first set\
    \ (if pipelining is used) of SETUP request(s) for any media\n   resource aggregate.\
    \  That way, the RTSP server can accept RTP and\n   RTCP multiplexing and only\
    \ use the first address specification or, if\n   not, use both specifications.\
    \  The RTSP agent, after having received\n   the response for a successful negotiation\
    \ of the usage of RTP and\n   RTCP multiplexing, can then release the resources\
    \ associated with the\n   second address specification.\n"
- title: C.2.  RTP over TCP
  contents:
  - "C.2.  RTP over TCP\n   Transport of RTP over TCP can be done in two ways: over\
    \ independent\n   TCP connections using [RFC4571] or interleaved in the RTSP\n\
    \   connection.  In both cases, the protocol MUST be \"rtp\" and the lower-\n\
    \   layer MUST be TCP.  The profile may be any of the above specified\n   ones:\
    \ AVP, AVPF, SAVP, or SAVPF.\n"
- title: C.2.1.  Interleaved RTP over TCP
  contents:
  - "C.2.1.  Interleaved RTP over TCP\n   The use of embedded (interleaved) binary\
    \ data transported on the RTSP\n   connection is possible as specified in Section\
    \ 14.  When using this\n   declared combination of interleaved binary data, the\
    \ RTSP messages\n   MUST be transported over TCP.  TLS may or may not be used.\
    \  If TLS is\n   used, both RTSP messages and the binary data will be protected\
    \ by\n   TLS.\n   One should, however, consider that this will result in all media\n\
    \   streams going through any proxy.  Using independent TCP connections\n   can\
    \ avoid that issue.\n"
- title: C.2.2.  RTP over Independent TCP
  contents:
  - "C.2.2.  RTP over Independent TCP\n   In this section, the sending of RTP [RFC3550]\
    \ over lower-layer\n   transport TCP [RFC793] according to \"Framing Real-time\
    \ Transport\n   Protocol (RTP) and RTP Control Protocol (RTCP) Packets over\n\
    \   Connection-Oriented Transport\" [RFC4571] is described.  This section\n  \
    \ adapts the guidelines for using RTP over TCP within SIP/SDP [RFC4145]\n   to\
    \ work with RTSP.\n   A client codes the support of RTP over independent TCP by\
    \ specifying\n   an RTP/AVP/TCP transport option without an interleaved parameter\
    \ in\n   the Transport line of a SETUP request.  This transport option MUST\n\
    \   include the \"unicast\" parameter.\n   If the client wishes to use RTP with\
    \ RTCP, two address specifications\n   need to be included in the \"dest_addr\"\
    \ parameter.  If the client\n   wishes to use RTP without RTCP, one address specification\
    \ is included\n   in the \"dest_addr\" parameter.  If the client wishes to multiplex\
    \ RTP\n   and RTCP on a single transport flow (see Appendix C.1.6.4), one or\n\
    \   two address specifications are included in the \"dest_addr\" parameter\n \
    \  in addition to the \"RTCP-mux\" transport parameter.  Two address\n   specifications\
    \ are allowed to facilitate successful negotiation when\n   the server or content\
    \ can't support RTP and RTCP multiplexing.\n   Ordering rules of dest_addr ports\
    \ follow the rules for RTP/AVP/UDP.\n   If the client wishes to play the active\
    \ role in initiating the TCP\n   connection, it MAY set the setup parameter (see\
    \ Section 18.54) on the\n   Transport line to be \"active\", or it MAY omit the\
    \ setup parameter, as\n   active is the default.  If the client signals the active\
    \ role, the\n   ports in the address specifications in the \"dest_addr\" parameter\
    \ MUST\n   be set to 9 (the discard port).\n   If the client wishes to play the\
    \ passive role in TCP connection\n   initiation, it MUST set the setup parameter\
    \ on the Transport line to\n   be \"passive\".  If the client is able to assume\
    \ the active or the\n   passive role, it MUST set the setup parameter on the Transport\
    \ line\n   to be \"actpass\".  In either case, the \"dest_addr\" parameter's address\n\
    \   specification port value for RTP MUST be set to the TCP port number\n   on\
    \ which the client is expecting to receive the TCP connection for\n   RTP, and\
    \ the \"dest_addr\" address specification port value for RTCP\n   MUST be set\
    \ to the TCP port number on which the client is expecting\n   to receive the TCP\
    \ connection for RTCP.  In the case that the client\n   wishes to multiplex RTP\
    \ and RTCP on a single transport flow, the\n   \"RTCP-mux\" parameter is included\
    \ and one or two \"dest_addr\" parameter\n   address specifications are included,\
    \ as mentioned earlier in this\n   section.\n   Upon receipt of a non-interleaved\
    \ RTP/AVP/TCP SETUP request, if a\n   server decides to accept this requested\
    \ option, the 2xx reply MUST\n   contain a Transport option that specifies RTP/AVP/TCP\
    \ (without using\n   the interleaved parameter and using the unicast parameter).\
    \  The\n   \"dest_addr\" parameter value MUST be echoed from the parameter value\n\
    \   in the client request unless the destination address (only port) was\n   not\
    \ provided; in which case, the server MAY include the source\n   address of the\
    \ RTSP TCP connection with the port number unchanged.\n   In addition, the server\
    \ reply MUST set the setup parameter on the\n   Transport line, to indicate the\
    \ role the server will play in the\n   connection setup.  Permissible values are\
    \ \"active\" (if a client set\n   setup to \"passive\" or \"actpass\") and \"\
    passive\" (if a client set setup\n   to \"active\" or \"actpass\").\n   If a server\
    \ sets setup to \"passive\", the \"src_addr\" in the reply MUST\n   indicate the\
    \ ports on which the server is willing to receive a TCP\n   connection for RTP\
    \ and (if the client requested a TCP connection for\n   RTCP by specifying two\
    \ \"dest_addr\" address specifications) a TCP/\n   RTCP connection.  If a server\
    \ sets setup to \"active\", the ports\n   specified in \"src_addr\" address specifications\
    \ MUST be set to 9.  The\n   server MAY use the \"ssrc\" parameter, following\
    \ the guidance in\n   Section 18.54.  The server sets only one address specification\
    \ in the\n   case that the client has indicated only a single address\n   specification\
    \ or in case RTP and RTCP multiplexing was requested and\n   accepted by the server.\
    \  Port ordering for \"src_addr\" follows the\n   rules for RTP/AVP/UDP.\n   Servers\
    \ MUST support taking the passive role and MAY support taking\n   the active role.\
    \  Servers with a public IP address take the passive\n   role, thus enabling clients\
    \ behind NATs and firewalls a better chance\n   of successful connect to the server\
    \ by actively connecting outwards.\n   Therefore, the clients are RECOMMENDED\
    \ to take the active role.\n   After sending (receiving) a 2xx reply for a SETUP\
    \ method for a non-\n   interleaved RTP/AVP/TCP media stream, the active party\
    \ SHOULD\n   initiate the TCP connection as soon as possible.  The client MUST\
    \ NOT\n   send a PLAY request prior to the establishment of all the TCP\n   connections\
    \ negotiated using SETUP for the session.  In case the\n   server receives a PLAY\
    \ request in a session that has not yet\n   established all the TCP connections,\
    \ it MUST respond using the 464\n   (Data Transport Not Ready Yet) (Section 17.4.28)\
    \ error code.\n   Once the PLAY request for a media resource transported over\
    \ non-\n   interleaved RTP/AVP/TCP occurs, media begins to flow from server to\n\
    \   client over the RTP TCP connection, and RTCP packets flow\n   bidirectionally\
    \ over the RTCP TCP connection.  Unless RTP and RTCP\n   multiplexing has been\
    \ negotiated; in which case, RTP and RTCP will\n   flow over a common TCP connection.\
    \  As in the RTP/UDP case, client-\n   to-server traffic on an RTP-only TCP session\
    \ is unspecified by this\n   memo.  The packets that travel on these connections\
    \ MUST be framed\n   using the protocol defined in [RFC4571], not by the framing\
    \ defined\n   for interleaving RTP over the RTSP connection defined in Section\
    \ 14.\n   A successful PAUSE request for media being transported over RTP/AVP/\n\
    \   TCP pauses the flow of packets over the connections, without closing\n   the\
    \ connections.  A successful TEARDOWN request signals that the TCP\n   connections\
    \ for RTP and RTCP are to be closed by the RTSP client as\n   soon as possible.\n\
    \   Subsequent SETUP requests using a URI already set up in an RTSP\n   session\
    \ using an RTP/AVP/TCP transport specification may be ambiguous\n   in the following\
    \ way: does the client wish to open up a new TCP\n   connection for RTP or RTCP\
    \ for the URI, or does the client wish to\n   continue using the existing TCP\
    \ connections?  The client SHOULD use\n   the \"connection\" parameter (defined\
    \ in Section 18.54) on the\n   Transport line to make its intention clear (by\
    \ setting \"connection\"\n   to \"new\" if new connections are needed, and by\
    \ setting \"connection\"\n   to \"existing\" if the existing connections are to\
    \ be used).  After a\n   2xx reply for a SETUP request for a new connection, parties\
    \ should\n   close the preexisting connections, after waiting a suitable period\n\
    \   for any stray RTP or RTCP packets to arrive.\n   The usage of SRTP, i.e.,\
    \ either SAVP or SAVPF profiles, requires that\n   a security association be established.\
    \  The default mechanism for\n   establishing that security association is to\
    \ use MIKEY[RFC3830] with\n   RTSP as defined Appendix C.1.4.1.\n   Below, a rewritten\
    \ version of the example \"Media on Demand\"\n   (Appendix A.1) shows the use\
    \ of RTP/AVP/TCP non-interleaved:\n      C->M: DESCRIBE rtsp://example.com/twister.3gp\
    \ RTSP/2.0\n            CSeq: 1\n            User-Agent: PhonyClient/1.2\n   \
    \   M->C: RTSP/2.0 200 OK\n            CSeq: 1\n            Server: PhonyServer/1.0\n\
    \            Date: Wed, 23 Jan 2013 15:36:52 +0000\n            Content-Type:\
    \ application/sdp\n            Content-Length: 227\n            Content-Base:\
    \ rtsp://example.com/twister.3gp/\n            Expires: Thu, 24 Jan 2013 15:36:52\
    \ +0000\n            v=0\n            o=- 2890844256 2890842807 IN IP4 198.51.100.34\n\
    \            s=RTSP Session\n            i=An Example of RTSP Session Usage\n\
    \            e=adm@example.com\n            c=IN IP4 0.0.0.0\n            a=control:\
    \ *\n            a=range:npt=00:00:00-00:10:34.10\n            t=0 0\n       \
    \     m=audio 0 RTP/AVP 0\n            a=control: trackID=1\n      C->M: SETUP\
    \ rtsp://example.com/twister.3gp/trackID=1 RTSP/2.0\n            CSeq: 2\n   \
    \         User-Agent: PhonyClient/1.2\n            Require: play.basic\n     \
    \       Transport: RTP/AVP/TCP;unicast;dest_addr=\":9\"/\":9\";\n            \
    \           setup=active;connection=new\n            Accept-Ranges: npt, smpte,\
    \ clock\n      M->C: RTSP/2.0 200 OK\n            CSeq: 2\n            Server:\
    \ PhonyServer/1.0\n            Transport: RTP/AVP/TCP;unicast;\n             \
    \          dest_addr=\":9\"/\":9\";\n                       src_addr=\"198.51.100.5:53478\"\
    /\"198.51.100:54091\";\n                       setup=passive;connection=new;ssrc=93CB001E\n\
    \            Session: OccldOFFq23KwjYpAnBbUr\n            Expires: Thu, 24 Jan\
    \ 2013 15:36:52 +0000\n            Date: Wed, 23 Jan 2013 15:36:52 +0000\n   \
    \         Accept-Ranges: npt\n            Media-Properties: Random-Access=0.8,\
    \ Immutable, Unlimited\n      C->M: TCP Connection Establishment x2\n      C->M:\
    \ PLAY rtsp://example.com/twister.3gp/ RTSP/2.0\n            CSeq: 4\n       \
    \     User-Agent: PhonyClient/1.2\n            Range: npt=30-\n            Session:\
    \ OccldOFFq23KwjYpAnBbUr\n      M->C: RTSP/2.0 200 OK\n            CSeq: 4\n \
    \           Server: PhonyServer/1.0\n            Date: Wed, 23 Jan 2013 15:36:54\
    \ +0000\n            Session: OccldOFFq23KwjYpAnBbUr\n            Range: npt=30-623.10\n\
    \            Seek-Style: First-Prior\n            RTP-Info:  url=\"rtsp://example.com/twister.3gp/trackID=1\"\
    \n               ssrc=4F312DD8:seq=54321;rtptime=2876889\n"
- title: C.3.  Handling Media-Clock Time Jumps in the RTP Media Layer
  contents:
  - "C.3.  Handling Media-Clock Time Jumps in the RTP Media Layer\n   RTSP allows\
    \ media clients to control selected, non-contiguous\n   sections of media presentations,\
    \ rendering those streams with an RTP\n   media layer [RFC3550].  Two cases occur,\
    \ the first is when a new PLAY\n   request replaces an old ongoing request and\
    \ the new request results\n   in a jump in the media.  This should produce continuous\
    \ media stream\n   at the RTP layer.  A client may also immediately follow a completed\n\
    \   PLAY request with a new PLAY request.  This will result in some gap\n   in\
    \ the media layer.  The below text will look into both cases.\n   A PLAY request\
    \ that replaces an ongoing PLAY request allows the media\n   layer rendering the\
    \ RTP stream to do so continuously without being\n   affected by jumps in media-clock\
    \ time.  The RTP timestamps for the\n   new media range are set so that they become\
    \ continuous with the\n   previous media range in the previous request.  The RTP\
    \ sequence\n   number for the first packet in the new range will be the next\n\
    \   following the last packet in the previous range, i.e., monotonically\n   increasing.\
    \  The goal is to allow the media-rendering layer to work\n   without interruption\
    \ or reconfiguration across the jumps in media\n   clock.  This should be possible\
    \ in all cases of replaced PLAY\n   requests for media that has random access\
    \ properties.  In this case,\n   care is needed to align frames or similar media-dependent\
    \ structures.\n   In cases where jumps in media-clock time are a result of RTSP\n\
    \   signaling operations arriving after a completed PLAY operation, the\n   request\
    \ timing will result in that media becoming non-continuous.\n   The server becomes\
    \ unable to send the media so that it arrives timely\n   and still carries timestamps\
    \ to make the media stream continuous.  In\n   these situations, the server will\
    \ produce RTP streams where there are\n   gaps in the RTP timeline for the media.\
    \  If the media has frame\n   structure, aligning the timestamp for the next frame\
    \ with the\n   previous structure reduces the burden to render this media.  The\
    \ gap\n   should represent the time the server hasn't been serving media, e.g.,\n\
    \   the time between the end of the media stream or a PAUSE request and\n   the\
    \ new PLAY request.  In these cases, the RTP sequence number would\n   normally\
    \ be monotonically increasing across the gap.\n   For RTSP sessions with media\
    \ that lacks random access properties,\n   such as live streams, any media-clock\
    \ jump is commonly the result of\n   a correspondingly long pause of delivery.\
    \  The RTP timestamp will\n   have increased in direct proportion to the duration\
    \ of the paused\n   delivery.  Note also that in this case the RTP sequence number\
    \ should\n   be the next packet number.  If not, the RTCP packet loss reporting\n\
    \   will indicate as loss all packets not received between the point of\n   pausing\
    \ and later resuming.  This may trigger congestion avoidance\n   mechanisms. \
    \ An allowed exception from the above recommendation on\n   monotonically increasing\
    \ RTP sequence number is live media streams,\n   likely being relayed.  In this\
    \ case, when the client resumes\n   delivery, it will get the media that is currently\
    \ being delivered to\n   the server itself.  For this type of basic delivery of\
    \ live streams\n   to multiple users over unicast, individual rewriting of RTP\
    \ sequence\n   numbers becomes quite a burden.  For solutions that already cache\n\
    \   media or perform time shifting, the rewriting should impose only a\n   minor\
    \ burden.\n   The goal when handling jumps in media-clock time is that the provided\n\
    \   stream is continuous without gaps in RTP timestamp or sequence\n   number.\
    \  However, when delivery has been halted for some reason, the\n   RTP timestamp,\
    \ when resuming, MUST represent the duration that the\n   delivery was halted.\
    \  An RTP sequence number MUST generally be the\n   next number, i.e., monotonically\
    \ increasing modulo 65536.  For media\n   resources with the properties Time-Progressing\
    \ and Time-Duration=0.0,\n   the server MAY create RTP media streams with RTP\
    \ sequence number\n   jumps in them due to the client first halting delivery and\
    \ later\n   resuming it (PAUSE and then later PLAY).  However, servers utilizing\n\
    \   this exception must take into consideration the resulting RTCP\n   receiver\
    \ reports that likely contain loss reports for all the packets\n   that were a\
    \ part of the discontinuity.  A client cannot rely on the\n   fact that a server\
    \ will align when resuming play, even if it is\n   RECOMMENDED.  The RTP-Info\
    \ header will provide information on how the\n   server acts in each case.\n \
    \     One cannot assume that the RTSP client can communicate with the\n      RTP\
    \ media agent, as the two may be independent processes.  If the\n      RTP timestamp\
    \ shows the same gap as the NPT, the media agent will\n      assume that there\
    \ is a pause in the presentation.  If the jump in\n      NPT is large enough,\
    \ the RTP timestamp may roll over and the media\n      agent may believe later\
    \ packets to be duplicates of packets just\n      played out.  Having the RTP\
    \ timestamp jump will also affect the\n      RTCP measurements based on this.\n\
    \   As an example, assume an RTP timestamp frequency of 8000 Hz, a\n   packetization\
    \ interval of 100 ms, and an initial sequence number and\n   timestamp of zero.\n\
    \      C->S: PLAY rtsp://example.com/fizzle RTSP/2.0\n        CSeq: 4\n      \
    \  Session: ymIqLXufHkMHGdtENdblWK\n        Range: npt=10-15\n        User-Agent:\
    \ PhonyClient/1.2\n      S->C: RTSP/2.0 200 OK\n        CSeq: 4\n        Session:\
    \ ymIqLXufHkMHGdtENdblWK\n        Range: npt=10-15\n        RTP-Info: url=\"rtsp://example.com/fizzle/audiotrack\"\
    \n                  ssrc=0D12F123:seq=0;rtptime=0\n   The ensuing RTP data stream\
    \ is depicted below:\n      S -> C: RTP packet - seq = 0,  rtptime = 0,     NPT\
    \ time = 10s\n      S -> C: RTP packet - seq = 1,  rtptime = 800,   NPT time =\
    \ 10.1s\n       . . .\n      S -> C: RTP packet - seq = 49, rtptime = 39200, NPT\
    \ time = 14.9s\n   Upon the completion of the requested delivery, the server sends\
    \ a\n   PLAY_NOTIFY.\n        S->C: PLAY_NOTIFY rtsp://example.com/fizzle RTSP/2.0\n\
    \              CSeq: 5\n              Notify-Reason: end-of-stream\n         \
    \     Request-Status: cseq=4 status=200 reason=\"OK\"\n              Range: npt=-15\n\
    \              RTP-Info:url=\"rtsp://example.com/fizzle/audiotrack\"\n       \
    \          ssrc=0D12F123:seq=49;rtptime=39200\n              Session: ymIqLXufHkMHGdtENdblWK\n\
    \        C->S: RTSP/2.0 200 OK\n              CSeq: 5\n              User-Agent:\
    \ PhonyClient/1.2\n   Upon the completion of the play range, the client follows\
    \ up with a\n   request to PLAY from a new NPT.\n   C->S: PLAY rtsp://example.com/fizzle\
    \ RTSP/2.0\n         CSeq: 6\n         Session: ymIqLXufHkMHGdtENdblWK\n     \
    \    Range: npt=18-20\n         User-Agent: PhonyClient/1.2\n   S->C: RTSP/2.0\
    \ 200 OK\n         CSeq: 6\n         Session: ymIqLXufHkMHGdtENdblWK\n       \
    \  Range: npt=18-20\n         RTP-Info: url=\"rtsp://example.com/fizzle/audiotrack\"\
    \n                   ssrc=0D12F123:seq=50;rtptime=40100\n   The ensuing RTP data\
    \ stream is depicted below:\n      S->C: RTP packet - seq = 50, rtptime = 40100,\
    \ NPT time = 18s\n      S->C: RTP packet - seq = 51, rtptime = 40900, NPT time\
    \ = 18.1s\n       . . .\n      S->C: RTP packet - seq = 69, rtptime = 55300, NPT\
    \ time = 19.9s\n   In this example, first, NPT 10 through 15 are played, then\
    \ the client\n   requests the server to skip ahead and play NPT 18 through 20.\
    \  The\n   first segment is presented as RTP packets with sequence numbers 0\n\
    \   through 49 and timestamps 0 through 39,200.  The second segment\n   consists\
    \ of RTP packets with sequence numbers 50 through 69, with\n   timestamps 40,100\
    \ through 55,200.  While there is a gap in the NPT,\n   there is no gap in the\
    \ sequence-number space of the RTP data stream.\n   The RTP timestamp gap is present\
    \ in the above example due to the time\n   it takes to perform the second play\
    \ request, in this case, 12.5 ms\n   (100/8000).\n"
- title: C.4.  Handling RTP Timestamps after PAUSE
  contents:
  - "C.4.  Handling RTP Timestamps after PAUSE\n   During a PAUSE/PLAY interaction\
    \ in an RTSP session, the duration of\n   time for which the RTP transmission\
    \ was halted MUST be reflected in\n   the RTP timestamp of each RTP stream.  The\
    \ duration can be calculated\n   for each RTP stream as the time elapsed from\
    \ when the last RTP packet\n   was sent before the PAUSE request was received\
    \ and when the first RTP\n   packet was sent after the subsequent PLAY request\
    \ was received.  The\n   duration includes all latency incurred and processing\
    \ time required\n   to complete the request.\n      RFC 3550 [RFC3550] states\
    \ that: \"the RTP timestamp for each unit\n      [packet] would be related to\
    \ the wallclock time at which the unit\n      becomes current on the virtual presentation\
    \ timeline\".\n      In order to satisfy the requirements of [RFC3550], the RTP\n\
    \      timestamp space needs to increase continuously with real time.\n      While\
    \ this is not optimal for stored media, it is required for RTP\n      and RTCP\
    \ to function as intended.  Using a continuous RTP\n      timestamp space allows\
    \ the same timestamp model for both stored\n      and live media and allows better\
    \ opportunity to integrate both\n      types of media under a single control.\n\
    \   As an example, assume a clock frequency of 8000 Hz, a packetization\n   interval\
    \ of 100 ms, and an initial sequence number and timestamp of\n   zero.\n   C->S:\
    \ PLAY rtsp://example.com/fizzle RTSP/2.0\n         CSeq: 4\n         Session:\
    \ ymIqLXufHkMHGdtENdblWK\n         Range: npt=10-15\n         User-Agent: PhonyClient/1.2\n\
    \   S->C: RTSP/2.0 200 OK\n         CSeq: 4\n         Session: ymIqLXufHkMHGdtENdblWK\n\
    \         Range: npt=10-15\n         RTP-Info: url=\"rtsp://example.com/fizzle/audiotrack\"\
    \n                   ssrc=0D12F123:seq=0;rtptime=0\n   The ensuing RTP data stream\
    \ is depicted below:\n      S -> C: RTP packet - seq = 0, rtptime = 0,    NPT\
    \ time = 10s\n      S -> C: RTP packet - seq = 1, rtptime = 800,  NPT time = 10.1s\n\
    \      S -> C: RTP packet - seq = 2, rtptime = 1600, NPT time = 10.2s\n      S\
    \ -> C: RTP packet - seq = 3, rtptime = 2400, NPT time = 10.3s\n   The client\
    \ then sends a PAUSE request:\n   C->S: PAUSE rtsp://example.com/fizzle RTSP/2.0\n\
    \         CSeq: 5\n         Session: ymIqLXufHkMHGdtENdblWK\n         User-Agent:\
    \ PhonyClient/1.2\n   S->C: RTSP/2.0 200 OK\n         CSeq: 5\n         Session:\
    \ ymIqLXufHkMHGdtENdblWK\n         Range: npt=10.4-15\n   20 seconds elapse and\
    \ then the client sends a PLAY request.  In\n   addition, the server requires\
    \ 15 ms to process the request:\n   C->S: PLAY rtsp://example.com/fizzle RTSP/2.0\n\
    \         CSeq: 6\n         Session: ymIqLXufHkMHGdtENdblWK\n         User-Agent:\
    \ PhonyClient/1.2\n   S->C: RTSP/2.0 200 OK\n         CSeq: 6\n         Session:\
    \ ymIqLXufHkMHGdtENdblWK\n         Range: npt=10.4-15\n         RTP-Info: url=\"\
    rtsp://example.com/fizzle/audiotrack\"\n                   ssrc=0D12F123:seq=4;rtptime=164400\n\
    \   The ensuing RTP data stream is depicted below:\n      S -> C: RTP packet -\
    \ seq = 4, rtptime = 164400, NPT time = 10.4s\n      S -> C: RTP packet - seq\
    \ = 5, rtptime = 165200, NPT time = 10.5s\n      S -> C: RTP packet - seq = 6,\
    \ rtptime = 166000, NPT time = 10.6s\n   First, NPT 10 through 10.3 is played,\
    \ then a PAUSE is received by the\n   server.  After 20 seconds, a PLAY is received\
    \ by the server that\n   takes 15 ms to process.  The duration of time for which\
    \ the session\n   was paused is reflected in the RTP timestamp of the RTP packets\
    \ sent\n   after this PLAY request.\n   A client can use the RTSP Range header\
    \ and RTP-Info header to map NPT\n   time of a presentation with the RTP timestamp.\n\
    \   Note: in RFC 2326 [RFC2326], this matter was not clearly defined and\n   was\
    \ misunderstood commonly.  However, for RTSP 2.0, it is expected\n   that this\
    \ will be handled correctly and no exception handling will be\n   required.\n\
    \   Note further: it may be required to reset some of the state to ensure\n  \
    \ the correct media decoding and the usual jitter-buffer handling when\n   issuing\
    \ a PLAY request.\n"
- title: C.5.  RTSP/RTP Integration
  contents:
  - "C.5.  RTSP/RTP Integration\n   For certain data types, tight integration between\
    \ the RTSP layer and\n   the RTP layer will be necessary.  This by no means precludes\
    \ the\n   above restrictions.  Combined RTSP/RTP media clients should use the\n\
    \   RTP-Info field to determine whether incoming RTP packets were sent\n   before\
    \ or after a seek or before or after a PAUSE.\n"
- title: C.6.  Scaling with RTP
  contents:
  - "C.6.  Scaling with RTP\n   For scaling (see Section 18.46), RTP timestamps should\
    \ correspond to\n   the rendering timing.  For example, when playing video recorded\
    \ at 30\n   frames per second at a scale of two and speed (Section 18.50) of one,\n\
    \   the server would drop every second frame to maintain and deliver\n   video\
    \ packets with the normal timestamp spacing of 3,000 per frame,\n   but NPT would\
    \ increase by 1/15 second for each video frame.\n      Note: the above scaling\
    \ puts requirements on the media codec or a\n      media stream to support it.\
    \  For example, motion JPEG or other\n      non-predictive video coding can easier\
    \ handle the above example.\n"
- title: C.7.  Maintaining NPT Synchronization with RTP Timestamps
  contents:
  - "C.7.  Maintaining NPT Synchronization with RTP Timestamps\n   The client can\
    \ maintain a correct display of NPT by noting the RTP\n   timestamp value of the\
    \ first packet arriving after repositioning.\n   The sequence parameter of the\
    \ RTP-Info (Section 18.45) header\n   provides the first sequence number of the\
    \ next segment.\n"
- title: C.8.  Continuous Audio
  contents:
  - "C.8.  Continuous Audio\n   For continuous audio, the server SHOULD set the RTP\
    \ marker bit at the\n   beginning of serving a new PLAY request or at jumps in\
    \ timeline.\n   This allows the client to perform playout delay adaptation.\n"
- title: C.9.  Multiple Sources in an RTP Session
  contents:
  - "C.9.  Multiple Sources in an RTP Session\n   Note that more than one SSRC MAY\
    \ be sent in the media stream.  If it\n   happens, all sources are expected to\
    \ be rendered simultaneously.\n"
- title: C.10.  Usage of SSRCs and the RTCP BYE Message during an RTSP Session
  contents:
  - "C.10.  Usage of SSRCs and the RTCP BYE Message during an RTSP Session\n   The\
    \ RTCP BYE message indicates the end of use of a given SSRC.  If\n   all sources\
    \ leave an RTP session, it can, in most cases, be assumed\n   to have ended. \
    \ Therefore, a client or server MUST NOT send an RTCP\n   BYE message until it\
    \ has finished using a SSRC.  A server SHOULD keep\n   using an SSRC until the\
    \ RTP session is terminated.  Prolonging the\n   use of a SSRC allows the established\
    \ synchronization context\n   associated with that SSRC to be used to synchronize\
    \ subsequent PLAY\n   requests even if the PLAY response is late.\n   An SSRC\
    \ collision with the SSRC that transmits media does also have\n   consequences,\
    \ as it will normally force the media sender to change\n   its SSRC in accordance\
    \ with the RTP specification [RFC3550].\n   However, an RTSP server may wait and\
    \ see if the client changes and\n   thus resolve the conflict to minimize the\
    \ impact.  As media sender,\n   SSRC change will result in a loss of synchronization\
    \ context and\n   require any receiver to wait for RTCP sender reports for all\
    \ media\n   requiring synchronization before being able to play out synchronized.\n\
    \   Due to these reasons, a client joining a session should take care not\n  \
    \ to select the same SSRC(s) as the server indicates in the ssrc\n   Transport\
    \ header parameter.  Any SSRC signaled in the Transport\n   header MUST be avoided.\
    \  A client detecting a collision prior to\n   sending any RTP or RTCP messages\
    \ SHALL also select a new SSRC.\n"
- title: C.11.  Future Additions
  contents:
  - "C.11.  Future Additions\n   It is the intention that any future protocol or profile\
    \ regarding\n   media delivery and lower transport should be easy to add to RTSP.\n\
    \   This section provides the necessary steps that need to be met.\n   The following\
    \ things need to be considered when adding a new protocol\n   or profile for use\
    \ with RTSP:\n   o  The protocol or profile needs to define a name tag representing\n\
    \      it.  This tag is required to be an ABNF \"token\" to be possible to\n \
    \     use in the Transport header specification.\n   o  The useful combinations\
    \ of protocol, profiles, and lower-layer\n      transport for this extension need\
    \ to be defined.  For each\n      combination, declare the necessary parameters\
    \ to use in the\n      Transport header.\n   o  For new media protocols, the interaction\
    \ with RTSP needs to be\n      addressed.  One important factor will be the media\n\
    \      synchronization.  It may be necessary to have new headers similar\n   \
    \   to RTP info to carry this information.\n   o  Discussion needs to occur regarding\
    \ congestion control for media,\n      especially if transport without built-in\
    \ congestion control is\n      used.\n   See the IANA Considerations section (Section\
    \ 22) for information on\n   how to register new attributes.\n"
- title: Appendix D.  Use of SDP for RTSP Session Descriptions
  contents:
  - "Appendix D.  Use of SDP for RTSP Session Descriptions\n   The Session Description\
    \ Protocol (SDP, [RFC4566]) may be used to\n   describe streams or presentations\
    \ in RTSP.  This description is\n   typically returned in reply to a DESCRIBE\
    \ request on a URI from a\n   server to a client or received via HTTP from a server\
    \ to a client.\n   This appendix describes how an SDP file determines the operation\
    \ of\n   an RTSP session.  Thus, it is worth pointing out that the\n   interpretation\
    \ of the SDP is done in the context of the SDP receiver,\n   which is the one\
    \ being configured.  This is the same as in SAP\n   [RFC2974]; this differs from\
    \ SDP Offer/Answer [RFC3264] where each\n   SDP is interpreted in the context\
    \ of the agent providing it.\n   SDP as is provides no mechanism by which a client\
    \ can distinguish,\n   without human guidance, between several media streams to\
    \ be rendered\n   simultaneously and a set of alternatives (e.g., two audio streams\n\
    \   spoken in different languages).  The SDP extension found in \"The\n   Session\
    \ Description Protocol (SDP) Grouping Framework\" [RFC5888]\n   provides such\
    \ functionality to some degree.  Appendix D.4 describes\n   the usage of SDP media\
    \ line grouping for RTSP.\n"
- title: D.1.  Definitions
  contents:
  - "D.1.  Definitions\n   The terms \"session-level\", \"media-level\", and other\
    \ key/attribute\n   names and values used in this appendix are to be used as defined\
    \ in\n   SDP [RFC4566]:\n"
- title: D.1.1.  Control URI
  contents:
  - "D.1.1.  Control URI\n   The \"a=control\" attribute is used to convey the control\
    \ URI.  This\n   attribute is used both for the session and media descriptions.\
    \  If\n   used for individual media, it indicates the URI to be used for\n   controlling\
    \ that particular media stream.  If found at the session\n   level, the attribute\
    \ indicates the URI for aggregate control\n   (presentation URI).  The session-level\
    \ URI MUST be different from any\n   media-level URI.  The presence of a session-level\
    \ control attribute\n   MUST be interpreted as support for aggregated control.\
    \  The control\n   attribute MUST be present on the media level unless the presentation\n\
    \   only contains a single media stream; in which case, the attribute MAY\n  \
    \ be present on the session level only and then also apply to that\n   single\
    \ media stream.\n   ABNF for the attribute is defined in Section 20.3.\n   Example:\n\
    \     a=control:rtsp://example.com/foo\n   This attribute MAY contain either relative\
    \ or absolute URIs,\n   following the rules and conventions set out in RFC 3986\
    \ [RFC3986].\n   Implementations MUST look for a base URI in the following order:\n\
    \   1.  the RTSP Content-Base field;\n   2.  the RTSP Content-Location field;\n\
    \   3.  the RTSP Request-URI.\n   If this attribute contains only an asterisk\
    \ (*), then the URI MUST be\n   treated as if it were an empty embedded URI; thus,\
    \ it will inherit\n   the entire base URI.\n      Note: RFC 2326 was very unclear\
    \ on the processing of relative URIs\n      and several RTSP 1.0 implementations\
    \ at the point of publishing\n      this document did not perform RFC 3986 processing\
    \ to determine the\n      resulting URI; instead, simple concatenation is common.\
    \  To avoid\n      this issue completely, it is recommended to use absolute URIs\
    \ in\n      the SDP.\n   The URI handling for SDPs from container files needs\
    \ special\n   consideration.  For example, let's assume that a container file\
    \ has\n   the URI: \"rtsp://example.com/container.mp4\".  Let's further assume\n\
    \   this URI is the base URI and that there is an absolute media-level\n   URI:\
    \ \"rtsp://example.com/container.mp4/trackID=2\".  A relative media-\n   level\
    \ URI that resolves in accordance with RFC 3986 [RFC3986] to the\n   above given\
    \ media URI is \"container.mp4/trackID=2\".  It is usually\n   not desirable to\
    \ need to include or modify the SDP stored within the\n   container file with\
    \ the server local name of the container file.  To\n   avoid this, one can modify\
    \ the base URI used to include a trailing\n   slash, e.g., \"rtsp://example.com/container.mp4/\"\
    .  In this case, the\n   relative URI for the media will only need to be \"trackID=2\"\
    .\n   However, this will also mean that using \"*\" in the SDP will result in\n\
    \   the control URI including the trailing slash, i.e.,\n   \"rtsp://example.com/container.mp4/\"\
    .\n      Note: the usage of TrackID in the above is not a standardized\n     \
    \ form, but one example out of several similar strings such as\n      TrackID,\
    \ Track_ID, StreamID that is used by different server\n      vendors to indicate\
    \ a particular piece of media inside a container\n      file.\n"
- title: D.1.2.  Media Streams
  contents:
  - "D.1.2.  Media Streams\n   The \"m=\" field is used to enumerate the streams.\
    \  It is expected that\n   all the specified streams will be rendered with appropriate\n\
    \   synchronization.  If the session is over multicast, the port number\n   indicated\
    \ SHOULD be used for reception.  The client MAY try to\n   override the destination\
    \ port, through the Transport header.  The\n   servers MAY allow this: the response\
    \ will indicate whether or not\n   this is allowed.  If the session is unicast,\
    \ the port numbers are the\n   ones RECOMMENDED by the server to the client, about\
    \ which receiver\n   ports to use; the client MUST still include its receiver\
    \ ports in its\n   SETUP request.  The client MAY ignore this recommendation.\
    \  If the\n   server has no preference, it SHOULD set the port number value to\n\
    \   zero.\n   The \"m=\" lines contain information about which transport protocol,\n\
    \   profile, and possibly lower-layer are to be used for the media\n   stream.\
    \  The combination of transport, profile, and lower layer, like\n   RTP/AVP/UDP,\
    \ needs to be defined for how to be used with RTSP.  The\n   currently defined\
    \ combinations are discussed in Appendix C; further\n   combinations MAY be specified.\n\
    \   Example:\n     m=audio 0 RTP/AVP 31\n"
- title: D.1.3.  Payload Type(s)
  contents:
  - "D.1.3.  Payload Type(s)\n   The payload type or types are specified in the \"\
    m=\" line.  In case\n   the payload type is a static payload type from RFC 3551\
    \ [RFC3551], no\n   other information may be required.  In case it is a dynamic\
    \ payload\n   type, the media attribute \"rtpmap\" is used to specify what the\
    \ media\n   is.  The \"encoding name\" within the \"rtpmap\" attribute may be\
    \ one of\n   those specified in [RFC4856], a media type registered with IANA\n\
    \   according to [RFC4855], or an experimental encoding as specified in\n   SDP\
    \ [RFC4566]).  Codec-specific parameters are not specified in this\n   field,\
    \ but rather in the \"fmtp\" attribute described below.\n   The selection of the\
    \ RTP payload type numbers used may be required to\n   consider RTP and RTCP Multiplexing\
    \ [RFC5761], if that is to be\n   supported by the server.\n"
- title: D.1.4.  Format-Specific Parameters
  contents:
  - "D.1.4.  Format-Specific Parameters\n   Format-specific parameters are conveyed\
    \ using the \"fmtp\" media\n   attribute.  The syntax of the \"fmtp\" attribute\
    \ is specific to the\n   encoding(s) to which the attribute refers.  Note that\
    \ some of the\n   format-specific parameters may be specified outside of the \"\
    fmtp\"\n   parameters, for example, like the \"ptime\" attribute for most audio\n\
    \   encodings.\n"
- title: D.1.5.  Directionality of Media Stream
  contents:
  - "D.1.5.  Directionality of Media Stream\n   The SDP attributes \"a=sendrecv\"\
    , \"a=recvonly\", and \"a=sendonly\"\n   provide instructions about the direction\
    \ the media streams flow\n   within a session.  When using RTSP, the SDP can be\
    \ delivered to a\n   client using either RTSP DESCRIBE or a number of RTSP external\n\
    \   methods, like HTTP, FTP, and email.  Based on this, the SDP applies\n   to\
    \ how the RTSP client will see the complete session.  Thus, media\n   streams\
    \ delivered from the RTSP server to the client would be given\n   the \"a=recvonly\"\
    \ attribute.\n   \"a=recvonly\" in an SDP provided to the RTSP client indicates\
    \ that\n   media delivery will only occur in the direction from the RTSP server\n\
    \   to the client.  SDP provided to the RTSP client that lacks any of the\n  \
    \ directionality attributes (\"a=recvonly\", \"a=sendonly\", \"a=sendrecv\")\n\
    \   would be interpreted as having \"a=sendrecv\".  At the time of writing,\n\
    \   there exists no RTSP mode suitable for media traffic in the direction\n  \
    \ from the RTSP client to the server.  Thus, all RTSP SDP SHOULD have\n   an \"\
    a=recvonly\" attribute when using the PLAY mode defined in this\n   document.\
    \  If future modes are defined for media in the client-to-\n   server direction,\
    \ then usage of \"a=sendonly\" or \"a=sendrecv\" may\n   become suitable to indicate\
    \ intended media directions.\n"
- title: D.1.6.  Range of Presentation
  contents:
  - "D.1.6.  Range of Presentation\n   The \"a=range\" attribute defines the total\
    \ time range of the stored\n   session or an individual media.  Live sessions\
    \ that are not seekable\n   can be indicated as specified below; whereas the length\
    \ of live\n   sessions can be deduced from the \"t=\" and \"r=\" SDP parameters.\n\
    \   The attribute is both a session- and a media-level attribute.  For\n   presentations\
    \ that contain media streams of the same duration, the\n   range attribute SHOULD\
    \ only be used at the session level.  In case of\n   different lengths, the range\
    \ attribute MUST be given at media level\n   for all media and SHOULD NOT be given\
    \ at the session level.  If the\n   attribute is present at both media level and\
    \ session level, the\n   media-level values MUST be used.\n   Note: usually one\
    \ will specify the same length for all media, even if\n   there isn't media available\
    \ for the full duration on all media.\n   However, that requires that the server\
    \ accept PLAY requests within\n   that range.\n   Servers MUST take care to provide\
    \ RTSP Range (see Section 18.40)\n   values that are consistent with what is presented\
    \ in the SDP for the\n   content.  There is no reason for non dynamic content,\
    \ like media\n   clips provided on demand to have inconsistent values.  Inconsistent\n\
    \   values between the SDP and the actual values for the content handled\n   by\
    \ the server is likely to generate some failure, like 457 \"Invalid\n   Range\"\
    , in case the client uses PLAY requests with a Range header.\n   In case the content\
    \ is dynamic in length and it is infeasible to\n   provide a correct value in\
    \ the SDP, the server is recommended to\n   describe this as content that is not\
    \ seekable (see below).  The\n   server MAY override that property in the response\
    \ to a PLAY request\n   using the correct values in the Range header.\n   The\
    \ unit is specified first, followed by the value range.  The units\n   and their\
    \ values are as defined in Section 4.4.1, Section 4.4.2, and\n   Section 4.4.3\
    \ and MAY be extended with further formats.  Any open-\n   ended range (start-),\
    \ i.e., without stop range, is of unspecified\n   duration and MUST be considered\
    \ as content that is not seekable\n   unless this property is overridden.  Multiple\
    \ instances carrying\n   different clock formats MAY be included at either session\
    \ or media\n   level.\n   ABNF for the attribute is defined in Section 20.3.\n\
    \   Examples:\n     a=range:npt=0-34.4368\n     a=range:clock=19971113T211503Z-19971113T220300Z\n\
    \     Non-seekable stream of unknown duration:\n     a=range:npt=0-\n"
- title: D.1.7.  Time of Availability
  contents:
  - "D.1.7.  Time of Availability\n   The \"t=\" field defines when the SDP is valid.\
    \  For on-demand content,\n   the server SHOULD indicate a stop time value for\
    \ which it guarantees\n   the description to be valid and a start time that is\
    \ equal to or\n   before the time at which the DESCRIBE request was received.\
    \  It MAY\n   also indicate start and stop times of 0, meaning that the session\
    \ is\n   always available.\n   For sessions that are of live type, i.e., specific\
    \ start time,\n   unknown stop time, likely not seekable, the \"t=\" and \"r=\"\
    \ field\n   SHOULD be used to indicate the start time of the event.  The stop\n\
    \   time SHOULD be given so that the live event will have ended at that\n   time,\
    \ while still not being unnecessary far into the future.\n"
- title: D.1.8.  Connection Information
  contents:
  - "D.1.8.  Connection Information\n   In SDP used with RTSP, the \"c=\" field contains\
    \ the destination\n   address for the media stream.  If a multicast address is\
    \ specified,\n   the client SHOULD use this address in any SETUP request as\n\
    \   destination address, including any additional parameters, such as\n   TTL.\
    \  For on-demand unicast streams and some multicast streams, the\n   destination\
    \ address MAY be specified by the client via the SETUP\n   request, thus overriding\
    \ any specified address.  To identify streams\n   without a fixed destination\
    \ address, where the client is required to\n   specify a destination address,\
    \ the \"c=\" field SHOULD be set to a null\n   value.  For addresses of type \"\
    IP4\", this value MUST be \"0.0.0.0\";\n   and for type \"IP6\", this value MUST\
    \ be \"0:0:0:0:0:0:0:0\" (can also be\n   written as \"::\"), i.e., the unspecified\
    \ address according to RFC 4291\n   [RFC4291].\n"
- title: D.1.9.  Message Body Tag
  contents:
  - "D.1.9.  Message Body Tag\n   The optional \"a=mtag\" attribute identifies a version\
    \ of the session\n   description.  It is opaque to the client.  SETUP requests\
    \ may include\n   this identifier in the If-Match field (see Section 18.24) to\
    \ allow\n   session establishment only if this attribute value still corresponds\n\
    \   to that of the current description.  The attribute value is opaque\n   and\
    \ may contain any character allowed within SDP attribute values.\n   ABNF for\
    \ the attribute is defined in Section 20.3.\n   Example:\n     a=mtag:\"158bb3e7c7fd62ce67f12b533f06b83a\"\
    \n      One could argue that the \"o=\" field provides identical\n      functionality.\
    \  However, it does so in a manner that would put\n      constraints on servers\
    \ that need to support multiple session\n      description types other than SDP\
    \ for the same piece of media\n      content.\n"
- title: D.2.  Aggregate Control Not Available
  contents:
  - "D.2.  Aggregate Control Not Available\n   If a presentation does not support\
    \ aggregate control, no session-\n   level \"a=control\" attribute is specified.\
    \  For an SDP with multiple\n   media sections specified, each section will have\
    \ its own control URI\n   specified via the \"a=control\" attribute.\n   Example:\n\
    \   v=0\n   o=- 2890844256 2890842807 IN IP4 192.0.2.56\n   s=I came from a web\
    \ page\n   e=adm@example.com\n   c=IN IP4 0.0.0.0\n   t=0 0\n   m=video 8002 RTP/AVP\
    \ 31\n   a=control:rtsp://audio.example.com/movie.aud\n   m=audio 8004 RTP/AVP\
    \ 3\n   a=control:rtsp://video.example.com/movie.vid\n   Note that the position\
    \ of the control URI in the description implies\n   that the client establishes\
    \ separate RTSP control sessions to the\n   servers audio.example.com and video.example.com.\n\
    \   It is recommended that an SDP file contain the complete media-\n   initialization\
    \ information even if it is delivered to the media\n   client through non-RTSP\
    \ means.  This is necessary as there is no\n   mechanism to indicate that the\
    \ client should request more detailed\n   media stream information via DESCRIBE.\n"
- title: D.3.  Aggregate Control Available
  contents:
  - "D.3.  Aggregate Control Available\n   In this scenario, the server has multiple\
    \ streams that can be\n   controlled as a whole.  In this case, there are both\
    \ a media-level\n   \"a=control\" attribute, which is used to specify the stream\
    \ URIs, and\n   a session-level \"a=control\" attribute, which is used as the\
    \ Request-\n   URI for aggregate control.  If the media-level URI is relative,\
    \ it is\n   resolved to absolute URIs according to Appendix D.1.1 above.\n   Example:\n\
    \   C->M: DESCRIBE rtsp://example.com/movie RTSP/2.0\n         CSeq: 1\n     \
    \    User-Agent: PhonyClient/1.2\n   M->C: RTSP/2.0 200 OK\n         CSeq: 1\n\
    \         Date: Wed, 23 Jan 2013 15:36:52 +0000\n         Expires: Wed, 23 Jan\
    \ 2013 16:36:52 +0000\n         Content-Type: application/sdp\n         Content-Base:\
    \ rtsp://example.com/movie/\n         Content-Length: 227\n         v=0\n    \
    \     o=- 2890844256 2890842807 IN IP4 192.0.2.211\n         s=I contain\n   \
    \      i=<more info>\n         e=adm@example.com\n         c=IN IP4 0.0.0.0\n\
    \         a=control:*\n         t=0 0\n         m=video 8002 RTP/AVP 31\n    \
    \     a=control:trackID=1\n         m=audio 8004 RTP/AVP 3\n         a=control:trackID=2\n\
    \   In this example, the client is recommended to establish a single RTSP\n  \
    \ session to the server, and it uses the URIs rtsp://example.com/movie/\n   trackID=1\
    \ and rtsp://example.com/movie/trackID=2 to set up the video\n   and audio streams,\
    \ respectively.  The URI rtsp://example.com/movie/,\n   which is resolved from\
    \ the \"*\", controls the whole presentation\n   (movie).\n   A client is not\
    \ required to issue SETUP requests for all streams\n   within an aggregate object.\
    \  Servers should allow the client to ask\n   for only a subset of the streams.\n"
- title: D.4.  Grouping of Media Lines in SDP
  contents:
  - "D.4.  Grouping of Media Lines in SDP\n   For some types of media, it is desirable\
    \ to express a relationship\n   between various media components, for instance,\
    \ for lip\n   synchronization or Scalable Video Codec (SVC) [RFC5583].  This\n\
    \   relationship is expressed on the SDP level by grouping of media\n   lines,\
    \ as described in [RFC5888], and can be exposed to RTSP.\n   For RTSP, it is mainly\
    \ important to know how to handle grouped media\n   received by means of SDP,\
    \ i.e., if the media are under aggregate\n   control (see Appendix D.3) or if\
    \ aggregate control is not available\n   (see Appendix D.2).\n   It is RECOMMENDED\
    \ that grouped media are handled by aggregate\n   control, to give the client\
    \ the ability to control either the whole\n   presentation or single media.\n"
- title: D.5.  RTSP External SDP Delivery
  contents:
  - "D.5.  RTSP External SDP Delivery\n   There are some considerations that need\
    \ to be made when the session\n   description is delivered to the client outside\
    \ of RTSP, for example\n   via HTTP or email.\n   First of all, the SDP needs\
    \ to contain absolute URIs, since relative\n   will, in most cases, not work as\
    \ the delivery will not correctly\n   forward the base URI.\n   The writing of\
    \ the SDP session availability information, i.e., \"t=\"\n   and \"r=\", needs\
    \ to be carefully considered.  When the SDP is fetched\n   by the DESCRIBE method,\
    \ the probability that it is valid is very\n   high.  However, the same is much\
    \ less certain for SDPs distributed\n   using other methods.  Therefore, the publisher\
    \ of the SDP should take\n   care to follow the recommendations about availability\
    \ in the SDP\n   specification [RFC4566] in Section 4.2.\n"
- title: Appendix E.  RTSP Use Cases
  contents:
  - "Appendix E.  RTSP Use Cases\n   This appendix describes the most important and\
    \ considered use cases\n   for RTSP.  They are listed in descending order of importance\
    \ in\n   regard to ensuring that all necessary functionality is present.  This\n\
    \   specification only fully supports usage of the two first.  Also, in\n   these\
    \ first two cases, there are special cases or exceptions that are\n   not supported\
    \ without extensions, e.g., the redirection of media\n   delivery to an address\
    \ other than the controlling agent's (client's).\n"
- title: E.1.  On-Demand Playback of Stored Content
  contents:
  - "E.1.  On-Demand Playback of Stored Content\n   An RTSP-capable server stores\
    \ content suitable for being streamed to\n   a client.  A client desiring playback\
    \ of any of the stored content\n   uses RTSP to set up the media transport required\
    \ to deliver the\n   desired content.  RTSP is then used to initiate, halt, and\
    \ manipulate\n   the actual transmission (playout) of the content.  RTSP is also\n\
    \   required to provide the necessary description and synchronization\n   information\
    \ for the content.\n   The above high-level description can be broken down into\
    \ a number of\n   functions of which RTSP needs to be capable.\n   Presentation\
    \ Description:  Provide initialization information about\n         the presentation\
    \ (content); for example, which media codecs are\n         needed for the content.\
    \  Other information that is important\n         includes the number of media\
    \ streams the presentation contains,\n         the transport protocols used for\
    \ the media streams, and\n         identifiers for these media streams.  This\
    \ information is\n         required before setup of the content is possible and\
    \ to\n         determine if the client is even capable of using the content.\n\
    \         This information need not be sent using RTSP; other external\n     \
    \    protocols can be used to transmit the transport presentation\n         descriptions.\
    \  Two good examples are the use of HTTP [RFC7230]\n         or email to fetch\
    \ or receive presentation descriptions like SDP\n         [RFC4566]\n   Setup:\
    \  Set up some or all of the media streams in a presentation.\n         The setup\
    \ itself consists of selecting the protocol for media\n         transport and\
    \ the necessary parameters for the protocol, like\n         addresses and ports.\n\
    \   Control of Transmission:  After the necessary media streams have been\n  \
    \       established, the client can request the server to start\n         transmitting\
    \ the content.  The client must be allowed to start\n         or stop the transmission\
    \ of the content at arbitrary times.\n         The client must also be able to\
    \ start the transmission at any\n         point in the timeline of the presentation.\n\
    \   Synchronization:  For media-transport protocols like RTP [RFC3550],\n    \
    \     it might be beneficial to carry synchronization information\n         within\
    \ RTSP.  This may be due to either the lack of inter-media\n         synchronization\
    \ within the protocol itself or the potential\n         delay before the synchronization\
    \ is established (which is the\n         case for RTP when using RTCP).\n   Termination:\
    \  Terminate the established contexts.\n   For this use case, there are a number\
    \ of assumptions about how it\n   works.  These are:\n   On-Demand content:  The\
    \ content is stored at the server and can be\n         accessed at any time during\
    \ a time period when it is intended\n         to be available.\n   Independent\
    \ sessions:  A server is capable of serving a number of\n         clients simultaneously,\
    \ including from the same piece of\n         content at different points in that\
    \ presentations timeline.\n   Unicast Transport:  Content for each individual\
    \ client is transmitted\n         to them using unicast traffic.\n   It is also\
    \ possible to redirect the media traffic to a different\n   destination than that\
    \ of the agent controlling the traffic.  However,\n   allowing this without appropriate\
    \ mechanisms for checking that the\n   destination approves of this allows for\
    \ Distributed DoS (DDoS).\n"
- title: E.2.  Unicast Distribution of Live Content
  contents:
  - "E.2.  Unicast Distribution of Live Content\n   This use case is similar to the\
    \ above on-demand content case (see\n   Appendix E.1), the difference is the nature\
    \ of the content itself.\n   Live content is continuously distributed as it becomes\
    \ available from\n   a source; i.e., the main difference from on-demand is that\
    \ one starts\n   distributing content before the end of it has become available\
    \ to the\n   server.\n   In many cases, the consumer of live content is only interested\
    \ in\n   consuming what actually happens \"now\"; i.e., very similar to\n   broadcast\
    \ TV.  However, in this case, it is assumed that there exists\n   no broadcast\
    \ or multicast channel to the users, and instead the\n   server functions as a\
    \ distribution node, sending the same content to\n   multiple receivers, using\
    \ unicast traffic between server and client.\n   This unicast traffic and the\
    \ transport parameters are individually\n   negotiated for each receiving client.\n\
    \   Another aspect of live content is that it often has a very limited\n   time\
    \ of availability, as it is only available for the duration of the\n   event the\
    \ content covers.  An example of such live content could be a\n   music concert\
    \ that lasts two hours and starts at a predetermined\n   time.  Thus, there is\
    \ a need to announce when and for how long the\n   live content is available.\n\
    \   In some cases, the server providing live content may be saving some\n   or\
    \ all of the content to allow clients to pause the stream and resume\n   it from\
    \ the paused point, or to \"rewind\" and play continuously from a\n   point earlier\
    \ than the live point.  Hence, this use case does not\n   necessarily exclude\
    \ playing from other than the live point of the\n   stream, playing with scales\
    \ other than 1.0, etc.\n"
- title: E.3.  On-Demand Playback Using Multicast
  contents:
  - "E.3.  On-Demand Playback Using Multicast\n   It is possible to use RTSP to request\
    \ that media be delivered to a\n   multicast group.  The entity setting up the\
    \ session (the controller)\n   will then control when and what media is delivered\
    \ to the group.\n   This use case has some potential for DoS attacks by flooding\
    \ a\n   multicast group.  Therefore, a mechanism is needed to indicate that\n\
    \   the group actually accepts the traffic from the RTSP server.\n   An open issue\
    \ in this use case is how one ensures that all receivers\n   listening to the\
    \ multicast or broadcast receives the session\n   presentation configuring the\
    \ receivers.  This specification has to\n   rely on an external solution to solve\
    \ this issue.\n"
- title: E.4.  Inviting an RTSP Server into a Conference
  contents:
  - "E.4.  Inviting an RTSP Server into a Conference\n   If one has an established\
    \ conference or group session, it is possible\n   to have an RTSP server distribute\
    \ media to the whole group.\n   Transmission to the group is simplest when controlled\
    \ by a single\n   participant or leader of the conference.  Shared control might\
    \ be\n   possible, but would require further investigation and possibly\n   extensions.\n\
    \   This use case assumes that there exists either a multicast or a\n   conference\
    \ focus that redistributes media to all participants.\n   This use case is intended\
    \ to be able to handle the following\n   scenario: a conference leader or participant\
    \ (hereafter called the\n   \"controller\") has some pre-stored content on an\
    \ RTSP server that he\n   wants to share with the group.  The controller sets\
    \ up an RTSP\n   session at the streaming server for this content and retrieves\
    \ the\n   session description for the content.  The destination for the media\n\
    \   content is set to the shared multicast group or conference focus.\n   When\
    \ desired by the controller, he/she can start and stop the\n   transmission of\
    \ the media to the conference group.\n   There are several issues with this use\
    \ case that are not solved by\n   this core specification for RTSP:\n   DoS: \
    \ To avoid an RTSP server from being an unknowing participant in\n         a DoS\
    \ attack, the server needs to be able to verify the\n         destination's acceptance\
    \ of the media.  Such a mechanism to\n         verify the approval of received\
    \ media does not yet exist;\n         instead, only policies can be used, which\
    \ can be made to work\n         in controlled environments.\n   Distributing the\
    \ presentation description to all participants in the\n   group:\n           \
    \ To enable a media receiver to correctly decode the content,\n            the\
    \ media configuration information needs to be distributed\n            reliably\
    \ to all participants.  This will most likely require\n            support from\
    \ an external protocol.\n      Passing control of the session:  If it is desired\
    \ to pass control\n            of the RTSP session between the participants, some\
    \ support\n            will be required by an external protocol to exchange state\n\
    \            information and possibly floor control of who is controlling\n  \
    \          the RTSP session.\n"
- title: E.5.  Live Content Using Multicast
  contents:
  - "E.5.  Live Content Using Multicast\n   This use case in its simplest form does\
    \ not require any use of RTSP\n   at all; this is what multicast conferences being\
    \ announced with SAP\n   [RFC2974] and SDP are intended to handle.  However, in\
    \ use cases\n   where more advanced features like access control to the multicast\n\
    \   session are desired, RTSP could be used for session establishment.\n   A client\
    \ desiring to join a live multicasted media session with\n   cryptographic (encryption)\
    \ access control could use RTSP in the\n   following way.  The source of the session\
    \ announces the session and\n   gives all interested an RTSP URI.  The client\
    \ connects to the server\n   and requests the presentation description, allowing\
    \ configuration for\n   reception of the media.  In this step, it is possible\
    \ for the client\n   to use secured transport and any desired level of authentication;\
    \ for\n   example, for billing or access control.  An RTSP link also allows for\n\
    \   load balancing between multiple servers.\n   If these were the only goals,\
    \ they could be achieved by simply using\n   HTTP.  However, for cases where the\
    \ sender likes to keep track of\n   each individual receiver of a session, and\
    \ possibly use the session\n   as a side channel for distributing key-updates\
    \ or other information\n   on a per-receiver basis, and the full set of receivers\
    \ is not known\n   prior to the session start, the state establishment that RTSP\n\
    \   provides can be beneficial.  In this case, a client would establish\n   an\
    \ RTSP session for this multicast group with the RTSP server.  The\n   RTSP server\
    \ will not transmit any media, but instead will point to\n   the multicast group.\
    \  The client and server will be able to keep the\n   session alive for as long\
    \ as the receiver participates in the session\n   thus enabling, for example,\
    \ the server to push updates to the client.\n   This use case will most likely\
    \ not be able to be implemented without\n   some extensions to the server-to-client\
    \ push mechanism.  Here the\n   PLAY_NOTIFY method (see Section 13.5) with a suitable\
    \ extension could\n   provide clear benefits.\n"
- title: Appendix F.  Text Format for Parameters
  contents:
  - "Appendix F.  Text Format for Parameters\n   A resource of type \"text/parameters\"\
    \ consists of either 1) a list of\n   parameters (for a query) or 2) a list of\
    \ parameters and associated\n   values (for a response or setting of the parameter).\
    \  Each entry of\n   the list is a single line of text.  Parameters are separated\
    \ from\n   values by a colon.  The parameter name MUST only use US-ASCII visible\n\
    \   characters while the values are UTF-8 text strings.  The media type\n   registration\
    \ form is in Section 22.16.\n   There is a potential interoperability issue for\
    \ this format.  It was\n   named in RFC 2326 but never defined, even if used in\
    \ examples that\n   hint at the syntax.  This format matches the purpose and its\
    \ syntax\n   supports the examples provided.  However, it goes further by allowing\n\
    \   UTF-8 in the value part; thus, usage of UTF-8 strings may not be\n   supported.\
    \  However, as individual parameters are not defined, the\n   implementing application\
    \ needs to have out-of-band agreement or using\n   feature tag anyway to determine\
    \ if the endpoint supports the\n   parameters.\n   The ABNF [RFC5234] grammar\
    \ for \"text/parameters\" content is:\n   file             = *((parameter / parameter-value)\
    \ CRLF)\n   parameter        = 1*visible-except-colon\n   parameter-value  = parameter\
    \ *WSP \":\" value\n   visible-except-colon = %x21-39 / %x3B-7E    ; VCHAR - \"\
    :\"\n   value            = *(TEXT-UTF8char / WSP)\n   TEXT-UTF8char    = <as defined\
    \ in Section 20.1>\n   WSP              = <See RFC 5234> ; Space or HTAB\n   VCHAR\
    \            = <See RFC 5234>\n   CRLF             = <See RFC 5234>\n"
- title: Appendix G.  Requirements for Unreliable Transport of RTSP
  contents:
  - "Appendix G.  Requirements for Unreliable Transport of RTSP\n   This appendix\
    \ provides guidance for those who want to implement RTSP\n   messages over unreliable\
    \ transports as has been defined in RTSP 1.0\n   [RFC2326].  RFC 2326 defined\
    \ the \"rtspu\" URI scheme and provided some\n   basic information for the transport\
    \ of RTSP messages over UDP.  The\n   information is being provided here as there\
    \ has been at least one\n   commercial implementation and compatibility with that\
    \ should be\n   maintained.\n   The following points should be considered for\
    \ an interoperable\n   implementation:\n   o  Requests shall be acknowledged by\
    \ the receiver.  If there is no\n      acknowledgement, the sender may resend\
    \ the same message after a\n      timeout of one round-trip time (RTT).  Any retransmissions\
    \ due to\n      lack of acknowledgement must carry the same sequence number as\
    \ the\n      original request.\n   o  The RTT can be estimated as in TCP (RFC\
    \ 6298) [RFC6298], with an\n      initial round-trip value of 500 ms.  An implementation\
    \ may cache\n      the last RTT measurement as the initial value for future\n\
    \      connections.\n   o  The Timestamp header (Section 18.53) is used to avoid\
    \ the\n      retransmission ambiguity problem [Stevens98].\n   o  The registered\
    \ default port for RTSP over UDP for the server is\n      554.\n   o  RTSP messages\
    \ can be carried over any lower-layer transport\n      protocol that is 8-bit\
    \ clean.\n   o  RTSP messages are vulnerable to bit errors and should not be\n\
    \      subjected to them.\n   o  Source authentication, or at least validation\
    \ that RTSP messages\n      comes from the same entity becomes extremely important,\
    \ as session\n      hijacking may be substantially easier for RTSP message transport\n\
    \      using an unreliable protocol like UDP than for TCP.\n   There are two RTSP\
    \ headers that are primarily intended for being used\n   by the unreliable handling\
    \ of RTSP messages and which will be\n   maintained:\n   o  CSeq: See Section\
    \ 18.20.  It should be noted that the CSeq header\n      is also required to match\
    \ requests and responses independent\n      whether a reliable or unreliable transport\
    \ is used.\n   o  Timestamp: See Section 18.53\n"
- title: Appendix H.  Backwards-Compatibility Considerations
  contents:
  - "Appendix H.  Backwards-Compatibility Considerations\n   This section contains\
    \ notes on issues about backwards compatibility\n   with clients or servers being\
    \ implemented according to RFC 2326\n   [RFC2326].  Note that there exists no\
    \ requirement to implement RTSP\n   1.0; in fact, this document recommends against\
    \ it as it is difficult\n   to do in an interoperable way.\n   A server implementing\
    \ RTSP 2.0 MUST include an RTSP-Version of\n   \"RTSP/2.0\" in all responses to\
    \ requests containing RTSP-Version value\n   of \"RTSP/2.0\".  If a server receives\
    \ an RTSP 1.0 request, it MAY\n   respond with an RTSP 1.0 response if it chooses\
    \ to support RFC 2326.\n   If the server chooses not to support RFC 2326, it MUST\
    \ respond with a\n   505 (RTSP Version Not Supported) status code.  A server MUST\
    \ NOT\n   respond to an RTSP 1.0 request with an RTSP 2.0 response.\n   Clients\
    \ implementing RTSP 2.0 MAY use an OPTIONS request with an\n   RTSP-Version of\
    \ \"RTSP/2.0\" to determine whether a server supports\n   RTSP 2.0.  If the server\
    \ responds with either an RTSP-Version of\n   \"RTSP/1.0\" or a status code of\
    \ 505 (RTSP Version Not Supported), the\n   client will have to use RTSP 1.0 requests\
    \ if it chooses to support\n   RFC 2326.\n"
- title: H.1.  Play Request in Play State
  contents:
  - "H.1.  Play Request in Play State\n   The behavior in the server when a Play is\
    \ received in Play state has\n   changed (Section 13.4).  In RFC 2326, the new\
    \ PLAY request would be\n   queued until the current Play completed.  Any new\
    \ PLAY request now\n   takes effect immediately replacing the previous request.\n"
- title: H.2.  Using Persistent Connections
  contents:
  - "H.2.  Using Persistent Connections\n   Some server implementations of RFC 2326\
    \ maintain a one-to-one\n   relationship between a connection and an RTSP session.\
    \  Such\n   implementations require clients to use a persistent connection to\n\
    \   communicate with the server and when a client closes its connection,\n   the\
    \ server may remove the RTSP session.  This is worth noting if an\n   RTSP 2.0\
    \ client also supporting 1.0 connects to a 1.0 server.\n"
- title: Appendix I.  Changes
  contents:
  - "Appendix I.  Changes\n   This appendix briefly lists the differences between\
    \ RTSP 1.0\n   [RFC2326] and RTSP 2.0 for an informational purpose.  For\n   implementers\
    \ of RTSP 2.0, it is recommended to read carefully through\n   this memo and not\
    \ to rely on the list of changes below to adapt from\n   RTSP 1.0 to RTSP 2.0,\
    \ as RTSP 2.0 is not intended to be backwards\n   compatible with RTSP 1.0 [RFC2326]\
    \ other than the version negotiation\n   mechanism.\n"
- title: I.1.  Brief Overview
  contents:
  - "I.1.  Brief Overview\n   The following protocol elements were removed in RTSP\
    \ 2.0 compared to\n   RTSP 1.0:\n   o  the RECORD and ANNOUNCE methods and all\
    \ related functionality\n      (including 201 (Created) and 250 (Low On Storage\
    \ Space) status\n      codes);\n   o  the use of UDP for RTSP message transport\
    \ (due to missing interest\n      and to broken specification);\n   o  the use\
    \ of PLAY method for keep-alive in Play state.\n   The following protocol elements\
    \ were added or changed in RTSP 2.0\n   compared to RTSP 1.0:\n   o  RTSP session\
    \ TEARDOWN from the server to the client;\n   o  IPv6 support;\n   o  extended\
    \ IANA registries (e.g., transport headers parameters,\n      transport-protocol,\
    \ profile, lower-transport, and mode);\n   o  request pipelining for quick session\
    \ start-up;\n   o  fully reworked state machine;\n   o  RTSP messages now use\
    \ URIs rather than URLs;\n   o  incorporated much of related HTTP text ([RFC2616])\
    \ in this memo,\n      compared to just referencing the sections in HTTP, to avoid\n\
    \      ambiguities;\n   o  the REDIRECT method was expanded and diversified for\
    \ different\n      situations;\n   o  Includes a new section about how to set\
    \ up different media-\n      transport alternatives and their profiles in addition\
    \ to lower-\n      layer protocols.  This caused the appendix on RTP interaction\
    \ to\n      be moved to the new section instead of being in the part that\n  \
    \    describes RTP.  The section also includes guidelines what to\n      consider\
    \ when writing usage guidelines for new protocols and\n      profiles;\n   o \
    \ Added an asynchronous notification method PLAY_NOTIFY.  This\n      method is\
    \ used by the RTSP server to asynchronously notify clients\n      about session\
    \ changes while in Play state.  To a limited extent,\n      this is comparable\
    \ with some implementations of ANNOUNCE in RTSP\n      1.0 not intended for Recording.\n"
- title: I.2.  Detailed List of Changes
  contents:
  - "I.2.  Detailed List of Changes\n   The below changes have been made to RTSP 1.0\
    \ (RFC 2326) when defining\n   RTSP 2.0.  Note that this list does not reflect\
    \ minor changes in\n   wording or correction of typographical errors.\n   o  The\
    \ section on minimal implementation was deleted.  Instead, the\n      main part\
    \ of the specification defines the core of RTSP 2.0.\n   o  The Transport header\
    \ has been changed in the following ways:\n      *  The ABNF has been changed\
    \ to define that extensions are\n         possible and that unknown parameters\
    \ result in servers ignoring\n         the transport specification.\n      * \
    \ To prevent backwards compatibility issues, any extension or new\n         parameter\
    \ requires the usage of a feature tag combined with the\n         Require header.\n\
    \      *  Syntax ambiguities with the Mode parameter have been resolved.\n   \
    \   *  Syntax error with \";\" for multicast and unicast has been\n         resolved.\n\
    \      *  Two new addressing parameters have been defined: src_addr and\n    \
    \     dest_addr.  These replace the parameters \"port\", \"client_port\",\n  \
    \       \"server_port\", \"destination\", and \"source\".\n      *  Support for\
    \ IPv6 explicit addresses in all address fields has\n         been included.\n\
    \      *  To handle URI definitions that contain \";\" or \",\", a quoted-URI\n\
    \         format has been introduced and is required.\n      *  IANA registries\
    \ for the transport header parameters, transport-\n         protocol, profile,\
    \ lower-transport, and mode have been defined.\n      *  The Transport header's\
    \ interleaved parameter's text was made\n         more strict and uses formal\
    \ requirements levels.  It was also\n         clarified that the interleaved channels\
    \ are symmetric and that\n         it is the server that sets the channel numbers.\n\
    \      *  It has been clarified that the client can't request of the\n       \
    \  server to use a certain RTP SSRC, using a request with the\n         transport\
    \ parameter SSRC.\n      *  Syntax definition for SSRC has been clarified to require\
    \ 8HEX.\n         It has also been extended to allow multiple values for clients\n\
    \         supporting this version.\n      *  Clarified the text on the Transport\
    \ header's \"dest_addr\"\n         parameters regarding what security precautions\
    \ the server is\n         required to perform.\n   o  The Range formats have been\
    \ changed in the following way:\n      *  The NPT format has been given an initial\
    \ NPT identifier that\n         must now be used.\n      *  All formats now support\
    \ initial open-ended formats of type\n         \"npt=-10\" and also format only\
    \ \"Range: smpte\" ranges for usage\n         with GET_PARAMETER requests.\n \
    \     *  The npt-hhmmss notation now follows ISO 8601 more strictly.\n   o  RTSP\
    \ message handling has been changed in the following ways:\n      *  RTSP messages\
    \ now use URIs rather than URLs.\n      *  It has been clarified that a 4xx message\
    \ due to a missing CSeq\n         header shall be returned without a CSeq header.\n\
    \      *  The 300 (Multiple Choices) response code has been removed.\n      *\
    \  Rules for how to handle the timing out RTSP messages have been\n         added.\n\
    \      *  Extended Pipelining rules allowing for quick session startup.\n    \
    \  *  Sequence numbering and proxy handling of sequence numbers have\n       \
    \  been defined, including cases when responses arrive out of\n         order.\n\
    \   o  The HTTP references have been updated to first RFCs 2616 and 2617\n   \
    \   and then to RFC 7230-7235.  Most of the text has been copied and\n      then\
    \ altered to fit RTSP into this specification.  The Public and\n      the Content-Base\
    \ headers have also been imported from RFC 2068 so\n      that they are defined\
    \ in the RTSP specification.  Known effects on\n      RTSP due to HTTP clarifications:\n\
    \      *  Content-Encoding header can include encoding of type\n         \"identity\"\
    .\n   o  The state machine section has been completely rewritten.  It now\n  \
    \    includes more details and is also more clear about the model used.\n   o\
    \  An IANA section has been included that contains a number of\n      registries\
    \ and their rules.  This will allow us to use IANA to\n      keep track of RTSP\
    \ extensions.\n   o  The transport of RTSP messages has seen the following changes:\n\
    \      *  The use of UDP for RTSP message transport has been deprecated\n    \
    \     due to missing interest and to broken specification.\n      *  The rules\
    \ for how TCP connections are to be handled have been\n         clarified.  Now\
    \ it is made clear that servers should not close\n         the TCP connection\
    \ unless they have been unused for significant\n         time.\n      *  Strong\
    \ recommendations why servers and clients should use\n         persistent connections\
    \ have also been added.\n      *  There is now a requirement on the servers to\
    \ handle non-\n         persistent connections as this provides fault tolerance.\n\
    \      *  Added wording on the usage of Connection:Close for RTSP.\n      *  Specified\
    \ usage of TLS for RTSP messages, including a scheme to\n         approve a proxy's\
    \ TLS connection to the next hop.\n   o  The following header-related changes\
    \ have been made:\n      *  Accept-Ranges response-header has been added.  This\
    \ header\n         clarifies which range formats can be used for a resource.\n\
    \      *  Fixed the missing definitions for the Cache-Control header.\n      \
    \   Also added to the syntax definition the missing delta-seconds\n         for\
    \ max-stale and min-fresh parameters.\n      *  Put requirement on CSeq header\
    \ that the value is increased by\n         one for each new RTSP request.  A recommendation\
    \ to start at 0\n         has also been added.\n      *  Added a requirement that\
    \ the Date header must be used for all\n         messages with a message body\
    \ and the Server should always\n         include it.\n      *  Removed the possibility\
    \ of using Range header with Scale header\n         to indicate when it is to\
    \ be activated, since it can't work as\n         defined.  Also, added a rule\
    \ that lack of Scale header in a\n         response indicates lack of support\
    \ for the header.  feature\n         tags for scaled playback have been defined.\n\
    \      *  The Speed header must now be responded to in order to indicate\n   \
    \      support and the actual speed going to be used.  A feature tag\n       \
    \  is defined.  Notes on congestion control were also added.\n      *  The Supported\
    \ header was borrowed from SIP [RFC3261] to help\n         with the feature negotiation\
    \ in RTSP.\n      *  Clarified that the Timestamp header can be used to resolve\n\
    \         retransmission ambiguities.\n      *  The Session header text has been\
    \ expanded with an explanation\n         on keep-alive and which methods to use.\
    \  SET_PARAMETER is now\n         recommended to use if only keep-alive within\
    \ RTSP is desired.\n      *  It has been clarified how the Range header formats\
    \ are used to\n         indicate pause points in the PAUSE response.\n      *\
    \  Clarified that RTP-Info URIs that are relative use the Request-\n         URI\
    \ as base URI.  Also clarified that the used URI must be the\n         one that\
    \ was used in the SETUP request.  The URIs are now also\n         required to\
    \ be quoted.  The header also expresses the SSRC for\n         the provided RTP\
    \ timestamp and sequence number values.\n      *  Added text that requires the\
    \ Range to always be present in PLAY\n         responses.  Clarified what should\
    \ be sent in case of live\n         streams.\n      *  The headers table has been\
    \ updated using a structure borrowed\n         from SIP.  Those tables convey\
    \ much more information and should\n         provide a good overview of the available\
    \ headers.\n      *  It has been clarified that any message with a message body\
    \ is\n         required to have a Content-Length header.  This was the case in\n\
    \         RFC 2326, but could be misinterpreted.\n      *  ETag has changed its\
    \ name to MTag.\n      *  To resolve functionality around MTag, the MTag and If-None-\n\
    \         Match header have been added from HTTP with necessary\n         clarification\
    \ in regard to RTSP operation.\n      *  Imported the Public header from HTTP\
    \ (RFC 2068 [RFC2068]) since\n         it has been removed from HTTP due to lack\
    \ of use.  Public is\n         used quite frequently in RTSP.\n      *  Clarified\
    \ rules for populating the Public header so that it is\n         an intersection\
    \ of the capabilities of all the RTSP agents in a\n         chain.\n      *  Added\
    \ the Media-Range header for listing the current\n         availability of the\
    \ media range.\n      *  Added the Notify-Reason header for giving the reason\
    \ when\n         sending PLAY_NOTIFY requests.\n      *  A new header Seek-Style\
    \ has been defined to direct and inform\n         how any seek operation should/have\
    \ been performed.\n   o  The Protocol Syntax has been changed in the following\
    \ way:\n      *  All ABNF definitions are updated according to the rules defined\n\
    \         in RFC 5234 [RFC5234] and have been gathered in a separate\n       \
    \  section (Section 20).\n      *  The ABNF for the User-Agent and Server headers\
    \ have been\n         corrected.\n      *  Some definitions in the introduction\
    \ regarding the RTSP session\n         have been changed.\n      *  The protocol\
    \ has been made fully IPv6 capable.\n      *  The CHAR rule has been changed to\
    \ exclude NULL.\n   o  The Status codes have been changed in the following ways:\n\
    \      *  The use of status code 303 (See Other) has been deprecated as\n    \
    \     it does not make sense to use in RTSP.\n      *  The never-defined status\
    \ code 411 \"Length Required\" has been\n         completely removed.\n      *\
    \  When sending response 451 (Parameter Not Understood) and 458\n         (Parameter\
    \ Is Read-Only), the response body should contain the\n         offending parameters.\n\
    \      *  Clarification on when a 3rr redirect status code can be\n         received\
    \ has been added.  This includes receiving 3rr as a\n         result of a request\
    \ within an established session.  This\n         provides clarification to a previous\
    \ unspecified behavior.\n      *  Removed the 201 (Created) and 250 (Low On Storage\
    \ Space) status\n         codes as they are only relevant to recording, which\
    \ is\n         deprecated.\n      *  Several new status codes have been defined:\
    \ 464 (Data Transport\n         Not Ready Yet), 465 (Notification Reason Unknown),\
    \ 470\n         (Connection Authorization Required), 471 (Connection\n       \
    \  Credentials Not Accepted), and 472 (Failure to Establish Secure\n         Connection).\n\
    \   o  The following functionality has been deprecated from the protocol:\n  \
    \    *  The use of Queued Play.\n      *  The use of PLAY method for keep-alive\
    \ in Play state.\n      *  The RECORD and ANNOUNCE methods and all related functionality.\n\
    \         Some of the syntax has been removed.\n      *  The possibility to use\
    \ timed execution of methods with the time\n         parameter in the Range header.\n\
    \      *  The description on how rtspu works is not part of the core\n       \
    \  specification and will require external description.  Only that\n         it\
    \ exists is mentioned here and some requirements for the\n         transport are\
    \ provided.\n   o  The following changes have been made in relation to methods:\n\
    \      *  The OPTIONS method has been clarified with regard to the use of\n  \
    \       the Public and Allow headers.\n      *  Added text clarifying the usage\
    \ of SET_PARAMETER for keep-alive\n         and usage without a body.\n      *\
    \  PLAY method is now allowed to be pipelined with the pipelining\n         of\
    \ one or more SETUP requests following the initial that\n         generates the\
    \ session for aggregated control.\n      *  REDIRECT has been expanded and diversified\
    \ for different\n         situations.\n      *  Added a new method PLAY_NOTIFY.\
    \  This method is used by the\n         RTSP server to asynchronously notify clients\
    \ about session\n         changes.\n   o  Wrote a new section about how to set\
    \ up different media-transport\n      alternatives and their profiles as well\
    \ as lower-layer protocols.\n      This caused the appendix on RTP interaction\
    \ to be moved to the new\n      section instead of being in the part that describes\
    \ RTP.  The new\n      section also includes guidelines what to consider when\
    \ writing\n      usage guidelines for new protocols and profiles.\n   o  Setup\
    \ and usage of independent TCP connections for transport of\n      RTP has been\
    \ specified.\n   o  Added a new section describing the available mechanisms to\n\
    \      determine if functionality is supported, called \"Capability\n      Handling\"\
    .  Renamed option-tags to feature tags.\n   o  Added a Contributors section with\
    \ people who have contributed\n      actual text to the specification.\n   o \
    \ Added a section \"Use Cases\" that describes the major use cases for\n     \
    \ RTSP.\n   o  Clarified the usage of a=range and how to indicate live content\n\
    \      that are not seekable with this header.\n   o  Text specifying the special\
    \ behavior of PLAY for live content.\n   o  Security features of RTSP have been\
    \ clarified:\n      *  HTTP-based authorization has been clarified requiring both\n\
    \         Basic and Digest support\n      *  TLS support has been mandated\n \
    \     *  If one implements RTP, then SRTP and defined MIKEY-based key-\n     \
    \    exchange must be supported\n      *  Various minor mitigations discussed\
    \ or resulted in protocol\n         changes.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   This memorandum defines RTSP version 2.0, which is a revision\
    \ of the\n   Proposed Standard RTSP version 1.0 defined in [RFC2326].  The authors\n\
    \   of RFC 2326 are Henning Schulzrinne, Anup Rao, and Robert Lanphier.\n   Both\
    \ RTSP version 1.0 and RTSP version 2.0 borrow format and\n   descriptions from\
    \ HTTP/1.1.\n   Robert Sparks and especially Elwyn Davies provided very valuable\
    \ and\n   detailed reviews in the IETF Last Call that greatly improved the\n \
    \  document and resolved many issues, especially regarding consistency.\n   This\
    \ document has benefited greatly from the comments of all those\n   participating\
    \ in the MMUSIC WG.  In addition to those already\n   mentioned, the following\
    \ individuals have contributed to this\n   specification:\n   Rahul Agarwal, Claudio\
    \ Allocchio, Jeff Ayars, Milko Boic, Torsten\n   Braun, Brent Browning, Bruce\
    \ Butterfield, Steve Casner, Maureen\n   Chesire, Jinhang Choi, Francisco Cortes,\
    \ Elwyn Davies, Spencer\n   Dawkins, Kelly Djahandari, Martin Dunsmuir, Adrian\
    \ Farrel, Stephen\n   Farrell, Ross Finlayson, Eric Fleischman, Jay Geagan, Andy\
    \ Grignon,\n   Christian Groves, V.  Guruprasad, Peter Haight, Mark Handley, Brad\n\
    \   Hefta-Gaub, Volker Hilt, John K.  Ho, Patrick Hoffman, Go Hori,\n   Philipp\
    \ Hoschka, Anne Jones, Ingemar Johansson, Jae-Hwan Kim, Anders\n   Klemets, Ruth\
    \ Lang, Barry Leiba, Stephanie Leif, Jonathan Lennox,\n   Eduardo F.  Llach, Chris\
    \ Lonvick, Xavier Marjou, Thomas Marshall, Rob\n   McCool, Martti Mela, David\
    \ Oran, Joerg Ott, Joe Pallas, Maria\n   Papadopouli, Sujal Patel, Ema Patki,\
    \ Alagu Periyannan, Colin Perkins,\n   Pekka Pessi, Igor Plotnikov, Pete Resnick,\
    \ Peter Saint-Andre, Holger\n   Schmidt, Jonathan Sergent, Pinaki Shah, David\
    \ Singer, Lior Sion, Jeff\n   Smith, Alexander Sokolsky, Dale Stammen, John Francis\
    \ Stracke, Geetha\n   Srikantan, Scott Taylor, David Walker, Stephan Wenger, Dale\
    \ R.\n   Worley, and Byungjo Yoon, and especially Flemming Andreasen.\n"
- title: Contributors
  contents:
  - "Contributors\n   The following people have made written contributions that were\n\
    \   included in the specification:\n   o  Tom Marshall contributed text on the\
    \ usage of 3rr status codes.\n   o  Thomas Zheng contributed text on the usage\
    \ of the Range in PLAY\n      responses and proposed an earlier version of the\
    \ PLAY_NOTIFY\n      method.\n   o  Sean Sheedy contributed text on the timeout\
    \ behavior of RTSP\n      messages and connections, the 463 (Destination Prohibited)\
    \ status\n      code, and proposed an earlier version of the PLAY_NOTIFY method.\n\
    \   o  Greg Sherwood proposed an earlier version of the PLAY_NOTIFY\n      method.\n\
    \   o  Fredrik Lindholm contributed text about the RTSP security\n      framework.\n\
    \   o  John Lazzaro contributed the text for RTP over Independent TCP.\n   o \
    \ Aravind Narasimhan contributed by rewriting \"Media-Transport\n      Alternatives\"\
    \ (Appendix C) and making editorial improvements on a\n      number of places\
    \ in the specification.\n   o  Torbjorn Einarsson has done some editorial improvements\
    \ of the\n      text.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Henning Schulzrinne\n   Columbia University\n   1214 Amsterdam\
    \ Avenue\n   New York, NY  10027\n   United States of America\n   Email: schulzrinne@cs.columbia.edu\n\
    \   Anup Rao\n   Cisco\n   United States of America\n   Email: anrao@cisco.com\n\
    \   Rob Lanphier\n   San Francisco, CA\n   United States of America\n   Email:\
    \ robla@robla.net\n   Magnus Westerlund\n   Ericsson\n   Faeroegatan 2\n   Stockholm\
    \  SE-164 80\n   Sweden\n   Email: magnus.westerlund@ericsson.com\n   Martin Stiemerling\
    \ (editor)\n   University of Applied Sciences Darmstadt\n   Haardtring 100\n \
    \  64295 Darmstadt\n   Germany\n   Email: mls.ietf@gmail.com\n   URI:   http://www.stiemerling.org\n"
