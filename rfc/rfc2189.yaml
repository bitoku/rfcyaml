- title: __initial_text__
  contents:
  - "           Core Based Trees (CBT version 2) Multicast Routing\n             \
    \         -- Protocol Specification --\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the Core Based Tree (CBT version 2) network\n\
    \   layer multicast routing protocol. CBT builds a shared multicast\n   distribution\
    \ tree per group, and is suited to inter- and intra-domain\n   multicast routing.\n\
    \   CBT may use a separate multicast routing table, or it may use that of\n  \
    \ underlying unicast routing, to establish paths between senders and\n   receivers.\
    \ The CBT architecture is described in [1].\n   This document is progressing through\
    \ the IDMR working group of the\n   IETF.  CBT related documents include [1, 5,\
    \ 6]. For all IDMR-related\n   documents, see http://www.cs.ucl.ac.uk/ietf/idmr.\n"
- title: TABLE OF CONTENTS
  contents:
  - "TABLE OF CONTENTS\n     4.4 QUIT_NOTIFICATION Processing...........................\
    \ 10\n         4.4.1 Sending QUIT_NOTIFICATIONs....................... 10\n  \
    \       4.4.2 Receiving QUIT_NOTIFICATIONs..................... 10\n     4.5 CBT\
    \ ECHO_REQUEST Processing............................ 11\n         4.5.1 Sending\
    \ ECHO_REQUESTs............................ 11\n         4.5.2 Receiving ECHO_REQUESTs..........................\
    \ 12\n     4.6 ECHO_REPLY Processing.................................. 12\n  \
    \       4.6.1 Sending ECHO_REPLYs.............................. 12\n         4.6.2\
    \ Receiving ECHO_REPLYs............................ 12\n     4.7 FLUSH_TREE Processing..................................\
    \ 13\n         4.7.1 Sending FLUSH_TREE Messages...................... 13\n  \
    \       4.7.2 Receiving FLUSH_TREE Messages.................... 13\n  5. Non-Member\
    \ Sending......................................... 13\n  6. Timers and Default\
    \ Values.................................. 13\n  7. CBT Packet Formats and Message\
    \ Types....................... 14\n     7.1 CBT Common Control Packet Header.......................\
    \ 14\n     7.2 HELLO Packet Format.................................... 15\n  \
    \   7.3 JOIN_REQUEST Packet Format............................. 16\n     7.4 JOIN_ACK\
    \ Packet Format................................. 16\n     7.5 QUIT_NOTIFICATION\
    \ Packet Format........................ 17\n     7.6 ECHO_REQUEST Packet Format.............................\
    \ 18\n     7.7 ECHO_REPLY Packet Format............................... 18\n  \
    \   7.8 FLUSH_TREE Packet Format............................... 19\n  8. Core\
    \ Router Discovery...................................... 19\n     8.1  \"Bootstrap\"\
    \ Mechanism Overview........................ 20\n     8.2  Bootstrap Message Format..............................\
    \ 21\n     8.3  Candidate Core Advertisement Message Format........... 21\n  9.\
    \ Interoperability Issues.................................... 21\n  10.  Security\
    \ Considerations.................................. 21\n  Acknowledgements..............................................\
    \ 22\n  References.................................................... 22\n  Author\
    \ Information............................................ 23\n"
- title: 1.  Changes from CBT version 1
  contents:
  - "1.  Changes from CBT version 1\n   This version of the CBT protocol specification\
    \ differs significantly\n   from the previous version. Consequently, this version\
    \ represents\n   version 2 of the CBT protocol.  CBT version 2 is not, and was\
    \ not,\n   intended to be backwards compatible with version 1; we do not expect\n\
    \   this to cause extensive compatibility problems because we do not\n   believe\
    \ CBT is at all widely deployed at this stage. However, any\n   future versions\
    \ of CBT can be expected to be backwards compatible\n   with this version.\n \
    \  The most significant changes to version 2 compared to version 1\n   include:\n\
    \   o new LAN mechanisms, including the incorporation of an HELLO\n     protocol.\n\
    \   o new simplified packet formats, with the definition of a common CBT\n   \
    \  control packet header.\n   o each group shared tree has only one active core\
    \ router.\n     This specification revision is a complete re-write of the previous\n\
    \     revision.\n"
- title: 2.  Introduction & Terminology
  contents:
  - "2.  Introduction & Terminology\n   In CBT, a \"core router\" (or just \"core\"\
    ) is a router which acts as a\n   \"meeting point\" between a sender and group\
    \ receivers. The term\n   \"rendezvous point (RP)\" is used equivalently in some\
    \ contexts [2]. A\n   core router need not be configured to know it is a core\
    \ router.\n   A router that is part of a CBT distribution tree is known as an\
    \ \"on-\n   tree\" router. An on-tree router maintains active state for the group.\n\
    \   We refer to a broadcast interface as any interface that supports\n   multicast\
    \ transmission.\n   An \"upstream\" interface (or router) is one which is on the\
    \ path\n   towards the group's core router with respect to this interface (or\n\
    \   router). A \"downstream\" interface (or router) is one which is on the\n \
    \  path away from the group's core router with respect to this interface\n   (or\
    \ router).\n   Other terminology is introduced in its context throughout the text.\n"
- title: 3.  CBT Functional Overview
  contents:
  - "3.  CBT Functional Overview\n   The CBT protocol is designed to build and maintain\
    \ a shared multicast\n   distribution tree that spans only those networks and\
    \ links leading to\n   interested receivers.\n   To achieve this, a host first\
    \ expresses its interest in joining a\n   group by multicasting an IGMP host membership\
    \ report [3] across its\n   attached link. On receiving this report, a local CBT\
    \ aware router\n   invokes the tree joining process (unless it has already) by\n\
    \   generating a JOIN_REQUEST message, which is sent to the next hop on\n   the\
    \ path towards the group's core router (how the local router\n   discovers which\
    \ core to join is discussed in section 8). This join\n   message must be explicitly\
    \ acknowledged (JOIN_ACK) either by the core\n   router itself, or by another\
    \ router that is on the path between the\n   sending router and the core, which\
    \ itself has already successfully\n   joined the tree.\n   The join message sets\
    \ up transient join state in the routers it\n   traverses, and this state consists\
    \ of <group, incoming interface,\n   outgoing interface>. \"Incoming interface\"\
    \ and \"outgoing interface\"\n   may be \"previous hop\" and \"next hop\", respectively,\
    \ if the\n   corresponding links do not support multicast transmission. \"Previous\n\
    \   hop\" is taken from the incoming control packet's IP source address,\n   and\
    \ \"next hop\" is gleaned from the routing table - the next hop to\n   the specified\
    \ core address. This transient state eventually times out\n   unless it is \"\
    confirmed\" with a join acknowledgement (JOIN_ACK) from\n   upstream. The JOIN_ACK\
    \ traverses the reverse path of the\n   corresponding join message, which is possible\
    \ due to the presence of\n   the transient join state. Once the acknowledgement\
    \ reaches the router\n   that originated the join message, the new receiver can\
    \ receive\n   traffic sent to the group.\n   Loops cannot be created in a CBT\
    \ tree because a) there is only one\n   active core per group, and b) tree building/maintenance\
    \ scenarios\n   which may lead to the creation of tree loops are avoided.  For\n\
    \   example, if a router's upstream neighbour becomes unreachable, the\n   router\
    \ immediately \"flushes\" all of its downstream branches, allowing\n   them to\
    \ individually rejoin if necessary.  Transient unicast loops do\n   not pose a\
    \ threat because a new join message that loops back on\n   itself will never get\
    \ acknowledged, and thus eventually times out.\n   The state created in routers\
    \ by the sending or receiving of a\n   JOIN_ACK is bi-directional - data can flow\
    \ either way along a tree\n   \"branch\", and the state is group specific - it\
    \ consists of the group\n   address and a list of local interfaces over which\
    \ join messages for\n   the group have previously been acknowledged. There is\
    \ no concept of\n   \"incoming\" or \"outgoing\" interfaces, though it is necessary\
    \ to be\n   able to distinguish the upstream interface from any downstream\n \
    \  interfaces. In CBT, these interfaces are known as the \"parent\" and\n   \"\
    child\" interfaces, respectively. A router is not considered \"on-\n   tree\"\
    \ until it has received a JOIN_ACK for a previously sent\n   JOIN_REQUEST.\n \
    \  With regards to the information contained in the multicast forwarding\n   cache,\
    \ on link types not supporting native multicast transmission an\n   on-tree router\
    \ must store the address of a parent and any children.\n   On links supporting\
    \ multicast however, parent and any child\n   information is represented with\
    \ local interface addresses (or similar\n   identifying information, such as an\
    \ interface \"index\") over which the\n   parent or child is reachable.\n   Data\
    \ from non-member senders must be encapsulated (IP-in-IP) by the\n   first-hop\
    \ router, and is unicast to the group's core router.\n   Consequently, no group\
    \ state is required in the network between the\n   first hop router and the group's\
    \ core. On arriving at the core\n   router, the data packet's outer encapsulating\
    \ header is removed and\n   the packet is disemminated over the group shared tree\
    \ as described\n   below.\n   When a multicast data packet arrives at a router,\
    \ the router uses the\n   group address as an index into the multicast forwarding\
    \ cache. A copy\n   of the incoming multicast data packet is forwarded over each\n\
    \   interface (or to each address) listed in the entry except the\n   incoming\
    \ interface.\n   Each router that comprises a CBT multicast tree, except the core\n\
    \   router, is responsible for maintaining its upstream link, provided it\n  \
    \ has interested downstream receivers, i.e. the child interface list is\n   not\
    \ NULL. A child interface is one over which a member host is\n   directly attached,\
    \ or one over which a downstream on-tree router is\n   attached.  This \"tree\
    \ maintenance\" is achieved by each downstream\n   router periodically sending\
    \ a CBT \"keepalive\" message (ECHO_REQUEST)\n   to its upstream neighbour, i.e.\
    \ its parent router on the tree. One\n   keepalive message is sent to represent\
    \ entries with the same parent,\n   thereby improving scalability on links which\
    \ are shared by many\n   groups.  On multicast capable links, a keepalive is multicast\
    \ to the\n   \"all-cbt-routers\" group (IANA assigned as 224.0.0.15); this has\
    \ a\n   suppressing effect on any other router for which the link is its\n   parent\
    \ link.  If a parent link does not support multicast\n   transmission, keepalives\
    \ are unicast.\n   The receipt of a keepalive message over a valid child interface\n\
    \   prompts a response (ECHO_REPLY), which is either unicast or\n   multicast,\
    \ as appropriate.  The ECHO_REPLY message carries a list of\n   groups for which\
    \ the corresponding interface is a child interface.\n   It cannot be assumed all\
    \ of the routers on a multi-access link have a\n   uniform view of unicast routing;\
    \ this is particularly the case when a\n   multi-access link spans two or more\
    \ unicast routing domains. This\n   could lead to multiple upstream tree branches\
    \ being formed (an error\n   condition) unless steps are taken to ensure all routers\
    \ on the link\n   agree which is the upstream router for a particular group. CBT\n\
    \   routers attached to a multi-access link participate in an explicit\n   election\
    \ mechanism that elects a single router, the designated router\n   (DR), as the\
    \ link's upstream router for all groups. Since the DR\n   might not be the link's\
    \ best next-hop for a particular core router,\n   this may result in join messages\
    \ being re-directed back across a\n   multi-access link. If this happens, the\
    \ re-directed join message is\n   unicast across the link by the DR to the best\
    \ next-hop, thereby\n   preventing a looping scenario. This re-direction only\
    \ ever applies to\n   join messages.  Whilst this is suboptimal for join messages,\
    \ which\n   are generated infrequently, multicast data never traverses a link\n\
    \   more than once (either natively, or encapsulated).\n   In all but the exception\
    \ case described above, all CBT control\n   messages are multicast over multicast\
    \ supporting links to the \"all-\n   cbt- routers\" group, with IP TTL 1. The\
    \ IP source address of CBT\n   control messages is the outgoing interface of the\
    \ sending router. The\n   IP destination address of CBT control messages is either\
    \ the \"all-\n   cbt- routers\" group address, or a unicast address, as appropriate.\n\
    \   All the necessary addressing information is obtained by on-tree\n   routers\
    \ as part of tree set up.\n   If CBT is implemented over a tunnelled topology,\
    \ when sending a CBT\n   control packet over a tunnel interface, the sending router\
    \ uses as\n   the packet's IP source address the local tunnel end point address,\n\
    \   and the remote tunnel end point address as the packet's IP\n   destination\
    \ address.\n"
- title: 4.  Protocol Specification Details
  contents:
  - "4.  Protocol Specification Details\n   Details of the CBT protocol are presented\
    \ in the context of a single\n   router implementation.\n"
- title: 4.1.  CBT HELLO Protocol
  contents:
  - "4.1.  CBT HELLO Protocol\n   The HELLO protocol is used to elect a designated\
    \ router (DR) on\n   broadcast-type links. It is also used to elect a designated\
    \ border\n   router (BR) when interconnecting a CBT domain with other domains\
    \ (see\n   [5]). Alternatively, the designated BR may be elected as a matter of\n\
    \   local policy.\n   A router represents its status as a link's DR by setting\
    \ the DR-flag\n   on that interface; a DR flag is associated with each of a router's\n\
    \   broadcast interfaces. This flag can only assume one of two values:\n   TRUE\
    \ or FALSE. By default, this flag is FALSE.\n   A network manager can preference\
    \ a router's DR eligibility by\n   optionally configuring an HELLO preference,\
    \ which is included in the\n   router's HELLO messages.  Valid configuration values\
    \ range from 1 to\n   254 (decimal), 1 representing the \"most eligible\" value.\
    \ In the\n   absence of explicit configuration, a router assumes the default HELLO\n\
    \   preference value of 255. The elected DR uses HELLO preference zero\n   (0)\
    \ in HELLO advertisements, irrespective of any configured\n   preference.  The\
    \ DR continues to use preference zero for as long as\n   it is running.\n   HELLO\
    \ messages are multicast periodically to the all-cbt-routers\n   group, 224.0.0.15,\
    \ using IP TTL 1. The advertisement period is\n   [HELLO_INTERVAL] seconds.\n\
    \   HELLO messages have a suppressing effect on those routers which would\n  \
    \ advertise a \"lesser preference\" in their HELLO messages; a router\n   resets\
    \ its [HELLO_INTERVAL] if the received HELLO is \"better\" than\n   its own. Thus,\
    \ in steady state, the HELLO protocol incurs very little\n   traffic overhead.\n\
    \   The DR election winner is that which advertises the lowest HELLO\n   preference,\
    \ or the lowest-addressed in the event of a tie.\n   The situation where two or\
    \ more routers attached to the same\n   broadcast link areadvertising HELLO preference\
    \ 0 should never arise.\n   However, should this situation arise, all but the\
    \ lowest addressed\n   zero advertising router relinquishes its claim as DR immediately\
    \ by\n   unsetting the DR flag on the corresponding interface. The\n   relinquishing\
    \ router(s) subsequently advertise their previously used\n   preference value\
    \ in HELLO advertisements.\n"
- title: 4.1.1.  Sending HELLOs
  contents:
  - "4.1.1.  Sending HELLOs\n   When a router starts up, it multicasts two HELLO messages\
    \ over each\n   of its broadcast interfaces in successsion. The DR flag is initially\n\
    \   unset (FALSE) on each broadcast interface.  This avoids the situation\n  \
    \ in which each router on a multi-access subnet believes it is the DR,\n   thus\
    \ preventing the multiple forwarding of join-requests should they\n   arrive during\
    \ this start up period.  If no \"better\" HELLO message is\n   received after\
    \ HOLDTIME seconds, the router assumes the role of DR on\n   the corresponding\
    \ interface.\n   A router sends an HELLO message whenever its [HELLO_INTERVAL]\n\
    \   expires.  Whenever a router sends an HELLO message, it resets its\n   hello\
    \ timer.\n"
- title: 4.1.2.  Receiving HELLOs
  contents:
  - "4.1.2.  Receiving HELLOs\n   A router does not respond to an HELLO message if\
    \ the received HELLO\n   is \"better\" than its own, or equally preferenced but\
    \ lower addressed.\n   A router must respond to an HELLO message if that received\
    \ is lesser\n   preferenced (or equally preferenced but higher addressed) than\
    \ would\n   be sent by this router over the same interface. This response is sent\n\
    \   on expiry of an interval timer which is set between zero (0) and\n   [HOLDTIME]\
    \ seconds when the lesser preferenced HELLO message is\n   received.\n"
- title: 4.2.  JOIN_REQUEST Processing
  contents:
  - "4.2.  JOIN_REQUEST Processing\n   A JOIN_REQUEST is the CBT control message used\
    \ to register a member\n   host's interest in joining the distribution tree for\
    \ the group.\n"
- title: 4.2.1.  Sending JOIN_REQUESTs
  contents:
  - "4.2.1.  Sending JOIN_REQUESTs\n   A JOIN_REQUEST can only ever be originated\
    \ by a leaf router, i.e. a\n   router with directly attached member hosts. This\
    \ join message is sent\n   hop-by-hop towards the core router for the group (see\
    \ section 8).\n   The originating router caches <group, NULL, upstream interface>\
    \ state\n   for each join it originates. This state is known as \"transient join\n\
    \   state\".  The absence of a \"downstream interface\" (NULL) indicates\n   that\
    \ this router is the join message originator, and is therefore\n   responsible\
    \ for any retransmissions of this message if a response is\n   not received within\
    \ [RTX_INTERVAL].  It is an error if no response is\n   received after [JOIN_TIMEOUT]\
    \ seconds.  If this error condition\n   occurs, the joining process may be re-invoked\
    \ by the receipt of the\n   next IGMP host membership report from a locally attached\
    \ member host.\n   Note that if the interface over which a JOIN_REQUEST is to\
    \ be sent\n   supports multicast, the JOIN_REQUEST is multicast to the all-cbt-\n\
    \   routers group, using IP TTL 1.  If the link does not support\n   multicast,\
    \ the JOIN_REQUEST is unicast to the next hop on the unicast\n   path to the group's\
    \ core.\n"
- title: 4.2.2.  Receiving JOIN_REQUESTs
  contents:
  - "4.2.2.  Receiving JOIN_REQUESTs\n   On broadcast links, JOIN_REQUESTs which are\
    \ multicast may only be\n   forwarded by the link's DR. Other routers attached\
    \ to the link may\n   process the join (see below). JOIN_REQUESTs which are multicast\
    \ over\n   a point-to-point link are only processed by the router on the link\n\
    \   which does not have a local interface corresponding to the join's\n   network\
    \ layer (IP) source address. Unicast JOIN_REQUESTs may only be\n   processed by\
    \ the router which has a local interface corresponding to\n   the join's network\
    \ layer (IP) destination address.\n   With regard to forwarding a received JOIN_REQUEST,\
    \ if the receiving\n   router is not on-tree for the group, and is not the group's\
    \ core\n   router, and has not already forwarded a join for the same group, the\n\
    \   join is forwarded to the next hop on the path towards the core. The\n   join\
    \ is multicast, or unicast, according to whether the outgoing\n   interface supports\
    \ multicast.  The router caches the following\n   information with respect to\
    \ the forwarded join: <group, downstream\n   interface, upstream interface>. Subsequent\
    \ JOIN_REQUESTs received for\n   the same group are cached until this router has\
    \ received a JOIN_ACK\n   for the previously sent join, at which time any cached\
    \ joins can also\n   be acknowledged.\n   If this transient join state is not\
    \ \"confirmed\" with a join\n   acknowledgement (JOIN_ACK) message from upstream,\
    \ the state is timed\n   out after [TRANSIENT_TIMEOUT] seconds.\n   If the receiving\
    \ router is the group's core router, the join is\n   \"terminated\" and acknowledged\
    \ by means of a JOIN_ACK. Similarly, if\n   the router is on-tree and the JOIN_REQUEST\
    \ arrives over an interface\n   that is not the upstream interface for the group,\
    \ the join is\n   acknowledged.\n   If a JOIN_REQUEST for the same group is scheduled\
    \ to be sent over the\n   corresponding interface (i.e. awaiting a timer expiry),\
    \ the\n   JOIN_REQUEST is unscheduled.\n   If this router has a cache-deletion-timer\
    \ [CACHE_DEL_TIMER] running\n   on the arrival interface for the group specified\
    \ in a multicast join,\n   the timer is cancelled.\n"
- title: 4.3.  JOIN_ACK Processing
  contents:
  - "4.3.  JOIN_ACK Processing\n   A JOIN_ACK is the mechanism by which an interface\
    \ is added to a\n   router's multicast forwarding cache; thus, the interface becomes\
    \ part\n   of the group distribution tree.\n"
- title: 4.3.1.  Sending JOIN_ACKs
  contents:
  - "4.3.1.  Sending JOIN_ACKs\n   The JOIN_ACK is sent over the same interface as\
    \ the corresponding\n   JOIN_REQUEST was received. The sending of the acknowledgement\
    \ causes\n   the router to add the interface to its child interface list in its\n\
    \   forwarding cache for the group, if it is not already.\n   A JOIN_ACK is multicast\
    \ or unicast, according to whether the outgoing\n   interface supports multicast\
    \ transmission or not.\n"
- title: 4.3.2.  Receiving JOIN_ACKs
  contents:
  - "4.3.2.  Receiving JOIN_ACKs\n   The group and arrival interface must be matched\
    \ to a <group, ....,\n   upstream interface> from the router's cached transient\
    \ state. If no\n   match is found, the JOIN_ACK is discarded.  If a match is found,\
    \ a\n   CBT forwarding cache entry for the group is created, with \"upstream\n\
    \   interface\" marked as the group's parent interface.\n   If \"downstream interface\"\
    \ in the cached transient state is NULL, the\n   JOIN_ACK has reached the originator\
    \ of the corresponding\n   JOIN_REQUEST; the JOIN_ACK is not forwarded downstream.\
    \  If\n   \"downstream interface\" is non-NULL, a JOIN_ACK for the group is sent\n\
    \   over the \"downstream interface\" (multicast or unicast, accordingly).\n \
    \  This interface is installed in the child interface list of the\n   group's\
    \ forwarding cache entry.\n   Once transient state has been confirmed by transferring\
    \ it to the\n   forwarding cache, the transient state is deleted.\n"
- title: 4.4.  QUIT_NOTIFICATION Processing
  contents:
  - "4.4.  QUIT_NOTIFICATION Processing\n   A CBT tree is \"pruned\" in the direction\
    \ downstream-to-upstream\n   whenever a CBT router's child interface list for\
    \ a group becomes\n   NULL.\n"
- title: 4.4.1.  Sending QUIT_NOTIFICATIONs
  contents:
  - "4.4.1.  Sending QUIT_NOTIFICATIONs\n   A QUIT_NOTIFICATION is sent to a router's\
    \ parent router on the tree\n   whenever the router's child interface list becomes\
    \ NULL. If the link\n   over which the quit is to be sent supports multicast transmission,\
    \ if\n   the sending router is the link's DR the quit is unicast, otherwise it\n\
    \   is multicast.\n   A QUIT_NOTIFICATION is not acknowledged; once sent, all\
    \ information\n   pertaining to the group it represents is deleted from the forwarding\n\
    \   cache immediately.\n   To help ensure consistency between a child and parent\
    \ router given\n   the potential for loss of a QUIT_NOTIFICATION, a total of [MAX_RTX]\n\
    \   QUIT_NOTIFICATIONs are sent, each HOLDTIME seconds after the previous\n  \
    \ one.\n   The sending of a quit (the first) also invokes the sending of a\n \
    \  FLUSH_TREE message over each downstream interface for the\n   corresponding\
    \ group.\n"
- title: 4.4.2.  Receiving QUIT_NOTIFICATIONs
  contents:
  - "4.4.2.  Receiving QUIT_NOTIFICATIONs\n   The group reported in the QUIT_NOTIFICATION\
    \ must be matched with a\n   forwarding cache entry. If no match is found, the\
    \ QUIT_NOTIFICATION\n   is ignored and discarded.  If a match is found, if the\
    \ arrival\n   interface is a valid child interface in the group entry, how the\n\
    \   router proceeds depends on whether the QUIT_NOTIFICATION was\n   multicast\
    \ or unicast.\n   If the QUIT_NOTIFICATION was unicast, the corresponding child\n\
    \   interface is deleted from the group's forwarding cache entry, and no\n   further\
    \ processing is required.\n   If the QUIT_NOTIFICATION was multicast, and the\
    \ arrival interface is\n   a valid child interface for the specified group, the\
    \ router sets a\n   cache-deletion-timer [CACHE_DEL_TIMER].\n   Because this router\
    \ might be acting as a parent router for multiple\n   downstream routers attached\
    \ to the arrival link, [CACHE_DEL_TIMER]\n   interval gives those routers that\
    \ did not send the  QUIT_NOTIFICA-\n   TION, but received it over their parent\
    \ interface, the opportunity to\n   ensure that the parent router does not remove\
    \ the link from its child\n   interface list.  Therefore, on receipt of a multicast\n\
    \   QUIT_NOTIFICATION over a parent interface, a receiving router\n   schedules\
    \ a JOIN_REQUEST for the group for sending at a random\n   interval between 0\
    \ (zero) and HOLDTIME seconds.  If a multicast\n   JOIN_REQUEST is received over\
    \ the corresponding interface (parent)\n   for the same group before this router\
    \ sends its own scheduled\n   JOIN_REQUEST, it unschedules the multicasting of\
    \ its own\n   JOIN_REQUEST.\n"
- title: 4.5.  ECHO_REQUEST Processing
  contents:
  - "4.5.  ECHO_REQUEST Processing\n   The ECHO_REQUEST message allows a child to\
    \ monitor reachability to\n   its parent router for a group (or range of groups\
    \ if the parent\n   router is the parent for multiple groups). Group information\
    \ is not\n   carried in ECHO_REQUEST messages.\n"
- title: 4.5.1.  Sending ECHO_REQUESTs
  contents:
  - "4.5.1.  Sending ECHO_REQUESTs\n   Whenever a router creates a forwarding cache\
    \ entry due to the receipt\n   of a JOIN_ACK, the router begins the periodic sending\
    \ of ECHO_REQUEST\n   messages over its parent interface. The ECHO_REQUEST is\
    \ multicast to\n   the \"all-cbt-routers\" group over multicast-capable interfaces,\
    \ unless\n   the sending router is the DR on the interface over which the\n  \
    \ ECHO_REQUEST is being sent, in which case it is unicast (as is the\n   corresponding\
    \ ECHO_REPLY).\n   ECHO_REQUEST messages are sent at [ECHO_INTERVAL] second intervals.\n\
    \   Whenever an ECHO_REQUEST is sent, [ECHO_INTERVAL] is reset.\n   If no response\
    \ is forthcoming, any groups present on the parent\n   interface will eventually\
    \ expire [GROUP_EXPIRE_TIME]. This results in\n   the sending of a QUIT_NOTIFICATION\
    \ upstream, and sends a FLUSH_TREE\n   message downstream for each group for which\
    \ the upstream interface\n   was the parent interface.\n"
- title: 4.5.2.  Receiving ECHO_REQUESTs
  contents:
  - "4.5.2.  Receiving ECHO_REQUESTs\n   If an ECHO_REQUEST is received over any valid\
    \ child interface, the\n   receiving router schedules an ECHO_REPLY message for\
    \ sending over the\n   same interface; the scheduled interval is between 0 (zero)\
    \ and\n   HOLDTIME seconds. This message is multicast to the \"all-cbt-routers\"\
    \n   group over multicast-capable interfaces, and unicast otherwise.\n   If a\
    \ multicast ECHO_REQUEST message arrives via any valid parent\n   interface, the\
    \ router resets its [ECHO_INTERVAL] timer for that\n   upstream interface, thereby\
    \ suppressing the sending of its own\n   ECHO_REQUEST over that upstream interface.\n"
- title: 4.6.  ECHO_REPLY Processing
  contents:
  - "4.6.  ECHO_REPLY Processing\n   ECHO_REPLY messages allow a child to monitor\
    \ the reachability of its\n   parent, and help ensure the group state information\
    \ is consistent\n   between them.\n"
- title: 4.6.1.  Sending ECHO_REPLY messages
  contents:
  - "4.6.1.  Sending ECHO_REPLY messages\n   An ECHO_REPLY message is sent in response\
    \ to receiving an\n   ECHO_REQUEST message, provided the ECHO_REQUEST is received\
    \ over any\n   one of this router's valid child interfaces. An ECHO_REPLY reports\n\
    \   all groups for which the link is its child.\n   ECHO_REPLY messages are unicast\
    \ or multicast, as appropriate.\n"
- title: 4.6.2.  Receiving ECHO_REPLY messages
  contents:
  - "4.6.2.  Receiving ECHO_REPLY messages\n   An ECHO_REPLY message must be received\
    \ via a valid parent interface.\n   For each group reported in an ECHO_REPLY,\
    \ the downstream router\n   attempts to match the group with one in its forwarding\
    \ cache for\n   which the arrival interface is the group's parent interface. For\
    \ each\n   successful match, the entry is \"refreshed\". If however, after\n \
    \  [GROUP_EXPIRE_TIME] seconds a group has not been \"refreshed\", a\n   QUIT_NOTIFICATION\
    \ is sent upstream, and a FLUSH_TREE message is sent\n   downstream, for the group.\n\
    \   If this router has directly attached members for any of the flushed\n   groups,\
    \ the receipt of an IGMP host membership report for any of\n   those groups will\
    \ prompt this router to rejoin the corresponding\n   tree(s).\n"
- title: 4.7.  FLUSH_TREE Processing
  contents:
  - "4.7.  FLUSH_TREE Processing\n   The FLUSH_TREE (flush) message is the mechanism\
    \ by which a router\n   invokes the tearing down of all its downstream branches\
    \ for a\n   particular group. The flush message is multicast to the \"all-cbt-\n\
    \   routers\" group when sent over multicast-capable interfaces, and\n   unicast\
    \ otherwise.\n"
- title: 4.7.1.  Sending FLUSH_TREE messages
  contents:
  - "4.7.1.  Sending FLUSH_TREE messages\n   A FLUSH_TREE message is sent over each\
    \ downstream (child) interface\n   when a router has lost reachability with its\
    \ parent router for the\n   group (detected via ECHO_REQUEST and ECHO_REPLY messages).\
    \ All group\n   state is removed from an interface over which a flush message\
    \ is\n   sent.  A flush can specify a single group, or all groups\n   (INADDR_ANY).\n"
- title: 4.7.2.  Receiving FLUSH_TREE messages
  contents:
  - "4.7.2.  Receiving FLUSH_TREE messages\n   A FLUSH_TREE message must be received\
    \ over the parent interface for\n   the specified group, otherwise the message\
    \ is discarded.\n   The flush message must be forwarded over each child interface\
    \ for the\n   specified group.\n   Once the flush message has been forwarded,\
    \ all state for the group is\n   removed from the router's forwarding cache.\n"
- title: 5.  Non-Member Sending
  contents:
  - "5.  Non-Member Sending\n   Data can be sent to a CBT tree by a sender not attached\
    \ to the group\n   tree.  The sending host originates native multicast data, which\
    \ is\n   promiscuously received by a local router, which must be CBT capable.\n\
    \   It is assumed the local CBT router knows about the relevant <core,\n   group>\
    \ mapping, and thus can encapsulate (IP-in-IP) the data packet\n   and unicast\
    \ it to the corresponding core router. On arriving at the\n   core router, the\
    \ data packet is decapsulated and disemminated over\n   the group tree in the\
    \ manner already described.\n"
- title: 6.  Timers and Default Values
  contents:
  - "6.  Timers and Default Values\n   This section provides a summary of the timers\
    \ described above,\n   together with their recommended default values. Other values\
    \ may be\n   configured; if so, the values used should be consistent across all\n\
    \   CBT routers attached to the same network.\n   o    [HELLO_INTERVAL]: the interval\
    \ between sending an HELLO message.\n        Default: 60 seconds.\n   o    [HELLO_PREFERENCE]:\
    \ Default: 255.\n   o    [HOLDTIME]: generic response interval. Default: 3 seconds.\n\
    \   o    [MAX_RTX]: default maximum number of retransmissions. Default 3.\n  \
    \ o    [RTX_INTERVAL]: message retransmission time. Default: 5 seconds.\n   o\
    \    [JOIN_TIMEOUT]: raise exception due to tree join failure.\n        Default:\
    \ 3.5 times [RTX_INTERVAL].\n   o    [TRANSIENT_TIMEOUT]: delete (unconfirmed)\
    \ transient state.\n        Default: (1.5*RTX_INTERVAL) seconds.\n   o    [CACHE_DEL_TIMER]:\
    \ remove child interface from forwarding cache.\n        Default: (1.5*HOLDTIME)\
    \ seconds.\n   o    [GROUP_EXPIRE_TIME]: time to send a QUIT_NOTIFICATION to our\n\
    \        non-responding parent.  Default: (1.5*ECHO_INTERVAL).\n   o    [ECHO_INTERVAL]:\
    \ interval between sending ECHO_REQUEST to parent\n        routers.  Default:\
    \ 60 seconds.\n   o    [EXPECTED_REPLY_TIME]: consider parent unreachable. Default:\
    \ 70\n        seconds.\n"
- title: 7. CBT Packet Formats and Message Types
  contents:
  - "7. CBT Packet Formats and Message Types\n   CBT control packets are encapsulated\
    \ in IP. CBT has been assigned IP\n   protocol number 7 by IANA [4].\n"
- title: 7.1.  CBT Common Control Packet Header
  contents:
  - "7.1.  CBT Common Control Packet Header\n   All CBT control messages have a common\
    \ fixed length header.\n       0               1               2             \
    \  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   \
    \   |  vers | type  |  addr len     |         checksum              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 1. CBT Common Control Packet Header\n   This CBT specification\
    \ is version 2.\n   CBT packet types are:\n   o    type 0: HELLO\n   o    type\
    \ 1: JOIN_REQUEST\n   o    type 2: JOIN_ACK\n   o    type 3: QUIT_NOTIFICATION\n\
    \   o    type 4: ECHO_REQUEST\n   o    type 5: ECHO_REPLY\n   o    type 6: FLUSH_TREE\n\
    \   o    type 7: Bootstrap Message (optional)\n   o    type 8: Candidate Core\
    \ Advertisement (optional)\n   o    Addr Length: address length in bytes of unicast\
    \ or multicast\n        addresses carried in the control packet.\n   o    Checksum:\
    \ the 16-bit one's complement of the one's complement\n        sum of the entire\
    \ CBT control packet.\n"
- title: 7.2.  HELLO Packet Format
  contents:
  - "7.2.  HELLO Packet Format\n    0               1               2            \
    \   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |   \
    \                 CBT Control Packet Header                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Preference   |  option type  |  option len   |  option value |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     Figure 2. HELLO Packet Format\n   HELLO Packet Field Definitions:\n\
    \   o    preference: sender's HELLO preference.\n   o    option type: the type\
    \ of option present in the \"option value\"\n        field.  One option type is\
    \ currently defined: option type 0\n        (zero) = BR_HELLO; option value 0\
    \ (zero); option length 0\n        (zero). This option type is used with HELLO\
    \ messages sent by a\n        border router (BR) as part of designated BR election\
    \ (see [5]).\n   o    option len: length of the \"option value\" field in bytes.\n\
    \   o    option value: variable length field carrying the option value.\n"
- title: 7.3.  JOIN_REQUEST Packet Format
  contents:
  - "7.3.  JOIN_REQUEST Packet Format\n       0               1               2  \
    \             3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                    CBT Control Packet Header                  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                          group address                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                          target router                        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                        originating router                     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  option type  |  option len   |        option value           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \               Figure 3. JOIN_REQUEST Packet Format\n      JOIN_REQUEST Field\
    \ Definitions\n   o    group address: multicast group address of the group being\
    \ joined.\n        For a \"wildcard\" join (see [5]), this field contains the\
    \ value of\n        INADDR_ANY.\n   o    target router: target (core) router for\
    \ the group.\n   o    originating router: router that originated this JOIN_REQUEST.\n\
    \   o    option type, option len, option value: see HELLO packet format,\n   \
    \     section 7.2.\n"
- title: 7.4.  JOIN_ACK Packet Format
  contents:
  - "7.4.  JOIN_ACK Packet Format\n      JOIN_ACK Field Definitions\n   o    group\
    \ address: multicast group address of the group being joined.\n   o    target\
    \ router: router (DR) that originated the corresponding\n        JOIN_REQUEST.\n\
    \       0               1               2               3\n       0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                    CBT Control Packet Header                  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                          group address                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                           target router                       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  option type  |  option len   |         option value          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure 4. JOIN_ACK Packet Format\n   o    option type,\
    \ option len, option value: see HELLO packet format,\n        section 7.2.\n"
- title: 7.5.  QUIT_NOTIFICATION Packet Format
  contents:
  - "7.5.  QUIT_NOTIFICATION Packet Format\n       0               1             \
    \  2               3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                    CBT Control Packet Header                  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                          group address                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                    originating child router                   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \            Figure 5. QUIT_NOTIFICATION Packet Format\n      QUIT_NOTIFICATION\
    \ Field Definitions\n   o    group address: multicast group address of the group\
    \ being joined.\n   o    originating child router: address of the router that\n\
    \        originates the QUIT_NOTIFICATION.\n"
- title: 7.6.  ECHO_REQUEST Packet Format
  contents:
  - "7.6.  ECHO_REQUEST Packet Format\n       0               1               2  \
    \             3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                    CBT Control Packet Header                  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                    originating child router                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     Figure 6. ECHO_REQUEST Packet Format\n      ECHO_REQUEST\
    \ Field Definitions\n   o    originating child router: address of the router that\n\
    \        originates the ECHO_REQUEST.\n"
- title: 7.7.  ECHO_REPLY Packet Format
  contents:
  - "7.7.  ECHO_REPLY Packet Format\n       0               1               2    \
    \           3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                    CBT Control Packet Header                  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                    originating parent router                  |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                       group address #1                        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                       group address #2                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                           ......                              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                       group address #n                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure 7. ECHO_REPLY Packet Format\n      ECHO_REPLY Field\
    \ Definitions\n   o    oringinating parent router: address of the router originating\n\
    \        this ECHO_REPLY.\n   o    group address: a list of multicast group addresses\
    \ for which\n        this router considers itself a parent router w.r.t. the link\n\
    \        over which this message is sent.\n"
- title: 7.8.  FLUSH_TREE Packet Format
  contents:
  - "7.8.  FLUSH_TREE Packet Format\n       0               1               2    \
    \           3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                    CBT Control Packet Header                  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                         group address                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                           ......                              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                       group address #n                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure 8. FLUSH_TREE Packet Format\n      FLUSH_TREE Field\
    \ Definitions\n   o    group address(es): multicast group address(es) of the group(s)\n\
    \        being \"flushed\".\n"
- title: 8.  Core Router Discovery
  contents:
  - "8.  Core Router Discovery\n   There are two available options for CBTv2 core\
    \ discovery; the\n   \"bootstrap\" mechanism (as currently specified with the\
    \ PIM sparse\n   mode protocol [2]) is applicable only to intra-domain core discovery,\n\
    \   and allows for a \"plug & play\" type operation with minimal\n   configuration.\
    \  The disadvantage of the bootstrap mechanism is that\n   it is much more difficult\
    \ to affect the shape, and thus optimality,\n   of the resulting distribution\
    \ tree.  Also, to be applicable, all CBT\n   routers within a domain must implement\
    \ the bootstrap mechanism.\n   The other option is to manually configure leaf\
    \ routers with <core,\n   group> mappings (note: leaf routers only); this imposes\
    \ a degree of\n   administrative burden - the mapping for a particular group must\
    \ be\n   coordinated across all leaf routers to ensure consistency. Hence,\n \
    \  this method does not scale particularly well. However, it is likely\n   that\
    \ \"better\" trees will result from this method, and it is also the\n   only available\
    \ option for inter-domain core discovery currently\n   available.\n"
- title: 8.1.  "Bootstrap" Mechanism Overview
  contents:
  - "8.1.  \"Bootstrap\" Mechanism Overview\n   It is unlikely that the bootstrap\
    \ mechanism will be appended to a\n   well-known network layer protocol, such\
    \ as IGMP [3], though this\n   would facilitate its ubiquitous (intra-domain)\
    \ deployment. Therefore,\n   each multicast routing protocol requiring the bootstrap\
    \ mechanism\n   must implement it as part of the multicast routing protocol itself.\n\
    \   A summary of the operation of the bootstrap mechanism follows\n   (details\
    \ are provided in [7]). It is assumed that all routers within\n   the domain implement\
    \ the \"bootstrap\" protocol, or at least forward\n   bootstrap protocol messages.\n\
    \   A subset of the domain's routers are configured to be CBT candidate\n   core\
    \ routers. Each candidate core router periodically (default every\n   60 secs)\
    \ advertises itself to the domain's Bootstrap Router (BSR),\n   using  \"Core\
    \ Advertisement\" messages.  The BSR is itself elected\n   dynamically from all\
    \ (or participating) routers in the domain.  The\n   domain's elected BSR collects\
    \ \"Core Advertisement\" messages from\n   candidate core routers and periodically\
    \ advertises a candidate core\n   set (CC-set) to each other router in the domain,\
    \ using traditional\n   hop- by-hop unicast forwarding. The BSR uses \"Bootstrap\
    \ Messages\" to\n   advertise the CC-set. Together, \"Core Advertisements\" and\
    \ \"Bootstrap\n   Messages\" comprise the \"bootstrap\" protocol.\n   When a router\
    \ receives an IGMP host membership report from one of its\n   directly attached\
    \ hosts, the local router uses a hash function on the\n   reported group address,\
    \ the result of which is used as an index into\n   the CC-set. This is how local\
    \ routers discover which core to use for\n   a particular group.\n   Note the\
    \ hash function is specifically tailored such that a small\n   number of consecutive\
    \ groups always hash to the same core.\n   Furthermore, bootstrap messages can\
    \ carry a \"group mask\", potentially\n   limiting a CC-set to a particular range\
    \ of groups. This can help\n   reduce traffic concentration at the core.\n   If\
    \ a BSR detects a particular core as being unreachable (it has not\n   announced\
    \ its availability within some period), it deletes the\n   relevant core from\
    \ the CC-set sent in its next bootstrap message.\n   This is how a local router\
    \ discovers a group's core is unreachable;\n   the router must re-hash for each\
    \ affected group and join the new core\n   after removing the old state. The removal\
    \ of the \"old\" state follows\n   the sending of a QUIT_NOTIFICATION upstream,\
    \ and a FLUSH_TREE message\n   downstream.\n"
- title: 8.2.  Bootstrap Message Format
  contents:
  - "8.2.  Bootstrap Message Format\n     0               1               2      \
    \         3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |             CBT common control packet header                  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |      For full Bootstrap Message specification, see [7]        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 9. Bootstrap Message Format\n"
- title: 8.3.  Candidate Core Advertisement Message Format
  contents:
  - "8.3.  Candidate Core Advertisement Message Format\n     0               1   \
    \            2               3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |              CBT common control packet header                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |   For full Candidate Core Adv. Message specification, see [7] |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \         Figure 10. Candidate Core Advertisement Message Format\n"
- title: 9.  Interoperability Issues
  contents:
  - "9.  Interoperability Issues\n   Interoperability between CBT and DVMRP is specified\
    \ in [5].\n   Interoperability with other multicast protocols will be fully\n\
    \   specified as the need arises.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   Security considerations are not addressed in\
    \ this memo.\n   Whilst multicast security is a topic of ongoing research, multicast\n\
    \   applications (users) nevertheless have the ability to take advantage\n   of\
    \ security services such as encryption or/and authentication\n   provided such\
    \ services are supported by the applications.\n   RFCs 1949 and 2093/2094 discuss\
    \ different ways of distributing\n   multicast key material, which can result\
    \ in the provision of network\n   layer access control to a multicast distribution\
    \ tree.\n   [9] offers a synopsis of multicast security threats and proposes some\n\
    \   possible counter measures.\n   Beyond these, little published work exists\
    \ on the topic of multicast\n   security.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Special thanks goes to Paul Francis, NTT Japan, for the\
    \ original\n   brainstorming sessions that brought about this work.\n   The emergence\
    \ of CBTv2 owes much to Clay Shields and his work on\n   Ordered CBT (OCBT) [8].\
    \ Clay identified and proved several failure\n   modes of CBT as it was specified\
    \ with multiple cores, and also\n   suggested using an unreliable quit mechanism,\
    \ which appears in this\n   specification as the QUIT_NOTIFICATION. Clay has also\
    \ provided more\n   general constructive comments on the CBT architecture and\n\
    \   specification.\n   Others that have contributed to the progress of CBT include\
    \ Ken\n   Carlberg, Eric Crawley, Jon Crowcroft, Mark Handley, Ahmed Helmy,\n\
    \   Nitin Jain, Alan O'Neill, Steven Ostrowsksi, Radia Perlman, Scott\n   Reeve,\
    \ Benny Rodrig, Martin Tatham, Dave Thaler, Sue Thompson, Paul\n   White, and\
    \ other participants of the IETF IDMR working group.\n   Thanks also to 3Com Corporation\
    \ and British Telecom Plc for funding\n   this work.\n"
- title: References
  contents:
  - "References\n   [1] Core Based Trees (CBT) Multicast Routing Architecture; A.\n\
    \   Ballardie; RFC 2201, September 1997.\n   [2] Protocol Independent Multicast\
    \ (PIM) Sparse Mode/Dense Mode; D.\n   Estrin et al; ftp://netweb.usc.edu/pim\
    \   Working drafts, 1996.\n   [3] Internet Group Management Protocol, version\
    \ 2 (IGMPv2); W.\n   Fenner; ftp://ds.internic.net/internet-drafts/draft-ietf-idmr-igmp-\n\
    \   v2-**.txt.  Working draft, 1996.\n   [4] Reynolds, J., and J. Postel, \"Assigned\
    \ Numbers\", STD 2, RFC 1700,\n   October 1994.\n   [5] CBT Border Router Specification\
    \ for Interconnecting a CBT Stub\n   Region to a DVMRP Backbone; A. Ballardie;\n\
    \   ftp://ds.internic.net/internet-drafts/draft-ietf-idmr-cbt-dm-\n   interop-**.txt.\
    \  Working draft,  March 1997.\n   [6] Ballardie, A., \"Scalable Multicast Key\
    \ Distribution\", RFC 1949,\n   July 1996.\n   [7] A Dynamic Bootstrap Mechanism\
    \ for Rendezvous-based Multicast\n   Routing; D. Estrin et al.; Technical Report;\n\
    \   ftp://catarina.usc.edu/pim\n   [8] The Ordered Core Based Tree Protocol; C.\
    \ Shields and J.J. Garcia-\n   Luna-Aceves; In Proceedings of IEEE Infocom'97,\
    \ Kobe, Japan, April\n   1997;\n   http://www.cse.ucsc.edu/research/ccrg/publications/infocomm97ocbt.ps.gz\n\
    \   [9]  Multicast-Specific Security Threats and Counter-Measures; A.\n   Ballardie\
    \ and J. Crowcroft; In Proceedings \"Symposium on Network and\n   Distributed\
    \ System Security\", February 1995, pp.2-16.\n"
- title: 'Author Information:'
  contents:
  - "Author Information:\n   Tony Ballardie,\n   Research Consultant\n   EMail: ABallardie@acm.org\n"
