- title: __initial_text__
  contents:
  - '                      PPP BSD Compression Protocol

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Point-to-Point Protocol (PPP) [1] provides a standard method\
    \ for\n   transporting multi-protocol datagrams over point-to-point links.\n \
    \  The PPP Compression Control Protocol [2] provides a method to\n   negotiate\
    \ and utilize compression protocols over PPP encapsulated\n   links.\n   This\
    \ document describes the use of the Unix Compress compression\n   protocol for\
    \ compressing PPP encapsulated packets.\n"
- title: Table of Contents
  contents:
  - 'Table of Contents

    '
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   UNIX compress as embodied in the freely and widely distributed\
    \ BSD\n   source has the following features:\n       - dynamic table clearing\
    \ when compression becomes less\n         effective.\n       - automatic turning\
    \ off of compression when the overall result\n         is not smaller than the\
    \ input.\n       - dynamic choice of code width within predetermined limits.\n\
    \       - heavily used for many years in networks, on modem and other\n      \
    \   point-to-point links to transfer netnews.\n       - an effective code width\
    \ requires less than 64KBytes of memory\n         on both sender and receive.\n"
- title: 1.1.  Licensing
  contents:
  - "1.1.  Licensing\n   BSD Unix compress command source is widely and freely available,\
    \ with\n   no additional license for many computer vendors.  The included source\n\
    \   code is based on the BSD compress command source and carries only the\n  \
    \ copyright of The Regents of the University of California.  Use the\n   code\
    \ entirely at your own risk. It has no warranties or\n   indemnifications of any\
    \ sort.  Note that there are patents on LZW.\n"
- title: 2.  BSD Compress Packets
  contents:
  - "2.  BSD Compress Packets\n   Before any BSD Compress packets may be communicated,\
    \ PPP must reach\n   the Network-Layer Protocol phase, and the CCP Control Protocol\
    \ must\n   reach the Opened state.\n   Exactly one BSD Compress datagram is encapsulated\
    \ in the PPP\n   Information field, where the PPP Protocol field contains 0xFD\
    \ or\n   0xFB.  0xFD is used when the PPP multilink protocol is not used or\n\
    \   \"above\" multilink.  0xFB is used \"below\" multilink, to compress\n   independently\
    \ on individual links of a multilink bundle.\n   The maximum length of the BSD\
    \ Compress datagram transmitted over a\n   PPP link is the same as the maximum\
    \ length of the Information field\n   of a PPP encapsulated packet.\n   Only packets\
    \ with PPP Protocol numbers in the range 0x0000 to 0x3FFF\n   and neither 0xFD\
    \ nor 0xFB are compressed.  Other PPP packets are\n   always sent uncompressed.\
    \  Control packets are infrequent and should\n   not be compressed for robustness.\n\
    \   Padding\n      BSD Compress packets require the previous negotiation of the\n\
    \      Self-Describing-Padding Configuration Option [3] if padding is\n      added\
    \ to packets.  If no padding is added, than Self-Describing-\n      Padding is\
    \ not required.\n   Reliability and Sequencing\n      BSD Compress requires the\
    \ packets to be delivered in sequence.  It\n      relies on Reset-Request and\
    \ Reset-Ack CCP packets or on\n      renegotiation of the Compression Control\
    \ Protocol [2] to indicate\n      loss of synchronization between the transmitter\
    \ and receiver.  The\n      HDLC FCS detects corrupted packets and the normal\
    \ mechanisms\n      discard them.  Missing or out of order packets are detected\
    \ by the\n      sequence number in each packet.  The packet sequence number ought\n\
    \      to be checked before decoding the packet.\n      Instead of transmitting\
    \ a Reset-Request packet when detecting a\n      decompression error, the receiver\
    \ MAY momentary force CCP to drop\n      out of the Opened state by transmitting\
    \ a new CCP Configure-\n      Request.  This method is more expensive than using\
    \ Reset-Requests.\n      When the receiver first encounters an unexpected sequence\
    \ number\n      it SHOULD send a Reset-Request CCP packet as defined in the\n\
    \      Compression Control Protocol.  When the transmitter sends the\n      Reset-Ack\
    \ or when the receiver receives a Reset-ACK, they must\n      reset the sequence\
    \ number to zero, clear the compression\n      dictionary, and resume sending\
    \ and receiving compressed packets.\n      The receiver MUST discard all compressed\
    \ packets after detecting\n      an error and until it receives a Reset-Ack. \
    \ This strategy can be\n      thought of as abandoning the transmission of one\
    \ \"file\" and\n      starting the transmission of a new \"file.\"\n      The\
    \ transmitter must clear its compression dictionary and respond\n      with a\
    \ Reset-Ack each time it receives a Reset-Request, because it\n      cannot know\
    \ if previous Reset-Acks reached the receiver.  The\n      receiver MUST clear\
    \ its compression dictionary each time it\n      receives a Reset-Ack, because\
    \ the transmitter will have cleared\n      its compression dictionary.\n     \
    \ When the link is busy, one decompression error is usually followed\n      by\
    \ several more before the Reset-Ack can be received.  It is\n      undesirable\
    \ to transmit Reset-Requests more frequently than the\n      round-trip-time of\
    \ the link, because redundant Reset-Requests\n      cause unnecessary compression\
    \ dictionary clearing.  The receiver\n      MAY transmit an additional Reset-Request\
    \ each time it receives a\n      compressed or uncompressed packet until it finally\
    \ receives a\n      Reset-Ack, but the receiver ought not transmit another Reset-\n\
    \      Request until the Reset-Ack for the previous one is late.  The\n      receiver\
    \ MUST transmit enough Reset-Request packets to ensure that\n      the transmitter\
    \ receives at least one.  For example, the receiver\n      might choose to not\
    \ transmit another Reset-Request until after one\n      second (or, of course,\
    \ a Reset-Ack has been received and\n      decompression resumed).\n   Data Expansion\n\
    \      When significant data expansion is detected, the PPP packet MUST\n    \
    \  be sent without compression.  Packets that would expand by fewer\n      than\
    \ 3 bytes SHOULD be sent without compression, but MAY be sent\n      compressed\
    \ provided the result does not exceed the MTU of the\n      link.  This makes\
    \ moot standards document exegesises about exactly\n      which bytes, such as\
    \ the Protocol fields, count toward expansion.\n      When a packet is received\
    \ with PPP Protocol numbers in the range\n      0x0000 to 0x3FFF, (except, of\
    \ course, 0xFD and 0xFB) it is assumed\n      that the packet would have caused\
    \ expansion.  The packet is\n      locally compressed to update the compression\
    \ history.\n      Sending incompressible packets in their native encapsulation\n\
    \      avoids maximum transmission unit complications.  If uncompressed\n    \
    \  packets could be larger than their native form, then it would be\n      necessary\
    \ for the upper layers of an implementation to treat the\n      PPP link as if\
    \ it had a smaller MTU, to ensure that compressed\n      incompressible packets\
    \ are never larger than the negotiated PPP\n      MTU.\n      Using native encapsulation\
    \ for incompressible packets complicates\n      the implementation.  The transmitter\
    \ and the receiver must start\n      putting information into the compression\
    \ dictionary starting with\n      the same packets, without relying upon seeing\
    \ a compressed packet\n      for synchronization.  The first few packets after\
    \ clearing the\n      dictionary are usually incompressible, and so are likely\
    \ to sent\n      in their native encapsulation, just like packets before\n   \
    \   compression is turned on.  If CCP or LCP packets are handled\n      separately\
    \ from Network-Layer packets (e.g. a \"daemon\" for control\n      packets and\
    \ \"kernel code\" for data packets), care must be taken to\n      ensure that\
    \ the transmitter synchronizes clearing the dictionary\n      with the transmission\
    \ of the configure-ACK or Reset-Ack that\n      starts compression, and the receiver\
    \ must similarly ensure that\n      its dictionary is cleared before it processes\
    \ the next packet.\n      A difficulty caused by sending data that would expand\
    \ uncompressed\n      is that the receiver must adaptively clear its dictionary\
    \ at\n      precisely the same times as the sender.  In the classic BSD\n    \
    \  compression code, the dictionary clearing is signaled by the\n      reserved\
    \ code 256.  Because data that would expend is sent without\n      compression,\
    \ there is no reliable way for the sender to signal\n      explicitly when it\
    \ has cleared its dictionary.  This difficulty is\n      resolved by specifying\
    \ the parameters that control the dictionary\n      clearing, and having both\
    \ sender and receiver clear their\n      dictionaries at the same times.\n"
- title: 2.1.  Packet Format
  contents:
  - "2.1.  Packet Format\n   A summary of the BSD Compress packet format is shown\
    \ below.\n   The fields are transmitted from left to right.\n    0           \
    \        1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         PPP Protocol          |           Sequence\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Data ...\n   +-+-+-+-+-+-+-+-+\n   PPP Protocol\n      The PPP Protocol\
    \ field is described in the Point-to-Point Protocol\n      Encapsulation [1].\n\
    \      When the BSD Compress compression protocol is successfully\n      negotiated\
    \ by the PPP Compression Control Protocol [2], the value\n      of the protocol\
    \ field is 0xFD or 0xFB.  This value MAY be\n      compressed when Protocol-Field-Compression\
    \ is negotiated.\n   Sequence\n      The sequence number is sent most significant\
    \ octet first.  It\n      starts at 0 when the dictionary is cleared, and is incremented\
    \ by\n      1 after each packet, including uncompressed packets.  The sequence\n\
    \      number after 65535 is zero.  In other words, the sequence number\n    \
    \  \"wraps\" in the usual way.\n      The sequence number ensures that lost or\
    \ out of order packets do\n      not cause the compression databases of the peers\
    \ to become\n      unsynchronized.  When an unexpected sequence number is\n  \
    \    encountered, the dictionaries must be resynchronized with a CCP\n      Reset-Request\
    \ or Configure-Request.  The packet sequence number\n      can be checked before\
    \ a compressed packet is decoded.\n   Data\n      The compressed PPP encapsulated\
    \ packet, consisting of the Protocol\n      and Data fields of the original, uncompressed\
    \ packet follows.\n      The Protocol field compression MUST be applied to the\
    \ protocol\n      field in the original packet before the sequence number is\n\
    \      computed or the entire packet is compressed, regardless of whether\n  \
    \    the PPP protocol field compression has been negotiated.  Thus, if\n     \
    \ the original protocol number was less than 0x100, it must be\n      compressed\
    \ to a single byte.\n      The format of the compressed data is more precisely\
    \ described by\n      the example code in the \"BSD Compress Algorithm\" appendix.\n"
- title: 3.  Configuration Option Format
  contents:
  - "3.  Configuration Option Format\n   Description\n      The CCP BSD Compress Configuration\
    \ Option negotiates the use of\n      BSD Compress on the link.  By default or\
    \ ultimate disagreement, no\n      compression is used.\n   A summary of the BSD\
    \ Compress Configuration Option format is shown\n   below.  The fields are transmitted\
    \ from left to right.\n    0                   1                   2\n    0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Type      |    Length     | Vers|   Dict  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Type\n      21 or 0x15 for BSD compress.\n   Length\n      3\n   Vers\n  \
    \    Must be the binary number 001.\n   Dict\n      The size in bits of the largest\
    \ code used.  It can range from 9 to\n      16.  A common choice is 12.  The code\
    \ included below can support\n      code sizes from 9 to 15.\n      It is convenient\
    \ to treat the byte containing the Vers and Dict\n      fields as a single field\
    \ with legal values ranging from 0x29 to\n      0x30.\n      Note that the peer\
    \ receiving compressed data must use the same\n      code size as the peer sending\
    \ data. It is not practical for the\n      receiver to use a larger dictionary\
    \ or code size, because both\n      dictionaries must be cleared at the same time,\
    \ even when the data\n      is not compressible, so that uncompressed packets\
    \ are being sent,\n      and so the receiver cannot receive LZW \"CLEAR\" codes.\n\
    \      When a received Configure-Request specifies a smaller dictionary\n    \
    \  than the local preference, it is often best to accept it instead\n      of\
    \ using a Configure-Nak to ask the peer to specify a larger\n      dictionary.\n"
- title: A.  BSD Compress Algorithm
  contents:
  - "A.  BSD Compress Algorithm\n   This code is the core of a commercial workstation\
    \ implementation.  It\n   was derived by transliterating the 4.*BSD compress command.\
    \  It is\n   unlikely to be of direct use in any system that does not have the\n\
    \   same mixture of mbufs and STREAMS buffers.  It may need to be retuned\n  \
    \ for CPU's other than RISC's with many registers and certain\n   addressing modes.\
    \  However, the code is the most accurate and\n   unambiguous way of defining\
    \ the changes to the BSD compress source\n   required to apply it to a stream\
    \ instead of a file.\n   Note that it assumes a \"short\" contains 16 bits and\
    \ an \"int\" contains\n   at least 32 bits.  Where it would matter if more than\
    \ 32 bits were in\n   an \"int\" or \"long,\" __uint32_t is used instead.\n"
- title: '/* Because this code is derived from the 4.3BSD compress source:'
  contents:
  - "/* Because this code is derived from the 4.3BSD compress source:\n *\n *\n *\
    \ Copyright (c) 1985, 1986 The Regents of the University of California.\n * All\
    \ rights reserved.\n *\n * This code is derived from software contributed to Berkeley\
    \ by\n * James A. Woods, derived from original work by Spencer Thomas\n * and\
    \ Joseph Orost.\n *\n * Redistribution and use in source and binary forms, with\
    \ or without\n * modification, are permitted provided that the following conditions\n\
    \ * are met:\n * 1. Redistributions of source code must retain the above copyright\n\
    \ *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions\
    \ in binary form must reproduce the above copyright\n *    notice, this list of\
    \ conditions and the following disclaimer in\n *    the documentation and/or other\
    \ materials provided with the\n *    distribution.\n * 3. All advertising materials\
    \ mentioning features or use of this\n *    software must display the following\
    \ acknowledgement:\n *      This product includes software developed by the University\
    \ of\n *      California, Berkeley and its contributors.\n * 4. Neither the name\
    \ of the University nor the names of its\n *    contributors may be used to endorse\
    \ or promote products derived\n *    from this software without specific prior\
    \ written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS\
    \ ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\
    \ TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR\
    \ PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS\n * OR CONTRIBUTORS BE\
    \ LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\
    \ DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\
    \ OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\
    \ CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\
    \ OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\
    \ USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\
    \ */\n"
- title: /* ***************** */
  contents:
  - '/* ***************** */

    '
- title: struct bsd_db {
  contents:
  - "struct bsd_db {\n    int     totlen;                     /* length of this structure\
    \ */\n    u_int   hsize;                      /* size of the hash table */\n \
    \   u_char  hshift;                     /* used in hash function */\n    u_char\
    \  n_bits;                     /* current bits/code */\n    u_char  debug;\n \
    \   u_char  unit;\n    u_short mru;\n    u_short seqno;                      /*\
    \ # of last byte of packet */\n    u_int   maxmaxcode;                 /* largest\
    \ valid code */\n    u_int   max_ent;                    /* largest code in use\
    \ */\n    u_int   in_count;                   /* uncompressed bytes */\n    u_int\
    \   bytes_out;                  /* compressed bytes */\n    u_int   ratio;   \
    \                   /* recent compression ratio */\n    u_int   checkpoint;  \
    \               /* when to next check ratio */\n    int     clear_count;     \
    \           /* times dictionary cleared */\n    int     incomp_count;        \
    \       /* incompressible packets */\n    int     decomp_count;              \
    \ /* packets decompressed */\n    int     overshoot;                  /* excess\
    \ decompression buf */\n    int     undershoot;                 /* insufficient\
    \ decomp. buf */\n    u_short *lens;                      /* array of lengths\
    \ of codes */\n    struct bsd_dict {\n        union {                        \
    \ /* hash value */\n            __uint32_t  fcode;\n            struct {\n"
- title: '#ifdef BSD_LITTLE_ENDIAN'
  contents:
  - "#ifdef BSD_LITTLE_ENDIAN\n                u_short prefix;         /* preceding\
    \ code */\n                u_char  suffix;         /* last character of new code\
    \ */\n                u_char  pad;\n"
- title: '#else'
  contents:
  - "#else\n                u_char  pad;\n                u_char  suffix;        \
    \ /* last character of new code */\n                u_short prefix;         /*\
    \ preceding code */\n"
- title: '#endif'
  contents:
  - "#endif\n            } hs;\n        } f;\n        u_short codem1;            \
    \     /* output of hash table -1 */\n        u_short cptr;                   /*\
    \ map code to hash table */\n    } dict[1];\n"
- title: '};'
  contents:
  - '};

    '
- title: '#define BSD_OVHD (2+2)                  /* overhead/packet */'
  contents:
  - '#define BSD_OVHD (2+2)                  /* overhead/packet */

    '
- title: '#define MIN_BSD_BITS    9'
  contents:
  - '#define MIN_BSD_BITS    9

    '
- title: '#define MAX_BSD_BITS    15              /* implementation limit */'
  contents:
  - '#define MAX_BSD_BITS    15              /* implementation limit */

    '
- title: '#define BSD_VERS        1               /* when shifted */'
  contents:
  - '#define BSD_VERS        1               /* when shifted */

    '
- title: '#ifdef _KERNEL'
  contents:
  - '#ifdef _KERNEL

    '
- title: extern struct bsd_db *pf_bsd_init(struct bsd_db*, int, int, int);
  contents:
  - 'extern struct bsd_db *pf_bsd_init(struct bsd_db*, int, int, int);

    '
- title: extern int pf_bsd_comp(struct bsd_db*,u_char*,int,struct mbuf*,int);
  contents:
  - 'extern int pf_bsd_comp(struct bsd_db*,u_char*,int,struct mbuf*,int);

    '
- title: extern mblk_t* pf_bsd_decomp(struct bsd_db*, mblk_t*);
  contents:
  - 'extern mblk_t* pf_bsd_decomp(struct bsd_db*, mblk_t*);

    '
- title: extern void pf_bsd_incomp(struct bsd_db*, mblk_t*, u_int);
  contents:
  - 'extern void pf_bsd_incomp(struct bsd_db*, mblk_t*, u_int);

    '
- title: '#endif'
  contents:
  - '#endif

    '
- title: /* ***************** */
  contents:
  - '/* ***************** */

    '
- title: /* PPP "BSD compress" compression
  contents:
  - "/* PPP \"BSD compress\" compression\n *  The differences between this compression\
    \ and the classic BSD LZW\n *  source are obvious from the requirement that the\
    \ classic code worked\n *  with files while this handles arbitrarily long streams\
    \ that\n *  are broken into packets.  They are:\n *\n *      When the code size\
    \ expands, a block of junk is not emitted by\n *          the compressor and not\
    \ expected by the decompressor.\n *\n *      New codes are not necessarily assigned\
    \ every time an old\n *          code is output by the compressor.  This is because\
    \ a packet\n *          end forces a code to be emitted, but does not imply that\
    \ a\n *          new sequence has been seen.\n *\n *      The compression ratio\
    \ is checked at the first end of a packet\n *          after the appropriate gap.\
    \  Besides simplifying and speeding\n *          things up, this makes it more\
    \ likely that the transmitter\n *          and receiver will agree when the dictionary\
    \ is cleared when\n *          compression is not going well.\n */\n"
- title: /*
  contents:
  - "/*\n * the next two codes should not be changed lightly, as they must not\n *\
    \ lie within the contiguous general code space.\n */\n"
- title: '#define CLEAR   256                     /* table clear output code */'
  contents:
  - '#define CLEAR   256                     /* table clear output code */

    '
- title: '#define FIRST   257                     /* first free entry */'
  contents:
  - '#define FIRST   257                     /* first free entry */

    '
- title: '#define LAST    255'
  contents:
  - '#define LAST    255

    '
- title: '#define BSD_INIT_BITS   MIN_BSD_BITS'
  contents:
  - '#define BSD_INIT_BITS   MIN_BSD_BITS

    '
- title: '#define MAXCODE(b) ((1 << (b)) - 1)'
  contents:
  - '#define MAXCODE(b) ((1 << (b)) - 1)

    '
- title: '#define BADCODEM1 MAXCODE(MAX_BSD_BITS);'
  contents:
  - '#define BADCODEM1 MAXCODE(MAX_BSD_BITS);

    '
- title: '#define BSD_HASH(prefix,suffix,hshift) ((((__uint32_t)(suffix)) \'
  contents:
  - "#define BSD_HASH(prefix,suffix,hshift) ((((__uint32_t)(suffix)) \\\n        \
    \                                 << (hshift)) \\\n                          \
    \              ^ (__uint32_t)(prefix))\n"
- title: '#define BSD_KEY(prefix,suffix) ((((__uint32_t)(suffix)) << 16)  \'
  contents:
  - "#define BSD_KEY(prefix,suffix) ((((__uint32_t)(suffix)) << 16)  \\\n        \
    \                        + (__uint32_t)(prefix))\n"
- title: '#define CHECK_GAP       10000           /* Ratio check interval */'
  contents:
  - '#define CHECK_GAP       10000           /* Ratio check interval */

    '
- title: '#define RATIO_SCALE_LOG 8'
  contents:
  - '#define RATIO_SCALE_LOG 8

    '
- title: '#define RATIO_SCALE     (1<<RATIO_SCALE_LOG)'
  contents:
  - '#define RATIO_SCALE     (1<<RATIO_SCALE_LOG)

    '
- title: '#define RATIO_MAX       (0x7fffffff>>RATIO_SCALE_LOG)'
  contents:
  - '#define RATIO_MAX       (0x7fffffff>>RATIO_SCALE_LOG)

    '
- title: /* clear the dictionary
  contents:
  - "/* clear the dictionary\n */\n"
- title: static void
  contents:
  - 'static void

    '
- title: pf_bsd_clear(struct bsd_db *db)
  contents:
  - 'pf_bsd_clear(struct bsd_db *db)

    '
- title: '{'
  contents:
  - "{\n        db->clear_count++;\n        db->max_ent = FIRST-1;\n        db->n_bits\
    \ = BSD_INIT_BITS;\n        db->ratio = 0;\n        db->bytes_out = 0;\n     \
    \   db->in_count = 0;\n        db->incomp_count = 0;\n        db->decomp_count\
    \ = 0;\n        db->overshoot = 0;\n        db->undershoot = 0;\n        db->checkpoint\
    \ = CHECK_GAP;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* If the dictionary is full, then see if it is time to reset it.
  contents:
  - "/* If the dictionary is full, then see if it is time to reset it.\n *\n * Compute\
    \ the compression ratio using fixed-point arithmetic\n * with 8 fractional bits.\n\
    \ *\n * Since we have an infinite stream instead of a single file,\n * watch only\
    \ the local compression ratio.\n *\n * Since both peers must reset the dictionary\
    \ at the same time even in\n * the absence of CLEAR codes (while packets are incompressible),\
    \ they\n * must compute the same ratio.\n */\n"
- title: static int                              /* 1=output CLEAR */
  contents:
  - 'static int                              /* 1=output CLEAR */

    '
- title: pf_bsd_check(struct bsd_db *db)
  contents:
  - 'pf_bsd_check(struct bsd_db *db)

    '
- title: '{'
  contents:
  - "{\n        register u_int new_ratio;\n        if (db->in_count >= db->checkpoint)\
    \ {\n                /* age the ratio by limiting the size of the counts */\n\
    \                if (db->in_count >= RATIO_MAX\n                    || db->bytes_out\
    \ >= RATIO_MAX) {\n                        db->in_count -= db->in_count/4;\n \
    \                       db->bytes_out -= db->bytes_out/4;\n                }\n\
    \                db->checkpoint = db->in_count + CHECK_GAP;\n                if\
    \ (db->max_ent >= db->maxmaxcode) {\n                        /* Reset the dictionary\
    \ only if the ratio is\n                         * worse, or if it looks as if\
    \ it has been\n                         * poisoned by incompressible data.\n \
    \                        *\n                         * This does not overflow,\
    \ because\n                         *      db->in_count <= RATIO_MAX.\n      \
    \                   */\n                        new_ratio = db->in_count<<RATIO_SCALE_LOG;\n\
    \                        if (db->bytes_out != 0)\n                           \
    \     new_ratio /= db->bytes_out;\n                        if (new_ratio < db->ratio\n\
    \                            || new_ratio < 1*RATIO_SCALE) {\n               \
    \                 pf_bsd_clear(db);\n                                return 1;\n\
    \                        }\n                        db->ratio = new_ratio;\n \
    \               }\n        }\n        return 0;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Initialize the database.
  contents:
  - "/* Initialize the database.\n */\n"
- title: struct bsd_db *
  contents:
  - 'struct bsd_db *

    '
- title: pf_bsd_init(struct bsd_db *db,          /* initialize this database */
  contents:
  - "pf_bsd_init(struct bsd_db *db,          /* initialize this database */\n    \
    \        int unit,                   /* for debugging */\n            int bits,\
    \                   /* size of LZW code word */\n            int mru)        \
    \            /* MRU for input, 0 for output*/\n"
- title: '{'
  contents:
  - "{\n        register int i;\n        register u_short *lens;\n        register\
    \ u_int newlen, hsize, hshift, maxmaxcode;\n        switch (bits) {\n        case\
    \ 9:                         /* needs 82152 for both comp &*/\n        case 10:\
    \                        /* needs 84144          decomp*/\n        case 11:  \
    \                      /* needs 88240 */\n        case 12:                   \
    \     /* needs 96432 */\n                hsize = 5003;\n                hshift\
    \ = 4;\n                break;\n        case 13:                        /* needs\
    \ 176784 */\n                hsize = 9001;\n                hshift = 5;\n    \
    \            break;\n        case 14:                        /* needs 353744 */\n\
    \                hsize = 18013;\n                hshift = 6;\n               \
    \ break;\n        case 15:                        /* needs 691440 */\n       \
    \         hsize = 35023;\n                hshift = 7;\n                break;\n\
    \        case 16:                        /* needs 1366160--far too much*/\n  \
    \              /* hsize = 69001; */    /* and 69001 is too big for */\n      \
    \          /* hshift = 8; */       /* cptr in struct bsd_db */\n             \
    \   /* break; */\n        default:\n                if (db) {\n              \
    \          if (db->lens)\n                                kern_free(db->lens);\n\
    \                        kern_free(db);\n                }\n                return\
    \ 0;\n        }\n        maxmaxcode = MAXCODE(bits);\n        newlen = sizeof(*db)\
    \ + (hsize-1)*(sizeof(db->dict[0]));\n        if (db) {\n                lens\
    \ = db->lens;\n                if (db->totlen != newlen) {\n                 \
    \       if (lens)\n                                kern_free(lens);\n        \
    \                kern_free(db);\n                        db = 0;\n           \
    \     }\n        }\n        if (!db) {\n                db = (struct bsd_db*)kern_malloc(newlen);\n\
    \                if (!db)\n                        return 0;\n               \
    \ if (mru == 0) {\n                        lens = 0;\n                } else {\n\
    \                        lens = (u_short*)kern_malloc((maxmaxcode+1)\n       \
    \                                              * sizeof(*lens));\n           \
    \             if (!lens) {\n                                kern_free(db);\n \
    \                               return 0;\n                        }\n       \
    \                 i = LAST+1;\n                        while (i != 0)\n      \
    \                          lens[--i] = 1;\n                }\n               \
    \ i = hsize;\n                while (i != 0) {\n                        db->dict[--i].codem1\
    \ = BADCODEM1;\n                        db->dict[i].cptr = 0;\n              \
    \  }\n        }\n        bzero(db,sizeof(*db)-sizeof(db->dict));\n        db->lens\
    \ = lens;\n        db->unit = unit;\n        db->mru = mru;\n        db->hsize\
    \ = hsize;\n        db->hshift = hshift;\n        db->maxmaxcode = maxmaxcode;\n\
    \        db->clear_count = -1;\n        pf_bsd_clear(db);\n        return db;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* compress a packet
  contents:
  - "/* compress a packet\n *      Assume the protocol is known to be >= 0x21 and\
    \ < 0xff.\n *      One change from the BSD compress command is that when the\n\
    \ *      code size expands, we do not output a bunch of padding.\n */\n"
- title: int                                     /* new slen */
  contents:
  - 'int                                     /* new slen */

    '
- title: pf_bsd_comp(struct bsd_db *db,
  contents:
  - "pf_bsd_comp(struct bsd_db *db,\n            u_char *cp_buf,             /* compress\
    \ into here */\n            int proto,                  /* this original PPP protocol\
    \ */\n            struct mbuf *m,             /* from here */\n            int\
    \ slen)\n"
- title: '{'
  contents:
  - "{\n        register int hshift = db->hshift;\n        register u_int max_ent\
    \ = db->max_ent;\n        register u_int n_bits = db->n_bits;\n        register\
    \ u_int bitno = 32;\n        register __uint32_t accum = 0;\n        register\
    \ struct bsd_dict *dictp;\n        register __uint32_t fcode;\n        register\
    \ u_char c;\n        register int hval, disp, ent;\n        register u_char *rptr,\
    \ *wptr;\n        struct mbuf *n;\n"
- title: '#define OUTPUT(ent) {                   \'
  contents:
  - "#define OUTPUT(ent) {                   \\\n        bitno -= n_bits;        \
    \        \\\n        accum |= ((ent) << bitno);      \\\n        do {        \
    \                    \\\n                *wptr++ = accum>>24;    \\\n        \
    \        accum <<= 8;            \\\n                bitno += 8;             \\\
    \n        } while (bitno <= 24);          \\\n        }\n        /* start with\
    \ the protocol byte */\n        ent = proto;\n        db->in_count++;\n      \
    \  /* install sequence number */\n        cp_buf[0] = db->seqno>>8;\n        cp_buf[1]\
    \ = db->seqno;\n        db->seqno++;\n        wptr = &cp_buf[2];\n        slen\
    \ = m->m_len;\n        db->in_count += slen;\n        rptr = mtod(m, u_char*);\n\
    \        n = m->m_next;\n        for (;;) {\n                if (slen == 0) {\n\
    \                        if (!n)\n                                break;\n   \
    \                     slen = n->m_len;\n                        rptr = mtod(n,\
    \ u_char*);\n                        n = n->m_next;\n                        if\
    \ (!slen)\n                                continue;   /* handle 0-length buffers*/\n\
    \                        db->in_count += slen;\n                }\n          \
    \      slen--;\n                c = *rptr++;\n                fcode = BSD_KEY(ent,c);\n\
    \                hval = BSD_HASH(ent,c,hshift);\n                dictp = &db->dict[hval];\n\
    \                /* Validate and then check the entry. */\n                if\
    \ (dictp->codem1 >= max_ent)\n                        goto nomatch;\n        \
    \        if (dictp->f.fcode == fcode) {\n                        ent = dictp->codem1+1;\n\
    \                        continue;       /* found (prefix,suffix) */\n       \
    \         }\n                /* continue probing until a match or invalid entry\
    \ */\n                disp = (hval == 0) ? 1 : hval;\n                do {\n \
    \                       hval += disp;\n                        if (hval >= db->hsize)\n\
    \                                hval -= db->hsize;\n                        dictp\
    \ = &db->dict[hval];\n                        if (dictp->codem1 >= max_ent)\n\
    \                                goto nomatch;\n                } while (dictp->f.fcode\
    \ != fcode);\n                ent = dictp->codem1+1;  /* found (prefix,suffix)\
    \ */\n                continue;\n"
- title: 'nomatch:'
  contents:
  - "nomatch:\n                OUTPUT(ent);            /* output the prefix */\n \
    \               /* code -> hashtable */\n                if (max_ent < db->maxmaxcode)\
    \ {\n                        struct bsd_dict *dictp2;\n                      \
    \  /* expand code size if needed */\n                        if (max_ent >= MAXCODE(n_bits))\n\
    \                                db->n_bits = ++n_bits;\n                    \
    \    /* Invalidate old hash table entry using\n                         * this\
    \ code, and then take it over.\n                         */\n                \
    \        dictp2 = &db->dict[max_ent+1];\n                        if (db->dict[dictp2->cptr].codem1\
    \ == max_ent)\n                                db->dict[dictp2->cptr].codem1=BADCODEM1;\n\
    \                        dictp2->cptr = hval;\n                        dictp->codem1\
    \ = max_ent;\n                        dictp->f.fcode = fcode;\n              \
    \          db->max_ent = ++max_ent;\n                }\n                ent =\
    \ c;\n        }\n        OUTPUT(ent);                    /* output the last code\
    \ */\n        db->bytes_out += (wptr-&cp_buf[2]   /* count complete bytes */\n\
    \                          + (32-bitno+7)/8);\n        if (pf_bsd_check(db))\n\
    \                OUTPUT(CLEAR);          /* do not count the CLEAR */\n      \
    \  /* Pad dribble bits of last code with ones.\n         * Do not emit a completely\
    \ useless byte of ones.\n         */\n        if (bitno != 32)\n             \
    \   *wptr++ = (accum | (0xff << (bitno-8))) >> 24;\n        /* Increase code size\
    \ if we would have without the packet\n         * boundary and as the decompressor\
    \ will.\n         */\n        if (max_ent >= MAXCODE(n_bits)\n            && max_ent\
    \ < db->maxmaxcode)\n                db->n_bits++;\n        return (wptr - cp_buf);\n"
- title: '#undef OUTPUT'
  contents:
  - '#undef OUTPUT

    '
- title: '}'
  contents:
  - '}

    '
- title: /* Update the "BSD Compress" dictionary on the receiver for
  contents:
  - "/* Update the \"BSD Compress\" dictionary on the receiver for\n * incompressible\
    \ data by pretending to compress the incoming data.\n */\n"
- title: void
  contents:
  - 'void

    '
- title: pf_bsd_incomp(struct bsd_db *db,
  contents:
  - "pf_bsd_incomp(struct bsd_db *db,\n              mblk_t *dmsg,\n             \
    \ u_int ent)                /* start with protocol byte */\n"
- title: '{'
  contents:
  - "{\n        register u_int hshift = db->hshift;\n        register u_int max_ent\
    \ = db->max_ent;\n        register u_int n_bits = db->n_bits;\n        register\
    \ struct bsd_dict *dictp;\n        register __uint32_t fcode;\n        register\
    \ u_char c;\n        register int hval, disp;\n        register int slen;\n  \
    \      register u_int bitno = 7;\n        register u_char *rptr;\n        db->incomp_count++;\n\
    \        db->in_count++;                 /* count protocol as 1 byte */\n    \
    \    db->seqno++;\n        rptr = dmsg->b_rptr+PPP_BUF_HEAD_INFO;\n        for\
    \ (;;) {\n                slen = dmsg->b_wptr - rptr;\n                if (slen\
    \ == 0) {\n                        dmsg = dmsg->b_cont;\n                    \
    \    if (!dmsg)\n                                break;\n                    \
    \    rptr = dmsg->b_rptr;\n                        continue;       /* skip zero-length\
    \ buffers */\n                }\n                db->in_count += slen;\n     \
    \           do {\n                        c = *rptr++;\n                     \
    \   fcode = BSD_KEY(ent,c);\n                        hval = BSD_HASH(ent,c,hshift);\n\
    \                        dictp = &db->dict[hval];\n                        /*\
    \ validate and then check the entry */\n                        if (dictp->codem1\
    \ >= max_ent)\n                                goto nomatch;\n               \
    \         if (dictp->f.fcode == fcode) {\n                                ent\
    \ = dictp->codem1+1;\n                                continue;   /* found (prefix,suffix)\
    \ */\n                        }\n                        /* continue until match\
    \ or invalid entry */\n                        disp = (hval == 0) ? 1 : hval;\n\
    \                        do {\n                                hval += disp;\n\
    \                                if (hval >= db->hsize)\n                    \
    \                    hval -= db->hsize;\n                                dictp\
    \ = &db->dict[hval];\n                                if (dictp->codem1 >= max_ent)\n\
    \                                        goto nomatch;\n                     \
    \   } while (dictp->f.fcode != fcode);\n                        ent = dictp->codem1+1;\n\
    \                        continue;       /* found (prefix,suffix) */\n"
- title: 'nomatch:                                /* output (count) the prefix */'
  contents:
  - "nomatch:                                /* output (count) the prefix */\n   \
    \                     bitno += n_bits;\n                        /* code -> hashtable\
    \ */\n                        if (max_ent < db->maxmaxcode) {\n              \
    \              struct bsd_dict *dictp2;\n                            /* expand\
    \ code size if needed */\n                            if (max_ent >= MAXCODE(n_bits))\n\
    \                                    db->n_bits = ++n_bits;\n                \
    \            /* Invalidate previous hash table entry\n                       \
    \      * assigned this code, and then take it over\n                         \
    \    */\n                            dictp2 = &db->dict[max_ent+1];\n        \
    \                    if (db->dict[dictp2->cptr].codem1==max_ent)\n           \
    \                     db->dict[dictp2->cptr].codem1=BADCODEM1;\n             \
    \               dictp2->cptr = hval;\n                            dictp->codem1\
    \ = max_ent;\n                            dictp->f.fcode = fcode;\n          \
    \                  db->max_ent = ++max_ent;\n                            db->lens[max_ent]\
    \ = db->lens[ent]+1;\n                        }\n                        ent =\
    \ c;\n                } while (--slen != 0);\n        }\n        bitno += n_bits;\
    \                /* output (count) last code */\n        db->bytes_out += bitno/8;\n\
    \        (void)pf_bsd_check(db);\n        /* Increase code size if we would have\
    \ without the packet\n         * boundary and as the decompressor will.\n    \
    \     */\n        if (max_ent >= MAXCODE(n_bits)\n            && max_ent < db->maxmaxcode)\n\
    \                db->n_bits++;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Decompress "BSD Compress"
  contents:
  - "/* Decompress \"BSD Compress\"\n */\n"
- title: mblk_t*                                 /* 0=failed, so zap CCP */
  contents:
  - 'mblk_t*                                 /* 0=failed, so zap CCP */

    '
- title: pf_bsd_decomp(struct bsd_db *db,
  contents:
  - "pf_bsd_decomp(struct bsd_db *db,\n              mblk_t *cmsg)\n"
- title: '{'
  contents:
  - "{\n        register u_int max_ent = db->max_ent;\n        register __uint32_t\
    \ accum = 0;\n        register u_int bitno = 32;      /* 1st valid bit in accum\
    \ */\n        register u_int n_bits = db->n_bits;\n        register u_int tgtbitno\
    \ = 32-n_bits; /* bitno when accum full */\n        register struct bsd_dict *dictp;\n\
    \        register int explen, i;\n        register u_int incode, oldcode, finchar;\n\
    \        register u_char *p, *rptr, *rptr9, *wptr0, *wptr;\n        mblk_t *dmsg,\
    \ *dmsg1, *bp;\n        db->decomp_count++;\n        rptr = cmsg->b_rptr;\n  \
    \      ASSERT(cmsg->b_wptr >= rptr+PPP_BUF_MIN);\n        ASSERT(PPP_BUF_ALIGN(rptr));\n\
    \        rptr += PPP_BUF_MIN;\n        /* get the sequence number */\n       \
    \ i = 0;\n        explen = 2;\n        do {\n                while (rptr >= cmsg->b_wptr)\
    \ {\n                        bp = cmsg;\n                        cmsg = cmsg->b_cont;\n\
    \                        freeb(bp);\n                        if (!cmsg) {\n  \
    \                              if (db->debug)\n                              \
    \          printf(\"bsd_decomp%d: missing\"\n                                \
    \               \" %d header bytes\\n\",\n                                   \
    \            db->unit, explen);\n                                return 0;\n \
    \                       }\n                        rptr = cmsg->b_rptr;\n    \
    \            }\n                i = (i << 8) + *rptr++;\n        } while (--explen\
    \ != 0);\n        if (i != db->seqno++) {\n                freemsg(cmsg);\n  \
    \              if (db->debug)\n                        printf(\"bsd_decomp%d:\
    \ bad sequence number 0x%x\"\n                               \" instead of 0x%x\\\
    n\",\n                               db->unit, i, db->seqno-1);\n            \
    \    return 0;\n        }\n        /* Guess how much memory we will need.  Assume\
    \ this packet was\n         * compressed by at least 1.5X regardless of the recent\
    \ ratio.\n         */\n        if (db->ratio > (RATIO_SCALE*3)/2)\n          \
    \      explen = (msgdsize(cmsg)*db->ratio)/RATIO_SCALE;\n        else\n      \
    \          explen = (msgdsize(cmsg)*3)/2;\n        if (explen > db->mru)\n   \
    \             explen = db->mru;\n        dmsg = dmsg1 = allocb(explen+PPP_BUF_HEAD_INFO,\
    \ BPRI_HI);\n        if (!dmsg1) {\n                freemsg(cmsg);\n         \
    \       return 0;\n        }\n        wptr = dmsg1->b_wptr;\n        ((struct\
    \ ppp_buf*)wptr)->type = BEEP_FRAME;\n        /* the protocol field must be compressed\
    \ */\n        ((struct ppp_buf*)wptr)->proto = 0;\n        wptr += PPP_BUF_HEAD_PROTO+1;\n\
    \        rptr9 = cmsg->b_wptr;\n        db->bytes_out += rptr9-rptr;\n       \
    \ wptr0 = wptr;\n        explen = dmsg1->b_datap->db_lim - wptr;\n        oldcode\
    \ = CLEAR;\n        for (;;) {\n                if (rptr >= rptr9) {\n       \
    \                 bp = cmsg;\n                        cmsg = cmsg->b_cont;\n \
    \                       freeb(bp);\n                        if (!cmsg)      /*\
    \ quit at end of message */\n                                break;\n        \
    \                rptr = cmsg->b_rptr;\n                        rptr9 = cmsg->b_wptr;\n\
    \                        db->bytes_out += rptr9-rptr;\n                      \
    \  continue;       /* handle 0-length buffers */\n                }\n        \
    \        /* Accumulate bytes until we have a complete code.\n                \
    \ * Then get the next code, relying on the 32-bit,\n                 * unsigned\
    \ accum to mask the result.\n                 */\n                bitno -= 8;\n\
    \                accum |= *rptr++ << bitno;\n                if (tgtbitno < bitno)\n\
    \                        continue;\n                incode = accum >> tgtbitno;\n\
    \                accum <<= n_bits;\n                bitno += n_bits;\n       \
    \         if (incode == CLEAR) {\n                        /* The dictionary must\
    \ only be cleared at\n                         * the end of a packet.  But there\
    \ could be an\n                         * empty message block at the end.\n  \
    \                       */\n                        if (rptr != rptr9\n      \
    \                      || cmsg->b_cont != 0) {\n                             \
    \   cmsg->b_rptr = rptr;\n                                i = msgdsize(cmsg);\n\
    \                                if (i != 0) {\n                             \
    \           freemsg(dmsg);\n                                        freemsg(cmsg);\n\
    \                                        if (db->debug)\n                    \
    \                            printf(\"bsd_decomp%d: \"\n                     \
    \                                  \"bad CLEAR\\n\",\n                       \
    \                                db->unit);\n                                \
    \        return 0;\n                                }\n                      \
    \  }\n                        pf_bsd_clear(db);\n                        freemsg(cmsg);\n\
    \                        wptr0 = wptr;\n                        break;\n     \
    \           }\n                /* Special case for KwKwK string. */\n        \
    \        if (incode > max_ent) {\n                        if (incode > max_ent+2\n\
    \                            || incode > db->maxmaxcode\n                    \
    \        || oldcode == CLEAR) {\n                                freemsg(dmsg);\n\
    \                                freemsg(cmsg);\n                            \
    \    if (db->debug)\n                                   printf(\"bsd_decomp%d:\
    \ bad code %x\\n\",\n                                          db->unit, incode);\n\
    \                                return 0;\n                        }\n      \
    \                  i = db->lens[oldcode];\n                        /* do not write\
    \ past end of buf */\n                        explen -= i+1;\n               \
    \         if (explen < 0) {\n                                db->undershoot -=\
    \ explen;\n                                db->in_count += wptr-wptr0;\n     \
    \                           dmsg1->b_wptr = wptr;\n                          \
    \      CK_WPTR(dmsg1);\n                                explen = MAX(64,i+1);\n\
    \                                bp = allocb(explen, BPRI_HI);\n             \
    \                   if (!bp) {\n                                        freemsg(cmsg);\n\
    \                                        freemsg(dmsg);\n                    \
    \                    return 0;\n                                }\n          \
    \                      dmsg1->b_cont = bp;\n                                dmsg1\
    \ = bp;\n                                wptr0 = wptr = dmsg1->b_wptr;\n     \
    \                          explen=dmsg1->b_datap->db_lim-wptr-(i+1);\n       \
    \                 }\n                        p = (wptr += i);\n              \
    \          *wptr++ = finchar;\n                        finchar = oldcode;\n  \
    \              } else {\n                        i = db->lens[finchar = incode];\n\
    \                        explen -= i;\n                        if (explen < 0)\
    \ {\n                                db->undershoot -= explen;\n             \
    \                   db->in_count += wptr-wptr0;\n                            \
    \    dmsg1->b_wptr = wptr;\n                                CK_WPTR(dmsg1);\n\
    \                                explen = MAX(64,i);\n                       \
    \         bp = allocb(explen, BPRI_HI);\n                                if (!bp)\
    \ {\n                                        freemsg(dmsg);\n                \
    \                        freemsg(cmsg);\n                                    \
    \    return 0;\n                                }\n                          \
    \      dmsg1->b_cont = bp;\n                                dmsg1 = bp;\n    \
    \                            wptr0 = wptr = dmsg1->b_wptr;\n                 \
    \               explen = dmsg1->b_datap->db_lim-wptr-i;\n                    \
    \    }\n                        p = (wptr += i);\n                }\n        \
    \        /* decode code and install in decompressed buffer */\n              \
    \  while (finchar > LAST) {\n                        dictp = &db->dict[db->dict[finchar].cptr];\n\
    \                        *--p = dictp->f.hs.suffix;\n                        finchar\
    \ = dictp->f.hs.prefix;\n                }\n                *--p = finchar;\n\
    \                /* If not first code in a packet, and\n                 * if\
    \ not out of code space, then allocate a new code.\n                 *\n     \
    \            * Keep the hash table correct so it can be used\n               \
    \  * with uncompressed packets.\n                 */\n                if (oldcode\
    \ != CLEAR\n                    && max_ent < db->maxmaxcode) {\n             \
    \           struct bsd_dict *dictp2;\n                        __uint32_t fcode;\n\
    \                        int hval, disp;\n                        fcode = BSD_KEY(oldcode,finchar);\n\
    \                        hval = BSD_HASH(oldcode,finchar,db->hshift);\n      \
    \                  dictp = &db->dict[hval];\n                        /* look for\
    \ a free hash table entry */\n                        if (dictp->codem1 < max_ent)\
    \ {\n                                disp = (hval == 0) ? 1 : hval;\n        \
    \                        do {\n                                        hval +=\
    \ disp;\n                                        if (hval >= db->hsize)\n    \
    \                                            hval -= db->hsize;\n            \
    \                            dictp = &db->dict[hval];\n                      \
    \          } while (dictp->codem1 < max_ent);\n                        }\n   \
    \                     /* Invalidate previous hash table entry\n              \
    \           * assigned this code, and then take it over\n                    \
    \     */\n                        dictp2 = &db->dict[max_ent+1];\n           \
    \             if (db->dict[dictp2->cptr].codem1 == max_ent) {\n              \
    \                  db->dict[dictp2->cptr].codem1=BADCODEM1;\n                \
    \        }\n                        dictp2->cptr = hval;\n                   \
    \     dictp->codem1 = max_ent;\n                        dictp->f.fcode = fcode;\n\
    \                        db->max_ent = ++max_ent;\n                        db->lens[max_ent]\
    \ = db->lens[oldcode]+1;\n                        /* Expand code size if needed.\n\
    \                         */\n                        if (max_ent >= MAXCODE(n_bits)\n\
    \                            && max_ent < db->maxmaxcode) {\n                \
    \                db->n_bits = ++n_bits;\n                                tgtbitno\
    \ = 32-n_bits;\n                        }\n                }\n               \
    \ oldcode = incode;\n        }\n        db->in_count += wptr-wptr0;\n        dmsg1->b_wptr\
    \ = wptr;\n        CK_WPTR(dmsg1);\n        db->overshoot += explen;\n       \
    \ /* Keep the checkpoint right so that incompressible packets\n         * clear\
    \ the dictionary at the right times.\n         */\n        if (pf_bsd_check(db)\n\
    \            && db->debug) {\n                printf(\"bsd_decomp%d: peer should\
    \ have \"\n                       \"cleared dictionary\\n\", db->unit);\n    \
    \    }\n        return dmsg;\n"
- title: '}'
  contents:
  - '}

    '
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: References
  contents:
  - "References\n   [1]   Simpson, W., \"The Point-to-Point Protocol (PPP)\", STD\
    \ 51,\n         RFC 1661, July 1994.\n   [2]   Rand, D., \"The PPP Compression\
    \ Control Protocol (CCP)\", RFC\n         1962, June 1996.\n   [3]   Simpson,\
    \ W., \"PPP LCP Extensions\", RFC 1570, January 1994.\n   [4]   Simpson, W., \"\
    PPP in HDLC-like Framing\", STD 51, RFC 1662,\n         July 1994.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   William Simpson provided and supported the very valuable\
    \ idea of not\n   using any additional header bytes for incompressible packets.\n"
- title: Chair's Address
  contents:
  - "Chair's Address\n   The working group can be contacted via the current chair:\n\
    \   Karl Fox\n   Ascend Communications\n   3518 Riverside Drive, Suite 101\n \
    \  Columbus, Ohio 43221\n   EMail: karl@ascend.com\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Questions about this memo can also be directed to:\n   Vernon\
    \ Schryver\n   2482 Lee Hill Drive\n   Boulder, Colorado 80302\n   EMail: vjs@rhyolite.com\n"
