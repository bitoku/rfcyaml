- title: __initial_text__
  contents:
  - ''
- title: Internet Research Task Force (IRTF)                            J. Buford
  contents:
  - "Internet Research Task Force (IRTF)                            J. Buford\n  \
    \               Application-Layer Multicast Extensions\n              to REsource\
    \ LOcation And Discovery (RELOAD)\n"
- title: Abstract
  contents:
  - "Abstract\n   We define a REsource LOcation And Discovery (RELOAD) Usage for\n\
    \   Application-Layer Multicast (ALM) as well as a mapping to the RELOAD\n   experimental\
    \ message type to support ALM.  The ALM Usage is intended\n   to support a variety\
    \ of ALM control algorithms in an overlay-\n   independent way.  Two example algorithms\
    \ are defined, based on Scribe\n   and P2PCast.\n   This document is a product\
    \ of the Scalable Adaptive Multicast\n   Research Group (SAM RG).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Research Task\n   Force (IRTF).\
    \  The IRTF publishes the results of Internet-related\n   research and development\
    \ activities.  These results might not be\n   suitable for deployment.  This RFC\
    \ represents the consensus of the\n   Scalable Adaptive Multicast Research Group\
    \ of the Internet Research\n   Task Force (IRTF).  Documents approved for publication\
    \ by the IRSG\n   are not a candidate for any level of Internet Standard; see\
    \ Section 2\n   of RFC 5741.\n   Information about the current status of this\
    \ document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7019.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Requirements Language ......................................5\n  \
    \ 2. Definitions .....................................................5\n    \
    \  2.1. Overlay Network ............................................5\n      2.2.\
    \ Overlay Multicast ..........................................5\n      2.3. Source-Specific\
    \ Multicast (SSM) ............................6\n      2.4. Any-Source Multicast\
    \ (ASM) .................................6\n      2.5. Peer .......................................................6\n\
    \   3. Assumptions .....................................................6\n  \
    \    3.1. Overlay ....................................................6\n    \
    \  3.2. Overlay Multicast ..........................................7\n      3.3.\
    \ RELOAD .....................................................7\n      3.4. NAT\
    \ ........................................................7\n      3.5. Tree Topology\
    \ ..............................................7\n   4. Architecture Extensions\
    \ to RELOAD ...............................7\n   5. RELOAD ALM Usage ................................................9\n\
    \   6. ALM Tree Control Signaling ......................................9\n  \
    \ 7. ALM Messages Mapped to RELOAD ..................................11\n    \
    \  7.1. Introduction ..............................................11\n      7.2.\
    \ Tree Lifecycle Messages ...................................12\n           7.2.1.\
    \ CreateALMTree ......................................12\n           7.2.2. CreateALMTreeResponse\
    \ ..............................13\n           7.2.3. Join ...............................................13\n\
    \           7.2.4. JoinAccept (Join Response) .........................14\n  \
    \         7.2.5. JoinReject (Join Response) .........................15\n    \
    \       7.2.6. JoinConfirm ........................................15\n      \
    \     7.2.7. JoinConfirmResponse ................................16\n        \
    \   7.2.8. JoinDecline ........................................16\n          \
    \ 7.2.9. JoinDeclineResponse ................................16\n           7.2.10.\
    \ Leave .............................................17\n           7.2.11. LeaveResponse\
    \ .....................................17\n           7.2.12. Reform or Optimize\
    \ Tree ...........................17\n           7.2.13. ReformResponse ....................................18\n\
    \           7.2.14. Heartbeat .........................................18\n  \
    \         7.2.15. Heartbeat Response ................................18\n    \
    \       7.2.16. NodeQuery .........................................19\n      \
    \     7.2.17. NodeQueryResponse .................................19\n        \
    \   7.2.18. Push ..............................................21\n          \
    \ 7.2.19. PushResponse ......................................22\n   8. Scribe\
    \ Algorithm ...............................................22\n      8.1. Overview\
    \ ..................................................22\n      8.2. Create ....................................................23\n\
    \      8.3. Join ......................................................24\n  \
    \    8.4. Leave .....................................................24\n    \
    \  8.5. JoinConfirm ...............................................24\n      8.6.\
    \ JoinDecline ...............................................24\n      8.7. Multicast\
    \ .................................................24\n   9. P2PCast Algorithm\
    \ ..............................................25\n      9.1. Overview ..................................................25\n\
    \      9.2. Message Mapping ...........................................25\n  \
    \    9.3. Create ....................................................26\n    \
    \  9.4. Join ......................................................26\n      9.5.\
    \ Leave .....................................................28\n      9.6. JoinConfirm\
    \ ...............................................28\n      9.7. Multicast .................................................28\n\
    \   10. Message Format ................................................28\n  \
    \    10.1. ALMHeader Definition .....................................30\n    \
    \  10.2. ALMMessageContents Definition ............................31\n      10.3.\
    \ Response Codes ...........................................31\n   11. Examples\
    \ ......................................................32\n      11.1. Create\
    \ Tree ..............................................32\n      11.2. Join Tree\
    \ ................................................33\n      11.3. Leave Tree ...............................................35\n\
    \      11.4. Push Data ................................................35\n  \
    \ 12. Kind Definitions ..............................................36\n    \
    \  12.1. ALMTree Kind Definition ..................................36\n   13.\
    \ RELOAD Configuration File Extensions ..........................37\n   14. IANA\
    \ Considerations ...........................................37\n      14.1. ALM\
    \ Algorithm Types ......................................37\n      14.2. Message\
    \ Code Registration ................................38\n      14.3. Error Code\
    \ Registration ..................................38\n   15. Security Considerations\
    \ .......................................39\n   16. Acknowledgements ..............................................40\n\
    \   17. References ....................................................40\n  \
    \    17.1. Normative Reference ......................................40\n    \
    \  17.2. Informative References ...................................40\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The concept of scalable adaptive multicast includes both\
    \ scaling\n   properties and adaptability properties.  Scalability is intended\
    \ to\n   cover:\n   o  large group size\n   o  large numbers of small groups\n\
    \   o  rate of group membership change\n   o  admission control for QoS\n   o\
    \  use with network-layer QoS mechanisms\n   o  varying degrees of reliability\n\
    \   o  trees connecting nodes over the global Internet\n   Adaptability includes\n\
    \   o  use of different control mechanisms for different multicast trees\n   \
    \   depending on initial application parameters or application classes\n   o \
    \ changing multicast tree structure depending on changes in\n      application\
    \ requirements, network conditions, and membership\n   Application-Layer Multicast\
    \ (ALM) has been demonstrated to be a\n   viable multicast technology where native\
    \ multicast isn't available.\n   Many ALM designs have been proposed.  This ALM\
    \ Usage focuses on:\n   o  ALM implemented in RELOAD-based overlays\n   o  Support\
    \ for a variety of ALM control algorithms\n   o  Providing a basis for defining\
    \ a separate hybrid ALM RELOAD Usage\n   RELOAD [RELOAD] has an application extension\
    \ mechanism in which a new\n   type of application defines a Usage.  A RELOAD\
    \ Usage defines a set of\n   data types and rules for their use.  In addition,\
    \ this document\n   describes additional message types and a new ALM algorithm\
    \ plugin\n   architectural component.\n   This document represents the consensus\
    \ of the SAM RG.  It was\n   repeatedly discussed within the research group, as\
    \ well as with other\n   Application-Layer Multicast experts.\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 2.  Definitions
  contents:
  - "2.  Definitions\n   We adopt the terminology defined in Section 3 of [RELOAD],\n\
    \   specifically the distinction between \"node\", \"peer\", and \"client\".\n"
- title: 2.1.  Overlay Network
  contents:
  - "2.1.  Overlay Network\n   Overlay network: An application-layer virtual or logical\
    \ network with\n   addressable end points that provides connectivity, routing,\
    \ and\n   messaging between end points.  Overlay networks are frequently used\n\
    \   as a substrate for deploying new network services or for providing a\n   routing\
    \ topology not available from the underlying physical network.\n   Many peer-to-peer\
    \ systems are overlay networks that run on top of the\n   Internet.  In Figure\
    \ 1, \"P\" indicates overlay peers, and peers are\n   connected in a logical address\
    \ space.  The links shown in the figure\n   represent predecessor/successor links.\
    \  Depending on the overlay\n   routing model, additional or different links may\
    \ be present.\n                           P    P    P   P     P\n            \
    \             ..+....+....+...+.....+...\n                        .          \
    \                +P\n                      P+                            .\n \
    \                       .                          +P\n                      \
    \   ..+....+....+...+.....+...\n                           P    P    P   P   \
    \  P\n                     Figure 1: Overlay Network Example\n"
- title: 2.2.  Overlay Multicast
  contents:
  - "2.2.  Overlay Multicast\n   Overlay Multicast (OM): Hosts participating in a\
    \ multicast session\n   form an overlay network and utilize unicast connections\
    \ among pairs\n   of hosts for data dissemination [BUFORD2009] [KOLBERG2010]\n\
    \   [BUFORD2008].  The hosts in overlay multicast exclusively handle\n   group\
    \ management, routing, and tree construction, without any support\n   from Internet\
    \ routers.  This is also commonly known as Application-\n   Layer Multicast (ALM)\
    \ or End-System Multicast (ESM).  We call systems\n   that use proxies connected\
    \ in an overlay multicast backbone \"proxied\n   overlay multicast\" or POM.\n"
- title: 2.3.  Source-Specific Multicast (SSM)
  contents:
  - "2.3.  Source-Specific Multicast (SSM)\n   SSM tree: The creator of the tree is\
    \ the source.  It sends data\n   messages to the tree root that are forwarded\
    \ down the tree.\n"
- title: 2.4.  Any-Source Multicast (ASM)
  contents:
  - "2.4.  Any-Source Multicast (ASM)\n   ASM tree: A node sending a data message\
    \ sends the message to its\n   parent and its children.  Each node receiving a\
    \ data message from one\n   edge forwards it to the remaining tree edges to which\
    \ it is\n   connected.\n"
- title: 2.5.  Peer
  contents:
  - "2.5.  Peer\n   Peer: An autonomous end system that is connected to the physical\n\
    \   network and participates in and contributes resources to overlay\n   construction,\
    \ routing, and maintenance.  Some peers may also perform\n   additional roles\
    \ such as connection relays, super nodes, NAT\n   traversal assistance, and data\
    \ storage.\n"
- title: 3.  Assumptions
  contents:
  - '3.  Assumptions

    '
- title: 3.1.  Overlay
  contents:
  - "3.1.  Overlay\n   Peers connect in a large-scale overlay, which may be used for\
    \ a\n   variety of peer-to-peer applications in addition to multicast\n   sessions.\
    \  Peers may assume additional roles in the overlay beyond\n   participation in\
    \ the overlay and in multicast trees.  We assume a\n   single-structured overlay\
    \ routing algorithm is used.  Any of a\n   variety of multi-hop, one-hop, or variable-hop\
    \ overlay algorithms\n   could be used.\n   Castro, et al. [CASTRO2003] compared\
    \ multi-hop overlays and found\n   that tree-based construction in a single overlay\
    \ outperformed using\n   separate overlays for each multicast session.  We use\
    \ a single\n   overlay rather than separate overlays per multicast session.\n\
    \   An overlay multicast algorithm may leverage the overlay's mechanism\n   for\
    \ maintaining overlay state in the face of churn.  For example, a\n   peer may\
    \ store a number of DHT (Distributed Hash Table) entries.\n   When the peer gracefully\
    \ leaves the overlay, it transfers those\n   entries to the nearest peer.  When\
    \ another peer joins that is closer\n   to some of the entries than the current\
    \ peer that holds those\n   entries, than those entries are migrated.  Overlay\
    \ churn affects\n   multicast trees as well; remedies include automatic migration\
    \ of the\n   tree state and automatic rejoin operations for dislocated child\n\
    \   nodes.\n"
- title: 3.2.  Overlay Multicast
  contents:
  - "3.2.  Overlay Multicast\n   The overlay supports concurrent multiple multicast\
    \ trees.  The limit\n   on the number of concurrent trees depends on peer and\
    \ network\n   resources and is not an intrinsic property of the overlay.\n"
- title: 3.3.  RELOAD
  contents:
  - "3.3.  RELOAD\n   We use RELOAD [RELOAD] as the peer-to-peer (P2P) overlay for\
    \ data\n   storage and the mechanism by which the peers interconnect and route\n\
    \   messages.  RELOAD is a generic P2P overlay, and application support\n   is\
    \ defined by profiles called Usages.\n"
- title: 3.4.  NAT
  contents:
  - "3.4.  NAT\n   Some nodes in the overlay may be in a private address space and\n\
    \   behind firewalls.  We use the RELOAD mechanisms for NAT traversal.\n   We\
    \ permit clients to be leaf nodes in an ALM tree.\n"
- title: 3.5.  Tree Topology
  contents:
  - "3.5.  Tree Topology\n   All tree control messages are routed in the overlay.\
    \  Two types of\n   data or media topologies are envisioned: 1) tree edges are\
    \ paths in\n   the overlay, and 2) tree edges are direct connections between a\n\
    \   parent and child peer in the tree, formed using the RELOAD AppAttach\n   method.\n"
- title: 4.  Architecture Extensions to RELOAD
  contents:
  - "4.  Architecture Extensions to RELOAD\n   There are two changes as depicted in\
    \ Figure 2.  New ALM messages are\n   mapped to RELOAD Message Transport using\
    \ the RELOAD experimental\n   message type.  A plugin for ALM algorithms handles\
    \ the ALM state and\n   control.  The ALM algorithm is under control of the application\
    \ via\n   the Group API [COMMON-API].\n                                      \
    \                 +---------+\n                                              \
    \         |Group API|\n                                                      \
    \ +---------+\n                                                            |\n\
    \          ------------------- Application  ------------------------\n       \
    \       +-------+                                     |\n              | ALM \
    \  |                                     |\n              | Usage |          \
    \                           |\n              +-------+                       \
    \              |\n           -------------- Messaging Service Boundary --------------\n\
    \                                                            |\n             +--------+\
    \      +-----------+---------+    +---------+\n             | Storage|<---> |\
    \ RELOAD    | ALM     |<-->| ALM Alg |\n             +--------+      | Message\
    \   | Messages|    +---------+\n                     ^       | Transport |   \
    \      |\n                     |       +-----------+---------+\n             \
    \        v          |    |\n                    +-------------+  |\n         \
    \           | Topology    |  |\n                    | Plugin      |  |\n     \
    \               +-------------+  |\n                       ^             |\n \
    \                      v             v\n                    +-------------------+\n\
    \                    | Forwarding &      |\n                    | Link Management\
    \   |\n                    +-------------------+\n           ---------- Overlay\
    \ Link Service Boundary --------------\n                 Figure 2: RELOAD Architecture\
    \ Extensions\n   The ALM components interact with RELOAD as follows:\n   o  ALM\
    \ uses the RELOAD data storage functionality to store an ALMTree\n      instance\
    \ when a new ALM tree is created in the overlay and to\n      retrieve ALMTree\
    \ instance(s) for existing ALM trees.\n   o  ALM applications and management tools\
    \ may use the RELOAD data\n      storage functionality to store diagnostic information\
    \ about the\n      operation of trees, including average number of trees, delay\
    \ from\n      source to leaf nodes, bandwidth use, and packet loss rate.  In\n\
    \      addition, diagnostic information may include statistics specific\n    \
    \  to the tree root or to any node in the tree.\n"
- title: 5.  RELOAD ALM Usage
  contents:
  - "5.  RELOAD ALM Usage\n   Applications of RELOAD are restricted in the data types\
    \ that can be\n   stored in the DHT.  The profile of accepted data types for an\n\
    \   application is referred to as a Usage.  RELOAD is designed so that\n   new\
    \ applications can easily define new Usages.  New RELOAD Usages are\n   needed\
    \ for multicast applications since the data types in base RELOAD\n   and existing\
    \ Usages are not sufficient.\n   We define an ALM Usage in RELOAD.  This ALM Usage\
    \ is sufficient for\n   applications that require ALM functionality in the overlay.\
    \  Figure 2\n   shows the internal structure of the ALM Usage.  This contains\
    \ the\n   Group API ([COMMON-API]), an ALM algorithm plugin (e.g., Scribe), and\n\
    \   the ALM messages that are then sent out to the RELOAD network.\n   A RELOAD\
    \ Usage is required [RELOAD] to define the following:\n   o  Kind-ID and code\
    \ points\n   o  data structures for each Kind\n   o  access control rules for\
    \ each Kind\n   o  the Resource Name used to hash to the Resource ID that determines\n\
    \      where the Kind is stored\n   o  address restoration after recovery from\
    \ a network partition (to\n      form a single coherent network)\n   o  the types\
    \ of connections that can be initiated using AppConnect\n   An ALM group_id is\
    \ a RELOAD node_id.  The owner of an ALM group\n   creates a RELOAD node_id as\
    \ specified in [RELOAD].  This means that a\n   group_id is used as a RELOAD Destination\
    \ for overlay routing\n   purposes.\n"
- title: 6.  ALM Tree Control Signaling
  contents:
  - "6.  ALM Tree Control Signaling\n   Peers use the overlay to support ALM operations\
    \ such as:\n   o  CreateALMTree\n   o  Join\n   o  Leave\n   o  Reform or optimize\
    \ tree\n   There are a variety of algorithms for peers to form multicast trees\n\
    \   in the overlay.  The approach presented here permits multiple such\n   algorithms\
    \ to be supported in the overlay since different algorithms\n   may be more suitable\
    \ for certain application requirements; the\n   approach also supports experimentation.\
    \  Therefore, overlay messaging\n   corresponding to the set of overlay multicast\
    \ operations MUST carry\n   algorithm identification information.\n   For example,\
    \ for small groups, the join point might be directly\n   assigned by the rendezvous\
    \ point, while for large trees the Join\n   request might be propagated down the\
    \ tree with candidate parents\n   forwarding their position directly to the new\
    \ node.\n   Here is a simplistic notation for forming a multicast tree in the\n\
    \   overlay.  Its main advantage is the use of the overlay for routing\n   both\
    \ control and data messages.  The group creator does not have to\n   be the root\
    \ of the tree or even in the tree.  It does not consider\n   per-node load, admission\
    \ control, or alternative paths.  After the\n   creation of a tree, the group_id\
    \ is expected to be advertised or\n   distributed out of band, perhaps by publishing\
    \ in the DHT.\n   Similarly, joining peers will discover the group_id out of band,\n\
    \   perhaps by a lookup in the tree.\n   As stated earlier, multiple algorithms\
    \ will coexist in the overlay.\n   1.  Peer that initiates multicast group:\n\
    \       group_id = create();  // Allocate a unique group_id.\n               \
    \              // The root is the nearest\n                             // peer\
    \ in the overlay.\n   2.  Any joining peer:\n       joinTree(group_id); // sends\
    \ \"join group_id\" message\n       The overlay routes the Join request using\
    \ the overlay routing\n       mechanism toward the peer with the nearest ID to\
    \ the group_id.\n       This peer is the root.  Peers on the path to the root\
    \ join the\n       tree as forwarding points.\n   3.  Leave Tree:\n       leaveTree(group_id);\
    \ // removes this node from the tree\n       Propagates a Leave request to each\
    \ child node and to the parent\n       node.  If the parent node is a forwarding\
    \ node and this is its\n       last child, then it propagates a Leave request\
    \ to its parent.  A\n       child node receiving a Leave request from a parent\
    \ sends a Join\n       request to the group_id.\n   4.  Message forwarding:\n\
    \       multicastMsg(group_id, msg);\n       For message forwarding, both Any-Source\
    \ Multicast (ASM) and\n       Source-Specific Multicast (SSM) approaches may be\
    \ used.\n"
- title: 7.  ALM Messages Mapped to RELOAD
  contents:
  - '7.  ALM Messages Mapped to RELOAD

    '
- title: 7.1.  Introduction
  contents:
  - "7.1.  Introduction\n   In this document, we define messages for overlay multicast\
    \ tree\n   creation, using an existing protocol (RELOAD) in the P2P-SIP WG\n \
    \  [RELOAD] for a universal structured peer-to-peer overlay protocol.\n   RELOAD\
    \ provides the mechanism to support a number of overlay\n   topologies.  Hence,\
    \ the overlay multicast framework defined in this\n   document can be used with\
    \ P2P-SIP and makes the Scalable Adaptive\n   Multicast (SAM) framework overlay\
    \ agnostic.\n   As discussed in the SAM requirements document [SAM-GENERIC], there\n\
    \   are a variety of ALM tree formation and tree maintenance algorithms.\n   The\
    \ intent of this specification is to be algorithm agnostic, similar\n   to how\
    \ RELOAD is overlay algorithm agnostic.  We assume that all\n   control messages\
    \ are propagated using overlay routed messages.\n   The message types needed for\
    \ ALM behavior are divided into the\n   following categories:\n   o  Tree lifecycle\
    \ (Create, Join, Leave, Reform, Heartbeat)\n   o  Peer region and multicast properties\n\
    \   The message codes are defined in Section 14.2 of this document.\n   Messages\
    \ are mapped to the RELOAD experimental message type.\n   In the following sections,\
    \ the protocol messages as mapped to RELOAD\n   are discussed.  Detailed example\
    \ message flows are provided in\n   Section 11.\n   In the following descriptions,\
    \ we use the datatype Dictionary, which\n   is a set of opaque values indexed\
    \ by an opaque key with one value for\n   each key.  A single dictionary entry\
    \ is represented by a\n   DictionaryEntry as defined in Section 7.2.3 of the RELOAD\
    \ document\n   [RELOAD].  The Dictionary datatype is defined as follows:\n   struct\
    \ {\n     DictionaryEntry elements<0..2^16-1>;\n     } Dictionary;\n"
- title: 7.2.  Tree Lifecycle Messages
  contents:
  - "7.2.  Tree Lifecycle Messages\n   Peers use the overlay to transmit ALM operations\
    \ defined in this\n   section.\n"
- title: 7.2.1.  CreateALMTree
  contents:
  - "7.2.1.  CreateALMTree\n   A new ALM tree is created in the overlay with the identity\
    \ specified\n   by group_id.  The common interpretation in a DHT-based overlay\
    \ of\n   group_id is that the peer with a peer_id closest to and less than the\n\
    \   group_id is the root of the tree.  However, other overlay types are\n   supported.\
    \  The tree has no children at the time it is created.\n   The group_id is generated\
    \ from a well-known session key to be used by\n   other peers to address the multicast\
    \ tree in the overlay.  The\n   generation of the group_id from the session_key\
    \ MUST be done using\n   the overlay's ID-generation mechanism.\n      struct\
    \ {\n        node_id peer_id;\n        opaque session_key<0..2^32-1>;\n      \
    \  node_id group_id;\n        Dictionary options;\n      } ALMTree;\n   peer_id:\
    \ overlay address of the peer that creates the multicast tree.\n   session_key:\
    \ a well-known string that when hashed using the overlay's\n   ID-generation algorithm\
    \ produces the group_id.\n   group_id: overlay address of the root of the tree.\n\
    \   options: name-value list of properties to be associated with the\n   tree,\
    \ such as the maximum size of the tree, restrictions on peers\n   joining the\
    \ tree, latency constraints, preference for distributed or\n   centralized tree\
    \ formation and maintenance, and Heartbeat interval.\n   Tree creation is subject\
    \ to access control since it involves a Store\n   operation.  The NODE-MATCH access\
    \ policy defined in Section 7.3.2 of\n   [RELOAD] is used.\n   A successful CreateALMTree\
    \ causes an ALMTree structure to be stored\n   in the overlay at the node G responsible\
    \ for the group_id.  This node\n   G performs the RELOAD-defined StoreReq operation\
    \ as a side effect of\n   performing the CreateALMTree.  If the StoreReq fails,\
    \ the\n   CreateALMTree fails too.\n   After a successful CreateALMTree, peers\
    \ can use the RELOAD Fetch\n   method to retrieve the ALMTree struct at address\
    \ group_id.  The\n   ALMTree Kind is defined in Section 12.1.\n"
- title: 7.2.2.  CreateALMTreeResponse
  contents:
  - "7.2.2.  CreateALMTreeResponse\n   After receiving a CreateALMTree message from\
    \ node S, the peer sends a\n   CreateALMTreeResponse to node S.\n        struct\
    \ {\n          Dictionary options;\n        } CreateALMTreeResponse;\n   options:\
    \ A node may provide algorithm-dependent parameters about the\n   created tree\
    \ to the requesting node.\n"
- title: 7.2.3.  Join
  contents:
  - "7.2.3.  Join\n   Join causes the distributed algorithm for peer join of a specific\
    \ ALM\n   group to be invoked.  The definition of the Join request is shown\n\
    \   below.  If successful, the joining peer is notified of one or more\n   candidate\
    \ parent peers in one or more JoinAccept messages.  The\n   particular ALM join\
    \ algorithm is not specified in this protocol.\n      struct {\n        node_id\
    \ peer_id;\n        node_id group_id;\n        Dictionary options;\n      } Join;\n\
    \   peer_id: overlay address of joining/leaving peer\n   group_id: overlay address\
    \ of the root of the tree\n   options: name-value list of options proposed by\
    \ joining peer\n   RELOAD is a request-response protocol.  Consequently, the messages\n\
    \   JoinAccept and JoinReject (defined below) are matching responses for\n   Join.\
    \  If JoinReject is received, then no further action on this\n   request is carried\
    \ out.  If JoinAccept is received, then either a\n   JoinConfirm or a JoinDecline\
    \ message (see below) is sent.  The\n   matching response for JoinConfirm is JoinConfirmResponse.\
    \  The\n   matching response for JoinDecline is JoinDeclineResponse.\n   The following\
    \ list shows the matching request-responses according to\n   the request-response\
    \ mechanism defined in [RELOAD].\n      Join -- JoinAccept: Node C sends a Join\
    \ request to node P.  If\n      node P accepts, it responds with JoinAccept.\n\
    \      Join -- JoinReject: Node C sends a Join request to node P.  If\n      node\
    \ P does not accept the Join request, it responds with\n      JoinReject.\n  \
    \    JoinConfirm -- JoinConfirmResponse: If node P sent node C a\n      JoinAccept\
    \ and node C confirms with a JoinConfirm request, then\n      node P responds\
    \ with a JoinConfirmResponse.\n      JoinDecline -- JoinDeclineResponse: If node\
    \ P sent node C a\n      JoinAccept and node C declines with a JoinDecline request,\
    \ then\n      node P responds with a JoinDeclineResponse.\n   Thus, Join, JoinConfirm,\
    \ and JoinDecline are treated as requests as\n   defined in RELOAD, are mapped\
    \ to the RELOAD exp_a_req message, and\n   are therefore retransmitted until either\
    \ a retry limit is reached or\n   a matching response received.  JoinAccept, JoinReject,\n\
    \   JoinConfirmResponse, and JoinDeclineResponse are treated as message\n   responses\
    \ as defined above and are mapped to the RELOAD exp_a_ans\n   message.\n   The\
    \ Join behavior can be described as follows:\n   if(checkAccept(msg)) {\n    \
    \   recvJoins.add(msg.source, msg.group_id)\n       SEND(JoinAccept(node_id, msg.source,\
    \ msg.group_id))\n   }\n"
- title: 7.2.4.  JoinAccept (Join Response)
  contents:
  - "7.2.4.  JoinAccept (Join Response)\n   JoinAccept tells the requesting joining\
    \ peer that the indicated peer\n   is available to act as its parent in the ALM\
    \ tree specified by\n   group_id, with the corresponding options specified.  A\
    \ peer MAY\n   receive more than one JoinAccept from different candidate parent\n\
    \   peers in the group_id tree.  The peer accepts a peer as parent using\n   a\
    \ JoinConfirm message.  A JoinAccept that receives neither a\n   JoinConfirm nor\
    \ JoinDecline message MUST expire.  RELOAD\n   implementations are able to read\
    \ a local configuration file for\n   settings.  It is assumed that this file contains\
    \ the timeout value to\n   be used.\n      struct {\n        node_id parent_peer_id;\n\
    \        node_id child_peer_id;\n        node_id group_id;\n        Dictionary\
    \ options;\n      } JoinAccept;\n   parent_peer_id: overlay address of a peer\
    \ that accepts the joining\n   peer\n   child_peer_id: overlay address of joining\
    \ peer\n   group_id: overlay address of the root of the tree\n   options: name-value\
    \ list of options accepted by parent peer\n"
- title: 7.2.5.  JoinReject (Join Response)
  contents:
  - "7.2.5.  JoinReject (Join Response)\n   A peer receiving a Join request responds\
    \ with a JoinReject response\n   to indicate the request is rejected.\n"
- title: 7.2.6.  JoinConfirm
  contents:
  - "7.2.6.  JoinConfirm\n   A peer receiving a JoinAccept message that it wishes\
    \ to accept MUST\n   explicitly accept it using a JoinConfirm message before the\n\
    \   expiration of a timer for the JoinAccept message.  The joining peer\n   MUST\
    \ include only those options from the JoinAccept that it also\n   accepts, completing\
    \ the negotiation of options between the two peers.\n      struct {\n        node_id\
    \ child_peer_id;\n        node_id parent_peer_id;\n        node_id group_id;\n\
    \        Dictionary options;\n      } JoinConfirm;\n   child_peer_id: overlay\
    \ address of joining peer that is a child of the\n   parent peer\n   parent_peer_id:\
    \ overlay address of the peer that is the parent of the\n   joining peer\n   group_id:\
    \ overlay address of the root of the tree\n   options: name-value list of options\
    \ accepted by both peers\n   The JoinConfirm message behavior is described below:\n\
    \   if(recvJoins.contains(msg.source,msg.group_id)){\n      if !(groups.contains(msg.group_id))\
    \ {\n         groups.add(msg.group_id)\n         SEND(msg,msg.group_id)\n    \
    \  }\n      groups[msg.group_id].children.add(msg.source)\n      recvJoins.del(msg.source,\
    \ msg.group_id)\n   }\n"
- title: 7.2.7.  JoinConfirmResponse
  contents:
  - "7.2.7.  JoinConfirmResponse\n   A peer receiving a JoinConfirm message responds\
    \ with a\n   JoinConfirmResponse message.\n"
- title: 7.2.8.  JoinDecline
  contents:
  - "7.2.8.  JoinDecline\n   A peer receiving a JoinAccept message that it does not\
    \ wish to accept\n   MAY explicitly decline it using a JoinDecline message.\n\
    \      struct {\n        node_id peer_id;\n        node_id parent_peer_id;\n \
    \       node_id group_id;\n      } JoinDecline;\n   peer_id: overlay address of\
    \ joining peer that declines the JoinAccept\n   parent_peer_id: overlay address\
    \ of the peer that issued a JoinAccept\n   to this peer\n   group_id: overlay\
    \ address of the root of the tree\n   The behavior of the JoinDecline message\
    \ is described as follows:\n   if(recvJoins.contains(msg.source,msg.group_id))\n\
    \      recvJoins.del(msg.source, msg.group_id)\n"
- title: 7.2.9.  JoinDeclineResponse
  contents:
  - "7.2.9.  JoinDeclineResponse\n   A peer receiving a JoinConfirm message responds\
    \ with a\n   JoinDeclineResponse message.\n"
- title: 7.2.10.  Leave
  contents:
  - "7.2.10.  Leave\n   A peer that is part of an ALM tree identified by group_id\
    \ that\n   intends to detach from either a child or parent peer SHOULD send a\n\
    \   Leave request to the peer from which it wishes to detach.  A peer\n   receiving\
    \ a Leave request from a peer that is neither in its parent\n   nor child lists\
    \ SHOULD ignore the message.\n      struct {\n        node_id peer_id;\n     \
    \   node_id group_id;\n        Dictionary options;\n      } Leave;\n   peer_id:\
    \ overlay address of leaving peer\n   group_id: overlay address of the root of\
    \ the tree\n   options: name-value list of options\n   The behavior of the Leave\
    \ request can be described as:\n   groups[msg.group_id].children.remove(msg.source)\n\
    \   if (groups[msg.group].children = 0)\n         SEND(msg,groups[msg.group_id].parent)\n"
- title: 7.2.11.  LeaveResponse
  contents:
  - "7.2.11.  LeaveResponse\n   A peer receiving a Leave request responds with a LeaveResponse\n\
    \   message.\n"
- title: 7.2.12.  Reform or Optimize Tree
  contents:
  - "7.2.12.  Reform or Optimize Tree\n   This triggers a reorganization of either\
    \ the entire tree or only a\n   subtree.  It MAY include hints to specific peers\
    \ of recommended\n   parent or child peers to which to reconnect.  A peer receiving\
    \ this\n   message MAY ignore it, MAY propagate it to other peers in its\n   subtree,\
    \ and MAY invoke local algorithms for selecting preferred\n   parent and/or child\
    \ peers.\n      struct {\n        node_id group_id;\n        node_id peer_id;\n\
    \        Dictionary options;\n      } Reform;\n   group_id: overlay address of\
    \ the root of the tree\n   peer_id: if omitted, then the tree is reorganized starting\
    \ from the\n   root; otherwise, it is reorganized only at the subtree identified\
    \ by\n   peer_id.\n   options: name-value list of options\n"
- title: 7.2.13.  ReformResponse
  contents:
  - "7.2.13.  ReformResponse\n   A peer receiving a Reform message responds with a\
    \ ReformResponse.\n      struct {\n        Dictionary options;\n      } ReformResponse;\n\
    \   options: algorithm-dependent information about the results of the\n   Reform\
    \ operation\n"
- title: 7.2.14.  Heartbeat
  contents:
  - "7.2.14.  Heartbeat\n   A child node signals to its adjacent parent nodes in the\
    \ tree that it\n   is alive.  If a parent node does not receive a Heartbeat message\n\
    \   within N Heartbeat time intervals, it MUST treat this as an explicit\n   Leave\
    \ request from the unresponsive peer.  N is configurable.  RELOAD\n   implementations\
    \ are able to read a local configuration file for\n   settings.  It is assumed\
    \ that this file contains the value for N to\n   be used.\n      struct {\n  \
    \      node_id peer_id_src;\n        node_id peer_id_dst;\n        node_id group_id;\n\
    \        Dictionary options;\n      } Heartbeat;\n   peer_id_src: source of Heartbeat\n\
    \   peer_id_dst: destination of Heartbeat\n   group_id: overlay address of the\
    \ root of the tree\n   options: an algorithm may use the Heartbeat message to\
    \ provide state\n   information to adjacent nodes in the tree\n"
- title: 7.2.15.  Heartbeat Response
  contents:
  - "7.2.15.  Heartbeat Response\n   A parent node responds with a HeartbeatResponse\
    \ to a Heartbeat from a\n   child node indicating that it has received the Heartbeat\
    \ message.\n"
- title: 7.2.16.  NodeQuery
  contents:
  - "7.2.16.  NodeQuery\n   The NodeQuery message is used to obtain information about\
    \ the state\n   and performance of the tree on a per-node basis.  A set of nodes\n\
    \   could be queried to construct a centralized view of the multicast\n   trees,\
    \ similar to a web crawler.\n        struct {\n          node_id peer_id_src;\n\
    \          node_id peer_id_dst;\n        } NodeQuery;\n   peer_id_src: source\
    \ of query\n   peer_id_dst: destination of query\n"
- title: 7.2.17.  NodeQueryResponse
  contents:
  - "7.2.17.  NodeQueryResponse\n   The response to a NodeQuery message contains a\
    \ NodeStatistics\n   instance for this node.\n   public struct {\n      uint32\
    \        node_lifetime;\n      uint32        total_number_trees;\n      uint16\
    \        number_algorithms_supported;\n      uint8         algorithms_supported[32];\n\
    \      TreeData      max_tree_data;\n      uint16        number_active_trees;\n\
    \      TreeData      tree_data<0..2^8-1>;\n      ImplementationInfo impl_info;\n\
    \   }  NodeStatistics;\n      node_lifetime: time the node has been alive in seconds\
    \ since last\n      restart\n      total_number_trees: total number of trees this\
    \ node has been part\n      of during the node lifetime\n      number_algorithms_supported:\
    \ value between 0..2^16-1 corresponding\n      to the number of algorithms supported\n\
    \      algorithms_supported: list of algorithms, each byte encoded using\n   \
    \   the corresponding algorithm code\n      max_tree_data: data about tree with\
    \ largest number of nodes that\n      this node was part of.  NodeQuery can be\
    \ used to crawl all the\n      nodes in an ALM tree to fill this field.  This\
    \ is intended to\n      support monitoring, algorithm design, and general experimentation\n\
    \      with ALM in RELOAD.\n      number_active_trees: current number of trees\
    \ that the node is part\n      of\n      tree_data: details of each active tree;\
    \ the number of such is\n      specified by number_active_trees\n      impl_info:\
    \ information about the implementation of this Usage\n   public struct {\n   \
    \  uint32       tree_id;\n     uint8        algorithm;\n     node_id      tree_root;\n\
    \     uint8        number_parents;\n     node_id      parent<0..2^8-1>;\n    \
    \ uint16       number_child_nodes;\n     node_id      children<0..2^16-1>;\n \
    \    uint32       path_length_to_root;\n     uint32       path_delay_to_root;\n\
    \     uint32       path_delay_to_child;\n   } TreeData;\n      tree_id: the ID\
    \ of the tree\n      algorithm: code identifying the multicast algorithm used\
    \ by this\n      tree\n      tree_root: node_id of tree root, or 0 if unknown\n\
    \      number_parents: 0 .. 2^8-1 indicates number of parent nodes for\n     \
    \ this node\n      parent: the RELOAD node_id of each parent node\n      number_child_nodes:\
    \ 0..2^16-1 indicates number of children\n      children: the RELOAD node_id of\
    \ each child node\n      path_length_to_root: number of overlay hops to the root\
    \ of the\n      tree\n      path_delay_to_root: RTT in milliseconds to root node\n\
    \      path_delay_to_child: last measured RTT in milliseconds to child\n     \
    \ node with largest RTT\n   public struct {\n     uint32       join_confirm_timeout;\n\
    \     uint32       heartbeat_interval;\n     uint32       heartbeat_response_timeout;\n\
    \     uint16       info_length;\n     uint8        info<0..2^16-1>;\n   } ImplementationInfo;\n\
    \      join_confirm_timeout: The default time for\n      JoinConfirm/JoinDecline,\
    \ intended to provide sufficient time for a\n      Join request to receive all\
    \ responses and confirm the best choice.\n      Default value is 5000 msec.  An\
    \ implementation can change this\n      value.\n      heartbeat_interval: The\
    \ default Heartbeat interval is 2000 msec.\n      Different interoperating implementations\
    \ could use different\n      intervals.\n      heartbeat_response_timeout: The\
    \ default Heartbeat timeout is 5000\n      msec and is the max time between Heartbeat\
    \ reports from an\n      adjacent node in the tree at which point the Heartbeat\
    \ is missed.\n      info_length: length of the info field\n      info: implementation-specific\
    \ information, such as name of\n      implementation, build version, and implementation-specific\n\
    \      features\n"
- title: 7.2.18.  Push
  contents:
  - "7.2.18.  Push\n   A peer sends arbitrary multicast data to other peers in the\
    \ tree.\n   Nodes in the tree forward this message to adjacent nodes in the tree\n\
    \   in an algorithm-dependent way.\n      struct {\n        node_id group_id;\n\
    \        uint8  priority;\n        uint32 length;\n        uint8  data<0..2^32-1>;\n\
    \      } Push;\n   group_id: overlay address of root of the ALM tree\n   priority:\
    \ the relative priority of the message; highest priority is\n   255.  A node may\
    \ ignore this field.\n   length: length of the data field in bytes\n   data: the\
    \ data\n   In pseudocode, the behavior of Push can be described as:\n   foreach(groups[msg.group_id].children\
    \ as node_id)\n        SEND(msg,node_id)\n   if memberOf(msg.group_id)\n     \
    \   invokeMessageHandler(msg.group_id, msg)\n"
- title: 7.2.19.  PushResponse
  contents:
  - "7.2.19.  PushResponse\n   After receiving a Push message from node S, the receiving\
    \ peer sends\n   a PushResponse to node S.\n      struct {\n        Dictionary\
    \ options;\n      } PushResponse;\n   options: A node may provide feedback to\
    \ the sender about previous\n   Push messages in some window, for example, the\
    \ last N Push messages.\n   The feedback could include, for each Push message\
    \ received, the\n   number of adjacent nodes that were forwarded the Push message\
    \ and the\n   number of adjacent nodes from which a PushResponse was received.\n"
- title: 8.  Scribe Algorithm
  contents:
  - '8.  Scribe Algorithm

    '
- title: 8.1.  Overview
  contents:
  - "8.1.  Overview\n   Figure 3 shows a mapping between RELOAD ALM messages (as defined\
    \ in\n   Section 5 of this document) and Scribe messages as defined in\n   [CASTRO2002].\n\
    \              +---------+-------------------+-----------------+\n           \
    \   | Section |RELOAD ALM Message | Scribe Message  |\n              +---------+-------------------+-----------------+\n\
    \              | 7.2.1   | CreateALMTree     | Create          |\n           \
    \   +---------+-------------------+-----------------+\n              | 7.2.3 \
    \  | Join              | Join            |\n              +---------+-------------------+-----------------+\n\
    \              | 7.2.4   | JoinAccept        |                 |\n           \
    \   +---------+-------------------+-----------------+\n              | 7.2.6 \
    \  | JoinConfirm       |                 |\n              +---------+-------------------+-----------------+\n\
    \              | 7.2.8   | JoinDecline       |                 |\n           \
    \   +---------+-------------------+-----------------+\n              | 7.2.10\
    \  | Leave             | Leave           |\n              +---------+-------------------+-----------------+\n\
    \              | 7.2.12  | Reform            |                 |\n           \
    \   +---------+-------------------+-----------------+\n              | 7.2.14\
    \  | Heartbeat         |                 |\n              +---------+-------------------+-----------------+\n\
    \              | 7.2.16  | NodeQuery         |                 |\n           \
    \   +---------+-------------------+-----------------+\n              | 7.2.18\
    \  | Push              | Multicast       |\n              +---------+-------------------+-----------------+\n\
    \              |         | Note 1            | deliver         |\n           \
    \   +---------+-------------------+-----------------+\n              |       \
    \  | Note 1            | forward         |\n              +---------+-------------------+-----------------+\n\
    \              |         | Note 1            | route           |\n           \
    \   +---------+-------------------+-----------------+\n              |       \
    \  | Note 1            | send            |\n              +---------+-------------------+-----------------+\n\
    \                   Figure 3: Mapping to Scribe Messages\n   Note 1: These Scribe\
    \ messages are handled by RELOAD messages.\n   The following sections describe\
    \ the Scribe algorithm in more detail.\n"
- title: 8.2.  Create
  contents:
  - "8.2.  Create\n   This message will create a group with group_id.  This message\
    \ MUST be\n   delivered to the node whose node_id is closest to the group_id.\
    \  This\n   node becomes the rendezvous point and root for the new multicast\n\
    \   tree.  Groups MAY have multiple sources of multicast messages.\n"
- title: 8.3.  Join
  contents:
  - "8.3.  Join\n   To join a multicast tree, a node SHOULD send a Join request with\
    \ the\n   group_id as the key.  This message gets routed by the overlay to the\n\
    \   rendezvous point of the tree.  If an intermediate node is already a\n   forwarder\
    \ for this tree, it SHOULD add the joining node as a child.\n   Otherwise, the\
    \ node SHOULD create a child table for the group and add\n   the joining node.\
    \  It SHOULD then send the Join request towards the\n   rendezvous point terminating\
    \ the Join request from the child.\n   To adapt the Scribe algorithm to the ALM\
    \ Usage proposed here, after a\n   Join request is accepted, a JoinAccept message\
    \ MUST be returned to\n   the joining node.\n"
- title: 8.4.  Leave
  contents:
  - "8.4.  Leave\n   When leaving a multicast group, a node SHOULD change its local\
    \ state\n   to indicate that it left the group.  If the node has no children in\n\
    \   its table, it MUST send a Leave request to its parent, from where it\n   SHOULD\
    \ travel up the multicast tree and stop at a node that still has\n   children\
    \ remaining after removing the leaving node.\n"
- title: 8.5.  JoinConfirm
  contents:
  - "8.5.  JoinConfirm\n   This message is not part of the Scribe protocol but is\
    \ required by\n   the basic protocol proposed in this document.  Thus, the Usage\
    \ MUST\n   send this message to confirm a joining node accepting its parent\n\
    \   node.\n"
- title: 8.6.  JoinDecline
  contents:
  - "8.6.  JoinDecline\n   Like JoinConfirm, this message is not part of the Scribe\
    \ protocol.\n   Thus, the Usage MUST send this message if a peer receiving a\n\
    \   JoinAccept message wishes to decline it.\n"
- title: 8.7.  Multicast
  contents:
  - "8.7.  Multicast\n   A message to be multicast to a group MUST be sent to the\
    \ rendezvous\n   node from where it is forwarded down the tree.  If a node is\
    \ a member\n   of the tree rather than just a forwarder, it SHOULD pass the\n\
    \   multicast data up to the application.\n"
- title: 9.  P2PCast Algorithm
  contents:
  - '9.  P2PCast Algorithm

    '
- title: 9.1.  Overview
  contents:
  - "9.1.  Overview\n   P2PCast [P2PCAST] creates a forest of related trees to increase\
    \ load\n   balancing.  P2PCast is independent of the underlying P2P substrate.\n\
    \   Its goals and approach are similar to SplitStream [SPLITSTREAM]\n   (which\
    \ assumes Pastry as the P2P overlay).  In P2PCast, the content\n   provider splits\
    \ the stream of data into f stripes.  Each tree in the\n   forest of multicast\
    \ trees is an (almost) full tree of arity f.  These\n   trees are conceptually\
    \ separate: every node of the system appears\n   once in each tree, with the content\
    \ provider being the source in all\n   of them.  To ensure that each peer contributes\
    \ as much bandwidth as\n   it receives, every node is a leaf in all the trees\
    \ except for one, in\n   which the node will serve as an internal node (proper\
    \ tree of this\n   node).  To reduce the complexity of the discussion that follows,\
    \ the\n   remainder of this section will assume that f = 2.  However, the\n  \
    \ algorithm scales for any number f.\n   P2PCast distinguishes the following types\
    \ of nodes:\n   o  Incomplete Node: A node with less than f children in its proper\n\
    \      stripe\n   o  Only-Child Node: A node whose parent (in any multicast tree)\
    \ is an\n      incomplete node\n   o  Complete Node: A node with exactly f children\
    \ in its proper stripe\n   o  Special Node: A single node that is a leaf in all\
    \ multicast trees\n      of the forest\n"
- title: 9.2.  Message Mapping
  contents:
  - "9.2.  Message Mapping\n   Figure 4 shows a mapping between RELOAD ALM messages\
    \ (as defined in\n   Section 5 of this document) and P2PCast messages as defined\
    \ in\n   [P2PCAST].\n               +---------+-------------------+-----------------+\n\
    \               | Section |RELOAD ALM Message | P2PCast Message |\n          \
    \     +---------+-------------------+-----------------+\n               | 7.2.1\
    \   | CreateALMTree     | Create          |\n               +---------+-------------------+-----------------+\n\
    \               | 7.2.3   | Join              | Join            |\n          \
    \     +---------+-------------------+-----------------+\n               | 7.2.4\
    \   | JoinAccept        |                 |\n               +---------+-------------------+-----------------+\n\
    \               | 7.2.6   | JoinConfirm       |                 |\n          \
    \     +---------+-------------------+-----------------+\n               | 7.2.8\
    \   | JoinDecline       |                 |\n               +---------+-------------------+-----------------+\n\
    \               | 7.2.10  | Leave             | Leave           |\n          \
    \     +---------+-------------------+-----------------+\n               | 7.2.12\
    \  | Reform            | Takeon          |\n               |         |       \
    \            | Substitute      |\n               |         |                 \
    \  | Search          |\n               |         |                   | Replace\
    \         |\n               |         |                   | Direct          |\n\
    \               |         |                   | Update          |\n          \
    \     +---------+-------------------+-----------------+\n               | 7.2.14\
    \  | Heartbeat         |                 |\n               +---------+-------------------+-----------------+\n\
    \               | 7.2.16  | NodeQuery         |                 |\n          \
    \     +---------+-------------------+-----------------+\n               | 7.2.18\
    \  | Push              | Multicast       |\n               +---------+-------------------+-----------------+\n\
    \                   Figure 4: Mapping to P2PCast Messages\n   The following sections\
    \ describe the mapping of the P2PCast messages\n   in more detail.\n"
- title: 9.3.  Create
  contents:
  - "9.3.  Create\n   This message will create a group with group_id.  This message\
    \ MUST be\n   delivered to the node whose node_id is closest to the group_id.\
    \  This\n   node becomes the rendezvous point and root for the new multicast\n\
    \   tree.  The rendezvous point will maintain f subtrees.\n"
- title: 9.4.  Join
  contents:
  - "9.4.  Join\n   To join a multicast tree, a joining node N MUST send a Join request\n\
    \   to a random node A already part of the tree.  Depending on the type\n   of\
    \ A, the joining algorithm continues as follows:\n   o  Incomplete Node: Node\
    \ A will arbitrarily select for which tree it\n      wants to serve as an internal\
    \ node and adopt N in that tree.  In\n      the other tree, node N will adopt\
    \ node A as a child (taking node\n      A's place in the tree), thus becoming\
    \ an internal node in the\n      stripe that node A didn't choose.\n   o  Only-Child\
    \ Node: As this node has a parent that is an incomplete\n      node, the joining\
    \ node will be redirected to the parent node and\n      will handle the request\
    \ as detailed above.\n   o  Complete Node: The contacted node A must be a leaf\
    \ in the other\n      tree.  If node A is a leaf node in Stripe 1, node N will\
    \ become an\n      internal node in Stripe 1, taking the place of node A and adopting\n\
    \      it at the same time.  To find a place for itself in the other\n      stripe,\
    \ node N starts a random walk down the subtree rooted at the\n      sibling of\
    \ node A (if node A is the root and thus does not have\n      siblings, node N\
    \ is sent directly to a leaf in that tree), which\n      ends as soon as node\
    \ N finds an incomplete node or a leaf.  In\n      this case, node N is adopted\
    \ by the incomplete node.\n   o  Special Node: as this node is a leaf in all subtrees,\
    \ the joining\n      node MAY adopt the node in one tree and become a child in\
    \ the\n      other.\n   P2PCast uses defined messages for communication between\
    \ nodes during\n   reorganization.  To use P2PCast in this context, these messages\
    \ are\n   encapsulated by the message type Reform.  In doing so, the P2PCast\n\
    \   message is to be included in the options parameter of Reform.  The\n   following\
    \ reorganization messages are defined by P2PCast:\n      Takeon: To take another\
    \ peer as a child\n      Substitute: To take the place of a child of some peer\n\
    \      Search: To obtain the child of a node in a particular stripe\n      Replace:\
    \ Different from Substitute in that the calling node that\n      makes a node\
    \ its child sheds off a random child\n      Direct: To direct a node to its would-be\
    \ parent\n      Update: A node sends its updated state to its children\n   To\
    \ adapt the P2PCast algorithm to the ALM Usage proposed here, after\n   a Join\
    \ request is accepted, a JoinAccept message MUST be returned to\n   the joining\
    \ node (one for every subtree).\n"
- title: 9.5.  Leave
  contents:
  - "9.5.  Leave\n   When leaving a multicast group, a node will change its local\
    \ state to\n   indicate that it left the group.  Disregarding the case where the\n\
    \   leaving node is the root of the tree, the leaving node must be\n   complete\
    \ or incomplete in its proper tree.  In the other trees, the\n   node is a leaf\
    \ and can just disappear by notifying its parent.  For\n   the proper tree, if\
    \ the node is incomplete, it is replaced by its\n   child.  However, if the node\
    \ is complete, a gap is created that is\n   filled by a random child.  If this\
    \ child is incomplete, it can simply\n   fill the gap.  However, if it is complete,\
    \ it needs to shed a random\n   child.  This child is directed to its sibling,\
    \ which sheds a random\n   child.  This process ripples down the tree until the\
    \ next-to-last\n   level is reached.  The shed node is then taken as a child by\
    \ the\n   parent of the deleted node in the other stripe.\n   Again, for the reorganization\
    \ of the tree, the Reform message type is\n   used as defined in the previous\
    \ section.\n"
- title: 9.6.  JoinConfirm
  contents:
  - "9.6.  JoinConfirm\n   This message is not part of the P2PCast protocol but is\
    \ required by\n   the basic protocol defined in this document.  Thus, the Usage\
    \ MUST\n   send this message to confirm a joining node accepting its parent\n\
    \   node.  As with Join and JoinAccept, this MUST be carried out for\n   every\
    \ subtree.\n"
- title: 9.7.  Multicast
  contents:
  - "9.7.  Multicast\n   A message to be multicast to a group MUST be sent to the\
    \ rendezvous\n   node from where it is forwarded down the tree by being split\
    \ into k\n   stripes.  Each stripe is then sent via a subtree.  If a receiving\n\
    \   node is a member of the tree rather than just a forwarder, it MAY\n   pass\
    \ the multicast data up to the application.\n"
- title: 10.  Message Format
  contents:
  - "10.  Message Format\n   All messages are mapped to the RELOAD experimental message\
    \ type.  The\n   mapping is shown in Figure 5.  The message codes are listed in\n\
    \   Section 14.2.  The format of the body of a message is provided in\n   [RELOAD].\n\
    \                +-------------------------+------------------+\n            \
    \    | Message                 |RELOAD Code Point |\n                +-------------------------+------------------+\n\
    \                | CreateALMTree           | exp_a_req        |\n            \
    \    +-------------------------+------------------+\n                | CreateALMTreeResponse\
    \   | exp_a_ans        |\n                +-------------------------+------------------+\n\
    \                | Join                    | exp_a_req        |\n            \
    \    +-------------------------+------------------+\n                | JoinAccept\
    \              | exp_a_ans        |\n                +-------------------------+------------------+\n\
    \                | JoinReject              | exp_a_ans        |\n            \
    \    +-------------------------+------------------+\n                | JoinConfirm\
    \             | exp_a_req        |\n                +-------------------------+------------------+\n\
    \                | JoinConfirmResponse     | exp_a_ans        |\n            \
    \    +-------------------------+------------------+\n                | JoinDecline\
    \             | exp_a_req        |\n                +-------------------------+------------------+\n\
    \                | JoinDeclineResponse     | exp_a_ans        |\n            \
    \    +-------------------------+------------------+\n                | Leave \
    \                  | exp_a_req        |\n                +-------------------------+------------------+\n\
    \                | LeaveResponse           | exp_a_ans        |\n            \
    \    +-------------------------+------------------+\n                | Reform\
    \                  | exp_a_req        |\n                +-------------------------+------------------+\n\
    \                | ReformResponse          | exp_a_ans        |\n            \
    \    +-------------------------+------------------+\n                | Heartbeat\
    \               | exp_a_req        |\n                +-------------------------+------------------+\n\
    \                | HeartbeatResponse       | exp_a_ans        |\n            \
    \    +-------------------------+------------------+\n                | NodeQuery\
    \               | exp_a_req        |\n                +-------------------------+------------------+\n\
    \                | NodeQueryResponse       | exp_a_ans        |\n            \
    \    +-------------------------+------------------+\n                | Push  \
    \                  | exp_a_req        |\n                +-------------------------+------------------+\n\
    \                | PushResponse            | exp_a_ans        |\n            \
    \    +-------------------------+------------------+\n                   Figure\
    \ 5: RELOAD Message Code Mapping\n   For Data Kind-IDs, the RELOAD specification\
    \ [RELOAD] states: \"Code\n   points in the range 0xF0000001 to 0xFFFFFFFE are\
    \ reserved for private\n   use\".  ALM Usage Kind-IDs are defined in the private\
    \ use range.\n   All ALM Usage messages map to the RELOAD Message Extension mechanism.\n\
    \   Code points for the Kinds defined in this document MUST NOT conflict\n   with\
    \ any defined code points for RELOAD.  RELOAD defines exp_a_req\n   and exp_a_ans\
    \ for experimental purposes.  This specification uses\n   only these message types\
    \ for all ALM messages.  RELOAD defines the\n   MessageContents data structure.\
    \  The ALM mapping uses the fields as\n   follows:\n   o  message_code: exp_a_req\
    \ for requests and exp_a_ans for responses\n   o  message_body: contains one instance\
    \ of ALMHeader followed by one\n      instance of ALMMessageContents\n   o  extensions:\
    \ unused\n"
- title: 10.1.  ALMHeader Definition
  contents:
  - "10.1.  ALMHeader Definition\n   struct {\n      uint32           sam_token;\n\
    \      uint16           alm_algorithm_id;\n      uint8            version;\n \
    \  } ALMHeader;\n   The fields in ALMHeader are used as follows:\n      sam_token:\
    \ The first four bytes identify this message as an ALM\n      message.  This field\
    \ MUST contain the value 0xD3414D42 (the string\n      \"SAMB\" with the high\
    \ bit of the first byte set).\n      alm_algorithm_id: The ALM Algorithm ID of\
    \ the ALM algorithm being\n      used.  Each multicast tree uses only one algorithm.\
    \  Trees with\n      different ALM algorithms can coexist and can share the same\
    \ nodes.\n      ALM Algorithm ID codes are defined in Section 14.1.\n      version:\
    \ The version of the ALM protocol being used.  This is a\n      fixed-point integer\
    \ between 0.1 and 25.4.  This document describes\n      version 1.0 with a value\
    \ of 0xA.\n"
- title: 10.2.  ALMMessageContents Definition
  contents:
  - "10.2.  ALMMessageContents Definition\n   struct {\n      uint16       alm_message_code;\n\
    \      opaque       alm_message_body;\n   } ALMMessageContents;\n   The fields\
    \ in ALMMessageContents are used as follows:\n      alm_message_code: This indicates\
    \ the message being sent.  The\n      message codes are listed in Section 14.2.\n\
    \      alm_message_body: The message body itself, represented as a\n      variable-length\
    \ string of bytes.  The bytes themselves are\n      dependent on the code value.\
    \  See Sections 8 and 9, which describe\n      the various ALM methods for the\
    \ definitions of the payload\n      contents.\n"
- title: 10.3.  Response Codes
  contents:
  - "10.3.  Response Codes\n   Response codes are defined in Section 6.3.3.1 of [RELOAD].\
    \  This\n   specification maps to RELOAD ErrorResponse as follows:\n   ErrorResponse.error_code\
    \ = Error_Exp_A;\n   Error_info contains an ALMErrorResponse instance.\n   public\
    \ struct {\n      uint16   alm_error_code;\n      opaque   alm_error_info<0..2^16-1>;\n\
    \   } ALMErrorResponse;\n   alm_error_code: The following error code values are\
    \ defined.  Numeric\n   values for these are defined in Section 14.3.\n      Error_Unknown_Algorithm:\
    \ The multicast algorithm is not known or\n      not supported.\n      Error_Child_Limit_Reached:\
    \ The maximum number of child nodes has\n      been reached for this node.\n \
    \     Error_Node_Bandwidth_Reached: The overall data bandwidth limit\n      through\
    \ this node has been reached.\n      Error_Node_Conn_Limit_Reached: The total\
    \ number of connections to\n      this node has been reached.\n      Error_Link_Cap_Limit_Reached:\
    \ The capacity of a link has been\n      reached.\n      Error_Node_Mem_Limit_Reached:\
    \ An internal memory capacity of the\n      node has been reached.\n      Error_Node_CPU_Cap_Limit_Reached:\
    \ An internal processing capacity\n      of the node has been reached.\n     \
    \ Error_Path_Limit_Reached: The maximum path length in hop count\n      over the\
    \ multicast tree has been reached.\n      Error_Path_Delay_Limit_Reached: The\
    \ maximum path length in message\n      delay over the multicast tree has been\
    \ reached.\n      Error_Tree_Fanout_Limit_Reached: The maximum fanout of a multicast\n\
    \      tree has been reached.\n      Error_Tree_Depth_Limit_Reached: The maximum\
    \ height of a multicast\n      tree has been reached.\n      Error_Other: A human-readable\
    \ description is placed in the\n      alm_error_info field.\n"
- title: 11.  Examples
  contents:
  - "11.  Examples\n   All peers in the examples are assumed to have completed\n \
    \  bootstrapping.  \"Pn\" refers to peer N.  \"group_id\" refers to a peer\n \
    \  responsible for storing the ALMTree instance with group_id.\n"
- title: 11.1.  Create Tree
  contents:
  - "11.1.  Create Tree\n   A node with \"NODE-MATCH\" rights sends a CreateALMTree\
    \ request to the\n   group_id node, which also has NODE-MATCH rights for its own\
    \ address.\n   The group_id node determines whether to create the new tree and,\
    \ if\n   so, performs a local StoreReq.  If the CreateALMTree succeeds, the\n\
    \   ALMTree instance can be retrieved using Fetch.  An example message\n   flow\
    \ for creating a tree is depicted in Figure 6.\n                P1      P2   \
    \   P3       P4      group_id\n                |       |       |        |    \
    \   |\n                |       |       |        |       |\n                | \
    \      |       |        |       |\n                | CreateALMTree |        |\
    \       |\n                |------------------------------->|\n              \
    \  |       |       |        |       |\n                |       |       |     \
    \   |       | StoreReq\n                |       |       |        |       |--+\n\
    \                |       |       |        |       |  |\n                |    \
    \   |       |        |       |  |\n                |       |       |        |\
    \       |<-+\n                |       |       |        |       | StoreResponse\n\
    \                |       |       |        |       |--+\n                |    \
    \   |       |        |       |  |\n                |       |       |        |\
    \       |  |\n                |       |       |        |       |<-+\n        \
    \        |       |       |        |       |\n                |       |       |\
    \        |       |\n                |       | CreateALMTreeResponse  |\n     \
    \           |<-------------------------------|\n                |       |    \
    \   |        |       |\n                |       |       |        |       |\n \
    \               | Fetch         |        |       |\n                |------------------------------->|\n\
    \                |       |       |        |       |\n                |       |\
    \       |        |       |\n                |       |         FetchResponse  |\n\
    \                |<-------------------------------|\n                |       |\
    \       |        |       |\n             Figure 6: Message Flow Example for CreateALMTree\n"
- title: 11.2.  Join Tree
  contents:
  - "11.2.  Join Tree\n   P1 joins node group_id as child node.  P2 joins the tree\
    \ as a child\n   of P1.  P4 joins the tree as a child of P1.  The corresponding\n\
    \   message flow is shown in Figure 7.\n                   P1      P2      P3\
    \       P4      group_id\n                   |       |       |        |      \
    \ |\n                   |       |       |        |       |\n                 \
    \  | Join                           |\n                   |------------------------------->|\n\
    \                   |       |       |        |       |\n                   | JoinAccept\
    \                     |\n                   |<-------------------------------|\n\
    \                   |       |       |        |       |\n                   | \
    \      |       |        |       |\n                   |       |Join          \
    \          |\n                   |       |----------------------->|\n        \
    \           |       |       |        |       |\n                   |         \
    \                   Join|\n                   |<-------------------------------|\n\
    \                   |       |       |        |       |\n                   |JoinAccept\
    \     |        |       |\n                   |------>|       |        |      \
    \ |\n                   |       |       |        |       |\n                 \
    \  |JoinConfirm    |        |       |\n                   |<------|       |  \
    \      |       |\n                   |       |       |        |       |\n    \
    \               |       |       |        |Join   |\n                   |     \
    \  |       |        |------>|\n                   |       |       |        | \
    \ Join |\n                   |<-------------------------------|\n            \
    \       |       |       |        |       |\n                   | Join  |     \
    \  |        |       |\n                   |------>|       |        |       |\n\
    \                   |       |       |        |       |\n                   | JoinAccept\
    \    |        |       |\n                   |----------------------->|       |\n\
    \                   |       |       |        |       |\n                   | \
    \      | JoinAccept     |       |\n                   |       |--------------->|\
    \       |\n                   |       |       |        |       |\n           \
    \        |       |       |        |       |\n                   |       |   JoinConfirm\
    \  |       |\n                   |<-----------------------|       |\n        \
    \           |       |       |        |       |\n                   |       | \
    \  JoinDecline  |       |\n                   |       |<---------------|     \
    \  |\n                   |       |       |        |       |\n                \
    \   |       |       |        |       |\n               Figure 7: Message Flow\
    \ Example for Tree Join\n"
- title: 11.3.  Leave Tree
  contents:
  - "11.3.  Leave Tree\n                   P1      P2      P3       P4      group_id\n\
    \                   |       |       |        |       |\n                   | \
    \      |       |        |       |\n                   |       |       |  Leave\
    \ |       |\n                   |<-----------------------|       |\n         \
    \          |       |       |        |       |\n                   | LeaveResponse\
    \ |        |       |\n                   |----------------------->|       |\n\
    \                   |       |       |        |       |\n                   | \
    \      |       |        |       |\n               Figure 8: Message Flow Example\
    \ for Leave Tree\n"
- title: 11.4.  Push Data
  contents:
  - "11.4.  Push Data\n   The multicast data is pushed recursively P1 => group_id\
    \ => P1 => P2,\n   P4 following the tree topology created in the Join example\
    \ above.  An\n   example message flow is shown in Figure 9.\n                \
    \   P1      P2      P3       P4      group_id\n                   |       |  \
    \     |        |       |\n                   | Push  |       |        |      \
    \ |\n                   |------------------------------->|\n                 \
    \  |       |       |        |       |\n                   |       |       |  \
    \  PushResponse|\n                   |<-------------------------------|\n    \
    \               |       |       |        |       |\n                   |     \
    \  |       |        |   Push|\n                   |<-------------------------------|\n\
    \                   |       |       |        |       |\n                   | PushResponse\
    \  |        |       |\n                   |------------------------------->|\n\
    \                   |       |       |        |       |\n                   |Push\
    \   |       |        |       |\n                   |------>|       |        |\
    \       |\n                   |       |       |        |       |\n           \
    \        |PushResponse   |        |       |\n                   |<------|    \
    \   |        |       |\n                   |       |       |        |       |\n\
    \                   | Push  |       |        |       |\n                   |----------------------->|\
    \       |\n                   |       |       |        |       |\n           \
    \        |       |   PushResponse |       |\n                   |<-----------------------|\
    \       |\n                   |       |       |        |       |\n           \
    \        |       |       |        |       |\n                   |       |    \
    \   |        |       |\n              Figure 9: Message Flow Example for Pushing\
    \ Data\n"
- title: 12.  Kind Definitions
  contents:
  - '12.  Kind Definitions

    '
- title: 12.1.  ALMTree Kind Definition
  contents:
  - "12.1.  ALMTree Kind Definition\n   This section defines the ALMTree Kind per\
    \ Section 7.4.5 of [RELOAD].\n   An instance of the ALMTree Kind is stored in\
    \ the overlay for each ALM\n   tree instance.  It is stored at the address group_id.\n\
    \   Kind-ID: 0xF0000001.  (This is a private-use code point per\n   Section 14.6\
    \ of [RELOAD].)  The Resource Name for the ALMTree Kind-ID\n   is the session_key\
    \ used to identify the ALM tree.\n   Data Model: The data model is the ALMTree\
    \ structure.\n   Access Control: NODE-MATCH.  The node performing the store operation\n\
    \   is required to have NODE-MATCH access.\n   Meaning: The meaning of the fields\
    \ is given in Section 7.2.1.\n      struct {\n        node_id peer_id;\n     \
    \   opaque session_key<0..2^32-1>;\n        node_id group_id;\n        Dictionary\
    \ options;\n      } ALMTree;\n"
- title: 13.  RELOAD Configuration File Extensions
  contents:
  - "13.  RELOAD Configuration File Extensions\n   There are no ALM parameters defined\
    \ for the RELOAD configuration\n   file.\n"
- title: 14.  IANA Considerations
  contents:
  - "14.  IANA Considerations\n   This section contains the new code points registered\
    \ by this\n   document.\n"
- title: 14.1.  ALM Algorithm Types
  contents:
  - "14.1.  ALM Algorithm Types\n   IANA has created the \"SAM ALM Algorithm IDs\"\
    \ registry.  Entries in\n   this registry are 16-bit integers denoting Application-Layer\n\
    \   Multicast algorithms as described in Section 10.1 of this document.\n   Code\
    \ points in the range 0x0003 to 0x7FFF SHALL be registered via\n   RFC 5226 [RFC5226]\
    \ Expert Review.  Code points in the range 0x8000 to\n   0xFFFF are reserved for\
    \ private use.  The initial contents of this\n   registry are:\n             \
    \ +----------------+-------------------+-----------+\n              | Algorithm\
    \ Name | ALM Algorithm ID  | RFC       |\n              +----------------+-------------------+-----------+\n\
    \              | INVALID-ALG    |            0x0000 | RFC 7019  |\n          \
    \    | SCRIBE-SAM     |            0x0001 | RFC 7019  |\n              | P2PCAST-SAM\
    \    |            0x0002 | RFC 7019  |\n              | Reserved       |     0x8000-0xFFFF\
    \ | RFC 7019  |\n              +----------------+-------------------+-----------+\n\
    \          Figure 10: \"SAM ALM Algorithm IDs\" Registry Allocations\n   These\
    \ values have been made available for the purposes of\n   experimentation.  These\
    \ values are not meant for vendor-specific use\n   of any sort and MUST NOT be\
    \ used for operational deployments.\n"
- title: 14.2.  Message Code Registration
  contents:
  - "14.2.  Message Code Registration\n   IANA has created the \"SAM ALM Message Codes\"\
    \ registry.  Entries in\n   this registry are 16-bit integers denoting message\
    \ codes as described\n   in Section 10.2 of this document.  Code points in the\
    \ range 0x0014 to\n   0x7FFF SHALL be registered via RFC 5226 [RFC5226] Expert\
    \ Review.\n   Code points in the range 0x8000 to 0xFFFF are reserved for private\n\
    \   use.  The initial contents of this registry are:\n        +-------------------------+----------------------+-----------+\n\
    \        | Message Code Name       | Message Code Value   | RFC       |\n    \
    \    +-------------------------+----------------------+-----------+\n        |\
    \ InvalidMessageCode      |               0x0000 | RFC 7019  |\n        | CreateALMTree\
    \           |               0x0001 | RFC 7019  |\n        | CreateALMTreeResponse\
    \   |               0x0002 | RFC 7019  |\n        | Join                    |\
    \               0x0003 | RFC 7019  |\n        | JoinAccept              |    \
    \           0x0004 | RFC 7019  |\n        | JoinReject              |        \
    \       0x0005 | RFC 7019  |\n        | JoinConfirm             |            \
    \   0x0006 | RFC 7019  |\n        | JoinConfirmResponse     |               0x0007\
    \ | RFC 7019  |\n        | JoinDecline             |               0x0008 | RFC\
    \ 7019  |\n        | JoinDeclineResponse     |               0x0009 | RFC 7019\
    \  |\n        | Leave                   |               0x000A | RFC 7019  |\n\
    \        | LeaveResponse           |               0x000B | RFC 7019  |\n    \
    \    | Reform                  |               0x000C | RFC 7019  |\n        |\
    \ ReformResponse          |               0x000D | RFC 7019  |\n        | Heartbeat\
    \               |               0x000E | RFC 7019  |\n        | HeartbeatResponse\
    \       |               0x000F | RFC 7019  |\n        | NodeQuery            \
    \   |               0x0010 | RFC 7019  |\n        | NodeQueryResponse       |\
    \               0x0011 | RFC 7019  |\n        | Push                    |    \
    \           0x0012 | RFC 7019  |\n        | PushResponse            |        \
    \       0x0013 | RFC 7019  |\n        | Reserved                |        0x8000-0xFFFF\
    \ | RFC 7019  |\n        +-------------------------+----------------------+-----------+\n\
    \          Figure 11: \"SAM ALM Message Codes\" Registry Allocations\n   These\
    \ values have been made available for the purposes of\n   experimentation.  These\
    \ values are not meant for vendor-specific use\n   of any sort and MUST NOT be\
    \ used for operational deployments.\n"
- title: 14.3.  Error Code Registration
  contents:
  - "14.3.  Error Code Registration\n   IANA has created the \"SAM ALM Error Codes\"\
    \ registry.  Entries in this\n   registry are 16-bit integers denoting error codes\
    \ as described in\n   Section 10.3 of this document.  Code points in the range\
    \ 0x000D to\n   0x7FFF SHALL be registered via RFC 5226 [RFC5226] Expert Review.\n\
    \   Code points in the range 0x8000 to 0xFFFF are reserved for private\n   use.\
    \  The initial contents of this registry are:\n      +----------------------------------+---------------+-----------+\n\
    \      | Error Code Name                  | Code Value    | RFC       |\n    \
    \  +----------------------------------+---------------+-----------+\n      | InvalidErrorCode\
    \                 |       0x0000  | RFC 7019  |\n      | Error_Unknown_Algorithm\
    \          |       0x0001  | RFC 7019  |\n      | Error_Child_Limit_Reached  \
    \      |       0x0002  | RFC 7019  |\n      | Error_Node_Bandwidth_Reached   \
    \  |       0x0003  | RFC 7019  |\n      | Error_Node_Conn_Limit_Reached    | \
    \      0x0004  | RFC 7019  |\n      | Error_Link_Cap_Limit_Reached     |     \
    \  0x0005  | RFC 7019  |\n      | Error_Node_Mem_Limit_Reached     |       0x0006\
    \  | RFC 7019  |\n      | Error_Node_CPU_Cap_Limit_Reached |       0x0007  | RFC\
    \ 7019  |\n      | Error_Path_Limit_Reached         |       0x0008  | RFC 7019\
    \  |\n      | Error_Path_Delay_Limit_Reached   |       0x0009  | RFC 7019  |\n\
    \      | Error_Tree_Fanout_Limit_Reached  |       0x000A  | RFC 7019  |\n    \
    \  | Error_Tree_Depth_Limit_Reached   |       0x000B  | RFC 7019  |\n      | Error_Other\
    \                      |       0x000C  | RFC 7019  |\n      | Reserved       \
    \                  | 0x8000-0xFFFF | RFC 7019  |\n      +----------------------------------+---------------+-----------+\n\
    \           Figure 12: \"SAM ALM Error Codes\" Registry Allocations\n   These\
    \ values have been made available for the purposes of\n   experimentation.  These\
    \ values are not meant for vendor-specific use\n   of any sort and MUST NOT be\
    \ used for operational deployments.\n"
- title: 15.  Security Considerations
  contents:
  - "15.  Security Considerations\n   Overlays are vulnerable to DoS and collusion\
    \ attacks.  We are not\n   solving overlay security issues.  We assume that the\
    \ node\n   authentication model as defined in [RELOAD] will be used.\n   Security\
    \ issues specific to ALM Usage include the following:\n   o  The right to create\
    \ group_id at some node_id\n   o  The right to store Tree info at some location\
    \ in the DHT\n   o  A limit on number of messages per second and bandwidth use\n\
    \   o  The right to join an ALM tree\n"
- title: 16.  Acknowledgements
  contents:
  - "16.  Acknowledgements\n   Marc Petit-Huguenin, Michael Welzl, Joerg Ott, and\
    \ Lars Eggert\n   provided important comments on earlier versions of this document.\n"
- title: 17.  References
  contents:
  - '17.  References

    '
- title: 17.1.  Normative Reference
  contents:
  - "17.1.  Normative Reference\n   [RFC2119]     Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n                 Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n"
- title: 17.2.  Informative References
  contents:
  - "17.2.  Informative References\n   [BUFORD2008]  Buford, J. and H. Yu, \"P2P:\
    \ Overlay Multicast\",\n                 Encyclopedia of Wireless and Mobile Communications,\n\
    \                 2008, <http://www.tandfonline.com/doi/abs/10.1081/\n       \
    \          E-EWMC-120043583>.\n   [BUFORD2009]  Buford, J., Yu, H., and E. Lua,\
    \ \"P2P Networking and\n                 Applications (Chapter 9)\", Morgan Kaufman,\
    \ 2009,\n                 <http://www.sciencedirect.com/science/book/\n      \
    \           9780123742148>.\n   [CASTRO2002]  Castro, M., Druschel, P., Kermarrec,\
    \ A., and A.\n                 Rowstron, \"SCRIBE: A large-scale and decentralized\n\
    \                 application-level multicast infrastructure\", IEEE\n       \
    \          Journal on Selected Areas in Communications, Vol. 20,\n           \
    \      No. 8, October 2002, <http://ieeexplore.ieee.org/xpl/\n               \
    \  login.jsp?tp=&arnumber=1038579>.\n   [CASTRO2003]  Castro, M., Jones, M., Kermarrec,\
    \ A., Rowstron, A.,\n                 Theimer, M., Wang, H., and A. Wolman, \"\
    An Evaluation of\n                 Scalable Application-level Multicast Built\
    \ Using Peer-\n                 to-peer Overlays\", Proceedings of IEEE INFOCOM\
    \ 2003,\n                 April 2003, <http://ieeexplore.ieee.org/xpl/\n     \
    \            login.jsp?tp=&arnumber=1208986>.\n   [COMMON-API]  Waehlisch, M.,\
    \ Schmidt, T., and S. Venaas, \"A Common\n                 API for Transparent\
    \ Hybrid Multicast\", Work in\n                 Progress, April 2013.\n   [KOLBERG2010]\
    \ Kolberg, M., \"Employing Multicast in P2P Overlay\n                 Networks\"\
    , Handbook of Peer-to-Peer Networking, 2010,\n                 <http://link.springer.com/content/pdf/\n\
    \                 10.1007%2F978-0-387-09751-0_30.pdf>.\n   [P2PCAST]     Nicolosi,\
    \ A. and S. Annapureddy, \"P2PCast: A Peer-to-\n                 Peer Multicast\
    \ Scheme for Streaming Data\", Stanford\n                 Secure Computer Systems\
    \ Group Report, May 2003,\n                 <http://www.scs.stanford.edu/~reddy/research/p2pcast/\n\
    \                 report.pdf>.\n   [RELOAD]      Jennings, C., Lowekamp, B., Ed.,\
    \ Rescorla, E., Baset,\n                 S., and H. Schulzrinne, \"REsource LOcation\
    \ And\n                 Discovery (RELOAD) Base Protocol\", Work in Progress,\n\
    \                 February 2013.\n   [RFC5226]     Narten, T. and H. Alvestrand,\
    \ \"Guidelines for Writing\n                 an IANA Considerations Section in\
    \ RFCs\", BCP 26, RFC\n                 5226, May 2008.\n   [SAM-GENERIC] Muramoto,\
    \ E., Imai, Y., and N. Kawaguchi, \"Requirements\n                 for Scalable\
    \ Adaptive Multicast Framework in Non-GIG\n                 Networks\", Work in\
    \ Progress, November 2006.\n   [SPLITSTREAM] Castro, M., Druschel, P., Nandi,\
    \ A., Kermarrec, A.,\n                 Rowstron, A., and A. Singh, \"SplitStream:\
    \ High-\n                 Bandwidth Multicast in a Cooperative Environment\",\
    \ SOSP\n                 '03, Lake Bolton, New York, October 2003,\n         \
    \        <http://dl.acm.org/citation.cfm?id=945474>.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   John Buford\n   Avaya Labs Research\n   211 Mt. Airy Rd.\n\
    \   Basking Ridge, New Jersey  07920\n   USA\n   Phone: +1 908 848 5675\n   EMail:\
    \ buford@avaya.com\n   Mario Kolberg (editor)\n   University of Stirling\n   Dept.\
    \ of Computing Science and Mathematics\n   Stirling  FK9 4LA\n   UK\n   Phone:\
    \ +44 1786 46 7440\n   EMail: mkolberg@ieee.org\n   URI:   http://www.cs.stir.ac.uk/~mko\n"
