- title: __initial_text__
  contents:
  - '    Structure of the Generic Security Service (GSS) Negotiation Loop

    '
- title: Abstract
  contents:
  - "Abstract\n   This document specifies the generic structure of the negotiation\
    \ loop\n   to establish a Generic Security Service (GSS) security context\n  \
    \ between initiator and acceptor.  The control flow of the loop is\n   indicated\
    \ for both parties, including error conditions, and\n   indications are given\
    \ for where application-specific behavior must be\n   specified.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7546.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n\
    \   2. Application Protocol Requirements ...............................3\n  \
    \ 3. Loop Structure ..................................................4\n    \
    \  3.1. Anonymous Initiators .......................................5\n      3.2.\
    \ GSS_Init_sec_context .......................................5\n      3.3. Sending\
    \ from Initiator to Acceptor .........................6\n      3.4. Acceptor Sanity\
    \ Checking ...................................6\n      3.5. GSS_Accept_sec_context\
    \ .....................................7\n      3.6. Sending from Acceptor to\
    \ Initiator .........................8\n      3.7. Initiator Input Validation\
    \ .................................9\n      3.8. Continue the Loop ..........................................9\n\
    \   4. After Security Context Negotiation ..............................9\n  \
    \    4.1. Authorization Checks ......................................10\n    \
    \  4.2. Using Partially Complete Security Contexts ................10\n      4.3.\
    \ Additional Context Tokens .................................11\n   5. Sample\
    \ Code ....................................................12\n      5.1. GSS\
    \ Application Sample Code ...............................13\n   6. Security Considerations\
    \ ........................................19\n   7. References .....................................................20\n\
    \      7.1. Normative References ......................................20\n  \
    \    7.2. Informative References ....................................20\n   Acknowledgements\
    \ ..................................................21\n   Author's Address ..................................................21\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   \"Generic Security Service Application Program Interface\
    \ Version 2,\n   Update 1\" [RFC2743] provides a generic interface for security\n\
    \   services in the form of an abstraction layer over the underlying\n   security\
    \ mechanisms that an application may use.  A GSS initiator and\n   acceptor exchange\
    \ messages, called \"tokens\", until a security context\n   is established.  Such\
    \ a security context allows for each party to\n   authenticate the other, the\
    \ passing of confidential and/or integrity-\n   protected messages between the\
    \ initiator and acceptor, the generation\n   of identical pseudorandom bit strings\
    \ by both participants [RFC4401],\n   and more.\n   During context establishment,\
    \ security context tokens are exchanged\n   synchronously, one at a time; the\
    \ initiator sends the first context\n   token.  The number of tokens that must\
    \ be exchanged between the\n   initiator and acceptor in order to establish the\
    \ security context is\n   dependent on the underlying mechanism as well as the\
    \ desired\n   properties of the security context and is, in general, not known\
    \ to\n   the application.  Accordingly, the application's control flow must\n\
    \   include a loop within which GSS security context tokens are\n   exchanged;\
    \ the loop terminates upon successful establishment of a\n   security context\
    \ or an error condition.  The GSS-API, together with\n   its security mechanisms,\
    \ specifies the format and encoding of the\n   context tokens themselves, but\
    \ the application protocol must specify\n   the necessary framing for the application\
    \ to determine what octet\n   strings constitute GSS security context tokens and\
    \ pass them into the\n   GSS-API implementation as appropriate.\n   The GSS-API\
    \ C-bindings [RFC2744] provide some example code for such a\n   negotiation loop,\
    \ but this code does not specify the application's\n   behavior on unexpected\
    \ or error conditions.  As such, individual\n   application protocol specifications\
    \ have had to specify the structure\n   of their GSS negotiation loops, including\
    \ error handling, on a per-\n   protocol basis (see [RFC4462], [RFC3645], [RFC5801],\
    \ [RFC4752], and\n   [RFC2203]).  This represents a substantial duplication of\
    \ effort, and\n   the various specifications go into different levels of detail\
    \ and\n   describe different possible error conditions.  Therefore, it is\n  \
    \ preferable to have the structure of the GSS negotiation loop,\n   including\
    \ error conditions and token passing, described in a single\n   specification\
    \ that can then be referred to from other documents in\n   lieu of repeating the\
    \ structure of the loop each time.  This document\n   fills that role.\n   The\
    \ necessary requirements for correctly performing a GSS negotiation\n   loop are\
    \ essentially all included in [RFC2743], but they are\n   scattered in many different\
    \ places.  This document brings all the\n   requirements together into one place\
    \ for the convenience of\n   implementors, even though the normative requirements\
    \ remain in\n   [RFC2743].  In a few places, this document notes additional behavior\n\
    \   that is useful for applications but is not mandated by [RFC2743].\n"
- title: 2.  Application Protocol Requirements
  contents:
  - "2.  Application Protocol Requirements\n   Part of the purpose of this document\
    \ is to guide the development of\n   new application protocols using the GSS-API,\
    \ as well as the\n   development of new application software using such protocols.\
    \  The\n   following list consists of features that are necessary or useful in\n\
    \   such an application protocol:\n   o  Protocols require a way to frame and\
    \ identify security context\n      negotiation tokens during the GSS negotiation\
    \ loop.\n   o  Error tokens should generally also get special framing, as the\n\
    \      recipient may have no other way to distinguish unexpected error\n     \
    \ context tokens from per-message tokens.\n   o  Protocols may benefit from a\
    \ generic means of indicating an error,\n      possibly accompanied by a descriptive\
    \ string, to be used if error\n      tokens are not available or not usable due\
    \ to constraints of the\n      application protocol.\n   o  A protocol may use\
    \ the negotiated GSS security context for per-\n      message operations; in such\
    \ cases, the protocol will need a way to\n      frame and identify those per-message\
    \ tokens and the nature of\n      their contents.  For example, a protocol message\
    \ may be\n      accompanied by the output of GSS_GetMIC() over that message; the\n\
    \      protocol must identify the location and size of that Message\n      Identity\
    \ Code (MIC) token and indicate that it is a MIC token and\n      to what cleartext\
    \ it corresponds.\n   o  Applications are responsible for authorization of the\n\
    \      authenticated peer principal names that are supplied by the GSS-\n    \
    \  API.  Such names are mechanism specific and may come from a\n      different\
    \ portion of a federated identity scheme.  Application\n      protocols may need\
    \ to supply additional information to support the\n      authorization of access\
    \ to a given resource, such as the Secure\n      Shell version 2 (SSHv2) \"username\"\
    \ parameter.\n"
- title: 3.  Loop Structure
  contents:
  - "3.  Loop Structure\n   The loop is begun by the appropriately named initiator,\
    \ which calls\n   GSS_Init_sec_context() with an empty (zero-length) input_token\
    \ and a\n   fixed set of input flags containing the desired attributes for the\n\
    \   security context.  The initiator should not change any of the input\n   parameters\
    \ to GSS_Init_sec_context() between calls to it during the\n   loop, with the\
    \ exception of the input_token parameter, which will\n   contain a message from\
    \ the acceptor after the initial call, and the\n   input_context_handle, which\
    \ must be the result returned in the\n   output_context_handle of the previous\
    \ call to GSS_Init_sec_context()\n   (GSS_C_NO_CONTEXT for the first call).  (In\
    \ the C bindings, there is\n   only a single read/modify context_handle argument,\
    \ so the same\n   variable should be passed for each call in the loop.)  RFC 2743\
    \ only\n   requires that the claimant_cred_handle argument remain constant over\n\
    \   all calls in the loop, but the other non-excepted arguments should\n   also\
    \ remain fixed for reliable operation.\n   The following subsections will describe\
    \ the various steps of the\n   loop, without special consideration to whether\
    \ a call to\n   GSS_Init_sec_context() or GSS_Accept_sec_context() is the first\
    \ such\n   call in the loop.\n"
- title: 3.1.  Anonymous Initiators
  contents:
  - "3.1.  Anonymous Initiators\n   If the initiator is requesting anonymity by setting\
    \ the anon_req_flag\n   input to GSS_Init_sec_context(), then on non-error returns\
    \ from\n   GSS_Init_sec_context() (that is, when the major status is\n   GSS_S_COMPLETE\
    \ or GSS_S_CONTINUE_NEEDED) the initiator must verify\n   that the output value\
    \ of anon_state from GSS_Init_sec_context() is\n   true before sending the security\
    \ context token to the acceptor.\n   Failing to perform this check could cause\
    \ the initiator to lose\n   anonymity.\n"
- title: 3.2.  GSS_Init_sec_context
  contents:
  - "3.2.  GSS_Init_sec_context\n   The initiator calls GSS_Init_sec_context() using\
    \ the\n   input_context_handle for the current security context being\n   established\
    \ and its fixed set of input parameters and the input_token\n   received from\
    \ the acceptor (if this is not the first iteration of the\n   loop).  The presence\
    \ or absence of a nonempty output_token and the\n   value of the major status\
    \ code are the indicators for how to proceed:\n   o  If the major status code\
    \ is GSS_S_COMPLETE and the output_token is\n      empty, then the context negotiation\
    \ is fully complete and ready\n      for use by the initiator with no further\
    \ actions.\n   o  If the major status code is GSS_S_COMPLETE and the output_token\
    \ is\n      nonempty, then the initiator's portion of the security context\n \
    \     negotiation is complete but the acceptor's is not.  The initiator\n    \
    \  must send the output_token to the acceptor so that the acceptor\n      can\
    \ establish its half of the security context.\n   o  If the major status code\
    \ is GSS_S_CONTINUE_NEEDED and the\n      output_token is nonempty, the context\
    \ negotiation is incomplete.\n      The initiator must send the output_token to\
    \ the acceptor and await\n      another input_token from the acceptor.\n   o \
    \ If the major status code is GSS_S_CONTINUE_NEEDED and the\n      output_token\
    \ is empty, the mechanism has produced an output that\n      is not compliant\
    \ with [RFC2743].  However, there are some known\n      implementations of certain\
    \ mechanisms such as NT LAN Manager\n      Security Support Provider [NTLMSSP]\
    \ that do produce empty context\n      negotiation tokens.  For maximum interoperability,\
    \ applications\n      should be prepared to accept such tokens and should transmit\
    \ them\n      to the acceptor if they are generated.\n   o  If the major status\
    \ code is any other value, the context\n      negotiation has failed.  If the\
    \ output_token is nonempty, it is an\n      error token and the initiator should\
    \ send it to the acceptor.  If\n      the output_token is empty, then the initiator\
    \ should indicate the\n      failure to the acceptor if an appropriate application-protocol\n\
    \      channel to do so is available.\n"
- title: 3.3.  Sending from Initiator to Acceptor
  contents:
  - "3.3.  Sending from Initiator to Acceptor\n   The establishment of a GSS security\
    \ context between initiator and\n   acceptor requires some communication channel\
    \ by which to exchange the\n   context negotiation tokens.  The nature of this\
    \ channel is not\n   specified by the GSS specification -- it could be a dedicated\
    \ TCP\n   channel, a UDP-based Remote Procedure Call (RPC) protocol, or any\n\
    \   other sort of channel.  In many cases, the channel will be\n   multiplexed\
    \ with non-GSS application data; the application protocol\n   must always provide\
    \ some means by which the GSS context tokens can be\n   identified (e.g., length\
    \ and start location) and passed through to\n   the mechanism accordingly.  The\
    \ application protocol may also include\n   a facility for indicating errors from\
    \ one party to the other, which\n   can be used to convey errors resulting from\
    \ GSS-API calls when\n   appropriate (such as when no error token was generated\
    \ by the GSS-API\n   implementation).  Note that GSS major and minor status codes\
    \ are\n   specified by language bindings, not the abstract API; sending a major\n\
    \   status code and optionally the display form of the two error codes\n   may\
    \ be the best that can be done in this case.\n   However, even the presence of\
    \ a communication channel does not\n   necessarily indicate that it is appropriate\
    \ for the initiator to\n   indicate such errors.  For example, if the acceptor\
    \ is a stateless or\n   near-stateless UDP server, there is probably no need for\
    \ the\n   initiator to explicitly indicate its failure to the acceptor.\n   Conditions\
    \ such as this can be treated in individual application\n   protocol specifications.\n\
    \   If a regular security context output_token is produced by the call to\n  \
    \ GSS_Init_sec_context(), the initiator must transmit this token to the\n   acceptor\
    \ over the application's communication channel.  If the call\n   to GSS_Init_sec_context()\
    \ returns an error token as output_token, it\n   is recommended that the initiator\
    \ transmit this token to the acceptor\n   over the application's communication\
    \ channel.\n"
- title: 3.4.  Acceptor Sanity Checking
  contents:
  - "3.4.  Acceptor Sanity Checking\n   The acceptor's half of the negotiation loop\
    \ is triggered by the\n   receipt of a context token from the initiator.  Before\
    \ calling\n   GSS_Accept_sec_context(), the acceptor may find it useful to perform\n\
    \   some sanity checks on the state of the negotiation loop.\n   If the acceptor\
    \ receives a context token but was not expecting such a\n   token (for example,\
    \ if the acceptor's previous call to\n   GSS_Accept_sec_context() returned GSS_S_COMPLETE),\
    \ this is probably\n   an error condition indicating that the initiator's state\
    \ is invalid.\n   See Section 4.3 for some exceptional cases.  It is likely appropriate\n\
    \   for the acceptor to report this error condition to the initiator via\n   the\
    \ application's communication channel.\n   If the acceptor is expecting a context\
    \ token (e.g., if the previous\n   call to GSS_Accept_sec_context() returned GSS_S_CONTINUE_NEEDED)\
    \ but\n   does not receive such a token within a reasonable amount of time\n \
    \  after transmitting the previous output_token to the initiator, the\n   acceptor\
    \ should assume that the initiator's state is invalid\n   (timeout) and fail the\
    \ GSS negotiation.  Again, it is likely\n   appropriate for the acceptor to report\
    \ this error condition to the\n   initiator via the application's communication\
    \ channel.\n"
- title: 3.5.  GSS_Accept_sec_context
  contents:
  - "3.5.  GSS_Accept_sec_context\n   The GSS acceptor responds to the actions of\
    \ an initiator; as such,\n   there should always be a nonempty input_token to\
    \ calls to\n   GSS_Accept_sec_context().  The input_context_handle parameter will\n\
    \   always be given as the output_context_handle from the previous call\n   to\
    \ GSS_Accept_sec_context() in a given negotiation loop, or\n   GSS_C_NO_CONTEXT\
    \ on the first call, but the acceptor_cred_handle and\n   chan_bindings arguments\
    \ should remain fixed over the course of a\n   given GSS negotiation loop.  [RFC2743]\
    \ only requires that the\n   acceptor_cred_handle remain fixed throughout the\
    \ loop, but the\n   chan_bindings argument should also remain fixed for reliable\n\
    \   operation.\n   The GSS acceptor calls GSS_Accept_sec_context(), using the\n\
    \   input_context_handle for the current security context being\n   established\
    \ and the input_token received from the initiator.  The\n   presence or absence\
    \ of a nonempty output_token and the value of the\n   major status code are the\
    \ indicators for how to proceed:\n   o  If the major status code is GSS_S_COMPLETE\
    \ and the output_token is\n      empty, then the context negotiation is fully\
    \ complete and ready\n      for use by the acceptor with no further actions.\n\
    \   o  If the major status code is GSS_S_COMPLETE and the output_token is\n  \
    \    nonempty, then the acceptor's portion of the security context\n      negotiation\
    \ is complete but the initiator's is not.  The acceptor\n      must send the output_token\
    \ to the initiator so that the initiator\n      can establish its half of the\
    \ security context.\n   o  If the major status code is GSS_S_CONTINUE_NEEDED and\
    \ the\n      output_token is nonempty, the context negotiation is incomplete.\n\
    \      The acceptor must send the output_token to the initiator and await\n  \
    \    another input_token from the initiator.\n   o  If the major status code is\
    \ GSS_S_CONTINUE_NEEDED and the\n      output_token is empty, the mechanism has\
    \ produced an output that\n      is not compliant with [RFC2743].  However, there\
    \ are some known\n      implementations of certain mechanisms such as NTLMSSP\
    \ [NTLMSSP]\n      that do produce empty context negotiation tokens.  For maximum\n\
    \      interoperability, applications should be prepared to accept such\n    \
    \  tokens and should transmit them to the initiator if they are\n      generated.\n\
    \   o  If the major status code is any other value, the context\n      negotiation\
    \ has failed.  If the output_token is nonempty, it is an\n      error token and\
    \ the acceptor should send it to the initiator.  If\n      the output_token is\
    \ empty, then the acceptor should indicate the\n      failure to the initiator\
    \ if an appropriate application-protocol\n      channel to do so is available.\n"
- title: 3.6.  Sending from Acceptor to Initiator
  contents:
  - "3.6.  Sending from Acceptor to Initiator\n   The mechanism for sending the context\
    \ token from acceptor to\n   initiator will depend on the nature of the communication\
    \ channel\n   between the two parties.  For a synchronous bidirectional channel,\
    \ it\n   can be just another piece of data sent over the link, but for a\n   stateless\
    \ UDP RPC acceptor, the token will probably end up being sent\n   as an RPC output\
    \ parameter.  Application protocol specifications will\n   need to specify the\
    \ nature of this behavior.\n   If the application protocol has the initiator driving\
    \ the\n   application's control flow, it is particularly helpful for the\n   acceptor\
    \ to indicate a failure to the initiator, as mentioned in some\n   of the above\
    \ cases conditional on \"an appropriate application-\n   protocol channel to do\
    \ so\".\n   If a regular security context output_token is produced by the call\
    \ to\n   GSS_Accept_sec_context(), the acceptor must transmit this token to\n\
    \   the initiator over the application's communication channel.  If the\n   call\
    \ to GSS_Accept_sec_context() returns an error token as\n   output_token, it is\
    \ recommended that the acceptor transmit this token\n   to the initiator over\
    \ the application's communication channel.\n"
- title: 3.7.  Initiator Input Validation
  contents:
  - "3.7.  Initiator Input Validation\n   The initiator's half of the negotiation\
    \ loop is triggered (after the\n   first call) by receipt of a context token from\
    \ the acceptor.  Before\n   calling GSS_Init_sec_context(), the initiator may\
    \ find it useful to\n   perform some sanity checks on the state of the negotiation\
    \ loop.\n   If the initiator receives a context token but was not expecting such\n\
    \   a token (for example, if the initiator's previous call to\n   GSS_Init_sec_context()\
    \ returned GSS_S_COMPLETE), this is probably an\n   error condition indicating\
    \ that the acceptor's state is invalid.  See\n   Section 4.3 for some exceptional\
    \ cases.  It may be appropriate for\n   the initiator to report this error condition\
    \ to the acceptor via the\n   application's communication channel.\n   If the\
    \ initiator is expecting a context token (that is, the previous\n   call to GSS_Init_sec_context()\
    \ returned GSS_S_CONTINUE_NEEDED) but\n   does not receive such a token within\
    \ a reasonable amount of time\n   after transmitting the previous output_token\
    \ to the acceptor, the\n   initiator should assume that the acceptor's state is\
    \ invalid and fail\n   the GSS negotiation.  Again, it may be appropriate for\
    \ the initiator\n   to report this error condition to the acceptor via the application's\n\
    \   communication channel.\n"
- title: 3.8.  Continue the Loop
  contents:
  - "3.8.  Continue the Loop\n   If the loop is in neither a success nor a failure\
    \ condition, then the\n   loop must continue.  Control flow returns to Section\
    \ 3.2.\n"
- title: 4.  After Security Context Negotiation
  contents:
  - "4.  After Security Context Negotiation\n   Once a party has completed its half\
    \ of the security context and\n   fulfilled its obligations to the other party,\
    \ the context is\n   complete, but it is not necessarily ready and appropriate\
    \ for use.\n   In particular, the security context flags may not be appropriate\
    \ for\n   the given application's use.  In some cases, the context may be ready\n\
    \   for use before the negotiation is complete, see Section 4.2.\n   The initiator\
    \ specifies, as part of its fixed set of inputs to\n   GSS_Init_sec_context(),\
    \ values for all defined request flag booleans,\n   among them: deleg_req_flag,\
    \ mutual_req_flag, replay_det_req_flag,\n   sequence_req_flag, conf_req_flag,\
    \ and integ_req_flag.  Upon\n   completion of the security context negotiation,\
    \ the initiator must\n   verify that the values of deleg_state, mutual_state,\n\
    \   replay_det_state, sequence_state, conf_avail, and integ_avail (and\n   any\
    \ additional flags added by extensions) from the last call to\n   GSS_Init_sec_context()\
    \ correspond to the requested flags.  If a flag\n   was requested but is not available\
    \ and that feature is necessary for\n   the application protocol, the initiator\
    \ must destroy the security\n   context and not use the security context for application\
    \ traffic.\n   Application protocol specifications citing this document should\n\
    \   indicate which context flags are required for their application\n   protocol.\n\
    \   The acceptor receives as output the following booleans: deleg_state,\n   mutual_state,\
    \ replay_det_state, sequence_state, anon_state,\n   trans_state, conf_avail, and\
    \ integ_avail, and any additional flags\n   added by extensions to the GSS-API.\
    \  The acceptor must verify that\n   any flags necessary for the application protocol\
    \ are set.  If a\n   necessary flag is not set, the acceptor must destroy the\
    \ security\n   context and not use the security context for application traffic.\n"
- title: 4.1.  Authorization Checks
  contents:
  - "4.1.  Authorization Checks\n   The acceptor receives as one of the outputs of\n\
    \   GSS_Accept_sec_context() the name of the initiator that has\n   authenticated\
    \ during the security context negotiation.  Applications\n   need to implement\
    \ authorization checks on this received name\n   ('client_name' in the sample\
    \ code) before providing access to\n   restricted resources.  In particular, security\
    \ context negotiation\n   can be successful when the client is anonymous or is\
    \ from a different\n   identity realm than the acceptor, depending on the details\
    \ of the\n   mechanism used by the GSS-API to establish the security context.\n\
    \   Acceptor applications can check which target name was used by the\n   initiator,\
    \ but the details are out of scope for this document.  See\n   Sections 2.2.6\
    \ and 1.1.5 of [RFC2743].  Additional information can be\n   available in GSS-API\
    \ Naming Extensions [RFC6680].\n"
- title: 4.2.  Using Partially Complete Security Contexts
  contents:
  - "4.2.  Using Partially Complete Security Contexts\n   For mechanism/flag combinations\
    \ that require multiple token\n   exchanges, the GSS-API specification [RFC2743]\
    \ provides a\n   prot_ready_state output value from GSS_Init_sec_context() and\n\
    \   GSS_Accept_sec_context(), which indicates when per-message operations\n  \
    \ are available.  However, many mechanism implementations do not\n   provide this\
    \ functionality and the analysis of the security\n   consequences of its use is\
    \ rather complicated, so it is not expected\n   to be useful in most application\
    \ protocols.\n   In particular, mutual authentication, replay protection, and\
    \ other\n   services (if requested) are services that will be active when\n  \
    \ GSS_S_COMPLETE is returned but that are not necessarily active before\n   the\
    \ security context is fully established.\n"
- title: 4.3.  Additional Context Tokens
  contents:
  - "4.3.  Additional Context Tokens\n   Under some conditions, a context token will\
    \ be received by a party to\n   a security context negotiation after that party\
    \ has completed the\n   negotiation (i.e., after GSS_Init_sec_context() or\n \
    \  GSS_Accept_sec_context() has returned GSS_S_COMPLETE).  Such tokens\n   must\
    \ be passed to GSS_Process_context_token() for processing.  It may\n   not always\
    \ be necessary for a mechanism implementation to generate an\n   error token on\
    \ the initiator side or for an initiator application to\n   transmit that token\
    \ to the acceptor; such decisions are out of scope\n   for this document.  Both\
    \ peers should always be prepared to process\n   such tokens and application protocols\
    \ should provide means by which\n   they can be transmitted.\n   Such tokens can\
    \ be security context deletion tokens, emitted when the\n   remote party called\
    \ GSS_Delete_sec_context() with a non-null\n   output_context_token parameter,\
    \ or error tokens, emitted when the\n   remote party experiences an error processing\
    \ the last token in a\n   security context negotiation exchange.  Errors experienced\
    \ when\n   processing tokens earlier in the negotiation would be transmitted as\n\
    \   normal security context tokens and processed by\n   GSS_Init_sec_context()\
    \ or GSS_Accept_sec_context(), as appropriate.\n   With the GSS-API version 2,\
    \ it is not recommended to use security\n   context deletion tokens, so error\
    \ tokens are expected to be the most\n   common form of additional context token\
    \ for new application\n   protocols.\n   GSS_Process_context_token() may indicate\
    \ an error in its major_status\n   field if an error is encountered locally during\
    \ token processing or\n   to indicate that an error was encountered on the peer\
    \ and conveyed in\n   an error token.  See [Err4151] of [RFC2743].  Regardless\
    \ of the\n   major_status output of GSS_Process_context_token(),\n   GSS_Inquire_context()\
    \ should be used after processing the extra\n   token, to query the status of\
    \ the security context and whether it can\n   supply the features necessary for\
    \ the application protocol.\n   At present, all tokens that should be handled\
    \ by\n   GSS_Process_context_token() will lead to the security context being\n\
    \   effectively unusable.  Future extensions to the GSS-API may allow for\n  \
    \ applications to continue to function after a call to\n   GSS_Process_context_token(),\
    \ and it is expected that the outputs of\n   GSS_Inquire_context() will indicate\
    \ whether it is safe to do so.\n   However, since there are no such extensions\
    \ at present (error tokens\n   and deletion tokens both result in the security\
    \ context being\n   essentially unusable), there is no guidance to give to applications\n\
    \   regarding this possibility at this time.\n   Even if GSS_Process_context_token()\
    \ processes an error or deletion\n   token that renders the context essentially\
    \ unusable, the resources\n   associated with the context must eventually be freed\
    \ with a call to\n   GSS_Delete_sec_context(), just as would be needed if\n  \
    \ GSS_Init_sec_context() or GSS_Accept_sec_context() had returned an\n   error\
    \ while processing an input context token and the\n   input_context_handle was\
    \ not GSS_C_NO_CONTEXT.  RFC 2743 has some\n   text that is slightly ambiguous\
    \ in this regard, but the best practice\n   is to always call GSS_Delete_sec_context().\n"
- title: 5.  Sample Code
  contents:
  - "5.  Sample Code\n   This section gives sample code for the GSS negotiation loop,\
    \ both for\n   a regular application and for an application where the initiator\n\
    \   wishes to remain anonymous.  Since the code for the two cases is very\n  \
    \ similar, the anonymous-specific additions are wrapped in a\n   conditional check;\
    \ that check and the conditional code may be ignored\n   if anonymous processing\
    \ is not needed.\n   Since the communication channel between the initiator and\
    \ acceptor is\n   a matter for individual application protocols, it is inherently\n\
    \   unspecified at the GSS-API level, which can lead to examples that are\n  \
    \ less satisfying than may be desired.  For example, the sample code in\n   [RFC2744]\
    \ uses an unspecified send_token_to_peer() routine.  Fully\n   correct and general\
    \ code to frame and transmit tokens requires a\n   substantial amount of error\
    \ checking and would detract from the core\n   purpose of this document, so we\
    \ only present the function signature\n   for one example of what such functions\
    \ might be and leave some\n   comments in the otherwise empty function bodies.\n\
    \   This sample code is written in C, using the GSS-API C-bindings\n   [RFC2744].\
    \  It uses the macro GSS_ERROR() to help unpack the various\n   sorts of information\
    \ that can be stored in the major status field;\n   supplementary information\
    \ does not necessarily indicate an error.\n   Applications written in other languages\
    \ will need to exercise care\n   that checks against the major status value are\
    \ written correctly.\n   This sample code should be compilable as a standalone\
    \ program, linked\n   against a GSS-API library.  In addition to supplying implementations\n\
    \   for the token transmission/receipt routines, in order for the program\n  \
    \ to successfully run when linked against most GSS-API libraries, the\n   initiator\
    \ will need to specify an explicit target name for the\n   acceptor, which must\
    \ match the credentials available to the acceptor.\n   A skeleton for how this\
    \ may be done is provided, using a dummy name.\n   This sample code assumes use\
    \ of v2 of the GSS-API.  Applications\n   wishing to remain compatible with v1\
    \ of the GSS-API may need to\n   perform additional checks in some locations.\n"
- title: 5.1.  GSS Application Sample Code
  contents:
  - '5.1.  GSS Application Sample Code

    '
- title: '#include <unistd.h>'
  contents:
  - '#include <unistd.h>

    '
- title: '#include <err.h>'
  contents:
  - '#include <err.h>

    '
- title: '#include <stdio.h>'
  contents:
  - '#include <stdio.h>

    '
- title: '#include <stdlib.h>'
  contents:
  - '#include <stdlib.h>

    '
- title: '#include <string.h>'
  contents:
  - '#include <string.h>

    '
- title: '#include <gssapi/gssapi.h>'
  contents:
  - '#include <gssapi/gssapi.h>

    '
- title: /*
  contents:
  - "/*\n * This helper is used only on buffers that we allocate ourselves (e.g.,\n\
    \ * from receive_token()).  Buffers allocated by GSS routines must use\n * gss_release_buffer().\n\
    \ */\n"
- title: static void
  contents:
  - 'static void

    '
- title: release_buffer(gss_buffer_t buf)
  contents:
  - 'release_buffer(gss_buffer_t buf)

    '
- title: '{'
  contents:
  - "{\n    free(buf->value);\n    buf->value = NULL;\n    buf->length = 0;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * Helper to send a token on the specified file descriptor.\n *\n * If errors\
    \ are encountered, this routine must not directly cause\n * termination of the\
    \ process because compliant GSS applications\n * must release resources allocated\
    \ by the GSS library before\n * exiting.\n *\n * Returns 0 on success, nonzero\
    \ on failure.\n */\n"
- title: static int
  contents:
  - 'static int

    '
- title: send_token(int fd, gss_buffer_t token)
  contents:
  - 'send_token(int fd, gss_buffer_t token)

    '
- title: '{'
  contents:
  - "{\n    /*\n     * Supply token framing and transmission code here.\n     *\n\
    \     * It is advisable for the application protocol to specify the\n     * length\
    \ of the token being transmitted unless the underlying\n     * transit does so\
    \ implicitly.\n     *\n     * In addition to checking for error returns from whichever\n\
    \     * syscall(s) are used to send data, applications should have\n     * a loop\
    \ to handle EINTR returns.\n     */\n    return 1;\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * Helper to receive a token on the specified file descriptor.\n *\n * If\
    \ errors are encountered, this routine must not directly cause\n * termination\
    \ of the process because compliant GSS applications\n * must release resources\
    \ allocated by the GSS library before\n * exiting.\n *\n * Returns 0 on success,\
    \ nonzero on failure.\n */\n"
- title: static int
  contents:
  - 'static int

    '
- title: receive_token(int fd, gss_buffer_t token)
  contents:
  - 'receive_token(int fd, gss_buffer_t token)

    '
- title: '{'
  contents:
  - "{\n    /*\n     * Supply token framing and transmission code here.\n     *\n\
    \     * In addition to checking for error returns from whichever\n     * syscall(s)\
    \ are used to receive data, applications should have\n     * a loop to handle\
    \ EINTR returns.\n     *\n     * This routine is assumed to allocate memory for\
    \ the local copy\n     * of the received token, which must be freed with release_buffer().\n\
    \     */\n    return 1;\n"
- title: '}'
  contents:
  - '}

    '
- title: static void
  contents:
  - 'static void

    '
- title: do_initiator(int readfd, int writefd, int anon)
  contents:
  - 'do_initiator(int readfd, int writefd, int anon)

    '
- title: '{'
  contents:
  - "{\n    int initiator_established = 0, ret;\n    gss_ctx_id_t ctx = GSS_C_NO_CONTEXT;\n\
    \    OM_uint32 major, minor, req_flags, ret_flags;\n    gss_buffer_desc input_token\
    \ = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;\n\
    \    gss_buffer_desc name_buf = GSS_C_EMPTY_BUFFER;\n    gss_name_t target_name\
    \ = GSS_C_NO_NAME;\n    /* Applications should set target_name to a real value.\
    \ */\n    name_buf.value = \"<service>@<hostname.domain>\";\n    name_buf.length\
    \ = strlen(name_buf.value);\n    major = gss_import_name(&minor, &name_buf,\n\
    \                            GSS_C_NT_HOSTBASED_SERVICE, &target_name);\n    if\
    \ (GSS_ERROR(major)) {\n        warnx(1, \"Could not import name\\n\");\n    \
    \    goto cleanup;\n    }\n    /* Mutual authentication will require a token from\
    \ acceptor to\n     * initiator and thus a second call to gss_init_sec_context().\
    \ */\n    req_flags = GSS_C_MUTUAL_FLAG | GSS_C_CONF_FLAG | GSS_C_INTEG_FLAG;\n\
    \    if (anon)\n        req_flags |= GSS_C_ANON_FLAG;\n    while (!initiator_established)\
    \ {\n        /* The initiator_cred_handle, mech_type, time_req,\n         * input_chan_bindings,\
    \ actual_mech_type, and time_rec\n         * parameters are not needed in many\
    \ cases.  We pass\n         * GSS_C_NO_CREDENTIAL, GSS_C_NO_OID, 0, NULL, NULL,\
    \ and NULL\n         * for them, respectively. */\n        major = gss_init_sec_context(&minor,\
    \ GSS_C_NO_CREDENTIAL, &ctx,\n                                     target_name,\
    \ GSS_C_NO_OID,\n                                     req_flags, 0, NULL, &input_token,\n\
    \                                     NULL, &output_token, &ret_flags,\n     \
    \                                NULL);\n        /* This was allocated by receive_token()\
    \ and is no longer\n         * needed.  Free it now to avoid leaks if the loop\
    \ continues. */\n        release_buffer(&input_token);\n        if (anon) {\n\
    \            /* Initiators that wish to remain anonymous must check\n        \
    \     * whether their request has been honored before sending\n             *\
    \ each token. */\n            if (!(ret_flags & GSS_C_ANON_FLAG)) {\n        \
    \        warnx(\"Anonymous requested but not available\\n\");\n              \
    \  goto cleanup;\n            }\n        }\n        /* Always send a token if\
    \ we are expecting another input token\n         * (GSS_S_CONTINUE_NEEDED is set)\
    \ or if it is nonempty. */\n        if ((major & GSS_S_CONTINUE_NEEDED) ||\n \
    \           output_token.length > 0) {\n            ret = send_token(writefd,\
    \ &output_token);\n            if (ret != 0)\n                goto cleanup;\n\
    \        }\n        /* Check for errors after sending the token so that we will\
    \ send\n         * error tokens. */\n        if (GSS_ERROR(major)) {\n       \
    \     warnx(\"gss_init_sec_context() error major 0x%x\\n\", major);\n        \
    \    goto cleanup;\n        }\n        /* Free the output token's storage; we\
    \ don't need it anymore.\n         * gss_release_buffer() is safe to call on the\
    \ output buffer\n         * from gss_int_sec_context(), even if there is no storage\n\
    \         * associated with that buffer. */\n        (void)gss_release_buffer(&minor,\
    \ &output_token);\n        if (major & GSS_S_CONTINUE_NEEDED) {\n            ret\
    \ = receive_token(readfd, &input_token);\n            if (ret != 0)\n        \
    \        goto cleanup;\n        } else if (major == GSS_S_COMPLETE) {\n      \
    \      initiator_established = 1;\n        } else {\n            /* This situation\
    \ is forbidden by RFC 2743.  Bail out. */\n            warnx(\"major not complete\
    \ or continue but not error\\n\");\n            goto cleanup;\n        }\n   \
    \ }   /* while (!initiator_established) */\n    if ((ret_flags & req_flags) !=\
    \ req_flags) {\n        warnx(\"Negotiated context does not support requested\
    \ flags\\n\");\n        goto cleanup;\n    }\n    printf(\"Initiator's context\
    \ negotiation successful\\n\");\n"
- title: 'cleanup:'
  contents:
  - "cleanup:\n    /* We are required to release storage for nonzero-length output\n\
    \     * tokens.  gss_release_buffer() zeros the length, so we\n     * will not\
    \ attempt to release the same buffer twice. */\n    if (output_token.length >\
    \ 0)\n        (void)gss_release_buffer(&minor, &output_token);\n    /* Do not\
    \ request a context deletion token; pass NULL. */\n    (void)gss_delete_sec_context(&minor,\
    \ &ctx, NULL);\n    (void)gss_release_name(&minor, &target_name);\n"
- title: '}'
  contents:
  - '}

    '
- title: /*
  contents:
  - "/*\n * Perform authorization checks on the initiator's GSS name object.\n *\n\
    \ * Returns 0 on success (the initiator is authorized) and nonzero\n * when the\
    \ initiator is not authorized.\n */\n"
- title: static int
  contents:
  - 'static int

    '
- title: check_authz(gss_name_t client_name)
  contents:
  - 'check_authz(gss_name_t client_name)

    '
- title: '{'
  contents:
  - "{\n    /*\n     * Supply authorization checking code here.\n     *\n     * Options\
    \ include bitwise comparison of the exported name against\n     * a local database\
    \ and introspection against name attributes.\n     */\n    return 0;\n"
- title: '}'
  contents:
  - '}

    '
- title: static void
  contents:
  - 'static void

    '
- title: do_acceptor(int readfd, int writefd)
  contents:
  - 'do_acceptor(int readfd, int writefd)

    '
- title: '{'
  contents:
  - "{\n    int acceptor_established = 0, ret;\n    gss_ctx_id_t ctx = GSS_C_NO_CONTEXT;\n\
    \    OM_uint32 major, minor, ret_flags;\n    gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;\n\
    \    gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;\n    gss_name_t client_name;\n\
    \    major = GSS_S_CONTINUE_NEEDED;\n    while (!acceptor_established) {\n   \
    \     if (major & GSS_S_CONTINUE_NEEDED) {\n            ret = receive_token(readfd,\
    \ &input_token);\n            if (ret != 0)\n                goto cleanup;\n \
    \       } else if (major == GSS_S_COMPLETE) {\n            acceptor_established\
    \ = 1;\n            break;\n        } else {\n            /* This situation is\
    \ forbidden by RFC 2743.  Bail out. */\n            warnx(\"major not complete\
    \ or continue but not error\\n\");\n            goto cleanup;\n        }\n   \
    \     /* We can use the default behavior or do not need the returned\n       \
    \  * information for the parameters acceptor_cred_handle,\n         * input_chan_bindings,\
    \ mech_type, time_rec, and\n         * delegated_cred_handle, and pass the values\n\
    \         * GSS_C_NO_CREDENTIAL, NULL, NULL, NULL, and NULL,\n         * respectively.\
    \  In some cases the src_name will not be\n         * needed, but most likely\
    \ it will be needed for some\n         * authorization or logging functionality.\
    \ */\n        major = gss_accept_sec_context(&minor, &ctx,\n                 \
    \                      GSS_C_NO_CREDENTIAL,\n                                \
    \       &input_token, NULL,\n                                       &client_name,\
    \ NULL,\n                                       &output_token, &ret_flags, NULL,\n\
    \                                       NULL);\n        /* This was allocated\
    \ by receive_token() and is no longer\n         * needed.  Free it now to avoid\
    \ leaks if the loop continues. */\n        release_buffer(&input_token);\n   \
    \     /* Always send a token if we are expecting another input token\n       \
    \  * (GSS_S_CONTINUE_NEEDED is set) or if it is nonempty. */\n        if ((major\
    \ & GSS_S_CONTINUE_NEEDED) ||\n            output_token.length > 0) {\n      \
    \      ret = send_token(writefd, &output_token);\n            if (ret != 0)\n\
    \                goto cleanup;\n        }\n        /* Check for errors after sending\
    \ the token so that we will send\n         * error tokens. */\n        if (GSS_ERROR(major))\
    \ {\n            warnx(\"gss_accept_sec_context() error major 0x%x\\n\", major);\n\
    \            goto cleanup;\n        }\n        /* Free the output token's storage;\
    \ we don't need it anymore.\n         * gss_release_buffer() is safe to call on\
    \ the output buffer\n         * from gss_accept_sec_context(), even if there is\
    \ no storage\n         * associated with that buffer. */\n        (void)gss_release_buffer(&minor,\
    \ &output_token);\n    }   /* while (!acceptor_established) */\n    if (!(ret_flags\
    \ & GSS_C_INTEG_FLAG)) {\n        warnx(\"Negotiated context does not support\
    \ integrity\\n\");\n        goto cleanup;\n    }\n    printf(\"Acceptor's context\
    \ negotiation successful\\n\");\n    ret = check_authz(client_name);\n    if (ret\
    \ != 0)\n        printf(\"Client is not authorized; rejecting access\\n\");\n"
- title: 'cleanup:'
  contents:
  - "cleanup:\n    release_buffer(&input_token);\n    /* We are required to release\
    \ storage for nonzero-length output\n     * tokens.  gss_release_buffer() zeros\
    \ the length, so we\n     * will not attempt to release the same buffer twice.\
    \ */\n    if (output_token.length > 0)\n        (void)gss_release_buffer(&minor,\
    \ &output_token);\n    /* Do not request a context deletion token, pass NULL.\
    \ */\n    (void)gss_delete_sec_context(&minor, &ctx, NULL);\n    (void)gss_release_name(&minor,\
    \ &client_name);\n"
- title: '}'
  contents:
  - '}

    '
- title: int
  contents:
  - 'int

    '
- title: main(void)
  contents:
  - 'main(void)

    '
- title: '{'
  contents:
  - "{\n    pid_t pid;\n    int fd1 = -1, fd2 = -1;\n    /* Create file descriptors\
    \ for reading/writing here. */\n    pid = fork();\n    if (pid == 0)\n       \
    \ do_initiator(fd1, fd2, 0);\n    else if (pid > 0)\n        do_acceptor(fd2,\
    \ fd1);\n    else\n        err(1, \"fork() failed\\n\");\n    exit(0);\n"
- title: '}'
  contents:
  - '}

    '
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   This document provides a (reasonably) concise\
    \ description and example\n   for correct construction of the GSS-API security\
    \ context negotiation\n   loop.  Since everything relating to the construction\
    \ and use of a GSS\n   security context is security related, there are security-relevant\n\
    \   considerations throughout the document.  It is useful to call out a\n   few\
    \ things in this section, though.\n   The GSS-API uses a request-and-check model\
    \ for features.  An\n   application using the GSS-API requests certain features\
    \ (e.g.,\n   confidentiality protection for messages or anonymity), but such a\n\
    \   request does not require the GSS implementation to provide that\n   feature.\
    \  The application must check the returned flags to verify\n   whether a requested\
    \ feature is present; if the feature was non-\n   optional for the application,\
    \ the application must generate an error.\n   Phrased differently, the GSS-API\
    \ will not generate an error if it is\n   unable to satisfy the features requested\
    \ by the application.\n   In many cases, it is convenient for GSS acceptors to\
    \ accept security\n   contexts using multiple acceptor names (such as by using\
    \ the default\n   credential set, as happens when GSS_C_NO_CREDENTIAL is passed\
    \ to\n   GSS_Accept_sec_context()).  This allows acceptors to use any\n   credentials\
    \ to which they have access for accepting security\n   contexts, which may not\
    \ be the desired behavior for a given\n   application.  (For example, the Secure\
    \ Shell daemon (sshd) may wish\n   to accept only using GSS_C_NT_HOSTBASED credentials\
    \ of the form\n   host@<hostname>, and not nfs@<hostname>.)  Acceptor applications\
    \ can\n   check which target name was used by the initiator, but the details\n\
    \   are out of scope for this document.  See Sections 2.2.6 and 1.1.5 of\n   [RFC2743]\n\
    \   The C sample code uses the macro GSS_ERROR() to assess the return\n   value\
    \ of gss_init_sec_context() and gss_accept_sec_context().  This\n   is done to\
    \ indicate where checks are needed in writing code for other\n   languages and\
    \ what the nature of those checks might be.  The C code\n   could be made simpler\
    \ by omitting that macro.  In applications\n   expecting to receive protected\
    \ octet streams, this macro should not\n   be used on the result of per-message\
    \ operations, as it omits checking\n   for supplementary status values such as\
    \ GSS_S_DUPLICATE_TOKEN,\n   GSS_S_OLD_TOKEN, etc.  Use of the GSS_ERROR() macro\
    \ on the results of\n   GSS-API per-message operations has resulted in security\n\
    \   vulnerabilities in existing software.\n   The security considerations from\
    \ RFCs 2743 and 2744 remain applicable\n   to consumers of this document.\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [RFC2743]  Linn, J., \"Generic Security Service\
    \ Application Program\n              Interface Version 2, Update 1\", RFC 2743,\n\
    \              DOI 10.17487/RFC2743, January 2000,\n              <http://www.rfc-editor.org/info/rfc2743>.\n\
    \   [RFC2744]  Wray, J., \"Generic Security Service API Version 2 :\n        \
    \      C-bindings\", RFC 2744, DOI 10.17487/RFC2744, January 2000,\n         \
    \     <http://www.rfc-editor.org/info/rfc2744>.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [Err4151]  RFC Errata, Erratum ID 4151, RFC\
    \ 2743.\n   [NTLMSSP]  Microsoft Corporation, \"[MS-NLMP]: NT LAN Manager (NTLM)\n\
    \              Authentication Protocol\", May 2014,\n              <https://msdn.microsoft.com/en-us/library/cc236621.aspx>.\n\
    \   [RFC2203]  Eisler, M., Chiu, A., and L. Ling, \"RPCSEC_GSS Protocol\n    \
    \          Specification\", RFC 2203, DOI 10.17487/RFC2203, September\n      \
    \        1997, <http://www.rfc-editor.org/info/rfc2203>.\n   [RFC3645]  Kwan,\
    \ S., Garg, P., Gilroy, J., Esibov, L., Westhead, J.,\n              and R. Hall,\
    \ \"Generic Security Service Algorithm for\n              Secret Key Transaction\
    \ Authentication for DNS (GSS-TSIG)\",\n              RFC 3645, DOI 10.17487/RFC3645,\
    \ October 2003,\n              <http://www.rfc-editor.org/info/rfc3645>.\n   [RFC4401]\
    \  Williams, N., \"A Pseudo-Random Function (PRF) API\n              Extension\
    \ for the Generic Security Service Application\n              Program Interface\
    \ (GSS-API)\", RFC 4401,\n              DOI 10.17487/RFC4401, February 2006,\n\
    \              <http://www.rfc-editor.org/info/rfc4401>.\n   [RFC4462]  Hutzelman,\
    \ J., Salowey, J., Galbraith, J., and V. Welch,\n              \"Generic Security\
    \ Service Application Program Interface\n              (GSS-API) Authentication\
    \ and Key Exchange for the Secure\n              Shell (SSH) Protocol\", RFC 4462,\
    \ DOI 10.17487/RFC4462, May\n              2006, <http://www.rfc-editor.org/info/rfc4462>.\n\
    \   [RFC4752]  Melnikov, A., Ed., \"The Kerberos V5 (\"GSSAPI\") Simple\n    \
    \          Authentication and Security Layer (SASL) Mechanism\",\n           \
    \   RFC 4752, DOI 10.17487/RFC4752, November 2006,\n              <http://www.rfc-editor.org/info/rfc4752>.\n\
    \   [RFC5801]  Josefsson, S. and N. Williams, \"Using Generic Security\n     \
    \         Service Application Program Interface (GSS-API) Mechanisms\n       \
    \       in Simple Authentication and Security Layer (SASL): The\n            \
    \  GS2 Mechanism Family\", RFC 5801, DOI 10.17487/RFC5801,\n              July\
    \ 2010, <http://www.rfc-editor.org/info/rfc5801>.\n   [RFC6680]  Williams, N.,\
    \ Johansson, L., Hartman, S., and S.\n              Josefsson, \"Generic Security\
    \ Service Application\n              Programming Interface (GSS-API) Naming Extensions\"\
    ,\n              RFC 6680, DOI 10.17487/RFC6680, August 2012,\n              <http://www.rfc-editor.org/info/rfc6680>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Thanks to Nico Williams and Jeff Hutzleman for prompting\
    \ me to write\n   this document.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Benjamin Kaduk\n   MIT Kerberos Consortium\n   EMail: kaduk@mit.edu\n"
