- title: __initial_text__
  contents:
  - '              Datagram Congestion Control Protocol (DCCP)

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   The Datagram Congestion Control Protocol (DCCP) is a transport\n\
    \   protocol that provides bidirectional unicast connections of\n   congestion-controlled\
    \ unreliable datagrams.  DCCP is suitable for\n   applications that transfer fairly\
    \ large amounts of data and that can\n   benefit from control over the tradeoff\
    \ between timeliness and\n   reliability.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n      4.5. Feature Negotiation Options ...............................15\n\
    \      4.6. Differences from TCP ......................................16\n  \
    \    4.7. Example Connection ........................................17\n   5.\
    \ Packet Formats .................................................18\n      5.1.\
    \ Generic Header ............................................19\n      5.2. DCCP-Request\
    \ Packets ......................................22\n      5.3. DCCP-Response Packets\
    \ .....................................23\n      5.4. DCCP-Data, DCCP-Ack, and\
    \ DCCP-DataAck Packets .............23\n      5.5. DCCP-CloseReq and DCCP-Close\
    \ Packets ......................25\n      5.6. DCCP-Reset Packets ........................................25\n\
    \      5.7. DCCP-Sync and DCCP-SyncAck Packets ........................28\n  \
    \    5.8. Options ...................................................29\n    \
    \       5.8.1. Padding Option .....................................31\n      \
    \     5.8.2. Mandatory Option ...................................31\n   6. Feature\
    \ Negotiation ............................................32\n      6.1. Change\
    \ Options ............................................32\n      6.2. Confirm Options\
    \ ...........................................33\n      6.3. Reconciliation Rules\
    \ ......................................33\n           6.3.1. Server-Priority\
    \ ....................................34\n           6.3.2. Non-Negotiable .....................................34\n\
    \      6.4. Feature Numbers ...........................................35\n  \
    \    6.5. Feature Negotiation Examples ..............................36\n    \
    \  6.6. Option Exchange ...........................................37\n      \
    \     6.6.1. Normal Exchange ....................................38\n        \
    \   6.6.2. Processing Received Options ........................38\n          \
    \ 6.6.3. Loss and Retransmission ............................40\n           6.6.4.\
    \ Reordering .........................................41\n           6.6.5. Preference\
    \ Changes .................................42\n           6.6.6. Simultaneous\
    \ Negotiation ...........................42\n           6.6.7. Unknown Features\
    \ ...................................43\n           6.6.8. Invalid Options ....................................43\n\
    \           6.6.9. Mandatory Feature Negotiation ......................44\n  \
    \ 7. Sequence Numbers ...............................................44\n    \
    \  7.1. Variables .................................................45\n      7.2.\
    \ Initial Sequence Numbers ..................................45\n      7.3. Quiet\
    \ Time ................................................46\n      7.4. Acknowledgement\
    \ Numbers ...................................47\n      7.5. Validity and Synchronization\
    \ ..............................47\n           7.5.1. Sequence and Acknowledgement\
    \ Number Windows ........48\n           7.5.2. Sequence Window Feature ............................49\n\
    \           7.5.3. Sequence-Validity Rules ............................49\n  \
    \         7.5.4. Handling Sequence-Invalid Packets ..................51\n    \
    \       7.5.5. Sequence Number Attacks ............................52\n      \
    \     7.5.6. Sequence Number Handling Examples ..................54\n      7.6.\
    \ Short Sequence Numbers ....................................55\n           7.6.1.\
    \ Allow Short Sequence Numbers Feature ...............55\n           7.6.2. When\
    \ to Avoid Short Sequence Numbers ...............56\n      7.7. NDP Count and\
    \ Detecting Application Loss ..................56\n           7.7.1. NDP Count\
    \ Usage Notes ..............................57\n           7.7.2. Send NDP Count\
    \ Feature .............................57\n   8. Event Processing ...............................................58\n\
    \      8.1. Connection Establishment ..................................58\n  \
    \         8.1.1. Client Request .....................................58\n    \
    \       8.1.2. Service Codes ......................................59\n      \
    \     8.1.3. Server Response ....................................61\n        \
    \   8.1.4. Init Cookie Option .................................62\n          \
    \ 8.1.5. Handshake Completion ...............................63\n      8.2. Data\
    \ Transfer .............................................63\n      8.3. Termination\
    \ ...............................................64\n           8.3.1. Abnormal\
    \ Termination ...............................66\n      8.4. DCCP State Diagram\
    \ ........................................66\n      8.5. Pseudocode ................................................67\n\
    \   9. Checksums ......................................................72\n  \
    \    9.1. Header Checksum Field .....................................73\n    \
    \  9.2. Header Checksum Coverage Field ............................73\n      \
    \     9.2.1. Minimum Checksum Coverage Feature ..................74\n      9.3.\
    \ Data Checksum Option ......................................75\n           9.3.1.\
    \ Check Data Checksum Feature ........................76\n           9.3.2. Checksum\
    \ Usage Notes ...............................76\n   10. Congestion Control ............................................76\n\
    \      10.1. TCP-like Congestion Control ..............................77\n  \
    \    10.2. TFRC Congestion Control ..................................78\n    \
    \  10.3. CCID-Specific Options, Features, and Reset Codes .........78\n      10.4.\
    \ CCID Profile Requirements ................................80\n      10.5. Congestion\
    \ State .........................................81\n   11. Acknowledgements ..............................................81\n\
    \      11.1. Acks of Acks and Unidirectional Connections ..............82\n  \
    \    11.2. Ack Piggybacking .........................................83\n    \
    \  11.3. Ack Ratio Feature ........................................84\n      11.4.\
    \ Ack Vector Options .......................................85\n           11.4.1.\
    \ Ack Vector Consistency ............................88\n           11.4.2. Ack\
    \ Vector Coverage ...............................89\n      11.5. Send Ack Vector\
    \ Feature ..................................90\n      11.6. Slow Receiver Option\
    \ .....................................90\n      11.7. Data Dropped Option ......................................91\n\
    \           11.7.1. Data Dropped and Normal Congestion Response .......94\n  \
    \         11.7.2. Particular Drop Codes .............................95\n   12.\
    \ Explicit Congestion Notification ..............................96\n      12.1.\
    \ ECN Incapable Feature ....................................96\n      12.2. ECN\
    \ Nonces ...............................................97\n      12.3. Aggression\
    \ Penalties .....................................98\n   13. Timing Options ................................................99\n\
    \      13.1. Timestamp Option .........................................99\n  \
    \    13.2. Elapsed Time Option ......................................99\n    \
    \  13.3. Timestamp Echo Option ...................................100\n   14.\
    \ Maximum Packet Size ..........................................101\n      14.1.\
    \ Measuring PMTU ..........................................102\n      14.2. Sender\
    \ Behavior .........................................103\n   15. Forward Compatibility\
    \ ........................................104\n   16. Middlebox Considerations\
    \ .....................................105\n   17. Relations to Other Specifications\
    \ ............................106\n      17.1. RTP .....................................................106\n\
    \      17.2. Congestion Manager and Multiplexing .....................108\n  \
    \ 18. Security Considerations ......................................108\n    \
    \  18.1. Security Considerations for Partial Checksums ...........109\n   19.\
    \ IANA Considerations ..........................................110\n      19.1.\
    \ Packet Types Registry ...................................110\n      19.2. Reset\
    \ Codes Registry ....................................110\n      19.3. Option Types\
    \ Registry ...................................110\n      19.4. Feature Numbers\
    \ Registry ................................111\n      19.5. Congestion Control\
    \ Identifiers Registry .................111\n      19.6. Ack Vector States Registry\
    \ ..............................111\n      19.7. Drop Codes Registry .....................................112\n\
    \      19.8. Service Codes Registry ..................................112\n  \
    \    19.9. Port Numbers Registry ...................................112\n   20.\
    \ Thanks .......................................................114\n   A.  Appendix:\
    \ Ack Vector Implementation Notes ....................116\n       A.1. Packet\
    \ Arrival ..........................................118\n            A.1.1. New\
    \ Packets ......................................118\n            A.1.2. Old Packets\
    \ ......................................119\n       A.2. Sending Acknowledgements\
    \ ................................120\n       A.3. Clearing State ..........................................120\n\
    \       A.4. Processing Acknowledgements .............................122\n  \
    \ B.  Appendix: Partial Checksumming Design Motivation .............123\n   Normative\
    \ References .............................................124\n   Informative\
    \ References ...........................................125\n"
- title: List of Tables
  contents:
  - "List of Tables\n   Table 1: DCCP Packet Types .......................................21\n\
    \   Table 2: DCCP Reset Codes ........................................28\n   Table\
    \ 3: DCCP Options ............................................30\n   Table 4:\
    \ DCCP Feature Numbers.....................................35\n   Table 5: DCCP\
    \ Congestion Control Identifiers .....................77\n   Table 6: DCCP Ack\
    \ Vector States ..................................86\n   Table 7: DCCP Drop Codes\
    \ .........................................92\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Datagram Congestion Control Protocol (DCCP) is a transport\n\
    \   protocol that implements bidirectional, unicast connections of\n   congestion-controlled,\
    \ unreliable datagrams.  Specifically, DCCP\n   provides the following:\n   o\
    \  Unreliable flows of datagrams.\n   o  Reliable handshakes for connection setup\
    \ and teardown.\n   o  Reliable negotiation of options, including negotiation\
    \ of a\n      suitable congestion control mechanism.\n   o  Mechanisms allowing\
    \ servers to avoid holding state for\n      unacknowledged connection attempts\
    \ and already-finished\n      connections.\n   o  Congestion control incorporating\
    \ Explicit Congestion Notification\n      (ECN) [RFC3168] and the ECN Nonce [RFC3540].\n\
    \   o  Acknowledgement mechanisms communicating packet loss and ECN\n      information.\
    \  Acks are transmitted as reliably as the relevant\n      congestion control\
    \ mechanism requires, possibly completely\n      reliably.\n   o  Optional mechanisms\
    \ that tell the sending application, with high\n      reliability, which data\
    \ packets reached the receiver, and whether\n      those packets were ECN marked,\
    \ corrupted, or dropped in the\n      receive buffer.\n   o  Path Maximum Transmission\
    \ Unit (PMTU) discovery [RFC1191].\n   o  A choice of modular congestion control\
    \ mechanisms.  Two mechanisms\n      are currently specified: TCP-like Congestion\
    \ Control [RFC4341] and\n      TCP-Friendly Rate Control (TFRC) [RFC4342].  DCCP\
    \ is easily\n      extensible to further forms of unicast congestion control.\n\
    \   DCCP is intended for applications such as streaming media that can\n   benefit\
    \ from control over the tradeoffs between delay and reliable\n   in-order delivery.\
    \  TCP is not well suited for these applications,\n   since reliable in-order\
    \ delivery and congestion control can cause\n   arbitrarily long delays.  UDP\
    \ avoids long delays, but UDP\n   applications that implement congestion control\
    \ must do so on their\n   own.  DCCP provides built-in congestion control, including\
    \ ECN\n   support, for unreliable datagram flows, avoiding the arbitrary delays\n\
    \   associated with TCP.  It also implements reliable connection setup,\n   teardown,\
    \ and feature negotiation.\n"
- title: 2.  Design Rationale
  contents:
  - "2.  Design Rationale\n   One DCCP design goal was to give most streaming UDP\
    \ applications\n   little reason not to switch to DCCP, once it is deployed. \
    \ To\n   facilitate this, DCCP was designed to have as little overhead as\n  \
    \ possible, both in terms of the packet header size and in terms of the\n   state\
    \ and CPU overhead required at end hosts.  Only the minimal\n   necessary functionality\
    \ was included in DCCP, leaving other\n   functionality, such as forward error\
    \ correction (FEC), semi-\n   reliability, and multiple streams, to be layered\
    \ on top of DCCP as\n   desired.\n   Different forms of conformant congestion\
    \ control are appropriate for\n   different applications.  For example, on-line\
    \ games might want to\n   make quick use of any available bandwidth, while streaming\
    \ media\n   might trade off this responsiveness for a steadier, less bursty rate.\n\
    \   (Sudden rate changes can cause unacceptable UI glitches such as\n   audible\
    \ pauses or clicks in the playout stream.)  DCCP thus allows\n   applications\
    \ to choose from a set of congestion control mechanisms.\n   One alternative,\
    \ TCP-like Congestion Control, halves the congestion\n   window in response to\
    \ a packet drop or mark, as in TCP.  Applications\n   using this congestion control\
    \ mechanism will respond quickly to\n   changes in available bandwidth, but must\
    \ tolerate the abrupt changes\n   in congestion window typical of TCP.  A second\
    \ alternative, TCP-\n   Friendly Rate Control (TFRC) [RFC3448], a form of equation-based\n\
    \   congestion control, minimizes abrupt changes in the sending rate\n   while\
    \ maintaining longer-term fairness with TCP.  Other alternatives\n   can be added\
    \ as future congestion control mechanisms are\n   standardized.\n   DCCP also\
    \ lets unreliable traffic safely use ECN.  A UDP kernel\n   Application Programming\
    \ Interface (API) might not allow applications\n   to set UDP packets as ECN capable,\
    \ since the API could not guarantee\n   that the application would properly detect\
    \ or respond to congestion.\n   DCCP kernel APIs will have no such issues, since\
    \ DCCP implements\n   congestion control itself.\n   We chose not to require the\
    \ use of the Congestion Manager [RFC3124],\n   which allows multiple concurrent\
    \ streams between the same sender and\n   receiver to share congestion control.\
    \  The current Congestion Manager\n   can only be used by applications that have\
    \ their own end-to-end\n   feedback about packet losses, but this is not the case\
    \ for many of\n   the applications currently using UDP.  In addition, the current\n\
    \   Congestion Manager does not easily support multiple congestion\n   control\
    \ mechanisms or mechanisms where the state about past packet\n   drops or marks\
    \ is maintained at the receiver rather than the sender.\n   DCCP should be able\
    \ to make use of CM where desired by the\n   application, but we do not see any\
    \ benefit in making the deployment\n   of DCCP contingent on the deployment of\
    \ CM itself.\n   We intend for DCCP's protocol mechanisms, which are described\
    \ in this\n   document, to suit any application desiring unicast congestion-\n\
    \   controlled streams of unreliable datagrams.  However, the congestion\n   control\
    \ mechanisms currently approved for use with DCCP, which are\n   described in\
    \ separate Congestion Control ID Profiles [RFC4341,\n   RFC4342], may cause problems\
    \ for some applications, including high-\n   bandwidth interactive video.  These\
    \ applications should be able to\n   use DCCP once suitable Congestion Control\
    \ ID Profiles are\n   standardized.\n"
- title: 3.  Conventions and Terminology
  contents:
  - "3.  Conventions and Terminology\n   The key words \"MUST\", \"MUST NOT\", \"\
    REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 3.1.  Numbers and Fields
  contents:
  - "3.1.  Numbers and Fields\n   All multi-byte numerical quantities in DCCP, such\
    \ as port numbers,\n   Sequence Numbers, and arguments to options, are transmitted\
    \ in\n   network byte order (most significant byte first).\n   We occasionally\
    \ refer to the \"left\" and \"right\" sides of a bit field.\n   \"Left\" means\
    \ towards the most significant bit, and \"right\" means\n   towards the least\
    \ significant bit.\n   Random numbers in DCCP are used for their security properties\
    \ and\n   SHOULD be chosen according to the guidelines in [RFC4086].\n   All operations\
    \ on DCCP sequence numbers use circular arithmetic\n   modulo 2^48, as do comparisons\
    \ such as \"greater\" and \"greatest\".\n   This form of arithmetic preserves\
    \ the relationships between sequence\n   numbers as they roll over from 2^48 -\
    \ 1 to 0.  Implementation\n   strategies for DCCP sequence numbers will resemble\
    \ those for other\n   circular arithmetic spaces, including TCP's sequence numbers\
    \ [RFC793]\n   and DNS's serial numbers [RFC1982].  It may make sense to store\
    \ DCCP\n   sequence numbers in the most significant 48 bits of 64-bit integers\n\
    \   and set the least significant 16 bits to zero, since this supports a\n   common\
    \ technique that implements circular comparison A < B by testing\n   whether (A\
    \ - B) < 0 using conventional two's-complement arithmetic.\n   Reserved bitfields\
    \ in DCCP packet headers MUST be set to zero by\n   senders and MUST be ignored\
    \ by receivers, unless otherwise specified.\n   This allows for future protocol\
    \ extensions.  In particular, DCCP\n   processors MUST NOT reset a DCCP connection\
    \ simply because a Reserved\n   field has non-zero value [RFC3360].\n"
- title: 3.2.  Parts of a Connection
  contents:
  - "3.2.  Parts of a Connection\n   Each DCCP connection runs between two hosts,\
    \ which we often name DCCP\n   A and DCCP B.  Each connection is actively initiated\
    \ by one of the\n   hosts, which we call the client; the other, initially passive\
    \ host is\n   called the server.  The term \"DCCP endpoint\" is used to refer\
    \ to\n   either of the two hosts explicitly named by the connection (the\n   client\
    \ and the server).  The term \"DCCP processor\" refers more\n   generally to any\
    \ host that might need to process a DCCP header; this\n   includes the endpoints\
    \ and any middleboxes on the path, such as\n   firewalls and network address translators.\n\
    \   DCCP connections are bidirectional: data may pass from either\n   endpoint\
    \ to the other.  This means that data and acknowledgements may\n   flow in both\
    \ directions simultaneously.  Logically, however, a DCCP\n   connection consists\
    \ of two separate unidirectional connections,\n   called half-connections.  Each\
    \ half-connection consists of the\n   application data sent by one endpoint and\
    \ the corresponding\n   acknowledgements sent by the other endpoint.  We can illustrate\
    \ this\n   as follows:\n      +--------+  A-to-B half-connection:         +--------+\n\
    \      |        |    -->  application data  -->    |        |\n      |       \
    \ |    <--  acknowledgements  <--    |        |\n      | DCCP A |            \
    \                      | DCCP B |\n      |        |  B-to-A half-connection: \
    \        |        |\n      |        |    <--  application data  <--    |     \
    \   |\n      +--------+    -->  acknowledgements  -->    +--------+\n   Although\
    \ they are logically distinct, in practice the half-\n   connections overlap;\
    \ a DCCP-DataAck packet, for example, contains\n   application data relevant to\
    \ one half-connection and acknowledgement\n   information relevant to the other.\n\
    \   In the context of a single half-connection, the terms \"HC-Sender\" and\n\
    \   \"HC-Receiver\" denote the endpoints sending application data and\n   acknowledgements,\
    \ respectively.  For example, DCCP A is the\n   HC-Sender and DCCP B is the HC-Receiver\
    \ in the A-to-B\n   half-connection.\n"
- title: 3.3.  Features
  contents:
  - "3.3.  Features\n   A DCCP feature is a connection attribute on whose value the\
    \ two\n   endpoints agree.  Many properties of a DCCP connection are controlled\n\
    \   by features, including the congestion control mechanisms in use on\n   the\
    \ two half-connections.  The endpoints achieve agreement through\n   the exchange\
    \ of feature negotiation options in DCCP headers.\n   DCCP features are identified\
    \ by a feature number and an endpoint.\n   The notation \"F/X\" represents the\
    \ feature with feature number F\n   located at DCCP endpoint X.  Each valid feature\
    \ number thus\n   corresponds to two features, which are negotiated separately\
    \ and need\n   not have the same value.  The two endpoints know, and agree on,\
    \ the\n   value of every valid feature.  DCCP A is the \"feature location\" for\n\
    \   all features F/A, and the \"feature remote\" for all features F/B.\n"
- title: 3.4.  Round-Trip Times
  contents:
  - "3.4.  Round-Trip Times\n   DCCP round-trip time measurements are performed by\
    \ congestion control\n   mechanisms; different mechanisms may measure round-trip\
    \ time in\n   different ways, or not measure it at all.  However, the main DCCP\n\
    \   protocol does use round-trip times occasionally, such as in the\n   initial\
    \ values for certain timers.  Each DCCP implementation thus\n   defines a default\
    \ round-trip time for use when no estimate is\n   available.  This parameter should\
    \ default to not less than 0.2\n   seconds, a reasonably conservative round-trip\
    \ time for Internet TCP\n   connections.  Protocol behavior specified in terms\
    \ of \"round-trip\n   time\" values actually refers to \"a current round-trip\
    \ time estimate\n   taken by some CCID, or, if no estimate is available, the default\n\
    \   round-trip time parameter\".\n   The maximum segment lifetime, or MSL, is\
    \ the maximum length of time a\n   packet can survive in the network.  The DCCP\
    \ MSL should equal that of\n   TCP, which is normally two minutes.\n"
- title: 3.5.  Security Limitation
  contents:
  - "3.5.  Security Limitation\n   DCCP provides no protection against attackers who\
    \ can snoop on a\n   connection in progress, or who can guess valid sequence numbers\
    \ in\n   other ways.  Applications desiring stronger security should use IPsec\n\
    \   [RFC2401]; depending on the level of security required, application-\n   level\
    \ cryptography may also suffice.  These issues are discussed\n   further in Sections\
    \ 7.5.5 and 18.\n"
- title: 3.6.  Robustness Principle
  contents:
  - "3.6.  Robustness Principle\n   DCCP implementations will follow TCP's \"general\
    \ principle of\n   robustness\": \"be conservative in what you do, be liberal\
    \ in what you\n   accept from others\" [RFC793].\n"
- title: 4.  Overview
  contents:
  - "4.  Overview\n   DCCP's high-level connection dynamics echo those of TCP.  Connections\n\
    \   progress through three phases: initiation, including a three-way\n   handshake;\
    \ data transfer; and termination.  Data can flow both ways\n   over the connection.\
    \  An acknowledgement framework lets senders\n   discover how much data has been\
    \ lost and thus avoid unfairly\n   congesting the network.  Of course, DCCP provides\
    \ unreliable datagram\n   semantics, not TCP's reliable bytestream semantics.\
    \  The application\n   must package its data into explicit frames and must retransmit\
    \ its\n   own data as necessary.  It may be useful to think of DCCP as TCP\n \
    \  minus bytestream semantics and reliability, or as UDP plus congestion\n   control,\
    \ handshakes, and acknowledgements.\n"
- title: 4.1.  Packet Types
  contents:
  - "4.1.  Packet Types\n   Ten packet types implement DCCP's protocol functions.\
    \  For example,\n   every new connection attempt begins with a DCCP-Request packet\
    \ sent\n   by the client.  In this way a DCCP-Request packet resembles a TCP\n\
    \   SYN, but since DCCP-Request is a packet type there is no way to send\n   an\
    \ unexpected flag combination, such as TCP's SYN+FIN+ACK+RST.\n   Eight packet\
    \ types occur during the progress of a typical connection,\n   shown here.  Note\
    \ the three-way handshakes during initiation and\n   termination.\n      Client\
    \                                      Server\n      ------                  \
    \                    ------\n                       (1) Initiation\n      DCCP-Request\
    \ -->\n                                       <-- DCCP-Response\n      DCCP-Ack\
    \ -->\n                       (2) Data transfer\n      DCCP-Data, DCCP-Ack, DCCP-DataAck\
    \ -->\n                   <-- DCCP-Data, DCCP-Ack, DCCP-DataAck\n            \
    \           (3) Termination\n                                       <-- DCCP-CloseReq\n\
    \      DCCP-Close -->\n                                          <-- DCCP-Reset\n\
    \   The two remaining packet types are used to resynchronize after bursts\n  \
    \ of loss.\n   Every DCCP packet starts with a fixed-size generic header.\n  \
    \ Particular packet types include additional fixed-size header data;\n   for example,\
    \ DCCP-Acks include an Acknowledgement Number.  DCCP\n   options and any application\
    \ data follow the fixed-size header.\n   The packet types are as follows:\n  \
    \ DCCP-Request\n      Sent by the client to initiate a connection (the first part\
    \ of the\n      three-way initiation handshake).\n   DCCP-Response\n      Sent\
    \ by the server in response to a DCCP-Request (the second part\n      of the three-way\
    \ initiation handshake).\n   DCCP-Data\n      Used to transmit application data.\n\
    \   DCCP-Ack\n      Used to transmit pure acknowledgements.\n   DCCP-DataAck\n\
    \      Used to transmit application data with piggybacked acknowledgement\n  \
    \    information.\n   DCCP-CloseReq\n      Sent by the server to request that\
    \ the client close the\n      connection.\n   DCCP-Close\n      Used by the client\
    \ or the server to close the connection; elicits\n      a DCCP-Reset in response.\n\
    \   DCCP-Reset\n      Used to terminate the connection, either normally or abnormally.\n\
    \   DCCP-Sync, DCCP-SyncAck\n      Used to resynchronize sequence numbers after\
    \ large bursts of loss.\n"
- title: 4.2.  Packet Sequencing
  contents:
  - "4.2.  Packet Sequencing\n   Each DCCP packet carries a sequence number so that\
    \ losses can be\n   detected and reported.  Unlike TCP sequence numbers, which\
    \ are byte-\n   based, DCCP sequence numbers increment by one per packet.  For\n\
    \   example:\n      DCCP A                                      DCCP B\n     \
    \ ------                                      ------\n      DCCP-Data(seqno 1)\
    \ -->\n      DCCP-Data(seqno 2) -->\n                         <-- DCCP-Ack(seqno\
    \ 10, ackno 2)\n      DCCP-DataAck(seqno 3, ackno 10) -->\n                  \
    \               <-- DCCP-Data(seqno 11)\n   Every DCCP packet increments the sequence\
    \ number, whether or not it\n   contains application data.  DCCP-Ack pure acknowledgements\
    \ increment\n   the sequence number; for instance, DCCP B's second packet above\
    \ uses\n   sequence number 11, since sequence number 10 was used for an\n   acknowledgement.\
    \  This lets endpoints detect all packet loss,\n   including acknowledgement loss.\
    \  It also means that endpoints can get\n   out of sync after long bursts of loss.\
    \  The DCCP-Sync and DCCP-\n   SyncAck packet types are used to recover (Section\
    \ 7.5).\n   Since DCCP provides unreliable semantics, there are no\n   retransmissions,\
    \ and having a TCP-style cumulative acknowledgement\n   field doesn't make sense.\
    \  DCCP's Acknowledgement Number field equals\n   the greatest sequence number\
    \ received, rather than the smallest\n   sequence number not received.  Separate\
    \ options indicate any\n   intermediate sequence numbers that weren't received.\n"
- title: 4.3.  States
  contents:
  - "4.3.  States\n   DCCP endpoints progress through different states during the\
    \ course of\n   a connection, corresponding roughly to the three phases of\n \
    \  initiation, data transfer, and termination.  The figure below shows\n   the\
    \ typical progress through these states for a client and server.\n      Client\
    \                                             Server\n      ------           \
    \                                  ------\n                        (0) No connection\n\
    \      CLOSED                                             LISTEN\n           \
    \             (1) Initiation\n      REQUEST      DCCP-Request -->\n          \
    \                         <-- DCCP-Response     RESPOND\n      PARTOPEN     DCCP-Ack\
    \ or DCCP-DataAck -->\n                        (2) Data transfer\n      OPEN \
    \         <-- DCCP-Data, Ack, DataAck -->      OPEN\n                        (3)\
    \ Termination\n                                   <-- DCCP-CloseReq     CLOSEREQ\n\
    \      CLOSING      DCCP-Close -->\n                                      <--\
    \ DCCP-Reset     CLOSED\n      TIMEWAIT\n      CLOSED\n   The nine possible states\
    \ are as follows.  They are listed in\n   increasing order, so that \"state >=\
    \ CLOSEREQ\" means the same as\n   \"state = CLOSEREQ or state = CLOSING or state\
    \ = TIMEWAIT\".  Section 8\n   describes the states in more detail.\n   CLOSED\n\
    \      Represents nonexistent connections.\n   LISTEN\n      Represents server\
    \ sockets in the passive listening state.  LISTEN\n      and CLOSED are not associated\
    \ with any particular DCCP connection.\n   REQUEST\n      A client socket enters\
    \ this state, from CLOSED, after sending a\n      DCCP-Request packet to try to\
    \ initiate a connection.\n   RESPOND\n      A server socket enters this state,\
    \ from LISTEN, after receiving a\n      DCCP-Request from a client.\n   PARTOPEN\n\
    \      A client socket enters this state, from REQUEST, after receiving a\n  \
    \    DCCP-Response from the server.  This state represents the third\n      phase\
    \ of the three-way handshake.  The client may send application\n      data in\
    \ this state, but it MUST include an Acknowledgement Number\n      on all of its\
    \ packets.\n   OPEN\n      The central data transfer portion of a DCCP connection.\
    \  Client\n      and server sockets enter this state from PARTOPEN and RESPOND,\n\
    \      respectively.  Sometimes we speak of SERVER-OPEN and CLIENT-OPEN\n    \
    \  states, corresponding to the server's OPEN state and the client's\n      OPEN\
    \ state.\n   CLOSEREQ\n      A server socket enters this state, from SERVER-OPEN,\
    \ to order the\n      client to close the connection and to hold TIMEWAIT state.\n\
    \   CLOSING\n      Server and client sockets can both enter this state to close\
    \ the\n      connection.\n   TIMEWAIT\n      A server or client socket remains\
    \ in this state for 2MSL (4\n      minutes) after the connection has been torn\
    \ down, to prevent\n      mistakes due to the delivery of old packets.  Only one\
    \ of the\n      endpoints has to enter TIMEWAIT state (the other can enter CLOSED\n\
    \      state immediately), and a server can request its client to hold\n     \
    \ TIMEWAIT state using the DCCP-CloseReq packet type.\n"
- title: 4.4.  Congestion Control Mechanisms
  contents:
  - "4.4.  Congestion Control Mechanisms\n   DCCP connections are congestion controlled,\
    \ but unlike in TCP, DCCP\n   applications have a choice of congestion control\
    \ mechanism.  In fact,\n   the two half-connections can be governed by different\
    \ mechanisms.\n   Mechanisms are denoted by one-byte congestion control identifiers,\
    \ or\n   CCIDs.  The endpoints negotiate their CCIDs during connection\n   initiation.\
    \  Each CCID describes how the HC-Sender limits data packet\n   rates, how the\
    \ HC-Receiver sends congestion feedback via\n   acknowledgements, and so forth.\
    \  CCIDs 2 and 3 are currently defined;\n   CCIDs 0, 1, and 4-255 are reserved.\
    \  Other CCIDs may be defined in\n   the future.\n   CCID 2 provides TCP-like\
    \ Congestion Control, which is similar to that\n   of TCP.  The sender maintains\
    \ a congestion window and sends packets\n   until that window is full.  Packets\
    \ are acknowledged by the receiver.\n   Dropped packets and ECN [RFC3168] indicate\
    \ congestion; the response\n   to congestion is to halve the congestion window.\
    \  Acknowledgements in\n   CCID 2 contain the sequence numbers of all received\
    \ packets within\n   some window, similar to a selective acknowledgement (SACK)\
    \ [RFC2018].\n   CCID 3 provides TCP-Friendly Rate Control (TFRC), an equation-based\n\
    \   form of congestion control intended to respond to congestion more\n   smoothly\
    \ than CCID 2.  The sender maintains a transmit rate, which it\n   updates using\
    \ the receiver's estimate of the packet loss and mark\n   rate.  CCID 3 behaves\
    \ somewhat differently than TCP in the short\n   term, but is designed to operate\
    \ fairly with TCP over the long term.\n   Section 10 describes DCCP's CCIDs in\
    \ more detail.  The behaviors of\n   CCIDs 2 and 3 are fully defined in separate\
    \ profile documents\n   [RFC4341, RFC4342].\n"
- title: 4.5.  Feature Negotiation Options
  contents:
  - "4.5.  Feature Negotiation Options\n   DCCP endpoints use Change and Confirm options\
    \ to negotiate and agree\n   on feature values.  Feature negotiation will almost\
    \ always happen on\n   the connection initiation handshake, but it can begin at\
    \ any time.\n   There are four feature negotiation options in all: Change L, Confirm\n\
    \   L, Change R, and Confirm R.  The \"L\" options are sent by the feature\n \
    \  location and the \"R\" options are sent by the feature remote.  A\n   Change\
    \ R option says to the feature location, \"change this feature\n   value as follows\"\
    .  The feature location responds with Confirm L,\n   meaning, \"I've changed it\"\
    .  Some features allow Change R options to\n   contain multiple values sorted\
    \ in preference order.  For example:\n      Client                           \
    \             Server\n      ------                                        ------\n\
    \      Change R(CCID, 2) -->\n                                    <-- Confirm\
    \ L(CCID, 2)\n                 * agreement that CCID/Server = 2 *\n      Change\
    \ R(CCID, 3 4) -->\n                               <-- Confirm L(CCID, 4, 4 2)\n\
    \                 * agreement that CCID/Server = 4 *\n   Both exchanges negotiate\
    \ the CCID/Server feature's value, which is\n   the CCID in use on the server-to-client\
    \ half-connection.  In the\n   second exchange, the client requests that the server\
    \ use either CCID\n   3 or CCID 4, with 3 preferred; the server chooses 4 and\
    \ supplies its\n   preference list, \"4 2\".\n   The Change L and Confirm R options\
    \ are used for feature negotiations\n   initiated by the feature location.  In\
    \ the following example, the\n   server requests that CCID/Server be set to 3\
    \ or 2, with 3 preferred,\n   and the client agrees.\n      Client           \
    \                            Server\n      ------                            \
    \           ------\n                                  <-- Change L(CCID, 3 2)\n\
    \      Confirm R(CCID, 3, 3 2)  -->\n                 * agreement that CCID/Server\
    \ = 3 *\n   Section 6 describes the feature negotiation options further,\n   including\
    \ the retransmission strategies that make negotiation\n   reliable.\n"
- title: 4.6.  Differences from TCP
  contents:
  - "4.6.  Differences from TCP\n   DCCP's differences from TCP apart from those discussed\
    \ so far include\n   the following:\n   o  Copious space for options (up to 1008\
    \ bytes or the PMTU).\n   o  Different acknowledgement formats.  The CCID for\
    \ a connection\n      determines how much acknowledgement information needs to\
    \ be\n      transmitted.  For example, in CCID 2 (TCP-like), this is about one\n\
    \      ack per 2 packets, and each ack must declare exactly which packets\n  \
    \    were received.  In CCID 3 (TFRC), it is about one ack per round-\n      trip\
    \ time, and acks must declare at minimum just the lengths of\n      recent loss\
    \ intervals.\n   o  Denial of Service (DoS) protection.  Several mechanisms help\
    \ limit\n      the amount of state that possibly-misbehaving clients can force\n\
    \      DCCP servers to maintain.  An Init Cookie option analogous to\n      TCP's\
    \ SYN Cookies [SYNCOOKIES] avoids SYN-flood-like attacks.\n      Only one connection\
    \ endpoint has to hold TIMEWAIT state; the\n      DCCP-CloseReq packet, which\
    \ may only be sent by the server, passes\n      that state to the client.  Various\
    \ rate limits let servers avoid\n      attacks that might force extensive computation\
    \ or packet\n      generation.\n   o  Distinguishing different kinds of loss.\
    \  A Data Dropped option\n      (Section 11.7) lets an endpoint declare that a\
    \ packet was dropped\n      because of corruption, because of receive buffer overflow,\
    \ and so\n      on.  This facilitates research into more appropriate rate-control\n\
    \      responses for these non-network-congestion losses (although\n      currently\
    \ such losses will cause a congestion response).\n   o  Acknowledgeability.  In\
    \ TCP, a packet may be acknowledged only\n      once the data is reliably queued\
    \ for application delivery.  This\n      does not make sense in DCCP, where an\
    \ application might, for\n      example, request a drop-from-front receive buffer.\
    \  A DCCP packet\n      may be acknowledged as soon as its header has been successfully\n\
    \      processed.  Concretely, a packet becomes acknowledgeable at Step 8\n  \
    \    of Section 8.5's packet processing pseudocode.  Acknowledgeability\n    \
    \  does not guarantee data delivery, however: the Data Dropped option\n      may\
    \ later report that the packet's application data was discarded.\n   o  No receive\
    \ window.  DCCP is a congestion control protocol, not a\n      flow control protocol.\n\
    \   o  No simultaneous open.  Every connection has one client and one\n      server.\n\
    \   o  No half-closed states.  DCCP has no states corresponding to TCP's\n   \
    \   FINWAIT and CLOSEWAIT, where one half-connection is explicitly\n      closed\
    \ while the other is still active.  The Data Dropped option's\n      Drop Code\
    \ 1, Application Not Listening (Section 11.7), can achieve\n      a similar effect,\
    \ however.\n"
- title: 4.7.  Example Connection
  contents:
  - "4.7.  Example Connection\n   The progress of a typical DCCP connection is as\
    \ follows.  (This\n   description is informative, not normative.)\n          Client\
    \                                  Server\n          ------                  \
    \                ------\n      0.  [CLOSED]                              [LISTEN]\n\
    \      1.  DCCP-Request -->\n      2.                               <-- DCCP-Response\n\
    \      3.  DCCP-Ack -->\n      4.  DCCP-Data, DCCP-Ack, DCCP-DataAck -->\n   \
    \                <-- DCCP-Data, DCCP-Ack, DCCP-DataAck\n      5.             \
    \                  <-- DCCP-CloseReq\n      6.  DCCP-Close -->\n      7.     \
    \                             <-- DCCP-Reset\n      8.  [TIMEWAIT]\n   1. The\
    \ client sends the server a DCCP-Request packet specifying the\n      client and\
    \ server ports, the service being requested, and any\n      features being negotiated,\
    \ including the CCID that the client\n      would like the server to use.  The\
    \ client may optionally piggyback\n      an application request on the DCCP-Request\
    \ packet.  The server may\n      ignore this application request.\n   2. The server\
    \ sends the client a DCCP-Response packet indicating that\n      it is willing\
    \ to communicate with the client.  This response\n      indicates any features\
    \ and options that the server agrees to,\n      begins other feature negotiations\
    \ as desired, and optionally\n      includes Init Cookies that wrap up all this\
    \ information and that\n      must be returned by the client for the connection\
    \ to complete.\n   3. The client sends the server a DCCP-Ack packet that acknowledges\n\
    \      the DCCP-Response packet.  This acknowledges the server's initial\n   \
    \   sequence number and returns any Init Cookies in the DCCP-Response.\n     \
    \ It may also continue feature negotiation.  The client may\n      piggyback an\
    \ application-level request on this ack, producing a\n      DCCP-DataAck packet.\n\
    \   4. The server and client then exchange DCCP-Data packets, DCCP-Ack\n     \
    \ packets acknowledging that data, and, optionally, DCCP-DataAck\n      packets\
    \ containing data with piggybacked acknowledgements.  If the\n      client has\
    \ no data to send, then the server will send DCCP-Data\n      and DCCP-DataAck\
    \ packets, while the client will send DCCP-Acks\n      exclusively.  (However,\
    \ the client may not send DCCP-Data packets\n      before receiving at least one\
    \ non-DCCP-Response packet from the\n      server.)\n   5. The server sends a\
    \ DCCP-CloseReq packet requesting a close.\n   6. The client sends a DCCP-Close\
    \ packet acknowledging the close.\n   7. The server sends a DCCP-Reset packet\
    \ with Reset Code 1, \"Closed\",\n      and clears its connection state.  DCCP-Resets\
    \ are part of normal\n      connection termination; see Section 5.6.\n   8. The\
    \ client receives the DCCP-Reset packet and holds state for two\n      maximum\
    \ segment lifetimes, or 2MSL, to allow any remaining packets\n      to clear the\
    \ network.\n   An alternative connection closedown sequence is initiated by the\n\
    \   client:\n   5b. The client sends a DCCP-Close packet closing the connection.\n\
    \   6b. The server sends a DCCP-Reset packet with Reset Code 1, \"Closed\",\n\
    \       and clears its connection state.\n   7b. The client receives the DCCP-Reset\
    \ packet and holds state for\n       2MSL to allow any remaining packets to clear\
    \ the network.\n"
- title: 5.  Packet Formats
  contents:
  - "5.  Packet Formats\n   The DCCP header can be from 12 to 1020 bytes long.  The\
    \ initial part\n   of the header has the same semantics for all currently defined\
    \ packet\n   types.  Following this comes any additional fixed-length fields\n\
    \   required by the packet type, and then a variable-length list of\n   options.\
    \  The application data area follows the header.  In some\n   packet types, this\
    \ area contains data for the application; in other\n   packet types, its contents\
    \ are ignored.\n      +---------------------------------------+  -.\n      | \
    \           Generic Header             |   |\n      +---------------------------------------+\
    \   |\n      | Additional Fields (depending on type) |   +- DCCP Header\n    \
    \  +---------------------------------------+   |\n      |          Options (optional)\
    \           |   |\n      +=======================================+  -'\n     \
    \ |         Application Data Area         |\n      +---------------------------------------+\n"
- title: 5.1.  Generic Header
  contents:
  - "5.1.  Generic Header\n   The DCCP generic header takes different forms depending\
    \ on the value\n   of X, the Extended Sequence Numbers bit.  If X is one, the\
    \ Sequence\n   Number field is 48 bits long, and the generic header takes 16 bytes,\n\
    \   as follows.\n       0                   1                   2            \
    \       3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |          Source Port          |           Dest Port           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  Data Offset  | CCVal | CsCov |           Checksum            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     |       |X|               |                               .\n   \
    \   | Res | Type  |=|   Reserved    |  Sequence Number (high bits)  .\n      |\
    \     |       |1|               |                               .\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      .                  Sequence Number (low bits)                   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   If X\
    \ is zero, only the low 24 bits of the Sequence Number are\n   transmitted, and\
    \ the generic header is 12 bytes long.\n       0                   1         \
    \          2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |          Source Port          |           Dest Port           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  Data Offset  | CCVal | CsCov |           Checksum            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     |       |X|                                               |\n   \
    \   | Res | Type  |=|          Sequence Number (low bits)           |\n      |\
    \     |       |0|                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The generic header fields are defined as follows.\n   Source and Destination\
    \ Ports: 16 bits each\n      These fields identify the connection, similar to\
    \ the corresponding\n      fields in TCP and UDP.  The Source Port represents\
    \ the relevant\n      port on the endpoint that sent this packet, and the Destination\n\
    \      Port represents the relevant port on the other endpoint.  When\n      initiating\
    \ a connection, the client SHOULD choose its Source Port\n      randomly to reduce\
    \ the likelihood of attack.\n      DCCP APIs should treat port numbers similarly\
    \ to TCP and UDP port\n      numbers.  For example, machines that distinguish\
    \ between\n      \"privileged\" and \"unprivileged\" ports for TCP and UDP should\
    \ do\n      the same for DCCP.\n   Data Offset: 8 bits\n      The offset from\
    \ the start of the packet's DCCP header to the start\n      of its application\
    \ data area, in 32-bit words.  The receiver MUST\n      ignore packets whose Data\
    \ Offset is smaller than the minimum-sized\n      header for the given Type or\
    \ larger than the DCCP packet itself.\n   CCVal: 4 bits\n      Used by the HC-Sender\
    \ CCID.  For example, the A-to-B CCID's\n      sender, which is active at DCCP\
    \ A, MAY send 4 bits of information\n      per packet to its receiver by encoding\
    \ that information in CCVal.\n      The sender MUST set CCVal to zero unless its\
    \ HC-Sender CCID\n      specifies otherwise, and the receiver MUST ignore the\
    \ CCVal field\n      unless its HC-Receiver CCID specifies otherwise.\n   Checksum\
    \ Coverage (CsCov): 4 bits\n      Checksum Coverage determines the parts of the\
    \ packet that are\n      covered by the Checksum field.  This always includes\
    \ the DCCP\n      header and options, but some or all of the application data\
    \ may be\n      excluded.  This can improve performance on noisy links for\n \
    \     applications that can tolerate corruption.  See Section 9.\n   Checksum:\
    \ 16 bits\n      The Internet checksum of the packet's DCCP header (including\n\
    \      options), a network-layer pseudoheader, and, depending on Checksum\n  \
    \    Coverage, all, some, or none of the application data.  See Section\n    \
    \  9.\n   Reserved (Res): 3 bits\n      Senders MUST set this field to all zeroes\
    \ on generated packets,\n      and receivers MUST ignore its value.\n   Type:\
    \ 4 bits\n      The Type field specifies the type of the packet.  The following\n\
    \      values are defined:\n                         Type   Meaning\n        \
    \                 ----   -------\n                           0    DCCP-Request\n\
    \                           1    DCCP-Response\n                           2 \
    \   DCCP-Data\n                           3    DCCP-Ack\n                    \
    \       4    DCCP-DataAck\n                           5    DCCP-CloseReq\n   \
    \                        6    DCCP-Close\n                           7    DCCP-Reset\n\
    \                           8    DCCP-Sync\n                           9    DCCP-SyncAck\n\
    \                         10-15  Reserved\n                     Table 1: DCCP\
    \ Packet Types\n      Receivers MUST ignore any packets with reserved type.  That\
    \ is,\n      packets with reserved type MUST NOT be processed, and they MUST\n\
    \      NOT be acknowledged as received.\n   Extended Sequence Numbers (X): 1 bit\n\
    \      Set to one to indicate the use of an extended generic header with\n   \
    \   48-bit Sequence and Acknowledgement Numbers.  DCCP-Data, DCCP-\n      DataAck,\
    \ and DCCP-Ack packets MAY set X to zero or one.  All\n      DCCP-Request, DCCP-Response,\
    \ DCCP-CloseReq, DCCP-Close, DCCP-\n      Reset, DCCP-Sync, and DCCP-SyncAck packets\
    \ MUST set X to one;\n      endpoints MUST ignore any such packets with X set\
    \ to zero.  High-\n      rate connections SHOULD set X to one on all packets to\
    \ gain\n      increased protection against wrapped sequence numbers and attacks.\n\
    \      See Section 7.6.\n   Sequence Number: 48 or 24 bits\n      Identifies the\
    \ packet uniquely in the sequence of all packets the\n      source sent on this\
    \ connection.  Sequence Number increases by one\n      with every packet sent,\
    \ including packets such as DCCP-Ack that\n      carry no application data.  See\
    \ Section 7.\n   All currently defined packet types except DCCP-Request and DCCP-Data\n\
    \   carry an Acknowledgement Number Subheader in the four or eight bytes\n   immediately\
    \ following the generic header.  When X=1, its format is:\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |           Reserved            |    Acknowledgement Number     .\n   \
    \   |                               |          (high bits)          .\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      .               Acknowledgement Number (low bits)               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   When\
    \ X=0, only the low 24 bits of the Acknowledgement Number are\n   transmitted,\
    \ giving the Acknowledgement Number Subheader this format:\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Reserved    |       Acknowledgement Number (low bits)       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Reserved:\
    \ 16 or 8 bits\n      Senders MUST set this field to all zeroes on generated packets,\n\
    \      and receivers MUST ignore its value.\n   Acknowledgement Number: 48 or\
    \ 24 bits\n      Generally contains GSR, the Greatest Sequence Number Received\
    \ on\n      any acknowledgeable packet so far.  A packet is acknowledgeable\n\
    \      if and only if its header was successfully processed by the\n      receiver;\
    \ Section 7.4 describes this further.  Options such as\n      Ack Vector (Section\
    \ 11.4) combine with the Acknowledgement\n      Number to provide precise information\
    \ about which packets have\n      arrived.\n      Acknowledgement Numbers on DCCP-Sync\
    \ and DCCP-SyncAck packets\n      need not equal GSR.  See Section 5.7.\n"
- title: 5.2.  DCCP-Request Packets
  contents:
  - "5.2.  DCCP-Request Packets\n   A client initiates a DCCP connection by sending\
    \ a DCCP-Request\n   packet.  These packets MAY contain application data and MUST\
    \ use\n   48-bit sequence numbers (X=1).\n       0                   1       \
    \            2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /            Generic DCCP Header with X=1 (16 bytes)            /\n   \
    \   /                   with Type=0 (DCCP-Request)                  /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                         Service Code                          |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                      Options and Padding                      /\n      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n\
    \      /                       Application Data                        /\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Service\
    \ Code: 32 bits\n      Describes the application-level service to which the client\n\
    \      application wants to connect.  Service Codes are intended to\n      provide\
    \ information about which application protocol a connection\n      intends to\
    \ use, thus aiding middleboxes and reducing reliance on\n      globally well-known\
    \ ports.  See Section 8.1.2.\n"
- title: 5.3.  DCCP-Response Packets
  contents:
  - "5.3.  DCCP-Response Packets\n   The server responds to valid DCCP-Request packets\
    \ with DCCP-Response\n   packets.  This is the second phase of the three-way handshake.\n\
    \   DCCP-Response packets MAY contain application data and MUST use\n   48-bit\
    \ sequence numbers (X=1).\n       0                   1                   2  \
    \                 3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /            Generic DCCP Header with X=1 (16 bytes)            /\n   \
    \   /                  with Type=1 (DCCP-Response)                  /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /          Acknowledgement Number Subheader (8 bytes)           /\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                         Service Code                          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /                      Options and Padding                      /\n   \
    \   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n      /\
    \                       Application Data                        /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Acknowledgement Number: 48 bits\n      Contains GSR.  Since DCCP-Responses\
    \ are only sent during\n      connection initiation, this will always equal the\
    \ Sequence Number\n      on a received DCCP-Request.\n   Service Code: 32 bits\n\
    \      MUST equal the Service Code on the corresponding DCCP-Request.\n"
- title: 5.4.  DCCP-Data, DCCP-Ack, and DCCP-DataAck Packets
  contents:
  - "5.4.  DCCP-Data, DCCP-Ack, and DCCP-DataAck Packets\n   The central data transfer\
    \ portion of every DCCP connection uses\n   DCCP-Data, DCCP-Ack, and DCCP-DataAck\
    \ packets.  These packets MAY use\n   24-bit sequence numbers, depending on the\
    \ value of the Allow Short\n   Sequence Numbers feature (Section 7.6.1).  DCCP-Data\
    \ packets carry\n   application data without acknowledgements.\n       0     \
    \              1                   2                   3\n       0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /              Generic DCCP Header (16 or 12 bytes)             /\n   \
    \   /                    with Type=2 (DCCP-Data)                    /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /                      Options and Padding                      /\n   \
    \   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n      /\
    \                       Application Data                        /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   DCCP-Ack packets dispense with the data but contain an\n   Acknowledgement\
    \ Number.  They are used for pure acknowledgements.\n       0                \
    \   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /              Generic DCCP Header (16 or 12 bytes)             /\n   \
    \   /                    with Type=3 (DCCP-Ack)                     /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /        Acknowledgement Number Subheader (8 or 4 bytes)        /\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                      Options and Padding                      /\n      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n\
    \      /                Application Data Area (Ignored)                /\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   DCCP-DataAck\
    \ packets carry both application data and an\n   Acknowledgement Number.  This\
    \ piggybacks acknowledgement information\n   on a data packet.\n       0     \
    \              1                   2                   3\n       0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /              Generic DCCP Header (16 or 12 bytes)             /\n   \
    \   /                  with Type=4 (DCCP-DataAck)                   /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /        Acknowledgement Number Subheader (8 or 4 bytes)        /\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                      Options and Padding                      /\n      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n\
    \      /                       Application Data                        /\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   A DCCP-Data\
    \ or DCCP-DataAck packet may have a zero-length application\n   data area, which\
    \ indicates that the application sent a zero-length\n   datagram.  This differs\
    \ from DCCP-Request and DCCP-Response packets,\n   where an empty application\
    \ data area indicates the absence of\n   application data (not the presence of\
    \ zero-length application data).\n   The API SHOULD report any received zero-length\
    \ datagrams to the\n   receiving application.\n   A DCCP-Ack packet MAY have a\
    \ non-zero-length application data area,\n   which essentially pads the DCCP-Ack\
    \ to a desired length.  Receivers\n   MUST ignore the content of the application\
    \ data area in DCCP-Ack\n   packets.\n   DCCP-Ack and DCCP-DataAck packets often\
    \ include additional\n   acknowledgement options, such as Ack Vector, as required\
    \ by the\n   congestion control mechanism in use.\n"
- title: 5.5.  DCCP-CloseReq and DCCP-Close Packets
  contents:
  - "5.5.  DCCP-CloseReq and DCCP-Close Packets\n   DCCP-CloseReq and DCCP-Close packets\
    \ begin the handshake that\n   normally terminates a connection.  Either client\
    \ or server may send a\n   DCCP-Close packet, which will elicit a DCCP-Reset packet.\
    \  Only the\n   server can send a DCCP-CloseReq packet, which indicates that the\n\
    \   server wants to close the connection but does not want to hold its\n   TIMEWAIT\
    \ state.  Both packet types MUST use 48-bit sequence numbers\n   (X=1).\n    \
    \   0                   1                   2                   3\n       0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /            Generic DCCP Header with X=1 (16 bytes)            /\n   \
    \   /         with Type=5 (DCCP-CloseReq) or 6 (DCCP-Close)         /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /          Acknowledgement Number Subheader (8 bytes)           /\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                      Options and Padding                      /\n      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n\
    \      /                Application Data Area (Ignored)                /\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   As with\
    \ DCCP-Ack packets, DCCP-CloseReq and DCCP-Close packets MAY\n   have non-zero-length\
    \ application data areas, whose contents receivers\n   MUST ignore.\n"
- title: 5.6.  DCCP-Reset Packets
  contents:
  - "5.6.  DCCP-Reset Packets\n   DCCP-Reset packets unconditionally shut down a connection.\n\
    \   Connections normally terminate with a DCCP-Reset, but resets may be\n   sent\
    \ for other reasons, including bad port numbers, bad option\n   behavior, incorrect\
    \ ECN Nonce Echoes, and so forth.  DCCP-Resets MUST\n   use 48-bit sequence numbers\
    \ (X=1).\n       0                   1                   2                   3\n\
    \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \            Generic DCCP Header with X=1 (16 bytes)            /\n      /   \
    \                with Type=7 (DCCP-Reset)                    /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /          Acknowledgement Number Subheader (8 bytes)           /\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  Reset Code   |    Data 1     |    Data 2     |    Data 3     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /                      Options and Padding                      /\n   \
    \   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n      /\
    \              Application Data Area (Error Text)               /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Reset Code: 8 bits\n      Represents the reason that the sender reset the\
    \ DCCP connection.\n   Data 1, Data 2, and Data 3: 8 bits each\n      The Data\
    \ fields provide additional information about why the\n      sender reset the\
    \ DCCP connection.  The meanings of these fields\n      depend on the value of\
    \ Reset Code.\n   Application Data Area: Error Text\n      If present, Error Text\
    \ is a human-readable text string encoded in\n      Unicode UTF-8, and preferably\
    \ in English, that describes the error\n      in more detail.  For example, a\
    \ DCCP-Reset with Reset Code 11,\n      \"Aggression Penalty\", might contain\
    \ Error Text such as \"Aggression\n      Penalty: Received 3 bad ECN Nonce Echoes,\
    \ assuming misbehavior\".\n   The following Reset Codes are currently defined.\
    \  Unless otherwise\n   specified, the Data 1, 2, and 3 fields MUST be set to\
    \ 0 by the sender\n   of the DCCP-Reset and ignored by its receiver.  Section\
    \ references\n   describe concrete situations that will cause each Reset Code\
    \ to be\n   generated; they are not meant to be exhaustive.\n   0, \"Unspecified\"\
    \n      Indicates the absence of a meaningful Reset Code.  Use of Reset\n    \
    \  Code 0 is NOT RECOMMENDED: the sender should choose a Reset Code\n      that\
    \ more clearly defines why the connection is being reset.\n   1, \"Closed\"\n\
    \      Normal connection close.  See Section 8.3.\n   2, \"Aborted\"\n      The\
    \ sending endpoint gave up on the connection because of lack of\n      progress.\
    \  See Sections 8.1.1 and 8.1.5.\n   3, \"No Connection\"\n      No connection\
    \ exists.  See Section 8.3.1.\n   4, \"Packet Error\"\n      A valid packet arrived\
    \ with unexpected type.  For example, a\n      DCCP-Data packet with valid header\
    \ checksum and sequence numbers\n      arrived at a connection in the REQUEST\
    \ state.  See Section 8.3.1.\n      The Data 1 field equals the offending packet\
    \ type as an eight-bit\n      number; thus, an offending packet with Type 2 will\
    \ result in a\n      Data 1 value of 2.\n   5, \"Option Error\"\n      An option\
    \ was erroneous, and the error was serious enough to\n      warrant resetting\
    \ the connection.  See Sections 6.6.7, 6.6.8, and\n      11.4.  The Data 1 field\
    \ equals the offending option type; Data 2\n      and Data 3 equal the first two\
    \ bytes of option data (or zero if\n      the option had less than two bytes of\
    \ data).\n   6, \"Mandatory Error\"\n      The sending endpoint could not process\
    \ an option O that was\n      immediately preceded by Mandatory.  The Data fields\
    \ report the\n      option type and data of option O, using the format of Reset\
    \ Code\n      5, \"Option Error\".  See Section 5.8.2.\n   7, \"Connection Refused\"\
    \n      The Destination Port didn't correspond to a port open for\n      listening.\
    \  Sent only in response to DCCP-Requests.  See Section\n      8.1.3.\n   8, \"\
    Bad Service Code\"\n      The Service Code didn't equal the service code attached\
    \ to the\n      Destination Port.  Sent only in response to DCCP-Requests.  See\n\
    \      Section 8.1.3.\n   9, \"Too Busy\"\n      The server is too busy to accept\
    \ new connections.  Sent only in\n      response to DCCP-Requests.  See Section\
    \ 8.1.3.\n   10, \"Bad Init Cookie\"\n      The Init Cookie echoed by the client\
    \ was incorrect or missing.\n      See Section 8.1.4.\n   11, \"Aggression Penalty\"\
    \n      This endpoint has detected congestion control-related misbehavior\n  \
    \    on the part of the other endpoint.  See Section 12.3.\n   12-127, Reserved\n\
    \      Receivers should treat these codes as they do Reset Code 0,\n      \"Unspecified\"\
    .\n   128-255, CCID-specific codes\n      Semantics depend on the connection's\
    \ CCIDs.  See Section 10.3.\n      Receivers should treat unknown CCID-specific\
    \ Reset Codes as they\n      do Reset Code 0, \"Unspecified\".\n   The following\
    \ table summarizes this information.\n          Reset\n          Code   Name \
    \                   Data 1     Data 2 & 3\n          -----  ----             \
    \       ------     ----------\n            0    Unspecified               0  \
    \          0\n            1    Closed                    0            0\n    \
    \        2    Aborted                   0            0\n            3    No Connection\
    \             0            0\n            4    Packet Error           pkt type\
    \        0\n            5    Option Error           option #   option data\n \
    \           6    Mandatory Error        option #   option data\n            7\
    \    Connection Refused        0            0\n            8    Bad Service Code\
    \          0            0\n            9    Too Busy                  0      \
    \      0\n           10    Bad Init Cookie           0            0\n        \
    \   11    Aggression Penalty        0            0\n          12-127 Reserved\n\
    \         128-255 CCID-specific codes\n                        Table 2: DCCP Reset\
    \ Codes\n   Options on DCCP-Reset packets are processed before the connection\
    \ is\n   shut down.  This means that certain combinations of options,\n   particularly\
    \ involving Mandatory, may cause an endpoint to respond to\n   a valid DCCP-Reset\
    \ with another DCCP-Reset.  This cannot lead to a\n   reset storm; since the first\
    \ endpoint has already reset the\n   connection, the second DCCP-Reset will be\
    \ ignored.\n"
- title: 5.7.  DCCP-Sync and DCCP-SyncAck Packets
  contents:
  - "5.7.  DCCP-Sync and DCCP-SyncAck Packets\n   DCCP-Sync packets help DCCP endpoints\
    \ recover synchronization after\n   bursts of loss and recover from half-open\
    \ connections.  Each valid\n   received DCCP-Sync immediately elicits a DCCP-SyncAck.\
    \  Both packet\n   types MUST use 48-bit sequence numbers (X=1).\n       0   \
    \                1                   2                   3\n       0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /            Generic DCCP Header with X=1 (16 bytes)            /\n   \
    \   /          with Type=8 (DCCP-Sync) or 9 (DCCP-SyncAck)          /\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      /          Acknowledgement Number Subheader (8 bytes)           /\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      /\
    \                      Options and Padding                      /\n      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n\
    \      /                Application Data Area (Ignored)                /\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The\
    \ Acknowledgement Number field has special semantics for DCCP-Sync\n   and DCCP-SyncAck\
    \ packets.  First, the packet corresponding to a\n   DCCP-Sync's Acknowledgement\
    \ Number need not have been\n   acknowledgeable.  Thus, receivers MUST NOT assume\
    \ that a packet was\n   processed simply because it appears in the Acknowledgement\
    \ Number\n   field of a DCCP-Sync packet.  This differs from all other packet\n\
    \   types, where the Acknowledgement Number by definition corresponds to\n   an\
    \ acknowledgeable packet.  Second, the Acknowledgement Number on any\n   DCCP-SyncAck\
    \ packet MUST correspond to the Sequence Number on an\n   acknowledgeable DCCP-Sync\
    \ packet.  In the presence of reordering,\n   this might not equal GSR.\n   As\
    \ with DCCP-Ack packets, DCCP-Sync and DCCP-SyncAck packets MAY have\n   non-zero-length\
    \ application data areas, whose contents receivers MUST\n   ignore.  Padded DCCP-Sync\
    \ packets may be useful when performing Path\n   MTU discovery; see Section 14.\n"
- title: 5.8.  Options
  contents:
  - "5.8.  Options\n   Any DCCP packet may contain options, which occupy space at\
    \ the end of\n   the DCCP header.  Each option is a multiple of 8 bits in length.\n\
    \   Individual options are not padded to multiples of 32 bits, and any\n   option\
    \ may begin on any byte boundary.  However, the combination of\n   all options\
    \ MUST add up to a multiple of 32 bits; Padding options\n   MUST be added as necessary\
    \ to fill out option space to a word\n   boundary.  Any options present are included\
    \ in the header checksum.\n   The first byte of an option is the option type.\
    \  Options with types 0\n   through 31 are single-byte options.  Other options\
    \ are followed by a\n   byte indicating the option's length.  This length value\
    \ includes the\n   two bytes of option-type and option-length as well as any option-data\n\
    \   bytes; it must therefore be greater than or equal to two.\n   Options MUST\
    \ be processed sequentially, starting with the first\n   option in the packet\
    \ header.  Options with unknown types MUST be\n   ignored.  Also, options with\
    \ nonsensical lengths (length byte less\n   than two or more than the remaining\
    \ space in the options portion of\n   the header) MUST be ignored, and any option\
    \ space following an option\n   with nonsensical length MUST likewise be ignored.\
    \  Unless otherwise\n   specified, multiple occurrences of the same option MUST\
    \ be processed\n   independently; for some options, this will mean in practice\
    \ that the\n   last valid occurrence of an option takes precedence.\n   The following\
    \ options are currently defined:\n               Option                      \
    \     DCCP-  Section\n       Type    Length     Meaning               Data?  Reference\n\
    \       ----    ------     -------               -----  ---------\n         0\
    \        1       Padding                 Y      5.8.1\n         1        1   \
    \    Mandatory               N      5.8.2\n         2        1       Slow Receiver\
    \           Y      11.6\n       3-31       1       Reserved\n        32     variable\
    \   Change L                N      6.1\n        33     variable   Confirm L  \
    \             N      6.2\n        34     variable   Change R                N\
    \      6.1\n        35     variable   Confirm R               N      6.2\n   \
    \     36     variable   Init Cookie             N      8.1.4\n        37     \
    \  3-8      NDP Count               Y      7.7\n        38     variable   Ack\
    \ Vector [Nonce 0]    N      11.4\n        39     variable   Ack Vector [Nonce\
    \ 1]    N      11.4\n        40     variable   Data Dropped            N     \
    \ 11.7\n        41        6       Timestamp               Y      13.1\n      \
    \  42      6/8/10    Timestamp Echo          Y      13.3\n        43       4/6\
    \      Elapsed Time            N      13.2\n        44        6       Data Checksum\
    \           Y      9.3\n       45-127  variable   Reserved\n      128-255  variable\
    \   CCID-specific options   -      10.3\n                        Table 3: DCCP\
    \ Options\n   Not all options are suitable for all packet types.  For example,\n\
    \   since the Ack Vector option is interpreted relative to the\n   Acknowledgement\
    \ Number, it isn't suitable on DCCP-Request and DCCP-\n   Data packets, which\
    \ have no Acknowledgement Number.  If an option\n   occurs on an unexpected packet\
    \ type, it MUST generally be ignored;\n   any such restrictions are mentioned\
    \ in each option's description.\n   The table summarizes the most common restriction:\
    \ when the DCCP-\n   Data? column value is N, the corresponding option MUST be\
    \ ignored\n   when received on a DCCP-Data packet.  (Section 7.5.5 describes why\n\
    \   such options are ignored as opposed to, say, causing a reset.)\n   Options\
    \ with invalid values MUST be ignored unless otherwise\n   specified.  For example,\
    \ any Data Checksum option with option length\n   4 MUST be ignored, since all\
    \ valid Data Checksum options have option\n   length 6.\n   This section describes\
    \ two generic options, Padding and Mandatory.\n   Other options are described\
    \ later.\n"
- title: 5.8.1.  Padding Option
  contents:
  - "5.8.1.  Padding Option\n   +--------+\n   |00000000|\n   +--------+\n     Type=0\n\
    \   Padding is a single-byte \"no-operation\" option used to pad between or\n\
    \   after options.  If the length of a packet's other options is not a\n   multiple\
    \ of 32 bits, then Padding options are REQUIRED to pad out the\n   options area\
    \ to the length implied by Data Offset.  Padding may also\n   be used between\
    \ options; for example, to align the beginning of a\n   subsequent option on a\
    \ 32-bit boundary.  There is no guarantee that\n   senders will use this option,\
    \ so receivers must be prepared to\n   process options even if they do not begin\
    \ on a word boundary.\n"
- title: 5.8.2.  Mandatory Option
  contents:
  - "5.8.2.  Mandatory Option\n   +--------+\n   |00000001|\n   +--------+\n     Type=1\n\
    \   Mandatory is a single-byte option that marks the immediately\n   following\
    \ option as mandatory.  Say that the immediately following\n   option is O.  Then\
    \ the Mandatory option has no effect if the\n   receiving DCCP endpoint understands\
    \ and processes O.  If the endpoint\n   does not understand or process O, however,\
    \ then it MUST reset the\n   connection using Reset Code 6, \"Mandatory Failure\"\
    .  For instance,\n   the endpoint would reset the connection if it did not understand\
    \ O's\n   type; if it understood O's type, but not O's data; if O's data was\n\
    \   invalid for O's type; if O was a feature negotiation option, and the\n   endpoint\
    \ did not understand the enclosed feature number; or if the\n   endpoint understood\
    \ O, but chose not to perform the action O implies.\n   This list is not exhaustive\
    \ and, in particular, individual option\n   specifications may describe additional\
    \ situations in which the\n   endpoint should reset the connection and situations\
    \ in which it\n   should not.\n   Mandatory options MUST NOT be sent on DCCP-Data\
    \ packets, and any\n   Mandatory options received on DCCP-Data packets MUST be\
    \ ignored.\n   The connection is in error and should be reset with Reset Code\
    \ 5,\n   \"Option Error\", if option O is absent (Mandatory was the last byte\
    \ of\n   the option list), or if option O equals Mandatory.  However, the\n  \
    \ combination \"Mandatory Padding\" is valid, and MUST behave like two\n   bytes\
    \ of Padding.\n   Section 6.6.9 describes the behavior of Mandatory feature negotiation\n\
    \   options in more detail.\n"
- title: 6.  Feature Negotiation
  contents:
  - "6.  Feature Negotiation\n   Four DCCP options, Change L, Confirm L, Change R,\
    \ and Confirm R, are\n   used to negotiate feature values.  Change options initiate\
    \ a\n   negotiation; Confirm options complete that negotiation.  The \"L\"\n \
    \  options are sent by the feature location, and the \"R\" options are\n   sent\
    \ by the feature remote.  Change options are retransmitted to\n   ensure reliability.\n\
    \   All these options have the same format.  The first byte of option\n   data\
    \ is the feature number, and the second and subsequent data bytes\n   hold one\
    \ or more feature values.  The exact format of the feature\n   value area depends\
    \ on the feature type; see Section 6.3.\n   +--------+--------+--------+--------+--------\n\
    \   |  Type  | Length |Feature#| Value(s) ...\n   +--------+--------+--------+--------+--------\n\
    \   Together, the feature number and the option type (\"L\" or \"R\")\n   uniquely\
    \ identify the feature to which an option applies.  The exact\n   format of the\
    \ Value(s) area depends on the feature number.\n   Feature negotiation options\
    \ MUST NOT be sent on DCCP-Data packets,\n   and any feature negotiation options\
    \ received on DCCP-Data packets\n   MUST be ignored.\n"
- title: 6.1.  Change Options
  contents:
  - "6.1.  Change Options\n   Change L and Change R options initiate feature negotiation.\
    \  The\n   option to use depends on the relevant feature's location: To start\
    \ a\n   negotiation for feature F/A, DCCP A will send a Change L option; to\n\
    \   start a negotiation for F/B, it will send a Change R option.  Change\n   options\
    \ are retransmitted until some response is received.  They\n   contain at least\
    \ one Value, and thus have a length of at least 4.\n              +--------+--------+--------+--------+--------\n\
    \   Change L:  |00100000| Length |Feature#| Value(s) ...\n              +--------+--------+--------+--------+--------\n\
    \               Type=32\n              +--------+--------+--------+--------+--------\n\
    \   Change R:  |00100010| Length |Feature#| Value(s) ...\n              +--------+--------+--------+--------+--------\n\
    \               Type=34\n"
- title: 6.2.  Confirm Options
  contents:
  - "6.2.  Confirm Options\n   Confirm L and Confirm R options complete feature negotiation\
    \ and are\n   sent in response to Change R and Change L options, respectively.\n\
    \   Confirm options MUST NOT be generated except in response to Change\n   options.\
    \  Confirm options need not be retransmitted, since Change\n   options are retransmitted\
    \ as necessary.  The first byte of the\n   Confirm option contains the feature\
    \ number from the corresponding\n   Change.  Following this is the selected Value,\
    \ and then possibly the\n   sender's preference list.\n              +--------+--------+--------+--------+--------\n\
    \   Confirm L: |00100001| Length |Feature#| Value(s) ...\n              +--------+--------+--------+--------+--------\n\
    \               Type=33\n              +--------+--------+--------+--------+--------\n\
    \   Confirm R: |00100011| Length |Feature#| Value(s) ...\n              +--------+--------+--------+--------+--------\n\
    \               Type=35\n   If an endpoint receives an invalid Change option --\
    \ with an unknown\n   feature number, or an invalid value -- it will respond with\
    \ an empty\n   Confirm option containing the problematic feature number, but no\n\
    \   value.  Such options have length 3.\n"
- title: 6.3.  Reconciliation Rules
  contents:
  - "6.3.  Reconciliation Rules\n   Reconciliation rules determine how the two sets\
    \ of preferences for a\n   given feature are resolved into a unique result.  The\
    \ reconciliation\n   rule depends only on the feature number.  Each reconciliation\
    \ rule\n   must have the property that the result is uniquely determined given\n\
    \   the contents of Change options sent by the two endpoints.\n   All current\
    \ DCCP features use one of two reconciliation rules:\n   server-priority (\"SP\"\
    ) and non-negotiable (\"NN\").\n"
- title: 6.3.1.  Server-Priority
  contents:
  - "6.3.1.  Server-Priority\n   The feature value is a fixed-length byte string (length\
    \ determined by\n   the feature number).  Each Change option contains a list of\
    \ values\n   ordered by preference, with the most preferred value coming first.\n\
    \   Each Confirm option contains the confirmed value, followed by the\n   confirmer's\
    \ preference list.  Thus, the feature's current value will\n   generally appear\
    \ twice in Confirm options' data, once as the current\n   value and once in the\
    \ confirmer's preference list.\n   To reconcile the preference lists, select the\
    \ first entry in the\n   server's list that also occurs in the client's list.\
    \  If there is no\n   shared entry, the feature's value MUST NOT change, and the\
    \ Confirm\n   option will confirm the feature's previous value (unless the Change\n\
    \   option was Mandatory; see Section 6.6.9).\n"
- title: 6.3.2.  Non-Negotiable
  contents:
  - "6.3.2.  Non-Negotiable\n   The feature value is a byte string.  Each option contains\
    \ exactly one\n   feature value.  The feature location signals a new value by\
    \ sending a\n   Change L option.  The feature remote MUST accept any valid value,\n\
    \   responding with a Confirm R option containing the new value, and it\n   MUST\
    \ send empty Confirm R options in response to invalid values\n   (unless the Change\
    \ L option was Mandatory; see Section 6.6.9).\n   Change R and Confirm L options\
    \ MUST NOT be sent for non-negotiable\n   features; see Section 6.6.8.  Non-negotiable\
    \ features use the feature\n   negotiation mechanism to achieve reliability.\n"
- title: 6.4.  Feature Numbers
  contents:
  - "6.4.  Feature Numbers\n   This document defines the following feature numbers.\n\
    \                                          Rec'n Initial        Section\n   Number\
    \   Meaning                       Rule   Value  Req'd Reference\n   ------   -------\
    \                       -----  -----  ----- ---------\n      0     Reserved\n\
    \      1     Congestion Control ID (CCID)   SP      2      Y     10\n      2 \
    \    Allow Short Seqnos             SP      0      Y     7.6.1\n      3     Sequence\
    \ Window                NN     100     Y     7.5.2\n      4     ECN Incapable\
    \                  SP      0      N     12.1\n      5     Ack Ratio          \
    \            NN      2      N     11.3\n      6     Send Ack Vector          \
    \      SP      0      N     11.5\n      7     Send NDP Count                 SP\
    \      0      N     7.7.2\n      8     Minimum Checksum Coverage      SP     \
    \ 0      N     9.2.1\n      9     Check Data Checksum            SP      0   \
    \   N     9.3.1\n    10-127  Reserved\n   128-255  CCID-specific features    \
    \                          10.3\n                      Table 4: DCCP Feature Numbers\n\
    \   Rec'n Rule     The reconciliation rule used for the feature.  SP\n       \
    \           means server-priority, NN means non-negotiable.\n   Initial Value\
    \  The initial value for the feature.  Every feature has\n                  a\
    \ known initial value.\n   Req'd          This column is \"Y\" if and only if\
    \ every DCCP\n                  implementation MUST understand the feature.  If\
    \ it is\n                  \"N\", then the feature behaves like an extension (see\n\
    \                  Section 15), and it is safe to respond to Change\n        \
    \          options for the feature with empty Confirm options.\n             \
    \     Of course, a CCID might require the feature; a DCCP\n                  that\
    \ implements CCID 2 MUST support Ack Ratio and\n                  Send Ack Vector,\
    \ for example.\n"
- title: 6.5.  Feature Negotiation Examples
  contents:
  - "6.5.  Feature Negotiation Examples\n   Here are three example feature negotiations\
    \ for features located at\n   the server, the first two for the Congestion Control\
    \ ID feature, the\n   last for the Ack Ratio.\n                 Client       \
    \              Server\n                 ------                     ------\n  \
    \    1. Change R(CCID, 2 3 1)  -->\n         (\"2 3 1\" is client's preference\
    \ list)\n      2.                        <--  Confirm L(CCID, 3, 3 2 1)\n    \
    \                           (3 is the negotiated value;\n                    \
    \           \"3 2 1\" is server's pref list)\n                  * agreement that\
    \ CCID/Server = 3 *\n      1.                   XXX  <--  Change L(CCID, 3 2 1)\n\
    \      2.                             Retransmission:\n                      \
    \          <--  Change L(CCID, 3 2 1)\n      3. Confirm R(CCID, 3, 2 3 1)  -->\n\
    \                  * agreement that CCID/Server = 3 *\n      1.              \
    \          <--  Change L(Ack Ratio, 3)\n      2. Confirm R(Ack Ratio, 3)  -->\n\
    \               * agreement that Ack Ratio/Server = 3 *\n   This example shows\
    \ a simultaneous negotiation.\n                  Client                     Server\n\
    \                  ------                     ------\n      1a. Change R(CCID,\
    \ 2 3 1)  -->\n       b.                        <--  Change L(CCID, 3 2 1)\n \
    \     2a.                        <--  Confirm L(CCID, 3, 3 2 1)\n       b. Confirm\
    \ R(CCID, 3, 2 3 1)  -->\n                   * agreement that CCID/Server = 3\
    \ *\n   Here are the byte encodings of several Change and Confirm options.\n \
    \  Each option is sent by DCCP A.\n   Change L(CCID, 2 3) = 32,5,1,2,3\n     \
    \ DCCP B should change CCID/A's value (feature number 1, a server-\n      priority\
    \ feature); DCCP A's preferred values are 2 and 3, in that\n      preference order.\n\
    \   Change L(Sequence Window, 1024) = 32,9,3,0,0,0,0,4,0\n      DCCP B should\
    \ change Sequence Window/A's value (feature number 3,\n      a non-negotiable\
    \ feature) to the 6-byte string 0,0,0,0,4,0 (the\n      value 1024).\n   Confirm\
    \ L(CCID, 2, 2 3) = 33,6,1,2,2,3\n      DCCP A has changed CCID/A's value to 2;\
    \ its preferred values are 2\n      and 3, in that preference order.\n   Empty\
    \ Confirm L(126) = 33,3,126\n      DCCP A doesn't implement feature number 126,\
    \ or DCCP B's proposed\n      value for feature 126/A was invalid.\n   Change\
    \ R(CCID, 3 2) = 34,5,1,3,2\n      DCCP B should change CCID/B's value; DCCP A's\
    \ preferred values are\n      3 and 2, in that preference order.\n   Confirm R(CCID,\
    \ 2, 3 2) = 35,6,1,2,3,2\n      DCCP A has changed CCID/B's value to 2; its preferred\
    \ values were\n      3 and 2, in that preference order.\n   Confirm R(Sequence\
    \ Window, 1024) = 35,9,3,0,0,0,0,4,0\n      DCCP A has changed Sequence Window/B's\
    \ value to the 6-byte string\n      0,0,0,0,4,0 (the value 1024).\n   Empty Confirm\
    \ R(126) = 35,3,126\n      DCCP A doesn't implement feature number 126, or DCCP\
    \ B's proposed\n      value for feature 126/B was invalid.\n"
- title: 6.6.  Option Exchange
  contents:
  - "6.6.  Option Exchange\n   A few basic rules govern feature negotiation option\
    \ exchange.\n   1. Every non-reordered Change option gets a Confirm option in\n\
    \      response.\n   2. Change options are retransmitted until a response for\
    \ the latest\n      Change is received.\n   3. Feature negotiation options are\
    \ processed in strictly-increasing\n      order by Sequence Number.\n   The rest\
    \ of this section describes the consequences of these rules in\n   more detail.\n"
- title: 6.6.1.  Normal Exchange
  contents:
  - "6.6.1.  Normal Exchange\n   Change options are generated when a DCCP endpoint\
    \ wants to change the\n   value of some feature.  Generally, this will happen\
    \ at the beginning\n   of a connection, although it may happen at any time.  We\
    \ say the\n   endpoint \"generates\" or \"sends\" a Change L or Change R option,\
    \ but of\n   course the option must be attached to a packet.  The endpoint may\n\
    \   attach the option to a packet it would have generated anyway (such as\n  \
    \ a DCCP-Request), or it may create a \"feature negotiation packet\",\n   often\
    \ a DCCP-Ack or DCCP-Sync, just to carry the option.  Feature\n   negotiation\
    \ packets are controlled by the relevant congestion control\n   mechanism.  For\
    \ example, DCCP A may send a DCCP-Ack or DCCP-Sync for\n   feature negotiation\
    \ only if the B-to-A CCID would allow sending a\n   DCCP-Ack.  In addition, an\
    \ endpoint SHOULD generate at most one\n   feature negotiation packet per round-trip\
    \ time.\n   On receiving a Change L or Change R option, a DCCP endpoint examines\n\
    \   the included preference list, reconciles that with its own preference\n  \
    \ list, calculates the new value, and sends back a Confirm R or Confirm\n   L\
    \ option, respectively, informing its peer of the new value or that\n   the feature\
    \ was not understood.  Every non-reordered Change option\n   MUST result in a\
    \ corresponding Confirm option, and any packet\n   including a Confirm option\
    \ MUST carry an Acknowledgement Number.\n   (Section 6.6.4 describes how Change\
    \ reordering is detected and\n   handled.)  Generated Confirm options may be attached\
    \ to packets that\n   would have been sent anyway (such as DCCP-Response or DCCP-SyncAck)\n\
    \   or to new feature negotiation packets, as described above.\n   The Change-sending\
    \ endpoint MUST wait to receive a corresponding\n   Confirm option before changing\
    \ its stored feature value.  The\n   Confirm-sending endpoint changes its stored\
    \ feature value as soon as\n   it sends the Confirm.\n   A packet MAY contain\
    \ more than one feature negotiation option,\n   possibly including two options\
    \ that refer to the same feature; as\n   usual, the options are processed sequentially.\n"
- title: 6.6.2.  Processing Received Options
  contents:
  - "6.6.2.  Processing Received Options\n   DCCP endpoints exist in one of three\
    \ states relative to each feature.\n   STABLE is the normal state, where the endpoint\
    \ knows the feature's\n   value and thinks the other endpoint agrees.  An endpoint\
    \ enters the\n   CHANGING state when it first sends a Change for the feature and\n\
    \   returns to STABLE once it receives a corresponding Confirm.  The\n   final\
    \ state, UNSTABLE, indicates that an endpoint in CHANGING state\n   changed its\
    \ preference list but has not yet transmitted a Change\n   option with the new\
    \ preference list.\n   Feature state transitions at a feature location are implemented\n\
    \   according to this diagram.  The diagram ignores sequence number and\n   option\
    \ validity issues; these are handled explicitly in the\n   pseudocode that follows.\n\
    \                                                          timeout/\n rcv Confirm\
    \ R      app/protocol evt : snd Change L       rcv non-ack\n : ignore      +---------------------------------------+\
    \  : snd Change L\n      +----+   |                                       |  +----+\n\
    \      |    v   |                   rcv Change R        v  |    v\n   +------------+\
    \  rcv Confirm R   : calc new value, +------------+\n   |            |  : accept\
    \ value    snd Confirm L   |            |\n   |   STABLE   |<-----------------------------------|\
    \  CHANGING  |\n   |            |        rcv empty Confirm R         |       \
    \     |\n   +------------+        : revert to old value       +------------+\n\
    \       |    ^                                            |    ^\n       +----+\
    \                                  pref list |    | snd\n rcv Change R       \
    \                           changes   |    | Change L\n : calc new value, snd\
    \ Confirm L                         v    |\n                                 \
    \                    +------------+\n                                        \
    \         +---|            |\n                            rcv Confirm/Change R\
    \ |   |  UNSTABLE  |\n                            : ignore             +-->| \
    \           |\n                                                     +------------+\n\
    \   Feature locations SHOULD use the following pseudocode, which\n   corresponds\
    \ to the state diagram, to react to each feature\n   negotiation option on each\
    \ valid non-Data packet received.  The\n   pseudocode refers to \"P.seqno\" and\
    \ \"P.ackno\", which are properties of\n   the packet; \"O.type\" and \"O.len\"\
    , which are properties of the option;\n   \"FGSR\" and \"FGSS\", which are properties\
    \ of the connection and handle\n   reordering as described in Section 6.6.4; \"\
    F.state\", which is the\n   feature's state (STABLE, CHANGING, or UNSTABLE); and\
    \ \"F.value\", which\n   is the feature's value.\n   First, check for unknown\
    \ features (Section 6.6.7);\n      If F is unknown,\n         If the option was\
    \ Mandatory,   /* Section 6.6.9 */\n            Reset connection and return\n\
    \         Otherwise, if O.type == Change R,\n            Send Empty Confirm L\
    \ on a future packet\n         Return\n   Second, check for reordering (Section\
    \ 6.6.4);\n      If F.state == UNSTABLE or P.seqno <= FGSR\n              or (O.type\
    \ == Confirm R and P.ackno < FGSS),\n         Ignore option and return\n   Third,\
    \ process Change R options;\n      If O.type == Change R,\n         If the option's\
    \ value is valid,   /* Section 6.6.8 */\n            Calculate new value\n   \
    \         Send Confirm L on a future packet\n            Set F.state := STABLE\n\
    \         Otherwise, if the option was Mandatory,\n            Reset connection\
    \ and return\n         Otherwise,\n            Send Empty Confirm L on a future\
    \ packet\n            /* Remain in existing state.  If that's CHANGING, this\n\
    \               endpoint will retransmit its Change L option later. */\n   Fourth,\
    \ process Confirm R options (but only in CHANGING state).\n      If F.state ==\
    \ CHANGING and O.type == Confirm R,\n         If O.len > 3,   /* nonempty */\n\
    \            If the option's value is valid,\n               Set F.value := new\
    \ value\n            Otherwise,\n               Reset connection and return\n\
    \         Set F.state := STABLE\n   Versions of this diagram and pseudocode are\
    \ also used by feature\n   remotes; simply switch the \"L\"s and \"R\"s, so that\
    \ the relevant\n   options are Change R and Confirm L.\n"
- title: 6.6.3.  Loss and Retransmission
  contents:
  - "6.6.3.  Loss and Retransmission\n   Packets containing Change and Confirm options\
    \ might be lost or\n   delayed by the network.  Therefore, Change options are\
    \ repeatedly\n   transmitted to achieve reliability.  We refer to this as\n  \
    \ \"retransmission\", although of course there are no packet-level\n   retransmissions\
    \ in DCCP: a Change option that is sent again will be\n   sent on a new packet\
    \ with a new sequence number.\n   A CHANGING endpoint transmits another Change\
    \ option once it realizes\n   that it has not heard back from the other endpoint.\
    \  The new Change\n   option need not contain the same payload as the original;\
    \ reordering\n   protection will ensure that agreement is reached based on the\
    \ most\n   recently transmitted option.\n   A CHANGING endpoint MUST continue\
    \ retransmitting Change options until\n   it gets some response or the connection\
    \ terminates.\n   Endpoints SHOULD use an exponential-backoff timer to decide\
    \ when to\n   retransmit Change options.  (Packets generated specifically for\n\
    \   feature negotiation MUST use such a timer.)  The timer interval is\n   initially\
    \ set to not less than one round-trip time, and should back\n   off to not less\
    \ than 64 seconds.  The backoff protects against\n   delayed agreement due to\
    \ the reordering protection algorithms\n   described in the next section.  Again,\
    \ endpoints may piggyback Change\n   options on packets they would have sent anyway\
    \ or create new packets\n   to carry the options.  Any new packets are controlled\
    \ by the relevant\n   congestion-control mechanism.\n   Confirm options are never\
    \ retransmitted, but the Confirm-sending\n   endpoint MUST generate a Confirm\
    \ option after every non-reordered\n   Change.\n"
- title: 6.6.4.  Reordering
  contents:
  - "6.6.4.  Reordering\n   Reordering might cause packets containing Change and Confirm\
    \ options\n   to arrive in an unexpected order.  Endpoints MUST ignore feature\n\
    \   negotiation options that do not arrive in strictly-increasing order\n   by\
    \ Sequence Number.  The rest of this section presents two algorithms\n   that\
    \ fulfill this requirement.\n   The first algorithm introduces two sequence number\
    \ variables that\n   each endpoint maintains for the connection.\n   FGSR    \
    \  Feature Greatest Sequence Number Received: The greatest\n             sequence\
    \ number received, considering only valid packets\n             that contained\
    \ one or more feature negotiation options\n             (Change and/or Confirm).\
    \  This value is initialized to\n             ISR - 1.\n   FGSS      Feature Greatest\
    \ Sequence Number Sent: The greatest\n             sequence number sent, considering\
    \ only packets that\n             contained one or more new Change options.  A\
    \ Change option\n             is new if and only if it was generated during a\
    \ transition\n             from the STABLE or UNSTABLE state to the CHANGING state;\n\
    \             Change options generated within the CHANGING state are\n       \
    \      retransmissions and MUST have exactly the same contents as\n          \
    \   previously transmitted options, allowing tolerance for\n             reordering.\
    \  FGSS is initialized to ISS.\n   Each endpoint checks two conditions on sequence\
    \ numbers to decide\n   whether to process received feature negotiation options.\n\
    \   1. If a packet's Sequence Number is less than or equal to FGSR, then\n   \
    \   its Change options MUST be ignored.\n   2. If a packet's Sequence Number is\
    \ less than or equal to FGSR, if it\n      has no Acknowledgement Number, OR if\
    \ its Acknowledgement Number is\n      less than FGSS, then its Confirm options\
    \ MUST be ignored.\n   Alternatively, an endpoint MAY maintain separate FGSR and\
    \ FGSS values\n   for every feature.  FGSR(F/X) would equal the greatest sequence\n\
    \   number received, considering only packets that contained Change or\n   Confirm\
    \ options applying to feature F/X; FGSS(F/X) would be defined\n   similarly. \
    \ This algorithm requires more state, but is slightly more\n   forgiving to multiple\
    \ overlapped feature negotiations.  Either\n   algorithm MAY be used; the first\
    \ algorithm, with connection-wide FGSR\n   and FGSS variables, is RECOMMENDED.\n\
    \   One consequence of these rules is that a CHANGING endpoint will\n   ignore\
    \ any Confirm option that does not acknowledge the latest Change\n   option sent.\
    \  This ensures that agreement, once achieved, used the\n   most recent available\
    \ information about the endpoints' preferences.\n"
- title: 6.6.5.  Preference Changes
  contents:
  - "6.6.5.  Preference Changes\n   Endpoints are allowed to change their preference\
    \ lists at any time.\n   However, an endpoint that changes its preference list\
    \ while in the\n   CHANGING state MUST transition to the UNSTABLE state.  It will\n\
    \   transition back to CHANGING once it has transmitted a Change option\n   with\
    \ the new preference list.  This ensures that agreement is based\n   on active\
    \ preference lists.  Without the UNSTABLE state, simultaneous\n   negotiation\
    \ -- where the endpoints began independent negotiations for\n   the same feature\
    \ at the same time -- might lead to the negotiation's\n   terminating with the\
    \ endpoints thinking the feature had different\n   values.\n"
- title: 6.6.6.  Simultaneous Negotiation
  contents:
  - "6.6.6.  Simultaneous Negotiation\n   The two endpoints might simultaneously open\
    \ negotiation for the same\n   feature, after which an endpoint in the CHANGING\
    \ state will receive a\n   Change option for the same feature.  Such received\
    \ Change options can\n   act as responses to the original Change options.  The\
    \ CHANGING\n   endpoint MUST examine the received Change's preference list,\n\
    \   reconcile that with its own preference list (as expressed in its\n   generated\
    \ Change options), and generate the corresponding Confirm\n   option.  It can\
    \ then transition to the STABLE state.\n"
- title: 6.6.7.  Unknown Features
  contents:
  - "6.6.7.  Unknown Features\n   Endpoints may receive Change options referring to\
    \ feature numbers\n   they do not understand -- for instance, when an extended\
    \ DCCP\n   converses with a non-extended DCCP.  Endpoints MUST respond to\n  \
    \ unknown Change options with Empty Confirm options (that is, Confirm\n   options\
    \ containing no data), which inform the CHANGING endpoint that\n   the feature\
    \ was not understood.  However, if the Change option was\n   Mandatory, the connection\
    \ MUST be reset; see Section 6.6.9.\n   On receiving an empty Confirm option for\
    \ some feature, the CHANGING\n   endpoint MUST transition back to the STABLE state,\
    \ leaving the\n   feature's value unchanged.  Section 15 suggests that the default\n\
    \   value for any extension feature correspond to \"extension not\n   available\"\
    .\n   Some features are required to be understood by all DCCPs (see Section\n\
    \   6.4).  The CHANGING endpoint SHOULD reset the connection (with Reset\n   Code\
    \ 5, \"Option Error\") if it receives an empty Confirm option for\n   such a feature.\n\
    \   Since Confirm options are generated only in response to Change\n   options,\
    \ an endpoint should never receive a Confirm option referring\n   to a feature\
    \ number it does not understand.  Nevertheless, endpoints\n   MUST ignore any\
    \ such options they receive.\n"
- title: 6.6.8.  Invalid Options
  contents:
  - "6.6.8.  Invalid Options\n   A DCCP endpoint might receive a Change or Confirm\
    \ option for a known\n   feature that lists one or more values that it does not\
    \ understand.\n   Some, but not all, such options are invalid, depending on the\n\
    \   relevant reconciliation rule (Section 6.3).  For instance:\n   o  All features\
    \ have length limitations, and options with invalid\n      lengths are invalid.\
    \  For example, the Ack Ratio feature takes\n      16-bit values, so valid \"\
    Confirm R(Ack Ratio)\" options have option\n      length 5.\n   o  Some non-negotiable\
    \ features have value limitations.  The Ack\n      Ratio feature takes two-byte,\
    \ non-zero integer values, so a\n      \"Change L(Ack Ratio, 0)\" option is never\
    \ valid.  Note that\n      server-priority features do not have value limitations,\
    \ since\n      unknown values are handled as a matter of course.\n   o  Any Confirm\
    \ option that selects the wrong value, based on the two\n      preference lists\
    \ and the relevant reconciliation rule, is invalid.\n   However, unexpected Confirm\
    \ options -- that refer to unknown feature\n   numbers, or that don't appear to\
    \ be part of a current negotiation --\n   are not invalid, although they are ignored\
    \ by the receiver.\n   An endpoint receiving an invalid Change option MUST respond\
    \ with the\n   corresponding empty Confirm option.  An endpoint receiving an invalid\n\
    \   Confirm option MUST reset the connection, with Reset Code 5, \"Option\n  \
    \ Error\".\n"
- title: 6.6.9.  Mandatory Feature Negotiation
  contents:
  - "6.6.9.  Mandatory Feature Negotiation\n   Change options may be preceded by Mandatory\
    \ options (Section 5.8.2).\n   Mandatory Change options are processed like normal\
    \ Change options\n   except that the following failure cases will cause the receiver\
    \ to\n   reset the connection with Reset Code 6, \"Mandatory Failure\", rather\n\
    \   than send a Confirm option.  The connection MUST be reset if:\n   o  the Change\
    \ option's feature number was not understood;\n   o  the Change option's value\
    \ was invalid, and the receiver would\n      normally have sent an empty Confirm\
    \ option in response; or\n   o  for server-priority features, there was no shared\
    \ entry in the two\n      endpoints' preference lists.\n   Other failure cases\
    \ do not cause connection reset; in particular,\n   reordering protection may\
    \ cause a Mandatory Change option to be\n   ignored without resetting the connection.\n\
    \   Confirm options behave identically and have the same reset conditions\n  \
    \ whether or not they are Mandatory.\n"
- title: 7.  Sequence Numbers
  contents:
  - "7.  Sequence Numbers\n   DCCP uses sequence numbers to arrange packets into sequence,\
    \ to\n   detect losses and network duplicates, and to protect against\n   attackers,\
    \ half-open connections, and the delivery of very old\n   packets.  Every packet\
    \ carries a Sequence Number; most packet types\n   carry an Acknowledgement Number\
    \ as well.\n   DCCP sequence numbers are packet based.  That is, Sequence Numbers\n\
    \   generated by each endpoint increase by one, modulo 2^48, per packet.\n   Even\
    \ DCCP-Ack and DCCP-Sync packets, and other packets that don't\n   carry user\
    \ data, increment the Sequence Number.  Since DCCP is an\n   unreliable protocol,\
    \ there are no true retransmissions, but effective\n   retransmissions, such as\
    \ retransmissions of DCCP-Request packets,\n   also increment the Sequence Number.\
    \  This lets DCCP implementations\n   detect network duplication, retransmissions,\
    \ and acknowledgement\n   loss; it is a significant departure from TCP practice.\n"
- title: 7.1.  Variables
  contents:
  - "7.1.  Variables\n   DCCP endpoints maintain a set of sequence number variables\
    \ for each\n   connection.\n   ISS     The Initial Sequence Number Sent by this\
    \ endpoint.  This\n           equals the Sequence Number of the first DCCP-Request\
    \ or\n           DCCP-Response sent.\n   ISR     The Initial Sequence Number Received\
    \ from the other endpoint.\n           This equals the Sequence Number of the\
    \ first DCCP-Request or\n           DCCP-Response received.\n   GSS     The Greatest\
    \ Sequence Number Sent by this endpoint.  Here,\n           and elsewhere, \"\
    greatest\" is measured in circular sequence\n           space.\n   GSR     The\
    \ Greatest Sequence Number Received from the other endpoint\n           on an\
    \ acknowledgeable packet.  (Section 7.4 defines this\n           term.)\n   GAR\
    \     The Greatest Acknowledgement Number Received from the other\n          \
    \ endpoint on an acknowledgeable packet that was not a DCCP-\n           Sync.\n\
    \   Some other variables are derived from these primitives.\n   SWL and SWH\n\
    \           (Sequence Number Window Low and High)  The extremes of the\n     \
    \      validity window for received packets' Sequence Numbers.\n   AWL and AWH\n\
    \           (Acknowledgement Number Window Low and High)  The extremes of\n  \
    \         the validity window for received packets' Acknowledgement\n        \
    \   Numbers.\n"
- title: 7.2.  Initial Sequence Numbers
  contents:
  - "7.2.  Initial Sequence Numbers\n   The endpoints' initial sequence numbers are\
    \ set by the first DCCP-\n   Request and DCCP-Response packets sent.  Initial\
    \ sequence numbers\n   MUST be chosen to avoid two problems:\n   o  delivery of\
    \ old packets, where packets lingering in the network\n      from an old connection\
    \ are delivered to a new connection with the\n      same addresses and port numbers;\
    \ and\n   o  sequence number attacks, where an attacker can guess the sequence\n\
    \      numbers that a future connection would use [M85].\n   These problems are\
    \ the same as those faced by TCP, and DCCP\n   implementations SHOULD use TCP's\
    \ strategies to avoid them [RFC793,\n   RFC1948].  The rest of this section explains\
    \ these strategies in more\n   detail.\n   To address the first problem, an implementation\
    \ MUST ensure that the\n   initial sequence number for a given <source address,\
    \ source port,\n   destination address, destination port> 4-tuple doesn't overlap\
    \ with\n   recent sequence numbers on previous connections with the same\n   4-tuple.\
    \  (\"Recent\" means sent within 2 maximum segment lifetimes, or\n   4 minutes.)\
    \  The implementation MUST additionally ensure that the\n   lower 24 bits of the\
    \ initial sequence number don't overlap with the\n   lower 24 bits of recent sequence\
    \ numbers (unless the implementation\n   plans to avoid short sequence numbers;\
    \ see Section 7.6).  An\n   implementation that has state for a recent connection\
    \ with the same\n   4-tuple can pick a good initial sequence number explicitly.\n\
    \   Otherwise, it could tie initial sequence number selection to some\n   clock,\
    \ such as the 4-microsecond clock used by TCP [RFC793].  Two\n   separate clocks\
    \ may be required, one for the upper 24 bits and one\n   for the lower 24 bits.\n\
    \   To address the second problem, an implementation MUST provide each\n   4-tuple\
    \ with an independent initial sequence number space.  Then,\n   opening a connection\
    \ doesn't provide any information about initial\n   sequence numbers on other\
    \ connections to the same host.  [RFC1948]\n   achieves this by adding a cryptographic\
    \ hash of the 4-tuple and a\n   secret to each initial sequence number.  For the\
    \ secret, [RFC1948]\n   recommends a combination of some truly random data [RFC4086],\
    \ an\n   administratively installed passphrase, the endpoint's IP address, and\n\
    \   the endpoint's boot time, but truly random data is sufficient.  Care\n   should\
    \ be taken when the secret is changed; such a change alters all\n   initial sequence\
    \ number spaces, which might make an initial sequence\n   number for some 4-tuple\
    \ equal a recently sent sequence number for the\n   same 4-tuple.  To avoid this\
    \ problem, the endpoint might remember\n   dead connection state for each 4-tuple\
    \ or stay quiet for 2 maximum\n   segment lifetimes around such a change.\n"
- title: 7.3.  Quiet Time
  contents:
  - "7.3.  Quiet Time\n   DCCP endpoints, like TCP endpoints, must take care before\
    \ initiating\n   connections when they boot.  In particular, they MUST NOT send\n\
    \   packets whose sequence numbers are close to the sequence numbers of\n   packets\
    \ lingering in the network from before the boot.  The simplest\n   way to enforce\
    \ this rule is for DCCP endpoints to avoid sending any\n   packets until one maximum\
    \ segment lifetime (2 minutes) after boot.\n   Other enforcement mechanisms include\
    \ remembering recent sequence\n   numbers across boots and reserving the upper\
    \ 8 or so bits of initial\n   sequence numbers for a persistent counter that decrements\
    \ by two each\n   boot.  (The latter mechanism would require disallowing packets\
    \ with\n   short sequence numbers; see Section 7.6.1.)\n"
- title: 7.4.  Acknowledgement Numbers
  contents:
  - "7.4.  Acknowledgement Numbers\n   Cumulative acknowledgements are meaningless\
    \ in an unreliable\n   protocol.  Therefore, DCCP's Acknowledgement Number field\
    \ has a\n   different meaning from TCP's.\n   A received packet is classified\
    \ as acknowledgeable if and only if its\n   header was successfully processed\
    \ by the receiving DCCP.  In terms of\n   the pseudocode in Section 8.5, a received\
    \ packet becomes\n   acknowledgeable when the receiving endpoint reaches Step\
    \ 8.  This\n   means, for example, that all acknowledgeable packets have valid\n\
    \   header checksums and sequence numbers.  A sent packet's\n   Acknowledgement\
    \ Number MUST equal the sending endpoint's GSR, the\n   Greatest Sequence Number\
    \ Received on an acknowledgeable packet, for\n   all packet types except DCCP-Sync\
    \ and DCCP-SyncAck.\n   \"Acknowledgeable\" does not refer to data processing.\
    \  Even\n   acknowledgeable packets may have their application data dropped, due\n\
    \   to receive buffer overflow or corruption, for instance.  Data Dropped\n  \
    \ options report these data losses when necessary, letting congestion\n   control\
    \ mechanisms distinguish between network losses and endpoint\n   losses.  This\
    \ issue is discussed further in Sections 11.4 and 11.7.\n   DCCP-Sync and DCCP-SyncAck\
    \ packets' Acknowledgement Numbers differ as\n   follows: The Acknowledgement\
    \ Number on a DCCP-Sync packet corresponds\n   to a received packet, but not necessarily\
    \ to an acknowledgeable\n   packet; in particular, it might correspond to an out-of-sync\
    \ packet\n   whose options were not processed.  The Acknowledgement Number on\
    \ a\n   DCCP-SyncAck packet always corresponds to an acknowledgeable DCCP-\n \
    \  Sync packet; it might be less than GSR in the presence of reordering.\n"
- title: 7.5.  Validity and Synchronization
  contents:
  - "7.5.  Validity and Synchronization\n   Any DCCP endpoint might receive packets\
    \ that are not actually part of\n   the current connection.  For instance, the\
    \ network might deliver an\n   old packet, an attacker might attempt to hijack\
    \ a connection, or the\n   other endpoint might crash, causing a half-open connection.\n\
    \   DCCP, like TCP, uses sequence number checks to detect these cases.\n   Packets\
    \ whose Sequence and/or Acknowledgement Numbers are out of\n   range are called\
    \ sequence-invalid and are not processed normally.\n   Unlike TCP, DCCP requires\
    \ a synchronization mechanism to recover from\n   large bursts of loss.  One endpoint\
    \ might send so many packets during\n   a burst of loss that when one of its packets\
    \ finally got through, the\n   other endpoint would label its Sequence Number\
    \ as invalid.  A\n   handshake of DCCP-Sync and DCCP-SyncAck packets recovers\
    \ from this\n   case.\n"
- title: 7.5.1.  Sequence and Acknowledgement Number Windows
  contents:
  - "7.5.1.  Sequence and Acknowledgement Number Windows\n   Each DCCP endpoint defines\
    \ sequence validity windows that are subsets\n   of the Sequence and Acknowledgement\
    \ Number spaces.  These windows\n   correspond to packets the endpoint expects\
    \ to receive in the next few\n   round-trip times.  The Sequence and Acknowledgement\
    \ Number windows\n   always contain GSR and GSS, respectively.  The window widths\
    \ are\n   controlled by Sequence Window features for the two half-connections.\n\
    \   The Sequence Number validity window for packets from DCCP B is [SWL,\n   SWH].\
    \  This window always contains GSR, the Greatest Sequence Number\n   Received\
    \ on a sequence-valid packet from DCCP B.  It is W packets\n   wide, where W is\
    \ the value of the Sequence Window/B feature.  One-\n   fourth of the sequence\
    \ window, rounded down, is less than or equal to\n   GSR, and three-fourths is\
    \ greater than GSR.  (This asymmetric\n   placement assumes that bursts of loss\
    \ are more common in the network\n   than significant reorderings.)\n     invalid\
    \  |       valid Sequence Numbers        |  invalid\n   <---------*|*===========*=======================*|*--------->\n\
    \         GSR -|GSR + 1 -   GSR                 GSR +|GSR + 1 +\n    floor(W/4)|floor(W/4)\
    \                 ceil(3W/4)|ceil(3W/4)\n               = SWL                \
    \           = SWH\n   The Acknowledgement Number validity window for packets from\
    \ DCCP B is\n   [AWL, AWH].  The high end of the window, AWH, equals GSS, the\n\
    \   Greatest Sequence Number Sent by DCCP A; the window is W' packets\n   wide,\
    \ where W' is the value of the Sequence Window/A feature.\n     invalid  |   \
    \ valid Acknowledgement Numbers    |  invalid\n   <---------*|*===================================*|*--------->\n\
    \      GSS - W'|GSS + 1 - W'                      GSS|GSS + 1\n              \
    \ = AWL                           = AWH\n   SWL and AWL are initially adjusted\
    \ so that they are not less than the\n   initial Sequence Numbers received and\
    \ sent, respectively:\n         SWL := max(GSR + 1 - floor(W/4), ISR),\n     \
    \    AWL := max(GSS + 1 - W', ISS).\n   These adjustments MUST be applied only\
    \ at the beginning of the\n   connection.  (Long-lived connections may wrap sequence\
    \ numbers so\n   that they appear to be less than ISR or ISS; the adjustments\
    \ MUST NOT\n   be applied in that case.)\n"
- title: 7.5.2.  Sequence Window Feature
  contents:
  - "7.5.2.  Sequence Window Feature\n   The Sequence Window/A feature determines\
    \ the width of the Sequence\n   Number validity window used by DCCP B and the\
    \ width of the\n   Acknowledgement Number validity window used by DCCP A.  DCCP\
    \ A sends\n   a \"Change L(Sequence Window, W)\" option to notify DCCP B that\
    \ the\n   Sequence Window/A value is W.\n   Sequence Window has feature number\
    \ 3 and is non-negotiable.  It takes\n   48-bit (6-byte) integer values, like\
    \ DCCP sequence numbers.  Change\n   and Confirm options for Sequence Window are\
    \ therefore 9 bytes long.\n   New connections start with Sequence Window 100 for\
    \ both endpoints.\n   The minimum valid Sequence Window value is Wmin = 32.  The\
    \ maximum\n   valid Sequence Window value is Wmax = 2^46 - 1 = 70368744177663.\n\
    \   Change options suggesting Sequence Window values out of this range\n   are\
    \ invalid and MUST be handled accordingly.\n   A proper Sequence Window/A value\
    \ must reflect the number of packets\n   DCCP A expects to be in flight.  Only\
    \ DCCP A can anticipate this\n   number.  Values that are too small increase the\
    \ risk of the endpoints\n   getting out sync after bursts of loss, and values\
    \ that are much too\n   small can prevent productive communication whether or\
    \ not there is\n   loss.  On the other hand, too-large values increase the risk\
    \ of\n   connection hijacking; Section 7.5.5 quantifies this risk.  One good\n\
    \   guideline is for each endpoint to set Sequence Window to about five\n   times\
    \ the maximum number of packets it expects to send in a round-\n   trip time.\
    \  Endpoints SHOULD send Change L(Sequence Window) options,\n   as necessary,\
    \ as the connection progresses.  Also, an endpoint MUST\n   NOT persistently send\
    \ more than its Sequence Window number of packets\n   per round-trip time; that\
    \ is, DCCP A MUST NOT persistently send more\n   than Sequence Window/A packets\
    \ per RTT.\n"
- title: 7.5.3.  Sequence-Validity Rules
  contents:
  - "7.5.3.  Sequence-Validity Rules\n   Sequence-validity depends on the received\
    \ packet's type.  This table\n   shows the sequence and acknowledgement number\
    \ checks applied to each\n   packet; a packet is sequence-valid if it passes both\
    \ tests, and\n   sequence-invalid if it does not.  Many of the checks refer to\
    \ the\n   sequence and acknowledgement number validity windows [SWL, SWH] and\n\
    \   [AWL, AWH] defined in Section 7.5.1.\n                                   \
    \          Acknowledgement Number\n   Packet Type      Sequence Number Check \
    \   Check\n   -----------      ---------------------    ----------------------\n\
    \   DCCP-Request     SWL <= seqno <= SWH (*)  N/A\n   DCCP-Response    SWL <=\
    \ seqno <= SWH (*)  AWL <= ackno <= AWH\n   DCCP-Data        SWL <= seqno <= SWH\
    \      N/A\n   DCCP-Ack         SWL <= seqno <= SWH      AWL <= ackno <= AWH\n\
    \   DCCP-DataAck     SWL <= seqno <= SWH      AWL <= ackno <= AWH\n   DCCP-CloseReq\
    \    GSR <  seqno <= SWH      GAR <= ackno <= AWH\n   DCCP-Close       GSR < \
    \ seqno <= SWH      GAR <= ackno <= AWH\n   DCCP-Reset       GSR <  seqno <= SWH\
    \      GAR <= ackno <= AWH\n   DCCP-Sync        SWL <= seqno             AWL <=\
    \ ackno <= AWH\n   DCCP-SyncAck     SWL <= seqno             AWL <= ackno <= AWH\n\
    \   (*) Check not applied if connection is in LISTEN or REQUEST state.\n   In\
    \ general, packets are sequence-valid if their Sequence and\n   Acknowledgement\
    \ Numbers lie within the corresponding valid windows,\n   [SWL, SWH] and [AWL,\
    \ AWH].  The exceptions to this rule are as\n   follows:\n   o  Since DCCP-CloseReq,\
    \ DCCP-Close, and DCCP-Reset packets end a\n      connection, they cannot have\
    \ Sequence Numbers less than or equal\n      to GSR, or Acknowledgement Numbers\
    \ less than GAR.\n   o  DCCP-Sync and DCCP-SyncAck Sequence Numbers are not strongly\n\
    \      checked.  These packet types exist specifically to get the\n      endpoints\
    \ back into sync; checking their Sequence Numbers would\n      eliminate their\
    \ usefulness.\n   The lenient checks on DCCP-Sync and DCCP-SyncAck packets allow\n\
    \   continued operation after unusual events, such as endpoint crashes\n   and\
    \ large bursts of loss, but there's no need for leniency in the\n   absence of\
    \ unusual events -- that is, during ongoing successful\n   communication.  Therefore,\
    \ DCCP implementations SHOULD use the\n   following, more stringent checks for\
    \ active connections, where a\n   connection is considered active if it has received\
    \ valid packets from\n   the other endpoint within the last three round-trip times.\n\
    \                                             Acknowledgement Number\n   Packet\
    \ Type      Sequence Number Check    Check\n   -----------      ---------------------\
    \    ----------------------\n   DCCP-Sync        SWL <= seqno <= SWH      AWL\
    \ <= ackno <= AWH\n   DCCP-SyncAck     SWL <= seqno <= SWH      AWL <= ackno <=\
    \ AWH\n   Finally, an endpoint MAY apply the following more stringent checks to\n\
    \   DCCP-CloseReq, DCCP-Close, and DCCP-Reset packets, further lowering\n   the\
    \ probability of successful blind attacks using those packet types.\n   Since\
    \ these checks can cause extra synchronization overhead and delay\n   connection\
    \ closing when packets are lost, they should be considered\n   experimental.\n\
    \                                             Acknowledgement Number\n   Packet\
    \ Type      Sequence Number Check    Check\n   -----------      ---------------------\
    \    ----------------------\n   DCCP-CloseReq    seqno == GSR + 1         GAR\
    \ <= ackno <= AWH\n   DCCP-Close       seqno == GSR + 1         GAR <= ackno <=\
    \ AWH\n   DCCP-Reset       seqno == GSR + 1         GAR <= ackno <= AWH\n   Note\
    \ that sequence-validity is only one of the validity checks\n   applied to received\
    \ packets.\n"
- title: 7.5.4.  Handling Sequence-Invalid Packets
  contents:
  - "7.5.4.  Handling Sequence-Invalid Packets\n   Endpoints respond to received sequence-invalid\
    \ packets as follows.\n   o  Any sequence-invalid DCCP-Sync or DCCP-SyncAck packet\
    \ MUST be\n      ignored.\n   o  A sequence-invalid DCCP-Reset packet MUST elicit\
    \ a DCCP-Sync\n      packet in response (subject to a possible rate limit).  This\n\
    \      response packet MUST use a new Sequence Number, and thus will\n      increase\
    \ GSS; GSR will not change, however, since the received\n      packet was sequence-invalid.\
    \  The response packet's\n      Acknowledgement Number MUST equal GSR.\n   o \
    \ Any other sequence-invalid packet MUST elicit a similar DCCP-Sync\n      packet,\
    \ except that the response packet's Acknowledgement Number\n      MUST equal the\
    \ sequence-invalid packet's Sequence Number.\n   On receiving a sequence-valid\
    \ DCCP-Sync packet, the peer endpoint\n   (say, DCCP B) MUST update its GSR variable\
    \ and reply with a DCCP-\n   SyncAck packet.  The DCCP-SyncAck packet's Acknowledgement\
    \ Number\n   will equal the DCCP-Sync's Sequence Number, which is not necessarily\n\
    \   GSR.  Upon receiving this DCCP-SyncAck, which will be sequence-valid\n   since\
    \ it acknowledges the DCCP-Sync, DCCP A will update its GSR\n   variable, and\
    \ the endpoints will be back in sync.  As an exception,\n   if the peer endpoint\
    \ is in the REQUEST state, it MUST respond with a\n   DCCP-Reset instead of a\
    \ DCCP-SyncAck.  This serves to clean up DCCP\n   A's half-open connection.\n\
    \   To protect against denial-of-service attacks, DCCP implementations\n   SHOULD\
    \ impose a rate limit on DCCP-Syncs sent in response to\n   sequence-invalid packets,\
    \ such as not more than eight DCCP-Syncs per\n   second.\n   DCCP endpoints MUST\
    \ NOT process sequence-invalid packets except,\n   perhaps, by generating a DCCP-Sync.\
    \  For instance, options MUST NOT\n   be processed.  An endpoint MAY temporarily\
    \ preserve sequence-invalid\n   packets in case they become valid later, however;\
    \ this can reduce the\n   impact of bursts of loss by delivering more packets\
    \ to the\n   application.  In particular, an endpoint MAY preserve sequence-\n\
    \   invalid packets for up to 2 round-trip times.  If, within that time,\n   the\
    \ relevant sequence windows change so that the packets become\n   sequence-valid,\
    \ the endpoint MAY process them again.\n   Note that sequence-invalid DCCP-Reset\
    \ packets cause DCCP-Syncs to be\n   generated.  This is because endpoints in\
    \ an unsynchronized state\n   (CLOSED, REQUEST, and LISTEN) might not have enough\
    \ information to\n   generate a proper DCCP-Reset on the first try.  For example,\
    \ if a\n   peer endpoint is in CLOSED state and receives a DCCP-Data packet, it\n\
    \   cannot guess the right Sequence Number to use on the DCCP-Reset it\n   generates\
    \ (since the DCCP-Data packet has no Acknowledgement Number).\n   The DCCP-Sync\
    \ generated in response to this bad reset serves as a\n   challenge, and contains\
    \ enough information for the peer to generate a\n   proper DCCP-Reset.  However,\
    \ the new DCCP-Reset may carry a different\n   Reset Code than the original DCCP-Reset;\
    \ probably the new Reset Code\n   will be 3, \"No Connection\".  The endpoint\
    \ SHOULD use information from\n   the original DCCP-Reset when possible.\n"
- title: 7.5.5.  Sequence Number Attacks
  contents:
  - "7.5.5.  Sequence Number Attacks\n   Sequence and Acknowledgement Numbers form\
    \ DCCP's main line of defense\n   against attackers.  An attacker that cannot\
    \ guess sequence numbers\n   cannot easily manipulate or hijack a DCCP connection,\
    \ and\n   requirements like careful initial sequence number choice eliminate\n\
    \   the most serious attacks.\n   An attacker might still send many packets with\
    \ randomly chosen\n   Sequence and Acknowledgement Numbers, however.  If one of\
    \ those\n   probes ends up sequence-valid, it may shut down the connection or\n\
    \   otherwise cause problems.  The easiest such attacks to execute are as\n  \
    \ follows:\n   o  Send DCCP-Data packets with random Sequence Numbers.  If one\
    \ of\n      these packets hits the valid sequence number window, the attack\n\
    \      packet's application data may be inserted into the data stream.\n   o \
    \ Send DCCP-Sync packets with random Sequence and Acknowledgement\n      Numbers.\
    \  If one of these packets hits the valid acknowledgement\n      number window,\
    \ the receiver will shift its sequence number window\n      accordingly, getting\
    \ out of sync with the correct endpoint --\n      perhaps permanently.\n   The\
    \ attacker has to guess both Source and Destination Ports for any\n   of these\
    \ attacks to succeed.  Additionally, the connection would have\n   to be inactive\
    \ for the DCCP-Sync attack to succeed, assuming the\n   victim implemented the\
    \ more stringent checks for active connections\n   recommended in Section 7.5.3.\n\
    \   To quantify the probability of success, let N be the number of attack\n  \
    \ packets the attacker is willing to send, W be the relevant sequence\n   window\
    \ width, and L be the length of sequence numbers (24 or 48).\n   The attacker's\
    \ best strategy is to space the attack packets evenly\n   over sequence space.\
    \  Then the probability of hitting one sequence\n   number window is P = WN/2^L.\n\
    \   The success probability for a DCCP-Data attack using short sequence\n   numbers\
    \ thus equals P = WN/2^24.  For W = 100, then, the attacker\n   must send more\
    \ than 83,000 packets to achieve a 50% chance of\n   success.  For reference,\
    \ the easiest TCP attack -- sending a SYN with\n   a random sequence number, which\
    \ will cause a connection reset if it\n   falls within the window -- with W =\
    \ 8760 (a common default) and\n   L = 32 requires more than 245,000 packets to\
    \ achieve a 50% chance of\n   success.\n   A fast connection's W will generally\
    \ be high, increasing the attack\n   success probability for fixed N.  If this\
    \ probability gets\n   uncomfortably high with L = 24, the endpoint SHOULD prevent\
    \ the use\n   of short sequence numbers by manipulating the Allow Short Sequence\n\
    \   Numbers feature (see Section 7.6.1).  The probability limit depends\n   on\
    \ the application, however.  Some applications, such as those\n   already designed\
    \ to handle corruption, are quite resilient to data\n   injection attacks.\n \
    \  The DCCP-Sync attack has L = 48, since DCCP-Sync packets use long\n   sequence\
    \ numbers exclusively; in addition, the success probability is\n   halved, since\
    \ only half the Sequence Number space is valid.  Attacks\n   have a correspondingly\
    \ smaller probability of success.  For a large W\n   of 2000 packets, then, the\
    \ attacker must send more than 10^11 packets\n   to achieve a 50% chance of success.\n\
    \   Attacks involving DCCP-Ack, DCCP-DataAck, DCCP-CloseReq, DCCP-Close,\n   and\
    \ DCCP-Reset packets are more difficult, since Sequence and\n   Acknowledgement\
    \ Numbers must both be guessed.  The probability of\n   attack success for these\
    \ packet types equals P = WXN/2^(2L), where W\n   is the Sequence Number window,\
    \ X is the Acknowledgement Number\n   window, and N and L are as before.\n   Since\
    \ DCCP-Data attacks with short sequence numbers are relatively\n   easy for attackers\
    \ to execute, DCCP has been engineered to prevent\n   these attacks from escalating\
    \ to connection resets or other serious\n   consequences.  In particular, any\
    \ options whose processing might\n   cause the connection to be reset are ignored\
    \ when they appear on\n   DCCP-Data packets.\n"
- title: 7.5.6.  Sequence Number Handling Examples
  contents:
  - "7.5.6.  Sequence Number Handling Examples\n   In the following example, DCCP\
    \ A and DCCP B recover from a large\n   burst of loss that runs DCCP A's sequence\
    \ numbers out of DCCP B's\n   appropriate sequence number window.\n   DCCP A \
    \                                          DCCP B\n   (GSS=1,GSR=10)         \
    \                          (GSS=10,GSR=1)\n               -->   DCCP-Data(seq\
    \ 2)     XXX\n                         ...\n               -->   DCCP-Data(seq\
    \ 100)   XXX\n               -->   DCCP-Data(seq 101)           -->  ???\n   \
    \                                                 seqno out of range;\n      \
    \                                              send Sync\n      OK       <-- \
    \  DCCP-Sync(seq 11, ack 101)   <--\n                                        \
    \            (GSS=11,GSR=1)\n               -->   DCCP-SyncAck(seq 102, ack 11)\
    \   -->   OK\n   (GSS=102,GSR=11)                                 (GSS=11,GSR=102)\n\
    \   In the next example, a DCCP connection recovers from a simple blind\n   attack.\n\
    \   DCCP A                                           DCCP B\n   (GSS=1,GSR=10)\
    \                                   (GSS=10,GSR=1)\n                *ATTACKER*\
    \  -->  DCCP-Data(seq 10^6)  -->  ???\n                                      \
    \              seqno out of range;\n                                         \
    \           send Sync\n      ???      <--   DCCP-Sync(seq 11, ack 10^6)  <--\n\
    \   ackno out of range; ignore\n   (GSS=1,GSR=10)                            \
    \       (GSS=11,GSR=1)\n   The final example demonstrates recovery from a half-open\
    \ connection.\n   DCCP A                                           DCCP B\n  \
    \ (GSS=1,GSR=10)                                   (GSS=10,GSR=1)\n   (Crash)\n\
    \   CLOSED                                               OPEN\n   REQUEST    \
    \ -->   DCCP-Request(seq 400)        -->   ???\n   !!          <--   DCCP-Sync(seq\
    \ 11, ack 400)   <--   OPEN\n   REQUEST     -->   DCCP-Reset(seq 401, ack 11)\
    \  -->   (Abort)\n   REQUEST                                              CLOSED\n\
    \   REQUEST     -->   DCCP-Request(seq 402)        -->   ...\n"
- title: 7.6.  Short Sequence Numbers
  contents:
  - "7.6.  Short Sequence Numbers\n   DCCP sequence numbers are 48 bits long.  This\
    \ large sequence space\n   protects DCCP connections against some blind attacks,\
    \ such as the\n   injection of DCCP-Resets into the connection.  However, DCCP-Data,\n\
    \   DCCP-Ack, and DCCP-DataAck packets, which make up the body of any\n   DCCP\
    \ connection, may reduce header space by transmitting only the\n   lower 24 bits\
    \ of the relevant Sequence and Acknowledgement Numbers.\n   The receiving endpoint\
    \ will extend these numbers to 48 bits using the\n   following pseudocode:\n \
    \  procedure Extend_Sequence_Number(S, REF)\n      /* S is a 24-bit sequence number\
    \ from the packet header.\n         REF is the relevant 48-bit reference sequence\
    \ number:\n         GSS if S is an Acknowledgement Number, and GSR if S is a\n\
    \         Sequence Number. */\n      Set REF_low := low 24 bits of REF\n     \
    \ Set REF_hi := high 24 bits of REF\n      If REF_low (<) S           /* circular\
    \ comparison mod 2^24 */\n            and S |<| REF_low,   /* conventional, non-circular\n\
    \                                    comparison */\n         Return (((REF_hi\
    \ + 1) mod 2^24) << 24) | S\n      Otherwise, if S (<) REF_low and REF_low |<|\
    \ S,\n         Return (((REF_hi - 1) mod 2^24) << 24) | S\n      Otherwise,\n\
    \         Return (REF_hi << 24) | S\n   The two different kinds of comparison\
    \ in the if statements detect\n   when the low-order bits of the sequence space\
    \ have wrapped.  (The\n   circular comparison \"REF_low (<) S\" returns true if\
    \ and only if\n   (S - REF_low), calculated using two's-complement arithmetic\
    \ and then\n   represented as an unsigned number, is less than or equal to 2^23\n\
    \   (mod 2^24).)  When this happens, the high-order bits are incremented\n   or\
    \ decremented, as appropriate.\n"
- title: 7.6.1.  Allow Short Sequence Numbers Feature
  contents:
  - "7.6.1.  Allow Short Sequence Numbers Feature\n   Endpoints can require that all\
    \ packets use long sequence numbers by\n   leaving the Allow Short Sequence Numbers\
    \ feature value at its default\n   of zero.  This can reduce the risk that data\
    \ will be inappropriately\n   injected into the connection.  DCCP A sends a \"\
    Change L(Allow Short\n   Seqnos, 1)\" option to indicate its desire to send packets\
    \ with short\n   sequence numbers.\n   Allow Short Sequence Numbers has feature\
    \ number 2 and is server-\n   priority.  It takes one-byte Boolean values.  When\
    \ Allow Short\n   Seqnos/B is zero, DCCP B MUST NOT send packets with short sequence\n\
    \   numbers and DCCP A MUST ignore any packets with short sequence\n   numbers\
    \ that are received.  Values of two or more are reserved.  New\n   connections\
    \ start with Allow Short Sequence Numbers 0 for both\n   endpoints.\n"
- title: 7.6.2.  When to Avoid Short Sequence Numbers
  contents:
  - "7.6.2.  When to Avoid Short Sequence Numbers\n   Short sequence numbers reduce\
    \ the rate DCCP connections can safely\n   achieve and increase the risks of certain\
    \ kinds of attacks, including\n   blind data injection.  Very-high-rate DCCP connections,\
    \ and\n   connections with large sequence windows (Section 7.5.2), SHOULD NOT\n\
    \   use short sequence numbers on their data packets.  The attack risk\n   issues\
    \ have been discussed in Section 7.5.5; we discuss the rate\n   limitation issue\
    \ here.\n   The sequence-validity mechanism assumes that the network does not\n\
    \   deliver extremely old data.  In particular, it assumes that the\n   network\
    \ must have dropped any packet by the time the connection wraps\n   around and\
    \ uses its sequence number again.  This constraint limits\n   the maximum connection\
    \ rate that can be safely achieved.  Let MSL\n   equal the maximum segment lifetime,\
    \ P equal the average DCCP packet\n   size in bits, and L equal the length of\
    \ sequence numbers (24 or 48\n   bits).  Then the maximum safe rate, in bits per\
    \ second, is\n   R = P*(2^L)/2MSL.\n   For the default MSL of 2 minutes, 1500-byte\
    \ DCCP packets, and short\n   sequence numbers, the safe rate is therefore approximately\
    \ 800 Mb/s.\n   Although 2 minutes is a very large MSL for any networks that could\n\
    \   sustain that rate with such small packets, long sequence numbers\n   allow\
    \ much higher rates under the same constraints: up to 14 petabits\n   a second\
    \ for 1500-byte packets and the default MSL.\n"
- title: 7.7.  NDP Count and Detecting Application Loss
  contents:
  - "7.7.  NDP Count and Detecting Application Loss\n   DCCP's sequence numbers increment\
    \ by one on every packet, including\n   non-data packets (packets that don't carry\
    \ application data).  This\n   makes DCCP sequence numbers suitable for detecting\
    \ any network loss,\n   but not for detecting the loss of application data.  The\
    \ NDP Count\n   option reports the length of each burst of non-data packets. \
    \ This\n   lets the receiving DCCP reliably determine when a burst of loss\n \
    \  included application data.\n   +--------+--------+-------- ... --------+\n\
    \   |00100101| Length |      NDP Count      |\n   +--------+--------+--------\
    \ ... --------+\n    Type=37  Len=3-8       (1-6 bytes)\n   If a DCCP endpoint's\
    \ Send NDP Count feature is one (see below), then\n   that endpoint MUST send\
    \ an NDP Count option on every packet whose\n   immediate predecessor was a non-data\
    \ packet.  Non-data packets\n   consist of DCCP packet types DCCP-Ack, DCCP-Close,\
    \ DCCP-CloseReq,\n   DCCP-Reset, DCCP-Sync, and DCCP-SyncAck.  The other packet\
    \ types,\n   namely DCCP-Request, DCCP-Response, DCCP-Data, and DCCP-DataAck,\
    \ are\n   considered data packets, although not all DCCP-Request and DCCP-\n \
    \  Response packets will actually carry application data.\n   The value stored\
    \ in NDP Count equals the number of consecutive non-\n   data packets in the run\
    \ immediately previous to the current packet.\n   Packets with no NDP Count option\
    \ are considered to have NDP Count\n   zero.\n   The NDP Count option can carry\
    \ one to six bytes of data.  The\n   smallest option format that can hold the\
    \ NDP Count SHOULD be used.\n   With NDP Count, the receiver can reliably tell\
    \ only whether a burst\n   of loss contained at least one data packet.  For example,\
    \ the\n   receiver cannot always tell whether a burst of loss contained a non-\n\
    \   data packet.\n"
- title: 7.7.1.  NDP Count Usage Notes
  contents:
  - "7.7.1.  NDP Count Usage Notes\n   Say that K consecutive sequence numbers are\
    \ missing in some burst of\n   loss, and that the Send NDP Count feature is on.\
    \  Then some\n   application data was lost within those sequence numbers unless\
    \ the\n   packet following the hole contains an NDP Count option whose value is\n\
    \   greater than or equal to K.\n   For example, say that an endpoint sent the\
    \ following sequence of\n   non-data packets (Nx) and data packets (Dx).\n   \
    \   N0  N1  D2  N3  D4  D5  N6  D7  D8  D9  D10 N11 N12 D13\n   Those packets\
    \ would have NDP Counts as follows.\n      N0  N1  D2  N3  D4  D5  N6  D7  D8\
    \  D9  D10 N11 N12 D13\n      -   1   2   -   1   -   -   1   -   -   -   -  \
    \ 1   2\n   NDP Count is not useful for applications that include their own\n\
    \   sequence numbers with their packet headers.\n"
- title: 7.7.2.  Send NDP Count Feature
  contents:
  - "7.7.2.  Send NDP Count Feature\n   The Send NDP Count feature lets DCCP endpoints\
    \ negotiate whether they\n   should send NDP Count options on their packets. \
    \ DCCP A sends a\n   \"Change R(Send NDP Count, 1)\" option to ask DCCP B to send\
    \ NDP Count\n   options.\n   Send NDP Count has feature number 7 and is server-priority.\
    \  It takes\n   one-byte Boolean values.  DCCP B MUST send NDP Count options as\n\
    \   described above when Send NDP Count/B is one, although it MAY send\n   NDP\
    \ Count options even when Send NDP Count/B is zero.  Values of two\n   or more\
    \ are reserved.  New connections start with Send NDP Count 0\n   for both endpoints.\n"
- title: 8.  Event Processing
  contents:
  - "8.  Event Processing\n   This section describes how DCCP connections move between\
    \ states and\n   which packets are sent when.  Note that feature negotiation takes\n\
    \   place in parallel with the connection-wide state transitions\n   described\
    \ here.\n"
- title: 8.1.  Connection Establishment
  contents:
  - "8.1.  Connection Establishment\n   DCCP connections' initiation phase consists\
    \ of a three-way handshake:\n   an initial DCCP-Request packet sent by the client,\
    \ a DCCP-Response\n   sent by the server in reply, and finally an acknowledgement\
    \ from the\n   client, usually via a DCCP-Ack or DCCP-DataAck packet.  The client\n\
    \   moves from the REQUEST state to PARTOPEN, and finally to OPEN; the\n   server\
    \ moves from LISTEN to RESPOND, and finally to OPEN.\n     Client State      \
    \                       Server State\n        CLOSED                         \
    \          LISTEN\n   1.   REQUEST   -->       Request        -->\n   2.     \
    \        <--       Response       <--   RESPOND\n   3.   PARTOPEN  -->     Ack,\
    \ DataAck     -->\n   4.             <--  Data, Ack, DataAck  <--   OPEN\n   5.\
    \   OPEN      <->  Data, Ack, DataAck  <->   OPEN\n"
- title: 8.1.1.  Client Request
  contents:
  - "8.1.1.  Client Request\n   When a client decides to initiate a connection, it\
    \ enters the REQUEST\n   state, chooses an initial sequence number (Section 7.2),\
    \ and sends a\n   DCCP-Request packet using that sequence number to the intended\n\
    \   server.\n   DCCP-Request packets will commonly carry feature negotiation options\n\
    \   that open negotiations for various connection parameters, such as\n   preferred\
    \ congestion control IDs for each half-connection.  They may\n   also carry application\
    \ data, but the client should be aware that the\n   server may not accept such\
    \ data.\n   A client in the REQUEST state SHOULD use an exponential-backoff timer\n\
    \   to send new DCCP-Request packets if no response is received.  The\n   first\
    \ retransmission should occur after approximately one second,\n   backing off\
    \ to not less than one packet every 64 seconds; or the\n   endpoint can use whatever\
    \ retransmission strategy is followed for\n   retransmitting TCP SYNs.  Each new\
    \ DCCP-Request MUST increment the\n   Sequence Number by one and MUST contain\
    \ the same Service Code and\n   application data as the original DCCP-Request.\n\
    \   A client MAY give up on its DCCP-Requests after some time (3 minutes,\n  \
    \ for example).  When it does, it SHOULD send a DCCP-Reset packet to\n   the server\
    \ with Reset Code 2, \"Aborted\", to clean up state in case\n   one or more of\
    \ the Requests actually arrived.  A client in REQUEST\n   state has never received\
    \ an initial sequence number from its peer, so\n   the DCCP-Reset's Acknowledgement\
    \ Number MUST be set to zero.\n   The client leaves the REQUEST state for PARTOPEN\
    \ when it receives a\n   DCCP-Response from the server.\n"
- title: 8.1.2.  Service Codes
  contents:
  - "8.1.2.  Service Codes\n   Each DCCP-Request contains a 32-bit Service Code, which\
    \ identifies\n   the application-level service to which the client application\
    \ is\n   trying to connect.  Service Codes should correspond to application\n\
    \   services and protocols.  For example, there might be a Service Code\n   for\
    \ SIP control connections and one for RTP audio connections.\n   Middleboxes,\
    \ such as firewalls, can use the Service Code to identify\n   the application\
    \ running on a nonstandard port (assuming the DCCP\n   header has not been encrypted).\n\
    \   Endpoints MUST associate a Service Code with every DCCP socket, both\n   actively\
    \ and passively opened.  The application will generally supply\n   this Service\
    \ Code.  Each active socket MUST have exactly one Service\n   Code.  Passive sockets\
    \ MAY, at the implementation's discretion, be\n   associated with more than one\
    \ Service Code; this might let multiple\n   applications, or multiple versions\
    \ of the same application, listen on\n   the same port, differentiated by Service\
    \ Code.  If the DCCP-Request's\n   Service Code doesn't equal any of the server's\
    \ Service Codes for the\n   given port, the server MUST reject the request by\
    \ sending a DCCP-\n   Reset packet with Reset Code 8, \"Bad Service Code\".  A\
    \ middlebox MAY\n   also send such a DCCP-Reset in response to packets whose Service\
    \ Code\n   is considered unsuitable.\n   Service Codes are not intended to be\
    \ DCCP-specific and are allocated\n   by IANA.  Following the policies outlined\
    \ in [RFC2434], most Service\n   Codes are allocated First Come First Served,\
    \ subject to the following\n   guidelines.\n   o  Service Codes are allocated\
    \ one at a time, or in small blocks.  A\n      short English description of the\
    \ intended service is REQUIRED to\n      obtain a Service Code assignment, but\
    \ no specification, standards\n      track or otherwise, is necessary.  IANA maintains\
    \ an association\n      of Service Codes to the corresponding phrases.\n   o \
    \ Users request specific Service Code values.  We suggest that users\n      request\
    \ Service Codes that can be represented using the \"SC:\"\n      formatting convention\
    \ described below.  Thus, the \"Frobodyne Plotz\n      Protocol\" might correspond\
    \ to Service Code 17178548426 or,\n      equivalently, \"SC:fdpz\".  The canonical\
    \ interpretation of a\n      Service Code field is numeric.\n   o  Service Codes\
    \ whose bytes each have values in the set {32, 45-57,\n      65-90} use a Specification\
    \ Required allocation policy.  That is,\n      these Service Codes are used for\
    \ international standard or\n      standards-track specifications, IETF or otherwise.\
    \  (This set\n      consists of the ASCII digits, uppercase letters, and characters\n\
    \      space, '-', '.', and '/'.)\n   o  Service Codes whose high-order byte equals\
    \ 63 (ASCII '?') are\n      reserved for Private Use.\n   o  Service Code 0 represents\
    \ the absence of a meaningful Service Code\n      and MUST NOT be allocated.\n\
    \   o  The value 4294967295 is an invalid Service Code.  Servers MUST\n      reject\
    \ any DCCP-Request with this Service Code value by sending a\n      DCCP-Reset\
    \ packet with Reset Code 8, \"Bad Service Code\".\n   This design for Service\
    \ Code allocation is based on the allocation of\n   4-byte identifiers for Macintosh\
    \ resources, PNG chunks, and TrueType\n   and OpenType tables.\n   In text settings,\
    \ we recommend that Service Codes be written in one\n   of three forms, prefixed\
    \ by the ASCII letters SC and either a colon\n   \":\" or equals sign \"=\". \
    \ These forms are interpreted as follows.\n   SC:     Indicates a Service Code\
    \ representable using a subset of the\n           ASCII characters.  The colon\
    \ is followed by one to four\n           characters taken from the following set:\
    \ letters, digits, and\n           the characters in \"-_+.*/?@\" (not including\
    \ quotes).\n           Numerically, these characters have values in {42-43, 45-57,\n\
    \           63-90, 95, 97-122}.  The Service Code is calculated by\n         \
    \  padding the string on the right with spaces (value 32) and\n           intepreting\
    \ the four-character result as a 32-bit big-endian\n           number.\n   SC=\
    \     Indicates a decimal Service Code.  The equals sign is\n           followed\
    \ by any number of decimal digits, which specify the\n           Service Code.\
    \  Values above 4294967294 are illegal.\n   SC=x or SC=X\n           Indicates\
    \ a hexadecimal Service Code.  The \"x\" or \"X\" is\n           followed by any\
    \ number of hexadecimal digits (upper or lower\n           case), which specify\
    \ the Service Code.  Values above\n           4294967294 are illegal.\n   Thus,\
    \ the Service Code 1717858426 might be represented in text as\n   either SC:fdpz,\
    \ SC=1717858426, or SC=x6664707A.\n"
- title: 8.1.3.  Server Response
  contents:
  - "8.1.3.  Server Response\n   In the second phase of the three-way handshake, the\
    \ server moves from\n   the LISTEN state to RESPOND and sends a DCCP-Response\
    \ message to the\n   client.  In this phase, a server will often specify the features\
    \ it\n   would like to use, either from among those the client requested or in\n\
    \   addition to those.  Among these options is the congestion control\n   mechanism\
    \ the server expects to use.\n   The server MAY respond to a DCCP-Request packet\
    \ with a DCCP-Reset\n   packet to refuse the connection.  Relevant Reset Codes\
    \ for refusing a\n   connection include 7, \"Connection Refused\", when the DCCP-Request's\n\
    \   Destination Port did not correspond to a DCCP port open for\n   listening;\
    \ 8, \"Bad Service Code\", when the DCCP-Request's Service\n   Code did not correspond\
    \ to the service code registered with the\n   Destination Port; and 9, \"Too Busy\"\
    , when the server is currently too\n   busy to respond to requests.  The server\
    \ SHOULD limit the rate at\n   which it generates these resets; for example, to\
    \ not more than 1024\n   per second.\n   The server SHOULD NOT retransmit DCCP-Response\
    \ packets; the client\n   will retransmit the DCCP-Request if necessary.  (Note\
    \ that the\n   \"retransmitted\" DCCP-Request will have, at least, a different\n\
    \   sequence number from the \"original\" DCCP-Request.  The server can\n   thus\
    \ distinguish true retransmissions from network duplicates.)  The\n   server will\
    \ detect that the retransmitted DCCP-Request applies to an\n   existing connection\
    \ because of its Source and Destination Ports.\n   Every valid DCCP-Request received\
    \ while the server is in the RESPOND\n   state MUST elicit a new DCCP-Response.\
    \  Each new DCCP-Response MUST\n   increment the server's Sequence Number by one\
    \ and MUST include the\n   same application data, if any, as the original DCCP-Response.\n\
    \   The server MUST NOT accept more than one piece of DCCP-Request\n   application\
    \ data per connection.  In particular, the DCCP-Response\n   sent in reply to\
    \ a retransmitted DCCP-Request with application data\n   SHOULD contain a Data\
    \ Dropped option, in which the retransmitted\n   DCCP-Request data is reported\
    \ with Drop Code 0, Protocol Constraints.\n   The original DCCP-Request SHOULD\
    \ also be reported in the Data Dropped\n   option, either in a Normal Block (if\
    \ the server accepted the data or\n   there was no data) or in a Drop Code 0 Drop\
    \ Block (if the server\n   refused the data the first time as well).\n   The Data\
    \ Dropped and Init Cookie options are particularly useful for\n   DCCP-Response\
    \ packets (Sections 11.7 and 8.1.4).\n   The server leaves the RESPOND state for\
    \ OPEN when it receives a valid\n   DCCP-Ack from the client, completing the three-way\
    \ handshake.  It MAY\n   also leave the RESPOND state for CLOSED after a timeout\
    \ of not less\n   than 4MSL (8 minutes); when doing so, it SHOULD send a DCCP-Reset\n\
    \   with Reset Code 2, \"Aborted\", to clean up state at the client.\n"
- title: 8.1.4.  Init Cookie Option
  contents:
  - "8.1.4.  Init Cookie Option\n   +--------+--------+--------+--------+--------+--------\n\
    \   |00100100| Length |         Init Cookie Value   ...\n   +--------+--------+--------+--------+--------+--------\n\
    \    Type=36\n   The Init Cookie option lets a DCCP server avoid having to hold\
    \ any\n   state until the three-way connection setup handshake has completed,\n\
    \   in a similar fashion as for TCP SYN cookies [SYNCOOKIES].  The server\n  \
    \ wraps up the Service Code, server port, and any options it cares\n   about from\
    \ both the DCCP-Request and DCCP-Response in an opaque\n   cookie.  Typically\
    \ the cookie will be encrypted using a secret known\n   only to the server and\
    \ will include a cryptographic checksum or magic\n   value so that correct decryption\
    \ can be verified.  When the server\n   receives the cookie back in the response,\
    \ it can decrypt the cookie\n   and instantiate all the state it avoided keeping.\
    \  In the meantime,\n   it need not move from the LISTEN state.\n   The Init Cookie\
    \ option MUST NOT be sent on DCCP-Request or DCCP-Data\n   packets.  Any Init\
    \ Cookie options received on DCCP-Request or DCCP-\n   Data packets, or after\
    \ the connection has been established (when the\n   connection's state is >= OPEN),\
    \ MUST be ignored.  The server MAY\n   include Init Cookie options in its DCCP-Response.\
    \  If so, then the\n   client MUST echo the same Init Cookie options, in the same\
    \ order, in\n   each succeeding DCCP packet until one of those packets is\n  \
    \ acknowledged (showing that the three-way handshake has completed) or\n   the\
    \ connection is reset.  As a result, the client MUST NOT use DCCP-\n   Data packets\
    \ until the three-way handshake completes or the\n   connection is reset.  The\
    \ Init Cookie options on a client packet MUST\n   equal those received on the\
    \ DCCP-Request indicated by the client\n   packet's Acknowledgement Number.  The\
    \ server SHOULD design its Init\n   Cookie format so that Init Cookies can be\
    \ checked for tampering; it\n   SHOULD respond to a tampered Init Cookie option\
    \ by resetting the\n   connection with Reset Code 10, \"Bad Init Cookie\".\n \
    \  Init Cookie's precise implementation need not be specified here;\n   since\
    \ Init Cookies are opaque to the client, there are no\n   interoperability concerns.\
    \  An example cookie format might encrypt\n   (using a secret key) the connection's\
    \ initial sequence and\n   acknowledgement numbers, ports, Service Code, any options\
    \ included on\n   the DCCP-Request packet and the corresponding DCCP-Response,\
    \ a random\n   salt, and a magic number.  On receiving a reflected Init Cookie,\
    \ the\n   server would decrypt the cookie, validate it by checking its magic\n\
    \   number, sequence numbers, and ports, and, if valid, create a\n   corresponding\
    \ socket using the options.\n   Each individual Init Cookie option can hold at\
    \ most 253 bytes of\n   data, but a server can send multiple Init Cookie options\
    \ to gain more\n   space.\n"
- title: 8.1.5.  Handshake Completion
  contents:
  - "8.1.5.  Handshake Completion\n   When the client receives a DCCP-Response from\
    \ the server, it moves\n   from the REQUEST state to PARTOPEN and completes the\
    \ three-way\n   handshake by sending a DCCP-Ack packet to the server.  The client\n\
    \   remains in PARTOPEN until it can be sure that the server has received\n  \
    \ some packet the client sent from PARTOPEN (either the initial DCCP-\n   Ack\
    \ or a later packet).  Clients in the PARTOPEN state that want to\n   send data\
    \ MUST do so using DCCP-DataAck packets, not DCCP-Data\n   packets.  This is because\
    \ DCCP-Data packets lack Acknowledgement\n   Numbers, so the server can't tell\
    \ from a DCCP-Data packet whether the\n   client saw its DCCP-Response.  Furthermore,\
    \ if the DCCP-Response\n   included an Init Cookie, that Init Cookie MUST be included\
    \ on every\n   packet sent in PARTOPEN.\n   The single DCCP-Ack sent when entering\
    \ the PARTOPEN state might, of\n   course, be dropped by the network.  The client\
    \ SHOULD ensure that\n   some packet gets through eventually.  The preferred mechanism\
    \ would\n   be a roughly 200-millisecond timer, set every time a packet is\n \
    \  transmitted in PARTOPEN.  If this timer goes off and the client is\n   still\
    \ in PARTOPEN, the client generates another DCCP-Ack and backs\n   off the timer.\
    \  If the client remains in PARTOPEN for more than 4MSL\n   (8 minutes), it SHOULD\
    \ reset the connection with Reset Code 2,\n   \"Aborted\".\n   The client leaves\
    \ the PARTOPEN state for OPEN when it receives a\n   valid packet other than DCCP-Response,\
    \ DCCP-Reset, or DCCP-Sync from\n   the server.\n"
- title: 8.2.  Data Transfer
  contents:
  - "8.2.  Data Transfer\n   In the central data transfer phase of the connection,\
    \ both server and\n   client are in the OPEN state.\n   DCCP A sends DCCP-Data\
    \ and DCCP-DataAck packets to DCCP B due to\n   application events on host A.\
    \  These packets are congestion-\n   controlled by the CCID for the A-to-B half-connection.\
    \  In contrast,\n   DCCP-Ack packets sent by DCCP A are controlled by the CCID\
    \ for the\n   B-to-A half-connection.  Generally, DCCP A will piggyback\n   acknowledgement\
    \ information on DCCP-Data packets when acceptable,\n   creating DCCP-DataAck\
    \ packets.  DCCP-Ack packets are used when there\n   is no data to send from DCCP\
    \ A to DCCP B, or when the congestion\n   state of the A-to-B CCID will not allow\
    \ data to be sent.\n   DCCP-Sync and DCCP-SyncAck packets may also occur in the\
    \ data\n   transfer phase.  Some cases causing DCCP-Sync generation are\n   discussed\
    \ in Section 7.5.  One important distinction between DCCP-\n   Sync packets and\
    \ other packet types is that DCCP-Sync elicits an\n   immediate acknowledgement.\
    \  On receiving a valid DCCP-Sync packet, a\n   DCCP endpoint MUST immediately\
    \ generate and send a DCCP-SyncAck\n   response (subject to any implementation\
    \ rate limits); the\n   Acknowledgement Number on that DCCP-SyncAck MUST equal\
    \ the Sequence\n   Number of the DCCP-Sync.\n   A particular DCCP implementation\
    \ might decide to initiate feature\n   negotiation only once the OPEN state was\
    \ reached, in which case it\n   might not allow data transfer until some time\
    \ later.  Data received\n   during that time SHOULD be rejected and reported using\
    \ a Data Dropped\n   Drop Block with Drop Code 0, Protocol Constraints (see Section\
    \ 11.7).\n"
- title: 8.3.  Termination
  contents:
  - "8.3.  Termination\n   DCCP connection termination uses a handshake consisting\
    \ of an\n   optional DCCP-CloseReq packet, a DCCP-Close packet, and a DCCP-Reset\n\
    \   packet.  The server moves from the OPEN state, possibly through the\n   CLOSEREQ\
    \ state, to CLOSED; the client moves from OPEN through CLOSING\n   to TIMEWAIT,\
    \ and after 2MSL wait time (4 minutes) to CLOSED.\n   The sequence DCCP-CloseReq,\
    \ DCCP-Close, DCCP-Reset is used when the\n   server decides to close the connection\
    \ but doesn't want to hold\n   TIMEWAIT state:\n     Client State            \
    \                 Server State\n        OPEN                                 \
    \    OPEN\n   1.             <--       CloseReq       <--   CLOSEREQ\n   2.  \
    \ CLOSING   -->        Close         -->\n   3.             <--        Reset \
    \        <--   CLOSED (LISTEN)\n   4.   TIMEWAIT\n   5.   CLOSED\n   A shorter\
    \ sequence occurs when the client decides to close the\n   connection.\n     Client\
    \ State                             Server State\n        OPEN               \
    \                      OPEN\n   1.   CLOSING   -->        Close         -->\n\
    \   2.             <--        Reset         <--   CLOSED (LISTEN)\n   3.   TIMEWAIT\n\
    \   4.   CLOSED\n   Finally, the server can decide to hold TIMEWAIT state:\n \
    \    Client State                             Server State\n        OPEN     \
    \                                OPEN\n   1.             <--        Close    \
    \     <--   CLOSING\n   2.   CLOSED    -->        Reset         -->\n   3.   \
    \                                         TIMEWAIT\n   4.                    \
    \                        CLOSED (LISTEN)\n   In all cases, the receiver of the\
    \ DCCP-Reset packet holds TIMEWAIT\n   state for the connection.  As in TCP, TIMEWAIT\
    \ state, where an\n   endpoint quietly preserves a socket for 2MSL (4 minutes)\
    \ after its\n   connection has closed, ensures that no connection duplicating\
    \ the\n   current connection's source and destination addresses and ports can\n\
    \   start up while old packets might remain in the network.\n   The termination\
    \ handshake proceeds as follows.  The receiver of a\n   valid DCCP-CloseReq packet\
    \ MUST respond with a DCCP-Close packet.\n   The receiver of a valid DCCP-Close\
    \ packet MUST respond with a DCCP-\n   Reset packet with Reset Code 1, \"Closed\"\
    .  The receiver of a valid\n   DCCP-Reset packet -- which is also the sender of\
    \ the DCCP-Close\n   packet (and possibly the receiver of the DCCP-CloseReq packet)\
    \ --\n   will hold TIMEWAIT state for the connection.\n   A DCCP-Reset packet\
    \ completes every DCCP connection, whether the\n   termination is clean (due to\
    \ application close; Reset Code 1,\n   \"Closed\") or unclean.  Unlike TCP, which\
    \ has two distinct termination\n   mechanisms (FIN and RST), DCCP ends all connections\
    \ in a uniform\n   manner.  This is justified because some aspects of connection\n\
    \   termination are the same independent of whether termination was\n   clean.\
    \  For instance, the endpoint that receives a valid DCCP-Reset\n   SHOULD hold\
    \ TIMEWAIT state for the connection.  Processors that must\n   distinguish between\
    \ clean and unclean termination can examine the\n   Reset Code.  DCCP implementations\
    \ generally transition to the CLOSED\n   state after sending a DCCP-Reset packet.\n\
    \   Endpoints in the CLOSEREQ and CLOSING states MUST retransmit DCCP-\n   CloseReq\
    \ and DCCP-Close packets, respectively, until leaving those\n   states.  The retransmission\
    \ timer should initially be set to go off\n   in two round-trip times and should\
    \ back off to not less than once\n   every 64 seconds if no relevant response\
    \ is received.\n   Only the server can send a DCCP-CloseReq packet or enter the\
    \ CLOSEREQ\n   state.  A server receiving a sequence-valid DCCP-CloseReq packet\
    \ MUST\n   respond with a DCCP-Sync packet and otherwise ignore the DCCP-\n  \
    \ CloseReq.\n   DCCP-Data, DCCP-DataAck, and DCCP-Ack packets received in CLOSEREQ\
    \ or\n   CLOSING states MAY be either processed or ignored.\n"
- title: 8.3.1.  Abnormal Termination
  contents:
  - "8.3.1.  Abnormal Termination\n   DCCP endpoints generate DCCP-Reset packets to\
    \ terminate connections\n   abnormally; a DCCP-Reset packet may be generated from\
    \ any state.\n   Resets sent in the CLOSED, LISTEN, and TIMEWAIT states use Reset\
    \ Code\n   3, \"No Connection\", unless otherwise specified.  Resets sent in the\n\
    \   REQUEST or RESPOND states use Reset Code 4, \"Packet Error\", unless\n   otherwise\
    \ specified.\n   DCCP endpoints in CLOSED, LISTEN, or TIMEWAIT state may need\
    \ to\n   generate a DCCP-Reset packet in response to a packet received from a\n\
    \   peer.  Since these states have no associated sequence number\n   variables,\
    \ the Sequence and Acknowledgement Numbers on the DCCP-Reset\n   packet R are\
    \ taken from the received packet P, as follows.\n   1. If P.ackno exists, then\
    \ set R.seqno := P.ackno + 1.  Otherwise,\n      set R.seqno := 0.\n   2. Set\
    \ R.ackno := P.seqno.\n   3. If the packet used short sequence numbers (P.X ==\
    \ 0), then set the\n      upper 24 bits of R.seqno and R.ackno to 0.\n"
- title: 8.4.  DCCP State Diagram
  contents:
  - "8.4.  DCCP State Diagram\n   The most common state transitions discussed above\
    \ can be summarized\n   in the following state diagram.  The diagram is illustrative;\
    \ the\n   text in Section 8.5 and elsewhere should be considered definitive.\n\
    \   For example, there are arcs (not shown) from every state except\n   CLOSED\
    \ to TIMEWAIT, contingent on the receipt of a valid DCCP-Reset.\n   +---------------------------+\
    \    +---------------------------+\n   |                           v    v    \
    \                       |\n   |                        +----------+          \
    \              |\n   |          +-------------+  CLOSED  +------------+      \
    \     |\n   |          | passive     +----------+  active    |           |\n \
    \  |          |  open                      open     |           |\n   |      \
    \    |                         snd Request |           |\n   |          v    \
    \                                 v           |\n   |     +----------+       \
    \                   +----------+     |\n   |     |  LISTEN  |                \
    \          | REQUEST  |     |\n   |     +----+-----+                         \
    \ +----+-----+     |\n   |          | rcv Request            rcv Response |  \
    \         |\n   |          | snd Response             snd Ack    |           |\n\
    \   |          v                                     v           |\n   |     +----------+\
    \                          +----------+     |\n   |     | RESPOND  |         \
    \                 | PARTOPEN |     |\n   |     +----+-----+                  \
    \        +----+-----+     |\n   |          | rcv Ack/DataAck         rcv packet\
    \  |           |\n   |          |                                     |      \
    \     |\n   |          |             +----------+            |           |\n \
    \  |          +------------>|   OPEN   |<-----------+           |\n   |      \
    \                  +--+-+--+--+                        |\n   |       server active\
    \ close | |  |   active close            |\n   |           snd CloseReq    | |\
    \  | or rcv CloseReq           |\n   |                           | |  |    snd\
    \ Close              |\n   |                           | |  |                \
    \           |\n   |     +----------+          | |  |          +----------+   \
    \  |\n   |     | CLOSEREQ |<---------+ |  +--------->| CLOSING  |     |\n   |\
    \     +----+-----+            |             +----+-----+     |\n   |         \
    \ | rcv Close        |        rcv Reset |           |\n   |          | snd Reset\
    \        |                  |           |\n   |<---------+                  |\
    \                  v           |\n   |                             |         \
    \    +----+-----+     |\n   |                   rcv Close |             | TIMEWAIT\
    \ |     |\n   |                   snd Reset |             +----+-----+     |\n\
    \   +-----------------------------+                  |           |\n         \
    \                                           +-----------+\n                  \
    \                               2MSL timer expires\n"
- title: 8.5.  Pseudocode
  contents:
  - "8.5.  Pseudocode\n   This section presents an algorithm describing the processing\
    \ steps a\n   DCCP endpoint must go through when it receives a packet.  A DCCP\n\
    \   implementation need not implement the algorithm as it is described\n   here,\
    \ but any implementation MUST generate observable effects exactly\n   as indicated\
    \ by this pseudocode, except where allowed otherwise by\n   another part of this\
    \ document.\n   The received packet is written as P, the socket as S.  Socket\n\
    \   variables are:\n   S.SWL - sequence number window low\n   S.SWH - sequence\
    \ number window high\n   S.AWL - acknowledgement number window low\n   S.AWH -\
    \ acknowledgement number window high\n   S.ISS - initial sequence number sent\n\
    \   S.ISR - initial sequence number received\n   S.OSR - first OPEN sequence number\
    \ received\n   S.GSS - greatest sequence number sent\n   S.GSR - greatest valid\
    \ sequence number received\n   S.GAR - greatest valid acknowledgement number received\
    \ on a\n           non-Sync; initialized to S.ISS\n   \"Send packet\" actions\
    \ always use, and increment, S.GSS.\n   Step 1: Check header basics\n      /*\
    \ This step checks for malformed packets.  Packets that fail\n         these checks\
    \ are ignored -- they do not receive Resets in\n         response */\n      If\
    \ the packet is shorter than 12 bytes, drop packet and return\n      If P.type\
    \ is not understood, drop packet and return\n      If P.Data Offset is smaller\
    \ than the given packet type's\n            fixed header length or larger than\
    \ the packet's length,\n            drop packet and return\n      If P.type is\
    \ not Data, Ack, or DataAck and P.X == 0 (the packet\n            has short sequence\
    \ numbers), drop packet and return\n      If the header checksum is incorrect,\
    \ drop packet and return\n      If P.CsCov is too large for the packet size, drop\
    \ packet and\n            return\n   Step 2: Check ports and process TIMEWAIT\
    \ state\n      /* Flow ID is <src addr, src port, dst addr, dst port> 4-tuple\
    \ */\n      Look up flow ID in table and get corresponding socket\n      If no\
    \ socket, or S.state == TIMEWAIT,\n         /* The following Reset's Sequence\
    \ and Acknowledgement Numbers\n            are taken from the input packet; see\
    \ Section 8.3.1. */\n         Generate Reset(No Connection) unless P.type == Reset\n\
    \         Drop packet and return\n   Step 3: Process LISTEN state\n      If S.state\
    \ == LISTEN,\n         If P.type == Request or P contains a valid Init Cookie\
    \ option,\n            /* Must scan the packet's options to check for Init\n \
    \              Cookies.  Only Init Cookies are processed here,\n             \
    \  however; other options are processed in Step 8.  This\n               scan\
    \ need only be performed if the endpoint uses Init\n               Cookies */\n\
    \            /* Generate a new socket and switch to that socket */\n         \
    \   Set S := new socket for this port pair\n            S.state = RESPOND\n  \
    \          Choose S.ISS (initial seqno) or set from Init Cookies\n           \
    \ Initialize S.GAR := S.ISS\n            Set S.ISR, S.GSR, S.SWL, S.SWH from packet\
    \ or Init Cookies\n            Continue with S.state == RESPOND\n            /*\
    \ A Response packet will be generated in Step 11 */\n         Otherwise,\n   \
    \         Generate Reset(No Connection) unless P.type == Reset\n            Drop\
    \ packet and return\n   Step 4: Prepare sequence numbers in REQUEST\n      If\
    \ S.state == REQUEST,\n         If (P.type == Response or P.type == Reset)\n \
    \              and S.AWL <= P.ackno <= S.AWH,\n            /* Set sequence number\
    \ variables corresponding to the\n               other endpoint, so P will pass\
    \ the tests in Step 6 */\n            Set S.GSR, S.ISR, S.SWL, S.SWH\n       \
    \     /* Response processing continues in Step 10; Reset\n               processing\
    \ continues in Step 9 */\n         Otherwise,\n            /* Only Response and\
    \ Reset are valid in REQUEST state */\n            Generate Reset(Packet Error)\n\
    \            Drop packet and return\n   Step 5: Prepare sequence numbers for Sync\n\
    \      If P.type == Sync or P.type == SyncAck,\n         If S.AWL <= P.ackno <=\
    \ S.AWH and P.seqno >= S.SWL,\n            /* P is valid, so update sequence number\
    \ variables\n               accordingly.  After this update, P will pass the tests\n\
    \               in Step 6.  A SyncAck is generated if necessary in\n         \
    \      Step 15 */\n            Update S.GSR, S.SWL, S.SWH\n         Otherwise,\n\
    \            Drop packet and return\n   Step 6: Check sequence numbers\n     \
    \ If P.X == 0 and the relevant Allow Short Seqnos feature is 0,\n         /* Packet\
    \ has short seqnos, but short seqnos not allowed */\n         Drop packet and\
    \ return\n      Otherwise, if P.X == 0,\n         Extend P.seqno and P.ackno to\
    \ 48 bits using the procedure\n         in Section 7.6\n      Let LSWL = S.SWL\
    \ and LAWL = S.AWL\n      If P.type == CloseReq or P.type == Close or P.type ==\
    \ Reset,\n         LSWL := S.GSR + 1, LAWL := S.GAR\n      If LSWL <= P.seqno\
    \ <= S.SWH\n            and (P.ackno does not exist or LAWL <= P.ackno <= S.AWH),\n\
    \         Update S.GSR, S.SWL, S.SWH\n         If P.type != Sync,\n          \
    \  Update S.GAR\n      Otherwise,\n         If P.type == Reset,\n            Send\
    \ Sync packet acknowledging S.GSR\n         Otherwise,\n            Send Sync\
    \ packet acknowledging P.seqno\n         Drop packet and return\n   Step 7: Check\
    \ for unexpected packet types\n      If (S.is_server and P.type == CloseReq)\n\
    \           or (S.is_server and P.type == Response)\n           or (S.is_client\
    \ and P.type == Request)\n           or (S.state >= OPEN and P.type == Request\n\
    \               and P.seqno >= S.OSR)\n           or (S.state >= OPEN and P.type\
    \ == Response\n               and P.seqno >= S.OSR)\n           or (S.state ==\
    \ RESPOND and P.type == Data),\n         Send Sync packet acknowledging P.seqno\n\
    \         Drop packet and return\n   Step 8: Process options and mark acknowledgeable\n\
    \      /* Option processing is not specifically described here.\n         Certain\
    \ options, such as Mandatory, may cause the connection\n         to be reset,\
    \ in which case Steps 9 and on are not executed */\n      Mark packet as acknowledgeable\
    \ (in Ack Vector terms, Received\n           or Received ECN Marked)\n   Step\
    \ 9: Process Reset\n      If P.type == Reset,\n         Tear down connection\n\
    \         S.state := TIMEWAIT\n         Set TIMEWAIT timer\n         Drop packet\
    \ and return\n   Step 10: Process REQUEST state (second part)\n      If S.state\
    \ == REQUEST,\n         /* If we get here, P is a valid Response from the server\
    \ (see\n            Step 4), and we should move to PARTOPEN state.  PARTOPEN\n\
    \            means send an Ack, don't send Data packets, retransmit\n        \
    \    Acks periodically, and always include any Init Cookie from\n            the\
    \ Response */\n         S.state := PARTOPEN\n         Set PARTOPEN timer\n   \
    \      Continue with S.state == PARTOPEN\n         /* Step 12 will send the Ack\
    \ completing the three-way\n            handshake */\n   Step 11: Process RESPOND\
    \ state\n      If S.state == RESPOND,\n         If P.type == Request,\n      \
    \      Send Response, possibly containing Init Cookie\n            If Init Cookie\
    \ was sent,\n               Destroy S and return\n               /* Step 3 will\
    \ create another socket when the client\n                  completes the three-way\
    \ handshake */\n         Otherwise,\n            S.OSR := P.seqno\n          \
    \  S.state := OPEN\n   Step 12: Process PARTOPEN state\n      If S.state == PARTOPEN,\n\
    \         If P.type == Response,\n            Send Ack\n         Otherwise, if\
    \ P.type != Sync,\n            S.OSR := P.seqno\n            S.state := OPEN\n\
    \   Step 13: Process CloseReq\n      If P.type == CloseReq and S.state < CLOSEREQ,\n\
    \         Generate Close\n         S.state := CLOSING\n         Set CLOSING timer\n\
    \   Step 14: Process Close\n      If P.type == Close,\n         Generate Reset(Closed)\n\
    \         Tear down connection\n         Drop packet and return\n   Step 15: Process\
    \ Sync\n      If P.type == Sync,\n         Generate SyncAck\n   Step 16: Process\
    \ data\n      /* At this point any application data on P can be passed to the\n\
    \         application, except that the application MUST NOT receive\n        \
    \ data from more than one Request or Response */\n"
- title: 9.  Checksums
  contents:
  - "9.  Checksums\n   DCCP uses a header checksum to protect its header against corruption.\n\
    \   Generally, this checksum also covers any application data.  DCCP\n   applications\
    \ can, however, request that the header checksum cover\n   only part of the application\
    \ data, or perhaps no application data at\n   all.  Link layers may then reduce\
    \ their protection on unprotected\n   parts of DCCP packets.  For some noisy links,\
    \ and for applications\n   that can tolerate corruption, this can greatly improve\
    \ delivery rates\n   and perceived performance.\n   Checksum coverage may eventually\
    \ impact congestion control mechanisms\n   as well.  A packet with corrupt application\
    \ data and complete\n   checksum coverage is treated as lost.  This incurs a heavy-duty\
    \ loss\n   response from the sender's congestion control mechanism, which can\n\
    \   unfairly penalize connections on links with high background\n   corruption.\
    \  The combination of reduced checksum coverage and Data\n   Checksum options\
    \ may let endpoints report packets as corrupt rather\n   than dropped, using Data\
    \ Dropped options and Drop Code 3 (see Section\n   11.7).  This may eventually\
    \ benefit applications.  However, further\n   research is required to determine\
    \ an appropriate response to\n   corruption, which can sometimes correlate with\
    \ congestion.  Corrupt\n   packets currently incur a loss response.\n   The Data\
    \ Checksum option, which contains a strong CRC, lets endpoints\n   detect application\
    \ data corruption.  An API can then be used to avoid\n   delivering corrupt data\
    \ to the application, even if links deliver\n   corrupt data to the endpoint due\
    \ to reduced checksum coverage.\n   However, the use of reduced checksum coverage\
    \ for applications that\n   demand correct data is currently considered experimental.\
    \  This is\n   because the combined loss-plus-corruption rate for packets with\n\
    \   reduced checksum coverage may be significantly higher than that for\n   packets\
    \ with full checksum coverage, although the loss rate will\n   generally be lower.\
    \  Actual behavior will depend on link design;\n   further research and experience\
    \ is required.\n   Reduced checksum coverage introduces some security considerations;\n\
    \   see Section 18.1.  See Appendix B for further motivation and\n   discussion.\
    \  DCCP's implementation of reduced checksum coverage was\n   inspired by UDP-Lite\
    \ [RFC3828].\n"
- title: 9.1.  Header Checksum Field
  contents:
  - "9.1.  Header Checksum Field\n   DCCP uses the TCP/IP checksum algorithm.  The\
    \ Checksum field in the\n   DCCP generic header (see Section 5.1) equals the 16-bit\
    \ one's\n   complement of the one's complement sum of all 16-bit words in the\n\
    \   DCCP header, DCCP options, a pseudoheader taken from the network-\n   layer\
    \ header, and, depending on the value of the Checksum Coverage\n   field, some\
    \ or all of the application data.  When calculating the\n   checksum, the Checksum\
    \ field itself is treated as 0.  If a packet\n   contains an odd number of header\
    \ and payload bytes to be checksummed,\n   8 zero bits are added on the right\
    \ to form a 16-bit word for checksum\n   purposes.  The pad byte is not transmitted\
    \ as part of the packet.\n   The pseudoheader is calculated as for TCP.  For IPv4,\
    \ it is 96 bits\n   long and consists of the IPv4 source and destination addresses,\
    \ the\n   IP protocol number for DCCP (padded on the left with 8 zero bits),\n\
    \   and the DCCP length as a 16-bit quantity (the length of the DCCP\n   header\
    \ with options, plus the length of any data); see [RFC793],\n   Section 3.1. \
    \ For IPv6, it is 320 bits long, and consists of the IPv6\n   source and destination\
    \ addresses, the DCCP length as a 32-bit\n   quantity, and the IP protocol number\
    \ for DCCP (padded on the left\n   with 24 zero bits); see [RFC2460], Section\
    \ 8.1.\n   Packets with invalid header checksums MUST be ignored.  In\n   particular,\
    \ their options MUST NOT be processed.\n"
- title: 9.2.  Header Checksum Coverage Field
  contents:
  - "9.2.  Header Checksum Coverage Field\n   The Checksum Coverage field in the DCCP\
    \ generic header (see Section\n   5.1) specifies what parts of the packet are\
    \ covered by the Checksum\n   field, as follows:\n   CsCov = 0      The Checksum\
    \ field covers the DCCP header, DCCP\n                  options, network-layer\
    \ pseudoheader, and all\n                  application data in the packet, possibly\
    \ padded on the\n                  right with zeros to an even number of bytes.\n\
    \   CsCov = 1-15   The Checksum field covers the DCCP header, DCCP\n         \
    \         options, network-layer pseudoheader, and the initial\n             \
    \     (CsCov-1)*4 bytes of the packet's application data.\n   Thus, if CsCov is\
    \ 1, none of the application data is protected by the\n   header checksum.  The\
    \ value (CsCov-1)*4 MUST be less than or equal to\n   the length of the application\
    \ data.  Packets with invalid CsCov\n   values MUST be ignored; in particular,\
    \ their options MUST NOT be\n   processed.  The meanings of values other than\
    \ 0 and 1 should be\n   considered experimental.\n   Values other than 0 specify\
    \ that corruption is acceptable in some or\n   all of the DCCP packet's application\
    \ data.  In fact, DCCP cannot even\n   detect corruption in areas not covered\
    \ by the header checksum, unless\n   the Data Checksum option is used.  Applications\
    \ should not make any\n   assumptions about the correctness of received data not\
    \ covered by the\n   checksum and should, if necessary, introduce their own validity\n\
    \   checks.\n   A DCCP application interface should let sending applications suggest\n\
    \   a value for CsCov for sent packets, defaulting to 0 (full coverage).\n   The\
    \ Minimum Checksum Coverage feature, described below, lets an\n   endpoint refuse\
    \ delivery of application data on packets with partial\n   checksum coverage;\
    \ by default, only fully covered application data is\n   accepted.  Lower layers\
    \ that support partial error detection MAY use\n   the Checksum Coverage field\
    \ as a hint of where errors do not need to\n   be detected.  Lower layers MUST\
    \ use a strong error detection\n   mechanism to detect at least errors that occur\
    \ in the sensitive part\n   of the packet, and to discard damaged packets.  The\
    \ sensitive part\n   consists of the bytes between the first byte of the IP header\
    \ and the\n   last byte identified by Checksum Coverage.\n   For more details\
    \ on application and lower-layer interface issues\n   relating to partial checksumming,\
    \ see [RFC3828].\n"
- title: 9.2.1.  Minimum Checksum Coverage Feature
  contents:
  - "9.2.1.  Minimum Checksum Coverage Feature\n   The Minimum Checksum Coverage feature\
    \ lets a DCCP endpoint determine\n   whether its peer is willing to accept packets\
    \ with reduced Checksum\n   Coverage.  For example, DCCP A sends a \"Change R(Minimum\
    \ Checksum\n   Coverage, 1)\" option to DCCP B to check whether B is willing to\n\
    \   accept packets with Checksum Coverage set to 1.\n   Minimum Checksum Coverage\
    \ has feature number 8 and is server-\n   priority.  It takes one-byte integer\
    \ values between 0 and 15; values\n   of 16 or more are reserved.  Minimum Checksum\
    \ Coverage/B reflects\n   values of Checksum Coverage that DCCP B finds unacceptable.\
    \  Say that\n   the value of Minimum Checksum Coverage/B is MinCsCov.  Then:\n\
    \   o  If MinCsCov = 0, then DCCP B only finds packets with CsCov = 0\n      acceptable.\n\
    \   o  If MinCsCov > 0, then DCCP B additionally finds packets with\n      CsCov\
    \ >= MinCsCov acceptable.\n   DCCP B MAY refuse to process application data from\
    \ packets with\n   unacceptable Checksum Coverage.  Such packets SHOULD be reported\n\
    \   using Data Dropped options (Section 11.7) with Drop Code 0, Protocol\n   Constraints.\
    \  New connections start with Minimum Checksum Coverage 0\n   for both endpoints.\n"
- title: 9.3.  Data Checksum Option
  contents:
  - "9.3.  Data Checksum Option\n   The Data Checksum option holds a 32-bit CRC-32c\
    \ cyclic redundancy-\n   check code of a DCCP packet's application data.\n   +--------+--------+--------+--------+--------+--------+\n\
    \   |00101100|00000110|              CRC-32c              |\n   +--------+--------+--------+--------+--------+--------+\n\
    \    Type=44  Length=6\n   The sending DCCP computes the CRC of the bytes comprising\
    \ the\n   application data area and stores it in the option data.  The CRC-32c\n\
    \   algorithm used for Data Checksum is the same as that used for SCTP\n   [RFC3309];\
    \ note that the CRC-32c of zero bytes of data equals zero.\n   The DCCP header\
    \ checksum will cover the Data Checksum option, so the\n   data checksum must\
    \ be computed before the header checksum.\n   A DCCP endpoint receiving a packet\
    \ with a Data Checksum option either\n   MUST or MAY check the Data Checksum;\
    \ the choice depends on the value\n   of the Check Data Checksum feature described\
    \ below.  If it checks the\n   checksum, it computes the received application\
    \ data's CRC-32c using\n   the same algorithm as the sender and compares the result\
    \ with the\n   Data Checksum value.  If the CRCs differ, the endpoint reacts in\
    \ one\n   of two ways:\n   o  The receiving application may have requested delivery\
    \ of known-\n      corrupt data via some optional API.  In this case, the packet's\n\
    \      data MUST be delivered to the application, with a note that it is\n   \
    \   known to be corrupt.  Furthermore, the receiving endpoint MUST\n      report\
    \ the packet as delivered corrupt using a Data Dropped option\n      (Drop Code\
    \ 7, Delivered Corrupt).\n   o  Otherwise, the receiving endpoint MUST drop the\
    \ application data\n      and report that data as dropped due to corruption using\
    \ a Data\n      Dropped option (Drop Code 3, Corrupt).\n   In either case, the\
    \ packet is considered acknowledgeable (since its\n   header was processed) and\
    \ will therefore be acknowledged using the\n   equivalent of Ack Vector's Received\
    \ or Received ECN Marked states.\n   Although Data Checksum is intended for packets\
    \ containing application\n   data, it may be included on other packets, such as\
    \ DCCP-Ack, DCCP-\n   Sync, and DCCP-SyncAck.  The receiver SHOULD calculate the\n\
    \   application data area's CRC-32c on such packets, just as it does for\n   DCCP-Data\
    \ and similar packets.  If the CRCs differ, the packets\n   similarly MUST be\
    \ reported using Data Dropped options (Drop Code 3),\n   although their application\
    \ data areas would not be delivered to the\n   application in any case.\n"
- title: 9.3.1.  Check Data Checksum Feature
  contents:
  - "9.3.1.  Check Data Checksum Feature\n   The Check Data Checksum feature lets\
    \ a DCCP endpoint determine\n   whether its peer will definitely check Data Checksum\
    \ options.  DCCP A\n   sends a Mandatory \"Change R(Check Data Checksum, 1)\"\
    \ option to DCCP B\n   to require it to check Data Checksum options (the connection\
    \ will be\n   reset if it cannot).\n   Check Data Checksum has feature number\
    \ 9 and is server-priority.  It\n   takes one-byte Boolean values.  DCCP B MUST\
    \ check any received Data\n   Checksum options when Check Data Checksum/B is one,\
    \ although it MAY\n   check them even when Check Data Checksum/B is zero.  Values\
    \ of two or\n   more are reserved.  New connections start with Check Data Checksum\
    \ 0\n   for both endpoints.\n"
- title: 9.3.2.  Checksum Usage Notes
  contents:
  - "9.3.2.  Checksum Usage Notes\n   Internet links must normally apply strong integrity\
    \ checks to the\n   packets they transmit [RFC3828, RFC3819].  This is the default\
    \ case\n   when the DCCP header's Checksum Coverage value equals zero (full\n\
    \   coverage).  However, the DCCP Checksum Coverage value might not be\n   zero.\
    \  By setting partial Checksum Coverage, the application\n   indicates that it\
    \ can tolerate corruption in the unprotected part of\n   the application data.\
    \  Recognizing this, link layers may reduce error\n   detection and/or correction\
    \ strength when transmitting this\n   unprotected part.  This, in turn, can significantly\
    \ increase the\n   likelihood of the endpoint's receiving corrupt data; Data Checksum\n\
    \   lets the receiver detect that corruption with very high probability.\n"
- title: 10.  Congestion Control
  contents:
  - "10.  Congestion Control\n   Each congestion control mechanism supported by DCCP\
    \ is assigned a\n   congestion control identifier, or CCID: a number from 0 to\
    \ 255.\n   During connection setup, and optionally thereafter, the endpoints\n\
    \   negotiate their congestion control mechanisms by negotiating the\n   values\
    \ for their Congestion Control ID features.  Congestion Control\n   ID has feature\
    \ number 1.  The CCID/A value equals the CCID in use for\n   the A-to-B half-connection.\
    \  DCCP B sends a \"Change R(CCID, K)\"\n   option to ask DCCP A to use CCID K\
    \ for its data packets.\n   CCID is a server-priority feature, so CCID negotiation\
    \ options can\n   list multiple acceptable CCIDs, sorted in descending order of\n\
    \   priority.  For example, the option \"Change R(CCID, 2 3 4)\" asks the\n  \
    \ receiver to use CCID 2 for its packets, although CCIDs 3 and 4 are\n   also\
    \ acceptable.  (This corresponds to the bytes \"35, 6, 1, 2, 3, 4\":\n   Change\
    \ R option (35), option length (6), feature ID (1), CCIDs (2, 3,\n   4).)  Similarly,\
    \ \"Confirm L(CCID, 2, 2 3 4)\" tells the receiver that\n   the sender is using\
    \ CCID 2 for its packets, but that CCIDs 3 and 4\n   might also be acceptable.\n\
    \   Currently allocated CCIDs are as follows:\n           CCID   Meaning     \
    \                 Reference\n           ----   -------                      ---------\n\
    \            0-1   Reserved\n             2    TCP-like Congestion Control  [RFC4341]\n\
    \             3    TCP-Friendly Rate Control    [RFC4342]\n           4-255  Reserved\n\
    \           Table 5: DCCP Congestion Control Identifiers\n   New connections start\
    \ with CCID 2 for both endpoints.  If this is\n   unacceptable for a DCCP endpoint,\
    \ that endpoint MUST send Mandatory\n   Change(CCID) options on its first packets.\n\
    \   All CCIDs standardized for use with DCCP will correspond to\n   congestion\
    \ control mechanisms previously standardized by the IETF.\n   We expect that for\
    \ quite some time, all such mechanisms will be TCP\n   friendly, but TCP-friendliness\
    \ is not an explicit DCCP requirement.\n   A DCCP implementation intended for\
    \ general use, such as an\n   implementation in a general-purpose operating system\
    \ kernel, SHOULD\n   implement at least CCID 2.  The intent is to make CCID 2\
    \ broadly\n   available for interoperability, although particular applications\n\
    \   might disallow its use.\n"
- title: 10.1.  TCP-like Congestion Control
  contents:
  - "10.1.  TCP-like Congestion Control\n   CCID 2, TCP-like Congestion Control, denotes\
    \ Additive Increase,\n   Multiplicative Decrease (AIMD) congestion control with\
    \ behavior\n   modelled directly on TCP, including congestion window, slow start,\n\
    \   timeouts, and so forth [RFC2581].  CCID 2 achieves maximum bandwidth\n   over\
    \ the long term, consistent with the use of end-to-end congestion\n   control,\
    \ but halves its congestion window in response to each\n   congestion event. \
    \ This leads to the abrupt rate changes typical of\n   TCP.  Applications should\
    \ use CCID 2 if they prefer maximum bandwidth\n   utilization to steadiness of\
    \ rate.  This is often the case for\n   applications that are not playing their\
    \ data directly to the user.\n   For example, a hypothetical application that\
    \ transferred files over\n   DCCP, using application-level retransmissions for\
    \ lost packets, would\n   prefer CCID 2 to CCID 3.  On-line games may also prefer\
    \ CCID 2.\n   CCID 2 is further described in [RFC4341].\n"
- title: 10.2.  TFRC Congestion Control
  contents:
  - "10.2.  TFRC Congestion Control\n   CCID 3 denotes TCP-Friendly Rate Control (TFRC),\
    \ an equation-based\n   rate-controlled congestion control mechanism.  TFRC is\
    \ designed to be\n   reasonably fair when competing for bandwidth with TCP-like\
    \ flows,\n   where a flow is \"reasonably fair\" if its sending rate is generally\n\
    \   within a factor of two of the sending rate of a TCP flow under the\n   same\
    \ conditions.  However, TFRC has a much lower variation of\n   throughput over\
    \ time compared with TCP, which makes CCID 3 more\n   suitable than CCID 2 for\
    \ applications such as streaming media where a\n   relatively smooth sending rate\
    \ is important.\n   CCID 3 is further described in [RFC4342].  The TFRC congestion\n\
    \   control algorithms were initially described in [RFC3448].\n"
- title: 10.3.  CCID-Specific Options, Features, and Reset Codes
  contents:
  - "10.3.  CCID-Specific Options, Features, and Reset Codes\n   Half of the option\
    \ types, feature numbers, and Reset Codes are\n   reserved for CCID-specific use.\
    \  CCIDs may often need new options,\n   for communicating acknowledgement or\
    \ rate information, for example;\n   reserved option spaces let CCIDs create options\
    \ at will without\n   polluting the global option space.  Option 128 might have\
    \ different\n   meanings on a half-connection using CCID 4 and a half-connection\n\
    \   using CCID 8.  CCID-specific options and features will never conflict\n  \
    \ with global options and features introduced by later versions of this\n   specification.\n\
    \   Any packet may contain information meant for either half-connection,\n   so\
    \ CCID-specific option types, feature numbers, and Reset Codes\n   explicitly\
    \ signal the half-connection to which they apply.\n   o  Option numbers 128 through\
    \ 191 are for options sent from the\n      HC-Sender to the HC-Receiver; option\
    \ numbers 192 through 255 are\n      for options sent from the HC-Receiver to\
    \ the HC-Sender.\n   o  Reset Codes 128 through 191 indicate that the HC-Sender\
    \ reset the\n      connection (most likely because of some problem with\n    \
    \  acknowledgements sent by the HC-Receiver).  Reset Codes 192\n      through\
    \ 255 indicate that the HC-Receiver reset the connection\n      (most likely because\
    \ of some problem with data packets sent by the\n      HC-Sender).\n   o  Finally,\
    \ feature numbers 128 through 191 are used for features\n      located at the\
    \ HC-Sender; feature numbers 192 through 255 are for\n      features located at\
    \ the HC-Receiver.  Since Change L and Confirm L\n      options for a feature\
    \ are sent by the feature location, we know\n      that any Change L(128) option\
    \ was sent by the HC-Sender, while any\n      Change L(192) option was sent by\
    \ the HC-Receiver.  Similarly,\n      Change R(128) options are sent by the HC-Receiver,\
    \ while Change\n      R(192) options are sent by the HC-Sender.\n   For example,\
    \ consider a DCCP connection where the A-to-B half-\n   connection uses CCID 4\
    \ and the B-to-A half-connection uses CCID 5.\n   Here is how a sampling of CCID-specific\
    \ options are assigned to\n   half-connections.\n                            \
    \       Relevant    Relevant\n        Packet  Option             Half-conn.  CCID\n\
    \        ------  ------             ----------  ----\n        A > B   128    \
    \              A-to-B     4\n        A > B   192                  B-to-A     5\n\
    \        A > B   Change L(128, ...)   A-to-B     4\n        A > B   Change R(192,\
    \ ...)   A-to-B     4\n        A > B   Confirm L(128, ...)  A-to-B     4\n   \
    \     A > B   Confirm R(192, ...)  A-to-B     4\n        A > B   Change R(128,\
    \ ...)   B-to-A     5\n        A > B   Change L(192, ...)   B-to-A     5\n   \
    \     A > B   Confirm R(128, ...)  B-to-A     5\n        A > B   Confirm L(192,\
    \ ...)  B-to-A     5\n        B > A   128                  B-to-A     5\n    \
    \    B > A   192                  A-to-B     4\n        B > A   Change L(128,\
    \ ...)   B-to-A     5\n        B > A   Change R(192, ...)   B-to-A     5\n   \
    \     B > A   Confirm L(128, ...)  B-to-A     5\n        B > A   Confirm R(192,\
    \ ...)  B-to-A     5\n        B > A   Change R(128, ...)   A-to-B     4\n    \
    \    B > A   Change L(192, ...)   A-to-B     4\n        B > A   Confirm R(128,\
    \ ...)  A-to-B     4\n        B > A   Confirm L(192, ...)  A-to-B     4\n   Using\
    \ CCID-specific options and feature options during a negotiation\n   for the corresponding\
    \ CCID feature is NOT RECOMMENDED, since it is\n   difficult to predict which\
    \ CCID will be in force when the option is\n   processed.  For example, if a DCCP-Request\
    \ contains the option\n   sequence \"Change L(CCID, 3), 128\", the CCID-specific\
    \ option \"128\" may\n   be processed either by CCID 3 (if the server supports\
    \ CCID 3) or by\n   the default CCID 2 (if it does not).  However, it is safe\
    \ to include\n   CCID-specific options following certain Mandatory Change(CCID)\n\
    \   options.  For example, if a DCCP-Request contains the option sequence\n  \
    \ \"Mandatory, Change L(CCID, 3), 128\", then either the \"128\" option\n   will\
    \ be processed by CCID 3 or the connection will be reset.\n   Servers that do\
    \ not implement the default CCID 2 might nevertheless\n   receive CCID 2-specific\
    \ options on a DCCP-Request packet.  (Such a\n   server MUST send Mandatory Change(CCID)\
    \ options on its DCCP-Response,\n   so CCID-specific options on any other packet\
    \ won't refer to CCID 2.)\n   The server MUST treat such options as non-understood.\
    \  Thus, it will\n   reset the connection on encountering a Mandatory CCID-specific\
    \ option\n   or feature negotiation request, send an empty Confirm for a non-\n\
    \   Mandatory Change option for a CCID-specific feature, and ignore other\n  \
    \ CCID-specific options.\n"
- title: 10.4.  CCID Profile Requirements
  contents:
  - "10.4.  CCID Profile Requirements\n   Each CCID Profile document MUST address\
    \ at least the following\n   requirements:\n   o  The profile MUST include the\
    \ name and number of the CCID being\n      described.\n   o  The profile MUST\
    \ describe the conditions in which it is likely to\n      be useful.  Often the\
    \ best way to do this is by comparison to\n      existing CCIDs.\n   o  The profile\
    \ MUST list and describe any CCID-specific options,\n      features, and Reset\
    \ Codes and SHOULD list those general options\n      and features described in\
    \ this document that are especially\n      relevant to the CCID.\n   o  Any newly\
    \ defined acknowledgement mechanism MUST include a way to\n      transmit ECN\
    \ Nonce Echoes back to the sender.\n   o  The profile MUST describe the format\
    \ of data packets, including\n      any options that should be included and the\
    \ setting of the CCval\n      header field.\n   o  The profile MUST describe the\
    \ format of acknowledgement packets,\n      including any options that should\
    \ be included.\n   o  The profile MUST define how data packets are congestion\n\
    \      controlled.  This includes responses to congestion events, to idle\n  \
    \    and application-limited periods, and to the DCCP Data Dropped and\n     \
    \ Slow Receiver options.  CCIDs that implement per-packet congestion\n      control\
    \ SHOULD discuss how packet size is factored in to\n      congestion control decisions.\n\
    \   o  The profile MUST specify when acknowledgement packets are\n      generated\
    \ and how they are congestion controlled.\n   o  The profile MUST define when\
    \ a sender using the CCID is considered\n      quiescent.\n   o  The profile MUST\
    \ say whether its CCID's acknowledgements ever need\n      to be acknowledged\
    \ and, if so, how often.\n"
- title: 10.5.  Congestion State
  contents:
  - "10.5.  Congestion State\n   Most congestion control algorithms depend on past\
    \ history to\n   determine the current allowed sending rate.  In CCID 2, this\n\
    \   congestion state includes a congestion window and a measurement of\n   the\
    \ number of packets outstanding in the network; in CCID 3, it\n   includes the\
    \ lengths of recent loss intervals.  Both CCIDs use an\n   estimate of the round-trip\
    \ time.  Congestion state depends on the\n   network path and is invalidated by\
    \ path changes.  Therefore, DCCP\n   senders and receivers SHOULD reset their\
    \ congestion state --\n   essentially restarting congestion control from \"slow\
    \ start\" or\n   equivalent -- on significant changes in the end-to-end path.\
    \  For\n   example, an endpoint that sends or receives a Mobile IPv6 Binding\n\
    \   Update message [RFC3775] SHOULD reset its congestion state for any\n   corresponding\
    \ DCCP connections.\n   A DCCP implementation MAY also reset its congestion state\
    \ when a CCID\n   changes (that is, when a negotiation for the CCID feature completes\n\
    \   successfully and the new feature value differs from the old value).\n   Thus,\
    \ a connection in a heavily congested environment might evade\n   end-to-end congestion\
    \ control by frequently renegotiating a CCID,\n   just as it could evade end-to-end\
    \ congestion control by opening new\n   connections for the same session.  This\
    \ behavior is prohibited.  To\n   prevent it, DCCP implementations MAY limit the\
    \ rate at which CCID can\n   be changed -- for instance, by refusing to change\
    \ a CCID feature\n   value more than once per minute.\n"
- title: 11.  Acknowledgements
  contents:
  - "11.  Acknowledgements\n   Congestion control requires that receivers transmit\
    \ information about\n   packet losses and ECN marks to senders.  DCCP receivers\
    \ MUST report\n   all congestion they see, as defined by the relevant CCID profile.\n\
    \   Each CCID says when acknowledgements should be sent, what options\n   they\
    \ must use, and so on.  DCCP acknowledgements are congestion\n   controlled, although\
    \ it is not required that the acknowledgement\n   stream be more than very roughly\
    \ TCP friendly; each CCID defines how\n   acknowledgements are congestion controlled.\n\
    \   Most acknowledgements use DCCP options.  For example, on a half-\n   connection\
    \ with CCID 2 (TCP-like), the receiver reports\n   acknowledgement information\
    \ using the Ack Vector option.  This\n   section describes common acknowledgement\
    \ options and shows how acks\n   using those options will commonly work.  Full\
    \ descriptions of the ack\n   mechanisms used for each CCID are laid out in the\
    \ CCID profile\n   specifications.\n   Acknowledgement options, such as Ack Vector,\
    \ depend on the DCCP\n   Acknowledgement Number and are thus only allowed on packet\
    \ types that\n   carry that number.  Acknowledgement options received on other\
    \ packet\n   types, namely DCCP-Request and DCCP-Data, MUST be ignored.  Detailed\n\
    \   acknowledgement options are not necessarily required on every packet\n   that\
    \ carries an Acknowledgement Number, however.\n"
- title: 11.1.  Acks of Acks and Unidirectional Connections
  contents:
  - "11.1.  Acks of Acks and Unidirectional Connections\n   DCCP was designed to work\
    \ well for both bidirectional and\n   unidirectional flows of data, and for connections\
    \ that transition\n   between these states.  However, acknowledgements required\
    \ for a\n   unidirectional connection are very different from those required for\n\
    \   a bidirectional connection.  In particular, unidirectional\n   connections\
    \ need to worry about acks of acks.\n   The ack-of-acks problem arises because\
    \ some acknowledgement\n   mechanisms are reliable.  For example, an HC-Receiver\
    \ using CCID 2,\n   TCP-like Congestion Control, sends Ack Vectors containing\
    \ completely\n   reliable acknowledgement information.  The HC-Sender should\n\
    \   occasionally inform the HC-Receiver that it has received an ack.  If\n   it\
    \ did not, the HC-Receiver might resend complete Ack Vector\n   information, going\
    \ back to the start of the connection, with every\n   DCCP-Ack packet!  However,\
    \ note that acks-of-acks need not be\n   reliable themselves: when an ack-of-acks\
    \ is lost, the HC-Receiver\n   will simply maintain, and periodically retransmit,\
    \ old\n   acknowledgement-related state for a little longer.  Therefore, there\n\
    \   is no need for acks-of-acks-of-acks.\n   When communication is bidirectional,\
    \ any required acks-of-acks are\n   automatically contained in normal acknowledgements\
    \ for data packets.\n   On a unidirectional connection, however, the receiver\
    \ DCCP sends no\n   data, so the sender would not normally send acknowledgements.\n\
    \   Therefore, the CCID in force on that half-connection must explicitly\n   say\
    \ whether, when, and how the HC-Sender should generate acks-of-\n   acks.\n  \
    \ For example, consider a bidirectional connection where both half-\n   connections\
    \ use the same CCID (either 2 or 3), and where DCCP B goes\n   \"quiescent\".\
    \  This means that the connection becomes unidirectional:\n   DCCP B stops sending\
    \ data and sends only DCCP-Ack packets to DCCP A.\n   In CCID 2, TCP-like Congestion\
    \ Control, DCCP B uses Ack Vector to\n   reliably communicate which packets it\
    \ has received.  As described\n   above, DCCP A must occasionally acknowledge\
    \ a pure acknowledgement\n   from DCCP B so that B can free old Ack Vector state.\
    \  For instance, A\n   might send a DCCP-DataAck packet instead of DCCP-Data every\
    \ now and\n   then.  In CCID 3, however, acknowledgement state is generally\n\
    \   bounded, so A does not need to acknowledge B's acknowledgements.\n   When\
    \ communication is unidirectional, a single CCID -- in the\n   example, the A-to-B\
    \ CCID -- controls both DCCPs' acknowledgements, in\n   terms of their content,\
    \ their frequency, and so forth.  For\n   bidirectional connections, the A-to-B\
    \ CCID governs DCCP B's\n   acknowledgements (including its acks of DCCP A's acks)\
    \ and the B-to-A\n   CCID governs DCCP A's acknowledgements.\n   DCCP A switches\
    \ its ack pattern from bidirectional to unidirectional\n   when it notices that\
    \ DCCP B has gone quiescent.  It switches from\n   unidirectional to bidirectional\
    \ when it must acknowledge even a\n   single DCCP-Data or DCCP-DataAck packet\
    \ from DCCP B.\n   Each CCID defines how to detect quiescence on that CCID, and\
    \ how that\n   CCID handles acks-of-acks on unidirectional connections.  The B-to-A\n\
    \   CCID defines when DCCP B has gone quiescent.  Usually, this happens\n   when\
    \ a period has passed without B sending any data packets; in CCID\n   2, for example,\
    \ this period is the maximum of 0.2 seconds and two\n   round-trip times.  The\
    \ A-to-B CCID defines how DCCP A handles\n   acks-of-acks once DCCP B has gone\
    \ quiescent.\n"
- title: 11.2.  Ack Piggybacking
  contents:
  - "11.2.  Ack Piggybacking\n   Acknowledgements of A-to-B data MAY be piggybacked\
    \ on data sent by\n   DCCP B, as long as that does not delay the acknowledgement\
    \ longer\n   than the A-to-B CCID would find acceptable.  However, data\n   acknowledgements\
    \ often require more than 4 bytes to express.  A large\n   set of acknowledgements\
    \ prepended to a large data packet might exceed\n   the allowed maximum packet\
    \ size.  In this case, DCCP B SHOULD send\n   separate DCCP-Data and DCCP-Ack\
    \ packets, or wait, but not too long,\n   for a smaller datagram.\n   Piggybacking\
    \ is particularly common at DCCP A when the B-to-A\n   half-connection is quiescent\
    \ -- that is, when DCCP A is just\n   acknowledging DCCP B's acknowledgements.\
    \  There are three reasons to\n   acknowledge DCCP B's acknowledgements: to allow\
    \ DCCP B to free up\n   information about previously acknowledged data packets\
    \ from A; to\n   shrink the size of future acknowledgements; and to manipulate\
    \ the\n   rate at which future acknowledgements are sent.  Since these are\n \
    \  secondary concerns, DCCP A can generally afford to wait indefinitely\n   for\
    \ a data packet to piggyback its acknowledgement onto; if DCCP B\n   wants to\
    \ elicit an acknowledgement, it can send a DCCP-Sync.\n   Any restrictions on\
    \ ack piggybacking are described in the relevant\n   CCID's profile.\n"
- title: 11.3.  Ack Ratio Feature
  contents:
  - "11.3.  Ack Ratio Feature\n   The Ack Ratio feature lets HC-Senders influence\
    \ the rate at which\n   HC-Receivers generate DCCP-Ack packets, thus controlling\
    \ reverse-path\n   congestion.  This differs from TCP, which presently has no\
    \ congestion\n   control for pure acknowledgement traffic.  Ack Ratio reverse-path\n\
    \   congestion control does not try to be TCP friendly.  It just tries to\n  \
    \ avoid congestion collapse, and to be somewhat better than TCP in the\n   presence\
    \ of a high packet loss or mark rate on the reverse path.\n   Ack Ratio applies\
    \ to CCIDs whose HC-Receivers clock acknowledgements\n   off the receipt of data\
    \ packets.  The value of Ack Ratio/A equals the\n   rough ratio of data packets\
    \ sent by DCCP A to DCCP-Ack packets sent\n   by DCCP B.  Higher Ack Ratios correspond\
    \ to lower DCCP-Ack rates; the\n   sender raises Ack Ratio when the reverse path\
    \ is congested and lowers\n   Ack Ratio when it is not.  Each CCID profile defines\
    \ how it controls\n   congestion on the acknowledgement path, and, particularly,\
    \ whether\n   Ack Ratio is used.  CCID 2, for example, uses Ack Ratio for\n  \
    \ acknowledgement congestion control, but CCID 3 does not.  However,\n   each\
    \ Ack Ratio feature has a value whether or not that value is used\n   by the relevant\
    \ CCID.\n   Ack Ratio has feature number 5 and is non-negotiable.  It takes two-\n\
    \   byte integer values.  An Ack Ratio/A value of four means that DCCP B\n   will\
    \ send at least one acknowledgement packet for every four data\n   packets sent\
    \ by DCCP A.  DCCP A sends a \"Change L(Ack Ratio)\" option\n   to notify DCCP\
    \ B of its ack ratio.  An Ack Ratio value of zero\n   indicates that the relevant\
    \ half-connection does not use an Ack Ratio\n   to control its acknowledgement\
    \ rate.  New connections start with Ack\n   Ratio 2 for both endpoints; this Ack\
    \ Ratio results in acknowledgement\n   behavior analogous to TCP's delayed acks.\n\
    \   Ack Ratio should be treated as a guideline rather than a strict\n   requirement.\
    \  We intend Ack Ratio-controlled acknowledgement behavior\n   to resemble TCP's\
    \ acknowledgement behavior when there is no reverse-\n   path congestion, and\
    \ to be somewhat more conservative when there is\n   reverse-path congestion.\
    \  Following this intent is more important\n   than implementing Ack Ratio precisely.\
    \  In particular:\n   o  Receivers MAY piggyback acknowledgement information on\
    \ data\n      packets, creating DCCP-DataAck packets.  The Ack Ratio does not\n\
    \      apply to piggybacked acknowledgements.  However, if the data\n      packets\
    \ are too big to carry acknowledgement information, or if\n      the data sending\
    \ rate is lower than Ack Ratio would suggest, then\n      DCCP B SHOULD send enough\
    \ pure DCCP-Ack packets to maintain the\n      rate of one acknowledgement per\
    \ Ack Ratio received data packets.\n   o  Receivers MAY rate-pace their acknowledgements\
    \ rather than send\n      acknowledgements immediately upon the receipt of data\
    \ packets.\n      Receivers that rate-pace acknowledgements SHOULD pick a rate\
    \ that\n      approximates the effect of Ack Ratio and SHOULD include Elapsed\n\
    \      Time options (Section 13.2) to help the sender calculate round-\n     \
    \ trip times.\n   o  Receivers SHOULD implement delayed acknowledgement timers\
    \ like\n      TCP's, whereby any packet's acknowledgement is delayed by at most\n\
    \      T seconds.  This delay lets the receiver collect additional\n      packets\
    \ to acknowledge and thus reduce the per-packet overhead of\n      acknowledgements;\
    \ but if T seconds have passed by and the ack is\n      still around, it is sent\
    \ out right away.  The default value of T\n      should be 0.2 seconds, as is\
    \ common in TCP implementations.  This\n      may lead to sending more acknowledgement\
    \ packets than Ack Ratio\n      would suggest.\n   o  Receivers SHOULD send acknowledgements\
    \ immediately on receiving\n      packets marked ECN Congestion Experienced or\
    \ packets whose out-\n      of-order sequence numbers potentially indicate loss.\
    \  However,\n      there is no need to send such immediate acknowledgements for\n\
    \      marked packets more than once per round-trip time.\n   o  Receivers MAY\
    \ ignore Ack Ratio if they perform their own\n      congestion control on acknowledgements.\
    \  For example, a receiver\n      that knows the loss and mark rate for its DCCP-Ack\
    \ packets might\n      maintain a TCP-friendly acknowledgement rate on its own.\
    \  Such a\n      receiver MUST either ensure that it always obtains sufficient\n\
    \      acknowledgement loss and mark information or fall back to Ack\n      Ratio\
    \ when sufficient information is not available, as might\n      happen during\
    \ periods when the receiver is quiescent.\n"
- title: 11.4.  Ack Vector Options
  contents:
  - "11.4.  Ack Vector Options\n   The Ack Vector gives a run-length encoded history\
    \ of data packets\n   received at the client.  Each byte of the vector gives the\
    \ state of\n   that data packet in the loss history, and the number of preceding\n\
    \   packets with the same state.  The option's data looks like this:\n   +--------+--------+--------+--------+--------+--------\n\
    \   |0010011?| Length |SSLLLLLL|SSLLLLLL|SSLLLLLL|  ...\n   +--------+--------+--------+--------+--------+--------\n\
    \   Type=38/39         \\___________ Vector ___________...\n   The two Ack Vector\
    \ options (option types 38 and 39) differ only in\n   the values they imply for\
    \ ECN Nonce Echo.  Section 12.2 describes\n   this further.\n   The vector itself\
    \ consists of a series of bytes, each of whose\n   encoding is:\n    0 1 2 3 4\
    \ 5 6 7\n   +-+-+-+-+-+-+-+-+\n   |Sta| Run Length|\n   +-+-+-+-+-+-+-+-+\n  \
    \ Sta[te] occupies the most significant two bits of each byte and can\n   have\
    \ one of four values, as follows:\n                    State  Meaning\n      \
    \              -----  -------\n                      0    Received\n         \
    \             1    Received ECN Marked\n                      2    Reserved\n\
    \                      3    Not Yet Received\n                  Table 6: DCCP\
    \ Ack Vector States\n   The term \"ECN marked\" refers to packets with ECN code\
    \ point 11, CE\n   (Congestion Experienced); packets received with this ECN code\
    \ point\n   MUST be reported using State 1, Received ECN Marked.  Packets\n  \
    \ received with ECN code points 00, 01, or 10 (Non-ECT, ECT(0), or\n   ECT(1),\
    \ respectively) MUST be reported using State 0, Received.\n   Run Length, the\
    \ least significant six bits of each byte, specifies\n   how many consecutive\
    \ packets have the given State.  Run Length zero\n   says the corresponding State\
    \ applies to one packet only; Run Length\n   63 says it applies to 64 consecutive\
    \ packets.  Run lengths of 65 or\n   more must be encoded in multiple bytes.\n\
    \   The first byte in the first Ack Vector option refers to the packet\n   indicated\
    \ in the Acknowledgement Number; subsequent bytes refer to\n   older packets.\
    \  Ack Vector MUST NOT be sent on DCCP-Data and DCCP-\n   Request packets, which\
    \ lack an Acknowledgement Number, and any Ack\n   Vector options encountered on\
    \ such packets MUST be ignored.\n   An Ack Vector containing the decimal values\
    \ 0,192,3,64,5 and for\n   which the Acknowledgement Number is decimal 100 indicates\
    \ that:\n      Packet 100 was received (Acknowledgement Number 100, State 0, Run\n\
    \      Length 0);\n      Packet 99 was lost (State 3, Run Length 0);\n      Packets\
    \ 98, 97, 96 and 95 were received (State 0, Run Length 3);\n      Packet 94 was\
    \ ECN marked (State 1, Run Length 0); and\n      Packets 93, 92, 91, 90, 89, and\
    \ 88 were received (State 0, Run\n      Length 5).\n   A single Ack Vector option\
    \ can acknowledge up to 16192 data packets.\n   Should more packets need to be\
    \ acknowledged than can fit in 253 bytes\n   of Ack Vector, then multiple Ack\
    \ Vector options can be sent; the\n   second Ack Vector begins where the first\
    \ left off, and so forth.\n   Ack Vector states are subject to two general constraints.\
    \  (These\n   principles SHOULD also be followed for other acknowledgement\n \
    \  mechanisms; referring to Ack Vector states simplifies their\n   explanation.)\n\
    \   1. Packets reported as State 0 or State 1 MUST be acknowledgeable:\n     \
    \ their options have been processed by the receiving DCCP stack.\n      Any data\
    \ on the packet need not have been delivered to the\n      receiving application;\
    \ in fact, the data may have been dropped.\n   2. Packets reported as State 3\
    \ MUST NOT be acknowledgeable.  Feature\n      negotiations and options on such\
    \ packets MUST NOT have been\n      processed, and the Acknowledgement Number\
    \ MUST NOT correspond to\n      such a packet.\n   Packets dropped in the application's\
    \ receive buffer MUST be reported\n   as Received or Received ECN Marked (States\
    \ 0 and 1), depending on\n   their ECN state; such packets' ECN Nonces MUST be\
    \ included in the\n   Nonce Echo.  The Data Dropped option informs the sender\
    \ that some\n   packets reported as received actually had their application data\n\
    \   dropped.\n   One or more Ack Vector options that, together, report the status\
    \ of a\n   packet with a sequence number less than ISN, the initial sequence\n\
    \   number, SHOULD be considered invalid.  The receiving DCCP SHOULD\n   either\
    \ ignore the options or reset the connection with Reset Code 5,\n   \"Option Error\"\
    .  No Ack Vector option can refer to a packet that has\n   not yet been sent,\
    \ as the Acknowledgement Number checks in Section\n   7.5.3 ensure, but because\
    \ of attack, implementation bug, or\n   misbehavior, an Ack Vector option can\
    \ claim that a packet was\n   received before it is actually delivered.  Section\
    \ 12.2 describes how\n   this is detected and how senders should react.  Packets\
    \ that haven't\n   been included in any Ack Vector option SHOULD be treated as\
    \ \"not yet\n   received\" (State 3) by the sender.\n   Appendix A provides a\
    \ non-normative description of the details of\n   DCCP acknowledgement handling\
    \ in the context of an abstract Ack\n   Vector implementation.\n"
- title: 11.4.1.  Ack Vector Consistency
  contents:
  - "11.4.1.  Ack Vector Consistency\n   A DCCP sender will commonly receive multiple\
    \ acknowledgements for\n   some of its data packets.  For instance, an HC-Sender\
    \ might receive\n   two DCCP-Acks with Ack Vectors, both of which contained information\n\
    \   about sequence number 24.  (Information about a sequence number is\n   generally\
    \ repeated in every ack until the HC-Sender acknowledges an\n   ack.  In this\
    \ case, perhaps the HC-Receiver is sending acks faster\n   than the HC-Sender\
    \ is acknowledging them.)  In a perfect world, the\n   two Ack Vectors would always\
    \ be consistent.  However, there are many\n   reasons why they might not be. \
    \ For example:\n   o  The HC-Receiver received packet 24 between sending its acks,\
    \ so\n      the first ack said 24 was not received (State 3) and the second\n\
    \      said it was received or ECN marked (State 0 or 1).\n   o  The HC-Receiver\
    \ received packet 24 between sending its acks, and\n      the network reordered\
    \ the acks.  In this case, the packet will\n      appear to transition from State\
    \ 0 or 1 to State 3.\n   o  The network duplicated packet 24, and one of the duplicates\
    \ was\n      ECN marked.  This might show up as a transition between States 0\n\
    \      and 1.\n   To cope with these situations, HC-Sender DCCP implementations\
    \ SHOULD\n   combine multiple received Ack Vector states according to this table:\n\
    \                               Received State\n                             \
    \    0   1   3\n                               +---+---+---+\n               \
    \              0 | 0 |0/1| 0 |\n                       Old     +---+---+---+\n\
    \                             1 | 1 | 1 | 1 |\n                      State   \
    \ +---+---+---+\n                             3 | 0 | 1 | 3 |\n              \
    \                 +---+---+---+\n   To read the table, choose the row corresponding\
    \ to the packet's old\n   state and the column corresponding to the packet's state\
    \ in the newly\n   received Ack Vector; then read the packet's new state off the\
    \ table.\n   For an old state of 0 (received non-marked) and received state of\
    \ 1\n   (received ECN marked), the packet's new state may be set to either 0\n\
    \   or 1.  The HC-Sender implementation will be indifferent to ack\n   reordering\
    \ if it chooses new state 1 for that cell.\n   The HC-Receiver should collect\
    \ information about received packets\n   according to the following table:\n \
    \                             Received Packet\n                              \
    \   0   1   3\n                               +---+---+---+\n                \
    \             0 | 0 |0/1| 0 |\n                     Stored    +---+---+---+\n\
    \                             1 |0/1| 1 | 1 |\n                      State   \
    \ +---+---+---+\n                             3 | 0 | 1 | 3 |\n              \
    \                 +---+---+---+\n   This table equals the sender's table except\
    \ that, when the stored\n   state is 1 and the received state is 0, the receiver\
    \ is allowed to\n   switch its stored state to 0.\n   An HC-Sender MAY choose\
    \ to throw away old information gleaned from\n   the HC-Receiver's Ack Vectors,\
    \ in which case it MUST ignore newly\n   received acknowledgements from the HC-Receiver\
    \ for those old packets.\n   It is often kinder to save recent Ack Vector information\
    \ for a while\n   so that the HC-Sender can undo its reaction to presumed congestion\n\
    \   when a \"lost\" packet unexpectedly shows up (the transition from State\n\
    \   3 to State 0).\n"
- title: 11.4.2.  Ack Vector Coverage
  contents:
  - "11.4.2.  Ack Vector Coverage\n   We can divide the packets that have been sent\
    \ from an HC-Sender to an\n   HC-Receiver into four roughly contiguous groups.\
    \  From oldest to\n   youngest, these are:\n   1. Packets already acknowledged\
    \ by the HC-Receiver, where the\n      HC-Receiver knows that the HC-Sender has\
    \ definitely received the\n      acknowledgements;\n   2. Packets already acknowledged\
    \ by the HC-Receiver, where the\n      HC-Receiver cannot be sure that the HC-Sender\
    \ has received the\n      acknowledgements;\n   3. Packets not yet acknowledged\
    \ by the HC-Receiver; and\n   4. Packets not yet received by the HC-Receiver.\n\
    \   The union of groups 2 and 3 is called the Acknowledgement Window.\n   Generally,\
    \ every Ack Vector generated by the HC-Receiver will cover\n   the whole Acknowledgement\
    \ Window: Ack Vector acknowledgements are\n   cumulative.  (This simplifies Ack\
    \ Vector maintenance at the\n   HC-Receiver; see Appendix A, below.)  As packets\
    \ are received, this\n   window both grows on the right and shrinks on the left.\
    \  It grows\n   because there are more packets, and shrinks because the HC-Sender's\n\
    \   Acknowledgement Numbers will acknowledge previous acknowledgements,\n   moving\
    \ packets from group 2 into group 1.\n"
- title: 11.5.  Send Ack Vector Feature
  contents:
  - "11.5.  Send Ack Vector Feature\n   The Send Ack Vector feature lets DCCPs negotiate\
    \ whether they should\n   use Ack Vector options to report congestion.  Ack Vector\
    \ provides\n   detailed loss information and lets senders report back to their\n\
    \   applications whether particular packets were dropped.  Send Ack\n   Vector\
    \ is mandatory for some CCIDs and optional for others.\n   Send Ack Vector has\
    \ feature number 6 and is server-priority.  It\n   takes one-byte Boolean values.\
    \  DCCP A MUST send Ack Vector options\n   on its acknowledgements when Send Ack\
    \ Vector/A has value one,\n   although it MAY send Ack Vector options even when\
    \ Send Ack Vector/A\n   is zero.  Values of two or more are reserved.  New connections\
    \ start\n   with Send Ack Vector 0 for both endpoints.  DCCP B sends a \"Change\n\
    \   R(Send Ack Vector, 1)\" option to DCCP A to ask A to send Ack Vector\n   options\
    \ as part of its acknowledgement traffic.\n"
- title: 11.6.  Slow Receiver Option
  contents:
  - "11.6.  Slow Receiver Option\n   An HC-Receiver sends the Slow Receiver option\
    \ to its sender to\n   indicate that it is having trouble keeping up with the\
    \ sender's data.\n   The HC-Sender SHOULD NOT increase its sending rate for approximately\n\
    \   one round-trip time after seeing a packet with a Slow Receiver\n   option.\
    \  After one round-trip time, the effect of Slow Receiver\n   disappears, allowing\
    \ the HC-Sender to increase its rate.  Therefore,\n   the HC-Receiver SHOULD continue\
    \ to send Slow Receiver options if it\n   needs to prevent the HC-Sender from\
    \ going faster in the long term.\n   The Slow Receiver option does not indicate\
    \ congestion, and the HC-\n   Sender need not reduce its sending rate.  (If necessary,\
    \ the receiver\n   can force the sender to slow down by dropping packets, with\
    \ or\n   without Data Dropped, or by reporting false ECN marks.)  APIs should\n\
    \   let receiver applications set Slow Receiver and sending applications\n   determine\
    \ whether their receivers are Slow.\n   Slow Receiver is a one-byte option.\n\
    \   +--------+\n   |00000010|\n   +--------+\n    Type=2\n   Slow Receiver does\
    \ not specify why the receiver is having trouble\n   keeping up with the sender.\
    \  Possible reasons include lack of buffer\n   space, CPU overload, and application\
    \ quotas.  A sending application\n   might react to Slow Receiver by reducing\
    \ its application-level\n   sending rate, for example.\n   The sending application\
    \ should not react to Slow Receiver by sending\n   more data, however.  Although\
    \ the optimal response to a CPU-bound\n   receiver might be to reduce compression\
    \ and send more data (a\n   highly-compressed data format might overwhelm a slow\
    \ CPU more\n   seriously than would the higher memory requirements of a less-\n\
    \   compressed data format), this kind of format change should be\n   requested\
    \ at the application level, not via the Slow Receiver option.\n   Slow Receiver\
    \ implements a portion of TCP's receive window\n   functionality.\n"
- title: 11.7.  Data Dropped Option
  contents:
  - "11.7.  Data Dropped Option\n   The Data Dropped option indicates that the application\
    \ data on one or\n   more received packets did not actually reach the application.\
    \  Data\n   Dropped additionally reports why the data was dropped: perhaps the\n\
    \   data was corrupt, or perhaps the receiver cannot keep up with the\n   sender's\
    \ current rate and the data was dropped in some receive\n   buffer.  Using Data\
    \ Dropped, DCCP endpoints can discriminate between\n   different kinds of loss;\
    \ this differs from TCP, in which all loss is\n   reported the same way.\n   Unless\
    \ it is explicitly specified otherwise, DCCP congestion control\n   mechanisms\
    \ MUST react as if each Data Dropped packet was marked as\n   ECN Congestion Experienced\
    \ by the network.  We intend for Data\n   Dropped to enable research into richer\
    \ congestion responses to\n   corrupt and other endpoint-dropped packets, but\
    \ DCCP CCIDs MUST react\n   conservatively to Data Dropped until this behavior\
    \ is standardized.\n   Section 11.7.2, below, describes congestion responses for\
    \ all current\n   Drop Codes.\n   If a received packet's application data is dropped\
    \ for one of the\n   reasons listed below, this SHOULD be reported using a Data\
    \ Dropped\n   option.  Alternatively, the receiver MAY choose to report as\n \
    \  \"received\" only those packets whose data were not dropped, subject to\n \
    \  the constraint that packets not reported as received MUST NOT have\n   had\
    \ their options processed.\n   The option's data looks like this:\n   +--------+--------+--------+--------+--------+--------\n\
    \   |00101000| Length | Block  | Block  | Block  |  ...\n   +--------+--------+--------+--------+--------+--------\n\
    \    Type=40          \\___________ Vector ___________ ...\n   The Vector consists\
    \ of a series of bytes, called Blocks, each of\n   whose encoding corresponds\
    \ to one of two choices:\n    0 1 2 3 4 5 6 7                  0 1 2 3 4 5 6 7\n\
    \   +-+-+-+-+-+-+-+-+                +-+-+-+-+-+-+-+-+\n   |0| Run Length  | \
    \      or       |1|DrpCd|Run Len|\n   +-+-+-+-+-+-+-+-+                +-+-+-+-+-+-+-+-+\n\
    \     Normal Block                      Drop Block\n   The first byte in the first\
    \ Data Dropped option refers to the packet\n   indicated by the Acknowledgement\
    \ Number; subsequent bytes refer to\n   older packets.  Data Dropped MUST NOT\
    \ be sent on DCCP-Data or DCCP-\n   Request packets, which lack an Acknowledgement\
    \ Number, and any Data\n   Dropped options received on such packets MUST be ignored.\n\
    \   Normal Blocks, which have high bit 0, indicate that any received\n   packets\
    \ in the Run Length had their data delivered to the\n   application.  Drop Blocks,\
    \ which have high bit 1, indicate that\n   received packets in the Run Len[gth]\
    \ were not delivered as usual.\n   The 3-bit Drop Code [DrpCd] field says what\
    \ happened; generally, no\n   data from that packet reached the application. \
    \ Packets reported as\n   \"not yet received\" MUST be included in Normal Blocks;\
    \ packets not\n   covered by any Data Dropped option are treated as if they were\
    \ in a\n   Normal Block.  Defined Drop Codes for Drop Blocks are as follows.\n\
    \                  Drop Code  Meaning\n                  ---------  -------\n\
    \                      0      Protocol Constraints\n                      1  \
    \    Application Not Listening\n                      2      Receive Buffer\n\
    \                      3      Corrupt\n                     4-6     Reserved\n\
    \                      7      Delivered Corrupt\n                   Table 7: DCCP\
    \ Drop Codes\n   In more detail:\n      0   The packet data was dropped due to\
    \ protocol constraints.  For\n          example, the data was included on a DCCP-Request\
    \ packet, but\n          the receiving application does not allow such piggybacking;\
    \ or\n          the data was included on a packet with inappropriately low\n \
    \         Checksum Coverage.\n      1   The packet data was dropped because the\
    \ application is no\n          longer listening.  See Section 11.7.2.\n      2\
    \   The packet data was dropped in a receive buffer, probably\n          because\
    \ of receive buffer overflow.  See Section 11.7.2.\n      3   The packet data\
    \ was dropped due to corruption.  See Section\n          9.3.\n      7   The packet\
    \ data was corrupted but was delivered to the\n          application anyway. \
    \ See Section 9.3.\n   For example, assume that a packet arrives with Acknowledgement\
    \ Number\n   100, an Ack Vector reporting all packets as received, and a Data\n\
    \   Dropped option containing the decimal values 0,160,3,162.  Then:\n      Packet\
    \ 100 was received (Acknowledgement Number 100, Normal Block,\n      Run Length\
    \ 0).\n      Packet 99 was dropped in a receive buffer (Drop Block, Drop Code\n\
    \      2, Run Length 0).\n      Packets 98, 97, 96, and 95 were received (Normal\
    \ Block, Run Length\n      3).\n      Packets 95, 94, and 93 were dropped in the\
    \ receive buffer (Drop\n      Block, Drop Code 2, Run Length 2).\n   Run lengths\
    \ of more than 128 (for Normal Blocks) or 16 (for Drop\n   Blocks) must be encoded\
    \ in multiple Blocks.  A single Data Dropped\n   option can acknowledge up to\
    \ 32384 Normal Block data packets,\n   although the receiver SHOULD NOT send a\
    \ Data Dropped option when all\n   relevant packets fit into Normal Blocks.  Should\
    \ more packets need to\n   be acknowledged than can fit in 253 bytes of Data Dropped,\
    \ then\n   multiple Data Dropped options can be sent.  The second option will\n\
    \   begin where the first left off, and so forth.\n   One or more Data Dropped\
    \ options that, together, report the status of\n   more packets than have been\
    \ sent, or that change the status of a\n   packet, or that disagree with Ack Vector\
    \ or equivalent options (by\n   reporting a \"not yet received\" packet as \"\
    dropped in the receive\n   buffer\", for example) SHOULD be considered invalid.\
    \  The receiving\n   DCCP SHOULD either ignore such options, or respond by resetting\
    \ the\n   connection with Reset Code 5, \"Option Error\".\n   A DCCP application\
    \ interface should let receiving applications\n   specify the Drop Codes corresponding\
    \ to received packets.  For\n   example, this would let applications calculate\
    \ their own checksums\n   but still report \"dropped due to corruption\" packets\
    \ via the Data\n   Dropped option.  The interface SHOULD NOT let applications\
    \ reduce the\n   \"seriousness\" of a packet's Drop Code; for example, the application\n\
    \   should not be able to upgrade a packet from delivered corrupt (Drop\n   Code\
    \ 7) to delivered normally (no Drop Code).\n   Data Dropped information is transmitted\
    \ reliably.  That is, endpoints\n   SHOULD continue to transmit Data Dropped options\
    \ until receiving an\n   acknowledgement indicating that the relevant options\
    \ have been\n   processed.  In Ack Vector terms, each acknowledgement should contain\n\
    \   Data Dropped options that cover the whole Acknowledgement Window\n   (Section\
    \ 11.4.2), although when every packet in that window would be\n   placed in a\
    \ Normal Block, no actual option is required.\n"
- title: 11.7.1.  Data Dropped and Normal Congestion Response
  contents:
  - "11.7.1.  Data Dropped and Normal Congestion Response\n   When deciding on a response\
    \ to a particular acknowledgement or set of\n   acknowledgements containing Data\
    \ Dropped options, a congestion\n   control mechanism MUST consider dropped packets,\
    \ ECN Congestion\n   Experienced marks (including marked packets that are included\
    \ in Data\n   Dropped), and packets singled out in Data Dropped.  For window-based\n\
    \   mechanisms, the valid response space is defined as follows.\n   Assume an\
    \ old window of W.  Independently calculate a new window\n   W_new1 that assumes\
    \ no packets were Data Dropped (so W_new1 contains\n   only the normal congestion\
    \ response), and a new window W_new2 that\n   assumes no packets were lost or\
    \ marked (so W_new2 contains only the\n   Data Dropped response).  We are assuming\
    \ that Data Dropped\n   recommended a reduction in congestion window, so W_new2\
    \ < W.\n   Then the actual new window W_new MUST NOT be larger than the minimum\n\
    \   of W_new1 and W_new2; and the sender MAY combine the two responses,\n   by\
    \ setting\n         W_new = W + min(W_new1 - W, 0) + min(W_new2 - W, 0).\n   The\
    \ details of how this is accomplished are specified in CCID profile\n   documents.\
    \  Non-window-based congestion control mechanisms MUST\n   behave analogously;\
    \ again, CCID profiles define how.\n"
- title: 11.7.2.  Particular Drop Codes
  contents:
  - "11.7.2.  Particular Drop Codes\n   Drop Code 0, Protocol Constraints, does not\
    \ indicate any kind of\n   congestion, so the sender's CCID SHOULD react to packets\
    \ with Drop\n   Code 0 as if they were received (with or without ECN Congestion\n\
    \   Experienced marks, as appropriate).  However, the sending endpoint\n   SHOULD\
    \ NOT send data until it believes the protocol constraint no\n   longer applies.\n\
    \   Drop Code 1, Application Not Listening, means the application running\n  \
    \ at the endpoint that sent the option is no longer listening for data.\n   For\
    \ example, a server might close its receiving half-connection to\n   new data\
    \ after receiving a complete request from the client.  This\n   would limit the\
    \ amount of state available at the server for incoming\n   data and thus reduce\
    \ the potential damage from certain denial-of-\n   service attacks.  A Data Dropped\
    \ option containing Drop Code 1 SHOULD\n   be sent whenever received data is ignored\
    \ due to a non-listening\n   application.  Once an endpoint reports Drop Code\
    \ 1 for a packet, it\n   SHOULD report Drop Code 1 for every succeeding data packet\
    \ on that\n   half-connection; once an endpoint receives a Drop State 1 report,\
    \ it\n   SHOULD expect that no more data will ever be delivered to the other\n\
    \   endpoint's application, so it SHOULD NOT send more data.\n   Drop Code 2,\
    \ Receive Buffer, indicates congestion inside the\n   receiving host.  For instance,\
    \ if a drop-from-tail kernel socket\n   buffer is too full to accept a packet's\
    \ application data, that packet\n   should be reported as Drop Code 2.  For a\
    \ drop-from-head or more\n   complex socket buffer, the dropped packet should\
    \ be reported as Drop\n   Code 2.  DCCP implementations may also provide an API\
    \ by which\n   applications can mark received packets as Drop Code 2, indicating\n\
    \   that the application ran out of space in its user-level receive\n   buffer.\
    \  (However, it is not generally useful to report packets as\n   dropped due to\
    \ Drop Code 2 after more than a couple of round-trip\n   times have passed.  The\
    \ HC-Sender may have forgotten its\n   acknowledgement state for the packet by\
    \ that time, so the Data\n   Dropped report will have no effect.)  Every packet\
    \ newly acknowledged\n   as Drop Code 2 SHOULD reduce the sender's instantaneous\
    \ rate by one\n   packet per round-trip time, unless the sender is already sending\
    \ one\n   packet per RTT or less.  Each CCID profile defines the CCID-specific\n\
    \   mechanism by which this is accomplished.\n   Currently, the other Drop Codes\
    \ (namely Drop Code 3, Corrupt; Drop\n   Code 7, Delivered Corrupt; and reserved\
    \ Drop Codes 4-6) MUST cause\n   the relevant CCID to behave as if the relevant\
    \ packets were ECN\n   marked (ECN Congestion Experienced).\n"
- title: 12.  Explicit Congestion Notification
  contents:
  - "12.  Explicit Congestion Notification\n   The DCCP protocol is fully ECN-aware\
    \ [RFC3168].  Each CCID specifies\n   how its endpoints respond to ECN marks.\
    \  Furthermore, DCCP, unlike\n   TCP, allows senders to control the rate at which\
    \ acknowledgements are\n   generated (with options like Ack Ratio); since acknowledgements\
    \ are\n   congestion controlled, they also qualify as ECN-Capable Transport.\n\
    \   Each CCID profile describes how that CCID interacts with ECN, both\n   for\
    \ data traffic and pure-acknowledgement traffic.  A sender SHOULD\n   set ECN-Capable\
    \ Transport on its packets' IP headers unless the\n   receiver's ECN Incapable\
    \ feature is on or the relevant CCID disallows\n   it.\n   The rest of this section\
    \ describes the ECN Incapable feature and the\n   interaction of the ECN Nonce\
    \ with acknowledgement options such as Ack\n   Vector.\n"
- title: 12.1.  ECN Incapable Feature
  contents:
  - "12.1.  ECN Incapable Feature\n   DCCP endpoints are ECN-aware by default, but\
    \ the ECN Incapable\n   feature lets an endpoint reject the use of Explicit Congestion\n\
    \   Notification.  The use of this feature is NOT RECOMMENDED.  ECN\n   incapability\
    \ both avoids ECN's possible benefits and prevents senders\n   from using the\
    \ ECN Nonce to check for receiver misbehavior.  A DCCP\n   stack MAY therefore\
    \ leave the ECN Incapable feature unimplemented,\n   acting as if all connections\
    \ were ECN capable.  Note that the\n   inappropriate firewall interactions that\
    \ dogged TCP's implementation\n   of ECN [RFC3360] involve TCP header bits, not\
    \ the IP header's ECN\n   bits; we know of no middlebox that would block ECN-capable\
    \ DCCP\n   packets but allow ECN-incapable DCCP packets.\n   ECN Incapable has\
    \ feature number 4 and is server-priority.  It takes\n   one-byte Boolean values.\
    \  DCCP A MUST be able to read ECN bits from\n   received frames' IP headers when\
    \ ECN Incapable/A is zero.  (This is\n   independent of whether it can set ECN\
    \ bits on sent frames.)  DCCP A\n   thus sends a \"Change L(ECN Inapable, 1)\"\
    \ option to DCCP B to inform\n   it that A cannot read ECN bits.  If the ECN Incapable/A\
    \ feature is\n   one, then all of DCCP B's packets MUST be sent as ECN incapable.\
    \  New\n   connections start with ECN Incapable 0 (that is, ECN capable) for\n\
    \   both endpoints.  Values of two or more are reserved.\n   If a DCCP is not\
    \ ECN capable, it MUST send Mandatory \"Change L(ECN\n   Incapable, 1)\" options\
    \ to the other endpoint until acknowledged (by\n   \"Confirm R(ECN Incapable,\
    \ 1)\") or the connection closes.\n   Furthermore, it MUST NOT accept any data\
    \ until the other endpoint\n   sends \"Confirm R(ECN Incapable, 1)\".  It SHOULD\
    \ send Data Dropped\n   options on its acknowledgements, with Drop Code 0 (\"\
    protocol\n   constraints\"), if the other endpoint does send data inappropriately.\n"
- title: 12.2.  ECN Nonces
  contents:
  - "12.2.  ECN Nonces\n   Congestion avoidance will not occur, and the receiver will\
    \ sometimes\n   get its data faster, if the sender isn't told about congestion\n\
    \   events.  Thus, the receiver has some incentive to falsify\n   acknowledgement\
    \ information, reporting that marked or dropped packets\n   were actually received\
    \ unmarked.  This problem is more serious with\n   DCCP than with TCP, since TCP\
    \ provides reliable transport: it is more\n   difficult with TCP to lie about\
    \ lost packets without breaking the\n   application.\n   ECN Nonces are a general\
    \ mechanism to prevent ECN cheating (or loss\n   cheating).  Two values for the\
    \ two-bit ECN header field indicate\n   ECN-Capable Transport, 01 and 10.  The\
    \ second code point, 10, is the\n   ECN Nonce.  In general, a protocol sender\
    \ chooses between these code\n   points randomly on its output packets, remembering\
    \ the sequence it\n   chose.  On every acknowledgement, the protocol receiver\
    \ reports the\n   number of ECN Nonces it has received thus far.  This is called\
    \ the\n   ECN Nonce Echo.  Since ECN marking and packet dropping both destroy\n\
    \   the ECN Nonce, a receiver that lies about an ECN mark or packet drop\n   has\
    \ a 50% chance of guessing right and avoiding discipline.  The\n   sender may\
    \ react punitively to an ECN Nonce mismatch, possibly up to\n   dropping the connection.\
    \  The ECN Nonce Echo field need not be an\n   integer; one bit is enough to catch\
    \ 50% of infractions, and the\n   probability of success drops exponentially as\
    \ more packets are sent\n   [RFC3540].\n   In DCCP, the ECN Nonce Echo field is\
    \ encoded in acknowledgement\n   options.  For example, the Ack Vector option\
    \ comes in two forms, Ack\n   Vector [Nonce 0] (option 38) and Ack Vector [Nonce\
    \ 1] (option 39),\n   corresponding to the two values for a one-bit ECN Nonce\
    \ Echo.  The\n   Nonce Echo for a given Ack Vector equals the one-bit sum (exclusive-\n\
    \   or, or parity) of ECN nonces for packets reported by that Ack Vector\n   as\
    \ received and not ECN marked.  Thus, only packets marked as State 0\n   matter\
    \ for this calculation (that is, valid received packets that\n   were not ECN\
    \ marked).  Every Ack Vector option is detailed enough for\n   the sender to determine\
    \ what the Nonce Echo should have been.  It can\n   check this calculation against\
    \ the actual Nonce Echo and complain if\n   there is a mismatch.  (The Ack Vector\
    \ could conceivably report every\n   packet's ECN Nonce state, but this would\
    \ severely limit its\n   compressibility without providing much extra protection.)\n\
    \   Each DCCP sender SHOULD set ECN Nonces on its packets and remember\n   which\
    \ packets had nonces.  When a sender detects an ECN Nonce Echo\n   mismatch, it\
    \ behaves as described in the next section.  Each DCCP\n   receiver MUST calculate\
    \ and use the correct value for ECN Nonce Echo\n   when sending acknowledgement\
    \ options.\n   ECN incapability, as indicated by the ECN Incapable feature, is\n\
    \   handled as follows: an endpoint sending packets to an ECN-incapable\n   receiver\
    \ MUST send its packets as ECN incapable, and an ECN-\n   incapable receiver MUST\
    \ use the value zero for all ECN Nonce Echoes.\n"
- title: 12.3.  Aggression Penalties
  contents:
  - "12.3.  Aggression Penalties\n   DCCP endpoints have several mechanisms for detecting\
    \ congestion-\n   related misbehavior.  For example:\n   o  A sender can detect\
    \ an ECN Nonce Echo mismatch, indicating\n      possible receiver misbehavior.\n\
    \   o  A receiver can detect whether the sender is responding to\n      congestion\
    \ feedback or Slow Receiver.\n   o  An endpoint may be able to detect that its\
    \ peer is reporting\n      inappropriately small Elapsed Time values (Section\
    \ 13.2).\n   An endpoint that detects possible congestion-related misbehavior\n\
    \   SHOULD try to verify that its peer is truly misbehaving.  For\n   example,\
    \ a sending endpoint might send a packet whose ECN header\n   field is set to\
    \ Congestion Experienced, 11; a receiver that doesn't\n   report a corresponding\
    \ mark is most likely misbehaving.\n   Upon detecting possible misbehavior, a\
    \ sender SHOULD respond as if\n   the receiver had reported one or more recent\
    \ packets as ECN-marked\n   (instead of unmarked), while a receiver SHOULD report\
    \ one or more\n   recent non-marked packets as ECN-marked.  Alternately, a sender\
    \ might\n   act as if the receiver had sent a Slow Receiver option, and a\n  \
    \ receiver might send Slow Receiver options.  Other reactions that\n   serve to\
    \ slow the transfer rate are also acceptable.  An entity that\n   detects particularly\
    \ egregious and ongoing misbehavior MAY also reset\n   the connection with Reset\
    \ Code 11, \"Aggression Penalty\".\n   However, ECN Nonce mismatches and other\
    \ warning signs can result from\n   innocent causes, such as implementation bugs\
    \ or attack.  In\n   particular, a successful DCCP-Data attack (Section 7.5.5)\
    \ can cause\n   the receiver to report an incorrect ECN Nonce Echo.  Therefore,\n\
    \   connection reset and other heavyweight mechanisms SHOULD be used only\n  \
    \ as last resorts, after multiple round-trip times of verified\n   aggression.\n"
- title: 13.  Timing Options
  contents:
  - "13.  Timing Options\n   The Timestamp, Timestamp Echo, and Elapsed Time options\
    \ help DCCP\n   endpoints explicitly measure round-trip times.\n"
- title: 13.1.  Timestamp Option
  contents:
  - "13.1.  Timestamp Option\n   This option is permitted in any DCCP packet.  The\
    \ length of the\n   option is 6 bytes.\n   +--------+--------+--------+--------+--------+--------+\n\
    \   |00101001|00000110|          Timestamp Value          |\n   +--------+--------+--------+--------+--------+--------+\n\
    \    Type=41  Length=6\n   The four bytes of option data carry the timestamp of\
    \ this packet.\n   The timestamp is a 32-bit integer that increases monotonically\
    \ with\n   time, at a rate of 1 unit per 10 microseconds.  At this rate,\n   Timestamp\
    \ Value will wrap approximately every 11.9 hours.  Endpoints\n   need not measure\
    \ time at this fine granularity; for example, an\n   endpoint that preferred to\
    \ measure time at millisecond granularity\n   might send Timestamp Values that\
    \ were all multiples of 100.  The\n   precise time corresponding to Timestamp\
    \ Value zero is not specified:\n   Timestamp Values are only meaningful relative\
    \ to other Timestamp\n   Values sent on the same connection.  A DCCP receiving\
    \ a Timestamp\n   option SHOULD respond with a Timestamp Echo option on the next\
    \ packet\n   it sends.\n"
- title: 13.2.  Elapsed Time Option
  contents:
  - "13.2.  Elapsed Time Option\n   This option is permitted in any DCCP packet that\
    \ contains an\n   Acknowledgement Number; such options received on other packet\
    \ types\n   MUST be ignored.  It indicates how much time has elapsed since the\n\
    \   packet being acknowledged -- the packet with the given\n   Acknowledgement\
    \ Number -- was received.  The option may take 4 or 6\n   bytes, depending on\
    \ the size of the Elapsed Time value.  Elapsed Time\n   helps correct round-trip\
    \ time estimates when the gap between\n   receiving a packet and acknowledging\
    \ that packet may be long -- in\n   CCID 3, for example, where acknowledgements\
    \ are sent infrequently.\n   +--------+--------+--------+--------+\n   |00101011|00000100|\
    \   Elapsed Time  |\n   +--------+--------+--------+--------+\n    Type=43   \
    \ Len=4\n   +--------+--------+--------+--------+--------+--------+\n   |00101011|00000110|\
    \            Elapsed Time           |\n   +--------+--------+--------+--------+--------+--------+\n\
    \    Type=43    Len=6\n   The option data, Elapsed Time, represents an estimated\
    \ lower bound on\n   the amount of time elapsed since the packet being acknowledged\
    \ was\n   received, with units of hundredths of milliseconds.  If Elapsed Time\n\
    \   is less than a half-second, the first, smaller form of the option\n   SHOULD\
    \ be used.  Elapsed Times of more than 0.65535 seconds MUST be\n   sent using\
    \ the second form of the option.  The special Elapsed Time\n   value 4294967295,\
    \ which corresponds to approximately 11.9 hours, is\n   used to represent any\
    \ Elapsed Time greater than 42949.67294 seconds.\n   DCCP endpoints MUST NOT report\
    \ Elapsed Times that are significantly\n   larger than the true elapsed times.\
    \  A connection MAY be reset with\n   Reset Code 11, \"Aggression Penalty\", if\
    \ one endpoint determines that\n   the other is reporting a much-too-large Elapsed\
    \ Time.\n   Elapsed Time is measured in hundredths of milliseconds as a\n   compromise\
    \ between two conflicting goals.  First, it provides enough\n   granularity to\
    \ reduce rounding error when measuring elapsed time over\n   fast LANs; second,\
    \ it allows many reasonable elapsed times to fit\n   into two bytes of data.\n"
- title: 13.3.  Timestamp Echo Option
  contents:
  - "13.3.  Timestamp Echo Option\n   This option is permitted in any DCCP packet,\
    \ as long as at least one\n   packet carrying the Timestamp option has been received.\
    \  Generally, a\n   DCCP endpoint should send one Timestamp Echo option for each\n\
    \   Timestamp option it receives, and it should send that option as soon\n   as\
    \ is convenient.  The length of the option is between 6 and 10\n   bytes, depending\
    \ on whether Elapsed Time is included and how large it\n   is.\n   +--------+--------+--------+--------+--------+--------+\n\
    \   |00101010|00000110|           Timestamp Echo          |\n   +--------+--------+--------+--------+--------+--------+\n\
    \    Type=42    Len=6\n   +--------+--------+------- ... -------+--------+--------+\n\
    \   |00101010|00001000|  Timestamp Echo   |   Elapsed Time  |\n   +--------+--------+-------\
    \ ... -------+--------+--------+\n    Type=42    Len=8       (4 bytes)\n   +--------+--------+-------\
    \ ... -------+------- ... -------+\n   |00101010|00001010|  Timestamp Echo   |\
    \    Elapsed Time   |\n   +--------+--------+------- ... -------+------- ... -------+\n\
    \    Type=42   Len=10       (4 bytes)           (4 bytes)\n   The first four bytes\
    \ of option data, Timestamp Echo, carry a\n   Timestamp Value taken from a preceding\
    \ received Timestamp option.\n   Usually, this will be the last packet that was\
    \ received -- the packet\n   indicated by the Acknowledgement Number, if any --\
    \ but it might be a\n   preceding packet.  Each Timestamp received will generally\
    \ result in\n   exactly one Timestamp Echo transmitted.  If an endpoint has received\n\
    \   multiple Timestamp options since the last time it sent a packet, then\n  \
    \ it MAY ignore all Timestamp options but the one included on the\n   packet with\
    \ the greatest sequence number.  Alternatively, it MAY\n   include multiple Timestamp\
    \ Echo options in its response, each\n   corresponding to a different Timestamp\
    \ option.\n   The Elapsed Time value, similar to that in the Elapsed Time option,\n\
    \   indicates the amount of time elapsed since receiving the packet whose\n  \
    \ timestamp is being echoed.  This time MUST have units of hundredths\n   of milliseconds.\
    \  Elapsed Time is meant to help the Timestamp sender\n   separate the network\
    \ round-trip time from the Timestamp receiver's\n   processing time.  This may\
    \ be particularly important for CCIDs where\n   acknowledgements are sent infrequently,\
    \ so that there might be\n   considerable delay between receiving a Timestamp\
    \ option and sending\n   the corresponding Timestamp Echo.  A missing Elapsed\
    \ Time field is\n   equivalent to an Elapsed Time of zero.  The smallest version\
    \ of the\n   option SHOULD be used that can hold the relevant Elapsed Time value.\n"
- title: 14.  Maximum Packet Size
  contents:
  - "14.  Maximum Packet Size\n   A DCCP implementation MUST maintain the maximum\
    \ packet size (MPS)\n   allowed for each active DCCP session.  The MPS is influenced\
    \ by the\n   maximum packet size allowed by the current congestion control\n \
    \  mechanism (CCMPS), the maximum packet size supported by the path's\n   links\
    \ (PMTU, the Path Maximum Transmission Unit) [RFC1191], and the\n   lengths of\
    \ the IP and DCCP headers.\n   A DCCP application interface SHOULD let the application\
    \ discover\n   DCCP's current MPS.  Generally, the DCCP implementation will refuse\n\
    \   to send any packet bigger than the MPS, returning an appropriate\n   error\
    \ to the application.  A DCCP interface MAY allow applications to\n   request\
    \ fragmentation for packets larger than PMTU, but not larger\n   than CCMPS. \
    \ (Packets larger than CCMPS MUST be rejected in any\n   case.)  Fragmentation\
    \ SHOULD NOT be the default, since it decreases\n   robustness: an entire packet\
    \ is discarded if even one of its\n   fragments is lost.  Applications can usually\
    \ get better error\n   tolerance by producing packets smaller than the PMTU.\n\
    \   The MPS reported to the application SHOULD be influenced by the size\n   expected\
    \ to be required for DCCP headers and options.  If the\n   application provides\
    \ data that, when combined with the options the\n   DCCP implementation would\
    \ like to include, would exceed the MPS, the\n   implementation should either\
    \ send the options on a separate packet\n   (such as a DCCP-Ack) or lower the\
    \ MPS, drop the data, and return an\n   appropriate error to the application.\n"
- title: 14.1.  Measuring PMTU
  contents:
  - "14.1.  Measuring PMTU\n   Each DCCP endpoint MUST keep track of the current PMTU\
    \ for each\n   connection, except that this is not required for IPv4 connections\n\
    \   whose applications have requested fragmentation.  The PMTU SHOULD be\n   initialized\
    \ from the interface MTU that will be used to send packets.\n   The MPS will be\
    \ initialized with the minimum of the PMTU and the\n   CCMPS, if any.\n   Classical\
    \ PMTU discovery uses unfragmentable packets.  In IPv4, these\n   packets have\
    \ the IP Don't Fragment (DF) bit set; in IPv6, all packets\n   are unfragmentable\
    \ once emitted by an end host.  As specified in\n   [RFC1191], when a router receives\
    \ a packet with DF set that is larger\n   than the next link's MTU, it sends an\
    \ ICMP Destination Unreachable\n   message back to the source whose Code indicates\
    \ that an\n   unfragmentable packet was too large to forward (a \"Datagram Too\
    \ Big\"\n   message).  When a DCCP implementation receives a Datagram Too Big\n\
    \   message, it decreases its PMTU to the Next-Hop MTU value given in the\n  \
    \ ICMP message.  If the MTU given in the message is zero, the sender\n   chooses\
    \ a value for PMTU using the algorithm described in [RFC1191],\n   Section 7.\
    \  If the MTU given in the message is greater than the\n   current PMTU, the Datagram\
    \ Too Big message is ignored, as described\n   in [RFC1191].  (We are aware that\
    \ this may cause problems for DCCP\n   endpoints behind certain firewalls.)\n\
    \   A DCCP implementation may allow the application occasionally to\n   request\
    \ that PMTU discovery be performed again.  This will reset the\n   PMTU to the\
    \ outgoing interface's MTU.  Such requests SHOULD be rate\n   limited, to one\
    \ per two seconds, for example.\n   A DCCP sender MAY treat the reception of an\
    \ ICMP Datagram Too Big\n   message as an indication that the packet being reported\
    \ was not lost\n   due to congestion, and so for the purposes of congestion control\
    \ it\n   MAY ignore the DCCP receiver's indication that this packet did not\n\
    \   arrive.  However, if this is done, then the DCCP sender MUST check\n   the\
    \ ECN bits of the IP header echoed in the ICMP message and only\n   perform this\
    \ optimization if these ECN bits indicate that the packet\n   did not experience\
    \ congestion prior to reaching the router whose link\n   MTU it exceeded.\n  \
    \ A DCCP implementation SHOULD ensure, as far as possible, that ICMP\n   Datagram\
    \ Too Big messages were actually generated by routers, so that\n   attackers cannot\
    \ drive the PMTU down to a falsely small value.  The\n   simplest way to do this\
    \ is to verify that the Sequence Number on the\n   ICMP error's encapsulated header\
    \ corresponds to a Sequence Number\n   that the implementation recently sent.\
    \  (According to current\n   specifications, routers should return the full DCCP\
    \ header and\n   payload up to a maximum of 576 bytes [RFC1812] or the minimum\
    \ IPv6\n   MTU [RFC2463], although they are not required to return more than 64\n\
    \   bits [RFC792].  Any amount greater than 128 bits will include the\n   Sequence\
    \ Number.)  ICMP Datagram Too Big messages with incorrect or\n   missing Sequence\
    \ Numbers may be ignored, or the DCCP implementation\n   may lower the PMTU only\
    \ temporarily in response.  If more than three\n   odd Datagram Too Big messages\
    \ are received and the other DCCP\n   endpoint reports more than three lost packets,\
    \ however, the DCCP\n   implementation SHOULD assume the presence of a confused\
    \ router and\n   either obey the ICMP messages' PMTU or (on IPv4 networks) switch\
    \ to\n   allowing fragmentation.\n   DCCP also allows upward probing of the PMTU\
    \ [PMTUD], where the DCCP\n   endpoint begins by sending small packets with DF\
    \ set and then\n   gradually increases the packet size until a packet is lost.\
    \  This\n   mechanism does not require any ICMP error processing.  DCCP-Sync\n\
    \   packets are the best choice for upward probing, since DCCP-Sync\n   probes\
    \ do not risk application data loss.  The DCCP implementation\n   inserts arbitrary\
    \ data into the DCCP-Sync application area, padding\n   the packet to the right\
    \ length.  Since every valid DCCP-Sync\n   generates an immediate DCCP-SyncAck\
    \ in response, the endpoint will\n   have a pretty good idea of when a probe is\
    \ lost.\n"
- title: 14.2.  Sender Behavior
  contents:
  - "14.2.  Sender Behavior\n   A DCCP sender SHOULD send every packet as unfragmentable,\
    \ as\n   described above, with the following exceptions.\n   o  On IPv4 connections\
    \ whose applications have requested\n      fragmentation, the sender SHOULD send\
    \ packets with the DF bit not\n      set.\n   o  On IPv6 connections whose applications\
    \ have requested\n      fragmentation, the sender SHOULD use fragmentation extension\n\
    \      headers to fragment packets larger than PMTU into suitably-sized\n    \
    \  chunks.  (Those chunks are, of course, unfragmentable.)\n   o  It is undesirable\
    \ for PMTU discovery to occur on the initial\n      connection setup handshake,\
    \ as the connection setup process may\n      not be representative of packet sizes\
    \ used during the connection,\n      and performing MTU discovery on the initial\
    \ handshake might\n      unnecessarily delay connection establishment.  Thus,\
    \ DCCP-Request\n      and DCCP-Response packets SHOULD be sent as fragmentable.\
    \  In\n      addition, DCCP-Reset packets SHOULD be sent as fragmentable,\n  \
    \    although typically these would be small enough to not be a\n      problem.\
    \  For IPv4 connections, these packets SHOULD be sent with\n      the DF bit not\
    \ set; for IPv6 connections, they SHOULD be\n      preemptively fragmented to\
    \ a size not larger than the relevant\n      interface MTU.\n   If the DCCP implementation\
    \ has decreased the PMTU, the sending\n   application has not requested fragmentation,\
    \ and the sending\n   application attempts to send a packet larger than the new\
    \ MPS, the\n   API MUST refuse to send the packet and return an appropriate error\
    \ to\n   the application.  The application should then use the API to query\n\
    \   the new value of MPS.  The kernel might have some packets buffered\n   for\
    \ transmission that are smaller than the old MPS but larger than\n   the new MPS.\
    \  It MAY send these packets as fragmentable, or it MAY\n   discard these packets;\
    \ it MUST NOT send them as unfragmentable.\n"
- title: 15.  Forward Compatibility
  contents:
  - "15.  Forward Compatibility\n   Future versions of DCCP may add new options and\
    \ features.  A few\n   simple guidelines will let extended DCCPs interoperate\
    \ with normal\n   DCCPs.\n   o  DCCP processors MUST NOT act punitively towards\
    \ options and\n      features they do not understand.  For example, DCCP processors\n\
    \      MUST NOT reset the connection if some field marked Reserved in\n      this\
    \ specification is non-zero; if some unknown option is present;\n      or if some\
    \ feature negotiation option mentions an unknown feature.\n      Instead, DCCP\
    \ processors MUST ignore these events.  The Mandatory\n      option is the single\
    \ exception: if Mandatory precedes some unknown\n      option or feature, the\
    \ connection MUST be reset.\n   o  DCCP processors MUST anticipate the possibility\
    \ of unknown feature\n      values, which might occur as part of a negotiation\
    \ for a known\n      feature.  For server-priority features, unknown values are\
    \ handled\n      as a matter of course: since the non-extended DCCP's priority\
    \ list\n      will not contain unknown values, the result of the negotiation\n\
    \      cannot be an unknown value.  A DCCP MUST respond with an empty\n      Confirm\
    \ option if it is assigned an unacceptable value for some\n      non-negotiable\
    \ feature.\n   o  Each DCCP extension SHOULD be controlled by some feature.  The\n\
    \      default value of this feature SHOULD correspond to \"extension not\n  \
    \    available\".  If an extended DCCP wants to use the extension, it\n      SHOULD\
    \ attempt to change the feature's value using a Change L or\n      Change R option.\
    \  Any non-extended DCCP will ignore the option,\n      thus leaving the feature\
    \ value at its default, \"extension not\n      available\".\n   Section 19 lists\
    \ DCCP assigned numbers reserved for experimental and\n   testing purposes.\n"
- title: 16.  Middlebox Considerations
  contents:
  - "16.  Middlebox Considerations\n   This section describes properties of DCCP that\
    \ firewalls, network\n   address translators, and other middleboxes should consider,\
    \ including\n   parts of the packet that middleboxes should not change.  The intent\n\
    \   is to draw attention to aspects of DCCP that may be useful, or\n   dangerous,\
    \ for middleboxes, or that differ significantly from TCP.\n   The Service Code\
    \ field in DCCP-Request packets provides information\n   that may be useful for\
    \ stateful middleboxes.  With Service Code, a\n   middlebox can tell what protocol\
    \ a connection will use without\n   relying on port numbers.  Middleboxes can\
    \ disallow connections that\n   attempt to access unexpected services by sending\
    \ a DCCP-Reset with\n   Reset Code 8, \"Bad Service Code\".  Middleboxes should\
    \ not modify the\n   Service Code unless they are really changing the service\
    \ a connection\n   is accessing.\n   The Source and Destination Port fields are\
    \ in the same packet\n   locations as the corresponding fields in TCP and UDP,\
    \ which may\n   simplify some middlebox implementations.\n   The forward compatibility\
    \ considerations in Section 15 apply to\n   middleboxes as well.  In particular,\
    \ middleboxes generally shouldn't\n   act punitively towards options and features\
    \ they do not understand.\n   Modifying DCCP Sequence Numbers and Acknowledgement\
    \ Numbers is more\n   tedious and dangerous than modifying TCP sequence numbers.\
    \  A\n   middlebox that added packets to or removed packets from a DCCP\n   connection\
    \ would have to modify acknowledgement options, such as Ack\n   Vector, and CCID-specific\
    \ options, such as TFRC's Loss Intervals, at\n   minimum.  On ECN-capable connections,\
    \ the middlebox would have to\n   keep track of ECN Nonce information for packets\
    \ it introduced or\n   removed, so that the relevant acknowledgement options continued\
    \ to\n   have correct ECN Nonce Echoes, or risk the connection being reset for\n\
    \   \"Aggression Penalty\".  We therefore recommend that middleboxes not\n   modify\
    \ packet streams by adding or removing packets.\n   Note that there is less need\
    \ to modify DCCP's per-packet sequence\n   numbers than to modify TCP's per-byte\
    \ sequence numbers; for example,\n   a middlebox can change the contents of a\
    \ packet without changing its\n   sequence number.  (In TCP, sequence number modification\
    \ is required\n   to support protocols like FTP that carry variable-length addresses\
    \ in\n   the data stream.  If such an application were deployed over DCCP,\n \
    \  middleboxes would simply grow or shrink the relevant packets as\n   necessary\
    \ without changing their sequence numbers.  This might\n   involve fragmenting\
    \ the packet.)\n   Middleboxes may, of course, reset connections in progress.\
    \  Clearly,\n   this requires inserting a packet into one or both packet streams,\
    \ but\n   the difficult issues do not arise.\n   DCCP is somewhat unfriendly to\
    \ \"connection splicing\" [SHHP00], in\n   which clients' connection attempts\
    \ are intercepted, but possibly\n   later \"spliced in\" to external server connections\
    \ via sequence number\n   manipulations.  A connection splicer at minimum would\
    \ have to ensure\n   that the spliced connections agreed on all relevant feature\
    \ values,\n   which might take some renegotiation.\n   The contents of this section\
    \ should not be interpreted as a wholesale\n   endorsement of stateful middleboxes.\n"
- title: 17.  Relations to Other Specifications
  contents:
  - '17.  Relations to Other Specifications

    '
- title: 17.1.  RTP
  contents:
  - "17.1.  RTP\n   The Real-Time Transport Protocol, RTP [RFC3550], is currently\
    \ used\n   over UDP by many of DCCP's target applications (for instance,\n   streaming\
    \ media).  Therefore, it is important to examine the\n   relationship between\
    \ DCCP and RTP and, in particular, the question of\n   whether any changes in\
    \ RTP are necessary or desirable when it is\n   layered over DCCP instead of UDP.\n\
    \   There are two potential sources of overhead in the RTP-over-DCCP\n   combination:\
    \ duplicated acknowledgement information and duplicated\n   sequence numbers.\
    \  Together, these sources of overhead add slightly\n   more than 4 bytes per\
    \ packet relative to RTP-over-UDP, and\n   eliminating the redundancy would not\
    \ reduce the overhead.\n   First, consider acknowledgements.  Both RTP and DCCP\
    \ report feedback\n   about loss rates to data senders, via RTP Control Protocol\
    \ Sender and\n   Receiver Reports (RTCP SR/RR packets) and via DCCP acknowledgement\n\
    \   options.  These feedback mechanisms are potentially redundant.\n   However,\
    \ RTCP SR/RR packets contain information not present in DCCP\n   acknowledgements,\
    \ such as \"interarrival jitter\", and DCCP's\n   acknowledgements contain information\
    \ not transmitted by RTCP, such as\n   the ECN Nonce Echo.  Neither feedback mechanism\
    \ makes the other\n   redundant.\n   Sending both types of feedback need not be\
    \ particularly costly\n   either.  RTCP reports may be sent relatively infrequently:\
    \ once every\n   5 seconds on average, for low-bandwidth flows.  In DCCP, some\n\
    \   feedback mechanisms are expensive -- Ack Vector, for example, is\n   frequent\
    \ and verbose -- but others are relatively cheap: CCID 3\n   (TFRC) acknowledgements\
    \ take between 16 and 32 bytes of options sent\n   once per round-trip time. \
    \ (Reporting less frequently than once per\n   RTT would make congestion control\
    \ less responsive to loss.)  We\n   therefore conclude that acknowledgement overhead\
    \ in RTP-over-DCCP\n   need not be significantly higher than for RTP-over-UDP,\
    \ at least for\n   CCID 3.\n   One clear redundancy can be addressed at the application\
    \ level.  The\n   verbose packet-by-packet loss reports sent in RTCP Extended\
    \ Reports\n   Loss RLE Blocks [RFC3611] can be derived from DCCP's Ack Vector\n\
    \   options.  (The converse is not true, since Loss RLE Blocks contain no\n  \
    \ ECN information.)  Since DCCP implementations should provide an API\n   for\
    \ application access to Ack Vector information, RTP-over-DCCP\n   applications\
    \ might request either DCCP Ack Vectors or RTCP Extended\n   Report Loss RLE Blocks,\
    \ but not both.\n   Now consider sequence number redundancy on data packets. \
    \ The\n   embedded RTP header contains a 16-bit RTP sequence number.  Most data\n\
    \   packets will use the DCCP-Data type; DCCP-DataAck and DCCP-Ack\n   packets\
    \ need not usually be sent.  The DCCP-Data header is 12 bytes\n   long without\
    \ options, including a 24-bit sequence number.  This is 4\n   bytes more than\
    \ a UDP header.  Any options required on data packets\n   would add further overhead,\
    \ although many CCIDs (for instance, CCID\n   3, TFRC) don't require options on\
    \ most data packets.\n   The DCCP sequence number cannot be inferred from the\
    \ RTP sequence\n   number since it increments on non-data packets as well as data\n\
    \   packets.  The RTP sequence number cannot be inferred from the DCCP\n   sequence\
    \ number either [RFC3550].  Furthermore, removing RTP's\n   sequence number would\
    \ not save any header space because of alignment\n   issues.  We therefore recommend\
    \ that RTP transmitted over DCCP use\n   the same headers currently defined. \
    \ The 4 byte header cost is a\n   reasonable tradeoff for DCCP's congestion control\
    \ features and access\n   to ECN.  Truly bandwidth-starved endpoints should use\
    \ some header\n   compression scheme.\n"
- title: 17.2.  Congestion Manager and Multiplexing
  contents:
  - "17.2.  Congestion Manager and Multiplexing\n   Since DCCP doesn't provide reliable,\
    \ ordered delivery, multiple\n   application sub-flows may be multiplexed over\
    \ a single DCCP\n   connection with no inherent performance penalty.  Thus, there\
    \ is no\n   need for DCCP to provide built-in support for multiple sub-flows.\n\
    \   This differs from SCTP [RFC2960].\n   Some applications might want to share\
    \ congestion control state among\n   multiple DCCP flows that share the same source\
    \ and destination\n   addresses.  This functionality could be provided by the\
    \ Congestion\n   Manager [RFC3124], a generic multiplexing facility.  However,\
    \ the CM\n   would not fully support DCCP without change; it does not gracefully\n\
    \   handle multiple congestion control mechanisms, for example.\n"
- title: 18.  Security Considerations
  contents:
  - "18.  Security Considerations\n   DCCP does not provide cryptographic security\
    \ guarantees.\n   Applications desiring cryptographic security services (integrity,\n\
    \   authentication, confidentiality, access control, and anti-replay\n   protection)\
    \ should use IPsec or end-to-end security of some kind;\n   Secure RTP is one\
    \ candidate protocol [RFC3711].\n   Nevertheless, DCCP is intended to protect\
    \ against some classes of\n   attackers: Attackers cannot hijack a DCCP connection\
    \ (close the\n   connection unexpectedly, or cause attacker data to be accepted\
    \ by an\n   endpoint as if it came from the sender) unless they can guess valid\n\
    \   sequence numbers.  Thus, as long as endpoints choose initial sequence\n  \
    \ numbers well, a DCCP attacker must snoop on data packets to get any\n   reasonable\
    \ probability of success.  Sequence number validity checks\n   provide this guarantee.\
    \  Section 7.5.5 describes sequence number\n   security further.  This security\
    \ property only holds assuming that\n   DCCP's random numbers are chosen according\
    \ to the guidelines in\n   [RFC4086].\n   DCCP also provides mechanisms to limit\
    \ the potential impact of some\n   denial-of-service attacks.  These mechanisms\
    \ include Init Cookie\n   (Section 8.1.4), the DCCP-CloseReq packet (Section 5.5),\
    \ the\n   Application Not Listening Drop Code (Section 11.7.2), limitations on\n\
    \   the processing of options that might cause connection reset (Section\n   7.5.5),\
    \ limitations on the processing of some ICMP messages (Section\n   14.1), and\
    \ various rate limits, which let servers avoid extensive\n   computation or packet\
    \ generation (Sections 7.5.3, 8.1.3, and others).\n   DCCP provides no protection\
    \ against attackers that can snoop on data\n   packets.\n"
- title: 18.1.  Security Considerations for Partial Checksums
  contents:
  - "18.1.  Security Considerations for Partial Checksums\n   The partial checksum\
    \ facility has a separate security impact,\n   particularly in its interaction\
    \ with authentication and encryption\n   mechanisms.  The impact is the same in\
    \ DCCP as in the UDP-Lite\n   protocol, and what follows was adapted from the\
    \ corresponding text in\n   the UDP-Lite specification [RFC3828].\n   When a DCCP\
    \ packet's Checksum Coverage field is not zero, the\n   uncovered portion of a\
    \ packet may change in transit.  This is\n   contrary to the idea behind most\
    \ authentication mechanisms:\n   authentication succeeds if the packet has not\
    \ changed in transit.\n   Unless authentication mechanisms that operate only on\
    \ the sensitive\n   part of packets are developed and used, authentication will\
    \ always\n   fail for partially-checksummed DCCP packets whose uncovered part\
    \ has\n   been damaged.\n   The IPsec integrity check (Encapsulation Security\
    \ Protocol, ESP, or\n   Authentication Header, AH) is applied (at least) to the\
    \ entire IP\n   packet payload.  Corruption of any bit within that area will then\n\
    \   result in the IP receiver's discarding a DCCP packet, even if the\n   corruption\
    \ happened in an uncovered part of the DCCP application\n   data.\n   When IPsec\
    \ is used with ESP payload encryption, a link can not\n   determine the specific\
    \ transport protocol of a packet being forwarded\n   by inspecting the IP packet\
    \ payload.  In this case, the link MUST\n   provide a standard integrity check\
    \ covering the entire IP packet and\n   payload.  DCCP partial checksums provide\
    \ no benefit in this case.\n   Encryption (e.g., at the transport or application\
    \ levels) may be\n   used.  Note that omitting an integrity check can, under certain\n\
    \   circumstances, compromise confidentiality [B98].\n   If a few bits of an encrypted\
    \ packet are damaged, the decryption\n   transform will typically spread errors\
    \ so that the packet becomes too\n   damaged to be of use.  Many encryption transforms\
    \ today exhibit this\n   behavior.  There exist encryption transforms, stream\
    \ ciphers, that do\n   not cause error propagation.  Proper use of stream ciphers\
    \ can be\n   quite difficult, especially when authentication checking is omitted\n\
    \   [BB01].  In particular, an attacker can cause predictable changes to\n   the\
    \ ultimate plaintext, even without being able to decrypt the\n   ciphertext.\n"
- title: 19.  IANA Considerations
  contents:
  - "19.  IANA Considerations\n   IANA has assigned IP Protocol Number 33 to DCCP.\n\
    \   DCCP introduces eight sets of numbers whose values should be\n   allocated\
    \ by IANA.  We refer to allocation policies, such as\n   Standards Action, outlined\
    \ in [RFC2434], and most registries reserve\n   some values for experimental and\
    \ testing use [RFC3692].  In addition,\n   DCCP requires that the IANA Port Numbers\
    \ registry be opened for DCCP\n   port registrations; Section 19.9 describes how.\
    \  The IANA should feel\n   free to contact the DCCP Expert Reviewer with questions\
    \ on any\n   registry, regardless of the registry policy, for clarification or\
    \ if\n   there is a problem with a request.\n"
- title: 19.1.  Packet Types Registry
  contents:
  - "19.1.  Packet Types Registry\n   Each entry in the DCCP Packet Types registry\
    \ contains a packet type,\n   which is a number in the range 0-15; a packet type\
    \ name, such as\n   DCCP-Request; and a reference to the RFC defining the packet\
    \ type.\n   The registry is initially populated using the values in Table 1\n\
    \   (Section 5.1).  This document allocates packet types 0-9, and packet\n   type\
    \ 14 is permanently reserved for experimental and testing use.\n   Packet types\
    \ 10-13 and 15 are currently reserved and should be\n   allocated with the Standards\
    \ Action policy, which requires IESG\n   review and approval and standards-track\
    \ IETF RFC publication.\n"
- title: 19.2.  Reset Codes Registry
  contents:
  - "19.2.  Reset Codes Registry\n   Each entry in the DCCP Reset Codes registry contains\
    \ a Reset Code,\n   which is a number in the range 0-255; a short description\
    \ of the\n   Reset Code, such as \"No Connection\"; and a reference to the RFC\n\
    \   defining the Reset Code.  The registry is initially populated using\n   the\
    \ values in Table 2 (Section 5.6).  This document allocates Reset\n   Codes 0-11,\
    \ and Reset Codes 120-126 are permanently reserved for\n   experimental and testing\
    \ use.  Reset Codes 12-119 and 127 are\n   currently reserved and should be allocated\
    \ with the IETF Consensus\n   policy, requiring an IETF RFC publication (standards\
    \ track or not)\n   with IESG review and approval.  Reset Codes 128-255 are permanently\n\
    \   reserved for CCID-specific registries; each CCID Profile document\n   describes\
    \ how the corresponding registry is managed.\n"
- title: 19.3.  Option Types Registry
  contents:
  - "19.3.  Option Types Registry\n   Each entry in the DCCP option types registry\
    \ contains an option type,\n   which is a number in the range 0-255; the name\
    \ of the option, such as\n   \"Slow Receiver\"; and a reference to the RFC defining\
    \ the option type.\n   The registry is initially populated using the values in\
    \ Table 3\n   (Section 5.8).  This document allocates option types 0-2 and 32-44,\n\
    \   and option types 31 and 120-126 are permanently reserved for\n   experimental\
    \ and testing use.  Option types 3-30, 45-119, and 127 are\n   currently reserved\
    \ and should be allocated with the IETF Consensus\n   policy, requiring an IETF\
    \ RFC publication (standards track or not)\n   with IESG review and approval.\
    \  Option types 128-255 are permanently\n   reserved for CCID-specific registries;\
    \ each CCID Profile document\n   describes how the corresponding registry is managed.\n"
- title: 19.4.  Feature Numbers Registry
  contents:
  - "19.4.  Feature Numbers Registry\n   Each entry in the DCCP feature numbers registry\
    \ contains a feature\n   number, which is a number in the range 0-255; the name\
    \ of the\n   feature, such as \"ECN Incapable\"; and a reference to the RFC defining\n\
    \   the feature number.  The registry is initially populated using the\n   values\
    \ in Table 4 (Section 6).  This document allocates feature\n   numbers 0-9, and\
    \ feature numbers 120-126 are permanently reserved for\n   experimental and testing\
    \ use.  Feature numbers 10-119 and 127 are\n   currently reserved and should be\
    \ allocated with the IETF Consensus\n   policy, requiring an IETF RFC publication\
    \ (standards track or not)\n   with IESG review and approval.  Feature numbers\
    \ 128-255 are\n   permanently reserved for CCID-specific registries; each CCID\
    \ Profile\n   document describes how the corresponding registry is managed.\n"
- title: 19.5.  Congestion Control Identifiers Registry
  contents:
  - "19.5.  Congestion Control Identifiers Registry\n   Each entry in the DCCP Congestion\
    \ Control Identifiers (CCIDs)\n   registry contains a CCID, which is a number\
    \ in the range 0-255; the\n   name of the CCID, such as \"TCP-like Congestion\
    \ Control\"; and a\n   reference to the RFC defining the CCID.  The registry is\
    \ initially\n   populated using the values in Table 5 (Section 10).  CCIDs 2 and\
    \ 3\n   are allocated by concurrently published profiles, and CCIDs 248-254\n\
    \   are permanently reserved for experimental and testing use.  CCIDs 0,\n   1,\
    \ 4-247, and 255 are currently reserved and should be allocated with\n   the IETF\
    \ Consensus policy, requiring an IETF RFC publication\n   (standards track or\
    \ not) with IESG review and approval.\n"
- title: 19.6.  Ack Vector States Registry
  contents:
  - "19.6.  Ack Vector States Registry\n   Each entry in the DCCP Ack Vector States\
    \ registry contains an Ack\n   Vector State, which is a number in the range 0-3;\
    \ the name of the\n   State, such as \"Received ECN Marked\"; and a reference\
    \ to the RFC\n   defining the State.  The registry is initially populated using\
    \ the\n   values in Table 6 (Section 11.4).  This document allocates States 0,\n\
    \   1, and 3.  State 2 is currently reserved and should be allocated with\n  \
    \ the Standards Action policy, which requires IESG review and approval\n   and\
    \ standards-track IETF RFC publication.\n"
- title: 19.7.  Drop Codes Registry
  contents:
  - "19.7.  Drop Codes Registry\n   Each entry in the DCCP Drop Codes registry contains\
    \ a Data Dropped\n   Drop Code, which is a number in the range 0-7; the name of\
    \ the Drop\n   Code, such as \"Application Not Listening\"; and a reference to\
    \ the RFC\n   defining the Drop Code.  The registry is initially populated using\n\
    \   the values in Table 7 (Section 11.7).  This document allocates Drop\n   Codes\
    \ 0-3 and 7.  Drop Codes 4-6 are currently reserved, and should\n   be allocated\
    \ with the Standards Action policy, which requires IESG\n   review and approval\
    \ and standards-track IETF RFC publication.\n"
- title: 19.8.  Service Codes Registry
  contents:
  - "19.8.  Service Codes Registry\n   Each entry in the Service Codes registry contains\
    \ a Service Code,\n   which is a number in the range 0-4294967294; a short English\n\
    \   description of the intended service; and an optional reference to an\n   RFC\
    \ or other publicly available specification defining the Service\n   Code.  The\
    \ registry should list the Service Code's numeric value as a\n   decimal number.\
    \  When the Service Code may be represented in \"SC:\"\n   format according to\
    \ the rules in Section 8.1.2, the registry should\n   also show the corresponding\
    \ ASCII interpretation of the Service Code\n   minus the \"SC:\" prefix.  Thus,\
    \ the number 1717858426 would\n   additionally appear as \"fdpz\".  Service Codes\
    \ are not DCCP-specific.\n   Service Code 0 is permanently reserved (it represents\
    \ the absence of\n   a meaningful Service Code), and Service Codes 1056964608-1073741823\n\
    \   (high byte ASCII \"?\") are reserved for Private Use.  Note that\n   4294967295\
    \ is not a valid Service Code.  Most of the remaining\n   Service Codes are allocated\
    \ First Come First Served, with no RFC\n   publication required; exceptions are\
    \ listed in Section 8.1.2.  This\n   document allocates a single Service Code,\
    \ 1145656131 (\"DISC\").  This\n   corresponds to the discard service, which discards\
    \ all data sent to\n   the service and sends no data in reply.\n"
- title: 19.9.  Port Numbers Registry
  contents:
  - "19.9.  Port Numbers Registry\n   DCCP services may use contact port numbers to\
    \ provide service to\n   unknown callers, as in TCP and UDP.  IANA is therefore\
    \ requested to\n   open the existing Port Numbers registry for DCCP using the\
    \ following\n   rules, which we intend to mesh well with existing Port Numbers\n\
    \   registration procedures.\n   Port numbers are divided into three ranges. \
    \ The Well Known Ports are\n   those from 0 through 1023, the Registered Ports\
    \ are those from 1024\n   through 49151, and the Dynamic and/or Private Ports\
    \ are those from\n   49152 through 65535.  Well Known and Registered Ports are\
    \ intended\n   for use by server applications that desire a default contact point\
    \ on\n   a system.  On most systems, Well Known Ports can only be used by\n  \
    \ system (or root) processes or by programs executed by privileged\n   users,\
    \ while Registered Ports can be used by ordinary user processes\n   or programs\
    \ executed by ordinary users.  Dynamic and/or Private Ports\n   are intended for\
    \ temporary use, including client-side ports, out-of-\n   band negotiated ports,\
    \ and application testing prior to registration\n   of a dedicated port; they\
    \ MUST NOT be registered.\n   The Port Numbers registry should accept registrations\
    \ for DCCP ports\n   in the Well Known Ports and Registered Ports ranges.  Well\
    \ Known and\n   Registered Ports SHOULD NOT be used without registration.  Although\n\
    \   in some cases -- such as porting an application from UDP to DCCP --\n   it\
    \ may seem natural to use a DCCP port before registration completes,\n   we emphasize\
    \ that IANA will not guarantee registration of particular\n   Well Known and Registered\
    \ Ports.  Registrations should be requested\n   as early as possible.\n   Each\
    \ port registration SHALL include the following information:\n   o  A short port\
    \ name, consisting entirely of letters (A-Z and a-z),\n      digits (0-9), and\
    \ punctuation characters from \"-_+./*\" (not\n      including the quotes).\n\
    \   o  The port number that is requested to be registered.\n   o  A short English\
    \ phrase describing the port's purpose.  This MUST\n      include one or more\
    \ space-separated textual Service Code\n      descriptors naming the port's corresponding\
    \ Service Codes (see\n      Section 8.1.2).\n   o  Name and contact information\
    \ for the person or entity performing\n      the registration, and possibly a\
    \ reference to a document defining\n      the port's use.  Registrations coming\
    \ from IETF working groups\n      need only name the working group, but indicating\
    \ a contact person\n      is recommended.\n   Registrants are encouraged to follow\
    \ these guidelines when submitting\n   a registration.\n   o  A port name SHOULD\
    \ NOT be registered for more than one DCCP port\n      number.\n   o  A port name\
    \ registered for UDP MAY be registered for DCCP as well.\n      Any such registration\
    \ SHOULD use the same port number as the\n      existing UDP registration.\n \
    \  o  Concrete intent to use a port SHOULD precede port registration.\n      For\
    \ example, existing UDP ports SHOULD NOT be registered in\n      advance of any\
    \ intent to use those ports for DCCP.\n   o  A port name generally associated\
    \ with TCP and/or SCTP SHOULD NOT\n      be registered for DCCP, since that port\
    \ name implies reliable\n      transport.  For example, we discourage registration\
    \ of any \"http\"\n      port for DCCP.  However, if such a registration makes\
    \ sense (that\n      is, if there is concrete intent to use such a port), the\
    \ DCCP\n      registration SHOULD use the same port number as the existing\n \
    \     registration.\n   o  Multiple DCCP registrations for the same port number\
    \ are allowed\n      as long as the registrations' Service Codes do not overlap.\n\
    \   This document registers the following port.  (This should be\n   considered\
    \ a model registration.)\n   discard    9/dccp    Discard SC:DISC\n   # IETF dccp\
    \ WG, Eddie Kohler <kohler@cs.ucla.edu>, [RFC4340]\n   The discard service, which\
    \ accepts DCCP connections on port 9,\n   discards all incoming application data\
    \ and sends no data in response.\n   Thus, DCCP's discard port is analogous to\
    \ TCP's discard port, and\n   might be used to check the health of a DCCP stack.\n"
- title: 20.  Thanks
  contents:
  - "20.  Thanks\n   Thanks to Jitendra Padhye for his help with early versions of\
    \ this\n   specification.\n   Thanks to Junwen Lai and Arun Venkataramani, who,\
    \ as interns at ICIR,\n   built a prototype DCCP implementation.  In particular,\
    \ Junwen Lai\n   recommended that the old feature negotiation mechanism be scrapped\n\
    \   and co-designed the current mechanism.  Arun Venkataramani's feedback\n  \
    \ improved Appendix A.\n   We thank the staff and interns of ICIR and, formerly,\
    \ ACIRI, the\n   members of the End-to-End Research Group, and the members of\
    \ the\n   Transport Area Working Group for their feedback on DCCP.  We\n   especially\
    \ thank the DCCP expert reviewers Greg Minshall, Eric\n   Rescorla, and Magnus\
    \ Westerlund for detailed written comments and\n   problem spotting, and Rob Austein\
    \ and Steve Bellovin for verbal\n   comments and written notes.  We also especially\
    \ thank Aaron Falk, the\n   working group chair during the development of this\
    \ specification.\n   We also thank those who provided comments and suggestions\
    \ via the\n   DCCP BOF, Working Group, and mailing lists, including Damon Lanphear,\n\
    \   Patrick McManus, Colin Perkins, Sara Karlberg, Kevin Lai, Bernard\n   Aboba,\
    \ Youngsoo Choi, Pengfei Di, Dan Duchamp, Lars Eggert, Gorry\n   Fairhurst, Derek\
    \ Fawcus, David Timothy Fleeman, John Loughney,\n   Ghyslain Pelletier, Hagen\
    \ Paul Pfeifer, Tom Phelan, Stanislav\n   Shalunov, Somsak Vanit-Anunchai, David\
    \ Vos, Yufei Wang, and Michael\n   Welzl.  In particular, Colin Perkins provided\
    \ extensive, detailed\n   feedback, Michael Welzl suggested the Data Checksum\
    \ option, Gorry\n   Fairhurst provided extensive feedback on various checksum\
    \ issues, and\n   Somsak Vanit-Anunchai, Jonathan Billington, and Tul Kongprakaiwoot's\n\
    \   Colored Petri Net model [VBK05] discovered several problems with\n   message\
    \ exchange.\n"
- title: 'A.  Appendix: Ack Vector Implementation Notes'
  contents:
  - "A.  Appendix: Ack Vector Implementation Notes\n   This appendix discusses particulars\
    \ of DCCP acknowledgement handling\n   in the context of an abstract implementation\
    \ for Ack Vector.  It is\n   informative and not normative.\n   The first part\
    \ of our implementation runs at the HC-Receiver, and\n   therefore acknowledges\
    \ data packets.  It generates Ack Vector\n   options.  The implementation has\
    \ the following characteristics:\n   o  At most one byte of state per acknowledged\
    \ packet.\n   o  O(1) time to update that state when a new packet arrives (normal\n\
    \      case).\n   o  Cumulative acknowledgements.\n   o  Quick removal of old\
    \ state.\n   The basic data structure is a circular buffer containing information\n\
    \   about acknowledged packets.  Each byte in this buffer contains a\n   state\
    \ and run length; the state can be 0 (packet received), 1 (packet\n   ECN marked),\
    \ or 3 (packet not yet received).  The buffer grows from\n   right to left.  The\
    \ implementation maintains five variables, aside\n   from the buffer contents:\n\
    \   o  \"buf_head\" and \"buf_tail\", which mark the live portion of the\n   \
    \   buffer.\n   o  \"buf_ackno\", the Acknowledgement Number of the most recent\
    \ packet\n      acknowledged in the buffer.  This corresponds to the \"head\"\n\
    \      pointer.\n   o  \"buf_nonce\", the one-bit sum (exclusive-or, or parity)\
    \ of the ECN\n      Nonces received on all packets acknowledged by the buffer\
    \ with\n      State 0.\n   We draw acknowledgement buffers like this:\n      +---------------------------------------------------------------+\n\
    \      |S,L|S,L|S,L|S,L|   |   |   |   |S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|\n   \
    \   +---------------------------------------------------------------+\n      \
    \              ^                   ^\n                 buf_tail     buf_head,\
    \ buf_ackno = A     buf_nonce = E\n                <=== buf_head and buf_tail\
    \ move this way <===\n   Each \"S,L\" represents a State/Run length byte.  We\
    \ will draw these\n   buffers showing only their live portion and will add an\
    \ annotation\n   showing the Acknowledgement Number for the last live byte in\
    \ the\n   buffer.  For example:\n        +-----------------------------------------------+\n\
    \      A |S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L| T    BN[E]\n      \
    \  +-----------------------------------------------+\n   Here, buf_nonce equals\
    \ E and buf_ackno equals A.\n   We will use this buffer as a running example.\n\
    \         +---------------------------+\n      10 |0,0|3,0|3,0|3,0|0,4|1,0|0,0|\
    \ 0    BN[1]   [Example Buffer]\n         +---------------------------+\n   In\
    \ concrete terms, its meaning is as follows:\n      Packet 10 was received.  (The\
    \ head of the buffer has sequence\n      number 10, state 0, and run length 0.)\n\
    \      Packets 9, 8, and 7 have not yet been received.  (The three bytes\n   \
    \   preceding the head each have state 3 and run length 0.)\n      Packets 6,\
    \ 5, 4, 3, and 2 were received.\n      Packet 1 was ECN marked.\n      Packet\
    \ 0 was received.\n      The one-bit sum of the ECN Nonces on packets 10, 6, 5,\
    \ 4, 3, 2,\n      and 0 equals 1.\n   Additionally, the HC-Receiver must keep\
    \ some information about the\n   Ack Vectors it has recently sent.  For each packet\
    \ sent carrying an\n   Ack Vector, it remembers four variables:\n   o  \"ack_seqno\"\
    , the Sequence Number used for the packet.  This is an\n      HC-Receiver sequence\
    \ number.\n   o  \"ack_ptr\", the value of buf_head at the time of acknowledgement.\n\
    \   o  \"ack_runlen\", the run length stored in the byte of buffer data at\n \
    \     buf_head at the time of acknowledgement.\n   o  \"ack_ackno\", the Acknowledgement\
    \ Number used for the packet.  This\n      is an HC-Sender sequence number.  Since\
    \ acknowledgements are\n      cumulative, this single number completely specifies\
    \ all necessary\n      information about the packets acknowledged by this Ack\
    \ Vector.\n   o  \"ack_nonce\", the one-bit sum of the ECN Nonces for all State\
    \ 0\n      packets in the buffer from buf_head to ack_ackno, inclusive.\n    \
    \  Initially, this equals the Nonce Echo of the acknowledgement's Ack\n      Vector\
    \ (or, if the ack packet contained more than one Ack Vector,\n      the exclusive-or\
    \ of all the acknowledgement's Ack Vectors).  It\n      changes as information\
    \ about old acknowledgements is removed (so\n      ack_ptr and buf_head diverge)\
    \ and as old packets arrive (so they\n      change from State 3 or State 1 to\
    \ State 0).\n"
- title: A.1.  Packet Arrival
  contents:
  - "A.1.  Packet Arrival\n   This section describes how the HC-Receiver updates its\n\
    \   acknowledgement buffer as packets arrive from the HC-Sender.\n"
- title: A.1.1.  New Packets
  contents:
  - "A.1.1.  New Packets\n   When a packet with Sequence Number greater than buf_ackno\
    \ arrives,\n   the HC-Receiver updates buf_head (by moving it to the left\n  \
    \ appropriately), buf_ackno (which is set to the new packet's Sequence\n   Number),\
    \ and possibly buf_nonce (if the packet arrived unmarked with\n   ECN Nonce 1),\
    \ in addition to the buffer itself.  For example, if\n   HC-Sender packet 11 arrived\
    \ ECN marked, the Example Buffer above\n   would enter this new state (changes\
    \ are marked with stars):\n         ** +***----------------------------+\n   \
    \      11 |1,0|0,0|3,0|3,0|3,0|0,4|1,0|0,0| 0    BN[1]\n         ** +***----------------------------+\n\
    \   If the packet's state equals the state at the head of the buffer, the\n  \
    \ HC-Receiver may choose to increment its run length (up to the\n   maximum).\
    \  For example, if HC-Sender packet 11 arrived without ECN\n   marking and with\
    \ ECN Nonce 0, the Example Buffer might enter this\n   state instead:\n      \
    \       ** +--*------------------------+\n             11 |0,1|3,0|3,0|3,0|0,4|1,0|0,0|\
    \ 0    BN[1]\n             ** +--*------------------------+\n   Of course, the\
    \ new packet's sequence number might not equal the\n   expected sequence number.\
    \  In this case, the HC-Receiver will enter\n   the intervening packets as State\
    \ 3.  If several packets are missing,\n   the HC-Receiver may prefer to enter\
    \ multiple bytes with run length 0,\n   rather than a single byte with a larger\
    \ run length; this simplifies\n   table updates if one of the missing packets\
    \ arrives.  For example, if\n   HC-Sender packet 12 arrived with ECN Nonce 1,\
    \ the Example Buffer\n   would enter this state:\n      ** +*******----------------------------+\
    \         *\n      12 |0,0|3,0|0,1|3,0|3,0|3,0|0,4|1,0|0,0| 0    BN[0]\n     \
    \ ** +*******----------------------------+         *\n   Of course, the circular\
    \ buffer may overflow when the HC-Sender is\n   sending data at a very high rate,\
    \ when the HC-Receiver's\n   acknowledgements are not reaching the HC-Sender,\
    \ or when the\n   HC-Sender is forgetting to acknowledge those acks (so the HC-Receiver\n\
    \   is unable to clean up old state).  In this case, the HC-Receiver\n   should\
    \ either compress the buffer (by increasing run lengths when\n   possible), transfer\
    \ its state to a larger buffer, or, as a last\n   resort, drop all received packets,\
    \ without processing them at all,\n   until its buffer shrinks again.\n"
- title: A.1.2.  Old Packets
  contents:
  - "A.1.2.  Old Packets\n   When a packet with Sequence Number S <= buf_ackno arrives,\
    \ the\n   HC-Receiver will scan the table for the byte corresponding to S.\n \
    \  (Indexing structures could reduce the complexity of this scan.)  If S\n   was\
    \ previously lost (State 3), and it was stored in a byte with run\n   length 0,\
    \ the HC-Receiver can simply change the byte's state.  For\n   example, if HC-Sender\
    \ packet 8 was received with ECN Nonce 0, the\n   Example Buffer would enter this\
    \ state:\n               +--------*------------------+\n            10 |0,0|3,0|0,0|3,0|0,4|1,0|0,0|\
    \ 0    BN[1]\n               +--------*------------------+\n   If S was not marked\
    \ as lost, or if it was not contained in the table,\n   the packet is probably\
    \ a duplicate and should be ignored.  (The new\n   packet's ECN marking state\
    \ might differ from the state in the buffer;\n   Section 11.4.1 describes what\
    \ is allowed then.)  If S's buffer byte\n   has a non-zero run length, then the\
    \ buffer might need to be\n   reshuffled to make space for one or two new bytes.\n\
    \   The ack_nonce fields may also need manipulation when old packets\n   arrive.\
    \  In particular, when S transitions from State 3 or State 1 to\n   State 0, and\
    \ S had ECN Nonce 1, then the implementation should flip\n   the value of ack_nonce\
    \ for every acknowledgement with ack_ackno >= S.\n   It is impossible with this\
    \ data structure to shift packets from State\n   0 to State 1, since the buffer\
    \ doesn't store individual packets' ECN\n   Nonces.\n"
- title: A.2.  Sending Acknowledgements
  contents:
  - "A.2.  Sending Acknowledgements\n   Whenever the HC-Receiver needs to generate\
    \ an acknowledgement, the\n   buffer's contents can simply be copied into one\
    \ or more Ack Vector\n   options.  Copied Ack Vectors might not be maximally compressed;\
    \ for\n   example, the Example Buffer above contains three adjacent 3,0 bytes\n\
    \   that could be combined into a single 3,2 byte.  The HC-Receiver\n   might,\
    \ therefore, choose to compress the buffer in place before\n   sending the option,\
    \ or to compress the buffer while copying it;\n   either operation is simple.\n\
    \   Every acknowledgement sent by the HC-Receiver SHOULD include the\n   entire\
    \ state of the buffer.  That is, acknowledgements are\n   cumulative.\n   If the\
    \ acknowledgement fits in one Ack Vector, that Ack Vector's\n   Nonce Echo simply\
    \ equals buf_nonce.  For multiple Ack Vectors, more\n   care is required.  The\
    \ Ack Vectors should be split at points\n   corresponding to previous acknowledgements,\
    \ since the stored\n   ack_nonce fields provide enough information to calculate\
    \ correct\n   Nonce Echoes.  The implementation should therefore acknowledge data\n\
    \   at least once per 253 bytes of buffer state.  (Otherwise, there'd be\n   no\
    \ way to calculate a Nonce Echo.)\n   For each acknowledgement it sends, the HC-Receiver\
    \ will add an\n   acknowledgement record.  ack_seqno will equal the HC-Receiver\n\
    \   sequence number it used for the ack packet; ack_ptr will equal\n   buf_head;\
    \ ack_runlen will equal the run length stored in the buffer's\n   buf_head byte;\
    \ ack_ackno will equal buf_ackno; and ack_nonce will\n   equal buf_nonce.\n"
- title: A.3.  Clearing State
  contents:
  - "A.3.  Clearing State\n   Some of the HC-Sender's packets will include acknowledgement\
    \ numbers,\n   which ack the HC-Receiver's acknowledgements.  When such an ack\
    \ is\n   received, the HC-Receiver finds the acknowledgement record R with the\n\
    \   appropriate ack_seqno and then does the following:\n   o  If the run length\
    \ in the buffer's R.ack_ptr byte is greater than\n      R.ack_runlen, then it\
    \ decrements that run length by\n      R.ack_runlen + 1 and sets buf_tail to R.ack_ptr.\
    \  Otherwise, it\n      sets buf_tail to R.ack_ptr + 1.\n   o  If R.ack_nonce\
    \ is 1, it flips buf_nonce, and the value of\n      ack_nonce for every later\
    \ ack record.\n   o  It throws away R and every preceding ack record.\n   (The\
    \ HC-Receiver may choose to keep some older information, in case a\n   lost packet\
    \ shows up late.)  For example, say that the HC-Receiver\n   storing the Example\
    \ Buffer had sent two acknowledgements already:\n   1. ack_seqno = 59, ack_runlen\
    \ = 1, ack_ackno = 3, ack_nonce = 1.\n   2. ack_seqno = 60, ack_runlen = 0, ack_ackno\
    \ = 10, ack_nonce = 0.\n   Say the HC-Receiver then received a DCCP-DataAck packet\
    \ with\n   Acknowledgement Number 59 from the HC-Sender.  This informs the\n \
    \  HC-Receiver that the HC-Sender received, and processed, all the\n   information\
    \ in HC-Receiver packet 59.  This packet acknowledged\n   HC-Sender packet 3,\
    \ so the HC-Sender has now received HC-Receiver's\n   acknowledgements for packets\
    \ 0, 1, 2, and 3.  The Example Buffer\n   should enter this state:\n         \
    \      +------------------*+ *       *\n            10 |0,0|3,0|3,0|3,0|0,2| 4\
    \    BN[0]\n               +------------------*+ *       *\n   The tail byte's\
    \ run length was adjusted, since packet 3 was in the\n   middle of that byte.\
    \  Since R.ack_nonce was 1, the buf_nonce field\n   was flipped, as were the ack_nonce\
    \ fields for later acknowledgements\n   (here, the HC-Receiver Ack 60 record,\
    \ not shown, has its ack_nonce\n   flipped to 1).  The HC-Receiver can also throw\
    \ away stored\n   information about HC-Receiver Ack 59 and any earlier\n   acknowledgements.\n\
    \   A careful implementation might try to ensure reasonable robustness to\n  \
    \ reordering.  Suppose that the Example Buffer is as before, but that\n   packet\
    \ 9 now arrives, out of sequence.  The buffer would enter this\n   state:\n  \
    \              +----*----------------------+\n             10 |0,0|0,0|3,0|3,0|0,4|1,0|0,0|\
    \ 0     BN[1]\n                +----*----------------------+\n   The danger is\
    \ that the HC-Sender might acknowledge the HC-Receiver's\n   previous acknowledgement\
    \ (with sequence number 60), which says that\n   Packet 9 was not received, before\
    \ the HC-Receiver has a chance to\n   send a new acknowledgement saying that Packet\
    \ 9 actually was\n   received.  Therefore, when packet 9 arrived, the HC-Receiver\
    \ might\n   modify its acknowledgement record as follows:\n   1. ack_seqno = 59,\
    \ ack_ackno = 3, ack_nonce = 1.\n   2. ack_seqno = 60, ack_ackno = 3, ack_nonce\
    \ = 1.\n   That is, Ack 60 is now treated like a duplicate of Ack 59.  This\n\
    \   would prevent the Tail pointer from moving past packet 9 until the\n   HC-Receiver\
    \ knows that the HC-Sender has seen an Ack Vector\n   indicating that packet's\
    \ arrival.\n"
- title: A.4.  Processing Acknowledgements
  contents:
  - "A.4.  Processing Acknowledgements\n   When the HC-Sender receives an acknowledgement,\
    \ it generally cares\n   about the number of packets that were dropped and/or\
    \ ECN marked.  It\n   simply reads this off the Ack Vector.  Additionally, it\
    \ should check\n   the ECN Nonce for correctness.  (As described in Section 11.4.1,\
    \ it\n   may want to keep more detailed information about acknowledged packets\n\
    \   in case packets change states between acknowledgements, or in case\n   the\
    \ application queries whether a packet arrived.)\n   The HC-Sender must also acknowledge\
    \ the HC-Receiver's\n   acknowledgements so that the HC-Receiver can free old\
    \ Ack Vector\n   state.  (Since Ack Vector acknowledgements are reliable, the\n\
    \   HC-Receiver must maintain and resend Ack Vector information until it\n   is\
    \ sure that the HC-Sender has received that information.)  A simple\n   algorithm\
    \ suffices: since Ack Vector acknowledgements are cumulative,\n   a single acknowledgement\
    \ number tells HC-Receiver how much ack\n   information has arrived.  Assuming\
    \ that the HC-Receiver sends no\n   data, the HC-Sender can ensure that at least\
    \ once a round-trip time,\n   it sends a DCCP-DataAck packet acknowledging the\
    \ latest DCCP-Ack\n   packet it has received.  Of course, the HC-Sender only needs\
    \ to\n   acknowledge the HC-Receiver's acknowledgements if the HC-Sender is\n\
    \   also sending data.  If the HC-Sender is not sending data, then the\n   HC-Receiver's\
    \ Ack Vector state is stable, and there is no need to\n   shrink it.  The HC-Sender\
    \ must watch for drops and ECN marks on\n   received DCCP-Ack packets so that\
    \ it can adjust the HC-Receiver's\n   ack-sending rate in response to congestion,\
    \ for example, with Ack\n   Ratio.\n   If the other half-connection is not quiescent\
    \ -- that is, the\n   HC-Receiver is sending data to the HC-Sender, possibly using\
    \ another\n   CCID -- then the acknowledgements on that half-connection are\n\
    \   sufficient for the HC-Receiver to free its state.\n"
- title: 'B.  Appendix: Partial Checksumming Design Motivation'
  contents:
  - "B.  Appendix: Partial Checksumming Design Motivation\n   A great deal of discussion\
    \ has taken place regarding the utility of\n   allowing a DCCP sender to restrict\
    \ the checksum so that it does not\n   cover the complete packet.  This section\
    \ attempts to capture some of\n   the rationale behind specific details of DCCP\
    \ design.\n   Many of the applications that we envisage using DCCP are resilient\
    \ to\n   some degree of data loss, or they would typically have chosen a\n   reliable\
    \ transport.  Some of these applications may also be resilient\n   to data corruption\
    \ -- some audio payloads, for example.  These\n   resilient applications might\
    \ rather receive corrupted data than have\n   DCCP drop corrupted packets.  This\
    \ is particularly because of\n   congestion control: DCCP cannot tell the difference\
    \ between packets\n   dropped due to corruption and packets dropped due to congestion,\
    \ and\n   so it must reduce the transmission rate accordingly.  This response\n\
    \   may cause the connection to receive less bandwidth than it is due;\n   corruption\
    \ in some networking technologies is independent of, or at\n   least not always\
    \ correlated to, congestion.  Therefore, corrupted\n   packets do not need to\
    \ cause as strong a reduction in transmission\n   rate as the congestion response\
    \ would dictate (as long as the DCCP\n   header and options are not corrupt).\n\
    \   Thus DCCP allows the checksum to cover all of the packet, just the\n   DCCP\
    \ header, or both the DCCP header and some number of bytes from\n   the application\
    \ data.  If the application cannot tolerate any data\n   corruption, then the\
    \ checksum must cover the whole packet.  If the\n   application would prefer to\
    \ tolerate some corruption rather than have\n   the packet dropped, then it can\
    \ set the checksum to cover only part\n   of the packet (but always the DCCP header).\
    \  In addition, if the\n   application wishes to decouple checksumming of the\
    \ DCCP header from\n   checksumming of the application data, it may do so by including\
    \ the\n   Data Checksum option.  This would allow DCCP to discard corrupted\n\
    \   application data without mistaking the corruption for network\n   congestion.\n\
    \   Thus, from the application point of view, partial checksums seem to\n   be\
    \ a desirable feature.  However, the usefulness of partial checksums\n   depends\
    \ on partially corrupted packets being delivered to the\n   receiver.  If the\
    \ link-layer CRC always discards corrupted packets,\n   then this will not happen,\
    \ and so the usefulness of partial checksums\n   would be restricted to corruption\
    \ that occurred in routers and other\n   places not covered by link CRCs.  There\
    \ does not appear to be\n   consensus on how likely it is that future network\
    \ links that suffer\n   significant corruption will not cover the entire packet\
    \ with a single\n   strong CRC.  DCCP makes it possible to tailor such links to\
    \ the\n   application, but it is difficult to predict if this will be\n   compelling\
    \ for future link technologies.\n   In addition, partial checksums do not co-exist\
    \ well with IP-level\n   authentication mechanisms such as IPsec AH, which cover\
    \ the entire\n   packet with a cryptographic hash.  Thus, if cryptographic\n \
    \  authentication mechanisms are required to co-exist with partial\n   checksums,\
    \ the authentication must be carried in the application\n   data.  A possible\
    \ mode of usage would appear to be similar to that of\n   Secure RTP.  However,\
    \ such \"application-level\" authentication does\n   not protect the DCCP option\
    \ negotiation and state machine from forged\n   packets.  An alternative would\
    \ be to use IPsec ESP, and to use\n   encryption to protect the DCCP headers against\
    \ attack, while using\n   the DCCP header validity checks to authenticate that\
    \ the header is\n   from someone who possessed the correct key.  While this is\
    \ resistant\n   to replay (due to the DCCP sequence number), it is not by itself\n\
    \   resistant to some forms of man-in-the-middle attacks because the\n   application\
    \ data is not tightly coupled to the packet header.  Thus,\n   an application-level\
    \ authentication probably needs to be coupled with\n   IPsec ESP or a similar\
    \ mechanism to provide a reasonably complete\n   security solution.  The overhead\
    \ of such a solution might be\n   unacceptable for some applications that would\
    \ otherwise wish to use\n   partial checksums.\n   On balance, the authors believe\
    \ that DCCP partial checksums have the\n   potential to enable some future uses\
    \ that would otherwise be\n   difficult.  As the cost and complexity of supporting\
    \ them is small,\n   it seems worth including them at this time.  It remains to\
    \ be seen\n   whether they are useful in practice.\n"
- title: Normative References
  contents:
  - "Normative References\n   [RFC793]       Postel, J., \"Transmission Control Protocol\"\
    , STD 7,\n                  RFC 793, September 1981.\n   [RFC1191]      Mogul,\
    \ J. and S. Deering, \"Path MTU discovery\", RFC\n                  1191, November\
    \ 1990.\n   [RFC2119]      Bradner, S., \"Key words for use in RFCs to Indicate\n\
    \                  Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2434]\
    \      Narten, T. and H. Alvestrand, \"Guidelines for Writing\n              \
    \    an IANA Considerations Section in RFCs\", BCP 26, RFC\n                 \
    \ 2434, October 1998.\n   [RFC2460]      Deering, S. and R. Hinden, \"Internet\
    \ Protocol, Version\n                  6 (IPv6) Specification\", RFC 2460, December\
    \ 1998.\n   [RFC3168]      Ramakrishnan, K., Floyd, S., and D. Black, \"The\n\
    \                  Addition of Explicit Congestion Notification (ECN) to\n   \
    \               IP\", RFC 3168, September 2001.\n   [RFC3309]      Stone, J.,\
    \ Stewart, R., and D. Otis, \"Stream Control\n                  Transmission Protocol\
    \ (SCTP) Checksum Change\", RFC\n                  3309, September 2002.\n   [RFC3692]\
    \      Narten, T., \"Assigning Experimental and Testing\n                  Numbers\
    \ Considered Useful\", BCP 82, RFC 3692, January\n                  2004.\n  \
    \ [RFC3775]      Johnson, D., Perkins, C., and J. Arkko, \"Mobility\n        \
    \          Support in IPv6\", RFC 3775, June 2004.\n   [RFC3828]      Larzon,\
    \ L-A., Degermark, M., Pink, S., Jonsson, L-E.,\n                  and G. Fairhurst,\
    \ \"The Lightweight User Datagram\n                  Protocol (UDP-Lite)\", RFC\
    \ 3828, July 2004.\n"
- title: Informative References
  contents:
  - "Informative References\n   [B98]          Bellovin, S.M., \"Cryptography and\
    \ the Internet\",\n                  CRYPTO '98 (LNCS 1462), pp 46-55, August\
    \ 1988.\n   [BB01]         Bellovin, S.M. and M. Blaze, \"Cryptographic Modes\
    \ of\n                  Operation for the Internet\", 2nd NIST Workshop on\n \
    \                 Modes of Operation, August 2001.\n   [M85]          Morris,\
    \ R.T., \"A Weakness in the 4.2BSD Unix TCP/IP\n                  Software\",\
    \ Computer Science Technical Report 117, AT&T\n                  Bell Laboratories,\
    \ Murray Hill, NJ, February 1985.\n   [PMTUD]        Mathis, M. and J. Heffner,\
    \ \"Path MTU Discovery\", Work\n                  in Progress, March 2006.\n \
    \  [RFC792]       Postel, J., \"Internet Control Message Protocol\", STD\n   \
    \               5, RFC 792, September 1981.\n   [RFC1812]      Baker, F., \"Requirements\
    \ for IP Version 4 Routers\",\n                  RFC 1812, June 1995.\n   [RFC1948]\
    \      Bellovin, S., \"Defending Against Sequence Number\n                  Attacks\"\
    , RFC 1948, May 1996.\n   [RFC1982]      Elz, R. and R. Bush, \"Serial Number\
    \ Arithmetic\", RFC\n                  1982, August 1996.\n   [RFC2018]      Mathis,\
    \ M., Mahdavi, J., Floyd, S., and A. Romanow,\n                  \"TCP Selective\
    \ Acknowledgement Options\", RFC 2018,\n                  October 1996.\n   [RFC2401]\
    \      Kent, S. and R. Atkinson, \"Security Architecture for\n               \
    \   the Internet Protocol\", RFC 2401, November 1998.\n   [RFC2463]      Conta,\
    \ A. and S. Deering, \"Internet Control Message\n                  Protocol (ICMPv6)\
    \ for the Internet Protocol Version 6\n                  (IPv6) Specification\"\
    , RFC 2463, December 1998.\n   [RFC2581]      Allman, M., Paxson, V., and W. Stevens,\
    \ \"TCP\n                  Congestion Control\", RFC 2581, April 1999.\n   [RFC2960]\
    \      Stewart, R., Xie, Q., Morneault, K., Sharp, C.,\n                  Schwarzbauer,\
    \ H., Taylor, T., Rytina, I., Kalla, M.,\n                  Zhang, L., and V.\
    \ Paxson, \"Stream Control Transmission\n                  Protocol\", RFC 2960,\
    \ October 2000.\n   [RFC3124]      Balakrishnan, H. and S. Seshan, \"The Congestion\n\
    \                  Manager\", RFC 3124, June 2001.\n   [RFC3360]      Floyd, S.,\
    \ \"Inappropriate TCP Resets Considered\n                  Harmful\", BCP 60,\
    \ RFC 3360, August 2002.\n   [RFC3448]      Handley, M., Floyd, S., Padhye, J.,\
    \ and J. Widmer,\n                  \"TCP Friendly Rate Control (TFRC): Protocol\n\
    \                  Specification\", RFC 3448, January 2003.\n   [RFC3540]    \
    \  Spring, N., Wetherall, D., and D. Ely, \"Robust\n                  Explicit\
    \ Congestion Notification (ECN) Signaling with\n                  Nonces\", RFC\
    \ 3540, June 2003.\n   [RFC3550]      Schulzrinne, H., Casner, S., Frederick,\
    \ R., and V.\n                  Jacobson, \"RTP: A Transport Protocol for Real-Time\n\
    \                  Applications\", STD 64, RFC 3550, July 2003.\n   [RFC3611]\
    \      Friedman, T., Caceres, R., and A. Clark, \"RTP Control\n              \
    \    Protocol Extended Reports (RTCP XR)\", RFC 3611,\n                  November\
    \ 2003.\n   [RFC3711]      Baugher, M., McGrew, D., Naslund, M., Carrara, E.,\
    \ and\n                  K. Norrman, \"The Secure Real-time Transport Protocol\n\
    \                  (SRTP)\", RFC 3711, March 2004.\n   [RFC3819]      Karn, P.,\
    \ Bormann, C., Fairhurst, G., Grossman, D.,\n                  Ludwig, R., Mahdavi,\
    \ J., Montenegro, G., Touch, J.,\n                  and L. Wood, \"Advice for\
    \ Internet Subnetwork\n                  Designers\", BCP 89, RFC 3819, July 2004.\n\
    \   [RFC4086]      Eastlake, D., 3rd, Schiller, J., and S. Crocker,\n        \
    \          \"Randomness Requirements for Security\", BCP 106, RFC\n          \
    \        4086, June 2005.\n   [RFC4341]      Floyd, S. and E. Kohler, \"Profile\
    \ for Datagram\n                  Congestion Control Protocol (DCCP) Congestion\
    \ Control\n                  ID 2: TCP-like Congestion Control\", RFC 4341, March\n\
    \                  2006.\n   [RFC4342]      Floyd, S., Kohler, E., and J. Padhye,\
    \ \"Profile for\n                  Datagram Congestion Control Protocol (DCCP)\
    \ Congestion\n                  Control ID 3: TCP-Friendly Rate Control (TFRC)\"\
    , RFC\n                  4342, March 2006.\n   [SHHP00]       Spatscheck, O.,\
    \ Hansen, J.S., Hartman, J.H., and L.L.\n                  Peterson, \"Optimizing\
    \ TCP Forwarder Performance\",\n                  IEEE/ACM Transactions on Networking\
    \ 8(2):146-157,\n                  April 2000.\n   [SYNCOOKIES]   Bernstein, D.J.,\
    \ \"SYN Cookies\",\n                  http://cr.yp.to/syncookies.html, as of March\
    \ 2006.\n   [VBK05]        Vanit-Anunchai, S., Billington, J., and T.\n      \
    \            Kongprakaiwoot, \"Discovering Chatter and\n                  Incompleteness\
    \ in the Datagram Congestion Control\n                  Protocol\", FORTE 2005,\
    \ pp 143-158, October 2005.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Eddie Kohler\n   4531C Boelter Hall\n   UCLA Computer\
    \ Science Department\n   Los Angeles, CA 90095\n   USA\n   EMail: kohler@cs.ucla.edu\n\
    \   Mark Handley\n   Department of Computer Science\n   University College London\n\
    \   Gower Street\n   London WC1E 6BT\n   UK\n   EMail: M.Handley@cs.ucl.ac.uk\n\
    \   Sally Floyd\n   ICSI Center for Internet Research\n   1947 Center Street,\
    \ Suite 600\n   Berkeley, CA 94704\n   USA\n   EMail: floyd@icir.org\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
