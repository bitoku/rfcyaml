- contents:
  - '     Object Security for Constrained RESTful Environments (OSCORE)

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document defines Object Security for Constrained RESTful\n
    \  Environments (OSCORE), a method for application-layer protection of\n   the
    Constrained Application Protocol (CoAP), using CBOR Object\n   Signing and Encryption
    (COSE).  OSCORE provides end-to-end protection\n   between endpoints communicating
    using CoAP or CoAP-mappable HTTP.\n   OSCORE is designed for constrained nodes
    and networks supporting a\n   range of proxy operations, including translation
    between different\n   transport protocols.\n   Although an optional functionality
    of CoAP, OSCORE alters CoAP\n   options processing and IANA registration.  Therefore,
    this document\n   updates RFC 7252.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8613.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   5\n     1.1.  Terminology . . . . . . . . . . . . . . . . . . . .
    . . .   7\n   2.  The OSCORE Option . . . . . . . . . . . . . . . . . . . . .
    .   8\n   3.  The Security Context  . . . . . . . . . . . . . . . . . . . .   8\n
    \    3.1.  Security Context Definition . . . . . . . . . . . . . . .   9\n     3.2.
    \ Establishment of Security Context Parameters  . . . . . .  11\n     3.3.  Requirements
    on the Security Context Parameters . . . . .  14\n   4.  Protected Message Fields
    \ . . . . . . . . . . . . . . . . . .  15\n     4.1.  CoAP Options  . . . . .
    . . . . . . . . . . . . . . . . .  16\n     4.2.  CoAP Header Fields and Payload
    \ . . . . . . . . . . . . .  24\n     4.3.  Signaling Messages  . . . . . . .
    . . . . . . . . . . . .  25\n   5.  The COSE Object . . . . . . . . . . . . .
    . . . . . . . . . .  26\n     5.1.  ID Context and 'kid context'  . . . . . .
    . . . . . . . .  27\n     5.2.  AEAD Nonce  . . . . . . . . . . . . . . . . .
    . . . . . .  28\n     5.3.  Plaintext . . . . . . . . . . . . . . . . . . . .
    . . . .  29\n     5.4.  Additional Authenticated Data . . . . . . . . . . . .
    . .  30\n   6.  OSCORE Header Compression . . . . . . . . . . . . . . . . . .
    \ 31\n     6.1.  Encoding of the OSCORE Option Value . . . . . . . . . . .  32\n
    \    6.2.  Encoding of the OSCORE Payload  . . . . . . . . . . . . .  33\n     6.3.
    \ Examples of Compressed COSE Objects . . . . . . . . . . .  33\n   7.  Message
    Binding, Sequence Numbers, Freshness, and Replay\n       Protection  . . . . .
    . . . . . . . . . . . . . . . . . . . .  36\n     7.1.  Message Binding . . .
    . . . . . . . . . . . . . . . . . .  36\n     7.2.  Sequence Numbers  . . . .
    . . . . . . . . . . . . . . . .  36\n     7.3.  Freshness . . . . . . . . . .
    . . . . . . . . . . . . . .  36\n     7.4.  Replay Protection . . . . . . . .
    . . . . . . . . . . . .  37\n     7.5.  Losing Part of the Context State  . .
    . . . . . . . . . .  38\n   8.  Processing  . . . . . . . . . . . . . . . . .
    . . . . . . . .  39\n     8.1.  Protecting the Request  . . . . . . . . . . .
    . . . . . .  39\n     8.2.  Verifying the Request . . . . . . . . . . . . . .
    . . . .  40\n     8.3.  Protecting the Response . . . . . . . . . . . . . . .
    . .  41\n     8.4.  Verifying the Response  . . . . . . . . . . . . . . . . .
    \ 43\n   9.  Web Linking . . . . . . . . . . . . . . . . . . . . . . . . .  44\n
    \  10. CoAP-to-CoAP Forwarding Proxy . . . . . . . . . . . . . . . .  45\n   11.
    HTTP Operations . . . . . . . . . . . . . . . . . . . . . . .  46\n     11.1.
    \ The HTTP OSCORE Header Field . . . . . . . . . . . . . .  46\n     11.2.  CoAP-to-HTTP
    Mapping . . . . . . . . . . . . . . . . . .  47\n     11.3.  HTTP-to-CoAP Mapping
    . . . . . . . . . . . . . . . . . .  48\n     11.4.  HTTP Endpoints . . . . .
    . . . . . . . . . . . . . . . .  48\n     11.5.  Example: HTTP Client and CoAP
    Server . . . . . . . . . .  48\n     11.6.  Example: CoAP Client and HTTP Server
    . . . . . . . . . .  50\n   12. Security Considerations . . . . . . . . . . .
    . . . . . . . .  51\n     12.1.  End-to-end Protection  . . . . . . . . . . .
    . . . . . .  51\n     12.2.  Security Context Establishment . . . . . . . . .
    . . . .  52\n     12.3.  Master Secret  . . . . . . . . . . . . . . . . . . .
    . .  52\n     12.4.  Replay Protection  . . . . . . . . . . . . . . . . . . .
    \ 53\n     12.5.  Client Aliveness . . . . . . . . . . . . . . . . . . . .  53\n
    \    12.6.  Cryptographic Considerations . . . . . . . . . . . . . .  53\n     12.7.
    \ Message Segmentation . . . . . . . . . . . . . . . . . .  54\n     12.8.  Privacy
    Considerations . . . . . . . . . . . . . . . . .  54\n   13. IANA Considerations
    . . . . . . . . . . . . . . . . . . . . .  55\n     13.1.  COSE Header Parameters
    Registry  . . . . . . . . . . . .  55\n     13.2.  CoAP Option Numbers Registry
    . . . . . . . . . . . . . .  55\n     13.3.  CoAP Signaling Option Numbers Registry
    . . . . . . . . .  56\n     13.4.  Header Field Registrations . . . . . . . .
    . . . . . . .  57\n     13.5.  Media Type Registration  . . . . . . . . . . .
    . . . . .  57\n     13.6.  CoAP Content-Formats Registry  . . . . . . . . . .
    . . .  58\n     13.7.  OSCORE Flag Bits Registry  . . . . . . . . . . . . . .
    .  58\n     13.8.  Expert Review Instructions . . . . . . . . . . . . . . .  59\n
    \  14. References  . . . . . . . . . . . . . . . . . . . . . . . . .  60\n     14.1.
    \ Normative References . . . . . . . . . . . . . . . . . .  60\n     14.2.  Informative
    References . . . . . . . . . . . . . . . . .  62\n   Appendix A.  Scenario Examples
    \ . . . . . . . . . . . . . . . . .  65\n     A.1.  Secure Access to Sensor .
    . . . . . . . . . . . . . . . .  65\n     A.2.  Secure Subscribe to Sensor  .
    . . . . . . . . . . . . . .  66\n   Appendix B.  Deployment Examples  . . . .
    . . . . . . . . . . . .  68\n     B.1.  Security Context Derived Once . . . .
    . . . . . . . . . .  68\n     B.2.  Security Context Derived Multiple Times .
    . . . . . . . .  70\n   Appendix C.  Test Vectors . . . . . . . . . . . . . .
    . . . . . .  75\n     C.1.  Test Vector 1: Key Derivation with Master Salt  .
    . . . .  75\n     C.2.  Test Vector 2: Key Derivation without Master Salt . .
    . .  77\n     C.3.  Test Vector 3: Key Derivation with ID Context . . . . . .
    \ 78\n     C.4.  Test Vector 4: OSCORE Request, Client . . . . . . . . . .  80\n
    \    C.5.  Test Vector 5: OSCORE Request, Client . . . . . . . . . .  81\n     C.6.
    \ Test Vector 6: OSCORE Request, Client . . . . . . . . . .  82\n     C.7.  Test
    Vector 7: OSCORE Response, Server  . . . . . . . . .  84\n     C.8.  Test Vector
    8: OSCORE Response with Partial IV, Server  .  85\n   Appendix D.  Overview of
    Security Properties  . . . . . . . . . .  86\n     D.1.  Threat Model  . . . .
    . . . . . . . . . . . . . . . . . .  86\n     D.2.  Supporting Proxy Operations
    . . . . . . . . . . . . . . .  87\n     D.3.  Protected Message Fields  . . .
    . . . . . . . . . . . . .  87\n     D.4.  Uniqueness of (key, nonce)  . . . .
    . . . . . . . . . . .  88\n     D.5.  Unprotected Message Fields  . . . . . .
    . . . . . . . . .  89\n   Appendix E.  CDDL Summary . . . . . . . . . . . . .
    . . . . . . .  93\n   Acknowledgments . . . . . . . . . . . . . . . . . . . .
    . . . . .  94\n   Authors' Addresses  . . . . . . . . . . . . . . . . . . . .
    . . .  94\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Constrained Application Protocol (CoAP) [RFC7252] is
    a web\n   transfer protocol designed for constrained nodes and networks\n   [RFC7228];
    CoAP may be mapped from HTTP [RFC8075].  CoAP specifies\n   the use of proxies
    for scalability and efficiency and references DTLS\n   [RFC6347] for security.
    \ CoAP-to-CoAP, HTTP-to-CoAP, and CoAP-to-HTTP\n   proxies require DTLS or TLS
    [RFC8446] to be terminated at the proxy.\n   Therefore, the proxy not only has
    access to the data required for\n   performing the intended proxy functionality,
    but is also able to\n   eavesdrop on, or manipulate any part of, the message payload
    and\n   metadata in transit between the endpoints.  The proxy can also\n   inject,
    delete, or reorder packets since they are no longer protected\n   by (D)TLS.\n
    \  This document defines the Object Security for Constrained RESTful\n   Environments
    (OSCORE) security protocol, protecting CoAP and CoAP-\n   mappable HTTP requests
    and responses end-to-end across intermediary\n   nodes such as CoAP forward proxies
    and cross-protocol translators\n   including HTTP-to-CoAP proxies [RFC8075].  In
    addition to the core\n   CoAP features defined in [RFC7252], OSCORE supports the
    Observe\n   [RFC7641], Block-wise [RFC7959], and No-Response [RFC7967] options,\n
    \  as well as the PATCH and FETCH methods [RFC8132].  An analysis of\n   end-to-end
    security for CoAP messages through some types of\n   intermediary nodes is performed
    in [CoAP-E2E-Sec].  OSCORE\n   essentially protects the RESTful interactions:
    the request method,\n   the requested resource, the message payload, etc. (see
    Section 4),\n   where \"RESTful\" refers to the Representational State Transfer
    (REST)\n   Architecture [REST].  OSCORE protects neither the CoAP messaging\n
    \  layer nor the CoAP Token, which may change between the endpoints;\n   therefore,
    those are processed as defined in [RFC7252].\n   Additionally, since the message
    formats for CoAP over unreliable\n   transport [RFC7252] and for CoAP over reliable
    transport [RFC8323]\n   differ only in terms of CoAP messaging layer, OSCORE can
    be applied\n   to both unreliable and reliable transports (see Figure 1).\n   OSCORE
    works in very constrained nodes and networks, thanks to its\n   small message
    size and the restricted code and memory requirements in\n   addition to what is
    required by CoAP.  Examples of the use of OSCORE\n   are given in Appendix A.
    \ OSCORE may be used over any underlying\n   layer, such as UDP or TCP, and with
    non-IP transports (e.g.,\n   [CoAP-802.15.4]).  OSCORE may also be used in different
    ways with\n   HTTP.  OSCORE messages may be transported in HTTP, and OSCORE may\n
    \  also be used to protect CoAP-mappable HTTP messages, as described\n   below.\n
    \              +-----------------------------------+\n               |            Application
    \           |\n               +-----------------------------------+\n               +-----------------------------------+
    \ \\\n               |  Requests / Responses / Signaling |  |\n               |-----------------------------------|
    \ |\n               |               OSCORE              |  | CoAP\n               |-----------------------------------|
    \ |\n               | Messaging Layer / Message Framing |  |\n               +-----------------------------------+
    \ /\n               +-----------------------------------+\n               |          UDP
    / TCP / ...          |\n               +-----------------------------------+\n
    \             Figure 1: Abstract Layering of CoAP with OSCORE\n   OSCORE is designed
    to protect as much information as possible while\n   still allowing CoAP proxy
    operations (Section 10).  It works with\n   existing CoAP-to-CoAP forward proxies
    [RFC7252], but an OSCORE-aware\n   proxy will be more efficient.  HTTP-to-CoAP
    proxies [RFC8075] and\n   CoAP-to-HTTP proxies can also be used with OSCORE, as
    specified in\n   Section 11.  OSCORE may be used together with TLS or DTLS over
    one or\n   more hops in the end-to-end path, e.g., transported with HTTPS in one\n
    \  hop and with plain CoAP in another hop.  The use of OSCORE does not\n   affect
    the URI scheme; therefore, OSCORE can be used with any URI\n   scheme defined
    for CoAP or HTTP.  The application decides the\n   conditions for which OSCORE
    is required.\n   OSCORE uses pre-shared keys that may have been established out-of-\n
    \  band or with a key establishment protocol (see Section 3.2).  The\n   technical
    solution builds on CBOR Object Signing and Encryption\n   (COSE) [RFC8152], providing
    end-to-end encryption, integrity, replay\n   protection, and binding of response
    to request.  A compressed version\n   of COSE is used, as specified in Section
    6.  The use of OSCORE is\n   signaled in CoAP with a new option (Section 2), and
    in HTTP with a\n   new header field (Section 11.1) and content type (Section 13.5).
    \ The\n   solution transforms a CoAP/HTTP message into an \"OSCORE message\"\n
    \  before sending, and vice versa after receiving.  The OSCORE message\n   is
    a CoAP/HTTP message related to the original message in the\n   following way:
    the original CoAP/HTTP message is translated to CoAP\n   (if not already in CoAP)
    and protected in a COSE object.  The\n   encrypted message fields of this COSE
    object are transported in the\n   CoAP payload/HTTP body of the OSCORE message,
    and the OSCORE option/\n   header field is included in the message.  A sketch
    of an exchange of\n   OSCORE messages, in the case of the original message being
    CoAP, is\n   provided in Figure 2.  The use of OSCORE with HTTP is detailed in\n
    \  Section 11.\n          Client                                          Server\n
    \            |      OSCORE request - POST example.com:      |\n             |
    \       Header, Token,                        |\n             |        Options:
    OSCORE, ...,                 |\n             |        Payload: COSE ciphertext
    \             |\n             +--------------------------------------------->|\n
    \            |                                              |\n             |<---------------------------------------------+\n
    \            |      OSCORE response - 2.04 (Changed):       |\n             |
    \       Header, Token,                        |\n             |        Options:
    OSCORE, ...,                 |\n             |        Payload: COSE ciphertext
    \             |\n             |                                              |\n
    \                  Figure 2: Sketch of CoAP with OSCORE\n   An implementation
    supporting this specification MAY implement only\n   the client part, MAY implement
    only the server part, or MAY implement\n   only one of the proxy parts.\n"
  - contents:
    - "1.1.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
      \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
      \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
      in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n
      \  capitals, as shown here.\n   Readers are expected to be familiar with the
      terms and concepts\n   described in CoAP [RFC7252], COSE [RFC8152], Concise
      Binary Object\n   Representation (CBOR) [RFC7049], Concise Data Definition Language\n
      \  (CDDL) [RFC8610] as summarized in Appendix E, and constrained\n   environments
      [RFC7228].  Additional optional features include Observe\n   [RFC7641], Block-wise
      [RFC7959], No-Response [RFC7967] and CoAP over\n   reliable transport [RFC8323].\n
      \  The term \"hop\" is used to denote a particular leg in the end-to-end\n   path.
      \ The concept \"hop-by-hop\" (as in \"hop-by-hop encryption\" or\n   \"hop-by-hop
      fragmentation\") opposed to \"end-to-end\", is used in this\n   document to
      indicate that the messages are processed accordingly in\n   the intermediaries,
      rather than just forwarded to the next node.\n   The term \"stop processing\"
      is used throughout the document to denote\n   that the message is not passed
      up to the CoAP request/response layer\n   (see Figure 1).\n   The terms Common
      Context, Sender Context, Recipient Context, Master\n   Secret, Master Salt,
      Sender ID, Sender Key, Recipient ID, Recipient\n   Key, ID Context, and Common
      IV are defined in Section 3.1.\n"
    title: 1.1.  Terminology
  title: 1.  Introduction
- contents:
  - "2.  The OSCORE Option\n   The OSCORE option defined in this section (see Figure
    3, which\n   extends \"Table 4: Options\" of [RFC7252]) indicates that the CoAP\n
    \  message is an OSCORE message and that it contains a compressed COSE\n   object
    (see Sections 5 and 6).  The OSCORE option is critical, safe\n   to forward, part
    of the cache key, and not repeatable.\n   +------+---+---+---+---+----------------+--------+--------+---------+\n
    \  | No.  | C | U | N | R | Name           | Format | Length | Default |\n   +------+---+---+---+---+----------------+--------+--------+---------+\n
    \  |   9  | x |   |   |   | OSCORE         |  (*)   | 0-255  | (none)  |\n   +------+---+---+---+---+----------------+--------+--------+---------+\n
    \      C = Critical,   U = Unsafe,   N = NoCacheKey,   R = Repeatable\n       (*)
    See below.\n                        Figure 3: The OSCORE Option\n   The OSCORE
    option includes the OSCORE flag bits (Section 6), the\n   Sender Sequence Number,
    the Sender ID, and the ID Context when these\n   fields are present (Section 3).
    \ The detailed format and length is\n   specified in Section 6.  If the OSCORE
    flag bits are all zero (0x00),\n   the option value SHALL be empty (Option Length
    = 0).  An endpoint\n   receiving a CoAP message without payload that also contains
    an OSCORE\n   option SHALL treat it as malformed and reject it.\n   A successful
    response to a request with the OSCORE option SHALL\n   contain the OSCORE option.
    \ Whether error responses contain the\n   OSCORE option depends on the error type
    (see Section 8).\n   For CoAP proxy operations, see Section 10.\n"
  title: 2.  The OSCORE Option
- contents:
  - "3.  The Security Context\n   OSCORE requires that client and server establish
    a shared security\n   context used to process the COSE objects.  OSCORE uses COSE
    with an\n   Authenticated Encryption with Associated Data (AEAD, [RFC5116])\n
    \  algorithm for protecting message data between a client and a server.\n   In
    this section, we define the security context and how it is derived\n   in client
    and server based on a shared secret and a key derivation\n   function.\n"
  - contents:
    - "3.1.  Security Context Definition\n   The security context is the set of information
      elements necessary to\n   carry out the cryptographic operations in OSCORE.
      \ For each endpoint,\n   the security context is composed of a \"Common Context\",
      a \"Sender\n   Context\", and a \"Recipient Context\".\n   The endpoints protect
      messages to send using the Sender Context and\n   verify messages received using
      the Recipient Context; both contexts\n   being derived from the Common Context
      and other data.  Clients and\n   servers need to be able to retrieve the correct
      security context to\n   use.\n   An endpoint uses its Sender ID (SID) to derive
      its Sender Context;\n   the other endpoint uses the same ID, now called Recipient
      ID (RID),\n   to derive its Recipient Context.  In communication between two\n
      \  endpoints, the Sender Context of one endpoint matches the Recipient\n   Context
      of the other endpoint, and vice versa.  Thus, the two\n   security contexts
      identified by the same IDs in the two endpoints are\n   not the same, but they
      are partly mirrored.  Retrieval and use of the\n   security context are shown
      in Figure 4.\n             .---------------------.   .---------------------.\n
      \            |    Common Context   | = |    Common Context   |\n             +---------------------+
      \  +---------------------+\n             |    Sender Context   | = |  Recipient
      Context  |\n             +---------------------+   +---------------------+\n
      \            |  Recipient Context  | = |    Sender Context   |\n             '---------------------'
      \  '---------------------'\n                      Client                   Server\n
      \                        |                       |\n   Retrieve context for
      \ | OSCORE request:       |\n    target resource      |   Token = Token1,     |\n
      \  Protect request with  |   kid = SID, ...      |\n     Sender Context      +---------------------->|
      Retrieve context with\n                         |                       |  RID
      = kid\n                         |                       | Verify request with\n
      \                        |                       |  Recipient Context\n                         |
      OSCORE response:      | Protect response with\n                         |   Token
      = Token1, ... |  Sender Context\n   Retrieve context with |<----------------------+\n
      \   Token = Token1       |                       |\n   Verify request with   |
      \                      |\n    Recipient Context    |                       |\n
      \           Figure 4: Retrieval and Use of the Security Context\n   The Common
      Context contains the following parameters:\n   o  AEAD Algorithm.  The COSE
      AEAD algorithm to use for encryption.\n   o  HKDF Algorithm.  An HMAC-based
      key derivation function (HKDF,\n      [RFC5869]) used to derive the Sender Key,
      Recipient Key, and\n      Common IV.\n   o  Master Secret.  Variable length,
      random byte string (see\n      Section 12.3) used to derive AEAD keys and Common
      IV.\n   o  Master Salt.  Optional variable-length byte string containing the\n
      \     salt used to derive AEAD keys and Common IV.\n   o  ID Context.  Optional
      variable-length byte string providing\n      additional information to identify
      the Common Context and to\n      derive AEAD keys and Common IV.  The use of
      ID Context is\n      described in Section 5.1.\n   o  Common IV.  Byte string
      derived from the Master Secret, Master\n      Salt, and ID Context.  Used to
      generate the AEAD nonce (see\n      Section 5.2).  Same length as the nonce
      of the AEAD Algorithm.\n   The Sender Context contains the following parameters:\n
      \  o  Sender ID.  Byte string used to identify the Sender Context, to\n      derive
      AEAD keys and Common IV, and to contribute to the\n      uniqueness of AEAD
      nonces.  Maximum length is determined by the\n      AEAD Algorithm.\n   o  Sender
      Key. Byte string containing the symmetric AEAD key to\n      protect messages
      to send.  Derived from Common Context and Sender\n      ID.  Length is determined
      by the AEAD Algorithm.\n   o  Sender Sequence Number.  Non-negative integer
      used by the sender\n      to enumerate requests and certain responses, e.g.,
      Observe\n      notifications.  Used as \"Partial IV\" [RFC8152] to generate
      unique\n      AEAD nonces.  Maximum value is determined by the AEAD Algorithm.\n
      \     Initialization is described in Section 3.2.2.\n   The Recipient Context
      contains the following parameters:\n   o  Recipient ID.  Byte string used to
      identify the Recipient Context,\n      to derive AEAD keys and Common IV, and
      to contribute to the\n      uniqueness of AEAD nonces.  Maximum length is determined
      by the\n      AEAD Algorithm.\n   o  Recipient Key. Byte string containing the
      symmetric AEAD key to\n      verify messages received.  Derived from Common
      Context and\n      Recipient ID.  Length is determined by the AEAD Algorithm.\n
      \  o  Replay Window (Server only).  The replay window used to verify\n      requests
      received.  Replay protection is described in Section 7.4\n      and Section
      3.2.2.\n   All parameters except Sender Sequence Number and Replay Window are\n
      \  immutable once the security context is established.  An endpoint may\n   free
      up memory by not storing the Common IV, Sender Key, and\n   Recipient Key, deriving
      them when needed.  Alternatively, an endpoint\n   may free up memory by not
      storing the Master Secret and Master Salt\n   after the other parameters have
      been derived.\n   Endpoints MAY operate as both client and server and use the
      same\n   security context for those roles.  Independent of being client or\n
      \  server, the endpoint protects messages to send using its Sender\n   Context,
      and verifies messages received using its Recipient Context.\n   The endpoints
      MUST NOT change the Sender/Recipient ID when changing\n   roles.  In other words,
      changing the roles does not change the set of\n   AEAD keys to be used.\n"
    title: 3.1.  Security Context Definition
  - contents:
    - "3.2.  Establishment of Security Context Parameters\n   Each endpoint derives
      the parameters in the security context from a\n   small set of input parameters.
      \ The following input parameters SHALL\n   be preestablished:\n   o  Master
      Secret\n   o  Sender ID\n   o  Recipient ID\n   The following input parameters
      MAY be preestablished.  In case any of\n   these parameters is not preestablished,
      the default value indicated\n   below is used:\n   o  AEAD Algorithm\n      *
      \ Default is AES-CCM-16-64-128 (COSE algorithm encoding: 10)\n   o  Master Salt\n
      \     *  Default is the empty byte string\n   o  HKDF Algorithm\n      *  Default
      is HKDF SHA-256\n   o  Replay Window\n      *  The default mechanism is an anti-replay
      sliding window (see\n         Section 4.1.2.6 of [RFC6347] with a window size
      of 32\n   All input parameters need to be known and agreed on by both\n   endpoints,
      but the Replay Window may be different in the two\n   endpoints.  The way the
      input parameters are preestablished is\n   application specific.  Considerations
      of security context\n   establishment are given in Section 12.2 and examples
      of deploying\n   OSCORE in Appendix B.\n"
    - contents:
      - "3.2.1.  Derivation of Sender Key, Recipient Key, and Common IV\n   The HKDF
        MUST be one of the HMAC-based HKDF [RFC5869] algorithms\n   defined for COSE
        [RFC8152].  HKDF SHA-256 is mandatory to implement.\n   The security context
        parameters Sender Key, Recipient Key, and Common\n   IV SHALL be derived from
        the input parameters using the HKDF, which\n   consists of the composition
        of the HKDF-Extract and HKDF-Expand steps\n   [RFC5869]:\n      output parameter
        = HKDF(salt, IKM, info, L)\n   where:\n   o  salt is the Master Salt as defined
        above\n   o  IKM is the Master Secret as defined above\n   o  info is the
        serialization of a CBOR array consisting of (the\n      notation follows [RFC8610]
        as summarized in Appendix E):\n      info = [\n        id : bstr,\n        id_context
        : bstr / nil,\n        alg_aead : int / tstr,\n        type : tstr,\n        L
        : uint,\n      ]\n   where:\n   o  id is the Sender ID or Recipient ID when
        deriving Sender Key and\n      Recipient Key, respectively, and the empty
        byte string when\n      deriving the Common IV.\n   o  id_context is the ID
        Context, or nil if ID Context is not\n      provided.\n   o  alg_aead is the
        AEAD Algorithm, encoded as defined in [RFC8152].\n   o  type is \"Key\" or
        \"IV\".  The label is an ASCII string and does not\n      include a trailing
        NUL byte.\n   o  L is the size of the key/nonce for the AEAD Algorithm used,
        in\n      bytes.\n   For example, if the algorithm AES-CCM-16-64-128 (see
        Section 10.2 in\n   [RFC8152]) is used, the integer value for alg_aead is
        10, the value\n   for L is 16 for keys and 13 for the Common IV.  Assuming
        use of the\n   default algorithms HKDF SHA-256 and AES-CCM-16-64-128, the
        extract\n   phase of HKDF produces a pseudorandom key (PRK) as follows:\n
        \     PRK = HMAC-SHA-256(Master Salt, Master Secret)\n   and as L is smaller
        than the hash function output size, the expand\n   phase of HKDF consists
        of a single HMAC invocation; therefore, the\n   Sender Key, Recipient Key,
        and Common IV are the first 16 or 13 bytes\n   of\n      output parameter
        = HMAC-SHA-256(PRK, info || 0x01)\n   where different values of info are used
        for each derived parameter\n   and where || denotes byte string concatenation.\n
        \  Note that [RFC5869] specifies that if the salt is not provided, it is\n
        \  set to a string of zeros.  For implementation purposes, not providing\n
        \  the salt is the same as setting the salt to the empty byte string.\n   OSCORE
        sets the salt default value to empty byte string, which is\n   converted to
        a string of zeroes (see Section 2.2 of [RFC5869]).\n"
      title: 3.2.1.  Derivation of Sender Key, Recipient Key, and Common IV
    - contents:
      - "3.2.2.  Initial Sequence Numbers and Replay Window\n   The Sender Sequence
        Number is initialized to 0.\n   The supported types of replay protection and
        replay window size is\n   application specific and depends on how OSCORE is
        transported (see\n   Section 7.4).  The default mechanism is the anti-replay
        window of\n   received messages used by IPsec AH/ESP and DTLS (see Section
        4.1.2.6\n   of [RFC6347]) with a window size of 32.\n"
      title: 3.2.2.  Initial Sequence Numbers and Replay Window
    title: 3.2.  Establishment of Security Context Parameters
  - contents:
    - "3.3.  Requirements on the Security Context Parameters\n   To ensure unique
      Sender Keys, the quartet (Master Secret, Master\n   Salt, ID Context, Sender
      ID) MUST be unique, i.e., the pair (ID\n   Context, Sender ID) SHALL be unique
      in the set of all security\n   contexts using the same Master Secret and Master
      Salt.  This means\n   that Sender ID SHALL be unique in the set of all security
      contexts\n   using the same Master Secret, Master Salt, and ID Context; such
      a\n   requirement guarantees unique (key, nonce) pairs for the AEAD.\n   Different
      methods can be used to assign Sender IDs: a protocol that\n   allows the parties
      to negotiate locally unique identifiers, a trusted\n   third party (e.g., [ACE-OAuth]),
      or the identifiers can be assigned\n   out-of-band.  The Sender IDs can be very
      short (note that the empty\n   string is a legitimate value).  The maximum length
      of Sender ID in\n   bytes equals the length of the AEAD nonce minus 6, see Section
      5.2.\n   For AES-CCM-16-64-128 the maximum length of Sender ID is 7 bytes.\n
      \  To simplify retrieval of the right Recipient Context, the Recipient\n   ID
      SHOULD be unique in the sets of all Recipient Contexts used by an\n   endpoint.
      \ If an endpoint has the same Recipient ID with different\n   Recipient Contexts,
      i.e., the Recipient Contexts are derived from\n   different Common Contexts,
      then the endpoint may need to try multiple\n   times before verifying the right
      security context associated to the\n   Recipient ID.\n   The ID Context is used
      to distinguish between security contexts.  The\n   methods used for assigning
      Sender ID can also be used for assigning\n   the ID Context.  Additionally,
      the ID Context can be used to\n   introduce randomness into new Sender and Recipient
      Contexts (see\n   Appendix B.2).  ID Context can be arbitrarily long.\n"
    title: 3.3.  Requirements on the Security Context Parameters
  title: 3.  The Security Context
- contents:
  - "4.  Protected Message Fields\n   OSCORE transforms a CoAP message (which may
    have been generated from\n   an HTTP message) into an OSCORE message, and vice
    versa.  OSCORE\n   protects as much of the original message as possible while
    still\n   allowing certain proxy operations (see Sections 10 and 11).  This\n
    \  section defines how OSCORE protects the message fields and transfers\n   them
    end-to-end between client and server (in any direction).\n   The remainder of
    this section and later sections focus on the\n   behavior in terms of CoAP messages.
    \ If HTTP is used for a particular\n   hop in the end-to-end path, then this section
    applies to the\n   conceptual CoAP message that is mappable to/from the original
    HTTP\n   message as discussed in Section 11.  That is, an HTTP message is\n   conceptually
    transformed to a CoAP message and then to an OSCORE\n   message, and similarly
    in the reverse direction.  An actual\n   implementation might translate directly
    from HTTP to OSCORE without\n   the intervening CoAP representation.\n   Protection
    of signaling messages (Section 5 of [RFC8323]) is\n   specified in Section 4.3.
    \ The other parts of this section target\n   request/response messages.\n   Message
    fields of the CoAP message may be protected end-to-end\n   between CoAP client
    and CoAP server in different ways:\n   o  Class E: encrypted and integrity protected,\n
    \  o  Class I: integrity protected only, or\n   o  Class U: unprotected.\n   The
    sending endpoint SHALL transfer Class E message fields in the\n   ciphertext of
    the COSE object in the OSCORE message.  The sending\n   endpoint SHALL include
    Class I message fields in the AAD of the AEAD\n   algorithm, allowing the receiving
    endpoint to detect if the value has\n   changed in transfer.  Class U message
    fields SHALL NOT be protected\n   in transfer.  Class I and Class U message field
    values are\n   transferred in the header or options part of the OSCORE message,\n
    \  which is visible to proxies.\n   Message fields not visible to proxies, i.e.,
    transported in the\n   ciphertext of the COSE object, are called \"Inner\" (Class
    E).  Message\n   fields transferred in the header or options part of the OSCORE\n
    \  message, which is visible to proxies, are called \"Outer\" (Class I or\n   Class
    U).  There are currently no Class I options defined.\n   An OSCORE message may
    contain both an Inner and an Outer instance of\n   a certain CoAP message field.
    \ Inner message fields are intended for\n   the receiving endpoint, whereas Outer
    message fields are used to\n   enable proxy operations.\n"
  - contents:
    - "4.1.  CoAP Options\n   A summary of how options are protected is shown in Figure
      5.  Note\n   that some options may have both Inner and Outer message fields,
      which\n   are protected accordingly.  Certain options require special\n   processing
      as is described in Section 4.1.3.\n   Options that are unknown or for which
      OSCORE processing is not\n   defined SHALL be processed as Class E (and no special
      processing).\n   Specifications of new CoAP options SHOULD define how they are\n
      \  processed with OSCORE.  A new COAP option SHOULD be of Class E unless\n   it
      requires proxy processing.  If a new CoAP option is of class U,\n   the potential
      issues with the option being unprotected SHOULD be\n   documented (see Appendix
      D.5).\n"
    - contents:
      - "4.1.1.  Inner Options\n   Inner option message fields (Class E) are used
        to communicate\n   directly with the other endpoint.\n   The sending endpoint
        SHALL write the Inner option message fields\n   present in the original CoAP
        message into the plaintext of the COSE\n   object (Section 5.3) and then remove
        the Inner option message fields\n   from the OSCORE message.\n   The processing
        of Inner option message fields by the receiving\n   endpoint is specified
        in Sections 8.2 and 8.4.\n                   +------+-----------------+---+---+\n
        \                  | No.  | Name            | E | U |\n                   +------+-----------------+---+---+\n
        \                  |   1  | If-Match        | x |   |\n                   |
        \  3  | Uri-Host        |   | x |\n                   |   4  | ETag            |
        x |   |\n                   |   5  | If-None-Match   | x |   |\n                   |
        \  6  | Observe         | x | x |\n                   |   7  | Uri-Port        |
        \  | x |\n                   |   8  | Location-Path   | x |   |\n                   |
        \  9  | OSCORE          |   | x |\n                   |  11  | Uri-Path        |
        x |   |\n                   |  12  | Content-Format  | x |   |\n                   |
        \ 14  | Max-Age         | x | x |\n                   |  15  | Uri-Query       |
        x |   |\n                   |  17  | Accept          | x |   |\n                   |
        \ 20  | Location-Query  | x |   |\n                   |  23  | Block2          |
        x | x |\n                   |  27  | Block1          | x | x |\n                   |
        \ 28  | Size2           | x | x |\n                   |  35  | Proxy-Uri       |
        \  | x |\n                   |  39  | Proxy-Scheme    |   | x |\n                   |
        \ 60  | Size1           | x | x |\n                   | 258  | No-Response
        \    | x | x |\n                   +------+-----------------+---+---+\n                 E
        = Encrypt and Integrity Protect (Inner)\n                 U = Unprotected
        (Outer)\n                   Figure 5: Protection of CoAP Options\n"
      title: 4.1.1.  Inner Options
    - contents:
      - "4.1.2.  Outer Options\n   Outer option message fields (Class U or I) are
        used to support proxy\n   operations, see Appendix D.2.\n   The sending endpoint
        SHALL include the Outer option message field\n   present in the original message
        in the options part of the OSCORE\n   message.  All Outer option message fields,
        including the OSCORE\n   option, SHALL be encoded as described in Section
        3.1 of [RFC7252],\n   where the delta is the difference from the previously
        included\n   instance of Outer option message field.\n   The processing of
        Outer options by the receiving endpoint is\n   specified in Sections 8.2 and
        8.4.\n   A procedure for integrity-protection-only of Class I option message\n
        \  fields is specified in Section 5.4.  Specifications that introduce\n   repeatable
        Class I options MUST specify that proxies MUST NOT change\n   the order of
        the instances of such an option in the CoAP message.\n   Note: There are currently
        no Class I option message fields defined.\n"
      title: 4.1.2.  Outer Options
    - contents:
      - "4.1.3.  Special Options\n   Some options require special processing as specified
        in this section.\n"
      - contents:
        - "4.1.3.1.  Max-Age\n   An Inner Max-Age message field is used to indicate
          the maximum time a\n   response may be cached by the client (as defined
          in [RFC7252]), end-\n   to-end from the server to the client, taking into
          account that the\n   option is not accessible to proxies.  The Inner Max-Age
          SHALL be\n   processed by OSCORE as a normal Inner option, specified in\n
          \  Section 4.1.1.\n   An Outer Max-Age message field is used to avoid unnecessary
          caching\n   of error responses caused by OSCORE processing at OSCORE-unaware\n
          \  intermediary nodes.  A server MAY set a Class U Max-Age message field\n
          \  with value zero to such error responses, described in Sections 7.4,\n
          \  8.2, and 8.4, since these error responses are cacheable, but\n   subsequent
          OSCORE requests would never create a hit in the\n   intermediary node caching
          it.  Setting the Outer Max-Age to zero\n   relieves the intermediary from
          uselessly caching responses.\n   Successful OSCORE responses do not need
          to include an Outer Max-Age\n   option.  Except when the Observe option
          (see Section 4.1.3.5) is\n   used, responses appear to the OSCORE-unaware
          intermediary as 2.04\n   (Changed) responses, which are non-cacheable (see
          Section 4.2).  For\n   Observe responses, which are cacheable, an Outer
          Max-Age option with\n   value 0 may be used to avoid unnecessary proxy caching.\n
          \  The Outer Max-Age message field is processed according to\n   Section
          4.1.2.\n"
        title: 4.1.3.1.  Max-Age
      - contents:
        - "4.1.3.2.  Uri-Host and Uri-Port\n   When the Uri-Host and Uri-Port are
          set to their default values (see\n   Section 5.10.1 [RFC7252]), they are
          omitted from the message\n   (Section 5.4.4 of [RFC7252]), which is favorable
          both for overhead\n   and privacy.\n   In order to support forward proxy
          operations, Proxy-Scheme, Uri-Host,\n   and Uri-Port need to be Class U.
          \ For the use of Proxy-Uri, see\n   Section 4.1.3.3.\n   Manipulation of
          unprotected message fields (including Uri-Host, Uri-\n   Port, destination
          IP/port or request scheme) MUST NOT lead to an\n   OSCORE message becoming
          verified by an unintended server.  Different\n   servers SHALL have different
          security contexts.\n"
        title: 4.1.3.2.  Uri-Host and Uri-Port
      - contents:
        - "4.1.3.3.  Proxy-Uri\n   When Proxy-Uri is present, the client SHALL first
          decompose the\n   Proxy-Uri value of the original CoAP message into the
          Proxy-Scheme,\n   Uri-Host, Uri-Port, Uri-Path, and Uri-Query options according
          to\n   Section 6.4 of [RFC7252].\n   Uri-Path and Uri-Query are Class E
          options and SHALL be protected and\n   processed as Inner options (Section
          4.1.1).\n   The Proxy-Uri option of the OSCORE message SHALL be set to the\n
          \  composition of Proxy-Scheme, Uri-Host, and Uri-Port options as\n   specified
          in Section 6.5 of [RFC7252] and processed as an Outer\n   option of Class
          U (Section 4.1.2).\n   Note that replacing the Proxy-Uri value with the
          Proxy-Scheme and\n   Uri-* options works by design for all CoAP URIs (see
          Section 6 of\n   [RFC7252]).  OSCORE-aware HTTP servers should not use the
          userinfo\n   component of the HTTP URI (as defined in Section 3.2.1 of [RFC3986]),\n
          \  so that this type of replacement is possible in the presence of CoAP-\n
          \  to-HTTP proxies (see Section 11.2).  In future specifications of\n   cross-protocol
          proxying behavior using different URI structures, it\n   is expected that
          the authors will create Uri-* options that allow\n   decomposing the Proxy-Uri,
          and specifying the OSCORE processing.\n   An example of how Proxy-Uri is
          processed is given here.  Assume that\n   the original CoAP message contains:\n
          \  o  Proxy-Uri = \"coap://example.com/resource?q=1\"\n   During OSCORE
          processing, Proxy-Uri is split into:\n   o  Proxy-Scheme = \"coap\"\n   o
          \ Uri-Host = \"example.com\"\n   o  Uri-Port = \"5683\" (default)\n   o
          \ Uri-Path = \"resource\"\n   o  Uri-Query = \"q=1\"\n   Uri-Path and Uri-Query
          follow the processing defined in\n   Section 4.1.1; thus, they are encrypted
          and transported in the COSE\n   object:\n   o  Uri-Path = \"resource\"\n
          \  o  Uri-Query = \"q=1\"\n   The remaining options are composed into the
          Proxy-Uri included in the\n   options part of the OSCORE message, which
          has value:\n   o  Proxy-Uri = \"coap://example.com\"\n   See Sections 6.1
          and 12.6 of [RFC7252] for more details.\n"
        title: 4.1.3.3.  Proxy-Uri
      - contents:
        - "4.1.3.4.  The Block Options\n   Block-wise [RFC7959] is an optional feature.
          \ An implementation MAY\n   support CoAP [RFC7252] and the OSCORE option
          without supporting\n   block-wise transfers.  The Block options (Block1,
          Block2, Size1,\n   Size2), when Inner message fields, provide secure message\n
          \  segmentation such that each segment can be verified.  The Block\n   options,
          when Outer message fields, enable hop-by-hop fragmentation\n   of the OSCORE
          message.  Inner and Outer block processing may have\n   different performance
          properties depending on the underlying\n   transport.  The end-to-end integrity
          of the message can be verified\n   both in case of Inner and Outer Block-wise
          transfers, provided all\n   blocks are received.\n"
        - contents:
          - "4.1.3.4.1.  Inner Block Options\n   The sending CoAP endpoint MAY fragment
            a CoAP message as defined in\n   [RFC7959] before the message is processed
            by OSCORE.  In this case,\n   the Block options SHALL be processed by
            OSCORE as normal Inner\n   options (Section 4.1.1).  The receiving CoAP
            endpoint SHALL process\n   the OSCORE message before processing Block-wise
            as defined in\n   [RFC7959].\n"
          title: 4.1.3.4.1.  Inner Block Options
        - contents:
          - "4.1.3.4.2.  Outer Block Options\n   Proxies MAY fragment an OSCORE message
            using [RFC7959] by introducing\n   Block option message fields that are
            Outer (Section 4.1.2).  Note\n   that the Outer Block options are neither
            encrypted nor integrity\n   protected.  As a consequence, a proxy can
            maliciously inject block\n   fragments indefinitely, since the receiving
            endpoint needs to receive\n   the last block (see [RFC7959]) to be able
            to compose the OSCORE\n   message and verify its integrity.  Therefore,
            applications supporting\n   OSCORE and [RFC7959] MUST specify a security
            policy defining a\n   maximum unfragmented message size (MAX_UNFRAGMENTED_SIZE)
            considering\n   the maximum size of message that can be handled by the
            endpoints.\n   Messages exceeding this size SHOULD be fragmented by the
            sending\n   endpoint using Inner Block options (Section 4.1.3.4.1).\n
            \  An endpoint receiving an OSCORE message with an Outer Block option\n
            \  SHALL first process this option according to [RFC7959], until all\n
            \  blocks of the OSCORE message have been received or the cumulated\n
            \  message size of the blocks exceeds MAX_UNFRAGMENTED_SIZE.  In the\n
            \  former case, the processing of the OSCORE message continues as\n   defined
            in this document.  In the latter case, the message SHALL be\n   discarded.\n
            \  Because of encryption of Uri-Path and Uri-Query, messages to the same\n
            \  server may, from the point of view of a proxy, look like they also\n
            \  target the same resource.  A proxy SHOULD mitigate a potential mix-up\n
            \  of blocks from concurrent requests to the same server, for example,\n
            \  using the Request-Tag processing specified in Section 3.3.2 of\n   [CoAP-ECHO-REQ-TAG].\n"
          title: 4.1.3.4.2.  Outer Block Options
        title: 4.1.3.4.  The Block Options
      - contents:
        - "4.1.3.5.  Observe\n   Observe [RFC7641] is an optional feature.  An implementation
          MAY\n   support CoAP [RFC7252] and the OSCORE option without supporting\n
          \  [RFC7641], in which case the Observe-related processing can be\n   omitted.\n
          \  The support for Observe [RFC7641] with OSCORE targets the\n   requirements
          on forwarding of Section 2.2.1 of [CoAP-E2E-Sec], i.e.,\n   that observations
          go through intermediary nodes, as illustrated in\n   Figure 8 of [RFC7641].\n
          \  Inner Observe SHALL be used to protect the value of the Observe\n   option
          between the endpoints.  Outer Observe SHALL be used to support\n   forwarding
          by intermediary nodes.\n   The server SHALL include a new Partial IV (see
          Section 5) in\n   responses (with or without the Observe option) to Observe\n
          \  registrations, except for the first response where Partial IV MAY be\n
          \  omitted.\n   For cancellations, Section 3.6 of [RFC7641] specifies that
          all\n   options MUST be identical to those in the registration request except\n
          \  for the Observe option and the set of ETag options.  For OSCORE\n   messages,
          this matching is to be done to the options in the decrypted\n   message.\n
          \  [RFC7252] does not specify how the server should act upon receiving\n
          \  the same Token in different requests.  When using OSCORE, the server\n
          \  SHOULD NOT remove an active observation just because it receives a\n
          \  request with the same Token.\n   Since POST with the Observe option is
          not defined, for messages with\n   the Observe option, the Outer Code MUST
          be set to 0.05 (FETCH) for\n   requests and to 2.05 (Content) for responses
          (see Section 4.2).\n"
        - contents:
          - "4.1.3.5.1.  Registrations and Cancellations\n   The Inner and Outer Observe
            options in the request MUST contain the\n   Observe value of the original
            CoAP request; 0 (registration) or 1\n   (cancellation).\n   Every time
            a client issues a new request with the Observe option, a\n   new Partial
            IV MUST be used (see Section 5), and so the payload and\n   OSCORE option
            are changed.  The server uses the Partial IV of the new\n   request as
            the 'request_piv' of all associated notifications (see\n   Section 5.4).\n
            \  Intermediaries are not assumed to have access to the OSCORE security\n
            \  context used by the endpoints; thus, they cannot make requests or\n
            \  transform responses with the OSCORE option that pass verification (at\n
            \  the receiving endpoint) as having come from the other endpoint.  This\n
            \  has the following consequences and limitations for Observe\n   operations.\n
            \  o  An intermediary node removing the Outer Observe 0 option does not\n
            \     change the registration request to a request without the Observe\n
            \     option (see Section 2 of [RFC7641]).  Instead other means for\n
            \     cancellation may be used as described in Section 3.6 of [RFC7641].\n
            \  o  An intermediary node is not able to transform a normal response\n
            \     into an OSCORE-protected Observe notification (see Figure 7 of\n
            \     [RFC7641]) that verifies as coming from the server.\n   o  An intermediary
            node is not able to initiate an OSCORE protected\n      Observe registration
            (Observe option with value 0) that verifies\n      as coming from the
            client.  An OSCORE-aware intermediary SHALL NOT\n      initiate registrations
            of observations (see Section 10).  If an\n      OSCORE-unaware proxy resends
            an old registration message from a\n      client, the replay protection
            mechanism in the server will be\n      triggered.  To prevent this from
            resulting in the OSCORE-unaware\n      proxy canceling the registration,
            a server MAY respond to a\n      replayed registration request with a
            replay of a cached\n      notification.  Alternatively, the server MAY
            send a new\n      notification.\n   o  An intermediary node is not able
            to initiate an OSCORE-protected\n      Observe cancellation (Observe option
            with value 1) that verifies\n      as coming from the client.  An application
            MAY decide to allow\n      intermediaries to cancel Observe registrations,
            e.g., to send the\n      Observe option with value 1 (see Section 3.6
            of [RFC7641]);\n      however, that can also be done with other methods,
            e.g., by\n      sending a RST message.  This is out of scope for this\n
            \     specification.\n"
          title: 4.1.3.5.1.  Registrations and Cancellations
        - contents:
          - "4.1.3.5.2.  Notifications\n   If the server accepts an Observe registration,
            a Partial IV MUST be\n   included in all notifications (both successful
            and error), except for\n   the first one where the Partial IV MAY be omitted.
            \ To protect\n   against replay, the client SHALL maintain a Notification
            Number for\n   each Observation it registers.  The Notification Number
            is a non-\n   negative integer containing the largest Partial IV of the
            received\n   notifications for the associated Observe registration.  Further\n
            \  details of replay protection of notifications are specified in\n   Section
            7.4.1.\n   For notifications, the Inner Observe option value MUST be empty
            (see\n   Section 3.2 of [RFC7252]).  The Outer Observe option in a\n   notification
            is needed for intermediary nodes to allow multiple\n   responses to one
            request, and it MAY be set to the value of the\n   Observe option in the
            original CoAP message.  The client performs\n   ordering of notifications
            and replay protection by comparing their\n   Partial IVs and SHALL ignore
            the Outer Observe option value.\n   If the client receives a response
            to an Observe request without an\n   Inner Observe option, then it verifies
            the response as a non-Observe\n   response, as specified in Section 8.4.
            \ If the client receives a\n   response to a non-Observe request with
            an Inner Observe option, then\n   it stops processing the message, as
            specified in Section 8.4.\n   A client MUST consider the notification
            with the highest Partial IV\n   as the freshest, regardless of the order
            of arrival.  In order to\n   support existing Observe implementations,
            the OSCORE client\n   implementation MAY set the Observe option value
            to the three least\n   significant bytes of the Partial IV.  Implementations
            need to make\n   sure that the notification without Partial IV is considered
            the\n   oldest.\n"
          title: 4.1.3.5.2.  Notifications
        title: 4.1.3.5.  Observe
      - contents:
        - "4.1.3.6.  No-Response\n   No-Response [RFC7967] is an optional feature
          used by the client to\n   communicate its disinterest in certain classes
          of responses to a\n   particular request.  An implementation MAY support
          [RFC7252] and the\n   OSCORE option without supporting [RFC7967].\n   If
          used, No-Response MUST be Inner.  The Inner No-Response SHALL be\n   processed
          by OSCORE as specified in Section 4.1.1.  The Outer option\n   SHOULD NOT
          be present.  The server SHALL ignore the Outer No-Response\n   option.  The
          client MAY set the Outer No-Response value to 26\n   (suppress all known
          codes) if the Inner value is set to 26.  The\n   client MUST be prepared
          to receive and discard 5.04 (Gateway Timeout)\n   error messages from intermediaries
          potentially resulting from\n   destination time out due to no response.\n"
        title: 4.1.3.6.  No-Response
      - contents:
        - "4.1.3.7.  OSCORE\n   The OSCORE option is only defined to be present in
          OSCORE messages as\n   an indication that OSCORE processing has been performed.
          \ The content\n   in the OSCORE option is neither encrypted nor integrity
          protected as\n   a whole, but some part of the content of this option is
          protected\n   (see Section 5.4).  Nested use of OSCORE is not supported:
          If OSCORE\n   processing detects an OSCORE option in the original CoAP message,\n
          \  then processing SHALL be stopped.\n"
        title: 4.1.3.7.  OSCORE
      title: 4.1.3.  Special Options
    title: 4.1.  CoAP Options
  - contents:
    - "4.2.  CoAP Header Fields and Payload\n   A summary of how the CoAP header fields
      and payload are protected is\n   shown in Figure 6, including fields specific
      to CoAP over UDP and\n   CoAP over TCP (marked accordingly in the table).\n
      \                      +------------------+---+---+\n                       |
      Field            | E | U |\n                       +------------------+---+---+\n
      \                      | Version (UDP)    |   | x |\n                       |
      Type (UDP)       |   | x |\n                       | Length (TCP)     |   |
      x |\n                       | Token Length     |   | x |\n                       |
      Code             | x |   |\n                       | Message ID (UDP) |   |
      x |\n                       | Token            |   | x |\n                       |
      Payload          | x |   |\n                       +------------------+---+---+\n
      \                E = Encrypt and Integrity Protect (Inner)\n                 U
      = Unprotected (Outer)\n          Figure 6: Protection of CoAP Header Fields
      and Payload\n   Most CoAP header fields (i.e., the message fields in the fixed
      4-byte\n   header) are required to be read and/or changed by CoAP proxies; thus,\n
      \  they cannot, in general, be protected end-to-end from one endpoint to\n   the
      other.  As mentioned in Section 1, OSCORE protects the CoAP\n   request/response
      layer only and not the CoAP messaging layer\n   (Section 2 of [RFC7252]), so
      fields such as Type and Message ID are\n   not protected with OSCORE.\n   The
      CoAP header field Code is protected by OSCORE.  Code SHALL be\n   encrypted
      and integrity protected (Class E) to prevent an\n   intermediary from eavesdropping
      on or manipulating it (e.g., changing\n   from GET to DELETE).\n   The sending
      endpoint SHALL write the Code of the original CoAP\n   message into the plaintext
      of the COSE object (see Section 5.3).\n   After that, the sending endpoint writes
      an Outer Code to the OSCORE\n   message.  With one exception (see Section 4.1.3.5),
      the Outer Code\n   SHALL be set to 0.02 (POST) for requests and to 2.04 (Changed)
      for\n   responses.  The receiving endpoint SHALL discard the Outer Code in\n
      \  the OSCORE message and write the Code of the COSE object plaintext\n   (Section
      5.3) into the decrypted CoAP message.\n   The other currently defined CoAP header
      fields are Unprotected (Class\n   U).  The sending endpoint SHALL write all
      other header fields of the\n   original message into the header of the OSCORE
      message.  The\n   receiving endpoint SHALL write the header fields from the
      received\n   OSCORE message into the header of the decrypted CoAP message.\n
      \  The CoAP Payload, if present in the original CoAP message, SHALL be\n   encrypted
      and integrity protected; thus, it is an Inner message\n   field.  The sending
      endpoint writes the payload of the original CoAP\n   message into the plaintext
      (Section 5.3) input to the COSE object.\n   The receiving endpoint verifies
      and decrypts the COSE object, and it\n   recreates the payload of the original
      CoAP message.\n"
    title: 4.2.  CoAP Header Fields and Payload
  - contents:
    - "4.3.  Signaling Messages\n   Signaling messages (CoAP Code 7.00-7.31) were
      introduced to exchange\n   information related to an underlying transport connection
      in the\n   specific case of CoAP over reliable transports [RFC8323].\n   OSCORE
      MAY be used to protect signaling if the endpoints for OSCORE\n   coincide with
      the endpoints for the signaling message.  If OSCORE is\n   used to protect signaling
      then:\n   o  To comply with [RFC8323], an initial empty Capabilities and\n      Settings
      Message (CSM) SHALL be sent.  The subsequent signaling\n      message SHALL
      be protected.\n   o  Signaling messages SHALL be protected as CoAP request messages,\n
      \     except in the case in which the signaling message is a response to\n      a
      previous signaling message; then it SHALL be protected as a CoAP\n      response
      message.  For example, 7.02 (Ping) is protected as a CoAP\n      request and
      7.03 (Pong) as a CoAP response.\n   o  The Outer Code for signaling messages
      SHALL be set to 0.02 (POST),\n      unless it is a response to a previous signaling
      message, in which\n      case it SHALL be set to 2.04 (Changed).\n   o  All
      signaling options, except the OSCORE option, SHALL be Inner\n      (Class E).\n
      \  NOTE: Option numbers for signaling messages are specific to the CoAP\n   Code
      (see Section 5.2 of [RFC8323]).\n   If OSCORE is not used to protect signaling,
      Signaling messages SHALL\n   be unaltered by OSCORE.\n"
    title: 4.3.  Signaling Messages
  title: 4.  Protected Message Fields
- contents:
  - "5.  The COSE Object\n   This section defines how to use COSE [RFC8152] to wrap
    and protect\n   data in the original message.  OSCORE uses the untagged COSE_Encrypt0\n
    \  structure (see Section 5.2 of [RFC8152]) with an AEAD algorithm.  The\n   AEAD
    key lengths, AEAD nonce length, and maximum Sender Sequence\n   Number are algorithm
    dependent.\n   The AEAD algorithm AES-CCM-16-64-128 defined in Section 10.2 of\n
    \  [RFC8152] is mandatory to implement.  For AES-CCM-16-64-128, the\n   length
    of Sender Key and Recipient Key is 128 bits; the length of\n   AEAD nonce and
    Common IV is 13 bytes.  The maximum Sender Sequence\n   Number is specified in
    Section 12.\n   As specified in [RFC5116], plaintext denotes the data that is
    to be\n   encrypted and integrity protected, and Additional Authenticated Data\n
    \  (AAD) denotes the data that is to be integrity protected only.\n   The COSE
    object SHALL be a COSE_Encrypt0 object with fields defined\n   as follows:\n   o
    \ The 'protected' field is empty.\n   o  The 'unprotected' field includes:\n      *
    \ The 'Partial IV' parameter.  The value is set to the Sender\n         Sequence
    Number.  All leading bytes of value zero SHALL be\n         removed when encoding
    the Partial IV, except in the case of\n         Partial IV value 0, which is encoded
    to the byte string 0x00.\n         This parameter SHALL be present in requests
    and will not\n         typically be present in responses (for two exceptions,
    see\n         Observe notifications (Section 4.1.3.5.2) and Replay Window\n         synchronization
    (Appendix B.1.2)).\n      *  The 'kid' parameter.  The value is set to the Sender
    ID.  This\n         parameter SHALL be present in requests and will not typically\n
    \        be present in responses.  An example where the Sender ID is\n         included
    in a response is the extension of OSCORE to group\n         communication [Group-OSCORE].\n
    \     *  Optionally, a 'kid context' parameter (see Section 5.1).  This\n         parameter
    MAY be present in requests and, if so, MUST contain\n         an ID Context (see
    Section 3.1).  This parameter SHOULD NOT be\n         present in responses: an
    example of how 'kid context' can be\n         used in responses is given in Appendix
    B.2.  If 'kid context'\n         is present in the request, then the server SHALL
    use a security\n         context with that ID Context when verifying the request.\n
    \  o  The 'ciphertext' field is computed from the secret key (Sender Key\n      or
    Recipient Key), AEAD nonce (see Section 5.2), plaintext (see\n      Section 5.3),
    and the AAD (see Section 5.4) following Section 5.2\n      of [RFC8152].\n   The
    encryption process is described in Section 5.3 of [RFC8152].\n"
  - contents:
    - "5.1.  ID Context and 'kid context'\n   For certain use cases, e.g., deployments
      where the same Sender ID is\n   used with multiple contexts, it is possible
      (and sometimes necessary,\n   see Section 3.3) for the client to use an ID Context
      to distinguish\n   the security contexts (see Section 3.1).  For example:\n
      \  o  If the client has a unique identifier in some namespace, then that\n      identifier
      can be used as ID Context.\n   o  The ID Context may be used to add randomness
      into new Sender and\n      Recipient Contexts, see Appendix B.2.\n   o  In the
      case of group communication [Group-OSCORE], a group\n      identifier is used
      as ID Context to enable different security\n      contexts for a server belonging
      to multiple groups.\n   The Sender ID and ID Context are used to establish the
      necessary\n   input parameters and in the derivation of the security context
      (see\n   Section 3.2).\n   While the 'kid' parameter is used to transport the
      Sender ID, the new\n   COSE header parameter 'kid context' is used to transport
      the ID\n   Context in requests, see Figure 7.\n   +----------+--------+------------+----------------+-----------------+\n
      \  |   Name   |  Label | Value Type | Value Registry |   Description   |\n   +----------+--------+------------+----------------+-----------------+\n
      \  |   kid    |    10  | bstr       |                | Identifies the  |\n   |
      context  |        |            |                | context for the |\n   |          |
      \       |            |                | key identifier  |\n   +----------+--------+------------+----------------+-----------------+\n
      \   Figure 7: Common Header Parameter 'kid context' for the COSE Object\n   If
      ID Context is non-empty and the client sends a request without\n   'kid context'
      resulting in an error indicating that the server could\n   not find the security
      context, then the client could include the ID\n   Context in the 'kid context'
      when making another request.  Note that\n   since the error is unprotected,
      it may have been spoofed and the real\n   response blocked by an on-path attacker.\n"
    title: 5.1.  ID Context and 'kid context'
  - contents:
    - "5.2.  AEAD Nonce\n   The high-level design of the AEAD nonce follows Section
      4.4 of\n   [IV-GEN].  The detailed construction of the AEAD nonce is presented\n
      \  here (see Figure 8):\n   1.  left-pad the Partial IV (PIV) with zeroes to
      exactly 5 bytes,\n   2.  left-pad the Sender ID of the endpoint that generated
      the Partial\n       IV (ID_PIV) with zeroes to exactly nonce length minus 6
      bytes,\n   3.  concatenate the size of the ID_PIV (a single byte S) with the\n
      \      padded ID_PIV and the padded PIV,\n   4.  and then XOR with the Common
      IV.\n   Note that in this specification, only AEAD algorithms that use nonces\n
      \  equal or greater than 7 bytes are supported.  The nonce construction\n   with
      S, ID_PIV, and PIV together with endpoint-unique IDs and\n   encryption keys
      makes it easy to verify that the nonces used with a\n   specific key will be
      unique, see Appendix D.4.\n   If the Partial IV is not present in a response,
      the nonce from the\n   request is used.  For responses that are not notifications
      (i.e.,\n   when there is a single response to a request), the request and the\n
      \  response should typically use the same nonce to reduce message\n   overhead.
      \ Both alternatives provide all the required security\n   properties, see Section
      7.4 and Appendix D.4.  Another non-Observe\n   scenario where a Partial IV is
      included in a response is when the\n   server is unable to perform replay protection,
      see Appendix B.1.2.\n   For processing instructions see Section 8.\n              <-
      nonce length minus 6 B -> <-- 5 bytes -->\n         +---+-------------------+--------+---------+-----+\n
      \        | S |      padding      | ID_PIV | padding | PIV |----+\n         +---+-------------------+--------+---------+-----+
      \   |\n                                                               |\n          <----------------
      nonce length ---------------->     |\n         +------------------------------------------------+
      \   |\n         |                   Common IV                    |->(XOR)\n
      \        +------------------------------------------------+    |\n                                                               |\n
      \         <---------------- nonce length ---------------->     |\n         +------------------------------------------------+
      \   |\n         |                     Nonce                      |<---+\n         +------------------------------------------------+\n
      \                     Figure 8: AEAD Nonce Formation\n"
    title: 5.2.  AEAD Nonce
  - contents:
    - "5.3.  Plaintext\n   The plaintext is formatted as a CoAP message with a subset
      of the\n   header (see Figure 9) consisting of:\n   o  the Code of the original
      CoAP message as defined in Section 3 of\n      [RFC7252]; and\n   o  all Inner
      option message fields (see Section 4.1.1) present in the\n      original CoAP
      message (see Section 4.1).  The options are encoded\n      as described in Section
      3.1 of [RFC7252], where the delta is the\n      difference from the previously
      included instance of Class E\n      option; and\n   o  the Payload of original
      CoAP message, if present, and in that case\n      prefixed by the one-byte Payload
      Marker (0xff).\n   NOTE: The plaintext contains all CoAP data that needs to
      be encrypted\n   end-to-end between the endpoints.\n      0                   1
      \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |     Code      |    Class E options (if any) ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |1 1 1 1 1 1 1 1|    Payload (if any) ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     (only if there is payload)\n                            Figure 9: Plaintext\n"
    title: 5.3.  Plaintext
  - contents:
    - "5.4.  Additional Authenticated Data\n   The external_aad SHALL be a CBOR array
      wrapped in a bstr object as\n   defined below, following the notation of [RFC8610]
      as summarized in\n   Appendix E:\n   external_aad = bstr .cbor aad_array\n   aad_array
      = [\n     oscore_version : uint,\n     algorithms : [ alg_aead : int / tstr
      ],\n     request_kid : bstr,\n     request_piv : bstr,\n     options : bstr,\n
      \  ]\n   where:\n   o  oscore_version: contains the OSCORE version number.\n
      \     Implementations of this specification MUST set this field to 1.\n      Other
      values are reserved for future versions.\n   o  algorithms: contains (for extensibility)
      an array of algorithms,\n      according to this specification only containing
      alg_aead.\n   o  alg_aead: contains the AEAD Algorithm from the security context\n
      \     used for the exchange (see Section 3.1).\n   o  request_kid: contains
      the value of the 'kid' in the COSE object of\n      the request (see Section
      5).\n   o  request_piv: contains the value of the 'Partial IV' in the COSE\n
      \     object of the request (see Section 5).\n   o  options: contains the Class
      I options (see Section 4.1.2) present\n      in the original CoAP message encoded
      as described in Section 3.1\n      of [RFC7252], where the delta is the difference
      from the\n      previously included instance of class I option.\n   The oscore_version
      and algorithms parameters are established out-of-\n   band; thus, they are not
      transported in OSCORE, but the external_aad\n   allows to verify that they are
      the same in both endpoints.\n   NOTE: The format of the external_aad is, for
      simplicity, the same for\n   requests and responses, although some parameters,
      e.g., request_kid,\n   need not be integrity protected in all requests.\n   The
      AAD is composed from the external_aad as described in Section 5.3\n   of [RFC8152]
      (the notation follows [RFC8610] as summarized in\n   Appendix E):\n      AAD
      = Enc_structure = [ \"Encrypt0\", h'', external_aad ]\n   The following is an
      example of AAD constructed using AEAD Algorithm =\n   AES-CCM-16-64-128 (10),
      request_kid = 0x00, request_piv = 0x25 and no\n   Class I options:\n   o  oscore_version:
      0x01 (1 byte)\n   o  algorithms: 0x810a (2 bytes)\n   o  request_kid: 0x00 (1
      byte)\n   o  request_piv: 0x25 (1 byte)\n   o  options: 0x (0 bytes)\n   o  aad_array:
      0x8501810a4100412540 (9 bytes)\n   o  external_aad: 0x498501810a4100412540 (10
      bytes)\n   o  AAD: 0x8368456e63727970743040498501810a4100412540 (21 bytes)\n
      \  Note that the AAD consists of a fixed string of 11 bytes concatenated\n   with
      the external_aad.\n"
    title: 5.4.  Additional Authenticated Data
  title: 5.  The COSE Object
- contents:
  - "6.  OSCORE Header Compression\n   The Concise Binary Object Representation (CBOR)
    [RFC7049] combines\n   very small message sizes with extensibility.  The CBOR
    Object Signing\n   and Encryption (COSE) [RFC8152] uses CBOR to create compact
    encoding\n   of signed and encrypted data.  However, COSE is constructed to\n
    \  support a large number of different stateless use cases and is not\n   fully
    optimized for use as a stateful security protocol, leading to a\n   larger than
    necessary message expansion.  In this section, we define\n   a stateless header
    compression mechanism, simply removing redundant\n   information from the COSE
    objects, which significantly reduces the\n   per-packet overhead.  The result
    of applying this mechanism to a COSE\n   object is called the \"compressed COSE
    object\".\n   The COSE_Encrypt0 object used in OSCORE is transported in the OSCORE\n
    \  option and in the Payload.  The Payload contains the ciphertext of\n   the
    COSE object.  The headers of the COSE object are compactly\n   encoded as described
    in the next section.\n"
  - contents:
    - "6.1.  Encoding of the OSCORE Option Value\n   The value of the OSCORE option
      SHALL contain the OSCORE flag bits,\n   the 'Partial IV' parameter, the 'kid
      context' parameter (length and\n   value), and the 'kid' parameter as follows:\n
      \         0 1 2 3 4 5 6 7 <------------- n bytes -------------->\n         +-+-+-+-+-+-+-+-+--------------------------------------\n
      \        |0 0 0|h|k|  n  |       Partial IV (if any) ...\n         +-+-+-+-+-+-+-+-+--------------------------------------\n
      \         <- 1 byte -> <----- s bytes ------>\n         +------------+----------------------+------------------+\n
      \        | s (if any) | kid context (if any) | kid (if any) ... |\n         +------------+----------------------+------------------+\n
      \                   Figure 10: The OSCORE Option Value\n   o  The first byte,
      containing the OSCORE flag bits, encodes the\n      following set of bits and
      the length of the 'Partial IV'\n      parameter:\n      *  The three least significant
      bits encode the Partial IV length\n         n.  If n = 0, then the Partial IV
      is not present in the\n         compressed COSE object.  The values n = 6 and
      n = 7 are\n         reserved.\n      *  The fourth least significant bit is
      the 'kid' flag, k.  It is\n         set to 1 if 'kid' is present in the compressed
      COSE object.\n      *  The fifth least significant bit is the 'kid context'
      flag, h.\n         It is set to 1 if the compressed COSE object contains a 'kid\n
      \        context' (see Section 5.1).\n      *  The sixth-to-eighth least significant
      bits are reserved for\n         future use.  These bits SHALL be set to zero
      when not in use.\n         According to this specification, if any of these
      bits are set\n         to 1, the message is considered to be malformed and\n
      \        decompression fails as specified in item 2 of Section 8.2.\n   The
      flag bits are registered in the \"OSCORE Flag Bits\" registry\n   specified
      in Section 13.7.\n   o  The following n bytes encode the value of the Partial
      IV, if the\n      Partial IV is present (n > 0).\n   o  The following 1 byte
      encodes the length s of the 'kid context'\n      (Section 5.1), if the 'kid
      context' flag is set (h = 1).\n   o  The following s bytes encode the 'kid context',
      if the 'kid\n      context' flag is set (h = 1).\n   o  The remaining bytes
      encode the value of the 'kid', if the 'kid' is\n      present (k = 1).\n   Note
      that the 'kid' MUST be the last field of the OSCORE option\n   value, even in
      the case in which reserved bits are used and\n   additional fields are added
      to it.\n   The length of the OSCORE option thus depends on the presence and\n
      \  length of Partial IV, 'kid context', 'kid', as specified in this\n   section,
      and on the presence and length of additional parameters, as\n   defined in the
      future documents registering those parameters.\n"
    title: 6.1.  Encoding of the OSCORE Option Value
  - contents:
    - "6.2.  Encoding of the OSCORE Payload\n   The payload of the OSCORE message
      SHALL encode the ciphertext of the\n   COSE object.\n"
    title: 6.2.  Encoding of the OSCORE Payload
  - contents:
    - "6.3.  Examples of Compressed COSE Objects\n   This section covers a list of
      OSCORE Header Compression examples for\n   requests and responses.  The examples
      assume the COSE_Encrypt0 object\n   is set (which means the CoAP message and
      cryptographic material is\n   known).  Note that the full CoAP unprotected message,
      as well as the\n   full security context, is not reported in the examples, but
      only the\n   input necessary to the compression mechanism, i.e., the COSE_Encrypt0\n
      \  object.  The output is the compressed COSE object as defined in\n   Section
      6, divided into two parts, since the object is transported in\n   two CoAP fields:
      the OSCORE option and payload.\n   1.  Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9,
      kid =\n       0x25, and Partial IV = 0x05\n       Before compression (24 bytes):\n
      \        [\n           h'',\n           { 4:h'25', 6:h'05' },\n           h'aea0155667924dff8a24e4cb35b9',\n
      \        ]\n       After compression (17 bytes):\n         Flag byte: 0b00001001
      = 0x09 (1 byte)\n         Option Value: 0x090525 (3 bytes)\n         Payload:
      0xaea0155667924dff8a24e4cb35b9 (14 bytes)\n   2.  Request with ciphertext =
      0xaea0155667924dff8a24e4cb35b9, kid =\n       empty string, and Partial IV =
      0x00\n       Before compression (23 bytes):\n         [\n           h'',\n           {
      4:h'', 6:h'00' },\n           h'aea0155667924dff8a24e4cb35b9',\n         ]\n
      \      After compression (16 bytes):\n         Flag byte: 0b00001001 = 0x09
      (1 byte)\n         Option Value: 0x0900 (2 bytes)\n         Payload: 0xaea0155667924dff8a24e4cb35b9
      (14 bytes)\n   3.  Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9,
      kid =\n       empty string, Partial IV = 0x05, and kid context = 0x44616c656b\n
      \      Before compression (30 bytes):\n         [\n           h'',\n           {
      4:h'', 6:h'05', 10:h'44616c656b' },\n           h'aea0155667924dff8a24e4cb35b9',\n
      \        ]\n       After compression (22  bytes):\n         Flag byte: 0b00011001
      = 0x19 (1 byte)\n         Option Value: 0x19050544616c656b (8 bytes)\n         Payload:
      0xae a0155667924dff8a24e4cb35b9 (14 bytes)\n   4.  Response with ciphertext
      = 0xaea0155667924dff8a24e4cb35b9 and no\n       Partial IV\n       Before compression
      (18 bytes):\n         [\n           h'',\n           {},\n           h'aea0155667924dff8a24e4cb35b9',\n
      \        ]\n       After compression (14 bytes):\n         Flag byte: 0b00000000
      = 0x00 (1 byte)\n         Option Value: 0x (0 bytes)\n         Payload: 0xaea0155667924dff8a24e4cb35b9
      (14 bytes)\n   5.  Response with ciphertext = 0xaea0155667924dff8a24e4cb35b9
      and\n       Partial IV = 0x07\n       Before compression (21 bytes):\n         [\n
      \          h'',\n           { 6:h'07' },\n           h'aea0155667924dff8a24e4cb35b9',\n
      \        ]\n       After compression (16 bytes):\n         Flag byte: 0b00000001
      = 0x01 (1 byte)\n         Option Value: 0x0107 (2 bytes)\n         Payload:
      0xaea0155667924dff8a24e4cb35b9 (14 bytes)\n"
    title: 6.3.  Examples of Compressed COSE Objects
  title: 6.  OSCORE Header Compression
- contents:
  - '7.  Message Binding, Sequence Numbers, Freshness, and Replay Protection

    '
  - contents:
    - "7.1.  Message Binding\n   In order to prevent response delay and mismatch attacks\n
      \  [CoAP-Actuators] from on-path attackers and compromised\n   intermediaries,
      OSCORE binds responses to the requests by including\n   the 'kid' and Partial
      IV of the request in the AAD of the response.\n   Therefore, the server needs
      to store the 'kid' and Partial IV of the\n   request until all responses have
      been sent.\n"
    title: 7.1.  Message Binding
  - contents:
    - "7.2.  Sequence Numbers\n   An AEAD nonce MUST NOT be used more than once per
      AEAD key.  The\n   uniqueness of (key, nonce) pairs is shown in Appendix D.4,
      and in\n   particular depends on a correct usage of Partial IVs (which encode\n
      \  the Sender Sequence Numbers, see Section 5).  If messages are\n   processed
      concurrently, the operation of reading and increasing the\n   Sender Sequence
      Number MUST be atomic.\n"
    - contents:
      - "7.2.1.  Maximum Sequence Number\n   The maximum Sender Sequence Number is
        algorithm dependent (see\n   Section 12) and SHALL be less than 2^40.  If
        the Sender Sequence\n   Number exceeds the maximum, the endpoint MUST NOT
        process any more\n   messages with the given Sender Context.  If necessary,
        the endpoint\n   SHOULD acquire a new security context before this happens.
        \ The\n   latter is out of scope of this document.\n"
      title: 7.2.1.  Maximum Sequence Number
    title: 7.2.  Sequence Numbers
  - contents:
    - "7.3.  Freshness\n   For requests, OSCORE provides only the guarantee that the
      request is\n   not older than the security context.  For applications having\n
      \  stronger demands on request freshness (e.g., control of actuators),\n   OSCORE
      needs to be augmented with mechanisms providing freshness (for\n   example,
      as specified in [CoAP-ECHO-REQ-TAG]).\n   Assuming an honest server (see Appendix
      D), the message binding\n   guarantees that a response is not older than its
      request.  For\n   responses that are not notifications (i.e., when there is
      a single\n   response to a request), this gives absolute freshness.  For\n   notifications,
      the absolute freshness gets weaker with time, and it\n   is RECOMMENDED that
      the client regularly re-register the observation.\n   Note that the message
      binding does not guarantee that a misbehaving\n   server created the response
      before receiving the request, i.e., it\n   does not verify server aliveness.\n
      \  For requests and notifications, OSCORE also provides relative\n   freshness
      in the sense that the received Partial IV allows a\n   recipient to determine
      the relative order of requests or responses.\n"
    title: 7.3.  Freshness
  - contents:
    - "7.4.  Replay Protection\n   In order to protect from replay of requests, the
      server's Recipient\n   Context includes a Replay Window.  A server SHALL verify
      that the\n   Sender Sequence Number received in the 'Partial IV' parameter of
      the\n   COSE object (see Section 6.1) has not been received before.  If this\n
      \  verification fails, the server SHALL stop processing the message, and\n   it
      MAY optionally respond with a 4.01 (Unauthorized) error message.\n   Also, the
      server MAY set an Outer Max-Age option with value zero to\n   inform any intermediary
      that the response is not to be cached.  The\n   diagnostic payload MAY contain
      the string \"Replay detected\".  The\n   size and type of the Replay Window
      depends on the use case and the\n   protocol with which the OSCORE message is
      transported.  In case of\n   reliable and ordered transport from endpoint to
      endpoint, e.g., TCP,\n   the server MAY just store the last received Partial
      IV and require\n   that newly received Partial IVs equal the last received Partial
      IV +\n   1.  However, in the case of mixed reliable and unreliable transports\n
      \  and where messages may be lost, such a replay mechanism may be too\n   restrictive
      and the default replay window may be more suitable (see\n   Section 3.2.2).\n
      \  Responses (with or without Partial IV) are protected against replay\n   as
      they are bound to the request and the fact that only a single\n   response is
      accepted.  In this case the Partial IV is not used for\n   replay protection
      of responses.\n   The operation of validating the Partial IV and updating the
      replay\n   protection MUST be atomic.\n"
    - contents:
      - "7.4.1.  Replay Protection of Notifications\n   The following applies additionally
        when the Observe option is\n   supported.\n   The Notification Number (see
        Section 4.1.3.5.2) is initialized to the\n   Partial IV of the first successfully
        verified notification in\n   response to the registration request.  A client
        MUST only accept at\n   most one Observe notification without Partial IV,
        and treat it as the\n   oldest notification received.  A client receiving
        a notification\n   containing a Partial IV SHALL compare the Partial IV with
        the\n   Notification Number associated to that Observe registration.  The\n
        \  client MUST stop processing notifications with a Partial IV that has\n
        \  been previously received.  Applications MAY decide that a client only\n
        \  processes notifications that have a greater Partial IV than the\n   Notification
        Number.\n   If the verification of the response succeeds, and the received\n
        \  Partial IV was greater than the Notification Number, then the client\n
        \  SHALL overwrite the corresponding Notification Number with the\n   received
        Partial IV.\n"
      title: 7.4.1.  Replay Protection of Notifications
    title: 7.4.  Replay Protection
  - contents:
    - "7.5.  Losing Part of the Context State\n   To prevent reuse of an AEAD nonce
      with the same AEAD key or the\n   acceptance of replayed messages, an endpoint
      needs to handle the\n   situation of losing rapidly changing parts of the context,
      such as\n   the Sender Sequence Number and Replay Window.  These are typically\n
      \  stored in RAM and therefore lost in the case of, e.g., an unplanned\n   reboot.
      \ There are different alternatives to recover, for example:\n   1.  The endpoints
      can reuse an existing Security Context after\n       updating the mutable parts
      of the security context (Sender\n       Sequence Number and Replay Window).
      \ This requires that the\n       mutable parts of the security context are available
      throughout\n       the lifetime of the device or that the device can establish
      a\n       fresh security context after loss of mutable security context\n       data.
      \ Examples are given based on careful use of nonvolatile\n       memory, see
      Appendix B.1.1 and the use of the Echo option, see\n       Appendix B.1.2.  If
      an endpoint makes use of a partial security\n       context stored in nonvolatile
      memory, it MUST NOT reuse a\n       previous Sender Sequence Number and MUST
      NOT accept previously\n       received messages.\n   2.  The endpoints can reuse
      an existing shared Master Secret and\n       derive new Sender and Recipient
      Contexts, see Appendix B.2 for an\n       example.  This typically requires
      a good source of randomness.\n   3.  The endpoints can use a trusted third-party-assisted
      key\n       establishment protocol such as [OSCORE-PROFILE].  This requires\n
      \      the execution of a three-party protocol and may require a good\n       source
      of randomness.\n   4.  The endpoints can run a key exchange protocol providing
      forward\n       secrecy resulting in a fresh Master Secret, from which an\n
      \      entirely new Security Context is derived.  This requires a good\n       source
      of randomness, and additionally, the transmission and\n       processing of
      the protocol may have a non-negligible cost, e.g.,\n       in terms of power
      consumption.\n   The endpoints need to be configured with information about
      which\n   method is used.  The choice of method may depend on capabilities of\n
      \  the devices deployed and the solution architecture.  Using a key\n   exchange
      protocol is necessary for deployments that require forward\n   secrecy.\n"
    title: 7.5.  Losing Part of the Context State
  title: 7.  Message Binding, Sequence Numbers, Freshness, and Replay Protection
- contents:
  - "8.  Processing\n   This section describes the OSCORE message processing.  Additional\n
    \  processing for Observe or Block-wise are described in subsections.\n   Note
    that, analogously to [RFC7252] where the Token and source/\n   destination pair
    are used to match a response with a request, both\n   endpoints MUST keep the
    association (Token, {Security Context,\n   Partial IV of the request}), in order
    to be able to find the Security\n   Context and compute the AAD to protect or
    verify the response.  The\n   association MAY be forgotten after it has been used
    to successfully\n   protect or verify the response, with the exception of Observe\n
    \  processing, where the association MUST be kept as long as the\n   Observation
    is active.\n   The processing of the Sender Sequence Number follows the procedure\n
    \  described in Section 3 of [IV-GEN].\n"
  - contents:
    - "8.1.  Protecting the Request\n   Given a CoAP request, the client SHALL perform
      the following steps to\n   create an OSCORE request:\n   1.  Retrieve the Sender
      Context associated with the target resource.\n   2.  Compose the AAD and the
      plaintext, as described in Sections 5.3\n       and 5.4.\n   3.  Encode the
      Partial IV (Sender Sequence Number in network byte\n       order) and increment
      the Sender Sequence Number by one.  Compute\n       the AEAD nonce from the
      Sender ID, Common IV, and Partial IV as\n       described in Section 5.2.\n
      \  4.  Encrypt the COSE object using the Sender Key. Compress the COSE\n       object
      as specified in Section 6.\n   5.  Format the OSCORE message according to Section
      4.  The OSCORE\n       option is added (see Section 4.1.2).\n"
    title: 8.1.  Protecting the Request
  - contents:
    - "8.2.  Verifying the Request\n   A server receiving a request containing the
      OSCORE option SHALL\n   perform the following steps:\n   1.  Discard Code and
      all Class E options (marked in Figure 5 with 'x'\n       in column E) present
      in the received message.  For example, an\n       If-Match Outer option is discarded,
      but an Uri-Host Outer option\n       is not discarded.\n   2.  Decompress the
      COSE object (Section 6) and retrieve the Recipient\n       Context associated
      with the Recipient ID in the 'kid' parameter,\n       additionally using the
      'kid context', if present.  Note that the\n       Recipient Context MAY be retrieved
      by deriving a new security\n       context, e.g. as described in Appendix B.2.
      \ If either the\n       decompression or the COSE message fails to decode, or
      the server\n       fails to retrieve a Recipient Context with Recipient ID\n
      \      corresponding to the 'kid' parameter received, then the server\n       SHALL
      stop processing the request.\n       *  If either the decompression or the COSE
      message fails to\n          decode, the server MAY respond with a 4.02 (Bad
      Option) error\n          message.  The server MAY set an Outer Max-Age option
      with\n          value zero.  The diagnostic payload MAY contain the string\n
      \         \"Failed to decode COSE\".\n       *  If the server fails to retrieve
      a Recipient Context with\n          Recipient ID corresponding to the 'kid'
      parameter received,\n          the server MAY respond with a 4.01 (Unauthorized)
      error\n          message.  The server MAY set an Outer Max-Age option with\n
      \         value zero.  The diagnostic payload MAY contain the string\n          \"Security
      context not found\".\n   3.  Verify that the Partial IV has not been received
      before using the\n       Replay Window, as described in Section 7.4.\n   4.
      \ Compose the AAD, as described in Section 5.4.\n   5.  Compute the AEAD nonce
      from the Recipient ID, Common IV, and the\n       Partial IV, received in the
      COSE object.\n   6.  Decrypt the COSE object using the Recipient Key, as per\n
      \      Section 5.3 of [RFC8152].  (The decrypt operation includes the\n       verification
      of the integrity.)\n       *  If decryption fails, the server MUST stop processing
      the\n          request and MAY respond with a 4.00 (Bad Request) error\n          message.
      \ The server MAY set an Outer Max-Age option with\n          value zero.  The
      diagnostic payload MAY contain the string\n          \"Decryption failed\".\n
      \      *  If decryption succeeds, update the Replay Window, as described\n          in
      Section 7.\n   7.  Add decrypted Code, options, and payload to the decrypted\n
      \      request.  The OSCORE option is removed.\n   8.  The decrypted CoAP request
      is processed according to [RFC7252].\n"
    - contents:
      - "8.2.1.  Supporting Block-wise\n   If Block-wise is supported, insert the
        following step before any\n   other:\n   A.  If Block-wise is present in the
        request, then process the Outer\n   Block options according to [RFC7959],
        until all blocks of the request\n   have been received (see Section 4.1.3.4).\n"
      title: 8.2.1.  Supporting Block-wise
    title: 8.2.  Verifying the Request
  - contents:
    - "8.3.  Protecting the Response\n   If a CoAP response is generated in response
      to an OSCORE request, the\n   server SHALL perform the following steps to create
      an OSCORE\n   response.  Note that CoAP error responses derived from CoAP\n
      \  processing (step 8 in Section 8.2) are protected, as well as\n   successful
      CoAP responses, while the OSCORE errors (steps 2, 3, and 6\n   in Section 8.2)
      do not follow the processing below but are sent as\n   simple CoAP responses,
      without OSCORE processing.\n   1.  Retrieve the Sender Context in the Security
      Context associated\n       with the Token.\n   2.  Compose the AAD and the plaintext,
      as described in Sections 5.3\n       and 5.4.\n   3.  Compute the AEAD nonce
      as described in Section 5.2:\n       *  Either use the AEAD nonce from the request,
      or\n       *  Encode the Partial IV (Sender Sequence Number in network byte\n
      \         order) and increment the Sender Sequence Number by one.\n          Compute
      the AEAD nonce from the Sender ID, Common IV, and\n          Partial IV.\n   4.
      \ Encrypt the COSE object using the Sender Key. Compress the COSE\n       object
      as specified in Section 6.  If the AEAD nonce was\n       constructed from a
      new Partial IV, this Partial IV MUST be\n       included in the message.  If
      the AEAD nonce from the request was\n       used, the Partial IV MUST NOT be
      included in the message.\n   5.  Format the OSCORE message according to Section
      4.  The OSCORE\n       option is added (see Section 4.1.2).\n"
    - contents:
      - "8.3.1.  Supporting Observe\n   If Observe is supported, insert the following
        step between steps 2\n   and 3 of Section 8.3:\n   A.  If the response is
        an Observe notification:\n   o  If the response is the first notification:\n
        \     *  compute the AEAD nonce as described in Section 5.2:\n         +  Either
        use the AEAD nonce from the request, or\n         +  Encode the Partial IV
        (Sender Sequence Number in network\n            byte order) and increment
        the Sender Sequence Number by one.\n            Compute the AEAD nonce from
        the Sender ID, Common IV, and\n            Partial IV.\n         Then, go
        to 4.\n   o  If the response is not the first notification:\n      *  encode
        the Partial IV (Sender Sequence Number in network byte\n         order) and
        increment the Sender Sequence Number by one.\n         Compute the AEAD nonce
        from the Sender ID, Common IV, and\n         Partial IV, then go to 4.\n"
      title: 8.3.1.  Supporting Observe
    title: 8.3.  Protecting the Response
  - contents:
    - "8.4.  Verifying the Response\n   A client receiving a response containing the
      OSCORE option SHALL\n   perform the following steps:\n   1.  Discard Code and
      all Class E options (marked in Figure 5 with 'x'\n       in column E) present
      in the received message.  For example, ETag\n       Outer option is discarded,
      as well as Max-Age Outer option.\n   2.  Retrieve the Recipient Context in the
      Security Context associated\n       with the Token.  Decompress the COSE object
      (Section 6).  If\n       either the decompression or the COSE message fails
      to decode,\n       then go to 8.\n   3.  Compose the AAD, as described in Section
      5.4.\n   4.  Compute the AEAD nonce\n       *  If the Partial IV is not present
      in the response, the AEAD\n          nonce from the request is used.\n       *
      \ If the Partial IV is present in the response, compute the AEAD\n          nonce
      from the Recipient ID, Common IV, and the Partial IV,\n          received in
      the COSE object.\n   5.  Decrypt the COSE object using the Recipient Key, as
      per\n       Section 5.3 of [RFC8152].  (The decrypt operation includes the\n
      \      verification of the integrity.)  If decryption fails, then go to\n       8.\n
      \  6.  Add decrypted Code, options and payload to the decrypted request.\n       The
      OSCORE option is removed.\n   7.  The decrypted CoAP response is processed according
      to [RFC7252].\n   8.  In case any of the previous erroneous conditions apply:
      the\n       client SHALL stop processing the response.\n"
    - contents:
      - "8.4.1.  Supporting Block-wise\n   If Block-wise is supported, insert the
        following step before any\n   other:\n   A.  If Block-wise is present in the
        response, then process the Outer\n   Block options according to [RFC7959],
        until all blocks of the\n   response have been received (see Section 4.1.3.4).\n"
      title: 8.4.1.  Supporting Block-wise
    - contents:
      - "8.4.2.  Supporting Observe\n   If Observe is supported:\n   Insert the following
        step between step 5 and step 6:\n   A.  If the request was an Observe registration,
        then:\n   o  If the Partial IV is not present in the response, and the Inner\n
        \     Observe option is present, and the AEAD nonce from the request was\n
        \     already used once, then go to 8.\n   o  If the Partial IV is present
        in the response and the Inner Observe\n      option is present, then follow
        the processing described in\n      Section 4.1.3.5.2 and Section 7.4.1, then:\n
        \     *  initialize the Notification Number (if first successfully\n         verified
        notification), or\n      *  overwrite the Notification Number (if the received
        Partial IV\n         was greater than the Notification Number).\n   Replace
        step 8 of Section 8.4 with:\n   B.  In case any of the previous erroneous
        conditions apply: the\n   client SHALL stop processing the response.  An error
        condition\n   occurring while processing a response to an observation request
        does\n   not cancel the observation.  A client MUST NOT react to failure by\n
        \  re-registering the observation immediately.\n"
      title: 8.4.2.  Supporting Observe
    title: 8.4.  Verifying the Response
  title: 8.  Processing
- contents:
  - "9.  Web Linking\n   The use of OSCORE MAY be indicated by a target \"osc\" attribute
    in a\n   web link [RFC8288] to a resource, e.g., using a link-format document\n
    \  [RFC6690] if the resource is accessible over CoAP.\n   The \"osc\" attribute
    is a hint indicating that the destination of that\n   link is only accessible
    using OSCORE, and unprotected access to it is\n   not supported.  Note that this
    is simply a hint, it does not include\n   any security context material or any
    other information required to\n   run OSCORE.\n   A value MUST NOT be given for
    the \"osc\" attribute; any present value\n   MUST be ignored by parsers.  The
    \"osc\" attribute MUST NOT appear more\n   than once in a given link-value; occurrences
    after the first MUST be\n   ignored by parsers.\n   The example in Figure 11 shows
    a use of the \"osc\" attribute: the\n   client does resource discovery on a server
    and gets back a list of\n   resources, one of which includes the \"osc\" attribute
    indicating that\n   the resource is protected with OSCORE.  The link-format notation
    (see\n   Section 5 of [RFC6690]) is used.\n                      REQ: GET /.well-known/core\n
    \                     RES: 2.05 Content\n                         </sensors/temp>;osc,\n
    \                        </sensors/light>;if=\"sensor\"\n                          Figure
    11: The Web Link\n"
  title: 9.  Web Linking
- contents:
  - "10.  CoAP-to-CoAP Forwarding Proxy\n   CoAP is designed for proxy operations
    (see Section 5.7 of [RFC7252]).\n   OSCORE is designed to work with OSCORE-unaware
    CoAP proxies.\n   Security requirements for forwarding are listed in Section 2.2.1
    of\n   [CoAP-E2E-Sec].  Proxy processing of the (Outer) Proxy-Uri option\n   works
    as defined in [RFC7252].  Proxy processing of the (Outer) Block\n   options works
    as defined in [RFC7959].\n   However, not all CoAP proxy operations are useful:\n
    \  o  Since a CoAP response is only applicable to the original CoAP\n      request,
    caching is in general not useful.  In support of existing\n      proxies, OSCORE
    uses the Outer Max-Age option, see\n      Section 4.1.3.1.\n   o  Proxy processing
    of the (Outer) Observe option as defined in\n      [RFC7641] is specified in Section
    4.1.3.5.\n   Optionally, a CoAP proxy MAY detect OSCORE and act accordingly.  An\n
    \  OSCORE-aware CoAP proxy:\n   o  SHALL bypass caching for the request if the
    OSCORE option is\n      present.\n   o  SHOULD avoid caching responses to requests
    with an OSCORE option.\n   In the case of Observe (see Section 4.1.3.5), the OSCORE-aware
    CoAP\n   proxy:\n   o  SHALL NOT initiate an Observe registration.\n   o  MAY
    verify the order of notifications using Partial IV rather than\n      the Observe
    option.\n"
  title: 10.  CoAP-to-CoAP Forwarding Proxy
- contents:
  - "11.  HTTP Operations\n   The CoAP request/response model may be mapped to HTTP
    and vice versa\n   as described in Section 10 of [RFC7252].  The HTTP-CoAP mapping
    is\n   further detailed in [RFC8075].  This section defines the components\n   needed
    to map and transport OSCORE messages over HTTP hops.  By\n   mapping between HTTP
    and CoAP and by using cross-protocol proxies,\n   OSCORE may be used end-to-end
    between, e.g., an HTTP client and a\n   CoAP server.  Examples are provided in
    Sections 11.5 and 11.6.\n"
  - contents:
    - "11.1.  The HTTP OSCORE Header Field\n   The HTTP OSCORE header field (see Section
      13.4) is used for carrying\n   the content of the CoAP OSCORE option when transporting
      OSCORE\n   messages over HTTP hops.\n   The HTTP OSCORE header field is only
      used in POST requests and\n   responses with HTTP Status Code 200 (OK).  When
      used, the HTTP header\n   field Content-Type is set to 'application/oscore'
      (see Section 13.5)\n   indicating that the HTTP body of this message contains
      the OSCORE\n   payload (see Section 6.2).  No additional semantics are provided
      by\n   other message fields.\n   Using the Augmented Backus-Naur Form (ABNF)
      notation of [RFC5234],\n   including the following core ABNF syntax rules defined
      by that\n   specification: ALPHA (letters) and DIGIT (decimal digits), the HTTP\n
      \  OSCORE header field value is as follows.\n   base64url-char = ALPHA / DIGIT
      / \"-\" / \"_\"\n   OSCORE = 2*base64url-char\n   The HTTP OSCORE header field
      is not appropriate to list in the\n   Connection header field (see Section 6.1
      of [RFC7230]) since it is\n   not hop-by-hop.  OSCORE messages are generally
      not useful when served\n   from cache (i.e., they will generally be marked Cache-Control:
      no-\n   cache) and so interaction with Vary is not relevant (Section 7.1.4 of\n
      \  [RFC7231]).  Since the HTTP OSCORE header field is critical for\n   message
      processing, moving it from headers to trailers renders the\n   message unusable
      in case trailers are ignored (see Section 4.1 of\n   [RFC7230]).\n   In general,
      intermediaries are not allowed to insert, delete, or\n   modify the OSCORE header.
      \ In general, changes to the HTTP OSCORE\n   header field will violate the integrity
      of the OSCORE message\n   resulting in an error.  For the same reason the HTTP
      OSCORE header\n   field is generally not preserved across redirects.\n   Since
      redirects are not defined in the mappings between HTTP and CoAP\n   ([RFC8075]
      [RFC7252]), a number of conditions need to be fulfilled\n   for redirects to
      work.  For CoAP-client-to-HTTP-server redirects,\n   such conditions include:\n
      \  o  the CoAP-to-HTTP proxy follows the redirect, instead of the CoAP\n      client
      as in the HTTP case.\n   o  the CoAP-to-HTTP proxy copies the HTTP OSCORE header
      field and\n      body to the new request.\n   o  the target of the redirect
      has the necessary OSCORE security\n      context required to decrypt and verify
      the message.\n   Since OSCORE requires the HTTP body to be preserved across
      redirects,\n   the HTTP server is RECOMMENDED to reply with 307 (Temporary Redirect)\n
      \  or 308 (Permanent Redirect) instead of 301 (Moved Permanently) or 302\n   (Found).\n
      \  For the case of HTTP-client-to-CoAP-server redirects, although\n   redirect
      is not defined for CoAP servers [RFC7252], an HTTP client\n   receiving a redirect
      should generate a new OSCORE request for the\n   server it was redirected to.\n"
    title: 11.1.  The HTTP OSCORE Header Field
  - contents:
    - "11.2.  CoAP-to-HTTP Mapping\n   Section 10.1 of [RFC7252] describes the fundamentals
      of the CoAP-to-\n   HTTP cross-protocol mapping process.  The additional rules
      for OSCORE\n   messages are as follows:\n   o  The HTTP OSCORE header field
      value is set to:\n      *  AA if the CoAP OSCORE option is empty; otherwise,\n
      \     *  the value of the CoAP OSCORE option (Section 6.1) in base64url\n         (Section
      5 of [RFC4648]) encoding without padding.\n         Implementation notes for
      this encoding are given in Appendix C\n         of [RFC7515].\n   o  The HTTP
      Content-Type is set to 'application/oscore' (see\n      Section 13.5), independent
      of CoAP Content-Format.\n"
    title: 11.2.  CoAP-to-HTTP Mapping
  - contents:
    - "11.3.  HTTP-to-CoAP Mapping\n   Section 10.2 of [RFC7252] and [RFC8075] specify
      the behavior of an\n   HTTP-to-CoAP proxy.  The additional rules for HTTP messages
      with the\n   OSCORE header field are as follows.\n   o  The CoAP OSCORE option
      is set as follows:\n      *  empty if the value of the HTTP OSCORE header field
      is a single\n         zero byte (0x00) represented by AA; otherwise,\n      *
      \ the value of the HTTP OSCORE header field decoded from\n         base64url
      (Section 5 of [RFC4648]) without padding.\n         Implementation notes for
      this encoding are given in Appendix C\n         of [RFC7515].\n   o  The CoAP
      Content-Format option is omitted, the content format for\n      OSCORE (Section
      13.6) MUST NOT be used.\n"
    title: 11.3.  HTTP-to-CoAP Mapping
  - contents:
    - "11.4.  HTTP Endpoints\n   Restricted to subsets of HTTP and CoAP supporting
      a bijective\n   mapping, OSCORE can be originated or terminated in HTTP endpoints.\n
      \  The sending HTTP endpoint uses [RFC8075] to translate the HTTP\n   message
      into a CoAP message.  The CoAP message is then processed with\n   OSCORE as
      defined in this document.  The OSCORE message is then\n   mapped to HTTP as
      described in Section 11.2 and sent in compliance\n   with the rules in Section
      11.1.\n   The receiving HTTP endpoint maps the HTTP message to a CoAP message\n
      \  using [RFC8075] and Section 11.3.  The resulting OSCORE message is\n   processed
      as defined in this document.  If successful, the plaintext\n   CoAP message
      is translated to HTTP for normal processing in the\n   endpoint.\n"
    title: 11.4.  HTTP Endpoints
  - contents:
    - "11.5.  Example: HTTP Client and CoAP Server\n   This section gives an example
      of what a request and a response\n   between an HTTP client and a CoAP server
      could look like.  The\n   example is not a test vector but intended as an illustration
      of how\n   the message fields are translated in the different steps.\n   Mapping
      and notation here is based on \"Simple Form\" (Section 5.4.1 of\n   [RFC8075]).\n
      \  [HTTP request -- Before client object security processing]\n     GET http://proxy.url/hc/?target_uri=coap://server.url/orders\n
      \     HTTP/1.1\n   [HTTP request -- HTTP Client to Proxy]\n     POST http://proxy.url/hc/?target_uri=coap://server.url/
      HTTP/1.1\n     Content-Type: application/oscore\n     OSCORE: CSU\n     Body:
      09 07 01 13 61 f7 0f d2 97 b1 [binary]\n   [CoAP request -- Proxy to CoAP Server]\n
      \    POST coap://server.url/\n     OSCORE: 09 25\n     Payload: 09 07 01 13
      61 f7 0f d2 97 b1 [binary]\n   [CoAP request -- After server object security
      processing]\n     GET coap://server.url/orders\n   [CoAP response -- Before
      server object security processing]\n     2.05 Content\n     Content-Format:
      0\n     Payload: Exterminate! Exterminate!\n   [CoAP response -- CoAP Server
      to Proxy]\n     2.04 Changed\n     OSCORE: [empty]\n     Payload: 00 31 d1 fc
      f6 70 fb 0c 1d d5 ... [binary]\n   [HTTP response -- Proxy to HTTP Client]\n
      \    HTTP/1.1 200 OK\n     Content-Type: application/oscore\n     OSCORE: AA\n
      \    Body: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]\n   [HTTP response --
      After client object security processing]\n     HTTP/1.1 200 OK\n     Content-Type:
      text/plain\n     Body: Exterminate! Exterminate!\n   Note that the HTTP Status
      Code 200 (OK) in the next-to-last message\n   is the mapping of CoAP Code 2.04
      (Changed), whereas the HTTP Status\n   Code 200 (OK) in the last message is
      the mapping of the CoAP Code\n   2.05 (Content), which was encrypted within
      the compressed COSE object\n   carried in the Body of the HTTP response.\n"
    title: '11.5.  Example: HTTP Client and CoAP Server'
  - contents:
    - "11.6.  Example: CoAP Client and HTTP Server\n   This section gives an example
      of what a request and a response\n   between a CoAP client and an HTTP server
      could look like.  The\n   example is not a test vector but intended as an illustration
      of how\n   the message fields are translated in the different steps.\n   [CoAP
      request -- Before client object security processing]\n     GET coap://proxy.url/\n
      \    Proxy-Uri=http://server.url/orders\n   [CoAP request -- CoAP Client to
      Proxy]\n     POST coap://proxy.url/\n     Proxy-Uri=http://server.url/\n     OSCORE:
      09 25\n     Payload: 09 07 01 13 61 f7 0f d2 97 b1 [binary]\n   [HTTP request
      -- Proxy to HTTP Server]\n     POST http://server.url/ HTTP/1.1\n     Content-Type:
      application/oscore\n     OSCORE: CSU\n     Body: 09 07 01 13 61 f7 0f d2 97
      b1 [binary]\n   [HTTP request -- After server object security processing]\n
      \    GET http://server.url/orders HTTP/1.1\n   [HTTP response -- Before server
      object security processing]\n     HTTP/1.1 200 OK\n     Content-Type: text/plain\n
      \    Body: Exterminate! Exterminate!\n   [HTTP response -- HTTP Server to Proxy]\n
      \    HTTP/1.1 200 OK\n     Content-Type: application/oscore\n     OSCORE: AA\n
      \    Body: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]\n   [CoAP response --
      Proxy to CoAP Client]\n     2.04 Changed\n     OSCORE: [empty]\n     Payload:
      00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]\n   [CoAP response -- After client
      object security processing]\n     2.05 Content\n     Content-Format: 0\n     Payload:
      Exterminate! Exterminate!\n   Note that the HTTP Code 2.04 (Changed) in the
      next-to-last message is\n   the mapping of HTTP Status Code 200 (OK), whereas
      the CoAP Code 2.05\n   (Content) in the last message is the value that was encrypted
      within\n   the compressed COSE object carried in the Body of the HTTP response.\n"
    title: '11.6.  Example: CoAP Client and HTTP Server'
  title: 11.  HTTP Operations
- contents:
  - "12.  Security Considerations\n   An overview of the security properties is given
    in Appendix D.\n"
  - contents:
    - "12.1.  End-to-end Protection\n   In scenarios with intermediary nodes such
      as proxies or gateways,\n   transport layer security such as (D)TLS only protects
      data hop-by-\n   hop.  As a consequence, the intermediary nodes can read and
      modify\n   any information.  The trust model where all intermediary nodes are\n
      \  considered trustworthy is problematic, not only from a privacy\n   perspective,
      but also from a security perspective, as the\n   intermediaries are free to
      delete resources on sensors and falsify\n   commands to actuators (such as \"unlock
      door\", \"start fire alarm\",\n   \"raise bridge\").  Even in the rare cases
      where all the owners of the\n   intermediary nodes are fully trusted, attacks
      and data breaches make\n   such an architecture brittle.\n   (D)TLS protects
      hop-by-hop the entire message.  OSCORE protects end-\n   to-end all information
      that is not required for proxy operations (see\n   Section 4).  (D)TLS and OSCORE
      can be combined, thereby enabling end-\n   to-end security of the message payload,
      in combination with hop-by-\n   hop protection of the entire message, during
      transport between\n   endpoint and intermediary node.  In particular, when OSCORE
      is used\n   with HTTP, the additional TLS protection of HTTP hops is RECOMMENDED,\n
      \  e.g., between an HTTP endpoint and a proxy translating between HTTP\n   and
      CoAP.\n   Applications need to consider that certain message fields and\n   messages
      types are not protected end-to-end and may be spoofed or\n   manipulated.  The
      consequences of unprotected message fields are\n   analyzed in Appendix D.5.\n"
    title: 12.1.  End-to-end Protection
  - contents:
    - "12.2.  Security Context Establishment\n   The use of COSE_Encrypt0 and AEAD
      to protect messages as specified in\n   this document requires an established
      security context.  The method\n   to establish the security context described
      in Section 3.2 is based\n   on a common Master Secret and unique Sender IDs.
      \ The necessary input\n   parameters may be preestablished or obtained using
      a key\n   establishment protocol augmented with establishment of Sender/\n   Recipient
      ID, such as a key exchange protocol or the OSCORE profile\n   of the Authentication
      and Authorization for Constrained Environments\n   (ACE) framework [OSCORE-PROFILE].
      \ Such a procedure must ensure that\n   the requirements of the security context
      parameters for the intended\n   use are complied with (see Section 3.3) even
      in error situations.\n   While recipient IDs are allowed to coincide between
      different\n   security contexts (see Section 3.3), this may cause a server to\n
      \  process multiple verifications before finding the right security\n   context
      or rejecting a message.  Considerations for deploying OSCORE\n   with a fixed
      Master Secret are given in Appendix B.\n"
    title: 12.2.  Security Context Establishment
  - contents:
    - "12.3.  Master Secret\n   OSCORE uses HKDF [RFC5869] and the established input
      parameters to\n   derive the security context.  The required properties of the
      security\n   context parameters are discussed in Section 3.3; in this section,
      we\n   focus on the Master Secret.  In this specification, HKDF denotes the\n
      \  composition of the expand and extract functions as defined in\n   [RFC5869]
      and the Master Secret is used as Input Keying Material\n   (IKM).\n   Informally,
      HKDF takes as source an IKM containing some good amount\n   of randomness but
      not necessarily distributed uniformly (or for which\n   an attacker has some
      partial knowledge) and derive from it one or\n   more cryptographically strong
      secret keys [RFC5869].\n   Therefore, the main requirement for the OSCORE Master
      Secret, in\n   addition to being secret, is that it have a good amount of\n
      \  randomness.  The selected key establishment schemes must ensure that\n   the
      necessary properties for the Master Secret are fulfilled.  For\n   pre-shared
      key deployments and key transport solutions such as\n   [OSCORE-PROFILE], the
      Master Secret can be generated offline using a\n   good random number generator.
      \ Randomness requirements for security\n   are described in [RFC4086].\n"
    title: 12.3.  Master Secret
  - contents:
    - "12.4.  Replay Protection\n   Replay attacks need to be considered in different
      parts of the\n   implementation.  Most AEAD algorithms require a unique nonce
      for each\n   message, for which the Sender Sequence Numbers in the COSE message\n
      \  field 'Partial IV' is used.  If the recipient accepts any sequence\n   number
      larger than the one previously received, then the problem of\n   sequence number
      synchronization is avoided.  With reliable transport,\n   it may be defined
      that only messages with sequence numbers that are\n   equal to the previous
      sequence number + 1 are accepted.  An adversary\n   may try to induce a device
      reboot for the purpose of replaying a\n   message (see Section 7.5).\n   Note
      that sharing a security context between servers may open up for\n   replay attacks,
      for example, if the Replay Windows are not\n   synchronized.\n"
    title: 12.4.  Replay Protection
  - contents:
    - "12.5.  Client Aliveness\n   A verified OSCORE request enables the server to
      verify the identity\n   of the entity who generated the message.  However, it
      does not verify\n   that the client is currently involved in the communication,
      since the\n   message may be a delayed delivery of a previously generated request,\n
      \  which now reaches the server.  To verify the aliveness of the client\n   the
      server may use the Echo option in the response to a request from\n   the client
      (see [CoAP-ECHO-REQ-TAG]).\n"
    title: 12.5.  Client Aliveness
  - contents:
    - "12.6.  Cryptographic Considerations\n   The maximum Sender Sequence Number
      is dependent on the AEAD\n   algorithm.  The maximum Sender Sequence Number
      is 2^40 - 1, or any\n   algorithm-specific lower limit, after which a new security
      context\n   must be generated.  The mechanism to build the AEAD nonce\n   (Section
      5.2) assumes that the nonce is at least 56 bits, and the\n   Partial IV is at
      most 40 bits.  The mandatory-to-implement AEAD\n   algorithm AES-CCM-16-64-128
      is selected for compatibility with CCM*.\n   AEAD algorithms that require unpredictable
      nonces are not supported.\n   In order to prevent cryptanalysis when the same
      plaintext is\n   repeatedly encrypted by many different users with distinct
      AEAD keys,\n   the AEAD nonce is formed by mixing the sequence number with a
      secret\n   per-context initialization vector (Common IV) derived along with
      the\n   keys (see Section 3.1 of [RFC8152]), and by using a Master Salt in\n
      \  the key derivation (see [MF00] for an overview).  The Master Secret,\n   Sender
      Key, Recipient Key, and Common IV must be secret, the rest of\n   the parameters
      may be public.  The Master Secret must have a good\n   amount of randomness
      (see Section 12.3).\n   The ID Context, Sender ID, and Partial IV are always
      at least\n   implicitly integrity protected, as manipulation leads to the wrong\n
      \  nonce or key being used and therefore results in decryption failure.\n"
    title: 12.6.  Cryptographic Considerations
  - contents:
    - "12.7.  Message Segmentation\n   The Inner Block options enable the sender to
      split large messages\n   into OSCORE-protected blocks such that the receiving
      endpoint can\n   verify blocks before having received the complete message.
      \ The Outer\n   Block options allow for arbitrary proxy fragmentation operations
      that\n   cannot be verified by the endpoints but that can, by policy, be\n   restricted
      in size since the Inner Block options allow for secure\n   fragmentation of
      very large messages.  A maximum message size (above\n   which the sending endpoint
      fragments the message and the receiving\n   endpoint discards the message, if
      complying to the policy) may be\n   obtained as part of normal resource discovery.\n"
    title: 12.7.  Message Segmentation
  - contents:
    - "12.8.  Privacy Considerations\n   Privacy threats executed through intermediary
      nodes are considerably\n   reduced by means of OSCORE.  End-to-end integrity
      protection and\n   encryption of the message payload and all options that are
      not used\n   for proxy operations provide mitigation against attacks on sensor
      and\n   actuator communication, which may have a direct impact on the\n   personal
      sphere.\n   The unprotected options (Figure 5) may reveal privacy-sensitive\n
      \  information, see Appendix D.5.  CoAP headers sent in plaintext allow,\n   for
      example, matching of CON and ACK (CoAP Message Identifier),\n   matching of
      request and responses (Token) and traffic analysis.\n   OSCORE does not provide
      protection for HTTP header fields that are\n   not both CoAP-mappable and Class
      E.  The HTTP message fields that are\n   visible to on-path entities are only
      used for the purpose of\n   transporting the OSCORE message, whereas the application-layer\n
      \  message is encoded in CoAP and encrypted.\n   COSE message fields, i.e.,
      the OSCORE option, may reveal information\n   about the communicating endpoints.
      \ For example, 'kid' and 'kid\n   context', which are intended to help the server
      find the right\n   context, may reveal information about the client.  Tracking
      'kid' and\n   'kid context' to one server may be used for correlating requests
      from\n   one client.\n   Unprotected error messages reveal information about
      the security\n   state in the communication between the endpoints.  Unprotected\n
      \  signaling messages reveal information about the reliable transport\n   used
      on a leg of the path.  Using the mechanisms described in\n   Section 7.5 may
      reveal when a device goes through a reboot.  This can\n   be mitigated by the
      device storing the precise state of Sender\n   Sequence Number and Replay Window
      on a clean shutdown.\n   The length of message fields can reveal information
      about the\n   message.  Applications may use a padding scheme to protect against\n
      \  traffic analysis.\n"
    title: 12.8.  Privacy Considerations
  title: 12.  Security Considerations
- contents:
  - '13.  IANA Considerations

    '
  - contents:
    - "13.1.  COSE Header Parameters Registry\n   The 'kid context' parameter has
      been added to the \"COSE Header\n   Parameters\" registry:\n   o  Name: kid
      context\n   o  Label: 10\n   o  Value Type: bstr\n   o  Value Registry:\n   o
      \ Description: Identifies the context for the key identifier\n   o  Reference:
      Section 5.1 of this document\n"
    title: 13.1.  COSE Header Parameters Registry
  - contents:
    - "13.2.  CoAP Option Numbers Registry\n   The OSCORE option has been added to
      the \"CoAP Option Numbers\"\n   registry:\n             +--------+-----------------+-------------------+\n
      \            | Number | Name            | Reference         |\n             +--------+-----------------+-------------------+\n
      \            |     9  | OSCORE          | [RFC8613]         |\n             +--------+-----------------+-------------------+\n
      \  Furthermore, the following existing entries in the \"CoAP Option\n   Numbers\"
      registry have been updated with a reference to the document\n   specifying OSCORE
      processing of that option:\n       +--------+-----------------+-------------------------------+\n
      \      | Number | Name            |          Reference            |\n       +--------+-----------------+-------------------------------+\n
      \      |   1    | If-Match        | [RFC7252] [RFC8613]           |\n       |
      \  3    | Uri-Host        | [RFC7252] [RFC8613]           |\n       |   4    |
      ETag            | [RFC7252] [RFC8613]           |\n       |   5    | If-None-Match
      \  | [RFC7252] [RFC8613]           |\n       |   6    | Observe         | [RFC7641]
      [RFC8613]           |\n       |   7    | Uri-Port        | [RFC7252] [RFC8613]
      \          |\n       |   8    | Location-Path   | [RFC7252] [RFC8613]           |\n
      \      |  11    | Uri-Path        | [RFC7252] [RFC8613]           |\n       |
      \ 12    | Content-Format  | [RFC7252] [RFC8613]           |\n       |  14    |
      Max-Age         | [RFC7252] [RFC8613]           |\n       |  15    | Uri-Query
      \      | [RFC7252] [RFC8613]           |\n       |  17    | Accept          |
      [RFC7252] [RFC8613]           |\n       |  20    | Location-Query  | [RFC7252]
      [RFC8613]           |\n       |  23    | Block2          | [RFC7959] [RFC8323]
      [RFC8613] |\n       |  27    | Block1          | [RFC7959] [RFC8323] [RFC8613]
      |\n       |  28    | Size2           | [RFC7959] [RFC8613]           |\n       |
      \ 35    | Proxy-Uri       | [RFC7252] [RFC8613]           |\n       |  39    |
      Proxy-Scheme    | [RFC7252] [RFC8613]           |\n       |  60    | Size1           |
      [RFC7252] [RFC8613]           |\n       | 258    | No-Response     | [RFC7967]
      [RFC8613]           |\n       +--------+-----------------+-------------------------------+\n
      \  Future additions to the \"CoAP Option Numbers\" registry need to\n   provide
      a reference to the document where the OSCORE processing of\n   that CoAP Option
      is defined.\n"
    title: 13.2.  CoAP Option Numbers Registry
  - contents:
    - "13.3.  CoAP Signaling Option Numbers Registry\n   The OSCORE option has been
      added to the \"CoAP Signaling Option\n   Numbers\" registry:\n     +------------+--------+---------------------+-------------------+\n
      \    | Applies to | Number | Name                | Reference         |\n     +------------+--------+---------------------+-------------------+\n
      \    | 7.xx (all) |     9  | OSCORE              | [RFC8613]         |\n     +------------+--------+---------------------+-------------------+\n"
    title: 13.3.  CoAP Signaling Option Numbers Registry
  - contents:
    - "13.4.  Header Field Registrations\n   The HTTP OSCORE header field has been
      added to the \"Message Headers\"\n   registry:\n     +-------------------+----------+----------+---------------------+\n
      \    | Header Field Name | Protocol | Status   | Reference           |\n     +-------------------+----------+----------+---------------------+\n
      \    | OSCORE            | http     | standard | [RFC8613],          |\n     |
      \                  |          |          | Section 11.1        |\n     +-------------------+----------+----------+---------------------+\n"
    title: 13.4.  Header Field Registrations
  - contents:
    - "13.5.  Media Type Registration\n   This section registers the 'application/oscore'
      media type in the\n   \"Media Types\" registry.  This media type is used to
      indicate that the\n   content is an OSCORE message.  The OSCORE body cannot
      be understood\n   without the OSCORE header field value and the security context.\n
      \    Type name: application\n     Subtype name: oscore\n     Required parameters:
      N/A\n     Optional parameters: N/A\n     Encoding considerations: binary\n     Security
      considerations: See the Security Considerations section\n        of [RFC8613].\n
      \    Interoperability considerations: N/A\n     Published specification: [RFC8613]\n
      \    Applications that use this media type: IoT applications sending\n        security
      content over HTTP(S) transports.\n     Fragment identifier considerations: N/A\n
      \    Additional information:\n     *  Deprecated alias names for this type:
      N/A\n     *  Magic number(s): N/A\n     *  File extension(s): N/A\n     *  Macintosh
      file type code(s): N/A\n     Person & email address to contact for further information:\n
      \       IESG <iesg@ietf.org>\n     Intended usage: COMMON\n     Restrictions
      on usage: N/A\n     Author: Goeran Selander <goran.selander@ericsson.com>\n
      \    Change Controller: IESG\n     Provisional registration?  No\n"
    title: 13.5.  Media Type Registration
  - contents:
    - "13.6.  CoAP Content-Formats Registry\n   This section registers the media type
      'application/oscore' media type\n   in the \"CoAP Content-Formats\" registry.
      \ This Content-Format for the\n   OSCORE payload is defined for potential future
      use cases and SHALL\n   NOT be used in the OSCORE message.  The OSCORE payload
      cannot be\n   understood without the OSCORE option value and the security context.\n
      \   +----------------------+----------+----------+-------------------+\n    |
      Media Type           | Encoding |   ID     |     Reference     |\n    +----------------------+----------+----------+-------------------+\n
      \   | application/oscore   |          |  10001   | [RFC8613]         |\n    +----------------------+----------+----------+-------------------+\n"
    title: 13.6.  CoAP Content-Formats Registry
  - contents:
    - "13.7.  OSCORE Flag Bits Registry\n   This document defines a subregistry for
      the OSCORE flag bits within\n   the \"CoRE Parameters\" registry.  The name
      of the subregistry is\n   \"OSCORE Flag Bits\".  The registry has been created
      with the Expert\n   Review policy [RFC8126].  Guidelines for the experts are
      provided in\n   Section 13.8.\n   The columns of the registry are as follows:\n
      \  o  Bit Position: This indicates the position of the bit in the set of\n      OSCORE
      flag bits, starting at 0 for the most significant bit.  The\n      bit position
      must be an integer or a range of integers, in the\n      range 0 to 63.\n   o
      \ Name: The name is present to make it easier to refer to and\n      discuss
      the registration entry.  The value is not used in the\n      protocol.  Names
      are to be unique in the table.\n   o  Description: This contains a brief description
      of the use of the\n      bit.\n   o  Reference: This contains a pointer to the
      specification defining\n      the entry.\n   The initial contents of the registry
      are in the table below.  The\n   reference column for all rows is this document.
      \ The entries with Bit\n   Position of 0 and 1 are marked as 'Reserved'.  The
      entry with Bit\n   Position of 1 will be specified in a future document and
      will be used\n   to expand the space for the OSCORE flag bits in Section 6.1,
      so that\n   entries 8-63 of the registry are defined.\n"
    - '+--------------+-------------+-----------------------------+-----------+

      '
    - '| Bit Position | Name        | Description                 | Reference |

      '
    - '+--------------+-------------+-----------------------------+-----------+

      '
    - '|       0      | Reserved    |                             |           |

      '
    - '+--------------+-------------+-----------------------------+-----------+

      '
    - '|       1      | Reserved    |                             |           |

      '
    - '+--------------+-------------+-----------------------------+-----------+

      '
    - '|       2      | Unassigned  |                             |           |

      '
    - '+--------------+-------------+-----------------------------+-----------+

      '
    - '|       3      | Kid Context | Set to 1 if kid context     | [RFC8613] |

      '
    - '|              | Flag        | is present in the           |           |

      '
    - '|              |             | compressed COSE object      |           |

      '
    - '+--------------+-------------+-----------------------------+-----------+

      '
    - '|       4      | Kid Flag    | Set to 1 if kid is present  | [RFC8613] |

      '
    - '|              |             | in the compressed COSE      |           |

      '
    - '|              |             | object                      |           |

      '
    - '+--------------+-------------+-----------------------------+-----------+

      '
    - '|     5-7      | Partial IV  | Encodes the Partial IV      | [RFC8613] |

      '
    - '|              | Length      | length; can have value      |           |

      '
    - '|              |             | 0 to 5                      |           |

      '
    - '+--------------+-------------+-----------------------------+-----------+

      '
    - '|    8-63      | Unassigned  |                             |           |

      '
    - '+--------------+-------------+-----------------------------+-----------+

      '
    title: 13.7.  OSCORE Flag Bits Registry
  - contents:
    - "13.8.  Expert Review Instructions\n   The expert reviewers for the registry
      defined in this document are\n   expected to ensure that the usage solves a
      valid use case that could\n   not be solved better in a different way, that
      it is not going to\n   duplicate one that is already registered, and that the
      registered\n   point is likely to be used in deployments.  They are furthermore\n
      \  expected to check the clarity of purpose and use of the requested\n   code
      points.  Experts should take into account the expected usage of\n   entries
      when approving point assignment, and the length of the\n   encoded value should
      be weighed against the number of code points\n   left that encode to that size
      and the size of device it will be used\n   on.  Experts should block registration
      for entries 8-63 until these\n   points are defined (i.e., until the mechanism
      for the OSCORE flag\n   bits expansion via bit 1 is specified).\n"
    title: 13.8.  Expert Review Instructions
  title: 13.  IANA Considerations
- contents:
  - '14.  References

    '
  - contents:
    - "14.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,\n              \"Randomness
      Requirements for Security\", BCP 106, RFC 4086,\n              DOI 10.17487/RFC4086,
      June 2005,\n              <https://www.rfc-editor.org/info/rfc4086>.\n   [RFC4648]
      \ Josefsson, S., \"The Base16, Base32, and Base64 Data\n              Encodings\",
      RFC 4648, DOI 10.17487/RFC4648, October 2006,\n              <https://www.rfc-editor.org/info/rfc4648>.\n
      \  [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n
      \             Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234,
      January 2008,\n              <https://www.rfc-editor.org/info/rfc5234>.\n   [RFC6347]
      \ Rescorla, E. and N. Modadugu, \"Datagram Transport Layer\n              Security
      Version 1.2\", RFC 6347, DOI 10.17487/RFC6347,\n              January 2012,
      <https://www.rfc-editor.org/info/rfc6347>.\n   [RFC7049]  Bormann, C. and P.
      Hoffman, \"Concise Binary Object\n              Representation (CBOR)\", RFC
      7049, DOI 10.17487/RFC7049,\n              October 2013, <https://www.rfc-editor.org/info/rfc7049>.\n
      \  [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n
      \             Protocol (HTTP/1.1): Message Syntax and Routing\",\n              RFC
      7230, DOI 10.17487/RFC7230, June 2014,\n              <https://www.rfc-editor.org/info/rfc7230>.\n
      \  [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n
      \             Protocol (HTTP/1.1): Semantics and Content\", RFC 7231,\n              DOI
      10.17487/RFC7231, June 2014,\n              <https://www.rfc-editor.org/info/rfc7231>.\n
      \  [RFC7252]  Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained\n              Application
      Protocol (CoAP)\", RFC 7252,\n              DOI 10.17487/RFC7252, June 2014,\n
      \             <https://www.rfc-editor.org/info/rfc7252>.\n   [RFC7641]  Hartke,
      K., \"Observing Resources in the Constrained\n              Application Protocol
      (CoAP)\", RFC 7641,\n              DOI 10.17487/RFC7641, September 2015,\n              <https://www.rfc-editor.org/info/rfc7641>.\n
      \  [RFC7959]  Bormann, C. and Z. Shelby, Ed., \"Block-Wise Transfers in\n              the
      Constrained Application Protocol (CoAP)\", RFC 7959,\n              DOI 10.17487/RFC7959,
      August 2016,\n              <https://www.rfc-editor.org/info/rfc7959>.\n   [RFC8075]
      \ Castellani, A., Loreto, S., Rahman, A., Fossati, T., and\n              E.
      Dijk, \"Guidelines for Mapping Implementations: HTTP to\n              the Constrained
      Application Protocol (CoAP)\", RFC 8075,\n              DOI 10.17487/RFC8075,
      February 2017,\n              <https://www.rfc-editor.org/info/rfc8075>.\n   [RFC8132]
      \ van der Stok, P., Bormann, C., and A. Sehgal, \"PATCH and\n              FETCH
      Methods for the Constrained Application Protocol\n              (CoAP)\", RFC
      8132, DOI 10.17487/RFC8132, April 2017,\n              <https://www.rfc-editor.org/info/rfc8132>.\n
      \  [RFC8152]  Schaad, J., \"CBOR Object Signing and Encryption (COSE)\",\n              RFC
      8152, DOI 10.17487/RFC8152, July 2017,\n              <https://www.rfc-editor.org/info/rfc8152>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8288]  Nottingham, M., \"Web
      Linking\", RFC 8288,\n              DOI 10.17487/RFC8288, October 2017,\n              <https://www.rfc-editor.org/info/rfc8288>.\n
      \  [RFC8323]  Bormann, C., Lemay, S., Tschofenig, H., Hartke, K.,\n              Silverajan,
      B., and B. Raymor, Ed., \"CoAP (Constrained\n              Application Protocol)
      over TCP, TLS, and WebSockets\",\n              RFC 8323, DOI 10.17487/RFC8323,
      February 2018,\n              <https://www.rfc-editor.org/info/rfc8323>.\n   [RFC8446]
      \ Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n              Version
      1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n              <https://www.rfc-editor.org/info/rfc8446>.\n
      \  [RFC8610]  Birkholz, H., Vigano, C., and C. Bormann, \"Concise Data\n              Definition
      Language (CDDL): A Notational Convention to\n              Express Concise Binary
      Object Representation (CBOR) and\n              JSON Data Structures\", RFC
      8610, DOI 10.17487/RFC8610,\n              June 2019, <https://www.rfc-editor.org/info/rfc8610>.\n"
    title: 14.1.  Normative References
  - contents:
    - "14.2.  Informative References\n   [ACE-OAuth]\n              Seitz, L., Selander,
      G., Wahlstroem, E., Erdtman, S., and\n              H. Tschofenig, \"Authentication
      and Authorization for\n              Constrained Environments (ACE) using the
      OAuth 2.0\n              Framework (ACE-OAuth)\", Work in Progress, draft-ietf-ace-\n
      \             oauth-authz-24, March 2019.\n   [CoAP-802.15.4]\n              Bormann,
      C., \"Constrained Application Protocol (CoAP) over\n              IEEE 802.15.4
      Information Element for IETF\", Work in\n              Progress, draft-bormann-6lo-coap-802-15-ie-00,
      April 2016.\n   [CoAP-Actuators]\n              Mattsson, J., Fornehed, J.,
      Selander, G., Palombini, F.,\n              and C. Amsuess, \"Controlling Actuators
      with CoAP\", Work in\n              Progress, draft-mattsson-core-coap-actuators-06,
      September\n              2018.\n   [CoAP-E2E-Sec]\n              Selander, G.,
      Palombini, F., and K. Hartke, \"Requirements\n              for CoAP End-To-End
      Security\", Work in Progress, draft-\n              hartke-core-e2e-security-reqs-03,
      July 2017.\n   [CoAP-ECHO-REQ-TAG]\n              Amsuess, C., Mattsson, J.,
      and G. Selander, \"CoAP: Echo,\n              Request-Tag, and Token Processing\",
      Work in Progress,\n              draft-ietf-core-echo-request-tag-04, March
      2019.\n   [Group-OSCORE]\n              Tiloca, M., Selander, G., Palombini,
      F., and J. Park,\n              \"Group OSCORE - Secure Group Communication
      for CoAP\", Work\n              in Progress, draft-ietf-core-oscore-groupcomm-04,
      March\n              2019.\n   [IV-GEN]   McGrew, D., \"Generation of Deterministic
      Initialization\n              Vectors (IVs) and Nonces\", Work in Progress,
      draft-mcgrew-\n              iv-gen-03, October 2013.\n   [MF00]     McGrew,
      D. and S. Fluhrer, \"Attacks on Additive Encryption\n              of Redundant
      Plaintext and Implications on Internet\n              Security\", Proceedings
      of the Seventh Annual Workshop on\n              Selected Areas in Cryptography
      (SAC 2000) Springer-\n              Verlag., pp. 14-28, 2000.\n   [OSCORE-PROFILE]\n
      \             Palombini, F., Seitz, L., Selander, G., and M. Gunnarsson,\n              \"OSCORE
      profile of the Authentication and Authorization\n              for Constrained
      Environments Framework\", Work in\n              Progress, draft-ietf-ace-oscore-profile-07,
      February 2019.\n   [REST]     Fielding, R., \"Architectural Styles and the Design
      of\n              Network-based Software Architectures\", Ph.D.\n              Dissertation,
      University of California, Irvine, 2010.\n   [RFC3552]  Rescorla, E. and B. Korver,
      \"Guidelines for Writing RFC\n              Text on Security Considerations\",
      BCP 72, RFC 3552,\n              DOI 10.17487/RFC3552, July 2003,\n              <https://www.rfc-editor.org/info/rfc3552>.\n
      \  [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource
      Identifier (URI): Generic Syntax\", STD 66,\n              RFC 3986, DOI 10.17487/RFC3986,
      January 2005,\n              <https://www.rfc-editor.org/info/rfc3986>.\n   [RFC5116]
      \ McGrew, D., \"An Interface and Algorithms for Authenticated\n              Encryption\",
      RFC 5116, DOI 10.17487/RFC5116, January 2008,\n              <https://www.rfc-editor.org/info/rfc5116>.\n
      \  [RFC5869]  Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand\n
      \             Key Derivation Function (HKDF)\", RFC 5869,\n              DOI
      10.17487/RFC5869, May 2010,\n              <https://www.rfc-editor.org/info/rfc5869>.\n
      \  [RFC6690]  Shelby, Z., \"Constrained RESTful Environments (CoRE) Link\n              Format\",
      RFC 6690, DOI 10.17487/RFC6690, August 2012,\n              <https://www.rfc-editor.org/info/rfc6690>.\n
      \  [RFC7228]  Bormann, C., Ersue, M., and A. Keranen, \"Terminology for\n              Constrained-Node
      Networks\", RFC 7228,\n              DOI 10.17487/RFC7228, May 2014,\n              <https://www.rfc-editor.org/info/rfc7228>.\n
      \  [RFC7515]  Jones, M., Bradley, J., and N. Sakimura, \"JSON Web\n              Signature
      (JWS)\", RFC 7515, DOI 10.17487/RFC7515, May\n              2015, <https://www.rfc-editor.org/info/rfc7515>.\n
      \  [RFC7967]  Bhattacharyya, A., Bandyopadhyay, S., Pal, A., and T.\n              Bose,
      \"Constrained Application Protocol (CoAP) Option for\n              No Server
      Response\", RFC 7967, DOI 10.17487/RFC7967,\n              August 2016, <https://www.rfc-editor.org/info/rfc7967>.\n
      \  [RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n              Writing
      an IANA Considerations Section in RFCs\", BCP 26,\n              RFC 8126, DOI
      10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n"
    title: 14.2.  Informative References
  title: 14.  References
- contents:
  - "Appendix A.  Scenario Examples\n   This section gives examples of OSCORE, targeting
    scenarios in\n   Section 2.2.1.1 of [CoAP-E2E-Sec].  The message exchanges are
    made,\n   based on the assumption that there is a security context established\n
    \  between client and server.  For simplicity, these examples only\n   indicate
    the content of the messages without going into detail of the\n   (compressed)
    COSE message format.\n"
  - contents:
    - "A.1.  Secure Access to Sensor\n   This example illustrates a client requesting
      the alarm status from a\n   server.\n      Client  Proxy  Server\n        |
      \      |       |\n        +------>|       |            Code: 0.02 (POST)\n        |
      POST  |       |           Token: 0x8c\n        |       |       |          OSCORE:
      [kid:5f, Partial IV:42]\n        |       |       |         Payload: {Code:0.01,\n
      \       |       |       |                   Uri-Path:\"alarm_status\"}\n        |
      \      |       |\n        |       +------>|            Code: 0.02 (POST)\n        |
      \      | POST  |           Token: 0x7b\n        |       |       |          OSCORE:
      [kid:5f, Partial IV:42]\n        |       |       |         Payload: {Code:0.01,\n
      \       |       |       |                   Uri-Path:\"alarm_status\"}\n        |
      \      |       |\n        |       |<------+            Code: 2.04 (Changed)\n
      \       |       |  2.04 |           Token: 0x7b\n        |       |       |          OSCORE:
      -\n        |       |       |         Payload: {Code:2.05, \"0\"}\n        |
      \      |       |\n        |<------+       |            Code: 2.04 (Changed)\n
      \       |  2.04 |       |           Token: 0x8c\n        |       |       |          OSCORE:
      -\n        |       |       |         Payload: {Code:2.05, \"0\"}\n        |
      \      |       |\n   Square brackets [ ... ] indicate content of compressed
      COSE object.\n   Curly brackets { ... } indicate encrypted data.\n                    Figure
      12: Secure Access to Sensor\n   The CoAP request/response Codes are encrypted
      by OSCORE and only\n   dummy Codes (POST/Changed) are visible in the header
      of the OSCORE\n   message.  The option Uri-Path (\"alarm_status\") and payload
      (\"0\") are\n   encrypted.\n   The COSE header of the request contains an identifier
      (5f),\n   indicating which security context was used to protect the message
      and\n   a Partial IV (42).\n   The server verifies the request as specified
      in Section 8.2.  The\n   client verifies the response as specified in Section
      8.4.\n"
    title: A.1.  Secure Access to Sensor
  - contents:
    - "A.2.  Secure Subscribe to Sensor\n   This example illustrates a client requesting
      subscription to a blood\n   sugar measurement resource (GET /glucose), first
      receiving the value\n   220 mg/dl and then a second value 180 mg/dl.\n      Client
      \ Proxy  Server\n        |       |       |\n        +------>|       |            Code:
      0.05 (FETCH)\n        | FETCH |       |           Token: 0x83\n        |       |
      \      |         Observe: 0\n        |       |       |          OSCORE: [kid:ca,
      Partial IV:15]\n        |       |       |         Payload: {Code:0.01,\n        |
      \      |       |                   Observe:0,\n        |       |       |                   Uri-Path:\"glucose\"}\n
      \       |       |       |\n        |       +------>|            Code: 0.05 (FETCH)\n
      \       |       | FETCH |           Token: 0xbe\n        |       |       |         Observe:
      0\n        |       |       |          OSCORE: [kid:ca, Partial IV:15]\n        |
      \      |       |         Payload: {Code:0.01,\n        |       |       |                   Observe:0,\n
      \       |       |       |                   Uri-Path:\"glucose\"}\n        |
      \      |       |\n        |       |<------+            Code: 2.05 (Content)\n
      \       |       |  2.05 |           Token: 0xbe\n        |       |       |         Observe:
      7\n        |       |       |          OSCORE: -\n        |       |       |         Payload:
      {Code:2.05,\n        |       |       |                   Observe:-,\n        |
      \      |       |                   Content-Format:0, \"220\"}\n        |       |
      \      |\n        |<------+       |            Code: 2.05 (Content)\n        |
      \ 2.05 |       |           Token: 0x83\n        |       |       |         Observe:
      7\n        |       |       |          OSCORE: -\n        |       |       |         Payload:
      {Code:2.05,\n        |       |       |                   Observe:-,\n        |
      \      |       |                   Content-Format:0, \"220\"}\n       ...     ...
      \    ...\n        |       |       |\n        |       |<------+            Code:
      2.05 (Content)\n        |       |  2.05 |           Token: 0xbe\n        |       |
      \      |         Observe: 8\n        |       |       |          OSCORE: [Partial
      IV:36]\n        |       |       |         Payload: {Code:2.05,\n        |       |
      \      |                   Observe:-,\n        |       |       |                   Content-Format:0,
      \"180\"}\n        |       |       |\n        |<------+       |            Code:
      2.05 (Content)\n        |  2.05 |       |           Token: 0x83\n        |       |
      \      |         Observe: 8\n        |       |       |          OSCORE: [Partial
      IV:36]\n        |       |       |         Payload: {Code:2.05,\n        |       |
      \      |                   Observe:-,\n        |       |       |                   Content-Format:0,
      \"180\"}\n        |       |       |\n   Square brackets [ ... ] indicate content
      of compressed COSE object\n   header.  Curly brackets { ... } indicate encrypted
      data.\n                   Figure 13: Secure Subscribe to Sensor\n   The dummy
      Codes (FETCH/Content) are used to allow forwarding of\n   Observe messages.
      \ The options Content-Format (0) and the payload\n   (\"220\" and \"180\") are
      encrypted.\n   The COSE header of the request contains an identifier (ca),\n
      \  indicating the security context used to protect the message and a\n   Partial
      IV (15).  The COSE header of the second response contains the\n   Partial IV
      (36).  The first response uses the Partial IV of the\n   request.\n   The server
      verifies that the Partial IV has not been received before.\n   The client verifies
      that the responses are bound to the request and\n   that the Partial IVs are
      greater than any Partial IV previously\n   received in a response bound to the
      request, except for the\n   notification without Partial IV, which is considered
      the oldest.\n"
    title: A.2.  Secure Subscribe to Sensor
  title: Appendix A.  Scenario Examples
- contents:
  - "Appendix B.  Deployment Examples\n   For many Internet of Things (IoT) deployments,
    a 128-bit uniformly\n   random Master Key is sufficient for encrypting all data
    exchanged\n   with the IoT device throughout its lifetime.  Two examples are given\n
    \  in this section.  In the first example, the security context is only\n   derived
    once from the Master Secret.  In the second example, security\n   contexts are
    derived multiple times using random inputs.\n"
  - contents:
    - "B.1.  Security Context Derived Once\n   An application that only derives the
      security context once needs to\n   handle the loss of mutable security context
      parameters, e.g., due to\n   reboot.\n"
    - contents:
      - "B.1.1.  Sender Sequence Number\n   In order to handle loss of Sender Sequence
        Numbers, the device may\n   implement procedures for writing to nonvolatile
        memory during normal\n   operations and updating the security context after
        reboot, provided\n   that the procedures comply with the requirements on the
        security\n   context parameters (Section 3.3).  This section gives an example
        of\n   such a procedure.\n   There are known issues related to writing to
        nonvolatile memory.  For\n   example, flash drives may have a limited number
        of erase operations\n   during its lifetime.  Also, the time for a write operation
        to\n   nonvolatile memory to be completed may be unpredictable, e.g., due
        to\n   caching, which could result in important security context data not\n
        \  being stored at the time when the device reboots.\n   However, many devices
        have predictable limits for writing to\n   nonvolatile memory, are physically
        limited to only send a small\n   amount of messages per minute, and may have
        no good source of\n   randomness.\n   To prevent reuse of Sender Sequence
        Number, an endpoint may perform\n   the following procedure during normal
        operations:\n   o  Before using a Sender Sequence Number that is evenly divisible
        by\n      K, where K is a positive integer, store the Sender Sequence Number\n
        \     (SSN1) in nonvolatile memory.  After booting, the endpoint\n      initiates
        the new Sender Sequence Number (SSN2) to the value\n      stored in persistent
        memory plus K plus F: SSN2 = SSN1 + K + F,\n      where F is a positive integer.\n
        \     *  Writing to nonvolatile memory can be costly; the value K gives\n
        \        a trade-off between frequency of storage operations and\n         efficient
        use of Sender Sequence Numbers.\n      *  Writing to nonvolatile memory may
        be subject to delays, or\n         failure; F MUST be set so that the last
        Sender Sequence Number\n         used before reboot is never larger than SSN2.\n
        \  If F cannot be set so SSN2 is always larger than the last Sender\n   Sequence
        Number used before reboot, the method described in this\n   section MUST NOT
        be used.\n"
      title: B.1.1.  Sender Sequence Number
    - contents:
      - "B.1.2.  Replay Window\n   In case of loss of security context on the server,
        to prevent\n   accepting replay of previously received requests, the server
        may\n   perform the following procedure after booting:\n   o  The server updates
        its Sender Sequence Number as specified in\n      Appendix B.1.1 to be used
        as Partial IV in the response containing\n      the Echo option (next bullet).\n
        \  o  For each stored security context, the first time after booting,\n      the
        server receives an OSCORE request, the server responds with an\n      OSCORE
        protected 4.01 (Unauthorized), containing only the Echo\n      option [CoAP-ECHO-REQ-TAG]
        and no diagnostic payload.  The server\n      MUST use its Partial IV when
        generating the AEAD nonce and MUST\n      include the Partial IV in the response
        (see Section 5).  If the\n      server with use of the Echo option can verify
        a second OSCORE\n      request as fresh, then the Partial IV of the second
        request is set\n      as the lower limit of the Replay Window of that security
        context.\n"
      title: B.1.2.  Replay Window
    - contents:
      - "B.1.3.  Notifications\n   To prevent the acceptance of replay of previously
        received\n   notifications, the client may perform the following procedure
        after\n   booting:\n   o  The client forgets about earlier registrations and
        removes all\n      Notification Numbers.  The client then registers again
        using the\n      Observe option.\n"
      title: B.1.3.  Notifications
    title: B.1.  Security Context Derived Once
  - contents:
    - "B.2.  Security Context Derived Multiple Times\n   An application that does
      not require forward secrecy may allow\n   multiple security contexts to be derived
      from one Master Secret.  The\n   requirements on the security context parameters
      MUST be fulfilled\n   (Section 3.3) even if the client or server is rebooted,\n
      \  recommissioned, or in error cases.\n   This section gives an example of a
      protocol that adds randomness to\n   the ID Context parameter and uses that
      together with input parameters\n   preestablished between client and server,
      in particular Master\n   Secret, Master Salt, and Sender/Recipient ID (see Section
      3.2), to\n   derive new security contexts.  The random input is transported\n
      \  between client and server in the 'kid context' parameter.  This\n   protocol
      MUST NOT be used unless both endpoints have good sources of\n   randomness.\n
      \  During normal requests, the ID Context of an established security\n   context
      may be sent in the 'kid context', which, together with 'kid',\n   facilitates
      for the server to locate a security context.\n   Alternatively, the 'kid context'
      may be omitted since the ID Context\n   is expected to be known to both client
      and server; see Section 5.1.\n   The protocol described in this section may
      only be needed when the\n   mutable part of security context is lost in the
      client or server,\n   e.g., when the endpoint has rebooted.  The protocol may
      additionally\n   be used whenever the client and server need to derive a new
      security\n   context.  For example, if a device is provisioned with one fixed
      set\n   of input parameters (including Master Secret, Sender and Recipient\n
      \  Identifiers), then a randomized ID Context ensures that the security\n   context
      is different for each deployment.\n   Note that the server needs to be configured
      to run this protocol when\n   it is not able to retrieve an existing security
      context, instead of\n   stopping processing the message as described in step
      2 of\n   Section 8.2.\n   The protocol is described below with reference to
      Figure 14.  The\n   client or the server may initiate the protocol, in the latter
      case\n   step 1 is omitted.\n                      Client                Server\n
      \                       |                      |\n"
    - "1. Protect with         |      request #1      |\n   ID Context = ID1     |--------------------->|
      2. Verify with\n                        |  kid_context = ID1   |    ID Context
      = ID1\n                        |                      |\n                        |
      \     response #1     |    Protect with\n"
    - "3. Verify with          |<---------------------|    ID Context = R2||ID1\n
      \  ID Context = R2||ID1 |   kid_context = R2   |\n                        |
      \                     |\n   Protect with         |      request #2      |\n
      \  ID Context = R2||R3  |--------------------->| 4. Verify with\n                        |
      kid_context = R2||R3 |    ID Context = R2||R3\n                        |                      |\n
      \                       |      response #2     |    Protect with\n"
    - "5. Verify with          |<---------------------|    ID Context = R2||R3\n   ID
      Context = R2||R3  |                      |\n        Figure 14: Protocol for
      Establishing a New Security Context\n   1.  (Optional) If the client does not
      have a valid security context\n       with the server, e.g., because of reboot
      or because this is the\n       first time it contacts the server, then it generates
      a random\n       string R1 and uses this as ID Context together with the input\n
      \      parameters shared with the server to derive a first security\n       context.
      \ The client sends an OSCORE request to the server\n       protected with the
      first security context, containing R1 wrapped\n       in a CBOR bstr as 'kid
      context'.  The request may target a\n       special resource used for updating
      security contexts.\n   2.  The server receives an OSCORE request for which it
      does not have\n       a valid security context, either because the client has
      generated\n       a new security context ID1 = R1 or because the server has
      lost\n       part of its security context, e.g., ID Context, Sender Sequence\n
      \      Number or Replay Window.  If the server is able to verify the\n       request
      (see Section 8.2) with the new derived first security\n       context using
      the received ID1 (transported in 'kid context') as\n       ID Context and the
      input parameters associated to the received\n       'kid', then the server generates
      a random string R2 and derives a\n       second security context with ID Context
      = ID2 = R2 || ID1.  The\n       server sends a 4.01 (Unauthorized) response
      protected with the\n       second security context, containing R2 wrapped in
      a CBOR bstr as\n       'kid context', and caches R2.  R2 MUST NOT be reused
      as that may\n       lead to reuse of key and nonce in response #1.  Note that
      the\n       server may receive several requests #1 associated with one\n       security
      context, leading to multiple parallel protocol runs.\n       Multiple instances
      of R2 may need to be cached until one of the\n       protocol runs is completed,
      see Appendix B.2.1.\n   3.  The client receives a response with 'kid context'
      containing a\n       CBOR bstr wrapping R2 to an OSCORE request it made with
      ID\n       Context = ID1.  The client derives a second security context\n       using
      ID Context = ID2 = R2 || ID1.  If the client can verify the\n       response
      (see Section 8.4) using the second security context,\n       then the client
      makes a request protected with a third security\n       context derived from
      ID Context = ID3 = R2 || R3, where R3 is a\n       random byte string generated
      by the client.  The request includes\n       R2 || R3 wrapped in a CBOR bstr
      as 'kid context'.\n   4.  If the server receives a request with 'kid context'
      containing a\n       CBOR bstr wrapping ID3, where the first part of ID3 is
      identical\n       to an R2 sent in a previous response #1, which it has not\n
      \      received before, then the server derives a third security context\n       with
      ID Context = ID3.  The server MUST NOT accept replayed\n       request #2 messages.
      \ If the server can verify the request (see\n       Section 8.2) with the third
      security context, then the server\n       marks the third security context to
      be used with this client and\n       removes all instances of R2 associated
      to this security context\n       from the cache.  This security context replaces
      the previous\n       security context with the client, and the first and the
      second\n       security contexts are deleted.  The server responds using the\n
      \      same security context as in the request.\n   5.  If the client receives
      a response to the request with the third\n       security context and the response
      verifies (see Section 8.4),\n       then the client marks the third security
      context to be used with\n       this server.  This security context replaces
      the previous\n       security context with the server, and the first and second\n
      \      security contexts are deleted.\n   If verification fails in any step,
      the endpoint stops processing that\n   message.\n   The length of the nonces
      R1, R2, and R3 is application specific.  The\n   application needs to set the
      length of each nonce such that the\n   probability of its value being repeated
      is negligible; typically, at\n   least 8 bytes long.  Since R2 may be generated
      as the result of a\n   replayed request #1, the probability for collision of
      R2s is impacted\n   by the birthday paradox.  For example, setting the length
      of R2 to 8\n   bytes results in an average collision after 2^32 response #1\n
      \  messages, which should not be an issue for a constrained server\n   handling
      on the order of one request per second.\n   Request #2 can be an ordinary request.
      \ The server performs the\n   action of the request and sends response #2 after
      having successfully\n   completed the operations related to the security context
      in step 4.\n   The client acts on response #2 after having successfully completed\n
      \  step 5.\n   When sending request #2, the client is assured that the Sender
      Key\n   (derived with the random value R3) has never been used before.  When\n
      \  receiving response #2, the client is assured that the response\n   (protected
      with a key derived from the random value R3 and the Master\n   Secret) was created
      by the server in response to request #2.\n   Similarly, when receiving request
      #2, the server is assured that the\n   request (protected with a key derived
      from the random value R2 and\n   the Master Secret) was created by the client
      in response to response\n   #1.  When sending response #2, the server is assured
      that the Sender\n   Key (derived with the random value R2) has never been used
      before.\n   Implementation and denial-of-service considerations are made in\n
      \  Appendix B.2.1 and Appendix B.2.2.\n"
    - contents:
      - "B.2.1.  Implementation Considerations\n   This section add some implementation
        considerations to the protocol\n   described in the previous section.\n   The
        server may only have space for a few security contexts or only be\n   able
        to handle a few protocol runs in parallel.  The server may\n   legitimately
        receive multiple request #1 messages using the same\n   immutable security
        context, e.g., because of packet loss.  Replays of\n   old request #1 messages
        could be difficult for the server to\n   distinguish from legitimate.  The
        server needs to handle the case\n   when the maximum number of cached R2s
        is reached.  If the server\n   receives a request #1 and is not capable of
        executing it then it may\n   respond with an unprotected 5.03 (Service Unavailable)
        error message.\n   The server may clear up state from protocol runs that never
        complete,\n   e.g., set a timer when caching R2, and remove R2 and the associated\n
        \  security contexts from the cache at timeout.  Additionally, state\n   information
        can be flushed at reboot.\n   As an alternative to caching R2, the server
        could generate R2 in such\n   a way that it can be sent (in response #1) and
        verified (at reception\n   of request #2) as the value of R2 it had generated.
        \ Such a procedure\n   MUST NOT lead to the server accepting replayed request
        #2 messages.\n   One construction described in the following is based on using
        a\n   secret random HMAC key K_HMAC per set of immutable security context\n
        \  parameters associated with a client.  This construction allows the\n   server
        to handle verification of R2 in response #2 at the cost of\n   storing the
        K_HMAC keys and a slightly larger message overhead in\n   response #1.  Steps
        below refer to modifications to Appendix B.2:\n   o  In step 2, R2 is generated
        in the following way.  First, the\n      server generates a random K_HMAC
        (unless it already has one\n      associated with the security context), then
        it sets R2 = S2 ||\n      HMAC(K_HMAC, S2) where S2 is a random byte string,
        and the HMAC is\n      truncated to 8 bytes.  K_HMAC may have an expiration
        time, after\n      which it is erased.  Note that neither R2, S2, nor the
        derived\n      first and second security contexts need to be cached.\n   o
        \ In step 4, instead of verifying that R2 coincides with a cached\n      value,
        the server looks up the associated K_HMAC and verifies the\n      truncated
        HMAC, and the processing continues accordingly depending\n      on verification
        success or failure.  K_HMAC is used until a run of\n      the protocol is
        completed (after verification of request #2), or\n      until it expires (whatever
        comes first), after which K_HMAC is\n      erased.  (The latter corresponds
        to removing the cached values of\n      R2 in step 4 of Appendix B.2 and makes
        the server reject replays\n      of request #2.)\n   The length of S2 is application
        specific and the probability for\n   collision of S2s is impacted by the birthday
        paradox.  For example,\n   setting the length of S2 to 8 bytes results in
        an average collision\n   after 2^32 response #1 messages, which should not
        be an issue for a\n   constrained server handling on the order of one request
        per second.\n   Two endpoints sharing a security context may accidentally
        initiate\n   two instances of the protocol at the same time, each in the role
        of\n   client, e.g., after a power outage affecting both endpoints.  Such
        a\n   race condition could potentially lead to both protocols failing, and\n
        \  both endpoints repeatedly reinitiating the protocol without\n   converging.
        \ Both endpoints can detect this situation, and it can be\n   handled in different
        ways.  The requests could potentially be more\n   spread out in time, for
        example, by only initiating this protocol\n   when the endpoint actually needs
        to make a request, potentially\n   adding a random delay before requests immediately
        after reboot or if\n   such parallel protocol runs are detected.\n"
      title: B.2.1.  Implementation Considerations
    - contents:
      - "B.2.2.  Attack Considerations\n   An on-path attacker may inject a message
        causing the endpoint to\n   process verification of the message.  A message
        crafted without\n   access to the Master Secret will fail to verify.\n   Replaying
        an old request with a value of 'kid_context' that the\n   server does not
        recognize could trigger the protocol.  This causes\n   the server to generate
        the first and second security context and send\n   a response.  But if the
        client did not expect a response, it will be\n   discarded.  This may still
        result in a denial-of-service attack\n   against the server, e.g., because
        of not being able to manage the\n   state associated with many parallel protocol
        runs, and it may prevent\n   legitimate client requests.  Implementation alternatives
        with less\n   data caching per request #1 message are favorable in this respect;\n
        \  see Appendix B.2.1.\n   Replaying response #1 in response to some request
        other than request\n   #1 will fail to verify, since response #1 is associated
        to request\n   #1, through the dependencies of ID Contexts and the Partial
        IV of\n   request #1 included in the external_aad of response #1.\n   If request
        #2 has already been well received, then the server has a\n   valid security
        context, so a replay of request #2 is handled by the\n   normal replay protection
        mechanism.  Similarly, if response #2 has\n   already been received, a replay
        of response #2 to some other request\n   from the client will fail by the
        normal verification of binding of\n   response to request.\n"
      title: B.2.2.  Attack Considerations
    title: B.2.  Security Context Derived Multiple Times
  title: Appendix B.  Deployment Examples
- contents:
  - "Appendix C.  Test Vectors\n   This appendix includes the test vectors for different
    examples of\n   CoAP messages using OSCORE.  Given a set of inputs, OSCORE defines\n
    \  how to set up the Security Context in both the client and the server.\n   Note
    that in Appendix C.4 and all following test vectors the Token\n   and the Message
    ID of the OSCORE-protected CoAP messages are set to\n   the same value of the
    unprotected CoAP message to help the reader\n   with comparisons.\n"
  - contents:
    - "C.1.  Test Vector 1: Key Derivation with Master Salt\n   In this test vector,
      a Master Salt of 8 bytes is used.  The default\n   values are used for AEAD
      Algorithm and HKDF.\n"
    - contents:
      - "C.1.1.  Client\n   Inputs:\n   o  Master Secret: 0x0102030405060708090a0b0c0d0e0f10
        (16 bytes)\n   o  Master Salt: 0x9e7ca92223786340 (8 bytes)\n   o  Sender
        ID: 0x (0 byte)\n   o  Recipient ID: 0x01 (1 byte)\n   From the previous parameters,\n
        \  o  info (for Sender Key): 0x8540f60a634b657910 (9 bytes)\n   o  info (for
        Recipient Key): 0x854101f60a634b657910 (10 bytes)\n   o  info (for Common
        IV): 0x8540f60a6249560d (8 bytes)\n   Outputs:\n   o  Sender Key: 0xf0910ed7295e6ad4b54fc793154302ff
        (16 bytes)\n   o  Recipient Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)\n
        \  o  Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)\n   From the previous
        parameters and a Partial IV equal to 0 (both for\n   sender and recipient):\n
        \  o  sender nonce: 0x4622d4dd6d944168eefb54987c (13 bytes)\n   o  recipient
        nonce: 0x4722d4dd6d944169eefb54987c (13 bytes)\n"
      title: C.1.1.  Client
    - contents:
      - "C.1.2.  Server\n   Inputs:\n   o  Master Secret: 0x0102030405060708090a0b0c0d0e0f10
        (16 bytes)\n   o  Master Salt: 0x9e7ca92223786340 (8 bytes)\n   o  Sender
        ID: 0x01 (1 byte)\n   o  Recipient ID: 0x (0 byte)\n   From the previous parameters,\n
        \  o  info (for Sender Key): 0x854101f60a634b657910 (10 bytes)\n   o  info
        (for Recipient Key): 0x8540f60a634b657910 (9 bytes)\n   o  info (for Common
        IV): 0x8540f60a6249560d (8 bytes)\n   Outputs:\n   o  Sender Key: 0xffb14e093c94c9cac9471648b4f98710
        (16 bytes)\n   o  Recipient Key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes)\n
        \  o  Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)\n   From the previous
        parameters and a Partial IV equal to 0 (both for\n   sender and recipient):\n
        \  o  sender nonce: 0x4722d4dd6d944169eefb54987c (13 bytes)\n   o  recipient
        nonce: 0x4622d4dd6d944168eefb54987c (13 bytes)\n"
      title: C.1.2.  Server
    title: 'C.1.  Test Vector 1: Key Derivation with Master Salt'
  - contents:
    - "C.2.  Test Vector 2: Key Derivation without Master Salt\n   In this test vector,
      the default values are used for AEAD Algorithm,\n   HKDF, and Master Salt.\n"
    - contents:
      - "C.2.1.  Client\n   Inputs:\n   o  Master Secret: 0x0102030405060708090a0b0c0d0e0f10
        (16 bytes)\n   o  Sender ID: 0x00 (1 byte)\n   o  Recipient ID: 0x01 (1 byte)\n
        \  From the previous parameters,\n   o  info (for Sender Key): 0x854100f60a634b657910
        (10 bytes)\n   o  info (for Recipient Key): 0x854101f60a634b657910 (10 bytes)\n
        \  o  info (for Common IV): 0x8540f60a6249560d (8 bytes)\n   Outputs:\n   o
        \ Sender Key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes)\n   o  Recipient
        Key: 0xe57b5635815177cd679ab4bcec9d7dda (16 bytes)\n   o  Common IV: 0xbe35ae297d2dace910c52e99f9
        (13 bytes)\n   From the previous parameters and a Partial IV equal to 0 (both
        for\n   sender and recipient):\n   o  sender nonce: 0xbf35ae297d2dace910c52e99f9
        (13 bytes)\n   o  recipient nonce: 0xbf35ae297d2dace810c52e99f9 (13 bytes)\n"
      title: C.2.1.  Client
    - contents:
      - "C.2.2.  Server\n   Inputs:\n   o  Master Secret: 0x0102030405060708090a0b0c0d0e0f10
        (16 bytes)\n   o  Sender ID: 0x01 (1 byte)\n   o  Recipient ID: 0x00 (1 byte)\n
        \  From the previous parameters,\n   o  info (for Sender Key): 0x854101f60a634b657910
        (10 bytes)\n   o  info (for Recipient Key): 0x854100f60a634b657910 (10 bytes)\n
        \  o  info (for Common IV): 0x8540f60a6249560d (8 bytes)\n   Outputs:\n   o
        \ Sender Key: 0xe57b5635815177cd679ab4bcec9d7dda (16 bytes)\n   o  Recipient
        Key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes)\n   o  Common IV: 0xbe35ae297d2dace910c52e99f9
        (13 bytes)\n   From the previous parameters and a Partial IV equal to 0 (both
        for\n   sender and recipient):\n   o  sender nonce: 0xbf35ae297d2dace810c52e99f9
        (13 bytes)\n   o  recipient nonce: 0xbf35ae297d2dace910c52e99f9 (13 bytes)\n"
      title: C.2.2.  Server
    title: 'C.2.  Test Vector 2: Key Derivation without Master Salt'
  - contents:
    - "C.3.  Test Vector 3: Key Derivation with ID Context\n   In this test vector,
      a Master Salt of 8 bytes and an ID Context of 8\n   bytes are used.  The default
      values are used for AEAD Algorithm and\n   HKDF.\n"
    - contents:
      - "C.3.1.  Client\n   Inputs:\n   o  Master Secret: 0x0102030405060708090a0b0c0d0e0f10
        (16 bytes)\n   o  Master Salt: 0x9e7ca92223786340 (8 bytes)\n   o  Sender
        ID: 0x (0 byte)\n   o  Recipient ID: 0x01 (1 byte)\n   o  ID Context: 0x37cbf3210017a2d3
        (8 bytes)\n   From the previous parameters,\n   o  info (for Sender Key):
        0x85404837cbf3210017a2d30a634b657910 (17\n      bytes)\n   o  info (for Recipient
        Key): 0x8541014837cbf3210017a2d30a634b657910\n      (18 bytes)\n   o  info
        (for Common IV): 0x85404837cbf3210017a2d30a6249560d (16\n      bytes)\n   Outputs:\n
        \  o  Sender Key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes)\n   o  Recipient
        Key: 0xe39a0c7c77b43f03b4b39ab9a268699f (16 bytes)\n   o  Common IV: 0x2ca58fb85ff1b81c0b7181b85e
        (13 bytes)\n   From the previous parameters and a Partial IV equal to 0 (both
        for\n   sender and recipient):\n   o  sender nonce: 0x2ca58fb85ff1b81c0b7181b85e
        (13 bytes)\n   o  recipient nonce: 0x2da58fb85ff1b81d0b7181b85e (13 bytes)\n"
      title: C.3.1.  Client
    - contents:
      - "C.3.2.  Server\n   Inputs:\n   o  Master Secret: 0x0102030405060708090a0b0c0d0e0f10
        (16 bytes)\n   o  Master Salt: 0x9e7ca92223786340 (8 bytes)\n   o  Sender
        ID: 0x01 (1 byte)\n   o  Recipient ID: 0x (0 byte)\n   o  ID Context: 0x37cbf3210017a2d3
        (8 bytes)\n   From the previous parameters,\n   o  info (for Sender Key):
        0x8541014837cbf3210017a2d30a634b657910 (18\n      bytes)\n   o  info (for
        Recipient Key): 0x85404837cbf3210017a2d30a634b657910 (17\n      bytes)\n   o
        \ info (for Common IV): 0x85404837cbf3210017a2d30a6249560d (16\n      bytes)\n
        \  Outputs:\n   o  Sender Key: 0xe39a0c7c77b43f03b4b39ab9a268699f (16 bytes)\n
        \  o  Recipient Key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes)\n   o  Common
        IV: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)\n   From the previous parameters
        and a Partial IV equal to 0 (both for\n   sender and recipient):\n   o  sender
        nonce: 0x2da58fb85ff1b81d0b7181b85e (13 bytes)\n   o  recipient nonce: 0x2ca58fb85ff1b81c0b7181b85e
        (13 bytes)\n"
      title: C.3.2.  Server
    title: 'C.3.  Test Vector 3: Key Derivation with ID Context'
  - contents:
    - "C.4.  Test Vector 4: OSCORE Request, Client\n   This section contains a test
      vector for an OSCORE-protected CoAP GET\n   request using the security context
      derived in Appendix C.1.  The\n   unprotected request only contains the Uri-Path
      and Uri-Host options.\n   Unprotected CoAP request:\n   0x44015d1f00003974396c6f63616c686f737483747631
      (22 bytes)\n   Common Context:\n   o  AEAD Algorithm: 10 (AES-CCM-16-64-128)\n
      \  o  Key Derivation Function: HKDF SHA-256\n   o  Common IV: 0x4622d4dd6d944168eefb54987c
      (13 bytes)\n   Sender Context:\n   o  Sender ID: 0x (0 byte)\n   o  Sender Key:
      0xf0910ed7295e6ad4b54fc793154302ff (16 bytes)\n   o  Sender Sequence Number:
      20\n   The following COSE and cryptographic parameters are derived:\n   o  Partial
      IV: 0x14 (1 byte)\n   o  kid: 0x (0 byte)\n   o  aad_array: 0x8501810a40411440
      (8 bytes)\n   o  AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes)\n
      \  o  plaintext: 0x01b3747631 (5 bytes)\n   o  encryption key: 0xf0910ed7295e6ad4b54fc793154302ff
      (16 bytes)\n   o  nonce: 0x4622d4dd6d944168eefb549868 (13 bytes)\n   From the
      previous parameter, the following is derived:\n   o  OSCORE option value: 0x0914
      (2 bytes)\n   o  ciphertext: 0x612f1092f1776f1c1668b3825e (13 bytes)\n   From
      there:\n   o  Protected CoAP request (OSCORE message): 0x44025d1f00003974396c6f6\n
      \     3616c686f7374620914ff612f1092f1776f1c1668b3825e (35 bytes)\n"
    title: 'C.4.  Test Vector 4: OSCORE Request, Client'
  - contents:
    - "C.5.  Test Vector 5: OSCORE Request, Client\n   This section contains a test
      vector for an OSCORE-protected CoAP GET\n   request using the security context
      derived in Appendix C.2.  The\n   unprotected request only contains the Uri-Path
      and Uri-Host options.\n   Unprotected CoAP request:\n   0x440171c30000b932396c6f63616c686f737483747631
      (22 bytes)\n   Common Context:\n   o  AEAD Algorithm: 10 (AES-CCM-16-64-128)\n
      \  o  Key Derivation Function: HKDF SHA-256\n   o  Common IV: 0xbe35ae297d2dace910c52e99f9
      (13 bytes)\n   Sender Context:\n   o  Sender ID: 0x00 (1 bytes)\n   o  Sender
      Key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes)\n   o  Sender Sequence Number:
      20\n   The following COSE and cryptographic parameters are derived:\n   o  Partial
      IV: 0x14 (1 byte)\n   o  kid: 0x00 (1 byte)\n   o  aad_array: 0x8501810a4100411440
      (9 bytes)\n   o  AAD: 0x8368456e63727970743040498501810a4100411440 (21 bytes)\n
      \  o  plaintext: 0x01b3747631 (5 bytes)\n   o  encryption key: 0x321b26943253c7ffb6003b0b64d74041
      (16 bytes)\n   o  nonce: 0xbf35ae297d2dace910c52e99ed (13 bytes)\n   From the
      previous parameter, the following is derived:\n   o  OSCORE option value: 0x091400
      (3 bytes)\n   o  ciphertext: 0x4ed339a5a379b0b8bc731fffb0 (13 bytes)\n   From
      there:\n   o  Protected CoAP request (OSCORE message): 0x440271c30000b932396c6f6\n
      \     3616c686f737463091400ff4ed339a5a379b0b8bc731fffb0 (36 bytes)\n"
    title: 'C.5.  Test Vector 5: OSCORE Request, Client'
  - contents:
    - "C.6.  Test Vector 6: OSCORE Request, Client\n   This section contains a test
      vector for an OSCORE-protected CoAP GET\n   request for an application that
      sets the ID Context and requires it\n   to be sent in the request, so 'kid context'
      is present in the\n   protected message.  This test vector uses the security
      context\n   derived in Appendix C.3.  The unprotected request only contains
      the\n   Uri-Path and Uri-Host options.\n   Unprotected CoAP request:\n   0x44012f8eef9bbf7a396c6f63616c686f737483747631
      (22 bytes)\n   Common Context:\n   o  AEAD Algorithm: 10 (AES-CCM-16-64-128)\n
      \  o  Key Derivation Function: HKDF SHA-256\n   o  Common IV: 0x2ca58fb85ff1b81c0b7181b85e
      (13 bytes)\n   o  ID Context: 0x37cbf3210017a2d3 (8 bytes)\n   Sender Context:\n
      \  o  Sender ID: 0x (0 bytes)\n   o  Sender Key: 0xaf2a1300a5e95788b356336eeecd2b92
      (16 bytes)\n   o  Sender Sequence Number: 20\n   The following COSE and cryptographic
      parameters are derived:\n   o  Partial IV: 0x14 (1 byte)\n   o  kid: 0x (0 byte)\n
      \  o  kid context: 0x37cbf3210017a2d3 (8 bytes)\n   o  aad_array: 0x8501810a40411440
      (8 bytes)\n   o  AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes)\n
      \  o  plaintext: 0x01b3747631 (5 bytes)\n   o  encryption key: 0xaf2a1300a5e95788b356336eeecd2b92
      (16 bytes)\n   o  nonce: 0x2ca58fb85ff1b81c0b7181b84a (13 bytes)\n   From the
      previous parameter, the following is derived:\n   o  OSCORE option value: 0x19140837cbf3210017a2d3
      (11 bytes)\n   o  ciphertext: 0x72cd7273fd331ac45cffbe55c3 (13 bytes)\n   From
      there:\n   o  Protected CoAP request (OSCORE message):\n      0x44022f8eef9bbf7a396c6f63616c686f73746b19140837cbf3210017a2d3ff\n
      \     72cd7273fd331ac45cffbe55c3 (44 bytes)\n"
    title: 'C.6.  Test Vector 6: OSCORE Request, Client'
  - contents:
    - "C.7.  Test Vector 7: OSCORE Response, Server\n   This section contains a test
      vector for an OSCORE-protected 2.05\n   (Content) response to the request in
      Appendix C.4.  The unprotected\n   response has payload \"Hello World!\" and
      no options.  The protected\n   response does not contain a 'kid' nor a Partial
      IV.  Note that some\n   parameters are derived from the request.\n   Unprotected
      CoAP response:\n   0x64455d1f00003974ff48656c6c6f20576f726c6421 (21 bytes)\n
      \  Common Context:\n   o  AEAD Algorithm: 10 (AES-CCM-16-64-128)\n   o  Key
      Derivation Function: HKDF SHA-256\n   o  Common IV: 0x4622d4dd6d944168eefb54987c
      (13 bytes)\n   Sender Context:\n   o  Sender ID: 0x01 (1 byte)\n   o  Sender
      Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)\n   o  Sender Sequence Number:
      0\n   The following COSE and cryptographic parameters are derived:\n   o  aad_array:
      0x8501810a40411440 (8 bytes)\n   o  AAD: 0x8368456e63727970743040488501810a40411440
      (20 bytes)\n   o  plaintext: 0x45ff48656c6c6f20576f726c6421 (14 bytes)\n   o
      \ encryption key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)\n   o  nonce:
      0x4622d4dd6d944168eefb549868 (13 bytes)\n   From the previous parameter, the
      following is derived:\n   o  OSCORE option value: 0x (0 bytes)\n   o  ciphertext:
      0xdbaad1e9a7e7b2a813d3c31524378303cdafae119106 (22\n      bytes)\n   From there:\n
      \  o  Protected CoAP response (OSCORE message):\n      0x64445d1f0000397490ffdbaad1e9a7e7b2a813d3c31524378303cdafae119106\n
      \     (32 bytes)\n"
    title: 'C.7.  Test Vector 7: OSCORE Response, Server'
  - contents:
    - "C.8.  Test Vector 8: OSCORE Response with Partial IV, Server\n   This section
      contains a test vector for an OSCORE protected 2.05\n   (Content) response to
      the request in Appendix C.4.  The unprotected\n   response has payload \"Hello
      World!\" and no options.  The protected\n   response does not contain a 'kid',
      but contains a Partial IV.  Note\n   that some parameters are derived from the
      request.\n   Unprotected CoAP response:\n   0x64455d1f00003974ff48656c6c6f20576f726c6421
      (21 bytes)\n   Common Context:\n   o  AEAD Algorithm: 10 (AES-CCM-16-64-128)\n
      \  o  Key Derivation Function: HKDF SHA-256\n   o  Common IV: 0x4622d4dd6d944168eefb54987c
      (13 bytes)\n   Sender Context:\n   o  Sender ID: 0x01 (1 byte)\n   o  Sender
      Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)\n   o  Sender Sequence Number:
      0\n   The following COSE and cryptographic parameters are derived:\n   o  Partial
      IV: 0x00 (1 byte)\n   o  aad_array: 0x8501810a40411440 (8 bytes)\n   o  AAD:
      0x8368456e63727970743040488501810a40411440 (20 bytes)\n   o  plaintext: 0x45ff48656c6c6f20576f726c6421
      (14 bytes)\n   o  encryption key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)\n
      \  o  nonce: 0x4722d4dd6d944169eefb54987c (13 bytes)\n   From the previous parameter,
      the following is derived:\n   o  OSCORE option value: 0x0100 (2 bytes)\n   o
      \ ciphertext: 0x4d4c13669384b67354b2b6175ff4b8658c666a6cf88e (22\n      bytes)\n
      \  From there:\n   o  Protected CoAP response (OSCORE message): 0x64445d1f00003974920100\n
      \     ff4d4c13669384b67354b2b6175ff4b8658c666a6cf88e (34 bytes)\n"
    title: 'C.8.  Test Vector 8: OSCORE Response with Partial IV, Server'
  title: Appendix C.  Test Vectors
- contents:
  - 'Appendix D.  Overview of Security Properties

    '
  - contents:
    - "D.1.  Threat Model\n   This section describes the threat model using the terms
      of [RFC3552].\n   It is assumed that the endpoints running OSCORE have not themselves\n
      \  been compromised.  The attacker is assumed to have control of the\n   CoAP
      channel over which the endpoints communicate, including\n   intermediary nodes.
      \ The attacker is capable of launching any passive\n   or active on-path or
      off-path attacks; including eavesdropping,\n   traffic analysis, spoofing, insertion,
      modification, deletion, delay,\n   replay, man-in-the-middle, and denial-of-service
      attacks.  This means\n   that the attacker can read any CoAP message on the
      network and\n   undetectably remove, change, or inject forged messages onto
      the wire.\n   OSCORE targets the protection of the CoAP request/response layer\n
      \  (Section 2 of [RFC7252]) between the endpoints, including the CoAP\n   Payload,
      Code, Uri-Path/Uri-Query, and the other Class E option\n   instances (Section
      4.1).\n   OSCORE does not protect the CoAP messaging layer (Section 2 of\n   [RFC7252])
      or other lower layers involved in routing and transporting\n   the CoAP requests
      and responses.\n   Additionally, OSCORE does not protect Class U option instances\n
      \  (Section 4.1), as these are used to support CoAP forward proxy\n   operations
      (see Section 5.7.2 of [RFC7252]).  The supported proxies\n   (forwarding, cross-protocol,
      e.g., CoAP to CoAP-mappable protocols\n   such as HTTP) must be able to change
      certain Class U options (by\n   instruction from the Client), resulting in the
      CoAP request being\n   redirected to the server.  Changes caused by the proxy
      may result in\n   the request not reaching the server or reaching the wrong
      server.\n   For cross-protocol proxies, mappings are done on the Outer part
      of\n   the message so these protocols are essentially used as transport.\n   Manipulation
      of these options may thus impact whether the protected\n   message reaches or
      does not reach the destination endpoint.\n   Attacks on unprotected CoAP message
      fields generally causes denial-\n   of-service attacks which are out of scope
      of this document, more\n   details are given in Appendix D.5.\n   Attacks against
      the CoAP request-response layer are in scope.  OSCORE\n   is intended to protect
      against eavesdropping, spoofing, insertion,\n   modification, deletion, replay,
      and man-in-the middle attacks.\n   OSCORE is susceptible to traffic analysis
      as discussed later in\n   Appendix D.\n"
    title: D.1.  Threat Model
  - contents:
    - "D.2.  Supporting Proxy Operations\n   CoAP is designed to work with intermediaries
      reading and/or changing\n   CoAP message fields to perform supporting operations
      in constrained\n   environments, e.g., forwarding and cross-protocol translations.\n
      \  Securing CoAP on the transport layer protects the entire message\n   between
      the endpoints, in which case CoAP proxy operations are not\n   possible.  In
      order to enable proxy operations, security on the\n   transport layer needs
      to be terminated at the proxy; in which case,\n   the CoAP message in its entirety
      is unprotected in the proxy.\n   Requirements for CoAP end-to-end security are
      specified in\n   [CoAP-E2E-Sec], in particular, forwarding is detailed in\n
      \  Section 2.2.1.  The client and server are assumed to be honest, while\n   proxies
      and gateways are only trusted to perform their intended\n   operations.\n   By
      working at the CoAP layer, OSCORE enables different CoAP message\n   fields
      to be protected differently, which allows message fields\n   required for proxy
      operations to be available to the proxy while\n   message fields intended for
      the other endpoint remain protected.  In\n   the remainder of this section,
      we analyze how OSCORE protects the\n   protected message fields and the consequences
      of message fields\n   intended for proxy operation being unprotected.\n"
    title: D.2.  Supporting Proxy Operations
  - contents:
    - "D.3.  Protected Message Fields\n   Protected message fields are included in
      the plaintext (Section 5.3)\n   and the AAD (Section 5.4) of the COSE_Encrypt0
      object and encrypted\n   using an AEAD algorithm.\n   OSCORE depends on a preestablished
      random Master Secret\n   (Section 12.3) used to derive encryption keys, and
      a construction for\n   making (key, nonce) pairs unique (Appendix D.4).  Assuming
      this is\n   true, and the keys are used for no more data than indicated in\n
      \  Section 7.2.1, OSCORE should provide the following guarantees:\n   o  Confidentiality:
      An attacker should not be able to determine the\n      plaintext contents of
      a given OSCORE message or determine that\n      different plaintexts are related
      (Section 5.3).\n   o  Integrity: An attacker should not be able to craft a new
      OSCORE\n      message with protected message fields different from an existing\n
      \     OSCORE message that will be accepted by the receiver.\n   o  Request-response
      binding: An attacker should not be able to make a\n      client match a response
      to the wrong request.\n   o  Non-replayability: An attacker should not be able
      to cause the\n      receiver to accept a message that it has previously received
      and\n      accepted.\n   In the above, the attacker is anyone except the endpoints,
      e.g., a\n   compromised intermediary.  Informally, OSCORE provides these\n   properties
      by AEAD-protecting the plaintext with a strong key and\n   uniqueness of (key,
      nonce) pairs.  AEAD encryption [RFC5116] provides\n   confidentiality and integrity
      for the data.  Response-request binding\n   is provided by including the 'kid'
      and Partial IV of the request in\n   the AAD of the response.  Non-replayability
      of requests and\n   notifications is provided by using unique (key, nonce) pairs
      and a\n   replay protection mechanism (application dependent, see Section 7.4).\n
      \  OSCORE is susceptible to a variety of traffic analysis attacks based\n   on
      observing the length and timing of encrypted packets.  OSCORE does\n   not provide
      any specific defenses against this form of attack, but\n   the application may
      use a padding mechanism to prevent an attacker\n   from directly determining
      the length of the padding.  However,\n   information about padding may still
      be revealed by side-channel\n   attacks observing differences in timing.\n"
    title: D.3.  Protected Message Fields
  - contents:
    - "D.4.  Uniqueness of (key, nonce)\n   In this section, we show that (key, nonce)
      pairs are unique as long\n   as the requirements in Sections 3.3 and 7.2.1 are
      followed.\n   Fix a Common Context (Section 3.1) and an endpoint, called the\n
      \  encrypting endpoint.  An endpoint may alternate between client and\n   server
      roles, but each endpoint always encrypts with the Sender Key\n   of its Sender
      Context.  Sender Keys are (stochastically) unique since\n   they are derived
      with HKDF using unique Sender IDs, so messages\n   encrypted by different endpoints
      use different keys.  It remains to\n   be proven that the nonces used by the
      fixed endpoint are unique.\n   Since the Common IV is fixed, the nonces are
      determined by PIV, where\n   PIV takes the value of the Partial IV of the request
      or of the\n   response, and by the Sender ID of the endpoint generating that\n
      \  Partial IV (ID_PIV).  The nonce construction (Section 5.2) with the\n   size
      of the ID_PIV (S) creates unique nonces for different (ID_PIV,\n   PIV) pairs.
      \ There are two cases:\n   A.  For requests, and responses with Partial IV (e.g.,
      Observe\n   notifications):\n   o  ID_PIV = Sender ID of the encrypting endpoint\n
      \  o  PIV = current Partial IV of the encrypting endpoint\n   Since the encrypting
      endpoint steps the Partial IV for each use, the\n   nonces used in case A are
      all unique as long as the number of\n   encrypted messages is kept within the
      required range (Section 7.2.1).\n   B.  For responses without Partial IV (e.g.,
      single response to a\n   request):\n   o  ID_PIV = Sender ID of the endpoint
      generating the request\n   o  PIV = Partial IV of the request\n   Since the
      Sender IDs are unique, ID_PIV is different from the Sender\n   ID of the encrypting
      endpoint.  Therefore, the nonces in case B are\n   different compared to nonces
      in case A, where the encrypting endpoint\n   generated the Partial IV.  Since
      the Partial IV of the request is\n   verified for replay (Section 7.4) associated
      to this Recipient\n   Context, PIV is unique for this ID_PIV, which makes all
      nonces in\n   case B distinct.\n"
    title: D.4.  Uniqueness of (key, nonce)
  - contents:
    - "D.5.  Unprotected Message Fields\n   This section analyzes attacks on message
      fields that are not\n   protected by OSCORE according to the threat model Appendix
      D.1.\n"
    - contents:
      - "D.5.1.  CoAP Header Fields\n   o  Version.  The CoAP version [RFC7252] is
        not expected to be\n      sensitive to disclosure.  Currently, there is only
        one CoAP\n      version defined.  A change of this parameter is potentially
        a\n      denial-of-service attack.  Future versions of CoAP need to analyze\n
        \     attacks to OSCORE-protected messages due to an adversary changing\n
        \     the CoAP version.\n   o  Token/Token Length.  The Token field is a client-local
        identifier\n      for differentiating between concurrent requests [RFC7252].
        \ CoAP\n      proxies are allowed to read and change Token and Token Length\n
        \     between hops.  An eavesdropper reading the Token can match\n      requests
        to responses that can be used in traffic analysis.  In\n      particular,
        this is true for notifications, where multiple\n      responses are matched
        to one request.  Modifications of Token and\n      Token Length by an on-path
        attacker may become a denial-of-service\n      attack, since it may prevent
        the client to identify to which\n      request the response belongs or to
        find the correct information to\n      verify integrity of the response.\n
        \  o  Code.  The Outer CoAP Code of an OSCORE message is POST or FETCH\n      for
        requests with corresponding response codes.  An endpoint\n      receiving
        the message discards the Outer CoAP Code and uses the\n      Inner CoAP Code
        instead (see Section 4.2).  Hence, modifications\n      from attackers to
        the Outer Code do not impact the receiving\n      endpoint.  However, changing
        the Outer Code from FETCH to a Code\n      value for a method that does not
        work with Observe (such as POST)\n      may, depending on proxy implementation
        since Observe is undefined\n      for several Codes, cause the proxy to not
        forward notifications,\n      which is a denial-of-service attack.  The use
        of FETCH rather than\n      POST reveals no more than what is revealed by
        the presence of the\n      Outer Observe option.\n   o  Type/Message ID.  The
        Type/Message ID fields [RFC7252] reveal\n      information about the UDP transport
        binding, e.g., an eavesdropper\n      reading the Type or Message ID gain
        information about how UDP\n      messages are related to each other.  CoAP
        proxies are allowed to\n      change Type and Message ID.  These message fields
        are not present\n      in CoAP over TCP [RFC8323] and do not impact the request/response\n
        \     message.  A change of these fields in a UDP hop is a denial-of-\n      service
        attack.  By sending an ACK, an attacker can make the\n      endpoint believe
        that it does not need to retransmit the previous\n      message.  By sending
        a RST, an attacker may be able to cancel an\n      observation.  By changing
        a NON to a CON, the attacker can cause\n      the receiving endpoint to ACK
        messages for which no ACK was\n      requested.\n   o  Length.  This field
        contains the length of the message [RFC8323],\n      which may be used for
        traffic analysis.  This message field is not\n      present in CoAP over UDP
        and does not impact the request/response\n      message.  A change of Length
        is a denial-of-service attack similar\n      to changing TCP header fields.\n"
      title: D.5.1.  CoAP Header Fields
    - contents:
      - "D.5.2.  CoAP Options\n   o  Max-Age. The Outer Max-Age is set to zero to
        avoid unnecessary\n      caching of OSCORE error responses.  Changing this
        value thus may\n      cause unnecessary caching.  No additional information
        is carried\n      with this option.\n   o  Proxy-Uri/Proxy-Scheme.  These
        options are used in CoAP forward\n      proxy deployments.  With OSCORE, the
        Proxy-Uri option does not\n      contain the Uri-Path/Uri-Query parts of the
        URI.  The other parts\n      of Proxy-Uri cannot be protected because forward
        proxies need to\n      change them in order to perform their functions.  The
        server can\n      verify what scheme is used in the last hop, but not what
        was\n      requested by the client or what was used in previous hops.\n   o
        \ Uri-Host/Uri-Port.  In forward proxy deployments, the Uri-Host/\n      Uri-Port
        may be changed by an adversary, and the application needs\n      to handle
        the consequences of that (see Section 4.1.3.2).  The\n      Uri-Host may either
        be omitted, reveal information equivalent to\n      that of the IP address,
        or reveal more privacy-sensitive\n      information, which is discouraged.\n
        \  o  Observe.  The Outer Observe option is intended for a proxy to\n      support
        forwarding of Observe messages, but it is ignored by the\n      endpoints
        since the Inner Observe option determines the processing\n      in the endpoints.
        \ Since the Partial IV provides absolute ordering\n      of notifications,
        it is not possible for an intermediary to spoof\n      reordering (see Section
        4.1.3.5).  The absence of Partial IV,\n      since only allowed for the first
        notification, does not prevent\n      correct ordering of notifications.  The
        size and distributions of\n      notifications over time may reveal information
        about the content\n      or nature of the notifications.  Cancellations (Section
        4.1.3.5.1)\n      are not bound to the corresponding registrations in the
        same way\n      responses are bound to requests in OSCORE (see Appendix D.3).\n
        \     However, that does not make attacks based on mismatched\n      cancellations
        possible, since for cancellations to be accepted,\n      all options in the
        decrypted message except for ETag options MUST\n      be the same (see Section
        4.1.3.5).\n   o  Block1/Block2/Size1/Size2.  The Outer Block options enable\n
        \     fragmentation of OSCORE messages in addition to segmentation\n      performed
        by the Inner Block options.  The presence of these\n      options indicates
        a large message being sent, and the message size\n      can be estimated and
        used for traffic analysis.  Manipulating\n      these options is a potential
        denial-of-service attack, e.g.,\n      injection of alleged Block fragments.
        \ The specification of a\n      maximum size of message, MAX_UNFRAGMENTED_SIZE\n
        \     (Section 4.1.3.4.2), above which messages will be dropped, is\n      intended
        as one measure to mitigate this kind of attack.\n   o  No-Response.  The Outer
        No-Response option is used to support\n      proxy functionality, specifically
        to avoid error transmissions\n      from proxies to clients, and to avoid
        bandwidth reduction to\n      servers by proxies applying congestion control
        when not receiving\n      responses.  Modifying or introducing this option
        is a potential\n      denial-of-service attack against the proxy operations,
        but since\n      the option has an Inner value, its use can be securely agreed
        upon\n      between the endpoints.  The presence of this option is not\n      expected
        to reveal any sensitive information about the message\n      exchange.\n   o
        \ OSCORE.  The OSCORE option contains information about the\n      compressed
        COSE header.  Changing this field may cause OSCORE\n      verification to
        fail.\n"
      title: D.5.2.  CoAP Options
    - contents:
      - "D.5.3.  Error and Signaling Messages\n   Error messages occurring during
        CoAP processing are protected end-to-\n   end.  Error messages occurring during
        OSCORE processing are not\n   always possible to protect, e.g., if the receiving
        endpoint cannot\n   locate the right security context.  For this setting,
        unprotected\n   error messages are allowed as specified to prevent extensive\n
        \  retransmissions.  Those error messages can be spoofed or manipulated,\n
        \  which is a potential denial-of-service attack.\n   This document specifies
        OPTIONAL error codes and specific diagnostic\n   payloads for OSCORE processing
        error messages.  Such messages might\n   reveal information about how many
        and which security contexts exist\n   on the server.  Servers MAY want to
        omit the diagnostic payload of\n   error messages, use the same error code
        for all errors, or avoid\n   responding altogether in case of OSCORE processing
        errors, if that is\n   a security concern for the application.  Moreover,
        clients MUST NOT\n   rely on the error code or the diagnostic payload to trigger
        specific\n   actions, as these errors are unprotected and can be spoofed or\n
        \  manipulated.\n   Signaling messages used in CoAP over TCP [RFC8323] are
        intended to be\n   hop-by-hop; spoofing signaling messages can be used as
        a denial-of-\n   service attack of a TCP connection.\n"
      title: D.5.3.  Error and Signaling Messages
    - contents:
      - "D.5.4.  HTTP Message Fields\n   In contrast to CoAP, where OSCORE does not
        protect header fields to\n   enable CoAP-CoAP proxy operations, the use of
        OSCORE with HTTP is\n   restricted to transporting a protected CoAP message
        over an HTTP hop.\n   Any unprotected HTTP message fields may reveal information
        about the\n   transport of the OSCORE message and enable various denial-of-service\n
        \  attacks.  It is RECOMMENDED to additionally use TLS [RFC8446] for\n   HTTP
        hops, which enables encryption and integrity protection of\n   headers, but
        still leaves some information for traffic analysis.\n"
      title: D.5.4.  HTTP Message Fields
    title: D.5.  Unprotected Message Fields
  title: Appendix D.  Overview of Security Properties
- contents:
  - "Appendix E.  CDDL Summary\n   Data structure definitions in the present specification
    employ the\n   CDDL language for conciseness and precision [RFC8610].  This appendix\n
    \  summarizes the small subset of CDDL that is used in the present\n   specification.\n
    \  Within the subset being used here, a CDDL rule is of the form \"name =\n   type\",
    where \"name\" is the name given to the \"type\".  A \"type\" can be\n   one of:\n
    \  o  a reference to another named type, by giving its name.  The\n      predefined
    named types used in the present specification are as\n      follows: \"uint\",
    an unsigned integer (as represented in CBOR by\n      major type 0); \"int\",
    an unsigned or negative integer (as\n      represented in CBOR by major type 0
    or 1); \"bstr\", a byte string\n      (as represented in CBOR by major type 2);
    \"tstr\", a text string\n      (as represented in CBOR by major type 3);\n   o
    \ a choice between two types, by giving both types separated by a\n      \"/\";\n
    \  o  an array type (as represented in CBOR by major type 4), where the\n      sequence
    of elements of the array is described by giving a\n      sequence of entries separated
    by commas \",\", and this sequence is\n      enclosed by square brackets \"[\"
    and \"]\".  Arrays described by an\n      array description contain elements that
    correspond one-to-one to\n      the sequence of entries given.  Each entry of
    an array description\n      is of the form \"name : type\", where \"name\" is
    the name given to\n      the entry and \"type\" is the type of the array element\n
    \     corresponding to this entry.\n"
  title: Appendix E.  CDDL Summary
- contents:
  - "Acknowledgments\n   The following individuals provided input to this document:
    Christian\n   Amsuess, Tobias Andersson, Carsten Bormann, Joakim Brorsson, Ben\n
    \  Campbell, Esko Dijk, Jaro Fietz, Thomas Fossati, Martin Gunnarsson,\n   Klaus
    Hartke, Rikard Hoeglund, Mirja Kuehlewind, Kathleen Moriarty,\n   Eric Rescorla,
    Michael Richardson, Adam Roach, Jim Schaad, Peter van\n   der Stok, Dave Thaler,
    Martin Thomson, Marco Tiloca, William Vignat,\n   and Malisa Vucinic.\n   Ludwig
    Seitz and Goeran Selander worked on this document as part of\n   the CelticPlus
    project CyberWI, with funding from Vinnova.  Ludwig\n   Seitz had additional funding
    from the SSF project SEC4Factory under\n   the grant RIT17-0032.\n"
  title: Acknowledgments
- contents:
  - "Authors' Addresses\n   Goeran Selander\n   Ericsson AB\n   Email: goran.selander@ericsson.com\n
    \  John Mattsson\n   Ericsson AB\n   Email: john.mattsson@ericsson.com\n   Francesca
    Palombini\n   Ericsson AB\n   Email: francesca.palombini@ericsson.com\n   Ludwig
    Seitz\n   RISE\n   Email: ludwig.seitz@ri.se\n"
  title: Authors' Addresses
