- contents:
  - "                   Failure Detection and Locator Pair\n               Exploration
    Protocol for IPv6 Multihoming\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents
    in effect on the date of\n   publication of this document (http://trustee.ietf.org/license-info).\n
    \  Please review these documents carefully, as they describe your rights\n   and
    restrictions with respect to this document.\n   This document may contain material
    from IETF Documents or IETF\n   Contributions published or made publicly available
    before November\n   10, 2008.  The person(s) controlling the copyright in some
    of this\n   material may not have granted the IETF Trust the right to allow\n
    \  modifications of such material outside the IETF Standards Process.\n   Without
    obtaining an adequate license from the person(s) controlling\n   the copyright
    in such materials, this document may not be modified\n   outside the IETF Standards
    Process, and derivative works of it may\n   not be created outside the IETF Standards
    Process, except to format\n   it for publication as an RFC or to translate it
    into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document specifies how the level 3 multihoming Shim6 protocol\n
    \  (Shim6) detects failures between two communicating nodes.  It also\n   specifies
    an exploration protocol for switching to another pair of\n   interfaces and/or
    addresses between the same nodes if a failure\n   occurs and an operational pair
    can be found.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Requirements Language ...........................................4\n   3.
    Definitions .....................................................4\n      3.1.
    Available Addresses ........................................4\n      3.2. Locally
    Operational Addresses ..............................5\n      3.3. Operational
    Address Pairs ..................................5\n      3.4. Primary Address
    Pair .......................................7\n      3.5. Current Address Pair
    .......................................7\n   4. Protocol Overview ...............................................8\n
    \     4.1. Failure Detection ..........................................8\n      4.2.
    Full Reachability Exploration .............................10\n      4.3. Exploration
    Order .........................................11\n   5. Protocol Definition ............................................13\n
    \     5.1. Keepalive Message .........................................13\n      5.2.
    Probe Message .............................................14\n      5.3. Keepalive
    Timeout Option Format ...........................18\n   6. Behavior .......................................................19\n
    \     6.1. Incoming Payload Packet ...................................20\n      6.2.
    Outgoing Payload Packet ...................................21\n      6.3. Keepalive
    Timeout .........................................21\n      6.4. Send Timeout ..............................................22\n
    \     6.5. Retransmission ............................................22\n      6.6.
    Reception of the Keepalive Message ........................22\n      6.7. Reception
    of the Probe Message State=Exploring ............23\n      6.8. Reception of the
    Probe Message State=InboundOk ............23\n      6.9. Reception of the Probe
    Message State=Operational ..........23\n      6.10. Graphical Representation of
    the State Machine ............24\n   7. Protocol Constants and Variables ...............................24\n
    \  8. Security Considerations ........................................25\n   9.
    Operational Considerations .....................................27\n   10. References
    ....................................................28\n      10.1. Normative
    References .....................................28\n      10.2. Informative References
    ...................................29\n   Appendix A. Example Protocol Runs..................................30\n
    \  Appendix B. Contributors...........................................35\n   Appendix
    C. Acknowledgements.......................................35\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Shim6 protocol [RFC5533] extends IPv6 to support multihoming.
    \ It\n   is an IP-layer mechanism that hides multihoming from applications.  A\n
    \  part of the Shim6 solution involves detecting when a currently used\n   pair
    of addresses (or interfaces) between two communication nodes has\n   failed and
    picking another pair when this occurs.  We call the former\n   \"failure detection\",
    and the latter, \"locator pair exploration\".\n   This document specifies the
    mechanisms and protocol messages to\n   achieve both failure detection and locator
    pair exploration.  This\n   part of the Shim6 protocol is called the REAchability
    Protocol\n   (REAP).\n   Failure detection is made as lightweight as possible.
    \ Payload data\n   traffic in both directions is observed, and in the case where
    there\n   is no traffic because the communication is idle, failure detection is\n
    \  also idle and doesn't generate any packets.  When payload traffic is\n   flowing
    in both directions, there is no need to send failure\n   detection packets, either.
    \ Only when there is traffic in one\n   direction does the failure detection mechanism
    generate keepalives in\n   the other direction.  As a result, whenever there is
    outgoing traffic\n   and no incoming return traffic or keepalives, there must
    be failure,\n   at which point the locator pair exploration is performed to find
    a\n   working address pair for each direction.\n   This document is structured
    as follows: Section 3 defines a set of\n   useful terms, Section 4 gives an overview
    of REAP, and Section 5\n   provides a detailed definition.  Section 6 specifies
    behavior, and\n   Section 7 discusses protocol constants.  Section 8 discusses
    the\n   security considerations of REAP.\n   In this specification, we consider
    an address to be synonymous with a\n   locator.  Other parts of the Shim6 protocol
    ensure that the different\n   locators used by a node actually belong together.
    \ That is, REAP is\n   not responsible for ensuring that said node ends up with
    a legitimate\n   locator.\n   REAP has been designed to be used with Shim6 and
    is therefore\n   tailored to an environment where it typically runs on hosts,
    uses\n   widely varying types of paths, and is unaware of application context.\n
    \  As a result, REAP attempts to be as self-configuring and unobtrusive\n   as
    possible.  In particular, it avoids sending any packets except\n   where absolutely
    required and employs exponential back-off to avoid\n   congestion.  The downside
    is that it cannot offer the same\n   granularity of detecting problems as mechanisms
    that have more\n   application context and ability to negotiate or configure parameters.\n
    \  Future versions of this specification may consider extensions with\n   such
    capabilities, for instance, through inheriting some mechanisms\n   from the Bidirectional
    Forwarding Detection (BFD) protocol [BFD].\n"
  title: 1.  Introduction
- contents:
  - "2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
    and \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
  title: 2.  Requirements Language
- contents:
  - "3.  Definitions\n   This section defines terms useful for discussing failure
    detection\n   and locator pair exploration.\n"
  - contents:
    - "3.1.  Available Addresses\n   Shim6 nodes need to be aware of what addresses
      they themselves have.\n   If a node loses the address it is currently using
      for communications,\n   another address must replace it.  And if a node loses
      an address that\n   the node's peer knows about, the peer must be informed.
      \ Similarly,\n   when a node acquires a new address it may generally wish the
      peer to\n   know about it.\n   Definition.  Available address - an address is
      said to be available\n   if all the following conditions are fulfilled:\n   o
      \ The address has been assigned to an interface of the node.\n   o  The valid
      lifetime of the prefix (Section 4.6.2 of RFC 4861\n      [RFC4861]) associated
      with the address has not expired.\n   o  The address is not tentative in the
      sense of RFC 4862 [RFC4862].\n      In other words, the address assignment is
      complete so that\n      communications can be started.\n      Note that this
      explicitly allows an address to be optimistic in\n      the sense of Optimistic
      Duplicate Address Detection (DAD)\n      [RFC4429] even though implementations
      may prefer using other\n      addresses as long as there is an alternative.\n
      \  o  The address is a global unicast or unique local address [RFC4193].\n      That
      is, it is not an IPv6 site-local or link-local address.\n      With link-local
      addresses, the nodes would be unable to determine\n      on which link the given
      address is usable.\n   o  The address and interface are acceptable for use according
      to a\n      local policy.\n   Available addresses are discovered and monitored
      through mechanisms\n   outside the scope of Shim6.  Shim6 implementations MUST
      be able to\n   employ information provided by IPv6 Neighbor Discovery [RFC4861],\n
      \  Address Autoconfiguration [RFC4862], and DHCP [RFC3315] (when DHCP is\n   implemented).
      \ This information includes the availability of a new\n   address and status
      changes of existing addresses (such as when an\n   address becomes invalid).\n"
    title: 3.1.  Available Addresses
  - contents:
    - "3.2.  Locally Operational Addresses\n   Two different granularity levels are
      needed for failure detection.\n   The coarser granularity is for individual
      addresses.\n   Definition.  Locally operational address - an available address
      is\n   said to be locally operational when its use is known to be possible\n
      \  locally.  In other words, when the interface is up, a default router\n   (if
      needed) suitable for this address is known to be reachable, and\n   no other
      local information points to the address being unusable.\n   Locally operational
      addresses are discovered and monitored through\n   mechanisms outside the Shim6
      protocol.  Shim6 implementations MUST be\n   able to employ information provided
      from Neighbor Unreachability\n   Detection [RFC4861].  Implementations MAY also
      employ additional,\n   link-layer-specific mechanisms.\n      Note 1: A part
      of the problem in ensuring that an address is\n      operational is making sure
      that after a change in link-layer\n      connectivity, we are still connected
      to the same IP subnet.\n      Mechanisms such as [DNA-SIM] can be used to ensure
      this.\n      Note 2: In theory, it would also be possible for nodes to learn\n
      \     about routing failures for a particular selected source prefix, if\n      only
      suitable protocols for this purpose existed.  Some proposals\n      in this
      space have been made (see, for instance [ADD-SEL] and\n      [MULTI6]), but
      none have been standardized to date.\n"
    title: 3.2.  Locally Operational Addresses
  - contents:
    - "3.3.  Operational Address Pairs\n   The existence of locally operational addresses
      are not, however, a\n   guarantee that communications can be established with
      the peer.  A\n   failure in the routing infrastructure can prevent packets from\n
      \  reaching their destination.  For this reason, we need the definition\n   of
      a second level of granularity, which is used for pairs of\n   addresses.\n   Definition.
      \ Bidirectionally operational address pair - a pair of\n   locally operational
      addresses are said to be an operational address\n   pair when bidirectional
      connectivity can be shown between the\n   addresses.  That is, a packet sent
      with one of the addresses in the\n   Source field and the other in the Destination
      field reaches the\n   destination, and vice versa.\n   Unfortunately, there
      are scenarios where bidirectionally operational\n   address pairs do not exist.
      \ For instance, ingress filtering or\n   network failures may result in one
      address pair being operational in\n   one direction while another one is operational
      from the other\n   direction.  The following definition captures this general
      situation.\n   Definition.  Unidirectionally operational address pair - a pair
      of\n   locally operational addresses are said to be a unidirectionally\n   operational
      address pair when packets sent with the first address as\n   the source and
      the second address as the destination reach the\n   destination.\n   Shim6 implementations
      MUST support the discovery of operational\n   address pairs through the use
      of explicit reachability tests and\n   Forced Bidirectional Communication (FBD),
      described later in this\n   specification.  Future extensions of Shim6 may specify
      additional\n   mechanisms.  Some ideas of such mechanisms are listed below but
      are\n   not fully specified in this document:\n   o  Positive feedback from
      upper-layer protocols.  For instance, TCP\n      can indicate to the IP layer
      that it is making progress.  This is\n      similar to how IPv6 Neighbor Unreachability
      Detection can, in some\n      cases, be avoided when upper layers provide information
      about\n      bidirectional connectivity [RFC4861].\n      In the case of unidirectional
      connectivity, the upper-layer\n      protocol responses come back using another
      address pair, but show\n      that the messages sent using the first address
      pair have been\n      received.\n   o  Negative feedback from upper-layer protocols.
      \ It is conceivable\n      that upper-layer protocols give an indication of
      a problem to the\n      multihoming layer.  For instance, TCP could indicate
      that there's\n      either congestion or lack of connectivity in the path because
      it\n      is not getting ACKs.\n   o  ICMP error messages.  Given the ease of
      spoofing ICMP messages,\n      one should be careful not to trust these blindly,
      however.  One\n      approach would be to use ICMP error messages only as a
      hint to\n      perform an explicit reachability test or to move an address pair\n
      \     to a lower place in the list of address pairs to be probed, but\n      not
      to use these messages as a reason to disrupt ongoing\n      communications without
      other indications of problems.  The\n      situation may be different when certain
      verifications of the ICMP\n      messages are being performed, as explained
      by Gont in [GONT].\n      These verifications can ensure that (practically)
      only on-path\n      attackers can spoof the messages.\n"
    title: 3.3.  Operational Address Pairs
  - contents:
    - "3.4.  Primary Address Pair\n   The primary address pair consists of the addresses
      that upper-layer\n   protocols use in their interaction with the Shim6 layer.
      \ Use of the\n   primary address pair means that the communication is compatible
      with\n   regular non-Shim6 communication and that no context tag needs to be\n
      \  present.\n"
    title: 3.4.  Primary Address Pair
  - contents:
    - "3.5.  Current Address Pair\n   Shim6 needs to avoid sending packets that belong
      to the same\n   transport connection concurrently over multiple paths.  This
      is\n   because congestion control in commonly used transport protocols is\n
      \  based upon a notion of a single path.  While routing can introduce\n   path
      changes as well and transport protocols have means to deal with\n   this, frequent
      changes will cause problems.  Effective congestion\n   control over multiple
      paths is considered a research topic at the\n   time of publication of this
      document.  Shim6 does not attempt to\n   employ multiple paths simultaneously.\n
      \     Note: The Stream Control Transmission Protocol (SCTP) and future\n      multipath
      transport protocols are likely to require interaction\n      with Shim6, at
      least to ensure that they do not employ Shim6\n      unexpectedly.\n   For these
      reasons, it is necessary to choose a particular pair of\n   addresses as the
      current address pair that will be used until\n   problems occur, at least for
      the same session.\n      It is theoretically possible to support multiple current
      address\n      pairs for different transport sessions or Shim6 contexts.\n      However,
      this is not supported in this version of the Shim6\n      protocol.\n   A current
      address pair need not be operational at all times.  If\n   there is no traffic
      to send, we may not know if the current address\n   pair is operational.  Nevertheless,
      it makes sense to assume that the\n   address pair that worked previously continues
      to be operational for\n   new communications as well.\n"
    title: 3.5.  Current Address Pair
  title: 3.  Definitions
- contents:
  - "4.  Protocol Overview\n   This section discusses the design of the reachability
    detection and\n   full reachability exploration mechanisms, and gives an overview
    of\n   the REAP protocol.\n   Exploring the full set of communication options
    between two nodes\n   that both have two or more addresses is an expensive operation
    as the\n   number of combinations to be explored increases very quickly with the\n
    \  number of addresses.  For instance, with two addresses on both sides,\n   there
    are four possible address pairs.  Since we can't assume that\n   reachability
    in one direction automatically means reachability for\n   the complement pair
    in the other direction, the total number of two-\n   way combinations is eight.
    \ (Combinations = nA * nB * 2.)\n   An important observation in multihoming is
    that failures are\n   relatively infrequent, so an operational pair that worked
    a few\n   seconds ago is very likely to still be operational.  Thus, it makes\n
    \  sense to have a lightweight protocol that confirms existing\n   reachability,
    and to only invoke heavier exploration mechanism when\n   there is a suspected
    failure.\n"
  - contents:
    - "4.1.  Failure Detection\n   Failure detection consists of three parts: tracking
      local\n   information, tracking remote peer status, and finally verifying\n
      \  reachability.  Tracking local information consists of using, for\n   instance,
      reachability information about the local router as an\n   input.  Nodes SHOULD
      employ techniques listed in Sections 3.1 and 3.2\n   to track the local situation.
      \ It is also necessary to track remote\n   address information from the peer.
      \ For instance, if the peer's\n   address in the current address pair is no
      longer locally operational,\n   a mechanism to relay that information is needed.
      \ The Update Request\n   message in the Shim6 protocol is used for this purpose
      [RFC5533].\n   Finally, when the local and remote information indicates that\n
      \  communication should be possible and there are upper-layer packets to\n   be
      sent, reachability verification is necessary to ensure that the\n   peers actually
      have an operational address pair.\n   A technique called Forced Bidirectional
      Detection (FBD) is employed\n   for the reachability verification.  Reachability
      for the currently\n   used address pair in a Shim6 context is determined by
      making sure\n   that whenever there is payload traffic in one direction, there
      is\n   also traffic in the other direction.  This can be data traffic as\n   well,
      or it may be transport-layer acknowledgments or a REAP\n   reachability keepalive
      if there is no other traffic.  This way, it is\n   no longer possible to have
      traffic in only one direction; so whenever\n   there is payload traffic going
      out, but there are no return packets,\n   there must be a failure, and the full
      exploration mechanism is\n   started.\n   A more detailed description of the
      current pair-reachability\n   evaluation mechanism:\n   1.  To prevent the other
      side from concluding that there is a\n       reachability failure, it's necessary
      for a node implementing the\n       failure-detection mechanism to generate
      periodic keepalives when\n       there is no other traffic.\n       FBD works
      by generating REAP keepalives if the node is receiving\n       packets from
      its peer but not sending any of its own.  The\n       keepalives are sent at
      certain intervals so that the other side\n       knows there is a reachability
      problem when it doesn't receive any\n       incoming packets for the duration
      of a Send Timeout period.  The\n       node communicates its Send Timeout value
      to the peer as a\n       Keepalive Timeout Option (Section 5.3) in the I2, I2bis,
      R2, or\n       UPDATE messages.  The peer then maps this value to its Keepalive\n
      \      Timeout value.\n       The interval after which keepalives are sent is
      named the\n       Keepalive Interval.  The RECOMMENDED approach for the Keepalive\n
      \      Interval is to send keepalives at one-half to one-third of the\n       Keepalive
      Timeout interval, so that multiple keepalives are\n       generated and have
      time to reach the peer before it times out.\n   2.  Whenever outgoing payload
      packets are generated, a timer is\n       started to reflect the requirement
      that the peer should generate\n       return traffic from payload packets.  The
      timeout value is set to\n       the value of Send Timeout.\n       For the purposes
      of this specification, \"payload packet\" refers\n       to any packet that
      is part of a Shim6 context, including both\n       upper-layer protocol packets
      and Shim6 protocol messages, except\n       those defined in this specification.
      \ For the latter messages,\n       Section 6 specifies what happens to the timers
      when a message is\n       transmitted or received.\n   3.  Whenever incoming
      payload packets are received, the timer\n       associated with the return traffic
      from the peer is stopped, and\n       another timer is started to reflect the
      requirement for this node\n       to generate return traffic.  This timeout
      value is set to the\n       value of Keepalive Timeout.\n       These two timers
      are mutually exclusive.  In other words, either\n       the node is expecting
      to see traffic from the peer based on the\n       traffic that the node sent
      earlier or the node is expecting to\n       respond to the peer based on the
      traffic that the peer sent\n       earlier (otherwise, the node is in an idle
      state).\n   4.  The reception of a REAP Keepalive message leads to stopping
      the\n       timer associated with the return traffic from the peer.\n   5.  Keepalive
      Interval seconds after the last payload packet has been\n       received for
      a context, if no other packet has been sent within\n       this context since
      the payload packet has been received, a REAP\n       Keepalive message is generated
      for the context in question and\n       transmitted to the peer.  A node may
      send the keepalive sooner\n       than Keepalive Interval seconds if implementation
      considerations\n       warrant this, but should take care to avoid sending keepalives
      at\n       an excessive rate.  REAP Keepalive messages SHOULD continue to be\n
      \      sent at the Keepalive Interval until either a payload packet in\n       the
      Shim6 context has been received from the peer or the\n       Keepalive Timeout
      expires.  Keepalives are not sent at all if one\n       or more payload packets
      were sent within the Keepalive Interval.\n   6.  Send Timeout seconds after
      the transmission of a payload packet\n       with no return traffic on this
      context, a full reachability\n       exploration is started.\n   Section 7 provides
      some suggested defaults for these timeout values.\n   The actual value SHOULD
      be randomized in order to prevent\n   synchronization.  Experience from the
      deployment of the Shim6\n   protocol is needed in order to determine what values
      are most\n   suitable.\n"
    title: 4.1.  Failure Detection
  - contents:
    - "4.2.  Full Reachability Exploration\n   As explained in previous sections,
      the currently used address pair\n   may become invalid, either through one of
      the addresses becoming\n   unavailable or nonoperational or through the pair
      itself being\n   declared nonoperational.  An exploration process attempts to
      find\n   another operational pair so that communications can resume.\n   What
      makes this process hard is the requirement to support\n   unidirectionally operational
      address pairs.  It is insufficient to\n   probe address pairs by a simple request-response
      protocol.  Instead,\n   the party that first detects the problem starts a process
      where it\n   tries each of the different address pairs in turn by sending a\n
      \  message to its peer.  These messages carry information about the\n   state
      of connectivity between the peers, such as whether the sender\n   has seen any
      traffic from the peer recently.  When the peer receives\n   a message that indicates
      a problem, it assists the process by\n   starting its own parallel exploration
      to the other direction, again\n   sending information about the recently received
      payload traffic or\n   signaling messages.\n   Specifically, when A decides
      that it needs to explore for an\n   alternative address pair to B, it will initiate
      a set of Probe\n   messages, in sequence, until it gets a Probe message from
      B\n   indicating that (a) B has received one of A's messages and,\n   obviously,
      (b) that B's Probe message gets back to A.  B uses the\n   same algorithm, but
      starts the process from the reception of the\n   first Probe message from A.\n
      \  Upon changing to a new address pair, the network path traversed most\n   likely
      has changed, so the upper-layer protocol (ULP), SHOULD be\n   informed.  This
      can be a signal for the ULP to adapt, due to the\n   change in path, so that
      for example, if the ULP is TCP, it could\n   initiate a slow start procedure.
      \ However, it's likely that the\n   circumstances that led to the selection
      of a new path already caused\n   enough packet loss to trigger slow start.\n
      \  REAP is designed to support failure recovery even in the case of\n   having
      only unidirectionally operational address pairs.  However, due\n   to security
      concerns discussed in Section 8, the exploration process\n   can typically be
      run only for a session that has already been\n   established.  Specifically,
      while REAP would in theory be capable of\n   exploration even during connection
      establishment, its use within the\n   Shim6 protocol does not allow this.\n"
    title: 4.2.  Full Reachability Exploration
  - contents:
    - "4.3.  Exploration Order\n   The exploration process assumes an ability to choose
      address pairs\n   for testing.  An overview of the choosing process used by
      REAP is as\n   follows:\n   o  As an input to start the process, the node has
      knowledge of its\n      own addresses and has been told via Shim6 protocol messages
      what\n      the addresses of the peer are.  A list of possible pairs of\n      addresses
      can be constructed by combining the two pieces of\n      information.\n   o
      \ By employing standard IPv6 address selection rules, the list is\n      pruned
      by removing combinations that are inappropriate, such as\n      attempting to
      use a link-local address when contacting a peer that\n      uses a global unicast
      address.\n   o  Similarly, standard IPv6 address selection rules provide a basic\n
      \     priority order for the pairs.\n   o  Local preferences may be applied
      for some additional tuning of the\n      order in the list.  The mechanisms
      for local preference settings\n      are not specified but can involve, for
      instance, configuration\n      that sets the preference for using one interface
      over another.\n   o  As a result, the node has a prioritized list of address
      pairs to\n      try.  However, the list may still be long, as there may be a\n
      \     combinatorial explosion when there are many addresses on both\n      sides.
      \ REAP employs these pairs sequentially, however, and uses a\n      back-off
      procedure to avoid a \"signaling storm\".  This ensures\n      that the exploration
      process is relatively conservative or \"safe\".\n      The tradeoff is that
      finding a working path may take time if there\n      are many addresses on both
      sides.\n   In more detail, the process is as follows.  Nodes first consult the\n
      \  RFC 3484 default address selection rules [RFC3484] to determine what\n   combinations
      of addresses are allowed from a local point of view, as\n   this reduces the
      search space.  RFC 3484 also provides a priority\n   ordering among different
      address pairs, possibly making the search\n   faster.  (Additional mechanisms
      may be defined in the future for\n   arriving at an initial ordering of address
      pairs before testing\n   starts [PAIR].)  Nodes may also use local information,
      such as known\n   quality of service parameters or interface types, to determine
      what\n   addresses are preferred over others, and try pairs containing such\n
      \  addresses first.  The Shim6 protocol also carries preference\n   information
      in its messages.\n   Out of the set of possible candidate address pairs, nodes
      SHOULD\n   attempt to test through all of them until an operational pair is\n
      \  found, and retry the process as necessary.  However, all nodes MUST\n   perform
      this process sequentially and with exponential back-off.\n   This sequential
      process is necessary in order to avoid a \"signaling\n   storm\" when an outage
      occurs (particularly for a complete site).\n   However, it also limits the number
      of addresses that can, in\n   practice, be used for multihoming, considering
      that transport- and\n   application-layer protocols will fail if the switch
      to a new address\n   pair takes too long.\n   Section 7 suggests default values
      for the timers associated with the\n   exploration process.  The value Initial
      Probe Timeout (0.5 seconds)\n   specifies the interval between initial attempts
      to send probes; the\n   Number of Initial Probes (4) specifies how many initial
      probes can be\n   sent before the exponential back-off procedure needs to be
      employed.\n   This process increases the time between every probe if there is
      no\n   response.  Typically, each increase doubles the time, but this\n   specification
      does not mandate a particular increase.\n      Note: The rationale for sending
      four packets at a fixed rate\n      before the exponential back-off is employed
      is to avoid having to\n      send these packets excessively fast.  Without this,
      having 0.5\n      seconds between the third and fourth probe means that the
      time\n      between the first and second probe would have to be 0.125 seconds,\n
      \     which gives very little time for a reply to the first packet to\n      arrive.
      \ Also, this means that the first four packets are sent\n      within 0.875
      seconds rather than 2 seconds, increasing the\n      potential for congestion
      if a large number of Shim6 contexts need\n      to send probes at the same time
      after a failure.\n   Finally, Max Probe Timeout (60 seconds) specifies a limit
      beyond\n   which the probe interval may not grow.  If the exploration process\n
      \  reaches this interval, it will continue sending at this rate until a\n   suitable
      response is triggered or the Shim6 context is garbage\n   collected, because
      upper-layer protocols using the Shim6 context in\n   question are no longer
      attempting to send packets.  Reaching the Max\n   Probe Timeout may also serve
      as a hint to the garbage collection\n   process that the context is no longer
      usable.\n"
    title: 4.3.  Exploration Order
  title: 4.  Protocol Overview
- contents:
  - '5.  Protocol Definition

    '
  - contents:
    - "5.1.  Keepalive Message\n   The format of the Keepalive message is as follows:\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  Next Header  |  Hdr Ext Len  |0|  Type = 66  |  Reserved1  |0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |            Checksum           |R|                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                            |\n   |                    Receiver Context Tag
      \                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                           Reserved2                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   +                            Options
      \                           +\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Next
      Header, Hdr Ext Len, 0, 0, Checksum\n      These are as specified in Section
      5.3 of the Shim6 protocol\n      description [RFC5533].\n   Type\n      This
      field identifies the Keepalive message and MUST be set to 66\n      (Keepalive).\n
      \  Reserved1\n      This is a 7-bit field reserved for future use.  It is set
      to zero\n      on transmit and MUST be ignored on receipt.\n   R\n      This
      is a 1-bit field reserved for future use.  It is set to zero\n      on transmit
      and MUST be ignored on receipt.\n   Receiver Context Tag\n      This is a 47-bit
      field for the context tag that the receiver has\n      allocated for the context.\n
      \  Reserved2\n      This is a 32-bit field reserved for future use.  It is set
      to zero\n      on transmit and MUST be ignored on receipt.\n   Options\n      This
      field MAY contain one or more Shim6 options.  However, there\n      are currently
      no defined options that are useful in a Keepalive\n      message.  The Options
      field is provided only for future\n      extensibility reasons.\n   A valid
      message conforms to the format above, has a Receiver Context\n   Tag that matches
      the context known by the receiver, is a valid Shim6\n   control message as defined
      in Section 12.3 of the Shim6 protocol\n   description [RFC5533], and has a Shim6
      context that is in state\n   ESTABLISHED.  The receiver processes a valid message
      by inspecting\n   its options and executing any actions specified for such options.\n
      \  The processing rules for this message are given in more detail in\n   Section
      6.\n"
    title: 5.1.  Keepalive Message
  - contents:
    - "5.2.  Probe Message\n   This message performs REAP exploration.  Its format
      is as follows:\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  Next Header  |  Hdr Ext Len  |0|  Type = 67  |   Reserved  |0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |            Checksum           |R|                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                            |\n   |                    Receiver Context Tag
      \                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | Precvd| Psent |Sta|                 Reserved2                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   +                      First
      probe sent                         +\n   |                                                               |\n
      \  +                      Source address                           +\n   |                                                               |\n
      \  +                                                               +\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n
      \  +                      First probe sent                         +\n   |                                                               |\n
      \  +                      Destination address                      +\n   |                                                               |\n
      \  +                                                               +\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                      First
      Probe Nonce                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                      First Probe Data                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  /                                                               /\n   /                      Nth
      probe sent                           /\n   |                                                               |\n
      \  +                      Source address                           +\n   |                                                               |\n
      \  +                                                               +\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n
      \  +                      Nth probe sent                           +\n   |                                                               |\n
      \  +                      Destination address                      +\n   |                                                               |\n
      \  +                                                               +\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                      Nth
      Probe Nonce                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                      Nth Probe Data                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   +                      First
      probe received                     +\n   |                                                               |\n
      \  +                      Source address                           +\n   |                                                               |\n
      \  +                                                               +\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n
      \  +                      First probe received                     +\n   |                                                               |\n
      \  +                      Destination address                      +\n   |                                                               |\n
      \  +                                                               +\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                      First
      Probe Nonce                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                      First Probe Data                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   +                      Nth
      probe received                       +\n   |                                                               |\n
      \  +                      Source address                           +\n   |                                                               |\n
      \  +                                                               +\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n
      \  +                      Nth probe received                       +\n   |                                                               |\n
      \  +                      Destination address                      +\n   |                                                               |\n
      \  +                                                               +\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                      Nth
      Probe Nonce                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                      Nth Probe Data                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  //                         Options                             //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Next Header, Hdr Ext Len, 0, 0, Checksum\n      These are as specified in
      Section 5.3 of the Shim6 protocol\n      description [RFC5533].\n   Type\n      This
      field identifies the Probe message and MUST be set to 67\n      (Probe).\n   Reserved\n
      \     This is a 7-bit field reserved for future use.  It is set to zero\n      on
      transmit and MUST be ignored on receipt.\n   R\n      This is a 1-bit field
      reserved for future use.  It is set to zero\n      on transmit and MUST be ignored
      on receipt.\n   Receiver Context Tag\n      This is a 47-bit field for the context
      tag that the receiver has\n      allocated for the context.\n   Psent\n      This
      is a 4-bit field that indicates the number of sent probes\n      included in
      this Probe message.  The first set of Probe fields\n      pertains to the current
      message and MUST be present, so the\n      minimum value for this field is 1.
      \ Additional sent Probe fields\n      are copies of the same fields sent in
      (recent) earlier probes and\n      may be included or omitted as per any logic
      employed by the\n      implementation.\n   Precvd\n      This is a 4-bit field
      that indicates the number of received probes\n      included in this Probe message.
      \ Received Probe fields are copies\n      of the same fields in earlier received
      probes that arrived since\n      the last transition to state Exploring.  When
      a sender is in state\n      InboundOk it MUST include copies of the fields of
      at least one of\n      the inbound probes.  A sender MAY include additional
      sets of these\n      received Probe fields in any state as per any logic employed
      by\n      the implementation.\n      The fields Probe Source, Probe Destination,
      Probe Nonce, and Probe\n      Data may be repeated, depending on the value of
      Psent and\n      Preceived.\n   Sta (State)\n      This 2-bit State field is
      used to inform the peer about the state\n      of the sender.  It has three
      legal values:\n      0 (Operational) implies that the sender both (a) believes
      it has\n      no problem communicating and (b) believes that the recipient also\n
      \     has no problem communicating.\n      1 (Exploring) implies that the sender
      has a problem communicating\n      with the recipient, e.g., it has not seen
      any traffic from the\n      recipient even when it expected some.\n      2 (InboundOk)
      implies that the sender believes it has no problem\n      communicating, i.e.,
      it at least sees packets from the recipient\n      but that the recipient either
      has a problem or has not yet\n      confirmed to the sender that the problem
      has been resolved.\n   Reserved2\n      MUST be set to zero upon transmission
      and MUST be ignored upon\n      reception.\n   Probe Source\n      This 128-bit
      field contains the source IPv6 address used to send\n      the probe.\n   Probe
      Destination\n      This 128-bit field contains the destination IPv6 address
      used to\n      send the probe.\n   Probe Nonce\n      This is a 32-bit field
      that is initialized by the sender with a\n      value that allows it to determine
      with which sent probes a\n      received probe correlates.  It is highly RECOMMENDED
      that the\n      Nonce field be at least moderately hard to guess so that even
      on-\n      path attackers can't deduce the next nonce value that will be\n      used.
      \ This value SHOULD be generated using a random number\n      generator that
      is known to have good randomness properties as\n      outlined in RFC 4086 [RFC4086].\n
      \  Probe Data\n      This is a 32-bit field with no fixed meaning.  The Probe
      Data\n      field is copied back with no changes.  Future flags may define a\n
      \     use for this field.\n   Options\n      For future extensions.\n"
    title: 5.2.  Probe Message
  - contents:
    - "5.3.  Keepalive Timeout Option Format\n   Either side of a Shim6 context can
      notify the peer of the value that\n   it would prefer the peer to use as its
      Keepalive Timeout value.  If\n   the node is using a non-default Send Timeout
      value, it MUST\n   communicate this value as a Keepalive Timeout value to the
      peer in\n   the below option.  This option MAY be sent in the I2, I2bis, R2,
      or\n   UPDATE messages.  The option SHOULD only need to be sent once in a\n
      \  given Shim6 association.  If a node receives this option, it SHOULD\n   update
      its Keepalive Timeout value for the peer.\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |           Type = 10         |0|        Length  = 4            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  +           Reserved            |      Keepalive Timeout        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Fields:\n   Type\n      This field identifies the option and MUST be set
      to 10 (Keepalive\n      Timeout).\n   Length\n      This field MUST be set as
      specified in Section 5.1 of the Shim6\n      protocol description [RFC5533]
      -- that is, set to 4.\n   Reserved\n      A 16-bit field reserved for future
      use.  It is set to zero upon\n      transmit and MUST be ignored upon receipt.\n
      \  Keepalive Timeout\n      The value in seconds corresponding to the suggested
      Keepalive\n      Timeout value for the peer.\n"
    title: 5.3.  Keepalive Timeout Option Format
  title: 5.  Protocol Definition
- contents:
  - "6.  Behavior\n   The required behavior of REAP nodes is specified below in the
    form of\n   a state machine.  The externally observable behavior of an\n   implementation
    MUST conform to this state machine, but there is no\n   requirement that the implementation
    actually employ a state machine.\n   Intermixed with the following description,
    we also provide a state\n   machine description in tabular form.  However, that
    form is only\n   informational.\n   On a given context with a given peer, the
    node can be in one of three\n   states: Operational, Exploring, or InboundOK.
    \ In the Operational\n   state, the underlying address pairs are assumed to be
    operational.\n   In the Exploring state, this node hasn't seen any traffic from
    the\n   peer for more than a Send Timer period.  Finally, in the InboundOK\n   state,
    this node sees traffic from the peer, but the peer may not yet\n   see any traffic
    from this node, so the exploration process needs to\n   continue.\n   The node
    also maintains the Send Timer (Send Timeout seconds) and\n   Keepalive Timer (Keepalive
    Timeout seconds).  The Send Timer reflects\n   the requirement that when this
    node sends a payload packet, there\n   should be some return traffic (either payload
    packets or Keepalive\n   messages) within Send Timeout seconds.  The Keepalive
    Timer reflects\n   the requirement that when this node receives a payload packet,
    there\n   should a similar response towards the peer.  The Keepalive Timer is\n
    \  only used within the Operational state, and the Send Timer within the\n   Operational
    and InboundOK states.  No timer is running in the\n   Exploring state.  As explained
    in Section 4.1, the two timers are\n   mutually exclusive.  That is, either the
    Keepalive Timer or the Send\n   Timer is running, or neither of them is running.\n
    \  Note that Appendix A gives some examples of typical protocol runs in\n   order
    to illustrate the behavior.\n"
  - contents:
    - "6.1.  Incoming Payload Packet\n   Upon the reception of a payload packet in
      the Operational state, the\n   node starts the Keepalive Timer if it was not
      yet running, and stops\n   the Send Timer if it was running.\n   If the node
      is in the Exploring state, it transitions to the\n   InboundOK state, sends
      a Probe message, and starts the Send Timer.\n   It fills the Psent and corresponding
      Probe Source Address, Probe\n   Destination Address, Probe Nonce, and Probe
      Data fields with\n   information about recent Probe messages that have not yet
      been\n   reported as seen by the peer.  It also fills the Precvd and\n   corresponding
      Probe Source Address, Probe Destination Address, Probe\n   Nonce, and Probe
      Data fields with information about recent Probe\n   messages it has seen from
      the peer.  When sending a Probe message,\n   the State field MUST be set to
      a value that matches the conceptual\n   state of the sender after sending the
      Probe.  In this case, the node\n   therefore sets the State field to 2 (InboundOk).
      \ The IP source and\n   destination addresses for sending the Probe message
      are selected as\n   discussed in Section 4.3.\n   In the InboundOK state, the
      node stops the Send Timer if it was\n   running, but does not do anything else.\n
      \  The reception of Shim6 control messages other than the Keepalive and\n   Probe
      messages are treated the same as the reception of payload\n   packets.\n   While
      the Keepalive Timer is running, the node SHOULD send Keepalive\n   messages
      to the peer with an interval of Keepalive Interval seconds.\n   Conceptually,
      a separate timer is used to distinguish between the\n   interval between Keepalive
      messages and the overall Keepalive Timeout\n   interval.  However, this separate
      timer is not modelled in the\n   tabular or graphical state machines.  When
      sent, the Keepalive\n   message is constructed as described in Section 5.1.
      \ It is sent using\n   the current address pair.\n   In the below tables, \"START\",
      \"RESTART\", and \"STOP\" refer to\n   starting, restarting, and stopping the
      Keepalive Timer or the Send\n   Timer, respectively.  \"GOTO\" refers to transitioning
      to another\n   state.  \"SEND\" refers to sending a message, and \"-\" refers
      to taking\n   no action.\n    Operational           Exploring               InboundOk\n
      \   --------------------------------------------------------------------\n    STOP
      Send             SEND Probe InboundOk    STOP Send\n    START Keepalive       START
      Send\n                          GOTO InboundOk\n"
    title: 6.1.  Incoming Payload Packet
  - contents:
    - "6.2.  Outgoing Payload Packet\n   Upon sending a payload packet in the Operational
      state, the node\n   stops the Keepalive Timer if it was running and starts the
      Send Timer\n   if it was not running.  In the Exploring state there is no effect,\n
      \  and in the InboundOK state the node simply starts the Send Timer if\n   it
      was not yet running.  (The sending of Shim6 control messages is\n   again treated
      the same.)\n     Operational             Exploring             InboundOk\n     ------------------------------------------------------------------\n
      \    START Send              -                     START Send\n     STOP Keepalive\n"
    title: 6.2.  Outgoing Payload Packet
  - contents:
    - "6.3.  Keepalive Timeout\n   Upon a timeout on the Keepalive Timer, the node
      sends one last\n   Keepalive message.  This can only happen in the Operational
      state.\n   The Keepalive message is constructed as described in Section 5.1.
      \ It\n   is sent using the current address pair.\n     Operational             Exploring
      \            InboundOk\n     ------------------------------------------------------------------\n
      \    SEND Keepalive          -                     -\n"
    title: 6.3.  Keepalive Timeout
  - contents:
    - "6.4.  Send Timeout\n   Upon a timeout on the Send Timer, the node enters the
      Exploring state\n   and sends a Probe message.  The Probe message is constructed
      as\n   explained in Section 6.1, except that the State field is set to 1\n   (Exploring).\n
      \    Operational             Exploring             InboundOk\n     ------------------------------------------------------------------\n
      \    SEND Probe Exploring    -                     SEND Probe Exploring\n     GOTO
      Exploring                                GOTO Exploring\n"
    title: 6.4.  Send Timeout
  - contents:
    - "6.5.  Retransmission\n   While in the Exploring state, the node keeps retransmitting
      its Probe\n   messages to different (or the same) addresses as defined in\n
      \  Section 4.3.  A similar process is employed in the InboundOk state,\n   except
      that upon such retransmission, the Send Timer is started if it\n   was not running
      already.\n   The Probe messages are constructed as explained in Section 6.1,\n
      \  except that the State field is set to 1 (Exploring) or 2 (InboundOk),\n   depending
      on which state the sender is in.\n     Operational            Exploring             InboundOk\n
      \    -----------------------------------------------------------------\n     -
      \                     SEND Probe Exploring  SEND Probe InboundOk\n                                                  START
      Send\n"
    title: 6.5.  Retransmission
  - contents:
    - "6.6.  Reception of the Keepalive Message\n   Upon the reception of a Keepalive
      message in the Operational state,\n   the node stops the Send Timer if it was
      running.  If the node is in\n   the Exploring state, it transitions to the InboundOK
      state, sends a\n   Probe message, and starts the Send Timer.  The Probe message
      is\n   constructed as explained in Section 6.1.\n   In the InboundOK state,
      the Send Timer is stopped if it was running.\n     Operational           Exploring
      \              InboundOk\n     ------------------------------------------------------------------\n
      \    STOP Send             SEND Probe InboundOk    STOP Send\n                           START
      Send\n                           GOTO InboundOk\n"
    title: 6.6.  Reception of the Keepalive Message
  - contents:
    - "6.7.  Reception of the Probe Message State=Exploring\n   Upon receiving a Probe
      message with State set to Exploring, the node\n   enters the InboundOK state,
      sends a Probe message as described in\n   Section 6.1, stops the Keepalive Timer
      if it was running, and\n   restarts the Send Timer.\n     Operational            Exploring
      \             InboundOk\n     ------------------------------------------------------------------\n
      \    SEND Probe InboundOk   SEND Probe InboundOk   SEND Probe InboundOk\n     STOP
      Keepalive         START Send             RESTART Send\n     RESTART Send           GOTO
      InboundOk\n     GOTO InboundOk\n"
    title: 6.7.  Reception of the Probe Message State=Exploring
  - contents:
    - "6.8.  Reception of the Probe Message State=InboundOk\n   Upon the reception
      of a Probe message with State set to InboundOk,\n   the node sends a Probe message,
      restarts the Send Timer, stops the\n   Keepalive Timer if it was running, and
      transitions to the Operational\n   state.  A new current address pair is chosen
      for the connection,\n   based on the reports of received probes in the message
      that we just\n   received.  If no received probes have been reported, the current\n
      \  address pair is unchanged.\n   The Probe message is constructed as explained
      in Section 6.1, except\n   that the State field is set to zero (Operational).\n
      \   Operational            Exploring              InboundOk\n    --------------------------------------------------------------------\n
      \   SEND Probe Operational SEND Probe Operational SEND Probe Operational\n    RESTART
      Send           RESTART Send           RESTART Send\n    STOP Keepalive         GOTO
      Operational       GOTO Operational\n"
    title: 6.8.  Reception of the Probe Message State=InboundOk
  - contents:
    - "6.9.  Reception of the Probe Message State=Operational\n   Upon the reception
      of a Probe message with State set to Operational,\n   the node stops the Send
      Timer if it was running, starts the Keepalive\n   Timer if it was not yet running,
      and transitions to the Operational\n   state.  The Probe message is constructed
      as explained in Section 6.1,\n   except that the State field is set to zero
      (Operational).\n      Note: This terminates the exploration process when both
      parties\n      are happy and know that their peer is happy as well.\n     Operational
      \            Exploring             InboundOk\n     ------------------------------------------------------------------\n
      \    STOP Send               STOP Send             STOP Send\n     START Keepalive
      \        START Keepalive       START Keepalive\n                             GOTO
      Operational      GOTO Operational\n   The reachability detection and exploration
      process has no effect on\n   payload communications until a new operational
      address pair has\n   actually been confirmed.  Prior to that, the payload packets
      continue\n   to be sent to the previously used addresses.\n"
    title: 6.9.  Reception of the Probe Message State=Operational
  - contents:
    - "6.10.  Graphical Representation of the State Machine\n   In the PDF version
      of this specification, an informational drawing\n   illustrates the state machine.
      \ Where the text and the drawing\n   differ, the text takes precedence.\n"
    title: 6.10.  Graphical Representation of the State Machine
  title: 6.  Behavior
- contents:
  - "7.  Protocol Constants and Variables\n   The following protocol constants are
    defined:\n     Initial Probe Timeout      0.5 seconds\n     Number of Initial
    Probes     4 probes\n   And these variables have the following default values:\n
    \    Send Timeout                15 seconds\n     Keepalive Timeout            X
    seconds, where X is the peer's\n                                    Send Timeout
    as communicated in\n                                    the Keepalive Timeout
    Option\n                                 15 seconds if the peer didn't send\n
    \                                   a Keepalive Timeout option\n     Keepalive
    Interval           Y seconds, where Y is one-third to\n                                    one-half
    of the Keepalive Timeout\n                                    value (see Section
    4.1)\n   Alternate values of the Send Timeout may be selected by a node and\n
    \  communicated to the peer in the Keepalive Timeout Option.  A very\n   small
    value of the Send Timeout may affect the ability to exchange\n   keepalives over
    a path that has a long roundtrip delay.  Similarly,\n   it may cause Shim6 to
    react to temporary failures more often than\n   necessary.  As a result, it is
    RECOMMENDED that an alternate Send\n   Timeout value not be under 10 seconds.
    \ Choosing a higher value than\n   the one recommended above is also possible,
    but there is a\n   relationship between Send Timeout and the ability of REAP to
    discover\n   and correct errors in the communication path.  In any case, in order\n
    \  for Shim6 to be useful, it should detect and repair communication\n   problems
    long before upper layers give up.  For this reason, it is\n   RECOMMENDED that
    Send Timeout be at most 100 seconds (default TCP R2\n   timeout [RFC1122]).\n
    \     Note: It is not expected that the Send Timeout or other values\n      will
    be estimated based on experienced roundtrip times.  Signaling\n      exchanges
    are performed based on exponential back-off.  The\n      keepalive processes send
    packets only in the relatively rare\n      condition that all traffic is unidirectional.\n"
  title: 7.  Protocol Constants and Variables
- contents:
  - "8.  Security Considerations\n   Attackers may spoof various indications from
    lower layers and from\n   the network in an effort to confuse the peers about
    which addresses\n   are or are not operational.  For example, attackers may spoof
    ICMP\n   error messages in an effort to cause the parties to move their\n   traffic
    elsewhere or even to disconnect.  Attackers may also spoof\n   information related
    to network attachments, Router Discovery, and\n   address assignments in an effort
    to make the parties believe they\n   have Internet connectivity when in reality
    they do not.\n   This may cause use of non-preferred addresses or even denial
    of\n   service.\n   This protocol does not provide any protection of its own for\n
    \  indications from other parts of the protocol stack.  Unprotected\n   indications
    SHOULD NOT be taken as a proof of connectivity problems.\n   However, REAP has
    weak resistance against incorrect information even\n   from unprotected indications
    in the sense that it performs its own\n   tests prior to picking a new address
    pair.  Denial-of-service\n   vulnerabilities remain, however, as do vulnerabilities
    against on-\n   path attackers.\n   Some aspects of these vulnerabilities can
    be mitigated through the\n   use of techniques specific to the other parts of
    the stack, such as\n   properly dealing with ICMP errors [GONT], link-layer security,
    or the\n   use of SEND [RFC3971] to protect IPv6 Router and Neighbor Discovery.\n
    \  Other parts of the Shim6 protocol ensure that the set of addresses we\n   are
    switching between actually belong together.  REAP itself provides\n   no such
    assurances.  Similarly, REAP provides some protection against\n   third-party
    flooding attacks [AURA02]; when REAP is run, its Probe\n   Nonces can be used
    as a return routability check that the claimed\n   address is indeed willing to
    receive traffic.  However, this needs to\n   be complemented with another mechanism
    to ensure that the claimed\n   address is also the correct node.  Shim6 does this
    by performing\n   binding of all operations to context tags.\n   The keepalive
    mechanism in this specification is vulnerable to\n   spoofing.  On-path attackers
    that can see a Shim6 context tag can\n   send spoofed Keepalive messages once
    per Send Timeout interval in\n   order to prevent two Shim6 nodes from sending
    Keepalives themselves.\n   This vulnerability is only relevant to nodes involved
    in a one-way\n   communication.  The result of the attack is that the nodes enter
    the\n   exploration phase needlessly, but they should be able to confirm\n   connectivity
    unless, of course, the attacker is able to prevent the\n   exploration phase from
    completing.  Off-path attackers may not be\n   able to generate spoofed results,
    given that the context tags are 47-\n   bit random numbers.\n   To protect against
    spoofed Keepalive messages, a node implementing\n   both Shim6 and IPsec MAY ignore
    incoming REAP keepalives if it has\n   good reason to assume that the other side
    will be sending IPsec-\n   protected return traffic.  In other words, if a node
    is sending TCP\n   payload data, it can reasonably expect to receive TCP ACKs
    in return.\n   If no IPsec-protected ACKs come back but unprotected keepalives
    do,\n   this could be the result of an attacker trying to hide broken\n   connectivity.\n
    \  The exploration phase is vulnerable to attackers that are on the\n   path.
    \ Off-path attackers would find it hard to guess either the\n   context tag or
    the correct probe identifiers.  Given that IPsec\n   operates above the Shim6
    layer, it is not possible to protect the\n   exploration phase against on-path
    attackers with IPsec.  This is\n   similar to the issues with protecting other
    Shim6 control exchanges.\n   There are mechanisms in place to prevent the redirection
    of\n   communications to wrong addresses, but on-path attackers can cause\n   denial-of-service,
    move communications to less-preferred address\n   pairs, and so on.\n   Finally,
    the exploration itself can cause a number of packets to be\n   sent.  As a result,
    it may be used as a tool for packet amplification\n   in flooding attacks.  It
    is required that the protocol employing REAP\n   has built-in mechanisms to prevent
    this.  For instance, Shim6\n   contexts are created only after a relatively large
    number of packets\n   have been exchanged, a cost that reduces the attractiveness
    of using\n   Shim6 and REAP for amplification attacks.  However, such protections\n
    \  are typically not present at connection-establishment time.  When\n   exploration
    would be needed for connection establishment to succeed,\n   its usage would result
    in an amplification vulnerability.  As a\n   result, Shim6 does not support the
    use of REAP in the connection-\n   establishment stage.\n"
  title: 8.  Security Considerations
- contents:
  - "9.  Operational Considerations\n   When there are no failures, the failure-detection
    mechanism (and\n   Shim6 in general) are lightweight: keepalives are not sent
    when a\n   Shim6 context is idle or when there is traffic in both directions.\n
    \  So in normal TCP or TCP-like operations, there would only be one or\n   two
    keepalives when a session transitions from active to idle.\n   Only when there
    are failures is there significant failure-detection\n   traffic, especially in
    the case where a link goes down that is shared\n   by many active sessions and
    by multiple nodes.  When this happens,\n   one keepalive is sent and then a series
    of probes.  This happens per\n   active (traffic-generating) context, all of which
    will time out\n   within 15 seconds after the failure.  This makes the peak traffic\n
    \  that Shim6 generates after a failure around one packet per second per\n   context.
    \ Presumably, the sessions that run over those contexts were\n   sending at least
    that much traffic and most likely more, but if the\n   backup path is significantly
    lower bandwidth than the failed path,\n   this could lead to temporary congestion.\n
    \     However, note that in the case of multihoming using BGP, if the\n      failover
    is fast enough that TCP doesn't go into slow start, the\n      full payload data
    traffic that flows over the failed path is\n      switched over to the backup
    path, and if this backup path is of a\n      lower capacity, there will be even
    more congestion.\n   Although the failure detection probing does not perform congestion\n
    \  control as such, the exponential back-off makes sure that the number\n   of
    packets sent quickly goes down and eventually reaches one per\n   context per
    minute, which should be sufficiently conservative even on\n   the lowest bandwidth
    links.\n   Section 7 specifies a number of protocol parameters.  Possible tuning\n
    \  of these parameters and others that are not mandated in this\n   specification
    may affect these properties.  It is expected that\n   further revisions of this
    specification provide additional\n   information after sufficient deployment experience
    has been obtained\n   from different environments.\n   Implementations may provide
    means to monitor their performance and\n   send alarms about problems.  Their
    standardization is, however, the\n   subject of future specifications.  In general,
    Shim6 is most\n   applicable for small sites and nodes, and it is expected that\n
    \  monitoring requirements on such deployments are relatively modest.\n   In any
    case, where the node is associated with a management system,\n   it is RECOMMENDED
    that detected failures and failover events are\n   reported via asynchronous notifications
    to the management system.\n   Similarly, where logging mechanisms are available
    on the node, these\n   events should be recorded in event logs.\n   Shim6 uses
    the same header for both signaling and the encapsulation\n   of payload packets
    after a rehoming event.  This way, fate is shared\n   between the two types of
    packets, so the situation where reachability\n   probes or keepalives can be transmitted
    successfully but payload\n   packets cannot, is largely avoided: either all Shim6
    packets make it\n   through, so Shim6 functions as intended, or none do, and no
    Shim6\n   state is negotiated.  Even in the situation where some packets make\n
    \  it through and others do not, Shim6 will generally either work as\n   intended
    or provide a service that is no worse than in the absence of\n   Shim6, apart
    from the possible generation of a small amount of\n   signaling traffic.\n   Sometimes
    payload packets (and possibly payload packets encapsulated\n   in the Shim6 header)
    do not make it through, but signaling and\n   keepalives do.  This situation can
    occur when there is a path MTU\n   discovery black hole on one of the paths.  If
    only large packets are\n   sent at some point, then reachability exploration will
    be turned on\n   and REAP will likely select another path, which may or may not
    be\n   affected by the PMTUD black hole.\n"
  title: 9.  Operational Considerations
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC3315]  Droms, R., Bound, J., Volz, B., Lemon, T., Perkins, C.,\n
      \             and M. Carney, \"Dynamic Host Configuration Protocol for\n              IPv6
      (DHCPv6)\", RFC 3315, July 2003.\n   [RFC3484]  Draves, R., \"Default Address
      Selection for Internet\n              Protocol version 6 (IPv6)\", RFC 3484,
      February 2003.\n   [RFC4086]  Eastlake, D., Schiller, J., and S. Crocker, \"Randomness\n
      \             Requirements for Security\", BCP 106, RFC 4086, June 2005.\n   [RFC4193]
      \ Hinden, R. and B. Haberman, \"Unique Local IPv6 Unicast\n              Addresses\",
      RFC 4193, October 2005.\n   [RFC4429]  Moore, N., \"Optimistic Duplicate Address
      Detection (DAD)\n              for IPv6\", RFC 4429, April 2006.\n   [RFC4861]
      \ Narten, T., Nordmark, E., Simpson, W., and H. Soliman,\n              \"Neighbor
      Discovery for IP version 6 (IPv6)\", RFC 4861,\n              September 2007.\n
      \  [RFC4862]  Thomson, S., Narten, T., and T. Jinmei, \"IPv6 Stateless\n              Address
      Autoconfiguration\", RFC 4862, September 2007.\n   [RFC5533]  Nordmark, E. and
      M. Bagnulo, \"Shim6: Level 3 Multihoming\n              Shim Protocol for IPv6\",
      RFC 5533, June 2009.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [ADD-SEL]  Bagnulo, M., \"Address selection
      in multihomed\n              environments\", Work in Progress, October 2005.\n
      \  [AURA02]   Aura, T., Roe, M., and J. Arkko, \"Security of Internet\n              Location
      Management\", Proceedings of the 18th Annual\n              Computer Security
      Applications Conference, Las Vegas,\n              Nevada, USA, December 2002.\n
      \  [BFD]      Katz, D. and D. Ward, \"Bidirectional Forwarding\n              Detection\",
      Work in Progress, February 2009.\n   [DNA-SIM]  Krishnan, S. and G. Daley, \"Simple
      procedures for\n              Detecting Network Attachment in IPv6\", Work in
      Progress,\n              February 2009.\n   [GONT]     Gont, F., \"ICMP attacks
      against TCP\", Work in Progress,\n              October 2008.\n   [MULTI6]   Huitema,
      C., \"Address selection in multihomed\n              environments\", Work in
      Progress, October 2004.\n   [PAIR]     Bagnulo, M., \"Default Locator-pair selection
      algorithm for\n              the Shim6 protocol\", Work in Progress, October
      2008.\n   [RFC1122]  Braden, R., \"Requirements for Internet Hosts -\n              Communication
      Layers\", STD 3, RFC 1122, October 1989.\n   [RFC3971]  Arkko, J., Kempf, J.,
      Zill, B., and P. Nikander, \"SEcure\n              Neighbor Discovery (SEND)\",
      RFC 3971, March 2005.\n   [RFC4960]  Stewart, R., \"Stream Control Transmission
      Protocol\",\n              RFC 4960, September 2007.\n   [RFC5206]  Nikander,
      P., Henderson, T., Vogt, C., and J. Arkko, \"End-\n              Host Mobility
      and Multihoming with the Host Identity\n              Protocol\", RFC 5206,
      April 2008.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  Example Protocol Runs\n   This appendix has examples of REAP protocol
    runs in typical\n   scenarios.  We start with the simplest scenario of two nodes,
    A and\n   B, that have a Shim6 connection with each other but are not currently\n
    \  sending any payload data.  As neither side sends anything, they also\n   do
    not expect anything back, so there are no messages at all:\n               EXAMPLE
    1: No Communications\n    Peer A                                        Peer B\n
    \     |                                             |\n      |                                             |\n
    \     |                                             |\n      |                                             |\n
    \     |                                             |\n      |                                             |\n
    \     |                                             |\n      |                                             |\n
    \  Our second example involves an active connection with bidirectional\n   payload
    packet flows.  Here, the reception of payload data from the\n   peer is taken
    as an indication of reachability, so again there are no\n   extra packets:\n          EXAMPLE
    2: Bidirectional Communications\n    Peer A                                        Peer
    B\n      |                                             |\n      |              payload
    packet                 |\n      |-------------------------------------------->|\n
    \     |                                             |\n      |              payload
    packet                 |\n      |<--------------------------------------------|\n
    \     |                                             |\n      |              payload
    packet                 |\n      |-------------------------------------------->|\n
    \     |                                             |\n      |                                             |\n
    \  The third example is the first one that involves an actual REAP\n   message.
    \ Here, the nodes communicate in just one direction, so REAP\n   messages are
    needed to indicate to the peer that sends payload\n   packets that its packets
    are getting through:\n         EXAMPLE 3: Unidirectional Communications\n    Peer
    A                                        Peer B\n      |                                             |\n
    \     |              payload packet                 |\n      |-------------------------------------------->|\n
    \     |                                             |\n      |              payload
    packet                 |\n      |-------------------------------------------->|\n
    \     |                                             |\n      |              payload
    packet                 |\n      |-------------------------------------------->|\n
    \     |                                             |\n      |              Keepalive
    Nonce=p              |\n      |<--------------------------------------------|\n
    \     |                                             |\n      |              payload
    packet                 |\n      |-------------------------------------------->|\n
    \     |                                             |\n      |                                             |\n
    \  The next example involves a failure scenario.  Here, A has address A,\n   and
    B has addresses B1 and B2.  The currently used address pairs are\n   (A, B1) and
    (B1, A).  All connections via B1 become broken, which\n   leads to an exploration
    process:\n              EXAMPLE 4: Failure Scenario\n    Peer A                                        Peer
    B\n      |                                             |\n   State:                                           |
    State:\n   Operational                                      | Operational\n      |
    \           (A,B1) payload packet            |\n      |-------------------------------------------->|\n
    \     |                                             |\n      |            (B1,A)
    payload packet            |\n      |<--------------------------------------------|
    At time T1\n      |                                             | path A<->B1\n
    \     |            (A,B1) payload packet            | becomes\n      |----------------------------------------/
    \   | broken.\n      |                                             |\n      |
    \          ( B1,A) payload packet            |\n      |   /-----------------------------------------|\n
    \     |                                             |\n      |            (A,B1)
    payload packet            |\n      |----------------------------------------/
    \   |\n      |                                             |\n      |            (B1,A)
    payload packet            |\n      |   /-----------------------------------------|\n
    \     |                                             |\n      |            (A,B1)
    payload packet            |\n      |----------------------------------------/
    \   |\n      |                                             |\n      |                                             |
    Send Timeout\n      |                                             | seconds after\n
    \     |                                             | T1, B happens to\n      |
    \                                            | see the problem\n      |             (B1,A)
    Probe Nonce=p,           | first and sends a\n      |                          state=exploring
    \   | complaint that\n      |   /-----------------------------------------| it
    is not\n      |                                             | receiving\n      |
    \                                            | anything.\n      |                                             |
    State:\n      |                                             | Exploring\n      |
    \                                            |\n      |             (B2,A) Probe
    Nonce=q,           |\n      |                          state=exploring    | But
    it's lost,\n      |<--------------------------------------------| retransmission\n
    \     |                                             | uses another pair\n   A
    realizes                                       |\n   that it needs                                    |\n
    \  to start the                                     |\n   exploration.                                     |\n
    \  It picks B2 as the                               |\n   most likely candidate,
    \                          |\n   as it appeared in the                            |\n
    \  Probe.                                           |\n   State: InboundOk                                 |\n
    \     |                                             |\n      |       (A, B2) Probe
    Nonce=r,                |\n      |                     state=inboundok,        |\n
    \     |                     received probe q        | This one gets\n      |-------------------------------------------->|
    through.\n      |                                             | State:\n      |
    \                                            | Operational\n      |       (B2,A)
    Probe Nonce=s,                 |\n      |                    state=operational,
    \      | B now knows\n      |                    received probe r         | that
    A has no\n      |<--------------------------------------------| problem receiving\n
    \     |                                             | its packets.\n   State:
    Operational                               |\n      |                                             |\n
    \     |            (A,B2) payload packet            |\n      |-------------------------------------------->|
    Payload packets\n      |                                             | flow again.\n
    \     |            (B2,A) payload packet            |\n      |<--------------------------------------------|\n
    \  The next example shows when the failure for the current locator pair\n   is
    in the other direction only.  A has addresses A1 and A2, and B has\n   addresses
    B1 and B2.  The current communication is between A1 and B1,\n   but A's packets
    no longer reach B using this pair.\n           EXAMPLE 5: One-Way Failure\n Peer
    A                                        Peer B\n   |                                             |\n"
  - 'State:                                           | State:

    '
  - "Operational                                      | Operational\n   |                                             |\n
    \  |           (A1,B1) payload packet            |\n   |-------------------------------------------->|\n
    \  |                                             |\n   |           (B1,A1) payload
    packet            |\n   |<--------------------------------------------|\n   |
    \                                            |\n   |           (A1,B1) payload
    packet            | At time T1\n   |----------------------------------------/
    \   | path A1->B1\n   |                                             | becomes\n
    \  |                                             | broken.\n   |           (B1,A1)
    payload packet            |\n   |<--------------------------------------------|\n
    \  |                                             |\n   |           (A1,B1) payload
    packet            |\n   |----------------------------------------/    |\n   |
    \                                            |\n   |           (B1,A1) payload
    packet            |\n   |<--------------------------------------------|\n   |
    \                                            |\n   |           (A1,B1) payload
    packet            |\n   |----------------------------------------/    |\n   |
    \                                            |\n   |                                             |
    Send Timeout\n   |                                             | seconds after\n
    \  |                                             | T1, B notices\n   |                                             |
    the problem and\n   |          (B1,A1) Probe Nonce=p,             | sends a\n
    \  |                        state=exploring      | complaint that\n   |<--------------------------------------------|
    it is not\n   |                                             | receiving\n   |
    \                                            | anything.\n"
  - 'A responds.                                      | State: Exploring

    '
  - "State: InboundOk                                 |\n   |                                             |\n
    \  |      (A1, B1) Probe Nonce=q,                |\n   |                     state=inboundok,
    \       |\n   |                     received probe p        |\n   |----------------------------------------/
    \   | A's response\n   |                                             | is lost.\n
    \  |         (B2,A2) Probe Nonce=r,              |\n   |                       state=exploring
    \      | Next, try a different\n   |<--------------------------------------------|
    locator pair.\n   |                                             |\n   |     (A2,
    B2) Probe Nonce=s,                 |\n   |                    state=inboundok,
    \        |\n   |                    received probes p, r     | This one gets\n
    \  |-------------------------------------------->| through.\n   |                                             |
    State: Operational\n   |                                             |\n   |                                             |
    B now knows\n   |                                             | that A has no\n
    \  |      (B2,A2) Probe Nonce=t,                 | problem receiving\n   |                    state=operational,
    \      | its packets and\n   |                    received probe s         | that
    A's probe\n   |<--------------------------------------------| gets to B.  It\n
    \  |                                             | sends a\n"
  - "State: Operational                               | confirmation to A.\n   |                                             |\n
    \  |           (A2,B2) payload packet            |\n   |-------------------------------------------->|
    Payload packets\n   |                                             | flow again.\n
    \  |           (B1,A1) payload packet            |\n   |<--------------------------------------------|\n"
  title: Appendix A.  Example Protocol Runs
- contents:
  - "Appendix B.  Contributors\n   This document attempts to summarize the thoughts
    and unpublished\n   contributions of many people, including MULTI6 WG design team
    members\n   Marcelo Bagnulo Braun, Erik Nordmark, Geoff Huston, Kurtis Lindqvist,\n
    \  Margaret Wasserman, and Jukka Ylitalo; MOBIKE WG contributors Pasi\n   Eronen,
    Tero Kivinen, Francis Dupont, Spencer Dawkins, and James\n   Kempf; and HIP WG
    contributors such as Pekka Nikander.  This document\n   is also in debt to work
    done in the context of SCTP [RFC4960] and the\n   Host Identity Protocol (HIP)
    multihoming and mobility extension\n   [RFC5206].\n"
  title: Appendix B.  Contributors
- contents:
  - "Appendix C.  Acknowledgements\n   The authors would also like to thank Christian
    Huitema, Pekka Savola,\n   John Loughney, Sam Xia, Hannes Tschofenig, Sebastien
    Barre, Thomas\n   Henderson, Matthijs Mekking, Deguang Le, Eric Gray, Dan Romascanu,\n
    \  Stephen Kent, Alberto Garcia, Bernard Aboba, Lars Eggert, Dave Ward,\n   and
    Tim Polk for interesting discussions in this problem space, and\n   for review
    of this specification.\n"
  title: Appendix C.  Acknowledgements
- contents:
  - "Authors' Addresses\n   Jari Arkko\n   Ericsson\n   Jorvas  02420\n   Finland\n
    \  EMail: jari.arkko@ericsson.com\n   Iljitsch van Beijnum\n   IMDEA Networks\n
    \  Avda. del Mar Mediterraneo, 22\n   Leganes, Madrid  28918\n   Spain\n   EMail:
    iljitsch@muada.com\n"
  title: Authors' Addresses
