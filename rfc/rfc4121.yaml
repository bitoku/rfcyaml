- title: __initial_text__
  contents:
  - "                        The Kerberos Version 5\n   Generic Security Service Application\
    \ Program Interface (GSS-API)\n                         Mechanism: Version 2\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document defines protocols, procedures, and conventions to\
    \ be\n   employed by peers implementing the Generic Security Service\n   Application\
    \ Program Interface (GSS-API) when using the Kerberos\n   Version 5 mechanism.\n\
    \   RFC 1964 is updated and incremental changes are proposed in response\n   to\
    \ recent developments such as the introduction of Kerberos\n   cryptosystem framework.\
    \  These changes support the inclusion of new\n   cryptosystems, by defining new\
    \ per-message tokens along with their\n   encryption and checksum algorithms based\
    \ on the cryptosystem\n   profiles.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n\
    \   2. Key Derivation for Per-Message Tokens ...........................4\n  \
    \ 3. Quality of Protection ...........................................4\n   4.\
    \ Definitions and Token Formats ...................................5\n      4.1.\
    \ Context Establishment Tokens ...............................5\n           4.1.1.\
    \ Authenticator Checksum ..............................6\n      4.2. Per-Message\
    \ Tokens .........................................9\n           4.2.1. Sequence\
    \ Number .....................................9\n           4.2.2. Flags Field\
    \ .........................................9\n           4.2.3. EC Field ...........................................10\n\
    \           4.2.4. Encryption and Checksum Operations .................10\n  \
    \         4.2.5. RRC Field ..........................................11\n    \
    \       4.2.6. Message Layouts ....................................12\n      4.3.\
    \ Context Deletion Tokens ...................................13\n      4.4. Token\
    \ Identifier Assignment Considerations ................13\n   5. Parameter Definitions\
    \ ..........................................14\n      5.1. Minor Status Codes\
    \ ........................................14\n           5.1.1. Non-Kerberos-specific\
    \ Codes ........................14\n           5.1.2. Kerberos-specific Codes\
    \ ............................15\n      5.2. Buffer Sizes ..............................................15\n\
    \   6. Backwards Compatibility Considerations .........................15\n  \
    \ 7. Security Considerations ........................................16\n   8.\
    \ Acknowledgements................................................17\n   9. References\
    \ .....................................................18\n      9.1. Normative\
    \ References ......................................18\n      9.2. Informative\
    \ References ....................................18\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   [RFC3961] defines a generic framework for describing encryption\
    \ and\n   checksum types to be used with the Kerberos protocol and associated\n\
    \   protocols.\n   [RFC1964] describes the GSS-API mechanism for Kerberos Version\
    \ 5.  It\n   defines the format of context establishment, per-message and context\n\
    \   deletion tokens, and uses algorithm identifiers for each cryptosystem\n  \
    \ in per-message and context deletion tokens.\n   The approach taken in this document\
    \ obviates the need for algorithm\n   identifiers.  This is accomplished by using\
    \ the same encryption\n   algorithm, specified by the crypto profile [RFC3961]\
    \ for the session\n   key or subkey that is created during context negotiation,\
    \ and its\n   required checksum algorithm.  Message layouts of the per-message\n\
    \   tokens are therefore revised to remove algorithm indicators and to\n   add\
    \ extra information to support the generic crypto framework\n   [RFC3961].\n \
    \  Tokens transferred between GSS-API peers for security context\n   establishment\
    \ are also described in this document.  The data elements\n   exchanged between\
    \ a GSS-API endpoint implementation and the Kerberos\n   Key Distribution Center\
    \ (KDC) [RFC4120] are not specific to GSS-API\n   usage and are therefore defined\
    \ within [RFC4120] rather than this\n   specification.\n   The new token formats\
    \ specified in this document MUST be used with\n   all \"newer\" encryption types\
    \ [RFC4120] and MAY be used with\n   encryption types that are not \"newer\",\
    \ provided that the initiator\n   and acceptor know from the context establishment\
    \ that they can both\n   process these new token formats.\n   \"Newer\" encryption\
    \ types are those which have been specified along\n   with or since the new Kerberos\
    \ cryptosystem specification [RFC3961],\n   as defined in section 3.1.3 of [RFC4120].\
    \  The list of not-newer\n   encryption types is as follows [RFC3961]:\n     \
    \      Encryption Type             Assigned Number\n         ----------------------------------------------\n\
    \          des-cbc-crc                        1\n          des-cbc-md4       \
    \                 2\n          des-cbc-md5                        3\n        \
    \  des3-cbc-md5                       5\n          des3-cbc-sha1             \
    \         7\n          dsaWithSHA1-CmsOID                 9\n          md5WithRSAEncryption-CmsOID\
    \       10\n          sha1WithRSAEncryption-CmsOID      11\n          rc2CBC-EnvOID\
    \                     12\n          rsaEncryption-EnvOID              13\n   \
    \       rsaES-OAEP-ENV-OID                14\n          des-ede3-cbc-Env-OID \
    \             15\n          des3-cbc-sha1-kd                  16\n          rc4-hmac\
    \                          23\n   Conventions used in this document\n   The key\
    \ words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"\
    SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n\
    \   document are to be interpreted as described in [RFC2119].\n   The term \"\
    little-endian order\" is used for brevity to refer to the\n   least-significant-octet-first\
    \ encoding, while the term \"big-endian\n   order\" is for the most-significant-octet-first\
    \ encoding.\n"
- title: 2.  Key Derivation for Per-Message Tokens
  contents:
  - "2.  Key Derivation for Per-Message Tokens\n   To limit the exposure of a given\
    \ key, [RFC3961] adopted \"one-way\"\n   \"entropy-preserving\" derived keys,\
    \ from a base key or protocol key,\n   for different purposes or key usages.\n\
    \   This document defines four key usage values below that are used to\n   derive\
    \ a specific key for signing and sealing messages from the\n   session key or\
    \ subkey [RFC4120] created during the context\n   establishment.\n           Name\
    \                         Value\n         -------------------------------------\n\
    \          KG-USAGE-ACCEPTOR-SEAL         22\n          KG-USAGE-ACCEPTOR-SIGN\
    \         23\n          KG-USAGE-INITIATOR-SEAL        24\n          KG-USAGE-INITIATOR-SIGN\
    \        25\n   When the sender is the context acceptor, KG-USAGE-ACCEPTOR-SIGN\
    \ is\n   used as the usage number in the key derivation function for deriving\n\
    \   keys to be used in MIC tokens (as defined in section 4.2.6.1).\n   KG-USAGE-ACCEPTOR-SEAL\
    \ is used for Wrap tokens (as defined in section\n   4.2.6.2).  Similarly, when\
    \ the sender is the context initiator,\n   KG-USAGE-INITIATOR-SIGN is used as\
    \ the usage number in the key\n   derivation function for MIC tokens, while KG-USAGE-INITIATOR-SEAL\
    \ is\n   used for Wrap tokens.  Even if the Wrap token does not provide for\n\
    \   confidentiality, the same usage values specified above are used.\n   During\
    \ the context initiation and acceptance sequence, the acceptor\n   MAY assert\
    \ a subkey in the AP-REP message.  If the acceptor asserts a\n   subkey, the base\
    \ key is the acceptor-asserted subkey and subsequent\n   per-message tokens MUST\
    \ be flagged with \"AcceptorSubkey\", as\n   described in section 4.2.2.  Otherwise,\
    \ if the initiator asserts a\n   subkey in the AP-REQ message, the base key is\
    \ this subkey;  if the\n   initiator does not assert a subkey, the base key is\
    \ the session key\n   in the service ticket.\n"
- title: 3.  Quality of Protection
  contents:
  - "3.  Quality of Protection\n   The GSS-API specification [RFC2743] provides Quality\
    \ of Protection\n   (QOP) values that can be used by applications to request a\
    \ certain\n   type of encryption or signing.  A zero QOP value is used to indicate\n\
    \   the \"default\" protection; applications that do not use the default\n   QOP\
    \ are not guaranteed to be portable across implementations, or even\n   to inter-operate\
    \ with different deployment configurations of the same\n   implementation.  Using\
    \ a different algorithm than the one for which\n   the key is defined may not\
    \ be appropriate.  Therefore, when the new\n   method in this document is used,\
    \ the QOP value is ignored.\n   The encryption and checksum algorithms in per-message\
    \ tokens are now\n   implicitly defined by the algorithms associated with the\
    \ session key\n   or subkey.  Therefore, algorithm identifiers as described in\n\
    \   [RFC1964] are no longer needed and are removed from the new token\n   headers.\n"
- title: 4.  Definitions and Token Formats
  contents:
  - "4.  Definitions and Token Formats\n   This section provides terms and definitions,\
    \ as well as descriptions\n   for tokens specific to the Kerberos Version 5 GSS-API\
    \ mechanism.\n"
- title: 4.1.  Context Establishment Tokens
  contents:
  - "4.1.  Context Establishment Tokens\n   All context establishment tokens emitted\
    \ by the Kerberos Version 5\n   GSS-API mechanism SHALL have the framing described\
    \ in section 3.1 of\n   [RFC2743], as illustrated by the following pseudo-ASN.1\
    \ structures:\n         GSS-API DEFINITIONS ::=\n         BEGIN\n         MechType\
    \ ::= OBJECT IDENTIFIER\n         -- representing Kerberos V5 mechanism\n    \
    \     GSSAPI-Token ::=\n         -- option indication (delegation, etc.) indicated\
    \ within\n         -- mechanism-specific token\n         [APPLICATION 0] IMPLICIT\
    \ SEQUENCE {\n                 thisMech MechType,\n                 innerToken\
    \ ANY DEFINED BY thisMech\n                    -- contents mechanism-specific\n\
    \                    -- ASN.1 structure not required\n                 }\n   \
    \      END\n   The innerToken field starts with a two-octet token-identifier\n\
    \   (TOK_ID) expressed in big-endian order, followed by a Kerberos\n   message.\n\
    \   Following are the TOK_ID values used in the context establishment\n   tokens:\n\
    \          Token               TOK_ID Value in Hex\n         -----------------------------------------\n\
    \          KRB_AP_REQ            01 00\n          KRB_AP_REP            02 00\n\
    \          KRB_ERROR             03 00\n   Where Kerberos message KRB_AP_REQUEST,\
    \ KRB_AP_REPLY, and KRB_ERROR\n   are defined in [RFC4120].\n   If an unknown\
    \ token identifier (TOK_ID) is received in the initial\n   context establishment\
    \ token, the receiver MUST return\n   GSS_S_CONTINUE_NEEDED major status, and\
    \ the returned output token\n   MUST contain a KRB_ERROR message with the error\
    \ code\n   KRB_AP_ERR_MSG_TYPE [RFC4120].\n"
- title: 4.1.1.  Authenticator Checksum
  contents:
  - "4.1.1.  Authenticator Checksum\n   The authenticator in the KRB_AP_REQ message\
    \ MUST include the optional\n   sequence number and the checksum field.  The checksum\
    \ field is used\n   to convey service flags, channel bindings, and optional delegation\n\
    \   information.\n   The checksum type MUST be 0x8003.  When delegation is used,\
    \ a\n   ticket-granting ticket will be transferred in a KRB_CRED message.\n  \
    \ This ticket SHOULD have its forwardable flag set.  The EncryptedData\n   field\
    \ of the KRB_CRED message [RFC4120] MUST be encrypted in the\n   session key of\
    \ the ticket used to authenticate the context.\n   The authenticator checksum\
    \ field SHALL have the following format:\n       Octet        Name      Description\n\
    \      -----------------------------------------------------------------\n   \
    \    0..3         Lgth    Number of octets in Bnd field;  Represented\n      \
    \                      in little-endian order;  Currently contains\n         \
    \                   hex value 10 00 00 00 (16).\n       4..19        Bnd     Channel\
    \ binding information, as described in\n                            section 4.1.1.2.\n\
    \       20..23       Flags   Four-octet context-establishment flags in\n     \
    \                       little-endian order as described in section\n        \
    \                    4.1.1.1.\n       24..25       DlgOpt  The delegation option\
    \ identifier (=1) in\n                            little-endian order [optional].\
    \  This field\n                            and the next two fields are present\
    \ if and\n                            only if GSS_C_DELEG_FLAG is set as described\n\
    \                            in section 4.1.1.1.\n       26..27       Dlgth  \
    \ The length of the Deleg field in\n                            little-endian\
    \ order [optional].\n       28..(n-1)    Deleg   A KRB_CRED message (n = Dlgth\
    \ + 28)\n                            [optional].\n       n..last      Exts   \
    \ Extensions [optional].\n   The length of the checksum field MUST be at least\
    \ 24 octets when\n   GSS_C_DELEG_FLAG is not set (as described in section 4.1.1.1),\
    \ and at\n   least 28 octets plus Dlgth octets when GSS_C_DELEG_FLAG is set. \
    \ When\n   GSS_C_DELEG_FLAG is set, the DlgOpt, Dlgth, and Deleg fields of the\n\
    \   checksum data MUST immediately follow the Flags field.  The optional\n   trailing\
    \ octets (namely the \"Exts\" field) facilitate future\n   extensions to this\
    \ mechanism.  When delegation is not used, but the\n   Exts field is present,\
    \ the Exts field starts at octet 24 (DlgOpt,\n   Dlgth and Deleg are absent).\n\
    \   Initiators that do not support the extensions MUST NOT include more\n   than\
    \ 24 octets in the checksum field (when GSS_C_DELEG_FLAG is not\n   set) or more\
    \ than 28 octets plus the KRB_CRED in the Deleg field\n   (when GSS_C_DELEG_FLAG\
    \ is set).  Acceptors that do not understand the\n   Extensions MUST ignore any\
    \ octets past the Deleg field of the\n   checksum data (when GSS_C_DELEG_FLAG\
    \ is set) or past the Flags field\n   of the checksum data (when GSS_C_DELEG_FLAG\
    \ is not set).\n"
- title: 4.1.1.1.  Checksum Flags Field
  contents:
  - "4.1.1.1.  Checksum Flags Field\n   The checksum \"Flags\" field is used to convey\
    \ service options or\n   extension negotiation information.\n   The following\
    \ context establishment flags are defined in [RFC2744].\n           Flag Name\
    \              Value\n         ---------------------------------\n          GSS_C_DELEG_FLAG\
    \           1\n          GSS_C_MUTUAL_FLAG          2\n          GSS_C_REPLAY_FLAG\
    \          4\n          GSS_C_SEQUENCE_FLAG        8\n          GSS_C_CONF_FLAG\
    \           16\n          GSS_C_INTEG_FLAG          32\n   Context establishment\
    \ flags are exposed to the calling application.\n   If the calling application\
    \ desires a particular service option, then\n   it requests that option via GSS_Init_sec_context()\
    \ [RFC2743].  If the\n   corresponding return state values [RFC2743] indicate\
    \ that any of the\n   above optional context level services will be active on\
    \ the context,\n   the corresponding flag values in the table above MUST be set\
    \ in the\n   checksum Flags field.\n   Flag values 4096..524288 (2^12, 2^13, ...,\
    \ 2^19) are reserved for use\n   with legacy vendor-specific extensions to this\
    \ mechanism.\n   All other flag values not specified herein are reserved for future\n\
    \   use.  Future revisions of this mechanism may use these reserved flags\n  \
    \ and may rely on implementations of this version to not use such flags\n   in\
    \ order to properly negotiate mechanism versions.  Undefined flag\n   values MUST\
    \ be cleared by the sender, and unknown flags MUST be\n   ignored by the receiver.\n"
- title: 4.1.1.2.  Channel Binding Information
  contents:
  - "4.1.1.2.  Channel Binding Information\n   These tags are intended to be used\
    \ to identify the particular\n   communications channel for which the GSS-API\
    \ security context\n   establishment tokens are intended, thus limiting the scope\
    \ within\n   which an intercepted context establishment token can be reused by\
    \ an\n   attacker (see [RFC2743], section 1.1.6).\n   When using C language bindings,\
    \ channel bindings are communicated to\n   the GSS-API using the following structure\
    \ [RFC2744]:\n         typedef struct gss_channel_bindings_struct {\n        \
    \    OM_uint32       initiator_addrtype;\n            gss_buffer_desc initiator_address;\n\
    \            OM_uint32       acceptor_addrtype;\n            gss_buffer_desc acceptor_address;\n\
    \            gss_buffer_desc application_data;\n         } *gss_channel_bindings_t;\n\
    \   The member fields and constants used for different address types are\n   defined\
    \ in [RFC2744].\n   The \"Bnd\" field contains the MD5 hash of channel bindings,\
    \ taken over\n   all non-null components of bindings, in order of declaration.\n\
    \   Integer fields within channel bindings are represented in little-\n   endian\
    \ order for the purposes of the MD5 calculation.\n   In computing the contents\
    \ of the Bnd field, the following detailed\n   points apply:\n   (1) For purposes\
    \ of MD5 hash computation, each integer field and\n       input length field SHALL\
    \ be formatted into four octets, using\n       little-endian octet ordering.\n\
    \   (2) All input length fields within gss_buffer_desc elements of a\n       gss_channel_bindings_struct\
    \ even those which are zero-valued,\n       SHALL be included in the hash calculation.\
    \  The value elements of\n       gss_buffer_desc elements SHALL be dereferenced,\
    \ and the resulting\n       data SHALL be included within the hash computation,\
    \ only for the\n       case of gss_buffer_desc elements having non-zero length\n\
    \       specifiers.\n   (3) If the caller passes the value GSS_C_NO_BINDINGS instead\
    \ of a\n       valid channel binding structure, the Bnd field SHALL be set to\
    \ 16\n       zero-valued octets.\n   If the caller to GSS_Accept_sec_context [RFC2743]\
    \ passes in\n   GSS_C_NO_CHANNEL_BINDINGS [RFC2744] as the channel bindings, then\
    \ the\n   acceptor MAY ignore any channel bindings supplied by the initiator,\n\
    \   returning success even if the initiator did pass in channel bindings.\n  \
    \ If the application supplies, in the channel bindings, a buffer with a\n   length\
    \ field larger than 4294967295 (2^32 - 1), the implementation of\n   this mechanism\
    \ MAY choose to reject the channel bindings altogether,\n   using major status\
    \ GSS_S_BAD_BINDINGS [RFC2743].  In any case, the\n   size of channel-binding\
    \ data buffers that can be used (interoperable,\n   without extensions) with this\
    \ specification is limited to 4294967295\n   octets.\n"
- title: 4.2.  Per-Message Tokens
  contents:
  - "4.2.  Per-Message Tokens\n   Two classes of tokens are defined in this section:\
    \ (1) \"MIC\" tokens,\n   emitted by calls to GSS_GetMIC() and consumed by calls\
    \ to\n   GSS_VerifyMIC(), and (2) \"Wrap\" tokens, emitted by calls to\n   GSS_Wrap()\
    \ and consumed by calls to GSS_Unwrap().\n   These new per-message tokens do not\
    \ include the generic GSS-API token\n   framing used by the context establishment\
    \ tokens.  These new tokens\n   are designed to be used with newer crypto systems\
    \ that can have\n   variable-size checksums.\n"
- title: 4.2.1.  Sequence Number
  contents:
  - "4.2.1.  Sequence Number\n   To distinguish intentionally-repeated messages from\
    \ maliciously-\n   replayed ones, per-message tokens contain a sequence number\
    \ field,\n   which is a 64 bit integer expressed in big-endian order.  After\n\
    \   sending a GSS_GetMIC() or GSS_Wrap() token, the sender's sequence\n   numbers\
    \ SHALL be incremented by one.\n"
- title: 4.2.2.  Flags Field
  contents:
  - "4.2.2.  Flags Field\n   The \"Flags\" field is a one-octet integer used to indicate\
    \ a set of\n   attributes for the protected message.  For example, one flag is\n\
    \   allocated as the direction-indicator, thus preventing the acceptance\n   of\
    \ the same message sent back in the reverse direction by an\n   adversary.\n \
    \  The meanings of bits in this field (the least significant bit is bit\n   0)\
    \ are as follows:\n          Bit    Name             Description\n         --------------------------------------------------------------\n\
    \          0   SentByAcceptor   When set, this flag indicates the sender\n   \
    \                            is the context acceptor.  When not set,\n       \
    \                        it indicates the sender is the context\n            \
    \                   initiator.\n          1   Sealed           When set in Wrap\
    \ tokens, this flag\n                               indicates confidentiality\
    \ is provided\n                               for.  It SHALL NOT be set in MIC\
    \ tokens.\n          2   AcceptorSubkey   A subkey asserted by the context acceptor\n\
    \                               is used to protect the message.\n   The rest of\
    \ available bits are reserved for future use and MUST be\n   cleared.  The receiver\
    \ MUST ignore unknown flags.\n"
- title: 4.2.3.  EC Field
  contents:
  - "4.2.3.  EC Field\n   The \"EC\" (Extra Count) field is a two-octet integer field\
    \ expressed\n   in big-endian order.\n   In Wrap tokens with confidentiality,\
    \ the EC field SHALL be used to\n   encode the number of octets in the filler,\
    \ as described in section\n   4.2.4.\n   In Wrap tokens without confidentiality,\
    \ the EC field SHALL be used to\n   encode the number of octets in the trailing\
    \ checksum, as described in\n   section 4.2.4.\n"
- title: 4.2.4.  Encryption and Checksum Operations
  contents:
  - "4.2.4.  Encryption and Checksum Operations\n   The encryption algorithms defined\
    \ by the crypto profiles provide for\n   integrity protection [RFC3961].  Therefore,\
    \ no separate checksum is\n   needed.\n   The result of decryption can be longer\
    \ than the original plaintext\n   [RFC3961] and the extra trailing octets are\
    \ called \"crypto-system\n   residue\" in this document.  However, given the size\
    \ of any plaintext\n   data, one can always find a (possibly larger) size, such\
    \ that when\n   padding the to-be-encrypted text to that size, there will be no\n\
    \   crypto-system residue added [RFC3961].\n   In Wrap tokens that provide for\
    \ confidentiality, the first 16 octets\n   of the Wrap token (the \"header\",\
    \ as defined in section 4.2.6), SHALL\n   be appended to the plaintext data before\
    \ encryption.  Filler octets\n   MAY be inserted between the plaintext data and\
    \ the \"header.\"  The\n   values and size of the filler octets are chosen by\
    \ implementations,\n   such that there SHALL be no crypto-system residue present\
    \ after the\n   decryption.  The resulting Wrap token is {\"header\" |\n   encrypt(plaintext-data\
    \ | filler | \"header\")}, where encrypt() is the\n   encryption operation (which\
    \ provides for integrity protection)\n   defined in the crypto profile [RFC3961],\
    \ and the RRC field (as\n   defined in section 4.2.5) in the to-be-encrypted header\
    \ contains the\n   hex value 00 00.\n   In Wrap tokens that do not provide for\
    \ confidentiality, the checksum\n   SHALL be calculated first over the to-be-signed\
    \ plaintext data, and\n   then over the first 16 octets of the Wrap token (the\
    \ \"header\", as\n   defined in section 4.2.6).  Both the EC field and the RRC\
    \ field in\n   the token header SHALL be filled with zeroes for the purpose of\n\
    \   calculating the checksum.  The resulting Wrap token is {\"header\" |\n   plaintext-data\
    \ | get_mic(plaintext-data | \"header\")}, where get_mic()\n   is the checksum\
    \ operation for the required checksum mechanism of the\n   chosen encryption mechanism\
    \ defined in the crypto profile [RFC3961].\n   The parameters for the key and\
    \ the cipher-state in the encrypt() and\n   get_mic() operations have been omitted\
    \ for brevity.\n   For MIC tokens, the checksum SHALL be calculated as follows:\
    \ the\n   checksum operation is calculated first over the to-be-signed\n   plaintext\
    \ data, and then over the first 16 octets of the MIC token,\n   where the checksum\
    \ mechanism is the required checksum mechanism of\n   the chosen encryption mechanism\
    \ defined in the crypto profile\n   [RFC3961].\n   The resulting Wrap and MIC\
    \ tokens bind the data to the token header,\n   including the sequence number\
    \ and the direction indicator.\n"
- title: 4.2.5.  RRC Field
  contents:
  - "4.2.5.  RRC Field\n   The \"RRC\" (Right Rotation Count) field in Wrap tokens\
    \ is added to\n   allow the data to be encrypted in-place by existing SSPI (Security\n\
    \   Service Provider Interface) [SSPI] applications that do not provide\n   an\
    \ additional buffer for the trailer (the cipher text after the in-\n   place-encrypted\
    \ data) in addition to the buffer for the header (the\n   cipher text before the\
    \ in-place-encrypted data).  Excluding the first\n   16 octets of the token header,\
    \ the resulting Wrap token in the\n   previous section is rotated to the right\
    \ by \"RRC\" octets.  The net\n   result is that \"RRC\" octets of trailing octets\
    \ are moved toward the\n   header.\n   Consider the following as an example of\
    \ this rotation operation:\n   Assume that the RRC value is 3 and the token before\
    \ the rotation is\n   {\"header\" | aa | bb | cc | dd | ee | ff | gg | hh}.  The\
    \ token after\n   rotation would be {\"header\" | ff | gg | hh | aa | bb | cc\
    \ | dd | ee\n   }, where {aa | bb | cc |...| hh} would be used to indicate the\
    \ octet\n   sequence.\n   The RRC field is expressed as a two-octet integer in\
    \ big-endian\n   order.\n   The rotation count value is chosen by the sender based\
    \ on\n   implementation details.  The receiver MUST be able to interpret all\n\
    \   possible rotation count values, including rotation counts greater\n   than\
    \ the length of the token.\n"
- title: 4.2.6.  Message Layouts
  contents:
  - "4.2.6.  Message Layouts\n   Per-message tokens start with a two-octet token identifier\
    \ (TOK_ID)\n   field, expressed in big-endian order.  These tokens are defined\n\
    \   separately in the following sub-sections.\n"
- title: 4.2.6.1.  MIC Tokens
  contents:
  - "4.2.6.1.  MIC Tokens\n   Use of the GSS_GetMIC() call yields a token (referred\
    \ as the MIC\n   token in this document), separate from the user data being protected,\n\
    \   which can be used to verify the integrity of that data as received.\n   The\
    \ token has the following format:\n         Octet no   Name        Description\n\
    \         --------------------------------------------------------------\n   \
    \      0..1     TOK_ID     Identification field.  Tokens emitted by\n        \
    \                     GSS_GetMIC() contain the hex value 04 04\n             \
    \                expressed in big-endian order in this\n                     \
    \        field.\n         2        Flags      Attributes field, as described in\
    \ section\n                             4.2.2.\n         3..7     Filler     Contains\
    \ five octets of hex value FF.\n         8..15    SND_SEQ    Sequence number field\
    \ in clear text,\n                             expressed in big-endian order.\n\
    \         16..last SGN_CKSUM  Checksum of the \"to-be-signed\" data and\n    \
    \                         octet 0..15, as described in section 4.2.4.\n   The\
    \ Filler field is included in the checksum calculation for\n   simplicity.\n"
- title: 4.2.6.2.  Wrap Tokens
  contents:
  - "4.2.6.2.  Wrap Tokens\n   Use of the GSS_Wrap() call yields a token (referred\
    \ as the Wrap token\n   in this document), which consists of a descriptive header,\
    \ followed\n   by a body portion that contains either the input user data in\n\
    \   plaintext concatenated with the checksum, or the input user data\n   encrypted.\
    \  The GSS_Wrap() token SHALL have the following format:\n         Octet no  \
    \ Name        Description\n         --------------------------------------------------------------\n\
    \          0..1     TOK_ID    Identification field.  Tokens emitted by\n     \
    \                        GSS_Wrap() contain the hex value 05 04\n            \
    \                 expressed in big-endian order in this\n                    \
    \         field.\n          2        Flags     Attributes field, as described\
    \ in section\n                             4.2.2.\n          3        Filler \
    \   Contains the hex value FF.\n          4..5     EC        Contains the \"extra\
    \ count\" field, in big-\n                             endian order as described\
    \ in section 4.2.3.\n          6..7     RRC       Contains the \"right rotation\
    \ count\" in big-\n                             endian order, as described in\
    \ section\n                             4.2.5.\n          8..15    SND_SEQ   Sequence\
    \ number field in clear text,\n                             expressed in big-endian\
    \ order.\n          16..last Data      Encrypted data for Wrap tokens with\n \
    \                            confidentiality, or plaintext data followed\n   \
    \                          by the checksum for Wrap tokens without\n         \
    \                    confidentiality, as described in section\n              \
    \               4.2.4.\n"
- title: 4.3.  Context Deletion Tokens
  contents:
  - "4.3.  Context Deletion Tokens\n   Context deletion tokens are empty in this mechanism.\
    \  Both peers to a\n   security context invoke GSS_Delete_sec_context() [RFC2743]\n\
    \   independently, passing a null output_context_token buffer to indicate\n  \
    \ that no context_token is required.  Implementations of\n   GSS_Delete_sec_context()\
    \ should delete relevant locally-stored\n   context information.\n"
- title: 4.4.  Token Identifier Assignment Considerations
  contents:
  - "4.4.  Token Identifier Assignment Considerations\n   Token identifiers (TOK_ID)\
    \ from 0x60 0x00 through 0x60 0xFF inclusive\n   are reserved and SHALL NOT be\
    \ assigned.  Thus, by examining the first\n   two octets of a token, one can tell\
    \ unambiguously if it is wrapped\n   with the generic GSS-API token framing.\n"
- title: 5.  Parameter Definitions
  contents:
  - "5.  Parameter Definitions\n   This section defines parameter values used by the\
    \ Kerberos V5 GSS-API\n   mechanism.  It defines interface elements that support\
    \ portability,\n   and assumes use of C language bindings per [RFC2744].\n"
- title: 5.1.  Minor Status Codes
  contents:
  - "5.1.  Minor Status Codes\n   This section recommends common symbolic names for\
    \ minor_status values\n   to be returned by the Kerberos V5 GSS-API mechanism.\
    \  Use of these\n   definitions will enable independent implementers to enhance\n\
    \   application portability across different implementations of the\n   mechanism\
    \ defined in this specification.  (In all cases,\n   implementations of GSS_Display_status()\
    \ will enable callers to\n   convert minor_status indicators to text representations.)\
    \  Each\n   implementation should make available, through include files or other\n\
    \   means, a facility to translate these symbolic names into the concrete\n  \
    \ values that a particular GSS-API implementation uses to represent the\n   minor_status\
    \ values specified in this section.\n   This list may grow over time and the need\
    \ for additional minor_status\n   codes, specific to particular implementations,\
    \ may arise.  However,\n   it is recommended that implementations should return\
    \ a minor_status\n   value as defined on a mechanism-wide basis within this section\
    \ when\n   that code accurately represents reportable status rather than using\
    \ a\n   separate, implementation-defined code.\n"
- title: 5.1.1.  Non-Kerberos-specific Codes
  contents:
  - "5.1.1.  Non-Kerberos-specific Codes\n         GSS_KRB5_S_G_BAD_SERVICE_NAME\n\
    \                 /* \"No @ in SERVICE-NAME name string\" */\n         GSS_KRB5_S_G_BAD_STRING_UID\n\
    \                 /* \"STRING-UID-NAME contains nondigits\" */\n         GSS_KRB5_S_G_NOUSER\n\
    \                 /* \"UID does not resolve to username\" */\n         GSS_KRB5_S_G_VALIDATE_FAILED\n\
    \                 /* \"Validation error\" */\n         GSS_KRB5_S_G_BUFFER_ALLOC\n\
    \                 /* \"Couldn't allocate gss_buffer_t data\" */\n         GSS_KRB5_S_G_BAD_MSG_CTX\n\
    \                 /* \"Message context invalid\" */\n         GSS_KRB5_S_G_WRONG_SIZE\n\
    \                 /* \"Buffer is the wrong size\" */\n         GSS_KRB5_S_G_BAD_USAGE\n\
    \                 /* \"Credential usage type is unknown\" */\n         GSS_KRB5_S_G_UNKNOWN_QOP\n\
    \                 /* \"Unknown quality of protection specified\" */\n"
- title: 5.1.2.  Kerberos-specific Codes
  contents:
  - "5.1.2.  Kerberos-specific Codes\n         GSS_KRB5_S_KG_CCACHE_NOMATCH\n    \
    \             /* \"Client principal in credentials does not match\n          \
    \          specified name\" */\n         GSS_KRB5_S_KG_KEYTAB_NOMATCH\n      \
    \           /* \"No key available for specified service\n                    principal\"\
    \ */\n         GSS_KRB5_S_KG_TGT_MISSING\n                 /* \"No Kerberos ticket-granting\
    \ ticket available\" */\n         GSS_KRB5_S_KG_NO_SUBKEY\n                 /*\
    \ \"Authenticator has no subkey\" */\n         GSS_KRB5_S_KG_CONTEXT_ESTABLISHED\n\
    \                 /* \"Context is already fully established\" */\n         GSS_KRB5_S_KG_BAD_SIGN_TYPE\n\
    \                 /* \"Unknown signature type in token\" */\n         GSS_KRB5_S_KG_BAD_LENGTH\n\
    \                 /* \"Invalid field length in token\" */\n         GSS_KRB5_S_KG_CTX_INCOMPLETE\n\
    \                 /* \"Attempt to use incomplete security context\" */\n"
- title: 5.2.  Buffer Sizes
  contents:
  - "5.2.  Buffer Sizes\n   All implementations of this specification MUST be capable\
    \ of\n   accepting buffers of at least 16K octets as input to GSS_GetMIC(),\n\
    \   GSS_VerifyMIC(), and GSS_Wrap().  They MUST also be capable of\n   accepting\
    \ the output_token generated by GSS_Wrap() for a 16K octet\n   input buffer as\
    \ input to GSS_Unwrap().  Implementations SHOULD\n   support 64K octet input buffers,\
    \ and MAY support even larger input\n   buffer sizes.\n"
- title: 6.  Backwards Compatibility Considerations
  contents:
  - "6.  Backwards Compatibility Considerations\n   The new token formats defined\
    \ in this document will only be\n   recognized by new implementations.  To address\
    \ this, implementations\n   can always use the explicit sign or seal algorithm\
    \ in [RFC1964] when\n   the key type corresponds to not \"newer\" enctypes.  As\
    \ an alternative,\n   one might retry sending the message with the sign or seal\
    \ algorithm\n   explicitly defined as in [RFC1964].  However, this would require\n\
    \   either the use of a mechanism such as [RFC2478] to securely negotiate\n  \
    \ the method, or the use of an out-of-band mechanism to choose the\n   appropriate\
    \ mechanism.  For this reason, it is RECOMMENDED that the\n   new token formats\
    \ defined in this document SHOULD be used only if\n   both peers are known to\
    \ support the new mechanism during context\n   negotiation because of, for example,\
    \ the use of \"new\" enctypes.\n   GSS_Unwrap() or GSS_VerifyMIC() can process\
    \ a message token as\n   follows: it can look at the first octet of the token\
    \ header, and if\n   it is 0x60, then the token must carry the generic GSS-API\
    \ pseudo\n   ASN.1 framing.  Otherwise, the first two octets of the token contain\n\
    \   the TOK_ID that uniquely identify the token message format.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   Channel bindings are validated by the acceptor.\
    \  The acceptor can\n   ignore the channel bindings restriction supplied by the\
    \ initiator and\n   carried in the authenticator checksum, if (1) channel bindings\
    \ are\n   not used by GSS_Accept_sec_context [RFC2743], and (2) the acceptor\n\
    \   does not prove to the initiator that it has the same channel bindings\n  \
    \ as the initiator (even if the client requested mutual\n   authentication). \
    \ This limitation should be considered by designers\n   of applications that would\
    \ use channel bindings, whether to limit the\n   use of GSS-API contexts to nodes\
    \ with specific network addresses, to\n   authenticate other established, secure\
    \ channels using Kerberos\n   Version 5, or for any other purpose.\n   Session\
    \ key types are selected by the KDC.  Under the current\n   mechanism, no negotiation\
    \ of algorithm types occurs, so server-side\n   (acceptor) implementations cannot\
    \ request that clients not use\n   algorithm types not understood by the server.\
    \  However,\n   administrators can control what enctypes can be used for session\
    \ keys\n   for this mechanism by controlling the set of the ticket session key\n\
    \   enctypes which the KDC is willing to use in tickets for a given\n   acceptor\
    \ principal.  Therefore, the KDC could be given the task of\n   limiting session\
    \ keys for a given service to types actually supported\n   by the Kerberos and\
    \ GSSAPI software on the server.  This has a\n   drawback for cases in which a\
    \ service principal name is used for both\n   GSSAPI-based and non-GSSAPI-based\
    \ communication (most notably the\n   \"host\" service key), if the GSSAPI implementation\
    \ does not understand\n   (for example) AES [RFC3962], but the Kerberos implementation\
    \ does.\n   This means that AES session keys cannot be issued for that service\n\
    \   principal, which keeps the protection of non-GSSAPI services weaker\n   than\
    \ necessary.  KDC administrators desiring to limit the session key\n   types to\
    \ support interoperability with such GSSAPI implementations\n   should carefully\
    \ weigh the reduction in protection offered by such\n   mechanisms against the\
    \ benefits of interoperability.\n"
- title: 8.  Acknowledgements
  contents:
  - "8.  Acknowledgements\n   Ken Raeburn and Nicolas Williams corrected many of our\
    \ errors in the\n   use of generic profiles and were instrumental in the creation\
    \ of this\n   document.\n   The text for security considerations was contributed\
    \ by Nicolas\n   Williams and Ken Raeburn.\n   Sam Hartman and Ken Raeburn suggested\
    \ the \"floating trailer\" idea,\n   namely the encoding of the RRC field.\n \
    \  Sam Hartman and Nicolas Williams recommended the replacing our\n   earlier\
    \ key derivation function for directional keys with different\n   key usage numbers\
    \ for each direction as well as retaining the\n   directional bit for maximum\
    \ compatibility.\n   Paul Leach provided numerous suggestions and comments.\n\
    \   Scott Field, Richard Ward, Dan Simon, Kevin Damour, and Simon\n   Josefsson\
    \ also provided valuable inputs on this document.\n   Jeffrey Hutzelman provided\
    \ comments and clarifications for the text\n   related to the channel bindings.\n\
    \   Jeffrey Hutzelman and Russ Housley suggested many editorial changes.\n   Luke\
    \ Howard provided implementations of this document for the Heimdal\n   code base,\
    \ and helped inter-operability testing with the Microsoft\n   code base, together\
    \ with Love Hornquist Astrand.  These experiments\n   formed the basis of this\
    \ document.\n   Martin Rex provided suggestions of TOK_ID assignment recommendations,\n\
    \   thus the token tagging in this document is unambiguous if the token\n   is\
    \ wrapped with the pseudo ASN.1 header.\n   John Linn wrote the original Kerberos\
    \ Version 5 mechanism\n   specification [RFC1964], of which some text has been\
    \ retained.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC2743]  Linn, J., \"Generic Security Service Application Program\n\
    \              Interface Version 2, Update 1\", RFC 2743, January 2000.\n   [RFC2744]\
    \  Wray, J., \"Generic Security Service API Version 2:\n              C-bindings\"\
    , RFC 2744, January 2000.\n   [RFC1964]  Linn, J., \"The Kerberos Version 5 GSS-API\
    \ Mechanism\", RFC\n              1964, June 1996.\n   [RFC3961]  Raeburn, K.,\
    \ \"Encryption and Checksum Specifications for\n              Kerberos 5\", RFC\
    \ 3961, February 2005.\n   [RFC4120]  Neuman, C., Yu, T., Hartman, S., and K.\
    \ Raeburn, \"The\n              Kerberos Network Authentication Service (V5)\"\
    , RFC 4120,\n              July 2005.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [SSPI]     Leach, P., \"Security Service Provider\
    \ Interface\",\n              Microsoft Developer Network (MSDN), April 2003.\n\
    \   [RFC3962]  Raeburn, K., \"Advanced Encryption Standard (AES)\n           \
    \   Encryption for Kerberos 5\", RFC 3962, February 2005.\n   [RFC2478]  Baize,\
    \ E. and D. Pinkas, \"The Simple and Protected GSS-API\n              Negotiation\
    \ Mechanism\", RFC 2478, December 1998.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Larry Zhu\n   One Microsoft Way\n   Redmond, WA 98052\
    \ - USA\n   EMail: LZhu@microsoft.com\n   Karthik Jaganathan\n   One Microsoft\
    \ Way\n   Redmond, WA 98052 - USA\n   EMail: karthikj@microsoft.com\n   Sam Hartman\n\
    \   Massachusetts Institute of Technology\n   77 Massachusetts Avenue\n   Cambridge,\
    \ MA 02139 - USA\n   EMail: hartmans-ietf@mit.edu\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
