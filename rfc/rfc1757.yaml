- title: __initial_text__
  contents:
  - '         Remote Network Monitoring Management Information Base

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo defines a portion of the Management Information Base (MIB)\n\
    \   for use with network management protocols in TCP/IP-based internets.\n   In\
    \ particular, it defines objects for managing remote network\n   monitoring devices.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   3.1 Resource Sharing Among Multiple Management Stations\
    \ ..    8\n   9. Author's Address ......................................   90\n\
    \   10. Appendix: Changes from RFC 1271 ......................   91\n"
- title: 1.  The Network Management Framework
  contents:
  - "1.  The Network Management Framework\n   The Internet-standard Network Management\
    \ Framework consists of three\n   components.  They are:\n      STD 16, RFC 1155\
    \ [1] which defines the SMI, the mechanisms used\n      for describing and naming\
    \ objects for the purpose of management.\n      STD 16, RFC 1212 [2] defines a\
    \ more concise description mechanism,\n      which is wholly consistent with the\
    \ SMI.\n      STD 17, RFC 1213 [3] which defines MIB-II, the core set of managed\n\
    \      objects for the Internet suite of protocols.\n      STD 15, RFC 1157 [4]\
    \ which defines the SNMP, the protocol used for\n      network access to managed\
    \ objects.\n   The Framework permits new objects to be defined for the purpose\
    \ of\n   experimentation and evaluation.\n   Managed objects are accessed via\
    \ a virtual information store, termed\n   the Management Information Base or MIB.\
    \  Within a given MIB module,\n   objects are defined using RFC 1212's OBJECT-TYPE\
    \ macro.  At a\n   minimum, each object has a name, a syntax, an access-level,\
    \ and an\n   implementation-status.\n   The name is an object identifier, an administratively\
    \ assigned name,\n   which specifies an object type.  The object type together\
    \ with an\n   object instance serves to uniquely identify a specific instantiation\n\
    \   of the object.  For human convenience, we often use a textual string,\n  \
    \ termed the object descriptor, to also refer to the object type.\n   The syntax\
    \ of an object type defines the abstract data structure\n   corresponding to that\
    \ object type.  The ASN.1[5] language is used for\n   this purpose.  However,\
    \ RFC 1155 purposely restricts the ASN.1\n   constructs which may be used.  These\
    \ restrictions are explicitly made\n   for simplicity.\n   The access-level of\
    \ an object type defines whether it makes \"protocol\n   sense\" to read and/or\
    \ write the value of an instance of the object\n   type.  (This access-level is\
    \ independent of any administrative\n   authorization policy.)\n   The implementation-status\
    \ of an object type indicates whether the\n   object is mandatory, optional, obsolete,\
    \ or deprecated.\n"
- title: 2.  Overview
  contents:
  - "2.  Overview\n   Remote network monitoring devices, often called monitors or\
    \ probes,\n   are instruments that exist for the purpose of managing a network.\n\
    \   Often these remote probes are stand-alone devices and devote\n   significant\
    \ internal resources for the sole purpose of managing a\n   network.  An organization\
    \ may employ many of these devices, one per\n   network segment, to manage its\
    \ internet.  In addition, these devices\n   may be used for a network management\
    \ service provider to access a\n   client network, often geographically remote.\n\
    \   The objects defined in this document are intended as an interface\n   between\
    \ an RMON agent and an RMON management application and are not\n   intended for\
    \ direct manipulation by humans.  While some users may\n   tolerate the direct\
    \ display of some of these objects, few will\n   tolerate the complexity of manually\
    \ manipulating objects to\n   accomplish row creation.  These functions should\
    \ be handled by the\n   management application.\n   While most of the objects\
    \ in this document are suitable for the\n   management of any type of network,\
    \ there are some which are specific\n   to managing Ethernet networks.  These\
    \ are the objects in the\n   etherStatsTable, the etherHistoryTable, and some\
    \ attributes of the\n   filterPktStatus and capturBufferPacketStatus objects.\
    \  The design of\n   this MIB allows similar objects to be defined for other network\n\
    \   types.  It is intended that future versions of this document and\n   additional\
    \ documents will define extensions for other network types\n   such as Token Ring\
    \ and FDDI.\n"
- title: 2.1.  Remote Network Management Goals
  contents:
  - "2.1.  Remote Network Management Goals\n              o Offline Operation\n  \
    \                There are sometimes conditions when a management\n          \
    \        station will not be in constant contact with its\n                  remote\
    \ monitoring devices.  This is sometimes by\n                  design in an attempt\
    \ to lower communications costs\n                  (especially when communicating\
    \ over a WAN or\n                  dialup link), or by accident as network failures\n\
    \                  affect the communications between the management\n        \
    \          station and the probe.\n                  For this reason, this MIB\
    \ allows a probe to be\n                  configured to perform diagnostics and\
    \ to collect\n                  statistics continuously, even when communication\
    \ with\n                  the management station may not be possible or\n    \
    \              efficient.  The probe may then attempt to notify\n            \
    \      the management station when an exceptional condition\n                \
    \  occurs.  Thus, even in circumstances where\n                  communication\
    \ between management station and probe is\n                  not continuous, fault,\
    \ performance, and configuration\n                  information may be continuously\
    \ accumulated and\n                  communicated to the management station conveniently\n\
    \                  and efficiently.\n              o Proactive Monitoring\n  \
    \                Given the resources available on the monitor, it\n          \
    \        is potentially helpful for it continuously to run\n                 \
    \ diagnostics and to log network performance.  The\n                  monitor\
    \ is always available at the onset of any\n                  failure.  It can\
    \ notify the management station of the\n                  failure and can store\
    \ historical statistical\n                  information about the failure.  This\
    \ historical\n                  information can be played back by the management\n\
    \                  station in an attempt to perform further diagnosis\n      \
    \            into the cause of the problem.\n              o Problem Detection\
    \ and Reporting\n                  The monitor can be configured to recognize\n\
    \                  conditions, most notably error conditions, and\n          \
    \        continuously to check for them.  When one of these\n                \
    \  conditions occurs, the event may be logged, and\n                  management\
    \ stations may be notified in a number of\n                  ways.\n         \
    \     o Value Added Data\n                  Because a remote monitoring device\
    \ represents a\n                  network resource dedicated exclusively to network\n\
    \                  management functions, and because it is located\n         \
    \         directly on the monitored portion of the network, the\n            \
    \      remote network monitoring device has the opportunity\n                \
    \  to add significant value to the data it collects.\n                  For instance,\
    \ by highlighting those hosts on the\n                  network that generate\
    \ the most traffic or errors, the\n                  probe can give the management\
    \ station precisely the\n                  information it needs to solve a class\
    \ of problems.\n              o Multiple Managers\n                  An organization\
    \ may have multiple management stations\n                  for different units\
    \ of the organization, for different\n                  functions (e.g. engineering\
    \ and operations), and in an\n                  attempt to provide disaster recovery.\
    \  Because\n                  environments with multiple management stations are\n\
    \                  common, the remote network monitoring device has to\n     \
    \             deal with more than own management station,\n                  potentially\
    \ using its resources concurrently.\n"
- title: 2.2.  Textual Conventions
  contents:
  - "2.2.  Textual Conventions\n   Two new data types are introduced as a textual\
    \ convention in this MIB\n   document.  These textual conventions enhance the\
    \ readability of the\n   specification and can ease comparison with other specifications\
    \ if\n   appropriate.  It should be noted that the introduction of the these\n\
    \   textual conventions has no effect on either the syntax nor the\n   semantics\
    \ of any managed objects.  The use of these is merely an\n   artifact of the explanatory\
    \ method used.  Objects defined in terms of\n   one of these methods are always\
    \ encoded by means of the rules that\n   define the primitive type.  Hence, no\
    \ changes to the SMI or the SNMP\n   are necessary to accommodate these textual\
    \ conventions which are\n   adopted merely for the convenience of readers and\
    \ writers in pursuit\n   of the elusive goal of clear, concise, and unambiguous\
    \ MIB documents.\n   The new data types are: OwnerString and EntryStatus.\n"
- title: 2.3.  Structure of MIB
  contents:
  - "2.3.  Structure of MIB\n   The objects are arranged into the following groups:\n\
    \                  - ethernet statistics\n                  - history control\n\
    \                  - ethernet history\n                  - alarm\n           \
    \       - host\n                  - hostTopN\n                  - matrix\n   \
    \               - filter\n                  - packet capture\n               \
    \   - event\n   These groups are the basic unit of conformance.  If a remote\n\
    \   monitoring device implements a group, then it must implement all\n   objects\
    \ in that group.  For example, a managed agent that implements\n   the host group\
    \ must implement the hostControlTable, the hostTable and\n   the hostTimeTable.\n\
    \   All groups in this MIB are optional.  Implementations of this MIB\n   must\
    \ also implement the system and interfaces group of MIB-II [6].\n   MIB-II may\
    \ also mandate the implementation of additional groups.\n   These groups are defined\
    \ to provide a means of assigning object\n   identifiers, and to provide a method\
    \ for managed agents to know which\n   objects they must implement.\n"
- title: 2.3.1.  The Ethernet Statistics Group
  contents:
  - "2.3.1.  The Ethernet Statistics Group\n   The ethernet statistics group contains\
    \ statistics measured by the\n   probe for each monitored Ethernet interface on\
    \ this device.  This\n   group consists of the etherStatsTable.  In the future\
    \ other groups\n   will be defined for other media types including Token Ring\
    \ and FDDI.\n   These groups should follow the same model as the ethernet statistics\n\
    \   group.\n"
- title: 2.3.2.  The History Control Group
  contents:
  - "2.3.2.  The History Control Group\n   The history control group controls the\
    \ periodic statistical sampling\n   of data from various types of networks.  This\
    \ group consists of the\n   historyControlTable.\n"
- title: 2.3.3.  The Ethernet History Group
  contents:
  - "2.3.3.  The Ethernet History Group\n   The ethernet history group records periodic\
    \ statistical samples from\n   an ethernet network and stores them for later retrieval.\
    \  This group\n   consists of the etherHistoryTable.  In the future, other groups\
    \ will\n   be defined for other media types including Token Ring and FDDI.\n"
- title: 2.3.4.  The Alarm Group
  contents:
  - "2.3.4.  The Alarm Group\n   The alarm group periodically takes statistical samples\
    \ from variables\n   in the probe and compares them to previously configured thresholds.\n\
    \   If the monitored variable crosses a threshold, an event is generated.\n  \
    \ A hysteresis mechanism is implemented to limit the generation of\n   alarms.\
    \  This group consists of the alarmTable and requires the\n   implementation of\
    \ the event group.\n"
- title: 2.3.5.  The Host Group
  contents:
  - "2.3.5.  The Host Group\n   The host group contains statistics associated with\
    \ each host\n   discovered on the network.  This group discovers hosts on the\
    \ network\n   by keeping a list of source and destination MAC Addresses seen in\n\
    \   good packets promiscuously received from the network.  This group\n   consists\
    \ of the hostControlTable, the hostTable, and the\n   hostTimeTable.\n"
- title: 2.3.6.  The HostTopN Group
  contents:
  - "2.3.6.  The HostTopN Group\n   The hostTopN group is used to prepare reports\
    \ that describe the hosts\n   that top a list ordered by one of their statistics.\
    \  The available\n   statistics are samples of one of their base statistics over\
    \ an\n   interval specified by the management station.  Thus, these statistics\n\
    \   are rate based.  The management station also selects how many such\n   hosts\
    \ are reported.  This group consists of the hostTopNControlTable\n   and the hostTopNTable,\
    \ and requires the implementation of the host\n   group.\n"
- title: 2.3.7.  The Matrix Group
  contents:
  - "2.3.7.  The Matrix Group\n   The matrix group stores statistics for conversations\
    \ between sets of\n   two addresses.  As the device detects a new conversation,\
    \ it creates\n   a new entry in its tables.  This group consists of the\n   matrixControlTable,\
    \ the matrixSDTable and the matrixDSTable.\n"
- title: 2.3.8.  The Filter Group
  contents:
  - "2.3.8.  The Filter Group\n   The filter group allows packets to be matched by\
    \ a filter equation.\n   These matched packets form a data stream that may be\
    \ captured or may\n   generate events.  This group consists of the filterTable\
    \ and the\n   channelTable.\n"
- title: 2.3.9.  The Packet Capture Group
  contents:
  - "2.3.9.  The Packet Capture Group\n   The Packet Capture group allows packets\
    \ to be captured after they\n   flow through a channel.  This group consists of\
    \ the\n   bufferControlTable and the captureBufferTable, and requires the\n  \
    \ implementation of the filter group.\n"
- title: 2.3.10.  The Event Group
  contents:
  - "2.3.10.  The Event Group\n   The event group controls the generation and notification\
    \ of events\n   from this device.  This group consists of the eventTable and the\n\
    \   logTable.\n"
- title: 3.  Control of Remote Network Monitoring Devices
  contents:
  - "3.  Control of Remote Network Monitoring Devices\n   Due to the complex nature\
    \ of the available functions in these\n   devices, the functions often need user\
    \ configuration.  In many cases,\n   the function requires parameters to be set\
    \ up for a data collection\n   operation.  The operation can proceed only after\
    \ these parameters are\n   fully set up.\n   Many functional groups in this MIB\
    \ have one or more tables in which\n   to set up control parameters, and one or\
    \ more data tables in which to\n   place the results of the operation.  The control\
    \ tables are typically\n   read-write in nature, while the data tables are typically\
    \ read-only.\n   Because the parameters in the control table often describe resulting\n\
    \   data in the data table, many of the parameters can be modified only\n   when\
    \ the control entry is invalid.  Thus, the method for modifying\n   these parameters\
    \ is to invalidate the control entry, causing its\n   deletion and the deletion\
    \ of any associated data entries, and then\n   create a new control entry with\
    \ the proper parameters.  Deleting the\n   control entry also gives a convenient\
    \ method for reclaiming the\n   resources used by the associated data.\n   Some\
    \ objects in this MIB provide a mechanism to execute an action on\n   the remote\
    \ monitoring device.  These objects may execute an action as\n   a result of a\
    \ change in the state of the object.  For those objects\n   in this MIB, a request\
    \ to set an object to the same value as it\n   currently holds would thus cause\
    \ no action to occur.\n   To facilitate control by multiple managers, resources\
    \ have to be\n   shared among the managers.  These resources are typically the\
    \ memory\n   and computation resources that a function requires.\n"
- title: 3.1.  Resource Sharing Among Multiple Management Stations
  contents:
  - "3.1.  Resource Sharing Among Multiple Management Stations\n   When multiple management\
    \ stations wish to use functions that compete\n   for a finite amount of resources\
    \ on a device, a method to facilitate\n   this sharing of resources is required.\
    \  Potential conflicts include:\n              o Two management stations wish\
    \ to simultaneously use\n                resources that together would exceed\
    \ the capability of\n                the device.\n              o A management\
    \ station uses a significant amount of\n                resources for a long period\
    \ of time.\n              o A management station uses resources and then crashes,\n\
    \                forgetting to free the resources so others may\n            \
    \    use them.\n   A mechanism is provided for each management station initiated\n\
    \   function in this MIB to avoid these conflicts and to help resolve\n   them\
    \ when they occur.  Each function has a label identifying the\n   initiator (owner)\
    \ of the function.  This label is set by the\n   initiator to provide for the\
    \ following possibilities:\n              o A management station may recognize\
    \ resources it owns\n                and no longer needs.\n              o A network\
    \ operator can find the management station that\n                owns the resource\
    \ and negotiate for it to be freed.\n              o A network operator may decide\
    \ to unilaterally free\n                resources another network operator has\
    \ reserved.\n              o Upon initialization, a management station may recognize\n\
    \                resources it had reserved in the past.  With this\n         \
    \       information it may free the resources if it no longer\n              \
    \  needs them.\n   Management stations and probes should support any format of\
    \ the owner\n   string dictated by the local policy of the organization.  It is\n\
    \   suggested that this name contain one or more of the following: IP\n   address,\
    \ management station name, network manager's name, location,\n   or phone number.\
    \  This information will help users to share the\n   resources more effectively.\n\
    \   There is often default functionality that the device or the\n   administrator\
    \ of the probe (often the network administrator) wishes\n   to set up.  The resources\
    \ associated with this functionality are then\n   owned by the device itself or\
    \ by the network administrator, and are\n   intended to be long-lived.  In this\
    \ case, the device or the\n   administrator will set the relevant owner object\
    \ to a string starting\n   with 'monitor'.  Indiscriminate modification of the\
    \ monitor-owned\n   configuration by network management stations is discouraged.\
    \  In\n   fact, a network management station should only modify these objects\n\
    \   under the direction of the administrator of the probe.\n   Resources on a\
    \ probe are scarce and are typically allocated when\n   control rows are created\
    \ by an application.  Since many applications\n   may be using a probe simultaneously,\
    \ indiscriminate allocation of\n   resources to particular applications is very\
    \ likely to cause resource\n   shortages in the probe.\n   When a network management\
    \ station wishes to utilize a function in a\n   monitor, it is encouraged to first\
    \ scan the control table of that\n   function to find an instance with similar\
    \ parameters to share.  This\n   is especially true for those instances owned\
    \ by the monitor, which\n   can be assumed to change infrequently.  If a management\
    \ station\n   decides to share an instance owned by another management station,\
    \ it\n   should understand that the management station that owns the instance\n\
    \   may indiscriminately modify or delete it.\n   It should be noted that a management\
    \ application should have the most\n   trust in a monitor-owned row because it\
    \ should be changed very\n   infrequently.  A row owned by the management application\
    \ is less\n   long-lived because a network administrator is more likely to re-\n\
    \   assign resources from a row that is in use by one user than from a\n   monitor-owned\
    \ row that is potentially in use by many users.  A row\n   owned by another application\
    \ would be even less long-lived because\n   the other application may delete or\
    \ modify that row completely at its\n   discretion.\n"
- title: 3.2.  Row Addition Among Multiple Management Stations
  contents:
  - "3.2.  Row Addition Among Multiple Management Stations\n   The addition of new\
    \ rows is achieved using the method described in\n   RFC 1212 [9].  In this MIB,\
    \ rows are often added to a table in order\n   to configure a function.  This\
    \ configuration usually involves\n   parameters that control the operation of\
    \ the function.  The agent\n   must check these parameters to make sure they are\
    \ appropriate given\n   restrictions defined in this MIB as well as any implementation\n\
    \   specific restrictions such as lack of resources.  The agent\n   implementor\
    \ may be confused as to when to check these parameters and\n   when to signal\
    \ to the management station that the parameters are\n   invalid.  There are two\
    \ opportunities:\n              o When the management station sets each parameter\
    \ object.\n              o When the management station sets the entry status object\n\
    \                to valid.\n   If the latter is chosen, it would be unclear to\
    \ the management\n   station which of the several parameters was invalid and caused\
    \ the\n   badValue error to be emitted.  Thus, wherever possible, the\n   implementor\
    \ should choose the former as it will provide more\n   information to the management\
    \ station.\n   A problem can arise when multiple management stations attempt to\
    \ set\n   configuration information simultaneously using SNMP.  When this\n  \
    \ involves the addition of a new conceptual row in the same control\n   table,\
    \ the managers may collide, attempting to create the same entry.\n   To guard\
    \ against these collisions, each such control entry contains a\n   status object\
    \ with special semantics that help to arbitrate among the\n   managers.  If an\
    \ attempt is made with the row addition mechanism to\n   create such a status\
    \ object and that object already exists, an error\n   is returned.  When more\
    \ than one manager simultaneously attempts to\n   create the same conceptual row,\
    \ only the first will succeed.  The\n   others will receive an error.\n   When\
    \ a manager wishes to create a new control entry, it needs to\n   choose an index\
    \ for that row.  It may choose this index in a variety\n   of ways, hopefully\
    \ minimizing the chances that the index is in use by\n   another manager.  If\
    \ the index is in use, the mechanism mentioned\n   previously will guard against\
    \ collisions.  Examples of schemes to\n   choose index values include random selection\
    \ or scanning the control\n   table looking for the first unused index.  Because\
    \ index values may\n   be any valid value in the range and they are chosen by\
    \ the manager,\n   the agent must allow a row to be created with any unused index\
    \ value\n   if it has the resources to create a new row.\n   Some tables in this\
    \ MIB reference other tables within this MIB.  When\n   creating or deleting entries\
    \ in these tables, it is generally\n   allowable for dangling references to exist.\
    \  There is no defined\n   order for creating or deleting entries in these tables.\n"
- title: 4.  Conventions
  contents:
  - "4.  Conventions\n   The following conventions are used throughout the RMON MIB\
    \ and its\n   companion documents.\n   Good Packets\n   Good packets are error-free\
    \ packets that have a valid frame length.\n   For example, on Ethernet, good packets\
    \ are error-free packets that\n   are between 64 octets long and 1518 octets long.\
    \  They follow the\n   form defined in IEEE 802.3 section 3.2.all.\n   Bad Packets\n\
    \   Bad packets are packets that have proper framing and are therefore\n   recognized\
    \ as packets, but contain errors within the packet or have\n   an invalid length.\
    \  For example, on Ethernet, bad packets have a\n   valid preamble and SFD, but\
    \ have a bad CRC, or are either shorter\n   than 64 octets or longer than 1518\
    \ octets.\n"
- title: 5.  Definitions
  contents:
  - "5.  Definitions\n          RMON-MIB DEFINITIONS ::= BEGIN\n              IMPORTS\n\
    \                  Counter                FROM RFC1155-SMI\n                 \
    \ DisplayString          FROM RFC1158-MIB\n                  mib-2           \
    \       FROM RFC1213-MIB\n                  OBJECT-TYPE            FROM RFC-1212\n\
    \                  TRAP-TYPE              FROM RFC-1215;\n          --  Remote\
    \ Network Monitoring MIB\n              rmon    OBJECT IDENTIFIER ::= { mib-2\
    \ 16 }\n              -- textual conventions\n              OwnerString ::= DisplayString\n\
    \              -- This data type is used to model an administratively\n      \
    \        -- assigned name of the owner of a resource. This\n              -- information\
    \ is taken from the NVT ASCII character\n              -- set.  It is suggested\
    \ that this name contain one or\n              -- more of the following: IP address,\
    \ management station\n              -- name, network manager's name, location,\
    \ or phone\n              -- number.\n              -- In some cases the agent\
    \ itself will be the owner of\n              -- an entry.  In these cases, this\
    \ string shall be set\n              -- to a string starting with 'monitor'.\n\
    \              --\n              -- SNMP access control is articulated entirely\
    \ in terms\n              -- of the contents of MIB views; access to a particular\n\
    \              -- SNMP object instance depends only upon its presence\n      \
    \        -- or absence in a particular MIB view and never upon\n             \
    \ -- its value or the value of related object instances.\n              -- Thus,\
    \ objects of this type afford resolution of\n              -- resource contention\
    \ only among cooperating managers;\n              -- they realize no access control\
    \ function with respect\n              -- to uncooperative parties.\n        \
    \      --\n              -- By convention, objects with this syntax are declared\
    \ as\n              -- having\n              --\n              --      SIZE (0..127)\n\
    \              EntryStatus ::= INTEGER\n                         { valid(1),\n\
    \                           createRequest(2),\n                           underCreation(3),\n\
    \                           invalid(4)\n                         }\n         \
    \     -- The status of a table entry.\n              --\n              -- Setting\
    \ this object to the value invalid(4) has the\n              -- effect of invalidating\
    \ the corresponding entry.\n              -- That is, it effectively disassociates\
    \ the mapping\n              -- identified with said entry.\n              --\
    \ It is an implementation-specific matter as to whether\n              -- the\
    \ agent removes an invalidated entry from the table.\n              -- Accordingly,\
    \ management stations must be prepared to\n              -- receive tabular information\
    \ from agents that\n              -- corresponds to entries currently not in use.\
    \  Proper\n              -- interpretation of such entries requires examination\n\
    \              -- of the relevant EntryStatus object.\n              --\n    \
    \          -- An existing instance of this object cannot be set to\n         \
    \     -- createRequest(2).  This object may only be set to\n              -- createRequest(2)\
    \ when this instance is created.  When\n              -- this object is created,\
    \ the agent may wish to create\n              -- supplemental object instances\
    \ with default values\n              -- to complete a conceptual row in this table.\
    \  Because\n              -- the creation of these default objects is entirely\
    \ at\n              -- the option of the agent, the manager must not assume\n\
    \              -- that any will be created, but may make use of any that\n   \
    \           -- are created. Immediately after completing the create\n        \
    \      -- operation, the agent must set this object to\n              -- underCreation(3).\n\
    \              --\n              -- When in the underCreation(3) state, an entry\
    \ is\n              -- allowed to exist in a possibly incomplete, possibly\n \
    \             -- inconsistent state, usually to allow it to be\n             \
    \ -- modified in mutiple PDUs.  When in this state, an\n              -- entry\
    \ is not fully active.  Entries shall exist in\n              -- the underCreation(3)\
    \ state until the management\n              -- station is finished configuring\
    \ the entry and sets\n              -- this object to valid(1) or aborts, setting\
    \ this\n              -- object to invalid(4).  If the agent determines that\n\
    \              -- an entry has been in the underCreation(3) state for\n      \
    \        -- an abnormally long time, it may decide that the\n              --\
    \ management station has crashed.  If the agent makes\n              -- this decision,\
    \ it may set this object to invalid(4)\n              -- to reclaim the entry.\
    \  A prudent agent will\n              -- understand that the management station\
    \ may need to\n              -- wait for human input and will allow for that\n\
    \              -- possibility in its determination of this abnormally\n      \
    \        -- long period.\n              --\n              -- An entry in the valid(1)\
    \ state is fully configured and\n              -- consistent and fully represents\
    \ the configuration or\n              -- operation such a row is intended to represent.\
    \  For\n              -- example, it could be a statistical function that is\n\
    \              -- configured and active, or a filter that is available\n     \
    \         -- in the list of filters processed by the packet capture\n        \
    \      -- process.\n              --\n              -- A manager is restricted\
    \ to changing the state of an\n              -- entry in the following ways:\n\
    \              --\n              --                       create   under\n   \
    \           --      To:       valid  Request  Creation  invalid\n            \
    \  -- From:\n              -- valid             OK       NO        OK       OK\n\
    \              -- createRequest    N/A      N/A       N/A      N/A\n         \
    \     -- underCreation     OK       NO        OK       OK\n              -- invalid\
    \           NO       NO        NO       OK\n              -- nonExistent     \
    \  NO       OK        NO       OK\n              --\n              -- In the table\
    \ above, it is not applicable to move the\n              -- state from the createRequest\
    \ state to any other\n              -- state because the manager will never find\
    \ the\n              -- variable in that state.  The nonExistent state is\n  \
    \            -- not a value of the enumeration, rather it means that\n       \
    \       -- the entryStatus variable does not exist at all.\n              --\n\
    \              -- An agent may allow an entryStatus variable to change\n     \
    \         -- state in additional ways, so long as the semantics\n            \
    \  -- of the states are followed.  This allowance is made\n              -- to\
    \ ease the implementation of the agent and is made\n              -- despite the\
    \ fact that managers should never\n              -- excercise these additional\
    \ state transitions.\n              statistics        OBJECT IDENTIFIER ::= {\
    \ rmon 1 }\n              history           OBJECT IDENTIFIER ::= { rmon 2 }\n\
    \              alarm             OBJECT IDENTIFIER ::= { rmon 3 }\n          \
    \    hosts             OBJECT IDENTIFIER ::= { rmon 4 }\n              hostTopN\
    \          OBJECT IDENTIFIER ::= { rmon 5 }\n              matrix            OBJECT\
    \ IDENTIFIER ::= { rmon 6 }\n              filter            OBJECT IDENTIFIER\
    \ ::= { rmon 7 }\n              capture           OBJECT IDENTIFIER ::= { rmon\
    \ 8 }\n              event             OBJECT IDENTIFIER ::= { rmon 9 }\n    \
    \      -- The Ethernet Statistics Group\n          --\n          -- Implementation\
    \ of the Ethernet Statistics group is\n          -- optional.\n          --\n\
    \          -- The ethernet statistics group contains statistics\n          --\
    \ measured by the probe for each monitored interface on\n          -- this device.\
    \  These statistics take the form of free\n          -- running counters that\
    \ start from zero when a valid entry\n          -- is created.\n          --\n\
    \          -- This group currently has statistics defined only for\n         \
    \ -- Ethernet interfaces.  Each etherStatsEntry contains\n          -- statistics\
    \ for one Ethernet interface.  The probe must\n          -- create one etherStats\
    \ entry for each monitored Ethernet\n          -- interface on the device.\n \
    \         etherStatsTable OBJECT-TYPE\n              SYNTAX SEQUENCE OF EtherStatsEntry\n\
    \              ACCESS not-accessible\n              STATUS mandatory\n       \
    \       DESCRIPTION\n                  \"A list of Ethernet statistics entries.\"\
    \n              ::= { statistics 1 }\n          etherStatsEntry OBJECT-TYPE\n\
    \              SYNTAX EtherStatsEntry\n              ACCESS not-accessible\n \
    \             STATUS mandatory\n              DESCRIPTION\n                  \"\
    A collection of statistics kept for a particular\n                  Ethernet interface.\
    \  As an example, an instance of the\n                  etherStatsPkts object\
    \ might be named etherStatsPkts.1\"\n              INDEX { etherStatsIndex }\n\
    \              ::= { etherStatsTable 1 }\n          EtherStatsEntry ::= SEQUENCE\
    \ {\n              etherStatsIndex                    INTEGER (1..65535),\n  \
    \            etherStatsDataSource               OBJECT IDENTIFIER,\n         \
    \     etherStatsDropEvents               Counter,\n              etherStatsOctets\
    \                   Counter,\n              etherStatsPkts                   \
    \  Counter,\n              etherStatsBroadcastPkts            Counter,\n     \
    \         etherStatsMulticastPkts            Counter,\n              etherStatsCRCAlignErrors\
    \           Counter,\n              etherStatsUndersizePkts            Counter,\n\
    \              etherStatsOversizePkts             Counter,\n              etherStatsFragments\
    \                Counter,\n              etherStatsJabbers                  Counter,\n\
    \              etherStatsCollisions               Counter,\n              etherStatsPkts64Octets\
    \             Counter,\n              etherStatsPkts65to127Octets        Counter,\n\
    \              etherStatsPkts128to255Octets       Counter,\n              etherStatsPkts256to511Octets\
    \       Counter,\n              etherStatsPkts512to1023Octets      Counter,\n\
    \              etherStatsPkts1024to1518Octets     Counter,\n              etherStatsOwner\
    \                    OwnerString,\n              etherStatsStatus            \
    \       EntryStatus\n          }\n          etherStatsIndex OBJECT-TYPE\n    \
    \          SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n       \
    \       STATUS mandatory\n              DESCRIPTION\n                  \"The value\
    \ of this object uniquely identifies this\n                  etherStats entry.\"\
    \n              ::= { etherStatsEntry 1 }\n          etherStatsDataSource OBJECT-TYPE\n\
    \              SYNTAX OBJECT IDENTIFIER\n              ACCESS read-write\n   \
    \           STATUS mandatory\n              DESCRIPTION\n                  \"\
    This object identifies the source of the data that\n                  this etherStats\
    \ entry is configured to analyze.  This\n                  source can be any ethernet\
    \ interface on this device.\n                  In order to identify a particular\
    \ interface, this\n                  object shall identify the instance of the\
    \ ifIndex\n                  object, defined in RFC 1213 and RFC 1573 [4,6], for\n\
    \                  the desired interface.  For example, if an entry\n        \
    \          were to receive data from interface #1, this object\n             \
    \     would be set to ifIndex.1.\n                  The statistics in this group\
    \ reflect all packets\n                  on the local network segment attached\
    \ to the\n                  identified interface.\n                  An agent\
    \ may or may not be able to tell if\n                  fundamental changes to\
    \ the media of the interface\n                  have occurred and necessitate\
    \ an invalidation of\n                  this entry.  For example, a hot-pluggable\
    \ ethernet\n                  card could be pulled out and replaced by a\n   \
    \               token-ring card.  In such a case, if the agent has\n         \
    \         such knowledge of the change, it is recommended that\n             \
    \     it invalidate this entry.\n                  This object may not be modified\
    \ if the associated\n                  etherStatsStatus object is equal to valid(1).\"\
    \n              ::= { etherStatsEntry 2 }\n          etherStatsDropEvents OBJECT-TYPE\n\
    \              SYNTAX Counter\n              ACCESS read-only\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The total number of\
    \ events in which packets\n                  were dropped by the probe due to\
    \ lack of resources.\n                  Note that this number is not necessarily\
    \ the number of\n                  packets dropped; it is just the number of times\
    \ this\n                  condition has been detected.\"\n              ::= {\
    \ etherStatsEntry 3 }\n          etherStatsOctets OBJECT-TYPE\n              SYNTAX\
    \ Counter\n              ACCESS read-only\n              STATUS mandatory\n  \
    \            DESCRIPTION\n                  \"The total number of octets of data\
    \ (including\n                  those in bad packets) received on the\n      \
    \            network (excluding framing bits but including\n                 \
    \ FCS octets).\n                  This object can be used as a reasonable estimate\
    \ of\n                  ethernet utilization.  If greater precision is\n     \
    \             desired, the etherStatsPkts and etherStatsOctets\n             \
    \     objects should be sampled before and after a common\n                  interval.\
    \  The differences in the sampled values are\n                  Pkts and Octets,\
    \ respectively, and the number of\n                  seconds in the interval is\
    \ Interval.  These values\n                  are used to calculate the Utilization\
    \ as follows:\n                                   Pkts * (9.6 + 6.4) + (Octets\
    \ * .8)\n                   Utilization = -------------------------------------\n\
    \                                           Interval * 10,000\n              \
    \    The result of this equation is the value Utilization\n                  which\
    \ is the percent utilization of the ethernet\n                  segment on a scale\
    \ of 0 to 100 percent.\"\n              ::= { etherStatsEntry 4 }\n          etherStatsPkts\
    \ OBJECT-TYPE\n              SYNTAX Counter\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The total number of packets (including bad packets,\n                  broadcast\
    \ packets, and multicast packets) received.\"\n              ::= { etherStatsEntry\
    \ 5 }\n          etherStatsBroadcastPkts OBJECT-TYPE\n              SYNTAX Counter\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The total number of good packets received\
    \ that were\n                  directed to the broadcast address.  Note that this\n\
    \                  does not include multicast packets.\"\n              ::= {\
    \ etherStatsEntry 6 }\n          etherStatsMulticastPkts OBJECT-TYPE\n       \
    \       SYNTAX Counter\n              ACCESS read-only\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"The total number of good packets\
    \ received that were\n                  directed to a multicast address.  Note\
    \ that this\n                  number does not include packets directed to the\n\
    \                  broadcast address.\"\n              ::= { etherStatsEntry 7\
    \ }\n          etherStatsCRCAlignErrors OBJECT-TYPE\n              SYNTAX Counter\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The total number of packets received that\n\
    \                  had a length (excluding framing bits, but\n               \
    \   including FCS octets) of between 64 and 1518\n                  octets, inclusive,\
    \ but but had either a bad\n                  Frame Check Sequence (FCS) with\
    \ an integral\n                  number of octets (FCS Error) or a bad FCS with\n\
    \                  a non-integral number of octets (Alignment Error).\"\n    \
    \          ::= { etherStatsEntry 8 }\n          etherStatsUndersizePkts OBJECT-TYPE\n\
    \              SYNTAX Counter\n              ACCESS read-only\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The total number of\
    \ packets received that were\n                  less than 64 octets long (excluding\
    \ framing bits,\n                  but including FCS octets) and were otherwise\
    \ well\n                  formed.\"\n              ::= { etherStatsEntry 9 }\n\
    \          etherStatsOversizePkts OBJECT-TYPE\n              SYNTAX Counter\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The total number of packets received that\
    \ were\n                  longer than 1518 octets (excluding framing bits,\n \
    \                 but including FCS octets) and were otherwise\n             \
    \     well formed.\"\n              ::= { etherStatsEntry 10 }\n          etherStatsFragments\
    \ OBJECT-TYPE\n              SYNTAX Counter\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The total number of packets received that were less\n                  than\
    \ 64 octets in length (excluding framing bits but\n                  including\
    \ FCS octets) and had either a bad Frame\n                  Check Sequence (FCS)\
    \ with an integral number of\n                  octets (FCS Error) or a bad FCS\
    \ with a non-integral\n                  number of octets (Alignment Error).\n\
    \                  Note that it is entirely normal for\n                  etherStatsFragments\
    \ to increment.  This is because\n                  it counts both runts (which\
    \ are normal occurrences\n                  due to collisions) and noise hits.\"\
    \n              ::= { etherStatsEntry 11 }\n          etherStatsJabbers OBJECT-TYPE\n\
    \              SYNTAX Counter\n              ACCESS read-only\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The total number of\
    \ packets received that were\n                  longer than 1518 octets (excluding\
    \ framing bits,\n                  but including FCS octets), and had either a\
    \ bad\n                  Frame Check Sequence (FCS) with an integral number\n\
    \                  of octets (FCS Error) or a bad FCS with a\n               \
    \   non-integral number of octets (Alignment Error).\n                  Note that\
    \ this definition of jabber is different\n                  than the definition\
    \ in IEEE-802.3 section 8.2.1.5\n                  (10BASE5) and section 10.3.1.4\
    \ (10BASE2).  These\n                  documents define jabber as the condition\
    \ where any\n                  packet exceeds 20 ms.  The allowed range to detect\n\
    \                  jabber is between 20 ms and 150 ms.\"\n              ::= {\
    \ etherStatsEntry 12 }\n          etherStatsCollisions OBJECT-TYPE\n         \
    \     SYNTAX Counter\n              ACCESS read-only\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"The best estimate of the total\
    \ number of collisions\n                  on this Ethernet segment.\n        \
    \          The value returned will depend on the location of\n               \
    \   the RMON probe. Section 8.2.1.3 (10BASE-5) and\n                  section\
    \ 10.3.1.3 (10BASE-2) of IEEE standard 802.3\n                  states that a\
    \ station must detect a collision, in\n                  the receive mode, if\
    \ three or more stations are\n                  transmitting simultaneously. \
    \ A repeater port must\n                  detect a collision when two or more\
    \ stations are\n                  transmitting simultaneously.  Thus a probe placed\
    \ on\n                  a repeater port could record more collisions than a\n\
    \                  probe connected to a station on the same segment\n        \
    \          would.\n                  Probe location plays a much smaller role\
    \ when\n                  considering 10BASE-T.  14.2.1.4 (10BASE-T) of IEEE\n\
    \                  standard 802.3 defines a collision as the\n               \
    \   simultaneous presence of signals on the DO and RD\n                  circuits\
    \ (transmitting and receiving at the same\n                  time).  A 10BASE-T\
    \ station can only detect\n                  collisions when it is transmitting.\
    \  Thus probes\n                  placed on a station and a repeater, should report\n\
    \                  the same number of collisions.\n                  Note also\
    \ that an RMON probe inside a repeater\n                  should ideally report\
    \ collisions between the\n                  repeater and one or more other hosts\
    \ (transmit\n                  collisions as defined by IEEE 802.3k) plus receiver\n\
    \                  collisions observed on any coax segments to which\n       \
    \           the repeater is connected.\"\n              ::= { etherStatsEntry\
    \ 13 }\n          etherStatsPkts64Octets OBJECT-TYPE\n              SYNTAX Counter\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The total number of packets (including bad\n\
    \                  packets) received that were 64 octets in length\n         \
    \         (excluding framing bits but including FCS octets).\"\n             \
    \ ::= { etherStatsEntry 14 }\n          etherStatsPkts65to127Octets OBJECT-TYPE\n\
    \              SYNTAX Counter\n              ACCESS read-only\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The total number of\
    \ packets (including bad\n                  packets) received that were between\n\
    \                  65 and 127 octets in length inclusive\n                  (excluding\
    \ framing bits but including FCS octets).\"\n              ::= { etherStatsEntry\
    \ 15 }\n          etherStatsPkts128to255Octets OBJECT-TYPE\n              SYNTAX\
    \ Counter\n              ACCESS read-only\n              STATUS mandatory\n  \
    \            DESCRIPTION\n                  \"The total number of packets (including\
    \ bad\n                  packets) received that were between\n               \
    \   128 and 255 octets in length inclusive\n                  (excluding framing\
    \ bits but including FCS octets).\"\n              ::= { etherStatsEntry 16 }\n\
    \          etherStatsPkts256to511Octets OBJECT-TYPE\n              SYNTAX Counter\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The total number of packets (including bad\n\
    \                  packets) received that were between\n                  256\
    \ and 511 octets in length inclusive\n                  (excluding framing bits\
    \ but including FCS octets).\"\n              ::= { etherStatsEntry 17 }\n   \
    \       etherStatsPkts512to1023Octets OBJECT-TYPE\n              SYNTAX Counter\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The total number of packets (including bad\n\
    \                  packets) received that were between\n                  512\
    \ and 1023 octets in length inclusive\n                  (excluding framing bits\
    \ but including FCS octets).\"\n              ::= { etherStatsEntry 18 }\n   \
    \       etherStatsPkts1024to1518Octets OBJECT-TYPE\n              SYNTAX Counter\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The total number of packets (including bad\n\
    \                  packets) received that were between\n                  1024\
    \ and 1518 octets in length inclusive\n                  (excluding framing bits\
    \ but including FCS octets).\"\n              ::= { etherStatsEntry 19 }\n   \
    \       etherStatsOwner OBJECT-TYPE\n              SYNTAX OwnerString\n      \
    \        ACCESS read-write\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"The entity that configured this entry and is\n          \
    \        therefore using the resources assigned to it.\"\n              ::= {\
    \ etherStatsEntry 20 }\n          etherStatsStatus OBJECT-TYPE\n             \
    \ SYNTAX EntryStatus\n              ACCESS read-write\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"The status of this etherStats\
    \ entry.\"\n              ::= { etherStatsEntry 21 }\n          -- The History\
    \ Control Group\n          -- Implementation of the History Control group is optional.\n\
    \          --\n          -- The history control group controls the periodic statistical\n\
    \          -- sampling of data from various types of networks.  The\n        \
    \  -- historyControlTable stores configuration entries that each\n          --\
    \ define an interface, polling period, and other parameters.\n          -- Once\
    \ samples are taken, their data is stored in an entry\n          -- in a media-specific\
    \ table.  Each such entry defines one\n          -- sample, and is associated\
    \ with the historyControlEntry that\n          -- caused the sample to be taken.\
    \  Each counter in the\n          -- etherHistoryEntry counts the same event as\
    \ its\n          -- similarly-named counterpart in the etherStatsEntry,\n    \
    \      -- except that each value here is a cumulative sum during a\n         \
    \ -- sampling period.\n          --\n          -- If the probe keeps track of\
    \ the time of day, it should\n          -- start the first sample of the history\
    \ at a time such that\n          -- when the next hour of the day begins, a sample\
    \ is\n          -- started at that instant.  This tends to make more\n       \
    \   -- user-friendly reports, and enables comparison of reports\n          --\
    \ from different probes that have relatively accurate time\n          -- of day.\n\
    \          --\n          -- The probe is encouraged to add two history control\
    \ entries\n          -- per monitored interface upon initialization that describe\n\
    \          -- a short term and a long term polling period.  Suggested\n      \
    \    -- parameters are 30 seconds for the short term polling period\n        \
    \  -- and 30 minutes for the long term period.\n          historyControlTable\
    \ OBJECT-TYPE\n              SYNTAX SEQUENCE OF HistoryControlEntry\n        \
    \      ACCESS not-accessible\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"A list of history control entries.\"\n              ::= {\
    \ history 1 }\n          historyControlEntry OBJECT-TYPE\n              SYNTAX\
    \ HistoryControlEntry\n              ACCESS not-accessible\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"A list of parameters\
    \ that set up a periodic sampling\n                  of statistics.  As an example,\
    \ an instance of the\n                  historyControlInterval object might be\
    \ named\n                  historyControlInterval.2\"\n              INDEX { historyControlIndex\
    \ }\n              ::= { historyControlTable 1 }\n          HistoryControlEntry\
    \ ::= SEQUENCE {\n              historyControlIndex             INTEGER (1..65535),\n\
    \              historyControlDataSource        OBJECT IDENTIFIER,\n          \
    \    historyControlBucketsRequested  INTEGER (1..65535),\n              historyControlBucketsGranted\
    \    INTEGER (1..65535),\n              historyControlInterval          INTEGER\
    \ (1..3600),\n              historyControlOwner             OwnerString,\n   \
    \           historyControlStatus            EntryStatus\n          }\n       \
    \   historyControlIndex OBJECT-TYPE\n              SYNTAX INTEGER (1..65535)\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"An index that uniquely identifies an entry\
    \ in the\n                  historyControl table.  Each such entry defines a\n\
    \                  set of samples at a particular interval for an\n          \
    \        interface on the device.\"\n              ::= { historyControlEntry 1\
    \ }\n          historyControlDataSource OBJECT-TYPE\n              SYNTAX OBJECT\
    \ IDENTIFIER\n              ACCESS read-write\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"This object identifies the source\
    \ of the data for\n                  which historical data was collected and\n\
    \                  placed in a media-specific table on behalf of this\n      \
    \            historyControlEntry.  This source can be any\n                  interface\
    \ on this device.  In order to identify\n                  a particular interface,\
    \ this object shall identify\n                  the instance of the ifIndex object,\
    \ defined\n                  in  RFC 1213 and RFC 1573 [4,6], for the desired\n\
    \                  interface.  For example, if an entry were to receive\n    \
    \              data from interface #1, this object would be set\n            \
    \      to ifIndex.1.\n                  The statistics in this group reflect all\
    \ packets\n                  on the local network segment attached to the\n  \
    \                identified interface.\n                  An agent may or may\
    \ not be able to tell if fundamental\n                  changes to the media of\
    \ the interface have occurred\n                  and necessitate an invalidation\
    \ of this entry.  For\n                  example, a hot-pluggable ethernet card\
    \ could be\n                  pulled out and replaced by a token-ring card.  In\n\
    \                  such a case, if the agent has such knowledge of the\n     \
    \             change, it is recommended that it invalidate this\n            \
    \      entry.\n                  This object may not be modified if the associated\n\
    \                  historyControlStatus object is equal to valid(1).\"\n     \
    \         ::= { historyControlEntry 2 }\n          historyControlBucketsRequested\
    \ OBJECT-TYPE\n              SYNTAX INTEGER (1..65535)\n              ACCESS read-write\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The requested number of discrete time intervals\n                  over which\
    \ data is to be saved in the part of the\n                  media-specific table\
    \ associated with this\n                  historyControlEntry.\n             \
    \     When this object is created or modified, the probe\n                  should\
    \ set historyControlBucketsGranted as closely to\n                  this object\
    \ as is possible for the particular probe\n                  implementation and\
    \ available resources.\"\n              DEFVAL { 50 }\n              ::= { historyControlEntry\
    \ 3 }\n          historyControlBucketsGranted OBJECT-TYPE\n              SYNTAX\
    \ INTEGER (1..65535)\n              ACCESS read-only\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"The number of discrete sampling\
    \ intervals\n                  over which data shall be saved in the part of\n\
    \                  the media-specific table associated with this\n           \
    \       historyControlEntry.\n                  When the associated historyControlBucketsRequested\n\
    \                  object is created or modified, the probe\n                \
    \  should set this object as closely to the requested\n                  value\
    \ as is possible for the particular\n                  probe implementation and\
    \ available resources.  The\n                  probe must not lower this value\
    \ except as a result\n                  of a modification to the associated\n\
    \                  historyControlBucketsRequested object.\n                  There\
    \ will be times when the actual number of\n                  buckets associated\
    \ with this entry is less than\n                  the value of this object.  In\
    \ this case, at the\n                  end of each sampling interval, a new bucket\
    \ will\n                  be added to the media-specific table.\n            \
    \      When the number of buckets reaches the value of\n                  this\
    \ object and a new bucket is to be added to the\n                  media-specific\
    \ table, the oldest bucket associated\n                  with this historyControlEntry\
    \ shall be deleted by\n                  the agent so that the new bucket can\
    \ be added.\n                  When the value of this object changes to a value\
    \ less\n                  than the current value, entries are deleted\n      \
    \            from the media-specific table associated with this\n            \
    \      historyControlEntry.  Enough of the oldest of these\n                 \
    \ entries shall be deleted by the agent so that their\n                  number\
    \ remains less than or equal to the new value of\n                  this object.\n\
    \                  When the value of this object changes to a value\n        \
    \          greater than the current value, the number of\n                  associated\
    \ media- specific entries may be allowed to\n                  grow.\"\n     \
    \         ::= { historyControlEntry 4 }\n          historyControlInterval OBJECT-TYPE\n\
    \              SYNTAX INTEGER (1..3600)\n              ACCESS read-write\n   \
    \           STATUS mandatory\n              DESCRIPTION\n                  \"\
    The interval in seconds over which the data is\n                  sampled for\
    \ each bucket in the part of the\n                  media-specific table associated\
    \ with this\n                  historyControlEntry.  This interval can\n     \
    \             be set to any number of seconds between 1 and\n                \
    \  3600 (1 hour).\n                  Because the counters in a bucket may overflow\
    \ at their\n                  maximum value with no indication, a prudent manager\n\
    \                  will take into account the possibility of overflow\n      \
    \            in any of the associated counters.  It is important\n           \
    \       to consider the minimum time in which any counter\n                  could\
    \ overflow on a particular media type and set\n                  the historyControlInterval\
    \ object to a value less\n                  than this interval.  This is typically\
    \ most\n                  important for the 'octets' counter in any\n        \
    \          media-specific table.  For example, on an Ethernet\n              \
    \    network, the etherHistoryOctets counter could\n                  overflow\
    \ in about one hour at the Ethernet's maximum\n                  utilization.\n\
    \                  This object may not be modified if the associated\n       \
    \           historyControlStatus object is equal to valid(1).\"\n            \
    \  DEFVAL { 1800 }\n              ::= { historyControlEntry 5 }\n          historyControlOwner\
    \ OBJECT-TYPE\n              SYNTAX OwnerString\n              ACCESS read-write\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The entity that configured this entry and is\n                  therefore\
    \ using the resources assigned to it.\"\n              ::= { historyControlEntry\
    \ 6 }\n          historyControlStatus OBJECT-TYPE\n              SYNTAX EntryStatus\n\
    \              ACCESS read-write\n              STATUS mandatory\n           \
    \   DESCRIPTION\n                  \"The status of this historyControl entry.\n\
    \                  Each instance of the media-specific table associated\n    \
    \              with this historyControlEntry will be deleted by the\n        \
    \          agent if this historyControlEntry is not equal to\n               \
    \   valid(1).\"\n              ::= { historyControlEntry 7 }\n          -- The\
    \ Ethernet History Group\n          -- Implementation of the Ethernet History\
    \ group is optional.\n          --\n          -- The Ethernet History group records\
    \ periodic\n          -- statistical samples from a network and stores them\n\
    \          -- for later retrieval.  Once samples are taken, their\n          --\
    \ data is stored in an entry in a media-specific\n          -- table.  Each such\
    \ entry defines one sample, and is\n          -- associated with the historyControlEntry\
    \ that caused\n          -- the sample to be taken.  This group defines the\n\
    \          -- etherHistoryTable, for Ethernet networks.\n          --\n      \
    \    etherHistoryTable OBJECT-TYPE\n              SYNTAX SEQUENCE OF EtherHistoryEntry\n\
    \              ACCESS not-accessible\n              STATUS mandatory\n       \
    \       DESCRIPTION\n                  \"A list of Ethernet history entries.\"\
    \n              ::= { history 2 }\n          etherHistoryEntry OBJECT-TYPE\n \
    \             SYNTAX EtherHistoryEntry\n              ACCESS not-accessible\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"An historical sample of Ethernet statistics on a\n                  particular\
    \ Ethernet interface.  This sample is\n                  associated with the historyControlEntry\
    \ which set up\n                  the parameters for a regular collection of these\n\
    \                  samples.  As an example, an instance of the\n             \
    \     etherHistoryPkts object might be named\n                  etherHistoryPkts.2.89\"\
    \n              INDEX { etherHistoryIndex , etherHistorySampleIndex }\n      \
    \        ::= { etherHistoryTable 1 }\n          EtherHistoryEntry ::= SEQUENCE\
    \ {\n              etherHistoryIndex                 INTEGER (1..65535),\n   \
    \           etherHistorySampleIndex           INTEGER (1..2147483647),\n     \
    \         etherHistoryIntervalStart         TimeTicks,\n              etherHistoryDropEvents\
    \            Counter,\n              etherHistoryOctets                Counter,\n\
    \              etherHistoryPkts                  Counter,\n              etherHistoryBroadcastPkts\
    \         Counter,\n              etherHistoryMulticastPkts         Counter,\n\
    \              etherHistoryCRCAlignErrors        Counter,\n              etherHistoryUndersizePkts\
    \         Counter,\n              etherHistoryOversizePkts          Counter,\n\
    \              etherHistoryFragments             Counter,\n              etherHistoryJabbers\
    \               Counter,\n              etherHistoryCollisions            Counter,\n\
    \              etherHistoryUtilization           INTEGER (0..10000)\n        \
    \  }\n          etherHistoryIndex OBJECT-TYPE\n              SYNTAX INTEGER (1..65535)\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The history of which this entry is a part.\
    \  The\n                  history identified by a particular value of this\n \
    \                 index is the same history as identified\n                  by\
    \ the same value of historyControlIndex.\"\n              ::= { etherHistoryEntry\
    \ 1 }\n          etherHistorySampleIndex OBJECT-TYPE\n              SYNTAX INTEGER\
    \ (1..2147483647)\n              ACCESS read-only\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"An index that uniquely identifies\
    \ the particular\n                  sample this entry represents among all samples\n\
    \                  associated with the same historyControlEntry.\n           \
    \       This index starts at 1 and increases by one\n                  as each\
    \ new sample is taken.\"\n              ::= { etherHistoryEntry 2 }\n        \
    \  etherHistoryIntervalStart OBJECT-TYPE\n              SYNTAX TimeTicks\n   \
    \           ACCESS read-only\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"The value of sysUpTime at the start of the interval\n   \
    \               over which this sample was measured.  If the probe\n         \
    \         keeps track of the time of day, it should start\n                  the\
    \ first sample of the history at a time such that\n                  when the\
    \ next hour of the day begins, a sample is\n                  started at that\
    \ instant.  Note that following this\n                  rule may require the probe\
    \ to delay collecting the\n                  first sample of the history, as each\
    \ sample must be\n                  of the same interval.  Also note that the\
    \ sample which\n                  is currently being collected is not accessible\
    \ in this\n                  table until the end of its interval.\"\n        \
    \      ::= { etherHistoryEntry 3 }\n          etherHistoryDropEvents OBJECT-TYPE\n\
    \              SYNTAX Counter\n              ACCESS read-only\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The total number of\
    \ events in which packets\n                  were dropped by the probe due to\
    \ lack of resources\n                  during this sampling interval.  Note that\
    \ this number\n              is not necessarily the number of packets dropped,\
    \ it\n              is just the number of times this condition has been\n    \
    \          detected.\"\n              ::= { etherHistoryEntry 4 }\n          etherHistoryOctets\
    \ OBJECT-TYPE\n              SYNTAX Counter\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The total number of octets of data (including\n                  those in\
    \ bad packets) received on the\n                  network (excluding framing bits\
    \ but including\n                  FCS octets).\"\n              ::= { etherHistoryEntry\
    \ 5 }\n          etherHistoryPkts OBJECT-TYPE\n              SYNTAX Counter\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The number of packets (including bad packets)\n\
    \                  received during this sampling interval.\"\n              ::=\
    \ { etherHistoryEntry 6 }\n          etherHistoryBroadcastPkts OBJECT-TYPE\n \
    \             SYNTAX Counter\n              ACCESS read-only\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The number of good\
    \ packets received during this\n                  sampling interval that were\
    \ directed to the\n                  broadcast address.\"\n              ::= {\
    \ etherHistoryEntry 7 }\n          etherHistoryMulticastPkts OBJECT-TYPE\n   \
    \           SYNTAX Counter\n              ACCESS read-only\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The number of good\
    \ packets received during this\n                  sampling interval that were\
    \ directed to a\n                  multicast address.  Note that this number does\
    \ not\n                  include packets addressed to the broadcast address.\"\
    \n              ::= { etherHistoryEntry 8 }\n          etherHistoryCRCAlignErrors\
    \ OBJECT-TYPE\n              SYNTAX Counter\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The number of packets received during this sampling\n                  interval\
    \ that had a length (excluding framing bits\n                  but including FCS\
    \ octets) between 64 and 1518\n                  octets, inclusive, but had either\
    \ a bad Frame Check\n                  Sequence (FCS) with an integral number\
    \ of octets\n                  (FCS Error) or a bad FCS with a non-integral number\n\
    \                  of octets (Alignment Error).\"\n              ::= { etherHistoryEntry\
    \ 9 }\n          etherHistoryUndersizePkts OBJECT-TYPE\n              SYNTAX Counter\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The number of packets received during this\n\
    \                  sampling interval that were less than 64 octets\n         \
    \         long (excluding framing bits but including FCS\n                  octets)\
    \ and were otherwise well formed.\"\n              ::= { etherHistoryEntry 10\
    \ }\n          etherHistoryOversizePkts OBJECT-TYPE\n              SYNTAX Counter\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The number of packets received during this\n\
    \                  sampling interval that were longer than 1518\n            \
    \      octets (excluding framing bits but including\n                  FCS octets)\
    \ but were otherwise well formed.\"\n              ::= { etherHistoryEntry 11\
    \ }\n          etherHistoryFragments OBJECT-TYPE\n              SYNTAX Counter\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The total number of packets received during\
    \ this\n                  sampling interval that were less than 64 octets in\n\
    \                  length (excluding framing bits but including FCS\n        \
    \          octets) had either a bad Frame Check Sequence (FCS)\n             \
    \     with an integral number of octets (FCS Error) or a bad\n               \
    \   FCS with a non-integral number of octets (Alignment\n                  Error).\n\
    \                  Note that it is entirely normal for\n                  etherHistoryFragments\
    \ to increment.  This is because\n                  it counts both runts (which\
    \ are normal occurrences\n                  due to collisions) and noise hits.\"\
    \n              ::= { etherHistoryEntry 12 }\n          etherHistoryJabbers OBJECT-TYPE\n\
    \              SYNTAX Counter\n              ACCESS read-only\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The number of packets\
    \ received during this\n                  sampling interval that were longer than\
    \ 1518 octets\n                  (excluding framing bits but including FCS octets),\n\
    \                  and  had either a bad Frame Check Sequence (FCS)\n        \
    \          with an integral number of octets (FCS Error) or\n                \
    \  a bad FCS with a non-integral number of octets\n                  (Alignment\
    \ Error).\n                  Note that this definition of jabber is different\n\
    \                  than the definition in IEEE-802.3 section 8.2.1.5\n       \
    \           (10BASE5) and section 10.3.1.4 (10BASE2).  These\n               \
    \   documents define jabber as the condition where any\n                  packet\
    \ exceeds 20 ms.  The allowed range to detect\n                  jabber is between\
    \ 20 ms and 150 ms.\"\n              ::= { etherHistoryEntry 13 }\n          etherHistoryCollisions\
    \ OBJECT-TYPE\n              SYNTAX Counter\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The best estimate of the total number of collisions\n                  on\
    \ this Ethernet segment during this sampling\n                  interval.\n  \
    \                The value returned will depend on the location of\n         \
    \         the RMON probe. Section 8.2.1.3 (10BASE-5) and\n                  section\
    \ 10.3.1.3 (10BASE-2) of IEEE standard 802.3\n                  states that a\
    \ station must detect a collision, in\n                  the receive mode, if\
    \ three or more stations are\n                  transmitting simultaneously. \
    \ A repeater port must\n                  detect a collision when two or more\
    \ stations are\n                  transmitting simultaneously.  Thus a probe placed\
    \ on\n                  a repeater port could record more collisions than a\n\
    \                  probe connected to a station on the same segment\n        \
    \          would.\n                  Probe location plays a much smaller role\
    \ when\n                  considering 10BASE-T.  14.2.1.4 (10BASE-T) of IEEE\n\
    \                  standard 802.3 defines a collision as the\n               \
    \   simultaneous presence of signals on the DO and RD\n                  circuits\
    \ (transmitting and receiving at the same\n                  time).  A 10BASE-T\
    \ station can only detect\n                  collisions when it is transmitting.\
    \  Thus probes\n                  placed on a station and a repeater, should report\n\
    \                  the same number of collisions.\n                  Note also\
    \ that an RMON probe inside a repeater\n                  should ideally report\
    \ collisions between the\n                  repeater and one or more other hosts\
    \ (transmit\n                  collisions as defined by IEEE 802.3k) plus receiver\n\
    \                  collisions observed on any coax segments to which\n       \
    \           the repeater is connected.\"\n              ::= { etherHistoryEntry\
    \ 14 }\n          etherHistoryUtilization OBJECT-TYPE\n              SYNTAX INTEGER\
    \ (0..10000)\n              ACCESS read-only\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"The best estimate of the mean\
    \ physical layer\n                  network utilization on this interface during\
    \ this\n                  sampling interval, in hundredths of a percent.\"\n \
    \             ::= { etherHistoryEntry 15 }\n          -- The Alarm Group\n   \
    \       -- Implementation of the Alarm group is optional.\n          --\n    \
    \      -- The Alarm Group requires the implementation of the Event\n         \
    \ -- group.\n          --\n          -- The Alarm group periodically takes\n \
    \         -- statistical samples from variables in the probe and\n          --\
    \ compares them to thresholds that have been\n          -- configured.  The alarm\
    \ table stores configuration\n          -- entries that each define a variable,\
    \ polling period,\n          -- and threshold parameters.  If a sample is found\
    \ to\n          -- cross the threshold values, an event is generated.\n      \
    \    -- Only variables that resolve to an ASN.1 primitive\n          -- type of\
    \ INTEGER (INTEGER, Counter, Gauge, or\n          -- TimeTicks) may be monitored\
    \ in this way.\n          --\n          -- This function has a hysteresis mechanism\
    \ to limit\n          -- the generation of events.  This mechanism generates\n\
    \          -- one event as a threshold is crossed in the\n          -- appropriate\
    \ direction.  No more events are generated\n          -- for that threshold until\
    \ the opposite threshold is\n          -- crossed.\n          --\n          --\
    \ In the case of a sampling a deltaValue, a probe may\n          -- implement\
    \ this mechanism with more precision if it\n          -- takes a delta sample\
    \ twice per period, each time\n          -- comparing the sum of the latest two\
    \ samples to the\n          -- threshold.  This allows the detection of threshold\n\
    \          -- crossings that span the sampling boundary.  Note\n          -- that\
    \ this does not require any special configuration\n          -- of the threshold\
    \ value.  It is suggested that probes\n          -- implement this more precise\
    \ algorithm.\n          alarmTable OBJECT-TYPE\n              SYNTAX SEQUENCE\
    \ OF AlarmEntry\n              ACCESS not-accessible\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"A list of alarm entries.\"\n \
    \             ::= { alarm 1 }\n          alarmEntry OBJECT-TYPE\n            \
    \  SYNTAX AlarmEntry\n              ACCESS not-accessible\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"A list of parameters\
    \ that set up a periodic checking\n                  for alarm conditions.  For\
    \ example, an instance of the\n                  alarmValue object might be named\
    \ alarmValue.8\"\n              INDEX { alarmIndex }\n              ::= { alarmTable\
    \ 1 }\n          AlarmEntry ::= SEQUENCE {\n              alarmIndex         \
    \           INTEGER (1..65535),\n              alarmInterval                 INTEGER,\n\
    \              alarmVariable                 OBJECT IDENTIFIER,\n            \
    \  alarmSampleType               INTEGER,\n              alarmValue          \
    \          INTEGER,\n              alarmStartupAlarm             INTEGER,\n  \
    \            alarmRisingThreshold          INTEGER,\n              alarmFallingThreshold\
    \         INTEGER,\n              alarmRisingEventIndex         INTEGER (0..65535),\n\
    \              alarmFallingEventIndex        INTEGER (0..65535),\n           \
    \   alarmOwner                    OwnerString,\n              alarmStatus    \
    \               EntryStatus\n          }\n          alarmIndex OBJECT-TYPE\n \
    \             SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n    \
    \          STATUS mandatory\n              DESCRIPTION\n                  \"An\
    \ index that uniquely identifies an entry in the\n                  alarm table.\
    \  Each such entry defines a\n                  diagnostic sample at a particular\
    \ interval\n                  for an object on the device.\"\n              ::=\
    \ { alarmEntry 1 }\n          alarmInterval OBJECT-TYPE\n              SYNTAX\
    \ INTEGER\n              ACCESS read-write\n              STATUS mandatory\n \
    \             DESCRIPTION\n                  \"The interval in seconds over which\
    \ the data is\n                  sampled and compared with the rising and falling\n\
    \                  thresholds.  When setting this variable, care\n           \
    \       should be taken in the case of deltaValue\n                  sampling\
    \ - the interval should be set short enough\n                  that the sampled\
    \ variable is very unlikely to\n                  increase or decrease by more\
    \ than 2^31 - 1 during\n                  a single sampling interval.\n      \
    \            This object may not be modified if the associated\n             \
    \     alarmStatus object is equal to valid(1).\"\n              ::= { alarmEntry\
    \ 2 }\n          alarmVariable OBJECT-TYPE\n              SYNTAX OBJECT IDENTIFIER\n\
    \              ACCESS read-write\n              STATUS mandatory\n           \
    \   DESCRIPTION\n                  \"The object identifier of the particular variable\
    \ to\n                  be sampled.  Only variables that resolve to an ASN.1\n\
    \                  primitive type of INTEGER (INTEGER, Counter, Gauge,\n     \
    \             or TimeTicks) may be sampled.\n                  Because SNMP access\
    \ control is articulated entirely\n                  in terms of the contents\
    \ of MIB views, no access\n                  control mechanism exists that can\
    \ restrict the value\n                  of this object to identify only those\
    \ objects that\n                  exist in a particular MIB view.  Because there\
    \ is\n                  thus no acceptable means of restricting the read\n   \
    \               access that could be obtained through the alarm\n            \
    \      mechanism, the probe must only grant write access to\n                \
    \  this object in those views that have read access to\n                  all\
    \ objects on the probe.\n                  During a set operation, if the supplied\
    \ variable\n                  name is not available in the selected MIB view,\
    \ a\n                  badValue error must be returned.  If at any time the\n\
    \                  variable name of an established alarmEntry is no\n        \
    \          longer available in the selected MIB view, the probe\n            \
    \      must change the status of this alarmEntry to\n                  invalid(4).\n\
    \                  This object may not be modified if the associated\n       \
    \           alarmStatus object is equal to valid(1).\"\n              ::= { alarmEntry\
    \ 3 }\n          alarmSampleType OBJECT-TYPE\n              SYNTAX INTEGER {\n\
    \                  absoluteValue(1),\n                  deltaValue(2)\n      \
    \        }\n              ACCESS read-write\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"The method of sampling the selected\
    \ variable and\n                  calculating the value to be compared against\
    \ the\n                  thresholds.  If the value of this object is\n       \
    \           absoluteValue(1), the value of the selected variable\n           \
    \       will be compared directly with the thresholds at the\n               \
    \   end of the sampling interval.  If the value of this\n                  object\
    \ is deltaValue(2), the value of the selected\n                  variable at the\
    \ last sample will be subtracted from\n                  the current value, and\
    \ the difference compared with\n                  the thresholds.\n          \
    \        This object may not be modified if the associated\n                 \
    \ alarmStatus object is equal to valid(1).\"\n              ::= { alarmEntry 4\
    \ }\n          alarmValue OBJECT-TYPE\n              SYNTAX INTEGER\n        \
    \      ACCESS read-only\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"The value of the statistic during the last sampling\n   \
    \               period.  For example, if the sample type is\n                \
    \  deltaValue, this value will be the difference\n                  between the\
    \ samples at the beginning and end of the\n                  period.  If the sample\
    \ type is absoluteValue, this\n                  value will be the sampled value\
    \ at the end of the\n                  period.\n                  This is the\
    \ value that is compared with the rising and\n                  falling thresholds.\n\
    \                  The value during the current sampling period is not\n     \
    \             made available until the period is completed and will\n        \
    \          remain available until the next period completes.\"\n             \
    \ ::= { alarmEntry 5 }\n          alarmStartupAlarm OBJECT-TYPE\n            \
    \  SYNTAX INTEGER {\n                  risingAlarm(1),\n                  fallingAlarm(2),\n\
    \                  risingOrFallingAlarm(3)\n              }\n              ACCESS\
    \ read-write\n              STATUS mandatory\n              DESCRIPTION\n    \
    \              \"The alarm that may be sent when this entry is first\n       \
    \           set to valid.  If the first sample after this entry\n            \
    \      becomes valid is greater than or equal to the\n                  risingThreshold\
    \ and alarmStartupAlarm is equal to\n                  risingAlarm(1) or risingOrFallingAlarm(3),\
    \ then a\n                  single rising alarm will be generated.  If the first\n\
    \                  sample after this entry becomes valid is less than\n      \
    \            or equal to the fallingThreshold and\n                  alarmStartupAlarm\
    \ is equal to fallingAlarm(2) or\n                  risingOrFallingAlarm(3), then\
    \ a single falling alarm\n                  will be generated.\n             \
    \     This object may not be modified if the associated\n                  alarmStatus\
    \ object is equal to valid(1).\"\n              ::= { alarmEntry 6 }\n       \
    \   alarmRisingThreshold OBJECT-TYPE\n              SYNTAX INTEGER\n         \
    \     ACCESS read-write\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"A threshold for the sampled statistic.  When the\n      \
    \            current sampled value is greater than or equal to\n             \
    \     this threshold, and the value at the last sampling\n                  interval\
    \ was less than this threshold, a single\n                  event will be generated.\
    \  A single event will also\n                  be generated if the first sample\
    \ after this entry\n                  becomes valid is greater than or equal to\
    \ this\n                  threshold and the associated alarmStartupAlarm is\n\
    \                  equal to risingAlarm(1) or risingOrFallingAlarm(3).\n     \
    \             After a rising event is generated, another such event\n        \
    \          will not be generated until the sampled value\n                  falls\
    \ below this threshold and reaches the\n                  alarmFallingThreshold.\n\
    \                  This object may not be modified if the associated\n       \
    \           alarmStatus object is equal to valid(1).\"\n              ::= { alarmEntry\
    \ 7 }\n          alarmFallingThreshold OBJECT-TYPE\n              SYNTAX INTEGER\n\
    \              ACCESS read-write\n              STATUS mandatory\n           \
    \   DESCRIPTION\n                  \"A threshold for the sampled statistic.  When\
    \ the\n                  current sampled value is less than or equal to this\n\
    \                  threshold, and the value at the last sampling\n           \
    \       interval was greater than this threshold, a single\n                 \
    \ event will be generated.  A single event will also\n                  be generated\
    \ if the first sample after this entry\n                  becomes valid is less\
    \ than or equal to this\n                  threshold and the associated alarmStartupAlarm\
    \ is\n                  equal to fallingAlarm(2) or risingOrFallingAlarm(3).\n\
    \                  After a falling event is generated, another such event\n  \
    \                will not be generated until the sampled value\n             \
    \     rises above this threshold and reaches the\n                  alarmRisingThreshold.\n\
    \                  This object may not be modified if the associated\n       \
    \           alarmStatus object is equal to valid(1).\"\n              ::= { alarmEntry\
    \ 8 }\n          alarmRisingEventIndex OBJECT-TYPE\n              SYNTAX INTEGER\
    \ (0..65535)\n              ACCESS read-write\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"The index of the eventEntry that\
    \ is\n                  used when a rising threshold is crossed.  The\n      \
    \            eventEntry identified by a particular value of\n                \
    \  this index is the same as identified by the same value\n                  of\
    \ the eventIndex object.  If there is no\n                  corresponding entry\
    \ in the eventTable, then\n                  no association exists.  In particular,\
    \ if this value\n                  is zero, no associated event will be generated,\
    \ as\n                  zero is not a valid event index.\n                  This\
    \ object may not be modified if the associated\n                  alarmStatus\
    \ object is equal to valid(1).\"\n              ::= { alarmEntry 9 }\n       \
    \   alarmFallingEventIndex OBJECT-TYPE\n              SYNTAX INTEGER (0..65535)\n\
    \              ACCESS read-write\n              STATUS mandatory\n           \
    \   DESCRIPTION\n                  \"The index of the eventEntry that is\n   \
    \               used when a falling threshold is crossed.  The\n             \
    \     eventEntry identified by a particular value of\n                  this index\
    \ is the same as identified by the same value\n                  of the eventIndex\
    \ object.  If there is no\n                  corresponding entry in the eventTable,\
    \ then\n                  no association exists.  In particular, if this value\n\
    \                  is zero, no associated event will be generated, as\n      \
    \            zero is not a valid event index.\n                  This object may\
    \ not be modified if the associated\n                  alarmStatus object is equal\
    \ to valid(1).\"\n              ::= { alarmEntry 10 }\n          alarmOwner OBJECT-TYPE\n\
    \              SYNTAX OwnerString\n              ACCESS read-write\n         \
    \     STATUS mandatory\n              DESCRIPTION\n                  \"The entity\
    \ that configured this entry and is\n                  therefore using the resources\
    \ assigned to it.\"\n              ::= { alarmEntry 11 }\n          alarmStatus\
    \ OBJECT-TYPE\n              SYNTAX EntryStatus\n              ACCESS read-write\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The status of this alarm entry.\"\n              ::= { alarmEntry 12 }\n \
    \         -- The Host Group\n          -- Implementation of the Host group is\
    \ optional.\n          --\n          -- The host group discovers new hosts on\
    \ the network by\n          -- keeping a list of source and destination MAC Addresses\
    \ seen\n          -- in good packets.  For each of these addresses, the host\n\
    \          -- group keeps a set of statistics.  The hostControlTable\n       \
    \   -- controls which interfaces this function is performed on,\n          --\
    \ and contains some information about the process.  On\n          -- behalf of\
    \ each hostControlEntry, data is collected on an\n          -- interface and placed\
    \ in both the hostTable and the\n          -- hostTimeTable.  If the monitoring\
    \ device finds itself\n          -- short of resources, it may delete entries\
    \ as needed.  It\n          -- is suggested that the device delete the least recently\n\
    \          -- used entries first.\n          -- The hostTable contains entries\
    \ for each address\n          -- discovered on a particular interface.  Each entry\n\
    \          -- contains statistical data about that host.  This table is\n    \
    \      -- indexed by the MAC address of the host, through which a\n          --\
    \ random access may be achieved.\n          -- The hostTimeTable contains data\
    \ in the same format as the\n          -- hostTable, and must contain the same\
    \ set of hosts, but is\n          -- indexed using hostTimeCreationOrder rather\
    \ than\n          -- hostAddress.\n          -- The hostTimeCreationOrder is an\
    \ integer which reflects\n          -- the relative order in which a particular\
    \ entry was\n          -- discovered and thus inserted into the table.  As this\n\
    \          -- order, and thus the index, is among those entries\n          --\
    \ currently in the table, the index for a particular entry\n          -- may change\
    \ if an (earlier) entry is deleted.  Thus the\n          -- association between\
    \ hostTimeCreationOrder and\n          -- hostTimeEntry may be broken at any time.\n\
    \          -- The hostTimeTable has two important uses.  The first is the\n  \
    \        -- fast download of this potentially large table.  Because the\n    \
    \      -- index of this table runs from 1 to the size of the table,\n        \
    \  -- inclusive, its values are predictable.  This allows very\n          -- efficient\
    \ packing of variables into SNMP PDU's and allows\n          -- a table transfer\
    \ to have multiple packets outstanding.\n          -- These benefits increase\
    \ transfer rates tremendously.\n          -- The second use of the hostTimeTable\
    \ is the efficient\n          -- discovery by the management station of new entries\
    \ added\n          -- to the table. After the management station has downloaded\n\
    \          -- the entire table, it knows that new entries will be added\n    \
    \      -- immediately after the end of the current table.  It can\n          --\
    \ thus detect new entries there and retrieve them easily.\n          -- Because\
    \ the association between hostTimeCreationOrder and\n          -- hostTimeEntry\
    \ may be broken at any time, the management\n          -- station must monitor\
    \ the related hostControlLastDeleteTime\n          -- object.  When the management\
    \ station thus detects a\n          -- deletion, it must assume that any such\
    \ associations have\n          --- been broken, and invalidate any it has stored\
    \ locally.\n          -- This includes restarting any download of the\n      \
    \    -- hostTimeTable that may have been in progress, as well as\n          --\
    \ rediscovering the end of the hostTimeTable so that it may\n          -- detect\
    \ new entries.  If the management station does not\n          -- detect the broken\
    \ association, it may continue to refer\n          -- to a particular host by\
    \ its creationOrder while\n          -- unwittingly retrieving the data associated\
    \ with another\n          -- host entirely.  If this happens while downloading\
    \ the\n          -- host table, the management station may fail to download\n\
    \          -- all of the entries in the table.\n          hostControlTable OBJECT-TYPE\n\
    \              SYNTAX SEQUENCE OF HostControlEntry\n              ACCESS not-accessible\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"A list of host table control entries.\"\n              ::= { hosts 1 }\n \
    \         hostControlEntry OBJECT-TYPE\n              SYNTAX HostControlEntry\n\
    \              ACCESS not-accessible\n              STATUS mandatory\n       \
    \       DESCRIPTION\n                  \"A list of parameters that set up the\
    \ discovery of\n                  hosts on a particular interface and the collection\n\
    \                  of statistics about these hosts.  For example, an\n       \
    \           instance of the hostControlTableSize object might be\n           \
    \       named hostControlTableSize.1\"\n              INDEX { hostControlIndex\
    \ }\n              ::= { hostControlTable 1 }\n          HostControlEntry ::=\
    \ SEQUENCE {\n              hostControlIndex            INTEGER (1..65535),\n\
    \              hostControlDataSource       OBJECT IDENTIFIER,\n              hostControlTableSize\
    \        INTEGER,\n              hostControlLastDeleteTime   TimeTicks,\n    \
    \          hostControlOwner            OwnerString,\n              hostControlStatus\
    \           EntryStatus\n          }\n          hostControlIndex OBJECT-TYPE\n\
    \              SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n   \
    \           STATUS mandatory\n              DESCRIPTION\n                  \"\
    An index that uniquely identifies an entry in the\n                  hostControl\
    \ table.  Each such entry defines\n                  a function that discovers\
    \ hosts on a particular\n                  interface and places statistics about\
    \ them in the\n                  hostTable and the hostTimeTable on behalf of\
    \ this\n                  hostControlEntry.\"\n              ::= { hostControlEntry\
    \ 1 }\n          hostControlDataSource OBJECT-TYPE\n              SYNTAX OBJECT\
    \ IDENTIFIER\n              ACCESS read-write\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"This object identifies the source\
    \ of the data for\n                  this instance of the host function.  This\
    \ source\n                  can be any interface on this device.  In order\n \
    \                 to identify a particular interface, this object shall\n    \
    \              identify the instance of the ifIndex object, defined\n        \
    \          in RFC 1213 and RFC 1573 [4,6], for the desired\n                 \
    \ interface. For example, if an entry were to receive\n                  data\
    \ from interface #1, this object would be set to\n                  ifIndex.1.\n\
    \                  The statistics in this group reflect all packets\n        \
    \          on the local network segment attached to the\n                  identified\
    \ interface.\n                  An agent may or may not be able to tell if\n \
    \                 fundamental changes to the media of the interface\n        \
    \          have occurred and necessitate an invalidation of\n                \
    \  this entry.  For example, a hot-pluggable ethernet\n                  card\
    \ could be pulled out and replaced by a\n                  token-ring card.  In\
    \ such a case, if the agent has\n                  such knowledge of the change,\
    \ it is recommended that\n                  it invalidate this entry.\n      \
    \            This object may not be modified if the associated\n             \
    \     hostControlStatus object is equal to valid(1).\"\n              ::= { hostControlEntry\
    \ 2 }\n          hostControlTableSize OBJECT-TYPE\n              SYNTAX INTEGER\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The number of hostEntries in the hostTable\
    \ and the\n                  hostTimeTable associated with this hostControlEntry.\"\
    \n              ::= { hostControlEntry 3 }\n          hostControlLastDeleteTime\
    \ OBJECT-TYPE\n              SYNTAX TimeTicks\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The value of sysUpTime when the last entry\n                  was deleted\
    \ from the portion of the hostTable\n                  associated with this hostControlEntry.\
    \  If no\n                  deletions have occurred, this value shall be zero.\"\
    \n              ::= { hostControlEntry 4 }\n          hostControlOwner OBJECT-TYPE\n\
    \              SYNTAX OwnerString\n              ACCESS read-write\n         \
    \     STATUS mandatory\n              DESCRIPTION\n                  \"The entity\
    \ that configured this entry and is\n                  therefore using the resources\
    \ assigned to it.\"\n              ::= { hostControlEntry 5 }\n          hostControlStatus\
    \ OBJECT-TYPE\n              SYNTAX EntryStatus\n              ACCESS read-write\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The status of this hostControl entry.\n                  If this object is\
    \ not equal to valid(1), all\n                  associated entries in the hostTable,\
    \ hostTimeTable,\n                  and the hostTopNTable shall be deleted by\
    \ the\n                  agent.\"\n              ::= { hostControlEntry 6 }\n\
    \          hostTable OBJECT-TYPE\n              SYNTAX SEQUENCE OF HostEntry\n\
    \              ACCESS not-accessible\n              STATUS mandatory\n       \
    \       DESCRIPTION\n                  \"A list of host entries.\"\n         \
    \     ::= { hosts 2 }\n          hostEntry OBJECT-TYPE\n              SYNTAX HostEntry\n\
    \              ACCESS not-accessible\n              STATUS mandatory\n       \
    \       DESCRIPTION\n                  \"A collection of statistics for a particular\
    \ host\n                  that has been discovered on an interface of this\n \
    \                 device.  For example, an instance of the\n                 \
    \ hostOutBroadcastPkts object might be named\n                  hostOutBroadcastPkts.1.6.8.0.32.27.3.176\"\
    \n              INDEX { hostIndex, hostAddress }\n              ::= { hostTable\
    \ 1 }\n          HostEntry ::= SEQUENCE {\n              hostAddress         \
    \    OCTET STRING,\n              hostCreationOrder       INTEGER (1..65535),\n\
    \              hostIndex               INTEGER (1..65535),\n              hostInPkts\
    \              Counter,\n              hostOutPkts             Counter,\n    \
    \          hostInOctets            Counter,\n              hostOutOctets     \
    \      Counter,\n              hostOutErrors           Counter,\n            \
    \  hostOutBroadcastPkts    Counter,\n              hostOutMulticastPkts    Counter\n\
    \          }\n          hostAddress OBJECT-TYPE\n              SYNTAX OCTET STRING\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The physical address of this host.\"\n   \
    \           ::= { hostEntry 1 }\n          hostCreationOrder OBJECT-TYPE\n   \
    \           SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n      \
    \        STATUS mandatory\n              DESCRIPTION\n                  \"An index\
    \ that defines the relative ordering of\n                  the creation time of\
    \ hosts captured for a\n                  particular hostControlEntry.  This index\
    \ shall\n                  be between 1 and N, where N is the value of\n     \
    \             the associated hostControlTableSize.  The ordering\n           \
    \       of the indexes is based on the order of each entry's\n               \
    \   insertion into the table, in which entries added\n                  earlier\
    \ have a lower index value than entries added\n                  later.\n    \
    \              It is important to note that the order for a\n                \
    \  particular entry may change as an (earlier) entry\n                  is deleted\
    \ from the table.  Because this order may\n                  change, management\
    \ stations should make use of the\n                  hostControlLastDeleteTime\
    \ variable in the\n                  hostControlEntry associated with the relevant\n\
    \                  portion of the hostTable.  By observing\n                 \
    \ this variable, the management station may detect\n                  the circumstances\
    \ where a previous association\n                  between a value of hostCreationOrder\n\
    \                  and a hostEntry may no longer hold.\"\n              ::= {\
    \ hostEntry 2 }\n          hostIndex OBJECT-TYPE\n              SYNTAX INTEGER\
    \ (1..65535)\n              ACCESS read-only\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"The set of collected host statistics\
    \ of which\n                  this entry is a part.  The set of hosts\n      \
    \            identified by a particular value of this\n                  index\
    \ is associated with the hostControlEntry\n                  as identified by\
    \ the same value of hostControlIndex.\"\n              ::= { hostEntry 3 }\n \
    \         hostInPkts OBJECT-TYPE\n              SYNTAX Counter\n             \
    \ ACCESS read-only\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"The number of good packets transmitted to this\n        \
    \          address since it was added to the hostTable.\"\n              ::= {\
    \ hostEntry 4 }\n          hostOutPkts OBJECT-TYPE\n              SYNTAX Counter\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The number of packets, including bad packets,\n\
    \                  transmitted by this address since it was added\n          \
    \        to the hostTable.\"\n              ::= { hostEntry 5 }\n          hostInOctets\
    \ OBJECT-TYPE\n              SYNTAX Counter\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The number of octets transmitted to this address\n                  since\
    \ it was added to the hostTable (excluding\n                  framing bits but\
    \ including FCS octets), except for\n                  those octets in bad packets.\"\
    \n              ::= { hostEntry 6 }\n          hostOutOctets OBJECT-TYPE\n   \
    \           SYNTAX Counter\n              ACCESS read-only\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The number of octets\
    \ transmitted by this address\n                  since it was added to the hostTable\
    \ (excluding\n                  framing bits but including FCS octets), including\n\
    \                  those octets in bad packets.\"\n              ::= { hostEntry\
    \ 7 }\n          hostOutErrors OBJECT-TYPE\n              SYNTAX Counter\n   \
    \           ACCESS read-only\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"The number of bad packets transmitted by this address\n \
    \                 since this host was added to the hostTable.\"\n            \
    \  ::= { hostEntry 8 }\n          hostOutBroadcastPkts OBJECT-TYPE\n         \
    \     SYNTAX Counter\n              ACCESS read-only\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"The number of good packets transmitted\
    \ by this\n                  address that were directed to the broadcast address\n\
    \                  since this host was added to the hostTable.\"\n           \
    \   ::= { hostEntry 9 }\n          hostOutMulticastPkts OBJECT-TYPE\n        \
    \      SYNTAX Counter\n              ACCESS read-only\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"The number of good packets transmitted\
    \ by this\n                  address that were directed to a multicast address\n\
    \                  since this host was added to the hostTable.\n             \
    \     Note that this number does not include packets\n                  directed\
    \ to the broadcast address.\"\n              ::= { hostEntry 10 }\n          --\
    \ host Time Table\n          hostTimeTable OBJECT-TYPE\n              SYNTAX SEQUENCE\
    \ OF HostTimeEntry\n              ACCESS not-accessible\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"A list of time-ordered\
    \ host table entries.\"\n              ::= { hosts 3 }\n          hostTimeEntry\
    \ OBJECT-TYPE\n              SYNTAX HostTimeEntry\n              ACCESS not-accessible\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"A collection of statistics for a particular host\n                  that has\
    \ been discovered on an interface of this\n                  device.  This collection\
    \ includes the relative\n                  ordering of the creation time of this\
    \ object.  For\n                  example, an instance of the hostTimeOutBroadcastPkts\n\
    \                  object might be named\n                  hostTimeOutBroadcastPkts.1.687\"\
    \n              INDEX { hostTimeIndex, hostTimeCreationOrder }\n             \
    \ ::= { hostTimeTable 1 }\n          HostTimeEntry ::= SEQUENCE {\n          \
    \    hostTimeAddress              OCTET STRING,\n              hostTimeCreationOrder\
    \        INTEGER (1..65535),\n              hostTimeIndex                INTEGER\
    \ (1..65535),\n              hostTimeInPkts               Counter,\n         \
    \     hostTimeOutPkts              Counter,\n              hostTimeInOctets  \
    \           Counter,\n              hostTimeOutOctets            Counter,\n  \
    \            hostTimeOutErrors            Counter,\n              hostTimeOutBroadcastPkts\
    \     Counter,\n              hostTimeOutMulticastPkts     Counter\n         \
    \ }\n          hostTimeAddress OBJECT-TYPE\n              SYNTAX OCTET STRING\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The physical address of this host.\"\n   \
    \           ::= { hostTimeEntry 1 }\n          hostTimeCreationOrder OBJECT-TYPE\n\
    \              SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n   \
    \           STATUS mandatory\n              DESCRIPTION\n                  \"\
    An index that uniquely identifies an entry in\n                  the hostTime\
    \ table among those entries associated\n                  with the same hostControlEntry.\
    \  This index shall\n                  be between 1 and N, where N is the value\
    \ of\n                  the associated hostControlTableSize.  The ordering\n \
    \                 of the indexes is based on the order of each entry's\n     \
    \             insertion into the table, in which entries added\n             \
    \     earlier have a lower index value than entries added\n                  later.\
    \ Thus the management station has the ability to\n                  learn of new\
    \ entries added to this table without\n                  downloading the entire\
    \ table.\n                  It is important to note that the index for a\n   \
    \               particular entry may change as an (earlier) entry\n          \
    \        is deleted from the table.  Because this order may\n                \
    \  change, management stations should make use of the\n                  hostControlLastDeleteTime\
    \ variable in the\n                  hostControlEntry associated with the relevant\n\
    \                  portion of the hostTimeTable.  By observing\n             \
    \     this variable, the management station may detect\n                  the\
    \ circumstances where a download of the table\n                  may have missed\
    \ entries, and where a previous\n                  association between a value\
    \ of hostTimeCreationOrder\n                  and a hostTimeEntry may no longer\
    \ hold.\"\n              ::= { hostTimeEntry 2 }\n          hostTimeIndex OBJECT-TYPE\n\
    \              SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n   \
    \           STATUS mandatory\n              DESCRIPTION\n                  \"\
    The set of collected host statistics of which\n                  this entry is\
    \ a part.  The set of hosts\n                  identified by a particular value\
    \ of this\n                  index is associated with the hostControlEntry\n \
    \                 as identified by the same value of hostControlIndex.\"\n   \
    \           ::= { hostTimeEntry 3 }\n          hostTimeInPkts OBJECT-TYPE\n  \
    \            SYNTAX Counter\n              ACCESS read-only\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The number of good\
    \ packets transmitted to this\n                  address since it was added to\
    \ the hostTimeTable.\"\n              ::= { hostTimeEntry 4 }\n          hostTimeOutPkts\
    \ OBJECT-TYPE\n              SYNTAX Counter\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The number of god packets transmitted by this\n                  address since\
    \ it was added to the hostTimeTable.\"\n              ::= { hostTimeEntry 5 }\n\
    \          hostTimeInOctets OBJECT-TYPE\n              SYNTAX Counter\n      \
    \        ACCESS read-only\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"The number of octets transmitted to this address\n      \
    \            since it was added to the hostTimeTable (excluding\n            \
    \      framing bits but including FCS octets), except for\n                  those\
    \ octets in bad packets.\"\n              ::= { hostTimeEntry 6 }\n          hostTimeOutOctets\
    \ OBJECT-TYPE\n              SYNTAX Counter\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The number of octets transmitted by this address\n                  since\
    \ it was added to the hostTimeTable (excluding\n                  framing bits\
    \ but including FCS octets), including\n                  those octets in bad\
    \ packets.\"\n              ::= { hostTimeEntry 7 }\n          hostTimeOutErrors\
    \ OBJECT-TYPE\n              SYNTAX Counter\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The number of bad packets transmitted by this address\n                  since\
    \ this host was added to the hostTimeTable.\"\n              ::= { hostTimeEntry\
    \ 8 }\n          hostTimeOutBroadcastPkts OBJECT-TYPE\n              SYNTAX Counter\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The number of good packets transmitted by\
    \ this\n                  address that were directed to the broadcast address\n\
    \                  since this host was added to the hostTimeTable.\"\n       \
    \       ::= { hostTimeEntry 9 }\n          hostTimeOutMulticastPkts OBJECT-TYPE\n\
    \              SYNTAX Counter\n              ACCESS read-only\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The number of good\
    \ packets transmitted by this\n                  address that were directed to\
    \ a multicast address\n                  since this host was added to the hostTimeTable.\n\
    \                  Note that this number does not include packets\n          \
    \        directed to the broadcast address.\"\n              ::= { hostTimeEntry\
    \ 10 }\n          -- The Host Top \"N\" Group\n          -- Implementation of\
    \ the Host Top N group is optional.\n          --\n          -- The Host Top N\
    \ group requires the implementation of the\n          -- host group.\n       \
    \   --\n          -- The Host Top N group is used to prepare reports that\n  \
    \        -- describe the hosts that top a list ordered by one of\n          --\
    \ their statistics.\n          -- The available statistics are samples of one\
    \ of their\n          -- base statistics, over an interval specified by the\n\
    \          -- management station.  Thus, these statistics are rate\n         \
    \ -- based.  The management station also selects how many such\n          -- hosts\
    \ are reported.\n          -- The hostTopNControlTable is used to initiate the\n\
    \          -- generation of such a report.  The management station\n         \
    \ -- may select the parameters of such a report, such as\n          -- which interface,\
    \ which statistic, how many hosts,\n          -- and the start and stop times\
    \ of the sampling.  When\n          -- the report is prepared, entries are created\
    \ in the\n          -- hostTopNTable associated with the relevant\n          --\
    \ hostTopNControlEntry.  These entries are static for\n          -- each report\
    \ after it has been prepared.\n          hostTopNControlTable OBJECT-TYPE\n  \
    \            SYNTAX SEQUENCE OF HostTopNControlEntry\n              ACCESS not-accessible\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"A list of top N host control entries.\"\n              ::= { hostTopN 1 }\n\
    \          hostTopNControlEntry OBJECT-TYPE\n              SYNTAX HostTopNControlEntry\n\
    \              ACCESS not-accessible\n              STATUS mandatory\n       \
    \       DESCRIPTION\n                  \"A set of parameters that control the\
    \ creation of a\n                  report of the top N hosts according to several\n\
    \                  metrics.  For example, an instance of the\n               \
    \   hostTopNDuration object might be named\n                  hostTopNDuration.3\"\
    \n              INDEX { hostTopNControlIndex }\n              ::= { hostTopNControlTable\
    \ 1 }\n          HostTopNControlEntry ::= SEQUENCE {\n              hostTopNControlIndex\
    \    INTEGER (1..65535),\n              hostTopNHostIndex       INTEGER (1..65535),\n\
    \              hostTopNRateBase        INTEGER,\n              hostTopNTimeRemaining\
    \   INTEGER,\n              hostTopNDuration        INTEGER,\n              hostTopNRequestedSize\
    \   INTEGER,\n              hostTopNGrantedSize     INTEGER,\n              hostTopNStartTime\
    \       TimeTicks,\n              hostTopNOwner           OwnerString,\n     \
    \         hostTopNStatus          EntryStatus\n          }\n          hostTopNControlIndex\
    \ OBJECT-TYPE\n              SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"An index that uniquely identifies an entry\n                  in the hostTopNControl\
    \ table.  Each such\n                  entry defines one top N report prepared\
    \ for\n                  one interface.\"\n              ::= { hostTopNControlEntry\
    \ 1 }\n          hostTopNHostIndex OBJECT-TYPE\n              SYNTAX INTEGER (1..65535)\n\
    \              ACCESS read-write\n              STATUS mandatory\n           \
    \   DESCRIPTION\n                  \"The host table for which a top N report will\
    \ be\n                  prepared on behalf of this entry.  The host table\n  \
    \                identified by a particular value of this index is\n         \
    \         associated with the same host table as identified by\n             \
    \     the same value of hostIndex.\n                  This object may not be modified\
    \ if the associated\n                  hostTopNStatus object is equal to valid(1).\"\
    \n              ::= { hostTopNControlEntry 2 }\n          hostTopNRateBase OBJECT-TYPE\n\
    \              SYNTAX INTEGER {\n                      hostTopNInPkts(1),\n  \
    \                    hostTopNOutPkts(2),\n                      hostTopNInOctets(3),\n\
    \                      hostTopNOutOctets(4),\n                      hostTopNOutErrors(5),\n\
    \                      hostTopNOutBroadcastPkts(6),\n                      hostTopNOutMulticastPkts(7)\n\
    \              }\n              ACCESS read-write\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"The variable for each host that\
    \ the hostTopNRate\n                  variable is based upon.\n              \
    \    This object may not be modified if the associated\n                  hostTopNStatus\
    \ object is equal to valid(1).\"\n              ::= { hostTopNControlEntry 3 }\n\
    \          hostTopNTimeRemaining OBJECT-TYPE\n              SYNTAX INTEGER\n \
    \             ACCESS read-write\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The number of seconds left in the report currently\n\
    \                  being collected.  When this object is modified by\n       \
    \           the management station, a new collection is started,\n           \
    \       possibly aborting a currently running report.  The\n                 \
    \ new value is used as the requested duration of this\n                  report,\
    \ which is loaded into the associated\n                  hostTopNDuration object.\n\
    \                  When this object is set to a non-zero value, any\n        \
    \          associated hostTopNEntries shall be made\n                  inaccessible\
    \ by the monitor.  While the value of\n                  this object is non-zero,\
    \ it decrements by one per\n                  second until it reaches zero.  During\
    \ this time, all\n                  associated hostTopNEntries shall remain\n\
    \                  inaccessible.  At the time that this object\n             \
    \     decrements to zero, the report is made accessible in\n                 \
    \ the hostTopNTable.  Thus, the hostTopN table needs\n                  to be\
    \ created only at the end of the collection\n                  interval.\"\n \
    \             DEFVAL { 0 }\n              ::= { hostTopNControlEntry 4 }\n   \
    \       hostTopNDuration OBJECT-TYPE\n              SYNTAX INTEGER\n         \
    \     ACCESS read-only\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"The number of seconds that this report has collected\n  \
    \                during the last sampling interval, or if this\n             \
    \     report is currently being collected, the number\n                  of seconds\
    \ that this report is being collected\n                  during this sampling\
    \ interval.\n                  When the associated hostTopNTimeRemaining object\
    \ is\n                  set, this object shall be set by the probe to the\n  \
    \                same value and shall not be modified until the next\n       \
    \           time the hostTopNTimeRemaining is set.\n                  This value\
    \ shall be zero if no reports have been\n                  requested for this\
    \ hostTopNControlEntry.\"\n              DEFVAL { 0 }\n              ::= { hostTopNControlEntry\
    \ 5 }\n          hostTopNRequestedSize OBJECT-TYPE\n              SYNTAX INTEGER\n\
    \              ACCESS read-write\n              STATUS mandatory\n           \
    \   DESCRIPTION\n                  \"The maximum number of hosts requested for\
    \ the top N\n                  table.\n                  When this object is created\
    \ or modified, the probe\n                  should set hostTopNGrantedSize as\
    \ closely to this\n                  object as is possible for the particular\
    \ probe\n                  implementation and available resources.\"\n       \
    \       DEFVAL { 10 }\n              ::= { hostTopNControlEntry 6 }\n        \
    \  hostTopNGrantedSize OBJECT-TYPE\n              SYNTAX INTEGER\n           \
    \   ACCESS read-only\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"The maximum number of hosts in the top N table.\n       \
    \           When the associated hostTopNRequestedSize object is\n            \
    \      created or modified, the probe should set this\n                  object\
    \ as closely to the requested value as is\n                  possible for the\
    \ particular implementation and\n                  available resources. The probe\
    \ must not lower this\n                  value except as a result of a set to\
    \ the associated\n                  hostTopNRequestedSize object.\n          \
    \        Hosts with the highest value of hostTopNRate shall be\n             \
    \     placed in this table in decreasing order of this rate\n                \
    \  until there is no more room or until there are no more\n                  hosts.\"\
    \n              ::= { hostTopNControlEntry 7 }\n          hostTopNStartTime OBJECT-TYPE\n\
    \              SYNTAX TimeTicks\n              ACCESS read-only\n            \
    \  STATUS mandatory\n              DESCRIPTION\n                  \"The value\
    \ of sysUpTime when this top N report was\n                  last started.  In\
    \ other words, this is the time that\n                  the associated hostTopNTimeRemaining\
    \ object was\n                  modified to start the requested report.\"\n  \
    \            ::= { hostTopNControlEntry 8 }\n          hostTopNOwner OBJECT-TYPE\n\
    \              SYNTAX OwnerString\n              ACCESS read-write\n         \
    \     STATUS mandatory\n              DESCRIPTION\n                  \"The entity\
    \ that configured this entry and is\n                  therefore using the resources\
    \ assigned to it.\"\n              ::= { hostTopNControlEntry 9 }\n          hostTopNStatus\
    \ OBJECT-TYPE\n              SYNTAX EntryStatus\n              ACCESS read-write\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The status of this hostTopNControl entry.\n                  If this object\
    \ is not equal to valid(1), all\n                  associated hostTopNEntries\
    \ shall be deleted by the\n                  agent.\"\n              ::= { hostTopNControlEntry\
    \ 10 }\n          hostTopNTable OBJECT-TYPE\n              SYNTAX SEQUENCE OF\
    \ HostTopNEntry\n              ACCESS not-accessible\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"A list of top N host entries.\"\
    \n              ::= { hostTopN 2 }\n          hostTopNEntry OBJECT-TYPE\n    \
    \          SYNTAX HostTopNEntry\n              ACCESS not-accessible\n       \
    \       STATUS mandatory\n              DESCRIPTION\n                  \"A set\
    \ of statistics for a host that is part of a\n                  top N report.\
    \  For example, an instance of the\n                  hostTopNRate object might\
    \ be named\n                  hostTopNRate.3.10\"\n              INDEX { hostTopNReport,\
    \ hostTopNIndex }\n              ::= { hostTopNTable 1 }\n          HostTopNEntry\
    \ ::= SEQUENCE {\n              hostTopNReport                INTEGER (1..65535),\n\
    \              hostTopNIndex                 INTEGER (1..65535),\n           \
    \   hostTopNAddress               OCTET STRING,\n              hostTopNRate  \
    \                INTEGER\n          }\n          hostTopNReport OBJECT-TYPE\n\
    \              SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n   \
    \           STATUS mandatory\n              DESCRIPTION\n                  \"\
    This object identifies the top N report of which\n                  this entry\
    \ is a part.  The set of hosts\n                  identified by a particular value\
    \ of this\n                  object is part of the same report as identified\n\
    \                  by the same value of the hostTopNControlIndex object.\"\n \
    \             ::= { hostTopNEntry 1 }\n          hostTopNIndex OBJECT-TYPE\n \
    \             SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n    \
    \          STATUS mandatory\n              DESCRIPTION\n                  \"An\
    \ index that uniquely identifies an entry in\n                  the hostTopN table\
    \ among those in the same report.\n                  This index is between 1 and\
    \ N, where N is the\n                  number of entries in this table.  Increasing\
    \ values\n                  of hostTopNIndex shall be assigned to entries with\n\
    \                  decreasing values of hostTopNRate until index N\n         \
    \         is assigned to the entry with the lowest value of\n                \
    \  hostTopNRate or there are no more hostTopNEntries.\"\n              ::= { hostTopNEntry\
    \ 2 }\n          hostTopNAddress OBJECT-TYPE\n              SYNTAX OCTET STRING\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The physical address of this host.\"\n   \
    \           ::= { hostTopNEntry 3 }\n          hostTopNRate OBJECT-TYPE\n    \
    \          SYNTAX INTEGER\n              ACCESS read-only\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The amount of change\
    \ in the selected variable\n                  during this sampling interval. \
    \ The selected\n                  variable is this host's instance of the object\n\
    \                  selected by hostTopNRateBase.\"\n              ::= { hostTopNEntry\
    \ 4 }\n          -- The Matrix Group\n          -- Implementation of the Matrix\
    \ group is optional.\n          --\n          -- The Matrix group consists of\
    \ the matrixControlTable,\n          -- matrixSDTable and the matrixDSTable. \
    \ These tables\n          -- store statistics for a particular conversation\n\
    \          -- between two addresses.  As the device detects a new\n          --\
    \ conversation, including those to a non-unicast\n          -- address, it creates\
    \ a new entry in both of the\n          -- matrix tables.  It must only create\
    \ new entries\n          -- based on information received in good packets.  If\n\
    \          -- the monitoring device finds itself short of\n          -- resources,\
    \ it may delete entries as needed.  It is\n          -- suggested that the device\
    \ delete the least recently\n          -- used entries first.\n          matrixControlTable\
    \ OBJECT-TYPE\n              SYNTAX SEQUENCE OF MatrixControlEntry\n         \
    \     ACCESS not-accessible\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"A list of information entries for the\n                 \
    \ traffic matrix on each interface.\"\n              ::= { matrix 1 }\n      \
    \    matrixControlEntry OBJECT-TYPE\n              SYNTAX MatrixControlEntry\n\
    \              ACCESS not-accessible\n              STATUS mandatory\n       \
    \       DESCRIPTION\n                  \"Information about a traffic matrix on\
    \ a particular\n                  interface.  For example, an instance of the\n\
    \                  matrixControlLastDeleteTime object might be named\n       \
    \           matrixControlLastDeleteTime.1\"\n              INDEX { matrixControlIndex\
    \ }\n              ::= { matrixControlTable 1 }\n          MatrixControlEntry\
    \ ::= SEQUENCE {\n              matrixControlIndex           INTEGER (1..65535),\n\
    \              matrixControlDataSource      OBJECT IDENTIFIER,\n             \
    \ matrixControlTableSize       INTEGER,\n              matrixControlLastDeleteTime\
    \  TimeTicks,\n              matrixControlOwner           OwnerString,\n     \
    \         matrixControlStatus          EntryStatus\n          }\n          matrixControlIndex\
    \ OBJECT-TYPE\n              SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"An index that uniquely identifies an entry in the\n                  matrixControl\
    \ table.  Each such entry defines\n                  a function that discovers\
    \ conversations on a\n                  particular interface and places statistics\
    \ about\n                  them in the matrixSDTable and the matrixDSTable on\n\
    \                  behalf of this matrixControlEntry.\"\n              ::= { matrixControlEntry\
    \ 1 }\n          matrixControlDataSource OBJECT-TYPE\n              SYNTAX OBJECT\
    \ IDENTIFIER\n              ACCESS read-write\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"This object identifies the source\
    \ of\n                  the data from which this entry creates a traffic\n   \
    \               matrix. This source can be any interface on this\n           \
    \       device.  In order to identify a particular\n                  interface,\
    \ this object shall identify the instance\n                  of the ifIndex object,\
    \ defined in RFC 1213 and RFC\n                  1573 [4,6], for the desired interface.\
    \  For example,\n                  if an entry were to receive data from interface\
    \ #1,\n                  this object would be set to ifIndex.1.\n            \
    \      The statistics in this group reflect all packets\n                  on\
    \ the local network segment attached to the\n                  identified interface.\n\
    \                  An agent may or may not be able to tell if\n              \
    \    fundamental changes to the media of the interface\n                  have\
    \ occurred and necessitate an invalidation of\n                  this entry. \
    \ For example, a hot-pluggable ethernet\n                  card could be pulled\
    \ out and replaced by a\n                  token-ring card.  In such a case, if\
    \ the agent has\n                  such knowledge of the change, it is recommended\
    \ that\n                  it invalidate this entry.\n                  This object\
    \ may not be modified if the associated\n                  matrixControlStatus\
    \ object is equal to valid(1).\"\n              ::= { matrixControlEntry 2 }\n\
    \          matrixControlTableSize OBJECT-TYPE\n              SYNTAX INTEGER\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The number of matrixSDEntries in the matrixSDTable\n\
    \                  for this interface.  This must also be the value of\n     \
    \             the number of entries in the matrixDSTable for this\n          \
    \        interface.\"\n              ::= { matrixControlEntry 3 }\n          matrixControlLastDeleteTime\
    \ OBJECT-TYPE\n              SYNTAX TimeTicks\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The value of sysUpTime when the last entry\n                  was deleted\
    \ from the portion of the matrixSDTable\n                  or matrixDSTable associated\
    \ with this\n                  matrixControlEntry. If no deletions have occurred,\n\
    \                  this value shall be zero.\"\n              ::= { matrixControlEntry\
    \ 4 }\n          matrixControlOwner OBJECT-TYPE\n              SYNTAX OwnerString\n\
    \              ACCESS read-write\n              STATUS mandatory\n           \
    \   DESCRIPTION\n                  \"The entity that configured this entry and\
    \ is\n                  therefore using the resources assigned to it.\"\n    \
    \          ::= { matrixControlEntry 5 }\n          matrixControlStatus OBJECT-TYPE\n\
    \              SYNTAX EntryStatus\n              ACCESS read-write\n         \
    \     STATUS mandatory\n              DESCRIPTION\n                  \"The status\
    \ of this matrixControl entry.\n                  If this object is not equal\
    \ to valid(1), all\n                  associated entries in the matrixSDTable\
    \ and the\n                  matrixDSTable shall be deleted by the agent.\"\n\
    \              ::= { matrixControlEntry 6 }\n          matrixSDTable OBJECT-TYPE\n\
    \              SYNTAX SEQUENCE OF MatrixSDEntry\n              ACCESS not-accessible\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"A list of traffic matrix entries indexed by\n                  source and\
    \ destination MAC address.\"\n              ::= { matrix 2 }\n          matrixSDEntry\
    \ OBJECT-TYPE\n              SYNTAX MatrixSDEntry\n              ACCESS not-accessible\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"A collection of statistics for communications between\n                  two\
    \ addresses on a particular interface.  For example,\n                  an instance\
    \ of the matrixSDPkts object might be named\n                  matrixSDPkts.1.6.8.0.32.27.3.176.6.8.0.32.10.8.113\"\
    \n              INDEX { matrixSDIndex,\n                      matrixSDSourceAddress,\
    \ matrixSDDestAddress }\n              ::= { matrixSDTable 1 }\n          MatrixSDEntry\
    \ ::= SEQUENCE {\n              matrixSDSourceAddress       OCTET STRING,\n  \
    \            matrixSDDestAddress         OCTET STRING,\n              matrixSDIndex\
    \               INTEGER (1..65535),\n              matrixSDPkts              \
    \  Counter,\n              matrixSDOctets              Counter,\n            \
    \  matrixSDErrors              Counter\n          }\n          matrixSDSourceAddress\
    \ OBJECT-TYPE\n              SYNTAX OCTET STRING\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The source physical address.\"\n              ::= { matrixSDEntry 1 }\n  \
    \        matrixSDDestAddress OBJECT-TYPE\n              SYNTAX OCTET STRING\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The destination physical address.\"\n    \
    \          ::= { matrixSDEntry 2 }\n          matrixSDIndex OBJECT-TYPE\n    \
    \          SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n       \
    \       STATUS mandatory\n              DESCRIPTION\n                  \"The set\
    \ of collected matrix statistics of which\n                  this entry is a part.\
    \  The set of matrix statistics\n                  identified by a particular\
    \ value of this index\n                  is associated with the same matrixControlEntry\n\
    \                  as identified by the same value of\n                  matrixControlIndex.\"\
    \n              ::= { matrixSDEntry 3 }\n          matrixSDPkts OBJECT-TYPE\n\
    \              SYNTAX Counter\n              ACCESS read-only\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The number of packets\
    \ transmitted from the source\n                  address to the destination address\
    \ (this number\n                  includes bad packets).\"\n              ::=\
    \ { matrixSDEntry 4 }\n          matrixSDOctets OBJECT-TYPE\n              SYNTAX\
    \ Counter\n              ACCESS read-only\n              STATUS mandatory\n  \
    \            DESCRIPTION\n                  \"The number of octets (excluding\
    \ framing bits but\n                  including FCS octets) contained in all packets\n\
    \                  transmitted from the source address to the\n              \
    \    destination address.\"\n              ::= { matrixSDEntry 5 }\n         \
    \ matrixSDErrors OBJECT-TYPE\n              SYNTAX Counter\n              ACCESS\
    \ read-only\n              STATUS mandatory\n              DESCRIPTION\n     \
    \             \"The number of bad packets transmitted from\n                 \
    \ the source address to the destination address.\"\n              ::= { matrixSDEntry\
    \ 6 }\n          -- Traffic matrix tables from destination to source\n       \
    \   matrixDSTable OBJECT-TYPE\n              SYNTAX SEQUENCE OF MatrixDSEntry\n\
    \              ACCESS not-accessible\n              STATUS mandatory\n       \
    \       DESCRIPTION\n                  \"A list of traffic matrix entries indexed\
    \ by\n                  destination and source MAC address.\"\n              ::=\
    \ { matrix 3 }\n          matrixDSEntry OBJECT-TYPE\n              SYNTAX MatrixDSEntry\n\
    \              ACCESS not-accessible\n              STATUS mandatory\n       \
    \       DESCRIPTION\n                  \"A collection of statistics for communications\
    \ between\n                  two addresses on a particular interface.  For example,\n\
    \                  an instance of the matrixSDPkts object might be named\n   \
    \               matrixSDPkts.1.6.8.0.32.10.8.113.6.8.0.32.27.3.176\"\n       \
    \       INDEX { matrixDSIndex,\n                      matrixDSDestAddress, matrixDSSourceAddress\
    \ }\n              ::= { matrixDSTable 1 }\n          MatrixDSEntry ::= SEQUENCE\
    \ {\n              matrixDSSourceAddress       OCTET STRING,\n              matrixDSDestAddress\
    \         OCTET STRING,\n              matrixDSIndex               INTEGER (1..65535),\n\
    \              matrixDSPkts                Counter,\n              matrixDSOctets\
    \              Counter,\n              matrixDSErrors              Counter\n \
    \         }\n          matrixDSSourceAddress OBJECT-TYPE\n              SYNTAX\
    \ OCTET STRING\n              ACCESS read-only\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"The source physical address.\"\
    \n              ::= { matrixDSEntry 1 }\n          matrixDSDestAddress OBJECT-TYPE\n\
    \              SYNTAX OCTET STRING\n              ACCESS read-only\n         \
    \     STATUS mandatory\n              DESCRIPTION\n                  \"The destination\
    \ physical address.\"\n              ::= { matrixDSEntry 2 }\n          matrixDSIndex\
    \ OBJECT-TYPE\n              SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The set of collected matrix statistics of which\n                  this entry\
    \ is a part.  The set of matrix statistics\n                  identified by a\
    \ particular value of this index\n                  is associated with the same\
    \ matrixControlEntry\n                  as identified by the same value of\n \
    \                 matrixControlIndex.\"\n              ::= { matrixDSEntry 3 }\n\
    \          matrixDSPkts OBJECT-TYPE\n              SYNTAX Counter\n          \
    \    ACCESS read-only\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"The number of packets transmitted from the source\n     \
    \             address to the destination address (this number\n              \
    \    includes bad packets).\"\n              ::= { matrixDSEntry 4 }\n       \
    \   matrixDSOctets OBJECT-TYPE\n              SYNTAX Counter\n              ACCESS\
    \ read-only\n              STATUS mandatory\n              DESCRIPTION\n     \
    \             \"The number of octets (excluding framing bits\n               \
    \   but including FCS octets) contained in all packets\n                  transmitted\
    \ from the source address to the\n                  destination address.\"\n \
    \             ::= { matrixDSEntry 5 }\n          matrixDSErrors OBJECT-TYPE\n\
    \              SYNTAX Counter\n              ACCESS read-only\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The number of bad\
    \ packets transmitted from\n                  the source address to the destination\
    \ address.\"\n              ::= { matrixDSEntry 6 }\n          -- The Filter Group\n\
    \          -- Implementation of the Filter group is optional.\n          --\n\
    \          -- The Filter group allows packets to be captured with an\n       \
    \   -- arbitrary filter expression.  A logical data and\n          -- event stream\
    \ or \"channel\" is formed by the packets\n          -- that match the filter\
    \ expression.\n          --\n          -- This filter mechanism allows the creation\
    \ of an arbitrary\n          -- logical expression with which to filter packets.\
    \  Each\n          -- filter associated with a channel is OR'ed with the others.\n\
    \          -- Within a filter, any bits checked in the data and status\n     \
    \     -- are AND'ed with respect to other bits in the same filter.\n         \
    \ -- The NotMask also allows for checking for inequality.\n          -- Finally,\
    \ the channelAcceptType object allows for\n          -- inversion of the whole\
    \ equation.\n          --\n          -- If a management station wishes to receive\
    \ a trap to alert\n          -- it that new packets have been captured and are\
    \ available\n          -- for download, it is recommended that it set up an alarm\n\
    \          -- entry that monitors the value of the relevant\n          -- channelMatches\
    \ instance.\n          --\n          -- The channel can be turned on or off, and\
    \ can also\n          -- generate events when packets pass through it.\n     \
    \     filterTable OBJECT-TYPE\n              SYNTAX SEQUENCE OF FilterEntry\n\
    \              ACCESS not-accessible\n              STATUS mandatory\n       \
    \       DESCRIPTION\n                  \"A list of packet filter entries.\"\n\
    \              ::= { filter 1 }\n          filterEntry OBJECT-TYPE\n         \
    \     SYNTAX FilterEntry\n              ACCESS not-accessible\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"A set of parameters\
    \ for a packet filter applied on a\n                  particular interface.  As\
    \ an example, an instance of\n                  the filterPktData object might\
    \ be named\n                  filterPktData.12\"\n              INDEX { filterIndex\
    \ }\n              ::= { filterTable 1 }\n          FilterEntry ::= SEQUENCE {\n\
    \              filterIndex                 INTEGER (1..65535),\n             \
    \ filterChannelIndex          INTEGER (1..65535),\n              filterPktDataOffset\
    \         INTEGER,\n              filterPktData               OCTET STRING,\n\
    \              filterPktDataMask           OCTET STRING,\n              filterPktDataNotMask\
    \        OCTET STRING,\n              filterPktStatus             INTEGER,\n \
    \             filterPktStatusMask         INTEGER,\n              filterPktStatusNotMask\
    \      INTEGER,\n              filterOwner                 OwnerString,\n    \
    \          filterStatus                EntryStatus\n          }\n          filterIndex\
    \ OBJECT-TYPE\n              SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"An index that uniquely identifies an entry\n                  in the filter\
    \ table.  Each such entry defines\n                  one filter that is to be\
    \ applied to every packet\n                  received on an interface.\"\n   \
    \           ::= { filterEntry 1 }\n          filterChannelIndex OBJECT-TYPE\n\
    \              SYNTAX INTEGER (1..65535)\n              ACCESS read-write\n  \
    \            STATUS mandatory\n              DESCRIPTION\n                  \"\
    This object identifies the channel of which this\n                  filter is\
    \ a part.  The filters identified by a\n                  particular value of\
    \ this object are associated with\n                  the same channel as identified\
    \ by the same value of\n                  the channelIndex object.\"\n       \
    \       ::= { filterEntry 2 }\n          filterPktDataOffset OBJECT-TYPE\n   \
    \           SYNTAX INTEGER\n              ACCESS read-write\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The offset from the\
    \ beginning of each packet where\n                  a match of packet data will\
    \ be attempted.  This offset\n                  is measured from the point in\
    \ the physical layer\n                  packet after the framing bits, if any.\
    \  For example,\n                  in an Ethernet frame, this point is at the\
    \ beginning\n                  of the destination MAC address.\n             \
    \     This object may not be modified if the associated\n                  filterStatus\
    \ object is equal to valid(1).\"\n              DEFVAL { 0 }\n              ::=\
    \ { filterEntry 3 }\n          filterPktData OBJECT-TYPE\n              SYNTAX\
    \ OCTET STRING\n              ACCESS read-write\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"The data that is to be matched\
    \ with the input\n                  packet.  For each packet received, this filter\
    \ and\n                  the accompanying filterPktDataMask and\n            \
    \      filterPktDataNotMask will be adjusted for the\n                  offset.\
    \  The only bits relevant to this match\n                  algorithm are those\
    \ that have the corresponding\n                  filterPktDataMask bit equal to\
    \ one.  The following\n                  three rules are then applied to every\
    \ packet:\n                  (1) If the packet is too short and does not have\
    \ data\n                      corresponding to part of the filterPktData, the\n\
    \                      packet will fail this data match.\n                  (2)\
    \ For each relevant bit from the packet with the\n                      corresponding\
    \ filterPktDataNotMask bit set to\n                      zero, if the bit from\
    \ the packet is not equal to\n                      the corresponding bit from\
    \ the filterPktData,\n                      then the packet will fail this data\
    \ match.\n                  (3) If for every relevant bit from the packet with\
    \ the\n                      corresponding filterPktDataNotMask bit set to one,\n\
    \                      the bit from the packet is equal to the\n             \
    \         corresponding bit from the filterPktData, then\n                   \
    \   the packet will fail this data match.\n                  Any packets that\
    \ have not failed any of the three\n                  matches above have passed\
    \ this data match.  In\n                  particular, a zero length filter will\
    \ match any\n                  packet.\n                  This object may not\
    \ be modified if the associated\n                  filterStatus object is equal\
    \ to valid(1).\"\n              ::= { filterEntry 4 }\n          filterPktDataMask\
    \ OBJECT-TYPE\n              SYNTAX OCTET STRING\n              ACCESS read-write\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The mask that is applied to the match process.\n                  After adjusting\
    \ this mask for the offset, only those\n                  bits in the received\
    \ packet that correspond to bits\n                  set in this mask are relevant\
    \ for further processing\n                  by the match algorithm.  The offset\
    \ is applied to\n                  filterPktDataMask in the same way it is applied\
    \ to the\n                  filter.  For the purposes of the matching algorithm,\n\
    \                  if the associated filterPktData object is longer\n        \
    \          than this mask, this mask is conceptually extended\n              \
    \    with '1' bits until it reaches the length of the\n                  filterPktData\
    \ object.\n                  This object may not be modified if the associated\n\
    \                  filterStatus object is equal to valid(1).\"\n             \
    \ ::= { filterEntry 5 }\n          filterPktDataNotMask OBJECT-TYPE\n        \
    \      SYNTAX OCTET STRING\n              ACCESS read-write\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The inversion mask\
    \ that is applied to the match\n                  process.  After adjusting this\
    \ mask for the offset,\n                  those relevant bits in the received\
    \ packet that\n                  correspond to bits cleared in this mask must\
    \ all be\n                  equal to their corresponding bits in the\n       \
    \           filterPktData object for the packet to be accepted.\n            \
    \      In addition, at least one of those relevant bits in\n                 \
    \ the received packet that correspond to bits set in\n                  this mask\
    \ must be different to its corresponding bit\n                  in the filterPktData\
    \ object.\n                  For the purposes of the matching algorithm, if the\n\
    \                  associated filterPktData object is longer than this\n     \
    \             mask, this mask is conceptually extended with '0'\n            \
    \      bits until it reaches the length of the\n                  filterPktData\
    \ object.\n                  This object may not be modified if the associated\n\
    \                  filterStatus object is equal to valid(1).\"\n             \
    \ ::= { filterEntry 6 }\n          filterPktStatus OBJECT-TYPE\n             \
    \ SYNTAX INTEGER\n              ACCESS read-write\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"The status that is to be matched\
    \ with the input\n                  packet.  The only bits relevant to this match\n\
    \                  algorithm are those that have the corresponding\n         \
    \         filterPktStatusMask bit equal to one.  The following\n             \
    \     two rules are then applied to every packet:\n                  (1) For each\
    \ relevant bit from the packet status\n                      with the corresponding\
    \ filterPktStatusNotMask bit\n                      set to zero, if the bit from\
    \ the packet status is\n                      not equal to the corresponding bit\
    \ from the\n                      filterPktStatus, then the packet will fail this\n\
    \                      status match.\n                  (2) If for every relevant\
    \ bit from the packet status\n                      with the corresponding filterPktStatusNotMask\
    \ bit\n                      set to one, the bit from the packet status is\n \
    \                     equal to the corresponding bit from the\n              \
    \        filterPktStatus, then the packet will fail this\n                   \
    \   status match.\n                  Any packets that have not failed either of\
    \ the two\n                  matches above have passed this status match.  In\n\
    \                  particular, a zero length status filter will match any\n  \
    \                packet's status.\n                  The value of the packet status\
    \ is a sum.  This sum\n                  initially takes the value zero.  Then,\
    \ for each\n                  error, E, that has been discovered in this packet,\n\
    \                  2 raised to a value representing E is added to the\n      \
    \            sum. The errors and the bits that represent them are\n          \
    \        dependent on the media type of the interface that\n                 \
    \ this channel is receiving packets from.\n                  The errors defined\
    \ for a packet captured off of an\n                  Ethernet interface are as\
    \ follows:\n                      bit #    Error\n                          0\
    \    Packet is longer than 1518 octets\n                          1    Packet\
    \ is shorter than 64 octets\n                          2    Packet experienced\
    \ a CRC or Alignment\n                               error\n                 \
    \ For example, an Ethernet fragment would have a\n                  value of 6\
    \ (2^1 + 2^2).\n                  As this MIB is expanded to new media types,\
    \ this\n                  object will have other media-specific errors\n     \
    \             defined.\n                  For the purposes of this status matching\
    \ algorithm,\n                  if the packet status is longer than this\n   \
    \               filterPktStatus object, this object is conceptually\n        \
    \          extended with '0' bits until it reaches the size of\n             \
    \     the packet status.\n                  This object may not be modified if\
    \ the associated\n                  filterStatus object is equal to valid(1).\"\
    \n              ::= { filterEntry 7 }\n          filterPktStatusMask OBJECT-TYPE\n\
    \              SYNTAX INTEGER\n              ACCESS read-write\n             \
    \ STATUS mandatory\n              DESCRIPTION\n                  \"The mask that\
    \ is applied to the status match\n                  process.  Only those bits\
    \ in the received packet\n                  that correspond to bits set in this\
    \ mask are\n                  relevant for further processing by the status match\n\
    \                  algorithm.  For the purposes of the matching\n            \
    \      algorithm, if the associated filterPktStatus object\n                 \
    \ is longer than this mask, this mask is conceptually\n                  extended\
    \ with '1' bits until it reaches the size of\n                  the filterPktStatus.\
    \  In addition, if a packet\n                  status is longer than this mask,\
    \ this mask is\n                  conceptually extended with '0' bits until it\
    \ reaches\n                  the size of the packet status.\n                \
    \  This object may not be modified if the associated\n                  filterStatus\
    \ object is equal to valid(1).\"\n              ::= { filterEntry 8 }\n      \
    \    filterPktStatusNotMask OBJECT-TYPE\n              SYNTAX INTEGER\n      \
    \        ACCESS read-write\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"The inversion mask that is applied to the status\n      \
    \            match process.  Those relevant bits in the received\n           \
    \       packet status that correspond to bits cleared in\n                  this\
    \ mask must all be equal to their corresponding\n                  bits in the\
    \ filterPktStatus object for the packet to\n                  be accepted.  In\
    \ addition, at least one of those\n                  relevant bits in the received\
    \ packet status that\n                  correspond to bits set in this mask must\
    \ be\n                  different to its corresponding bit in the\n          \
    \        filterPktStatus object for the packet to be\n                  accepted.\n\
    \                  For the purposes of the matching algorithm, if the\n      \
    \            associated filterPktStatus object or a packet status\n          \
    \        is longer than this mask, this mask is conceptually\n               \
    \   extended with '0' bits until it reaches the longer\n                  of the\
    \ lengths of the filterPktStatus object and the\n                  packet status.\n\
    \                  This object may not be modified if the associated\n       \
    \           filterStatus object is equal to valid(1).\"\n              ::= { filterEntry\
    \ 9 }\n          filterOwner OBJECT-TYPE\n              SYNTAX OwnerString\n \
    \             ACCESS read-write\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The entity that configured this entry and\
    \ is\n                  therefore using the resources assigned to it.\"\n    \
    \          ::= { filterEntry 10 }\n          filterStatus OBJECT-TYPE\n      \
    \        SYNTAX EntryStatus\n              ACCESS read-write\n              STATUS\
    \ mandatory\n              DESCRIPTION\n                  \"The status of this\
    \ filter entry.\"\n              ::= { filterEntry 11 }\n          channelTable\
    \ OBJECT-TYPE\n              SYNTAX SEQUENCE OF ChannelEntry\n              ACCESS\
    \ not-accessible\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"A list of packet channel entries.\"\n              ::= {\
    \ filter 2 }\n          channelEntry OBJECT-TYPE\n              SYNTAX ChannelEntry\n\
    \              ACCESS not-accessible\n              STATUS mandatory\n       \
    \       DESCRIPTION\n                  \"A set of parameters for a packet channel\
    \ applied on a\n                  particular interface.  As an example, an instance\
    \ of\n                  the channelMatches object might be named\n           \
    \       channelMatches.3\"\n              INDEX { channelIndex }\n           \
    \   ::= { channelTable 1 }\n          ChannelEntry ::= SEQUENCE {\n          \
    \    channelIndex               INTEGER (1..65535),\n              channelIfIndex\
    \             INTEGER (1..65535),\n              channelAcceptType          INTEGER,\n\
    \              channelDataControl         INTEGER,\n              channelTurnOnEventIndex\
    \    INTEGER (0..65535),\n              channelTurnOffEventIndex   INTEGER (0..65535),\n\
    \              channelEventIndex          INTEGER (0..65535),\n              channelEventStatus\
    \         INTEGER,\n              channelMatches             Counter,\n      \
    \        channelDescription         DisplayString (SIZE (0..127)),\n         \
    \     channelOwner               OwnerString,\n              channelStatus   \
    \           EntryStatus\n          }\n          channelIndex OBJECT-TYPE\n   \
    \           SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n      \
    \        STATUS mandatory\n              DESCRIPTION\n                  \"An index\
    \ that uniquely identifies an entry in the\n                  channel table. \
    \ Each such entry defines one channel,\n                  a logical data and event\
    \ stream.\n                  It is suggested that before creating a channel, an\n\
    \                  application should scan all instances of the\n            \
    \      filterChannelIndex object to make sure that there\n                  are\
    \ no pre-existing filters that would be\n                  inadvertently be linked\
    \ to the channel.\"\n              ::= { channelEntry 1 }\n          channelIfIndex\
    \ OBJECT-TYPE\n              SYNTAX INTEGER (1..65535)\n              ACCESS read-write\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The value of this object uniquely identifies the\n                  interface\
    \ on this remote network monitoring device\n                  to which the associated\
    \ filters are applied to allow\n                  data into this channel.  The\
    \ interface identified by\n                  a particular value of this object\
    \ is the same\n                  interface as identified by the same value of\
    \ the\n                  ifIndex object, defined in RFC 1213 and RFC 1573\n  \
    \                [4,6].\n                  The filters in this group are applied\
    \ to all packets\n                  on the local network segment attached to the\n\
    \                  identified interface.\n                  An agent may or may\
    \ not be able to tell if\n                  fundamental changes to the media of\
    \ the interface\n                  have occurred and necessitate an invalidation\
    \ of\n                  this entry.  For example, a hot-pluggable ethernet\n \
    \                 card could be pulled out and replaced by a\n               \
    \   token-ring card.  In such a case, if the agent has\n                  such\
    \ knowledge of the change, it is recommended that\n                  it invalidate\
    \ this entry.\n                  This object may not be modified if the associated\n\
    \                  channelStatus object is equal to valid(1).\"\n            \
    \  ::= { channelEntry 2 }\n          channelAcceptType OBJECT-TYPE\n         \
    \     SYNTAX INTEGER {\n                  acceptMatched(1),\n                \
    \  acceptFailed(2)\n              }\n              ACCESS read-write\n       \
    \       STATUS mandatory\n              DESCRIPTION\n                  \"This\
    \ object controls the action of the filters\n                  associated with\
    \ this channel.  If this object is equal\n                  to acceptMatched(1),\
    \ packets will be accepted to this\n                  channel if they are accepted\
    \ by both the packet data\n                  and packet status matches of an associated\
    \ filter.  If\n                  this object is equal to acceptFailed(2), packets\
    \ will\n                  be accepted to this channel only if they fail either\n\
    \                  the packet data match or the packet status match of\n     \
    \             each of the associated filters.\n                  In particular,\
    \ a channel with no associated filters\n                  will match no packets\
    \ if set to acceptMatched(1)\n                  case and will match all packets\
    \ in the\n                  acceptFailed(2) case.\n                  This object\
    \ may not be modified if the associated\n                  channelStatus object\
    \ is equal to valid(1).\"\n              ::= { channelEntry 3 }\n          channelDataControl\
    \ OBJECT-TYPE\n              SYNTAX INTEGER {\n                  on(1),\n    \
    \              off(2)\n              }\n              ACCESS read-write\n    \
    \          STATUS mandatory\n              DESCRIPTION\n                  \"This\
    \ object controls the flow of data through this\n                  channel.  If\
    \ this object is on(1), data, status and\n                  events flow through\
    \ this channel.  If this object is\n                  off(2), data, status and\
    \ events will not flow\n                  through this channel.\"\n          \
    \    DEFVAL { off }\n              ::= { channelEntry 4 }\n          channelTurnOnEventIndex\
    \ OBJECT-TYPE\n              SYNTAX INTEGER (0..65535)\n              ACCESS read-write\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The value of this object identifies the event\n                  that is configured\
    \ to turn the associated\n                  channelDataControl from off to on\
    \ when the event is\n                  generated.  The event identified by a particular\
    \ value\n                  of this object is the same event as identified by the\n\
    \                  same value of the eventIndex object.  If there is no\n    \
    \              corresponding entry in the eventTable, then no\n              \
    \    association exists.  In fact, if no event is intended\n                 \
    \ for this channel, channelTurnOnEventIndex must be\n                  set to\
    \ zero, a non-existent event index.\n                  This object may not be\
    \ modified if the associated\n                  channelStatus object is equal\
    \ to valid(1).\"\n              ::= { channelEntry 5 }\n          channelTurnOffEventIndex\
    \ OBJECT-TYPE\n              SYNTAX INTEGER (0..65535)\n              ACCESS read-write\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The value of this object identifies the event\n                  that is configured\
    \ to turn the associated\n                  channelDataControl from on to off\
    \ when the event is\n                  generated.  The event identified by a particular\
    \ value\n                  of this object is the same event as identified by the\n\
    \                  same value of the eventIndex object.  If there is no\n    \
    \              corresponding entry in the eventTable, then no\n              \
    \    association exists.  In fact, if no event is intended\n                 \
    \ for this channel, channelTurnOffEventIndex must be\n                  set to\
    \ zero, a non-existent event index.\n                  This object may not be\
    \ modified if the associated\n                  channelStatus object is equal\
    \ to valid(1).\"\n              ::= { channelEntry 6 }\n          channelEventIndex\
    \ OBJECT-TYPE\n              SYNTAX INTEGER (0..65535)\n              ACCESS read-write\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The value of this object identifies the event\n                  that is configured\
    \ to be generated when the\n                  associated channelDataControl is\
    \ on and a packet\n                  is matched.  The event identified by a particular\n\
    \                  value of this object is the same event as identified\n    \
    \              by the same value of the eventIndex object.  If\n             \
    \     there is no corresponding entry in the eventTable,\n                  then\
    \ no association exists.  In fact, if no event is\n                  intended\
    \ for this channel, channelEventIndex must be\n                  set to zero,\
    \ a non-existent event index.\n                  This object may not be modified\
    \ if the associated\n                  channelStatus object is equal to valid(1).\"\
    \n              ::= { channelEntry 7 }\n          channelEventStatus OBJECT-TYPE\n\
    \              SYNTAX INTEGER {\n                  eventReady(1),\n          \
    \        eventFired(2),\n                  eventAlwaysReady(3)\n             \
    \ }\n              ACCESS read-write\n              STATUS mandatory\n       \
    \       DESCRIPTION\n                  \"The event status of this channel.\n \
    \                 If this channel is configured to generate events\n         \
    \         when packets are matched, a means of controlling\n                 \
    \ the flow of those events is often needed.  When\n                  this object\
    \ is equal to eventReady(1), a single\n                  event may be generated,\
    \ after which this object\n                  will be set by the probe to eventFired(2).\
    \  While\n                  in the eventFired(2) state, no events will be\n  \
    \                generated until the object is modified to\n                 \
    \ eventReady(1) (or eventAlwaysReady(3)).  The\n                  management station\
    \ can thus easily respond to a\n                  notification of an event by\
    \ re-enabling this object.\n                  If the management station wishes\
    \ to disable this\n                  flow control and allow events to be generated\n\
    \                  at will, this object may be set to\n                  eventAlwaysReady(3).\
    \  Disabling the flow control\n                  is discouraged as it can result\
    \ in high network\n                  traffic or other performance problems.\"\n\
    \              DEFVAL { eventReady }\n              ::= { channelEntry 8 }\n \
    \         channelMatches OBJECT-TYPE\n              SYNTAX Counter\n         \
    \     ACCESS read-only\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"The number of times this channel has matched a\n        \
    \          packet. Note that this object is updated even when\n              \
    \    channelDataControl is set to off.\"\n              ::= { channelEntry 9 }\n\
    \          channelDescription OBJECT-TYPE\n              SYNTAX DisplayString\
    \ (SIZE (0..127))\n              ACCESS read-write\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"A comment describing this channel.\"\
    \n              ::= { channelEntry 10 }\n          channelOwner OBJECT-TYPE\n\
    \              SYNTAX OwnerString\n              ACCESS read-write\n         \
    \     STATUS mandatory\n              DESCRIPTION\n                  \"The entity\
    \ that configured this entry and is\n                  therefore using the resources\
    \ assigned to it.\"\n              ::= { channelEntry 11 }\n          channelStatus\
    \ OBJECT-TYPE\n              SYNTAX EntryStatus\n              ACCESS read-write\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The status of this channel entry.\"\n              ::= { channelEntry 12 }\n\
    \          -- The Packet Capture Group\n          -- Implementation of the Packet\
    \ Capture group is optional.\n          --\n          -- The Packet Capture Group\
    \ requires implementation of the\n          -- Filter Group.\n          --\n \
    \         -- The Packet Capture group allows packets to be captured\n        \
    \  -- upon a filter match.  The bufferControlTable controls\n          -- the\
    \ captured packets output from a channel that is\n          -- associated with\
    \ it.  The captured packets are placed\n          -- in entries in the captureBufferTable.\
    \  These entries are\n          -- associated with the bufferControlEntry on whose\
    \ behalf they\n          -- were stored.\n          bufferControlTable OBJECT-TYPE\n\
    \              SYNTAX SEQUENCE OF BufferControlEntry\n              ACCESS not-accessible\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"A list of buffers control entries.\"\n              ::= { capture 1 }\n  \
    \        bufferControlEntry OBJECT-TYPE\n              SYNTAX BufferControlEntry\n\
    \              ACCESS not-accessible\n              STATUS mandatory\n       \
    \       DESCRIPTION\n                  \"A set of parameters that control the\
    \ collection of\n                  a stream of packets that have matched filters.\
    \  As\n                  an example, an instance of the\n                  bufferControlCaptureSliceSize\
    \ object might be named\n                  bufferControlCaptureSliceSize.3\"\n\
    \              INDEX { bufferControlIndex }\n              ::= { bufferControlTable\
    \ 1 }\n          BufferControlEntry ::= SEQUENCE {\n              bufferControlIndex\
    \                INTEGER (1..65535),\n              bufferControlChannelIndex\
    \         INTEGER (1..65535),\n              bufferControlFullStatus         \
    \  INTEGER,\n              bufferControlFullAction           INTEGER,\n      \
    \        bufferControlCaptureSliceSize     INTEGER,\n              bufferControlDownloadSliceSize\
    \    INTEGER,\n              bufferControlDownloadOffset       INTEGER,\n    \
    \          bufferControlMaxOctetsRequested   INTEGER,\n              bufferControlMaxOctetsGranted\
    \     INTEGER,\n              bufferControlCapturedPackets      INTEGER,\n   \
    \           bufferControlTurnOnTime           TimeTicks,\n              bufferControlOwner\
    \                OwnerString,\n              bufferControlStatus             \
    \  EntryStatus\n          }\n          bufferControlIndex OBJECT-TYPE\n      \
    \        SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n         \
    \     STATUS mandatory\n              DESCRIPTION\n                  \"An index\
    \ that uniquely identifies an entry\n                  in the bufferControl table.\
    \  The value of this\n                  index shall never be zero.  Each such\n\
    \                  entry defines one set of packets that is\n                \
    \  captured and controlled by one or more filters.\"\n              ::= { bufferControlEntry\
    \ 1 }\n          bufferControlChannelIndex OBJECT-TYPE\n              SYNTAX INTEGER\
    \ (1..65535)\n              ACCESS read-write\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"An index that identifies the channel\
    \ that is the\n                  source of packets for this bufferControl table.\n\
    \                  The channel identified by a particular value of this\n    \
    \              index is the same as identified by the same value of\n        \
    \          the channelIndex object.\n                  This object may not be\
    \ modified if the associated\n                  bufferControlStatus object is\
    \ equal to valid(1).\"\n              ::= { bufferControlEntry 2 }\n         \
    \ bufferControlFullStatus OBJECT-TYPE\n              SYNTAX INTEGER {\n      \
    \                spaceAvailable(1),\n                      full(2)\n         \
    \     }\n              ACCESS read-only\n              STATUS mandatory\n    \
    \          DESCRIPTION\n                  \"This object shows whether the buffer\
    \ has room to\n                  accept new packets or if it is full.\n      \
    \            If the status is spaceAvailable(1), the buffer is\n             \
    \     accepting new packets normally.  If the status is\n                  full(2)\
    \ and the associated bufferControlFullAction\n                  object is wrapWhenFull,\
    \ the buffer is accepting new\n                  packets by deleting enough of\
    \ the oldest packets\n                  to make room for new ones as they arrive.\
    \  Otherwise,\n                  if the status is full(2) and the\n          \
    \        bufferControlFullAction object is lockWhenFull,\n                  then\
    \ the buffer has stopped collecting packets.\n                  When this object\
    \ is set to full(2) the probe must\n                  not later set it to spaceAvailable(1)\
    \ except in the\n                  case of a significant gain in resources such\
    \ as\n                  an increase of bufferControlOctetsGranted.  In\n     \
    \             particular, the wrap-mode action of deleting old\n             \
    \     packets to make room for newly arrived packets\n                  must not\
    \ affect the value of this object.\"\n              ::= { bufferControlEntry 3\
    \ }\n          bufferControlFullAction OBJECT-TYPE\n              SYNTAX INTEGER\
    \ {\n                      lockWhenFull(1),\n                      wrapWhenFull(2)\
    \    -- FIFO\n              }\n              ACCESS read-write\n             \
    \ STATUS mandatory\n              DESCRIPTION\n                  \"Controls the\
    \ action of the buffer when it\n                  reaches the full status.  When\
    \ in the lockWhenFull(1)\n                  state and a packet is added to the\
    \ buffer that\n                  fills the buffer, the bufferControlFullStatus\
    \ will\n                  be set to full(2) and this buffer will stop capturing\n\
    \                  packets.\"\n              ::= { bufferControlEntry 4 }\n  \
    \        bufferControlCaptureSliceSize OBJECT-TYPE\n              SYNTAX INTEGER\n\
    \              ACCESS read-write\n              STATUS mandatory\n           \
    \   DESCRIPTION\n                  \"The maximum number of octets of each packet\n\
    \                  that will be saved in this capture buffer.\n              \
    \    For example, if a 1500 octet packet is received by\n                  the\
    \ probe and this object is set to 500, then only\n                  500 octets\
    \ of the packet will be stored in the\n                  associated capture buffer.\
    \  If this variable is set\n                  to 0, the capture buffer will save\
    \ as many octets\n                  as is possible.\n                  This object\
    \ may not be modified if the associated\n                  bufferControlStatus\
    \ object is equal to valid(1).\"\n              DEFVAL { 100 }\n             \
    \ ::= { bufferControlEntry 5 }\n          bufferControlDownloadSliceSize OBJECT-TYPE\n\
    \              SYNTAX INTEGER\n              ACCESS read-write\n             \
    \ STATUS mandatory\n              DESCRIPTION\n                  \"The maximum\
    \ number of octets of each packet\n                  in this capture buffer that\
    \ will be returned in\n                  an SNMP retrieval of that packet.  For\
    \ example,\n                  if 500 octets of a packet have been stored in the\n\
    \                  associated capture buffer, the associated\n               \
    \   bufferControlDownloadOffset is 0, and this\n                  object is set\
    \ to 100, then the captureBufferPacket\n                  object that contains\
    \ the packet will contain only\n                  the first 100 octets of the\
    \ packet.\n                  A prudent manager will take into account possible\n\
    \                  interoperability or fragmentation problems that may\n     \
    \             occur if the download slice size is set too large.\n           \
    \       In particular, conformant SNMP implementations are not\n             \
    \     required to accept messages whose length exceeds 484\n                 \
    \ octets, although they are encouraged to support larger\n                  datagrams\
    \ whenever feasible.\"\n              DEFVAL { 100 }\n              ::= { bufferControlEntry\
    \ 6 }\n          bufferControlDownloadOffset OBJECT-TYPE\n              SYNTAX\
    \ INTEGER\n              ACCESS read-write\n              STATUS mandatory\n \
    \             DESCRIPTION\n                  \"The offset of the first octet of\
    \ each packet\n                  in this capture buffer that will be returned\
    \ in\n                  an SNMP retrieval of that packet.  For example,\n    \
    \              if 500 octets of a packet have been stored in the\n           \
    \       associated capture buffer and this object is set to\n                \
    \  100, then the captureBufferPacket object that\n                  contains the\
    \ packet will contain bytes starting\n                  100 octets into the packet.\"\
    \n              DEFVAL { 0 }\n              ::= { bufferControlEntry 7 }\n   \
    \       bufferControlMaxOctetsRequested OBJECT-TYPE\n              SYNTAX INTEGER\n\
    \              ACCESS read-write\n              STATUS mandatory\n           \
    \   DESCRIPTION\n                  \"The requested maximum number of octets to\
    \ be\n                  saved in this captureBuffer, including any\n         \
    \         implementation-specific overhead. If this variable\n               \
    \   is set to -1, the capture buffer will save as many\n                  octets\
    \ as is possible.\n                  When this object is created or modified,\
    \ the probe\n                  should set bufferControlMaxOctetsGranted as closely\n\
    \                  to this object as is possible for the particular probe\n  \
    \                implementation and available resources.  However, if\n      \
    \            the object has the special value of -1, the probe\n             \
    \     must set bufferControlMaxOctetsGranted to -1.\"\n              DEFVAL {\
    \ -1 }\n              ::= { bufferControlEntry 8 }\n          bufferControlMaxOctetsGranted\
    \ OBJECT-TYPE\n              SYNTAX INTEGER\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The maximum number of octets that can be\n                  saved in this\
    \ captureBuffer, including overhead.\n                  If this variable is -1,\
    \ the capture buffer will save\n                  as many octets as possible.\n\
    \                  When the bufferControlMaxOctetsRequested object is\n      \
    \            created or modified, the probe should set this object\n         \
    \         as closely to the requested value as is possible for\n             \
    \     the particular probe implementation and available\n                  resources.\n\
    \                  However, if the request object has the special value\n    \
    \              of -1, the probe must set this object to -1.\n                \
    \  The probe must not lower this value except as a result\n                  of\
    \ a modification to the associated\n                  bufferControlMaxOctetsRequested\
    \ object.\n                  When this maximum number of octets is reached\n \
    \                 and a new packet is to be added to this\n                  capture\
    \ buffer and the corresponding\n                  bufferControlFullAction is set\
    \ to wrapWhenFull(2),\n                  enough of the oldest packets associated\
    \ with this\n                  capture buffer shall be deleted by the agent so\n\
    \                  that the new packet can be added.  If the\n               \
    \   corresponding bufferControlFullAction is set to\n                  lockWhenFull(1),\
    \ the new packet shall be discarded.\n                  In either case, the probe\
    \ must set\n                  bufferControlFullStatus to full(2).\n          \
    \        When the value of this object changes to a value less\n             \
    \     than the current value, entries are deleted from\n                  the\
    \ captureBufferTable associated with this\n                  bufferControlEntry.\
    \  Enough of the\n                  oldest of these captureBufferEntries shall\
    \ be\n                  deleted by the agent so that the number of octets\n  \
    \                used remains less than or equal to the new value of\n       \
    \           this object.\n                  When the value of this object changes\
    \ to a value\n                  greater than the current value, the number of\n\
    \                  associated captureBufferEntries may be allowed to\n       \
    \           grow.\"\n              ::= { bufferControlEntry 9 }\n          bufferControlCapturedPackets\
    \ OBJECT-TYPE\n              SYNTAX INTEGER\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The number of packets currently in this\n                  captureBuffer.\"\
    \n              ::= { bufferControlEntry 10 }\n          bufferControlTurnOnTime\
    \ OBJECT-TYPE\n              SYNTAX TimeTicks\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The value of sysUpTime when this capture buffer was\n                  first\
    \ turned on.\"\n              ::= { bufferControlEntry 11 }\n          bufferControlOwner\
    \ OBJECT-TYPE\n              SYNTAX OwnerString\n              ACCESS read-write\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The entity that configured this entry and is\n                  therefore\
    \ using the resources assigned to it.\"\n              ::= { bufferControlEntry\
    \ 12 }\n          bufferControlStatus OBJECT-TYPE\n              SYNTAX EntryStatus\n\
    \              ACCESS read-write\n              STATUS mandatory\n           \
    \   DESCRIPTION\n                  \"The status of this buffer Control Entry.\"\
    \n              ::= { bufferControlEntry 13 }\n          captureBufferTable OBJECT-TYPE\n\
    \              SYNTAX SEQUENCE OF CaptureBufferEntry\n              ACCESS not-accessible\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"A list of packets captured off of a channel.\"\n              ::= { capture\
    \ 2 }\n          captureBufferEntry OBJECT-TYPE\n              SYNTAX CaptureBufferEntry\n\
    \              ACCESS not-accessible\n              STATUS mandatory\n       \
    \       DESCRIPTION\n                  \"A packet captured off of an attached\
    \ network.  As an\n                  example, an instance of the captureBufferPacketData\n\
    \                  object might be named captureBufferPacketData.3.1783\"\n  \
    \            INDEX { captureBufferControlIndex, captureBufferIndex }\n       \
    \       ::= { captureBufferTable 1 }\n          CaptureBufferEntry ::= SEQUENCE\
    \ {\n              captureBufferControlIndex   INTEGER (1..65535),\n         \
    \     captureBufferIndex          INTEGER (1..2147483647),\n              captureBufferPacketID\
    \       INTEGER,\n              captureBufferPacketData     OCTET STRING,\n  \
    \            captureBufferPacketLength   INTEGER,\n              captureBufferPacketTime\
    \     INTEGER,\n              captureBufferPacketStatus   INTEGER\n          }\n\
    \          captureBufferControlIndex OBJECT-TYPE\n              SYNTAX INTEGER\
    \ (1..65535)\n              ACCESS read-only\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"The index of the bufferControlEntry\
    \ with which\n                  this packet is associated.\"\n              ::=\
    \ { captureBufferEntry 1 }\n          captureBufferIndex OBJECT-TYPE\n       \
    \       SYNTAX INTEGER (1..2147483647)\n              ACCESS read-only\n     \
    \         STATUS mandatory\n              DESCRIPTION\n                  \"An\
    \ index that uniquely identifies an entry\n                  in the captureBuffer\
    \ table associated with a\n                  particular bufferControlEntry.  This\
    \ index will\n                  start at 1 and increase by one for each new packet\n\
    \                  added with the same captureBufferControlIndex.\n          \
    \        Should this value reach 2147483647, the next packet\n               \
    \   added with the same captureBufferControlIndex shall\n                  cause\
    \ this value to wrap around to 1.\"\n              ::= { captureBufferEntry 2\
    \ }\n          captureBufferPacketID OBJECT-TYPE\n              SYNTAX INTEGER\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"An index that describes the order of packets\n\
    \                  that are received on a particular interface.\n            \
    \      The packetID of a packet captured on an\n                  interface is\
    \ defined to be greater than the\n                  packetID's of all packets\
    \ captured previously on\n                  the same interface.  As the captureBufferPacketID\n\
    \                  object has a maximum positive value of 2^31 - 1,\n        \
    \          any captureBufferPacketID object shall have the\n                 \
    \ value of the associated packet's packetID mod 2^31.\"\n              ::= { captureBufferEntry\
    \ 3 }\n          captureBufferPacketData OBJECT-TYPE\n              SYNTAX OCTET\
    \ STRING\n              ACCESS read-only\n              STATUS mandatory\n   \
    \           DESCRIPTION\n                  \"The data inside the packet, starting\
    \ at the\n                  beginning of the packet plus any offset specified\
    \ in\n                  the associated bufferControlDownloadOffset,\n        \
    \          including any link level headers.  The length of the\n            \
    \      data in this object is the minimum of the length of\n                 \
    \ the captured packet minus the offset, the length of\n                  the associated\
    \ bufferControlCaptureSliceSize minus\n                  the offset, and the associated\n\
    \                  bufferControlDownloadSliceSize.  If this minimum is\n     \
    \             less than zero, this object shall have a length of\n           \
    \       zero.\"\n              ::= { captureBufferEntry 4 }\n          captureBufferPacketLength\
    \ OBJECT-TYPE\n              SYNTAX INTEGER\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The actual length (off the wire) of the packet stored\n                  in\
    \ this entry, including FCS octets.\"\n              ::= { captureBufferEntry\
    \ 5 }\n          captureBufferPacketTime OBJECT-TYPE\n              SYNTAX INTEGER\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The number of milliseconds that had passed\
    \ since\n                  this capture buffer was first turned on when this\n\
    \                  packet was captured.\"\n              ::= { captureBufferEntry\
    \ 6 }\n          captureBufferPacketStatus OBJECT-TYPE\n              SYNTAX INTEGER\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"A value which indicates the error status of\
    \ this\n                  packet.\n                  The value of this object\
    \ is defined in the same way as\n                  filterPktStatus.  The value\
    \ is a sum.  This sum\n                  initially takes the value zero.  Then,\
    \ for each\n                  error, E, that has been discovered in this packet,\n\
    \                  2 raised to a value representing E is added to the\n      \
    \            sum.\n                  The errors defined for a packet captured\
    \ off of an\n                  Ethernet interface are as follows:\n          \
    \            bit #    Error\n                          0    Packet is longer than\
    \ 1518 octets\n                          1    Packet is shorter than 64 octets\n\
    \                          2    Packet experienced a CRC or Alignment\n      \
    \                         error\n                          3    First packet in\
    \ this capture buffer after\n                               it was detected that\
    \ some packets were\n                               not processed correctly.\n\
    \                          4    Packet's order in buffer is only\n           \
    \                    approximate (May only be set for packets\n              \
    \                 sent from the probe)\n                  For example, an Ethernet\
    \ fragment would have a\n                  value of 6 (2^1 + 2^2).\n         \
    \         As this MIB is expanded to new media types, this\n                 \
    \ object will have other media-specific errors defined.\"\n              ::= {\
    \ captureBufferEntry 7 }\n          -- The Event Group\n          -- Implementation\
    \ of the Event group is optional.\n          --\n          -- The Event group\
    \ controls the generation and notification\n          -- of events from this device.\
    \  Each entry in the eventTable\n          -- describes the parameters of the\
    \ event that can be\n          -- triggered. Each event entry is fired by an associated\n\
    \          -- condition located elsewhere in the MIB.  An event entry\n      \
    \    -- may also be associated- with a function elsewhere in the\n          --\
    \ MIB that will be executed when the event is generated.  For\n          -- example,\
    \ a channel may be turned on or off by the firing\n          -- of an event.\n\
    \          --\n          -- Each eventEntry may optionally specify that a log\
    \ entry\n          -- be created on its behalf whenever the event occurs.\n  \
    \        -- Each entry may also specify that notification should\n          --\
    \ occur by way of SNMP trap messages.  In this case, the\n          -- community\
    \ for the trap message is given in the associated\n          -- eventCommunity\
    \ object.  The enterprise and specific trap\n          -- fields of the trap are\
    \ determined by the condition that\n          -- triggered the event.  Two traps\
    \ are defined: risingAlarm\n          -- and fallingAlarm.  If the eventTable\
    \ is triggered by a\n          -- condition specified elsewhere, the enterprise\
    \ and\n          -- specific trap fields must be specified for traps\n       \
    \   -- generated for that condition.\n          eventTable OBJECT-TYPE\n     \
    \         SYNTAX SEQUENCE OF EventEntry\n              ACCESS not-accessible\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"A list of events to be generated.\"\n              ::= { event 1 }\n     \
    \     eventEntry OBJECT-TYPE\n              SYNTAX EventEntry\n              ACCESS\
    \ not-accessible\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"A set of parameters that describe an event to be\n      \
    \            generated when certain conditions are met.  As an\n             \
    \     example, an instance of the eventLastTimeSent object\n                 \
    \ might be named eventLastTimeSent.6\"\n              INDEX { eventIndex }\n \
    \             ::= { eventTable 1 }\n          EventEntry ::= SEQUENCE {\n    \
    \          eventIndex          INTEGER (1..65535),\n              eventDescription\
    \    DisplayString (SIZE (0..127)),\n              eventType           INTEGER,\n\
    \              eventCommunity      OCTET STRING (SIZE (0..127)),\n           \
    \   eventLastTimeSent   TimeTicks,\n              eventOwner          OwnerString,\n\
    \              eventStatus         EntryStatus\n          }\n          eventIndex\
    \ OBJECT-TYPE\n              SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"An index that uniquely identifies an entry in the\n                  event\
    \ table.  Each such entry defines one event that\n                  is to be generated\
    \ when the appropriate conditions\n                  occur.\"\n              ::=\
    \ { eventEntry 1 }\n          eventDescription OBJECT-TYPE\n              SYNTAX\
    \ DisplayString (SIZE (0..127))\n              ACCESS read-write\n           \
    \   STATUS mandatory\n              DESCRIPTION\n                  \"A comment\
    \ describing this event entry.\"\n              ::= { eventEntry 2 }\n       \
    \   eventType OBJECT-TYPE\n              SYNTAX INTEGER {\n                  \
    \    none(1),\n                      log(2),\n                      snmp-trap(3),\
    \    -- send an SNMP trap\n                      log-and-trap(4)\n           \
    \   }\n              ACCESS read-write\n              STATUS mandatory\n     \
    \         DESCRIPTION\n                  \"The type of notification that the probe\
    \ will make\n                  about this event.  In the case of log, an entry\
    \ is\n                  made in the log table for each event.  In the case of\n\
    \                  snmp-trap, an SNMP trap is sent to one or more\n          \
    \        management stations.\"\n              ::= { eventEntry 3 }\n        \
    \  eventCommunity OBJECT-TYPE\n              SYNTAX OCTET STRING (SIZE (0..127))\n\
    \              ACCESS read-write\n              STATUS mandatory\n           \
    \   DESCRIPTION\n                  \"If an SNMP trap is to be sent, it will be\
    \ sent to\n                  the SNMP community specified by this octet string.\n\
    \                  In the future this table will be extended to include\n    \
    \              the party security mechanism.  This object shall be\n         \
    \         set to a string of length zero if it is intended that\n            \
    \      that mechanism be used to specify the destination of\n                \
    \  the trap.\"\n              ::= { eventEntry 4 }\n          eventLastTimeSent\
    \ OBJECT-TYPE\n              SYNTAX TimeTicks\n              ACCESS read-only\n\
    \              STATUS mandatory\n              DESCRIPTION\n                 \
    \ \"The value of sysUpTime at the time this event\n                  entry last\
    \ generated an event.  If this entry has\n                  not generated any\
    \ events, this value will be\n                  zero.\"\n              ::= { eventEntry\
    \ 5 }\n          eventOwner OBJECT-TYPE\n              SYNTAX OwnerString\n  \
    \            ACCESS read-write\n              STATUS mandatory\n             \
    \ DESCRIPTION\n                  \"The entity that configured this entry and is\n\
    \                  therefore using the resources assigned to it.\n           \
    \       If this object contains a string starting with\n                  'monitor'\
    \ and has associated entries in the log\n                  table, all connected\
    \ management stations should\n                  retrieve those log entries, as\
    \ they may have\n                  significance to all management stations connected\
    \ to\n                  this device\"\n              ::= { eventEntry 6 }\n  \
    \        eventStatus OBJECT-TYPE\n              SYNTAX EntryStatus\n         \
    \     ACCESS read-write\n              STATUS mandatory\n              DESCRIPTION\n\
    \                  \"The status of this event entry.\n                  If this\
    \ object is not equal to valid(1), all\n                  associated log entries\
    \ shall be deleted by the\n                  agent.\"\n              ::= { eventEntry\
    \ 7 }\n          --\n          logTable OBJECT-TYPE\n              SYNTAX SEQUENCE\
    \ OF LogEntry\n              ACCESS not-accessible\n              STATUS mandatory\n\
    \              DESCRIPTION\n                  \"A list of events that have been\
    \ logged.\"\n              ::= { event 2 }\n          logEntry OBJECT-TYPE\n \
    \             SYNTAX LogEntry\n              ACCESS not-accessible\n         \
    \     STATUS mandatory\n              DESCRIPTION\n                  \"A set of\
    \ data describing an event that has been\n                  logged.  For example,\
    \ an instance of the\n                  logDescription object might be named\n\
    \                  logDescription.6.47\"\n              INDEX { logEventIndex,\
    \ logIndex }\n              ::= { logTable 1 }\n          LogEntry ::= SEQUENCE\
    \ {\n              logEventIndex           INTEGER (1..65535),\n             \
    \ logIndex                INTEGER (1..2147483647),\n              logTime    \
    \             TimeTicks,\n              logDescription          DisplayString\
    \ (SIZE (0..255))\n          }\n          logEventIndex OBJECT-TYPE\n        \
    \      SYNTAX INTEGER (1..65535)\n              ACCESS read-only\n           \
    \   STATUS mandatory\n              DESCRIPTION\n                  \"The event\
    \ entry that generated this log\n                  entry.  The log identified\
    \ by a particular\n                  value of this index is associated with the\
    \ same\n                  eventEntry as identified by the same value\n       \
    \           of eventIndex.\"\n              ::= { logEntry 1 }\n          logIndex\
    \ OBJECT-TYPE\n              SYNTAX INTEGER (1..2147483647)\n              ACCESS\
    \ read-only\n              STATUS mandatory\n              DESCRIPTION\n     \
    \             \"An index that uniquely identifies an entry\n                 \
    \ in the log table amongst those generated by the\n                  same eventEntries.\
    \  These indexes are\n                  assigned beginning with 1 and increase\
    \ by one\n                  with each new log entry.  The association\n      \
    \            between values of logIndex and logEntries\n                  is fixed\
    \ for the lifetime of each logEntry.\n                  The agent may choose to\
    \ delete the oldest\n                  instances of logEntry as required because\
    \ of\n                  lack of memory.  It is an implementation-specific\n  \
    \                matter as to when this deletion may occur.\"\n              ::=\
    \ { logEntry 2 }\n          logTime OBJECT-TYPE\n              SYNTAX TimeTicks\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"The value of sysUpTime when this log entry\
    \ was\n                  created.\"\n              ::= { logEntry 3 }\n      \
    \    logDescription OBJECT-TYPE\n              SYNTAX DisplayString (SIZE (0..255))\n\
    \              ACCESS read-only\n              STATUS mandatory\n            \
    \  DESCRIPTION\n                  \"An implementation dependent description of\
    \ the\n                  event that activated this log entry.\"\n            \
    \  ::= { logEntry 4 }\n          --  These definitions use the TRAP-TYPE macro\
    \ as\n          --  defined in RFC 1215 [10]\n          --  Remote Network Monitoring\
    \ Traps\n          risingAlarm TRAP-TYPE\n              ENTERPRISE rmon\n    \
    \          VARIABLES { alarmIndex, alarmVariable, alarmSampleType,\n         \
    \                 alarmValue, alarmRisingThreshold }\n              DESCRIPTION\n\
    \                  \"The SNMP trap that is generated when an alarm\n         \
    \         entry crosses its rising threshold and generates\n                 \
    \ an event that is configured for sending SNMP\n                  traps.\"\n \
    \             ::= 1\n          fallingAlarm TRAP-TYPE\n              ENTERPRISE\
    \ rmon\n              VARIABLES { alarmIndex, alarmVariable, alarmSampleType,\n\
    \                          alarmValue, alarmFallingThreshold }\n             \
    \ DESCRIPTION\n                  \"The SNMP trap that is generated when an alarm\n\
    \                  entry crosses its falling threshold and generates\n       \
    \           an event that is configured for sending SNMP\n                  traps.\"\
    \n              ::= 2\n          END\n"
- title: 6.  Acknowledgments
  contents:
  - "6.  Acknowledgments\n   This document was produced by the IETF Remote Network\
    \ Monitoring\n   Working Group.\n"
- title: 7.  References
  contents:
  - "7.  References\n   [1] Cerf, V., \"IAB Recommendations for the Development of\
    \ Internet\n       Network Management Standards\", RFC 1052, NRI, April 1988.\n\
    \   [2] Cerf, V., \"Report of the Second Ad Hoc Network Management Review\n  \
    \     Group\", RFC 1109, NRI, August 1989.\n   [3] Rose M., and K. McCloghrie,\
    \ \"Structure and Identification of\n       Management Information for TCP/IP-based\
    \ internets\", STD 16, RFC\n       1155, Performance Systems International, Hughes\
    \ LAN Systems, May\n       1990.\n   [4] McCloghrie K., and M. Rose, Editors,\
    \ \"Management Information Base\n       for Network Management of TCP/IP-based\
    \ internets\", STD 17, RFC\n       1213, Performance Systems International, March\
    \ 1991.\n   [5] Case, J., Fedor, M., Schoffstall, M., and J. Davin, \"Simple\n\
    \       Network Management Protocol\", STD 15, RFC 1157, SNMP Research,\n    \
    \   Performance Systems International, Performance Systems\n       International,\
    \ MIT Laboratory for Computer Science, May 1990.\n   [6] McCloghrie, K., and F.\
    \ Kastenholz, \"Evolution of the Interfaces\n       Group of MIB-II\", RFC 1573,\
    \ Hughes LAN Systems, FTP Software,\n       January 1994.\n   [7] Information\
    \ processing systems - Open Systems Interconnection -\n       Specification of\
    \ Abstract Syntax Notation One (ASN.1),\n       International Organization for\
    \ Standardization.  International\n       Standard 8824, (December, 1987).\n \
    \  [8] Information processing systems - Open Systems Interconnection -\n     \
    \  Specification of Basic Encoding Rules for Abstract Notation One\n       (ASN.1),\
    \ International Organization for Standardization.\n       International Standard\
    \ 8825, (December, 1987).\n   [9] Rose, M., and K. McCloghrie, Editors, \"Concise\
    \ MIB Definitions\",\n       RFC 1212, Performance Systems International, Hughes\
    \ LAN Systems,\n       March 1991.\n  [10] Rose, M., Editor, \"A Convention for\
    \ Defining Traps for use with\n       the SNMP\", RFC 1215, Performance Systems\
    \ International, March\n       1991.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: 9.  Author's Address
  contents:
  - "9.  Author's Address\n   Steven Waldbusser\n   Carnegie Mellon University\n \
    \  5000 Forbes Ave.\n   Pittsburgh, PA 15213\n   EMail: waldbusser@cmu.edu\n"
- title: '10.  Appendix: Changes from RFC 1271'
  contents:
  - "10.  Appendix: Changes from RFC 1271\n   The RMON MIB has not been significantly\
    \ changed since RFC 1271 was\n   issued.\n   Two changes were made to object definitions:\n\
    \  1) A new status bit has been defined for the\n     captureBufferPacketStatus\
    \ object, indicating that the packet\n     order within the capture buffer may\
    \ not be identical to the\n     packet order as received off the wire.  This bit\
    \ may only be used\n     for packets transmitted by the probe.  Older NMS applications\
    \ can\n     safely ignore this status bit, which might be used by newer\n    \
    \ agents.\n  2) The packetMatch trap has been removed.  This trap was never\n\
    \     actually 'approved' and was not added to this document along with\n    \
    \ the risingAlarm and fallingAlarm traps. The packetMatch trap\n     could not\
    \ be throttled, which could cause disruption of normal\n     network traffic under\
    \ some circumstances. An NMS should configure\n     a risingAlarm threshold on\
    \ the appropriate channelMatches\n     instance if a trap is desired for a packetMatch\
    \ event. Note that\n     logging of packetMatch events is still supported--only\
    \ trap\n     generation for such events has been removed.\n   In addition, several\
    \ clarifications to individual object definitions\n   have been added to assist\
    \ agent and NMS implementors:\n     - global definition of \"good packets\" and\
    \ \"bad packets\"\n     - more detailed text governing conceptual row creation\
    \ and\n       modification\n     - instructions for probes relating to interface\
    \ changes and\n       disruptions\n     - clarification of some ethernet counter\
    \ definitions\n     - recommended formula for calculating network utilization\n\
    \     - clarification of channel and captureBuffer behavior for some\n       unusual\
    \ conditions\n     - examples of proper instance naming for each table\n"
