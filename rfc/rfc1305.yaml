- title: __initial_text__
  contents:
  - "                   Network Time Protocol (Version 3)\n               Specification,\
    \ Implementation and Analysis\nNote: This document consists of an approximate\
    \ rendering in ASCII of the\nPostScript document of the same name. It is provided\
    \ for convenience and\nfor use in searches, etc. However, most tables, figures,\
    \ equations and\ncaptions have not been rendered and the pagination and section\
    \ headings\nare not available.\nAbstract\nThis document describes the Network\
    \ Time Protocol (NTP), specifies its\nformal structure and summarizes information\
    \ useful for its\nimplementation. NTP provides the mechanisms to synchronize time\
    \ and\ncoordinate time distribution in a large, diverse internet operating at\n\
    rates from mundane to lightwave. It uses a returnable-time design in\nwhich a\
    \ distributed subnet of time servers operating in a self-\norganizing, hierarchical-master-slave\
    \ configuration synchronizes local\nclocks within the subnet and to national time\
    \ standards via wire or\nradio. The servers can also redistribute reference time\
    \ via local\nrouting algorithms and time daemons.\nStatus of this Memo\nThis RFC\
    \ specifies an IAB standards track protocol for the Internet\ncommunity and requests\
    \ discussion and suggestions for improvements.\nPlease refer to the current edition\
    \ of the <169>IAB Official Protocol\nStandards<170> for the standardization state\
    \ and status of this\nprotocol. Distribution of this memo is unlimited.\nKeywords:\
    \ network clock synchronization, standard time distribution,\nfault-tolerant architecture,\
    \ maximum-likelihood estimation, disciplined\noscillator, internet protocol, high-speed\
    \ networks, formal\nspecification.\nPreface\nThis document describes Version 3\
    \ of the Network Time Protocol (NTP). It\nsupersedes Version 2 of the protocol\
    \ described in RFC-1119 dated\nSeptember 1989. However, it neither changes the\
    \ protocol in any\nsignificant way nor obsoletes previous versions or existing\n\
    implementations. The main motivation for the new version is to refine\nthe analysis\
    \ and implementation models for new applications at much\nhigher network speeds\
    \ to the gigabit-per-second regime and to provide\nfor the enhanced stability,\
    \ accuracy and precision required at such\nspeeds. In particular, the sources\
    \ of time and frequency errors have\nbeen rigorously examined and error bounds\
    \ established in order to\nimprove performance, provide a model for correctness\
    \ assertions and\nindicate timekeeping quality to the user. The revision also\
    \ incorporates\ntwo new optional features, (1) an algorithm to combine the offsets\
    \ of a\nnumber of peer time servers in order to enhance accuracy and (2)\nimproved\
    \ local-clock algorithms which allow the poll intervals on all\nsynchronization\
    \ paths to be substantially increased in order to reduce\nnetwork overhead. An\
    \ overview of the changes, which are described in\ndetail in Appendix D, follows:\n\
    1.\nIn Version 3 The local-clock algorithm has been overhauled to improve\nstability\
    \ and accuracy. Appendix G presents a detailed mathematical\nmodel and design\
    \ example which has been refined with the aid of\nfeedback-control analysis and\
    \ extensive simulation using data collected\nover ordinary Internet paths. Section\
    \ 5 of RFC-1119 on the NTP local\nclock has been completely rewritten to describe\
    \ the new algorithm. Since\nthe new algorithm can result in message rates far\
    \ below the old ones, it\nis highly recommended that they be used in new implementations.\
    \ Note\nthat use of the new algorithm does not affect interoperability with\n\
    previous versions or existing implementations.\n2.\nIn Version 3 a new algorithm\
    \ to combine the offsets of a number of peer\ntime servers is presented in Appendix\
    \ F. This algorithm is modelled on\nthose used by national standards laboratories\
    \ to combine the weighted\noffsets from a number of standard clocks to construct\
    \ a synthetic\nlaboratory timescale more accurate than that of any clock separately.\
    \ It\ncan be used in an NTP implementation to improve accuracy and stability\n\
    and reduce errors due to asymmetric paths in the Internet. The new\nalgorithm\
    \ has been simulated using data collected over ordinary Internet\npaths and, along\
    \ with the new local-clock algorithm, implemented and\ntested in the Fuzzball\
    \ time servers now running in the Internet. Note\nthat use of the new algorithm\
    \ does not affect interoperability with\nprevious versions or existing implementations.\n\
    3.\nSeveral inconsistencies and minor errors in previous versions have been\n\
    corrected in Version 3. The description of the procedures has been\nrewritten\
    \ in pseudo-code augmented by English commentary for clarity and\nto avoid ambiguity.\
    \ Appendix I has been added to illustrate C-language\nimplementations of the various\
    \ filtering and selection algorithms\nsuggested for NTP. Additional information\
    \ is included in Section 5 and\nin Appendix E, which includes the tutorial material\
    \ formerly included in\nSection 2 of RFC-1119, as well as much new material clarifying\
    \ the\ninterpretation of timescales and leap seconds.\n4.\nMinor changes have\
    \ been made in the Version-3 local-clock algorithms to\navoid problems observed\
    \ when leap seconds are introduced in the UTC\ntimescale and also to support an\
    \ auxiliary precision oscillator, such as\na cesium clock or timing receiver,\
    \ as a precision timebase. In addition,\nchanges were made to some procedures\
    \ described in Section 3 and in the\nclock-filter and clock-selection procedures\
    \ described in Section 4.\nWhile these changes were made to correct minor bugs\
    \ found as the result\nof experience and are recommended for new implementations,\
    \ they do not\naffect interoperability with previous versions or existing\nimplementations\
    \ in other than minor ways (at least until the next leap\nsecond).\n5.\nIn Version\
    \ 3 changes were made to the way delay, offset and dispersion\nare defined, calculated\
    \ and processed in order to reliably bound the\nerrors inherent in the time-transfer\
    \ procedures. In particular, the\nerror accumulations were moved from the delay\
    \ computation to the\ndispersion computation and both included in the clock filter\
    \ and\nselection procedures. The clock-selection procedure was modified to\nremove\
    \ the first of the two sorting/discarding steps and replace with an\nalgorithm\
    \ first proposed by Marzullo and later incorporated in the\nDigital Time Service.\
    \ These changes do not significantly affect the\nordinary operation of or compatibility\
    \ with various versions of NTP, but\nthey do provide the basis for formal statements\
    \ of correctness as\ndescribed in Appendix H.\nTable of Contents\n1.       Introduction\
    \   1\n1.1.     Related Technology     2\n2.       System Architecture    4\n\
    2.1.     Implementation Model   6\n2.2.     Network Configurations 7\n3.     \
    \  Network Time Protocol  8\n3.1.     Data Formats   8\n3.2.     State Variables\
    \ and Parameters 9\n3.2.1.   Common Variables       9\n3.2.2.   System Variables\
    \       12\n3.2.3.   Peer Variables 12\n3.2.4.   Packet Variables       14\n3.2.5.\
    \   Clock-Filter Variables 14\n3.2.6.   Authentication Variables       15\n3.2.7.\
    \   Parameters     15\n3.3.     Modes of Operation     17\n3.4.     Event Processing\
    \       19\n3.4.1.   Notation Conventions   19\n3.4.2.   Transmit Procedure  \
    \   20\n3.4.3.   Receive Procedure      22\n3.4.4.   Packet Procedure       24\n\
    3.4.5.   Clock-Update Procedure 27\n3.4.6.   Primary-Clock Procedure        28\n\
    3.4.7.   Initialization Procedures      28\n3.4.7.1.         Initialization Procedure\
    \       29\n3.4.7.2.         Initialization-Instantiation Procedure 29\n3.4.7.3.\
    \         Receive-Instantiation Procedure        30\n3.4.7.4.         Primary\
    \ Clock-Instantiation Procedure  31\n3.4.8.   Clear Procedure        31\n3.4.9.\
    \   Poll-Update Procedure  32\n3.5.     Synchronization Distance Procedure   \
    \  32\n3.6.     Access Control Issues  33\n4.       Filtering and Selection Algorithms\
    \     34\n4.1.     Clock-Filter Procedure 35\n4.2.     Clock-Selection Procedure\
    \      36\n4.2.1.   Intersection Algorithm 36\n5.       Local Clocks   40\n5.1.\
    \     Fuzzball Implementation        41\n5.2.     Gradual Phase Adjustments  \
    \    42\n5.3.     Step Phase Adjustments 43\n5.4.     Implementation Issues  44\n\
    6.       Acknowledgments        45\n7.       References     46\nA.       Appendix\
    \ A. NTP Data Format - Version 3        50\nB.       Appendix B. NTP Control Messages\
    \       53\nB.1.     NTP Control Message Format     54\nB.2.     Status Words\
    \   56\nB.2.1.   System Status Word     56\nB.2.2.   Peer Status Word       57\n\
    B.2.3.   Clock Status Word      58\nB.2.4.   Error Status Word      58\nB.3. \
    \    Commands       59\nC.       Appendix C. Authentication Issues      61\nC.1.\
    \     NTP Authentication Mechanism   62\nC.2.     NTP Authentication Procedures\
    \  63\nC.2.1.   Encrypt Procedure      63\n4.2.2.   Clustering Algorithm   38\n\
    C.2.2.   Decrypt Procedure      64\nC.2.3.   Control-Message Procedures     65\n\
    D.       Appendix D. Differences from Previous Versions.        66\nE.       Appendix\
    \ E. The NTP Timescale and its Chronometry      70\nE.1.     Introduction   70\n\
    E.2.     Primary Frequency and Time Standards   70\nE.3.     Time and Frequency\
    \ Dissemination       72\nE.4.     Calendar Systems       74\nE.5.     The Modified\
    \ Julian Day System 75\nE.6.     Determination of Frequency     76\nE.7.     Determination\
    \ of Time and Leap Seconds 76\nE.8.     The NTP Timescale and Reckoning with UTC\
    \       78\nF.       Appendix F. The NTP Clock-Combining Algorithm  80\nF.1. \
    \    Introduction   80\nF.2.     Determining Time and Frequency 80\nF.3.     Clock\
    \ Modelling        81\nF.4.     Development of a Composite Timescale   81\nF.5.\
    \     Application to NTP     84\nF.6.     Clock-Combining Procedure      84\n\
    G.       Appendix G. Computer Clock Modelling and Analysis      86\nG.1.     Computer\
    \ Clock Models  86\nG.1.1.   The Fuzzball Clock Model       88\nG.1.2.   The Unix\
    \ Clock Model   89\nG.2.     Mathematical Model of the NTP Logical Clock    91\n\
    G.3.     Parameter Management   93\nG.4.     Adjusting VCO Gain (<$Ebold alpha>)\
    \    94\nG.5.     Adjusting PLL Bandwidth (<$Ebold tau>) 94\nG.6.     The NTP\
    \ Clock Model    95\nH.       Appendix H. Analysis of Errors and Correctness Principles\n\
    98\nH.1.     Introduction   98\nH.2.     Timestamp Errors       98\nH.3.     Measurement\
    \ Errors     100\nH.4.     Network Errors 101\nH.5.     Inherited Errors     \
    \  102\nH.6.     Correctness Principles 104\nI.       Appendix I. Selected C-Language\
    \ Program Listings       107\nI.1.     Common Definitions and Variables      \
    \ 107\nI.2.     Clock<196>Filter Algorithm     108\nI.3.     Interval Intersection\
    \ Algorithm        109\nI.4.     Clock<196>Selection Algorithm  110\nI.5.    \
    \ Clock<196>Combining Procedure  111\nI.6.     Subroutine to Compute Synchronization\
    \ Distance 112\nList of Figures\nFigure 1. Implementation Model  6\nFigure 2.\
    \ Calculating Delay and Offset  25\nFigure 3. Clock Registers       39\nFigure\
    \ 4. NTP Message Header    50\nFigure 5. NTP Control Message Header    54\nFigure\
    \ 6. Status Word Formats   55\nFigure 7. Authenticator Format  63\nFigure 8. Comparison\
    \ of UTC and NTP Timescales at Leap  79\nFigure 9. Network Time Protocol 80\n\
    Figure 10. Hardware Clock Models        86\nFigure 11. Clock Adjustment Process\
    \     90\nFigure 12. NTP Phase-Lock Loop (PLL) Model      91\nFigure 13. Timing\
    \ Intervals     96\nFigure 14. Measuring Delay and Offset   100\nFigure 15. Error\
    \ Accumulations  103\nFigure 16. Confidence Intervals and Intersections      \
    \ 105\nList of Tables\nTable 1. System Variables       12\nTable 2. Peer Variables\
    \ 13\nTable 3. Packet Variables       14\nTable 4. Parameters     16\nTable 5.\
    \ Modes and Actions      22\nTable 6. Clock Parameters       40\nTable 7. Characteristics\
    \ of Standard Oscillators        71\nTable 8. Table of Leap-Second Insertions\
    \        77\nTable 9. Notation Used in PLL Analysis  91\nTable 10. PLL Parameters\
    \        91\nTable 11. Notation Used in PLL Analysis 95\nTable 12. Notation Used\
    \ in Error Analysis       98\nIntroduction\nThis document constitutes a formal\
    \ specification of the Network Time\nProtocol (NTP) Version 3, which is used to\
    \ synchronize timekeeping among\na set of distributed time servers and clients.\
    \ It defines the\narchitectures, algorithms, entities and protocols used by NTP\
    \ and is\nintended primarily for implementors. A companion document [MIL91a]\n\
    summarizes the requirements, analytical models, algorithmic analysis and\nperformance\
    \ under typical Internet conditions. Another document [MIL91b]\ndescribes the\
    \ NTP timescale and its relationship to other standard\ntimescales now in use.\
    \ NTP was first described in RFC-958 [MIL85c], but\nhas since evolved in significant\
    \ ways, culminating in the most recent\nNTP Version 2 described in RFC-1119 [MIL89].\
    \ It is built on the Internet\nProtocol (IP) [DAR81a] and User Datagram Protocol\
    \ (UDP) [POS80], which\nprovide a connectionless transport mechanism; however,\
    \ it is readily\nadaptable to other protocol suites. NTP is evolved from the Time\n\
    Protocol [POS83b] and the ICMP Timestamp message [DAR81b], but is\nspecifically\
    \ designed to maintain accuracy and robustness, even when\nused over typical Internet\
    \ paths involving multiple gateways, highly\ndispersive delays and unreliable\
    \ nets.\nThe service environment consists of the implementation model and service\n\
    model described in Section 2. The implementation model is based on a\nmultiple-process\
    \ operating system architecture, although other\narchitectures could be used as\
    \ well. The service model is based on a\nreturnable-time design which depends\
    \ only on measured clock offsets, but\ndoes not require reliable message delivery.\
    \ The synchronization subnet\nuses a self-organizing, hierarchical-master-slave\
    \ configuration, with\nsynchronization paths determined by a minimum-weight spanning\
    \ tree.\nWhile multiple masters (primary servers) may exist, there is no\nrequirement\
    \ for an election protocol.\nNTP itself is described in Section 3. It provides\
    \ the protocol\nmechanisms to synchronize time in principle to precisions in the\
    \ order\nof nanoseconds while preserving a non-ambiguous date well into the next\n\
    century. The protocol includes provisions to specify the characteristics\nand\
    \ estimate the error of the local clock and the time server to which\nit may be\
    \ synchronized. It also includes provisions for operation with a\nnumber of mutually\
    \ suspicious, hierarchically distributed primary\nreference sources such as radio-synchronized\
    \ clocks.\nSection 4 describes algorithms useful for deglitching and smoothing\n\
    clock-offset samples collected on a continuous basis. These algorithms\nevolved\
    \ from those suggested in [MIL85a], were refined as the results of\nexperiments\
    \ described in [MIL85b] and further evolved under typical\noperating conditions\
    \ over the last three years. In addition, as the\nresult of experience in operating\
    \ multiple-server subnets including\nradio clocks at several sites in the U.S.\
    \ and with clients in the U.S.\nand Europe, reliable algorithms for selecting\
    \ good clocks from a\npopulation possibly including broken ones have been developed\
    \ [DEC89],\n[MIL91a] and are described in Section 4.\nThe accuracies achievable\
    \ by NTP depend strongly on the precision of the\nlocal-clock hardware and stringent\
    \ control of device and process\nlatencies. Provisions must be included to adjust\
    \ the software logical-\nclock time and frequency in response to corrections produced\
    \ by NTP.\nSection 5 describes a local-clock design evolved from the Fuzzball\n\
    implementation described in [MIL83b] and [MIL88b]. This design includes\noffset-slewing,\
    \ frequency compensation and deglitching mechanisms\ncapable of accuracies in\
    \ the order of a millisecond, even after extended\nperiods when synchronization\
    \ to primary reference sources has been lost.\nDetails specific to NTP packet\
    \ formats used with the Internet Protocol\n(IP) and User Datagram Protocol (UDP)\
    \ are presented in Appendix A, while\ndetails of a suggested auxiliary NTP Control\
    \ Message, which may be used\nwhen comprehensive network-monitoring facilities\
    \ are not available, are\npresented in Appendix B. Appendix C contains specification\
    \ and\nimplementation details of an optional authentication mechanism which can\n\
    be used to control access and prevent unauthorized data modification,\nwhile Appendix\
    \ D contains a listing of differences between Version 3 of\nNTP and previous versions.\
    \ Appendix E expands on issues involved with\nprecision timescales and calendar\
    \ dating peculiar to computer networks\nand NTP. Appendix F describes an optional\
    \ algorithm to improve accuracy\nby combining the time offsets of a number of\
    \ clocks. Appendix G presents\na detailed mathematical model and analysis of the\
    \ NTP local-clock\nalgorithms. Appendix H analyzes the sources and propagation\
    \ of errors\nand presents correctness principles relating to the time-transfer\n\
    service. Appendix I illustrates C-language code segments for the clock-\nfilter,\
    \ clock-selection and related algorithms described in Section 4.\nOther mechanisms\
    \ have been specified in the Internet protocol suite to\nrecord and transmit the\
    \ time at which an event takes place, including\nthe Daytime protocol [POS83a],\
    \ Time Protocol [POS83b], ICMP Timestamp\nmessage [DAR81b] and IP Timestamp option\
    \ [SU81]. Experimental results on\nmeasured clock offsets and roundtrip delays\
    \ in the Internet are\ndiscussed in [MIL83a], [MIL85b], [COL88] and [MIL88a].\
    \ Other\nsynchronization algorithms are discussed in [LAM78], [GUS84], [HAL84],\n\
    [LUN84], [LAM85], [MAR85], [MIL85a], [MIL85b], [MIL85c], [GUS85b],\n[SCH86], [TRI86],\
    \ [RIC88], [MIL88a], [DEC89] and [MIL91a], while\nprotocols based on them are\
    \ described in [MIL81a], [MIL81b], [MIL83b],\n[GUS85a], [MIL85c], [TRI86], [MIL88a],\
    \ [DEC89] and [MIL91a]. NTP uses\ntechniques evolved from them and both linear-systems\
    \ and agreement\nmethodologies. Linear methods for digital telephone network\n\
    synchronization are summarized in [LIN80], while agreement methods for\nclock\
    \ synchronization are summarized in [LAM85].\nThe Digital Time Service (DTS) [DEC89]\
    \ has many of the same service\nobjectives as NTP. The DTS design places heavy\
    \ emphasis on configuration\nmanagement and correctness principles when operated\
    \ in a managed LAN or\nLAN-cluster environment, while NTP places heavy emphasis\
    \ on the accuracy\nand stability of the service operated in an unmanaged, global-internet\n\
    environment. In DTS a synchronization subnet consists of clerks,\nservers, couriers\
    \ and time providers. With respect to the NTP\nnomenclature, a time provider is\
    \ a primary reference source, a courier\nis a secondary server intended to import\
    \ time from one or more distant\nprimary servers for local redistribution and\
    \ a server is intended to\nprovide time for possibly many end nodes or clerks.\
    \ Unlike NTP, DTS does\nnot need or use mode or stratum information in clock selection\
    \ and does\nnot include provisions to filter timing noise, select the most accurate\n\
    from a set of presumed correct clocks or compensate for inherent\nfrequency errors.\n\
    In fact, the latest revisions in NTP have adopted certain features of\nDTS in\
    \ order to support correctness principles. These include mechanisms\nto bound\
    \ the maximum errors inherent in the time-transfer procedures and\nthe use of\
    \ a provably correct (subject to stated assumptions) mechanism\nto reject inappropriate\
    \ peers in the clock-selection procedures. These\nfeatures are described in Section\
    \ 4 and Appendix H of this document.\nThe Fuzzball routing protocol [MIL83b],\
    \ sometimes called Hellospeak,\nincorporates time synchronization directly into\
    \ the routing-protocol\ndesign. One or more processes synchronize to an external\
    \ reference\nsource, such as a radio clock or NTP daemon, and the routing algorithm\n\
    constructs a minimum-weight spanning tree rooted on these processes. The\nclock\
    \ offsets are then distributed along the arcs of the spanning tree\nto all processes\
    \ in the system and the various process clocks corrected\nusing the procedure\
    \ described in Section 5 of this document. While it\ncan be seen that the design\
    \ of Hellospeak strongly influenced the design\nof NTP, Hellospeak itself is not\
    \ an Internet protocol and is unsuited\nfor use outside its local-net environment.\n\
    The Unix 4.3bsd time daemon timed [GUS85a] uses a single master-time\ndaemon to\
    \ measure offsets of a number of slave hosts and send periodic\ncorrections to\
    \ them. In this model the master is determined using an\nelection algorithm [GUS85b]\
    \ designed to avoid situations where either no\nmaster is elected or more than\
    \ one master is elected. The election\nprocess requires a broadcast capability,\
    \ which is not a ubiquitous\nfeature of the Internet. While this model has been\
    \ extended to support\nhierarchical configurations in which a slave on one network\
    \ serves as a\nmaster on the other [TRI86], the model requires handcrafted\nconfiguration\
    \ tables in order to establish the hierarchy and avoid\nloops. In addition to\
    \ the burdensome, but presumably infrequent,\noverheads of the election process,\
    \ the offset measurement/correction\nprocess requires twice as many messages as\
    \ NTP per update.\nA scheme with features similar to NTP is described in [KOP87].\
    \ This\nscheme is intended for multi-server LANs where each of a set of possibly\n\
    many time servers determines its local-time offset relative to each of\nthe other\
    \ servers in the set using periodic timestamped messages, then\ndetermines the\
    \ local-clock correction using the Fault-Tolerant Average\n(FTA) algorithm of\
    \ [LUN84]. The FTA algorithm, which is useful where up\nto k servers may be faulty,\
    \ sorts the offsets, discards the k highest\nand lowest ones and averages the\
    \ rest. The scheme, as described in\n[SCH86], is most suitable to LAN environments\
    \ which support broadcast\nand would result in unacceptable overhead in an internet\
    \ environment. In\naddition, for reasons given in Section 4 of this paper, the\
    \ statistical\nproperties of the FTA algorithm are not likely to be optimal in\
    \ an\ninternet environment with highly dispersive delays.\nA good deal of research\
    \ has gone into the issue of maintaining accurate\ntime in a community where some\
    \ clocks cannot be trusted. A truechimer is\na clock that maintains timekeeping\
    \ accuracy to a previously published\n(and trusted) standard, while a falseticker\
    \ is a clock that does not.\nDetermining whether a particular clock is a truechimer\
    \ or falseticker is\nan interesting abstract problem which can be attacked using\
    \ agreement\nmethods summarized in [LAM85] and [SRI87].\nA convergence function\
    \ operates upon the offsets between the clocks in a\nsystem to increase the accuracy\
    \ by reducing or eliminating errors caused\nby falsetickers. There are two classes\
    \ of convergence functions, those\ninvolving interactive-convergence algorithms\
    \ and those involving\ninteractive-consistency algorithms. Interactive-convergence\
    \ algorithms\nuse statistical clustering techniques such as the fault-tolerant\
    \ average\nalgorithm of [HAL84], the CNV algorithm of [LUN84], the majority-subset\n\
    algorithm of [MIL85a], the non-Byzantine algorithm of [RIC88], the\negocentric\
    \ algorithm of [SCH86], the intersection algorithm of [MAR85]\nand [DEC89] and\
    \ the algorithms in Section 4 of this document.\nInteractive-consistency algorithms\
    \ are designed to detect faulty clock\nprocesses which might indicate grossly\
    \ inconsistent offsets in\nsuccessive readings or to different readers. These\
    \ algorithms use an\nagreement protocol involving successive rounds of readings,\
    \ possibly\nrelayed and possibly augmented by digital signatures. Examples include\n\
    the fireworks algorithm of [HAL84] and the optimum algorithm of [SRI87].\nHowever,\
    \ these algorithms require large numbers of messages, especially\nwhen large numbers\
    \ of clocks are involved, and are designed to detect\nfaults that have rarely\
    \ been found in the Internet experience. For these\nreasons they are not considered\
    \ further in this document.\nIn practice it is not possible to determine the truechimers\
    \ from the\nfalsetickers on other than a statistical basis, especially with\n\
    hierarchical configurations and a statistically noisy Internet. While it\nis possible\
    \ to bound the maximum errors in the time-transfer procedures,\nassuming sufficiently\
    \ generous tolerances are adopted for the hardware\ncomponents, this generally\
    \ results in rather poor accuracies and\nstabilities. The approach taken in the\
    \ NTP design and its predecessors\ninvolves mutually coupled oscillators and maximum-likelihood\
    \ estimation\nand clock-selection procedures, together with a design that allows\n\
    provable assertions on error bounds to be made relative to stated\nassumptions\
    \ on the correctness of the primary reference sources. From\nthe analytical point\
    \ of view, the system of distributed NTP peers\noperates as a set of coupled phase-locked\
    \ oscillators, with the update\nalgorithm functioning as a phase detector and\
    \ the local clock as a\ndisciplined oscillator, but with deterministic error bounds\
    \ calculated\nat each step in the time-transfer process.\nThe particular choice\
    \ of offset measurement and computation procedure\ndescribed in Section 3 is a\
    \ variant of the returnable-time system used\nin some digital telephone networks\
    \ [LIN80]. The clock filter and\nselection algorithms are designed so that the\
    \ clock synchronization\nsubnet self-organizes into a hierarchical-master-slave\
    \ configuration\n[MIT80]. With respect to timekeeping accuracy and stability,\
    \ the\nsimilarity of NTP to digital telephone systems is not accidental, since\n\
    systems like this have been studied extensively [LIN80], [BRA80]. What\nmakes\
    \ the NTP model unique is the adaptive configuration, polling,\nfiltering, selection\
    \ and correctness mechanisms which tailor the\ndynamics of the system to fit the\
    \ ubiquitous Internet environment.\nSystem Architecture\nIn the NTP model a number\
    \ of primary reference sources, synchronized by\nwire or radio to national standards,\
    \ are connected to widely accessible\nresources, such as backbone gateways, and\
    \ operated as primary time\nservers. The purpose of NTP is to convey timekeeping\
    \ information from\nthese servers to other time servers via the Internet and also\
    \ to cross-\ncheck clocks and mitigate errors due to equipment or propagation\n\
    failures. Some number of local-net hosts or gateways, acting as\nsecondary time\
    \ servers, run NTP with one or more of the primary servers.\nIn order to reduce\
    \ the protocol overhead, the secondary servers\ndistribute time via NTP to the\
    \ remaining local-net hosts. In the\ninterest of reliability, selected hosts can\
    \ be equipped with less\naccurate but less expensive radio clocks and used for\
    \ backup in case of\nfailure of the primary and/or secondary servers or communication\
    \ paths\nbetween them.\nThroughout this document a standard nomenclature has been\
    \ adopted: the\nstability of a clock is how well it can maintain a constant frequency,\n\
    the accuracy is how well its frequency and time compare with national\nstandards\
    \ and the precision is how precisely these quantities can be\nmaintained within\
    \ a particular timekeeping system. Unless indicated\notherwise, the offset of\
    \ two clocks is the time difference between them,\nwhile the skew is the frequency\
    \ difference (first derivative of offset\nwith time) between them. Real clocks\
    \ exhibit some variation in skew\n(second derivative of offset with time), which\
    \ is called drift; however,\nin this version of the specification the drift is\
    \ assumed zero.\nNTP is designed to produce three products: clock offset, roundtrip\
    \ delay\nand dispersion, all of which are relative to a selected reference clock.\n\
    Clock offset represents the amount to adjust the local clock to bring it\ninto\
    \ correspondence with the reference clock. Roundtrip delay provides\nthe capability\
    \ to launch a message to arrive at the reference clock at a\nspecified time. Dispersion\
    \ represents the maximum error of the local\nclock relative to the reference clock.\
    \ Since most host time servers will\nsynchronize via another peer time server,\
    \ there are two components in\neach of these three products, those determined\
    \ by the peer relative to\nthe primary reference source of standard time and those\
    \ measured by the\nhost relative to the peer. Each of these components are maintained\n\
    separately in the protocol in order to facilitate error control and\nmanagement\
    \ of the subnet itself. They provide not only precision\nmeasurements of offset\
    \ and delay, but also definitive maximum error\nbounds, so that the user interface\
    \ can determine not only the time, but\nthe quality of the time as well.\nThere\
    \ is no provision for peer discovery or virtual-circuit management\nin NTP. Data\
    \ integrity is provided by the IP and UDP checksums. No flow-\ncontrol or retransmission\
    \ facilities are provided or necessary.\nDuplicate detection is inherent in the\
    \ processing algorithms. The\nservice can operate in a symmetric mode, in which\
    \ servers and clients\nare indistinguishable, yet maintain a small amount of state\
    \ information,\nor in client/server mode, in which servers need maintain no state\
    \ other\nthan that contained in the client request. A lightweight association-\n\
    management capability, including dynamic reachability and variable poll-\nrate\
    \ mechanisms, is included only to manage the state information and\nreduce resource\
    \ requirements. Since only a single NTP message format is\nused, the protocol\
    \ is easily implemented and can be used in a variety of\nsolicited or unsolicited\
    \ polling mechanisms.\nIt should be recognized that clock synchronization requires\
    \ by its\nnature long periods and multiple comparisons in order to maintain\n\
    accurate timekeeping. While only a few measurements are usually adequate\nto reliably\
    \ determine local time to within a second or so, periods of\nmany hours and dozens\
    \ of measurements are required to resolve oscillator\nskew and maintain local\
    \ time to the order of a millisecond. Thus, the\naccuracy achieved is directly\
    \ dependent on the time taken to achieve it.\nFortunately, the frequency of measurements\
    \ can be quite low and almost\nalways non-intrusive to normal net operations.\n\
    Implementation Model\nIn what may be the most common client/server model a client\
    \ sends an NTP\nmessage to one or more servers and processes the replies as received.\n\
    The server interchanges addresses and ports, overwrites certain fields\nin the\
    \ message, recalculates the checksum and returns the message\nimmediately. Information\
    \ included in the NTP message allows the client\nto determine the server time\
    \ with respect to local time and adjust the\nlocal clock accordingly. In addition,\
    \ the message includes information\nto calculate the expected timekeeping accuracy\
    \ and reliability, as well\nas select the best from possibly several servers.\n\
    While the client/server model may suffice for use on local nets\ninvolving a public\
    \ server and perhaps many workstation clients, the full\ngenerality of NTP requires\
    \ distributed participation of a number of\nclient/servers or peers arranged in\
    \ a dynamically reconfigurable,\nhierarchically distributed configuration. It\
    \ also requires sophisticated\nalgorithms for association management, data manipulation\
    \ and local-clock\ncontrol. Throughout the remainder of this document the term\
    \ host refers\nto an instantiation of the protocol on a local processor, while\
    \ the term\npeer refers to the instantiation of the protocol on a remote processor\n\
    connected by a network path.\nFigure 1<$&fig1> shows an implementation model for\
    \ a host including\nthree processes sharing a partitioned data base, with a partition\n\
    dedicated to each peer, and interconnected by a message-passing system.\nThe transmit\
    \ process, driven by independent timers for each peer,\ncollects information in\
    \ the data base and sends NTP messages to the\npeers. Each message contains the\
    \ local timestamp when the message is\nsent, together with previously received\
    \ timestamps and other information\nnecessary to determine the hierarchy and manage\
    \ the association. The\nmessage transmission rate is determined by the accuracy\
    \ required of the\nlocal clock, as well as the accuracies of its peers.\nThe receive\
    \ process receives NTP messages and perhaps messages in other\nprotocols, as well\
    \ as information from directly connected radio clocks.\nWhen an NTP message is\
    \ received, the offset between the peer clock and\nthe local clock is computed\
    \ and incorporated into the data base along\nwith other information useful for\
    \ error determination and peer\nselection. A filtering algorithm described in\
    \ Section 4 improves the\naccuracy by discarding inferior data.\nThe update procedure\
    \ is initiated upon receipt of a message and at other\ntimes. It processes the\
    \ offset data from each peer and selects the best\none using the algorithms of\
    \ Section 4. This may involve many\nobservations of a few peers or a few observations\
    \ of many peers,\ndepending on the accuracies required.\nThe local-clock process\
    \ operates upon the offset data produced by the\nupdate procedure and adjusts\
    \ the phase and frequency of the local clock\nusing the mechanisms described in\
    \ Section 5. This may result in either a\nstep-change or a gradual phase adjustment\
    \ of the local clock to reduce\nthe offset to zero. The local clock provides a\
    \ stable source of time\ninformation to other users of the system and for subsequent\
    \ reference by\nNTP itself.\nNetwork Configurations\nThe synchronization subnet\
    \ is a connected network of primary and\nsecondary time servers, clients and interconnecting\
    \ transmission paths.\nA primary time server is directly synchronized to a primary\
    \ reference\nsource, usually a radio clock. A secondary time server derives\n\
    synchronization, possibly via other secondary servers, from a primary\nserver\
    \ over network paths possibly shared with other services. Under\nnormal circumstances\
    \ it is intended that the synchronization subnet of\nprimary and secondary servers\
    \ assumes a hierarchical-master-slave\nconfiguration with the primary servers\
    \ at the root and secondary servers\nof decreasing accuracy at successive levels\
    \ toward the leaves.\nFollowing conventions established by the telephone industry\
    \ [BEL86], the\naccuracy of each server is defined by a number called the stratum,\
    \ with\nthe topmost level (primary servers) assigned as one and each level\ndownwards\
    \ (secondary servers) in the hierarchy assigned as one greater\nthan the preceding\
    \ level. With current technology and available radio\nclocks, single-sample accuracies\
    \ in the order of a millisecond can be\nachieved at the network interface of a\
    \ primary server. Accuracies of\nthis order require special care in the design\
    \ and implementation of the\noperating system and the local-clock mechanism, such\
    \ as described in\nSection 5.\nAs the stratum increases from one, the single-sample\
    \ accuracies\nachievable will degrade depending on the network paths and local-clock\n\
    stabilities. In order to avoid the tedious calculations [BRA80]\nnecessary to\
    \ estimate errors in each specific configuration, it is\nuseful to assume the\
    \ mean measurement errors accumulate approximately in\nproportion to the measured\
    \ delay and dispersion relative to the root of\nthe synchronization subnet. Appendix\
    \ H contains an analysis of errors,\nincluding a derivation of maximum error as\
    \ a function of delay and\ndispersion, where the latter quantity depends on the\
    \ precision of the\ntimekeeping system, frequency tolerance of the local clock\
    \ and various\nresiduals. Assuming the primary servers are synchronized to standard\n\
    time within known accuracies, this provides a reliable, determistic\nspecification\
    \ on timekeeping accuracies throughout the synchronization\nsubnet.\nAgain drawing\
    \ from the experience of the telephone industry, which\nlearned such lessons at\
    \ considerable cost [ABA89], the synchronization\nsubnet topology should be organized\
    \ to produce the highest accuracy, but\nmust never be allowed to form a loop.\
    \ An additional factor is that each\nincrement in stratum involves a potentially\
    \ unreliable time server which\nintroduces additional measurement errors. The\
    \ selection algorithm used\nin NTP uses a variant of the Bellman-Ford distributed\
    \ routing algorithm\n[37] to compute the minimum-weight spanning trees rooted\
    \ on the primary\nservers. The distance metric used by the algorithm consists\
    \ of the\n(scaled) stratum plus the synchronization distance, which itself\nconsists\
    \ of the dispersion plus one-half the absolute delay. Thus, the\nsynchronization\
    \ path will always take the minimum number of servers to\nthe root, with ties\
    \ resolved on the basis of maximum error.\nAs a result of this design, the subnet\
    \ reconfigures automatically in a\nhierarchical-master-slave configuration to\
    \ produce the most accurate and\nreliable time, even when one or more primary\
    \ or secondary servers or the\nnetwork paths between them fail. This includes\
    \ the case where all normal\nprimary servers (e.g., highly accurate WWVB radio\
    \ clock operating at the\nlowest synchronization distances) on a possibly partitioned\
    \ subnet fail,\nbut one or more backup primary servers (e.g., less accurate WWV\
    \ radio\nclock operating at higher synchronization distances) continue operation.\n\
    However, should all primary servers throughout the subnet fail, the\nremaining\
    \ secondary servers will synchronize among themselves while\ndistances ratchet\
    \ upwards to a preselected maximum <169>infinity<170>\ndue to the well-known properties\
    \ of the Bellman-Ford algorithm. Upon\nreaching the maximum on all paths, a server\
    \ will drop off the subnet and\nfree-run using its last determined time and frequency.\
    \ Since these\ncomputations are expected to be very precise, especially in frequency,\n\
    even extended outage periods can result in timekeeping errors not\ngreater than\
    \ a few milliseconds per day with appropriately stabilized\noscillators (see Section\
    \ 5).\nIn the case of multiple primary servers, the spanning-tree computation\n\
    will usually select the server at minimum synchronization distance.\nHowever,\
    \ when these servers are at approximately the same distance, the\ncomputation\
    \ may result in random selections among them as the result of\nnormal dispersive\
    \ delays. Ordinarily, this does not degrade accuracy as\nlong as any discrepancy\
    \ between the primary servers is small compared to\nthe synchronization distance.\
    \ If not, the filter and selection\nalgorithms will select the best of the available\
    \ servers and cast out\noutlyers as intended.\nNetwork Time Protocol\nThis section\
    \ consists of a formal definition of the Network Time\nProtocol, including its\
    \ data formats, entities, state variables, events\nand event-processing procedures.\
    \ The specification is based on the\nimplementation model illustrated in Figure\
    \ 1, but it is not intended\nthat this model is the only one upon which a specification\
    \ can be based.\nIn particular, the specification is intended to illustrate and\
    \ clarify\nthe intrinsic operations of NTP, as well as to serve as a foundation\
    \ for\na more rigorous, comprehensive and verifiable specification.\nData Formats\n\
    All mathematical operations expressed or implied herein are in two's-\ncomplement,\
    \ fixed-point arithmetic. Data are specified as integer or\nfixed-point quantities,\
    \ with bits numbered in big-endian fashion from\nzero starting at the left, or\
    \ high-order, position. Since various\nimplementations may scale externally derived\
    \ quantities for internal\nuse, neither the precision nor decimal-point placement\
    \ for fixed-point\nquantities is specified. Unless specified otherwise, all quantities\
    \ are\nunsigned and may occupy the full field width with an implied zero\npreceding\
    \ bit zero. Hardware and software packages designed to work with\nsigned quantities\
    \ will thus yield surprising results when the most\nsignificant (sign) bit is\
    \ set. It is suggested that externally derived,\nunsigned fixed-point quantities\
    \ such as timestamps be shifted right one\nbit for internal use, since the precision\
    \ represented by the full field\nwidth is seldom justified.\nSince NTP timestamps\
    \ are cherished data and, in fact, represent the main\nproduct of the protocol,\
    \ a special timestamp format has been\nestablished. NTP timestamps are represented\
    \ as a 64-bit unsigned fixed-\npoint number, in seconds relative to 0h on 1 January\
    \ 1900. The integer\npart is in the first 32 bits and the fraction part in the\
    \ last 32 bits.\nThis format allows convenient multiple-precision arithmetic and\n\
    conversion to Time Protocol representation (seconds), but does\ncomplicate the\
    \ conversion to ICMP Timestamp message representation\n(milliseconds). The precision\
    \ of this representation is about 200\npicoseconds, which should be adequate for\
    \ even the most exotic\nrequirements.\nTimestamps are determined by copying the\
    \ current value of the local\nclock to a timestamp when some significant event,\
    \ such as the arrival of\na message, occurs. In order to maintain the highest\
    \ accuracy, it is\nimportant that this be done as close to the hardware or software\
    \ driver\nassociated with the event as possible. In particular, departure\ntimestamps\
    \ should be redetermined for each link-level retransmission. In\nsome cases a\
    \ particular timestamp may not be available, such as when the\nhost is rebooted\
    \ or the protocol first starts up. In these cases the 64-\nbit field is set to\
    \ zero, indicating the value is invalid or undefined.\nNote that since some time\
    \ in 1968 the most significant bit (bit 0 of the\ninteger part) has been set and\
    \ that the 64-bit field will overflow some\ntime in 2036. Should NTP be in use\
    \ in 2036, some external means will be\nnecessary to qualify time relative to\
    \ 1900 and time relative to 2036\n(and other multiples of 136 years). Timestamped\
    \ data requiring such\nqualification will be so precious that appropriate means\
    \ should be\nreadily available. There will exist an 200-picosecond interval,\n\
    henceforth ignored, every 136 years when the 64-bit field will be zero\nand thus\
    \ considered invalid.\nState Variables and Parameters\nFollowing is a summary\
    \ of the various state variables and parameters\nused by the protocol. They are\
    \ separated into classes of system\nvariables, which relate to the operating system\
    \ environment and local-\nclock mechanism; peer variables, which represent the\
    \ state of the\nprotocol machine specific to each peer; packet variables, which\n\
    represent the contents of the NTP message; and parameters, which\nrepresent fixed\
    \ configuration constants for all implementations of the\ncurrent version. For\
    \ each class the description of the variable is\nfollowed by its name and the\
    \ procedure or value which controls it. Note\nthat variables are in lower case,\
    \ while parameters are in upper case.\nAdditional details on formats and use are\
    \ presented in later sections\nand Appendices.\nCommon Variables\nThe following\
    \ variables are common to two or more of the system, peer\nand packet classes.\
    \ Additional variables are specific to the optional\nauthentication mechanism\
    \ as described in Appendix C. When necessary to\ndistinguish between common variables\
    \ of the same name, the variable\nidentifier will be used.\nPeer Address (peer.peeraddr,\
    \ pkt.peeraddr), Peer Port (peer.peerport,\npkt.peerport): These are the 32-bit\
    \ Internet address and 16-bit port\nnumber of the peer.\nHost Address (peer.hostaddr,\
    \ pkt.hostaddr), Host Port (peer.hostport,\npkt.hostport): These are the 32-bit\
    \ Internet address and 16-bit port\nnumber of the host. They are included among\
    \ the state variables to\nsupport multi-homing.\nLeap Indicator (sys.leap, peer.leap,\
    \ pkt.leap): This is a two-bit code\nwarning of an impending leap second to be\
    \ inserted in the NTP timescale.\nThe bits are set before 23:59 on the day of\
    \ insertion and reset after\n00:00 on the following day. This causes the number\
    \ of seconds (rollover\ninterval) in the day of insertion to be increased or decreased\
    \ by one.\nIn the case of primary servers the bits are set by operator\nintervention,\
    \ while in the case of secondary servers the bits are set by\nthe protocol. The\
    \ two bits, bit 0 and bit 1, respectively, are coded as\nfollows:\n@Z_TBL_BEG\
    \ = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E8), WIDTH(5.0000),\nABOVE(.0830),\
    \ BELOW(.0830), HGUTTER(.0560), KEEP(OFF), ALIGN(CT)\n@Z_TBL_BODY = TABLE TEXT,\
    \ TABLE TEXT\n00, no warning\n01, last minute has 61 seconds\n10, last minute\
    \ has 59 seconds\n11, alarm condition (clock not synchronized)\n@Z_TBL_END =\n\
    In all except the alarm condition (112), NTP itself does nothing with\nthese bits,\
    \ except pass them on to the time-conversion routines that are\nnot part of NTP.\
    \ The alarm condition occurs when, for whatever reason,\nthe local clock is not\
    \ synchronized, such as when first coming up or\nafter an extended period when\
    \ no primary reference source is available.\nMode (peer.mode, pkt.mode): This\
    \ is an integer indicating the\nassociation mode, with values coded as follows:\n\
    @Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E8), WIDTH(5.0000),\nABOVE(.0830),\
    \ BELOW(.0830), HGUTTER(.0560), KEEP(OFF), ALIGN(CT)\n@Z_TBL_BODY = TABLE TEXT,\
    \ TABLE TEXT\n0, unspecified\n1, symmetric active\n2, symmetric passive\n3, client\n\
    4, server\n5, broadcast\n6, reserved for NTP control messages\n7, reserved for\
    \ private use\n@Z_TBL_END =\nStratum (sys.stratum, peer.stratum, pkt.stratum):\
    \ This is an integer\nindicating the stratum of the local clock, with values defined\
    \ as\nfollows:\n@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E8), WIDTH(5.0000),\n\
    ABOVE(.0830), BELOW(.0830), HGUTTER(.0560), KEEP(OFF), ALIGN(CT)\n@Z_TBL_BODY\
    \ = TABLE TEXT, TABLE TEXT\n0, unspecified\n1, primary reference (e.g.,, calibrated\
    \ atomic clock,, radio clock)\n2-255, secondary reference (via NTP)\n@Z_TBL_END\
    \ =\nFor comparison purposes a value of zero is considered greater than any\n\
    other value. Note that the maximum value of the integer encoded as a\npacket variable\
    \ is limited by the parameter NTP.MAXSTRATUM.\nPoll Interval (sys.poll, peer.hostpoll,\
    \ peer.peerpoll, pkt.poll): This\nis a signed integer indicating the minimum interval\
    \ between transmitted\nmessages, in seconds as a power of two. For instance, a\
    \ value of six\nindicates a minimum interval of 64 seconds.\nPrecision (sys.precision,\
    \ peer.precision, pkt.precision): This is a\nsigned integer indicating the precision\
    \ of the various clocks, in\nseconds to the nearest power of two. The value must\
    \ be rounded to the\nnext larger power of two; for instance, a 50-Hz (20 ms) or\
    \ 60-Hz (16.67\nms) power-frequency clock would be assigned the value -5 (31.25\
    \ ms),\nwhile a 1000-Hz (1 ms) crystal-controlled clock would be assigned the\n\
    value -9 (1.95 ms).\nRoot Delay (sys.rootdelay, peer.rootdelay, pkt.rootdelay):\
    \ This is a\nsigned fixed-point number indicating the total roundtrip delay to\
    \ the\nprimary reference source at the root of the synchronization subnet, in\n\
    seconds. Note that this variable can take on both positive and negative\nvalues,\
    \ depending on clock precision and skew.\nRoot Dispersion (sys.rootdispersion,\
    \ peer.rootdispersion,\npkt.rootdispersion): This is a signed fixed-point number\
    \ indicating the\nmaximum error relative to the primary reference source at the\
    \ root of\nthe synchronization subnet, in seconds. Only positive values greater\n\
    than zero are possible.\n32-bit code identifying the particular reference clock.\
    \ In the case of\nstratum 0 (unspecified) or stratum 1 (primary reference source),\
    \ this is\na four-octet, left-justified, zero-padded ASCII string, for example\
    \ (see\nAppendix A for comprehensive list):\n@Z_TBL_BEG = COLUMNS(3), DIMENSION(IN),\
    \ COLWIDTHS(E2,E2,E5),\nWIDTH(4.1700), ABOVE(.1670), BELOW(.0830), HGUTTER(.3330),\n\
    BOX(Z_SINGLE), KEEP(ON), ALIGN(CT), L1(R1C0..R1C3)\n@Z_TBL_BODY = TABLE CENTER,\
    \ TABLE HEADER, TABLE HEADER\nStratum, Code, Meaning\n@Z_TBL_BODY = TABLE CENTER,\
    \ TABLE TEXT, TABLE TEXT\n0, DCN, DCN routing protocol\n0, TSP, TSP time protocol\n\
    1, ATOM, Atomic clock (calibrated)\n1, WWVB, WWVB LF (band 5) radio\n1, GOES,\
    \ GOES UHF (band 9) satellite\n@Z_TBL_BODY = TABLE CENTER, TABLE HEADER, TABLE\
    \ HEADER\n1, WWV, WWV HF (band 7) radio\n@Z_TBL_END =\nIn the case of stratum\
    \ 2 and greater (secondary reference) this is the\nfour-octet Internet address\
    \ of the peer selected for synchronization.\nthe local time, in timestamp format,\
    \ when the local clock was last\nupdated. If the local clock has never been synchronized,\
    \ the value is\nzero.\nOriginate Timestamp (peer.org, pkt.org): This is the local\
    \ time, in\ntimestamp format, at the peer when its latest NTP message was sent.\
    \ If\nthe peer becomes unreachable the value is set to zero.\nReceive Timestamp\
    \ (peer.rec, pkt.rec): This is the local time, in\ntimestamp format, when the\
    \ latest NTP message from the peer arrived. If\nthe peer becomes unreachable the\
    \ value is set to zero.\nTransmit Timestamp (peer.xmt, pkt.xmt): This is the local\
    \ time, in\ntimestamp format, at which the NTP message departed the sender.\n\
    System Variables\nTable 1<$&tab1> shows the complete set of system variables.\
    \ In addition\nto the common variables described previously, the following variables\n\
    are used by the operating system in order to synchronize the local\nclock.\nLocal\
    \ Clock (sys.clock): This is the current local time, in timestamp\nformat. Local\
    \ time is derived from the hardware clock of the particular\nmachine and increments\
    \ at intervals depending on the design used. An\nappropriate design, including\
    \ slewing and skew-Compensation mechanisms,\nis described in Section 5.\nClock\
    \ Source (sys.peer): This is a selector identifying the current\nsynchronization\
    \ source. Usually this will be a pointer to a structure\ncontaining the peer variables.\
    \ The special value NULL indicates there is\nno currently valid synchronization\
    \ source.\nPeer Variables\nTable 2 shows the complete set of peer variables. In\
    \ addition to the\ncommon variables described previously, the following variables\
    \ are used\nby the peer management and measurement functions.\nConfigured Bit\
    \ (peer.config): This is a bit indicating that the\nassociation was created from\
    \ configuration information and should not be\ndemobilized if the peer becomes\
    \ unreachable.\nUpdate Timestamp (peer.update): This is the local time, in timestamp\n\
    format, when the most recent NTP message was received. It is used in\ncalculating\
    \ the skew dispersion.\nReachability Register (peer.reach): This is a shift register\
    \ of\nNTP.WINDOW bits used to determine the reachability status of the peer,\n\
    with bits entering from the least significant (rightmost) end. A peer is\nconsidered\
    \ reachable if at least one bit in this register is set to one.\nPeer Timer (peer.timer):\
    \ This is an integer counter used to control the\ninterval between transmitted\
    \ NTP messages. Once set to a nonzero value,\nthe counter decrements at one-second\
    \ intervals until reaching zero, at\nwhich time the transmit procedure is called.\
    \ Note that the operation of\nthis timer is independent of local-clock updates,\
    \ which implies that the\ntimekeeping system and interval-timer system architecture\
    \ must be\nindependent of each other.<$&tab2>\nPacket Variables\nTable 3<$&tab3>\
    \ shows the complete set of packet variables. In addition\nto the common variables\
    \ described previously, the following variables\nare defined.\nVersion Number\
    \ (pkt.version): This is an integer indicating the version\nnumber of the sender.\
    \ NTP messages will always be sent with the current\nversion number NTP.VERSION\
    \ and will always be accepted if the version\nnumber matches NTP.VERSION. Exceptions\
    \ may be advised on a case-by-case\nbasis at times when the version number is\
    \ changed. Specific guidelines\nfor interoperation between this version and previous\
    \ versions of NTP are\nsummarized in Appendix D.\nClock-Filter Variables\nWhen\
    \ the filter and selection algorithms suggested in Section 4 are\nused, the following\
    \ state variables are defined in addition to the\nvariables described previously.\n\
    Filter Register (peer.filter): This is a shift register of NTP.SHIFT\nstages,\
    \ where each stage stores a 3-tuple consisting of the measured\ndelay, measured\
    \ offset and calculated dispersion associated with a\nsingle observation. These\
    \ 3-tuples enter from the most significant\n(leftmost) right and are shifted towards\
    \ the least significant\n(rightmost) end and eventually discarded as new observations\
    \ arrive.\nValid Data Counter (peer.valid): This is an integer counter indicating\n\
    the valid samples remaining in the filter register. It is used to\ndetermine the\
    \ reachability state and when the poll interval should be\nincreased or decreased.\n\
    Offset (peer.offset): This is a signed, fixed-point number indicating\nthe offset\
    \ of the peer clock relative to the local clock, in seconds.\nDelay (peer.delay):\
    \ This is a signed fixed-point number indicating the\nroundtrip delay of the peer\
    \ clock relative to the local clock over the\nnetwork path between them, in seconds.\
    \ Note that this variable can take\non both positive and negative values, depending\
    \ on clock precision and\nskew-error accumulation.\nDispersion (peer.dispersion):\
    \ This is a signed fixed-point number\nindicating the maximum error of the peer\
    \ clock relative to the local\nclock over the network path between them, in seconds.\
    \ Only positive\nvalues greater than zero are possible.\nAuthentication Variables\n\
    When the authentication mechanism suggested in Appendix C is used, the\nfollowing\
    \ state variables are defined in addition to the variables\ndescribed previously.\
    \ These variables are used only if the optional\nauthentication mechanism described\
    \ in Appendix C is implemented.\nAuthentication Enabled Bit (peer.authenable):\
    \ This is a bit indicating\nthat the association is to operate in the authenticated\
    \ mode.\nAuthenticated Bit (peer.authentic): This is a bit indicating that the\n\
    last message received from the peer has been correctly authenticated.\nKey Identifier\
    \ (peer.hostkeyid, peer.peerkeyid, pkt.keyid): This is an\ninteger identifying\
    \ the cryptographic key used to generate the message-\nauthentication code.\n\
    Cryptographic Keys (sys.key): This is a set of 64-bit DES keys. Each key\nis constructed\
    \ as in the Berkeley Unix distributions, which consists of\neight octets, where\
    \ the seven low-order bits of each octet correspond to\nthe DES bits 1-7 and the\
    \ high-order bit corresponds to the DES odd-\nparity bit 8.\nCrypto-Checksum (pkt.check):\
    \ This is a crypto-checksum computed by the\nencryption procedure.\nParameters\n\
    Table 4<$&tab4> shows the parameters assumed for all implementations\noperating\
    \ in the Internet system. It is necessary to agree on the values\nfor these parameters\
    \ in order to avoid unnecessary network overheads and\nstable peer associations.\
    \ The following parameters are assumed fixed and\napplicable to all associations.\n\
    Version Number (NTP.VERSION): This is the current NTP version number\n(3).\nNTP\
    \ Port (NTP.PORT): This is the port number (123) assigned by the\nInternet Assigned\
    \ Numbers Authority to NTP.\nMaximum Stratum (NTP.MAXSTRATUM): This is the maximum\
    \ stratum value that\ncan be encoded as a packet variable, also interpreted as\n\
    <169>infinity<170> or unreachable by the subnet routing algorithm.\nMaximum Clock\
    \ Age (NTP.MAXAGE): This is the maximum interval a reference\nclock will be considered\
    \ valid after its last update, in seconds.\nMaximum Skew (NTP.MAXSKEW): This is\
    \ the maximum offset error due to skew\nof the local clock over the interval determined\
    \ by NTP.MAXAGE, in\nseconds. The ratio <$Ephi~=~roman {NTP.MAXSKEW over NTP.MAXAGE}>\
    \ is\ninterpreted as the maximum possible skew rate due to all causes.\nMaximum\
    \ Distance (NTP.MAXDISTANCE): When the selection algorithm\nsuggested in Section\
    \ 4 is used, this is the maximum synchronization\ndistance for peers acceptable\
    \ for synchronization.\nMinimum Poll Interval (NTP.MINPOLL): This is the minimum\
    \ poll interval\nallowed by any peer of the Internet system, in seconds to a power\
    \ of\ntwo.\nMaximum Poll Interval (NTP.MAXPOLL): This is the maximum poll interval\n\
    allowed by any peer of the Internet system, in seconds to a power of\ntwo.\nMinimum\
    \ Select Clocks (NTP.MINCLOCK): When the selection algorithm\nsuggested in Section\
    \ 4 is used, this is the minimum number of peers\nacceptable for synchronization.\n\
    Maximum Select Clocks (NTP.MAXCLOCK): When the selection algorithm\nsuggested\
    \ in Section 4 is used, this is the maximum number of peers\nconsidered for selection.\n\
    Minimum Dispersion (NTP.MINDISPERSE): When the filter algorithm\nsuggested in\
    \ Section 4 is used, this is the minimum dispersion increment\nfor each stratum\
    \ level, in seconds.\nMaximum Dispersion (NTP.MAXDISPERSE): When the filter algorithm\n\
    suggested in Section 4 is used, this is the maximum peer dispersion and\nthe dispersion\
    \ assumed for missing data, in seconds.\nReachability Register Size (NTP.WINDOW):\
    \ This is the size of the\nreachability register (peer.reach), in bits.\nFilter\
    \ Size (NTP.SHIFT): When the filter algorithm suggested in Section\n4 is used,\
    \ this is the size of the clock filter (peer.filter) shift\nregister, in stages.\n\
    Filter Weight (NTP.FILTER): When the filter algorithm suggested in\nSection 4\
    \ is used, this is the weight used to compute the filter\ndispersion.\nSelect\
    \ Weight (NTP.SELECT): When the selection algorithm suggested in\nSection 4 is\
    \ used, this is the weight used to compute the select\ndispersion.\nModes of Operation\n\
    Except in broadcast mode, an NTP association is formed when two peers\nexchange\
    \ messages and one or both of them create and maintain an\ninstantiation of the\
    \ protocol machine, called an association. The\nassociation can operate in one\
    \ of five modes as indicated by the host-\nmode variable (peer.mode): symmetric\
    \ active, symmetric passive, client,\nserver and broadcast, which are defined\
    \ as follows:\nSymmetric Active (1): A host operating in this mode sends periodic\n\
    messages regardless of the reachability state or stratum of its peer. By\noperating\
    \ in this mode the host announces its willingness to synchronize\nand be synchronized\
    \ by the peer.\nSymmetric Passive (2): This type of association is ordinarily\
    \ created\nupon arrival of a message from a peer operating in the symmetric active\n\
    mode and persists only as long as the peer is reachable and operating at\na stratum\
    \ level less than or equal to the host; otherwise, the\nassociation is dissolved.\
    \ However, the association will always persist\nuntil at least one message has\
    \ been sent in reply. By operating in this\nmode the host announces its willingness\
    \ to synchronize and be\nsynchronized by the peer.\nClient (3): A host operating\
    \ in this mode sends periodic messages\nregardless of the reachability state or\
    \ stratum of its peer. By\noperating in this mode the host, usually a LAN workstation,\
    \ announces\nits willingness to be synchronized by, but not to synchronize the\
    \ peer.\nServer (4): This type of association is ordinarily created upon arrival\n\
    of a client request message and exists only in order to reply to that\nrequest,\
    \ after which the association is dissolved. By operating in this\nmode the host,\
    \ usually a LAN time server, announces its willingness to\nsynchronize, but not\
    \ to be synchronized by the peer.\nBroadcast (5): A host operating in this mode\
    \ sends periodic messages\nregardless of the reachability state or stratum of\
    \ the peers. By\noperating in this mode the host, usually a LAN time server operating\
    \ on\na high-speed broadcast medium, announces its willingness to synchronize\n\
    all of the peers, but not to be synchronized by any of them.\nA host operating\
    \ in client mode occasionally sends an NTP message to a\nhost operating in server\
    \ mode, perhaps right after rebooting and at\nperiodic intervals thereafter. The\
    \ server responds by simply\ninterchanging addresses and ports, filling in the\
    \ required information\nand returning the message to the client. Servers need\
    \ retain no state\ninformation between client requests, while clients are free\
    \ to manage\nthe intervals between sending NTP messages to suit local conditions.\
    \ In\nthese modes the protocol machine described in this document can be\nconsiderably\
    \ simplified to a simple remote-procedure-call mechanism\nwithout significant\
    \ loss of accuracy or robustness, especially when\noperating over high-speed LANs.\n\
    In the symmetric modes the client/server distinction (almost)\ndisappears. Symmetric\
    \ passive mode is intended for use by time servers\noperating near the root nodes\
    \ (lowest stratum) of the synchronization\nsubnet and with a relatively large\
    \ number of peers on an intermittent\nbasis. In this mode the identity of the\
    \ peer need not be known in\nadvance, since the association with its state variables\
    \ is created only\nwhen an NTP message arrives. Furthermore, the state storage\
    \ can be\nreused when the peer becomes unreachable or is operating at a higher\n\
    stratum level and thus ineligible as a synchronization source.\nSymmetric active\
    \ mode is intended for use by time servers operating near\nthe end nodes (highest\
    \ stratum) of the synchronization subnet. Reliable\ntime service can usually be\
    \ maintained with two peers at the next lower\nstratum level and one peer at the\
    \ same stratum level, so the rate of\nongoing polls is usually not significant,\
    \ even when connectivity is lost\nand error messages are being returned for every\
    \ poll.\nNormally, one peer operates in an active mode (symmetric active, client\n\
    or broadcast modes) as configured by a startup file, while the other\noperates\
    \ in a passive mode (symmetric passive or server modes), often\nwithout prior\
    \ configuration. However, both peers can be configured to\noperate in the symmetric\
    \ active mode. An error condition results when\nboth peers operate in the same\
    \ mode, but not symmetric active mode. In\nsuch cases each peer will ignore messages\
    \ from the other, so that prior\nassociations, if any, will be demobilized due\
    \ to reachability failure.\nBroadcast mode is intended for operation on high-speed\
    \ LANs with\nnumerous workstations and where the highest accuracies are not required.\n\
    In the typical scenario one or more time servers on the LAN send\nperiodic broadcasts\
    \ to the workstations, which then determine the time\non the basis of a preconfigured\
    \ latency in the order of a few\nmilliseconds. As in the client/server modes the\
    \ protocol machine can be\nconsiderably simplified in this mode; however, a modified\
    \ form of the\nclock selection algorithm may prove useful in cases where multiple\
    \ time\nservers are used for enhanced reliability.\nEvent Processing\nThe significant\
    \ events of interest in NTP occur upon expiration of a\npeer timer (peer.timer),\
    \ one of which is dedicated to each peer with an\nactive association, and upon\
    \ arrival of an NTP message from the various\npeers. An event can also occur as\
    \ the result of an operator command or\ndetected system fault, such as a primary\
    \ reference source failure. This\nsection describes the procedures invoked when\
    \ these events occur.\nNotation Conventions\nThe NTP filtering and selection algorithms\
    \ act upon a set of variables\nfor clock offset (<$Etheta ,~THETA>), roundtrip\
    \ delay (<$Edelta\n,~DELTA>) and dispersion (<$Eepsilon ,~EPSILON>). When necessary\
    \ to\ndistinguish between them, lower-case Greek letters are used for\nvariables\
    \ relative to a peer, while upper-case Greek letters are used\nfor variables relative\
    \ to the primary reference source(s), i.e., via the\npeer to the root of the synchronization\
    \ subnet. Subscripts will be used\nto identify the particular peer when this is\
    \ not clear from context. The\nalgorithms are based on a quantity called the synchronization\
    \ distance\n(<$Elambda ,~LAMBDA>), which is computed from the roundtrip delay\
    \ and\ndispersion as described below.\nAs described in Appendix H, the peer dispersion\
    \ <$Eepsilon> includes\ncontributions due to measurement error <$Erho~=~1~<< <<~roman\n\
    sys.precision>, skew-error accumulation <$Ephi tau>, where\n<$Ephi~=~roman {NTP.MAXSKEW\
    \ over NTP.MAXAGE}> is the maximum skew rate\nand <$Etau~=~roman {sys.clock~-~peer.update}>\
    \ is the interval since the\nlast update, and filter (sample) dispersion <$Eepsilon\
    \ sub sigma>\ncomputed by the clock-filter algorithm. The root dispersion <$EEPSILON>\n\
    includes contributions due to the selected peer dispersion <$Eepsilon>\nand skew-error\
    \ accumulation <$Ephi tau>, together with the root\ndispersion for the peer itself.\
    \ The system dispersion includes the\nselect (sample) dispersion <$Eepsilon sub\
    \ xi> computed by the clock-\nselect algorithm and the absolute initial clock\
    \ offset <$E| THETA |>\nprovided to the local-clock algorithm. Both <$Eepsilon>\
    \ and <$EEPSILON>\nare dynamic quantities, since they depend on the elapsed time\
    \ <$Etau>\nsince the last update, as well as the sample dispersions calculated\
    \ by\nthe algorithms.\nEach time the relevant peer variables are updated, all\
    \ dispersions\nassociated with that peer are updated to reflect the skew-error\n\
    accumulation. The computations can be summarized as follows:\n<$Etheta~==~roman\
    \ peer.offset> ,\n<$Edelta~==~roman peer.delay> ,\n<$Eepsilon~==~roman peer.dispersion~=~rho~+~phi\
    \ tau~+~epsilon sub sigma>\n,\n<$Elambda~==~epsilon~+~{| delta |} over 2> ,\n\
    where <$Etau> is the interval since the original timestamp (from which\n<$Etheta>\
    \ and <$Edelta> were determined) was transmitted to the present\ntime and <$Eepsilon\
    \ sub sigma> is the filter dispersion (see clock-\nfilter procedure below). The\
    \ variables relative to the root of the\nsynchronization subnet via peer i are\
    \ determined as follows:\n<$ETHETA sub i~==~theta sub i> ,\n<$EDELTA sub i~==~roman\
    \ peer.rootdelay~+~delta sub i> ,\n<$EEPSILON sub i~==~roman peer.rootdispersion~+~epsilon\
    \ sub i~+~phi tau\nsub i> ,\n<$ELAMBDA sub i~==~EPSILON sub i~+~{| DELTA sub i\
    \ |} over 2> ,\nwhere all variables are understood to pertain to the ith peer.\
    \ Finally,\nassuming the ith peer is selected for synchronization, the system\n\
    variables are determined as follows:\n<$ETHETA~=~>combined final offset ,\n<$EDELTA~=~DELTA\
    \ sub i> ,\n<$EEPSILON~=~EPSILON sub i~+~epsilon sub xi~+~| THETA |> ,\n<$ELAMBDA~=~LAMBDA\
    \ sub i> ,\nwhere <$Eepsilon sub xi> is the select dispersion (see clock-selection\n\
    procedure below).\nInformal pseudo-code which accomplishes these computations\
    \ is presented\nbelow. Note that the pseudo-code is represented in no particular\n\
    language, although it has many similarities to the C language. Specific\ndetails\
    \ on the important algorithms are further illustrated in the C-\nlanguage routines\
    \ in Appendix I.\nTransmit Procedure\nThe transmit procedure is executed when\
    \ the peer timer decrements to\nzero for all modes except client mode with a broadcast\
    \ server and server\nmode in all cases. In client mode with a broadcast server\
    \ messages are\nnever sent. In server mode messages are sent only in response\
    \ to\nreceived messages. This procedure is also called by the receive\nprocedure\
    \ when an NTP message arrives that does not result in a\npersistent association.\n\
    begin transmit procedure\nThe following initializes the packet buffer and copies\
    \ the packet\nvariables. The value skew is necessary to account for the skew-error\n\
    accumulated over the interval since the local clock was last set.\n        <$Eroman\
    \ pkt.peeraddr~<<-~roman peer.hostaddr>;         /* copy\nsystem and peer variables\
    \ */\n        <$Eroman pkt.peerport~<<-~roman peer.hostport>;\n        <$Eroman\
    \ pkt.hostaddr~<<-~roman peer.peeraddr>;\n        <$Eroman pkt.hostport~<<-~roman\
    \ peer.peerport>;\n        <$Eroman pkt.leap~<<-~roman sys.leap>;\n        <$Eroman\
    \ pkt.version~<<-~roman NTP.VERSION>;\n        <$Eroman pkt.mode~<<-~roman peer.mode>;\n\
    \        <$Eroman pkt.stratum~<<-~roman sys.stratum>;\n        <$Eroman pkt.poll~<<-~roman\
    \ peer.hostpoll>;\n        <$Eroman pkt.precision~<<-~roman sys.precision>;\n\
    \        <$Eroman pkt.rootdelay~<<-~roman sys.rootdelay>;\n        if (sys.leap\
    \ = 112 or (sys.clock <196> sys.reftime) >>\nNTP.MAXAGE)\n                <$Eskew~<<-~roman\
    \ NTP.MAXSKEW>;\n        else\n                <$Eskew~<<-~phi roman {(sys.clock~-~sys.reftime)}>;\n\
    \        <$Eroman {pkt.rootdispersion~<<-~roman\nsys.rootdispersion~+~(1~<< <<~sys.precision)}~+~skew>;\n\
    \        <$Eroman pkt.refid~<<-~roman sys.refid>;\n        <$Eroman pkt.reftime~<<-~roman\
    \ sys.reftime>;\nThe transmit timestamp pkt.xmt will be used later in order to\
    \ validate\nthe reply; thus, implementations must save the exact value transmitted.\n\
    In addition, the order of copying the timestamps should be designed so\nthat the\
    \ time to format and copy the data does not degrade accuracy.\n        <$Eroman\
    \ pkt.org~<<-~roman peer.org>;                           \n/* copy timestamps\
    \ */\n        <$Eroman pkt.rec~<<-~roman peer.rec>;\n        <$Eroman pkt.xmt~<<-~roman\
    \ sys.clock>;\n        <$Eroman peer.xmt~<<-~roman pkt.xmt>;\nThe call to encrypt\
    \ is implemented only if authentication is\nimplemented. If authentication is\
    \ enabled, the delay to encrypt the\nauthenticator may degrade accuracy. Therefore,\
    \ implementations should\ninclude a system state variable (not mentioned elsewhere\
    \ in this\nspecification) which contains an offset calculated to match the expected\n\
    encryption delay and correct the transmit timestamp as obtained from the\nlocal\
    \ clock.\n        #ifdef (authentication implemented)     /* see Appendix C */\n\
    \                call encrypt;\n                #endef\n        send packet;\n\
    The reachability register is shifted one position to the left, with zero\nreplacing\
    \ the vacated bit. If all bits of this register are zero, the\nclear procedure\
    \ is called to purge the clock filter and reselect the\nsynchronization source,\
    \ if necessary. If the association was not\nconfigured by the initialization procedure,\
    \ the association is\ndemobilized.\n        <$Eroman peer.reach~<<-~roman peer.reach~<<\
    \ <<~1>;              \n/* update reachability */\n        if (<$Eroman peer.reach~=~0>\
    \ and <$Eroman peer.config~=~0>)\nbegin\n                demobilize association;\n\
    \                exit;\n                endif\nIf valid data have been shifted\
    \ into the filter register at least once\nduring the preceding two poll intervals\
    \ (low-order bit of peer.reach set\nto one), the valid data counter is incremented.\
    \ After eight such valid\nintervals the poll interval is incremented. Otherwise,\
    \ the valid data\ncounter and poll interval are both decremented and the clock-filter\n\
    procedure called with zero values for offset and delay and\nNTP.MAXDISPERSE for\
    \ dispersion. The clock-select procedure is called to\nreselect the synchronization\
    \ source, if necessary.\n        if (<$Eroman peer.reach~&~6~!=~0>)          \
    \            /* test\ntwo low-order bits (shifted) */ \n                if (<$Eroman\
    \ peer.valid~<<~roman NTP.SHIFT>)    /* valid\ndata received */\n            \
    \            <$Eroman peer.valid~<<-~roman peer.valid~+~1>;\n                \
    \        else <$Eroman peer.hostpoll~<<-~roman\npeer.hostpoll~+~1>;\n        else\
    \ begin\n                <$Eroman peer.valid~<<-~roman peer.valid~-~1>;  /*\n\
    nothing heard */\n                <$Eroman peer.hostpoll~<<-~roman peer.hostpoll~-~1>);\n\
    \                call clock-filter(0, 0, NTP.MAXDISPERSE);\n                call\
    \ clock-select;                      /* select clock\nsource */\n            \
    \    endif\n        call poll-update;\n        end transmit procedure;\nReceive\
    \ Procedure\nThe receive procedure is executed upon arrival of an NTP message.\
    \ It\nvalidates the message, interprets the various modes and calls other\nprocedures\
    \ to filter the data and select the synchronization source. If\nthe version number\
    \ in the packet does not match the current version, the\nmessage may be discarded;\
    \ however, exceptions may be advised on a case-\nby-case basis at times when the\
    \ version is changed. If the NTP control\nmessages described in Appendix B are\
    \ implemented and the packet mode is\n6 (control), the control-message procedure\
    \ is called. The source and\ndestination Internet addresses and ports in the IP\
    \ and UDP headers are\nmatched to the correct peer. If there is no match a new\
    \ instantiation of\nthe protocol machine is created and the association mobilized.\n\
    begin receive procedure\n        if (<$Eroman pkt.version~!=~roman NTP.VERSION>)\
    \ exit;\n        #ifdef (control messages implemented)\n                if (<$Eroman\
    \ pkt.mode~=~6>) call control-message;\n                #endef\n        for (all\
    \ associations)                  /* access control goes\nhere */\n           \
    \     match addresses and ports to associations;\n        if (no matching association)\n\
    \                call receive-instantiation procedure;   /* create\nassociation\
    \ */\nThe call to decrypt is implemented only if authentication is\nimplemented.\n\
    \        #ifdef (authentication implemented)     /* see Appendix C */\n      \
    \          call decrypt;\n                #endef\nIf the packet mode is nonzero,\
    \ this becomes the value of mode used in\nthe following step; otherwise, the peer\
    \ is an old NTP version and mode\nis determined from the port numbers as described\
    \ in Section 3.3.\n        if (pkt.mode = 0)                               /*\
    \ for\ncompatibility with old versions */\n                <$Emode~<<-~>(see Section\
    \ 3.3);\n        else\n                <$Emode~<<-~roman pkt.mode>;\nTable 5<$&tab5>\
    \ shows for each combination of peer.mode and mode the\nresulting case labels.\n\
    \        case (mode, peer.hostmode)              /* see Table 5 */\nIf error the\
    \ packet is simply ignored and the association demobilized,\nif not previously\
    \ configured.\nerror:          if (<$Eroman peer.config~=~0>) demobilize association;\
    \  \n/* see no evil */\n                break;\nIf recv the packet is processed\
    \ and the association marked reachable if\ntests five through eight (valid header)\
    \ enumerated in the packet\nprocedure succeed. If, in addition, tests one through\
    \ four succeed\n(valid data), the clock-update procedure is called to update the\
    \ local\nclock. Otherwise, if the association was not previously configured, it\n\
    is demobilized.\nrecv:           call packet;                            /* process\n\
    packet */\n                if (valid header) begin         /* if valid header,\n\
    update local clock */\n                        <$Eroman peer.reach~<<-~roman peer.reach~|~1>;\n\
    \                        if (valid data) call clock-update;\n                \
    \        endif\n                else\n                        if (<$Eroman peer.config~=~0>)\
    \ demobilize\nassociation;\n                break;\nIf xmit the packet is processed\
    \ and an immediate reply is sent. The\nassociation is then demobilized if not\
    \ previously configured.\nxmit:           call packet;                       \
    \     /* process\npacket */\n                <$Eroman peer.hostpoll~<<-~roman\
    \ peer.peerpoll>;        \n/* send immediate reply */\n                call poll-update;\n\
    \                call transmit;\n                if (<$Eroman peer.config~=~0>)\
    \ demobilize association;\n                break;\nIf pkt the packet is processed\
    \ and the association marked reachable if\ntests five through eight (valid header)\
    \ enumerated in the packet\nprocedure succeed. If, in addition, tests one through\
    \ four succeed\n(valid data), the clock-update procedure is called to update the\
    \ local\nclock. Otherwise, if the association was not previously configured, an\n\
    immediate reply is sent and the association demobilized.\npkt:            call\
    \ packet;                            /* process\npacket */\n                if\
    \ (valid header) begin         /* if valid header,\nupdate local clock */\n  \
    \                      <$Eroman peer.reach~<<-~roman peer.reach~|~1>;\n      \
    \                  if (valid data) call clock-update;\n                      \
    \  endif\n                else if (<$Eroman peer.config~=~0>) begin\n        \
    \                <$Eroman peer.hostpoll~<<-~roman\npeer.peerpoll>; /* send immediate\
    \ reply */\n                        call poll-update;\n                      \
    \  call transmit;\n                        demobilize association;\n         \
    \               endif\n                endcase\n        end receive procedure;\n\
    Packet Procedure\nThe packet procedure checks the message validity, computes delay/offset\n\
    samples and calls other procedures to filter the data and select the\nsynchronization\
    \ source. Test 1 requires the transmit timestamp not match\nthe last one received\
    \ from the same peer; otherwise, the message might\nbe an old duplicate. Test\
    \ 2 requires the originate timestamp match the\nlast one sent to the same peer;\
    \ otherwise, the message might be out of\norder, bogus or worse. In case of broadcast\
    \ mode (5) the apparent\nroundtrip delay will be zero and the full accuracy of\
    \ the time-transfer\noperation may not be achievable. However, the accuracy achieved\
    \ may be\nadequate for most purposes. The poll-update procedure is called with\n\
    argument peer.hostpoll (peer.peerpoll may have changed).\nbegin packet procedure\n\
    \        <$Eroman peer.rec~<<-~roman sys.clock>;                 /*\ncapture receive\
    \ timestamp */\n        if (<$Eroman pkt.mode ~!=~5>) begin\n                <$Etest1~<<-~(\
    \ roman {pkt.xmt~!=~peer.org})>;   /* test\n1 */\n                <$Etest2~<<-~(\
    \ roman {pkt.org~=~peer.xmt})>;    /* test\n2 */\n                endif\n    \
    \    else begin\n                <$Eroman pkt.org~<<-~roman peer.rec>;       \
    \            \n/* fudge missing timestamps */\n                <$Eroman pkt.rec~<<-~roman\
    \ pkt.xmt>;\n                <$Etest1~<<-~bold roman true>;                  \
    \        \n/* fake tests */\n                <$Etest2~<<-~bold roman true>;\n\
    \                endif\n        <$Eroman peer.org~<<-~roman pkt.xmt>;        \
    \                   \n/* update originate timestamp */\n        <$Eroman peer.peerpoll~<<-~roman\
    \ pkt.poll>;                     \n/* adjust poll interval */\n        call poll-update(peer.hostpoll);\n\
    Test 3 requires that both the originate and receive timestamps are\nnonzero. If\
    \ either of the timestamps are zero, the association has not\nsynchronized or\
    \ has lost reachability in one or both directions.\n        <$Etest3~<<-~( roman\
    \ pkt.org~!=~0> and <$Eroman pkt.rec~!=~0)>; \n/* test 3 */\nThe roundtrip delay\
    \ and clock offset relative to the peer are calculated\nas follows. Number the\
    \ times of sending and receiving NTP messages as\nshown in Figure 2<$&fig2> and\
    \ let i be an even integer. Then Ti-3, Ti-2,\nTi-1 and Ti are the contents of\
    \ the pkt.org, pkt.rec, pkt.xmt and\npeer.rec variables, respectively. The clock\
    \ offset <$Etheta>, roundtrip\ndelay <$Edelta> and dispersion <$Eepsilon> of the\
    \ host relative to the\npeer is:\n<$Edelta~=~(T sub i~-~T sub {i - 3} )~-~(T sub\
    \ {i - 1}~-~T sub {i - 2}\n)> ,\n<$Etheta~=~{(T sub {i - 2}~-~T sub {i-3})~+~(T\
    \ sub {i-1}~-~T sub i ) }\nover 2> ,\n<$Eepsilon~=~roman {(1~<< <<~sys.precision})~+~phi\
    \ (T sub i ~-~T sub {i-\n3} )> ,\nwhere, as before, <$Ephi~=~roman{ NTP.MAXSKEW\
    \ over NTP.MAXAGE}>. The\nquantity <$Eepsilon> represents the maximum error or\
    \ dispersion due to\nmeasurement error at the host and local-clock skew accumulation\
    \ over the\ninterval since the last message was transmitted to the peer.\nSubsequently,\
    \ the dispersion will be updated by the clock-filter\nprocedure.\nThe above method\
    \ amounts to a continuously sampled, returnable-time\nsystem, which is used in\
    \ some digital telephone networks [BEL86]. Among\nthe advantages are that the\
    \ order and timing of the messages are\nunimportant and that reliable delivery\
    \ is not required. Obviously, the\naccuracies achievable depend upon the statistical\
    \ properties of the\noutbound and inbound data paths. Further analysis and experimental\n\
    results bearing on this issue can be found in [MIL90] and in Appendix H.\nTest\
    \ 4 requires that the calculated delay be within <169>reasonable<170>\nbounds:\n\
    \        <$Etest4~<<-~(| delta |~<<~roman NTP.MAXDISPERSE~bold\nand~epsilon~<<~roman\
    \ NTP.MAXDISPERSE)>;  /* test 4 */\nTest 5 is implemented only if the authentication\
    \ mechanism described in\nAppendix C is implemented. It requires either that authentication\
    \ be\nexplicitly disabled or that the authenticator be present and correct as\n\
    determined by the decrypt procedure.\n        #ifdef (authentication implemented)\
    \     /* test 5 */\n                <$Etest5~<<-~( roman {(peer.config~=~1~bold\n\
    and~peer.authenable~=~0)~bold or~ peer.authentic~=~1})>;\n                #endef\n\
    Test 6 requires the peer clock be synchronized and the interval since\nthe peer\
    \ clock was last updated be positive and less than NTP.MAXAGE.\nTest 7 insures\
    \ that the host will not synchronize on a peer with greater\nstratum. Test 8 requires\
    \ that the header contains <169>reasonable<170>\nvalues for the pkt.rootdelay\
    \ and pkt.rootdispersion fields.\n        <$Etest6~<<-~( roman pkt.leap~!=~11\
    \ sub 2> and          /* test\n6 */\n                <$Eroman\n{pkt.reftime~<<=~pkt.xmt~<<~pkt.reftime~+~NTP.MAXAGE}>)\n\
    \        <$Etest7~<<-~roman {pkt.stratum ~<<=~sys.stratum}> and  /* test\n7 */\n\
    \                 <$Eroman {pkt.stratum ~<<~NTP.MAXSTRATUM}>;\n        <$Etest8~<<-~(\
    \ roman {| pkt.rootdelay |~<<~NTP.MAXDISPERSE}>\nand     /* test 8 */\n      \
    \          <$Eroman {pkt.rootdispersion~<<~NTP.MAXDISPERSE})>;\nWith respect to\
    \ further processing, the packet includes valid\n(synchronized) data if tests\
    \ one through four succeed\n<$E(test1~&~test2~&~test3~&~test4~=~1)>, regardless\
    \ of the remaining\ntests. Only packets with valid data can be used to calculate\
    \ offset,\ndelay and dispersion values. The packet includes a valid header if\
    \ tests\nfive through eight succeed <$E(test5~&~test6~&~test7~&~test8~=~1)>,\n\
    regardless of the remaining tests. Only packets with valid headers can\nbe used\
    \ to determine whether a peer can be selected for synchronization.\nNote that\
    \ <$Etest1> and <$Etest2> are not used in broadcast mode (forced\nto true), since\
    \ the originate and receive timestamps are undefined.\nThe clock-filter procedure\
    \ is called to produce the delay (peer.delay),\noffset (peer.offset) and dispersion\
    \ (peer.dispersion) for the peer.\nSpecification of the clock-filter algorithm\
    \ is not an integral part of\nthe NTP specification, since there may be other\
    \ algorithms that work\nwell in practice. However, one found to work well in the\
    \ Internet\nenvironment is described in Section 4 and its use is recommended.\n\
    \        if (not valid header) exit;\n        <$Eroman peer.leap~<<-~roman pkt.leap>;\
    \                 /* copy\npacket variables */\n        <$Eroman peer.stratum~<<-~roman\
    \ pkt.stratum>;\n        <$Eroman peer.precision~<<-~roman pkt.precision>;\n \
    \       <$Eroman peer.rootdelay~<<-~roman pkt.rootdelay>;\n        <$Eroman peer.rootdispersion~<<-~roman\
    \ pkt.rootdispersion>;\n        <$Eroman peer.refid~<<-~roman pkt.refid>;\n  \
    \      <$Eroman peer.reftime~<<-~roman pkt.reftime>;\n        if (valid data)\
    \ call clock-filter(<$Etheta ,~delta ,~epsilon>); \n/* process sample */\n   \
    \     end packet procedure;\nClock-Update Procedure\nThe clock-update procedure\
    \ is called from the receive procedure when\nvalid clock offset, delay and dispersion\
    \ data have been determined by\nthe clock-filter procedure for the current peer.\
    \ The result of the\nclock-selection and clock-combining procedures is the final\
    \ clock\ncorrection <$ETHETA>, which is used by the local-clock procedure to\n\
    update the local clock. If no candidates survive these procedures, the\nclock-update\
    \ procedure exits without doing anything further.\nbegin clock-update procedure\n\
    \        call clock-select;                              /* select clock\nsource\
    \ */\n        if (<$Eroman sys.peer~!=~peer>) exit;\nIt may happen that the local\
    \ clock may be reset, rather than slewed to\nits final value. In this case the\
    \ clear procedure is called for every\npeer to purge the clock filter, reset the\
    \ poll interval and reselect the\nsynchronization source, if necessary. Note that\
    \ the local-clock\nprocedure sets the leap bits sys.leap to <169>unsynchronized<170>\
    \ 112 in\nthis case, so that no other peer will attempt to synchronize to the\
    \ host\nuntil the host once again selects a peer for synchronization.\nThe distance\
    \ procedure calculates the root delay <$EDELTA>, root\ndispersion <$EEPSILON>\
    \ and root synchronization distance <$ELAMBDA> via\nthe peer to the root of the\
    \ synchronization subnet. The host will not\nsynchronize to the selected peer\
    \ if the distance is greater than\nNTP.MAXDISTANCE. The reason for the minimum\
    \ clamp at NTP.MINDISPERSE is\nto discourage subnet route flaps that can happen\
    \ with Bellman-Ford\nalgorithms and small roundtrip delays.\n        <$ELAMBDA~<M=O>\n\
    <~>an distance (peer)>;                         /* update system\nvariables */\n\
    \ <B>    if (<$ELAMBDA~>>=~roman NTP.MAXDISTANCE>) exit;\n        <$Eroman sys.leap~<<-~roman\
    \ peer.leap>;\n        <$Eroman sys.stratum~<<-~roman peer.stratum~+~1>;\n   \
    \     <$Eroman sys.refid~<<-~roman peer.peeraddr>;\n        call local-clock;\n\
    \        if (local clock reset) begin                    /* if reset,\nclear state\
    \ variables */\n                <$Eroman sys.leap~<<-~11 sub 2>;\n           \
    \     for (all peers) call clear;\n                endif\n        else begin\n\
    \                <$Eroman sys.peer~<<-~peer>;                    /* if\nnot, adjust\
    \ local clock */\n                <$Eroman sys.rootdelay~<<-~DELTA>;\n       \
    \         <$Eroman sys.rootdispersion~<<-~EPSILON~+~max ( epsilon\nsub xi~+~|\
    \ THETA |,~roman NTP.MINDISPERSE)>;\n                endif\n        <$Eroman sys.reftime~<<-~roman\
    \ sys.clock>;\n        end clock-update procedure;\nIn some system configurations\
    \ a precise source of timing information is\navailable in the form of a train\
    \ of timing pulses spaced at one-second\nintervals. Usually, this is in addition\
    \ to a source of timecode\ninformation, such as a radio clock or even NTP itself,\
    \ to number the\nseconds, minutes, hours and days. In these configurations the\
    \ system\nvariables are set to refer to the source from which the pulses are\n\
    derived. For those configurations which support a primary reference\nsource, such\
    \ as a radio clock or calibrated atomic clock, the stratum is\nset at one as long\
    \ as this is the actual synchronization source and\nwhether or not the primary-clock\
    \ procedure is used.\nSpecification of the clock-selection and local-clock algorithms\
    \ is not\nan integral part of the NTP specification, since there may be other\n\
    algorithms which provide equivalent performance. However, a clock-\nselection\
    \ algorithm found to work well in the Internet environment is\ndescribed in Section\
    \ 4, while a local-clock algorithm is described in\nSection 5 and their use is\
    \ recommended. The clock-selection algorithm\ndescribed in Section 4 usually picks\
    \ the peer at the lowest stratum and\nminimum synchronization distance among all\
    \ those available, unless that\npeer appears to be a falseticker. The result is\
    \ that the algorithms all\nwork to build a minimum-weight spanning tree relative\
    \ to the primary\nreference time servers and thus a hierarchical-master-slave\n\
    synchronization subnet.\nPrimary-Clock Procedure\nWhen a primary reference source\
    \ such as a radio clock is connected to\nthe host, it is convenient to incorporate\
    \ its information into the data\nbase as if the clock were represented as an ordinary\
    \ peer. In the\nprimary-clock procedure the clock is polled once a minute or so\
    \ and the\nreturned timecode used to produce a new update for the local clock.\
    \ When\npeer.timer decrements to zero for a primary clock peer, the transmit\n\
    procedure is not called; rather, the radio clock is polled, usually\nusing an\
    \ ASCII string specified for this purpose. When a valid timecode\nis received\
    \ from the radio clock, it is converted to NTP timestamp\nformat and the peer\
    \ variables updated. The value of peer.leap is set\ndepending on the status of\
    \ the leap-warning bit in the timecode, if\navailable, or manually by the operator.\
    \ The value for peer.peeraddr,\nwhich will become the value of sys.refid when\
    \ the clock-update procedure\nis called, is set to an ASCII string describing\
    \ the clock type (see\nAppendix A).\nbegin primary-clock-update procedure\n  \
    \      <$Eroman peer.leap~<<-~\"from\"~radio~or~operator>;       /* copy\nvariables\
    \ */\n        <$Eroman peer.peeraddr~<<-~ASCII~identifier>;\n        <$Eroman\
    \ peer.rec~<<-~radio~timestamp>;\n        <$Eroman peer.reach~<<-~1>;\n      \
    \  call clock-filter(<$Eroman {sys.clock~-~peer.rec,~0,~1~<<\n<<~peer.precision}>);\
    \   /* process sample */\n        call clock-update;                         \
    \     /* update local\nclock */\n        end primary-clock-update procedure;\n\
    Initialization Procedures\nThe initialization procedures are used to set up and\
    \ initialize the\nsystem, its peers and associations.\n Initialization Procedure\n\
    The initialization procedure is called upon reboot or restart of the NTP\ndaemon.\
    \ The local clock is presumably undefined at reboot; however, in\nsome equipment\
    \ an estimate is available from the reboot environment,\nsuch as a battery-backed\
    \ clock/calendar. The precision variable is\ndetermined by the intrinsic architecture\
    \ of the local hardware clock.\nThe authentication variables are used only if\
    \ the authentication\nmechanism described in Appendix C is implemented. The values\
    \ of these\nvariables are determined using procedures beyond the scope of NTP\n\
    itself.\nbegin initialization procedure\n        #ifdef (authentication implemented)\
    \     / * see Appendix C */\n                <$Eroman sys.keys~<<-~as~required>;\n\
    \                #endef;\n        <$Eroman sys.leap~<<-~11 sub 2>;           \
    \                     \n/* copy variables */\n        <$Eroman sys.stratum~<<-~0~(undefined)>;\n\
    \        <$Eroman sys.precision~<<-~host~precision>;\n        <$Eroman sys.rootdelay~<<-~0~(undefined)>;\n\
    \        <$Eroman sys.rootdispersion~<<-~0~(undefined)>;\n        <$Eroman sys.refid~<<-~0~(undefined)>;\n\
    \        <$Eroman sys.reftime~<<-~0~(undefined)>;\n        <$Eroman sys.clock~<<-~external~reference>;\n\
    \        <$Eroman sys.peer~<<-~roman NULL>;\n        <$Eroman sys.poll~<<-~roman\
    \ NTP.MINPOLL>;\n        for (all configured peers)                      /* create\n\
    configured associations */\n                call initialization-instantiation\
    \ procedure;\n        end initialization procedure;\n Initialization-Instantiation\
    \ Procedure\nThis implementation-specific procedure is called from the initialization\n\
    procedure to define an association. The addresses and modes of the peers\nare\
    \ determined using information read during the reboot procedure or as\nthe result\
    \ of operator commands. The authentication variables are used\nonly if the authentication\
    \ mechanism described in Appendix C is\nimplemented. The values of these variables\
    \ are determined using\nprocedures beyond the scope of NTP itself. With the authentication\
    \ bits\nset as suggested, only properly authenticated peers can become the\nsynchronization\
    \ source.\nbegin initialization-instantiation procedure\n        <$Eroman peer.config~<<-~1>;\n\
    \        #ifdef (authentication implemented)     /* see Appendix C */\n      \
    \          <$Eroman peer.authenable~<<-~1~(suggested)>;\n                <$Eroman\
    \ peer.authentic~<<-~0>;\n                <$Eroman peer.hostkeyid~<<-~as~required>;\n\
    \                <$Eroman peer.peerkeyid~<<-~0>;\n                #endef;\n  \
    \      <$Eroman peer.peeraddr~<<-~peer~IP~address>;    /* copy\nvariables */\n\
    \        <$Eroman peer.peerport~<<-~roman NTP.PORT>;\n        <$Eroman peer.hostaddr~<<-~host~IP~address>;\n\
    \        <$Eroman peer.hostport~<<-~roman NTP.PORT>;\n        <$Eroman peer.mode~<<-~host~mode>;\n\
    \        <$Eroman peer.peerpoll~<<-~0~(undefined)>;\n        <$Eroman peer.timer~<<-~0>;\n\
    \        <$Eroman peer.delay~<<-~0~(undefined)>;\n        <$Eroman peer.offset~<<-~0~(undefined)>;\n\
    \        call clear;                                     /* initialize\nassociation\
    \ */\n        end initialization-instantiation procedure;\n Receive-Instantiation\
    \ Procedure\nThe receive-instantiation procedure is called from the receive procedure\n\
    when a new peer is discovered. It initializes the peer variables and\nmobilizes\
    \ the association. If the message is from a peer operating in\nclient mode (3),\
    \ the host mode is set to server mode (4); otherwise, it\nis set to symmetric\
    \ passive mode (2). The authentication variables are\nused only if the authentication\
    \ mechanism described in Appendix C is\nimplemented. If implemented, only properly\
    \ authenticated non-configured\npeers can become the synchronization source.\n\
    begin receive-instantiation procedure\n        #ifdef (authentication implemented)\
    \     /* see Appendix C */\n                <$Eroman peer.authenable~<<-~0>;\n\
    \                <$Eroman peer.authentic~<<-~0>;\n                <$Eroman peer.hostkeyid~<<-~as~required>;\n\
    \                <$Eroman peer.peerkeyid~<<-~0>;\n                #endef\n   \
    \     <$Eroman peer.config~<<-~0>;                            /* copy\nvariables\
    \ */\n        <$Eroman peer.peeraddr~<<-~roman pkt.peeraddr>;\n        <$Eroman\
    \ peer.peerport~<<-~roman pkt.peerport>;\n        <$Eroman peer.hostaddr~<<-~roman\
    \ pkt.hostaddr>;\n        <$Eroman peer.hostport~<<-~roman pkt.hostport>;\n  \
    \      if (pkt.mode = 3)                               /* determine\nmode */\n\
    \                <$Eroman peer.mode~<<-~4>;\n                else\n          \
    \      <$Eroman peer.mode~<<-~2>;\n        <$Eroman peer.peerpoll~<<-~0~(undefined)>;\n\
    \        <$Eroman peer.timer~<<-~0>;\n        <$Eroman peer.delay~<<-~0~(undefined)>;\n\
    \        <$Eroman peer.offset~<<-~0~(undefined)>;\n        call clear;       \
    \                              /* initialize\nassociation */\n        end receive-instantiation\
    \ procedure;\n Primary Clock-Instantiation Procedure\nThis procedure is called\
    \ from the initialization procedure in order to\nset up the state variables for\
    \ the primary clock. The value for\npeer.precision is determined from the radio\
    \ clock specification and\nhardware interface. The value for peer.rootdispersion\
    \ is nominally ten\ntimes the inherent maximum error of the radio clock; for instance,\n\
    <$E10~mu s> for a calibrated atomic clock, 10 ms for a WWVB or GOES\nradio clock\
    \ and 100 ms for a less accurate WWV radio clock.\nbegin clock-instantiation procedure\n\
    \        <$Eroman peer.config~<<-~1>;                            /* copy\nvariables\
    \ */\n        <$Eroman peer.peeraddr~<<-~0~undefined>;\n        <$Eroman peer.peerport~<<-~0~(not~used)>;\n\
    \        <$Eroman peer.hostaddr~<<-~0~(not~used)>;\n        <$Eroman peer.hostport~<<-~0~(not~used)>;\n\
    \        <$Eroman peer.leap~<<-~11 sub 2>;\n        <$Eroman peer.mode~<<-~0~(not~used)>;\n\
    \        <$Eroman peer.stratum~<<-~0>;\n        <$Eroman peer.peerpoll~<<-~0~(undefined)>;\n\
    \        <$Eroman peer.precision~<<-~clock~precision>;\n        <$Eroman peer.rootdelay~<<-~0>;\n\
    \        <$Eroman peer.rootdispersion~<<-~clock~dispersion>;\n        <$Eroman\
    \ peer.refid~<<-~0~(not~used)>;\n        <$Eroman peer.reftime~<<-~0~(undefined)>;\n\
    \        <$Eroman peer.timer~<<-~0>;\n        <$Eroman peer.delay~<<-~0~(undefined)>;\n\
    \        <$Eroman peer.offset~<<-~0~(undefined)>;\n        call clear;       \
    \                              /* initialize\nassociation */\n        end clock-instantiation\
    \ procedure;\nIn some configurations involving a calibrated atomic clock or LORAN-C\n\
    receiver, the primary reference source may provide only a seconds pulse,\nbut\
    \ lack a complete timecode from which the numbering of the seconds,\netc., can\
    \ be derived. In these configurations seconds numbering can be\nderived from other\
    \ sources, such as a radio clock or even other NTP\npeers. In these configurations\
    \ the primary clock variables should\nreflect the primary reference source, not\
    \ the seconds-numbering source;\nhowever, if the seconds-numbering source fails\
    \ or is known to be\noperating incorrectly, updates from the primary reference\
    \ source should\nbe suppressed as if it had failed.\nClear Procedure\nThe clear\
    \ procedure is called when some event occurs that results in a\nsignificant change\
    \ in reachability state or potential disruption of the\nlocal clock.\nbegin clear\
    \ procedure\n        <$Eroman peer.org~<<-~0~(undefined)>;                   /*\
    \ mark\ntimestamps undefined */\n        <$Eroman peer.rec~<<-~0~(undefined)>;\n\
    \        <$Eroman peer.xmt~<<-~0~(undefined)>;\n        <$Eroman peer.reach~<<-~0>;\
    \                             /* reset\nstate variables */\n        <$Eroman peer.filter~<<-~[0,~,0,~roman\
    \ NTP.MAXDISPERSE]>;   /*\nall stages */\n        <$Eroman peer.valid~<<-~0>;\n\
    \        <$Eroman peer.dispersion~<<-~roman NTP.MAXDISPERSE>;\n        <$Eroman\
    \ {peer.hostpoll~<<-~NTP.MINPOLL}>;              /* reset\npoll interval */\n\
    \        call poll-update;\n        call clock-select;                       \
    \       /* select clock\nsource */\n        end clear procedure;\nPoll-Update\
    \ Procedure\nThe poll-update procedure is called when a significant event occurs\
    \ that\nmay result in a change of the poll interval or peer timer. It checks the\n\
    values of the host poll interval (peer.hostpoll) and peer poll interval\n(peer.peerpoll)\
    \ and clamps each within the valid range. If the peer is\nselected for synchronization,\
    \ the value is further clamped as a function\nof the computed compliance (see\
    \ Section 5).\nbegin poll-update procedure\n        <$Etemp~<<-~roman peer.hostpoll>;\
    \                       /*\ndetermine host poll interval */\n        if (<$Epeer~=~roman\
    \ sys.peer>)\n                <$Etemp~<<-~min (temp,~roman {sys.poll,~NTP.MAXPOLL)}>;\n\
    \        else\n                <$Etemp~<<-~min (temp,~roman NTP.MAXPOLL)>;\n \
    \       <$Eroman peer.hostpoll~<<-~max (temp,~roman NTP.MINPOLL)>;\n        <$Etemp~<<-~1~<<\
    \ << ~min ( roman {peer.hostpoll,~max\n(peer.peerpoll,~NTP.MINPOLL)})>;\nIf the\
    \ poll interval is unchanged and the peer timer is zero, the timer\nis simply\
    \ reset. If the poll interval is changed and the new timer value\nis greater than\
    \ the present value, no additional action is necessary;\notherwise, the peer timer\
    \ must be reduced. When the peer timer must be\nreduced it is important to discourage\
    \ tendencies to synchronize\ntransmissions between the peers. A prudent precaution\
    \ is to randomize\nthe first transmission after the timer is reduced, for instance\
    \ by the\nsneaky technique illustrated.\n        if (peer.timer = 0)         \
    \                    /* reset peer\ntimer */\n                <$Eroman peer.timer~<<-~temp>;\n\
    \        else if (<$Eroman peer.timer~>>~temp>)\n                <$Eroman peer.timer~<<-~(\
    \ roman sys.clock~&~(temp~-\n~1))~+~1>;\n        end poll-update procedure;\n\
    Synchronization Distance Procedure\nThe distance procedure calculates the synchronization\
    \ distance from the\npeer variables for the peer peer.\nbegin distance(peer) procedure;\n\
    \        <$EDELTA~<<-~roman {peer.rootdelay~+~|peer.delay|}>;\n        <$EEPSILON~<<-~roman\n\
    {peer.rootdispersion~+~peer.dispersion~+~phi (sys.clock~-~peer.update)\n}>;\n\
    \        <$ELAMBDA~<<-~EPSILON~+~{| DELTA |} over 2> ;\n        end distance procedure;\n\
    Note that, while <$EDELTA> may be negative in some cases, both\n<$EEPSILON> and\
    \ <$ELAMBDA> are always positive.\nAccess Control Issues\nThe NTP design is such\
    \ that accidental or malicious data modification\n(tampering) or destruction (jamming)\
    \ at a time server should not in\ngeneral result in timekeeping errors elsewhere\
    \ in the synchronization\nsubnet. However, the success of this approach depends\
    \ on redundant time\nservers and diverse network paths, together with the assumption\
    \ that\ntampering or jamming will not occur at many time servers throughout the\n\
    synchronization subnet at the same time. In principle, the subnet\nvulnerability\
    \ can be engineered through the selection of time servers\nknown to be trusted\
    \ and allowing only those time servers to become the\nsynchronization source.\
    \ The authentication procedures described in\nAppendix C represent one mechanism\
    \ to enforce this; however, the\nencryption algorithms can be quite CPU-intensive\
    \ and can seriously\ndegrade accuracy, unless precautions such as mentioned in\
    \ the\ndescription of the transmit procedure are taken.\nWhile not a required\
    \ feature of NTP itself, some implementations may\ninclude an access-control feature\
    \ that prevents unauthorized access and\ncontrols which peers are allowed to update\
    \ the local clock. For this\npurpose it is useful to distinguish between three\
    \ categories of access:\nthose that are preauthorized as trusted, preauthorized\
    \ as friendly and\nall other (non-preauthorized) accesses. Presumably, preauthorization\
    \ is\naccomplished by entries in the configuration file or some kind of\nticket-management\
    \ system such as Kerberos [STE88]. In this model only\ntrusted accesses can result\
    \ in the peer becoming the synchronization\nsource. While friendly accesses cannot\
    \ result in the peer becoming the\nsynchronization source, NTP messages and timestamps\
    \ are returned as\nspecified.\nIt does not seem useful to maintain a secret clock,\
    \ as would result from\nrestricting non-preauthorized accesses, unless the intent\
    \ is to hide the\nexistence of the time server itself. Well-behaved Internet hosts\
    \ are\nexpected to return an ICMP service-unavailable error message if a\nservice\
    \ is not implemented or resources are not available; however, in\nthe case of\
    \ NTP the resources required are minimal, so there is little\nneed to restrict\
    \ requests intended only to read the clock. A simple but\neffective access-control\
    \ mechanism is then to consider all associations\npreconfigured in a symmetric\
    \ mode or client mode (modes 1, 2 and 3) as\ntrusted and all other associations,\
    \ preconfigured or not, as friendly.\nIf a more comprehensive trust model is required,\
    \ the design can be based\non an access-control list with each entry consisting\
    \ of a 32-bit\nInternet address, 32-bit mask and three-bit mode. If the logical\
    \ AND of\nthe source address (pkt.peeraddr) and the mask in an entry matches the\n\
    corresponding address in the entry and the mode (pkt.mode) matches the\nmode in\
    \ the entry, the access is allowed; otherwise an ICMP error\nmessage is returned\
    \ to the requestor. Through appropriate choice of\nmask, it is possible to restrict\
    \ requests by mode to individual\naddresses, a particular subnet or net addresses,\
    \ or have no restriction\nat all. The access-control list would then serve as\
    \ a filter controlling\nwhich peers could create associations.\nFiltering and\
    \ Selection Algorithms\nA most important factor affecting the accuracy and reliability\
    \ of time\ndistribution is the complex of algorithms used to reduce the effect\
    \ of\nstatistical errors and falsetickers due to failure of various subnet\ncomponents,\
    \ reference sources or propagation media. The algorithms\nsuggested in this section\
    \ were developed and refined over several years\nof operation in the Internet\
    \ under widely varying topologies, speeds and\ntraffic regimes. While these algorithms\
    \ are believed the best available\nat the present time, they are not an integral\
    \ part of the NTP\nspecification, since other algorithms with similar or superior\n\
    performance may be devised in future.\nHowever, it is important to observe that\
    \ not all time servers or clients\nin an NTP synchronization subnet must implement\
    \ these algorithms. For\ninstance, simple workstations may dispense with one or\
    \ both of them in\nthe interests of simplicity if accuracy and reliability requirements\n\
    justify. Nevertheless, it would be expected that an NTP server providing\nsynchronization\
    \ to a sizable community, such as a university campus or\nresearch laboratory,\
    \ would be expected to implement these algorithms or\nothers proved to have equivalent\
    \ functionality. A comprehensive\ndiscussion of the design principles and performance\
    \ is given in\n[MIL91a].\nIn order for the NTP filter and selection algorithms\
    \ to operate\neffectively, it is useful to have a measure of recent sample variance\n\
    recorded for each peer. The measure adopted is based on first-order\ndifferences,\
    \ which are easy to compute and effective for the purposes\nintended. There are\
    \ two measures, one called the filter dispersion\n<$Eepsilon sub sigma> and the\
    \ other the select dispersion <$Eepsilon sub\nxi>. Both are computed as the weighted\
    \ sum of the clock offsets in a\ntemporary list sorted by synchronization distance.\
    \ If <$Etheta sub i\n~(0~<<=~i~<<~n)> is the offset of the ith entry, then the\
    \ sample\ndifference <$Eepsilon sub ij> of the ith entry relative to the jth entry\n\
    is defined <$Eepsilon sub ij~<~>=~| theta sub i~-~theta sub j |> . The\ndispersion\
    \ relative to the jth entry is defined <$Eepsilon sub j> and\ncomputed as the\
    \ weighted sum\n<$Eepsilon sub j~=~sum from {i~=~0} to {n~-~1}~epsilon sub ij~w~sup\n\
    {i+1}> ,\nwhere w is a weighting factor chosen to control the influence of\nsynchronization\
    \ distance in the dispersion budget. In the NTP algorithms\nw is chosen less than\
    \ <$E1 / 2>: <$Ew~=~roman NTP.FILTER> for filter\ndispersion and <$Ew~=~roman\
    \ NTP.SELECT> for select dispersion. The\n(absolute) dispersion <$Eepsilon sub\
    \ sigma> and <$Eepsilon sub xi> as\nused in the NTP algorithms are defined relative\
    \ to the 0th entry\n<$Eepsilon sub 0>.\nThere are two procedures described in\
    \ the following, the clock-filter\nprocedure, which is used to select the best\
    \ offset samples from a given\nclock, and the clock-selection procedure, which\
    \ is used to select the\nbest clock among a hierarchical set of clocks.\nClock-Filter\
    \ Procedure\nThe clock-filter procedure is executed upon arrival of an NTP message\
    \ or\nother event that results in new data samples. It takes arguments of the\n\
    form (<$Etheta ,~delta ,~epsilon>), where <$Etheta> is a sample clock\noffset\
    \ measurement and <$Edelta> and <$Eepsilon> are the associated\nroundtrip delay\
    \ and dispersion. It determines the filtered clock offset\n(peer.offset), roundtrip\
    \ delay (peer.delay) and dispersion\n(peer.dispersion). It also updates the dispersion\
    \ of samples already\nrecorded and saves the current time (peer.update).\nThe\
    \ basis of the clock-filter procedure is the filter shift register\n(peer.filter),\
    \ which consists of NTP.SHIFT stages, each stage containing\na 3-tuple <$E[ theta\
    \ sub i ,~delta sub i ,~epsilon sub i ]>, with\nindices numbered from zero on\
    \ the left. The filter is initialized with\nthe value <$E[0,~0,~roman NTP.MAXDISPERSE]>\
    \ in all stages by the clear\nprocedure. New data samples are shifted into the\
    \ filter at the left end,\ncausing first NULLs then old samples to fall off the\
    \ right end. The\npacket procedure provides samples of the form (<$Etheta ,~delta\n\
    ,~epsilon>) as new updates arrive, while the transmit procedure provides\nsamples\
    \ of the form <$E[0,~0,~roman NTP.MAXDISPERSE]> when two poll\nintervals elapse\
    \ without a fresh update. While the same symbols\n(<$Etheta ,~delta ,~epsilon>)\
    \ are used here for the arguments, clock-\nfilter contents and peer variables,\
    \ the meaning will be clear from\ncontext. The following pseudo-code describes\
    \ this procedure.\nbegin clock-filter procedure (<$Etheta ,~delta ,~epsilon>)\n\
    The dispersion <$Eepsilon sub i> for all valid samples in the filter\nregister\
    \ must be updated to account for the skew-error accumulation\nsince the last update.\
    \ These samples are also inserted on a temporary\nlist with entry format <$E[distance,index]>.\
    \ The samples in the register\nare shifted right one stage, with the overflow\
    \ sample discarded and the\nnew sample inserted at the leftmost stage. The temporary\
    \ list is then\nsorted by increasing distance. If no samples remain in the list,\
    \ the\nprocedure exits without updating the peer variables.\n        for (i from\
    \ NTP.SIZE <196> 1 to 1) begin        /* update\ndispersion */\n             \
    \   <$E[ theta sub i ,~delta sub i ,~epsilon sub i ]~<<-~[\ntheta sub {i-1} ,~delta\
    \ sub {i-1} ,~epsilon sub {i-1} ]>;               \n/* shift stage right */\n\
    \                <$Eepsilon sub i~=~epsilon sub i~+~phi tau>;\n              \
    \  add <$E[ lambda sub i~==~epsilon sub i~+~{| delta  sub i\n|} over 2 ,~i]> to\
    \ temporary list;\n                endfor;\n        <$E[ theta sub 0 ,~delta sub\
    \ 0 ,~epsilon sub 0 ]~<<-~[ theta\n,~delta ,~epsilon ]>;                   /*\
    \ insert new sample */\n        add <$E[ lambda~==~epsilon~+~{| delta |} over\
    \ 2 ,~0]> to\ntemporary list;\n        <$Eroman peer.update~<<-~roman sys.clock>;\
    \                      \n/* reset base time */\n        sort temporary list by\
    \ increasing <$E[distance~||index]>;\nwhere <$E[distance~||index]> represents\
    \ the concatenation of the\ndistance and index fields and distance is the high-order\
    \ field. The\nfilter dispersion <$Eepsilon sub sigma> is computed and included\
    \ in the\npeer dispersion. Note that for this purpose the temporary list is\n\
    already sorted.\n        <$Eepsilon sub sigma~<<-~0>;\n        for (i from NTP.SHIFT<196>1\
    \ to 0)               /* compute\nfilter dispersion */\n                if (<$Eroman\
    \ peer.dispersion sub index[i]~>>=~roman\nNTP.MAXDISPERSE> or\n              \
    \          <$E| theta sub i~-~theta sub 0 |~>>~roman\nNTP.MAXDISPERSE>)\n    \
    \                    <$Eepsilon sub sigma~<~><<-~( epsilon sub\nsigma~+~roman\
    \ NTP.MAXDISPERSE)~times~roman NTP.FILTER>;\n                else\n          \
    \              <$Eepsilon sub sigma~<~><<-~( epsilon sub\nsigma~+~| theta sub\
    \ i~-~theta sub 0 |)~times~roman NTP.FILTER>;\nThe peer offset <$Etheta sub 0>,\
    \ delay <$Edelta sub 0> and dispersion\n<$Eepsilon sub 0> are chosen as the values\
    \ corresponding to the minimum-\ndistance sample; in other words, the sample corresponding\
    \ to the first\nentry on the temporary list, here represented as the 0th subscript.\n\
    \        <$Eroman peer.offset~<<-~theta sub 0>;                          \n/*\
    \ update peer variables */\n        <$Eroman peer.delay~<<-~delta sub 0>;\n  \
    \      <$Eroman peer.dispersion~<<-~min ( epsilon sub 0~+~epsilon sub\nsigma ,~roman\
    \ NTP.MAXDISPERSE)>;\n        end clock-filter procedure\nThe peer.offset and\
    \ peer.delay variables represent the clock offset and\nroundtrip delay of the\
    \ local clock relative to the peer clock. Both of\nthese are precision quantities\
    \ and can usually be averaged over long\nintervals in order to improve accuracy\
    \ and stability without bias\naccumulation (see Appendix H). The peer.dispersion\
    \ variable represents\nthe maximum error due to measurement error, skew-error\
    \ accumulation and\nsample variance. All three variables are used in the clock-selection\
    \ and\nclock-combining procedures to select the peer clock(s) used for\nsynchronization\
    \ and to maximize the accuracy and stability of the\nindications.\nClock-Selection\
    \ Procedure\nThe clock-selection procedure uses the peer variables <$ETHETA>,\n\
    <$EDELTA>, <$EEPSILON> and <$Etau> and is called when these variables\nchange\
    \ or when the reachability status changes. It consists of two\nalgorithms, the\
    \ intersection algorithm and the clustering algorithm. The\nintersection algorithm\
    \ constructs a list of candidate peers eligible to\nbecome the synchronization\
    \ source, computes a confidence interval for\neach and casts out falsetickers\
    \ using a technique adapted from Marzullo\nand Owicki [MAR85]. The clustering\
    \ algorithm sorts the list of surviving\ncandidates in order of stratum and synchronization\
    \ distance and\nrepeatedly casts out outlyers on the basis of select dispersion\
    \ until\nonly the most accurate, precise and stable survivors are left. A bit\
    \ is\nset for each survivor to indicate the outcome of the selection process.\n\
    The system variable sys.peer is set as a pointer to the most likely\nsurvivor,\
    \ if there is one, or to the NULL value if not.\nIntersection Algorithm\n    \
    \    begin clock-selection procedure\nEach peer is examined in turn and added\
    \ to an endpoint list only if it\npasses several sanity checks designed to avoid\
    \ loops and use of\nexceptionally noisy data. If no peers survive the sanity checks,\
    \ the\nprocedure exits without finding a synchronization source. For each of m\n\
    survivors three entries of the form <$E[endpoint,~type]> are added to\nthe endpoint\
    \ list: <$E[ THETA~-~LAMBDA ,~-~1]>, <$E[ THETA ,~0]> and\n<$E[ THETA~+~LAMBDA\
    \ ,~1]>. There will be <$E3 m> entries on the list,\nwhich is then sorted by increasing\
    \ endpoint.\n        <$Em~<<-~0>;\n        for (each peer)                   \
    \      /* calling all peers */\n                if (<$Eroman {peer.reach~!=~0~bold\n\
    and~peer.dispersion~<<~NTP.MAXDISPERSE}> and\n                        not (peer.stratum\
    \ >> 1 and peer.refid =\npeer.hostaddr)) begin\n                        <$ELAMBDA~<MO>\n\
    <~>an distance (peer)>;                 /* make list entry */\n              \
    \          add <$E[ THETA~-~LAMBDA ,~-1]> to endpoint list;\n                \
    \        add <$E[ THETA ,~0]> to endpoint list;\n                        add <$E[\
    \ THETA~+~LAMBDA ,~1]> to endpoint list;\n                        <$Em~<<-~m~+~1>;\n\
    \                        <B>endif\n                endfor\n        if (<$Em~=~0>)\
    \ begin                            /* skedaddle if\nno candidates */\n       \
    \         <$Eroman sys.peer~<<-~roman NULL>;\n                <$Eroman sys.stratum~<<-~0~(undefined)>;\n\
    \                exit;\n                endif\n        sort endpoint list by increasing\
    \ endpoint||type;\nThe following algorithm is adapted from DTS [DEC89] and is\
    \ designed to\nproduce the largest single intersection containing only truechimers.\
    \ The\nalgorithm begins by initializing a value f and counters i and c to zero.\n\
    Then, starting from the lowest endpoint of the sorted endpoint list, for\neach\
    \ entry <$E[endpoint,~type]> the value of type is subtracted from the\ncounter\
    \ i, which is the number of intersections. If type is zero,\nincrement the value\
    \ of c, which is the number of falsetickers (see\nAppendix H). If <$Ei~>>=~m~-~f>\
    \ for some entry, endpoint of that entry\nbecomes the lower endpoint of the intersection;\
    \ otherwise, f is\nincreased by one and the above procedure is repeated. Without\
    \ resetting\nf or c, a similar procedure is used to find the upper endpoint, except\n\
    that the value of type is added to the counter.. If after both endpoints\nhave\
    \ been determined <$Ec~<<=~f>, the procedure continues having found\n<$Em~-~f>\
    \ truechimers; otherwise, f is increased by one and the entire\nprocedure is repeated.\n\
    \        for (f from 0 to <$Ef~>>=~m over 2>) begin              /*\ncalling all\
    \ truechimers */\n                <$Ec~<<-~0>;\n                <$Ei~<<-~0>;\n\
    \                for (each [endpoint, type] from lowest) begin   /* find\nlow\
    \ endpoint */\n                        <$Ei~<<-~i~-~type>;\n                 \
    \       <$Elow~<<-~endpoint>;\n                        if (<$Ei~>>=~m~-~f>) break;\n\
    \                        if (<$Etype~=~0>) <$Ec~<<-~c~+~1>;\n                \
    \        endfor;\n                <$Ei~<<-~0>;\n                for (each [endpoint,\
    \ type] from highest) begin  /* find\nhigh endpoint */\n                     \
    \   <$Ei~<<-~i~+~type>;\n                        <$Ehigh~<<-~endpoint>;\n    \
    \                    if (<$Ei~>>=~m~-~f>) break;\n                        if (<$Etype~=~0>)\
    \ <$Ec~<<-~c~+~1>;\n                        endfor;\n                if (<$Ec~<<=~f>)\
    \ break;                 /* continue\nuntil all falsetickers found */\n      \
    \          endfor;\n        if (<$Elow~>>~high>) begin                       \
    \       /* quit\nif no intersection found */\n                <$Eroman sys.peer~<<-~roman\
    \ NULL>;\n                exit;\n                endif;\nNote that processing\
    \ continues past this point only if there are more\nthan <$Em over 2> intersections.\
    \ However, it is possible, but not highly\nlikely, that there may be fewer than\
    \ <$Em over 2> truechimers remaining\nin the intersection.\nClustering Algorithm\n\
    In the original DTS algorithm the clock-selection procedure exits at\nthis point\
    \ with the presumed correct time set midway in the computed\nintersection <$E[low,~high]>.\
    \ However, this can lead to a considerable\nloss in accuracy and stability, since\
    \ the individual peer statistics are\nlost. Therefore, in NTP the candidates that\
    \ survived the preceding steps\nare processed further. The candidate list is rebuilt\
    \ with entries of the\nform <$E[distance,~index]>, where distance is computed\
    \ from the (scaled)\npeer stratum and synchronization distance <$ELAMBDA>. The\
    \ scaling factor\nprovides a mechanism to weight the combination of stratum and\
    \ distance.\nOrdinarily, the stratum will dominate, unless one or more of the\n\
    survivors has an exceptionally high distance. The list is then sorted by\nincreasing\
    \ distance.\n        <$Em~<<-~0>;\n        for (each peer) begin             \
    \      /* calling all peers */\n                if (<$Elow~<<=~theta~<<=~high>)\
    \ begin\n                        <$ELAMBDA~<<-~roman distance (peer)>;       \
    \    \n/* make list entry */\n                        <$Edist~<<-~roman\n{peer.stratum~times~NTP.MAXDISPERSE~+~LAMBDA\
    \ }>\n                        add <$E[ dist ,~peer]> to candidate list;\n    \
    \                    <$Em~<<-~m~+~1>;\n                        endif;\n      \
    \          endfor;\n        sort candidate list by increasing dist;\nThe next\
    \ steps are designed to cast out outlyers which exhibit\nsignificant dispersions\
    \ relative to the other members of the candidate\nlist while minimizing wander,\
    \ especially on high-speed LANs with many\ntime servers. Wander causes needless\
    \ network overhead, since the poll\ninterval is clamped at sys.poll as each new\
    \ peer is selected for\nsynchronization and only slowly increases when the peer\
    \ is no longer\nselected. It has been the practical experience that the number\
    \ of\ncandidates surviving to this point can become quite large and can result\n\
    in significant processor cycles without materially enhancing stability\nand accuracy.\
    \ Accordingly, the candidate list is truncated at\nNTP.MAXCLOCK entries.\nNote\
    \ <$Eepsilon sub {xi i}> is the select (sample) dispersion relative\nto the ith\
    \ peer represented on the candidate list, which can be\ncalculated in a manner\
    \ similar to the filter dispersion described\npreviously. The <$EEPSILON sub j>\
    \ is the dispersion of the jth peer\nrepresented on the list and includes components\
    \ due to measurement\nerror, skew-error accumulation and filter dispersion. If\
    \ the maximum\n<$Eepsilon sub {xi i}> is greater than the minimum <$EEPSILON sub\
    \ j> and\nthe number of survivors is greater than NTP.MINCLOCK, the ith peer is\n\
    discarded from the list and the procedure is repeated. If the current\nsynchronization\
    \ source is one of the survivors and there is no other\nsurvivor of lower stratum,\
    \ then the procedure exits without doing\nanything further. Otherwise, the synchronization\
    \ source is set to the\nfirst survivor on the candidate list. In the following\
    \ i, j, k, l are\npeer indices, with k the index of the current synchronization\
    \ source\n(NULL if none) and l the index of the first survivor on the candidate\n\
    list.\n        while begin\n                for (each survivor <$E[distance,~index]>)\
    \ begin /*\ncompute dispersions */\n                        find index i for max\
    \ <$Eepsilon sub {xi i}>;\n                        find index j for min <$EEPSILON\
    \ sub j>;\n                        endfor\n                if (<$Eepsilon sub\
    \ {xi i}~<<=~EPSILON sub j> or\n<$Em~<<=~roman NTP.MINCLOCK>) break;\n       \
    \         <$Eroman peer.survivor [i]~<<-~0> ;             /*\ndiscard ith peer\
    \ */\n                if (<$Ei~=~k>) <$Eroman sys.peer~<<-~roman NULL>;\n    \
    \            delete the ith peer from the candidate list;\n                <$Em~<<-~m~-~1>;\n\
    \                endwhile\n        if (<$Eroman peer.survivor [k]~=~0> or <$Eroman\
    \ peer.stratum\n[k]~>>~roman peer.stratum [l]>) begin\n                <$Eroman\
    \ sys.peer~<<-~l>;                               \n/* new clock source */\n  \
    \              call poll-update;\n                endif\n        end clock-select\
    \ procedure;\nThe algorithm is designed to favor those peers near the head of\
    \ the\ncandidate list, which are at the lowest stratum and distance and\npresumably\
    \ can provide the most accurate and stable time. With proper\nselection of weight\
    \ factor v (also called NTP.SELECT), entries will be\ntrimmed from the tail of\
    \ the list, unless a few outlyers disagree\nsignificantly with respect to the\
    \ remaining entries, in which case the\noutlyers are discarded first. The termination\
    \ condition is designed to\navoid needless switching between synchronization sources\
    \ when not\nstatistically justified, yet maintain a bias toward the low-stratum,\n\
    low-distance peers.\nLocal Clocks\nIn order to implement a precise and accurate\
    \ local clock, the host must\nbe equipped with a hardware clock consisting of\
    \ an oscillator and\ninterface and capable of the required precision and stability.\
    \ A logical\nclock is then constructed using these components plus software\n\
    components that adjust the apparent time and frequency in response to\nperiodic\
    \ updates computed by NTP or some other time-synchronization\nprotocol such as\
    \ Hellospeak [MIL83b] or the Unix 4.3bsd TSP [GUS85a].\nThis section describes\
    \ the Fuzzball local-clock model and\nimplementation, which includes provisions\
    \ for precise time and frequency\nadjustment and can maintain time to within 15\
    \ ns and frequency to within\n0.3 ms per day. The model is suitable for use with\
    \ both compensated and\nuncompensated quartz oscillators and can be adapted to\
    \ power-frequency\noscillators. A summary of the characteristics of these and\
    \ other types\nof oscillators can be found in Appendix E, while a comprehensive\n\
    mathematical analysis of the NTP local-clock model can be found in\nAppendix G.\n\
    It is important to note that the particular implementation described is\nonly\
    \ one of possibly many implementations that provide equivalent\nfunctionality.\
    \ However, it is equally important to note that the clock\nmodel described in\
    \ Appendix G and which is the basis of the\nimplementation involves a particular\
    \ kind of control-feedback loop that\nis potentially unstable if the design rules\
    \ are broken. The model and\nparameter described in Appendix G are designed to\
    \ provide accurate and\nstable time under typical operating conditions using conventional\n\
    hardware and in the face of disruptions in hardware or network\nconnectivity.\
    \ The parameters have been engineered for reliable operation\nin a multi-level\
    \ hierarchical subnet where unstable operation at one\nlevel can disrupt possibly\
    \ many other levels.\nFuzzball Implementation\nThe Fuzzball local clock consists\
    \ of a collection of hardware and\nsoftware registers, together with a set of\
    \ algorithms, which implement a\nlogical clock that functions as a disciplined\
    \ oscillator and\nsynchronizes to an external source. Following is a description\
    \ of its\ncomponents and manner of operation. Note that all arithmetic is two's\n\
    complement integer and all shifts <169><<<<<170> and <169>>>>><170> are\narithmetic\
    \ (sign-fill for right shifts and zero-fill for left shifts).\nAlso note that\
    \ <$Ex~<< <<~n> is equivalent to <$Ex~>> >>~-~n>.\nThe principal components of\
    \ the local clock are shown in Figure\n3,<$&fig3> in which the fraction points\
    \ shown are relative to whole\nmilliseconds. The 48-bit Clock register and 32-bit\
    \ Prescaler function as\na disciplined oscillator which increments in milliseconds\
    \ relative to\nmidnight at the fraction point. The 32-bit Clock-Adjust register\
    \ is used\nto adjust the oscillator phase in gradual steps to avoid discontinuities\n\
    in the indicated timescale. Its contents are designated x in the\nfollowing. The\
    \ 32-bit Skew-Compensation register is used to trim the\noscillator frequency\
    \ by adding small phase increments at periodic\nadjustment intervals and can compensate\
    \ for frequency errors as much as\n.01% or <F128M><F255D>100 ppm. Its contents\
    \ are designated y in the\nfollowing. The 16-bit Watchdog counter and 32-bit Compliance\
    \ register\nare used to determine validity, as well as establish the PLL bandwidth\n\
    and poll interval (see Appendix G). The contents of the Compliance\nregister are\
    \ designated z in the following. The 32-bit PPS-Adjust\nregister is used to hold\
    \ a precision time adjustment when a source of 1-\npps pulses is available, while\
    \ the 8-bit PPS counter is used to verify\npresence of these pulses. The two-bit\
    \ Flags register contains the two\nleap bits described elsewhere (leap).\nAll\
    \ registers except the Prescaler register are ordinarily implemented\nin memory.\
    \ In typical clock interface designs such as the DEC KWV11-C,\nthe Prescaler register\
    \ is implemented as a 16-bit buffered counter\ndriven by a quartz-controlled oscillator\
    \ at some multiple of 1000 Hz. A\ncounter overflow is signalled by an interrupt,\
    \ which results in an\nincrement of the Clock register at the bit corresponding\
    \ to the\noverflow. The time of day is determined by reading the Prescaler\nregister,\
    \ which does not disturb the counting process, and adding its\nvalue to that of\
    \ the Clock register with fraction points aligned as\nshown and with unimplemented\
    \ low-order bits set to zero. In other\ninterface designs, such as the LSI-11\
    \ event-line mechanism, each tick of\nthe clock is signalled by an interrupt at\
    \ intervals of 16-2/3 ms or 20\nms, depending on interface and mains frequency.\
    \ When this occurs the\nappropriate increment in fractional milliseconds is added\
    \ to the Clock\nregister.\nThe various parameters used are summarized in Table\
    \ 6, in which certain\nparameters have been rescaled from those given in Appendix\
    \ G due to the\nunits here being in milliseconds.<$&tab6> When the system is\n\
    initialized, all registers and counters are cleared and the leap bits\nset to\
    \ 112 (unsynchronized). At adjustment intervals of CLOCK.ADJ\nseconds CLOCK.ADJ\
    \ is subtracted from the PPS counter, but only if the\nprevious contents of the\
    \ PPS counter are greater than zero. Also,\nCLOCK.ADJ is added to the Watchdog\
    \ counter, but the latter is clamped\nnot to exceed NTP.MAXAGE divided by CLOCK.ADJ\
    \ (one full day). In\naddition, if the Watchdog counter reaches this value, the\
    \ leap bits are\nset to 112 (unsynchronized).\nIn some system configurations a\
    \ precise source of timing information is\navailable in the form of a train of\
    \ timing pulses spaced at one-second\nintervals. Usually, this is in addition\
    \ to a source of timecode\ninformation, such as a radio clock or even NTP itself,\
    \ to number the\nseconds, minutes, hours and days. In typical clock interface\
    \ designs\nsuch as the DEC KWV11-C, a special input is provided which can trigger\n\
    an interrupt as each pulse is received. When this happens the PPS\ncounter is\
    \ set to CLOCK.PPS and the current time offset is determined in\nthe usual way.\
    \ Then, the PPS-Adjust register is set to the time offset\nscaled to milliseconds.\
    \ Finally, if the PPS-Adjust register is greater\nthan or equal to 500, 1000 is\
    \ subtracted from its contents. As described\nbelow, the PPS-Adjust register and\
    \ PPS counters can be used in\nconjunction with an ordinary timecode to produce\
    \ an extremely accurate\nlocal clock.\nGradual Phase Adjustments\nLeft uncorrected,\
    \ the local clock runs at the offset and frequency\nresulting from its last update.\
    \ An update is produced by an event that\nresults in a valid clock selection.\
    \ It consists of a signed 48-bit\ninteger in whole milliseconds and fraction,\
    \ with fraction point to the\nleft of bit 32. If the magnitude is greater than\
    \ the maximum aperture\nCLOCK.MAX, a step adjustment is required, in which case\
    \ proceed as\ndescribed later. Otherwise, a gradual phase adjustment is performed.\n\
    Normally, the update is computed by the NTP algorithms described\npreviously;\
    \ however, if the PPS counter is greater than zero, the value\nof the PPS-Adjust\
    \ register is used instead. Let u be a 32-bit quantity\nwith bits 0-31 set as\
    \ bits 16-47 of the update. If some of the low-order\nbits of the update are unimplemented,\
    \ they are set as the value of the\nsign bit. These operations move the fraction\
    \ point of u to the left of\nbit 16 and minimize the effects of truncation and\
    \ roundoff errors. Let b\nbe the number of leading zeros of the absolute value\
    \ of the Compliance\nregister and let c be the number of leading zeros of the\
    \ Watchdog\ncounter, both of which are easily computed by compact loops. Then,\
    \ set b\nto\n<$Eb~=~b~-~16~+~roman CLOCK.COMP>\nand clamp it to be not less than\
    \ zero. This represents the logarithm of\nthe loop time constant. Then, set c\
    \ to\n<$Ec~=~10~-~c>\nand clamp it to be not greater than NTP.MAXPOLL <196> NTP.MINPOLL.\
    \ This\nrepresents the logarithm of the integration interval since the last\n\
    update. The clamps insure stable operation under typical conditions\nencountered\
    \ in the Internet. Then, compute new values for the Clock-\nAdjust and Skew-Compensation\
    \ registers\n<$Ex~=~u~>> >>~b> ,\n<$Ey~=~y~+~(u~>> >>~(b~+~b~-~c))> .\nFinally,\
    \ compute the exponential average\n<$Ez~=~z~+~(u~<< <<~(b~+~ roman CLOCK.MULT)~-~z)~>>\
    \ >>~ roman\nCLOCK.WEIGHT> ,\nwhere the left shift realigns the fraction point\
    \ for greater precision\nand ease of computation.\nAt each adjustment interval\
    \ the final clock correction consisting of two\ncomponents is determined. The\
    \ first (phase) component consists of the\nquantity\n<$Ex~>> >>~ roman CLOCK.PHASE>\
    \ ,\nwhich is then subtracted from the previous contents of the Clock-Adjust\n\
    register to form the new contents of that register. The second\n(frequency) component\
    \ consists of the quantity\n<$Ey~>> >>~ roman CLOCK.FREQ> .\nThe sum of the phase\
    \ and frequency components is the final clock\ncorrection, which is then added\
    \ to the Clock register. FInally, the\nWatchdog counter is set to zero. Operation\
    \ continues in this way until a\nnew correction is introduced.\nThe value of b\
    \ computed above can be used to update the poll interval\nsystem variable (sys.poll).\
    \ This functions as an adaptive parameter that\nprovides a very valuable feature\
    \ which reduces the polling overhead,\nespecially if the clock-combining algorithm\
    \ described in Appendix F is\nused:\n<$Eroman sys.poll~<<-~b~+~roman NTP.MINPOLL>\
    \ .\nUnder conditions when update noise is high or the hardware oscillator\nfrequency\
    \ is changing relatively rapidly due to environmental\nconditions, the magnitude\
    \ of the compliance increases. With the\nparameters specified, this causes the\
    \ loop bandwidth (reciprocal of time\nconstant) to increase and the poll interval\
    \ to decrease, eventually to\nNTP.MINPOLL seconds. When noise is low and the hardware\
    \ oscillator very\nstable, the compliance decreases, which causes the loop bandwidth\
    \ to\ndecrease and the poll interval to increase, eventually to NTP.MAXPOLL\n\
    seconds.\nThe parameters in Table 6 have been selected so that, under good\nconditions\
    \ with updates in the order of a few milliseconds, a precision\nof a millisecond\
    \ per day (about .01 ppm or 10-8), can be achieved. Care\nis required in the implementation\
    \ to insure monotonicity of the Clock\nregister and to preserve the highest precision\
    \ while minimizing the\npropagation of roundoff errors. Since all of the multiply/divide\n\
    operations (except those involved with the 1-pps pulses) computed in\nreal time\
    \ can be approximated by bitwise-shift operations, it is not\nnecessary to implement\
    \ a full multiply/divide capability in hardware or\nsoftware.\nIn the various\
    \ implementations of NTP for many Unix-based systems it has\nbeen the common experience\
    \ that the single most important factor\naffecting local-clock stability is the\
    \ matching of the phase and\nfrequency coefficients to the particular kernel implementation.\
    \ It is\nvital that these coefficients be engineered according to the model\n\
    values, for otherwise the PLL can fail to track normal oscillator\nvariations\
    \ and can even become unstable.\nStep Phase Adjustments\nWhen the magnitude of\
    \ a correction exceeds the maximum aperture\nCLOCK.MAX, the possibility exists\
    \ that the clock is so far out of\nsynchronization with the reference source that\
    \ the best action is an\nimmediate and wholesale replacement of Clock register\
    \ contents, rather\nthan in gradual adjustments as described above. However, in\
    \ cases where\nthe sample variance is extremely high, it is prudent to disbelieve\
    \ a\nstep change, unless a significant interval has elapsed since the last\ngradual\
    \ adjustment. Therefore, if a step change is indicated and the\nWatchdog counter\
    \ is less than the preconfigured value CLOCK.MINSTEP, the\nupdate is ignored and\
    \ the local-clock procedure exits. These safeguards\nare especially useful in\
    \ those system configurations using a calibrated\natomic clock or LORAN-C receiver\
    \ in conjunction with a separate source\nof seconds-numbering information, such\
    \ as a radio clock or NTP peer.\nIf a step change is indicated the update is added\
    \ directly to the Clock\nregister and the Clock-Adjust register and Watchdog counter\
    \ both set to\nzero, but the other registers are left undisturbed. Since a step\
    \ change\ninvalidates data currently in the clock filters, the leap bits are set\n\
    to 112 (unsynchronized) and, as described elsewhere, the clear procedure\nis called\
    \ to purge the clock filters and state variables for all peers.\nIn practice,\
    \ the necessity to perform a step change is rare and usually\noccurs when the\
    \ local host or reference source is rebooted, for example.\nThis is fortunate,\
    \ since step changes can result in the local clock\napparently running backward,\
    \ as well as incorrect delay and offset\nmeasurements of the synchronization mechanism\
    \ itself.\nConsiderable experience with the Internet environment suggests the\n\
    values of CLOCK.MAX tabulated in Table 6 as appropriate. In practice,\nthese values\
    \ are exceeded with a single time-server source only under\nconditions of the\
    \ most extreme congestion or when multiple failures of\nnodes or links have occurred.\
    \ The most common case when the maximum is\nexceeded is when the time-server source\
    \ is changed and the time\nindicated by the new and old sources exceeds the maximum\
    \ due to\nsystematic errors in the primary reference source or large differences\n\
    in path delays. It is recommended that implementations include\nprovisions to\
    \ tailor CLOCK.MAX for specific situations. The amount that\nCLOCK.MAX can be\
    \ increased without violating the monotonicity\nrequirement depends on the Clock\
    \ register increment. For an increment of\n10 ms, as used in many workstations,\
    \ the value shown in Table 6 can be\nincreased by a factor of five.\nImplementation\
    \ Issues\nThe basic NTP robustness model is that a host has no other means to\n\
    verify time other than NTP itself. In some equipment a battery-backed\nclock/calendar\
    \ is available for a sanity check. If such a device is\navailable, it should be\
    \ used only to confirm sanity of the timekeeping\nsystem, not as the source of\
    \ system time. In the common assumption (not\nalways justified) that the clock/calendar\
    \ is more reliable, but less\naccurate, than the NTP synchronization subnet, the\
    \ recommended approach\nat initialization is to set the Clock register as determined\
    \ from the\nclock/calendar and the other registers, counters and flags as described\n\
    above. On subsequent updates if the time offset is greater than a\nconfiguration\
    \ parameter (e.g., 1000 seconds), then the update should be\ndiscarded and an\
    \ error condition reported. Some implementations\nperiodically record the contents\
    \ of the Skew-Compensation register in\nstable storage such as a system file or\
    \ NVRAM and retrieve this value at\ninitialization. This can significantly reduce\
    \ the time to converge to\nthe nominal stability and accuracy regime.\nConversion\
    \ from NTP format to the common date and time formats used by\napplication programs\
    \ is simplified if the internal local-clock format\nuses separate date and time\
    \ variables. The time variable is designed to\nroll over at 24 hours, give or\
    \ take a leap second as determined by the\nleap-indicator bits, with its overflows\
    \ (underflows) incrementing\n(decrementing) the date variable. The date and time\
    \ variables then\nindicate the number of days and seconds since some previous\
    \ reference\ntime, but uncorrected for intervening leap seconds.\nOn the day prior\
    \ to the insertion of a leap second the leap bits\n(sys.leap) are set at the primary\
    \ servers, presumably by manual means.\nSubsequently, these bits show up at the\
    \ local host and are passed to the\nlocal-clock procedure. This causes the modulus\
    \ of the time variable,\nwhich is the length of the current day, to be increased\
    \ or decreased by\none second as appropriate. Immediately following insertion\
    \ the leap bits\nare reset. Additional discussion on this issue can be found in\
    \ Appendix\nE.\nLack of a comprehensive mechanism to administer the leap bits\
    \ in the\nprimary servers is presently an awkward problem better suited to a\n\
    comprehensive network-management mechanism yet to be developed. As a\npractical\
    \ matter and unless specific provisions have been made\notherwise, currently manufactured\
    \ radio clocks have no provisions for\nleap seconds, either automatic or manual.\
    \ Thus, when a leap actually\noccurs, the radio must resynchronize to the broadcast\
    \ timecode, which\nmay take from a few minutes to some hours. Unless special provisions\
    \ are\nmade, a primary server might leap to the new timescale, only to be\nyanked\
    \ back to the previous timescale when it next synchronizes to the\nradio. Subsequently,\
    \ the server will be yanked forward again when the\nradio itself resynchronizes\
    \ to the broadcast timecode.\nThis problem can not be reliably avoided using any\
    \ selection algorithm,\nsince there will always exist an interval of at least\
    \ a couple of\nminutes and possibly as much as some hours when some or all radios\
    \ will\nbe out of synchronization with the broadcast timecode and only after the\n\
    majority of them have resynchronized will the subnet settle down. The\nCLOCK.MINSTEP\
    \ delay is designed to cope with this problem by forcing a\nminimum interval since\
    \ the last gradual adjustment was made before\nallowing a step change to occur.\
    \ Therefore, until the radio\nresynchronizes, it will continue on the old timescale,\
    \ which is one\nsecond off the local clock after the leap and outside the maximum\n\
    aperture CLOCK.MAX permitted for gradual phase adjustments. When the\nradio eventually\
    \ resynchronizes, it will almost certainly come up within\nthe aperture and again\
    \ become the reference source. Thus, even in the\nunlikely case when the local\
    \ clock incorrectly leaps, the server will go\nno longer than CLOCK.MINSTEP seconds\
    \ before resynchronizing.\nAcknowledgments\nMany people contributed to the contents\
    \ of this document, which was\nthoroughly debated by electronic mail and debugged\
    \ using two different\nprototype implementations for the Unix 4.3bsd operating\
    \ system, one\nwritten by Louis Mamakos and Michael Petry of the University of\
    \ Maryland\nand the other by Dennis Ferguson of the University of Toronto. Another\n\
    implementation for the Fuzzball operating system [MIL88b] was written by\nthe\
    \ author. Many individuals to numerous to mention meticulously tested\nthe several\
    \ beta-test prototype versions and ruthlessly smoked out the\nbugs, both in the\
    \ code and the specification. Especially useful were\ncomments from Dennis Ferguson\
    \ and Bill Sommerfeld, as well as\ndiscussions with Joe Comuzzi and others at\
    \ Digital Equipment\nCorporation.\nReferences\n[ABA89]\nAbate, et al. AT&T's new\
    \ approach to the synchronization of\ntelecommunication networks. IEEE Communications\
    \ Magazine (April 1989),\n35-45.\n[ALL74a]\nAllan, D.W., J.H. Shoaf and D. Halford.\
    \ Statistics of time and frequency\ndata analysis. In: Blair, B.E. (Ed.). Time\
    \ and Frequency Theory and\nFundamentals. National Bureau of Standards Monograph\
    \ 140, U.S.\nDepartment of Commerce, 1974, 151-204.\n[ALL74b]\nAllan, D.W., J.E.\
    \ Gray and H.E. Machlan. The National Bureau of\nStandards atomic time scale:\
    \ generation, stability, accuracy and\naccessibility. In: Blair, B.E. (Ed.). Time\
    \ and Frequency Theory and\nFundamentals. National Bureau of Standards Monograph\
    \ 140, U.S.\nDepartment of Commerce, 1974, 205-231.\n[BEL86]\nBell Communications\
    \ Research. Digital Synchronization Network Plan.\nTechnical Advisory TA-NPL-000436,\
    \ 1 November 1986.\n[BER87]\nBertsekas, D., and R. Gallager. Data Networks. Prentice-Hall,\
    \ Englewood\nCliffs, NJ, 1987.\n[BLA74]\nBlair, B.E. Time and frequency dissemination:\
    \ an overview of principles\nand techniques. In: Blair, B.E. (Ed.). Time and Frequency\
    \ Theory and\nFundamentals. National Bureau of Standards Monograph 140, U.S.\n\
    Department of Commerce, 1974, 233-314.\n[BRA80]\nBraun, W.B. Short term frequency\
    \ effects in networks of coupled\noscillators. IEEE Trans. Communications COM-28,\
    \ 8 (August 1980), 1269-\n1275.\n[COL88]\nCole, R., and C. Foxcroft. An experiment\
    \ in clock synchronisation. The\nComputer Journal 31, 6 (1988), 496-502.\n[DAR81a]\n\
    Defense Advanced Research Projects Agency. Internet Protocol. DARPA\nInstitute,\
    \ September 1981.\n[DAR81b]\nDefense Advanced Research Projects Agency. Internet\
    \ Control Message\nProtocol. DARPA Network Working Group Report RFC-792, USC Information\n\
    Sciences Institute, September 1981.\n[DEC89]\nDigital Time Service Functional\
    \ Specification Version T.1.0.5. Digital\nEquipment Corporation, 1989.\n[DER90]\n\
    Dershowitz, N., and E.M. Reingold. Calendrical Calculations. Software\nPractice\
    \ and Experience 20, 9 (September 1990), 899-928.\n[FRA82]\nFrank, R.L. History\
    \ of LORAN-C. Navigation 29, 1 (Spring 1982).\n[GUS84]\nGusella, R., and S. Zatti.\
    \ TEMPO - A network time controller for a\ndistributed Berkeley UNIX system. IEEE\
    \ Distributed Processing Technical\nCommittee Newsletter 6, NoSI-2 (June 1984),\
    \ 7-15. Also in: Proc. Summer\nUSENIX Conference (June 1984, Salt Lake City).\n\
    [GUS85a]\nGusella, R., and S. Zatti. The Berkeley UNIX 4.3BSD time synchronization\n\
    protocol: protocol specification. Technical Report UCB/CSD 85/250,\nUniversity\
    \ of California, Berkeley, June 1985.\n[GUS85b]\nGusella, R., and S. Zatti. An\
    \ election algorithm for a distributed clock\nsynchronization program. Technical\
    \ Report UCB/CSD 86/275, University of\nCalifornia, Berkeley, December 1985.\n\
    [HAL84]\nHalpern, J.Y., B. Simons, R. Strong and D. Dolly. Fault-tolerant clock\n\
    synchronization. Proc. Third Annual ACM Symposium on Principles of\nDistributed\
    \ Computing (August 1984), 89-102.\n[JOR85]\nJordan, E.C. (Ed). Reference Data\
    \ for Engineers, Seventh Edition. H.W.\nSams & Co., New York, 1985.\n[KOP87]\n\
    Kopetz, H., and W. Ochsenreiter. Clock synchronization in distributed\nreal-time\
    \ systems. IEEE Trans. Computers C-36, 8 (August 1987), 933-939.\n[LAM78]\nLamport,\
    \ L., Time, clocks and the ordering of events in a distributed\nsystem. Comm.\
    \ ACM 21, 7 (July 1978), 558-565.\n[LAM85]\nLamport, L., and P.M. Melliar-Smith.\
    \ Synchronizing clocks in the\npresence of faults. J. ACM 32, 1 (January 1985),\
    \ 52-78.\n[LIN80]\nLindsay, W.C., and A.V. Kantak. Network synchronization of\
    \ random\nsignals. IEEE Trans. Communications COM-28, 8 (August 1980), 1260-1266.\n\
    [LUN84]\nLundelius, J., and N.A. Lynch. A new fault-tolerant algorithm for clock\n\
    synchronization. Proc. Third Annual ACM Symposium on Principles of\nDistributed\
    \ Computing (August 1984), 75-88.\n[MAR85]\nMarzullo, K., and S. Owicki. Maintaining\
    \ the time in a distributed\nsystem. ACM Operating Systems Review 19, 3 (July\
    \ 1985), 44-54.\n[MIL81a]\nMills, D.L. Time Synchronization in DCNET Hosts. DARPA\
    \ Internet Project\nReport IEN-173, COMSAT Laboratories, February 1981.\n[MIL81b]\n\
    Mills, D.L. DCNET Internet Clock Service. DARPA Network Working Group\nReport\
    \ RFC-778, COMSAT Laboratories, April 1981.\n[MIL83a]\nMills, D.L. Internet Delay\
    \ Experiments. DARPA Network Working Group\nReport RFC-889, M/A-COM Linkabit,\
    \ December 1983.\n[MIL83b]\nMills, D.L. DCN local-network protocols. DARPA Network\
    \ Working Group\nReport RFC-891, M/A-COM Linkabit, December 1983.\n[MIL85a]\n\
    Mills, D.L. Algorithms for synchronizing network clocks. DARPA Network\nWorking\
    \ Group Report RFC-956, M/A-COM Linkabit, September 1985.\n[MIL85b]\nMills, D.L.\
    \ Experiments in network clock synchronization. DARPA Network\nWorking Group Report\
    \ RFC-957, M/A-COM Linkabit, September 1985.\n[MIL85c]\nMills, D.L. Network Time\
    \ Protocol (NTP). DARPA Network Working Group\nReport RFC-958, M/A-COM Linkabit,\
    \ September 1985.\n[MIL88a]\nMills, D.L. Network Time Protocol (version 1) - specification\
    \ and\nimplementation. DARPA Network Working Group Report RFC-1059, University\n\
    of Delaware, July 1988.\n[MIL88b]\nMills, D.L. The Fuzzball. Proc. ACM SIGCOMM\
    \ 88 Symposium (Palo Alto, CA,\nAugust 1988), 115-122.\n[MIL89]\nMills, D.L. Network\
    \ Time Protocol (version 2) - specification and\nimplementation. DARPA Network\
    \ Working Group Report RFC-1119, University\nof Delaware, September 1989.\n[MIL90]\n\
    Mills, D.L. Measured performance of the Network Time Protocol in the\nInternet\
    \ system. ACM Computer Communication Review 20, 1 (January 1990),\n65-75.\n[MIL91a]\n\
    Mills, D.L. Internet time synchronization: the Network Time Protocol.\nIEEE Trans.\
    \ Communications 39, 10 (October 1991), 1482-1493.\n[MIL91b]\nMills, D.L. On the\
    \ chronology and metrology of computer network\ntimescales and their application\
    \ to the Network Time Protocol. ACM\nComputer Communications Review 21, 5 (October\
    \ 1991), 8-17.\n[MIT80]\nMitra, D. Network synchronization: analysis of a hybrid\
    \ of master-slave\nand mutual synchronization. IEEE Trans. Communications COM-28,\
    \ 8 (August\n1980), 1245-1259.\n[NBS77]\nData Encryption Standard. Federal Information\
    \ Processing Standards\nPublication 46. National Bureau of Standards, U.S. Department\
    \ of\nCommerce, 1977.\n[NBS79]\nTime and Frequency Dissemination Services. NBS\
    \ Special Publication 432,\nU.S. Department of Commerce, 1979.\n[NBS80]\nDES Modes\
    \ of Operation. Federal Information Processing Standards\nPublication 81. National\
    \ Bureau of Standards, U.S. Department of\nCommerce, December 1980.\n[POS80]\n\
    Postel, J. User Datagram Protocol. DARPA Network Working Group Report\n[POS83a]\n\
    Postel, J. Daytime protocol. DARPA Network Working Group Report RFC-867,\nUSC\
    \ Information Sciences Institute, May 1983.\n[POS83b]\nPostel, J. Time protocol.\
    \ DARPA Network Working Group Report RFC-868,\nUSC Information Sciences Institute,\
    \ May 1983.\n[RIC88]\nRickert, N.W. Non Byzantine clock synchronization - a programming\n\
    experiment. ACM Operating Systems Review 22, 1 (January 1988), 73-78.\n[SCH86]\n\
    Schneider, F.B. A paradigm for reliable clock synchronization.\nDepartment of\
    \ Computer Science Technical Report TR 86-735, Cornell\nUniversity, February 1986.\n\
    [SMI86]\nSmith, J. Modern Communications Circuits. McGraw-Hill, New York, NY,\n\
    1986.\n[SRI87]\nSrikanth, T.K., and S. Toueg. Optimal clock synchronization. J.\
    \ ACM 34,\n3 (July 1987), 626-645.\n[STE88]\nSteiner, J.G., C. Neuman, and J.I.\
    \ Schiller. Kerberos: an authentication\nservice for open network systems. Proc.\
    \ Winter USENIX Conference\n(February 1988).\n[SU81]\nSu, Z. A specification of\
    \ the Internet protocol (IP) timestamp option.\nDARPA Network Working Group Report\
    \ RFC-781. SRI International, May 1981.\n[TRI86]\nTripathi, S.K., and S.H. Chang.\
    \ ETempo: a clock synchronization\nalgorithm for hierarchical LANs - implementation\
    \ and measurements.\nSystems Research Center Technical Report TR-86-48, University\
    \ of\nMaryland, 1986.\n[VAN84]\nVan Dierendonck, A.J., and W.C. Melton. Applications\
    \ of time transfer\nusing NAVSTAR GPS. In: Global Positioning System, Papers Published\
    \ in\nNavigation, Vol. II, Institute of Navigation, Washington, DC, 1984.\n[VAS78]\n\
    Vass, E.R. OMEGA navigation system: present status and plans 1977-1980.\nNavigation\
    \ 25, 1 (Spring 1978).\nAppendix A. NTP Data Format - Version 3\nThe format of\
    \ the NTP Message data area, which immediately follows the\nUDP header, is shown\
    \ in Figure 4<$&fig4>. Following is a description of\nits fields.\nLeap Indicator\
    \ (LI): This is a two-bit code warning of an impending leap\nsecond to be inserted/deleted\
    \ in the last minute of the current day,\nwith bit 0 and bit 1, respectively,\
    \ coded as follows:\n@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E8),\
    \ WIDTH(5.0000),\nABOVE(.0830), BELOW(.0830), HGUTTER(.0560), KEEP(OFF), ALIGN(CT)\n\
    @Z_TBL_BODY = TABLE TEXT, TABLE TEXT\n00, no warning\n01, last minute has 61 seconds\n\
    10, last minute has 59 seconds)\n11, alarm condition (clock not synchronized)\n\
    @Z_TBL_END =\nVersion Number (VN): This is a three-bit integer indicating the\
    \ NTP\nversion number, currently three (3).\nMode: This is a three-bit integer\
    \ indicating the mode, with values\ndefined as follows:\n@Z_TBL_BEG = COLUMNS(2),\
    \ DIMENSION(IN), COLWIDTHS(E1,E8), WIDTH(5.0000),\nABOVE(.0830), BELOW(.0830),\
    \ HGUTTER(.0560), KEEP(OFF), ALIGN(CT)\n@Z_TBL_BODY = TABLE TEXT, TABLE TEXT\n\
    0, reserved\n1, symmetric active\n2, symmetric passive\n3, client\n4, server\n\
    5, broadcast\n6, reserved for NTP control message (see Appendix B)\n7, reserved\
    \ for private use\n@Z_TBL_END =\nStratum: This is a eight-bit integer indicating\
    \ the stratum level of the\nlocal clock, with values defined as follows:\n@Z_TBL_BEG\
    \ = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E8), WIDTH(5.0000),\nABOVE(.0830),\
    \ BELOW(.0830), HGUTTER(.0560), KEEP(OFF), ALIGN(CT)\n@Z_TBL_BODY = TABLE TEXT,\
    \ TABLE TEXT\n0, unspecified\n1, primary reference (e.g.,, radio clock)\n2-255,\
    \ secondary reference (via NTP)\n@Z_TBL_END =\nThe values that can appear in this\
    \ field range from zero to NTP.INFIN\ninclusive.\nPoll Interval: This is an eight-bit\
    \ signed integer indicating the\nmaximum interval between successive messages,\
    \ in seconds to the nearest\npower of two. The values that can appear in this\
    \ field range from\nNTP.MINPOLL to NTP.MAXPOLL inclusive.\nPrecision: This is\
    \ an eight-bit signed integer indicating the precision\nof the local clock, in\
    \ seconds to the nearest power of two.\nRoot Delay: This is a 32-bit signed fixed-point\
    \ number indicating the\ntotal roundtrip delay to the primary reference source,\
    \ in seconds with\nfraction point between bits 15 and 16. Note that this variable\
    \ can take\non both positive and negative values, depending on clock precision\
    \ and\nskew.\nRoot Dispersion: This is a 32-bit signed fixed-point number indicating\n\
    the maximum error relative to the primary reference source, in seconds\nwith fraction\
    \ point between bits 15 and 16. Only positive values greater\nthan zero are possible.\n\
    particular reference clock. In the case of stratum 0 (unspecified) or\nstratum\
    \ 1 (primary reference), this is a four-octet, left-justified,\nzero-padded ASCII\
    \ string. While not enumerated as part of the NTP\nspecification, the following\
    \ are suggested ASCII identifiers:\n@Z_TBL_BEG = COLUMNS(3), DIMENSION(IN), COLWIDTHS(E2,E2,E5),\n\
    WIDTH(4.6700), ABOVE(.1670), BELOW(.0830), HGUTTER(.3330),\nBOX(Z_SINGLE), KEEP(ON),\
    \ ALIGN(CT), L1(R1C0..R1C3)\n@Z_TBL_BODY = TABLE HEADER, TABLE HEADER, TABLE HEADER\n\
    Stratum, Code, Meaning\n@Z_TBL_BODY = TABLE TEXT, TABLE TEXT, TABLE TEXT\n0, DCN,\
    \ DCN routing protocol\n0, NIST, NIST public modem\n0, TSP, TSP time protocol\n\
    0, DTS, Digital Time Service\n1, ATOM, Atomic clock (calibrated)\n1, VLF, VLF\
    \ radio (OMEGA,, etc.)\n1, callsign, Generic radio\n1, LORC, LORAN-C radionavigation\n\
    1, GOES, GOES UHF environment satellite\n@Z_TBL_BODY = TABLE HEADER, TABLE HEADER,\
    \ TABLE HEADER\n1, GPS, GPS UHF satellite positioning\n@Z_TBL_END =\nIn the case\
    \ of stratum 2 and greater (secondary reference) this is the\nfour-octet Internet\
    \ address of the primary reference host.\nlast set or corrected, in 64-bit timestamp\
    \ format.\nOriginate Timestamp: This is the local time at which the request\n\
    departed the client host for the service host, in 64-bit timestamp\nformat.\n\
    Receive Timestamp: This is the local time at which the request arrived\nat the\
    \ service host, in 64-bit timestamp format.\nTransmit Timestamp: This is the local\
    \ time at which the reply departed\nthe service host for the client host, in 64-bit\
    \ timestamp format.\nAuthenticator (optional): When the NTP authentication mechanism\
    \ is\nimplemented, this contains the authenticator information defined in\nAppendix\
    \ C.\nAppendix B. NTP Control Messages\nIn a comprehensive network-management\
    \ environment, facilities are\npresumed available to perform routine NTP control\
    \ and monitoring\nfunctions, such as setting the leap-indicator bits at the primary\n\
    servers, adjusting the various system parameters and monitoring regular\noperations.\
    \ Ordinarily, these functions can be implemented using a\nnetwork-management protocol\
    \ such as SNMP and suitable extensions to the\nMIB database. However, in those\
    \ cases where such facilities are not\navailable, these functions can be implemented\
    \ using special NTP control\nmessages described herein. These messages are intended\
    \ for use only in\nsystems where no other management facilities are available\
    \ or\nappropriate, such as in dedicated-function bus peripherals. Support for\n\
    these messages is not required in order to conform to this\nspecification.\nThe\
    \ NTP Control Message has the value 6 specified in the mode field of\nthe first\
    \ octet of the NTP header and is formatted as shown below. The\nformat of the\
    \ data field is specific to each command or response;\nhowever, in most cases\
    \ the format is designed to be constructed and\nviewed by humans and so is coded\
    \ in free-form ASCII. This facilitates\nthe specification and implementation of\
    \ simple management tools in the\nabsence of fully evolved network-management\
    \ facilities. As in ordinary\nNTP messages, the authenticator field follows the\
    \ data field. If the\nauthenticator is used the data field is zero-padded to a\
    \ 32-bit\nboundary, but the padding bits are not considered part of the data field\n\
    and are not included in the field count.\nIP hosts are not required to reassemble\
    \ datagrams larger than 576\noctets; however, some commands or responses may involve\
    \ more data than\nwill fit into a single datagram. Accordingly, a simple reassembly\n\
    feature is included in which each octet of the message data is numbered\nstarting\
    \ with zero. As each fragment is transmitted the number of its\nfirst octet is\
    \ inserted in the offset field and the number of octets is\ninserted in the count\
    \ field. The more-data (M) bit is set in all\nfragments except the last.\nMost\
    \ control functions involve sending a command and receiving a\nresponse, perhaps\
    \ involving several fragments. The sender chooses a\ndistinct, nonzero sequence\
    \ number and sets the status field and R and E\nbits to zero. The responder interprets\
    \ the opcode and additional\ninformation in the data field, updates the status\
    \ field, sets the R bit\nto one and returns the three 32-bit words of the header\
    \ along with\nadditional information in the data field. In case of invalid message\n\
    format or contents the responder inserts a code in the status field,\nsets the\
    \ R and E bits to one and, optionally, inserts a diagnostic\nmessage in the data\
    \ field.\nSome commands read or write system variables and peer variables for\
    \ an\nassociation identified in the command. Others read or write variables\n\
    associated with a radio clock or other device directly connected to a\nsource\
    \ of primary synchronization information. To identify which type of\nvariable\
    \ and association a 16-bit association identifier is used. System\nvariables are\
    \ indicated by the identifier zero. As each association is\nmobilized a unique,\
    \ nonzero identifier is created for it. These\nidentifiers are used in a cyclic\
    \ fashion, so that the chance of using an\nold identifier which matches a newly\
    \ created association is remote. A\nmanagement entity can request a list of current\
    \ identifiers and\nsubsequently use them to read and write variables for each\
    \ association.\nAn attempt to use an expired identifier results in an exception\n\
    response, following which the list can be requested again.\nSome exception events,\
    \ such as when a peer becomes reachable or\nunreachable, occur spontaneously and\
    \ are not necessarily associated with\na command. An implementation may elect\
    \ to save the event information for\nlater retrieval or to send an asynchronous\
    \ response (called a trap) or\nboth. In case of a trap the IP address and port\
    \ number is determined by\na previous command and the sequence field is set as\
    \ described below.\nCurrent status and summary information for the latest exception\
    \ event is\nreturned in all normal responses. Bits in the status field indicate\n\
    whether an exception has occurred since the last response and whether\nmore than\
    \ one exception has occurred.\nCommands need not necessarily be sent by an NTP\
    \ peer, so ordinary\naccess-control procedures may not apply; however, the optional\n\
    mask/match mechanism suggested elsewhere in this document provides the\ncapability\
    \ to control access by mode number, so this could be used to\nlimit access for\
    \ control messages (mode 6) to selected address ranges.\nNTP Control Message Format\n\
    The format of the NTP Control Message header, which immediately follows\nthe UDP\
    \ header, is shown in Figure 5<$&fig5>. Following is a description\nof its fields.\
    \ Bit positions marked as zero are reserved and should\nalways be transmitted\
    \ as zero.\nVersion Number (VN): This is a three-bit integer indicating the NTP\n\
    version number, currently three (3).\nMode: This is a three-bit integer indicating\
    \ the mode. It must have the\nvalue 6, indicating an NTP control message.\nResponse\
    \ Bit (R): Set to zero for commands, one for responses.\nError Bit (E): Set to\
    \ zero for normal response, one for error response.\nMore Bit (M): Set to zero\
    \ for last fragment, one for all others.\nOperation Code (Op): This is a five-bit\
    \ integer specifying the command\nfunction. Values currently defined include the\
    \ following:\n@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E8), WIDTH(5.0000),\n\
    ABOVE(.0830), BELOW(.0830), HGUTTER(.0560), KEEP(OFF), ALIGN(CT)\n@Z_TBL_BODY\
    \ = TABLE TEXT, TABLE TEXT\n0, reserved\n1, read status command/response\n2, read\
    \ variables command/response\n3, write variables command/response\n4, read clock\
    \ variables command/response\n5, write clock variables command/response\n6, set\
    \ trap address/port command/response\n7, trap response\n8-31, reserved\n@Z_TBL_END\
    \ =\nSequence: This is a 16-bit integer indicating the sequence number of the\n\
    command or response.\nStatus: This is a 16-bit code indicating the current status\
    \ of the\nsystem, peer or clock, with values coded as described in following\n\
    sections.\nAssociation ID: This is a 16-bit integer identifying a valid\nassociation.\n\
    Offset: This is a 16-bit integer indicating the offset, in octets, of\nthe first\
    \ octet in the data area.\nCount: This is a 16-bit integer indicating the length\
    \ of the data field,\nin octets.\nData: This contains the message data for the\
    \ command or response. The\nmaximum number of data octets is 468.\nAuthenticator\
    \ (optional): When the NTP authentication mechanism is\nimplemented, this contains\
    \ the authenticator information defined in\nAppendix C.\nStatus Words\nStatus\
    \ words indicate the present status of the system, associations and\nclock. They\
    \ are designed to be interpreted by network-monitoring\nprograms and are in one\
    \ of four 16-bit formats shown in Figure 6<$&fig6>\nand described in this section.\
    \ System and peer status words are\nassociated with responses for all commands\
    \ except the read clock\nvariables, write clock variables and set trap address/port\
    \ commands. The\nassociation identifier zero specifies the system status word,\
    \ while a\nnonzero identifier specifies a particular peer association. The status\n\
    word returned in response to read clock variables and write clock\nvariables commands\
    \ indicates the state of the clock hardware and\ndecoding software. A special\
    \ error status word is used to report\nmalformed command fields or invalid values.\n\
    System Status Word\nThe system status word appears in the status field of the\
    \ response to a\nread status or read variables command with a zero association\n\
    identifier. The format of the system status word is as follows:\nLeap Indicator\
    \ (LI): This is a two-bit code warning of an impending leap\nsecond to be inserted/deleted\
    \ in the last minute of the current day,\nwith bit 0 and bit 1, respectively,\
    \ coded as follows:\n@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E8),\
    \ WIDTH(5.0000),\nABOVE(.0830), BELOW(.0830), HGUTTER(.0560), KEEP(OFF), ALIGN(CT)\n\
    @Z_TBL_BODY = TABLE TEXT, TABLE TEXT\n00, no warning\n01, last minute has 61 seconds\n\
    10, last minute has 59 seconds)\n11, alarm condition (clock not synchronized)\n\
    @Z_TBL_END =\nClock Source: This is a six-bit integer indicating the current\n\
    synchronization source, with values coded as follows:\n@Z_TBL_BEG = COLUMNS(2),\
    \ DIMENSION(IN), COLWIDTHS(E1,E8), WIDTH(5.0000),\nABOVE(.0830), BELOW(.0830),\
    \ HGUTTER(.0560), KEEP(OFF), ALIGN(CT)\n@Z_TBL_BODY = TABLE TEXT, TABLE TEXT\n\
    0, unspecified or unknown\n1, Calibrated atomic clock (e.g.,, HP 5061)\n2, VLF\
    \ (band 4) or LF (band 5) radio (e.g.,, OMEGA,, WWVB)\n3, HF (band 7) radio (e.g.,,\
    \ CHU,, MSF,, WWV/H)\n4, UHF (band 9) satellite (e.g.,, GOES,, GPS)\n5, local\
    \ net (e.g.,, DCN,, TSP,, DTS)\n6, UDP/NTP\n7, UDP/TIME\n8, eyeball-and-wristwatch\n\
    9, telephone modem (e.g.,, NIST)\n10-63, reserved\n@Z_TBL_END =\nSystem Event\
    \ Counter: This is a four-bit integer indicating the number\nof system exception\
    \ events occurring since the last time the system\nstatus word was returned in\
    \ a response or included in a trap message.\nThe counter is cleared when returned\
    \ in the status field of a response\nand freezes when it reaches the value 15.\n\
    System Event Code: This is a four-bit integer identifying the latest\nsystem exception\
    \ event, with new values overwriting previous values, and\ncoded as follows:\n\
    @Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E8), WIDTH(5.0000),\nABOVE(.0830),\
    \ BELOW(.0830), HGUTTER(.0560), KEEP(OFF), ALIGN(CT)\n@Z_TBL_BODY = TABLE TEXT,\
    \ TABLE TEXT\n0, unspecified\n1, system restart\n2, system or hardware fault\n\
    3, system new status word (leap bits or synchronization change)\n4, system new\
    \ synchronization source or stratum (sys.peer or sys.stratum\nchange)\n5, system\
    \ clock reset (offset correction exceeds CLOCK.MAX)\n6, system invalid time or\
    \ date (see NTP specification)\n7, system clock exception (see system clock status\
    \ word)\n8-15, reserved\n@Z_TBL_END =\nPeer Status Word\nA peer status word is\
    \ returned in the status field of a response to a\nread status, read variables\
    \ or write variables command and appears also\nin the list of association identifiers\
    \ and status words returned by a\nread status command with a zero association\
    \ identifier. The format of a\npeer status word is as follows:\nPeer Status: This\
    \ is a five-bit code indicating the status of the peer\ndetermined by the packet\
    \ procedure, with bits assigned as follows:\n@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN),\
    \ COLWIDTHS(E1,E8), WIDTH(5.0000),\nABOVE(.0830), BELOW(.0830), HGUTTER(.0560),\
    \ KEEP(OFF), ALIGN(CT)\n@Z_TBL_BODY = TABLE TEXT, TABLE TEXT\n0, configured (peer.config)\n\
    1, authentication enabled (peer.authenable)\n2, authentication okay (peer.authentic)\n\
    3, reachability okay (peer.reach <F128M><F255D> 0)\n4, reserved\n@Z_TBL_END =\n\
    Peer Selection (Sel): This is a three-bit integer indicating the status\nof the\
    \ peer determined by the clock-selection procedure, with values\ncoded as follows:\n\
    @Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E8), WIDTH(5.0000),\nABOVE(.0830),\
    \ BELOW(.0830), HGUTTER(.0560), KEEP(OFF), ALIGN(CT)\n@Z_TBL_BODY = TABLE TEXT,\
    \ TABLE TEXT\n0, rejected\n1, passed sanity checks (tests 1 through 8 in Section\
    \ 3.4.3)\n2, passed correctness checks (intersection algorithm in Section 4.2.1)\n\
    3, passed candidate checks (if limit check implemented)\n4, passed outlyer checks\
    \ (clustering algorithm in Section 4.2.2)\n5, current synchronization source;\
    \ max distance exceeded (if limit check\nimplemented)\n6, current synchronization\
    \ source; max distance okay\n7, reserved\n@Z_TBL_END =\nPeer Event Counter: This\
    \ is a four-bit integer indicating the number of\npeer exception events that occurred\
    \ since the last time the peer status\nword was returned in a response or included\
    \ in a trap message. The\ncounter is cleared when returned in the status field\
    \ of a response and\nfreezes when it reaches the value 15.\nPeer Event Code: This\
    \ is a four-bit integer identifying the latest peer\nexception event, with new\
    \ values overwriting previous values, and coded\nas follows:\n@Z_TBL_BEG = COLUMNS(2),\
    \ DIMENSION(IN), COLWIDTHS(E1,E8), WIDTH(5.0000),\nABOVE(.0830), BELOW(.0830),\
    \ HGUTTER(.0560), KEEP(OFF), ALIGN(CT)\n@Z_TBL_BODY = TABLE TEXT, TABLE TEXT\n\
    0, unspecified\n1, peer IP error\n2, peer authentication failure (peer.authentic\
    \ bit was one now zero)\n3, peer unreachable (peer.reach was nonzero now zero)\n\
    4, peer reachable (peer.reach was zero now nonzero)\n5, peer clock exception (see\
    \ peer clock status word)\n6-15, reserved\n@Z_TBL_END =\nClock Status Word\nThere\
    \ are two ways a reference clock can be attached to a NTP service\nhost, as an\
    \ dedicated device managed by the operating system and as a\nsynthetic peer managed\
    \ by NTP. As in the read status command, the\nassociation identifier is used to\
    \ identify which one, zero for the\nsystem clock and nonzero for a peer clock.\
    \ Only one system clock is\nsupported by the protocol, although many peer clocks\
    \ can be supported. A\nsystem or peer clock status word appears in the status\
    \ field of the\nresponse to a read clock variables or write clock variables command.\n\
    This word can be considered an extension of the system status word or\nthe peer\
    \ status word as appropriate. The format of the clock status word\nis as follows:\n\
    Clock Status: This is an eight-bit integer indicating the current clock\nstatus,\
    \ with values coded as follows:\n@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E8),\
    \ WIDTH(5.0000),\nABOVE(.0830), BELOW(.0830), HGUTTER(.0560), KEEP(OFF), ALIGN(CT)\n\
    @Z_TBL_BODY = TABLE TEXT, TABLE TEXT\n0, clock operating within nominals\n1, reply\
    \ timeout\n2, bad reply format\n3, hardware or software fault\n4, propagation\
    \ failure\n5, bad date format or value\n6, bad time format or value\n7-255, reserved\n\
    @Z_TBL_END =\nClock Event Code: This is an eight-bit integer identifying the latest\n\
    clock exception event, with new values overwriting previous values. When\na change\
    \ to any nonzero value occurs in the radio status field, the\nradio status field\
    \ is copied to the clock event code field and a system\nor peer clock exception\
    \ event is declared as appropriate.\nError Status Word\nAn error status word is\
    \ returned in the status field of an error\nresponse as the result of invalid\
    \ message format or contents. Its\npresence is indicated when the E (error) bit\
    \ is set along with the\nresponse (R) bit in the response. It consists of an eight-bit\
    \ integer\ncoded as follows:\n@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E8),\
    \ WIDTH(5.0000),\nABOVE(.0830), BELOW(.0830), HGUTTER(.0560), KEEP(OFF), ALIGN(CT)\n\
    @Z_TBL_BODY = TABLE TEXT, TABLE TEXT\n0, unspecified\n1, authentication failure\n\
    2, invalid message length or format\n3, invalid opcode\n4, unknown association\
    \ identifier\n5, unknown variable name\n6, invalid variable value\n7, administratively\
    \ prohibited\n8-255, reserved\n@Z_TBL_END =\nCommands\nCommands consist of the\
    \ header and optional data field shown in Figure\n6. When present, the data field\
    \ contains a list of identifiers or\nassignments in the form\n<<identifier>>[=<<value>>],<<identifier>>[=<<value>>],...\n\
    where <<identifier>> is the ASCII name of a system or peer variable\nspecified\
    \ in Table 2 or Table 3 and <<value>> is expressed as a decimal,\nhexadecimal\
    \ or string constant in the syntax of the C programming\nlanguage. Where no ambiguity\
    \ exists, the <169>sys.<170> or\n<169>peer.<170> prefixes shown in Table 2 or\
    \ Table 4 can be suppressed.\nWhitespace (ASCII nonprinting format effectors)\
    \ can be added to improve\nreadability for simple monitoring programs that do\
    \ not reformat the data\nfield. Internet addresses are represented as four octets\
    \ in the form\n[n.n.n.n], where n is in decimal notation and the brackets are\
    \ optional.\nTimestamps, including reference, originate, receive and transmit\
    \ values,\nas well as the logical clock, are represented in units of seconds and\n\
    fractions, preferably in hexadecimal notation, while delay, offset,\ndispersion\
    \ and distance values are represented in units of milliseconds\nand fractions,\
    \ preferably in decimal notation. All other values are\nrepresented as-is, preferably\
    \ in decimal notation.\nImplementations may define variables other than those\
    \ listed in Table 2\nor Table 3. Called extramural variables, these are distinguished\
    \ by the\ninclusion of some character type other than alphanumeric or <169>.<170>\n\
    in the name. For those commands that return a list of assignments in the\nresponse\
    \ data field, if the command data field is empty, it is expected\nthat all available\
    \ variables defined in Table 3 or Table 4 of the NTP\nspecification will be included\
    \ in the response. For the read commands,\nif the command data field is nonempty,\
    \ an implementation may choose to\nprocess this field to individually select which\
    \ variables are to be\nreturned.\nCommands are interpreted as follows:\nRead Status\
    \ (1): The command data field is empty or contains a list of\nidentifiers separated\
    \ by commas. The command operates in two ways\ndepending on the value of the association\
    \ identifier. If this identifier\nis nonzero, the response includes the peer identifier\
    \ and status word.\nOptionally, the response data field may contain other information,\
    \ such\nas described in the Read Variables command. If the association\nidentifier\
    \ is zero, the response includes the system identifier (0) and\nstatus word, while\
    \ the data field contains a list of binary-coded pairs\n<<association identifier>>\
    \ <<status word>>,\none for each currently defined association.\nRead Variables\
    \ (2): The command data field is empty or contains a list\nof identifiers separated\
    \ by commas. If the association identifier is\nnonzero, the response includes\
    \ the requested peer identifier and status\nword, while the data field contains\
    \ a list of peer variables and values\nas described above. If the association\
    \ identifier is zero, the data\nfield contains a list of system variables and\
    \ values. If a peer has been\nselected as the synchronization source, the response\
    \ includes the peer\nidentifier and status word; otherwise, the response includes\
    \ the system\nidentifier (0) and status word.\nWrite Variables (3): The command\
    \ data field contains a list of\nassignments as described above. The variables\
    \ are updated as indicated.\nThe response is as described for the Read Variables\
    \ command.\nRead Clock Variables (4): The command data field is empty or contains\
    \ a\nlist of identifiers separated by commas. The association identifier\nselects\
    \ the system clock variables or peer clock variables in the same\nway as in the\
    \ Read Variables command. The response includes the\nrequested clock identifier\
    \ and status word and the data field contains a\nlist of clock variables and values,\
    \ including the last timecode message\nreceived from the clock.\nWrite Clock Variables\
    \ (5): The command data field contains a list of\nassignments as described above.\
    \ The clock variables are updated as\nindicated. The response is as described\
    \ for the Read Clock Variables\ncommand.\nSet Trap Address/Port (6): The command\
    \ association identifier, status\nand data fields are ignored. The address and\
    \ port number for subsequent\ntrap messages are taken from the source address\
    \ and port of the control\nmessage itself. The initial trap counter for trap response\
    \ messages is\ntaken from the sequence field of the command. The response association\n\
    identifier, status and data fields are not significant. Implementations\nshould\
    \ include sanity timeouts which prevent trap transmissions if the\nmonitoring\
    \ program does not renew this information after a lengthy\ninterval.\nTrap Response\
    \ (7): This message is sent when a system, peer or clock\nexception event occurs.\
    \ The opcode field is 7 and the R bit is set. The\ntrap counter is incremented\
    \ by one for each trap sent and the sequence\nfield set to that value. The trap\
    \ message is sent using the IP address\nand port fields established by the set\
    \ trap address/port command. If a\nsystem trap the association identifier field\
    \ is set to zero and the\nstatus field contains the system status word. If a peer\
    \ trap the\nassociation identifier field is set to that peer and the status field\n\
    contains the peer status word. Optional ASCII-coded information can be\nincluded\
    \ in the data field.\nAppendix C. Authentication Issues\nNTP robustness requirements\
    \ are similar to those of other multiple-peer\ndistributed protocols used for\
    \ network routing, management and file\naccess. These include protection from\
    \ faulty implementations, improper\noperation and possibly malicious replay attacks\
    \ with or without data\nmodification. These requirements are especially stringent\
    \ with\ndistributed protocols, since damage due to failures can propagate\nquickly\
    \ throughout the network, devastating archives, routes and\nmonitoring systems\
    \ and even bring down major portions of the network in\nthe fashion of the classic\
    \ Internet Worm.\nThe access-control mechanism suggested in the NTP specification\
    \ responds\nto these requirements by limiting access to trusted peers. The various\n\
    sanity checks resist most replay and spoofing attacks by discarding old\nduplicates\
    \ and using the originate timestamp as a one-time pad, since it\nis unlikely that\
    \ even a synchronized peer can predict future timestamps\nwith the precision required\
    \ on the basis of past observations alone. In\naddition, the protocol environment\
    \ resists jamming attacks by employing\nredundant time servers and diverse network\
    \ paths. Resistance to\nstochastic disruptions, actual or manufactured, are minimized\
    \ by careful\ndesign of the filtering and selection algorithms.\nHowever, it is\
    \ possible that a determined intruder can disrupt\ntimekeeping operations between\
    \ peers by subtle modifications of NTP\nmessage data, such as falsifying header\
    \ fields or certain timestamps. In\ncases where protection from even these types\
    \ of attacks is required, a\nspecifically engineered message-authentication mechanism\
    \ based on\ncryptographic techniques is necessary. Typical mechanisms involve\
    \ the\nuse of cryptographic certificates, algorithms and key media, together\n\
    with secure media databases and key-management protocols. Ongoing\nresearch efforts\
    \ in this area are directed toward developing a standard\nmethodology that can\
    \ be used with many protocols, including NTP.\nHowever, while it may eventually\
    \ be the case that ubiquitous, widely\napplicable authentication methodology may\
    \ be adopted by the Internet\ncommunity and effectively overtake the mechanism\
    \ described here, it does\nnot appear that specific standards and implementations\
    \ will happen\nwithin the lifetime of this particular version of NTP.\nThe NTP\
    \ authentication mechanism described here is intended for interim\nuse until specific\
    \ standards and implementations operating at the\nnetwork level or transport level\
    \ are available. Support for this\nmechanism is not required in order to conform\
    \ to the NTP specification\nitself. The mechanism, which operates at the application\
    \ level, is\ndesigned to protect against unauthorized message-stream modification\
    \ and\nmisrepresentation of source by insuring that unbroken, authenticated\n\
    paths exist between a trusted, stratum-one server in a particular\nsynchronization\
    \ subnet and all other servers in that subnet. It employs\na crypto-checksum,\
    \ computed by the sender and checked by the receiver,\ntogether with a set of\
    \ predistributed algorithms, certificates and\ncryptographic keys indexed by a\
    \ key identifier included in the message.\nHowever, there are no provisions in\
    \ NTP itself to distribute or maintain\nthe certificates, algorithms or keys.\
    \ These quantities may occasionally\nbe changed, which may result in inconsistent\
    \ key information while\nrekeying is in progress. The nature of NTP itself is\
    \ quite tolerant to\nsuch disruptions, so no particular provisions are included\
    \ to deal with\nthem.\nThe intent of the authentication mechanism is to provide\
    \ a framework\nthat can be used in conjunction with selected mode combinations\
    \ to build\nspecific plans to manage clockworking communities and implement policy\n\
    as necessary. It can be selectively enabled or disabled on a per-peer\nbasis.\
    \ There is no specific plan proposed to manage the use of such\nschemes; although\
    \ several possibilities are immediately obvious. In one\nscenario a group of time\
    \ servers peers among themselves using symmetric\nmodes and shares one secret\
    \ key, say key 1, while another group of\nservers peers among themselves using\
    \ symmetric modes and shares another\nsecret key, say key 2. Now, assume by policy\
    \ it is decided that selected\nservers in group 1 can provide synchronization\
    \ to group 2, but not the\nother way around. The selected servers in group 1 are\
    \ given key 2, but\noperated only in server mode, so cannot accept synchronization\
    \ from\ngroup 2; however, group 2 has authenticated access to group-1 servers.\n\
    Many other scenarios are possible with suitable combinations of modes\nand keys.\n\
    A packet format and crypto-checksum procedure appropriate for NTP is\nspecified\
    \ in the following sections. The cryptographic information is\ncarried in an authenticator\
    \ which follows the (unmodified) NTP header\nfields. The crypto-checksum procedure\
    \ uses the Data Encryption Standard\n(DES) [NBS77]; however, only the DES encryption\
    \ algorithm is used and\nthe decryption algorithm is not necessary. This feature\
    \ is specifically\ntargeted toward governmental sensitivities on the export of\n\
    cryptographic technology, since the DES decryption algorithm need not be\nincluded\
    \ in NTP software distributions and thus cannot be extracted and\nused in other\
    \ applications to avoid message data disclosure.\nNTP Authentication Mechanism\n\
    When it is created and possibly at other times, each association is\nallocated\
    \ variables identifying the certificate authority, encryption\nalgorithm, cryptographic\
    \ key and possibly other data. The specific\nprocedures to allocate and initialize\
    \ these variables are beyond the\nscope of this specification, as are the association\
    \ of the identifiers\nand keys and the management and distribution of the keys\
    \ themselves. For\nexample and consistency with the conventions of the NTP specification,\
    \ a\nset of appropriate peer and packet variables might include the\nfollowing:\n\
    Authentication Enabled Bit (peer.authenable): This is a bit indicating\nthat the\
    \ association is to operate in the authenticated mode. For\nconfigured peers this\
    \ bit is determined from the startup environment.\nFor non-configured peers, this\
    \ bit is set to one if an arriving message\nincludes the authenticator and set\
    \ to zero otherwise.\nAuthenticated Bit (peer.authentic): This is a bit indicating\
    \ that the\nlast message received from the peer has been correctly authenticated.\n\
    Key Identifier (peer.hostkeyid, peer.peerkeyid, pkt.keyid): This is an\ninteger\
    \ identifying the cryptographic key used to generate the message-\nauthentication\
    \ code. The system variable peer.hostkeyid is used for\nactive associations. The\
    \ peer.peerkeyid variable is initialized at zero\n(unspecified) when the association\
    \ is mobilized. For purposes of\nauthentication an unassigned value is interpreted\
    \ as zero (unspecified).\nCryptographic Keys (sys.key): This is a set of 64-bit\
    \ DES keys. Each key\nis constructed as in the Berkeley Unix distributions, which\
    \ consists of\neight octets, where the seven low-order bits of each octet correspond\
    \ to\nthe DES bits 1-7 and the high-order bit corresponds to the DES odd-\nparity\
    \ bit 8. By convention, the unspecified key 0 (zero), consisting of\neight odd-parity\
    \ zero octets, is used for testing and presumed known\nthroughout the NTP community.\
    \ The remaining keys are distributed using\nmethods outside the scope of NTP.\n\
    Crypto-Checksum (pkt.check): This is a crypto-checksum computed by the\nencryption\
    \ procedure.\nThe authenticator field consists of two subfields, one consisting\
    \ of the\npkt.keyid variable and the other the pkt.check variable computed by\
    \ the\nencrypt procedure, which is called by the transmit procedure described\n\
    in the NTP specification, and by the decrypt procedure, which is called\nby the\
    \ receive procedure described in the NTP specification. Its\npresence is revealed\
    \ by the fact the total datagram length according to\nthe UDP header is longer\
    \ than the NTP message length, which includes the\nheader plus the data field,\
    \ if present. For authentication purposes, the\nNTP message is zero-padded if\
    \ necessary to a 64-bit boundary, although\nthe padding bits are not considered\
    \ part of the NTP message itself. The\nauthenticator format shown in Figure 7<$&fig7>\
    \ has 96 bits, including a\n32-bit key identifier and 64-bit crypto-checksum,\
    \ and is aligned on a\n32-bit boundary for efficient computation. Additional information\n\
    required in some implementations, such as certificate authority and\nencryption\
    \ algorithm, can be inserted between the (padded) NTP message\nand the key identifier,\
    \ as long as the alignment conditions are met.\nLike the authenticator itself,\
    \ this information is not included in the\ncrypto-checksum. Use of these data\
    \ are beyond the scope of this\nspecification. These conventions may be changed\
    \ in future as the result\nof other standardization activities.\nNTP Authentication\
    \ Procedures\nWhen authentication is implemented there are two additional procedures\n\
    added to those described in the NTP specification. One of these\n(encrypt) constructs\
    \ the crypto-checksum in transmitted messages, while\nthe other (decrypt) checks\
    \ this quantity in received messages. The\nprocedures use a variant of the cipher-block\
    \ chaining method described\nin [NBS80] as applied to DES. In principal, the procedure\
    \ is independent\nof DES and requires only that the encryption algorithm operate\
    \ on 64-bit\nblocks. While the NTP authentication mechanism specifies the use\
    \ of DES,\nother algorithms could be used by prior arrangement.\nEncrypt Procedure\n\
    For ordinary NTP messages the encryption procedure operates as follows.\nIf authentication\
    \ is not enabled, the procedure simply exits. If the\nassociation is active (modes\
    \ 1, 3, 5), the key is determined from the\nsystem key identifier. If the association\
    \ is passive (modes 2, 4) the\nkey is determined from the peer key identifier,\
    \ if the authentic bit is\nset, or as the default key (zero) otherwise. These\
    \ conventions allow\nfurther protection against replay attacks and keying errors,\
    \ as well as\nfacilitate testing and migration to new versions. The crypto-checksum\
    \ is\ncalculated using the 64-bit NTP header and data words, but not the\nauthenticator\
    \ or padding bits.\nbegin encrypt procedure\n        if (<$Eroman peer.authenable~=~0>)\
    \ exit;                /* do\nnothing if not enabled */\n        if (<$Eroman\
    \ {peer.hostmode~=~1~bold or~peer.hostmode~=~3~bold\nor~peer.hostmode ~=~5}>)\n\
    \                <$Ekeyid~<<-~roman peer.hostkeyid>;             /*\nactive modes\
    \ use system key */\n        else\n                if (<$Eroman peer.authentic~=~1>)\
    \               /*\npassive modes use peer key */\n                         <$Ekeyid~<<-~roman\
    \ peer.peerkeyid>;\n                else\n                         <$Ekeyid~<<-~0>;\
    \                       /*\nunauthenticated use key 0 */\n        <$Etemp~<<-~0>;\
    \                                 /* calculate\ncrypto-checksum */\n        for\
    \ (each 64-bit header and data word) begin\n                <$Etemp~<<-~temp~roman\
    \ bold xor~word>;\n                <$Etemp~<<-~roman DES (temp,~keyid)>;\n   \
    \             endfor;\n        <$Eroman pkt.keyid~<<-~keyid>;                \
    \          /*\ninsert packet variables */\n        <$Eroman pkt.check~<<-~temp>;\n\
    \        end encrypt procedure;\nDecrypt Procedure\nFor ordinary messages the\
    \ decryption procedure operates as follows. If\nthe peer is not configured, the\
    \ data portion of the message is inspected\nto determine if the authenticator\
    \ fields are present. If so,\nauthentication is enabled; otherwise, it is disabled.\
    \ If authentication\nis enabled and the authenticator fields are present and the\
    \ crypto-\nchecksum succeeds, the authentication bit is set to one; otherwise,\
    \ it\nis set to zero.\nbegin decrypt procedure\n        <$Eroman peer.authentic~<<-~0>;\n\
    \        if (<$Eroman peer.config~=~0>)                          /* if\nnot configured,\
    \ enable per packet */\n                if (authenticator present)\n         \
    \               <$Eroman peer.authenable~<<-~1>;\n                else\n     \
    \                   <$Eroman peer.authenable~<<-~0>;\n        if (<$Eroman peer.authenable~=~0>\
    \ or authenticator not present))\nexit;\n        <$Eroman {peer.peerkeyid~<<-~pkt.keyid}>;\
    \               /* use\npeer key */\n        <$Etemp~<<-~0>;                 \
    \                /* calculate\ncrypto-checksum */\n        for (each 64-bit header\
    \ and data word) begin\n                <$Etemp~<<-~temp~roman bold xor~word>;\n\
    \                <$Etemp~<<-~roman DES (temp,~roman peer.peerkeyid)>;\n      \
    \          endfor;\n        if (temp == pkt.check) <$Eroman peer.authentic~<<-~1>;\
    \  /*\ndeclare result */\n        end decrypt procedure;\nControl-Message Procedures\n\
    In anticipation that the functions provided by the NTP control messages\nwill\
    \ eventually be subsumed by a comprehensive network-managment\nfunction, the peer\
    \ variables are not used for control message\nauthentication. If an NTP command\
    \ message is received with an\nauthenticator field, the crypto-checksum is computed\
    \ as in the decrypt\nprocedure and the response message includes the authenticator\
    \ field as\ncomputed by the encrypt procedure. If the received authenticator is\n\
    correct, the key for the response is the same as in the command;\notherwise, the\
    \ default key (zero) is used. Commands causing a change to\nthe peer data base,\
    \ such as the write variables and set trap\naddress/port commands, must be correctly\
    \ authenticated; however, the\nremaining commands are normally not authenticated\
    \ in order to minimize\nthe encryption overhead.\nAppendix D. Differences from\
    \ Previous Versions.\nThe original NTP, later called NTP Version 0, was described\
    \ in RFC-958\n[MIL85c]. Subsequently, Version 0 was superseded by Version 1 (RFC-1059\n\
    [MIL88a]), and Version 2 (RFC-1119 [MIL89]. The Version-2 description\nwas split\
    \ into two documents, RFC-1119 defining the architecture and\nspecifying the protocol\
    \ and algorithms, and another [MIL90b] describing\nthe service model, algorithmic\
    \ analysis and operating experience. In\nprevious versions these two objectives\
    \ were combined in one document.\nWhile the architecture assumed in Version 3\
    \ is identical to Version 2,\nthe protocols and algorithms differ in minor ways.\
    \ Differences between\nNTP Version 3 and previous versions are described in this\
    \ Appendix. Due\nto known bugs in very old implementations, continued support\
    \ for\nVersion-0 implementations is not recommended. It is recommended that new\n\
    implementations follow the guidelines below when interoperating with\nolder implementations.\n\
    Version 3 neither changes the protocol in any significant way nor\nobsoletes previous\
    \ versions or existing implementations. The main\nmotivation for the new version\
    \ is to refine the analysis and\nimplementation models for new applications at\
    \ much higher network speeds\nto the gigabit-per-second regime and to provide\
    \ for the enhanced\nstability, accuracy and precision required at such speeds.\
    \ In\nparticular, the sources of time and frequency errors have been\nrigorously\
    \ examined and error bounds established in order to improve\nperformance, provide\
    \ a model for correctness assertions and indicate\ntimekeeping quality to the\
    \ user. Version 3 also incorporates two new\noptional features, (1) an algorithm\
    \ to combine the offsets of a number\nof peer time servers in order to enhance\
    \ accuracy and (2) improved\nlocal-clock algorithms which allow the poll intervals\
    \ on all\nsynchronization paths to be substantially increased in order to reduce\n\
    network overhead. Following is a summary of previous versions of the\nprotocol\
    \ together with details of the Version 3 changes.\n1.\nVersion 1 supports no modes\
    \ other than symmetric-active and symmetric-\npassive, which are determined by\
    \ inspecting the port-number fields of\nthe UDP packet header. The peer mode can\
    \ be determined explicitly from\nthe packet-mode variable (pkt.mode) if it is\
    \ nonzero and implicitly from\nthe source port (pkt.peerport) and destination\
    \ port (pkt.hostport)\nvariables if it is zero. For the case where pkt.mode is\
    \ zero the mode is\ndetermined as follows:\n@Z_TBL_BEG = COLUMNS(3), DIMENSION(IN),\
    \ WIDTH(5.0000), ABOVE(.1670),\nBELOW(.0830), HGUTTER(.3330), BOX(Z_SINGLE), KEEP(ON),\
    \ ALIGN(CT),\nL1(R1C0..R1C3)\n@Z_TBL_BODY = TABLE HEADER, TABLE HEADER, TABLE\
    \ HEADER\npkt.peerport, pkt.hostport, Mode\n@Z_TBL_BODY = TABLE TEXT, TABLE TEXT,\
    \ TABLE TEXT\nNTP.PORT, NTP.PORT, symmetric active\nNTP.PORT, not NTP.PORT, server\n\
    not NTP.PORT, NTP.PORT, client\n@Z_TBL_BODY = TABLE HEADER, TABLE HEADER, TABLE\
    \ HEADER\nnot NTP.PORT, not NTP.PORT, not possible\n@Z_TBL_END =\nNote that it\
    \ is not possible in this case to distinguish between\nsymmetric active and symmetric\
    \ passive modes. Use of the pkt.mode and\nNTP.PORT variables in this way is not\
    \ recommended and may not be\nsupported in future versions of the protocol. The\
    \ low-order three bits\nof the first octet, specified as zero in Version 1, are\
    \ used for the\nmode field in Version 2. Version-2 and Version-3 implementations\n\
    interoperating with Version-1 implementations should operate in a\npassive mode\
    \ only and use the value one in the version number\n(pkt.version) field and zero\
    \ in the mode (pkt.mode) field in transmitted\nmessages.\n2.\nVersion 1 does not\
    \ support the NTP control message described in Appendix\nB. Certain old versions\
    \ of the Unix NTP daemon ntpd use the high-order\nbits of the stratum field (pkt.stratum)\
    \ for control and monitoring\npurposes. While these bits are never set during\
    \ normal Version-1,\nVersion-2 or Version-3 operations, new implementations may\
    \ use the NTP\nreserved mode 6 described in Appendix B and/or private reserved\
    \ mode 7\nfor special purposes, such as remote control and monitoring, and in\
    \ such\ncases the format of the packet following the first octet can be\narbitrary.\
    \ While there is no guarantee that different implementations\ncan interoperate\
    \ using private reserved mode 7, it is recommended that\nvanilla ASCII format\
    \ be used whenever possible.\n3.\nVersion 1 does not support authentication. The\
    \ key identifiers,\ncryptographic keys and procedures described in Appendix C\
    \ are new to\nVersion 2 and continued in Version 3, along with the corresponding\n\
    variables, procedures and authenticator fields. In the NTP message\ndescribed\
    \ in Appendix A and NTP control message described in Appendix B\nthe format and\
    \ contents of the header fields are independent of the\nauthentication mechanism\
    \ and the authenticator itself follows the header\nfields, so that previous versions\
    \ will ignore the authenticator.\n4.\nIn Version 1 the total dispersion (pkt.rootdispersion)\
    \ field of the NTP\nheader was called the estimated drift rate, but not used in\
    \ the protocol\nor timekeeping procedures. Implementations of the Version-1 protocol\n\
    typically set this field to the current value of the skew-compensation\nregister,\
    \ which is a signed quantity. In a Version 2 implementation\napparent large values\
    \ in this field may affect the order considered in\nthe clock-selection procedure.\
    \ Version-2 and Version-3 implementations\ninteroperating with older implementations\
    \ should assume this field is\nzero, regardless of its actual contents.\n5.\n\
    Version 2 and Version 3 incorporate several sanity checks designed to\navoid disruptions\
    \ due to unsynchronized, duplicate or bogus timestamp\ninformation. The checks\
    \ in Version 3 are specifically designed to detect\nlost or duplicate packets\
    \ and resist invalid timestamps. The leap-\nindicator bits are set to show the\
    \ unsynchronized state if updates are\nnot received from a reference source for\
    \ a considerable time or if the\nreference source has not received updates for\
    \ a considerable time. Some\nVersion-1 implementations could claim valid synchronization\
    \ indefinitely\nfollowing loss of the reference source.\n6.\nThe clock-selection\
    \ procedure of Version 2 was considerably refined as\nthe result of accumulated\
    \ experience with the Version-1 implementation.\nAdditional sanity checks are\
    \ included for authentication, range bounds\nand to avoid use of very old data.\
    \ The candidate list is sorted twice,\nonce to select a relatively few robust\
    \ candidates from a potentially\nlarge population of unruly peers and again to\
    \ order the resulting list\nby measurement quality. As in Version 1, The final\
    \ selection procedure\nrepeatedly casts out outlyers on the basis of weighted\
    \ dispersion.\n7.\nThe local-clock procedure of Version 2 were considerably improved\
    \ over\nVersion 1 as the result of analysis, simulation and experience. Checks\n\
    have been added to warn that the oscillator has gone too long without\nupdate\
    \ from a reference source. The compliance register has been added\nto improve\
    \ frequency stability to the order of a millisecond per day.\nThe various parameters\
    \ were retuned for optimum loop stability using\nmeasured data over typical Internet\
    \ paths and with typical local-clock\nhardware. In version 3 the phase-lock loop\
    \ model was further refined to\nprovide an adaptive-bandwidth feature that automatically\
    \ adjusts for the\ninherent stabilities of the reference clock and local clock\
    \ while\nproviding optimum loop stability in each case.\n8.\nProblems in the timekeeping\
    \ calculations of Version 1 with high-speed\nLANs were found and corrected in\
    \ Version 2. These were caused by jitter\ndue to small differences in clock rates\
    \ and different precisions between\nthe peers. Subtle bugs in the Version-1 reachability\
    \ and polling-rate\ncontrol were found and corrected. The peer.valid and sys.hold\
    \ variables\nwere added to avoid instabilities when the reference source changes\n\
    rapidly due to large dispersive delays under conditions of severe\nnetwork congestion.\
    \ The peer.config, peer.authenable and peer.authentic\nbits were added to control\
    \ special features and simplify configuration.\n9.\nIn Version 3 The local-clock\
    \ algorithm has been overhauled to improve\nstability and accuracy. Appendix G\
    \ presents a detailed mathematical\nmodel and design example which has been refined\
    \ with the aid of\nfeedback-control analysis and extensive simulation using data\
    \ collected\nover ordinary Internet paths. Section 5 of RFC-1119 on the NTP local\n\
    clock has been completely rewritten to describe the new algorithm. Since\nthe\
    \ new algorithm can result in message rates far below the old ones, it\nis highly\
    \ recommended that they be used in new implementations. Note\nthat this algorithm\
    \ is not integral to the NTP protocol specification\nitself and its use does not\
    \ affect interoperability with previous\nversions or existing implementations;\
    \ however, in order to insure\noverall NTP subnet stability in the Internet, it\
    \ is essential that the\nlocal-clock characteristics of all NTP time servers conform\
    \ to the\nanalytical models presented previously and in this document.\n10.\n\
    In Version 3 a new algorithm to combine the offsets of a number of peer\ntime\
    \ servers is presented in Appendix F. This algorithm is modelled on\nthose used\
    \ by national standards laboratories to combine the weighted\noffsets from a number\
    \ of standard clocks to construct a synthetic\nlaboratory timescale more accurate\
    \ than that of any clock separately. It\ncan be used in an NTP implementation\
    \ to improve accuracy and stability\nand reduce errors due to asymmetric paths\
    \ in the Internet. The new\nalgorithm has been simulated using data collected\
    \ over ordinary Internet\npaths and, along with the new local-clock algorithm,\
    \ implemented and\ntested in the Fuzzball time servers now running in the Internet.\
    \ Note\nthat this algorithm is not integral to the NTP protocol specification\n\
    itself and its use does not affect interoperability with previous\nversions or\
    \ existing implementations.\n11.\nSeveral inconsistencies and minor errors in\
    \ previous versions have been\ncorrected in Version 3. The description of the\
    \ procedures has been\nrewritten in pseudo-code augmented by English commentary\
    \ for clarity and\nto avoid ambiguity. Appendix I has been added to illustrate\
    \ C-language\nimplementations of the various filtering and selection algorithms\n\
    suggested for NTP. Additional information is included in Section 5 and\nin Appendix\
    \ E, which includes the tutorial material formerly included in\nSection 2 of RFC-1119,\
    \ as well as much new material clarifying the\ninterpretation of timescales and\
    \ leap seconds.\n12.\nMinor changes have been made in the Version-3 local-clock\
    \ algorithms to\navoid problems observed when leap seconds are introduced in the\
    \ UTC\ntimescale and also to support an auxiliary precision oscillator, such as\n\
    a cesium clock or timing receiver, as a precision timebase. In addition,\nchanges\
    \ were made to some procedures described in Section 3 and in the\nclock-filter\
    \ and clock-selection procedures described in Section 4.\nWhile these changes\
    \ were made to correct minor bugs found as the result\nof experience and are recommended\
    \ for new implementations, they do not\naffect interoperability with previous\
    \ versions or existing\nimplementations in other than minor ways (at least until\
    \ the next leap\nsecond).\n13.\nIn Version 3 changes were made to the way delay,\
    \ offset and dispersion\nare defined, calculated and processed in order to reliably\
    \ bound the\nerrors inherent in the time-transfer procedures. In particular, the\n\
    error accumulations were moved from the delay computation to the\ndispersion computation\
    \ and both included in the clock filter and\nselection procedures. The clock-selection\
    \ procedure was modified to\nremove the first of the two sorting/discarding steps\
    \ and replace with an\nalgorithm first proposed by Marzullo and later incorporated\
    \ in the\nDigital Time Service. These changes do not significantly affect the\n\
    ordinary operation of or compatibility with various versions of NTP, but\nthey\
    \ do provide the basis for formal statements of correctness as\ndescribed in Appendix\
    \ H.\nAppendix E. The NTP Timescale and its Chronometry\nIntroduction\nFollowing\
    \ is an extended discussion on computer network chronometry,\nwhich is the precise\
    \ determination of computer time and frequency\nrelative to international standards\
    \ and the determination of\nconventional civil time and date according to the\
    \ modern calendar. It\ndescribes the methods conventionally used to establish\
    \ civil time and\ndate and the various timescales now in use. In particular, it\n\
    characterizes the Network Time Protocol (NTP) timescale relative to the\nCoordinated\
    \ Universal Time (UTC) timescale, and establishes the precise\ninterpretation\
    \ of UTC leap seconds in NTP.\nIn the following discussion the terms time, oscillator,\
    \ clock, epoch,\ncalendar, date and timescale are used in a technical sense. Strictly\n\
    speaking, the time of an event is an abstraction which determines the\nordering\
    \ of events in some given frame of reference. An oscillator is a\ngenerator capable\
    \ of precise frequency (relative to the given frame of\nreference) to a specified\
    \ tolerance. A clock is an oscillator together\nwith a counter which records the\
    \ (fractional) number of cycles since\nbeing initialized with a given value at\
    \ a given time. The value of the\ncounter at any given time is called its epoch\
    \ at that time. In general,\nepoches are not continuous and depend on the precision\
    \ of the counter.\nA calendar is a mapping from epoch in some frame of reference\
    \ to the\ntimes and dates used in everyday life. Since multiple calendars are\
    \ in\nuse today and sometimes disagree on the dating of the same events in the\n\
    past, the chronometry of past and present events is an art practiced by\nhistorians.\
    \ One of the goals of this discussion is to provide a standard\nchronometry for\
    \ precision dating of present and future events in a\nglobal networking community.\
    \ To synchronize frequency means to adjust\nthe oscillators in the network to\
    \ run at the same frequency, to\nsynchronize time means to set the clocks so that\
    \ all agree at a\nparticular epoch with respect to UTC, as provided by international\n\
    standards, and to synchronize clocks means to synchronize them in both\nfrequency\
    \ and time.\nIn order to synchronize clocks, there must be some way to directly\
    \ or\nindirectly compare them in time and frequency. The ultimate frame of\nreference\
    \ for our world consists of the cosmic oscillators: the Sun,\nMoon and other galactic\
    \ orbiters. Since the frequencies of these\noscillators are relatively unstable\
    \ and not known exactly, the ultimate\nreference standard oscillator has been\
    \ chosen by international agreement\nas a synthesis of many observations of an\
    \ atomic transition of exquisite\nstability. The epoches of each heavenly and\
    \ Earthbound oscillator\ndefines a distinctive timescale, not necessarily always\
    \ continuous,\nrelative to the standard oscillator. Another goal of this presentation\n\
    is to describe a standard chronometry to rationalize conventional\ncomputer time\
    \ and UTC; in particular, how to handle leap seconds.\nPrimary Frequency and Time\
    \ Standards\nA primary frequency standard is an oscillator that can maintain\n\
    extremely precise frequency relative to a physical phenomenon, such as a\ntransition\
    \ in the orbital states of an electron. Presently available\natomic oscillators\
    \ are based on the transitions of the hydrogen, cesium\nand rubidium atoms. Table\
    \ 7<$&tab7> shows the characteristics for\ntypical oscillators of these types\
    \ compared with those for various types\nof quartz-crystal oscillators found in\
    \ electronic equipment. For reasons\nof cost and robustness cesium oscillators\
    \ are used worldwide for\nnational primary frequency standards. On the other hand,\
    \ local clocks\nused in computing equipment almost always are designed with\n\
    uncompensated crystal oscillators.\nFor the three atomic oscillators listed in\
    \ Table 7 the drift/aging\ncolumn shows the maximum offset per day from nominal\
    \ standard frequency\ndue to systematic mechanical and electrical characteristics.\
    \ In the case\nof crystal oscillators this offset is not constant, which results\
    \ in a\ngradual change in frequency with time, called aging. Even if a crystal\n\
    oscillator is temperature compensated by some means, it must be\nperiodically\
    \ compared to a primary standard in order to maintain the\nhighest accuracy. For\
    \ all types of oscillators the stability column\nshows the maximum variation in\
    \ frequency per day due to circuit noise\nand environmental factors.\nAs the telephone\
    \ networks of the world are evolving rapidly to digital\ntechnology, consideration\
    \ should be given to the methods used for\nfrequency synchronization in digital\
    \ networks. A network of clocks in\nwhich each oscillator is phase-locked to a\
    \ single frequency standard is\ncalled isochronous, while a network in which some\
    \ oscillators are phase-\nlocked to different master oscillators, but with the\
    \ master oscillators\nclosely synchronized in frequency (not necessarily phase\
    \ locked), to a\nsingle frequency standard is called plesiochronous. In plesiochronous\n\
    systems the phase of some oscillators can slip relative to others and\ncause occasional\
    \ data errors in synchronous transmission systems.\nThe industry has agreed on\
    \ a classification of clock oscillators as a\nfunction of minimum accuracy, minimum\
    \ stability and other factors\n[ALL74a]. There are three factors which determine\
    \ the classification:\nstability, jitter and wander. Stability refers to the systematic\n\
    variation of frequency with time and is synonymous with aging, drift,\ntrends,\
    \ etc. Jitter (also called timing jitter) refers to short-term\nvariations in\
    \ frequency with components greater than 10 Hz, while wander\nrefers to long-term\
    \ variations in frequency with components less than 10\nHz. The classification\
    \ determines the oscillator stratum (not to be\nconfused with the NTP stratum),\
    \ with the more accurate oscillators\nassigned the lower strata and less accurate\
    \ oscillators the higher\nstrata:\n@Z_TBL_BEG = COLUMNS(3), DIMENSION(IN), COLWIDTHS(E1,E2,E2),\n\
    WIDTH(5.0000), ABOVE(.1670), BELOW(.0830), HGUTTER(.3330),\nBOX(Z_SINGLE), KEEP(ON),\
    \ ALIGN(CT), L1(R1C0..R1C3)\n@Z_TBL_BODY = TABLE CENTER, TABLE HEADER, TABLE HEADER\n\
    Stratum, Min Accuracy (per day), Min Stability (per day)\n@Z_TBL_BODY = TABLE\
    \ CENTER, TABLE TEXT, TABLE TEXT\n1, 1 x 10-11, not specified\n2, 1.6 x 10-8,\
    \ 1 x 10-10\n3, 4.6 x 10-6, 3.7 x 10-7\n@Z_TBL_BODY = TABLE CENTER, TABLE HEADER,\
    \ TABLE HEADER\n4, 3.2 x 10-5, not specified\n@Z_TBL_END =\nThe construction,\
    \ operation and maintenance of stratum-one oscillators\nis assumed to be consistent\
    \ with national standards and often includes\ncesium oscillators or precision\
    \ crystal oscillators synchronized via\nLORAN-C to national standards. Stratum-two\
    \ oscillators represent the\nstability required for interexchange toll switches\
    \ such as the AT&T 4ESS\nand interexchange digital cross-connect systems, while\
    \ stratum-three\noscillators represent the stability required for exchange switches\
    \ such\nas the AT&T 5ESS and local cross-connect systems. Stratum-four\noscillators\
    \ represent the stability required for digital channel-banks\nand PBX systems.\n\
    Time and Frequency Dissemination\nIn order that atomic and civil time can be coordinated\
    \ throughout the\nworld, national administrations operate primary time and frequency\n\
    standards and coordinate them cooperatively by observing various radio\nbroadcasts\
    \ and through occasional use of portable atomic clocks. Most\nseafaring nations\
    \ of the world operate some sort of broadcast time\nservice for the purpose of\
    \ calibrating chronographs, which are used in\nconjunction with ephemeris data\
    \ to determine navigational position. In\nmany countries the service is primitive\
    \ and limited to seconds-pips\nbroadcast by marine communication stations at certain\
    \ hours. For\ninstance, a chronograph error of one second represents a longitudinal\n\
    position error of about 0.23 nautical mile at the Equator.\nThe U.S. National\
    \ Institute of Standards and Technology (NIST - formerly\nNational Bureau of Standards)\
    \ operates three radio services for the\ndissemination of primary time and frequency\
    \ information. One of these\nuses high-frequency (HF or CCIR band 7) transmissions\
    \ on frequencies of\n2.5, 5, 10, 15 and 20 MHz from Fort Collins, CO (WWV), and\
    \ Kauai, HI\n(WWVH). Signal propagation is usually by reflection from the upper\n\
    ionospheric layers, which vary in height and composition throughout the\nday and\
    \ season and result in unpredictable delay variations at the\nreceiver. The timecode\
    \ is transmitted over a 60-second interval at a\ndata rate of 1 bps using a 100-Hz\
    \ subcarrier on the broadcast signal.\nThe timecode information includes UTC time-day\
    \ information, but does not\ncurrently include year or leap-second warning. While\
    \ these transmissions\nand those of Canada from Ottawa, Ontario (CHU), and other\
    \ countries can\nbe received over large areas in the western hemisphere, reliable\n\
    frequency comparisons can be made only to the order of 10-7 and time\naccuracies\
    \ are limited to the order of a millisecond [BLA74]. Radio\nclocks which operate\
    \ with these transmissions include the Traconex 1020,\nwhich provides accuracies\
    \ to about ten milliseconds and is priced in the\n$1,500 range.\nA second service\
    \ operated by NIST uses low-frequency (LF or CCIR band 5)\ntransmissions on 60\
    \ kHz from Boulder, CO (WWVB), and can be received\nover the continental U.S.\
    \ and adjacent coastal areas. Signal propagation\nis via the lower ionospheric\
    \ layers, which are relatively stable and\nhave predictable diurnal variations\
    \ in height. The timecode is\ntransmitted over a 60-second interval at a rate\
    \ of 1 pps using periodic\nreductions in carrier power. With appropriate receiving\
    \ and averaging\ntechniques and corrections for diurnal and seasonal propagation\
    \ effects,\nfrequency comparisons to within 10-11 are possible and time accuracies\n\
    of from a few to 50 microseconds can be obtained [BLA74]. Some countries\nin western\
    \ Europe operate similar services which use transmissions on 60\nkHz from Rugby,\
    \ U.K. (MSF), and on 77.5 kHz from Mainflingen, West\nGermany (DCF77). The timecode\
    \ information includes UTC time-day-year\ninformation and leap-second warning.\
    \ Radio clocks which operate with\nthese transmissions include the Spectracom\
    \ 8170 and Kinemetrics/TrueTime\n60-DC and LF-DC, which provide accuracies to\
    \ a millisecond or less and\nare priced in the $2,500 range. However, these receivers\
    \ do not extract\nthe year information and leap-second warning.\nThe third service\
    \ operated by NIST uses ultra-high frequency (UHF or\nCCIR band 9) transmissions\
    \ on about 468 MHz from the Geosynchronous\nOrbit Environmental Satellites (GOES),\
    \ three of which cover the western\nhemisphere. The timecode is interleaved with\
    \ messages used to\ninterrogate remote sensors and consists of 60 4-bit binary-coded\
    \ decimal\nwords transmitted over an interval of 30 seconds. The timecode\ninformation\
    \ includes UTC time-day-year information and leap-second\nwarning. Radio clocks\
    \ which operate with these transmissions include the\nKinemetrics/TrueTime 468-DC,\
    \ which provides accuracies to 0.5 ms and is\npriced in the $6,000 range. However,\
    \ this receiver does not extract the\nyear information and leap-second warning.\n\
    The U.S. Department of Defense is developing the Global Positioning\nSystem (GPS)\
    \ for worldwide precision navigation. This system will\neventually provide 24-hour\
    \ worldwide coverage using a constellation of\n24 satellites in 12-hour orbits.\
    \ For time-transfer applications GPS has\na potential accuracy in the order of\
    \ a few nanoseconds; however, various\nconsiderations of defense policy may limit\
    \ accuracy to hundreds of\nnanoseconds [VAN84]. The timecode information includes\
    \ GPS time and UTC\ncorrection; however, there appears to be no leap-second warning.\
    \ Radio\nclocks which operate with these transmissions include the\nKinemetrics/TrueTime\
    \ GPS-DC, which provides accuracies to 200 <$Emu>s\nand is priced in the $12,000\
    \ range. However, since only about half the\nsatellites have been launched, expensive\
    \ rubidium or quartz oscillators\nare necessary to preserve accuracy during outages.\
    \ Also, since this is a\nsingle-channel receiver, it must be supplied with geographic\
    \ coordinates\nwithin a degree from an external source before operation begins.\n\
    The U.S. Coast Guard, along with agencies of other countries, has\noperated the\
    \ LORAN-C [FRA82] radionavigation system for many years. It\ncurrently provides\
    \ time-transfer accuracies of less than a microsecond\nand eventually may achieve\
    \ 100 ns within the ground-wave coverage area\nof a few hundred kilometers from\
    \ the transmitter. Beyond the ground wave\narea signal propagation is via the\
    \ lower ionospheric layers, which\ndecreases accuracies to the order of 50 us.\
    \ With the recent addition of\nthe Mid-Continent Chain, the deployment of LORAN-C\
    \ transmitters now\nprovides complete coverage of the U.S. LORAN-C timing receivers,\
    \ such as\nthe Austron 2000, are specialized and extremely expensive (up to\n\
    $20,000). They are used primarily to monitor local cesium clocks and are\nnot\
    \ suited for unattended, automatic operation. While the LORAN-C system\nprovides\
    \ a highly accurate frequency and time reference within the\nground wave area,\
    \ there is no timecode modulation, so the receiver must\nbe supplied with UTC\
    \ time to within a few tens of seconds from an\nexternal source before operation\
    \ begins.\nThe OMEGA [VAS78] radionavigation system operated by the U.S. Navy\
    \ and\nother countries consists of eight very-low-frequency (VLF or CCIR band\n\
    4) transmitters operating on frequencies from 10.2 to 13.1 kHz and\nproviding\
    \ 24-hour worldwide coverage. With appropriate receiving and\naveraging techniques\
    \ and corrections for propagation effects, frequency\ncomparisons and time accuracies\
    \ are comparable to the LF systems, but\nwith worldwide coverage [BLA74]. Radio\
    \ clocks which operate with these\ntransmissions include the Kinemetrics/TrueTime\
    \ OM-DC, which provides\naccuracies to 1 ms and is priced in the $3,500 range.\
    \ While the OMEGA\nsystem provides a highly accurate frequency reference, there\
    \ is no\ntimecode modulation, so the receiver must be supplied with geographic\n\
    coordinates within a degree and UTC time within five seconds from an\nexternal\
    \ source before operation begins. There are several other VLF\nservices intended\
    \ primarily for worldwide data communications with\ncharacteristics similar to\
    \ OMEGA. These services can be used in a manner\nsimilar to OMEGA, but this requires\
    \ specialized techniques not suited\nfor unattended, automatic operation.\nNote\
    \ that not all transmission formats used by NIST radio broadcast\nservices [NBS79]\
    \ and no currently available radio clocks include\nprovisions for year information\
    \ and leap-second warning. This\ninformation must be determined from other sources.\
    \ NTP includes\nprovisions to distribute advance warnings of leap seconds using\
    \ the\nleap-indicator bits described in the NTP specification. The protocol is\n\
    designed so that these bits can be set manually or by the radio timecode\nat the\
    \ primary time servers and then automatically distributed\nthroughout the synchronization\
    \ subnet to all other time servers.\nCalendar Systems\nThe calendar systems used\
    \ in the ancient world reflect the agricultural,\npolitical and ritual needs characteristic\
    \ of the societies in which they\nflourished. Astronomical observations to establish\
    \ the winter and summer\nsolstices were in use three to four millennia ago. By\
    \ the 14th century\nBC the Shang Chinese had established the solar year as 365.25\
    \ days and\nthe lunar month as 29.5 days. The lunisolar calendar, in which the\n\
    ritual month is based on the Moon and the agricultural year on the Sun,\nwas used\
    \ throughout the ancient Near East (except Egypt) and Greece from\nthe third millennium\
    \ BC. Early calendars used either thirteen lunar\nmonths of 28 days or twelve\
    \ alternating lunar months of 29 and 30 days\nand haphazard means to reconcile\
    \ the 354/364-day lunar year with the\n365-day vague solar year.\nThe ancient\
    \ Egyptian lunisolar calendar had twelve 30-day lunar months,\nbut was guided\
    \ by the seasonal appearance of the star Sirius (Sothis).\nIn order to reconcile\
    \ this calendar with the solar year, a civil\ncalendar was invented by adding\
    \ five intercalary days for a total of 365\ndays. However, in time it was observed\
    \ that the civil year was about\none-fourth day shorter than the actual solar\
    \ year and thus would precess\nrelative to it over a 1460-year cycle called the\
    \ Sothic cycle. Along\nwith the Shang Chinese, the ancient Egyptians had thus\
    \ established the\nsolar year at 365.25 days, or within about 11 minutes of the\
    \ present\nmeasured value. In 432 BC, about a century after the Chinese had done\n\
    so, the Greek astronomer Meton calculated there were 110 lunar months of\n29 days\
    \ and 125 lunar months of 30 days for a total of 235 lunar months\nin 6940 solar\
    \ days, or just over 19 years. The 19-year cycle, called the\nMetonic cycle, established\
    \ the lunar month at 29.532 solar days, or\nwithin about two minutes of the present\
    \ measured value.\nThe Roman republican calendar was based on a lunar year and\
    \ by 50 BC was\neight weeks out of step with the solar year. Julius Caesar invited\
    \ the\nAlexandrian astronomer Sosigenes to redesign the calendar, which led to\n\
    the adoption in 46 BC of the Julian calendar. This calendar is based on\na year\
    \ of 365 days with an intercalary day inserted every four years.\nHowever, for\
    \ the first 36 years an intercalary day was mistakenly\ninserted every three years\
    \ instead of every four. The result was 12\nintercalary days instead of nine,\
    \ and a series of corrections that was\nnot complete until 8 AD.\nThe seven-day\
    \ Sumerian week was introduced only in the fourth century AD\nby Emperor Constantine\
    \ I. During the Roman era a 15-year census cycle,\ncalled the Indiction cycle,\
    \ was instituted for taxation purposes. The\nsequence of day-names for consecutive\
    \ occurrences of a particular day of\nthe year does not recur for 28 years, called\
    \ the solar cycle. Thus, the\nleast common multiple of the 28-year solar cycle,\
    \ 19-year Metonic cycle\nand 15-year Indiction cycle results in a grand 7980-year\
    \ supercycle\ncalled the Julian Era, which began in 4713 BC. A particular combination\n\
    of the day of the week, day of the year, phase of the Moon and round of\nthe census\
    \ will recur beginning in 3268 AD.\nBy 1545 the discrepancy in the Julian year\
    \ relative to the solar year\nhad accumulated to ten days. In 1582, following\
    \ suggestions by the\nastronomers Christopher Clavius and Luigi Lilio, Pope Gregory\
    \ XIII\nissued a papal bull which decreed, among other things, that the solar\n\
    year would consist of 365.2422 days. In order to more closely\napproximate the\
    \ new value, only those centennial years divisible by 400\nwould be leap years,\
    \ while the remaining centennial years would not,\nmaking the actual value 365.2425,\
    \ or within about 26 seconds of the\ncurrent measured value. Since the beginning\
    \ of the Common Era and prior\nto 1990 there were 474 intercalary days inserted\
    \ in the Julian calendar,\nbut 14 of these were removed in the Gregorian calendar.\
    \ While the\nGregorian calendar is in use throughout most of the world today,\
    \ some\ncountries did not adopt it until early in the twentieth century.\nWhile\
    \ it remains a fascinating field for time historians, the above\nnarrative provides\
    \ conclusive evidence that conjugating calendar dates\nof significant events and\
    \ assigning NTP timestamps to them is\napproximate at best. In principle, reliable\
    \ dating of such events\nrequires only an accurate count of the days relative\
    \ to some globally\nalarming event, such as a comet passage or supernova explosion;\
    \ however,\nonly historically persistent and politically stable societies, such\
    \ as\nthe ancient Chinese and Egyptian, and especially the classic Maya,\npossessed\
    \ the means and will to do so.\nThe Modified Julian Day System\nIn order to measure\
    \ the span of the universe or the decay of the proton,\nit is necessary to have\
    \ a standard day-numbering plan. Accordingly, the\nInternational Astronomical\
    \ Union has adopted the use of the standard\nsecond and Julian Day Number (JDN)\
    \ to date cosmological events and\nrelated phenomena. The standard day consists\
    \ of 86,400 standard seconds,\nwhere time is expressed as a fraction of the whole\
    \ day, and the standard\nyear consists of 365.25 standard days.\nIn the scheme\
    \ devised in 1583 by the French scholar Joseph Julius\nScaliger and named after\
    \ his father, Julius Caesar Scaliger, JDN 0.0\ncorresponds to 12h (noon) on the\
    \ first day of the Julian Era, 1 January\n4713 BC. The years prior to the Common\
    \ Era (BC) are reckoned according\nto the Julian calendar, while the years of\
    \ the Common Era (AD) are\nreckoned according to the Gregorian calendar. Since\
    \ 1 January 1 AD in\nthe Gregorian calendar corresponds to 3 January 1 in the\
    \ Julian calendar\n[DER90], JDN 1,721,426.0 corresponds to 12h on the first day\
    \ of the\nCommon Era, 1 January 1 AD. The Modified Julian Date (MJD), which is\n\
    sometimes used to represent dates near our own era in conventional time\nand with\
    \ fewer digits, is defined as MJD = JD <196> 2,400,000.5.\nFollowing the convention\
    \ that our century began at 0h on 1 January 1900,\nat which time the tropical\
    \ year was already 12h old, that eclectic\ninstant corresponds to MJD 15,020.0.\
    \ Thus, the Julian timescale ticks in\nstandard (atomic) 365.25-day centuries\
    \ and was set to a given value at\nthe approximate epoch of a cosmic event which\
    \ apparently synchronized\nthe entire human community, the origin of the Common\
    \ Era.\nDetermination of Frequency\nFor many years the most important use of time\
    \ and frequency information\nwas for worldwide navigation and space science, which\
    \ depend on\nastronomical observations of the Sun, Moon and stars [JOR85]. Sidereal\n\
    time is based on the transit of stars across the celestial meridian of\nan observer.\
    \ The mean sidereal day is 23 hours, 56 minutes and 4.09\nseconds, but varies\
    \ about <F128M><F255D>30 ms throughout the year due\nto polar wandering and orbit\
    \ variations. Ephemeris time is based on\ntables with which a standard time interval\
    \ such as the tropical year -\none complete revolution of the Earth around the\
    \ Sun - can be determined\nthrough observations of the Sun, Moon and planets.\
    \ In 1958 the standard\nsecond was defined as 1/31,556,925.9747 of the tropical\
    \ year that began\nthis century. On this scale the tropical year is 365.2421987\
    \ days and\nthe lunar month - one complete revolution of the Moon around the Earth\
    \ -\nis 29.53059 days; however, the actual tropical year can be determined\nonly\
    \ to an accuracy of about 50 ms and has been increasing by about 5.3\nms per year.\n\
    Of the three heavenly oscillators readily apparent to ancient mariners\nand astronomers\
    \ - the Earth rotation about its axis, the Earth\nrevolution around the Sun and\
    \ the Moon revolution around the Earth -\nnone of the three have the intrinsic\
    \ stability, relative to modern\ntechnology, to serve as a standard reference\
    \ oscillator. In 1967 the\nstandard second was redefined as <169>9,192,631,770\
    \ periods of the\nradiation corresponding to the transition between the two hyperfine\n\
    levels of the ground state of the cesium-133 atom.<170> Since 1972 the\ntime and\
    \ frequency standards of the world have been based on\nInternational Atomic Time\
    \ (TAI), which is defined and maintained using\nmultiple cesium-beam oscillators\
    \ to an accuracy of a few parts in 1013,\nor better than a microsecond per day.\
    \ Note that, while this provides an\nextraordinarily precise timescale, it does\
    \ not necessarily agree with\nconventional solar time and may not in fact even\
    \ be absolutely uniform,\nunless subtle atomic conspiracies can be ruled out.\n\
    Determination of Time and Leap Seconds\nThe International Bureau of Weights and\
    \ Measures (IBWM) uses\nastronomical observations provided by the U.S. Naval Observatory\
    \ and\nother observatories to determine UTC. Starting from apparent mean solar\n\
    time as observed, the UT0 timescale is determined using corrections for\nEarth\
    \ orbit and inclination (the Equation of Time, as used by sundials),\nthe UT1\
    \ (navigator's) timescale by adding corrections for polar\nmigration and the UT2\
    \ timescale by adding corrections for known\nperiodicity variations. While standard\
    \ frequencies are based on TAI,\nconventional civil time is based on UT1, which\
    \ is presently slowing\nrelative to TAI by a fraction of a second per year. When\
    \ the magnitude\nof correction approaches 0.7 second, a leap second is inserted\
    \ or\ndeleted in the TAI timescale on the last day of June or December.\nFor the\
    \ most precise coordination and timestamping of events since 1972,\nit is necessary\
    \ to know when leap seconds are implemented in UTC and how\nthe seconds are numbered.\
    \ As specified in CCIR Report 517, which is\nreproduced in [BLA74], a leap second\
    \ is inserted following second\n23:59:59 on the last day of June or December and\
    \ becomes second 23:59:60\nof that day. A leap second would be deleted by omitting\
    \ second 23:59:59\non one of these days, although this has never happened. Leap\
    \ seconds\nwere inserted prior to 1 January 1991 on the occasions listed in Table\n\
    8<$&tab8> (courtesy U.S. Naval Observatory). Published IBWM corrections\nconsist\
    \ not only of leap seconds, which result in step discontinuities\nrelative to\
    \ TAI, but 100-ms UT1 adjustments called DUT1, which provide\nincreased accuracy\
    \ for navigation and space science.\nNote that the NTP time column actually shows\
    \ the epoch following the\nlast second of the day given in the UTC date and MJD\
    \ columns (except for\nthe first line), which is the precise epoch of insertion.\
    \ The offset\ncolumn shows the cumulative seconds offset between the uncoordinated\n\
    (Julian) timescale and the UTC timescale; that is, the number of seconds\nto add\
    \ to the Julian clock in order to maintain nominal agreement with\nthe UTC clock.\
    \ Finally, note that the epoch of insertion is relative to\nthe timescale immediately\
    \ prior to that epoch; e.g., the epoch of the 31\nDecember 90 insertion is determined\
    \ on the timescale in effect following\nthe 31 December 1990 insertion, which\
    \ means the actual insertion\nrelative to the Julian clock is fourteen seconds\
    \ later than the apparent\ntime on the UTC timescale.\nThe UTC timescale thus\
    \ ticks in standard (atomic) seconds and was set to\nthe value 0h MJD 41,317.0\
    \ at the epoch determined by astronomical\nobservation to be 0h on 1 January 1972\
    \ according to the Gregorian\ncalendar; that is, the inaugural tick of the UTC\
    \ Era. In fact, the\ninaugural tick which synchronized the cosmic oscillators,\
    \ Julian clock,\nUTC clock and Gregorian calendar forevermore was displaced about\
    \ ten\nseconds from the civil clock then in use, while the GPS clock is ahead\n\
    of the UTC clock by six seconds in late 1990. Subsequently, the UTC\nclock has\
    \ marched backward relative to the Julian timescale exactly one\nsecond on scheduled\
    \ occasions at monumental epoches embedded in the\ninstitutional memory of our\
    \ civilization. Note in passing that leap-\nsecond adjustments affect the number\
    \ of seconds per day and thus the\nnumber of seconds per year. Apparently, should\
    \ we choose to worry about\nit, the UTC clock, Julian clock and various cosmic\
    \ clocks will\ninexorably drift apart with time until rationalized by some future\
    \ papal\nbull.\nThe NTP Timescale and Reckoning with UTC\nThe NTP timescale is\
    \ based on the UTC timescale, but not necessarily\nalways coincident with it.\
    \ At 0h on 1 January 1972 (MJD 41,317.0), the\nfirst tick of the UTC Era, the\
    \ NTP clock was set to 2,272,060,800,\nrepresenting the number of standard seconds\
    \ since 0h on 1 January 1900\n(MJD 15,020.0). The insertion of leap seconds in\
    \ UTC and subsequently\ninto NTP does not affect the UTC or NTP oscillator, only\
    \ the conversion\nto conventional civil UTC time. However, since the only institutional\n\
    memory available to NTP are the UTC timecode broadcast services, the NTP\ntimescale\
    \ is in effect reset to UTC as each timecode is received. Thus,\nwhen a leap second\
    \ is inserted in UTC and subsequently in NTP, knowledge\nof all previous leap\
    \ seconds is lost.\nAnother way to describe this is to say there are as many NTP\
    \ timescales\nas historic leap seconds. In effect, a new timescale is established\n\
    after each new leap second. Thus, all previous leap seconds, not to\nmention the\
    \ apparent origin of the timescale itself, lurch backward one\nsecond as each\
    \ new timescale is established. If a clock synchronized to\nNTP in 1990 was used\
    \ to establish the UTC epoch of an event that\noccurred in early 1972 without\
    \ correction, the event would appear\nfifteen seconds late relative to UTC. However,\
    \ NTP primary time servers\nresolve the epoch using the broadcast timecode, so\
    \ that the NTP clock is\nset to the broadcast value on the current timescale.\
    \ As a result, for\nthe most precise determination of epoch relative to the historic\
    \ UTC\nclock, the user must subtract from the apparent NTP epoch the offsets\n\
    shown in Table 8 at the relative epoches shown. This is a feature of\nalmost all\
    \ present day time-distribution mechanisms.\nThe chronometry involved can be illustrated\
    \ with the help of Figure 8,\nwhich shows the details of seconds numbering just\
    \ before, during and\nafter the last scheduled leap insertion at 23:59:59 on 31\
    \ December 1989.\nNotice the NTP leap bits are set on the day prior to insertion,\
    \ as\nindicated by the <169>+<170> symbols on the figure. Since this makes the\n\
    day one second longer than usual, the NTP day rollover will not occur\nuntil the\
    \ end of the first occurrence of second 800. The UTC time\nconversion routines\
    \ must notice the apparent time and the leap bits and\nhandle the timescale conversions\
    \ accordingly. Immediately after the leap\ninsertion both timescales resume ticking\
    \ the seconds as if the leap had\nnever happened. The chronometric correspondence\
    \ between the UTC and NTP\ntimescales continues, but NTP has forgotten about all\
    \ past leap\ninsertions. In NTP chronometric determination of UTC time intervals\n\
    spanning leap seconds will thus be in error, unless the exact times of\ninsertion\
    \ are known.\nIt is possible that individual systems may use internal data formats\n\
    other than the NTP timestamp format, which is represented in seconds to\na precision\
    \ of about 200 picoseconds; however, a persuasive argument\nexists to use a two-part\
    \ representation, one part for whole days (MJD or\nsome fixed offset from it)\
    \ and the other for the seconds (or some scaled\nvalue, such as milliseconds).\
    \ This not only facilitates conversion\nbetween NTP and conventional civil time,\
    \ but makes the insertion of leap\nseconds much easier. All that is required is\
    \ to change the modulus of\nthe seconds counter, which on overflow increments\
    \ the day counter. This\ndesign insures that continuity of the timescale is assured,\
    \ even if\noutside synchronization is lost before, during or after leap-second\n\
    insertion. Since timestamp data are unaffected, synchronization is\nassured, even\
    \ if timestamp data are in flight at the instant and\noriginated before or at\
    \ that instant.\nAppendix F. The NTP Clock-Combining Algorithm\nIntroduction\n\
    A common problem in synchronization subnets is systematic time-offset\nerrors\
    \ resulting from asymmetric transmission paths, where the networks\nor transmission\
    \ media in one direction are substantially different from\nthe other. The errors\
    \ can range from microseconds on high-speed ring\nnetworks to large fractions\
    \ of a second on satellite/landline paths. It\nhas been found experimentally that\
    \ these errors can be considerably\nreduced by combining the apparent offsets\
    \ of a number of time servers to\nproduce a more accurate working offset. Following\
    \ is a description of\nthe combining method used in the NTP implementation for\
    \ the Fuzzball\n[MIL88b]. The method is similar to that used by national standards\n\
    laboratories to determine a synthetic laboratory timescale from an\nensemble of\
    \ cesium clocks [ALL74b]. These procedures are optional and\nnot required in a\
    \ conforming NTP implementation.\nIn the following description the stability of\
    \ a clock is how well it can\nmaintain a constant frequency, the accuracy is how\
    \ well its frequency\nand time compare with national standards and the precision\
    \ is how\nprecisely these quantities can be maintained within a particular\ntimekeeping\
    \ system. Unless indicated otherwise, The offset of two clocks\nis the time difference\
    \ between them, while the skew is the frequency\ndifference (first derivative\
    \ of offset with time) between them. Real\nclocks exhibit some variation in skew\
    \ (second derivative of offset with\ntime), which is called drift.\nDetermining\
    \ Time and Frequency\nFigure 9<$&fig9> shows the overall organization of the NTP\
    \ time-server\nmodel. Timestamps exchanged with possibly many other subnet peers\
    \ are\nused to determine individual roundtrip delays and clock offsets relative\n\
    to each peer as described in the NTP specification. As shown in the\nfigure, the\
    \ computed delays and offsets are processed by the clock\nfilter to reduce incidental\
    \ timing noise and the most accurate and\nreliable subset determined by the clock-selection\
    \ algorithm. The\nresulting offsets of this subset are first combined as described\
    \ below\nand then processed by the phase-locked loop (PLL). In the PLL the\ncombined\
    \ effects of the filtering, selection and combining operations is\nto produce\
    \ a phase-correction term. This is processed by the loop filter\nto control the\
    \ local clock, which functions as a voltage-controlled\noscillator (VCO). The\
    \ VCO furnishes the timing (phase) reference to\nproduce the timestamps used in\
    \ all calculations.\nClock Modelling\nThe International Standard (SI) definition\
    \ of time interval is in terms\nof the standard second: <169>the duration of 9,192,631,770\
    \ periods of\nthe radiation corresponding to the transition between the two hyperfine\n\
    levels of the ground state of the cesium-133 atom.<170> Let u represent\nthe standard\
    \ unit of time interval so defined and <$Ev~=~1 over u> be\nthe standard unit\
    \ of frequency. The epoch, denoted by t, is defined as\nthe reading of a counter\
    \ that runs at frequency v and began counting at\nsome agreed initial epoch t0,\
    \ which defines the standard or absolute\ntimescale. For the purposes of the following\
    \ analysis, the epoch of the\nstandard timescale, as well as the time indicated\
    \ by a clock will be\nconsidered continuous. In practice, time is determined relative\
    \ to a\nclock constructed from an atomic oscillator and system of\ncounter/dividers,\
    \ which defines a timescale associated with that\nparticular oscillator. Standard\
    \ time and frequency are then determined\nfrom an ensemble of such timescales\
    \ and algorithms designed to combine\nthem to produce a composite timescale approximating\
    \ the standard\ntimescale.\nLet <$ET(t)> be the time displayed by a clock at epoch\
    \ t relative to the\nstandard timescale:\n<$ET(t)~=~1/2 D(t sub 0 )[t~-~t sub\
    \ 0 ] sup 2~+~R(t sub 0 )[t~-~t sub 0\n]~ +~T(t sub 0 )~+~x(t)> ,\nwhere <$ED(t\
    \ sub 0 )> is the fractional frequency drift per unit time,\n<$ER(t sub 0 )> the\
    \ frequency and <$ET(t sub 0 )> the time at some\nprevious epoch t0. In the usual\
    \ stationary model these quantities can be\nassumed constant or changing slowly\
    \ with epoch. The random nature of the\nclock is characterized by <$Ex(t)>, which\
    \ represents the random noise\n(jitter) relative to the standard timescale. In\
    \ the usual analysis the\nsecond-order term <$ED(t sub 0 )> is ignored and the\
    \ noise term <$Ex(t)>\nmodelled as a normal distribution with predictable spectral\
    \ density or\nautocorrelation function.\nThe probability density function of time\
    \ offset <$Eroman p (t~-~T(t))>\nusually appears as a bell-shaped curve centered\
    \ somewhere near zero. The\nwidth and general shape of the curve are determined\
    \ by <$Ex(t)>, which\ndepends on the oscillator precision and jitter characteristics,\
    \ as well\nas the measurement system and its transmission paths. Beginning at\
    \ epoch\nt0 the offset is set to zero, following which the bell creeps either\
    \ to\nthe left or right, depending on the value of <$ER(t sub 0 )> and\naccelerates\
    \ depending on the value of <$ED(t sub 0 )>.\nDevelopment of a Composite Timescale\n\
    Now consider the time offsets of a number of real clocks connected by\nreal networks.\
    \ A display of the offsets of all clocks relative to the\nstandard timescale will\
    \ appear as a system of bell-shaped curves slowly\nprecessing relative to each\
    \ other, but with some further away from\nnominal zero than others. The bells\
    \ will normally be scattered over the\noffset space, more or less close to each\
    \ other, with some overlapping\nand some not. The problem is to estimate the true\
    \ offset relative to the\nstandard timescale from a system of offsets collected\
    \ routinely between\nthe clocks.\nA composite timescale can be determined from\
    \ a sequence of offsets\nmeasured between the n clocks of an ensemble at nominal\
    \ intervals\n<$Etau>. Let <$ER sub i (t sub 0 )> be the frequency and <$ET sub\
    \ i (t\nsub 0 )> the time of the ith clock at epoch t0 relative to the standard\n\
    timescale and let <169>^<170> designate the associated estimates. Then,\nan estimator\
    \ for Ti computed at t0 for epoch <$Et sub 0~+~tau> is\n<$ET hat sub i ( t sub\
    \ 0~+~ tau )~=~R hat sub i (t sub 0 ) tau ~+~T sub\ni (t sub 0 )> ,\nneglecting\
    \ second-order terms. Consider a set of n independent time-\noffset measurements\
    \ made between the clocks at epoch <$Et sub 0 ~+~ tau>\nand let the offset between\
    \ clock i and clock j at that epoch be <$ET sub\nij (t sub 0~+~ tau )>, defined\
    \ as\n<$ET sub ij (t sub 0~+~ tau )~==~T sub i (t sub 0~+~ tau )~-~T sub j (t\n\
    sub 0~+~ tau )> .\nNote that <$ET sub ij~=~- T sub ji> and <$ET sub ii~=~0>. Let\
    \ <$Ew sub i\n( tau )> be a previously determined weight factor associated with\
    \ the\nith clock for the nominal interval <$Etau>. The basis for new estimates\n\
    at epoch <$Et sub 0~+~ tau > is\n<$ET sub j (t sub 0~+~tau )~=~sum from {i=1}\
    \ to n w sub i ( tau )[ T hat\nsub i (t sub 0~+~tau )~+~T sub ji (t sub 0~+~tau\
    \ )].>\nThat is, the apparent time indicated by the jth clock is a weighted\n\
    average of the estimated time of each clock at epoch <$Et sub 0 ~+~ tau>\nplus\
    \ the time offset measured between the jth clock and that clock at\nepoch <$Et\
    \ sub 0 ~+~ tau>.\nAn intuitive grasp of the behavior of this algorithm can be\
    \ gained with\nthe aid of a few examples. For instance, if <$Ew sub i ( tau )>\
    \ is unity\nfor the ith clock and zero for all others, the apparent time for each\
    \ of\nthe other clocks is simply the estimated time <$ET hat sub i (t sub\n0~+~tau\
    \ )>. If <$Ew sub i ( tau )> is zero for the ith clock, that clock\ncan never\
    \ affect any other clock and its apparent time is determined\nentirely from the\
    \ other clocks. If <$Ew sub i ( tau )~=~1 / n> for all\ni, the apparent time of\
    \ the ith clock is equal to the average of the\ntime estimates computed at t0\
    \ plus the average of the time offsets\nmeasured to all other clocks. Finally,\
    \ in a system with two clocks and\n<$Ew sub i ( tau )~=~1 / 2> for each, and if\
    \ the estimated time at epoch\n<$Et sub 0~+~tau> is fast by 1 s for one clock\
    \ and slow by 1 s for the\nother, the apparent time for both clocks will coincide\
    \ with the standard\ntimescale.\nIn order to establish a basis for the next interval\
    \ <$Etau>, it is\nnecessary to update the frequency estimate <$ER hat sub i (t\
    \ sub 0~+~tau\n)> and weight factor <$Ew sub i ( tau )>. The average frequency\
    \ assumed\nfor the ith clock during the previous interval <$Etau> is simply the\n\
    difference between the times at the beginning and end of the interval\ndivided\
    \ by <$Etau>. A good estimator for <$ER sub i (t sub 0~+~tau )>\nhas been found\
    \ to be the exponential average of these differences, which\nis given by\n<$ER\
    \ hat sub i (t sub 0~+~tau )~=~R hat sub i (t sub 0 )~+~alpha sub i [\nR hat sub\
    \ i (t sub 0 )~-~{T sub i (t sub 0~+~tau )~-~T sub i (t sub 0 )}\nover tau ]>\
    \ ,\nwhere <$Ealpha sub i> is an experimentally determined weight factor\nwhich\
    \ depends on the estimated frequency error of the ith clock. In\norder to calculate\
    \ the weight factor <$Ew sub i ( tau )>, it is\nnecessary to determine the expected\
    \ error <$Eepsilon sub i ( tau )> for\neach clock. In the following, braces <169>|<170>\
    \ indicate absolute value\nand brackets <169><<>><170> indicate the infinite time\
    \ average. In\npractice, the infinite averages are computed as exponential time\n\
    averages. An estimate of the magnitude of the unbiased error of the ith\nclock\
    \ accumulated over the nominal interval <$Etau> is\n<$Eepsilon sub i ( tau )~=~|\
    \ T hat sub i ( t sub 0~+~tau )~-~T sub i ( t\nsub 0~+~tau ) |~+~{0.8~<<~epsilon\
    \ sub e sup 2 ( tau )~>> } over sqrt {\n<<~epsilon sub i sup 2 ( tau )~>> }> ,\n\
    where <$Eepsilon sub i ( tau )> and <$Eepsilon sub e ( tau )> are the\naccumulated\
    \ error of the ith clock and entire clock ensemble,\nrespectively. The accumulated\
    \ error of the entire ensemble is\n<$E<<~epsilon sub e sup 2 ( tau )~>>~=~left\
    \ [ sum from i=1 to n~1 over {\n<<~epsilon sub i sup 2 ( tau )~>> } right ] sup\
    \ {~-1}>.\nFinally, the weight factor for the ith clock is calculated as\n<$Ew\
    \ sub i ( tau )~=~ { <<~epsilon sub e sup 2 ( tau )~>> } over {\n<<~epsilon sub\
    \ i sup 2 ( tau )~>> }> .\nWhen all estimators and weight factors have been updated,\
    \ the origin of\nthe estimation interval is shifted and the new value of t0 becomes\
    \ the\nold value of <$Et sub 0 ~+~ tau>.\nWhile not entering into the above calculations,\
    \ it is useful to estimate\nthe frequency error, since the ensemble clocks can\
    \ be located some\ndistance from each other and become isolated for some time\
    \ due to\nnetwork failures. The frequency-offset error in Ri is equivalent to\
    \ the\nfractional frequency yi,\n<$Ey sub i~=~{ nu sub i~-~nu sub I } over nu\
    \ sub I>\nmeasured between the ith timescale and the standard timescale I.\nTemporarily\
    \ dropping the subscript i for clarity, consider a sequence of\nN independent\
    \ frequency-offset samples <$Ey(j)~ (j~=~1,~2,~... ,~N)>\nwhere the interval between\
    \ samples is uniform and equal to T. Let\n<$Etau> be the nominal interval over\
    \ which these samples are averaged.\nThe Allan variance <$Esigma sub y sup 2 (\
    \ N,~T,~tau )> [ALL74a] is\ndefined as\n<$E<< sigma sub y sup 2 ( N,~T,~tau )~>>~=~<<\
    \ ~ 1 over { N~-~1 }~ left [\nsum from j=1 to N~y (j) sup 2~-~1 over N~left (\
    \ sum from j=1 to N~y(j)\nright ) sup 2 right ]~>>> ,\nA particularly useful formulation\
    \ is <$EN~=~2> and <$ET~=~tau>:\n<$E<< sigma sub y sup 2 (N~=~2,~T~=~tau ,~tau\
    \ )>>~==~sigma sub y sup 2 (\ntau )~=~<< {[y(j~+~1)~-~y(j)] sup 2 } over 2 >>>\
    \ ,\nso that\n<$Esigma sub y sup 2 ( tau )~=~1 over {2(N~-~1)}sum from { j = 1\
    \ } to\n{n-1 }~[y(j~+~1)~-~y(j)] sup 2> .\nWhile the Allan variance has found\
    \ application when estimating errors in\nensembles of cesium clocks, its application\
    \ to NTP is limited due to the\ncomputation and storage burden. As described in\
    \ the next section, it is\npossible to estimate errors with some degree of confidence\
    \ using normal\nbyproducts of NTP processing algorithms.\nApplication to NTP\n\
    The NTP clock model is somewhat less complex than the general model\ndescribed\
    \ above. For instance, at the present level of development it is\nnot necessary\
    \ to separately estimate the time and frequency of all peer\nclocks, only the\
    \ time and frequency of the local clock. If the\ntimekeeping reference is the\
    \ local clock itself, then the offsets\navailable in the peer.offset peer variables\
    \ can be used directly for the\n<$ET sub ij> quantities above. In addition, the\
    \ NTP local-clock model\nincorporates a type-II phase-locked loop, which itself\
    \ reliably\nestimates frequency errors and corrects accordingly. Thus, the\nrequirement\
    \ for estimating frequency is entirely eliminated.\nThere remains the problem\
    \ of how to determine a robust and easily\ncomputable error estimate <$Eepsilon\
    \ sub i>. The method described above,\nalthough analytically justified, is most\
    \ difficult to implement.\nHappily, as a byproduct of the NTP clock-filter algorithm,\
    \ a useful\nerror estimate is available in the form of the dispersion. As described\n\
    in the NTP specification, the dispersion includes the absolute value of\nthe weighted\
    \ average of the offsets between the chosen offset sample and\nthe <$En~-~1> other\
    \ samples retained for selection. The effectiveness of\nthis estimator was compared\
    \ with the above estimator by simulation using\nobserved timekeeping data and\
    \ found to give quite acceptable results.\nThe NTP clock-combining algorithm can\
    \ be implemented with only minor\nmodifications to the algorithms as described\
    \ in the NTP specification.\nAlthough elsewhere in the NTP specification the use\
    \ of general-purpose\nmultiply/divide routines has been successfully avoided,\
    \ there seems to\nbe no way to avoid them in the clock-combining algorithm. However,\
    \ for\nbest performance the local-clock algorithm described elsewhere in this\n\
    document should be implemented as well, since the combining algorithms\nresult\
    \ in a modest increase in phase noise which the revised local-clock\nalgorithm\
    \ is designed to suppress.\nClock-Combining Procedure\nThe result of the NTP clock-selection\
    \ procedure is a set of survivors\n(there must be at least one) that represent\
    \ truechimers, or correct\nclocks. When clock combining is not implemented, one\
    \ of these peers,\nchosen as the most likely candidate, becomes the synchronization\
    \ source\nand its computed offset becomes the final clock correction.\nSubsequently,\
    \ the system variables are adjusted as described in the NTP\nclock-update procedure.\
    \ When clock combining is implemented, these\nactions are unchanged, except that\
    \ the final clock correction is\ncomputed by the clock-combining procedure.\n\
    The clock-combining procedure is called from the clock-select procedure.\nIt constructs\
    \ from the variables of all surviving peers the final clock\ncorrection <$ETHETA>.\
    \ The estimated error required by the algorithms\npreviously described is based\
    \ on the synchronization distance <$ELAMBDA>\ncomputed by the distance procedure,\
    \ as defined in the NTP specification.\nThe reciprocal of <$ELAMBDA> is the weight\
    \ of each clock-offset\ncontribution to the final clock correction. The following\
    \ pseudo-code\ndescribes the procedure.\nbegin clock-combining procedure\n   \
    \     <$Etemp1~<<-~0>;\n        <$Etemp2~<<-~0>;\n        for (each peer remaining\
    \ on the candidate list)         /* scan\nall survivors */\n                <$ELAMBDA~<<-~roman\
    \ distance (peer)>;\n                <$Etemp~<<-~1 over roman\n{peer.stratum~times~NTP.MAXDISPERSE~+~LAMBDA\
    \ }>;\n                <$Etemp1~<<-~temp1~+~temp>;             /* update weight\n\
    and offset */\n                <$Etemp2~<<-~temp2~+~temp~times~roman peer.offset>;\n\
    \                endif;\n        <$ETHETA~<<-~temp2 over temp1>;             \
    \                    \n/* compute final correction */\n        end clock-combining\
    \ procedure;\nThe value <$ETHETA> is the final clock correction used by the local-\n\
    clock procedure to adjust the clock.\nAppendix G. Computer Clock Modelling and\
    \ Analysis\nA computer clock includes some kind of reference oscillator, which\
    \ is\nstabilized by a quartz crystal or some other means, such as the power\n\
    grid. Usually, the clock includes a prescaler, which divides the\noscillator frequency\
    \ to a standard value, such as 1 MHz or 100 Hz, and a\ncounter, implemented in\
    \ hardware, software or some combination of the\ntwo, which can be read by the\
    \ processor. For systems intended to be\nsynchronized to an external source of\
    \ standard time, there must be some\nmeans to correct the phase and frequency\
    \ by occasional vernier\nadjustments produced by the timekeeping protocol. Special\
    \ care is\nnecessary in all timekeeping system designs to insure that the clock\n\
    indications are always monotonically increasing; that is, system time\nnever <169>runs\
    \ backwards.<170>\nComputer Clock Models\nThe simplest computer clock consists\
    \ of a hardware latch which is set by\noverflow of a hardware counter or prescaler,\
    \ and causes a processor\ninterrupt or tick. The latch is reset when acknowledged\
    \ by the\nprocessor, which then increments the value of a software clock counter.\n\
    The phase of the clock is adjusted by adding periodic corrections to the\ncounter\
    \ as necessary. The frequency of the clock can be adjusted by\nchanging the value\
    \ of the increment itself, in order to make the clock\nrun faster or slower. The\
    \ precision of this simple clock model is\nlimited to the tick interval, usually\
    \ in the order of 10 ms; although in\nsome systems the tick interval can be changed\
    \ using a kernel variable.\nThis software clock model requires a processor interrupt\
    \ on every tick,\nwhich can cause significant overhead if the tick interval is\
    \ small, say\nin the order less 1 ms with the newer RISC processors. Thus, in\
    \ order to\nachieve timekeeping precisions less than 1 ms, some kind of hardware\n\
    assist is required. A straightforward design consists of a voltage-\ncontrolled\
    \ oscillator (VCO), in which the frequency is controlled by a\nbuffered, digital/analog\
    \ converter (DAC). Under the assumption that the\nVCO tolerance is 10-4 or 100\
    \ parts-per-million (ppm) (a reasonable value\nfor inexpensive crystals) and the\
    \ precision required is 100 <$Emu roman\ns> (a reasonable goal for a RISC processor),\
    \ the DAC must include at\nleast ten bits.\nA design sketch of a computer clock\
    \ constructed entirely of hardware\nlogic components is shown in Figure 10a<$&fig10>.\
    \ The clock is read by\nfirst pulsing the read signal, which latches the current\
    \ value of the\nclock counter, then adding the contents of the clock-counter latch\
    \ and a\n64-bit clock-offset variable, which is maintained in processor memory.\n\
    The clock phase is adjusted by adding a correction to the clock-offset\nvariable,\
    \ while the clock frequency is adjusted by loading a correction\nto the DAC latch.\
    \ In principle, this clock model can be adapted to any\nprecision by changing\
    \ the number of bits of the prescaler or clock\ncounter or changing the VCO frequency.\
    \ However, it does not seem useful\nto reduce precision much below the minimum\
    \ interrupt latency, which is\nin the low microseconds for a modern RISC processor.\n\
    If it is not possible to vary the oscillator frequency, which might be\nthe case\
    \ if the oscillator is an external frequency standard, a design\nsuch as shown\
    \ in Figure 10b may be used. It includes a fixed-frequency\noscillator and prescaler\
    \ which includes a dual-modulus swallow counter\nthat can be operated in either\
    \ divide-by-10 or divide-by-11 modes as\ncontrolled by a pulse produced by a programmable\
    \ divider (PD). The PD is\nloaded with a value representing the frequency offset.\
    \ Each time the\ndivider overflows a pulse is produced which switches the swallow\
    \ counter\nfrom the divide-by-10 mode to the divide-by-11 mode and then back again,\n\
    which in effect <169>swallows<170> or deletes a single pulse of the\nprescaler\
    \ pulse train.\nThe pulse train produced by the prescaler is controlled precisely\
    \ over a\nsmall range by the contents of the PD. If programmed to emit pulses\
    \ at a\nlow rate, relatively few pulses are swallowed per second and the\nfrequency\
    \ counted is near the upper limit of its range; while, if\nprogrammed to emit\
    \ pulses at a high rate, relatively many pulses are\nswallowed and the frequency\
    \ counted is near the lower limit. Assuming\nsome degree of freedom in the choice\
    \ of oscillator frequency and\nprescaler ratios, this design can compensate for\
    \ a wide range of\noscillator frequency tolerances.\nIn all of the above designs\
    \ it is necessary to limit the amount of\nadjustment incorporated in any step\
    \ to insure that the system clock\nindications are always monotonically increasing.\
    \ With the software clock\nmodel this is assured as long as the increment is never\
    \ negative. When\nthe magnitude of a phase adjustment exceeds the tick interval\
    \ (as\ncorrected for the frequency adjustment), it is necessary to spread the\n\
    adjustments over mulitple tick intervals. This strategy amounts to a\ndeliberate\
    \ frequency offset sustained for an interval equal to the total\nnumber of ticks\
    \ required and, in fact, is a feature of the Unix clock\nmodel discussed below.\n\
    In the hardware clock models the same considerations apply; however, in\nthese\
    \ designs the tick interval amounts to a single pulse at the\nprescaler output,\
    \ which may be in the order of 1 ms. In order to avoid\ndecreasing the indicated\
    \ time when a negative phase correction occurs,\nit is necessary to avoid modifying\
    \ the clock-offset variable in\nprocessor memory and to confine all adjustments\
    \ to the VCO or prescaler.\nThus, all phase adjustments must be performed by means\
    \ of programmed\nfrequency adjustments in much the same way as with the software\
    \ clock\nmodel described previously.\nIt is interesting to conjecture on the design\
    \ of a processor assist that\ncould provide all of the above functions in a compact,\
    \ general-purpose\nhardware interface. The interface might consist of a multifunction\
    \ timer\nchip such as the AMD 9513A, which includes five 16-bit counters, each\n\
    with programmable load and hold registers, plus an onboard crystal\noscillator,\
    \ prescaler and control circuitry. A 48-bit hardware clock\ncounter would utilize\
    \ three of the 16-bit counters, while the fourth\nwould be used as the swallow\
    \ counter and the fifth as the programmable\ndivider. With the addition of a programmable-array\
    \ logic device and\narchitecture-specific host interface, this compact design\
    \ could provide\nall the functions necessary for a comprehensive timekeeping system.\n\
    The Fuzzball Clock Model\nThe Fuzzball clock model uses a combination of hardware\
    \ and software to\nprovide precision timing with a minimum of software and processor\n\
    overhead. The model includes an oscillator, prescaler and hardware\ncounter; however,\
    \ the oscillator frequency remains constant and the\nhardware counter produces\
    \ only a fraction of the total number of bits\nrequired by the clock counter.\
    \ A typical design uses a 64-bit software\nclock counter and a 16-bit hardware\
    \ counter which counts the prescaler\noutput. A hardware-counter overflow causes\
    \ the processor to increment\nthe software counter at the bit corresponding to\
    \ the frequency <$E2 sup\nN f sub p>, where N is the number of bits of the hardware\
    \ counter and fp\nis the counted frequency at the prescaler output. The processor\
    \ reads\nthe clock counter by first generating a read pulse, which latches the\n\
    hardware counter, and then adding its contents, suitably aligned, to the\nsoftware\
    \ counter.\nThe Fuzzball clock can be corrected in phase by adding a (signed)\n\
    adjustment to the software clock counter. In practice, this is done only\nwhen\
    \ the local time is substantially different from the time indicated\nby the clock\
    \ and may violate the monotonicity requirement. Vernier phase\nadjustments determined\
    \ in normal system operation must be limited to no\nmore than the period of the\
    \ counted frequency, which is 1 kHz for LSI-11\nFuzzballs. In the Fuzzball model\
    \ these adjustments are performed at\nintervals of 4 s, called the adjustment\
    \ interval, which provides a\nmaximum frequency adjustment range of 250 ppm. The\
    \ adjustment\nopportunities are created using the interval-timer facility, which\
    \ is a\nfeature of most operating systems and independent of the time-of-day\n\
    clock. However,  if the counted frequency is increased from 1 kHz to 1\nMHz for\
    \ enhanced precision, the adjustment frequency must be increased\nto 250 Hz, which\
    \ substantially increases processor overhead. A modified\ndesign suitable for\
    \ high precision clocks is presented in the next\nsection.\nIn some applications\
    \ involving the Fuzzball model, an external pulse-\nper-second (pps) signal is\
    \ available from a reference source such as a\ncesium clock or GPS receiver. Such\
    \ a signal generally provides much\nhigher accuracy than the serial character\
    \ string produced by a radio\ntimecode receiver, typically in the low nanoseconds.\
    \ In the Fuzzball\nmodel this signal is processed by an interface which produces\
    \ a hardware\ninterrupt coincident with the arrival of the pps pulse. The processor\n\
    then reads the clock counter and computes the residual modulo 1 s of the\nclock\
    \ counter. This represents the local-clock error relative to the pps\nsignal.\n\
    Assuming the seconds numbering of the clock counter has been determined\nby a\
    \ reliable source, such as a timecode receiver, the offset within the\nsecond\
    \ is determined by the residual computed above. In the NTP local-\nclock model\
    \ the timecode receiver or NTP establishes the time to within\n<F128M><F255D>128\
    \ ms, called the aperture, which guarantees the seconds\nnumbering to within the\
    \ second. Then, the pps residual can be used\ndirectly to correct the oscillator,\
    \ since the offset must be less than\nthe aperture for a correctly operating timecode\
    \ receiver and pps signal.\nThe above technique has an inherent error equal to\
    \ the latency of the\ninterrupt system, which in modern RISC processors is in\
    \ the low tens of\nmicroseconds. It is possible to improve accuracy by latching\
    \ the\nhardware time-of-day counter directly by the pps pulse and then reading\n\
    the counter in the same way as usual. This requires additional circuitry\nto prioritize\
    \ the pps signal relative to the pulse generated by the\nprogram to latch the\
    \ counter.\nThe Unix Clock Model\nThe Unix 4.3bsd clock model is based on two\
    \ system calls, settimeofday\nand adjtime, together with two kernel variables\
    \ tick and tickadj. The\nsettimeofday call unceremoniously resets the kernel clock\
    \ to the value\ngiven, while the adjtime call slews the kernel clock to a new\
    \ value\nnumerically equal to the sum of the present time of day and the (signed)\n\
    argument given in the adjtime call. In order to understand the behavior\nof the\
    \ Unix clock as controlled by the Fuzzball clock model described\nabove, it is\
    \ helpful to explore the operations of adjtime in more\ndetail.\nThe Unix clock\
    \ model assumes an interrupt produced by an onboard\nfrequency source, such as\
    \ the clock counter and prescaler described\npreviously, to deliver a pulse train\
    \ in the 100-Hz range. In priniciple,\nthe power grid frequency can be used, although\
    \ it is much less stable\nthan a crystal oscillator. Each interrupt causes an\
    \ increment called\ntick to be added to the clock counter. The value of the increment\
    \ is\nchosen so that the clock counter, plus an initial offset established by\n\
    the settimeofday call, is equal to the time of day in microseconds.\nThe Unix\
    \ clock can actually run at three different rates, one\ncorresponding to tick,\
    \ which is related to the intrinsic frequency of\nthe particular oscillator used\
    \ as the clock source, one to\n<$Etick~+~tickadj> and the third to <$Etick~-~tickadj>.\
    \ Normally the\nrate corresponding to tick is used; but, if adjtime is called,\
    \ the\nargument <$Edelta> given is used to calculate an interval <$EDELTA\nt~=~delta~tick\
    \ over tickadj> during which one or the other of the two\nrates are used, depending\
    \ on the sign of <$Edelta>. The effect is to\nslew the clock to a new value at\
    \ a small, constant rate, rather than\nincorporate the adjustment all at once,\
    \ which could cause the clock to\nbe set backward. With common values of <$Etick~=~10>\
    \ ms and\n<$Etickadj~=~5~mu roman s>, the maximum frequency adjustment range is\n\
    <$E+- tickadj over tick~=~+- {5~roman x~10 sup -6} over {10 sup -2}> or\n<F128M><F255D>500\
    \ ppm. Even larger ranges may be required in the case\nof some workstations (e.g.,\
    \ SPARCstations) with extremely poor component\ntolerances.\nWhen precisions not\
    \ less than about 1 ms are required, the Fuzzball\nclock model can be adapted\
    \ to the Unix model by software simulation, as\ndescribed in Section 5 of the\
    \ NTP specification, and calling adjtime at\neach adjustment interval. When precisions\
    \ substantially better than this\nare required, the hardware microsecond clock\
    \ provided in some\nworkstations can be used together with certain refinements\
    \ of the\nFuzzball and Unix clock models. The particular design described below\
    \ is\nappropriate for a maximum oscillator frequency tolerance of 100 ppm\n(.01%),\
    \ which can be obtained using a relatively inexpensive quartz\ncrystal oscillator,\
    \ but is readily scalable for other assumed\ntolerances.\nThe clock model requires\
    \ the capability to slew the clock frequency over\nthe range <F128M><F255D>100\
    \ ppm with an intrinsic oscillator frequency\nerror as great as <F128M><F255D>100\
    \ ppm. Figure 11<$&fig11> shows the\ntiming relationships at the extremes of the\
    \ requirements envelope.\nStarting from an assumed offset of nominal zero and\
    \ an assumed error of\n+100 ppm at time 0 s, the line AC shows how the uncorrected\
    \ offset grows\nwith time. Let <$Esigma> represent the adjustment interval and\
    \ a the\ninterval AB, in seconds, and let r be the slew, or rate at which\ncorrections\
    \ are introduced, in ppm. For an accuracy specification of 100\n<$Emu roman s>,\
    \ then\n<$Esigma~<<=~{100~mu roman s} over {100~roman ppm}~+~{100~mu roman s}\n\
    over {(r~-~100)~roman ppm}~=~r over {r~-~100}> .\nThe line AE represents the extreme\
    \ case where the clock is to be steered\n<F128M>-<F255D>100 ppm. Since the slew\
    \ must be complete at the end of\nthe adjustment interval,\n<$Ea~<<=~{(r~-~200)~sigma}\
    \ over r>.\nThese relationships are satisfied only if <$Er~>>~200~roman ppm> and\n\
    <$Esigma~<<~2~roman s>. Using <$Er~=~300~roman ppm> for convenience,\n<$Esigma~=~1.5~roman\
    \ s> and <$Ea~<<=~0.5~roman s>. For the Unix clock\nmodel with <$Etick~=~10~roman\
    \ ms>, this results in the value of\n<$Etickadj~=~3~mu roman s>.\nOne of the assumptions\
    \ made in the Unix clock model is that the period\nof adjustment computed in the\
    \ adjtime call must be completed before the\nnext call is made. If not, this results\
    \ in an error message to the\nsystem log. However, in order to correct for the\
    \ intrinsic frequency\noffset of the clock oscillator, the NTP clock model requires\
    \ adjtime to\nbe called at regular adjustment intervals of <$Esigma> s. Using\
    \ the\nalgorithms described here and the architecture constants in the NTP\nspecification,\
    \ these adjustments will always complete.\nMathematical Model of the NTP Logical\
    \ Clock\nThe NTP logical clock can be represented by the feedback-control model\n\
    shown in Figure 12<$&fig12>. The model consists of an adaptive-\nparameter, phase-lock\
    \ loop (PLL), which continuously adjusts the phase\nand frequency of an oscillator\
    \ to compensate for its intrinsic jitter,\nwander and drift. A mathematical analysis\
    \ of this model developed along\nthe lines of [SMI86] is presented in following\
    \ sections, along with a\ndesign example useful for implementation guidance in\
    \ operating-systems\nenvironments such as Unix and Fuzzball. Table 9<$&tab9> summarizes\
    \ the\nquantities ordinarily treated as variables in the model. By convention,\n\
    <$Ev> is used for internal loop variables, <$Etheta> for phase,\n<$Eomega> for\
    \ frequency and <$Etau> for time. Table 10<$&tab10>\nsummarizes those quantities\
    \ ordinarily fixed as constants in the model.\nNote that these are all expressed\
    \ as a power of two in order to simplify\nthe implementation.\nIn Figure 12 the\
    \ variable <$Etheta sub r> represents the phase of the\nreference signal and <$Etheta\
    \ sub o> the phase of the voltage-controlled\noscillator (VCO). The phase detector\
    \ (PD) produces a voltage <$Ev sub d>\nrepresenting the phase difference <$Etheta\
    \ sub r~-~theta sub o> . The\nclock filter functions as a tapped delay line, with\
    \ the output <$Ev sub\ns> taken at the tap selected by the clock-filter algorithm\
    \ described in\nthe NTP specification. The loop filter, represented by the equations\n\
    given below, produces a VCO correction voltage <$Ev sub c>, which\ncontrols the\
    \ oscillator frequency and thus the phase <$Etheta sub o>.\nThe PLL behavior is\
    \ completely determined by its open-loop, Laplace\ntransfer function <$EG(s)>\
    \ in the s domain. Since both frequency and\nphase corrections are required, an\
    \ appropriate design consists of a\ntype-II PLL, which is defined by the function\n\
    <$EG(s)~=~{omega sub c sup 2} over {tau sup 2 s sup 2}~( 1 ~+~{tau s}\nover omega\
    \ sub z )> ,\nwhere <$Eomega sub c> is the crossover frequency (also called loop\n\
    gain), <$Eomega sub z> is the corner frequency (required for loop\nstability)\
    \ and <$Etau> determines the PLL time constant and thus the\nbandwidth. While\
    \ this is a first-order function and some improvement in\nphase noise might be\
    \ gained from a higher-order function, in practice\nthe improvement is lost due\
    \ to the effects of the clock-filter delay, as\ndescribed below.\nThe open-loop\
    \ transfer function <$EG(s)> is constructed by breaking the\nloop at point a on\
    \ Figure 12 and computing the ratio of the output phase\n<$Etheta sub o (s)> to\
    \ the reference phase <$Etheta sub r (s)>. This\nfunction is the product of the\
    \ individual transfer functions for the\nphase detector, clock filter, loop filter\
    \ and VCO. The phase detector\ndelivers a voltage <$Ev sub d (t)~=~ theta sub\
    \ r (t)>, so its transfer\nfunction is simply <$EF sub d (s)~=~1>, expressed in\
    \ V/rad. The VCO\ndelivers a frequency change <$EDELTA omega ~=~{roman d~theta\
    \ sub o (t)}\nover {roman dt}~=~alpha {v sub c (t)}>, where <$Ealpha> is the VCO\
    \ gain\nin rad/V-sec and <$Etheta sub o (t)~=~alpha~int v sub c (t)~dt>. Its\n\
    transfer function is the Laplace transform of the integral, <$EF sub o\n(s)~=~alpha\
    \ over s>, expressed in rad/V. The clock filter contributes a\nstochastic delay\
    \ due to the clock-filter algorithm; but, for present\npurposes, this delay will\
    \ be assumed a constant T, so its transfer\nfunction is the Laplace transform\
    \ of the delay, <$EF sub s (s)~=~e sup\n{- Ts}>. Let <$EF(s)> be the transfer\
    \ function of the loop filter, which\nhas yet to be determined. The open-loop\
    \ transfer function <$EG(s)> is\nthe product of these four individual transfer\
    \ functions:\n<$EG(s)~=~{omega sub c sup 2} over {tau sup 2 s sup 2}~( 1 ~+~{tau\
    \ s}\nover omega sub z )~=~F sub d (s) F sub s (s) F(s) F sub o (s)~=~1e sup\n\
    {-Ts}~F(s)~alpha over s> .\nFor the moment, assume that the product <$ETs> is\
    \ small, so that <$Ee\nsup {-Ts}~approx ~1>. Making the following substitutions,\n\
    <$Eomega sub c sup 2~=~alpha over { K sub f}~~~~> and <$E~~~~omega sub\nz~=~K\
    \ sub g over {K sub f}>\nand rearranging yields\n<$EF(s)~=~1 over {K sub g~tau}~+~1\
    \ over {K sub f~tau sup 2 s }> ,\nwhich corresponds to a constant term plus an\
    \ integrating term scaled by\nthe PLL time constant <$Etau>. This form is convenient\
    \ for\nimplementation as a sampled-data system, as described later.\nWith the\
    \ parameter values given in Table 10, the Bode plot of the open-\nloop transfer\
    \ function <$EG(s)> consists of a <196>12 dB/octave line\nwhich intersects the\
    \ 0-dB baseline at <$Eomega sub c~=~2 sup -12> rad/s,\ntogether with a +6 dB/octave\
    \ line at the corner frequency <$Eomega sub\nz~=~2 sup -14> rad/s. The damping\
    \ factor <$Ezeta~=~omega sub c over {2\nomega sub z}~=~2> suggests the PLL will\
    \ be stable and have a large phase\nmargin together with a low overshoot. However,\
    \ if the clock-filter delay\nT is not small compared to the loop delay, which\
    \ is approximately equal\nto <$E1 over omega sub c>, the above analysis becomes\
    \ unreliable and the\nloop can become unstable. With the values determined as\
    \ above, T is\nordinarily small enough to be neglected.\nAssuming the output is\
    \ taken at <$Ev sub s>, the closed-loop transfer\nfunction <$EH(s)> is\n<$EH(s)~==~{v\
    \ sub s (s)} over {theta sub r (s)}~=~{F sub d (s) e sup {-\nTs}} over {1~+~G(s)}>\
    \ .\nIf only the relative response is needed and the clock-filter delay can\n\
    be neglected, <$EH(s)> can be written\n<$EH(s)~=~1 over {1~+~G(s)}~=~s sup 2 over\
    \ {s sup 2~+~omega sub c sup 2\nover {omega sub z~tau} s~+~omega sub c sup 2 over\
    \ tau sup 2}> .\nFor some input function <$EI(s)> the output function <$EI(s)H(s)>\
    \ can be\ninverted to find the time response. Using a unit-step input <$EI(s)~=~1\n\
    over s> and the values determined as above, This yields a PLL risetime\nof about\
    \ 52 minutes, a maximum overshoot of about 4.8 percent in about\n1.7 hours and\
    \ a settling time to within one percent of the initial\noffset in about 8.7 hours.\n\
    Parameter Management\nA very important feature of the NTP PLL design is the ability\
    \ to adapt\nits behavior to match the prevailing stability of the local oscillator\n\
    and transmission conditions in the network. This is done using the\n<$Ealpha>\
    \ and <$Etau> parameters shown in Table 10. Mechanisms for doing\nthis are described\
    \ in following sections.\nAdjusting VCO Gain (<$Ebold alpha>)\nThe <$Ealpha> parameter\
    \ is determined by the maximum frequency tolerance\nof the local oscillator and\
    \ the maximum jitter requirements of the\ntimekeeping system. This parameter is\
    \ usually an architecture constant\nand fixed during system operation. In the\
    \ implementation model described\nbelow, the reciprocal of <$Ealpha>, called the\
    \ adjustment interval\n<$Esigma>, determines the time between corrections of the\
    \ local clock,\nand thus the value of <$Ealpha>. The value of <$Esigma> can be\n\
    determined by the following procedure.\nThe maximum frequency tolerance for board-mounted,\
    \ uncompensated quartz-\ncrystal oscillators is probably in the range of 10-4\
    \ (100 ppm). Many if\nnot most Internet timekeeping systems can tolerate jitter\
    \ to at least\nthe order of the intrinsic local-clock resolution, called precision\
    \ in\nthe NTP specification, which is commonly in the range from one to 20 ms.\n\
    Assuming 10-3 s peak-to-peak as the most demanding case, the interval\nbetween\
    \ clock corrections must be no more than <$Esigma~=~10 sup -3 over\n{2 roman~x~10\
    \ sup -4}~=~5> sec. For the NTP reference model\n<$Esigma~=~4> sec in order to\
    \ allow for known features of the Unix\noperating-system kernel. However, in order\
    \ to support future anticipated\nimprovements in accuracy possible with faster\
    \ workstations, it may be\nuseful to decrease <$Esigma> to as little as one-tenth\
    \ the present\nvalue.\nNote that if <$Esigma> is changed, it is necessary to adjust\
    \ the\nparameters <$EK sub f> and <$EK sub g> in order to retain the same loop\n\
    bandwidth; in particular, the same <$Eomega sub c> and <$Eomega sub z>.\nSince\
    \ <$Ealpha> varies as the reciprocal of <$Esigma>, if <$Esigma> is\nchanged to\
    \ something other than 22, as in Table 10, it is necessary to\ndivide both <$EK\
    \ sub f> and <$EK sub g> by <$Esigma over 4> to obtain\nthe new values.\nAdjusting\
    \ PLL Bandwidth (<$Ebold tau>)\nA key feature of the type-II PLL design is its\
    \ capability to compensate\nfor the intrinsic frequency errors of the local oscillator.\
    \ This\nrequires a initial period of adaptation in order to refine the frequency\n\
    estimate (see later sections of this appendix). The <$Etau> parameter\ndetermines\
    \ the PLL time constant and thus the loop bandwidth, which is\napproximately equal\
    \ to <$E{omega sub c} over tau>. When operated with a\nrelatively large bandwidth\
    \ (small <$Etau>), as in the analysis above,\nthe PLL adapts quickly to changes\
    \ in the input reference signal, but has\npoor long term stability. Thus, it is\
    \ possible to accumulate substantial\nerrors if the system is deprived of the\
    \ reference signal for an extended\nperiod. When operated with a relatively small\
    \ bandwidth (large <$Etau>),\nthe PLL adapts slowly to changes in the input reference\
    \ signal, and may\neven fail to lock onto it. Assuming the frequency estimate\
    \ has\nstabilized, it is possible for the PLL to coast for an extended period\n\
    without external corrections and without accumulating significant error.\nIn order\
    \ to achieve the best performance without requiring individual\ntailoring of the\
    \ loop bandwidth, it is necessary to compute each value\nof <$Etau> based on the\
    \ measured values of offset, delay and dispersion,\nas produced by the NTP protocol\
    \ itself. The traditional way of doing\nthis in precision timekeeping systems\
    \ based on cesium clocks, is to\nrelate <$Etau> to the Allan variance, which is\
    \ defined as the mean of\nthe first-order differences of sequential samples measured\
    \ during a\nspecified interval <$Etau>,\n<$Esigma sub y sup 2 ( tau )~=~1 over\
    \ {2(N~-~1)}sum from { i = 1 } to\n{N-1 }~[y(i~+~1)~-~y(i)] sup 2> ,\nwhere y\
    \ is the fractional frequency measured with respect to the local\ntimescale and\
    \ N is the number of samples.\nIn the NTP local-clock model the Allan variance\
    \ (called the compliance,\nh in Table 11) is approximated on a continuous basis\
    \ by exponentially\naveraging the first-order differences of the offset samples\
    \ using an\nempirically determined averaging constant. Using somewhat ad-hoc mapping\n\
    functions determined from simulation and experience, the compliance is\nmanipulated\
    \ to produce the loop time constant and update interval.\nThe NTP Clock Model\n\
    The PLL behavior can also be described by a set of recurrence equations,\nwhich\
    \ depend upon several variables and constants. The variables and\nparameters used\
    \ in these equations are shown in Tables 9, 10 and\n11<$&tab11>. Note the use\
    \ of powers of two, which facilitates\nimplementation using arithmetic shifts\
    \ and avoids the requirement for a\nmultiply/divide capability.\nA capsule overview\
    \ of the design may be helpful in understanding how it\noperates. The logical\
    \ clock is continuously adjusted in small increments\nat fixed intervals of <$Esigma>.\
    \ The increments are determined while\nupdating the variables shown in Tables\
    \ 9 and 11, which are computed from\nreceived NTP messages as described in the\
    \ NTP specification. Updates\ncomputed from these messages occur at discrete times\
    \ as each is\nreceived. The intervals <$Emu> between updates are variable and\
    \ can\nrange up to about 17 minutes. As part of update processing the\ncompliance\
    \ h is computed and used to adjust the PLL time constant\n<$Etau>. Finally, the\
    \ update interval <$Erho> for transmitted NTP\nmessages is determined as a fixed\
    \ multiple of <$Etau>.\nith update shown in Figure 13<$&fig13>. All variables\
    \ are initialized at\n<$Ei~=~0> to zero, except the time constant <$Etau (0)~=~tau>,\
    \ poll\ninterval <$Emu (0)~=~tau> (from Table 10) and compliance <$Eh (0)~=~K\n\
    sub s>. After an interval <$Emu (i)> (<$Ei~>>~0>) from the previous\nupdate the\
    \ ith update arrives at time <$Et(i)> including the time\noffset <$Ev sub s (i)>.\
    \ Then, after an interval <$Emu (i~+~1)> the\n<$Ei+1 roman th> update arrives\
    \ at time <$Et(i~+~1)> including the time\noffset <$Ev sub s (i~+~1)>. When the\
    \ update <$Ev sub s (i)> is received,\nthe frequency error <$Ef(i~+~1)> and phase\
    \ error <$Eg(i~+~1)> are\ncomputed:\n<$Ef(i~+~1)~=~f(i)~+~{mu (i) v sub s (i)}\
    \ over {tau (i) sup 2 }>\n,<$E~~~~~g(i~+~1)~=~{v sub s (i)} over {tau (i)}> .\n\
    Note that these computations depend on the value of the time constant\n<$Etau\
    \ (i)> and poll interval <$Emu (i)> previously computed from the\n<$Ei-1 roman\
    \ th> update. Then, the time constant for the next interval\nis computed from\
    \ the current value of the compliance <$Eh(i)>\n<$Etau (i~+~1)~=~roman max [K\
    \ sub s~-~|~h(i)|,~1]> .\nNext, using the new value of <$Etau>, called <$Etau\
    \ prime> to avoid\nconfusion, the poll interval is computed\n<$Erho (i~+~1)~=~K\
    \ sub u~tau prime> .\nFinally, the compliance <$Eh(i~+~1)> is recomputed for use\
    \ in the <$Ei+1\nroman th> update:\n<$Eh(i~+~1)~=~h(i)~+~{K sub t~tau prime v\
    \ sub s (i)~-~h(i) }over K sub\nh> .\nThe factor <$Etau prime> in the above has\
    \ the effect of adjusting the\nbandwidth of the PLL as a function of compliance.\
    \ When the compliance\nhas been low over some relatively long period, <$Etau prime>\
    \ is\nincreased and the bandwidth is decreased. In this mode small timing\nfluctuations\
    \ due to jitter in the network are suppressed and the PLL\nattains the most accurate\
    \ frequency estimate. On the other hand, if the\ncompliance becomes high due to\
    \ greatly increased jitter or a systematic\nfrequency offset, <$Etau prime> is\
    \ decreased and the bandwidth is\nincreased. In this mode the PLL is most adaptive\
    \ to transients which can\noccur due to reboot of the system or a major timing\
    \ error. In order to\nmaintain optimum stability, the poll interval <$Erho> is\
    \ varied directly\nwith <$Etau>.\nA model suitable for simulation and parameter\
    \ refinement can be\nconstructed from the above recurrence relations. It is convenient\
    \ to set\nthe temporary variable <$Ea~=~g(i~+~1)>. At each adjustment interval\n\
    <$Esigma> the quantity <$Ea over K sub g~+~{f(i~+~1)} over K sub f> is\nadded\
    \ to the local-clock phase and the quantity <$Ea over K sub g> is\nsubtracted\
    \ from a. For convenience, let n be the greatest integer in\n<$E{mu (i)} over\
    \ sigma>; that is, the number of adjustments that occur\nin the ith interval.\
    \ Thus, at the end of the ith interval just before\nthe <$Ei+1 roman th> update,\
    \ the VCO control voltage is:\n<$Ev sub c (i~+~1)~=~v sub c (i)~+~{[1~-~(1~-~1\
    \ over K sub g ) sup n\n]}~{g(i~+~1)} ~+~n over {K sub f }~{ f(i~+~1)}~.>\nDetailed\
    \ simulation of the NTP PLL with the values specified in Tables\n9, 10 and 11\
    \ and the clock filter described in the NTP specification\nresults in the following\
    \ characteristics: For a 100-ms phase change the\nloop reaches zero error in 39\
    \ minutes, overshoots 7 ms at 54 minutes and\nsettles to less than 1 ms in about\
    \ six hours. For a 50-ppm frequency\nchange the loop reaches 1 ppm in about 16\
    \ hours and 0.1 ppm in about 26\nhours. When the magnitude of correction exceeds\
    \ a few milliseconds or a\nfew ppm for more than a few updates, the compliance\
    \ begins to increase,\nwhich causes the loop time constant and update interval\
    \ to decrease.\nWhen the magnitude of correction falls below about 0.1 ppm for\
    \ a few\nhours, the compliance begins to decrease, which causes the loop time\n\
    constant and update interval to increase. The effect is to provide a\nbroad capture\
    \ range exceeding 4 s per day, yet the capability to resolve\noscillator skew\
    \ well below 1 ms per day. These characteristics are\nappropriate for typical\
    \ crystal-controlled oscillators with or without\ntemperature compensation or\
    \ oven control.\nAppendix H. Analysis of Errors and Correctness Principles\nIntroduction\n\
    This appendix contains an analysis of errors arising in the generation\nand processing\
    \ of NTP timestamps and the determination of delays and\noffsets. It establishes\
    \ error bounds as a function of measured roundtrip\ndelay and dispersion to the\
    \ root (primary reference source) of the\nsynchronization subnet. It also discusses\
    \ correctness assertions about\nthese error bounds and the time-transfer, filtering\
    \ and selection\nalgorithms used in NTP.\nThe notation <$Ew~=~[u,~v]> in the following\
    \ describes the interval in\nwhich u is the lower limit and v the upper limit,\
    \ inclusive. Thus,\n<$Eu~=~min (w)~<<=~v~=~max (w)>, and for scalar a,\n<$Ew~+~a~=~[u~+~a,~v~+~a]>.\
    \ Table 12<$&tab12> shows a summary of other\nnotation used in the analysis. The\
    \ notation <$E<<~x~>>> designates the\n(infinite) average of x, which is usually\
    \ approximated by an exponential\naverage, while the notation <$Ex hat> designates\
    \ an estimator for x. The\nlower-case Greek letters <$Etheta>, <$Edelta> and <$Eepsilon>\
    \ are used\nto designate measurement data for the local clock to a peer clock,\
    \ while\nthe upper-case Greek letters <$ETHETA>, <$EDELTA> and <$EEPSILON> are\n\
    used to designate measurement data for the local clock relative to the\nprimary\
    \ reference source at the root of the synchronization subnet.\nExceptions will\
    \ be noted as they arise.\nTimestamp Errors\nThe standard second (1 s) is defined\
    \ as <169>9,192,631,770 periods of\nthe radiation corresponding to the transition\
    \ between the two hyperfine\nlevels of the ground state of the cesium-133 atom<170>\
    \ [ALL74b], which\nimplies a granularity of about 1.1x10-10 s. Other intervals\
    \ can be\ndetermined as rational multiples of 1 s. While NTP time has an inherent\n\
    resolution of about 2.3x10-10 s, local clocks ordinarily have\nresolutions much\
    \ worse than this, so the inherent error in resolving NTP\ntime relative to the\
    \ 1 s can be neglected.\nIn this analysis the local clock is represented by a\
    \ counter/divider\nwhich increments at intervals of s seconds and is driven by\
    \ an\noscillator which operates at frequency <$Ef sub c~=~n over s> for some\n\
    integer n. A timestamp <$ET(t)> is determined by reading the clock at an\narbitrary\
    \ time t (the argument t will be usually omitted for\nconciseness). Strictly speaking,\
    \ s is not known exactly, but can be\nassumed bounded from above by the maximum\
    \ reading error <$Erho>. The\nreading error itself is represented by the random\
    \ variable r bounded by\nthe interval <$E[-~rho ,~0]>, where <$Erho> depends on\
    \ the particular\nclock implementation. Since the intervals between reading the\
    \ same clock\nare almost always independent of and much larger than s, successive\n\
    readings can be considered independent and identically distributed. The\nfrequency\
    \ error of the clock oscillator is represented by the random\nvariable f bounded\
    \ by the interval <$E[-~phi ,~phi ]>, where <$Ephi>\nrepresents the maximum frequency\
    \ tolerance of the oscillator throughout\nits service life. While f for a particular\
    \ clock is a random variable\nwith respect to the population of all clocks, for\
    \ any one clock it\nordinarily changes only slowly with time and can usually be\
    \ assumed a\nconstant for that clock. Thus, an NTP timestamp can be represented\
    \ by\nthe random variable T:\n<$ET~=~t~+~r~+~f tau> ,\nwhere t represents a clock\
    \ reading, <$Etau> represents the time interval\nsince this reading and minor\
    \ approximations inherent in the measurement\nof <$Etau> are neglected.\nIn order\
    \ to assess the nature and expected magnitude of timestamp errors\nand the calculations\
    \ based on them, it is useful to examine the\ncharacteristics of the probability\
    \ density functions (pdf) <$Ep sub r\n(x)> and <$Ep sub f (x)> for r and f respectively.\
    \ Assuming the clock\nreading and counting processes are independent, the pdf\
    \ for r is uniform\nover the interval <$E[-~rho ,~0]>. With conventional manufacturing\n\
    processes and temperature variations the pdf for f can be approximated\nby a truncated,\
    \ zero-mean Gaussian distribution with standard deviation\n<$Esigma>. In conventional\
    \ manufacturing processes <$Esigma> is\nmaneuvered so that the fraction of samples\
    \ rejected outside the interval\n<$E[-~phi ,~phi ]> is acceptable. The pdf for\
    \ the total timestamp error\n<$Eepsilon (x)> is thus the sum of the r and f contributions,\
    \ computed\nas\n<$Eepsilon (x)~ =~ int~from {- inf } to inf p sub r (t) p sub\
    \ f (x~-~t)\nd t> ,\nwhich appears as a bell-shaped curve, symmetric about <$E-~rho\
    \ over 2>\nand bounded by the interval\n<$E[ min (r)~+~min (f tau ),~max (r)~+~max\
    \ (f tau )]~=~[-~rho ~-~phi tau\n,~phi tau ]> .\nSince f changes only slowly over\
    \ time for any single clock,\n<$Eepsilon~==~[ min (r)~+~f tau ,~max (r)~+~f tau\
    \ ]~=~ [-~ rho ,~0]~+~f\ntau> ,\nwhere <$Eepsilon> without argument designates\
    \ the interval and\n<$Eepsilon (x)> designates the pdf. In the following development\n\
    subscripts will be used on various quantities to indicate to which\nentity or\
    \ timestamp the quantity applies. Occasionally, <$Eepsilon> will\nbe used to designate\
    \ an absolute maximum error, rather than the\ninterval, but the distinction will\
    \ be clear from context.\nMeasurement Errors\nIn NTP the roundtrip delay and clock\
    \ offset between two peers A and B\nare determined by a procedure in which timestamps\
    \ are exchanged via the\nnetwork paths between them. The procedure involves the\
    \ four most recent\ntimestamps numbered as shown in Figure 14<$&fig14>, where\
    \ the <$Etheta\nsub 0> represents the true clock offset of peer B relative to\
    \ peer A.\nThe <$ET sub 1> and <$ET sub 4> timestamps are determined relative\
    \ to\nthe A clock, while the <$ET sub 2> and <$ET sub 3> timestamps are\ndetermined\
    \ relative to the B clock. The measured roundtrip delay\n<$Edelta> and clock offset\
    \ <$Etheta> of B relative to A are given by\n<$Edelta~=~(T sub 4~-~T sub 1 )~-~(T\
    \ sub 3~-~T sub 2\n)~~~~and~~~~theta~=~{(T sub 2~-~T sub 1 )~+~(T sub 3~-~T sub\
    \ 4 )} over\n2> .\nThe errors inherent in determining the timestamps T1, T2, T3\
    \ and T4 are,\nrespectively,\n<$Eepsilon sub 1~=~[-~rho sub A ,~0]>, <$E~epsilon\
    \ sub 2~=~[-~rho sub B\n,~0]>, <$E~epsilon sub 3~=~[-~rho sub B ,~0]~+~f sub B\
    \ (T sub 3 ~-~T sub\n2 )>, <$E~epsilon sub 4~=~[-~rho sub A ,~0]~+~f sub A (T\
    \ sub 4 ~-~T sub\n1 )> .\nFor specific peers A and B, where <$Ef sub A> and <$Ef\
    \ sub B> can be\nconsidered constants, the interval containing the maximum error\
    \ inherent\nin determining <$Edelta> is given by\n<$E[ min ( epsilon sub 4 )~-~max\
    \ ( epsilon sub 1 )~-~max ( epsilon sub 3\n)~+~min ( epsilon sub 2 ),~ max ( epsilon\
    \ sub 4 )~-~min ( epsilon sub 1\n)~-~min ( epsilon sub 3 )~+~max ( epsilon sub\
    \ 2 )]>\n<$E=~[-~rho sub A~-~rho sub B ,~rho sub A ~+~rho sub B ]~+~f sub A (T\n\
    sub 4~-~T sub 1 )~-~f sub B (T sub 3~-~T sub 2 )> .\nIn the NTP local clock model\
    \ the residual frequency errors <$Ef sub A>\nand <$Ef sub B> are minimized through\
    \ the use of a type-II phase-lock\nloop (PLL). Under most conditions these errors\
    \ will be small and can be\nignored. The pdf for the remaining errors is symmetric,\
    \ so that <$Edelta\nhat~=~<< delta >>> is an unbiased maximum-likelihood estimator\
    \ for the\ntrue roundtrip delay, independent of the particular values of <$Erho\
    \ sub\nA> and <$Erho sub B>.\nHowever, in order to reliably bound the errors under\
    \ all conditions of\ncomponent variation and operational regimes, the design of\
    \ the PLL and\nthe tolerance of its intrinsic oscillator must be controlled so\
    \ that it\nis not possible under any circumstances for <$Ef sub A> or <$Ef sub\
    \ B>\nto exceed the bounds <$E[-~phi sub A ,~phi sub A ]> or <$E[-~phi sub B\n\
    ,~phi sub B ]>, respectively. Setting <$Erho~=~max ( rho sub A ,~rho sub\nB )>\
    \ for convenience, the absolute maximum error <$Eepsilon sub delta>\ninherent\
    \ in determining roundtrip delay <$Edelta> is given by\n<$Eepsilon sub delta~==~rho~+~phi\
    \ sub A (T sub 4~-~T sub 1 )~+~phi sub B\n(T sub 3~-~T sub 2 )> ,\nneglecting\
    \ residuals.\nAs in the case for <$Edelta>, where <$Ef sub A> and <$Ef sub B>\
    \ can be\nconsidered constants, the interval containing the maximum error inherent\n\
    in determining <$Etheta> is given by\n<$E{[ min ( epsilon sub 2 )~-~max ( epsilon\
    \ sub 1 )~+~min ( epsilon sub\n3 )~-~max ( epsilon sub 4 ),~ max ( epsilon sub\
    \ 2 )~-~min ( epsilon sub\n1 )~+~max ( epsilon sub 3 )~-~min ( epsilon sub 4 )]}\
    \ over 2>\n<$E=~[ -~rho sub B ,~rho sub A ]~+~{f sub B (T sub 3~-~T sub 2 )~-~f\
    \ sub\nA (T sub 4 ~-~T sub 1 )} over 2> .\nUnder most conditions the errors due\
    \ to <$Ef sub A> and <$Ef sub B> will\nbe small and can be ignored. If <$Erho\
    \ sub A~=~rho sub B~=~rho>; that\nis, if both the A and B clocks have the same\
    \ resolution, the pdf for the\nremaining errors is symmetric, so that <$Etheta\
    \ hat~=~<< theta >>> is an\nunbiased maximum-likelihood estimator for the true\
    \ clock offset <$Etheta\nsub 0>, independent of the particular value of <$Erho>.\
    \ If <$Erho sub\nA~!=~rho sub B>, <$E<< theta >>> is not an unbiased estimator;\
    \ however,\nthe bias error is in the order of\n<$E{rho sub A~-~rho sub B } over\
    \ 2> .\nand can usually be neglected.\nAgain setting <$Erho~=~max ( rho sub A\
    \ ,~rho sub B )> for convenience,\nthe absolute maximum error <$Eepsilon sub theta>\
    \ inherent in determining\nclock offset <$Etheta> is given by\n<$Eepsilon sub\
    \ theta~==~{rho~+~phi sub A (T sub 4~-~T sub 1 )~+~phi sub\nB (T sub 3~-~T sub\
    \ 2 )} over 2 > .\nNetwork Errors\nIn practice, errors due to stochastic network\
    \ delays usually dominate.\nIn general, it is not possible to characterize network\
    \ delays as a\nstationary random process, since network queues can grow and shrink\
    \ in\nchaotic fashion and arriving customer traffic is frequently bursty.\nHowever,\
    \ it is a simple exercise to calculate bounds on clock offset\nerrors as a function\
    \ of measured delay. Let <$ET sub 2~-~T sub 1~=~a>\nand <$ET sub 3~-~T sub 4~=~b>.\
    \ Then,\n<$Edelta~=~a~-~b~~~~ and ~~~~theta~=~{a~+~b} over 2> .\nThe true offset\
    \ of B relative to A is called <$Etheta sub 0> in Figure\n14. Let x denote the\
    \ actual delay between the departure of a message\nfrom A and its arrival at B.\
    \ Therefore, <$Ex~+~theta sub 0~=~T sub 2~-~T\nsub 1~==~a>. Since x must be positive\
    \ in our universe, <$Ex~=~a~-~theta\nsub 0~>>=~0>, which requires <$Etheta sub\
    \ 0~<<=~a>. A similar argument\nrequires that <$Eb~<<=~theta sub 0>, so surely\
    \ <$Eb~<<=~theta sub\n0~<<=~a>. This inequality can also be expressed\n<$Eb~=~{a~+~b}\
    \ over 2~-~{a~-~b} over 2~<<=~theta sub 0~<<=~{a~+~b} over\n2~+~{a~-~b} over 2~=~a>\
    \ ,\nwhich is equivalent to\n<$Etheta~-~delta over 2~<<=~theta sub 0~<<=~theta~+~delta\
    \ over 2> .\nIn the previous section bounds on delay and offset errors were\n\
    determined. Thus, the inequality can be written\n<$Etheta~-~epsilon sub theta~-~{delta~+~epsilon\
    \ sub delta} over\n2~<<=~theta sub 0~<<=~theta~+~epsilon sub theta~+~{delta~+~\
    \ epsilon sub\ndelta } over 2> ,\nwhere <$Eepsilon sub theta> is the maximum offset\
    \ error and <$Eepsilon\nsub delta> is the maximum delay error derived previously.\
    \ The quantity\n<$Eepsilon~=~epsilon sub theta~+~epsilon sub delta over 2~=~rho~+~phi\n\
    sub A (T sub 4~-~T sub 1 )~+~phi sub B (T sub 3~-~T sub 2 )> ,\ncalled the peer\
    \ dispersion, defines the maximum error in the inequality.\nThus, the correctness\
    \ interval I can be defined as the interval\n<$EI~=~[ theta~-~delta over 2~-~epsilon\
    \ ,~theta~+~delta over 2~+~epsilon\n]> ,\nin which the clock offset <$EC~=~theta>\
    \ is the midpoint. By\nconstruction, the true offset <$Etheta sub 0> must lie\
    \ somewhere in this\ninterval.\nInherited Errors\nAs described in the NTP specification,\
    \ the NTP time server maintains the\nlocal clock <$ETHETA>, together with the\
    \ root roundtrip delay <$EDELTA>\nand root dispersion <$EEPSILON> relative to\
    \ the primary reference source\nat the root of the synchronization subnet. The\
    \ values of these variables\nare either included in each update message or can\
    \ be derived as\ndescribed in the NTP specification. In addition, the protocol\
    \ exchange\nand clock-filter algorithm provide the clock offset <$Etheta> and\n\
    roundtrip delay <$Edelta> of the local clock relative to the peer clock,\nas well\
    \ as various error accumulations as described below. The following\ndiscussion\
    \ establishes how errors inherent in the time-transfer process\naccumulate within\
    \ the subnet and contribute to the overall error budget\nat each server.\nAn NTP\
    \ measurement update includes three parts: clock offset <$Etheta>,\nroundtrip\
    \ delay <$Edelta> and maximum error or dispersion <$Eepsilon> of\nthe local clock\
    \ relative to a peer clock. In case of a primary clock\nupdate, these values are\
    \ usually all zero, although <$Eepsilon> can be\ntailored to reflect the specified\
    \ maximum error of the primary reference\nsource itself. In other cases <$Etheta>\
    \ and <$Edelta> are calculated\ndirectly from the four most recent timestamps,\
    \ as described in the NTP\nspecification. The dispersion <$Eepsilon> includes\
    \ the following\ncontributions:\n1.\nEach time the local clock is read a reading\
    \ error is incurred due to the\nfinite granularity or precision of the implementation.\
    \ This is called\nthe measurement dispersion <$Erho>.\n2.\nOnce an offset is determined,\
    \ an error due to frequency offset or skew\naccumulates with time. This is called\
    \ the skew dispersion <$Ephi tau>,\nwhere <$Ephi> represents the skew-rate constant\
    \ (<$Eroman NTP.MAXSKEW\nover NTP.MAXAGE> in the NTP specification) and <$Etau>\
    \ is the interval\nsince the dispersion was last updated.\n3\nWhen a series of\
    \ offsets are determined at regular intervals and\naccumulated in a window of\
    \ samples, as in the NTP clock-filter\nalgorithm, the (estimated) additional error\
    \ due to offset sample\nvariance is called the filter dispersion <$Eepsilon sub\
    \ sigma>.\n4.\nWhen a number of peers are considered for synchronization and two\
    \ or\nmore are determined to be correctly synchronized to a primary reference\n\
    source, as in the NTP clock-selection algorithm, the (estimated)\nadditional error\
    \ due to offset sample variance is called the selection\ndispersion <$Eepsilon\
    \ sub xi>.\nFigure 15<$&fig15> shows how these errors accumulate in the ordinary\n\
    course of NTP processing. Received messages from a single peer are\nrepresented\
    \ by the packet variables. From the four most recent\ntimestamps T1, T2, T3 and\
    \ T4 the clock offset and roundtrip delay sample\nfor the local clock relative\
    \ to the peer clock are calculated directly.\nIncluded in the message are the\
    \ root roundtrip delay <$EDELTA prime> and\nroot dispersion <$EEPSILON prime>\
    \ of the peer itself; however, before\nsending, the peer adds the measurement\
    \ dispersion <$Erho> and skew\ndispersion <$Ephi tau>, where these quantities\
    \ are determined by the\npeer and <$Etau> is the interval according to the peer\
    \ clock since its\nclock was last updated.\nThe NTP clock-filter procedure saves\
    \ the most recent samples <$Etheta\nsub i> and <$Edelta sub i> in the clock filter\
    \ as described in the NTP\nspecification. The quantities <$Erho> and <$Ephi> characterize\
    \ the local\nclock maximum reading error and frequency error, respectively. Each\n\
    sample includes the dispersion <$Eepsilon sub i~=~rho~+~phi (T sub 4~-~T\nsub\
    \ 1 )>, which is set upon arrival. Each time a new sample arrives all\nsamples\
    \ in the filter are updated with the skew dispersion <$Ephi tau\nsub i>, where\
    \ <$Etau sub i> is the interval since the last sample\narrived, as recorded in\
    \ the variable peer.update. The clock-filter\nalgorithm determines the selected\
    \ clock offset <$Etheta> (peer.offset),\ntogether with the associated roundtrip\
    \ delay <$Edelta> (peer.delay) and\nfilter dispersion <$Eepsilon sub sigma>, which\
    \ is added to the\nassociated sample dispersion <$Eepsilon sub i> to form the\
    \ peer\ndispersion <$Eepsilon> (peer.dispersion).\nThe NTP clock-selection procedure\
    \ selects a single peer to become the\nsynchronization source as described in\
    \ the NTP specification. The\noperation of the algorithm determines the final\
    \ clock offset <$ETHETA>\n(local clock), roundtrip delay <$EDELTA> (sys.rootdelay)\
    \ and dispersion\n<$EEPSILON> (sys.rootdispersion) relative to the root of the\n\
    synchronization subnet, as shown in Figure 15. Note the inclusion of the\nselected\
    \ peer dispersion and skew accumulation since the dispersion was\nlast updated,\
    \ as well as the select dispersion <$Eepsilon sub xi>\ncomputed by the clock-select\
    \ algorithm itself. Also, note that, in order\nto preserve overall synchronization\
    \ subnet stability, the final clock\noffset <$ETHETA> is in fact determined from\
    \ the offset of the local\nclock relative to the peer clock, rather than the root\
    \ of the subnet.\nFinally, note that the packet variables <$EDELTA prime> and\
    \ <$EEPSILON\nprime> are in fact determined from the latest message received,\
    \ not at\nthe precise time the offset selected by the clock-filter algorithm was\n\
    determined. Minor errors arising due to these simplifications will be\nignored.\
    \ Thus, the total dispersion accumulation relative to the root of\nthe synchronization\
    \ subnet is\n<$EEPSILON~=~epsilon~+~phi tau~+~epsilon sub xi~+~| THETA |~+~EPSILON\n\
    prime > ,\nwhere <$Etau> is the time since the peer variables were last updated\
    \ and\n<$E| THETA |> is the initial absolute error in setting the local clock.\n\
    The three values of clock offset, roundtrip delay and dispersion are all\nadditive;\
    \ that is, if <$ETHETA sub i>, <$EDELTA sub i> and <$EEPSILON\nsub i> represent\
    \ the values at peer i relative to the root of the\nsynchronization subnet, the\
    \ values\n<$ETHETA sub j (t)~==~THETA sub i~+~theta sub j (t)> ,   <$EDELTA sub\
    \ j\n(t)~==~DELTA sub i~+~delta sub j> ,   <$EEPSILON sub j (t)~==~EPSILON\nsub\
    \ i~+~epsilon sub i~+~epsilon sub j (t)> ,\nrepresent the clock offset, roundtrip\
    \ delay and dispersion of peer j at\ntime t. The time dependence of <$Etheta sub\
    \ j (t)> and <$Eepsilon sub j\n(t)> represents the local-clock correction and\
    \ dispersion accumulated\nsince the last update was received from peer i, while\
    \ the term\n<$Eepsilon sub i> represents the dispersion accumulated by peer i\
    \ from\nthe time its clock was last set until the latest update was sent to peer\n\
    j. Note that, while the offset of the local clock relative to the peer\nclock\
    \ can be determined directly, the offset relative to the root of the\nsynchronization\
    \ subnet is not directly determinable, except on a\nprobabilistic basis and within\
    \ the bounds established in this and the\nprevious section.\nThe NTP synchronization\
    \ subnet topology is that of a tree rooted at the\nprimary server(s). Thus, there\
    \ is an unbroken path from every time\nserver to the primary reference source.\
    \ Accuracy and stability are\nproportional to synchronization distance <$ELAMBDA>,\
    \ defined as\n<$ELAMBDA~==~EPSILON~+~DELTA over 2> .\nThe selection algorithm\
    \ favors the minimum-distance paths and thus\nmaximizes accuracy and stability.\
    \ Since <$ETHETA sub 0>, <$EDELTA sub 0>\nand <$EEPSILON sub 0> are all zero,\
    \ the sum of the clock offsets,\nroundtrip delays and dispersions of each server\
    \ along the minimum-\ndistance path from the root of the synchronization subnet\
    \ to a given\nserver i are the clock offset <$ETHETA sub i>, roundtrip delay <$EDELTA\n\
    sub i> and dispersion <$EEPSILON sub i> inherited by and characteristic\nof that\
    \ server.\nCorrectness Principles\nIn order to minimize the occurrence of errors\
    \ due to incorrect clocks\nand maximize the reliability of the service, NTP relies\
    \ on multiple\npeers and disjoint peer paths whenever possible. In the previous\n\
    development it was shown that, if the primary reference source at the\nroot of\
    \ the synchronization subnet is in fact a correct clock, then the\ntrue offset\
    \ <$Etheta sub 0> relative to that clock must be contained in\nthe interval\n\
    <$E[ THETA~-~LAMBDA ,~THETA~+~LAMBDA ]~==~[ THETA~-~EPSILON~-~DELTA over\n2 ,~THETA~+~EPSILON~+~DELTA\
    \ over 2 ]> .\nWhen a number of clocks are involved, it is not clear beforehand\
    \ which\nare correct and which are not; however, as cited previously, there are\
    \ a\nnumber of techniques based on clustering and filtering principles which\n\
    yield a high probability of detecting and discarding incorrect clocks.\nMarzullo\
    \ and Owicki [MAR85] devised an algorithm designed to find an\nappropriate interval\
    \ containing the correct time given the confidence\nintervals of m clocks, of\
    \ which no more than f are considered incorrect.\nThe algorithm finds the smallest\
    \ single intersection containing all\npoints in at least <$Em~-~f> of the given\
    \ confidence intervals.\nFigure 16<$&fig16> illustrates the operation of this\
    \ algorithm with a\nscenario involving four clocks A, B, C and D, with the calculated\
    \ time\n(shown by the <F128><F255> symbol) and confidence interval shown for\n\
    each. These intervals are computed as described in previous sections of\nthis\
    \ appendix. For instance, any point in the A interval may possibly\nrepresent\
    \ the actual time associated with that clock. If all clocks are\ncorrect, there\
    \ must exist a nonempty intersection including all four\nintervals; but, clearly\
    \ this is not the case in this scenario. However,\nif it is assumed that one of\
    \ the clocks is incorrect (e.g., D), it might\nbe possible to find a nonempty\
    \ intersection including all but one of the\nintervals. If not, it might be possible\
    \ to find a nonempty intersection\nincluding all but two of the intervals and\
    \ so on.\nThe algorithm proposed by DEC for use in the Digital Time Service\n\
    [DEC89] is based on these principles. For the scenario illustrated in\nFigure\
    \ 16, it computes the interval for <$Em~=~4> clocks, three of which\nturn out\
    \ to be correct and one not. The low endpoint of the intersection\nis found as\
    \ follows. A variable f is initialized with the number of\npresumed incorrect\
    \ clocks, in this case zero, and a counter i is\ninitialized at zero. Starting\
    \ from the lowest endpoint, the algorithm\nincrements i at each low endpoint,\
    \ decrements i at each high endpoint,\nand stops when <$Ei~>>=~m~-~f>. The counter\
    \ records the number of\nintersections and thus the number of presumed correct\
    \ clocks. In the\nexample the counter never reaches four, so f is increased by\
    \ one and the\nprocedure is repeated. This time the counter reaches three and\
    \ stops at\nthe low endpoint of the intersection marked DTS. The upper endpoint\
    \ of\nthis intersection is found using a similar procedure.\nThis algorithm will\
    \ always find the smallest single intersection\ncontaining points in at least\
    \ one of the original <$Em~-~f> confidence\nintervals as long as the number of\
    \ incorrect clocks is less than half\nthe total <$Ef~<<~m over 2>. However, some\
    \ points in the intersection\nmay not be contained in all <$Em~-~f> of the original\
    \ intervals;\nmoreover, some or all of the calculated times (such as for C in\
    \ Figure\n16) may lie outside the intersection. In the NTP clock-selection\nprocedure\
    \ the above algorithm is modified so as to include at least\n<$Em~-~f> of the\
    \ calculated times. In the modified algorithm a counter c\nis initialized at zero.\
    \ When starting from either endpoint, c is\nincremented at each calculated time;\
    \ however, neither f nor c are reset\nbetween finding the low and high endpoints\
    \ of the intersection. If after\nboth endpoints have been found <$Ec~>>~f>, f\
    \ is increased by one and the\nentire procedure is repeated. The revised algorithm\
    \ finds the smallest\nintersection of <$Em~-~f> intervals containing at least\
    \ <$Em~-~f>\ncalculated times. As shown in Figure 16, the modified algorithm produces\n\
    the intersection marked NTP and including the calculated time for C.\nIn the NTP\
    \ clock-selection procedure the peers represented by the clocks\nin the final\
    \ intersection, called the survivors, are placed on a\ncandidate list. In the\
    \ remaining steps of the procedure one or more\nsurvivors may be discarded from\
    \ the list as outlyers. Finally, the\nclock-combining algorithm described in Appendix\
    \ F provides a weighted\naverage of the remaining survivors based on synchronization\
    \ distance.\nThe resulting estimates represent a synthetic peer with offset between\n\
    the maximum and minimum offsets of the remaining survivors. This defines\nthe\
    \ clock offset <$ETHETA>, total roundtrip total delay <$EDELTA> and\ntotal dispersion\
    \ <$EEPSILON> which the local clock inherits. In\nprinciple, these values could\
    \ be included in the time interface provided\nby the operating system to the user,\
    \ so that the user could evaluate the\nquality of indications directly.\nAppendix\
    \ I. Selected C-Language Program Listings\nFollowing are C-language program listings\
    \ of selected algorithms\ndescribed in the NTP specification. While these have\
    \ been tested as part\nof a software simulator using data collected in regular\
    \ operation, they\ndo not necessarily represent a standard implementation, since\
    \ many other\nimplementations could in principle conform to the NTP specification.\n\
    Common Definitions and Variables\nThe following definitions are common to all\
    \ procedures and peers.\n#define NMAX 40                                 /* max\
    \ clocks */\n#define FMAX 8                                  /* max filter size\
    \ */\n#define HZ 1000                                 /* clock rate */\n#define\
    \ MAXSTRAT 15                             /* max stratum */\n#define MAXSKEW 1\
    \                               /* max skew error per\nMAXAGE */\n#define MAXAGE\
    \ 86400                            /* max clock age */\n#define MAXDISP 16   \
    \                           /* max dispersion */\n#define MINCLOCK 3         \
    \                     /* min survivor clocks\n*/\n#define MAXCLOCK 10        \
    \                     /* min candidate clocks\n*/\n#define FILTER .5         \
    \                              /* filter weight\n*/\n#define SELECT .75      \
    \                        /* select weight */\nThe folowing are peer state variables\
    \ (one set for each peer).\ndouble filtp[NMAX][FMAX];                        \
    \       /* offset\nsamples */\ndouble fildp[NMAX][FMAX];                     \
    \  /* delay samples */\ndouble filep[NMAX][FMAX];                       /* dispersion\
    \ samples */\ndouble tp[NMAX];                                        /* offset\
    \ */\ndouble dp[NMAX];                                        /* delay */\ndouble\
    \ ep[NMAX];                                        /* dispersion */\ndouble rp[NMAX];\
    \                                        /* last offset\n*/\ndouble utc[NMAX];\
    \                                       /* update tstamp\n*/\nint st[NMAX];  \
    \                                         /* stratum */\nThe following are system\
    \ state variables and constants.\ndouble rho = 1./HZ;                        \
    \             /* max reading\nerror */\ndouble phi = MAXSKEW/MAXAGE;         \
    \   /* max skew rate */\ndouble bot, top;                                    \
    \    /* confidence\ninterval limits */\ndouble theta;                        \
    \                   /* clock offset\n*/\ndouble delta;                       \
    \                    /* roundtrip\ndelay */\ndouble epsil;                   \
    \                        /* dispersion */\ndouble tstamp;                    \
    \              /* current time */\nint source;                               \
    \              /* clock source\n*/\nint n1, n2;                              \
    \               /* min/max clock\nids */\nThe folowing are temporary lists shared\
    \ by all peers and procedures.\ndouble list[3*NMAX];                         \
    \   /* temporary list*/\nint index[3*NMAX];                                  \
    \    /* index list */\nClock<196>Filter Algorithm\n/*\n   clock filter algorithm\n\
    \   n = peer id, offset = sample offset, delay = sample delay, disp =\nsample\
    \ dispersion;\n   computes tp[n] = peer offset, dp[n] = peer delay, ep[n] = peer\n\
    dispersion\n */\nvoid filter(int n, double offset, double delay, double disp)\
    \ {\n        int i, j, k, m;                                 /* int temps */\n\
    \        double x;                                       /* double temps\n*/\n\
    \        for (i = FMAX<196>1; i >> 0; i<196> <196>) {            /*\nupdate/shift\
    \ filter */\n                filtp[n][i] = filtp[n][i<196>1]; fildp[n][i] =\n\
    fildp[n][i<196>1];\n                filep[n][i] = filep[n][i<196>1]+phi*(tstamp<196>utc[n]);\n\
    \                }\n        utc[n] = tstamp; filtp[n][0] = offset<196>tp[0]; fildp[n][0]\
    \ =\ndelay; filep[n][0] = disp;\n        m = 0;                              \
    \            /*\nconstruct/sort temp list */\n        for (i = 0; i << FMAX; i++)\
    \ {\n                if (filep[n][i] >>= MAXDISP) continue;\n                list[m]\
    \ = filep[n][i]+fildp[n][i]/2.; index[m] = i;\n                for (j = 0; j <<\
    \ m; j++) {\n                        if (list[j] >> list[m]) {\nlist[m]; index[j]\
    \ = index[m];\n                        }\n                m = m+1;\n         \
    \       }\n        if (m <<= 0) ep[n] = MAXDISP;           /* compute filter\n\
    dispersion */           \n        else {\n                ep[n] = 0;\n       \
    \         for (i = FMAX<196>1; i >>= 0; i<196> <196>) {\n                    \
    \    if (i << m) x =\nfabs(filtp[n][index[0]]<196>filtp[n][index[i]]);\n     \
    \                   else x = MAXDISP;\n                        ep[n] = FILTER*(ep[n]+x);\n\
    \                        }\n                i = index[0]; ep[n] = ep[n]+filep[n][i];\
    \ tp[n] =\nfiltp[n][i]; dp[n] = fildp[n][i];\n                }\n        return;\n\
    \        }\nInterval Intersection Algorithm\n/*\n   compute interval intersection\n\
    \   computes bot = lowpoint, top = highpoint (bot >> top if no\nintersection)\n\
    */\nvoid dts() {\n        int f;                                          /* intersection\n\
    ceiling */\n        int end;                                        /* endpoint\n\
    counter */\n        int clk;                                                /*\n\
    falseticker counter */\n        int i, j, k, m, n;                           \
    \   /* int temps */\n        double x, y;                                    /*\
    \ double temps\n*/\n        m = 0; i = 0;\n        for (n = n1; n <<= n2; n++)\
    \ {   /* construct endpoint list */\n                if (ep[n] >>= MAXDISP) continue;\n\
    \                m = m+1;\n                list[i] = tp[n]<196>dist(n); index[i]\
    \ = <196>1; /*\nlowpoint */\n                for (j = 0; j << i; j++) {\n    \
    \                    if ((list[j] >> list[i]) || ((list[j] ==\nlist[i]) && (index[j]\
    \ >> index[i]))) {\nlist[i]; index[j] = index[i];\n                        }\n\
    \                i = i+1;\n                list[i] = tp[n]; index[i] = 0;    \
    \      /* midpoint */\n                for (j = 0; j << i; j++) {\n          \
    \              if ((list[j] >> list[i]) || ((list[j] ==\nlist[i]) && (index[j]\
    \ >> index[i]))) {\nlist[i]; index[j] = index[i];\n                        }\n\
    \                i = i+1;\n                list[i] = tp[n]+dist(n); index[i] =\
    \ 1;  /* highpoint */\n                for (j = 0; j << i; j++) {\n          \
    \              if ((list[j] >> list[i]) || ((list[j] ==\nlist[i]) && (index[j]\
    \ >> index[i]))) {\nlist[i]; index[j] = index[i];\n                        }\n\
    \                i = i+1;\n                }\n        if (m <<= 0) return;\n \
    \       for (f = 0; f << m/2; f++) {                    /* find\nintersection\
    \ */\n                clk = 0; end = 0;                       /* lowpoint */\n\
    \                for (j = 0; j << i; j++) {\n                        end = end<196>index[j];\
    \ bot = list[j];\n                        if (end >>= (m<196>f)) break;\n    \
    \                    if (index[j] == 0) clk = clk+1;\n                       \
    \ }\n                end = 0;                                /* highpoint */\n\
    \                for (j = i<196>1; j >>= 0; j<196> <196>) {\n                \
    \        end = end+index[j]; top = list[j];\n                        if (end >>=\
    \ (m<196>f)) break;\n                        if (index[j] == 0) clk = clk+1;\n\
    \                        }\n                if (clk <<= f) break;\n          \
    \      }\n        return;\n        }\nClock<196>Selection Algorithm\n/*\n   select\
    \ best subset of clocks in candidate list\n   bot = lowpoint, top = highpoint;\
    \ constructs index = candidate index\nlist,\n   m = number of candidates, source\
    \ = clock source,\n   theta = clock offset, delta = roundtrip delay, epsil = dispersion\n\
    */\nvoid select() {\n        double xi;                                      /*\
    \ max select\ndispersion */\n        double eps;                             \
    \        /* min peer\ndispersion */\n        int i, j, k, n;                 \
    \                /* int temps */\n        double x, y, z;                    \
    \     /* double temps */\n        m = 0;\n        for (n = n1; n <<= n2; n++)\
    \ {   /* make/sort candidate list */\n                if ((st[n] >> 0) && (st[n]\
    \ << MAXSTRAT) && (tp[n] >>=\nbot) && (tp[n] <<= top)) {\n                   \
    \     list[m] = MAXDISP*st[n]+dist(n); index[m] = n;\n                       \
    \ for (j = 0; j << m; j++) {\nlist[j] = list[m]; index[j] = index[m];\n      \
    \                  m = m+1;\n                        }\n                }\n  \
    \      if (m <<= 0) {\n                source = 0; return;\n                }\n\
    \        if (m >> MAXCLOCK) m = MAXCLOCK;\n        while (1) {               \
    \                      /* cast out\nfalsetickers */\n                xi = 0.;\
    \ eps = MAXDISP;\n                for (j = 0; j << m; j++) {\n               \
    \         x = 0.;\n                        for (k = m<196>1; k >>= 0; k<196> <196>)\n\
    SELECT*(x+fabs(tp[index[j]]<196>tp[index[k]]));\n                        if (x\
    \ >> xi) {\n                        x = ep[index[j]]+phi*(tstamp<196>utc[index[j]]);\n\
    \                        if (x << eps) eps = x;          /* min(eps) */\n    \
    \                    }\n                if ((xi <<= eps) || (m <<= MINCLOCK))\
    \ break;\n                if (index[i] == source) source = 0;\n              \
    \  for (j = i; j << m<196>1; j++) index[j] = index[j+1];\n                m =\
    \ m<196>1;\n                }\n        i = index[0];                         \
    \          /* declare\nwinner */\n        if (source != i)\n                if\
    \ (source == 0) source = i;\n                else if (st[i] << st[source]) source\
    \ = i;\n        theta = combine(); delta = dp[i]; epsil =\nep[i]+phi*(tstamp<196>utc[i])+xi;\n\
    \        return;\n        }\nClock<196>Combining Procedure\n/*\n   compute weighted\
    \ ensemble average\n   index = candidate index list, m = number of candidates;\
    \ returns\ncombined clock offset\n*/\ndouble combine() {\n        int i;     \
    \                                     /* int temps */\n        double x, y, z;\
    \                         /* double temps */\n        z = 0. ; y = 0.;\n     \
    \   for (i = 0; i << m; i++) {                      /* compute\nweighted offset\
    \ */\n                j = index[i]; x = dist(j)); z = z+tp[j]/x; y = y+1./x;\n\
    \                }\n        return z/y;                                     /*\
    \ normalize */\n        }\nSubroutine to Compute Synchronization Distance\n/*\n\
    \   compute synchronization distance\n   n = peer id; returns synchronization\
    \ distance\n */\ndouble dist(int n) {\n        return ep[n]+phi*(tstamp<196>utc[n])+fabs(dp[n])/2.;\n\
    \        }\nSecurity considerations\nsee Section 3.6 and Appendix C\nAuthor's\
    \ address\nDavid L. Mills\nElectrical Engineering Department\nUniversity of Delaware\n"
