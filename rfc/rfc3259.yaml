- title: __initial_text__
  contents:
  - '                  A Message Bus for Local Coordination

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2002).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The local Message Bus (Mbus) is a light-weight message-oriented\n\
    \   coordination protocol for group communication between application\n   components.\
    \  The Mbus provides automatic location of communication\n   peers, subject based\
    \ addressing, reliable message transfer and\n   different types of communication\
    \ schemes.  The protocol is layered on\n   top of IP multicast and is specified\
    \ for IPv4 and IPv6.  The IP\n   multicast scope is limited to link-local multicast.\
    \  This document\n   specifies the Mbus protocol, i.e., message syntax, addressing\
    \ and\n   transport mechanisms.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.    Introduction . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n   1.1   Mbus Overview  . . . . . . . . . . . . . . . . . .\
    \ . . . . .  3\n   1.2   Purpose of this Document . . . . . . . . . . . . . .\
    \ . . . .  5\n   1.3   Areas of Application . . . . . . . . . . . . . . . . .\
    \ . . .  5\n   1.4   Terminology for requirement specifications . . . . . . .\
    \ . .  6\n   2.    Common Formal Syntax Rules . . . . . . . . . . . . . . . .\
    \ .  6\n   3.    Message Format . . . . . . . . . . . . . . . . . . . . . . .\
    \  7\n   4.    Addressing . . . . . . . . . . . . . . . . . . . . . . . . .  9\n\
    \   4.1   Mandatory Address Elements . . . . . . . . . . . . . . . . . 10\n  \
    \ 5.    Message Syntax . . . . . . . . . . . . . . . . . . . . . . . 11\n   5.1\
    \   Message Encoding . . . . . . . . . . . . . . . . . . . . . . 11\n   5.2  \
    \ Message Header . . . . . . . . . . . . . . . . . . . . . . . 11\n   5.3   Command\
    \ Syntax . . . . . . . . . . . . . . . . . . . . . . . 12\n   6.    Transport\
    \  . . . . . . . . . . . . . . . . . . . . . . . . . 13\n   6.1   Local Multicast/Broadcast\
    \  . . . . . . . . . . . . . . . . . 14\n   6.1.1 Mbus multicast groups for IPv4\
    \ . . . . . . . . . . . . . . . 15\n   6.1.2 Mbus multicast groups for IPv6 .\
    \ . . . . . . . . . . . . . . 15\n   6.1.3 Use of Broadcast . . . . . . . . .\
    \ . . . . . . . . . . . . . 16\n   6.1.4 Mbus UDP Port Number . . . . . . . .\
    \ . . . . . . . . . . . . 16\n   6.2   Directed Unicast . . . . . . . . . . .\
    \ . . . . . . . . . . . 16\n   7.    Reliability  . . . . . . . . . . . . . .\
    \ . . . . . . . . . . 18\n   8.    Awareness of other Entities  . . . . . . .\
    \ . . . . . . . . . 20\n   8.1   Hello Message Transmission Interval  . . . .\
    \ . . . . . . . . 21\n   8.1.1 Calculating the Interval for Hello Messages  .\
    \ . . . . . . . 22\n   8.1.2 Initialization of Values . . . . . . . . . . . .\
    \ . . . . . . 23\n   8.1.3 Adjusting the Hello Message Interval when the Number\
    \ of\n         Entities increases . . . . . . . . . . . . . . . . . . . . . 23\n\
    \   8.1.4 Adjusting the Hello Message Interval when the Number of\n         Entities\
    \ decreases . . . . . . . . . . . . . . . . . . . . . 23\n   8.1.5 Expiration\
    \ of hello timers . . . . . . . . . . . . . . . . . 23\n   8.2   Calculating the\
    \ Timeout for Mbus Entities  . . . . . . . . . 24\n   9.    Messages . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . 24\n   9.1   mbus.hello . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . 24\n   9.2   mbus.bye . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . 25\n   9.3   mbus.ping  . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . 25\n   9.4   mbus.quit  . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . 26\n   9.5   mbus.waiting . . . . . . . .\
    \ . . . . . . . . . . . . . . . . 26\n   9.6   mbus.go  . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . 27\n   10.   Constants  . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . 27\n   11.   Mbus Security  . . . . . . . . . .\
    \ . . . . . . . . . . . . . 28\n   11.1  Security Model . . . . . . . . . . .\
    \ . . . . . . . . . . . . 28\n   11.2  Encryption . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . 28\n   11.3  Message Authentication . . . . . . . . .\
    \ . . . . . . . . . . 29\n   11.4  Procedures for Senders and Receivers . . .\
    \ . . . . . . . . . 30\n   12.   Mbus Configuration . . . . . . . . . . . . .\
    \ . . . . . . . . 31\n   12.1  File based parameter storage . . . . . . . . .\
    \ . . . . . . . 33\n   12.2  Registry based parameter storage . . . . . . . .\
    \ . . . . . . 34\n   13.   Security Considerations  . . . . . . . . . . . . .\
    \ . . . . . 34\n   14.   IANA Considerations  . . . . . . . . . . . . . . . .\
    \ . . . . 35\n   15.   References . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . 35\n   A.    About References . . . . . . . . . . . . . . . . . . . .\
    \ . . 37\n   B.    Limitations and Future Work  . . . . . . . . . . . . . . .\
    \ . 37\n   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . .\
    \ 38\n   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . . 39\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The implementation of multiparty multimedia conferencing\
    \ systems is\n   one example where a simple coordination infrastructure can be\
    \ useful:\n   In a variety of conferencing scenarios, a local communication channel\n\
    \   can provide conference-related information exchange between co-\n   located\
    \ but otherwise independent application entities, for example\n   those taking\
    \ part in application sessions that belong to the same\n   conference.  In loosely\
    \ coupled conferences such a mechanism allows\n   for coordination of application\
    \ entities, e.g., to implement\n   synchronization between media streams or to\
    \ configure entities\n   without user interaction.  It can also be used to implement\
    \ tightly\n   coupled conferences enabling a conference controller to enforce\n\
    \   conference wide control within an end system.\n   Conferencing systems such\
    \ as IP telephones can also be viewed as\n   components of a distributed system\
    \ and can thus be integrated into a\n   group of application modules: For example,\
    \ an IP telephony call that\n   is conducted with a stand-alone IP telephone can\
    \ be dynamically\n   extended to include media engines for other media types using\
    \ the\n   coordination function of an appropriate coordination mechanism.\n  \
    \ Different individual conferencing components can thus be combined to\n   build\
    \ a coherent multimedia conferencing system for a user.\n   Other possible scenarios\
    \ include the coordination of application\n   components that are distributed\
    \ on different hosts in a network, for\n   example, so-called Internet appliances.\n"
- title: 1.1  Mbus Overview
  contents:
  - "1.1  Mbus Overview\n   Local coordination of application components requires\
    \ a number of\n   different interaction models: some messages (such as membership\n\
    \   information, floor control notifications, dissemination of conference\n  \
    \ state changes, etc.) may need to be sent to all local application\n   entities.\
    \  Messages may also be targeted at a certain application\n   class (e.g., all\
    \ whiteboards or all audio tools) or agent type (e.g.,\n   all user interfaces\
    \ rather than all media engines).  Or there may be\n   any (application- or message-specific)\
    \ subgrouping defining the\n   intended recipients, e.g., messages related to\
    \ media synchronization.\n   Finally, there may be messages that are directed\
    \ at a single entity:\n   for example, specific configuration settings that a\
    \ conference\n   controller sends to a particular application entity, or query-\n\
    \   response exchanges between any local server and its clients.\n   The Mbus\
    \ protocol as defined here satisfies these different\n   communication needs by\
    \ defining different message transport\n   mechanisms (defined in Section 6) and\
    \ by providing a flexible\n   addressing scheme (defined in Section 4).\n   Furthermore,\
    \ Mbus messages exchanged between application entities may\n   have different\
    \ reliability requirements (which are typically derived\n   from their semantics).\
    \  Some messages will have a rather transient\n   character conveying ephemeral\
    \ state information (which is\n   refreshed/updated periodically), such as the\
    \ volume meter level of an\n   audio receiver entity to be displayed by its user\
    \ interface agent.\n   Certain Mbus messages (such as queries for parameters or\
    \ queries to\n   local servers) may require a response from the peer(s), thereby\n\
    \   providing an explicit acknowledgment at the semantic level on top of\n   the\
    \ Mbus.  Other messages will modify the application or conference\n   state and\
    \ hence it is crucial that they do not get lost.  The latter\n   type of message\
    \ has to be delivered reliably to the recipient,\n   whereas messages of the first\
    \ type do not require reliability\n   mechanisms at the Mbus transport layer.\
    \  For messages confirmed at\n   the application layer it is up to the discretion\
    \ of the application\n   whether or not to use a reliable transport underneath.\n\
    \   In some cases, application entities will want to tailor the degree of\n  \
    \ reliability to their needs, others will want to rely on the\n   underlying transport\
    \ to ensure delivery of the messages -- and this\n   may be different for each\
    \ Mbus message.  The Mbus message passing\n   mechanism specified in this document\
    \ provides a maximum of\n   flexibility by providing reliable transmission achieved\
    \ through\n   transport-layer acknowledgments (in case of point-to-point\n   communications\
    \ only) as well as unreliable message passing (for\n   unicast, local multicast,\
    \ and local broadcast).  We address this\n   topic in Section 4.\n   Finally,\
    \ accidental or malicious disturbance of Mbus communications\n   through messages\
    \ originated by applications from other users needs to\n   be prevented.  Accidental\
    \ reception of Mbus messages from other users\n   may occur if either two users\
    \ share the same host for using Mbus\n   applications or if they are using Mbus\
    \ applications that are spread\n   across the same network link: in either case,\
    \ the used Mbus multicast\n   address and the port number may be identical leading\
    \ to reception of\n   the other party's Mbus messages in addition to the user's\
    \ own ones.\n   Malicious disturbance may happen because of applications multicasting\n\
    \   (e.g., at a global scope) or unicasting Mbus messages.  To eliminate\n   the\
    \ possibility of processing unwanted Mbus messages, the Mbus\n   protocol contains\
    \ message digests for authentication.  Furthermore,\n   the Mbus allows for encryption\
    \ to ensure privacy and thus enable\n   using the Mbus for local key distribution\
    \ and other functions\n   potentially sensitive to eavesdropping.  This document\
    \ defines the\n   framework for configuring Mbus applications with regard to security\n\
    \   parameters in Section 12.\n"
- title: 1.2  Purpose of this Document
  contents:
  - "1.2  Purpose of this Document\n   Three components constitute the message bus:\
    \ the low level message\n   passing mechanisms, a command syntax and naming hierarchy,\
    \ and the\n   addressing scheme.\n   The purpose of this document is to define\
    \ the protocol mechanisms of\n   the lower level Mbus message passing mechanism\
    \ which is common to all\n   Mbus implementations.  This includes the specification\
    \ of\n   o  the generic Mbus message format;\n   o  the addressing concept for\
    \ application entities (note that\n      concrete addressing schemes are to be\
    \ defined by application-\n      specific profiles);\n   o  the transport mechanisms\
    \ to be employed for conveying messages\n      between (co-located) application\
    \ entities;\n   o  the security concept to prevent misuse of the Message Bus (such\
    \ as\n      taking control of another user's conferencing environment);\n   o\
    \  the details of the Mbus message syntax; and\n   o  a set of mandatory application\
    \ independent commands that are used\n      for bootstrapping Mbus sessions.\n"
- title: 1.3 Areas of Application
  contents:
  - "1.3 Areas of Application\n   The Mbus protocol can be deployed in many different\
    \ application\n   areas, including but not limited to:\n   Local conference control:\
    \ In the Mbone community a model has arisen\n      whereby a set of loosely coupled\
    \ tools are used to participate in\n      a conference.  A typical scenario is\
    \ that audio, video, and shared\n      workspace functionality is provided by\
    \ three separate tools\n      (although some combined tools exist).  This maps\
    \ well onto the\n      underlying RTP [8] (as well as other) media streams, which\
    \ are\n      also transmitted separately.  Given such an architecture, it is\n\
    \      useful to be able to perform some coordination of the separate\n      media\
    \ tools.  For example, it may be desirable to communicate\n      playout-point\
    \ information between audio and video tools, in order\n      to implement lip-synchronization,\
    \ to arbitrate the use of shared\n      resources (such as input devices), etc.\n\
    \      A refinement of this architecture relies on the presence of a\n      number\
    \ of media engines which perform protocol functions as well\n      as capturing\
    \ and playout of media.  In addition, one (or more)\n      (separate) user interface\
    \ agents exist that interact with and\n      control their media engine(s).  Such\
    \ an approach allows\n      flexibility in the user-interface design and implementation,\
    \ but\n      obviously requires some means by which the various involved agents\n\
    \      may communicate with one another.  This is particularly desirable\n   \
    \   to enable a coherent response to a user's conference-related\n      actions\
    \ (such as joining or leaving a conference).\n      Although current practice\
    \ in the Mbone community is to work with a\n      loosely coupled conference control\
    \ model, situations arise where\n      this is not appropriate and a more tightly\
    \ coupled wide-area\n      conference control protocol must be employed.  In such\
    \ cases, it\n      is highly desirable to be able to re-use the existing tools\
    \ (media\n      engines) available for loosely coupled conferences and integrate\n\
    \      them with a system component implementing the tight conference\n      control\
    \ model.  One appropriate means to achieve this integration\n      is a communication\
    \ channel that allows a dedicated conference\n      control entity to \"remotely\"\
    \ control the media engines in addition\n      to or instead of their respective\
    \ user interfaces.\n   Control of device groups in a network: A group of devices\
    \ that are\n      connected to a local network, e.g., home appliances in a home\n\
    \      network, require a local coordination mechanism.  Minimizing\n      manual\
    \ configuration and the the possibility to deploy group\n      communication will\
    \ be useful in this application area as well.\n"
- title: 1.4  Terminology for requirement specifications
  contents:
  - "1.4  Terminology for requirement specifications\n   In this document, the key\
    \ words \"MUST\", \"MUST NOT\", \"REQUIRED\",\n   \"SHALL\", \"SHALL NOT\", \"\
    SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",\n   and \"OPTIONAL\" are to\
    \ be interpreted as described in RFC 2119 [1] and\n   indicate requirement levels\
    \ for compliant Mbus implementations.\n"
- title: 2.  Common Formal Syntax Rules
  contents:
  - "2.  Common Formal Syntax Rules\n   This section contains definitions of common\
    \ ABNF [13] syntax elements\n   that are later referenced by other definitions\
    \ in this document:\n      base64          = base64_terminal /\n             \
    \           ( 1*(4base64_CHAR) [base64_terminal] )\n      base64_char     = UPALPHA\
    \ / LOALPHA / DIGIT / \"+\" / \"/\"\n                        ;; Case-sensitive\n\
    \      base64_terminal = (2base64_char \"==\") / (3base64_char \"=\")\n      UPALPHA\
    \         = %x41-5A            ;; Uppercase: A-Z\n      LOALPHA         = %x61-7A\
    \            ;; Lowercase: a-z\n      ALPHA           =  %x41-5A / %x61-7A   ;\
    \ A-Z / a-z\n      CHAR            =  %x01-7E\n                         ; any\
    \ 7-bit US-ASCII character,\n                          excluding NUL and delete\n\
    \      OCTET           =  %x00-FF\n                         ; 8 bits of data\n\
    \      CR              =  %x0D\n                         ; carriage return\n \
    \     CRLF            =  CR LF\n                         ; Internet standard newline\n\
    \      DIGIT           =  %x30-39\n                         ; 0-9\n      DQUOTE\
    \          =  %x22\n                         ; \" (Double Quote)\n      HTAB \
    \           =  %x09\n                         ; horizontal tab\n      LF     \
    \         =  %x0A\n                         ; linefeed\n      LWSP           \
    \ =  *(WSP / CRLF WSP)\n                         ; linear white space (past newline)\n\
    \      SP              =  %x20\n                         ; space\n      WSP  \
    \           =  SP / HTAB\n                         ; white space\n   Taken from\
    \ RFC 2234 [13] and RFC 2554 [14].\n"
- title: 3.  Message Format
  contents:
  - "3.  Message Format\n   An Mbus message comprises a header and a body.  The header\
    \ is used to\n   indicate how and where a message should be delivered and the\
    \ body\n   provides information and commands to the destination entity.  The\n\
    \   following pieces of information are included in the header:\n      A fixed\
    \ ProtocolID field identifies the version of the message bus\n      protocol used.\
    \  The protocol defined in this document is\n      \"mbus/1.0\" (case-sensitive).\n\
    \      A sequence number (SeqNum) is contained in each message.  The\n      first\
    \ message sent by a source SHOULD set SeqNum to zero, and it\n      MUST increment\
    \ by one for each message sent by that source.  A\n      single sequence number\
    \ is used for all messages from a source,\n      irrespective of the intended\
    \ recipients and the reliability mode\n      selected. The value range of a sequence\
    \ number is (0,4294967295).\n      An implementation MUST re-set its sequence\
    \ number to 0 after\n      reaching 4294967295.  Implementations MUST take into\
    \ account that\n      the SeqNum of other entities may wrap-around.\n      SeqNums\
    \ are decimal numbers in ASCII representation.\n      The TimeStamp field is also\
    \ contained in each message and SHOULD\n      contain a decimal number representing\
    \ the time of the message\n      construction in milliseconds since 00:00:00,\
    \ UTC, January 1, 1970.\n      A MessageType field indicates the kind of message\
    \ being sent.  The\n      value \"R\" indicates that the message is to be transmitted\
    \ reliably\n      and MUST be acknowledged by the recipient, \"U\" indicates an\n\
    \      unreliable message which MUST NOT be acknowledged.\n      The SrcAddr field\
    \ identifies the sender of a message.  This MUST\n      be a complete address,\
    \ with all address elements specified.  The\n      addressing scheme is described\
    \ in Section 4.\n      The DestAddr field identifies the intended recipient(s)\
    \ of the\n      message.  This field MAY be wildcarded by omitting address\n \
    \     elements and hence address any number (including zero) of\n      application\
    \ entities.  The addressing scheme is described in\n      Section 4.\n      The\
    \ AckList field comprises a list of SeqNums for which this\n      message is an\
    \ acknowledgment.  See Section 7 for details.\n   The header is followed by the\
    \ message body which contains zero or\n   more commands to be delivered to the\
    \ destination entity.  The syntax\n   for a complete message is given in Section\
    \ 5.\n   If multiple commands are contained within the same Mbus message\n   payload,\
    \ they MUST to be delivered to the Mbus application in the\n   same sequence in\
    \ which they appear in the message payload.\n"
- title: 4.  Addressing
  contents:
  - "4.  Addressing\n   Each entity in the message has a unique Mbus address that\
    \ is used to\n   identify the entity.  Mbus addresses are sequences of address\n\
    \   elements that are tag/value pairs.  The tag and the value are\n   separated\
    \ by a colon and tag/value pairs are separated by whitespace,\n   like this:\n\
    \      (tag:value tag:value ...)\n   The formal ABNF syntax definition for Mbus\
    \ addresses and their\n   elements is as follows:\n      mbus_address    = \"\
    (\" *WSP *1address_list *WSP \")\"\n      address_list    = address_element\n\
    \                      / address_element 1*WSP address_list\n      address_element\
    \ = address_tag \":\" address_value\n      address_tag     = 1*32(ALPHA)\n   \
    \   address_value   = 1*64(%x21-27 / %x2A-7E)\n                        ; any 7-bit\
    \ US-ASCII character\n                        ; excluding white space, delete,\n\
    \                        ; control characters, \"(\" and \")\"\n   Note that this\
    \ and other ABNF definitions in this document use the\n   non-terminal symbols\
    \ defined in Section 2.\n   An address_tag MUST be unique within an Mbus address,\
    \ i.e., it MUST\n   only occur once.\n   Each entity has a fixed sequence of address\
    \ elements constituting its\n   address and MUST only process messages sent to\
    \ addresses that either\n   match all elements or consist of a subset of its own\
    \ address\n   elements.  The order of address elements in an address sequence\
    \ is\n   not relevant.  Two address elements match if both their tags and\n  \
    \ their values are equivalent.  Equivalence for address element and\n   address\
    \ value strings means that each octet in the one string has the\n   same value\
    \ as the corresponding octet in the second string.  For\n   example, an entity\
    \ with an address of:\n   (conf:test media:audio module:engine app:rat id:4711-1@192.168.1.1)\n\
    \   will process messages sent to\n   (media:audio module:engine)\n   and\n  \
    \ (module:engine)\n   but must ignore messages sent to\n   (conf:test media:audio\
    \ module:engine app:rat id:123-4@192.168.1.1\n   foo:bar)\n   and\n   (foo:bar)\n\
    \   A message that should be processed by all entities requires an empty\n   set\
    \ of address elements.\n"
- title: 4.1  Mandatory Address Elements
  contents:
  - "4.1  Mandatory Address Elements\n   Each Mbus entity MUST provide one mandatory\
    \ address element that\n   allows it to identify the entity.  The element tag\
    \ is \"id\" and the\n   value MUST be be composed of the following components:\n\
    \   o  The IP address of the interface that is used for sending messages\n   \
    \   to the Mbus.  For IPv4 this is the address in dotted decimal\n      notation.\
    \  For IPv6 the interface-ID-part of the node's link-local\n      address in textual\
    \ representation as specified in RFC 2373 [3]\n      MUST be used.\n      In this\
    \ specification, this part is called the \"host-ID\".\n   o  An identifier (\"\
    entity-ID\") that is unique within the scope of a\n      single host-ID.  The\
    \ entity comprises two parts.  For systems\n      where the concept of a process\
    \ ID is applicable it is RECOMMENDED\n      that this identifier be composed using\
    \ a process-ID and a per-\n      process disambiguator for different Mbus entities\
    \ of a process.\n      If a process ID is not available, this part of the entity-ID\
    \ may\n      be randomly chosen (it is recommended that at least a 32 bit\n  \
    \    random number is chosen).  Both numbers are represented in decimal\n    \
    \  textual form and MUST be separated by a '-' (ASCII x2d) character.\n   Note\
    \ that the entity-ID cannot be the port number of the endpoint\n   used for sending\
    \ messages to the Mbus because implementations MAY use\n   the common Mbus port\
    \ number for sending to and receiving from the\n   multicast group (as specified\
    \ in Section 6).\n   The complete syntax definition for the entity identifier\
    \ is as\n   follows:\n      id-element   = \"id:\" id-value\n      id-value  \
    \   = entity-id \"@\" host-id\n      entity-id    = 1*10DIGIT \"-\" 1*5DIGIT\n\
    \      host-id      = (IPv4address / IPv6address)\n   Please refer to [3] for\
    \ the productions of IPv4address and IPv6address.\n   An example for an id element:\n\
    \      id:4711-99@192.168.1.1\n"
- title: 5.  Message Syntax
  contents:
  - '5.  Message Syntax

    '
- title: 5.1  Message Encoding
  contents:
  - "5.1  Message Encoding\n   All messages MUST use the UTF-8 character encoding.\
    \  Note that US\n   ASCII is a subset of UTF-8 and requires no additional encoding,\
    \ and\n   that a message encoded with UTF-8 will not contain zero bytes.\n   Each\
    \ Message MAY be encrypted using a secret key algorithm as\n   defined in Section\
    \ 11.\n"
- title: 5.2  Message Header
  contents:
  - "5.2  Message Header\n   The fields in the header are separated by white space\
    \ characters,\n   and followed by CRLF.  The format of the header is as follows:\n\
    \   msg_header = \"mbus/1.0\" 1*WSP SeqNum 1*WSP TimeStamp 1*WSP\n           \
    \     MessageType 1*WSP SrcAddr 1*WSP DestAddr 1*WSP AckList\n   The header fields\
    \ are explained in Message Format (Section 3).  Here\n   are the ABNF syntax definitions\
    \ for the header fields:\n      SeqNum      = 1*10DIGIT     ; numeric range 0\
    \ - 2^32-1\n      TimeStamp   = 1*13DIGIT\n      MessageType = \"R\" / \"U\"\n\
    \      ScrAddr     = mbus_address\n      DestAddr    = mbus_address\n      AckList\
    \     = \"(\" *WSP *1(1*DIGIT *(1*WSP 1*10DIGIT)) *WSP \")\"\n      See Section\
    \ 4 for a definition of \"mbus_address\".\n   The syntax definition of a complete\
    \ message is as follows:\n      mbus_message = msg_header *1(CRLF msg_payload)\n\
    \      msg_payload  = mbus_command *(CRLF mbus_command)\n   The definition of\
    \ production rules for an Mbus command is given in\n   Section 5.3.\n"
- title: 5.3  Command Syntax
  contents:
  - "5.3  Command Syntax\n   The header is followed by zero, one, or more, commands\
    \ to be\n   delivered to the Mbus entities indicated by the DestAddr field.  Each\n\
    \   command consists of a command name that is followed by a list of\n   zero,\
    \ or more parameters and is terminated by a newline.\n      command ( parameter\
    \ parameter ... )\n   Syntactically, the command name MUST be a `symbol' as defined\
    \ in the\n   following table.  The parameters MAY be any data type drawn from\
    \ the\n   following table:\n      val             = Integer / Float / String /\
    \ List /\n                        Symbol / Data\n      Integer         = *1\"\
    -\" 1*DIGIT\n      Float           = *1\"-\" 1*DIGIT \".\" 1*DIGIT\n      String\
    \          = DQUOTE *CHAR DQUOTE\n                        ; see below for escape\
    \ characters\n      List            = \"(\" *WSP *1(val *(1*WSP val)) *WSP \"\
    )\"\n      Symbol          = ALPHA *(ALPHA / DIGIT / \"_\" / \"-\" /\n       \
    \                 \".\")\n      Data            = \"<\" *base64 \">\"\n   Boolean\
    \ values are encoded as an integer, with the value of zero\n   representing false,\
    \ and non-zero representing true.\n   String parameters in the payload MUST be\
    \ enclosed in the double quote\n   (\") character.  Within strings, the escape\
    \ character is the backslash\n   (\\), and the following escape sequences are\
    \ defined:\n      +----------------+-----------+\n      |Escape Sequence |  Meaning\
    \  |\n      +----------------+-----------+\n      |      \\\\        |    \\ \
    \     |\n      |      \\\"        |     \"     |\n      |      \\n        | newline\
    \   |\n      +----------------+-----------+\n   List parameters do not have to\
    \ be homogeneous lists, i.e., they can\n   contain parameters of different types.\n\
    \   Opaque data is represented as Base64-encoded (see RFC 1521 [7])\n   character\
    \ strings surrounded by \"< \" and \"> \"\n   The ABNF syntax definition for Mbus\
    \ commands is as follows:\n      mbus_command = command_name arglist\n      command_name\
    \ = Symbol\n      arglist      = List\n   Command names SHOULD be constructed\
    \ hierarchically to group\n   conceptually related commands under a common hierarchy.\
    \  The\n   delimiter between names in the hierarchy MUST be \".\"  (dot).\n  \
    \ Application profiles MUST NOT define commands starting with \"mbus.\".\n   The\
    \ Mbus addressing scheme defined in Section 4 allows specifying\n   incomplete\
    \ addresses by omitting certain elements of an address\n   element list, enabling\
    \ entities to send commands to a group of Mbus\n   entities.  Therefore, all command\
    \ names SHOULD be unambiguous in a\n   way that it is possible to interpret or\
    \ ignore them without\n   considering the message's address.\n   A set of commands\
    \ within a certain hierarchy that MUST be understood\n   by every entity is defined\
    \ in Section 9.\n"
- title: 6.  Transport
  contents:
  - "6.  Transport\n   All messages are transmitted as UDP messages, with two possible\n\
    \   alternatives:\n   1. Local multicast/broadcast:\n      This transport class\
    \ MUST be used for all messages that are not\n      sent to a fully qualified\
    \ target address.  It MAY also be used for\n      messages that are sent to a\
    \ fully qualified target address.  It\n      MUST be provided by conforming implementations.\
    \  See Section 6.1\n      for details.\n   2. Directed unicast:\n      This transport\
    \ class MAY be used for messages that are sent to a\n      fully qualified destination\
    \ address.  It is OPTIONAL and does not\n      have to be provided by conforming\
    \ implementations.\n   A fully qualified target address is an Mbus address of\
    \ an existing\n   Mbus entity in an Mbus session. An implementation can identify\
    \ an\n   Mbus address as fully qualified by maintaining a list of known\n   entities\
    \ within an Mbus session. Each known entity has its own\n   unique, fully qualified\
    \ Mbus address.\n   Messages are transmitted in UDP datagrams, a maximum message\
    \ size of\n   64 KBytes MUST NOT be exceeded.  It is RECOMMENDED that applications\n\
    \   using a non host-local scope do not exceed a message size of the link\n  \
    \ MTU.\n   Note that \"unicast\", \"multicast\" and \"broadcast\" mean IP Unicast,\
    \ IP\n   Multicast and IP Broadcast respectively.  It is possible to send an\n\
    \   Mbus message that is addressed to a single entity using IP Multicast.\n  \
    \ This specification deals with both Mbus over UDP/IPv4 and Mbus over\n   UDP/IPv6.\n"
- title: 6.1  Local Multicast/Broadcast
  contents:
  - "6.1  Local Multicast/Broadcast\n   In general, the Mbus uses multicast with a\
    \ limited scope for message\n   transport.  Two different Mbus multicast scopes\
    \ are defined, either\n   of which can be configured to be used with an Mbus session:\n\
    \   1.  host-local\n   2.  link-local\n   Participants of an Mbus session have\
    \ to know the multicast address in\n   advance -- it cannot be negotiated during\
    \ the session since it is\n   already needed for initial communication between\
    \ the Mbus entities\n   during the bootstrapping phase.  It also cannot be allocated\
    \ prior to\n   an Mbus session because there would be no mechanism to announce\
    \ the\n   allocated address to all potential Mbus entities.  Therefore, the\n\
    \   multicast address has to be assigned statically.  This document\n   defines\
    \ the use of statically assigned addresses and also provides a\n   specification\
    \ of how an Mbus session can be configured to use non-\n   standard, unassigned\
    \ addresses (see Section 12).\n   The following sections specify the use of multicast\
    \ addresses for\n   IPv4 and IPv6.\n"
- title: 6.1.1  Mbus multicast groups for IPv4
  contents:
  - "6.1.1  Mbus multicast groups for IPv4\n   For IPv4, a statically assigned, scope-relative\
    \ multicast address as\n   defined by RFC 2365 [11] is used.  The offset for the\
    \ scope relative\n   address for Mbus is 8 (MBUS, see\n   http://www.iana.org/assignments/multicast-addresses\
    \ [19]).\n   Different scopes are defined by RFC 2365 [11].  The IPv4 Local Scope\n\
    \   (239.255.0.0/16) is the minimal enclosing scope for administratively\n   scoped\
    \ multicast (as defined by RFC 2365 [11]) and not further\n   divisible -- its\
    \ exact extent is site dependent.\n   For the IPv4 Local Scope, applying the rules\
    \ of RFC 2365 [11] and\n   using the assigned offset of 8, the Mbus multicast\
    \ address is\n   therefore 239.255.255.247.\n   For IPv4, the different defined\
    \ Mbus scopes (host-local and link-\n   local) are to be realized as follows:\n\
    \   host-local multicast: Unless configured otherwise, the assigned\n      scope-relative\
    \ Mbus address in the Local Scope (239.255.255.247 as\n      of RFC 2365 [11])\
    \ MUST be used.  Mbus UDP datagrams SHOULD be sent\n      with a TTL of 0.\n \
    \  link-local multicast: Unless configured otherwise, the assigned\n      scope-relative\
    \ Mbus address in the Local Scope (239.255.255.247 as\n      of RFC 2365 [11])\
    \ MUST be used.  Mbus UDP datagrams SHOULD be sent\n      with a TTL of 1.\n"
- title: 6.1.2  Mbus multicast groups for IPv6
  contents:
  - "6.1.2  Mbus multicast groups for IPv6\n   IPv6 has different address ranges for\
    \ different multicast scopes and\n   distinguishes node local and link local scopes,\
    \ that are implemented\n   as a set of address prefixes for the different address\
    \ ranges (RFC\n   2373 [3]).  The link-local prefix is FF02, the node-local prefix\
    \ is\n   FF01.  A permanently assigned multicast address will be used for Mbus\n\
    \   multicast communication, i.e., an address that is independent of the\n   scope\
    \ value and that can be used for all scopes.  Implementations for\n   IPv6 MUST\
    \ use the scope-independent address and the appropriate\n   prefix for the selected\
    \ scope.  For host-local Mbus communication the\n   IPv6 node-local scope prefix\
    \ MUST be used, for link-local Mbus\n   communication the IPv6 link-local scope\
    \ prefix MUST be used.\n   The permanent IPv6 multicast address for Mbus/Ipv6\
    \ is\n   FF0X:0:0:0:0:0:0:300.\n   FF0X:0:0:0:0:0:0:300 SHOULD be used for Mbus/IPv6\
    \ where the X in FF0X\n   indicates that the scope is not fixed because this is\
    \ an all scope\n   address.  This means, for node-local scope, FF01:0:0:0:0:0:0:300\n\
    \   SHOULD be used and for link-local scope FF02:0:0:0:0:0:0:300 SHOULD\n   be\
    \ used.  See RFC 2375 [4] for IPv6 multicast address assignments.\n   If a single\
    \ application system is distributed across several co-\n   located hosts, link\
    \ local scope SHOULD be used for multicasting Mbus\n   messages that potentially\
    \ have recipients on the other hosts.  The\n   Mbus protocol is not intended (and\
    \ hence deliberately not designed)\n   for communication between hosts not on\
    \ the same link.  See Section 12\n   for specifications of Mbus configuration\
    \ mechanisms.\n"
- title: 6.1.3  Use of Broadcast
  contents:
  - "6.1.3  Use of Broadcast\n   In situations where multicast is not available, broadcast\
    \ MAY be used\n   instead.  In these cases an IP broadcast address for the connected\n\
    \   network SHOULD be used for sending.  The node-local broadcast address\n  \
    \ for IPv6 is FF01:0:0:0:0:0:0:1, the link-local broadcast address for\n   IPv6\
    \ is FF02:0:0:0:0:0:0:1.  For IPv4, the generic broadcast address\n   (for link-local\
    \ broadcast) is 255.255.255.255.  It is RECOMMENDED\n   that IPv4-implementations\
    \ use the generic broadcast address and a TTL\n   of zero for host-local broadcast.\n\
    \   Broadcast MUST NOT be used in situations where multicast is available\n  \
    \ and supported by all systems participating in an Mbus session.\n   See Section\
    \ 12 for configuring the use of broadcast.\n"
- title: 6.1.4  Mbus UDP Port Number
  contents:
  - "6.1.4  Mbus UDP Port Number\n   The registered Mbus UDP port number is 47000.\n"
- title: 6.2  Directed Unicast
  contents:
  - "6.2  Directed Unicast\n   Directed unicast (via UDP) to the port of a specific\
    \ application is\n   an alternative transport class to multicast.  Directed unicast\
    \ is an\n   OPTIONAL optimization and MAY be used by Mbus implementations for\n\
    \   delivering messages addressed to a single application entity only --\n   the\
    \ address of which the Mbus implementation has learned from other\n   message\
    \ exchanges before.  Note that the DestAddr field of such\n   messages MUST be\
    \ filled in properly nevertheless.  Every Mbus entity\n   SHOULD use a single\
    \ unique endpoint address for sending messages to\n   the Mbus multicast group\
    \ or to individual receiving entities.  A\n   unique endpoint address is a tuple\
    \ consisting of the entity's IP\n   address and a UDP source port number, where\
    \ the port number is\n   different from the standard Mbus port number.\n   Messages\
    \ MUST only be sent via unicast if the Mbus target address is\n   unique and if\
    \ the sending entity can verify that the receiving entity\n   uses a unique endpoint\
    \ address.  The latter can be verified by\n   considering the last message received\
    \ from that entity.\n      Note that several Mbus entities, say within the same\
    \ process, may\n      share a common transport address; in this case, the contents\
    \ of\n      the destination address field is used to further dispatch the\n  \
    \    message.  Given the definition of \"unique endpoint address\" above,\n  \
    \    the use of a shared endpoint address and a dispatcher still allows\n    \
    \  other Mbus entities to send unicast messages to one of the\n      entities\
    \ that share the endpoint address.  So this can be\n      considered an implementation\
    \ detail.\n   Messages with an empty target address list MUST always be sent to\
    \ all\n   Mbus entities (via multicast if available).\n   The following algorithm\
    \ can be used by sending entities to determine\n   whether an Mbus address is\
    \ unique considering the current set of Mbus\n   entities:\n         let ta=the\
    \ target address;\n         iterate through the set of all\n         currently\
    \ known Mbus addresses {\n            let ti=the address in each iteration;\n\
    \            count the addresses for which\n            the predicate isSubsetOf(ta,ti)\
    \ yields true;\n         }\n      If the count of matching addresses is exactly\
    \ 1 the address is\n      unique.  The following algorithm can be used for the\
    \ predicate\n      isSubsetOf, that checks whether the second message matches\
    \ the\n      first according to the rules specified in Section 4.  (A match\n\
    \      means that a receiving entity that uses the second Mbus address\n     \
    \ must also process received messages with the first address as a\n      target\
    \ address.)\n         isSubsetOf(addr a1,a2) yields true, iff\n            every\
    \ address element of a1 is contained\n            in a2's address element list.\n\
    \      An address element a1 is contained in an address element list if\n    \
    \  the list contains an element that is equal to a1.  An address\n      element\
    \ is considered equal to another address element if it has\n      the same values\
    \ for both of the two address element fields (tag\n      and value).\n"
- title: 7.  Reliability
  contents:
  - "7.  Reliability\n   While most messages are expected to be sent using unreliable\n\
    \   transport, it may be necessary to deliver some messages reliably.\n   Reliability\
    \ can be selected on a per message basis by means of the\n   MessageType field.\
    \  Reliable delivery is supported for messages with\n   a single recipient only;\
    \ i.e., to a fully qualified Mbus address.  An\n   entity can thus only send reliable\
    \ messages to known addresses, i.e.,\n   it can only send reliable messages to\
    \ entities that have announced\n   their existence on the Mbus (e.g., by means\
    \ of mbus.hello() messages\n   as defined in Section 9.1).  A sending entity MUST\
    \ NOT send a message\n   reliably if the target address is not unique.  (See Section\
    \ 6 for the\n   specification of an algorithm to determine whether an address\
    \ is\n   unique.)  A receiving entity MUST only process and acknowledge a\n  \
    \ reliable message if the destination address exactly matches its own\n   source\
    \ address (the destination address MUST NOT be a subset of the\n   source address).\n\
    \   Disallowing reliable message delivery for messages sent to multiple\n   destinations\
    \ is motivated by simplicity of the implementation as well\n   as the protocol.\
    \  The desired effect can be achieved at the\n   application layer by sending\
    \ individual reliable messages to each\n   fully qualified destination address,\
    \ if the membership information\n   for the Mbus session is available.\n   Each\
    \ message is tagged with a message sequence number.  If the\n   MessageType is\
    \ \"R\", the sender expects an acknowledgment from the\n   recipient within a\
    \ short period of time.  If the acknowledgment is\n   not received within this\
    \ interval, the sender MUST retransmit the\n   message (with the same message\
    \ sequence number), increase the\n   timeout, and restart the timer.  Messages\
    \ MUST be retransmitted a\n   small number of times (see below) before the transmission\
    \ or the\n   recipient are considered to have failed.  If the message is not\n\
    \   delivered successfully, the sending application is notified.  In this\n  \
    \ case, it is up to the application to determine the specific actions\n   (if\
    \ any) to be taken.\n   Reliable messages MUST be acknowledged by adding their\
    \ SeqNum to the\n   AckList field of a message sent to the originator of the reliable\n\
    \   message.  This message MUST be sent to a fully qualified Mbus target\n   address.\
    \  Multiple acknowledgments MAY be sent in a single message.\n   Implementations\
    \ MAY either piggy-back the AckList onto another\n   message sent to the same\
    \ destination, or MAY send a dedicated\n   acknowledgment message, with no commands\
    \ in the message payload part.\n   The precise procedures are as follows:\n  \
    \ Sender: A sender A of a reliable message M to receiver B MUST\n      transmit\
    \ the message either via IP-multicast or via IP-unicast,\n      keep a copy of\
    \ M, initialize a retransmission counter N to '1',\n      and start a retransmission\
    \ timer T (initialized to T_r).  If an\n      acknowledgment is received from\
    \ B, timer T MUST be cancelled and\n      the copy of M is discarded.  If T expires,\
    \ the message M MUST be\n      retransmitted, the counter N MUST be incremented\
    \ by one, and the\n      timer MUST be restarted (set to N*T_r).  If N exceeds\
    \ the\n      retransmission threshold N_r, the transmission is assumed to have\n\
    \      failed, further retransmission attempts MUST NOT be undertaken,\n     \
    \ the copy of M MUST be discarded, and the sending application\n      SHOULD be\
    \ notified.\n   Receiver: A receiver B of a reliable message from a sender A MUST\n\
    \      acknowledge reception of the message within a time period T_c <\n     \
    \ T_r.  This MAY be done by means of a dedicated acknowledgment\n      message\
    \ or by piggy-backing the acknowledgment on another message\n      addressed only\
    \ to A.\n   Receiver optimization: In a simple implementation, B may choose to\n\
    \      immediately send a dedicated acknowledgment message.  However, for\n  \
    \    efficiency, it could add the SeqNum of the received message to a\n      sender-specific\
    \ list of acknowledgments; if the added SeqNum is\n      the first acknowledgment\
    \ in the list, B SHOULD start an\n      acknowledgment timer TA (initialized to\
    \ T_c).  When the timer\n      expires, B SHOULD create a dedicated acknowledgment\
    \ message and\n      send it to A.  If B is to transmit another Mbus message addressed\n\
    \      only to A, it should piggy-back the acknowledgments onto this\n      message\
    \ and cancel TA.  In either case, B should store a copy of\n      the acknowledgment\
    \ list as a single entry in the per-sender copy\n      list, keep this entry for\
    \ a period T_k, and empty the\n      acknowledgment list.  In case any of the\
    \ messages kept in an entry\n      of the copy list is received again from A,\
    \ the entire\n      acknowledgment list stored in this entry is scheduled for\
    \ (re-)\n      transmission following the above rules.\n   Constants and Algorithms:\
    \ The following constants and algorithms\n      SHOULD be used by implementations:\n\
    \      T_r=100ms\n      N_r=3\n      T_c=70ms\n      T_k=((N_r)*(N_r+1)/2)*T_r\n"
- title: 8.  Awareness of other Entities
  contents:
  - "8.  Awareness of other Entities\n   Before Mbus entities can communicate with\
    \ one another, they need to\n   mutually find out about their existence.  After\
    \ this bootstrap\n   procedure that each Mbus entity goes through all other entities\n\
    \   listening to the same Mbus know about the newcomer and the newcomer\n   has\
    \ learned about all the other entities.  Furthermore, entities need\n   to be\
    \ able to to notice the failure (or leaving) of other entities.\n   Any Mbus entity\
    \ MUST announce its presence (on the Mbus) after\n   starting up.  This is to\
    \ be done repeatedly throughout its lifetime\n   to address the issues of startup\
    \ sequence: Entities should always\n   become aware of other entities independent\
    \ of the order of starting.\n   Each Mbus entity MUST maintain the number of Mbus\
    \ session members and\n   continuously update this number according to any observed\
    \ changes.\n   The mechanisms of how the existence and the leaving of other entities\n\
    \   can be detected are dedicated Mbus messages for entity awareness:\n   mbus.hello\
    \ (Section 9.1) and mbus.bye (Section 9.2).  Each Mbus\n   protocol implementation\
    \ MUST periodically send mbus.hello messages\n   that are used by other entities\
    \ to monitor the existence of that\n   entity.  If an entity has not received\
    \ mbus.hello messages for a\n   certain time (see Section 8.2) from an entity,\
    \ the respective entity\n   is considered to have left the Mbus and MUST be excluded\
    \ from the set\n   of currently known entities.  Upon the reception of a mbus.bye\n\
    \   message the respective entity is considered to have left the Mbus as\n   well\
    \ and MUST be excluded from the set of currently known entities\n   immediately.\n\
    \   Each Mbus entity MUST send hello messages to the Mbus after startup.\n   After\
    \ transmission of the hello message, it MUST start a timer after\n   the expiration\
    \ of which the next hello message is to be transmitted.\n   Transmission of hello\
    \ messages MUST NOT be stopped unless the entity\n   detaches from the Mbus. \
    \ The interval for sending hello messages is\n   dependent on the current number\
    \ of entities in an Mbus group and can\n   thus change dynamically in order to\
    \ avoid congestion due to many\n   entities sending hello messages at a constant\
    \ high rate.\n   Section 8.1 specifies the calculation of hello message intervals\
    \ that\n   MUST be used by protocol implementations.  Using the values that are\n\
    \   calculated for obtaining the current hello message timer, the timeout\n  \
    \ for received hello messages is calculated in Section 8.2.  Section 9\n   specifies\
    \ the command synopsis for the corresponding Mbus messages.\n"
- title: 8.1  Hello Message Transmission Interval
  contents:
  - "8.1  Hello Message Transmission Interval\n   Since the number of entities in\
    \ an Mbus session may vary, care must\n   be taken to allow the Mbus protocol\
    \ to automatically scale over a\n   wide range of group sizes.  The average rate\
    \ at which hello messages\n   are received would increase linearly to the number\
    \ of entities in a\n   session if the sending interval was set to a fixed value.\
    \  Given an\n   interval of 1 second this would mean that an entity taking part\
    \ in an\n   Mbus session with n entities would receive n hello messages per\n\
    \   second.  Assuming all entities resided on one host, this would lead\n   to\
    \ n*n messages that have to be processed per second -- which is\n   obviously\
    \ not a viable solution for larger groups.  It is therefore\n   necessary to deploy\
    \ dynamically adapted hello message intervals,\n   taking varying numbers of entities\
    \ into account.  In the following,\n   we specify an algorithm that MUST be used\
    \ by implementors to\n   calculate the interval for hello messages considering\
    \ the observed\n   number of Mbus entities.\n   The algorithm features the following\
    \ characteristics:\n   o  The number of hello messages that are received by a\
    \ single entity\n      in a certain time unit remains approximately constant as\
    \ the\n      number of entities changes.\n   o  The effective interval that is\
    \ used by a specific Mbus entity is\n      randomized in order to avoid unintentional\
    \ synchronization of\n      hello messages within an Mbus session.  The first\
    \ hello message of\n      an entity is also delayed by a certain random amount\
    \ of time.\n   o  A timer reconsideration mechanism is deployed in order to adapt\n\
    \      the interval more appropriately in situations where a rapid change\n  \
    \    of the number of entities is observed.  This is useful when an\n      entity\
    \ joins an Mbus session and is still learning of the\n      existence of other\
    \ entities or when a larger number of entities\n      leaves the Mbus at once.\n"
- title: 8.1.1  Calculating the Interval for Hello Messages
  contents:
  - "8.1.1  Calculating the Interval for Hello Messages\n   The following variable\
    \ names are used in the calculation specified\n   below (all time values in milliseconds):\n\
    \   hello_p: The last time a hello message has been sent by a Mbus\n      entity.\n\
    \   hello_now: The current time\n   hello_d: The deterministic calculated interval\
    \ between hello\n      messages.\n   hello_e: The effective (randomized) interval\
    \ between hello messages.\n   hello_n: The time for the next scheduled transmission\
    \ of a hello\n      message.\n   entities_p: The numbers of entities at the time\
    \ hello_n has been last\n      recomputed.\n   entities: The number of currently\
    \ known entities.\n   The interval between hello messages MUST be calculated as\
    \ follows:\n   The number of currently known entities is multiplied by\n   c_hello_factor,\
    \ yielding the interval between hello messages in\n   milliseconds.  This is the\
    \ deterministic calculated interval, denoted\n   hello_d.  The minimum value for\
    \ hello_d is c_hello_min which yields\n      hello_d = max(c_hello_min,c_hello_factor\
    \ * entities * 1ms).\n   Section 8 provides a specification of how to obtain the\
    \ number of\n   currently known entities.  Section 10 provides values for the\n\
    \   constants c_hello_factor and c_hello_min.\n   The effective interval hello_e\
    \ that is to be used by individual\n   entities is calculated by multiplying hello_d\
    \ with a randomly chosen\n   number between c_hello_dither_min and c_hello_dither_max\
    \ as follows:\n       hello_e = c_hello_dither_min +\n                 RND * (c_hello_dither_max\
    \ - c_hello_dither_min)\n   with RND being a random function that yields an even\
    \ distribution\n   between 0 and 1.  See also Section 10.\n   hello_n, the time\
    \ for the next hello message in milliseconds is set\n   to hello_e + hello_now.\n"
- title: 8.1.2  Initialization of Values
  contents:
  - "8.1.2  Initialization of Values\n   Upon joining an Mbus session a protocol implementation\
    \ sets\n   hello_p=0, hello_now=0 and entities=1, entities_p=1 (the Mbus entity\n\
    \   itself) and then calculates the time for the next hello message as\n   specified\
    \ in Section 8.1.1.  The next hello message is scheduled for\n   transmission\
    \ at hello_n.\n"
- title: 8.1.3  Adjusting the Hello Message Interval when the Number of Entities
  contents:
  - "8.1.3  Adjusting the Hello Message Interval when the Number of Entities\n   \
    \    increases\n   When the existence of a new entity is observed by a protocol\n\
    \   implementation the number of currently known entities is updated.  No\n  \
    \ further action concerning the calculation of the hello message\n   interval\
    \ is required.  The reconsideration of the timer interval\n   takes place when\
    \ the current timer for the next hello message expires\n   (see Section 8.1.5).\n"
- title: 8.1.4  Adjusting the Hello Message Interval when the Number of Entities
  contents:
  - "8.1.4  Adjusting the Hello Message Interval when the Number of Entities\n   \
    \    decreases\n   Upon realizing that an entity has left the Mbus the number\
    \ of\n   currently known entities is updated and the following algorithm\n   should\
    \ be used to reconsider the timer interval for hello messages:\n   1. The value\
    \ for hello_n is updated by setting hello_n = hello_now +\n      (entities/entities_p)*(hello_n\
    \ - hello_now)\n   2. The value for hello_p is updated by setting hello_p = hello_now\
    \ -\n      (entities/entities_p)*(hello_now - hello_p)\n   3. The currently active\
    \ timer for the next hello messages is\n      cancelled and a new timer is started\
    \ for hello_n.\n   4. entities_p is set to entities.\n"
- title: 8.1.5 Expiration of hello timers
  contents:
  - "8.1.5 Expiration of hello timers\n   When the hello message timer expires, the\
    \ protocol implementation\n   MUST perform the following operations:\n      The\
    \ hello interval hello_e is computed as specified in Section\n      8.1.1.\n \
    \     1. IF hello_e + hello_p <= hello_now THEN a hello message is\n         transmitted.\
    \  hello_p is set to hello_now, hello_e is\n         calculated again as specified\
    \ in Section 8.1.1 and hello_n is\n         set to hello_e + hello_now.\n    \
    \  2. ELSE IF hello_e + hello_p > hello_now THEN hello_n is set to\n         hello_e\
    \ + hello_p.  A new timer for the next hello message is\n         started to expire\
    \ at hello_n.  No hello message is transmitted.\n      entities_p is set to entities.\n"
- title: 8.2  Calculating the Timeout for Mbus Entities
  contents:
  - "8.2  Calculating the Timeout for Mbus Entities\n   Whenever an Mbus entity has\
    \ not heard for a time span of\n   c_hello_dead*(hello_d*c_hello_dither_max) milliseconds\
    \ from another\n   Mbus entity it may consider this entity to have failed (or\
    \ have quit\n   silently).  The number of the currently known entities MUST be\n\
    \   updated accordingly.  See Section 8.1.4 for details.  Note that no\n   need\
    \ for any further action is necessarily implied from this\n   observation.\n \
    \  Section 8.1.1 specifies how to obtain hello_d.  Section 10 defines\n   values\
    \ for the constants c_hello_dead and c_hello_dither_max.\n"
- title: 9.  Messages
  contents:
  - "9.  Messages\n   This section defines some basic application-independent messages\
    \ that\n   MUST be understood by all implementations; these messages are\n   required\
    \ for proper operation of the Mbus.  This specification does\n   not contain application-specific\
    \ messages. These are to be defined\n   outside of the basic Mbus protocol specification\
    \ in separate Mbus\n   profiles.\n"
- title: 9.1  mbus.hello
  contents:
  - "9.1  mbus.hello\n      Syntax:\n      mbus.hello()\n      Parameters: - none\
    \ -\n   mbus.hello messages MUST be sent unreliably to all Mbus entities.\n  \
    \ Each Mbus entity learns about other Mbus entities by observing their\n   mbus.hello\
    \ messages and tracking the sender address of each message\n   and can thus calculate\
    \ the current number of entities.\n   mbus.hello messages MUST be sent periodically\
    \ in dynamically\n   calculated intervals as specified in Section 8.\n   Upon\
    \ startup the first mbus.hello message MUST be sent after a delay\n   hello_delay,\
    \ where hello_delay be a randomly chosen number between 0\n   and c_hello_min\
    \ (see Section 10).\n"
- title: 9.2  mbus.bye
  contents:
  - "9.2  mbus.bye\n      Syntax:  mbus.bye()\n      Parameters: - none -\n   An Mbus\
    \ entity that is about to terminate (or \"detach\" from the Mbus)\n   SHOULD announce\
    \ this by transmitting an mbus.bye message.  The\n   mbus.bye message MUST be\
    \ sent unreliably to all entities.\n"
- title: 9.3  mbus.ping
  contents:
  - "9.3  mbus.ping\n      Syntax:  mbus.ping()\n      Parameters: - none -\n   mbus.ping\
    \ can be used to solicit other entities to signal their\n   existence by replying\
    \ with an mbus.hello message.  Each protocol\n   implementation MUST understand\
    \ mbus.ping and reply with an mbus.hello\n   message.  The reply hello message\
    \ MUST be delayed for hello_delay\n   milliseconds, where hello_delay be a randomly\
    \ chosen number between 0\n   and c_hello_min (see Section 10).  Several mbus.ping\
    \ messages MAY be\n   answered by a single mbus.hello: if one or more further\
    \ mbus.ping\n   messages are received while the entity is waiting hello_delay\
    \ time\n   units before transmitting the mbus.hello message, no extra mbus.hello\n\
    \   message need be scheduled for those additional mbus.ping messages.\n   As\
    \ specified in Section 9.1 hello messages MUST be sent unreliably to\n   all Mbus\
    \ entities.  This is also the case for replies to ping\n   messages.  An entity\
    \ that replies to mbus.ping with mbus.hello SHOULD\n   stop any outstanding timers\
    \ for hello messages after sending the\n   hello message and schedule a new timer\
    \ event for the subsequent hello\n   message.  (Note that using the variables\
    \ and the algorithms of\n   Section 8.1.1 this can be achieved by setting hello_p\
    \ to hello_now.)\n   mbus.ping allows a new entity to quickly check for other\
    \ entities\n   without having to wait for the regular individual hello messages.\
    \  By\n   specifying a target address the new entity can restrict the\n   solicitation\
    \ for hello messages to a subset of entities it is\n   interested in.\n"
- title: 9.4  mbus.quit
  contents:
  - "9.4  mbus.quit\n      Syntax:\n      mbus.quit()\n      Parameters: - none -\n\
    \   The mbus.quit message is used to request other entities to terminate\n   themselves\
    \ (and detach from the Mbus).  Whether this request is\n   honoured by receiving\
    \ entities or not is application specific and\n   not defined in this document.\n\
    \   The mbus.quit message can be multicast or sent reliably via unicast\n   to\
    \ a single Mbus entity or a group of entities.\n"
- title: 9.5  mbus.waiting
  contents:
  - "9.5  mbus.waiting\n      Syntax:\n      mbus.waiting(condition)\n      Parameters:\n\
    \         symbol condition\n         The condition parameter is used to indicate\
    \ that the entity\n         transmitting this message is waiting for a particular\
    \ event to\n         occur.\n   An Mbus entity SHOULD be able to indicate that\
    \ it is waiting for a\n   certain event to happen (similar to a P() operation\
    \ on a semaphore\n   but without creating external state somewhere else).  In\
    \ conjunction\n   with this, an Mbus entity SHOULD be capable of indicating to\
    \ another\n   entity that this condition is now satisfied (similar to a semaphore's\n\
    \   V() operation).\n   The mbus.waiting message MAY be broadcast to all Mbus\
    \ entities, MAY\n   be multicast to an arbitrary subgroup, or MAY be unicast to\
    \ a\n   particular peer.  Transmission of the mbus.waiting message MUST be\n \
    \  unreliable and hence MUST be repeated at an application-defined\n   interval\
    \ (until the condition is satisfied).\n   If an application wants to indicate\
    \ that it is waiting for several\n   conditions to be met, several mbus.waiting\
    \ messages are sent\n   (possibly included in the same Mbus payload).  Note that\
    \ mbus.hello\n   and mbus.waiting messages may also be transmitted in a single\
    \ Mbus\n   payload.\n"
- title: 9.6  mbus.go
  contents:
  - "9.6  mbus.go\n      Syntax:\n      mbus.go(condition)\n      Parameters:\n  \
    \       symbol condition\n         This parameter specifies which condition is\
    \ met.\n   The mbus.go message is sent by an Mbus entity to \"unblock\" another\n\
    \   Mbus entity -- which has indicated that it is waiting for a certain\n   condition\
    \ to be met.  Only a single condition can be specified per\n   mbus.go message.\
    \  If several conditions are satisfied simultaneously\n   multiple mbus.go messages\
    \ MAY be combined in a single Mbus payload.\n   The mbus.go message MUST be sent\
    \ reliably via unicast to the Mbus\n   entity to unblock.\n"
- title: 10.  Constants
  contents:
  - "10.  Constants\n   The following values for timers and counters mentioned in\
    \ this\n   document SHOULD be used by implementations:\n      +-------------------+------------------------+--------------+\n\
    \      |Timer / Counter    | Value                  | Unit         |\n      +-------------------+------------------------+--------------+\n\
    \      |c_hello_factor     | 200                    |     -        |\n      |c_hello_min\
    \        | 1000                   | milliseconds |\n      |c_hello_dither_min\
    \ | 0.9                    |     -        |\n      |c_hello_dither_max | 1.1 \
    \                   |     -        |\n      |c_hello_dead       | 5          \
    \            |     -        |\n      +-------------------+------------------------+--------------+\n\
    \         T_r=100ms\n         N_r=3\n         T_c=70ms\n         T_k=((N_r)*(N_r+1)/2)*T_r\n"
- title: 11.  Mbus Security
  contents:
  - '11.  Mbus Security

    '
- title: 11.1  Security Model
  contents:
  - "11.1  Security Model\n   In order to prevent accidental or malicious disturbance\
    \ of Mbus\n   communications through messages originated by applications from\
    \ other\n   users, message authentication is deployed (Section 11.3).  For each\n\
    \   message, a digest MUST be calculated based on the value of a shared\n   secret\
    \ key value.  Receivers of messages MUST check if the sender\n   belongs to the\
    \ same Mbus security domain by re-calculating the digest\n   and comparing it\
    \ to the received value.  The messages MUST only be\n   processed further if both\
    \ values are equal.  In order to allow\n   different simultaneous Mbus sessions\
    \ at a given scope and to\n   compensate defective implementations of host local\
    \ multicast, message\n   authentication MUST be provided by conforming implementations.\n\
    \   Privacy of Mbus message transport can be achieved by optionally using\n  \
    \ symmetric encryption methods (Section 11.2).  Each message MAY be\n   encrypted\
    \ using an additional shared secret key and a symmetric\n   encryption algorithm.\
    \  Encryption is OPTIONAL for applications, i.e.,\n   it is allowed to configure\
    \ an Mbus domain not to use encryption.  But\n   conforming implementations MUST\
    \ provide the possibility to use\n   message encryption (see below).\n   Message\
    \ authentication and encryption can be parameterized: the\n   algorithms to apply,\
    \ the keys to use, etc.  These and other\n   parameters are defined in an Mbus\
    \ configuration object that is\n   accessible by all Mbus entities that participate\
    \ in an Mbus session.\n   In order to achieve interoperability conforming implementations\n\
    \   SHOULD use the values provided by such an Mbus configuration.\n   Section\
    \ 12 defines the mandatory and optional parameters as well as\n   storage procedures\
    \ for different platforms.  Only in cases where none\n   of the options mentioned\
    \ in Section 12 is applicable alternative\n   methods of configuring Mbus protocol\
    \ entities MAY be deployed.\n   The algorithms and procedures for applying encryption\
    \ and\n   authentication techniques are specified in the following sections.\n"
- title: 11.2  Encryption
  contents:
  - "11.2  Encryption\n   Encryption of messages is OPTIONAL, that means, an Mbus\
    \ MAY be\n   configured not to use encryption.\n   Implementations can choose\
    \ between different encryption algorithms.\n   Every conforming implementation\
    \ MUST provide the AES [18] algorithm.\n   In addition, the following algorithms\
    \ SHOULD be supported: DES [16],\n   3DES (triple DES) [16] and IDEA [20].\n \
    \  For algorithms requiring en/decryption data to be padded to certain\n   boundaries\
    \ octets with a value of 0 SHOULD be used for padding\n   characters.\n   The\
    \ length of the encryption keys is determined by the currently used\n   encryption\
    \ algorithm.  This means, the configured encryption key MUST\n   NOT be shorter\
    \ than the native key length for the currently\n   configured algorithm.\n   DES\
    \ implementations MUST use the DES Cipher Block Chaining (CBC)\n   mode.  DES\
    \ keys (56 bits) MUST be encoded as 8 octets as described in\n   RFC 1423 [12],\
    \ resulting in 12 Base64-encoded characters.  IDEA uses\n   128-bit keys (24 Base64-encoded\
    \ characters).  AES can use either\n   128-bit, 192-bit or 256-bit keys.  For\
    \ Mbus encryption using AES only\n   128-bit keys (24 Base64-encoded characters)\
    \ MUST be used.\n"
- title: 11.3  Message Authentication
  contents:
  - "11.3  Message Authentication\n   For authentication of messages, hashed message\
    \ authentication codes\n   (HMACs) as described in RFC 2104 [5] are deployed.\
    \  In general,\n   implementations can choose between a number of digest algorithms.\n\
    \   For Mbus authentication, the HMAC algorithm MUST be applied in the\n   following\
    \ way:\n      The keyed hash value is calculated using the HMAC algorithm\n  \
    \    specified in RFC 2104 [5].  The specific hash algorithm and the\n      secret\
    \ hash key MUST be obtained from the Mbus configuration (see\n      Section 12).\n\
    \      The keyed hash values (see RFC 2104 [5]) MUST be truncated to 96\n    \
    \  bits (12 octets).\n      Subsequently, the resulting 12 octets MUST be Base64-encoded,\n\
    \      resulting in 16 Base64-encoded characters (see RFC 1521 [7]).\n   Either\
    \ MD5 [15] or SHA-1 [17] SHOULD be used for message\n   authentication codes (MACs).\
    \  An implementation MAY provide MD5,\n   whereas SHA-1 MUST be implemented.\n\
    \   The length of the hash keys is determined by the selected hashing\n   algorithm.\
    \  This means, the configured hash key MUST NOT be shorter\n   than the native\
    \ key length for the currently configured algorithm.\n"
- title: 11.4  Procedures for Senders and Receivers
  contents:
  - "11.4  Procedures for Senders and Receivers\n   The algorithms that MUST be provided\
    \ by implementations are AES and\n   SHA-1.\n   See Section 12 for a specification\
    \ of notations for Base64-strings.\n   A sender MUST apply the following operations\
    \ to a message that is to\n   be sent:\n   1. If encryption is enabled, the message\
    \ MUST be encrypted using the\n      configured algorithm and the configured encryption\
    \ key.  Padding\n      (adding extra-characters) for block-ciphers MUST be applied\
    \ as\n      specified in Section 11.2.  If encryption is not enabled, the\n  \
    \    message is left unchanged.\n   2. Subsequently, a message authentication\
    \ code (MAC) for the\n      (encrypted) message MUST be calculated using the configured\
    \ HMAC-\n      algorithm and the configured hash key.\n   3. The MAC MUST then\
    \ be converted to Base64 encoding, resulting in 16\n      Base64-characters as\
    \ specified in Section 11.3.\n   4. At last, the sender MUST construct the final\
    \ message by placing\n      the (encrypted) message after the base64-encoded MAC\
    \ and a CRLF.\n      The ABNF definition for the final message is as follows:\n\
    \      final_msg = MsgDigest CRLF encr_msg\n      MsgDigest = base64\n      encr_msg\
    \  = *OCTET\n   A receiver MUST apply the following operations to a message that\
    \ it\n   has received:\n   1. Separate the base64-encoded MAC from the (encrypted)\
    \ message and\n      decode the MAC.\n   2. Re-calculate the MAC for the message\
    \ using the configured HMAC-\n      algorithm and the configured hash key.\n \
    \  3. Compare the original MAC with re-calculated MAC.  If they differ,\n    \
    \  the message MUST be discarded without further processing.\n   4. If encryption\
    \ is enabled, the message MUST be decrypted using the\n      configured algorithm\
    \ and the configured encryption key.  Trailing\n      octets with a value of 0\
    \ MUST be deleted.  If the message does not\n      start with the string \"mbus/\"\
    \ the message MUST be discarded\n      without further processing.\n"
- title: 12.  Mbus Configuration
  contents:
  - "12.  Mbus Configuration\n   An implementation MUST be configurable by the following\
    \ parameters:\n      Configuration version\n         The version number of the\
    \ given configuration entity.  Version\n         numbers allow implementations\
    \ to check if they can process the\n         entries of a given configuration\
    \ entity.  Version number are\n         integer values.  The version number for\
    \ the version specified\n         here is 1.\n      Encryption key\n         The\
    \ secret key used for message encryption.\n      Hash key\n         The hash key\
    \ used for message authentication.\n      Scope\n         The multicast scope\
    \ to be used for sent messages.\n   The above parameters are mandatory and MUST\
    \ be present in every Mbus\n   configuration entity.\n   The following parameters\
    \ are optional.  When they are present they\n   MUST be honored.  When they are\
    \ not present implementations SHOULD\n   fall back to the predefined default values\
    \ (as defined in Transport\n   (Section 6)):\n      Address\n         The non-standard\
    \ multicast address to use for message\n         transport.\n      Use of Broadcast\n\
    \         It can be specified whether broadcast should be used.  If\n        \
    \ broadcast has been configured implementations SHOULD use the\n         network\
    \ broadcast address (as specified in Section 6.1.3)\n         instead of the standard\
    \ multicast address.\n      Port Number\n         The non-standard UDP port number\
    \ to use for message transport.\n   Two distinct facilities for parameter storage\
    \ are considered: For\n   Unix-like systems a per-user configuration file SHOULD\
    \ be used and\n   for Windows-95/98/NT/2000/XP systems a set of registry entries\
    \ is\n   defined that SHOULD be used.  For other systems it is RECOMMENDED\n \
    \  that the file-based configuration mechanism is used.\n   The syntax of the\
    \ values for the respective parameter entries remains\n   the same for both configuration\
    \ facilities.  The following defines a\n   set of ABNF (see RFC 2234 [13]) productions\
    \ that are later re-used\n   for the definitions for the configuration file syntax\
    \ and registry\n   entries:\n   algo-id          =    \"NOENCR\" / \"AES\" / \"\
    DES\" / \"3DES\" / \"IDEA\" /\n                            \"HMAC-MD5-96\" / \"\
    HMAC-SHA1-96\"\n   scope            =    \"HOSTLOCAL\" / \"LINKLOCAL\"\n   key\
    \              =    base64\n   version_number   =    1*10DIGIT\n   key_value \
    \       =    \"(\" algo-id \",\" key \")\"\n   address          =    IPv4address\
    \ / IPv6address / \"BROADCAST\"\n   port             =    1*5DIGIT   ; values\
    \ from 0 through 65535\n   Given the definition above, a key entry MUST be specified\
    \ using this\n   notation:\n      \"(\"algo-id\",\"base64string\")\"\n   algo-id\
    \ is one of the character strings specified above.  For algo-\n   id==\"NOENCR\"\
    \ the other fields are ignored.  The delimiting commas\n   MUST always be present\
    \ though.\n   A Base64 string consists of the characters defined in the Base64\n\
    \   char-set (see RFC 1521 [7]) including all possible padding\n   characters,\
    \ i.e., the length of a Base64-string is always a multiple\n   of 4.\n   The scope\
    \ parameter is used to configure an IP-Multicast scope and\n   may be set to either\
    \ \"HOSTLOCAL\" or \"LINKLOCAL\".  Implementations\n   SHOULD choose an appropriate\
    \ IP-Multicast scope depending on the\n   value of this parameter and construct\
    \ an effective IP-Address\n   considering the specifications of Section 6.1.\n\
    \   The use of broadcast is configured by providing the value \"BROADCAST\"\n\
    \   for the address field.  If broadcast has been configured,\n   implementations\
    \ SHOULD use the network broadcast address for the used\n   IP version instead\
    \ of the standard multicast address.\n   The version_number parameter specifies\
    \ a version number for the used\n   configuration entity.\n"
- title: 12.1  File based parameter storage
  contents:
  - "12.1  File based parameter storage\n   The file name for an Mbus configuration\
    \ file is \".mbus\" in the user's\n   home-directory.  If an environment variable\
    \ called MBUS is defined\n   implementations SHOULD interpret the value of this\
    \ variable as a\n   fully qualified file name that is to be used for the configuration\n\
    \   file.  Implementations MUST ensure that this file has appropriate\n   file\
    \ permissions that prevent other users to read or write it.  The\n   file MUST\
    \ exist before a conference is initiated.  Its contents MUST\n   be UTF-8 encoded\
    \ and MUST comply to the following syntax definition:\n      mbus-file     = \
    \   mbus-topic LF *(entry LF)\n      mbus-topic    =    \"[MBUS]\"\n      entry\
    \         =     1*(version_info / hashkey_info\n                             /\
    \ encryptionkey_info / scope_info\n                             / port_info /\
    \ address_info)\n      version_info  =    \"CONFIG_VERSION=\" version_number\n\
    \      hashkey_info  =    \"HASHKEY=\" key_value\n      encrkey_info  =    \"\
    ENCRYPTIONKEY=\" key_value\n      scope_info    =    \"SCOPE=\" scope\n      port_info\
    \     =    \"PORT=\" port\n      address_info  =    \"ADDRESS=\" address\n   The\
    \ following entries are defined: CONFIG_VERSION, HASHKEY,\n   ENCRYPTIONKEY, SCOPE,\
    \ PORT, ADDRESS.\n   The entries CONFIG_VERSION, HASHKEY and ENCRYPTIONKEY are\
    \ mandatory,\n   they MUST be present in every Mbus configuration file.  The order\
    \ of\n   entries is not significant.\n   An example for an Mbus configuration\
    \ file:\n      [MBUS]\n      CONFIG_VERSION=1\n      HASHKEY=(HMAC-MD5-96,MTIzMTU2MTg5MTEy)\n\
    \      ENCRYPTIONKEY=(DES,MTIzMTU2MQ==)\n      SCOPE=HOSTLOCAL\n      ADDRESS=224.255.222.239\n\
    \      PORT=47000\n"
- title: 12.2  Registry-based parameter storage
  contents:
  - "12.2  Registry-based parameter storage\n   For systems lacking the concept of\
    \ a user's home-directory as a place\n   for configuration files the suggested\
    \ database for configuration\n   settings (e.g., the Windows9x, Windows NT, Windows\
    \ 2000, Windows XP\n   registry) SHOULD be used.  The hierarchy for Mbus related\
    \ registry\n   entries is as follows:\n      HKEY_CURRENT_USER\\Software\\Mbus\n\
    \   The entries in this hierarchy section are:\n      +---------------+--------+----------------+\n\
    \      |Name           | Type   | ABNF production|\n      +---------------+--------+----------------|\n\
    \      |CONFIG_VERSION | DWORD  | version_number |\n      |HASHKEY        | String\
    \ | key_value      |\n      |ENCRYPTIONKEY  | String | key_value      |\n    \
    \  |SCOPE          | String | scope          |\n      |ADDRESS        | String\
    \ | address        |\n      |PORT           | DWORD  | port           |\n    \
    \  +---------------+--------+----------------+\n   The same syntax for key values\
    \ as for the file based configuration\n   facility MUST be used.\n"
- title: 13.  Security Considerations
  contents:
  - "13.  Security Considerations\n   The Mbus security mechanisms are specified in\
    \ Section 11.1.\n   It should be noted that the Mbus transport specification defines\
    \ a\n   mandatory baseline set of algorithms that have to be supported by\n  \
    \ implementations.  This baseline set is intended to provide reasonable\n   security\
    \ by mandating algorithms and key lengths that are considered\n   to be cryptographically\
    \ strong enough at the time of writing.\n   However, in order to allow for efficiency\
    \ it is allowable to use\n   cryptographically weaker algorithms, for example\
    \ HMAC-MD5 instead of\n   HMAC-SHA1.  Furthermore, encryption can be turned off\
    \ completely if\n   privacy is provided by other means or not considered important\
    \ for a\n   certain application.\n   Users of the Mbus should therefore be aware\
    \ of the selected security\n   configuration and should check if it meets the\
    \ security demands for a\n   given application.  Since every implementation MUST\
    \ provide the\n   cryptographically strong algorithm it should always be possible\
    \ to\n   configure an Mbus in a way that secure communication with\n   authentication\
    \ and privacy is ensured.\n   In any way, application developers should be aware\
    \ of incorrect IP\n   implementations that do not conform to RFC 1122 [2] and\
    \ do send\n   datagrams with TTL values of zero, resulting in Mbus messages sent\
    \ to\n   the local network link although a user might have selected host local\n\
    \   scope in the Mbus configuration.  When using administratively scoped\n   multicast,\
    \ users cannot always assume the presence of correctly\n   configured boundary\
    \ routers.  In these cases the use of encryption\n   SHOULD be considered if privacy\
    \ is desired.\n"
- title: 14.  IANA Considerations
  contents:
  - "14.  IANA Considerations\n   The IANA has assigned a scope-relative multicast\
    \ address with an\n   offset of 8 for Mbus/IPv4.  The IPv6 permanent multicast\
    \ address is\n   FF0X:0:0:0:0:0:0:300.\n   The registered Mbus UDP port number\
    \ is 47000.\n"
- title: 15.  References
  contents:
  - "15.  References\n   [1]   Bradner, S., \"Key words for use in RFCs to Indicate\
    \ Requirement\n         Levels\", BCP 14, RFC 2119, March 1997.\n   [2]   Braden,\
    \ R., \"Requirements for Internet Hosts -- Communication\n         Layers\", STD\
    \ 3, RFC 1122, October 1989.\n   [3]   Hinden, R. and S. Deering, \"IP Version\
    \ 6 Addressing\n         Architecture\", RFC 2373, July 1998.\n   [4]   Hinden,\
    \ R. and S. Deering, \"IPv6 Multicast Address\n         Assignments\", RFC 2375,\
    \ July 1998.\n   [5]   Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing\n\
    \         for Message Authentication\", RFC 2104, February 1997.\n   [6]   Resnick,\
    \ P., Editor, \"Internet Message Format\", RFC 2822, April\n         2001.\n \
    \  [7]   Borenstein, N. and N. Freed, \"MIME (Multipurpose Internet Mail\n   \
    \      Extensions) Part One: Mechanisms for Specifying and Describing\n      \
    \   the Format of Internet Message Bodies\", RFC 1521, September\n         1993.\n\
    \   [8]   Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobsen,\n      \
    \   \"RTP: A Transport Protocol for Real-Time Applications\", RFC\n         1889,\
    \ January 1996.\n   [9]   Handley, M., Schulzrinne, H., Schooler, E. and J. Rosenberg,\n\
    \         \"SIP: Session Initiation Protocol\", RFC 2543, March 1999.\n   [10]\
    \  Handley, M. and V. Jacobsen, \"SDP: Session Description\n         Protocol\"\
    , RFC 2327, April 1998.\n   [11]  Meyer, D., \"Administratively Scoped IP Multicast\"\
    , BCP 23, RFC\n         2365, July 1998.\n   [12]  Balenson, D., \"Privacy Enhancement\
    \ for Internet Electronic\n         Mail: Part III: Algorithms, Modes, and Identifiers\"\
    , RFC 1423,\n         February 1993.\n   [13]  Crocker, D. and P. Overell, \"\
    Augmented BNF for Syntax\n         Specifications: ABNF\", RFC 2234, November\
    \ 1997.\n   [14]  Myers, J., \"SMTP Service Extension for Authentication\", RFC\n\
    \         2554, March 1999.\n   [15]  Rivest, R., \"The MD5 Message-Digest Algorithm\"\
    , RFC 1321, April\n         1992.\n   [16]  U.S. DEPARTMENT OF COMMERCE/National\
    \ Institute of Standards and\n         Technology, \"Data Encryption Standard\
    \ (DES)\", FIPS PUB 46-3,\n         Category Computer Security, Subcategory Cryptography,\
    \ October\n         1999.\n   [17]  U.S. DEPARTMENT OF COMMERCE/National Institute\
    \ of Standards and\n         Technology, \"Secure Hash Standard\", FIPS PUB 180-1,\
    \ April 1995.\n   [18]  Daemen, J.D. and V.R. Rijmen, \"AES Proposal: Rijndael\"\
    , March\n         1999.\n   [19]  IANA, \"Internet Multicast Addresses\", URL\n\
    \         http://www.iana.org/assignments/multicast-addresses, May 2001.\n   [20]\
    \  Schneier, B., \"Applied Cryptography\", Edition 2, Publisher John\n       \
    \  Wiley & Sons, Inc., status: non-normative, 1996.\n"
- title: Appendix A.  About References
  contents:
  - "Appendix A.  About References\n   Please note that the list of references contains\
    \ normative as well as\n   non-normative references.  Each Non-normative references\
    \ is marked as\n   \"status: non-normative\".  All unmarked references are normative.\n"
- title: Appendix B.  Limitations and Future Work
  contents:
  - "Appendix B.  Limitations and Future Work\n   The Mbus is a light-weight local\
    \ coordination mechanism and\n   deliberately not designed for larger scope coordination.\
    \  It is\n   expected to be used on a single node or -- at most -- on a single\n\
    \   network link.\n   Therefore the Mbus protocol does not contain features that\
    \ would be\n   required to qualify it for the use over the global Internet:\n\
    \      There are no mechanisms to provide congestion control.  The issue\n   \
    \   of congestion control is a general problem for multicast\n      protocols.\
    \  The Mbus allows for un-acknowledged messages that are\n      sent unreliably,\
    \ for example as event notifications, from one\n      entity to another.  Since\
    \ negative acknowledgements are not\n      defined there is no way the sender\
    \ could realize that it is\n      flooding another entity or congesting a low\
    \ bandwidth network\n      segment.\n      The reliability mechanism, i.e., the\
    \ retransmission timers, are\n      designed to provide effective, responsive\
    \ message transport on\n      local links but are not suited to cope with larger\
    \ delays that\n      could be introduced from router queues etc.\n   Some experiments\
    \ are currently underway to test the applicability of\n   bridges between different\
    \ distributed Mbus domains without changing\n   the basic protocol semantics.\
    \  Since the use of such bridges should\n   be orthogonal to the basic Mbus protocol\
    \ definitions and since these\n   experiments are still work in progress there\
    \ is no mention of this\n   concept in this specification.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Joerg Ott\n   TZI, Universitaet Bremen\n   Bibliothekstr.\
    \ 1\n   Bremen  28359\n   Germany\n   Phone: +49.421.201-7028\n   Fax:   +49.421.218-7000\n\
    \   EMail: jo@tzi.uni-bremen.de\n   Colin Perkins\n   USC Information Sciences\
    \ Institute\n   3811 N. Fairfax Drive #200\n   Arlington VA 22203\n   USA\n  \
    \ EMail: csp@isi.edu\n   Dirk Kutscher\n   TZI, Universitaet Bremen\n   Bibliothekstr.\
    \ 1\n   Bremen  28359\n   Germany\n   Phone: +49.421.218-7595\n   Fax:   +49.421.218-7000\n\
    \   EMail: dku@tzi.uni-bremen.de\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2002).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
