- title: __initial_text__
  contents:
  - '                    Signaling Compression (SigComp)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document defines Signaling Compression (SigComp), a solution\
    \ for\n   compressing messages generated by application protocols such as the\n\
    \   Session Initiation Protocol (SIP) (RFC 3261) and the Real Time\n   Streaming\
    \ Protocol (RTSP) (RFC 2326).  The architecture and\n   prerequisites of SigComp\
    \ are outlined, along with the format of the\n   SigComp message.\n   Decompression\
    \ functionality for SigComp is provided by a Universal\n   Decompressor Virtual\
    \ Machine (UDVM) optimized for the task of running\n   decompression algorithms.\
    \  The UDVM can be configured to understand\n   the output of many well-known\
    \ compressors such as DEFLATE (RFC-1951).\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction...................................................2\n\
    \   2.  Terminology....................................................3\n   3.\
    \  SigComp architecture...........................................5\n   4.  SigComp\
    \ dispatchers...........................................15\n   5.  SigComp compressor............................................18\n\
    \   6.  SigComp state handler.........................................20\n   7.\
    \  SigComp message format........................................23\n   8.  Overview\
    \ of the UDVM..........................................28\n   9.  UDVM instruction\
    \ set..........................................37\n   10. Security Considerations.......................................56\n\
    \   11. IANA Considerations...........................................58\n   12.\
    \ Acknowledgements..............................................59\n   13. References....................................................59\n\
    \   14. Authors' Addresses............................................60\n   15.\
    \ Full Copyright Statement......................................62\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Many application protocols used for multimedia communications\
    \ are\n   text-based and engineered for bandwidth rich links.  As a result the\n\
    \   messages have not been optimized in terms of size.  For example,\n   typical\
    \ SIP messages range from a few hundred bytes up to two\n   thousand bytes or\
    \ more [RFC3261].\n   With the planned usage of these protocols in wireless handsets\
    \ as\n   part of 2.5G and 3G cellular networks, the large message size is\n  \
    \ problematic.  With low-rate IP connectivity the transmission delays\n   are\
    \ significant.  Taking into account retransmissions, and the\n   multiplicity\
    \ of messages that are required in some flows, call setup\n   and feature invocation\
    \ are adversely affected.  SigComp provides a\n   means to eliminate this problem\
    \ by offering robust, lossless\n   compression of application messages.\n   This\
    \ document outlines the architecture and prerequisites of the\n   SigComp solution,\
    \ the format of the SigComp message and the Universal\n   Decompressor Virtual\
    \ Machine (UDVM) that provides decompression\n   functionality.\n   SigComp is\
    \ offered to applications as a layer between the application\n   and an underlying\
    \ transport.  The service provided is that of the\n   underlying transport plus\
    \ compression.  SigComp supports a wide range\n   of transports including TCP,\
    \ UDP and SCTP [RFC-2960].\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in BCP\
    \ 14, RFC 2119\n   [RFC-2119].\n   Application\n      Entity that invokes SigComp\
    \ and performs the following tasks:\n      1. Supplying application messages to\
    \ the compressor dispatcher\n      2. Receiving decompressed messages from the\
    \ decompressor\n         dispatcher\n      3. Determining the compartment identifier\
    \ for a decompressed\n         message.\n   Bytecode\n      Machine code that\
    \ can be executed by a virtual machine.\n   Compressor\n      Entity that encodes\
    \ application messages using a certain\n      compression algorithm, and keeps\
    \ track of state that can be used\n      for compression.  The compressor is responsible\
    \ for ensuring that\n      the messages it generates can be decompressed by the\
    \ remote UDVM.\n   Compressor Dispatcher\n      Entity that receives application\
    \ messages, invokes a compressor,\n      and forwards the resulting SigComp compressed\
    \ messages to a remote\n      endpoint.\n   UDVM Cycles\n      A measure of the\
    \ amount of \"CPU power\" required to execute a UDVM\n      instruction (the simplest\
    \ UDVM instructions require a single UDVM\n      cycle).  An upper limit is placed\
    \ on the number of UDVM cycles\n      that can be used to decompress each bit\
    \ in a SigComp message.\n   Decompressor Dispatcher\n      Entity that receives\
    \ SigComp messages, invokes a UDVM, and\n      forwards the resulting decompressed\
    \ messages to the application.\n   Endpoint\n      One instance of an application,\
    \ a SigComp layer, and a transport\n      layer for sending and/or receiving SigComp\
    \ messages.\n   Message-based Transport\n      A transport that carries data as\
    \ a set of bounded messages.\n   Compartment\n      An application-specific grouping\
    \ of messages that relate to a peer\n      endpoint.  Depending on the signaling\
    \ protocol, this grouping may\n      relate to application concepts such as \"\
    session\", \"dialog\",\n      \"connection\", or \"association\".  The application\
    \ allocates state\n      memory on a per-compartment basis, and determines when\
    \ a\n      compartment should be created or closed.\n   Compartment Identifier\n\
    \      An identifier (in a locally chosen format) that uniquely\n      references\
    \ a compartment.\n   SigComp\n      The overall compression solution, comprising\
    \ the compressor, UDVM,\n      dispatchers and state handler.\n   SigComp Message\n\
    \      A message sent from the compressor dispatcher to the decompressor\n   \
    \   dispatcher.  In case of a message-based transport such as UDP, a\n      SigComp\
    \ message corresponds to exactly one datagram.  For a\n      stream-based transport\
    \ such as TCP, the SigComp messages are\n      separated by reserved delimiters.\n\
    \   Stream-based transport\n      A transport that carries data as a continuous\
    \ stream with no\n      message boundaries.\n   Transport\n      Mechanism for\
    \ passing data between two endpoints.  SigComp is\n      capable of sending messages\
    \ over a wide range of transports\n      including TCP, UDP and SCTP [RFC-2960].\n\
    \   Universal Decompressor Virtual Machine (UDVM)\n      The machine architecture\
    \ described in this document.  The UDVM is\n      used to decompress SigComp messages.\n\
    \   State\n      Data saved for retrieval by later SigComp messages.\n   State\
    \ Handler\n      Entity responsible for accessing and storing state information\n\
    \      once permission is granted by the application.\n   State Identifier\n \
    \     Reference used to access a previously created item of state.\n"
- title: 3.  SigComp Architecture
  contents:
  - "3.  SigComp Architecture\n   In the SigComp architecture, compression and decompression\
    \ is\n   performed at two communicating endpoints.  The layout of a single\n \
    \  endpoint is illustrated in Figure 1:\n   +-------------------------------------------------------------------+\n\
    \   |                                                                   |\n  \
    \ |                         Local application                         |\n   |\
    \                                                                   |\n   +-------------------------------------------------------------------+\n\
    \                           |                       ^  |\n     Application message\
    \ & |          Decompressed |  | Compartment\n    compartment identifier |   \
    \            message |  | identifier\n                           |           \
    \            |  |\n   +-- -- -- -- -- -- -- --|-- -- -- -- -- -- -- --|--|-- --\
    \ -- -- -- -+\n                           v                       |  v\n   | \
    \   +------------------------+         +----------------------+    |\n       \
    \ |                        |         |                      |\n   | +--|     \
    \  Compressor       |         |     Decompressor     |<-+ |\n     |  |       dispatcher\
    \       |         |      dispatcher      |  |\n   | |  |                     \
    \   |         |                      |  | |\n     |  +------------------------+\
    \         +----------------------+  |\n   | |  ^    ^                        \
    \                     ^         | |\n     |  |    |                          \
    \                   |         |\n   | |  |    v                              \
    \               |         | |\n     |  |  +--------------+   +---------------+\
    \            |         |\n   | |  |  |              |   |   +-------+   |    \
    \        v         | |\n     |  |  | Compressor 1 |<----->|State 1|   |    +--------------+\
    \  |\n   | |  |  |              |   |   +-------+   |    |              |  | |\n\
    \     |  |  +--------------+   |               |    | Decompressor |  |\n   |\
    \ |  |                     | State handler |<-->|              |  | |\n     |\
    \  |  +--------------+   |               |    |    (UDVM)    |  |\n   | |  | \
    \ |              |   |   +-------+   |    |              |  | |\n     |  +->|\
    \ Compressor 2 |<----->|State 2|   |    +--------------+  |\n   | |     |    \
    \          |   |   +-------+   |                      | |\n     |     +--------------+\
    \   +---------------+      SigComp layer   |\n   | |                         \
    \                                      | |\n   +-| -- -- -- -- -- -- -- -- --\
    \ -- -- -- -- -- -- -- -- -- -- -- --|-+\n     |                             \
    \                                  |\n     | SigComp                         \
    \                      SigComp |\n     | message                             \
    \                  message |\n     v                                         \
    \                      |\n   +-------------------------------------------------------------------+\n\
    \   |                                                                   |\n  \
    \ |                          Transport layer                          |\n   |\
    \                                                                   |\n   +-------------------------------------------------------------------+\n\
    \    Figure 1: High-level architectural overview of one SigComp endpoint\n   Note\
    \ that SigComp is offered to applications as a layer between the\n   application\
    \ and the underlying transport, and so Figure 1 is an\n   endpoint when viewed\
    \ from a transport layer perspective.  From the\n   perspective of multi-hop application\
    \ layer protocols however, SigComp\n   is applied on a per-hop basis.\n   The\
    \ SigComp layer is further decomposed into the following entities:\n   1. Compressor\
    \ dispatcher - the interface from the application.  The\n      application supplies\
    \ the compressor dispatcher with an application\n      message and a compartment\
    \ identifier (see Section 3.1 for further\n      details).  The compressor dispatcher\
    \ invokes a particular\n      compressor, which returns a SigComp message to be\
    \ forwarded to the\n      remote endpoint.\n   2. Decompressor dispatcher - the\
    \ interface towards the application.\n      The decompressor dispatcher receives\
    \ a SigComp message and invokes\n      an instance of the Universal Decompressor\
    \ Virtual Machine (UDVM).\n      It then forwards the resulting decompressed message\
    \ to the\n      application, which may return a compartment identifier if it\n\
    \      wishes to allow state to be saved for the message.\n   3. One or more compressors\
    \ - the entities that convert application\n      messages into SigComp messages.\
    \  Distinct compressors are invoked\n      on a per-compartment basis, using the\
    \ compartment identifiers\n      supplied by the application.  A compressor receives\
    \ an application\n      message from the compressor dispatcher, compresses the\
    \ message,\n      and returns a SigComp message to the compressor dispatcher.\
    \  Each\n      compressor chooses a certain algorithm to encode the data (e.g.,\n\
    \      DEFLATE).\n   4. UDVM - the entity that decompresses SigComp messages.\
    \ Note that\n      since SigComp can run over an unsecured transport layer, a\n\
    \      separate instance of the UDVM is invoked on a per-message basis.\n    \
    \  However, during the decompression process the UDVM may invoke the\n      state\
    \ handler to access existing state or create new state.\n   5. State handler -\
    \ the entity that can store and retrieve state.\n      State is information that\
    \ is stored between SigComp messages,\n      avoiding the need to upload the data\
    \ on a per-message basis.  For\n      security purposes it is only possible to\
    \ create new state with the\n      permission of the application.  State creation\
    \ and retrieval are\n      further described in Chapter 6.\n   When compressing\
    \ a bidirectional application protocol the choice to\n   use SigComp can be made\
    \ independently in both directions, and\n   compression in one direction does\
    \ not necessarily imply compression\n   in the reverse direction.  Moreover, even\
    \ when two communicating\n   endpoints send SigComp messages in both directions,\
    \ there is no need\n   to use the same compression algorithm in each direction.\n\
    \   Note that a SigComp endpoint can decompress messages from multiple\n   remote\
    \ endpoints at different locations in a network, as the\n   architecture is designed\
    \ to prevent SigComp messages from one\n   endpoint interfering with messages\
    \ from a different endpoint.  A\n   consequence of this design choice is that\
    \ it is difficult for a\n   malicious user to disrupt SigComp operation by inserting\
    \ false\n   compressed messages on the transport layer.\n"
- title: 3.1.  Requirements on the Application
  contents:
  - "3.1.  Requirements on the Application\n   From an application perspective the\
    \ SigComp layer appears as a new\n   transport, with similar behavior to the original\
    \ transport used to\n   carry uncompressed data (for example SigComp/UDP behaves\
    \ similarly to\n   native UDP).\n   Mechanisms for discovering whether an endpoint\
    \ supports SigComp are\n   beyond the scope of this document.\n   All SigComp\
    \ messages contain a prefix (the five most-significant bits\n   of the first byte\
    \ are set to one) that does not occur in UTF-8\n   encoded text messages [RFC-2279],\
    \ so for applications which use this\n   encoding (or ASCII encoding) it is possible\
    \ to multiplex uncompressed\n   application messages and SigComp messages on the\
    \ same port.\n   Applications can still reserve a new port specifically for SigComp\n\
    \   however (e.g., as part of the discovery mechanism).\n   If a particular endpoint\
    \ wishes to be stateful then it needs to\n   partition its decompressed messages\
    \ into \"compartments\" under which\n   state can be saved.  SigComp relies on\
    \ the application to provide\n   this partition.  So for stateful endpoints a\
    \ new interface is\n   required to the application in order to leverage the authentication\n\
    \   mechanisms used by the application itself.\n   When the application receives\
    \ a decompressed message it maps the\n   message to a certain compartment and\
    \ supplies the compartment\n   identifier to SigComp.  Each compartment is allocated\
    \ a separate\n   compressor and a certain amount of memory to store state information,\n\
    \   so the application must assign distinct compartments to distinct\n   remote\
    \ endpoints.  However it is possible for a local endpoint to\n   establish several\
    \ compartments that relate to the same remote\n   endpoint (this should be avoided\
    \ where possible as it may waste\n   memory and reduce the overall compression\
    \ ratio, but it does not\n   cause messages to be incorrectly decompressed). \
    \ In this case,\n   reliable stateful operation is possible only if the decompressor\
    \ does\n   not lump several messages into one compartment when the compressor\n\
    \   expected them to be assigned different compartments.\n   The exact format\
    \ of the compartment identifier is unimportant\n   provided that different identifiers\
    \ are given to different\n   compartments.\n   Applications that wish to communicate\
    \ using SigComp in a stateful\n   fashion should use an authentication mechanism\
    \ to securely map\n   decompressed messages to compartment identifiers.  They\
    \ should also\n   agree on any limits to the lifetime of a compartment, to avoid\
    \ the\n   case where an endpoint accesses state information that has already\n\
    \   been deleted.\n"
- title: 3.2.  SigComp feedback mechanism
  contents:
  - "3.2.  SigComp feedback mechanism\n   If a signaling protocol sends SigComp messages\
    \ in both directions and\n   there is a one-to-one relationship between the compartments\n\
    \   established by the applications on both ends (\"peer compartments\"),\n  \
    \ the two endpoints can cooperate more closely.  In this case, it is\n   possible\
    \ to send feedback information that monitors the behavior of\n   an endpoint and\
    \ helps to improve the overall compression ratio.\n   SigComp performs feedback\
    \ on a request/response basis, so a\n   compressor makes a feedback request and\
    \ receives some feedback data\n   in return.  The procedure for requesting and\
    \ returning feedback in\n   SigComp is illustrated in Figure 2:\n    +---------------------+\
    \                     +---------------------+\n    | +-----------------+ |   \
    \                  | +-----------------+ |\n   -->|   Compressor    |------------------------>|\
    \      UDVM       |<->\n    | |  sending to B   | |   SigComp message   | |  \
    \               | |2\n    | +-----------------+ | requesting feedback | +-----------------+\
    \ |\n    |          ^     1,9  |                     |  3       |          |\n\
    \    |          |          |                     |          v          |\n   \
    \ | +-----------------+ |                     | +-----------------+ |\n    | |\
    \      State      | |                     | |      State      | |\n    | |   \
    \  handler     | |                     | |     handler     | |\n    | +-----------------+\
    \ |                     | +-----------------+ |\n    |          ^       8  | \
    \                    |  4       |          |\n    |          |          |    \
    \                 |          v          |\n    | +-----------------+ |       \
    \              | +-----------------+ |\n    | |      UDVM       | |          \
    \           | |   Compressor    | |\n   <->|                 |<------------------------|\
    \  sending to A   |<--\n   6| +-----------------+ |   SigComp message   | +-----------------+\
    \ |\n    |                  7  | returning feedback  |  5                  |\n\
    \    |     Endpoint A      |                     |     Endpoint B      |\n   \
    \ +---------------------+                     +---------------------+\n      \
    \ Figure 2: Steps involved in the transmission of feedback data\n   The dispatchers,\
    \ the application and the transport layer are omitted\n   from the diagram for\
    \ clarity.  Note that the decompressed messages\n   pass via the decompressor\
    \ dispatcher to the application; moreover the\n   SigComp messages transmitted\
    \ from the compressor to the remote UDVM\n   are sent via first the compressor\
    \ dispatcher, followed by the\n   transport layer and finally the decompressor\
    \ dispatcher.\n   The steps for requesting and returning feedback data are described\
    \ in\n   more detail below:\n   1. The compressor that sends messages to Endpoint\
    \ B piggybacks a\n      feedback request onto a SigComp message.\n   2. When the\
    \ application receives the decompressed message, it may\n      return the compartment\
    \ identifier for the message.\n   3. The UDVM in Endpoint B forwards the requested\
    \ feedback data to the\n      state handler.\n   4. If the UDVM can supply a valid\
    \ compartment identifier, then the\n      state handler forwards the feedback\
    \ data to the appropriate\n      compressor (namely the compressor sending to\
    \ Endpoint A).\n   5. The compressor returns the requested feedback data to Endpoint\
    \ A\n      piggybacked onto a SigComp message.\n   6. When the application receives\
    \ the decompressed message, it may\n      return the compartment identifier for\
    \ the message.\n   7. The UDVM in Endpoint A forwards the returned feedback data\
    \ to the\n      state handler.\n   8. If the UDVM can supply a valid compartment\
    \ identifier, then the\n      state handler forwards the feedback data to the\
    \ appropriate\n      compressor (namely the compressor sending to Endpoint B).\n\
    \   9. The compressor makes use of the returned feedback data.\n   The detailed\
    \ role played by each entity in the transmission of\n   feedback data is explained\
    \ in subsequent chapters.\n"
- title: 3.3.  SigComp Parameters
  contents:
  - "3.3.  SigComp Parameters\n   An advantage of using a virtual machine for decompression\
    \ is that\n   almost all of the implementation flexibility lies in the SigComp\n\
    \   compressors.  When receiving SigComp messages an endpoint generally\n   behaves\
    \ in a predictable manner.\n   Note however that endpoints implementing SigComp\
    \ will typically have\n   a wide range of capabilities, each offering a different\
    \ amount of\n   working memory, processing power etc.  In order to support this\
    \ wide\n   variation in endpoint capabilities, the following parameters are\n\
    \   provided to modify SigComp behavior when receiving SigComp messages:\n   decompression_memory_size\n\
    \   state_memory_size\n   cycles_per_bit\n   SigComp_version\n   locally available\
    \ state (a set containing 0 or more state items)\n   Each parameter has a minimum\
    \ value that MUST be offered by all\n   receiving SigComp endpoints.  Moreover,\
    \ endpoints MAY offer\n   additional resources if available; these resources can\
    \ be advertised\n   to remote endpoints using the SigComp feedback mechanism.\n\
    \   Particular applications may also agree a-priori to offer additional\n   resources\
    \ as mandatory (e.g., SigComp for SIP offers a dictionary of\n   common SIP phrases\
    \ as a mandatory state item).\n   Each of the SigComp parameters is described\
    \ in greater detail below.\n"
- title: 3.3.1.  Memory Size and UDVM Cycles
  contents:
  - "3.3.1.  Memory Size and UDVM Cycles\n   The decompression_memory_size parameter\
    \ specifies the amount of\n   memory available to decompress one SigComp message.\
    \  (Note that the\n   term \"amount of memory\" is used on a conceptual level\
    \ in order to\n   specify decompressor behavior and allow resource planning on\
    \ the side\n   of the compressor -- an implementation could require additional,\n\
    \   bounded amounts of actual memory resources or could even organize its\n  \
    \ memory in a completely different way as long as this does not cause\n   decompression\
    \ failures where the conceptual model would not.)  A\n   portion of this memory\
    \ is used to buffer a SigComp message before it\n   is decompressed; the remainder\
    \ is given to the UDVM.  Note that the\n   memory is allocated on a per-message\
    \ basis and can be reclaimed after\n   the message has been decompressed.  All\
    \ endpoints implementing\n   SigComp MUST offer a decompression_memory_size of\
    \ at least 2048\n   bytes.\n   The state_memory_size parameter specifies the number\
    \ of bytes offered\n   to a particular compartment for the creation of state.\
    \  This\n   parameter is set to 0 if the endpoint is stateless.\n   Unlike the\
    \ other SigComp parameters, the state_memory_size is offered\n   on a per-compartment\
    \ basis and may vary for different compartments.\n   The memory for a compartment\
    \ is reclaimed when the application\n   determines that the compartment is no\
    \ longer required.\n   The cycles_per_bit parameter specifies the number of \"\
    UDVM cycles\"\n   available to decompress each bit in a SigComp message.  Executing\
    \ a\n   UDVM instruction requires a certain number of UDVM cycles; a complete\n\
    \   list of UDVM instructions and their cost in UDVM cycles can be found\n   in\
    \ Chapter 9.  An endpoint MUST offer a minimum of 16 cycles_per_bit.\n   Each\
    \ of the three parameter values MUST be chosen from the limited\n   set given\
    \ below, so that the parameters can be efficiently encoded\n   for transmission\
    \ using the SigComp feedback mechanism.\n   The cycles_per_bit parameter is encoded\
    \ using 2 bits, whilst the\n   decompression_memory_size and state_memory_size\
    \ are both encoded\n   using 3 bits.  The bit encodings and their corresponding\
    \ values are\n   as follows:\n   Encoding:   cycles_per_bit:   Encoding:   state_memory_size\
    \ (bytes):\n   00          16                000         0\n   01          32\
    \                001         2048\n   10          64                010      \
    \   4096\n   11          128               011         8192\n                \
    \                 100         16384\n                                 101    \
    \     32768\n                                 110         65536\n            \
    \                     111         131072\n   The decompression_memory_size is\
    \ encoded in the same manner as the\n   state_memory_size, except that the bit\
    \ pattern 000 cannot be used (as\n   an endpoint cannot offer a decompression_memory_size\
    \ of 0 bytes).\n"
- title: 3.3.2.  SigComp Version
  contents:
  - "3.3.2.  SigComp Version\n   The SigComp_version parameter specifies whether only\
    \ the basic\n   version of SigComp is available, or whether an upgraded version\
    \ is\n   available offering additional instructions etc.  Within the UDVM, it\n\
    \   is available as a 2-byte value, generated by zero-extending the 1-\n   byte\
    \ SigComp_version parameter (i.e., the first byte of the 2-byte\n   value is always\
    \ zero).\n   The basic version of SigComp is Version 0x01, which is the version\n\
    \   described in this document.\n   To ensure backwards compatibility, if a SigComp\
    \ message is\n   successfully decompressed by Version 0x01 of SigComp then it\
    \ will be\n   successfully decompressed on upgraded versions.  Similarly, if the\n\
    \   message triggers a manual decompression failure (see Section 8.7),\n   then\
    \ it will also continue to do so.\n   However, messages that cause an unexpected\
    \ decompression failure on\n   Version 0x01 of SigComp may be successfully decompressed\
    \ by upgraded\n   versions.\n   The simplest way to upgrade SigComp in a backwards-compatible\
    \ manner\n   is to add additional UDVM instructions, as this will not affect the\n\
    \   decompression of SigComp messages compatible with Version 0x01.\n   Reserved\
    \ addresses in the UDVM memory (Useful Values, see Section\n   7.2) may also be\
    \ assigned values in future versions of SigComp.\n"
- title: 3.3.3.  Locally Available State Items
  contents:
  - "3.3.3.  Locally Available State Items\n   A SigComp state item is an item of\
    \ data that is retained between\n   SigComp messages.  State items can be retrieved\
    \ and loaded into the\n   UDVM memory as part of the decompression process, often\
    \ significantly\n   improving the compression ratio as the same information does\
    \ not have\n   to be uploaded on a per-message basis.\n   Each endpoint maintains\
    \ a set of state items where every item is\n   composed of the following information:\n\
    \   Name:                      Type of data:\n   state_identifier           20-byte\
    \ value\n   state_length               2-byte value\n   state_address        \
    \      2-byte value\n   state_instruction          2-byte value\n   minimum_access_length\
    \      2-byte value from 6 to 20 inclusive\n   state_value                String\
    \ of state_length consecutive bytes\n   State items are typically created at an\
    \ endpoint upon successful\n   decompression of a SigComp message.  The remote\
    \ compressor sending\n   the message makes a state creation request by invoking\
    \ the\n   appropriate UDVM instruction, and the state is saved once permission\n\
    \   is granted by the application.\n   However, an endpoint MAY also wish to offer\
    \ a set of locally\n   available state items that have not been uploaded as part\
    \ of a\n   SigComp message.  For example it might offer well-known decompression\n\
    \   algorithms, dictionaries of common phrases used in a specific\n   signaling\
    \ protocol, etc.\n   Since these state items are established locally without input\
    \ from a\n   remote endpoint, they are most useful if publicly documented so that\n\
    \   a wide collection of remote endpoints can determine the data\n   contained\
    \ in each state item and how it may be used.  Further\n   Internet Documents and\
    \ RFCs may be published to describe particular\n   locally available state items.\n\
    \   Although there are no locally available state items that are\n   mandatory\
    \ for every SigComp endpoint, certain state items can be made\n   mandatory in\
    \ a specific environment (e.g., the dictionary of common\n   phrases for a specific\
    \ signaling protocol could be made mandatory for\n   that signaling protocol's\
    \ usage of SigComp).  Also, remote endpoints\n   can indicate their interest in\
    \ receiving a list of some of the state\n   items available locally at an endpoint\
    \ using the SigComp feedback\n   mechanism.\n   It is a matter of local decision\
    \ for an endpoint what items of\n   locally available state it advertises; this\
    \ decision has no influence\n   on interoperability, but may increase or decrease\
    \ the efficiency of\n   the compression achievable between the endpoints.\n"
- title: 4.  SigComp Dispatchers
  contents:
  - "4.  SigComp Dispatchers\n   This chapter defines the behavior of the compressor\
    \ and decompressor\n   dispatcher.  The function of these entities is to provide\
    \ an\n   interface between SigComp and its environment, minimizing the effort\n\
    \   needed to integrate SigComp into an existing protocol stack.\n"
- title: 4.1.  Compressor Dispatcher
  contents:
  - "4.1.  Compressor Dispatcher\n   The compressor dispatcher receives messages from\
    \ the application and\n   passes the compressed version of each message to the\
    \ transport layer.\n   Note that SigComp invokes compressors on a per-compartment\
    \ basis, so\n   when the application provides a message to be compressed it must\
    \ also\n   provide a compartment identifier.  The compressor dispatcher forwards\n\
    \   the application message to the correct compressor based on the\n   compartment\
    \ identifier (invoking a new compressor if a new\n   compartment identifier is\
    \ encountered).  The compressor returns a\n   SigComp message that can be passed\
    \ to the transport layer.\n   Additionally, the application should indicate to\
    \ the compressor\n   dispatcher when it wishes to close a particular compartment,\
    \ so that\n   the resources taken by the corresponding compressor can be reclaimed.\n"
- title: 4.2.  Decompressor Dispatcher
  contents:
  - "4.2.  Decompressor Dispatcher\n   The decompressor dispatcher receives messages\
    \ from the transport\n   layer and passes the decompressed version of each message\
    \ to the\n   application.\n   To ensure that SigComp can run over an unsecured\
    \ transport layer, the\n   decompressor dispatcher invokes a new instance of the\
    \ UDVM for each\n   new SigComp message.  Resources for the UDVM are released\
    \ as soon as\n   the message has been decompressed.\n   The dispatcher MUST NOT\
    \ make more than one SigComp message available\n   to a given instance of the\
    \ UDVM.  In particular, the dispatcher MUST\n   NOT concatenate two SigComp messages\
    \ to form a single message.\n"
- title: 4.2.1.  Decompressor Dispatcher Strategies
  contents:
  - "4.2.1.  Decompressor Dispatcher Strategies\n   Once the UDVM has been invoked\
    \ it is initialized using the SigComp\n   message of Chapter 7.  The message is\
    \ then decompressed by the UDVM,\n   returned to the decompressor dispatcher,\
    \ and passed on to the\n   receiving application.  Note that the UDVM has no awareness\
    \ of\n   whether the underlying transport is message-based or stream-based,\n\
    \   and so it always outputs decompressed data as a stream.  It is the\n   responsibility\
    \ of the dispatcher to provide the decompressed message\n   to the application\
    \ in the expected form (i.e., as a stream or as a\n   distinct, bounded message).\
    \  The dispatcher knows that the end of a\n   decompressed message has been reached\
    \ when the UDVM instruction END-\n   MESSAGE is invoked (see Section 9.4.9).\n\
    \   For a stream-based transport, two strategies are therefore possible\n   for\
    \ the decompressor dispatcher:\n   1) The dispatcher collects a complete SigComp\
    \ message and then\n      invokes the UDVM.  The advantage is that, even in implementations\n\
    \      that have multiple incoming compressed streams, only one instance\n   \
    \   of the UDVM is ever required.\n   2) The dispatcher collects the SigComp header\
    \ (see Section 7) and\n      invokes the UDVM; the UDVM stays active while the\
    \ rest of the\n      message arrives.  The advantage is that there is no need\
    \ to buffer\n      up the rest of the message; the message can be decompressed\
    \ as it\n      arrives, and any decompressed output can be relayed to the\n  \
    \    application immediately.\n   In general, which of the strategies is used\
    \ is an implementation\n   choice.\n   However, the compressor may want to take\
    \ advantage of strategy 2 by\n   expecting that some of the application message\
    \ is passed on to the\n   application before the SigComp message is terminated,\
    \ e.g., by\n   keeping the UDVM active while expecting the application to\n  \
    \ continuously receive decompressed output.  This approach (\"continuous\n   mode\"\
    ) invalidates some assumptions of the SigComp security model and\n   can only\
    \ be used if the transport itself can provide the required\n   protection against\
    \ denial of service attacks.  Also, since only\n   strategy 2 works in this approach,\
    \ the use of continuous mode\n   requires previous agreement between the two endpoints.\n"
- title: 4.2.2.  Record Marking
  contents:
  - "4.2.2.  Record Marking\n   For a stream-based transport, the dispatcher delimits\
    \ messages by\n   parsing the compressed data stream for instances of 0xFF and\
    \ taking\n   the following actions:\n   Occurs in data stream:     Action:\n \
    \  0xFF 00                    one 0xFF byte in the data stream\n   0xFF 01   \
    \                 same, but the next byte is quoted (could\n                 \
    \             be another 0xFF)\n      :                                      \
    \     :\n   0xFF 7F                    same, but the next 127 bytes are quoted\n\
    \   0xFF 80 to 0xFF FE         (reserved for future standardization)\n   0xFF\
    \ FF                    end of SigComp message\n   The combinations 0xFF01 to\
    \ 0xFF7F are useful to limit the worst case\n   expansion of the record marking\
    \ scheme:  the 1 (0xFF01) to 127\n   (0xFF7F) bytes following the byte combination\
    \ are copied literally by\n   the decompressor without taking any special action\
    \ on 0xFF.  (Note\n   that 0xFF00 is just a special case of this, where zero following\n\
    \   bytes are copied literally.)\n   In UDVM version 0x01, any occurrence of the\
    \ combinations 0xFF80 to\n   0xFFFE that are not protected by quoting causes decompression\n\
    \   failure; the decompressor SHOULD close the stream-based transport in\n   this\
    \ case.\n"
- title: 4.3.  Returning a Compartment Identifier
  contents:
  - "4.3.  Returning a Compartment Identifier\n   Upon receiving a decompressed message\
    \ the application may supply the\n   dispatcher with a compartment identifier.\
    \  Supplying this identifier\n   grants permission for the following:\n   1. Items\
    \ of state accompanying the decompressed message can be saved\n      using the\
    \ state memory reserved for the specified compartment.\n   2. The feedback data\
    \ accompanying the decompressed message can be\n      trusted sufficiently that\
    \ it can be used when sending SigComp\n      messages that relate to the compressor's\
    \ equivalent for the\n      compartment.\n   The dispatcher passes the compartment\
    \ identifier to the UDVM, where\n   it is used as per the END-MESSAGE instruction\
    \ (see Section 9.4.9).\n   The application uses a suitable authentication mechanism\
    \ to determine\n   whether the decompressed message belongs to a legitimate compartment\n\
    \   or not.  If the application fails to authenticate the message with\n   sufficient\
    \ confidence to allow state to be saved or feedback data to\n   be trusted, it\
    \ supplies a \"no valid compartment\" error to the\n   dispatcher and the UDVM\
    \ is terminated without creating any state or\n   forwarding any feedback data.\n"
- title: 5.  SigComp Compressor
  contents:
  - "5.  SigComp Compressor\n   An important feature of SigComp is that decompression\
    \ functionality\n   is provided by a Universal Decompressor Virtual Machine (UDVM).\
    \  This\n   means that the compressor can choose any algorithm to generate\n \
    \  compressed SigComp messages, and then upload bytecode for the\n   corresponding\
    \ decompression algorithm to the UDVM as part of the\n   SigComp message.\n  \
    \ To help with the implementation and testing of a SigComp endpoint,\n   further\
    \ Internet Documents and RFCs may be published to describe\n   particular compression\
    \ algorithms.\n   The overall requirement placed on the compressor is that of\n\
    \   transparency, i.e., the compressor MUST NOT send bytecode which\n   causes\
    \ the UDVM to incorrectly decompress a given SigComp message.\n   The following\
    \ more specific requirements are also placed on the\n   compressor (they can be\
    \ considered particular instances of the\n   transparency requirement):\n   1.\
    \ For robustness, it is recommended that the compressor supply some\n      form\
    \ of integrity check (not necessarily of cryptographic\n      strength) over the\
    \ application message to ensure that successful\n      decompression has occurred.\
    \  A UDVM instruction is provided for\n      CRC verification; also, another instruction\
    \ can be used to compute\n      a SHA-1 cryptographic hash.\n   2. The compressor\
    \ MUST ensure that the message can be decompressed\n      using the resources\
    \ available at the remote endpoint.\n   3. If the transport is message-based,\
    \ then the compressor MUST map\n      each application message to exactly one\
    \ SigComp message.\n   4. If the transport is stream-based but the application\
    \ defines its\n      own internal message boundaries, then the compressor SHOULD\
    \ map\n      each application message to exactly one SigComp message.\n   Message\
    \ boundaries should be preserved over a stream-based transport\n   so that accidental\
    \ or malicious damage to one SigComp message does\n   not affect the decompression\
    \ of subsequent messages.\n   Additionally, if the state handler passes some requested\
    \ feedback to\n   the compressor, then it SHOULD be returned in the next SigComp\n\
    \   message generated by the compressor (unless the state handler passes\n   some\
    \ newer requested feedback before the older feedback has been\n   sent, in which\
    \ case the older feedback is deleted).\n   If present, the requested feedback\
    \ item SHOULD be copied unmodified\n   into the returned_feedback_item field provided\
    \ in the SigComp\n   message.  Note that there is no need to transmit any requested\n\
    \   feedback item more than once.\n   The compressor SHOULD also upload the local\
    \ SigComp parameters to the\n   remote endpoint, unless the endpoint has indicated\
    \ that it does not\n   wish to receive these parameters or the compressor determines\
    \ that\n   the parameters have already successfully arrived (see Section 5.1 for\n\
    \   details of how this can be achieved).  The SigComp parameters are\n   uploaded\
    \ to the UDVM memory at the remote endpoint as described in\n   Section 9.4.9.\n"
- title: 5.1.  Ensuring Successful Decompression
  contents:
  - "5.1.  Ensuring Successful Decompression\n   A compressor MUST be certain that\
    \ all of the data needed to\n   decompress a SigComp message is available at the\
    \ receiving endpoint.\n   One way to ensure this is to send all of the needed\
    \ information in\n   every SigComp message (including bytecode to decompress the\
    \ message).\n   However, the compression ratio for this method will be relatively\n\
    \   low.\n   To obtain the best overall compression ratio the compressor needs\
    \ to\n   request the creation of new state items at the remote endpoint.  The\n\
    \   information saved in these state items can then be accessed by later\n   SigComp\
    \ messages, avoiding the need to upload the data on a per-\n   message basis.\n\
    \   Before the compressor can access saved state however, it must ensure\n   that\
    \ the SigComp message carrying the state creation request arrived\n   successfully\
    \ at the receiving endpoint.  For a reliable transport\n   (e.g., TCP or SCTP)\
    \ this is guaranteed.  For an unreliable transport\n   however, the compressor\
    \ must provide a suitable mechanism itself (see\n   [RFC-3321] for further details).\n\
    \   The compressor must also ensure that the state item it wishes to\n   access\
    \ has not been rejected due to a lack of state memory.  This can\n   be accomplished\
    \ by checking the state_memory_size parameter using the\n   SigComp feedback mechanism\
    \ (see Section 9.4.9 for further details).\n"
- title: 5.2.  Compression Failure
  contents:
  - "5.2.  Compression Failure\n   The compressor SHOULD make every effort to successfully\
    \ compress an\n   application message, but in certain cases this might not be\
    \ possible\n   (particularly if resources are scarce at the receiving endpoint).\
    \ In\n   this case a \"compression failure\" is called.\n   If a compression failure\
    \ occurs then the compressor informs the\n   dispatcher and takes no further action.\
    \  The dispatcher MUST report\n   this failure to the application so that it can\
    \ try other methods to\n   deliver the message.\n"
- title: 6.  State Handling and Feedback
  contents:
  - "6.  State Handling and Feedback\n   This chapter defines the behavior of the\
    \ SigComp state handler.  The\n   function of the state handler is to retain information\
    \ between\n   received SigComp messages; it is the only SigComp entity that is\n\
    \   capable of this function, and so it is of particular importance from\n   a\
    \ security perspective.\n"
- title: 6.1.  Creating and Accessing State
  contents:
  - "6.1.  Creating and Accessing State\n   To provide security against the malicious\
    \ insertion or modification\n   of SigComp messages, a separate instance of the\
    \ UDVM is invoked to\n   decompress each message.  This ensures that damaged SigComp\
    \ messages\n   do not prevent the successful decompression of subsequent valid\n\
    \   messages.\n   Note, however, that the overall compression ratio is often\n\
    \   significantly higher if messages can be compressed relative to the\n   information\
    \ contained in previous messages.  For this reason, it is\n   possible to create\
    \ state items for access when a later message is\n   being decompressed.  Both\
    \ the creation and access of state are\n   designed to be secure against malicious\
    \ tampering with the compressed\n   data.  The UDVM can only create a state item\
    \ when a complete message\n   has been successfully decompressed and the application\
    \ has returned a\n   compartment identifier under which the state can be saved.\n\
    \   State access cannot be protected by relying on the application alone,\n  \
    \ since the authentication mechanism may require information from the\n   decompressed\
    \ message (which of course is not available until after\n   the state has been\
    \ accessed).  Instead, SigComp protects state access\n   by creating a state identifier\
    \ that is a hash over the item of state\n   to be retrieved.  This state_identifier\
    \ must be supplied to retrieve\n   an item of state from the state handler.\n\
    \   Also note that state is not deleted when it is accessed.  So even if\n   a\
    \ malicious sender manages to access some state information,\n   subsequent messages\
    \ compressed relative to this state can still be\n   successfully decompressed.\n\
    \   Each state item contains a state_identifier that is used to access\n   the\
    \ state.  One state identifier can be supplied in the SigComp\n   message header\
    \ to initialize the UDVM (see Chapter 7); additional\n   state items can be retrieved\
    \ using the STATE-ACCESS instruction.  The\n   UDVM can also request the creation\
    \ of a new state item by using the\n   STATE-CREATE and END-MESSAGE instructions\
    \ (see Chapter 9 for further\n   details).\n"
- title: 6.2.  Memory Management
  contents:
  - "6.2.  Memory Management\n   The state handler manages state memory on a per-compartment\
    \ basis.\n   Each compartment can store state up to a certain state_memory_size\n\
    \   (where the application may assign different values for the\n   state_memory_size\
    \ parameter to different compartments).\n   As well as storing the state items\
    \ themselves, the state handler\n   maintains a list of the state items created\
    \ by a particular\n   compartment and ensures that no compartment exceeds its\
    \ allocated\n   state_memory_size.  For the purpose of calculation, each state\
    \ item\n   is considered to cost (state_length + 64) bytes.\n   Each instance\
    \ of the UDVM can pass up to four state creation requests\n   to the state handler,\
    \ as well as up to four state free requests (the\n   latter are requests to free\
    \ the memory taken by a state item in a\n   certain compartment).  When the state\
    \ handler receives a state\n   creation request from the UDVM it takes the following\
    \ steps:\n   1. The state handler MUST reject all state creation requests that\
    \ are\n      not accompanied by a valid compartment identifier, or if the\n  \
    \    compartment is allocated 0 bytes of state memory. Note that if a\n      state\
    \ creation request fails due to lack of state memory then it\n      does not mean\
    \ that the corresponding SigComp message is damaged;\n      compressors will often\
    \ make state creation requests in the first\n      SigComp message of a compartment,\
    \ before they have discovered the\n      state_memory_size using the SigComp feedback\
    \ mechanism.\n   2. If the state creation request needs more state memory than\
    \ the\n      total state_memory_size for the compartment, the state handler\n\
    \      deletes all but the first (state_memory_size - 64) bytes from the\n   \
    \   state_value.  It sets the state_length to (state_memory_size -\n      64),\
    \ and recalculates the state_identifier as defined in Section\n      9.4.9.\n\
    \   3. If the state creation request contains a state_identifier that\n      already\
    \ exists then the state handler checks whether the requested\n      state item\
    \ is identical to the established state item and counts\n      the state creation\
    \ request as successful if this is the case.  If\n      not then the state creation\
    \ request is unsuccessful (although the\n      probability that this will occur\
    \ is vanishingly small).\n   4. If the state creation request exceeds the state\
    \ memory allocated\n      to the compartment, sufficient items of state created\
    \ by the same\n      compartment are freed until enough memory is available to\n\
    \      accommodate the new state.  When a state item is freed, it is\n      removed\
    \ from the list of states created by the compartment and the\n      memory cost\
    \ of the state item no longer counts towards the total\n      cost for the compartment.\
    \  Note, however, that identical state\n      items may be created by several\
    \ different compartments, so a state\n      item must not be physically deleted\
    \ unless the state handler\n      determines that it is no longer required by\
    \ any compartment.\n   5. The order in which the existing state items are freed\
    \ is\n      determined by the state_retention_priority, which is set when the\n\
    \      state items are created.  The state_retention_priority of 65535 is\n  \
    \    reserved for locally available states; these states must always be\n    \
    \  freed first.  Apart from this special case, states with the lowest\n      state_retention_priority\
    \ are always freed first.  In the event of\n      a tie, then the state item created\
    \ first in the compartment is\n      also the first to be freed.\n   The state_retention_priority\
    \ is always stored on a per-compartment\n   basis as part of the list of state\
    \ items created by each compartment.\n   In particular, the same state item might\
    \ have several priority values\n   if it has been created by several different\
    \ compartments.\n   Note that locally available state items (as described in Section\n\
    \   3.3.3) need not be mapped to any particular compartment.  However, if\n  \
    \ they are created on a per-compartment basis, then they must not\n   interfere\
    \ with the state created at the request of the remote\n   endpoint.  The special\
    \ state_retention_priority of 65535 is reserved\n   for locally available state\
    \ items to ensure that this is the case.\n   The UDVM may also explicitly request\
    \ the state handler to free a\n   specific state item in a compartment.  In this\
    \ case, the state\n   handler deletes the state item from the list of state items\
    \ created\n   by the compartment (as before the state item itself must not be\n\
    \   physically deleted unless the state handler determines that it is not\n  \
    \ longer required by any compartment).\n   The application should indicate to\
    \ the state handler when it wishes\n   to close a particular compartment, so that\
    \ the resources taken by the\n   corresponding state can be reclaimed.\n"
- title: 6.3.  Feedback Data
  contents:
  - "6.3.  Feedback Data\n   The SigComp feedback mechanism allows feedback data to\
    \ be received by\n   a UDVM and forwarded via the state handler to the correct\
    \ compressor.\n   Since this feedback data is retained between SigComp messages,\
    \ it is\n   considered to be part of the overall state and can only be forwarded\n\
    \   if accompanied by a valid compartment identifier.  If this is the\n   case,\
    \ then the state handler forwards the feedback data to the\n   compressor responsible\
    \ for sending messages that pertain to the peer\n   compartment of the specified\
    \ compartment.\n"
- title: 7.  SigComp Message Format
  contents:
  - "7.  SigComp Message Format\n   This chapter describes the format of the SigComp\
    \ message and how the\n   message is used to initialize the UDVM memory.\n   Note\
    \ that the SigComp message is not copied into the UDVM memory as\n   soon as it\
    \ arrives; instead, the UDVM indicates when it requires\n   compressed data using\
    \ a specific instruction.  It then pauses and\n   waits for the information to\
    \ be supplied before executing the next\n   instruction.  This means that the\
    \ UDVM can begin to decompress a\n   SigComp message before the entire message\
    \ has been received.\n   A consequence of the above behavior is that when the\
    \ UDVM is invoked,\n   the size of the UDVM memory depends on whether the transport\
    \ used to\n   provide the SigComp message is stream-based or message-based.  If\
    \ the\n   transport is message-based then sufficient memory must be available\n\
    \   to buffer the entire SigComp message before it is passed to the UDVM.\n  \
    \ So if the message is n bytes long, then the UDVM memory size is set\n   to (decompression_memory_size\
    \ - n), up to a maximum of 65536 bytes.\n   If the transport is stream-based however,\
    \ then a fixed-size input\n   buffer is required to accommodate the stream, independently\
    \ of the\n   size of each SigComp message. So, for simplicity, the UDVM memory\n\
    \   size is set to (decompression_memory_size / 2).\n   As a separate instance\
    \ of the UDVM is invoked on a per-message basis,\n   each SigComp message must\
    \ explicitly indicate its chosen\n   decompression algorithm as well as any additional\
    \ information that is\n   needed to decompress the message (e.g., one or more\
    \ previously\n   received messages, a dictionary of common SIP phrases etc.).\
    \  This\n   information can either be uploaded as part of the SigComp message\
    \ or\n   retrieved from an item of state.\n   A SigComp message takes one of two\
    \ forms depending on whether it\n   accesses a state item at the receiving endpoint.\
    \  The two variants of\n   a SigComp message are given in Figure 3.  (The T-bit\
    \ controls the\n   format of the returned feedback item and is defined in Section\
    \ 7.1.)\n     0   1   2   3   4   5   6   7       0   1   2   3   4   5   6  \
    \ 7\n   +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   1   1   1 | T |  len  |   | 1   1   1   1   1 | T |   0   |\n  \
    \ +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+\n   |\
    \                               |   |                               |\n   :  \
    \  returned feedback item     :   :    returned feedback item     :\n   |    \
    \                           |   |                               |\n   +---+---+---+---+---+---+---+---+\
    \   +---+---+---+---+---+---+---+---+\n   |                               |  \
    \ |           code_len            |\n   :   partial state identifier    :   +---+---+---+---+---+---+---+---+\n\
    \   |                               |   |   code_len    |  destination  |\n  \
    \ +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+\n   |\
    \                               |   |                               |\n   :  \
    \ remaining SigComp message   :   :    uploaded UDVM bytecode     :\n   |    \
    \                           |   |                               |\n   +---+---+---+---+---+---+---+---+\
    \   +---+---+---+---+---+---+---+---+\n                                      \
    \ |                               |\n                                       :\
    \   remaining SigComp message   :\n                                       |  \
    \                             |\n                                       +---+---+---+---+---+---+---+---+\n\
    \                   Figure 3: Format of a SigComp message\n   Decompression failure\
    \ occurs if the SigComp message is too short to\n   contain the expected fields\
    \ (see Section 8.7 for further details).\n   The fields except for the \"remaining\
    \ SigComp message\" are referred to\n   as the \"SigComp header\" (note that this\
    \ may include the uploaded UDVM\n   bytecode).\n"
- title: 7.1.  Returned feedback item
  contents:
  - "7.1.  Returned feedback item\n   For both variants of the SigComp message, the\
    \ T-bit is set to 1\n   whenever the SigComp message contains a returned feedback\
    \ item.  The\n   format of the returned feedback item is illustrated in Figure\
    \ 4.\n     0   1   2   3   4   5   6   7       0   1   2   3   4   5   6   7\n\
    \   +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+\n  \
    \ | 0 |  returned_feedback_field  |   | 1 | returned_feedback_length  |\n   +---+---+---+---+---+---+---+---+\
    \   +---+---+---+---+---+---+---+---+\n                                      \
    \ |                               |\n                                       :\
    \    returned_feedback_field    :\n                                       |  \
    \                             |\n                                       +---+---+---+---+---+---+---+---+\n\
    \                Figure 4: Format of returned feedback item\n   Note that the\
    \ returned feedback length specifies the size of the\n   returned feedback field\
    \ (from 0 to 127 bytes).  So the total size of\n   the returned feedback item\
    \ lies between 1 and 128 bytes.\n   The returned feedback item is not copied to\
    \ the UDVM memory; instead,\n   it is buffered until the UDVM has successfully\
    \ decompressed the\n   SigComp message.  It is then forwarded to the state handler\
    \ with the\n   rest of the feedback data (see Section 9.4.9 for further details).\n"
- title: 7.2.  Accessing Stored State
  contents:
  - "7.2.  Accessing Stored State\n   The len field of the SigComp message determines\
    \ which fields follow\n   the returned feedback item.  If the len field is non-zero,\
    \ then the\n   SigComp message contains a state identifier to access a state item\
    \ at\n   the receiving endpoint.  All state items include a 20-byte state\n  \
    \ identifier as per Section 3.3.3, but it is possible to transmit as\n   few as\
    \ 6 bytes from the identifier if the sender believes that this\n   is sufficient\
    \ to match a unique state item at the receiving endpoint.\n   The len field encodes\
    \ the number of transmitted bytes as follows:\n   Encoding:   Length of partial\
    \ state identifier\n   01          6 bytes\n   10          9 bytes\n   11    \
    \      12 bytes\n   The partial state identifier is passed to the state handler,\
    \ which\n   compares it with the most significant bytes of the state_identifier\n\
    \   in every currently stored state item.  Decompression failure occurs\n   if\
    \ no state item is matched or if more than one state item is\n   matched.\n  \
    \ Decompression failure also occurs if exactly one state item is\n   matched but\
    \ the state item contains a minimum_access_length greater\n   than the length\
    \ of the partial state identifier.  This prevents\n   especially sensitive state\
    \ items from being accessed maliciously by\n   brute force guessing of the state_identifier.\n\
    \   If a state item is successfully accessed then the state_value byte\n   string\
    \ is copied into the UDVM memory beginning at state_address.\n   The first 32\
    \ bytes of UDVM memory are then initialized to special\n   values as illustrated\
    \ in Figure 5.\n                      0             7 8            15\n      \
    \               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                     |    \
    \   UDVM_memory_size        |  0 - 1\n                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     |        cycles_per_bit         |  2 - 3\n             \
    \        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                     |        SigComp_version\
    \        |  4 - 5\n                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \                   |    partial_state_ID_length    |  6 - 7\n               \
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                     |         state_length\
    \          |  8 - 9\n                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     |                               |\n                    \
    \ :           reserved            :  10 - 31\n                     |         \
    \                      |\n                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 5: Initializing Useful Values in UDVM memory\n   The first\
    \ five 2-byte words are initialized to contain some values\n   that might be useful\
    \ to the UDVM bytecode (Useful Values).  Note that\n   these values are for information\
    \ only and can be overwritten when\n   executing the UDVM bytecode without any\
    \ effect on the endpoint.  The\n   MSBs of each 2-byte word are stored preceding\
    \ the LSBs.\n   Addresses 0 to 5 indicate the resources available to the receiving\n\
    \   endpoint.  The UDVM memory size is expressed in bytes modulo 2^16, so\n  \
    \ in particular, it is set to 0 if the UDVM memory size is 65536 bytes.\n   The\
    \ cycles_per_bit is expressed as a 2-byte integer taking the value\n   16, 32,\
    \ 64 or 128.  The SigComp_version is expressed as a 2-byte\n   value as per Section\
    \ 3.3.2.\n   Addresses 6 to 9 are initialized to the length of the partial state\n\
    \   identifier, followed by the state_length from the retrieved state\n   item.\
    \  Both are expressed as 2-byte values.\n   Addresses 10 to 31 are reserved and\
    \ are initialized to 0 for Version\n   0x01 of SigComp.  Future versions of SigComp\
    \ can use these locations\n   for additional Useful Values, so a decompressor\
    \ MUST NOT rely on\n   these values being zero.\n   Any remaining addresses in\
    \ the UDVM memory that have not yet been\n   initialized MUST be set to 0.\n \
    \  The UDVM then begins executing instructions at the memory address\n   contained\
    \ in state_instruction (which is part of the retrieved item\n   of state).  Note\
    \ that the remaining SigComp message is held by the\n   decompressor dispatcher\
    \ until requested by the UDVM.\n   (Note that the Useful Values are only set at\
    \ UDVM startup; there is\n   no special significance to this memory area afterwards.\
    \  This means\n   that the UDVM bytecode is free to use these locations for any\
    \ other\n   purpose a memory location might be used for; it just has to be aware\n\
    \   they are not necessarily initialized to zero.)\n"
- title: 7.3.  Uploading UDVM bytecode
  contents:
  - "7.3.  Uploading UDVM bytecode\n   If the len field is set to 0 then the bytecode\
    \ needed to decompress\n   the SigComp message is supplied as part of the message\
    \ itself.  The\n   12-bit code_len field specifies the size of the uploaded UDVM\n\
    \   bytecode (from 0 to 4095 bytes inclusive); eight most significant\n   bits\
    \ are in the first byte, followed by the four least significant\n   bits in the\
    \ most significant bits in the second byte.  The remaining\n   bits in the second\
    \ byte are interpreted as a 4-bit destination field\n   that specifies the starting\
    \ memory address to which the bytecode is\n   copied.  The destination field is\
    \ encoded as follows:\n                     Encoding:   Destination address:\n\
    \                     0000        reserved\n                     0001        2\
    \  *  64  =  128\n                     0010        3  *  64  =  196\n        \
    \             0011        4  *  64  =  256\n                       :         \
    \       :\n                     1111        16 *  64  =  1024\n   Note that the\
    \ encoding 0000 is reserved for future SigComp versions,\n   and causes a decompression\
    \ failure in Version 0x01.\n   The UDVM memory is initialized as per Figure 5,\
    \ except that addresses\n   6 to 9 inclusive are set to 0 because no state item\
    \ has been\n   accessed.  The UDVM then begins executing instructions at the memory\n\
    \   address specified by the destination field.  As above, the remaining\n   SigComp\
    \ message is held by the decompressor dispatcher until needed\n   by the UDVM.\n"
- title: 8.  Overview of the UDVM
  contents:
  - "8.  Overview of the UDVM\n   Decompression functionality for SigComp is provided\
    \ by a Universal\n   Decompressor Virtual Machine (UDVM).  The UDVM is a virtual\
    \ machine\n   much like the Java Virtual Machine but with a key difference:  it\
    \ is\n   designed solely for the purpose of running decompression algorithms.\n\
    \   The motivation for creating the UDVM is to provide flexibility when\n   choosing\
    \ how to compress a given application message.  Rather than\n   picking one of\
    \ a small number of pre-negotiated algorithms, the\n   compressor implementer\
    \ has the freedom to select an algorithm of\n   their choice.  The compressed\
    \ data is then combined with a set of\n   UDVM instructions that allow the original\
    \ data to be extracted, and\n   the result is outputted as a SigComp message.\
    \  Since the UDVM is\n   optimized specifically for running decompression algorithms,\
    \ the code\n   size of a typical algorithm is small (often sub 100 bytes).\n \
    \  Moreover, the UDVM approach does not add significant extra processing\n   or\
    \ memory requirements compared to running a fixed preprogrammed\n   decompression\
    \ algorithm.\n   Figure 6 gives a detailed view of the interfaces between the\
    \ UDVM and\n   its environment.\n   +----------------+                       \
    \          +----------------+\n   |                |     Request compressed data\
    \     |                |\n   |                |-------------------------------->|\
    \                |\n   |                |<--------------------------------|  \
    \              |\n   |                |     Provide compressed data     |    \
    \            |\n   |                |                                 |      \
    \          |\n   |                |    Output decompressed data     |  Decompressor\
    \  |\n   |                |-------------------------------->|   dispatcher   |\n\
    \   |                |                                 |                |\n  \
    \ |                |     Indicate end of message     |                |\n   |\
    \                |-------------------------------->|                |\n   |  \
    \              |<--------------------------------|                |\n   |    \
    \  UDVM      | Provide compartment identifier  |                |\n   |      \
    \          |                                 +----------------+\n   |        \
    \        |\n   |                |                                 +----------------+\n\
    \   |                |    Request state information    |                |\n  \
    \ |                |-------------------------------->|                |\n   |\
    \                |<--------------------------------|                |\n   |  \
    \              |    Provide state information    |     State      |\n   |    \
    \            |                                 |    handler     |\n   |      \
    \          |   Make state creation request   |                |\n   |        \
    \        |-------------------------------->|                |\n   |          \
    \      |  Forward feedback information   |                |\n   +----------------+\
    \                                 +----------------+\n         Figure 6: Interfaces\
    \ between the UDVM and its environment\n   Note that once the UDVM has been initialized,\
    \ additional compressed\n   data and state information are only provided at the\
    \ request of a\n   specific UDVM instruction.\n   This chapter describes the basic\
    \ features of the UDVM including the\n   UDVM registers and the format of UDVM\
    \ bytecode.\n"
- title: 8.1.  UDVM Registers
  contents:
  - "8.1.  UDVM Registers\n   The UDVM registers are 2-byte words in the UDVM memory\
    \ that have\n   special tasks, for example specifying the location of the stack\
    \ used\n   by the CALL and RETURN instructions.\n   The UDVM registers are illustrated\
    \ in Figure 7.\n                      0             7 8            15\n      \
    \               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                     |    \
    \    byte_copy_left         |  64 - 65\n                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     |        byte_copy_right        |  66 - 67\n           \
    \          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                     |        input_bit_order\
    \        |  68 - 69\n                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     |        stack_location         |  70 - 71\n           \
    \          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             Figure 7: Memory addresses\
    \ of the UDVM registers\n   The MSBs of each register are always stored before\
    \ the LSBs.  So, for\n   example, the MSBs of byte_copy_left are stored at Address\
    \ 64 whilst\n   the LSBs are stored at Address 65.\n   The use of each UDVM register\
    \ is defined in the following sections.\n   (Note that the UDVM registers start\
    \ at Address 64, that is 32 bytes\n   after the area reserved for Useful Values.\
    \  The intention is that the\n   gap, i.e., the area between Address 32 and Address\
    \ 63, will often be\n   used as scratch-pad memory that is guaranteed to be zero\
    \ at UDVM\n   startup and is efficiently addressable in operand types reference\
    \ ($)\n   and multitype (%).)\n"
- title: 8.2.  Requesting Additional Compressed Data
  contents:
  - "8.2.  Requesting Additional Compressed Data\n   The decompressor dispatcher stores\
    \ the compressed data from the\n   SigComp message before it is requested by the\
    \ UDVM via one of the\n   INPUT instructions.  When the UDVM bytecode is first\
    \ executed, the\n   dispatcher contains the remaining SigComp message after the\
    \ header\n   has been used to initialize the UDVM as per Chapter 7.\n   Note that\
    \ the INPUT-BITS and INPUT-HUFFMAN instructions retrieve a\n   stream of individual\
    \ compressed bits from the dispatcher.  To provide\n   bitwise compatibility with\
    \ various well-known compression algorithms,\n   the input_bit_order register\
    \ can modify the order in which individual\n   bits are passed within a byte.\n\
    \   The input_bit_order register contains the following three flags:\n       \
    \               0             7 8            15\n                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     |         reserved        |F|H|P|  68 - 69\n           \
    \          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The P-bit controls the order\
    \ in which bits are passed from the\n   dispatcher to the INPUT instructions.\
    \  If set to 0, it indicates that\n   the bits within an individual byte are passed\
    \ to the INPUT\n   instructions in MSB to LSB order.  If it is set to 1, the bits\
    \ are\n   passed in LSB to MSB order.\n   Note that the input_bit_order register\
    \ cannot change the order in\n   which the bytes themselves are passed to the\
    \ INPUT instructions\n   (bytes are always passed in the same order as they occur\
    \ in the\n   SigComp message).\n   The following diagram illustrates the order\
    \ in which bits are passed\n   to the INPUT instructions for both cases:\n   \
    \ MSB         LSB MSB         LSB     MSB         LSB MSB         LSB\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |0 1 2 3 4 5 6 7|8 9 ...        |  \
    \ |7 6 5 4 3 2 1 0|        ... 9 8|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \        Byte 0           Byte 1              Byte 0          Byte 1\n       \
    \          P = 0                               P = 1\n   Note that after one or\
    \ more INPUT instructions the dispatcher may\n   hold a fraction of a byte (what\
    \ used to be the LSBs if P = 0, or, the\n   MSBs, if P = 1).  If an INPUT instruction\
    \ is encountered and the P-\n   bit has changed since the last INPUT instruction,\
    \ any fraction of a\n   byte still held by the dispatcher MUST be discarded (even\
    \ if the\n   INPUT instruction requests zero bits).  The first bit passed to the\n\
    \   INPUT instruction is taken from the subsequent byte.\n   When an INPUT instruction\
    \ requests n bits of compressed data, it\n   interprets the received bits as an\
    \ integer between 0 and 2^n - 1.\n   The F-bit and the H-bit specify whether the\
    \ bits in these integers\n   are considered to arrive in MSB to LSB order (bit\
    \ set to 0) or in LSB\n   to MSB order (bit set to 1).\n   If the F-bit is set\
    \ to 0, the INPUT-BITS instruction interprets the\n   received bits as arriving\
    \ MSBs first, and if it is set to 1, it\n   interprets the bits as arriving LSBs\
    \ first.  The H-bit performs the\n   same function for the INPUT-HUFFMAN instruction.\
    \  Note that it is\n   possible to set these two bits to different values in order\
    \ to use\n   different bit orders for the two instructions (certain algorithms\n\
    \   actually require this, e.g., DEFLATE [RFC-1951]).  (Note that there\n   are\
    \ no special considerations for changing the F- or H-bit between\n   INPUT instructions,\
    \ unlike the discard rule for the P-bit described\n   above.)\n   Decompression\
    \ failure occurs if an INPUT-BITS or an INPUT-HUFFMAN\n   instruction is encountered\
    \ and the input_bit_order register does not\n   lie between 0 and 7 inclusive.\n"
- title: 8.3.  UDVM Stack
  contents:
  - "8.3.  UDVM Stack\n   Certain UDVM instructions make use of a stack of 2-byte\
    \ words stored\n   at the memory address specified by the 2-byte word stack_location.\n\
    \   The stack contains the following words:\n               Name:            \
    \     Starting memory address:\n               stack_fill            stack_location\n\
    \               stack[0]              stack_location + 2\n               stack[1]\
    \              stack_location + 4\n               stack[2]              stack_location\
    \ + 6\n                  :                       :\n   The notation stack_location\
    \ is an abbreviation for the contents of\n   the stack_location register, i.e.,\
    \ the 2-byte word at locations 70\n   and 71.  The notation stack_fill is an abbreviation\
    \ for the 2-byte\n   word at stack_location and stack_location+1.  Similarly,\
    \ the notation\n   stack[n] is an abbreviation for the 2-byte word at\n   stack_location+2*n+2\
    \ and stack_location+2*n+3.  (As always, the\n   arithmetic is modulo 2^16.)\n\
    \   The stack is used by the CALL, RETURN, PUSH and POP instructions.\n   \"Pushing\"\
    \ a value on the stack is an abbreviation for copying the\n   value to stack[stack_fill]\
    \ and then increasing stack_fill by 1.  CALL\n   and PUSH push values on the stack.\n\
    \   \"Popping\" a value from the stack is an abbreviation for decreasing\n   stack_fill\
    \ by 1, and then using the value stored in\n   stack[stack_fill].  Decompression\
    \ failure occurs if stack_fill is\n   zero at the commencement of a popping operation.\
    \  POP and RETURN pop\n   values from the stack.\n   For both of these abstract\
    \ operations, the UDVM first takes note of\n   the current value of stack_location\
    \ and uses this value for both\n   sub-operations (accessing the stack and manipulating\
    \ stack_fill),\n   i.e., overwriting stack_location in the course of the operation\
    \ is\n   inconsequential for the operation.\n"
- title: 8.4.  Byte copying
  contents:
  - "8.4.  Byte copying\n   A number of UDVM instructions require a string of bytes\
    \ to be copied\n   to and from areas of the UDVM memory.  This section defines\
    \ how the\n   byte copying operation should be performed.\n   The string of bytes\
    \ is copied in ascending order of memory address,\n   respecting the bounds set\
    \ by byte_copy_left and byte_copy_right.\n   More precisely, if a byte is copied\
    \ from/to Address m then the next\n   byte is copied from/to Address n where n\
    \ is calculated as follows:\n   Set k := m + 1 (modulo 2^16)\n   If k = byte_copy_right\
    \ then set n := byte_copy_left, else set n := k\n   Decompression failure occurs\
    \ if a byte is copied from/to an address\n   beyond the UDVM memory.\n   Note\
    \ that the string of bytes is copied one byte at a time.  In\n   particular, some\
    \ of the later bytes to be copied may themselves have\n   been written into the\
    \ UDVM memory by the byte copying operation\n   currently being performed.\n \
    \  Equally, it is possible for a byte copying operation to overwrite the\n   instruction\
    \ that invoked the byte copy.  If this occurs, then the\n   byte copying operation\
    \ MUST be completed as if the original\n   instruction were still in place in\
    \ the UDVM memory (this also applies\n   if byte_copy_left or byte_copy_right\
    \ are overwritten).\n   Byte copying is used by the following UDVM instructions:\n\
    \   SHA-1, COPY, COPY-LITERAL, COPY-OFFSET, MEMSET, INPUT-BYTES, STATE-\n   ACCESS,\
    \ OUTPUT, END-MESSAGE\n"
- title: 8.5.  Instruction operands and UDVM bytecode
  contents:
  - "8.5.  Instruction operands and UDVM bytecode\n   Each of the UDVM instructions\
    \ in a piece of UDVM bytecode is\n   represented by a single byte, followed by\
    \ 0 or more bytes containing\n   the operands required by the instruction.\n \
    \  During instruction execution, conceptually the UDVM first fetches the\n   first\
    \ byte of the instruction, determines the number and types of\n   operands required\
    \ for this instruction, and then decodes all the\n   operands in sequence before\
    \ starting to act on the instruction.\n   (Note that the UDVM instructions have\
    \ been designed in such a way\n   that this sequence remains conceptual in those\
    \ cases where it would\n   result in an unreasonable burden on the implementation.)\n\
    \   To reduce the size of typical UDVM bytecode, each operand for a UDVM\n   instruction\
    \ is compressed using variable-length encoding.  The aim is\n   to store more\
    \ common operand values using fewer bytes than rarely\n   occurring values.\n\
    \   Four different types of operand are available: the literal, the\n   reference,\
    \ the multitype and the address.  Chapter 9 gives a complete\n   list of UDVM\
    \ instructions and the operand types that follow each\n   instruction.\n   The\
    \ UDVM bytecode for each operand type is illustrated in Figure 8 to\n   Figure\
    \ 10, together with the integer values represented by the\n   bytecode.\n   Note\
    \ that the MSBs in the bytecode are illustrated as preceding the\n   LSBs.  Also,\
    \ any string of bits marked with k consecutive \"n\"s is to\n   be interpreted\
    \ as an integer N from 0 to 2^k - 1 inclusive (with the\n   MSBs of n illustrated\
    \ as preceding the LSBs).\n   The decoded integer value of the bytecode can be\
    \ interpreted in two\n   ways.  In some cases it is taken to be the actual value\
    \ of the\n   operand.  In other cases it is taken to be a memory address at which\n\
    \   the 2-byte operand value can be found (MSBs found at the specified\n   address,\
    \ LSBs found at the following address).  The latter cases are\n   denoted by memory[X]\
    \ where X is the address and memory[X] is the 2-\n   byte value starting at Address\
    \ X.\n   The simplest operand type is the literal (#), which encodes a\n   constant\
    \ integer from 0 to 65535 inclusive.  A literal operand may\n   require between\
    \ 1 and 3 bytes depending on its value.\n   Bytecode:                       Operand\
    \ value:      Range:\n   0nnnnnnn                        N                   0\
    \ - 127\n   10nnnnnn nnnnnnnn               N                   0 - 16383\n  \
    \ 11000000 nnnnnnnn nnnnnnnn      N                   0 - 65535\n            \
    \   Figure 8: Bytecode for a literal (#) operand\n   The second operand type is\
    \ the reference ($), which is always used to\n   access a 2-byte value located\
    \ elsewhere in the UDVM memory.  The\n   bytecode for a reference operand is decoded\
    \ to be a constant integer\n   from 0 to 65535 inclusive, which is interpreted\
    \ as the memory address\n   containing the actual value of the operand.\n   Bytecode:\
    \                       Operand value:      Range:\n   0nnnnnnn              \
    \          memory[2 * N]       0 - 65535\n   10nnnnnn nnnnnnnn               memory[2\
    \ * N]       0 - 65535\n   11000000 nnnnnnnn nnnnnnnn      memory[N]         \
    \  0 - 65535\n              Figure 9: Bytecode for a reference ($) operand\n \
    \  Note that the range of a reference operand is always 0 - 65535\n   independently\
    \ of how many bits are used to encode the reference,\n   because the operand always\
    \ references a 2-byte value in the memory.\n   The third kind of operand is the\
    \ multitype (%), which can be used to\n   encode both actual values and memory\
    \ addresses.  The multitype\n   operand also offers efficient encoding for small\
    \ integer values (both\n   positive and negative) and for powers of 2.\n   Bytecode:\
    \                       Operand value:      Range:\n   00nnnnnn              \
    \          N                   0 - 63\n   01nnnnnn                        memory[2\
    \ * N]       0 - 65535\n   1000011n                        2 ^ (N + 6)       \
    \ 64 , 128\n   10001nnn                        2 ^ (N + 8)    256 , ... , 32768\n\
    \   111nnnnn                        N + 65504       65504 - 65535\n   1001nnnn\
    \ nnnnnnnn               N + 61440       61440 - 65535\n   101nnnnn nnnnnnnn \
    \              N                   0 - 8191\n   110nnnnn nnnnnnnn            \
    \   memory[N]           0 - 65535\n   10000000 nnnnnnnn nnnnnnnn      N      \
    \             0 - 65535\n   10000001 nnnnnnnn nnnnnnnn      memory[N]        \
    \   0 - 65535\n              Figure 10: Bytecode for a multitype (%) operand\n\
    \   The fourth operand type is the address (@).  This operand is decoded\n   as\
    \ a multitype operand followed by a further step: the memory address\n   of the\
    \ UDVM instruction containing the address operand is added to\n   obtain the correct\
    \ operand value.  So if the operand value from\n   Figure 10 is D then the actual\
    \ operand value of an address is\n   calculated as follows:\n   operand_value\
    \ = (memory_address_of_instruction + D) modulo 2^16\n   Address operands are always\
    \ used in instructions that control program\n   flow, because they ensure that\
    \ the UDVM bytecode is position-\n   independent code (i.e., it will run independently\
    \ of where it is\n   placed in the UDVM memory).\n"
- title: 8.6.  UDVM Cycles
  contents:
  - "8.6.  UDVM Cycles\n   Once the UDVM has been invoked it executes the instructions\
    \ contained\n   in its memory consecutively unless otherwise indicated (for example\n\
    \   when the UDVM encounters a JUMP instruction).  If the next\n   instruction\
    \ to be executed lies outside the available memory then\n   decompression failure\
    \ occurs (see Section 8.7).\n   To ensure that a SigComp message cannot consume\
    \ excessive processing\n   resources, SigComp limits the number of \"UDVM cycles\"\
    \ allocated to\n   each message.  The number of available UDVM cycles is initialized\
    \ to\n   1000 plus the number of bits in the SigComp header (as described in\n\
    \   Section 7); this sum is then multiplied by cycles_per_bit.  Each time\n  \
    \ an instruction is executed the number of available UDVM cycles is\n   decreased\
    \ by the amount specified in Chapter 9.  Additionally, if the\n   UDVM successfully\
    \ requests n bits of compressed data using one of the\n   INPUT instructions then\
    \ the number of available UDVM cycles is\n   increased by n * cycles_per_bit once\
    \ the instruction has been\n   executed.\n   This means that the maximum number\
    \ of UDVM cycles available for\n   processing an n-byte SigComp message is given\
    \ by the formula:\n           maximum_UDVM_cycles = (8 * n + 1000) * cycles_per_bit\n\
    \   The reason that this total is not allocated to the UDVM when it is\n   invoked\
    \ is that the UDVM can begin to decompress a message that has\n   only been partially\
    \ received.  So the total message size may not be\n   known when the UDVM is initialized.\n\
    \   Note that the number of UDVM cycles MUST NOT be increased if a\n   request\
    \ for additional compressed data fails.\n   The UDVM stops executing instructions\
    \ when it encounters an END-\n   MESSAGE instruction or if decompression failure\
    \ occurs (see Section\n   8.7 for further details).\n"
- title: 8.7.  Decompression Failure
  contents:
  - "8.7.  Decompression Failure\n   If a compressed message given to the UDVM is\
    \ corrupted (either\n   accidentally or maliciously), then the UDVM may terminate\
    \ with a\n   decompression failure.\n   Reasons for decompression failure include\
    \ the following:\n   1. A SigComp message contains an invalid header as per Chapter\
    \ 7.\n   2. A SigComp message is larger than the decompression_memory_size.\n\
    \   3. An instruction costs more than the number of remaining UDVM\n      cycles.\n\
    \   4. The UDVM attempts to read from or write to a memory address beyond\n  \
    \    its memory size.\n   5. An unknown instruction is encountered.\n   6. An\
    \ unknown operand is encountered.\n   7. An instruction is encountered that cannot\
    \ be processed\n      successfully by the UDVM (for example a RETURN instruction\
    \ when no\n      CALL instruction has previously been encountered).\n   8. A request\
    \ to access some state information fails.\n   9. A manual decompression failure\
    \ is triggered using the\n      DECOMPRESSION-FAILURE instruction.\n   If a decompression\
    \ failure occurs when decompressing a message then\n   the UDVM informs the dispatcher\
    \ and takes no further action.  It is\n   the responsibility of the dispatcher\
    \ to decide how to cope with the\n   decompression failure.  In general a dispatcher\
    \ SHOULD discard the\n   compressed message (or the compressed stream if the transport\
    \ is\n   stream-based) and any decompressed data that has been outputted but\n\
    \   not yet passed to the application.\n"
- title: 9.  UDVM Instruction Set
  contents:
  - "9.  UDVM Instruction Set\n   The UDVM currently understands 36 instructions,\
    \ chosen to support the\n   widest possible range of compression algorithms with\
    \ the minimum\n   possible overhead.\n   Figure 11 lists the different instructions\
    \ and the bytecode values\n   used to encode the instructions.  The cost of each\
    \ instruction in\n   UDVM cycles is also given:\n   Instruction:       Bytecode\
    \ value:   Cost in UDVM cycles:\n   DECOMPRESSION-FAILURE     0          1\n \
    \  AND                       1          1\n   OR                        2    \
    \      1\n   NOT                       3          1\n   LSHIFT               \
    \     4          1\n   RSHIFT                    5          1\n   ADD        \
    \               6          1\n   SUBTRACT                  7          1\n   MULTIPLY\
    \                  8          1\n   DIVIDE                    9          1\n \
    \  REMAINDER                 10         1\n   SORT-ASCENDING            11   \
    \      1 + k * (ceiling(log2(k)) + n)\n   SORT-DESCENDING           12       \
    \  1 + k * (ceiling(log2(k)) + n)\n   SHA-1                     13         1 +\
    \ length\n   LOAD                      14         1\n   MULTILOAD            \
    \     15         1 + n\n   PUSH                      16         1\n   POP    \
    \                   17         1\n   COPY                      18         1 +\
    \ length\n   COPY-LITERAL              19         1 + length\n   COPY-OFFSET \
    \              20         1 + length\n   MEMSET                    21        \
    \ 1 + length\n   JUMP                      22         1\n   COMPARE          \
    \         23         1\n   CALL                      24         1\n   RETURN \
    \                   25         1\n   SWITCH                    26         1 +\
    \ n\n   CRC                       27         1 + length\n   INPUT-BYTES      \
    \         28         1 + length\n   INPUT-BITS                29         1\n \
    \  INPUT-HUFFMAN             30         1 + n\n   STATE-ACCESS              31\
    \         1 + state_length\n   STATE-CREATE              32         1 + state_length\n\
    \   STATE-FREE                33         1\n   OUTPUT                    34  \
    \       1 + output_length\n   END-MESSAGE               35         1 + state_length\n\
    \      Figure 11: UDVM instructions and corresponding bytecode values\n   Each\
    \ UDVM instruction costs a minimum of 1 UDVM cycle.  Certain\n   instructions\
    \ may cost additional cycles depending on the values of\n   the instruction operands.\
    \  Named variables in the cost expressions\n   refer to the values of the instruction\
    \ operands with these names.\n   Note that for the SORT instructions, the formula\
    \ ceiling(log2(k))\n   calculates the smallest value i such that k <= 2^i.\n \
    \  The UDVM instruction set offers a mix of low-level and high-level\n   instructions.\
    \  The high-level instructions can all be emulated using\n   combinations of low-level\
    \ instructions, but given a choice it is\n   generally preferable to use a single\
    \ instruction rather than a large\n   number of general-purpose instructions.\
    \  The resulting bytecode will\n   be more compact (leading to a higher overall\
    \ compression ratio) and\n   decompression will typically be faster because the\
    \ implementation of\n   the high-level instructions can be more easily optimized.\n\
    \   All instructions are encoded as a single byte to indicate the\n   instruction\
    \ type, followed by 0 or more bytes containing the operands\n   required by the\
    \ instruction.  The instruction specifies which of the\n   four operand types\
    \ of Section 8.5 is used in each case. For example\n   the ADD instruction is\
    \ followed by two operands:\n   ADD ($operand_1, %operand_2)\n   When converted\
    \ into bytecode the number of bytes required by the ADD\n   instruction depends\
    \ on the value of each operand, and whether the\n   multitype operand contains\
    \ the operand value itself or a memory\n   address where the actual value of the\
    \ operand can be found.\n   Each instruction is explained in more detail below.\n\
    \   Whenever the description of an instruction uses the expression \"and\n   then\"\
    , the intended semantics is that the effect explained before\n   \"and then\"\
    \ is completed before work on the effect explained after the\n   \"and then\"\
    \ is commenced.\n"
- title: 9.1.  Mathematical Instructions
  contents:
  - "9.1.  Mathematical Instructions\n   The following instructions provide a number\
    \ of mathematical\n   operations including bit manipulation, arithmetic and sorting.\n"
- title: 9.1.1.  Bit Manipulation
  contents:
  - "9.1.1.  Bit Manipulation\n   The AND, OR, NOT, LSHIFT and RSHIFT instructions\
    \ provide simple bit\n   manipulation on 2-byte words.\n   AND ($operand_1, %operand_2)\n\
    \   OR ($operand_1, %operand_2)\n   NOT ($operand_1)\n   LSHIFT ($operand_1, %operand_2)\n\
    \   RSHIFT ($operand_1, %operand_2)\n   After the operation is complete, the value\
    \ of the first operand is\n   overwritten with the result.  (Note that since this\
    \ operand is a\n   reference, it is the 2-byte word at the memory address specified\
    \ by\n   the operand that is overwritten.)\n   The precise definitions of LSHIFT\
    \ and RSHIFT are given below.  Note\n   that m and n are the 2-byte values encoded\
    \ by the operands, and that\n   floor(x) calculates the largest integer not greater\
    \ than x:\n   LSHIFT (m, n) := m * 2^n (modulo 2^16)\n   RSHIFT (m, n) := floor(m\
    \ / 2^n)\n"
- title: 9.1.2.  Arithmetic
  contents:
  - "9.1.2.  Arithmetic\n   The ADD, SUBTRACT, MULTIPLY, DIVIDE and REMAINDER instructions\n\
    \   perform arithmetic on 2-byte words.\n   ADD ($operand_1, %operand_2)\n   SUBTRACT\
    \ ($operand_1, %operand_2)\n   MULTIPLY ($operand_1, %operand_2)\n   DIVIDE ($operand_1,\
    \ %operand_2)\n   REMAINDER ($operand_1, %operand_2)\n   After the operation is\
    \ complete, the value of the first operand is\n   overwritten with the result.\n\
    \   The precise definition of each instruction is given below:\n   ADD (m, n)\
    \       := m + n (modulo 2^16)\n   SUBTRACT (m, n)  := m - n (modulo 2^16)\n \
    \  MULTIPLY (m, n)  := m * n (modulo 2^16)\n   DIVIDE (m, n)    := floor(m / n)\n\
    \   REMAINDER (m, n) := m - n * floor(m / n)\n   Decompression failure occurs\
    \ if a DIVIDE or REMAINDER instruction\n   encounters an operand_2 that is zero.\n"
- title: 9.1.3.  Sorting
  contents:
  - "9.1.3.  Sorting\n   The SORT-ASCENDING and SORT-DESCENDING instructions sort\
    \ lists of 2-\n   byte words.\n   SORT-ASCENDING (%start, %n, %k)\n   SORT-DESCENDING\
    \ (%start, %n, %k)\n   The start operand specifies the starting memory address\
    \ of the block\n   of data to be sorted.\n   The block of data itself is divided\
    \ into n lists each containing k\n   2-byte words.  The SORT-ASCENDING instruction\
    \ applies a certain\n   permutation to the lists, such that the first list is\
    \ sorted into\n   ascending order (treating each 2-byte word as an unsigned integer).\n\
    \   The same permutation is applied to all n lists, so lists other than\n   the\
    \ first will not necessarily be sorted into order.\n   In the case that two words\
    \ have the same value, the original ordering\n   of the list is preserved.\n \
    \  For example, the first list might contain a set of integers to be\n   sorted\
    \ whilst the second list might be used to keep track of where\n   the integers\
    \ appear in the sorted list:\n            Before sorting              After sorting\n\
    \         List 1        List 2        List 1        List 2\n            8    \
    \         1             1             2\n            1             2         \
    \    1             3\n            1             3             3             4\n\
    \            3             4             8             1\n   The SORT-DESCENDING\
    \ instruction behaves as above, except that the\n   first list is sorted into\
    \ descending order.\n"
- title: 9.1.4.  SHA-1
  contents:
  - "9.1.4.  SHA-1\n   The SHA-1 instruction calculates a 20-byte SHA-1 hash [RFC-3174]\
    \ over\n   the specified area of UDVM memory.\n   SHA-1 (%position, %length, %destination)\n\
    \   The position and length operands specify the starting memory address\n   and\
    \ the length of the byte string over which the SHA-1 hash is\n   calculated. \
    \ Byte copying rules are enforced as per Section 8.4.\n   The destination operand\
    \ gives the starting address to which the\n   resulting 20-byte hash will be copied.\
    \  Byte copying rules are\n   enforced as above.\n"
- title: 9.2.  Memory Management Instructions
  contents:
  - "9.2.  Memory Management Instructions\n   The following instructions are used\
    \ to set up the UDVM memory, and to\n   copy byte strings from one memory location\
    \ to another.\n"
- title: 9.2.1.  LOAD
  contents:
  - "9.2.1.  LOAD\n   The LOAD instruction sets a 2-byte word to a certain specified\
    \ value.\n   The format of a LOAD instruction is as follows:\n   LOAD (%address,\
    \ %value)\n   The first operand specifies the starting address of a 2-byte word,\n\
    \   whilst the second operand specifies the value to be loaded into this\n   word.\
    \  As usual, MSBs are stored before LSBs in the UDVM memory.\n"
- title: 9.2.2.  MULTILOAD
  contents:
  - "9.2.2.  MULTILOAD\n   The MULTILOAD instruction sets a contiguous block of 2-byte\
    \ words in\n   the UDVM memory to specified values.\n   MULTILOAD (%address, #n,\
    \ %value_0, ..., %value_n-1)\n   The first operand specifies the starting address\
    \ of the contiguous\n   2-byte words, whilst the operands value_0 through to value_n-1\n\
    \   specify the values to load into these words (in the same order as\n   they\
    \ appear in the instruction).\n   Decompression failure occurs if the set of 2-byte\
    \ words set by the\n   instruction would overlap the memory locations held by\
    \ the\n   instruction (including its operands) itself, i.e., if the instruction\n\
    \   would be self-modifying.  (This restriction makes it simpler to\n   implement\
    \ MULTILOAD step-by-step instead of having to decode all\n   operands before being\
    \ able to copy data, as is implied by the\n   conceptual model of instruction\
    \ execution.)\n"
- title: 9.2.3.  PUSH and POP
  contents:
  - "9.2.3.  PUSH and POP\n   The PUSH and POP instructions read from and write to\
    \ the UDVM stack\n   (as defined in Section 8.3).\n   PUSH (%value)\n   POP (%address)\n\
    \   The PUSH instruction pushes the value specified by its operand on the\n  \
    \ stack.\n   The POP instruction pops a value from the stack and then copies the\n\
    \   value to the specified memory address.  (Note that the expression\n   \"and\
    \ then\" implies that the copying of the value is inconsequential\n   for the\
    \ stack operation itself, which happens beforehand.)\n   See Section 8.3 for possible\
    \ error conditions.\n"
- title: 9.2.4.  COPY
  contents:
  - "9.2.4.  COPY\n   The COPY instruction is used to copy a string of bytes from\
    \ one part\n   of the UDVM memory to another.\n   COPY (%position, %length, %destination)\n\
    \   The position operand specifies the memory address of the first byte\n   in\
    \ the string to be copied, and the length operand specifies the\n   number of\
    \ bytes to be copied.\n   The destination operand gives the address to which the\
    \ first byte in\n   the string will be copied.\n   Byte copying is performed as\
    \ per the rules of Section 8.4.\n"
- title: 9.2.5.  COPY-LITERAL
  contents:
  - "9.2.5.  COPY-LITERAL\n   A modified version of the COPY instruction is given\
    \ below:\n   COPY-LITERAL (%position, %length, $destination)\n   The COPY-LITERAL\
    \ instruction behaves as a COPY instruction except\n   that after copying is completed,\
    \ the value of the destination operand\n   is replaced by the address to which\
    \ the next byte of data would be\n   copied.  More precisely it is replaced by\
    \ the value n, derived as per\n   Section 8.4 with m set to the destination address\
    \ of the last byte to\n   be copied, if any (i.e., if the value of the length\
    \ operand is zero,\n   the value of the destination operand is not changed).\n"
- title: 9.2.6.  COPY-OFFSET
  contents:
  - "9.2.6.  COPY-OFFSET\n   A further version of the COPY-LITERAL instruction is\
    \ given below:\n   COPY-OFFSET (%offset, %length, $destination)\n   The COPY-OFFSET\
    \ instruction behaves as a COPY-LITERAL instruction\n   except that an offset\
    \ operand is given instead of a position operand.\n   To derive the value of the\
    \ position operand, starting at the memory\n   address specified by destination,\
    \ the UDVM counts backwards a total\n   of offset memory addresses.\n   If the\
    \ memory address specified in byte_copy_left is reached, the\n   next memory address\
    \ is taken to be (byte_copy_right - 1) modulo 2^16.\n   The COPY-OFFSET instruction\
    \ then behaves as a COPY-LITERAL\n   instruction, taking the value of the position\
    \ operand to be the last\n   memory address reached in the above step.\n"
- title: 9.2.7.  MEMSET
  contents:
  - "9.2.7.  MEMSET\n   The MEMSET instruction initializes an area of UDVM memory\
    \ to a\n   specified sequence of values. The format of a MEMSET instruction is\n\
    \   as follows:\n   MEMSET (%address, %length, %start_value, %offset)\n   The\
    \ sequence of values used by the MEMSET instruction is specified by\n   the following\
    \ formula:\n   Seq[n] := (start_value + n * offset) modulo 256\n   The values\
    \ Seq[0] to Seq[length - 1] inclusive are each interpreted\n   as a single byte,\
    \ and then concatenated to form a byte string where\n   the first byte has value\
    \ Seq[0], the second byte has value Seq[1] and\n   so on up to the last byte which\
    \ has value Seq[length - 1].\n   The string is then byte copied into the UDVM\
    \ memory beginning at the\n   memory address specified as an operand to the MEMSET\
    \ instruction,\n   obeying the rules of Section 8.4.  (Note that the byte string\
    \ may\n   overwrite the MEMSET instruction or its operands; as explained in\n\
    \   Section 8.5, the MEMSET instruction must be executed as if the\n   original\
    \ operands were still in place in the UDVM memory.)\n"
- title: 9.3.  Program Flow Instructions
  contents:
  - "9.3.  Program Flow Instructions\n   The following instructions alter the flow\
    \ of UDVM code.  Each\n   instruction jumps to one of a number of memory addresses\
    \ based on a\n   certain specified criterion.\n   Note that certain I/O instructions\
    \ (see Section 9.4) can also alter\n   program flow.\n"
- title: 9.3.1.  JUMP
  contents:
  - "9.3.1.  JUMP\n   The JUMP instruction moves program execution to the specified\
    \ memory\n   address.\n   JUMP (@address)\n   Decompression failure occurs if\
    \ the value of the address operand lies\n   beyond the overall UDVM memory size.\n"
- title: 9.3.2.  COMPARE
  contents:
  - "9.3.2.  COMPARE\n   The COMPARE instruction compares two operands and then jumps\
    \ to one\n   of three specified memory addresses depending on the result.\n  \
    \ COMPARE (%value_1, %value_2, @address_1, @address_2, @address_3)\n   If value_1\
    \ < value_2 then the UDVM continues instruction execution at\n   the memory address\
    \ specified by address 1. If value_1 = value_2 then\n   it jumps to the address\
    \ specified by address_2. If value_1 > value_2\n   then it jumps to the address\
    \ specified by address_3.\n"
- title: 9.3.3.  CALL and RETURN
  contents:
  - "9.3.3.  CALL and RETURN\n   The CALL and RETURN instructions provide support\
    \ for compression\n   algorithms with a nested structure.\n   CALL (@address)\n\
    \   RETURN\n   Both instructions use the UDVM stack of Section 8.3.  When the\
    \ UDVM\n   reaches a CALL instruction, it finds the memory address of the\n  \
    \ instruction immediately following the CALL instruction and pushes\n   this 2-byte\
    \ value on the stack, ready for later retrieval.  It then\n   continues instruction\
    \ execution at the memory address specified by\n   the address operand.\n   When\
    \ the UDVM reaches a RETURN instruction it pops a value from the\n   stack and\
    \ then continues instruction execution at the memory address\n   just popped.\n\
    \   See Section 8.3 for error conditions.\n"
- title: 9.3.4.  SWITCH
  contents:
  - "9.3.4.  SWITCH\n   The SWITCH instruction performs a conditional jump based on\
    \ the value\n   of one of its operands.\n   SWITCH (#n, %j, @address_0, @address_1,\
    \ ... , @address_n-1)\n   When a SWITCH instruction is encountered the UDVM reads\
    \ the value of\n   j. It then continues instruction execution at the address specified\n\
    \   by address j.\n   Decompression failure occurs if j specifies a value of n\
    \ or more, or\n   if the address lies beyond the overall UDVM memory size.\n"
- title: 9.3.5.  CRC
  contents:
  - "9.3.5.  CRC\n   The CRC instruction verifies a string of bytes using a 2-byte\
    \ CRC.\n   CRC (%value, %position, %length, @address)\n   The actual CRC calculation\
    \ is performed using the generator\n   polynomial x^16 + x^12 + x^5 + 1, which\
    \ coincides with the 2-byte\n   Frame Check Sequence (FCS) of PPP [RFC-1662].\n\
    \   The position and length operands define the string of bytes over\n   which\
    \ the CRC is evaluated.  Byte copying rules are enforced as per\n   Section 8.4.\n\
    \   The CRC value is computed exactly as defined for the 16-bit FCS\n   calculation\
    \ in [RFC-1662].\n   The value operand contains the expected integer value of\
    \ the 2-byte\n   CRC.  If the calculated CRC matches the expected value then the\
    \ UDVM\n   continues instruction execution at the following instruction.\n   Otherwise\
    \ the UDVM jumps to the memory address specified by the\n   address operand.\n"
- title: 9.4.  I/O instructions
  contents:
  - "9.4.  I/O instructions\n   The following instructions allow the UDVM to interface\
    \ with its\n   environment.  Note that in the overall SigComp architecture all\
    \ of\n   these interfaces pass to the decompressor dispatcher or to the state\n\
    \   handler.\n"
- title: 9.4.1.  DECOMPRESSION-FAILURE
  contents:
  - "9.4.1.  DECOMPRESSION-FAILURE\n   The DECOMPRESSION-FAILURE instruction triggers\
    \ a manual decompression\n   failure.  This is useful if the UDVM bytecode discovers\
    \ that it\n   cannot successfully decompress the message (e.g., by using the CRC\n\
    \   instruction).\n   This instruction has no operands.\n"
- title: 9.4.2.  INPUT-BYTES
  contents:
  - "9.4.2.  INPUT-BYTES\n   The INPUT-BYTES instruction requests a certain number\
    \ of bytes of\n   compressed data from the decompressor dispatcher.\n   INPUT-BYTES\
    \ (%length, %destination, @address)\n   The length operand indicates the requested\
    \ number of bytes of\n   compressed data, and the destination operand specifies\
    \ the starting\n   memory address to which they should be copied.  Byte copying\
    \ is\n   performed as per the rules of Section 8.4.\n   If the instruction requests\
    \ data that lies beyond the end of the\n   SigComp message, no data is returned.\
    \  Instead the UDVM moves program\n   execution to the address specified by the\
    \ address operand.\n   If the INPUT-BYTES is encountered after an INPUT-BITS or\
    \ an INPUT-\n   HUFFMAN instruction has been used, and the dispatcher currently\
    \ holds\n   a fraction of a byte, then the fraction MUST be discarded before any\n\
    \   data is passed to the UDVM.  The first byte to be passed is the byte\n   immediately\
    \ following the discarded data.\n"
- title: 9.4.3.  INPUT-BITS
  contents:
  - "9.4.3.  INPUT-BITS\n   The INPUT-BITS instruction requests a certain number of\
    \ bits of\n   compressed data from the decompressor dispatcher.\n   INPUT-BITS\
    \ (%length, %destination, @address)\n   The length operand indicates the requested\
    \ number of bits.\n   Decompression failure occurs if this operand does not lie\
    \ between 0\n   and 16 inclusive.\n   The destination operand specifies the memory\
    \ address to which the\n   compressed data should be copied.  Note that the requested\
    \ bits are\n   interpreted as a 2-byte integer ranging from 0 to 2^length - 1,\
    \ as\n   explained in Section 8.2.\n   If the instruction requests data that lies\
    \ beyond the end of the\n   SigComp message, no data is returned.  Instead the\
    \ UDVM moves program\n   execution to the address specified by the address operand.\n"
- title: 9.4.4.  INPUT-HUFFMAN
  contents:
  - "9.4.4.  INPUT-HUFFMAN\n   The INPUT-HUFFMAN instruction requests a variable number\
    \ of bits of\n   compressed data from the decompressor dispatcher.  The instruction\n\
    \   initially requests a small number of bits and compares the result\n   against\
    \ a certain criterion; if the criterion is not met, then\n   additional bits are\
    \ requested until the criterion is achieved.\n   The INPUT-HUFFMAN instruction\
    \ is followed by three mandatory operands\n   plus n additional sets of operands.\
    \  Every additional set contains\n   four operands as shown below:\n   INPUT-HUFFMAN\
    \ (%destination, @address, #n, %bits_1, %lower_bound_1,\n   %upper_bound_1, %uncompressed_1,\
    \ ... , %bits_n, %lower_bound_n,\n   %upper_bound_n, %uncompressed_n)\n   Note\
    \ that if n = 0 then the INPUT-HUFFMAN instruction is ignored and\n   program\
    \ execution resumes at the following instruction.\n   Decompression failure occurs\
    \ if (bits_1 + ... + bits_n) > 16.\n   In all other cases, the behavior of the\
    \ INPUT-HUFFMAN instruction is\n   defined below:\n   1. Set j := 1 and set H\
    \ := 0.\n   2. Request bits_j compressed bits.  Interpret the returned bits as\
    \ an\n      integer k from 0 to 2^bits_j - 1, as explained in Section 8.2.\n \
    \  3. Set H := H * 2^bits_j + k.\n   4. If data is requested that lies beyond\
    \ the end of the SigComp\n      message, terminate the INPUT-HUFFMAN instruction\
    \ and move program\n      execution to the memory address specified by the address\
    \ operand.\n   5. If (H < lower_bound_j) or (H > upper_bound_j) then set j :=\
    \ j + 1.\n      Then go back to Step 2, unless j > n in which case decompression\n\
    \      failure occurs.\n   6. Copy (H + uncompressed_j - lower_bound_j) modulo\
    \ 2^16 to the\n      memory address specified by the destination operand.\n"
- title: 9.4.5.  STATE-ACCESS
  contents:
  - "9.4.5.  STATE-ACCESS\n   The STATE-ACCESS instruction retrieves some previously\
    \ stored state\n   information.\n   STATE-ACCESS (%partial_identifier_start, %partial_identifier_length,\n\
    \   %state_begin, %state_length, %state_address, %state_instruction)\n   The partial_identifier_start\
    \ and partial_identifier_length operands\n   specify the location of the partial\
    \ state identifier used to retrieve\n   the state information.  This identifier\
    \ has the same function as the\n   partial state identifier transmitted in the\
    \ SigComp message as per\n   Section 7.2.\n   Decompression failure occurs if\
    \ partial_identifier_length does not\n   lie between 6 and 20 inclusive.  Decompression\
    \ failure also occurs if\n   no state item matching the partial state identifier\
    \ can be found, if\n   more than one state item matches the partial identifier,\
    \ or if\n   partial_identifier_length is less than the minimum_access_length of\n\
    \   the matched state item. Otherwise, a state item is returned from the\n   state\
    \ handler.\n   If any of the operands state_address, state_instruction or\n  \
    \ state_length is set to 0 then its value is taken from the returned\n   item\
    \ of state instead.\n   Note that when calculating the number of UDVM cycles the\
    \ STATE-ACCESS\n   instruction costs (1 + state_length) cycles.  The value of\n\
    \   state_length MUST be taken from the returned item of state in the\n   case\
    \ that the state_length operand is set to 0.\n   The state_begin and state_length\
    \ operands define the starting byte\n   and number of bytes to copy from the state_value\
    \ contained in the\n   returned item of state.  Decompression failure occurs if\
    \ bytes are\n   copied from beyond the end of the state_value.  Note that\n  \
    \ decompression failure will always occur if the state_length operand\n   is set\
    \ to 0 but the state_begin operand is non-zero.\n   The state_address operand\
    \ contains a UDVM memory address.  The\n   requested portion of the state_value\
    \ is byte copied to this memory\n   address using the rules of Section 8.4.\n\
    \   Program execution then resumes at the memory address specified by\n   state_instruction,\
    \ unless this address is 0 in which case program\n   execution resumes at the\
    \ next instruction following the STATE-ACCESS\n   instruction.  Note that the\
    \ latter case only occurs if both the\n   state_instruction operand and the state_instruction\
    \ value from the\n   requested state are set to 0.\n"
- title: 9.4.6.  STATE-CREATE
  contents:
  - "9.4.6.  STATE-CREATE\n   The STATE-CREATE instruction requests the creation of\
    \ a state item at\n   the receiving endpoint.\n   STATE-CREATE (%state_length,\
    \ %state_address, %state_instruction,\n   %minimum_access_length, %state_retention_priority)\n\
    \   Note that the new state item cannot be created until a valid\n   compartment\
    \ identifier has been returned by the application.\n   Consequently, when a STATE-CREATE\
    \ instruction is encountered the UDVM\n   simply buffers the five supplied operands\
    \ until the END-MESSAGE\n   instruction is reached.  The steps taken at this point\
    \ are described\n   in Section 9.4.9.\n   Decompression failure MUST occur if\
    \ more than four state creation\n   requests are made before the END-MESSAGE instruction\
    \ is encountered.\n   Decompression failure also occurs if the minimum_access_length\
    \ does\n   not lie between 6 and 20 inclusive, or if the\n   state_retention_priority\
    \ is 65535.\n"
- title: 9.4.7.  STATE-FREE
  contents:
  - "9.4.7.  STATE-FREE\n   The STATE-FREE instruction informs the receiving endpoint\
    \ that the\n   sender no longer wishes to use a particular state item.\n   STATE-FREE\
    \ (%partial_identifier_start, %partial_identifier_length)\n   Note that the STATE-FREE\
    \ instruction does not automatically delete a\n   state item, but instead reclaims\
    \ the memory taken by the state item\n   within a certain compartment, which is\
    \ generally not known before the\n   END-MESSAGE instruction is reached.  So just\
    \ as for the STATE-CREATE\n   instruction, when a STATE-FREE instruction is encountered\
    \ the UDVM\n   simply buffers the two supplied operands until the END-MESSAGE\n\
    \   instruction is reached.  The steps taken at this point are described\n   in\
    \ Section 9.4.9.\n   Decompression failure MUST occur if more than four state\
    \ free\n   requests are made before the END-MESSAGE instruction is encountered.\n\
    \   Decompression failure also occurs if partial_identifier_length does\n   not\
    \ lie between 6 and 20 inclusive.\n"
- title: 9.4.8.  OUTPUT
  contents:
  - "9.4.8.  OUTPUT\n   The OUTPUT instruction provides successfully decompressed\
    \ data to the\n   dispatcher.\n   OUTPUT (%output_start, %output_length)\n   The\
    \ operands define the starting memory address and length of the\n   byte string\
    \ to be provided to the dispatcher.  Note that the OUTPUT\n   instruction can\
    \ be used to output a partially decompressed message;\n   each time the instruction\
    \ is encountered it provides a new byte\n   string that the dispatcher appends\
    \ to the end of any bytes previously\n   passed to the dispatcher via the OUTPUT\
    \ instruction.\n   The string of data is byte copied from the UDVM memory obeying\
    \ the\n   rules of Section 8.4.\n   Decompression failure occurs if the cumulative\
    \ number of bytes\n   provided to the dispatcher exceeds 65536 bytes.\n   Since\
    \ there is technically a difference between outputting a 0-byte\n   decompressed\
    \ message, and not outputting a decompressed message at\n   all, the OUTPUT instruction\
    \ needs to distinguish between the two\n   cases.  Thus, if the UDVM terminates\
    \ before encountering an OUTPUT\n   instruction it is considered not to have outputted\
    \ a decompressed\n   message.  If it encounters one or more OUTPUT instructions,\
    \ each of\n   which provides 0 bytes of data to the dispatcher, then it is\n \
    \  considered to have outputted a 0-byte decompressed message.\n"
- title: 9.4.9.  END-MESSAGE
  contents:
  - "9.4.9.  END-MESSAGE\n   The END-MESSAGE instruction successfully terminates the\
    \ UDVM and\n   forwards the state creation and state free requests to the state\n\
    \   handler together with any supplied feedback data.\n   END-MESSAGE (%requested_feedback_location,\n\
    \   %returned_parameters_location, %state_length, %state_address,\n   %state_instruction,\
    \ %minimum_access_length,\n   %state_retention_priority)\n   When the END-MESSAGE\
    \ instruction is encountered, the decompressor\n   dispatcher indicates to the\
    \ application that a complete message has\n   been decompressed.  The application\
    \ may return a compartment\n   identifier, which the UDVM forwards to the state\
    \ handler together\n   with the state creation and state free requests and any\
    \ supplied\n   feedback data.\n   The actual decompressed message is outputted\
    \ separately using the\n   OUTPUT instruction; this conserves memory at the UDVM\
    \ because there\n   is no need to buffer an entire decompressed message before\
    \ it can be\n   passed to the dispatcher.\n   The END-MESSAGE instruction may\
    \ pass up to four state creation\n   requests and up to four state free requests\
    \ to the state handler.\n   The requests are passed to the state handler in the\
    \ same order as\n   they are made; in particular it is possible for the state\
    \ creation\n   requests and the state free requests to be interleaved.\n   The\
    \ state creation requests are made by the STATE-CREATE instruction.\n   Note however\
    \ that the END-MESSAGE can make one state creation request\n   itself using the\
    \ supplied operands. If the specified\n   minimum_access_length does not lie between\
    \ 6 and 20 inclusive, or if\n   the state_retention_priority is 65535 then the\
    \ END-MESSAGE\n   instruction fails to make a state creation request of its own\n\
    \   (however decompression failure does not occur and the state creation\n   requests\
    \ made by the STATE-CREATE instruction are still valid).\n   Note that there is\
    \ a maximum limit of four state creation requests\n   per instance of the UDVM.\
    \  Therefore, decompression failure occurs if\n   the END-MESSAGE instruction\
    \ makes a state creation request and four\n   instances of the STATE-CREATE instruction\
    \ have already been\n   encountered.\n   When creating a state item it is necessary\
    \ to give the state_length,\n   state address, state_instruction and minimum_access_length;\
    \ these are\n   supplied as operands in the STATE-CREATE instruction (or the END-\n\
    \   MESSAGE instruction).  A complete item of state also requires a\n   state_value\
    \ and a state_identifier, which are derived as follows:\n   The UDVM byte copies\
    \ a string of state_length bytes from the UDVM\n   memory beginning at state_address\
    \ (obeying the rules of Section 8.4).\n   This is the state_value.\n   The UDVM\
    \ then calculates a 20-byte SHA-1 hash [RFC-3174] over the\n   byte string formed\
    \ by concatenating the state_length, state_address,\n   state_instruction, minimum_access_length\
    \ and state_value (in the\n   order given).  This is the state_identifier.\n \
    \  The state_retention_priority is not part of the state item itself,\n   but\
    \ instead determines the order in which state will be deleted when\n   the compartment\
    \ exceeds its allocated state memory.  The\n   state_retention_priority is supplied\
    \ as an operand in the STATE-\n   CREATE or END-MESSAGE instruction and is passed\
    \ to the state handler\n   as part of each state creation request.\n   The state\
    \ free requests are made by the STATE-FREE instruction. Each\n   STATE-FREE instruction\
    \ supplies the values partial_identifier_start\n   and partial_identifier_length;\
    \ upon reaching the END-MESSAGE\n   instruction these values are used to byte\
    \ copy a partial state\n   identifier from the UDVM memory.  If no state item\
    \ matching the\n   partial state identifier can be found or if more than one state\
    \ item\n   in the compartment matches the partial state identifier, then the\n\
    \   state free request is ignored (this does not cause decompression\n   failure\
    \ to occur).  Otherwise, the state handler frees the matched\n   state item as\
    \ specified in Section 6.2.\n   As well as forwarding the state creation and state\
    \ free requests, the\n   END-MESSAGE instruction may also pass feedback data to\
    \ the state\n   handler.  Feedback data is used to inform the receiving endpoint\n\
    \   about the capabilities of the sending endpoint, which can help to\n   improve\
    \ the overall compression ratio and to reduce the working\n   memory requirements\
    \ of the endpoints.\n   Two types of feedback data are available: requested feedback\
    \ and\n   returned feedback.  The format of the requested feedback data is\n \
    \  given in Figure 12.  As outlined in Section 3.2, the requested\n   feedback\
    \ data can be used to influence the contents of the returned\n   feedback data\
    \ in the reverse direction.\n   The returned feedback data is itself subdivided\
    \ into a returned\n   feedback item and a list of returned SigComp parameters.\
    \  The\n   returned feedback item is of sufficient importance to warrant its own\n\
    \   field in the SigComp header as described in Section 7.1.  The\n   returned\
    \ SigComp parameters are illustrated in Figure 13.\n   Note that the formats of\
    \ Figure 12 and Figure 13 are only for local\n   presentation of the feedback\
    \ data on the interface between the UDVM\n   and state handler.  The formats do\
    \ not mandate any bits on the wire;\n   the compressor can transmit the data in\
    \ any form provided that it is\n   loaded into the UDVM memory at the correct\
    \ addresses.\n   Moreover, the responsibility for ensuring that feedback data\
    \ arrives\n   successfully over an unreliable transport lies with the sender.\
    \  The\n   receiving endpoint always uses the last received value for each field\n\
    \   in the feedback data, even if the values are out of date due to\n   packet\
    \ loss or misordering.\n   If the requested_feedback_location operand is set to\
    \ 0, then no\n   feedback request is made; otherwise, it points to the starting\
    \ memory\n   address of the requested feedback data as shown in Figure 12.\n \
    \       0   1   2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n\
    \      |     reserved      | Q | S | I |  requested_feedback_location\n      +---+---+---+---+---+---+---+---+\n\
    \      |                               |\n      :    requested feedback item \
    \   :  if Q = 1\n      |                               |\n      +---+---+---+---+---+---+---+---+\n\
    \               Figure 12: Format of requested feedback data\n   The reserved\
    \ bits may be used in future versions of SigComp, and are\n   set to 0 in Version\
    \ 0x01.  Non-zero values should be ignored by the\n   receiving endpoint.\n  \
    \ The Q-bit indicates whether a requested feedback item is present or\n   not.\
    \  The compressor can set the requested feedback item to an\n   arbitrary value,\
    \ which will then be transmitted unmodified in the\n   reverse direction as a\
    \ returned feedback item.  See Chapter 5 for\n   further details of how the requested\
    \ feedback item is returned.\n   The format of the requested feedback item is\
    \ identical to the format\n   of the returned feedback item illustrated in Figure\
    \ 4.\n   The compressor sets the S-bit to 1 if it does not wish (or no longer\n\
    \   wishes) to save state information at the receiving endpoint and also\n   does\
    \ not wish to access state information that it has previously\n   saved.  Consequently,\
    \ if the S-bit is set to 1 then the receiving\n   endpoint can reclaim the state\
    \ memory allocated to the remote\n   compressor and set the state_memory_size\
    \ for the compartment to 0.\n   The compressor may change its mind and switch\
    \ the S-bit back to 0 in\n   a later message.  However, the receiving endpoint\
    \ is under no\n   obligation to use the original state_memory_size for the compartment;\n\
    \   it may choose to allocate less memory to the compartment or possibly\n   none\
    \ at all.\n   Similarly the compressor sets the I-bit to 1 if it does not wish\
    \ (or\n   no longer wishes) to access any of the locally available state items\n\
    \   offered by the receiving endpoint.  This can help to conserve\n   bandwidth\
    \ because the list of locally available state items no longer\n   needs to be\
    \ returned in the reverse direction.  It may also conserve\n   memory at the receiving\
    \ endpoint, as the state handler can delete any\n   locally available state items\
    \ that it determines are no longer\n   required by any remote endpoint.  Note\
    \ that the compressor can set\n   the I-bit back to 0 in a later message, but\
    \ it cannot access any\n   locally available state items that were previously\
    \ offered by the\n   receiving endpoint unless they are subsequently re-announced.\n\
    \   If the returned_parameters_location operand is set to 0, then no\n   SigComp\
    \ parameters are returned; otherwise, it points to the starting\n   memory address\
    \ of the returned parameters as shown in Figure 13.\n        0   1   2   3   4\
    \   5   6   7\n      +---+---+---+---+---+---+---+---+\n      |  cpb  |    dms\
    \    |    sms    |  returned_parameters_location\n      +---+---+---+---+---+---+---+---+\n\
    \      |        SigComp_version        |\n      +---+---+---+---+---+---+---+---+\n\
    \      | length_of_partial_state_ID_1  |\n      +---+---+---+---+---+---+---+---+\n\
    \      |                               |\n      :  partial_state_identifier_1\
    \   :\n      |                               |\n      +---+---+---+---+---+---+---+---+\n\
    \              :               :\n      +---+---+---+---+---+---+---+---+\n  \
    \    | length_of_partial_state_ID_n  |\n      +---+---+---+---+---+---+---+---+\n\
    \      |                               |\n      :  partial_state_identifier_n\
    \   :\n      |                               |\n      +---+---+---+---+---+---+---+---+\n\
    \             Figure 13: Format of returned SigComp parameters\n   The first byte\
    \ encodes the SigComp parameters cycles_per_bit,\n   decompression_memory_size\
    \ and state_memory_size as per Section 3.3.1.\n   The byte can be set to 0 if\
    \ the three parameters are not included in\n   the feedback data.  (This may be\
    \ useful to save bits in the\n   compressed message if the remote endpoint is\
    \ already satisfied all\n   necessary information has reached the endpoint receiving\
    \ the\n   message.)\n   The second byte encodes the SigComp_version as per Section\
    \ 3.3.2.\n   Similar to the first byte, the second byte can be set to 0 if the\n\
    \   parameter is not included in the feedback data.\n   The remaining bytes encode\
    \ a list of partial state identifiers for\n   the locally available state items\
    \ offered by the sending endpoint.\n   Each state item is encoded as a 1-byte\
    \ length field, followed by a\n   partial state identifier containing as many\
    \ bytes as indicated in the\n   length field.  The sender can choose to send as\
    \ few as 6 bytes if it\n   believes that this is sufficient for the receiver to\
    \ determine which\n   state item is being offered.\n   The list of state identifiers\
    \ is terminated by a byte in the position\n   where the next length field would\
    \ be expected that is set to a value\n   below 6 or above 20.  Note that upgraded\
    \ SigComp versions may append\n   additional items of data after the final length\
    \ field.\n"
- title: 10. Security Considerations
  contents:
  - '10. Security Considerations

    '
- title: 10.1.  Security Goals
  contents:
  - "10.1.  Security Goals\n   The overall security goal of the SigComp architecture\
    \ is to not\n   create risks that are in addition to those already present in\
    \ the\n   application protocols.  There is no intention for SigComp to enhance\n\
    \   the security of the application, as it always can be circumvented by\n   not\
    \ using compression.  More specifically, the high-level security\n   goals can\
    \ be described as:\n   1. Do not worsen security of existing application protocol\n\
    \   2. Do not create any new security issues\n   3. Do not hinder deployment of\
    \ application security.\n"
- title: 10.2.  Security Risks and Mitigation
  contents:
  - "10.2.  Security Risks and Mitigation\n   This section identifies the potential\
    \ security risks associated with\n   SigComp, and explains how each risk is minimized\
    \ by the scheme.\n"
- title: 10.2.1.  Confidentiality Risks
  contents:
  - "10.2.1.  Confidentiality Risks\n   - Attacking SigComp by snooping into state\
    \ of other users:\n   State is accessed by supplying a state identifier, which\
    \ is a\n   cryptographic hash of the state being referenced.  This implies that\n\
    \   the referencing message already needs knowledge about the state.  To\n   enforce\
    \ this, a state item cannot be accessed without supplying a\n   minimum of 48\
    \ bits from the hash.  This also minimizes the\n   probability of an accidental\
    \ state collision.  A compressor can,\n   using the minimum_access_length operand\
    \ of the STATE-CREATE and END-\n   MESSAGE instructions, increase the number of\
    \ bits that need to be\n   supplied to access the state, increasing the protection\
    \ against\n   attacks.\n   Generally, ways to obtain knowledge about the state\
    \ identifier (e.g.,\n   passive attacks) will also easily provide knowledge about\
    \ the\n   referenced state, so no new vulnerability results.\n   An endpoint needs\
    \ to handle state identifiers with the same care it\n   would handle the state\
    \ itself.\n"
- title: 10.2.2.  Integrity Risks
  contents:
  - "10.2.2.  Integrity Risks\n   The SigComp approach assumes that there is appropriate\
    \ integrity\n   protection below and/or above the SigComp layer.  The state creation\n\
    \   mechanism provides some additional potential to compromise the\n   integrity\
    \ of the messages; however, this would most likely be\n   detectable at the application\
    \ layer.\n   - Attacking SigComp by faking state or making unauthorized changes\
    \ to\n     state:\n   State cannot be destroyed by a malicious sender unless it\
    \ can send\n   messages that the application identifies as belonging to the same\n\
    \   compartment the state was created under; this adds additional\n   security\
    \ risks only when the application allows the installation of\n   SigComp state\
    \ from a message where it would not have installed state\n   itself.\n   Faking\
    \ or changing state is only possible if the hash allows\n   intentional collision.\n"
- title: 10.2.3.  Availability Risks (Avoiding DoS Vulnerabilities)
  contents:
  - "10.2.3.  Availability Risks (Avoiding DoS Vulnerabilities)\n   - Use of SigComp\
    \ as a tool in a DoS attack to another target:\n   SigComp cannot easily be used\
    \ as an amplifier in a reflection attack,\n   as it only generates one decompressed\
    \ message per incoming compressed\n   message.  This message is then handed to\
    \ the application; the utility\n   as a reflection amplifier is therefore limited\
    \ by the utility of the\n   application for this purpose.\n   However, it must\
    \ be noted that SigComp can be used to generate larger\n   messages as input to\
    \ the application than have to be sent from the\n   malicious sender; this therefore\
    \ can send smaller messages (at a\n   lower bandwidth) than are delivered to the\
    \ application.  Depending on\n   the reflection characteristics of the application,\
    \ this can be\n   considered a mild form of amplification.  The application MUST\
    \ limit\n   the number of packets reflected to a potential target - even if\n\
    \   SigComp is used to generate a large amount of information from a\n   small\
    \ incoming attack packet.\n   - Attacking SigComp as the DoS target by filling\
    \ it with state:\n   Excessive state can only be installed by a malicious sender\
    \ (or a set\n   of malicious senders) with the consent of the application.  The\n\
    \   system consisting of SigComp and application is thus approximately as\n  \
    \ vulnerable as the application itself, unless it allows the\n   installation\
    \ of SigComp state from a message where it would not have\n   installed application\
    \ state itself.\n   If this is desirable to increase the compression ratio, the\
    \ effect\n   can be mitigated by making use of feedback at the application level\n\
    \   that indicates whether the state requested was actually installed -\n   this\
    \ allows a system under attack to gracefully degrade by no longer\n   installing\
    \ compressor state that is not matched by application state.\n   Obviously, if\
    \ a stream-based transport is used, the streams\n   themselves constitute state\
    \ that has to be handled in the same way\n   that the application itself would\
    \ handle a stream-based transport; if\n   an application is not equipped for stream-based\
    \ transport, it should\n   not allow SigComp connections on a stream-based transport.\
    \  For the\n   alternative SigComp usage described as \"continuous mode\" in Section\n\
    \   4.2.1, an attacker could create any number of active UDVMs unless\n   there\
    \ is some DoS protection at a lower level (e.g., by using TLS in\n   appropriate\
    \ configurations).\n   - Attacking the UDVM by faking state or making unauthorized\
    \ changes\n     to state:\n   This is covered in Section 10.2.2.\n   - Attacking\
    \ the UDVM by sending it looping code:\n   The application sets an upper limit\
    \ to the number of \"UDVM cycles\"\n   that can be used per compressed message\
    \ and per input bit in the\n   compressed message.  The damage inflicted by sending\
    \ packets with\n   looping code is therefore limited, although this may still\
    \ be\n   substantial if a large number of UDVM cycles are offered by the UDVM.\n\
    \   However, this would be true for any decompressor that can receive\n   packets\
    \ over an unsecured transport.\n"
- title: 11. IANA Considerations
  contents:
  - "11. IANA Considerations\n   SigComp requires a 1-byte name space, the SigComp_version,\
    \ which has\n   been created by the IANA.  Upgraded versions of SigComp must be\n\
    \   backwards-compatible with Version 0x01, described in this document.\n   Adding\
    \ additional UDVM instructions and assigning values to the\n   reserved UDVM memory\
    \ addresses are two possible upgrades for which\n   this is the case.\n   Following\
    \ the policies outlined in [RFC-2434], the IANA policy for\n   assigning a new\
    \ value for the SigComp_version shall require a\n   Standards Action.  Values\
    \ are thus assigned only for Standards Track\n   RFCs approved by the IESG.\n"
- title: 12. Acknowledgements
  contents:
  - "12. Acknowledgements\n   Thanks to\n      Abigail Surtees\n      Mark A West\n\
    \      Lawrence Conroy\n      Christian Schmidt\n      Max Riegel\n      Lars-Erik\
    \ Jonsson\n      Stefan Forsgren\n      Krister Svanbro\n      Miguel Garcia\n\
    \      Christopher Clanton\n      Khiem Le\n      Ka Cheong Leung\n      Robert\
    \ Sugar\n   for valuable input and review.\n"
- title: 13. References
  contents:
  - '13. References

    '
- title: 13.1. Normative References
  contents:
  - "13.1. Normative References\n   [RFC-1662]  Simpson, W., \"PPP in HDLC-like Framing\"\
    , STD 51, RFC\n               1662, July 1994.\n   [RFC-2119]  Bradner, S., \"\
    Key words for use in RFCs to Indicate\n               Requirement Levels\", BCP\
    \ 14, RFC 2119, March 1997.\n   [RFC-3174]  Eastlake, 3rd, D. and P. Jones, \"\
    US Secure Hash Algorithm\n               1 (SHA1)\", RFC 3174, September 2001.\n"
- title: 13.2. Informative References
  contents:
  - "13.2. Informative References\n   [RFC-1951]  Deutsch, P., \"DEFLATE Compressed\
    \ Data Format\n               Specification version 1.3\", RFC 1951, May 1996.\n\
    \   [RFC-2026]  Bradner, S., \"The Internet Standards Process - Revision\n   \
    \            3\", BCP 9, RFC 2026, October 1996.\n   [RFC-2279]  Yergeau, F.,\
    \ \"UTF-8, a transformation format of ISO\n               10646\", RFC 2279, January\
    \ 1998.\n   [RFC-2326]  Schulzrinne, H., Rao, A. and R. Lanphier, \"Real Time\n\
    \               Streaming Protocol (RTSP)\", RFC 2326, April 1998.\n   [RFC-2434]\
    \  Alvestrand, H. and T. Narten, \"Guidelines for Writing an\n               IANA\
    \ Considerations Section in RFCs\", BCP 26, RFC 2434,\n               October\
    \ 1998.\n   [RFC-2960]  Stewart, R., Xie, Q., Morneault, K., Sharp, C.,\n    \
    \           Schwartzbauer, H., Taylor, T., Rytina, I., Kalla, M.,\n          \
    \     Zhang, L. and V. Paxson, \"Stream Control Transmission\n               Protocol\"\
    , RFC 2960, October 2000.\n   [RFC-3261]  Rosenberg, J., Schulzrinne, H., Camarillo,\
    \ G., Johnston,\n               A., Peterson, J., Sparks, R., Handley, M. and\
    \ E.\n               Schooler, \"SIP: Session Initiation Protocol\", RFC 3261,\n\
    \               June 2002.\n   [RFC-3321]  Hannu, H., Christoffersson, J., Forsgren,\
    \ S., Leung,\n               K.-C., Liu, Z. and R. Price, \"Signaling Compression\n\
    \               (SigComp) - Extended Operations\", RFC 3321, January\n       \
    \        2003.\n"
- title: 14. Authors' Addresses
  contents:
  - "14. Authors' Addresses\n   Richard Price\n   Roke Manor Research Ltd\n   Romsey,\
    \ Hants, SO51 0ZN\n   United Kingdom\n   Phone: +44 1794 833681\n   EMail: richard.price@roke.co.uk\n\
    \   Carsten Bormann\n   Universitaet Bremen TZI\n   Postfach 330440\n   D-28334\
    \ Bremen, Germany\n   Phone: +49 421 218 7024\n   EMail: cabo@tzi.org\n   Jan\
    \ Christoffersson\n   Box 920\n   Ericsson AB\n   SE-971 28 Lulea, Sweden\n  \
    \ Phone: +46 920 20 28 40\n   EMail: jan.christoffersson@epl.ericsson.se\n   Hans\
    \ Hannu\n   Box 920\n   Ericsson AB\n   SE-971 28 Lulea, Sweden\n   Phone: +46\
    \ 920 20 21 84\n   EMail: hans.hannu@epl.ericsson.se\n   Zhigang Liu\n   Nokia\
    \ Research Center\n   6000 Connection Drive\n   Irving, TX 75039\n   Phone: +1\
    \ 972 894-5935\n   EMail: zhigang.c.liu@nokia.com\n   Jonathan Rosenberg\n   dynamicsoft\n\
    \   72 Eagle Rock Avenue\n   First Floor\n   East Hanover, NJ 07936\n   EMail:\
    \ jdrosen@dynamicsoft.com\n"
- title: 15.  Full Copyright Statement
  contents:
  - "15.  Full Copyright Statement\n   Copyright (C) The Internet Society (2003).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
