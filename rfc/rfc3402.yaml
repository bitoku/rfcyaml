- title: __initial_text__
  contents:
  - "               Dynamic Delegation Discovery System (DDDS)\n                 \
    \       Part Two: The Algorithm\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2002).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the Dynamic Delegation Discovery System\n\
    \   (DDDS) algorithm for applying dynamically retrieved string\n   transformation\
    \ rules to an application-unique string.  Well-formed\n   transformation rules\
    \ will reflect the delegation of management of\n   information associated with\
    \ the string.  This document is also part\n   of a series that is completely specified\
    \ in \"Dynamic Delegation\n   Discovery System (DDDS) Part One: The Comprehensive\
    \ DDDS\" (RFC 3401).\n   It is very important to note that it is impossible to\
    \ read and\n   understand any document in this series without reading the others.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  2\n   2.  Terminology  . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  3\n   3.  The Algorithm  . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  4\n   3.1 Components of a Rule . . . . . . . . . . . . . . . . . .\
    \ . . .  6\n   3.2 Substitution Expression Syntax . . . . . . . . . . . . . .\
    \ . .  6\n   3.3 The Complete Algorithm . . . . . . . . . . . . . . . . . . .\
    \ .  8\n   4.  Specifying An Application  . . . . . . . . . . . . . . . . . .\
    \  9\n   5.  Specifying A Database  . . . . . . . . . . . . . . . . . . . . 11\n\
    \   6.  Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n  \
    \ 6.1 An Automobile Parts Identification System  . . . . . . . . . . 12\n   6.2\
    \ A Document Identification Service  . . . . . . . . . . . . . . 14\n   7.  Security\
    \ Considerations  . . . . . . . . . . . . . . . . . . . 15\n   8.  IANA Considerations\
    \  . . . . . . . . . . . . . . . . . . . . . 15\n       References . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . 15\n       Author's Address . . . .\
    \ . . . . . . . . . . . . . . . . . . . 16\n       Full Copyright Statement .\
    \ . . . . . . . . . . . . . . . . . . 17\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   The Dynamic Delegation Discovery System (DDDS) is used to\
    \ implement\n   lazy binding of strings to data, in order to support dynamically\n\
    \   configured delegation systems.  The DDDS functions by mapping some\n   unique\
    \ string to data stored within a DDDS Database by iteratively\n   applying string\
    \ transformation rules until a terminal condition is\n   reached.\n   This document\
    \ describes the general DDDS algorithm, not any\n   particular application or\
    \ usage scenario.  The entire series of\n   documents is specified in \"Dynamic\
    \ Delegation Discovery System (DDDS)\n   Part One: The Comprehensive DDDS\" (RFC\
    \ 3401) [1].  It is very\n   important to note that it is impossible to read and\
    \ understand a\n   single document in that series without reading the related\
    \ documents.\n   The DDDS's history is an evolution from work done by the Uniform\n\
    \   Resource Name Working Group.  When Uniform Resource Names (URNs) [6]\n   were\
    \ originally formulated there was the desire to locate an\n   authoritative server\
    \ for a URN that (by design) contained no\n   information about network locations.\
    \  A system was formulated that\n   could use a database of rules that could be\
    \ applied to a URN to find\n   out information about specific chunks of syntax.\
    \  This system was\n   originally called the Resolver Discovery Service (RDS)\
    \ [7] and only\n   applied to URNs.\n   Over time other systems began to apply\
    \ this same algorithm and\n   infrastructure to other, non-URN related, systems\
    \ (see Section 6 for\n   examples of other ways of using the DDDS).  This caused\
    \ some of the\n   underlying assumptions to change and need clarification.  These\n\
    \   documents are an update of those original URN specifications in order\n  \
    \ to allow new applications and rule databases to be developed in a\n   standardized\
    \ manner.\n   This document obsoletes RFC 2168 [11] and RFC 2915 [9] as well as\n\
    \   updates RFC 2276 [7].\n"
- title: 2. Terminology
  contents:
  - "2. Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119.\n   Application Unique String\n      A string that is the initial input\
    \ to a DDDS application.  The\n      lexical structure of this string must imply\
    \ a unique delegation\n      path, which is analyzed and traced by the repeated\
    \ selection and\n      application of Rewrite Rules.\n   Rewrite Rule\n      A\
    \ rule that is applied to an Application Unique String to produce\n      either\
    \ a new key to select a new rewrite rule from the rule\n      database, or a final\
    \ result string that is returned to the calling\n      application.  Also simply\
    \ known as a Rule.\n   First Well Known Rule\n      This is a rewrite rule that\
    \ is defined by the application and not\n      actually in the Rule Database.\
    \  It is used to produce the first\n      valid key.\n   Terminal Rule\n     \
    \ A Rewrite Rule that, when used, yields a string that is the final\n      result\
    \ of the DDDS process, rather than another database key.\n   Application\n   \
    \   A set of protocols and specifications that specify actual values\n      for\
    \ the various generalized parts of the DDDS algorithm.  An\n      Application\
    \ must define the syntax and semantics of the\n      Application Unique String,\
    \ the First Well Known Rule, and one or\n      more Databases that are valid for\
    \ the Application.\n   Rule Database\n      Any store of Rules such that a unique\
    \ key can identify a set of\n      Rules that specify the delegation step used\
    \ when that particular\n      Key is used.\n   Services\n      A common rule database\
    \ may be used to associate different services\n      with a given Application\
    \ Unique String; e.g., different protocol\n      functions, different operational\
    \ characteristics, geographic\n      segregation, backwards compatibility, etc.\
    \  Possible service\n      differences might be message receiving services for\
    \ email/fax/\n      voicemail, load balancing over web servers, selection of a\
    \ nearby\n      mirror server, cost vs performance trade-offs, etc.  These\n \
    \     Services are included as part of a Rule to allow the Application\n     \
    \ to make branching decisions based on the applicability of one\n      branch\
    \ or the other from a Service standpoint.\n   Flags\n      Most Applications will\
    \ require a way for a Rule to signal to the\n      Application that some Rules\
    \ provide particular outcomes that\n      others do not; e.g., different output\
    \ formats, extensibility\n      mechanisms, terminal rule signaling, etc.  Most\
    \ Databases will\n      define a Flags field that an Application can use to encode\
    \ various\n      values that express these signals.\n"
- title: 3. The Algorithm
  contents:
  - "3. The Algorithm\n   The DDDS algorithm is based on the concept of Rewrite Rules.\
    \  These\n   rules are collected into a DDDS Rule Database, and accessed by given\n\
    \   unique keys.  A given Rule, when applied to an Application Unique\n   String,\
    \ transforms that String into new Key that can be used to\n   retrieve a new Rule\
    \ from the Rule Database.  This new rule is then\n   reapplied to the original\
    \ Application Unique String and the cycle\n   repeats itself until a terminating\
    \ condition is reached.  An\n   Application MUST NOT apply a Rule to the output\
    \ of a previous Rule.\n   All Rewrite Rules for all Applications must ALWAYS apply\
    \ to the exact\n   same Application Unique String that the algorithm started with.\n\
    \   It is a fundamental assumption that the Application Unique String has\n  \
    \ some kind of regular, lexical structure that the rules can be applied\n   to.\
    \  It is an assumption of the DDDS that the lexical element used to\n   make a\
    \ delegation decision is simple enough to be contained within\n   the Application\
    \ Unique String itself.  The DDDS does not solve the\n   case where a delegation\
    \ decision is made using knowledge contained\n   outside the AUS and the Rule\
    \ (time of day, financial transactions,\n   rights management, etc.).\n   Diagrammatically\
    \ the algorithm looks like this:\n          +--------- Application Unique String\n\
    \          |                 +-----+\n          |                 |input|\n  \
    \        |         +-------+     +---------+\n          |         | First Well\
    \ Known Rule |\n          |         +-------+      +--------+\n          |   \
    \              |output|\n          |                 +------+\n          |   \
    \             First Key\n          |                    |\n          |       \
    \             +----<--------------<--------------+\n          |              \
    \      |                                  |\n          |                   key\
    \     (a DDDS database always     |\n          |                 +-----+    takes\
    \ a key and returns    |\n          |                 |input|    a rule)     \
    \               ^\n          |       +---------+     +------------+          \
    \        |\n          |       | Lookup key in DDDS Database|                 \
    \ |\n          |       +---------+      +-----------+                  |\n   \
    \       |                 |output|                              |\n          |\
    \                 +------+                              |\n          |       \
    \          rule set                              |\n          |              \
    \      |                                  |\n          |                    |\
    \      (the input to a rule        |\n          |                 rule set  is\
    \ the rule and the AUS.    ^\n          |                 +-----+   The output\
    \ is always        |\n          +---------------->|input|   either a key or the\
    \ result) |\n            +---------------+     +------------------+          \
    \  |\n            | Apply Rules to Application Unique String|           |\n  \
    \          | until non-empty result are obtained     |           |\n         \
    \   | that meet the applications requirements |           |\n            +---------------+\
    \      +-----------------+            |\n                            |output|\
    \                              |\n                            +------+       \
    \                       ^\n                              key                 \
    \                |\n                               |                         \
    \         |\n                               v                                \
    \  |\n               +--------------------------------------+           |\n  \
    \             | Was the last matching rule terminal? | No >------+\n         \
    \      +--------------------------------------+\n                            \
    \  Yes     (if the rule isn't terminal then\n                               |\
    \      its output is the new key which\n                               |     \
    \ is used to find a new rule set)\n              +------------------------------------+\n\
    \              | The output of the last rule is the |\n              | result\
    \ desired by the application  |\n              +------------------------------------+\n"
- title: 3.1 Components of a Rule
  contents:
  - "3.1 Components of a Rule\n   A Rule is made up of 4 pieces of information:\n\
    \   A Priority\n      Simply a number used to show which of two otherwise equal\
    \ rules\n      may have precedence.  This allows the database to express rules\n\
    \      that may offer roughly the same results but one delegation path\n     \
    \ may be faster, better, cheaper than the other.\n   A Set of Flags\n      Flags\
    \ are used to specify attributes of the rule that determine if\n      this rule\
    \ is the last one to be applied.  The last rule is called\n      the terminal\
    \ rule and its output should be the intended result for\n      the application.\
    \  Flags are unique across Applications.  An\n      Application may specify that\
    \ it is using a flag defined by yet\n      another Application but it must use\
    \ that other Application's\n      definition.  One Application cannot redefine\
    \ a Flag used by\n      another Application.  This may mean that a registry of\
    \ Flags will\n      be needed in the future but at this time it is not a requirement.\n\
    \   A Description of Services\n      Services are used to specify semantic attributes\
    \ of a particular\n      delegation branch.  There are many cases where two delegation\n\
    \      branches are identical except that one delegates down to a result\n   \
    \   that provides one set of features while another provides some\n      other\
    \ set.  Features may include operational issues such as load\n      balancing,\
    \ geographically based traffic segregation, degraded but\n      backwardly compatible\
    \ functions for older clients, etc.  For\n      example, two rules may equally\
    \ apply to a specific delegation\n      decision for a string.  One rule can lead\
    \ to a terminal rule that\n      produces information for use in high availability\
    \ environments\n      while another may lead to an archival service that may be\
    \ slower\n      but is more stable over long periods of time.\n   A Substitution\
    \ Expression\n      This is the actual string modification part of the rule. \
    \ It is a\n      combination of a POSIX Extended Regular Expression [8] and a\n\
    \      replacement string similar to Unix sed-style substitution\n      expression.\n"
- title: 3.2 Substitution Expression Syntax
  contents:
  - "3.2 Substitution Expression Syntax\n   The character set(s) that the substitution\
    \ expression is in and can\n   act on are dependent both on the Application and\
    \ on the Database\n   being used.  An Application must define what the allowed\
    \ character\n   sets are for the Application Unique String.  A DDDS Database\n\
    \   specification must define what character sets are required for\n   producing\
    \ its keys and for how the substitution expression itself is\n   encoded.  The\
    \ grammar-required characters below only have meaning\n   once a specific character\
    \ set is defined for the Database and/or\n   Application.\n   The syntax of the\
    \ Substitution Expression part of the rule is a\n   sed-style substitution expression.\
    \  True sed-style substitution\n   expressions are not appropriate for use in\
    \ this application for a\n   variety of reasons, therefore the contents of the\
    \ regexp field MUST\n   follow this grammar:\n"
- title: subst-expr   = delim-char  ere  delim-char  repl  delim-char  *flags
  contents:
  - 'subst-expr   = delim-char  ere  delim-char  repl  delim-char  *flags

    '
- title: delim-char   = "/" / "!" / <Any octet not in 'POS-DIGIT' or 'flags'>
  contents:
  - "delim-char   = \"/\" / \"!\" / <Any octet not in 'POS-DIGIT' or 'flags'>\n  \
    \                 ; All occurrences of a delim_char in a subst_expr\n        \
    \           ; must be the same character.>\n"
- title: ere          = <POSIX Extended Regular Expression>
  contents:
  - 'ere          = <POSIX Extended Regular Expression>

    '
- title: repl         = *(string / backref)
  contents:
  - 'repl         = *(string / backref)

    '
- title: string       = *(anychar / escapeddelim)
  contents:
  - 'string       = *(anychar / escapeddelim)

    '
- title: anychar      = <any character other than delim-char>
  contents:
  - 'anychar      = <any character other than delim-char>

    '
- title: escapeddelim = "\" delim-char
  contents:
  - 'escapeddelim = "\" delim-char

    '
- title: backref      = "\" POS-DIGIT
  contents:
  - 'backref      = "\" POS-DIGIT

    '
- title: flags        = "i"
  contents:
  - 'flags        = "i"

    '
- title: POS-DIGIT    = "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"
  contents:
  - "POS-DIGIT    = \"1\" / \"2\" / \"3\" / \"4\" / \"5\" / \"6\" / \"7\" / \"8\"\
    \ / \"9\"\n   The result of applying the substitution expression to the String\
    \ MUST\n   result in a key which obeys the rules of the Database (unless of\n\
    \   course it is a Terminal Rule in which case the output follows the\n   rules\
    \ of the application).  Since it is possible for the regular\n   expression to\
    \ be improperly specified, such that a non-conforming key\n   can be constructed,\
    \ client software SHOULD verify that the result is\n   a legal database key before\
    \ using it.\n   Backref expressions in the repl portion of the substitution\n\
    \   expression are replaced by the (possibly empty) string of characters\n   enclosed\
    \ by '(' and ')' in the ERE portion of the substitution\n   expression.  N is\
    \ a single digit from 1 through 9, inclusive.  It\n   specifies the N'th backref\
    \ expression, the one that begins with the\n   N'th '(' and continues to the matching\
    \ ')'.  For example, the ERE\n                         (A(B(C)DE)(F)G)\n    has\
    \ backref expressions:\n                         \\1  = ABCDEFG\n            \
    \             \\2  = BCDE\n                         \\3  = C\n               \
    \          \\4  = F\n                         \\5..\\9  = error - no matching\
    \ subexpression\n   The \"i\" flag indicates that the ERE matching SHALL be performed\
    \ in a\n   case-insensitive fashion.  Furthermore, any backref replacements MAY\n\
    \   be normalized to lower case when the \"i\" flag is given.  This flag\n   has\
    \ meaning only when both the Application and Database define a\n   character set\
    \ where case insensitivity is valid.\n   The first character in the substitution\
    \ expression shall be used as\n   the character that delimits the components of\
    \ the substitution\n   expression.  There must be exactly three non-escaped occurrences\
    \ of\n   the delimiter character in a substitution expression.  Since escaped\n\
    \   occurrences of the delimiter character will be interpreted as\n   occurrences\
    \ of that character, digits MUST NOT be used as delimiters.\n   Backrefs would\
    \ be confused with literal digits were this allowed.\n   Similarly, if flags are\
    \ specified in the substitution expression, the\n   delimiter character must not\
    \ also be a flag character.\n"
- title: 3.3 The Complete Algorithm
  contents:
  - "3.3 The Complete Algorithm\n   The following is the exact DDDS algorithm:\n \
    \  1.  The First Well Known Rule is applied to the Application Unique\n      \
    \ String which produces a Key.\n   2.  The Application asks the Database for the\
    \ ordered set of Rules\n       that are bound to that Key (see NOTE below on order\
    \ details).\n   3.  The Substitution Expression for each Rule in the list is applied,\n\
    \       in order, to the Application Unique String until a non-empty\n       string\
    \ is produced.  The position in the list is noted and the\n       Rule that produced\
    \ the non-empty string is used for the next\n       step.  If the next step rejects\
    \ this rule and returns to this\n       step then the Substitution Expression\
    \ application process\n       continues at the point where it left off.  If the\
    \ list is\n       exhausted without a valid match then the application is notified\n\
    \       that no valid output was available.\n   4.  If the Service description\
    \ of the rule does not meet the client's\n       requirements, go back to step\
    \ 3 and continue through the already\n       retrieved list of rules.  If it does\
    \ match the client's\n       requirements then this Rule is used for the next\
    \ step.  If and\n       only if the client is capable of handling it and if it\
    \ is deemed\n       safe to do so by the Application's specification, the client\
    \ may\n       make a note of the current Rule but still return to step 3 as\n\
    \       though it had rejected it.  In either case, the output of this\n     \
    \  step is one and only one Rule.\n   5.  If the Flags part of the Rule designate\
    \ that this Rule is NOT\n       Terminal, go back to step 2 with the substitution\
    \ result as the\n       new Key.\n   6.  Notify the Application that the process\
    \ has finished and provide\n       the Application with the Flags and Services\
    \ part of the Rule\n       along with the output of the last Substitution Expression.\n\
    \   NOTE 1: In some applications and/or databases the result set can\n   express\
    \ the case where two or more Rules are considered equal.  These\n   Rules are\
    \ treated as the same Rule, each one possibly having a\n   Priority which is used\
    \ to communicate a preference for otherwise\n   equivalent Rules.  This allows\
    \ for Rules to act as fallbacks for\n   others.  It should be noted that this\
    \ is a real Preference, not a\n   load balancing mechanism.  Applications should\
    \ define the difference\n   carefully.\n   NOTE 2: Databases may or may not have\
    \ rules that determine when and\n   how records within that database expire (expiration\
    \ dates, times to\n   live, etc.).  These expiration mechanisms must be adhered\
    \ to in all\n   cases.  Specifically, since the expiration of a databases record\n\
    \   could cause a new Rule to be retrieved that is inconsistent with\n   previous\
    \ Rules, while in the algorithm any attempts to optimize the\n   process by falling\
    \ back to previous keys and Rules MUST ensure that\n   no previously retrieved\
    \ Rule has expired.  If a Rule has expired then\n   the application MUST start\
    \ over at Step 1.\n"
- title: 4. Specifying an Application
  contents:
  - "4. Specifying an Application\n   In order for this algorithm to have any usefulness,\
    \ a specification\n   must be written describing an application and one or more\
    \ databases.\n   In order to specify an application the following pieces of\n\
    \   information are required:\n   Application Unique String:\n      This is the\
    \ only string that the rewrite rules will apply to.  The\n      string must have\
    \ some regular structure and be unique within the\n      application such that\
    \ anyone applying Rules taken from the same\n      Database will end up with the\
    \ same Keys.  For example, the URI\n      Resolution application defines the Application\
    \ Unique String to be\n      a URI.\n      No application is allowed to define\
    \ an Application Unique String\n      such that the Key obtained by a rewrite\
    \ rule is treated as the\n      Application Unique String for input to a new rule.\
    \  This leads to\n      sendmail style rewrite rules which are fragile and error\
    \ prone.\n      The one single exception to this is when an Application defines\n\
    \      some flag or state where the rules for that application are\n      suspended\
    \ and a new DDDS Application or some other arbitrary set\n      of rules take\
    \ over.  If this is the case then, by definition, none\n      of these rules apply.\
    \  One such case can be found in the URI\n      Resolution application which defines\
    \ the 'p' flag which states\n      that the next step is 'protocol specific' and\
    \ thus outside of the\n      scope of DDDS.\n   First Well Known Rule:\n     \
    \ This is the first rule that, when applied to the Application\n      Unique String,\
    \ produces the first valid Key.  It can be expressed\n      in the same form as\
    \ a Rule or it can be something more complex.\n      For example, the URI Resolution\
    \ application might specify that the\n      rule is that the sequence of characters\
    \ in the URI up to but not\n      including the first colon (the URI scheme) is\
    \ the first Key.\n   Valid Databases:\n      The application can define which\
    \ Databases are valid.  For each\n      Database the Application must define how\
    \ the First Well Known\n      Rule's output (the first Key) is turned into something\
    \ that is\n      valid for that Database.  For example, the URI Resolution\n \
    \     application could use the Domain Name System (DNS) as a Database.\n    \
    \  The operation for turning this first Key into something that was\n      valid\
    \ for the database would be to to turn it into some DNS-valid\n      domain-name.\
    \  Additionally, for each Database an Application\n      defines, it must also\
    \ specify what the valid character sets are\n      that will produce the correct\
    \ Keys.  In the URI Resolution example\n      shown here, the character set of\
    \ a URI is 7 bit ASCII which\n      matches fairly well with DNS's 8 bit limitation\
    \ on characters in\n      its zone files.\n   Expected Output:\n      The Application\
    \ must define what the expected output of the\n      Terminal Rule should be.\
    \  For example, the URI Resolution\n      application is concerned with finding\
    \ servers that contain\n      authoritative data about a given URI.  Thus the\
    \ output of the\n      terminal rule would be information (hosts, ports, protocols,\
    \ etc.)\n      that would be used to contact that authoritative server.\n   In\
    \ the past there has been some confusion concerning load balancing\n   and the\
    \ use of the DDDS 'Priority'.  Applications should be aware\n   that the Priority\
    \ of a given rule is just that:  a way of specifying\n   that one rule is \"better,\
    \ faster, cheaper\" than another.  If an\n   application needs some method of\
    \ allowing a client to load balance\n   between servers (i.e., weighted random\
    \ selection, etc.) then it\n   should do so outside the DDDS algorithm.  For example,\
    \ Applications\n   that make use of the DNS Database may use the SRV record as\
    \ a way of\n   signifying that a particular service is actually handled by several\n\
    \   hosts cooperating with each other.  The difference being that load\n   balancing\
    \ is done between hosts that are identical to each other\n   where as DDDS is\
    \ concerned with delegation paths that have some\n   particular feature set or\
    \ administrative domain.\n"
- title: 5. Specifying A Database
  contents:
  - "5. Specifying A Database\n   Additionally, any Application must have at least\
    \ one corresponding\n   Database from which to retrieve the Rules.  It is important\
    \ to note\n   that a given Database may be used by more than one Application.\
    \  If\n   this is the case, each rule must be use some combination of its\n  \
    \ Services and/or substitution expression to match only those\n   Application\
    \ Unique Strings for which it is valid.\n   A Database specification must include\
    \ the following pieces of\n   information:\n   General Specification:\n      The\
    \ Database must have a general specification.  This can\n      reference other\
    \ standards (SQL, DNS, etc.) or it can fully specify\n      a novel database system.\
    \  This specification MUST be clear as to\n      what allowed character sets exist\
    \ in order to know in which\n      character set the Keys and Rules are encoded.\n\
    \   Lookup Procedure:\n      This specifies how a query is formulated and submitted\
    \ to the\n      database.  In the case of databases that are used for other\n\
    \      purposes (such as DNS), the specification must be clear as to how\n   \
    \   a query is formulated specifically for the database to be a DDDS\n      database.\
    \  For example, a DNS based Database must specify which\n      Resource Records\
    \ or Query Types are used.\n   Key Format:\n      If any operations are needed\
    \ in order to turn a Key into something\n      that is valid for the database\
    \ then these must be clearly defined.\n      For example, in the case of a DNS\
    \ database, the Keys must be\n      constructed as valid domain-names.\n   Rule\
    \ Format:\n      The specification for the output format of a rule.\n   Rule Insertion\
    \ Procedure:\n      A specification for how a Rule is inserted into the database.\n\
    \      This can include policy statements about whether or not a Rule is\n   \
    \   allowed to be added.\n   Rule Collision Avoidance:\n      Since a Database\
    \ may be used by multiple Applications (ENUM and\n      URI Resolution for example),\
    \ the specification must be clear about\n      how rule collisions will be avoided.\
    \  There are usually two\n      methods for handling this: 1) disallow one key\
    \ from being valid in\n      two different Applications; 2) if 1 isn't possible\
    \ then write the\n      substitution expression such that the regular expression\
    \ part\n      contains enough of the Application Unique String as part of its\n\
    \      match to differentiate between the two Applications.\n"
- title: 6. Examples
  contents:
  - "6. Examples\n   The examples given here are for pedagogical purposes only.  They\
    \ are\n   specifically taken from ficticious applications that have not been\n\
    \   specified in any published document.\n"
- title: 6.1 An Automobile Parts Identification System
  contents:
  - "6.1 An Automobile Parts Identification System\n   In this example imagine a system\
    \ setup where all automobile\n   manufacturers come together and create a standardized\
    \ part numbering\n   system for the various parts (nuts, bolts, frames, instruments,\
    \ etc.)\n   that make up the automobile manufacturing and repair process.  The\n\
    \   problem with such a system is that the auto industry is a very\n   distributed\
    \ system where parts are built by various third parties\n   distributed around\
    \ the world.  In order to find information about a\n   given part a system must\
    \ be able to find out who makes that part and\n   contact them about it.\n   To\
    \ facilitate this distributed system the identification number\n   assigned to\
    \ a part is assigned hierarchically such that the first 5\n   digits make up a\
    \ parts manufacturer ID number.  The next 3 digits are\n   an auto line identifier\
    \ (Ford, Toyota, etc.).  The rest of the digits\n   are assigned by the parts\
    \ manufacturer according to rules that the\n   manufacturer decides.\n   The auto\
    \ industry decides to use the DDDS to create a distributed\n   information retrieval\
    \ system that routes queries to the actual owner\n   of the data.  The industry\
    \ specifies a database and a query syntax\n   for retrieving rewrite rules (the\
    \ APIDA Network) and then specifies\n   the Auto Parts Identification DDDS Application\
    \ (APIDA).\n   The APIDA specification would define the following:\n   o  Application\
    \ Unique String: the part number.\n   o  First Well Known Rule: take the first\
    \ 5 digits (the manufacturers\n      ID number) and use that as the Key.\n   o\
    \  Valid Databases: The APIDA Network.\n   o  Expected Output: EDIFAC information\
    \ about the part.\n   The APIDA Network Database specification would define the\
    \ following:\n   o  General Specification: a network of EDI enabled databases\
    \ and\n      services that, when given a subcomponent of a part number will\n\
    \      return an XML encoded rewrite rule.\n   o  Lookup Procedure: following\
    \ normal APIDA Network protocols, ask\n      the network for a rewrite rule for\
    \ the Key.\n   o  Key Format: no conversion is required.\n   o  Rule Format: see\
    \ APIDA Network documentation for the XML DTD.\n   o  Rule Insertion Procedure:\
    \ determined by the authority that has\n      control over each section of the\
    \ part number.  I.e., in order to\n      get a manufacturer ID you must be a member\
    \ of the Auto Parts\n      Manufacturers Association.\n   In order to illustrate\
    \ how the system would work, imagine the part\n   number \"4747301AB7D\".  The\
    \ system would take the first 5 digits,\n   '47473' and ask the network for that\
    \ Rewrite Rule.  This Rule would\n   be provided by the parts manufacturers database\
    \ and would allow the\n   manufacturer to either further sub-delegate the space\
    \ or point the\n   querier directly at the EDIFAC information in the system.\n\
    \   In this example let's suppose that the manufacturer returns a Rule\n   that\
    \ states that the next 3 digits should be used as part of a query\n   to their\
    \ service in order to find a new Rule.  This new Rule would\n   allow the parts\
    \ manufacturer to further delegate the query to their\n   parts factories for\
    \ each auto line.  In our example part number the\n   number '01A' denotes the\
    \ Toyota line of cars.  The Rule that the\n   manufacturer returns further delegates\
    \ the query to a supply house in\n   Japan.  This rule also denotes that this\
    \ Rule is terminal and thus\n   the result of this last query will be the actual\
    \ information about\n   the part.\n"
- title: 6.2 A Document Identification Service
  contents:
  - "6.2 A Document Identification Service\n   This example is very similar to the\
    \ last since the documents in this\n   system can simply be thought of as the\
    \ auto part in the last example.\n   The difference here is that the information\
    \ about the document is\n   kept very close to the author (usually on their desktop).\
    \  Thus there\n   is the probability that the number of delegations can be very\
    \ deep.\n   Also, in order to keep from having a large flat space of authors,\
    \ the\n   authors are organized by organizations and departments.\n   Let's suppose\
    \ that the Application Unique String in this example\n   looks like the following:\n\
    \      <organization>-<department>-<author>:<project>-<bookcase>-<book>\n   The\
    \ Application specification would look like this:\n   o  Application Unique String:\
    \ the Document ID string given above.\n   o  First Well Known Rule: the characters\
    \ up to but not including the\n      first '-' is treated as the first Key.\n\
    \   o  Valid Databases: the DIS LDAP Directory.\n   o  Expected Output: a record\
    \ from an LDAP server containing\n      bibliographic information about the document\
    \ in XML.\n   The Database specification for the DIS LDAP Directory would look\
    \ like\n   this:\n   o  General Specification: the Database uses the LDAP directory\n\
    \      service.  Each LDAP server has a record that contains the Rewrite\n   \
    \   Rule.  Rules refer to other LDAP servers using the LDAP URL\n      scheme.\n\
    \   o  Lookup Procedure: using standard LDAP queries, the client asks the\n  \
    \    LDAP server for information about the Key.\n   o  Key Format: no conversion\
    \ is necessary.\n   o  Rule Format: See the LDAP Rewrite Rule specification.\n\
    \   o  Rule Insertion Procedure: See the procedures published by the\n      entity\
    \ that has authority over that section of the DIS tree.  The\n      first section,\
    \ the organization, is owned by the DIS Agency.\n   In this example, the first\
    \ lookup is for the organization's Rule.  At\n   that point the organization may\
    \ point the client directly at some\n   large, organization wide database that\
    \ contains the expected output.\n   Other organizations may decentralize this\
    \ process so that Rules end\n   up delegating the query all the way down to the\
    \ authors document\n   management environment of choice.\n"
- title: 7. Security Considerations
  contents:
  - "7. Security Considerations\n   This document simply defines the DDDS algorithm\
    \ and thus, by itself,\n   does not imply any security issues.  It is when this\
    \ algorithm is\n   coupled with a Database and an Application that security\n\
    \   considerations can be known well enough to enumerate them beyond\n   simply\
    \ saying that dynamic delegation points are a possible point of\n   attack.\n"
- title: 8. IANA Considerations
  contents:
  - "8. IANA Considerations\n   This document does not create any requirements on\
    \ the IANA.  Database\n   and Application specifications may have considerable\
    \ requirements but\n   they cannot be enumerated here.\n"
- title: References
  contents:
  - "References\n   [1]  Mealling, M., \"Dynamic Delegation Discovery System (DDDS)\n\
    \        Part One: The Comprehensive DDDS\", RFC 3401, October 2002.\n   [2] \
    \ Mealling, M., \"Dynamic Delegation Discovery System (DDDS)\n        Part Two:\
    \ The Algorithm\", RFC 3402, October 2002.\n   [3]  Mealling, M., \"Dynamic Delegation\
    \ Discovery System (DDDS)\n        Part Three: The Domain Name System (DNS) Database\"\
    , RFC 3403,\n        October 2002.\n   [4]  Mealling, M., \"Dynamic Delegation\
    \ Discovery System (DDDS)\n        Part Four: The Uniform Resource Identifiers\
    \ (URI) Resolution\n        Application\", RFC 3404, October 2002.\n   [5]  Mealling,\
    \ M., \"Dynamic Delegation Discovery System (DDDS)\n        Part Five: URI.ARPA\
    \ Assignment Procedures\", RFC 3405,\n        October 2002.\n   [6]  Moats, R.,\
    \ \"URN Syntax\", RFC 2141, May 1997.\n   [7]  Sollins, K., \"Architectural Principles\
    \ of Uniform Resource Name\n        Resolution\", RFC 2276, January 1998.\n  \
    \ [8]  The Institute of Electrical and Electronics Engineers, \"IEEE\n       \
    \ Standard for Information Technology - Portable Operating System\n        Interface\
    \ (POSIX) - Part 2: Shell and Utilities (Vol. 1)\", IEEE\n        Std 1003.2-1992,\
    \ ISBN 1-55937-255-9, January 1993.\n   [9]  Mealling, M. and R. Daniel, \"The\
    \ Naming Authority Pointer\n        (NAPTR) DNS Resource Record\", RFC 2915, August\
    \ 2000.\n   [10] Faltstrom, P., \"E.164 number and DNS\", RFC 2916, September\n\
    \        2000.\n   [11] Daniel, R. and M. Mealling, \"Resolution of Uniform Resource\n\
    \        Identifiers using the Domain Name System\", RFC 2168, June 1997.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Michael Mealling\n   VeriSign\n   21345 Ridgetop Circle\n\
    \   Sterling, VA  20166\n   US\n   EMail: michael@neonym.net\n   URI:   http://www.verisignlabs.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2002).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
