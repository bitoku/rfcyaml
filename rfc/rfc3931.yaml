- contents:
  - '           Layer Two Tunneling Protocol - Version 3 (L2TPv3)

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes \"version 3\" of the Layer Two Tunneling\n
    \  Protocol (L2TPv3).  L2TPv3 defines the base control protocol and\n   encapsulation
    for tunneling multiple Layer 2 connections between two\n   IP nodes.  Additional
    documents detail the specifics for each data\n   link type being emulated.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  3\n       1.1.  Changes from RFC 2661. . . . . . . . . . . . . .
    . . . .  4\n       1.2.  Specification of Requirements. . . . . . . . . . . .
    . .  4\n       1.3.  Terminology. . . . . . . . . . . . . . . . . . . . . . .
    \ 5\n   2.  Topology . . . . . . . . . . . . . . . . . . . . . . . . . . .  8\n
    \  3.  Protocol Overview. . . . . . . . . . . . . . . . . . . . . . .  9\n       3.1.
    \ Control Message Types. . . . . . . . . . . . . . . . . . 10\n       3.2.  L2TP
    Header Formats. . . . . . . . . . . . . . . . . . . 11\n             3.2.1.  L2TP
    Control Message Header. . . . . . . . . . . 11\n             3.2.2.  L2TP Data
    Message. . . . . . . . . . . . . . . . 12\n       3.3.  Control Connection Management.
    . . . . . . . . . . . . . 13\n             3.3.1.  Control Connection Establishment
    . . . . . . . . 14\n             3.3.2.  Control Connection Teardown. . . . .
    . . . . . . 14\n       3.4.  Session Management . . . . . . . . . . . . . . .
    . . . . 15\n             3.4.1.  Session Establishment for an Incoming Call .
    . . 15\n             3.4.2.  Session Establishment for an Outgoing Call . . .
    15\n             3.4.3.  Session Teardown . . . . . . . . . . . . . . . . 16\n
    \  4.  Protocol Operation . . . . . . . . . . . . . . . . . . . . . . 16\n       4.1.
    \ L2TP Over Specific Packet-Switched Networks (PSNs) . . . 16\n             4.1.1.
    \ L2TPv3 over IP . . . . . . . . . . . . . . . . . 17\n             4.1.2.  L2TP
    over UDP. . . . . . . . . . . . . . . . . . 18\n             4.1.3.  L2TP and
    IPsec . . . . . . . . . . . . . . . . . 20\n             4.1.4.  IP Fragmentation
    Issues. . . . . . . . . . . . . 21\n       4.2.  Reliable Delivery of Control
    Messages. . . . . . . . . . 23\n       4.3.  Control Message Authentication .
    . . . . . . . . . . . . 25\n       4.4.  Keepalive (Hello). . . . . . . . . .
    . . . . . . . . . . 26\n       4.5.  Forwarding Session Data Frames . . . . .
    . . . . . . . . 26\n       4.6.  Default L2-Specific Sublayer . . . . . . . .
    . . . . . . 27\n             4.6.1.  Sequencing Data Packets. . . . . . . . .
    . . . . 28\n       4.7.  L2TPv2/v3 Interoperability and Migration . . . . . .
    . . 28\n             4.7.1.  L2TPv3 over IP . . . . . . . . . . . . . . . . .
    29\n             4.7.2.  L2TPv3 over UDP. . . . . . . . . . . . . . . . . 29\n
    \            4.7.3.  Automatic L2TPv2 Fallback. . . . . . . . . . . . 29\n   5.
    \ Control Message Attribute Value Pairs. . . . . . . . . . . . . 30\n       5.1.
    \ AVP Format . . . . . . . . . . . . . . . . . . . . . . . 30\n       5.2.  Mandatory
    AVPs and Setting the M Bit . . . . . . . . . . 32\n       5.3.  Hiding of AVP
    Attribute Values . . . . . . . . . . . . . 33\n       5.4.  AVP Summary. . . .
    . . . . . . . . . . . . . . . . . . . 36\n             5.4.1.  General Control
    Message AVPs . . . . . . . . . . 36\n             5.4.2.  Result and Error Codes
    . . . . . . . . . . . . . 40\n             5.4.3.  Control Connection Management
    AVPs . . . . . . . 43\n             5.4.4.  Session Management AVPs. . . . . .
    . . . . . . . 48\n             5.4.5.  Circuit Status AVPs. . . . . . . . . .
    . . . . . 57\n   6.  Control Connection Protocol Specification. . . . . . . .
    . . . 59\n       6.1.  Start-Control-Connection-Request (SCCRQ) . . . . . . .
    . 60\n       6.2.  Start-Control-Connection-Reply (SCCRP) . . . . . . . . . 60\n
    \      6.3.  Start-Control-Connection-Connected (SCCCN) . . . . . . . 61\n       6.4.
    \ Stop-Control-Connection-Notification (StopCCN) . . . . . 61\n       6.5.  Hello
    (HELLO). . . . . . . . . . . . . . . . . . . . . . 61\n       6.6.  Incoming-Call-Request
    (ICRQ) . . . . . . . . . . . . . . 62\n       6.7.  Incoming-Call-Reply (ICRP)
    . . . . . . . . . . . . . . . 63\n       6.8.  Incoming-Call-Connected (ICCN)
    . . . . . . . . . . . . . 63\n       6.9.  Outgoing-Call-Request (OCRQ) . . .
    . . . . . . . . . . . 64\n       6.10. Outgoing-Call-Reply (OCRP) . . . . . .
    . . . . . . . . . 65\n       6.11. Outgoing-Call-Connected (OCCN) . . . . . .
    . . . . . . . 65\n       6.12. Call-Disconnect-Notify (CDN) . . . . . . . . .
    . . . . . 66\n       6.13. WAN-Error-Notify (WEN) . . . . . . . . . . . . . .
    . . . 66\n       6.14. Set-Link-Info (SLI). . . . . . . . . . . . . . . . . .
    . 67\n       6.15. Explicit-Acknowledgement (ACK) . . . . . . . . . . . . . 67\n
    \  7.  Control Connection State Machines. . . . . . . . . . . . . . . 68\n       7.1.
    \ Malformed AVPs and Control Messages. . . . . . . . . . . 68\n       7.2.  Control
    Connection States. . . . . . . . . . . . . . . . 69\n       7.3.  Incoming Calls
    . . . . . . . . . . . . . . . . . . . . . 71\n             7.3.1.  ICRQ Sender
    States . . . . . . . . . . . . . . . 72\n             7.3.2.  ICRQ Recipient States.
    . . . . . . . . . . . . . 73\n       7.4.  Outgoing Calls . . . . . . . . . .
    . . . . . . . . . . . 74\n             7.4.1.  OCRQ Sender States . . . . . .
    . . . . . . . . . 75\n             7.4.2.  OCRQ Recipient (LAC) States. . . .
    . . . . . . . 76\n       7.5.  Termination of a Control Connection. . . . . .
    . . . . . 77\n   8.  Security Considerations. . . . . . . . . . . . . . . . .
    . . . 78\n       8.1.  Control Connection Endpoint and Message Security . . .
    . 78\n       8.2.  Data Packet Spoofing . . . . . . . . . . . . . . . . . . 78\n
    \  9.  Internationalization Considerations. . . . . . . . . . . . . . 79\n   10.
    IANA Considerations. . . . . . . . . . . . . . . . . . . . . . 80\n       10.1.
    Control Message Attribute Value Pairs (AVPs) . . . . . . 80\n       10.2. Message
    Type AVP Values. . . . . . . . . . . . . . . . . 81\n       10.3. Result Code
    AVP Values . . . . . . . . . . . . . . . . . 81\n       10.4. AVP Header Bits.
    . . . . . . . . . . . . . . . . . . . . 82\n       10.5. L2TP Control Message
    Header Bits . . . . . . . . . . . . 82\n       10.6. Pseudowire Types . . . .
    . . . . . . . . . . . . . . . . 83\n       10.7. Circuit Status Bits. . . . .
    . . . . . . . . . . . . . . 83\n       10.8. Default L2-Specific Sublayer bits.
    . . . . . . . . . . . 84\n       10.9. L2-Specific Sublayer Type. . . . . . .
    . . . . . . . . . 84\n       10.10 Data Sequencing Level. . . . . . . . . . .
    . . . . . . . 84\n   11. References . . . . . . . . . . . . . . . . . . . . .
    . . . . . 85\n       11.1. Normative References . . . . . . . . . . . . . . .
    . . . 85\n       11.2. Informative References . . . . . . . . . . . . . . . .
    . 85\n   12. Acknowledgments. . . . . . . . . . . . . . . . . . . . . . . . 87\n
    \  Appendix A: Control Slow Start and Congestion Avoidance. . . . . . 89\n   Appendix
    B: Control Message Examples . . . . . . . . . . . . . . . 90\n   Appendix C: Processing
    Sequence Numbers. . . . . . . . . . . . . . 91\n   Editors' Addresses . . . .
    . . . . . . . . . . . . . . . . . . . . 93\n   Full Copyright Statement . . .
    . . . . . . . . . . . . . . . . . . 94\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Layer Two Tunneling Protocol (L2TP) provides a dynamic
    mechanism\n   for tunneling Layer 2 (L2) \"circuits\" across a packet-oriented
    data\n   network (e.g., over IP).  L2TP, as originally defined in RFC 2661, is\n
    \  a standard method for tunneling Point-to-Point Protocol (PPP)\n   [RFC1661]
    sessions.  L2TP has since been adopted for tunneling a\n   number of other L2
    protocols.  In order to provide greater\n   modularity, this document describes
    the base L2TP protocol,\n   independent of the L2 payload that is being tunneled.\n
    \  The base L2TP protocol defined in this document consists of (1) the\n   control
    protocol for dynamic creation, maintenance, and teardown of\n   L2TP sessions,
    and (2) the L2TP data encapsulation to multiplex and\n   demultiplex L2 data streams
    between two L2TP nodes across an IP\n   network.  Additional documents are expected
    to be published for each\n   L2 data link emulation type (a.k.a. pseudowire-type)
    supported by\n   L2TP (i.e., PPP, Ethernet, Frame Relay, etc.).  These documents
    will\n   contain any pseudowire-type specific details that are outside the\n   scope
    of this base specification.\n   When the designation between L2TPv2 and L2TPv3
    is necessary, L2TP as\n   defined in RFC 2661 will be referred to as \"L2TPv2\",
    corresponding to\n   the value in the Version field of an L2TP header.  (Layer
    2\n   Forwarding, L2F, [RFC2341] was defined as \"version 1\".)  At times,\n   L2TP
    as defined in this document will be referred to as \"L2TPv3\".\n   Otherwise,
    the acronym \"L2TP\" will refer to L2TPv3 or L2TP in\n   general.\n"
  - contents:
    - "1.1.  Changes from RFC 2661\n   Many of the protocol constructs described in
      this document are\n   carried over from RFC 2661.  Changes include clarifications
      based on\n   years of interoperability and deployment experience as well as\n
      \  modifications to either improve protocol operation or provide a\n   clearer
      separation from PPP.  The intent of these modifications is to\n   achieve a
      healthy balance between code reuse, interoperability\n   experience, and a directed
      evolution of L2TP as it is applied to new\n   tasks.\n   Notable differences
      between L2TPv2 and L2TPv3 include the following:\n      Separation of all PPP-related
      AVPs, references, etc., including a\n      portion of the L2TP data header that
      was specific to the needs of\n      PPP.  The PPP-specific constructs are described
      in a companion\n      document.\n      Transition from a 16-bit Session ID and
      Tunnel ID to a 32-bit\n      Session ID and Control Connection ID, respectively.\n
      \     Extension of the Tunnel Authentication mechanism to cover the\n      entire
      control message rather than just a portion of certain\n      messages.\n   Details
      of these changes and a recommendation for transitioning to\n   L2TPv3 are discussed
      in Section 4.7.\n"
    title: 1.1.  Changes from RFC 2661
  - contents:
    - "1.2.  Specification of Requirements\n   The key words \"MUST\", \"MUST NOT\",
      \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
      \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described
      in [RFC2119].\n"
    title: 1.2.  Specification of Requirements
  - contents:
    - "1.3.  Terminology\n   Attribute Value Pair (AVP)\n      The variable-length
      concatenation of a unique Attribute\n      (represented by an integer), a length
      field, and a Value\n      containing the actual value identified by the attribute.
      \ Zero or\n      more AVPs make up the body of control messages, which are used
      in\n      the establishment, maintenance, and teardown of control\n      connections.
      \ This basic construct is sometimes referred to as a\n      Type-Length-Value
      (TLV) in some specifications.  (See also:\n      Control Connection, Control
      Message.)\n   Call (Circuit Up)\n      The action of transitioning a circuit
      on an L2TP Access\n      Concentrator (LAC) to an \"up\" or \"active\" state.
      \ A call may be\n      dynamically established through signaling properties
      (e.g., an\n      incoming or outgoing call through the Public Switched Telephone\n
      \     Network (PSTN)) or statically configured (e.g., provisioning a\n      Virtual
      Circuit on an interface).  A call is defined by its\n      properties (e.g.,
      type of call, called number, etc.) and its data\n      traffic.  (See also:
      Circuit, Session, Incoming Call, Outgoing\n      Call, Outgoing Call Request.)\n
      \  Circuit\n      A general term identifying any one of a wide range of L2\n
      \     connections.  A circuit may be virtual in nature (e.g., an ATM\n      PVC,
      an IEEE 802 VLAN, or an L2TP session), or it may have direct\n      correlation
      to a physical layer (e.g., an RS-232 serial line).\n      Circuits may be statically
      configured with a relatively long-lived\n      uptime, or dynamically established
      with signaling to govern the\n      establishment, maintenance, and teardown
      of the circuit.  For the\n      purposes of this document, a statically configured
      circuit is\n      considered to be essentially the same as a very simple, long-\n
      \     lived, dynamic circuit.  (See also: Call, Remote System.)\n   Client\n
      \     (See Remote System.)\n   Control Connection\n      An L2TP control connection
      is a reliable control channel that is\n      used to establish, maintain, and
      release individual L2TP sessions\n      as well as the control connection itself.
      \ (See also: Control\n      Message, Data Channel.)\n   Control Message\n      An
      L2TP message used by the control connection.  (See also:\n      Control Connection.)\n
      \  Data Message\n      Message used by the data channel.  (a.k.a. Data Packet,
      See also:\n      Data Channel.)\n   Data Channel\n      The channel for L2TP-encapsulated
      data traffic that passes between\n      two LCCEs over a Packet-Switched Network
      (i.e., IP).  (See also:\n      Control Connection, Data Message.)\n   Incoming
      Call\n      The action of receiving a call (circuit up event) on an LAC.  The\n
      \     call may have been placed by a remote system (e.g., a phone call\n      over
      a PSTN), or it may have been triggered by a local event\n      (e.g., interesting
      traffic routed to a virtual interface).  An\n      incoming call that needs
      to be tunneled (as determined by the LAC)\n      results in the generation of
      an L2TP ICRQ message.  (See also:\n      Call, Outgoing Call, Outgoing Call
      Request.)\n   L2TP Access Concentrator (LAC)\n      If an L2TP Control Connection
      Endpoint (LCCE) is being used to\n      cross-connect an L2TP session directly
      to a data link, we refer to\n      it as an L2TP Access Concentrator (LAC).
      \ An LCCE may act as both\n      an L2TP Network Server (LNS) for some sessions
      and an LAC for\n      others, so these terms must only be used within the context
      of a\n      given set of sessions unless the LCCE is in fact single purpose\n
      \     for a given topology.  (See also: LCCE, LNS.)\n   L2TP Control Connection
      Endpoint (LCCE)\n      An L2TP node that exists at either end of an L2TP control\n
      \     connection.  May also be referred to as an LAC or LNS, depending\n      on
      whether tunneled frames are processed at the data link (LAC) or\n      network
      layer (LNS).  (See also: LAC, LNS.)\n   L2TP Network Server (LNS)\n      If
      a given L2TP session is terminated at the L2TP node and the\n      encapsulated
      network layer (L3) packet processed on a virtual\n      interface, we refer
      to this L2TP node as an L2TP Network Server\n      (LNS).  A given LCCE may
      act as both an LNS for some sessions and\n      an LAC for others, so these
      terms must only be used within the\n      context of a given set of sessions
      unless the LCCE is in fact\n      single purpose for a given topology.  (See
      also: LCCE, LAC.)\n   Outgoing Call\n      The action of placing a call by an
      LAC, typically in response to\n      policy directed by the peer in an Outgoing
      Call Request.  (See\n      also: Call, Incoming Call, Outgoing Call Request.)\n
      \  Outgoing Call Request\n      A request sent to an LAC to place an outgoing
      call.  The request\n      contains specific information not known a priori by
      the LAC (e.g.,\n      a number to dial).  (See also: Call, Incoming Call, Outgoing\n
      \     Call.)\n   Packet-Switched Network (PSN)\n      A network that uses packet
      switching technology for data delivery.\n      For L2TPv3, this layer is principally
      IP.  Other examples include\n      MPLS, Frame Relay, and ATM.\n   Peer\n      When
      used in context with L2TP, Peer refers to the far end of an\n      L2TP control
      connection (i.e., the remote LCCE).  An LAC's peer\n      may be either an LNS
      or another LAC.  Similarly, an LNS's peer may\n      be either an LAC or another
      LNS.  (See also: LAC, LCCE, LNS.)\n   Pseudowire (PW)\n      An emulated circuit
      as it traverses a PSN.  There is one\n      Pseudowire per L2TP Session.  (See
      also: Packet-Switched Network,\n      Session.)\n   Pseudowire Type\n      The
      payload type being carried within an L2TP session.  Examples\n      include
      PPP, Ethernet, and Frame Relay.  (See also: Session.)\n   Remote System\n      An
      end system or router connected by a circuit to an LAC.\n   Session\n      An
      L2TP session is the entity that is created between two LCCEs in\n      order
      to exchange parameters for and maintain an emulated L2\n      connection.  Multiple
      sessions may be associated with a single\n      Control Connection.\n   Zero-Length
      Body (ZLB) Message\n      A control message with only an L2TP header.  ZLB messages
      are used\n      only to acknowledge messages on the L2TP reliable control\n
      \     connection.  (See also: Control Message.)\n"
    title: 1.3.  Terminology
  title: 1.  Introduction
- contents:
  - "2.  Topology\n   L2TP operates between two L2TP Control Connection Endpoints
    (LCCEs),\n   tunneling traffic across a packet network.  There are three\n   predominant
    tunneling models in which L2TP operates: LAC-LNS (or vice\n   versa), LAC-LAC,
    and LNS-LNS.  These models are diagrammed below.\n   (Dotted lines designate network
    connections.  Solid lines designate\n   circuit connections.)\n                     Figure
    2.0: L2TP Reference Models\n   (a) LAC-LNS Reference Model: On one side, the LAC
    receives traffic\n   from an L2 circuit, which it forwards via L2TP across an
    IP or other\n   packet-based network.  On the other side, an LNS logically terminates\n
    \  the L2 circuit locally and routes network traffic to the home\n   network.
    \ The action of session establishment is driven by the LAC\n   (as an incoming
    call) or the LNS (as an outgoing call).\n    +-----+  L2  +-----+                        +-----+\n
    \   |     |------| LAC |.........[ IP ].........| LNS |...[home network]\n    +-----+
    \     +-----+                        +-----+\n    remote\n    system\n                       |<--
    emulated service -->|\n          |<----------- L2 service ------------>|\n   (b)
    LAC-LAC Reference Model: In this model, both LCCEs are LACs.\n   Each LAC forwards
    circuit traffic from the remote system to the peer\n   LAC using L2TP, and vice
    versa.  In its simplest form, an LAC acts as\n   a simple cross-connect between
    a circuit to a remote system and an\n   L2TP session.  This model typically involves
    symmetric establishment;\n   that is, either side of the connection may initiate
    a session at any\n   time (or simultaneously, in which a tie breaking mechanism
    is\n   utilized).\n   +-----+  L2  +-----+                      +-----+  L2  +-----+\n
    \  |     |------| LAC |........[ IP ]........| LAC |------|     |\n   +-----+
    \     +-----+                      +-----+      +-----+\n   remote                                                 remote\n
    \  system                                                 system\n                      |<-
    emulated service ->|\n         |<----------------- L2 service ----------------->|\n
    \  (c) LNS-LNS Reference Model: This model has two LNSs as the LCCEs.  A\n   user-level,
    traffic-generated, or signaled event typically drives\n   session establishment
    from one side of the tunnel.  For example, a\n   tunnel generated from a PC by
    a user, or automatically by customer\n   premises equipment.\n                   +-----+
    \                     +-----+\n  [home network]...| LNS |........[ IP ]........|
    LNS |...[home network]\n                   +-----+                      +-----+\n
    \                        |<- emulated service ->|\n                         |<----
    L2 service ---->|\n   Note: In L2TPv2, user-driven tunneling of this type is often
    referred\n   to as \"voluntary tunneling\" [RFC2809].  Further, an LNS acting
    as\n   part of a software package on a host is sometimes referred to as an\n   \"LAC
    Client\" [RFC2661].\n"
  title: 2.  Topology
- contents:
  - "3.  Protocol Overview\n   L2TP is comprised of two types of messages, control
    messages and data\n   messages (sometimes referred to as \"control packets\" and
    \"data\n   packets\", respectively).  Control messages are used in the\n   establishment,
    maintenance, and clearing of control connections and\n   sessions.  These messages
    utilize a reliable control channel within\n   L2TP to guarantee delivery (see
    Section 4.2 for details).  Data\n   messages are used to encapsulate the L2 traffic
    being carried over\n   the L2TP session.  Unlike control messages, data messages
    are not\n   retransmitted when packet loss occurs.\n   The L2TPv3 control message
    format defined in this document borrows\n   largely from L2TPv2.  These control
    messages are used in conjunction\n   with the associated protocol state machines
    that govern the dynamic\n   setup, maintenance, and teardown for L2TP sessions.
    \ The data message\n   format for tunneling data packets may be utilized with
    or without the\n   L2TP control channel, either via manual configuration or via
    other\n   signaling methods to pre-configure or distribute L2TP session\n   information.
    \ Utilization of the L2TP data message format with other\n   signaling methods
    is outside the scope of this document.\n                       Figure 3.0: L2TPv3
    Structure\n             +-------------------+    +-----------------------+\n             |
    Tunneled Frame    |    | L2TP Control Message  |\n             +-------------------+
    \   +-----------------------+\n             | L2TP Data Header  |    | L2TP Control
    Header   |\n             +-------------------+    +-----------------------+\n
    \            | L2TP Data Channel |    | L2TP Control Channel  |\n             |
    (unreliable)      |    | (reliable)            |\n             +-------------------+----+-----------------------+\n
    \            | Packet-Switched Network (IP, FR, MPLS, etc.)   |\n             +------------------------------------------------+\n
    \  Figure 3.0 depicts the relationship of control messages and data\n   messages
    over the L2TP control and data channels, respectively.  Data\n   messages are
    passed over an unreliable data channel, encapsulated by\n   an L2TP header, and
    sent over a Packet-Switched Network (PSN) such as\n   IP, UDP, Frame Relay, ATM,
    MPLS, etc.  Control messages are sent over\n   a reliable L2TP control channel,
    which operates over the same PSN.\n   The necessary setup for tunneling a session
    with L2TP consists of two\n   steps: (1) Establishing the control connection,
    and (2) establishing\n   a session as triggered by an incoming call or outgoing
    call.  An L2TP\n   session MUST be established before L2TP can begin to forward
    session\n   frames.  Multiple sessions may be bound to a single control\n   connection,
    and multiple control connections may exist between the\n   same two LCCEs.\n"
  - contents:
    - "3.1.  Control Message Types\n   The Message Type AVP (see Section 5.4.1) defines
      the specific type of\n   control message being sent.\n   This document defines
      the following control message types (see\n   Sections 6.1 through 6.15 for details
      on the construction and use of\n   each message):\n   Control Connection Management\n
      \      0  (reserved)\n       1  (SCCRQ)    Start-Control-Connection-Request\n
      \      2  (SCCRP)    Start-Control-Connection-Reply\n       3  (SCCCN)    Start-Control-Connection-Connected\n
      \      4  (StopCCN)  Stop-Control-Connection-Notification\n       5  (reserved)\n
      \      6  (HELLO)    Hello\n      20  (ACK)      Explicit Acknowledgement\n
      \  Call Management\n       7  (OCRQ)     Outgoing-Call-Request\n       8  (OCRP)
      \    Outgoing-Call-Reply\n       9  (OCCN)     Outgoing-Call-Connected\n      10
      \ (ICRQ)     Incoming-Call-Request\n      11  (ICRP)     Incoming-Call-Reply\n
      \     12  (ICCN)     Incoming-Call-Connected\n      13  (reserved)\n      14
      \ (CDN)      Call-Disconnect-Notify\n   Error Reporting\n      15  (WEN)      WAN-Error-Notify\n
      \  Link Status Change Reporting\n      16  (SLI)      Set-Link-Info\n"
    title: 3.1.  Control Message Types
  - contents:
    - "3.2.  L2TP Header Formats\n   This section defines header formats for L2TP
      control messages and\n   L2TP data messages.  All values are placed into their
      respective\n   fields and sent in network order (high-order octets first).\n"
    - contents:
      - "3.2.1.  L2TP Control Message Header\n   The L2TP control message header provides
        information for the reliable\n   transport of messages that govern the establishment,
        maintenance, and\n   teardown of L2TP sessions.  By default, control messages
        are sent\n   over the underlying media in-band with L2TP data messages.\n
        \  The L2TP control message header is formatted as follows:\n                 Figure
        3.2.1: L2TP Control Message Header\n    0                   1                   2
        \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |T|L|x|x|S|x|x|x|x|x|x|x|  Ver  |             Length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                     Control Connection ID                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |               Ns              |               Nr              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  The T bit MUST be set to 1, indicating that this is a control\n   message.\n
        \  The L and S bits MUST be set to 1, indicating that the Length field\n   and
        sequence numbers are present.\n   The x bits are reserved for future extensions.
        \ All reserved bits\n   MUST be set to 0 on outgoing messages and ignored
        on incoming\n   messages.\n   The Ver field indicates the version of the L2TP
        control message\n   header described in this document.  On sending, this field
        MUST be\n   set to 3 for all messages (unless operating in an environment
        that\n   includes L2TPv2 [RFC2661] and/or L2F [RFC2341] as well, see Section\n
        \  4.1 for details).\n   The Length field indicates the total length of the
        message in octets,\n   always calculated from the start of the control message
        header itself\n   (beginning with the T bit).\n   The Control Connection ID
        field contains the identifier for the\n   control connection.  L2TP control
        connections are named by\n   identifiers that have local significance only.
        \ That is, the same\n   control connection will be given unique Control Connection
        IDs by\n   each LCCE from within each endpoint's own Control Connection ID\n
        \  number space.  As such, the Control Connection ID in each message is\n
        \  that of the intended recipient, not the sender.  Non-zero Control\n   Connection
        IDs are selected and exchanged as Assigned Control\n   Connection ID AVPs
        during the creation of a control connection.\n   Ns indicates the sequence
        number for this control message, beginning\n   at zero and incrementing by
        one (modulo 2**16) for each message sent.\n   See Section 4.2 for more information
        on using this field.\n   Nr indicates the sequence number expected in the
        next control message\n   to be received.  Thus, Nr is set to the Ns of the
        last in-order\n   message received plus one (modulo 2**16).  See Section 4.2
        for more\n   information on using this field.\n"
      title: 3.2.1.  L2TP Control Message Header
    - contents:
      - "3.2.2.  L2TP Data Message\n   In general, an L2TP data message consists of
        a (1) Session Header,\n   (2) an optional L2-Specific Sublayer, and (3) the
        Tunnel Payload, as\n   depicted below.\n                  Figure 3.2.2: L2TP
        Data Message Header\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                      L2TP Session Header                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                      L2-Specific Sublayer                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                        Tunnel Payload                      ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  The L2TP Session Header is specific to the encapsulating PSN over\n   which
        the L2TP traffic is delivered.  The Session Header MUST provide\n   (1) a
        method of distinguishing traffic among multiple L2TP data\n   sessions and
        (2) a method of distinguishing data messages from\n   control messages.\n
        \  Each type of encapsulating PSN MUST define its own session header,\n   clearly
        identifying the format of the header and parameters necessary\n   to setup
        the session.  Section 4.1 defines two session headers, one\n   for transport
        over UDP and one for transport over IP.\n   The L2-Specific Sublayer is an
        intermediary layer between the L2TP\n   session header and the start of the
        tunneled frame.  It contains\n   control fields that are used to facilitate
        the tunneling of each\n   frame (e.g., sequence numbers or flags).  The Default
        L2-Specific\n   Sublayer for L2TPv3 is defined in Section 4.6.\n   The Data
        Message Header is followed by the Tunnel Payload, including\n   any necessary
        L2 framing as defined in the payload-specific companion\n   documents.\n"
      title: 3.2.2.  L2TP Data Message
    title: 3.2.  L2TP Header Formats
  - contents:
    - "3.3.  Control Connection Management\n   The L2TP control connection handles
      dynamic establishment, teardown,\n   and maintenance of the L2TP sessions and
      of the control connection\n   itself.  The reliable delivery of control messages
      is described in\n   Section 4.2.\n   This section describes typical control
      connection establishment and\n   teardown exchanges.  It is important to note
      that, in the diagrams\n   that follow, the reliable control message delivery
      mechanism exists\n   independently of the L2TP state machine.  For instance,
      Explicit\n   Acknowledgement (ACK) messages may be sent after any of the control\n
      \  messages indicated in the exchanges below if an acknowledgment is not\n   piggybacked
      on a later control message.\n   LCCEs are identified during control connection
      establishment either\n   by the Host Name AVP, the Router ID AVP, or a combination
      of the two\n   (see Section 5.4.3).  The identity of a peer LCCE is central
      to\n   selecting proper configuration parameters (i.e., Hello interval,\n   window
      size, etc.) for a control connection, as well as for\n   determining how to
      set up associated sessions within the control\n   connection, password lookup
      for control connection authentication,\n   control connection level tie breaking,
      etc.\n"
    - contents:
      - "3.3.1.  Control Connection Establishment\n   Establishment of the control
        connection involves an exchange of AVPs\n   that identifies the peer and its
        capabilities.\n   A three-message exchange is used to establish the control
        connection.\n   The following is a typical message exchange:\n      LCCE A
        \     LCCE B\n      ------      ------\n      SCCRQ ->\n                  <-
        SCCRP\n      SCCCN ->\n"
      title: 3.3.1.  Control Connection Establishment
    - contents:
      - "3.3.2.  Control Connection Teardown\n   Control connection teardown may be
        initiated by either LCCE and is\n   accomplished by sending a single StopCCN
        control message.  As part of\n   the reliable control message delivery mechanism,
        the recipient of a\n   StopCCN MUST send an ACK message to acknowledge receipt
        of the\n   message and maintain enough control connection state to properly\n
        \  accept StopCCN retransmissions over at least a full retransmission\n   cycle
        (in case the ACK message is lost).  The recommended time for a\n   full retransmission
        cycle is at least 31 seconds (see Section 4.2).\n   The following is an example
        of a typical control message exchange:\n      LCCE A      LCCE B\n      ------
        \     ------\n      StopCCN ->\n      (Clean up)\n                  (Wait)\n
        \                 (Clean up)\n   An implementation may shut down an entire
        control connection and all\n   sessions associated with the control connection
        by sending the\n   StopCCN.  Thus, it is not necessary to clear each session\n
        \  individually when tearing down the whole control connection.\n"
      title: 3.3.2.  Control Connection Teardown
    title: 3.3.  Control Connection Management
  - contents:
    - "3.4.  Session Management\n   After successful control connection establishment,
      individual\n   sessions may be created.  Each session corresponds to a single
      data\n   stream between the two LCCEs.  This section describes the typical\n
      \  call establishment and teardown exchanges.\n"
    - contents:
      - "3.4.1.  Session Establishment for an Incoming Call\n   A three-message exchange
        is used to establish the session.  The\n   following is a typical sequence
        of events:\n      LCCE A      LCCE B\n      ------      ------\n      (Call\n
        \      Detected)\n      ICRQ ->\n                 <- ICRP\n      (Call\n       Accepted)\n
        \     ICCN ->\n"
      title: 3.4.1.  Session Establishment for an Incoming Call
    - contents:
      - "3.4.2.  Session Establishment for an Outgoing Call\n   A three-message exchange
        is used to set up the session.  The\n   following is a typical sequence of
        events:\n      LCCE A      LCCE B\n      ------      ------\n                 <-
        OCRQ\n      OCRP ->\n      (Perform\n       Call\n       Operation)\n      OCCN
        ->\n      (Call Operation\n       Completed\n       Successfully)\n"
      title: 3.4.2.  Session Establishment for an Outgoing Call
    - contents:
      - "3.4.3.  Session Teardown\n   Session teardown may be initiated by either
        the LAC or LNS and is\n   accomplished by sending a CDN control message.  After
        the last\n   session is cleared, the control connection MAY be torn down as
        well\n   (and typically is).  The following is an example of a typical control\n
        \  message exchange:\n      LCCE A      LCCE B\n      ------      ------\n
        \     CDN ->\n      (Clean up)\n                  (Clean up)\n"
      title: 3.4.3.  Session Teardown
    title: 3.4.  Session Management
  title: 3.  Protocol Overview
- contents:
  - '4.  Protocol Operation

    '
  - contents:
    - "4.1.  L2TP Over Specific Packet-Switched Networks (PSNs)\n   L2TP may operate
      over a variety of PSNs.  There are two modes\n   described for operation over
      IP, L2TP directly over IP (see Section\n   4.1.1) and L2TP over UDP (see Section
      4.1.2).  L2TPv3 implementations\n   MUST support L2TP over IP and SHOULD support
      L2TP over UDP for better\n   NAT and firewall traversal, and for easier migration
      from L2TPv2.\n   L2TP over other PSNs may be defined, but the specifics are
      outside\n   the scope of this document.  Examples of L2TPv2 over other PSNs\n
      \  include [RFC3070] and [RFC3355].\n   The following field definitions are
      defined for use in all L2TP\n   Session Header encapsulations.\n   Session ID\n
      \     A 32-bit field containing a non-zero identifier for a session.\n      L2TP
      sessions are named by identifiers that have local\n      significance only.
      \ That is, the same logical session will be\n      given different Session IDs
      by each end of the control connection\n      for the life of the session.  When
      the L2TP control connection is\n      used for session establishment, Session
      IDs are selected and\n      exchanged as Local Session ID AVPs during the creation
      of a\n      session.  The Session ID alone provides the necessary context for\n
      \     all further packet processing, including the presence, size, and\n      value
      of the Cookie, the type of L2-Specific Sublayer, and the\n      type of payload
      being tunneled.\n   Cookie\n      The optional Cookie field contains a variable-length
      value\n      (maximum 64 bits) used to check the association of a received data\n
      \     message with the session identified by the Session ID.  The Cookie\n      MUST
      be set to the configured or signaled random value for this\n      session.  The
      Cookie provides an additional level of guarantee\n      that a data message
      has been directed to the proper session by the\n      Session ID.  A well-chosen
      Cookie may prevent inadvertent\n      misdirection of stray packets with recently
      reused Session IDs,\n      Session IDs subject to packet corruption, etc.  The
      Cookie may\n      also provide protection against some specific malicious packet\n
      \     insertion attacks, as described in Section 8.2.\n      When the L2TP control
      connection is used for session\n      establishment, random Cookie values are
      selected and exchanged as\n      Assigned Cookie AVPs during session creation.\n"
    - contents:
      - "4.1.1.  L2TPv3 over IP\n   L2TPv3 over IP (both versions) utilizes the IANA-assigned
        IP protocol\n   ID 115.\n"
      - contents:
        - "4.1.1.1.  L2TPv3 Session Header Over IP\n   Unlike L2TP over UDP, the L2TPv3
          session header over IP is free of\n   any restrictions imposed by coexistence
          with L2TPv2 and L2F.  As\n   such, the header format has been designed to
          optimize packet\n   processing.  The following session header format is
          utilized when\n   operating L2TPv3 over IP:\n               Figure 4.1.1.1:
          L2TPv3 Session Header Over IP\n    0                   1                   2
          \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
          3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |                           Session ID                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |               Cookie (optional, maximum 64 bits)...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \                                                                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  The Session ID and Cookie fields are as defined in Section 4.1.  The\n
          \  Session ID of zero is reserved for use by L2TP control messages (see\n
          \  Section 4.1.1.2).\n"
        title: 4.1.1.1.  L2TPv3 Session Header Over IP
      - contents:
        - "4.1.1.2.  L2TP Control and Data Traffic over IP\n   Unlike L2TP over UDP,
          which uses the T bit to distinguish between\n   L2TP control and data packets,
          L2TP over IP uses the reserved Session\n   ID of zero (0) when sending control
          messages.  It is presumed that\n   checking for the zero Session ID is more
          efficient -- both in header\n   size for data packets and in processing
          speed for distinguishing\n   between control and data messages -- than checking
          a single bit.\n   The entire control message header over IP, including the
          zero session\n   ID, appears as follows:\n           Figure 4.1.1.2: L2TPv3
          Control Message Header Over IP\n    0                   1                   2
          \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
          3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |                      (32 bits of zeros)                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |T|L|x|x|S|x|x|x|x|x|x|x|  Ver  |             Length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |                     Control Connection ID                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |               Ns              |               Nr              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  Named fields are as defined in Section 3.2.1.  Note that the Length\n
          \  field is still calculated from the beginning of the control message\n
          \  header, beginning with the T bit.  It does NOT include the \"(32 bits\n
          \  of zeros)\" depicted above.\n   When operating directly over IP, L2TP
          packets lose the ability to\n   take advantage of the UDP checksum as a
          simple packet integrity\n   check, which is of particular concern for L2TP
          control messages.\n   Control Message Authentication (see Section 4.3),
          even with an empty\n   password field, provides for a sufficient packet
          integrity check and\n   SHOULD always be enabled.\n"
        title: 4.1.1.2.  L2TP Control and Data Traffic over IP
      title: 4.1.1.  L2TPv3 over IP
    - contents:
      - "4.1.2.  L2TP over UDP\n   L2TPv3 over UDP must consider other L2 tunneling
        protocols that may\n   be operating in the same environment, including L2TPv2
        [RFC2661] and\n   L2F [RFC2341].\n   While there are efficiencies gained by
        running L2TP directly over IP,\n   there are possible side effects as well.
        \ For instance, L2TP over IP\n   is not as NAT-friendly as L2TP over UDP.\n"
      - contents:
        - "4.1.2.1.  L2TP Session Header Over UDP\n   The following session header
          format is utilized when operating L2TPv3\n   over UDP:\n              Figure
          4.1.2.1: L2TPv3 Session Header over UDP\n    0                   1                   2
          \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
          3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |T|x|x|x|x|x|x|x|x|x|x|x|  Ver  |          Reserved             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |                           Session ID                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |               Cookie (optional, maximum 64 bits)...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \                                                                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  The T bit MUST be set to 0, indicating that this is a data message.\n
          \  The x bits and Reserved field are reserved for future extensions.\n   All
          reserved values MUST be set to 0 on outgoing messages and ignored\n   on
          incoming messages.\n   The Ver field MUST be set to 3, indicating an L2TPv3
          message.\n   Note that the initial bits 1, 4, 6, and 7 have meaning in L2TPv2\n
          \  [RFC2661], and are deprecated and marked as reserved in L2TPv3.\n   Thus,
          for UDP mode on a system that supports both versions of L2TP,\n   it is
          important that the Ver field be inspected first to determine\n   the Version
          of the header before acting upon any of these bits.\n   The Session ID and
          Cookie fields are as defined in Section 4.1.\n"
        title: 4.1.2.1.  L2TP Session Header Over UDP
      - contents:
        - "4.1.2.2.  UDP Port Selection\n   The method for UDP Port Selection defined
          in this section is\n   identical to that defined for L2TPv2 [RFC2661].\n
          \  When negotiating a control connection over UDP, control messages MUST\n
          \  be sent as UDP datagrams using the registered UDP port 1701\n   [RFC1700].
          \ The initiator of an L2TP control connection picks an\n   available source
          UDP port (which may or may not be 1701) and sends to\n   the desired destination
          address at port 1701.  The recipient picks a\n   free port on its own system
          (which may or may not be 1701) and sends\n   its reply to the initiator's
          UDP port and address, setting its own\n   source port to the free port it
          found.\n   Any subsequent traffic associated with this control connection\n
          \  (either control traffic or data traffic from a session established\n
          \  through this control connection) must use these same UDP ports.\n   It
          has been suggested that having the recipient choose an arbitrary\n   source
          port (as opposed to using the destination port in the packet\n   initiating
          the control connection, i.e., 1701) may make it more\n   difficult for L2TP
          to traverse some NAT devices.  Implementations\n   should consider the potential
          implication of this capability before\n   choosing an arbitrary source port.
          \ A NAT device that can pass TFTP\n   traffic with variant UDP ports should
          be able to pass L2TP UDP\n   traffic since both protocols employ similar
          policies with regard to\n   UDP port selection.\n"
        title: 4.1.2.2.  UDP Port Selection
      - contents:
        - "4.1.2.3.  UDP Checksum\n   The tunneled frames that L2TP carry often have
          their own checksums or\n   integrity checks, rendering the UDP checksum
          redundant for much of\n   the L2TP data message contents.  Thus, UDP checksums
          MAY be disabled\n   in order to reduce the associated packet processing
          burden at the\n   L2TP endpoints.\n   The L2TP header itself does not have
          its own checksum or integrity\n   check.  However, use of the L2TP Session
          ID and Cookie pair guards\n   against accepting an L2TP data message if
          corruption of the Session\n   ID or associated Cookie has occurred.  When
          the L2-Specific Sublayer\n   is present in the L2TP header, there is no
          built-in integrity check\n   for the information contained therein if UDP
          checksums or some other\n   integrity check is not employed.  IPsec (see
          Section 4.1.3) may be\n   used for strong integrity protection of the entire
          contents of L2TP\n   data messages.\n   UDP checksums MUST be enabled for
          L2TP control messages.\n"
        title: 4.1.2.3.  UDP Checksum
      title: 4.1.2.  L2TP over UDP
    - contents:
      - "4.1.3.  L2TP and IPsec\n   The L2TP data channel does not provide cryptographic
        security of any\n   kind.  If the L2TP data channel operates over a public
        or untrusted\n   IP network where privacy of the L2TP data is of concern or\n
        \  sophisticated attacks against L2TP are expected to occur, IPsec\n   [RFC2401]
        MUST be made available to secure the L2TP traffic.\n   Either L2TP over UDP
        or L2TP over IP may be secured with IPsec.\n   [RFC3193] defines the recommended
        method for securing L2TPv2.  L2TPv3\n   possesses identical characteristics
        to IPsec as L2TPv2 when running\n   over UDP and implementations MUST follow
        the same recommendation.\n   When operating over IP directly, [RFC3193] still
        applies, though\n   references to UDP source and destination ports (in particular,
        those\n   in Section 4, \"IPsec Filtering details when protecting L2TP\")
        may be\n   ignored.  Instead, the selectors used to identify L2TPv3 traffic
        are\n   simply the source and destination IP addresses for the tunnel\n   endpoints
        together with the L2TPv3 IP protocol type, 115.\n   In addition to IP transport
        security, IPsec defines a mode of\n   operation that allows tunneling of IP
        packets.  The packet-level\n   encryption and authentication provided by IPsec
        tunnel mode and that\n   provided by L2TP secured with IPsec provide an equivalent
        level of\n   security for these requirements.\n   IPsec also defines access
        control features that are required of a\n   compliant IPsec implementation.
        \ These features allow filtering of\n   packets based upon network and transport
        layer characteristics such\n   as IP address, ports, etc.  In the L2TP tunneling
        model, analogous\n   filtering may be performed at the network layer above
        L2TP.  These\n   network layer access control features may be handled at an
        LCCE via\n   vendor-specific authorization features, or at the network layer\n
        \  itself by using IPsec transport mode end-to-end between the\n   communicating
        hosts.  The requirements for access control mechanisms\n   are not a part
        of the L2TP specification, and as such, are outside\n   the scope of this
        document.\n   Protecting the L2TP packet stream with IPsec does, in turn,
        also\n   protect the data within the tunneled session packets while\n   transported
        from one LCCE to the other.  Such protection must not be\n   considered a
        substitution for end-to-end security between\n   communicating hosts or applications.\n"
      title: 4.1.3.  L2TP and IPsec
    - contents:
      - "4.1.4.  IP Fragmentation Issues\n   Fragmentation and reassembly in network
        equipment generally require\n   significantly greater resources than sending
        or receiving a packet as\n   a single unit.  As such, fragmentation and reassembly
        should be\n   avoided whenever possible.  Ideal solutions for avoiding\n   fragmentation
        include proper configuration and management of MTU\n   sizes among the Remote
        System, the LCCE, and the IP network, as well\n   as adaptive measures that
        operate with the originating host (e.g.,\n   [RFC1191], [RFC1981]) to reduce
        the packet sizes at the source.\n   An LCCE MAY fragment a packet before encapsulating
        it in L2TP.  For\n   example, if an IPv4 packet arrives at an LCCE from a
        Remote System\n   that, after encapsulation with its associated framing, L2TP,
        and IP,\n   does not fit in the available path MTU towards its LCCE peer,
        the\n   local LCCE may perform IPv4 fragmentation on the packet before tunnel\n
        \  encapsulation.  This creates two (or more) L2TP packets, each\n   carrying
        an IPv4 fragment with its associated framing.  This\n   ultimately has the
        effect of placing the burden of fragmentation on\n   the LCCE, while reassembly
        occurs on the IPv4 destination host.\n   If an IPv6 packet arrives at an LCCE
        from a Remote System that, after\n   encapsulation with associated framing,
        L2TP and IP, does not fit in\n   the available path MTU towards its L2TP peer,
        the Generic Packet\n   Tunneling specification [RFC2473], Section 7.1 SHOULD
        be followed.\n   In this case, the LCCE should either send an ICMP Packet
        Too Big\n   message to the data source, or fragment the resultant L2TP/IP
        packet\n   (for reassembly by the L2TP peer).\n   If the amount of traffic
        requiring fragmentation and reassembly is\n   rather light, or there are sufficiently
        optimized mechanisms at the\n   tunnel endpoints, fragmentation of the L2TP/IP
        packet may be\n   sufficient for accommodating mismatched MTUs that cannot
        be managed\n   by more efficient means.  This method effectively emulates
        a larger\n   MTU between tunnel endpoints and should work for any type of
        L2-\n   encapsulated packet.  Note that IPv6 does not support \"in-flight\"\n
        \  fragmentation of data packets.  Thus, unlike IPv4, the MTU of the\n   path
        towards an L2TP peer must be known in advance (or the last\n   resort IPv6
        minimum MTU of 1280 bytes utilized) so that IPv6\n   fragmentation may occur
        at the LCCE.\n   In summary, attempting to control the source MTU by communicating\n
        \  with the originating host, forcing that an MTU be sufficiently large\n
        \  on the path between LCCE peers to tunnel a frame from any other\n   interface
        without fragmentation, fragmenting IP packets before\n   encapsulation with
        L2TP/IP, or fragmenting the resultant L2TP/IP\n   packet between the tunnel
        endpoints, are all valid methods for\n   managing MTU mismatches.  Some are
        clearly better than others\n   depending on the given deployment.  For example,
        a passive monitoring\n   application using L2TP would certainly not wish to
        have ICMP messages\n   sent to a traffic source.  Further, if the links connecting
        a set of\n   LCCEs have a very large MTU (e.g., SDH/SONET) and it is known
        that\n   the MTU of all links being tunneled by L2TP have smaller MTUs (e.g.,\n
        \  1500 bytes), then any IP fragmentation and reassembly enabled on the\n
        \  participating LCCEs would never be utilized.  An implementation MUST\n
        \  implement at least one of the methods described in this section for\n   managing
        mismatched MTUs, based on careful consideration of how the\n   final product
        will be deployed.\n   L2TP-specific fragmentation and reassembly methods,
        which may or may\n   not depend on the characteristics of the type of link
        being tunneled\n   (e.g., judicious packing of ATM cells), may be defined
        as well, but\n   these methods are outside the scope of this document.\n"
      title: 4.1.4.  IP Fragmentation Issues
    title: 4.1.  L2TP Over Specific Packet-Switched Networks (PSNs)
  - contents:
    - "4.2.  Reliable Delivery of Control Messages\n   L2TP provides a lower level
      reliable delivery service for all control\n   messages.  The Nr and Ns fields
      of the control message header (see\n   Section 3.2.1) belong to this delivery
      mechanism.  The upper level\n   functions of L2TP are not concerned with retransmission
      or ordering\n   of control messages.  The reliable control messaging mechanism
      is a\n   sliding window mechanism that provides control message retransmission\n
      \  and congestion control.  Each peer maintains separate sequence number\n   state
      for each control connection.\n   The message sequence number, Ns, begins at
      0.  Each subsequent\n   message is sent with the next increment of the sequence
      number.  The\n   sequence number is thus a free-running counter represented
      modulo\n   65536.  The sequence number in the header of a received message is\n
      \  considered less than or equal to the last received number if its\n   value
      lies in the range of the last received number and the preceding\n   32767 values,
      inclusive.  For example, if the last received sequence\n   number was 15, then
      messages with sequence numbers 0 through 15, as\n   well as 32784 through 65535,
      would be considered less than or equal.\n   Such a message would be considered
      a duplicate of a message already\n   received and ignored from processing.  However,
      in order to ensure\n   that all messages are acknowledged properly (particularly
      in the case\n   of a lost ACK message), receipt of duplicate messages MUST be\n
      \  acknowledged by the reliable delivery mechanism.  This acknowledgment\n   may
      either piggybacked on a message in queue or sent explicitly via\n   an ACK message.\n
      \  All control messages take up one slot in the control message sequence\n   number
      space, except the ACK message.  Thus, Ns is not incremented\n   after an ACK
      message is sent.\n   The last received message number, Nr, is used to acknowledge
      messages\n   received by an L2TP peer.  It contains the sequence number of the\n
      \  message the peer expects to receive next (e.g., the last Ns of a\n   non-ACK
      message received plus 1, modulo 65536).  While the Nr in a\n   received ACK
      message is used to flush messages from the local\n   retransmit queue (see below),
      the Nr of the next message sent is not\n   updated by the Ns of the ACK message.
      \ Nr SHOULD be sanity-checked\n   before flushing the retransmit queue.  For
      instance, if the Nr\n   received in a control message is greater than the last
      Ns sent plus 1\n   modulo 65536, the control message is clearly invalid.\n   The
      reliable delivery mechanism at a receiving peer is responsible\n   for making
      sure that control messages are delivered in order and\n   without duplication
      to the upper level.  Messages arriving out-of-\n   order may be queued for in-order
      delivery when the missing messages\n   are received.  Alternatively, they may
      be discarded, thus requiring a\n   retransmission by the peer.  When dropping
      out-of-order control\n   packets, Nr MAY be updated before the packet is discarded.\n
      \  Each control connection maintains a queue of control messages to be\n   transmitted
      to its peer.  The message at the front of the queue is\n   sent with a given
      Ns value and is held until a control message\n   arrives from the peer in which
      the Nr field indicates receipt of this\n   message.  After a period of time
      (a recommended default is 1 second\n   but SHOULD be configurable) passes without
      acknowledgment, the\n   message is retransmitted.  The retransmitted message
      contains the\n   same Ns value, but the Nr value MUST be updated with the sequence\n
      \  number of the next expected message.\n   Each subsequent retransmission of
      a message MUST employ an\n   exponential backoff interval.  Thus, if the first
      retransmission\n   occurred after 1 second, the next retransmission should occur
      after 2\n   seconds has elapsed, then 4 seconds, etc.  An implementation MAY\n
      \  place a cap upon the maximum interval between retransmissions.  This\n   cap
      SHOULD be no less than 8 seconds per retransmission.  If no peer\n   response
      is detected after several retransmissions (a recommended\n   default is 10,
      but MUST be configurable), the control connection and\n   all associated sessions
      MUST be cleared.  As it is the first message\n   to establish a control connection,
      the SCCRQ MAY employ a different\n   retransmission maximum than other control
      messages in order to help\n   facilitate failover to alternate LCCEs in a timely
      fashion.\n   When a control connection is being shut down for reasons other
      than\n   loss of connectivity, the state and reliable delivery mechanisms MUST\n
      \  be maintained and operated for the full retransmission interval after\n   the
      final message StopCCN message has been sent (e.g., 1 + 2 + 4 + 8\n   + 8...
      seconds), or until the StopCCN message itself has been\n   acknowledged.\n   A
      sliding window mechanism is used for control message transmission\n   and retransmission.
      \ Consider two peers, A and B.  Suppose A\n   specifies a Receive Window Size
      AVP with a value of N in the SCCRQ or\n   SCCRP message.  B is now allowed to
      have a maximum of N outstanding\n   (i.e., unacknowledged) control messages.
      \ Once N messages have been\n   sent, B must wait for an acknowledgment from
      A that advances the\n   window before sending new control messages.  An implementation
      may\n   advertise a non-zero receive window as small or as large as it\n   wishes,
      depending on its own ability to process incoming messages\n   before sending
      an acknowledgement.  Each peer MUST limit the number\n   of unacknowledged messages
      it will send before receiving an\n   acknowledgement by this Receive Window
      Size.  The actual internal\n   unacknowledged message send-queue depth may be
      further limited by\n   local resource allocation or by dynamic slow-start and
      congestion-\n   avoidance mechanisms.\n   When retransmitting control messages,
      a slow start and congestion\n   avoidance window adjustment procedure SHOULD
      be utilized.  A\n   recommended procedure is described in Appendix A.  A peer
      MAY drop\n   messages, but MUST NOT actively delay acknowledgment of messages
      as a\n   technique for flow control of control messages.  Appendix B contains\n
      \  examples of control message transmission, acknowledgment, and\n   retransmission.\n"
    title: 4.2.  Reliable Delivery of Control Messages
  - contents:
    - "4.3.  Control Message Authentication\n   L2TP incorporates an optional authentication
      and integrity check for\n   all control messages.  This mechanism consists of
      a computed one-way\n   hash over the header and body of the L2TP control message,
      a pre-\n   configured shared secret, and a local and remote nonce (random value)\n
      \  exchanged via the Control Message Authentication Nonce AVP. This\n   per-message
      authentication and integrity check is designed to perform\n   a mutual authentication
      between L2TP nodes, perform integrity\n   checking of all control messages,
      and guard against control message\n   spoofing and replay attacks that would
      otherwise be trivial to mount.\n   At least one shared secret (password) MUST
      exist between\n   communicating L2TP nodes to enable Control Message Authentication.\n
      \  See Section 5.4.3 for details on calculation of the Message Digest\n   and
      construction of the Control Message Authentication Nonce and\n   Message Digest
      AVPs.\n   L2TPv3 Control Message Authentication is similar to L2TPv2 [RFC2661]\n
      \  Tunnel Authentication in its use of a shared secret and one-way hash\n   calculation.
      \ The principal difference is that, instead of computing\n   the hash over selected
      contents of a received control message (e.g.,\n   the Challenge AVP and Message
      Type) as in L2TPv2, the entire message\n   is used in the hash in L2TPv3.  In
      addition, instead of including the\n   hash digest in just the SCCRP and SCCCN
      messages, it is now included\n   in all L2TP messages.\n   The Control Message
      Authentication mechanism is optional, and may be\n   disabled if both peers
      agree.  For example, if IPsec is already being\n   used for security and integrity
      checking between the LCCEs, the\n   function of the L2TP mechanism becomes redundant
      and may be disabled.\n   Presence of the Control Message Authentication Nonce
      AVP in an SCCRQ\n   or SCCRP message serves as indication to a peer that Control
      Message\n   Authentication is enabled.  If an SCCRQ or SCCRP contains a Control\n
      \  Message Authentication Nonce AVP, the receiver of the message MUST\n   respond
      with a Message Digest AVP in all subsequent messages sent.\n   Control Message
      Authentication is always bidirectional; either both\n   sides participate in
      authentication, or neither does.\n   If Control Message Authentication is disabled,
      the Message Digest AVP\n   still MAY be sent as an integrity check of the message.
      \ The\n   integrity check is calculated as in Section 5.4.3, with an empty\n
      \  zero-length shared secret, local nonce, and remote nonce.  If an\n   invalid
      Message Digest is received, it should be assumed that the\n   message has been
      corrupted in transit and the message dropped\n   accordingly.\n   Implementations
      MAY rate-limit control messages, particularly SCCRQ\n   messages, upon receipt
      for performance reasons or for protection\n   against denial of service attacks.\n"
    title: 4.3.  Control Message Authentication
  - contents:
    - "4.4.  Keepalive (Hello)\n   L2TP employs a keepalive mechanism to detect loss
      of connectivity\n   between a pair of LCCEs.  This is accomplished by injecting
      Hello\n   control messages (see Section 6.5) after a period of time has elapsed\n
      \  since the last data message or control message was received on an\n   L2TP
      session or control connection, respectively.  As with any other\n   control
      message, if the Hello message is not reliably delivered, the\n   sending LCCE
      declares that the control connection is down and resets\n   its state for the
      control connection.  This behavior ensures that a\n   connectivity failure between
      the LCCEs is detected independently by\n   each end of a control connection.\n
      \  Since the control channel is operated in-band with data traffic over\n   the
      PSN, this single mechanism can be used to infer basic data\n   connectivity
      between a pair of LCCEs for all sessions associated with\n   the control connection.\n
      \  Periodic keepalive for the control connection MUST be implemented by\n   sending
      a Hello if a period of time (a recommended default is 60\n   seconds, but MUST
      be configurable) has passed without receiving any\n   message (data or control)
      from the peer.  An LCCE sending Hello\n   messages across multiple control connections
      between the same LCCE\n   endpoints MUST employ a jittered timer mechanism to
      prevent grouping\n   of Hello messages.\n"
    title: 4.4.  Keepalive (Hello)
  - contents:
    - "4.5.  Forwarding Session Data Frames\n   Once session establishment is complete,
      circuit frames are received\n   at an LCCE, encapsulated in L2TP (with appropriate
      attention to\n   framing, as described in documents for the particular pseudowire\n
      \  type), and forwarded over the appropriate session.  For every\n   outgoing
      data message, the sender places the identifier specified in\n   the Local Session
      ID AVP (received from peer during session\n   establishment) in the Session
      ID field of the L2TP data header.  In\n   this manner, session frames are multiplexed
      and demultiplexed between\n   a given pair of LCCEs.  Multiple control connections
      may exist\n   between a given pair of LCCEs, and multiple sessions may be\n
      \  associated with a given control connection.\n   The peer LCCE receiving the
      L2TP data packet identifies the session\n   with which the packet is associated
      by the Session ID in the data\n   packet's header.  The LCCE then checks the
      Cookie field in the data\n   packet against the Cookie value received in the
      Assigned Cookie AVP\n   during session establishment.  It is important for implementers
      to\n   note that the Cookie field check occurs after looking up the session\n
      \  context by the Session ID, and as such, consists merely of a value\n   match
      of the Cookie field and that stored in the retrieved context.\n   There is no
      need to perform a lookup across the Session ID and Cookie\n   as a single value.
      \ Any received data packets that contain invalid\n   Session IDs or associated
      Cookie values MUST be dropped.  Finally,\n   the LCCE either forwards the network
      packet within the tunneled frame\n   (e.g., as an LNS) or switches the frame
      to a circuit (e.g., as an\n   LAC).\n"
    title: 4.5.  Forwarding Session Data Frames
  - contents:
    - "4.6.  Default L2-Specific Sublayer\n   This document defines a Default L2-Specific
      Sublayer format (see\n   Section 3.2.2) that a pseudowire may use for features
      such as\n   sequencing support, L2 interworking, OAM, or other per-data-packet\n
      \  operations.  The Default L2-Specific Sublayer SHOULD be used by a\n   given
      PW type to support these features if it is adequate, and its\n   presence is
      requested by a peer during session negotiation.\n   Alternative sublayers MAY
      be defined (e.g., an encapsulation with a\n   larger Sequence Number field or
      timing information) and identified\n   for use via the L2-Specific Sublayer
      Type AVP.\n              Figure 4.6: Default L2-Specific Sublayer Format\n    0
      \                  1                   2                   3\n    0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |x|S|x|x|x|x|x|x|              Sequence Number                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The S (Sequence) bit is set to 1 when the Sequence Number contains a\n   valid
      number for this sequenced frame.  If the S bit is set to zero,\n   the Sequence
      Number contents are undefined and MUST be ignored by the\n   receiver.\n   The
      Sequence Number field contains a free-running counter of 2^24\n   sequence numbers.
      \ If the number in this field is valid, the S bit\n   MUST be set to 1.  The
      Sequence Number begins at zero, which is a\n   valid sequence number.  (In this
      way, implementations inserting\n   sequence numbers do not have to \"skip\"
      zero when incrementing.)  The\n   sequence number in the header of a received
      message is considered\n   less than or equal to the last received number if
      its value lies in\n   the range of the last received number and the preceding
      (2^23-1)\n   values, inclusive.\n"
    - contents:
      - "4.6.1.  Sequencing Data Packets\n   The Sequence Number field may be used
        to detect lost, duplicate, or\n   out-of-order packets within a given session.\n
        \  When L2 frames are carried over an L2TP-over-IP or L2TP-over-UDP/IP\n   data
        channel, this part of the link has the characteristic of being\n   able to
        reorder, duplicate, or silently drop packets.  Reordering may\n   break some
        non-IP protocols or L2 control traffic being carried by\n   the link.  Silent
        dropping or duplication of packets may break\n   protocols that assume per-packet
        indications of error, such as TCP\n   header compression.  While a common
        mechanism for packet sequence\n   detection is provided, the sequence dependency
        characteristics of\n   individual protocols are outside the scope of this
        document.\n   If any protocol being transported by over L2TP data channels
        cannot\n   tolerate misordering of data packets, packet duplication, or silent\n
        \  packet loss, sequencing may be enabled on some or all packets by\n   using
        the S bit and Sequence Number field defined in the Default L2-\n   Specific
        Sublayer (see Section 4.6).  For a given L2TP session, each\n   LCCE is responsible
        for communicating to its peer the level of\n   sequencing support that it
        requires of data packets that it receives.\n   Mechanisms to advertise this
        information during session negotiation\n   are provided (see Data Sequencing
        AVP in Section 5.4.4).\n   When determining whether a packet is in or out
        of sequence, an\n   implementation SHOULD utilize a method that is resilient
        to temporary\n   dropouts in connectivity coupled with high per-session packet
        rates.\n   The recommended method is outlined in Appendix C.\n"
      title: 4.6.1.  Sequencing Data Packets
    title: 4.6.  Default L2-Specific Sublayer
  - contents:
    - "4.7.  L2TPv2/v3 Interoperability and Migration\n   L2TPv2 and L2TPv3 environments
      should be able to coexist while a\n   migration to L2TPv3 is made.  Migration
      issues are discussed for each\n   media type in this section.  Most issues apply
      only to\n   implementations that require both L2TPv2 and L2TPv3 operation.\n
      \  However, even L2TPv3-only implementations must at least be mindful of\n   these
      issues in order to interoperate with implementations that\n   support both versions.\n"
    - contents:
      - "4.7.1.  L2TPv3 over IP\n   L2TPv3 implementations running strictly over IP
        with no desire to\n   interoperate with L2TPv2 implementations may safely
        disregard most\n   migration issues from L2TPv2.  All control messages and
        data messages\n   are sent as described in this document, without normative
        reference\n   to RFC 2661.\n   If one wishes to tunnel PPP over L2TPv3, and
        fallback to L2TPv2 only\n   if it is not available, then L2TPv3 over UDP with
        automatic fallback\n   (see Section 4.7.3) MUST be used.  There is no deterministic
        method\n   for automatic fallback from L2TPv3 over IP to either L2TPv2 or
        L2TPv3\n   over UDP.  One could infer whether L2TPv3 over IP is supported
        by\n   sending an SCCRQ and waiting for a response, but this could be\n   problematic
        during periods of packet loss between L2TP nodes.\n"
      title: 4.7.1.  L2TPv3 over IP
    - contents:
      - "4.7.2.  L2TPv3 over UDP\n   The format of the L2TPv3 over UDP header is defined
        in Section\n   4.1.2.1.\n   When operating over UDP, L2TPv3 uses the same
        port (1701) as L2TPv2\n   and shares the first two octets of header format
        with L2TPv2.  The\n   Ver field is used to distinguish L2TPv2 packets from
        L2TPv3 packets.\n   If an implementation is capable of operating in L2TPv2
        or L2TPv3\n   modes, it is possible to automatically detect whether a peer
        can\n   support L2TPv2 or L2TPv3 and operate accordingly.  The details of\n
        \  this fallback capability is defined in the following section.\n"
      title: 4.7.2.  L2TPv3 over UDP
    - contents:
      - "4.7.3.  Automatic L2TPv2 Fallback\n   When running over UDP, an implementation
        may detect whether a peer is\n   L2TPv3-capable by sending a special SCCRQ
        that is properly formatted\n   for both L2TPv2 and L2TPv3.  This is accomplished
        by sending an SCCRQ\n   with its Ver field set to 2 (for L2TPv2), and ensuring
        that any\n   L2TPv3-specific AVPs (i.e., AVPs present within this document
        and not\n   defined within RFC 2661) in the message are sent with each M bit
        set\n   to 0, and that all L2TPv2 AVPs are present as they would be for\n
        \  L2TPv2.  This is done so that L2TPv3 AVPs will be ignored by an\n   L2TPv2-only
        implementation.  Note that, in both L2TPv2 and L2TPv3,\n   the value contained
        in the space of the control message header\n   utilized by the 32-bit Control
        Connection ID in L2TPv3, and the 16-\n   bit Tunnel ID and\n   16-bit Session
        ID in L2TPv2, are always 0 for an SCCRQ.  This\n   effectively hides the fact
        that there are a pair of 16-bit fields in\n   L2TPv2, and a single 32-bit
        field in L2TPv3.\n   If the peer implementation is L2TPv3-capable, a control
        message with\n   the Ver field set to 3 and an L2TPv3 header and message format
        will\n   be sent in response to the SCCRQ.  Operation may then continue as\n
        \  L2TPv3.  If a message is received with the Ver field set to 2, it\n   must
        be assumed that the peer implementation is L2TPv2-only, thus\n   enabling
        fallback to L2TPv2 mode to safely occur.\n   Note Well: The L2TPv2/v3 auto-detection
        mode requires that all L2TPv3\n   implementations over UDP be liberal in accepting
        an SCCRQ control\n   message with the Ver field set to 2 or 3 and the presence
        of L2TPv2-\n   specific AVPs.  An L2TPv3-only implementation MUST ignore all
        L2TPv2\n   AVPs (e.g., those defined in RFC 2661 and not in this document)\n
        \  within an SCCRQ with the Ver field set to 2 (even if the M bit is set\n
        \  on the L2TPv2-specific AVPs).\n"
      title: 4.7.3.  Automatic L2TPv2 Fallback
    title: 4.7.  L2TPv2/v3 Interoperability and Migration
  title: 4.  Protocol Operation
- contents:
  - "5.  Control Message Attribute Value Pairs\n   To maximize extensibility while
    permitting interoperability, a\n   uniform method for encoding message types is
    used throughout L2TP.\n   This encoding will be termed AVP (Attribute Value Pair)
    for the\n   remainder of this document.\n"
  - contents:
    - "5.1.  AVP Format\n   Each AVP is encoded as follows:\n                          Figure
      5.1: AVP Format\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |M|H| rsvd  |      Length       |           Vendor ID           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |         Attribute Type        |        Attribute Value ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                      (until Length is reached)                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The first six bits comprise a bit mask that describes the general\n   attributes
      of the AVP.  Two bits are defined in this document; the\n   remaining bits are
      reserved for future extensions.  Reserved bits\n   MUST be set to 0 when sent
      and ignored upon receipt.\n   Mandatory (M) bit: Controls the behavior required
      of an\n   implementation that receives an unrecognized AVP.  The M bit of a\n
      \  given AVP MUST only be inspected and acted upon if the AVP is\n   unrecognized
      (see Section 5.2).\n   Hidden (H) bit: Identifies the hiding of data in the
      Attribute Value\n   field of an AVP.  This capability can be used to avoid the
      passing of\n   sensitive data, such as user passwords, as cleartext in an AVP.\n
      \  Section 5.3 describes the procedure for performing AVP hiding.\n   Length:
      Contains the number of octets (including the Overall Length\n   and bit mask
      fields) contained in this AVP.  The Length may be\n   calculated as 6 + the
      length of the Attribute Value field in octets.\n   The field itself is 10 bits,
      permitting a maximum of 1023 octets of\n   data in a single AVP.  The minimum
      Length of an AVP is 6.  If the\n   Length is 6, then the Attribute Value field
      is absent.\n   Vendor ID: The IANA-assigned \"SMI Network Management Private\n
      \  Enterprise Codes\" [RFC1700] value.  The value 0, corresponding to\n   IETF-adopted
      attribute values, is used for all AVPs defined within\n   this document.  Any
      vendor wishing to implement its own L2TP\n   extensions can use its own Vendor
      ID along with private Attribute\n   values, guaranteeing that they will not
      collide with any other\n   vendor's extensions or future IETF extensions.  Note
      that there are\n   16 bits allocated for the Vendor ID, thus limiting this feature
      to\n   the first 65,535 enterprises.\n   Attribute Type: A 2-octet value with
      a unique interpretation across\n   all AVPs defined under a given Vendor ID.\n
      \  Attribute Value: This is the actual value as indicated by the Vendor\n   ID
      and Attribute Type.  It follows immediately after the Attribute\n   Type field
      and runs for the remaining octets indicated in the Length\n   (i.e., Length
      minus 6 octets of header).  This field is absent if the\n   Length is 6.\n   In
      the event that the 16-bit Vendor ID space is exhausted, vendor-\n   specific
      AVPs with a 32-bit Vendor ID MUST be encapsulated in the\n   following manner:\n
      \                Figure 5.2: Extended Vendor ID AVP Format\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |M|H| rsvd  |      Length       |               0               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |              58               |       32-bit Vendor ID     ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                                  |        Attribute Type         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                      Attribute Value                       ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                   (until Length is reached)                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  This AVP encodes a vendor-specific AVP with a 32-bit Vendor ID space\n   within
      the Attribute Value field.  Multiple AVPs of this type may\n   exist in any
      message.  The 16-bit Vendor ID MUST be 0, indicating\n   that this is an IETF-defined
      AVP, and the Attribute Type MUST be 58,\n   indicating that what follows is
      a vendor-specific AVP with a 32-bit\n   Vendor ID code.  This AVP MAY be hidden
      (the H bit MAY be 0 or 1).\n   The M bit for this AVP MUST be set to 0.  The
      Length of the AVP is 12\n   plus the length of the Attribute Value.\n"
    title: 5.1.  AVP Format
  - contents:
    - "5.2.  Mandatory AVPs and Setting the M Bit\n   If the M bit is set on an AVP
      that is unrecognized by its recipient,\n   the session or control connection
      associated with the control message\n   containing the AVP MUST be shut down.
      \ If the control message\n   containing the unrecognized AVP is associated with
      a session (e.g.,\n   an ICRQ, ICRP, ICCN, SLI, etc.), then the session MUST
      be issued a\n   CDN with a Result Code of 2 and Error Code of 8 (as defined
      in\n   Section 5.4.2) and shut down.  If the control message containing the\n
      \  unrecognized AVP is associated with establishment or maintenance of a\n   Control
      Connection (e.g., SCCRQ, SCCRP, SCCCN, Hello), then the\n   associated Control
      Connection MUST be issued a StopCCN with Result\n   Code of 2 and Error Code
      of 8 (as defined in Section 5.4.2) and shut\n   down.  If the M bit is not set
      on an unrecognized AVP, the AVP MUST\n   be ignored when received, processing
      the control message as if the\n   AVP were not present.\n   Receipt of an unrecognized
      AVP that has the M bit set is catastrophic\n   to the session or control connection
      with which it is associated.\n   Thus, the M bit should only be set for AVPs
      that are deemed crucial\n   to proper operation of the session or control connection
      by the\n   sender.  AVPs that are considered crucial by the sender may vary
      by\n   application and configured options.  In no case shall a receiver of\n
      \  an AVP \"validate\" if the M bit is set on a recognized AVP.  If the\n   AVP
      is recognized (as all AVPs defined in this document MUST be for a\n   compliant
      L2TPv3 specification), then by definition, the M bit is of\n   no consequence.\n
      \  The sender of an AVP is free to set its M bit to 1 or 0 based on\n   whether
      the configured application strictly requires the value\n   contained in the
      AVP to be recognized or not.  For example,\n   \"Automatic L2TPv2 Fallback\"
      in Section 4.7.3 requires the setting of\n   the M bit on all new L2TPv3 AVPs
      to zero if fallback to L2TPv2 is\n   supported and desired, and 1 if not.\n
      \  The M bit is useful as extra assurance for support of critical AVP\n   extensions.
      \ However, more explicit methods may be available to\n   determine support for
      a given feature rather than using the M bit\n   alone.  For example, if a new
      AVP is defined in a message for which\n   there is always a message reply (i.e.,
      an ICRQ, ICRP, SCCRQ, or SCCRP\n   message), rather than simply sending an AVP
      in the message with the M\n   bit set, availability of the extension may be
      identified by sending\n   an AVP in the request message and expecting a corresponding
      AVP in a\n   reply message.  This more explicit method, when possible, is\n
      \  preferred.\n   The M bit also plays a role in determining whether or not
      a malformed\n   or out-of-range value within an AVP should be ignored or should\n
      \  result in termination of a session or control connection (see Section\n   7.1
      for more details).\n"
    title: 5.2.  Mandatory AVPs and Setting the M Bit
  - contents:
    - "5.3.  Hiding of AVP Attribute Values\n   The H bit in the header of each AVP
      provides a mechanism to indicate\n   to the receiving peer whether the contents
      of the AVP are hidden or\n   present in cleartext.  This feature can be used
      to hide sensitive\n   control message data such as user passwords, IDs, or other
      vital\n   information.\n   The H bit MUST only be set if (1) a shared secret
      exists between the\n   LCCEs and (2) Control Message Authentication is enabled
      (see Section\n   4.3).  If the H bit is set in any AVP(s) in a given control
      message,\n   at least one Random Vector AVP must also be present in the message\n
      \  and MUST precede the first AVP having an H bit of 1.\n   The shared secret
      between LCCEs is used to derive a unique shared key\n   for hiding and unhiding
      calculations.  The derived shared key is\n   obtained via an HMAC-MD5 keyed
      hash [RFC2104], with the key\n   consisting of the shared secret, and with the
      data being hashed\n   consisting of a single octet containing the value 1.\n
      \        shared_key = HMAC_MD5 (shared_secret, 1)\n   Hiding an AVP value is
      done in several steps.  The first step is to\n   take the length and value fields
      of the original (cleartext) AVP and\n   encode them into the Hidden AVP Subformat,
      which appears as follows:\n                     Figure 5.3: Hidden AVP Subformat\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |   Length of Original Value    |   Original Attribute Value ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                 ...              |             Padding ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Length of Original Attribute Value: This is length of the Original\n   Attribute
      Value to be obscured in octets.  This is necessary to\n   determine the original
      length of the Attribute Value that is lost\n   when the additional Padding is
      added.\n   Original Attribute Value: Attribute Value that is to be obscured.\n
      \  Padding: Random additional octets used to obscure length of the\n   Attribute
      Value that is being hidden.\n   To mask the size of the data being hidden, the
      resulting subformat\n   MAY be padded as shown above.  Padding does NOT alter
      the value\n   placed in the Length of Original Attribute Value field, but does\n
      \  alter the length of the resultant AVP that is being created.  For\n   example,
      if an Attribute Value to be hidden is 4 octets in length,\n   the unhidden AVP
      length would be 10 octets (6 + Attribute Value\n   length).  After hiding, the
      length of the AVP would become 6 +\n   Attribute Value length + size of the
      Length of Original Attribute\n   Value field + Padding.  Thus, if Padding is
      12 octets, the AVP length\n   would be 6 + 4 + 2 + 12 = 24 octets.\n   Next,
      an MD5 [RFC1321] hash is performed (in network byte order) on\n   the concatenation
      of the following:\n         + the 2-octet Attribute number of the AVP\n         +
      the shared key\n         + an arbitrary length random vector\n   The value of
      the random vector used in this hash is passed in the\n   value field of a Random
      Vector AVP.  This Random Vector AVP must be\n   placed in the message by the
      sender before any hidden AVPs.  The same\n   random vector may be used for more
      than one hidden AVP in the same\n   message, but not for hiding two or more
      instances of an AVP with the\n   same Attribute Type unless the Attribute Values
      in the two AVPs are\n   also identical.  When a different random vector is used
      for the\n   hiding of subsequent AVPs, a new Random Vector AVP MUST be placed
      in\n   the control message before the first AVP to which it applies.\n   The
      MD5 hash value is then XORed with the first 16-octet (or less)\n   segment of
      the Hidden AVP Subformat and placed in the Attribute Value\n   field of the
      Hidden AVP.  If the Hidden AVP Subformat is less than 16\n   octets, the Subformat
      is transformed as if the Attribute Value field\n   had been padded to 16 octets
      before the XOR.  Only the actual octets\n   present in the Subformat are modified,
      and the length of the AVP is\n   not altered.\n   If the Subformat is longer
      than 16 octets, a second one-way MD5 hash\n   is calculated over a stream of
      octets consisting of the shared key\n   followed by the result of the first
      XOR.  That hash is XORed with the\n   second 16-octet (or less) segment of the
      Subformat and placed in the\n   corresponding octets of the Value field of the
      Hidden AVP.\n   If necessary, this operation is repeated, with the shared key
      used\n   along with each XOR result to generate the next hash to XOR the next\n
      \  segment of the value with.\n   The hiding method was adapted from [RFC2865],
      which was taken from\n   the \"Mixing in the Plaintext\" section in the book
      \"Network Security\"\n   by Kaufman, Perlman and Speciner [KPS].  A detailed
      explanation of\n   the method follows:\n   Call the shared key S, the Random
      Vector RV, and the Attribute Type\n   A.  Break the value field into 16-octet
      chunks p_1, p_2, etc., with\n   the last one padded at the end with random data
      to a 16-octet\n   boundary.  Call the ciphertext blocks c_1, c_2, etc.  We will
      also\n   define intermediate values b_1, b_2, etc.\n      b_1 = MD5 (A + S +
      RV)   c_1 = p_1 xor b_1\n      b_2 = MD5 (S + c_1)      c_2 = p_2 xor b_2\n
      \               .                      .\n                .                      .\n
      \               .                      .\n      b_i = MD5 (S + c_i-1)    c_i
      = p_i xor b_i\n   The String will contain c_1 + c_2 +...+ c_i, where \"+\" denotes\n
      \  concatenation.\n   On receipt, the random vector is taken from the last Random
      Vector\n   AVP encountered in the message prior to the AVP to be unhidden.  The\n
      \  above process is then reversed to yield the original value.\n"
    title: 5.3.  Hiding of AVP Attribute Values
  - contents:
    - "5.4.  AVP Summary\n   The following sections contain a list of all L2TP AVPs
      defined in\n   this document.\n   Following the name of the AVP is a list indicating
      the message types\n   that utilize each AVP.  After each AVP title follows a
      short\n   description of the purpose of the AVP, a detail (including a graphic)\n
      \  of the format for the Attribute Value, and any additional information\n   needed
      for proper use of the AVP.\n"
    - contents:
      - "5.4.1.  General Control Message AVPs\n   Message Type (All Messages)\n      The
        Message Type AVP, Attribute Type 0, identifies the control\n      message
        herein and defines the context in which the exact meaning\n      of the following
        AVPs will be determined.\n      The Attribute Value field for this AVP has
        the following format:\n       0                   1\n       0 1 2 3 4 5 6
        7 8 9 0 1 2 3 4 5\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |         Message
        Type          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      The Message
        Type is a 2-octet unsigned integer.\n      The Message Type AVP MUST be the
        first AVP in a message,\n      immediately following the control message header
        (defined in\n      Section 3.2.1).  See Section 3.1 for the list of defined
        control\n      message types and their identifiers.\n      The Mandatory (M)
        bit within the Message Type AVP has special\n      meaning.  Rather than an
        indication as to whether the AVP itself\n      should be ignored if not recognized,
        it is an indication as to\n      whether the control message itself should
        be ignored.  If the M\n      bit is set within the Message Type AVP and the
        Message Type is\n      unknown to the implementation, the control connection
        MUST be\n      cleared.  If the M bit is not set, then the implementation
        may\n      ignore an unknown message type.  The M bit MUST be set to 1 for\n
        \     all message types defined in this document.  This AVP MUST NOT be\n
        \     hidden (the H bit MUST be 0).  The Length of this AVP is 8.\n      A
        vendor-specific control message may be defined by setting the\n      Vendor
        ID of the Message Type AVP to a value other than the IETF\n      Vendor ID
        of 0 (see Section 5.1).  The Message Type AVP MUST still\n      be the first
        AVP in the control message.\n   Message Digest (All Messages)\n      The Message
        Digest AVP, Attribute Type 59 is used as an integrity\n      and authentication
        check of the L2TP Control Message header and\n      body.\n      The Attribute
        Value field for this AVP has the following format:\n       0                   1
        \                  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |  Digest Type  | Message Digest ...\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \                                       ... (16 or 20 octets)         |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     Digest Type is a one-octet integer indicating the Digest\n      calculation
        algorithm:\n         0 HMAC-MD5 [RFC2104]\n         1 HMAC-SHA-1 [RFC2104]\n
        \     Digest Type 0 (HMAC-MD5) MUST be supported, while Digest Type 1\n      (HMAC-SHA-1)
        SHOULD be supported.\n      The Message Digest is of variable length and contains
        the result\n      of the control message authentication and integrity calculation.\n
        \     For Digest Type 0 (HMAC-MD5), the length of the digest MUST be 16\n
        \     bytes.  For Digest Type 1 (HMAC-SHA-1) the length of the digest\n      MUST
        be 20 bytes.\n      If Control Message Authentication is enabled, at least
        one Message\n      Digest AVP MUST be present in all messages and MUST be
        placed\n      immediately after the Message Type AVP.  This forces the Message\n
        \     Digest AVP to begin at a well-known and fixed offset.  A second\n      Message
        Digest AVP MAY be present in a message and MUST be placed\n      directly
        after the first Message Digest AVP.\n      The shared secret between LCCEs
        is used to derive a unique shared\n      key for Control Message Authentication
        calculations.  The derived\n      shared key is obtained via an HMAC-MD5 keyed
        hash [RFC2104], with\n      the key consisting of the shared secret, and with
        the data being\n      hashed consisting of a single octet containing the value
        2.\n         shared_key = HMAC_MD5 (shared_secret, 2)\n      Calculation of
        the Message Digest is as follows for all messages\n      other than the SCCRQ
        (where \"+\" refers to concatenation):\n         Message Digest = HMAC_Hash
        (shared_key, local_nonce +\n                                     remote_nonce
        + control_message)\n         HMAC_Hash: HMAC Hashing algorithm identified
        by the Digest Type\n         (MD5 or SHA1)\n         local_nonce: Nonce chosen
        locally and advertised to the remote\n         LCCE.\n         remote_nonce:
        Nonce received from the remote LCCE\n         (The local_nonce and remote_nonce
        are advertised via the\n         Control Message Authentication Nonce AVP,
        also defined in this\n         section.)\n         shared_key: Derived shared
        key for this control connection\n         control_message: The entire contents
        of the L2TP control\n         message, including the control message header
        and all AVPs.\n         Note that the control message header in this case
        begins after\n         the all-zero Session ID when running over IP (see Section\n
        \        4.1.1.2), and after the UDP header when running over UDP (see\n         Section
        4.1.2.1).\n      When calculating the Message Digest, the Message Digest AVP
        MUST\n      be present within the control message with the Digest Type set
        to\n      its proper value, but the Message Digest itself set to zeros.\n
        \     When receiving a control message, the contents of the Message\n      Digest
        AVP MUST be compared against the expected digest value\n      based on local
        calculation.  This is done by performing the same\n      digest calculation
        above, with the local_nonce and remote_nonce\n      reversed.  This message
        authenticity and integrity checking MUST\n      be performed before utilizing
        any information contained within the\n      control message.  If the calculation
        fails, the message MUST be\n      dropped.\n      The SCCRQ has special treatment
        as it is the initial message\n      commencing a new control connection.  As
        such, there is only one\n      nonce available.  Since the nonce is present
        within the message\n      itself as part of the Control Message Authentication
        Nonce AVP,\n      there is no need to use it in the calculation explicitly.\n
        \     Calculation of the SCCRQ Message Digest is performed as follows:\n         Message
        Digest = HMAC_Hash (shared_key, control_message)\n      To allow for graceful
        switchover to a new shared secret or hash\n      algorithm, two Message Digest
        AVPs MAY be present in a control\n      message, and two shared secrets MAY
        be configured for a given\n      LCCE.  If two Message Digest AVPs are received
        in a control\n      message, the message MUST be accepted if either Message
        Digest is\n      valid.  If two shared secrets are configured, each (separately)\n
        \     MUST be used for calculating a digest to be compared to the\n      Message
        Digest(s) received.  When calculating a digest for a\n      control message,
        the Value field for both of the Message Digest\n      AVPs MUST be set to
        zero.\n      This AVP MUST NOT be hidden (the H bit MUST be 0).  The M bit
        for\n      this AVP SHOULD be set to 1, but MAY vary (see Section 5.2).  The\n
        \     Length is 23 for Digest Type 1 (HMAC-MD5), and 27 for Digest Type\n
        \     2 (HMAC-SHA-1).\n   Control Message Authentication Nonce (SCCRQ, SCCRP)\n
        \     The Control Message Authentication Nonce AVP, Attribute Type 73,\n      MUST
        contain a cryptographically random value [RFC1750].  This\n      value is
        used for Control Message Authentication.\n      The Attribute Value field
        for this AVP has the following format:\n       0                   1                   2
        \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     | Nonce ... (arbitrary number of octets)\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Nonce is of arbitrary length, though at least 16 octets is\n      recommended.
        \ The Nonce contains the random value for use in the\n      Control Message
        Authentication hash calculation (see Message\n      Digest AVP definition
        in this section).\n      If Control Message Authentication is enabled, this
        AVP MUST be\n      present in the SCCRQ and SCCRP messages.\n      This AVP
        MUST NOT be hidden (the H bit MUST be 0).  The M bit for\n      this AVP SHOULD
        be set to 1, but MAY vary (see Section 5.2).  The\n      Length of this AVP
        is 6 plus the length of the Nonce.\n   Random Vector (All Messages)\n      The
        Random Vector AVP, Attribute Type 36, MUST contain a\n      cryptographically
        random value [RFC1750].  This value is used for\n      AVP Hiding.\n      The
        Attribute Value field for this AVP has the following format:\n       0                   1
        \                  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     | Random Octet String ... (arbitrary number of octets)\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Random Octet String is of arbitrary length, though at least 16\n
        \     octets is recommended.  The string contains the random vector for\n
        \     use in computing the MD5 hash to retrieve or hide the Attribute\n      Value
        of a hidden AVP (see Section 5.3).\n      More than one Random Vector AVP
        may appear in a message, in which\n      case a hidden AVP uses the Random
        Vector AVP most closely\n      preceding it.  As such, at least one Random
        Vector AVP MUST\n      precede the first AVP with the H bit set.\n      This
        AVP MUST NOT be hidden (the H bit MUST be 0).  The M bit for\n      this AVP
        SHOULD be set to 1, but MAY vary (see Section 5.2).  The\n      Length of
        this AVP is 6 plus the length of the Random Octet\n      String.\n"
      title: 5.4.1.  General Control Message AVPs
    - contents:
      - "5.4.2.  Result and Error Codes\n   Result Code (StopCCN, CDN)\n      The
        Result Code AVP, Attribute Type 1, indicates the reason for\n      terminating
        the control connection or session.\n      The Attribute Value field for this
        AVP has the following format:\n       0                   1                   2
        \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |          Result Code          |     Error Code (optional)     |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     | Error Message ... (optional, arbitrary number of octets)      |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Result Code is a 2-octet unsigned integer.  The optional Error\n
        \     Code is a 2-octet unsigned integer.  An optional Error Message can\n
        \     follow the Error Code field.  Presence of the Error Code and\n      Message
        is indicated by the AVP Length field.  The Error Message\n      contains an
        arbitrary string providing further (human-readable)\n      text associated
        with the condition.  Human-readable text in all\n      error messages MUST
        be provided in the UTF-8 charset [RFC3629]\n      using the Default Language
        [RFC2277].\n      This AVP MUST NOT be hidden (the H bit MUST be 0).  The
        M bit for\n      this AVP SHOULD be set to 1, but MAY vary (see Section 5.2).
        \ The\n      Length is 8 if there is no Error Code or Message, 10 if there
        is\n      an Error Code and no Error Message, or 10 plus the length of the\n
        \     Error Message if there is an Error Code and Message.\n      Defined
        Result Code values for the StopCCN message are as follows:\n         0 - Reserved.\n
        \        1 - General request to clear control connection.\n         2 - General
        error, Error Code indicates the problem.\n         3 - Control connection
        already exists.\n         4 - Requester is not authorized to establish a control\n
        \            connection.\n         5 - The protocol version of the requester
        is not supported,\n             Error Code indicates highest version supported.\n
        \        6 - Requester is being shut down.\n         7 - Finite state machine
        error or timeout\n      General Result Code values for the CDN message are
        as follows:\n         0 - Reserved.\n         1 - Session disconnected due
        to loss of carrier or\n             circuit disconnect.\n         2 - Session
        disconnected for the reason indicated in Error\n             Code.\n         3
        - Session disconnected for administrative reasons.\n         4 - Session establishment
        failed due to lack of appropriate\n             facilities being available
        (temporary condition).\n         5 - Session establishment failed due to lack
        of appropriate\n             facilities being available (permanent condition).\n
        \       13 - Session not established due to losing tie breaker.\n        14
        - Session not established due to unsupported PW type.\n        15 - Session
        not established, sequencing required without\n             valid L2-Specific
        Sublayer.\n        16 - Finite state machine error or timeout.\n      Additional
        service-specific Result Codes are defined outside this\n      document.\n
        \     The Error Codes defined below pertain to types of errors that are\n
        \     not specific to any particular L2TP request, but rather to\n      protocol
        or message format errors.  If an L2TP reply indicates in\n      its Result
        Code that a General Error occurred, the General Error\n      value should
        be examined to determine what the error was.  The\n      currently defined
        General Error codes and their meanings are as\n      follows:\n      0 - No
        General Error.\n      1 - No control connection exists yet for this pair of
        LCCEs.\n      2 - Length is wrong.\n      3 - One of the field values was
        out of range.\n      4 - Insufficient resources to handle this operation now.\n
        \     5 - Invalid Session ID.\n      6 - A generic vendor-specific error occurred.\n
        \     7 - Try another.  If initiator is aware of other possible\n          responder
        destinations, it should try one of them.  This can\n          be used to guide
        an LAC or LNS based on policy.\n      8 - The session or control connection
        was shut down due to receipt\n          of an unknown AVP with the M bit set
        (see Section 5.2).  The\n          Error Message SHOULD contain the attribute
        of the offending\n          AVP in (human-readable) text form.\n      9 -
        Try another directed.  If an LAC or LNS is aware of other\n          possible
        destinations, it should inform the initiator of the\n          control connection
        or session.  The Error Message MUST contain\n          a comma-separated list
        of addresses from which the initiator\n          may choose.  If the L2TP
        data channel runs over IPv4, then\n          this would be a comma-separated
        list of IP addresses in the\n          canonical dotted-decimal format (e.g.,
        \"192.0.2.1, 192.0.2.2,\n          192.0.2.3\") in the UTF-8 charset [RFC3629]
        using the Default\n          Language [RFC2277].  If there are no servers
        for the LAC or\n          LNS to suggest, then Error Code 7 should be used.
        \ For IPv4,\n          the delimiter between addresses MUST be precisely a
        single\n          comma and a single space.  For IPv6, each literal address
        MUST\n          be enclosed in \"[\" and \"]\" characters, following the encoding\n
        \         described in [RFC2732].\n      When a General Error Code of 6 is
        used, additional information\n      about the error SHOULD be included in
        the Error Message field.  A\n      vendor-specific AVP MAY be sent to more
        precisely detail a\n      vendor-specific problem.\n"
      title: 5.4.2.  Result and Error Codes
    - contents:
      - "5.4.3.  Control Connection Management AVPs\n   Control Connection Tie Breaker
        (SCCRQ)\n      The Control Connection Tie Breaker AVP, Attribute Type 5,\n
        \     indicates that the sender desires a single control connection to\n      exist
        between a given pair of LCCEs.\n      The Attribute Value field for this AVP
        has the following format:\n       0                   1                   2
        \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     | Control Connection Tie Breaker Value ...\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \                                                ... (64 bits)        |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Control Connection Tie Breaker Value is an 8-octet random\n      value
        that is used to choose a single control connection when two\n      LCCEs request
        a control connection concurrently.  The recipient of\n      a SCCRQ must check
        to see if a SCCRQ has been sent to the peer; if\n      so, a tie has been
        detected.  In this case, the LCCE must compare\n      its Control Connection
        Tie Breaker value with the one received in\n      the SCCRQ.  The lower value
        \"wins\", and the \"loser\" MUST discard\n      its control connection.  A
        StopCCN SHOULD be sent by the winner as\n      an explicit rejection for the
        losing SCCRQ.  In the case in which\n      a tie breaker is present on both
        sides and the value is equal,\n      both sides MUST discard their control
        connections and restart\n      control connection negotiation with a new,
        random tie breaker\n      value.\n      If a tie breaker is received and an
        outstanding SCCRQ has no tie\n      breaker value, the initiator that included
        the Control Connection\n      Tie Breaker AVP \"wins\".  If neither side issues
        a tie breaker,\n      then two separate control connections are opened.\n
        \     Applications that employ a distinct and well-known initiator have\n
        \     no need for tie breaking, and MAY omit this AVP or disable tie\n      breaking
        functionality.  Applications that require tie breaking\n      also require
        that an LCCE be uniquely identifiable upon receipt of\n      an SCCRQ.  For
        L2TP over IP, this MUST be accomplished via the\n      Router ID AVP.\n      Note
        that in [RFC2661], this AVP is referred to as the \"Tie\n      Breaker AVP\"
        and is applicable only to a control connection.  In\n      L2TPv3, the AVP
        serves the same purpose of tie breaking, but is\n      applicable to a control
        connection or a session.  The Control\n      Connection Tie Breaker AVP (present
        only in Control Connection\n      messages) and Session Tie Breaker AVP (present
        only in Session\n      messages), are described separately in this document,
        but share\n      the same Attribute type of 5.\n      This AVP MUST NOT be
        hidden (the H bit MUST be 0).  The M bit for\n      this AVP SHOULD be set
        to 1, but MAY vary (see Section 5.2).  The\n      length of this AVP is 14.\n
        \  Host Name (SCCRQ, SCCRP)\n      The Host Name AVP, Attribute Type 7, indicates
        the name of the\n      issuing LAC or LNS, encoded in the US-ASCII charset.\n
        \     The Attribute Value field for this AVP has the following format:\n       0
        \                  1                   2                   3\n       0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     | Host Name ... (arbitrary number of octets)\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Host Name is of arbitrary length, but MUST be at least 1\n      octet.\n
        \     This name should be as broadly unique as possible; for hosts\n      participating
        in DNS [RFC1034], a host name with fully qualified\n      domain would be
        appropriate.  The Host Name AVP and/or Router ID\n      AVP MUST be used to
        identify an LCCE as described in Section 3.3.\n      This AVP MUST NOT be
        hidden (the H bit MUST be 0).  The M bit for\n      this AVP SHOULD be set
        to 1, but MAY vary (see Section 5.2).  The\n      Length of this AVP is 6
        plus the length of the Host Name.\n   Router ID (SCCRQ, SCCRP)\n      The
        Router ID AVP, Attribute Type 60, is an identifier used to\n      identify
        an LCCE for control connection setup, tie breaking,\n      and/or tunnel authentication.\n
        \     The Attribute Value field for this AVP has the following format:\n       0
        \                  1                   2                   3\n       0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                      Router Identifier                        |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Router Identifier is a 4-octet unsigned integer.  Its value is\n
        \     unique for a given LCCE, per Section 8.1 of [RFC2072].  The Host\n      Name
        AVP and/or Router ID AVP MUST be used to identify an LCCE as\n      described
        in Section 3.3.\n      Implementations MUST NOT assume that Router Identifier
        is a valid\n      IP address.  The Router Identifier for L2TP over IPv6 can
        be\n      obtained from an IPv4 address (if available) or via unspecified\n
        \     implementation-specific means.\n      This AVP MUST NOT be hidden (the
        H bit MUST be 0).  The M bit for\n      this AVP SHOULD be set to 1, but MAY
        vary (see Section 5.2).  The\n      Length of this AVP is 10.\n   Vendor Name
        (SCCRQ, SCCRP)\n      The Vendor Name AVP, Attribute Type 8, contains a vendor-specific\n
        \     (possibly human-readable) string describing the type of LAC or LNS\n
        \     being used.\n      The Attribute Value field for this AVP has the following
        format:\n       0                   1                   2                   3\n
        \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |  Vendor Name ... (arbitrary number of octets)\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Vendor Name is the indicated number of octets representing the\n
        \     vendor string.  Human-readable text for this AVP MUST be provided\n
        \     in the US-ASCII charset [RFC1958, RFC2277].\n      This AVP MAY be hidden
        (the H bit MAY be 0 or 1).  The M bit for\n      this AVP SHOULD be set to
        0, but MAY vary (see Section 5.2).  The\n      Length (before hiding) of this
        AVP is 6 plus the length of the\n      Vendor Name.\n   Assigned Control Connection
        ID (SCCRQ, SCCRP, StopCCN)\n      The Assigned Control Connection ID AVP,
        Attribute Type 61,\n      contains the ID being assigned to this control connection
        by the\n      sender.\n      The Attribute Value field for this AVP has the
        following format:\n       0                   1                   2                   3\n
        \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                Assigned Control Connection ID                 |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Assigned Control Connection ID is a 4-octet non-zero unsigned\n
        \     integer.\n      The Assigned Control Connection ID AVP establishes the
        identifier\n      used to multiplex and demultiplex multiple control connections\n
        \     between a pair of LCCEs.  Once the Assigned Control Connection ID\n
        \     AVP has been received by an LCCE, the Control Connection ID\n      specified
        in the AVP MUST be included in the Control Connection ID\n      field of all
        control packets sent to the peer for the lifetime of\n      the control connection.
        \ Before the Assigned Control Connection ID\n      AVP is received from a
        peer, all control messages MUST be sent to\n      that peer with a Control
        Connection ID value of 0 in the header.\n      Because a Control Connection
        ID value of 0 is used in this special\n      manner, the zero value MUST NOT
        be sent as an Assigned Control\n      Connection ID value.\n      Under certain
        circumstances, an LCCE may need to send a StopCCN to\n      a peer without
        having yet received an Assigned Control Connection\n      ID AVP from the
        peer (i.e., SCCRQ sent, no SCCRP received yet).\n      In this case, the Assigned
        Control Connection ID AVP that had been\n      sent to the peer earlier (i.e.,
        in the SCCRQ) MUST be sent as the\n      Assigned Control Connection ID AVP
        in the StopCCN.  This policy\n      allows the peer to try to identify the
        appropriate control\n      connection via a reverse lookup.\n      This AVP
        MAY be hidden (the H bit MAY be 0 or 1).  The M bit for\n      this AVP SHOULD
        be set to 1, but MAY vary (see Section 5.2).  The\n      Length (before hiding)
        of this AVP is 10.\n   Receive Window Size (SCCRQ, SCCRP)\n      The Receive
        Window Size AVP, Attribute Type 10, specifies the\n      receive window size
        being offered to the remote peer.\n      The Attribute Value field for this
        AVP has the following format:\n       0                   1\n       0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |
        \        Window Size           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Window Size is a 2-octet unsigned integer.\n      If absent, the
        peer must assume a Window Size of 4 for its\n      transmit window.\n      The
        remote peer may send the specified number of control messages\n      before
        it must wait for an acknowledgment.  See Section 4.2 for\n      more information
        on reliable control message delivery.\n      This AVP MUST NOT be hidden (the
        H bit MUST be 0).  The M bit for\n      this AVP SHOULD be set to 1, but MAY
        vary (see Section 5.2).  The\n      Length of this AVP is 8.\n   Pseudowire
        Capabilities List (SCCRQ, SCCRP)\n      The Pseudowire Capabilities List (PW
        Capabilities List) AVP,\n      Attribute Type 62, indicates the L2 payload
        types the sender can\n      support.  The specific payload type of a given
        session is\n      identified by the Pseudowire Type AVP.\n      The Attribute
        Value field for this AVP has the following format:\n       0                   1
        \                  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |           PW Type 0           |             ...               |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |              ...              |          PW Type N            |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     Defined PW types that may appear in this list are managed by IANA\n
        \     and will appear in associated pseudowire-specific documents for\n      each
        PW type.\n      If a sender includes a given PW type in the PW Capabilities
        List\n      AVP, the sender assumes full responsibility for supporting that\n
        \     particular payload, such as any payload-specific AVPs, L2-Specific\n
        \     Sublayer, or control messages that may be defined in the\n      appropriate
        companion document.\n      This AVP MAY be hidden (the H bit MAY be 0 or 1).
        \ The M bit for\n      this AVP SHOULD be set to 1, but MAY vary (see Section
        5.2).  The\n      Length (before hiding) of this AVP is 8 octets with one
        PW type\n      specified, plus 2 octets for each additional PW type.\n   Preferred
        Language (SCCRQ, SCCRP)\n      The Preferred Language AVP, Attribute Type
        72, provides a method\n      for an LCCE to indicate to the peer the language
        in which human-\n      readable messages it sends SHOULD be composed.  This
        AVP contains\n      a single language tag or language range [RFC3066].\n      The
        Attribute Value field for this AVP has the following format:\n      0                   1
        \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |  Preferred Language... (arbitrary number of octets)\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Preferred Language is the indicated number of octets\n      representing
        the language tag or language range, encoded in the\n      US-ASCII charset.\n
        \     It is not required to send a Preferred Language AVP.  If (1) an\n      LCCE
        does not signify a language preference by the inclusion of\n      this AVP
        in the SCCRQ or SCCRP, (2) the Preferred Language AVP is\n      unrecognized,
        or (3) the requested language is not supported by\n      the peer LCCE, the
        default language [RFC2277] MUST be used for all\n      internationalized strings
        sent by the peer.\n      This AVP MAY be hidden (the H bit MAY be 0 or 1).
        \ The M bit for\n      this AVP SHOULD be set to 0, but MAY vary (see Section
        5.2).  The\n      Length (before hiding) of this AVP is 6 plus the length
        of the\n      Preferred Language.\n"
      title: 5.4.3.  Control Connection Management AVPs
    - contents:
      - "5.4.4.  Session Management AVPs\n   Local Session ID (ICRQ, ICRP, ICCN, OCRQ,
        OCRP, OCCN, CDN, WEN, SLI)\n      The Local Session ID AVP (analogous to the
        Assigned Session ID in\n      L2TPv2), Attribute Type 63, contains the identifier
        being assigned\n      to this session by the sender.\n      The Attribute
        Value field for this AVP has the following format:\n       0                   1
        \                  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                       Local Session ID                        |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Local Session ID is a 4-octet non-zero unsigned integer.\n      The
        Local Session ID AVP establishes the two identifiers used to\n      multiplex
        and demultiplex sessions between two LCCEs.  Each LCCE\n      chooses any
        free value it desires, and sends it to the remote LCCE\n      using this AVP.
        \ The remote LCCE MUST then send all data packets\n      associated with this
        session using this value.  Additionally, for\n      all session-oriented control
        messages sent after this AVP is\n      received (e.g., ICRP, ICCN, CDN, SLI,
        etc.), the remote LCCE MUST\n      echo this value in the Remote Session ID
        AVP.\n      Note that a Session ID value is unidirectional.  Because each
        LCCE\n      chooses its Session ID independent of its peer LCCE, the value\n
        \     does not have to match in each direction for a given session.\n      See
        Section 4.1 for additional information about the Session ID.\n      This AVP
        MAY be hidden (the H bit MAY be 0 or 1).  The M bit for\n      this AVP SHOULD
        be 1 set to 1, but MAY vary (see Section 5.2).\n      The Length (before hiding)
        of this AVP is 10.\n   Remote Session ID (ICRQ, ICRP, ICCN, OCRQ, OCRP, OCCN,
        CDN, WEN, SLI)\n      The Remote Session ID AVP, Attribute Type 64, contains
        the\n      identifier that was assigned to this session by the peer.\n      The
        Attribute Value field for this AVP has the following format:\n       0                   1
        \                  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                      Remote Session ID                        |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Remote Session ID is a 4-octet non-zero unsigned integer.\n      The
        Remote Session ID AVP MUST be present in all session-level\n      control
        messages.  The AVP's value echoes the session identifier\n      advertised
        by the peer via the Local Session ID AVP.  It is the\n      same value that
        will be used in all transmitted data messages by\n      this side of the session.
        \ In most cases, this identifier is\n      sufficient for the peer to look
        up session-level context for this\n      control message.\n      When a session-level
        control message must be sent to the peer\n      before the Local Session ID
        AVP has been received, the value of\n      the Remote Session ID AVP MUST
        be set to zero.  Additionally, the\n      Local Session ID AVP (sent in a
        previous control message for this\n      session) MUST be included in the
        control message.  The peer must\n      then use the Local Session ID AVP to
        perform a reverse lookup to\n      find its session context.  Session-level
        control messages defined\n      in this document that might be subject to
        a reverse lookup by a\n      receiving peer include the CDN, WEN, and SLI.\n
        \     This AVP MAY be hidden (the H bit MAY be 0 or 1).  The M bit for\n      this
        AVP SHOULD be set to 1, but MAY vary (see Section 5.2).  The\n      Length
        (before hiding) of this AVP is 10.\n   Assigned Cookie (ICRQ, ICRP, OCRQ,
        OCRP)\n      The Assigned Cookie AVP, Attribute Type 65, contains the Cookie\n
        \     value being assigned to this session by the sender.\n      The Attribute
        Value field for this AVP has the following format:\n       0                   1
        \                  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |               Assigned Cookie (32 or 64 bits) ...\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Assigned Cookie is a 4-octet or 8-octet random value.\n      The
        Assigned Cookie AVP contains the value used to check the\n      association
        of a received data message with the session identified\n      by the Session
        ID.  All data messages sent to a peer MUST use the\n      Assigned Cookie
        sent by the peer in this AVP.  The value's length\n      (0, 32, or 64 bits)
        is obtained by the length of the AVP.\n      A missing Assigned Cookie AVP
        or Assigned Cookie Value of zero\n      length indicates that the Cookie field
        should not be present in\n      any data packets sent to the LCCE sending
        this AVP.\n      See Section 4.1 for additional information about the Assigned\n
        \     Cookie.\n      This AVP MAY be hidden (the H bit MAY be 0 or 1).  The
        M bit for\n      this AVP SHOULD be set to 1, but MAY vary (see Section 5.2).
        \ The\n      Length (before hiding) of this AVP may be 6, 10, or 14 octets.\n
        \  Serial Number (ICRQ, OCRQ)\n      The Serial Number AVP, Attribute Type
        15, contains an identifier\n      assigned by the LAC or LNS to this session.\n
        \     The Attribute Value field for this AVP has the following format:\n       0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                        Serial Number                          |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Serial Number is a 32-bit value.\n      The Serial Number is intended
        to be an easy reference for\n      administrators on both ends of a control
        connection to use when\n      investigating session failure problems.  Serial
        Numbers should be\n      set to progressively increasing values, which are
        likely to be\n      unique for a significant period of time across all interconnected\n
        \     LNSs and LACs.\n      Note that in RFC 2661, this value was referred
        to as the \"Call\n      Serial Number AVP\".  It serves the same purpose and
        has the same\n      attribute value and composition.\n      This AVP MAY be
        hidden (the H bit MAY be 0 or 1).  The M bit for\n      this AVP SHOULD be
        set to 0, but MAY vary (see Section 5.2).  The\n      Length (before hiding)
        of this AVP is 10.\n   Remote End ID (ICRQ, OCRQ)\n      The Remote End ID
        AVP, Attribute Type 66, contains an identifier\n      used to bind L2TP sessions
        to a given circuit, interface, or\n      bridging instance.  It also may be
        used to detect session-level\n      ties.\n      The Attribute Value field
        for this AVP has the following format:\n       0                   1                   2
        \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     | Remote End Identifier ... (arbitrary number of octets)\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Remote End Identifier field is a variable-length field whose\n      value
        is unique for a given LCCE peer, as described in Section\n      3.3.\n      A
        session-level tie is detected if an LCCE receives an ICRQ or\n      OCRQ with
        an End ID AVP whose value matches that which was just\n      sent in an outgoing
        ICRQ or OCRQ to the same peer.  If the two\n      values match, an LCCE recognizes
        that a tie exists (i.e., both\n      LCCEs are attempting to establish sessions
        for the same circuit).\n      The tie is broken by the Session Tie Breaker
        AVP.\n      By default, the LAC-LAC cross-connect application (see Section\n
        \     2(b)) of L2TP over an IP network MUST utilize the Router ID AVP\n      and
        Remote End ID AVP to associate a circuit to an L2TP session.\n      Other
        AVPs MAY be used for LCCE or circuit identification as\n      specified in
        companion documents.\n      This AVP MAY be hidden (the H bit MAY be 0 or
        1).  The M bit for\n      this AVP SHOULD be set to 1, but MAY vary (see Section
        5.2).  The\n      Length (before hiding) of this AVP is 6 plus the length
        of the\n      Remote End Identifier value.\n   Session Tie Breaker (ICRQ,
        OCRQ)\n      The Session Tie Breaker AVP, Attribute Type 5, is used to break\n
        \     ties when two peers concurrently attempt to establish a session\n      for
        the same circuit.\n      The Attribute Value field for this AVP has the following
        format:\n      0                   1                   2                   3\n
        \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     | Session Tie Breaker Value ...\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \                                                ... (64 bits)        |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Session Tie Breaker Value is an 8-octet random value that is\n      used
        to choose a session when two LCCEs concurrently request a\n      session for
        the same circuit.  A tie is detected by examining the\n      peer's identity
        (described in Section 3.3) plus the per-session\n      shared value communicated
        via the End ID AVP.  In the case of a\n      tie, the recipient of an ICRQ
        or OCRQ must compare the received\n      tie breaker value with the one that
        it sent earlier.  The LCCE\n      with the lower value \"wins\" and MUST send
        a CDN with result code\n      set to 13 (as defined in Section 5.4.2) in response
        to the losing\n      ICRQ or OCRQ.  In the case in which a tie is detected,
        tie\n      breakers are sent by both sides, and the tie breaker values are\n
        \     equal, both sides MUST discard their sessions and restart session\n
        \     negotiation with new random tie breaker values.\n      If a tie is detected
        but only one side sends a Session Tie Breaker\n      AVP, the session initiator
        that included the Session Tie Breaker\n      AVP \"wins\".  If neither side
        issues a tie breaker, then both sides\n      MUST tear down the session.\n
        \     This AVP MUST NOT be hidden (the H bit MUST be 0).  The M bit for\n
        \     this AVP SHOULD be set to 1, but MAY vary (see Section 5.2).  The\n
        \     Length of this AVP is 14.\n   Pseudowire Type (ICRQ, OCRQ)\n      The
        Pseudowire Type (PW Type) AVP, Attribute Type 68, indicates\n      the L2
        payload type of the packets that will be tunneled using\n      this L2TP session.\n
        \     The Attribute Value field for this AVP has the following format:\n       0
        \                  1\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |           PW Type             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     A peer MUST NOT request an incoming or outgoing call with a PW\n      Type
        AVP specifying a value not advertised in the PW Capabilities\n      List AVP
        it received during control connection establishment.\n      Attempts to do
        so MUST result in the call being rejected via a CDN\n      with the Result
        Code set to 14 (see Section 5.4.2).\n      This AVP MAY be hidden (the H bit
        MAY be 0 or 1).  The M bit for\n      this AVP SHOULD be set to 1, but MAY
        vary (see Section 5.2).  The\n      Length (before hiding) of this AVP is
        8.\n   L2-Specific Sublayer (ICRQ, ICRP, ICCN, OCRQ, OCRP, OCCN)\n      The
        L2-Specific Sublayer AVP, Attribute Type 69, indicates the\n      presence
        and format of the L2-Specific Sublayer the sender of this\n      AVP requires
        on all incoming data packets for this L2TP session.\n       0                   1\n
        \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |   L2-Specific Sublayer Type   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The L2-Specific Sublayer Type is a 2-octet unsigned integer with\n      the
        following values defined in this document:\n         0 - There is no L2-Specific
        Sublayer present.\n         1 - The Default L2-Specific Sublayer (defined
        in Section 4.6)\n             is used.\n      If this AVP is received and
        has a value other than zero, the\n      receiving LCCE MUST include the identified
        L2-Specific Sublayer in\n      its outgoing data messages.  If the AVP is
        not received, it is\n      assumed that there is no sublayer present.\n      This
        AVP MAY be hidden (the H bit MAY be 0 or 1).  The M bit for\n      this AVP
        SHOULD be set to 1, but MAY vary (see Section 5.2).  The\n      Length (before
        hiding) of this AVP is 8.\n   Data Sequencing (ICRQ, ICRP, ICCN, OCRQ, OCRP,
        OCCN)\n      The Data Sequencing AVP, Attribute Type 70, indicates that the\n
        \     sender requires some or all of the data packets that it receives\n      to
        be sequenced.\n      The Attribute Value field for this AVP has the following
        format:\n       0                   1\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |     Data Sequencing
        Level     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      The Data Sequencing
        Level is a 2-octet unsigned integer indicating\n      the degree of incoming
        data traffic that the sender of this AVP\n      wishes to be marked with sequence
        numbers.\n      Defined Data Sequencing Levels are as follows:\n         0
        - No incoming data packets require sequencing.\n         1 - Only non-IP data
        packets require sequencing.\n         2 - All incoming data packets require
        sequencing.\n      If a Data Sequencing Level of 0 is specified, there is
        no need to\n      send packets with sequence numbers.  If sequence numbers
        are sent,\n      they will be ignored upon receipt.  If no Data Sequencing
        AVP is\n      received, a Data Sequencing Level of 0 is assumed.\n      If
        a Data Sequencing Level of 1 is specified, only non-IP traffic\n      carried
        within the tunneled L2 frame should have sequence numbers\n      applied.
        \ Non-IP traffic here refers to any packets that cannot be\n      classified
        as an IP packet within their respective L2 framing\n      (e.g., a PPP control
        packet or NETBIOS frame encapsulated by Frame\n      Relay before being tunneled).
        \ All traffic that can be classified\n      as IP MUST be sent with no sequencing
        (i.e., the S bit in the L2-\n      Specific Sublayer is set to zero).  If
        a packet is unable to be\n      classified at all (e.g., because it has been
        compressed or\n      encrypted at layer 2) or if an implementation is unable
        to perform\n      such classification within L2 frames, all packets MUST be
        provided\n      with sequence numbers (essentially falling back to a Data\n
        \     Sequencing Level of 2).\n      If a Data Sequencing Level of 2 is specified,
        all traffic MUST be\n      sequenced.\n      Data sequencing may only be requested
        when there is an L2-Specific\n      Sublayer present that can provide sequence
        numbers.  If sequencing\n      is requested without requesting a L2-Specific
        Sublayer AVP, the\n      session MUST be disconnected with a Result Code of
        15 (see Section\n      5.4.2).\n      This AVP MAY be hidden (the H bit MAY
        be 0 or 1).  The M bit for\n      this AVP SHOULD be set to 1, but MAY vary
        (see Section 5.2).  The\n      Length (before hiding) of this AVP is 8.\n
        \  Tx Connect Speed (ICRQ, ICRP, ICCN, OCRQ, OCRP, OCCN)\n      The Tx Connect
        Speed BPS AVP, Attribute Type 74, contains the\n      speed of the facility
        chosen for the connection attempt.\n      The Attribute Value field for this
        AVP has the following format:\n       0                   1                   2
        \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                      Connect Speed in bps...\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \                       ...Connect Speed in bps (64 bits)             |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The Tx Connect Speed BPS is an 8-octet value indicating the speed\n
        \     in bits per second.  A value of zero indicates that the speed is\n      indeterminable
        or that there is no physical point-to-point link.\n      When the optional
        Rx Connect Speed AVP is present, the value in\n      this AVP represents the
        transmit connect speed from the\n      perspective of the LAC (i.e., data
        flowing from the LAC to the\n      remote system).  When the optional Rx Connect
        Speed AVP is NOT\n      present, the connection speed between the remote system
        and LAC is\n      assumed to be symmetric and is represented by the single
        value in\n      this AVP.\n      This AVP MAY be hidden (the H bit MAY be
        0 or 1).  The M bit for\n      this AVP SHOULD be set to 0, but MAY vary (see
        Section 5.2).  The\n      Length (before hiding) of this AVP is 14.\n   Rx
        Connect Speed (ICRQ, ICRP, ICCN, OCRQ, OCRP, OCCN)\n      The Rx Connect Speed
        AVP, Attribute Type 75, represents the speed\n      of the connection from
        the perspective of the LAC (i.e., data\n      flowing from the remote system
        to the LAC).\n      The Attribute Value field for this AVP has the following
        format:\n       0                   1                   2                   3\n
        \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                      Connect Speed in bps...\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \                       ...Connect Speed in bps (64 bits)             |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     Connect Speed BPS is an 8-octet value indicating the speed in bits\n
        \     per second.  A value of zero indicates that the speed is\n      indeterminable
        or that there is no physical point-to-point link.\n      Presence of this
        AVP implies that the connection speed may be\n      asymmetric with respect
        to the transmit connect speed given in the\n      Tx Connect Speed AVP.\n
        \     This AVP MAY be hidden (the H bit MAY be 0 or 1).  The M bit for\n      this
        AVP SHOULD be set to 0, but MAY vary (see Section 5.2).  The\n      Length
        (before hiding) of this AVP is 14.\n   Physical Channel ID (ICRQ, ICRP, OCRP)\n
        \     The Physical Channel ID AVP, Attribute Type 25, contains the\n      vendor-specific
        physical channel number used for a call.\n      The Attribute Value field
        for this AVP has the following format:\n       0                   1                   2
        \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                      Physical Channel ID                      |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     Physical Channel ID is a 4-octet value intended to be used for\n      logging
        purposes only.\n      This AVP MAY be hidden (the H bit MAY be 0 or 1).  The
        M bit for\n      this AVP SHOULD be set to 0, but MAY vary (see Section 5.2).
        \ The\n      Length (before hiding) of this AVP is 10.\n"
      title: 5.4.4.  Session Management AVPs
    - contents:
      - "5.4.5.  Circuit Status AVPs\n   Circuit Status (ICRQ, ICRP, ICCN, OCRQ, OCRP,
        OCCN, SLI)\n      The Circuit Status AVP, Attribute Type 71, indicates the
        initial\n      status of or a status change in the circuit to which the session\n
        \     is bound.\n      The Attribute Value field for this AVP has the following
        format:\n       0                   1\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |         Reserved          |N|A|\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      The A (Active) bit indicates
        whether the circuit is\n      up/active/ready (1) or down/inactive/not-ready
        (0).\n      The N (New) bit indicates whether the circuit status indication
        is\n      for a new circuit (1) or an existing circuit (0).  Links that have\n
        \     a similar mechanism available (e.g., Frame Relay) MUST map the\n      setting
        of this bit to the associated signaling for that link.\n      Otherwise, the
        New bit SHOULD still be set the first time the L2TP\n      session is established
        after provisioning.\n      The remaining bits are reserved for future use.
        \ Reserved bits\n      MUST be set to 0 when sending and ignored upon receipt.\n
        \     The Circuit Status AVP is used to advertise whether a circuit or\n      interface
        bound to an L2TP session is up and ready to send and/or\n      receive traffic.
        \ Different circuit types have different names for\n      status types.  For
        example, HDLC primary and secondary stations\n      refer to a circuit as
        being \"Receive Ready\" or \"Receive Not\n      Ready\", while Frame Relay
        refers to a circuit as \"Active\" or\n      \"Inactive\".  This AVP adopts
        the latter terminology, though the\n      concept remains the same regardless
        of the PW type for the L2TP\n      session.\n      In the simplest case, the
        circuit to which this AVP refers is a\n      single physical interface, port,
        or circuit, depending on the\n      application and the session setup.  The
        status indication in this\n      AVP may then be used to provide simple ILMI
        interworking for a\n      variety of circuit types.  For virtual or multipoint
        interfaces,\n      the Circuit Status AVP is still utilized, but in this case,
        it\n      refers to the state of an internal structure or a logical set of\n
        \     circuits.  Each PW-specific companion document MUST specify\n      precisely
        how this AVP is translated for each circuit type.\n      If this AVP is received
        with a Not Active notification for a given\n      L2TP session, all data traffic
        for that session MUST cease (or not\n      begin) in the direction of the
        sender of the Circuit Status AVP\n      until the circuit is advertised as
        Active.\n      The Circuit Status MUST be advertised by this AVP in ICRQ,
        ICRP,\n      OCRQ, and OCRP messages.  Often, the circuit type will be marked\n
        \     Active when initiated, but subsequently MAY be advertised as\n      Inactive.
        \ This indicates that an L2TP session is to be created,\n      but that the
        interface or circuit is still not ready to pass\n      traffic.  The ICCN,
        OCCN, and SLI control messages all MAY contain\n      this AVP to update the
        status of the circuit after establishment\n      of the L2TP session is requested.\n
        \     If additional circuit status information is needed for a given PW\n
        \     type, any new PW-specific AVPs MUST be defined in a separate\n      document.
        \ This AVP is only for general circuit status information\n      generally
        applicable to all circuit/interface types.\n      This AVP MAY be hidden (the
        H bit MAY be 0 or 1).  The M bit for\n      this AVP SHOULD be set to 1, but
        MAY vary (see Section 5.2).  The\n      Length (before hiding) of this AVP
        is 8.\n   Circuit Errors (WEN)\n      The Circuit Errors AVP, Attribute Type
        34, conveys circuit error\n      information to the peer.\n      The Attribute
        Value field for this AVP has the following format:\n       0                   1
        \                  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n
        \                                    |             Reserved           |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                        Hardware Overruns                      |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                         Buffer Overruns                       |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                         Timeout Errors                        |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     |                        Alignment Errors                       |\n
        \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \     The following fields are defined:\n      Reserved: 2 octets of Reserved
        data is present (providing longword\n         alignment within the AVP of
        the following values).  Reserved\n         data MUST be zero on sending and
        ignored upon receipt.\n      Hardware Overruns: Number of receive buffer overruns
        since call\n         was established.\n      Buffer Overruns: Number of buffer
        overruns detected since call was\n         established.\n      Timeout Errors:
        Number of timeouts since call was established.\n      Alignment Errors: Number
        of alignment errors since call was\n         established.\n      This AVP
        MAY be hidden (the H bit MAY be 0 or 1).  The M bit for\n      this AVP SHOULD
        be set to 0, but MAY vary (see Section 5.2).  The\n      Length (before hiding)
        of this AVP is 32.\n"
      title: 5.4.5.  Circuit Status AVPs
    title: 5.4.  AVP Summary
  title: 5.  Control Message Attribute Value Pairs
- contents:
  - "6.  Control Connection Protocol Specification\n   The following control messages
    are used to establish, maintain, and\n   tear down L2TP control connections.  All
    data packets are sent in\n   network order (high-order octets first).  Any \"reserved\"
    or \"empty\"\n   fields MUST be sent as 0 values to allow for protocol extensibility.\n
    \  The exchanges in which these messages are involved are outlined in\n   Section
    3.3.\n"
  - contents:
    - "6.1.  Start-Control-Connection-Request (SCCRQ)\n   Start-Control-Connection-Request
      (SCCRQ) is a control message used to\n   initiate a control connection between
      two LCCEs.  It is sent by\n   either the LAC or the LNS to begin the control
      connection\n   establishment process.\n   The following AVPs MUST be present
      in the SCCRQ:\n      Message Type\n      Host Name\n      Router ID\n      Assigned
      Control Connection ID\n      Pseudowire Capabilities List\n   The following
      AVPs MAY be present in the SCCRQ:\n      Random Vector\n      Control Message
      Authentication Nonce\n      Message Digest\n      Control Connection Tie Breaker\n
      \     Vendor Name\n      Receive Window Size\n      Preferred Language\n"
    title: 6.1.  Start-Control-Connection-Request (SCCRQ)
  - contents:
    - "6.2.  Start-Control-Connection-Reply (SCCRP)\n   Start-Control-Connection-Reply
      (SCCRP) is the control message sent in\n   reply to a received SCCRQ message.
      \ The SCCRP is used to indicate\n   that the SCCRQ was accepted and that establishment
      of the control\n   connection should continue.\n   The following AVPs MUST be
      present in the SCCRP:\n      Message Type\n      Host Name\n      Router ID\n
      \     Assigned Control Connection ID\n      Pseudowire Capabilities List\n   The
      following AVPs MAY be present in the SCCRP:\n      Random Vector\n      Control
      Message Authentication Nonce\n      Message Digest\n      Vendor Name\n      Receive
      Window Size\n      Preferred Language\n"
    title: 6.2.  Start-Control-Connection-Reply (SCCRP)
  - contents:
    - "6.3.  Start-Control-Connection-Connected (SCCCN)\n   Start-Control-Connection-Connected
      (SCCCN) is the control message\n   sent in reply to an SCCRP.  The SCCCN completes
      the control\n   connection establishment process.\n   The following AVP MUST
      be present in the SCCCN:\n      Message Type\n   The following AVP MAY be present
      in the SCCCN:\n      Random Vector\n      Message Digest\n"
    title: 6.3.  Start-Control-Connection-Connected (SCCCN)
  - contents:
    - "6.4.  Stop-Control-Connection-Notification (StopCCN)\n   Stop-Control-Connection-Notification
      (StopCCN) is the control message\n   sent by either LCCE to inform its peer
      that the control connection is\n   being shut down and that the control connection
      should be closed.  In\n   addition, all active sessions are implicitly cleared
      (without sending\n   any explicit session control messages).  The reason for
      issuing this\n   request is indicated in the Result Code AVP.  There is no explicit\n
      \  reply to the message, only the implicit ACK that is received by the\n   reliable
      control message delivery layer.\n   The following AVPs MUST be present in the
      StopCCN:\n      Message Type\n      Result Code\n   The following AVPs MAY be
      present in the StopCCN:\n      Random Vector\n      Message Digest\n      Assigned
      Control Connection ID\n   Note that the Assigned Control Connection ID MUST
      be present if the\n   StopCCN is sent after an SCCRQ or SCCRP message has been
      sent.\n"
    title: 6.4.  Stop-Control-Connection-Notification (StopCCN)
  - contents:
    - "6.5.  Hello (HELLO)\n   The Hello (HELLO) message is an L2TP control message
      sent by either\n   peer of a control connection.  This control message is used
      as a\n   \"keepalive\" for the control connection.  See Section 4.2 for a\n
      \  description of the keepalive mechanism.\n   HELLO messages are global to
      the control connection.  The Session ID\n   in a HELLO message MUST be 0.\n
      \  The following AVP MUST be present in the HELLO:\n      Message Type\n   The
      following AVP MAY be present in the HELLO:\n      Random Vector\n      Message
      Digest\n"
    title: 6.5.  Hello (HELLO)
  - contents:
    - "6.6.  Incoming-Call-Request (ICRQ)\n   Incoming-Call-Request (ICRQ) is the
      control message sent by an LCCE\n   to a peer when an incoming call is detected
      (although the ICRQ may\n   also be sent as a result of a local event).  It is
      the first in a\n   three-message exchange used for establishing a session via
      an L2TP\n   control connection.\n   The ICRQ is used to indicate that a session
      is to be established\n   between an LCCE and a peer.  The sender of an ICRQ
      provides the peer\n   with parameter information for the session.  However,
      the sender\n   makes no demands about how the session is terminated at the peer\n
      \  (i.e., whether the L2 traffic is processed locally, forwarded, etc.).\n   The
      following AVPs MUST be present in the ICRQ:\n      Message Type\n      Local
      Session ID\n      Remote Session ID\n      Serial Number\n      Pseudowire Type\n
      \     Remote End ID\n      Circuit Status\n   The following AVPs MAY be present
      in the ICRQ:\n      Random Vector\n      Message Digest\n      Assigned Cookie\n
      \     Session Tie Breaker\n      L2-Specific Sublayer\n      Data Sequencing\n
      \     Tx Connect Speed\n      Rx Connect Speed\n      Physical Channel ID\n"
    title: 6.6.  Incoming-Call-Request (ICRQ)
  - contents:
    - "6.7.  Incoming-Call-Reply (ICRP)\n   Incoming-Call-Reply (ICRP) is the control
      message sent by an LCCE in\n   response to a received ICRQ.  It is the second
      in the three-message\n   exchange used for establishing sessions within an L2TP
      control\n   connection.\n   The ICRP is used to indicate that the ICRQ was successful
      and that\n   the peer should establish (i.e., answer) the incoming call if it
      has\n   not already done so.  It also allows the sender to indicate specific\n
      \  parameters about the L2TP session.\n   The following AVPs MUST be present
      in the ICRP:\n      Message Type\n      Local Session ID\n      Remote Session
      ID\n      Circuit Status\n   The following AVPs MAY be present in the ICRP:\n
      \     Random Vector\n      Message Digest\n      Assigned Cookie\n      L2-Specific
      Sublayer\n      Data Sequencing\n      Tx Connect Speed\n      Rx Connect Speed\n
      \     Physical Channel ID\n"
    title: 6.7.  Incoming-Call-Reply (ICRP)
  - contents:
    - "6.8.  Incoming-Call-Connected (ICCN)\n   Incoming-Call-Connected (ICCN) is
      the control message sent by the\n   LCCE that originally sent an ICRQ upon receiving
      an ICRP from its\n   peer.  It is the final message in the three-message exchange
      used for\n   establishing L2TP sessions.\n   The ICCN is used to indicate that
      the ICRP was accepted, that the\n   call has been established, and that the
      L2TP session should move to\n   the established state.  It also allows the sender
      to indicate\n   specific parameters about the established call (parameters that
      may\n   not have been available at the time the ICRQ was issued).\n   The following
      AVPs MUST be present in the ICCN:\n      Message Type\n      Local Session ID\n
      \     Remote Session ID\n   The following AVPs MAY be present in the ICCN:\n
      \     Random Vector\n      Message Digest\n      L2-Specific Sublayer\n      Data
      Sequencing\n      Tx Connect Speed\n      Rx Connect Speed\n      Circuit Status\n"
    title: 6.8.  Incoming-Call-Connected (ICCN)
  - contents:
    - "6.9.  Outgoing-Call-Request (OCRQ)\n   Outgoing-Call-Request (OCRQ) is the
      control message sent by an LCCE\n   to an LAC to indicate that an outbound call
      at the LAC is to be\n   established based on specific destination information
      sent in this\n   message.  It is the first in a three-message exchange used
      for\n   establishing a session and placing a call on behalf of the initiating\n
      \  LCCE.\n   Note that a call may be any L2 connection requiring well-known\n
      \  destination information to be sent from an LCCE to an LAC.  This call\n   could
      be a dialup connection to the PSTN, an SVC connection, the IP\n   address of
      another LCCE, or any other destination dictated by the\n   sender of this message.\n
      \  The following AVPs MUST be present in the OCRQ:\n      Message Type\n      Local
      Session ID\n      Remote Session ID\n      Serial Number\n      Pseudowire Type\n
      \     Remote End ID\n      Circuit Status\n   The following AVPs MAY be present
      in the OCRQ:\n      Random Vector\n      Message Digest\n      Assigned Cookie\n
      \     Tx Connect Speed\n      Rx Connect Speed\n      Session Tie Breaker\n
      \     L2-Specific Sublayer\n      Data Sequencing\n"
    title: 6.9.  Outgoing-Call-Request (OCRQ)
  - contents:
    - "6.10.  Outgoing-Call-Reply (OCRP)\n   Outgoing-Call-Reply (OCRP) is the control
      message sent by an LAC to\n   an LCCE in response to a received OCRQ.  It is
      the second in a\n   three-message exchange used for establishing a session within
      an L2TP\n   control connection.\n   OCRP is used to indicate that the LAC has
      been able to attempt the\n   outbound call.  The message returns any relevant
      parameters regarding\n   the call attempt.  Data MUST NOT be forwarded until
      the OCCN is\n   received, which indicates that the call has been placed.\n   The
      following AVPs MUST be present in the OCRP:\n      Message Type\n      Local
      Session ID\n      Remote Session ID\n      Circuit Status\n   The following
      AVPs MAY be present in the OCRP:\n      Random Vector\n      Message Digest\n
      \     Assigned Cookie\n      L2-Specific Sublayer\n      Tx Connect Speed\n
      \     Rx Connect Speed\n      Data Sequencing\n      Physical Channel ID\n"
    title: 6.10.  Outgoing-Call-Reply (OCRP)
  - contents:
    - "6.11.  Outgoing-Call-Connected (OCCN)\n   Outgoing-Call-Connected (OCCN) is
      the control message sent by an LAC\n   to another LCCE after the OCRP and after
      the outgoing call has been\n   completed.  It is the final message in a three-message
      exchange used\n   for establishing a session.\n   OCCN is used to indicate that
      the result of a requested outgoing call\n   was successful.  It also provides
      information to the LCCE who\n   requested the call about the particular parameters
      obtained after the\n   call was established.\n   The following AVPs MUST be
      present in the OCCN:\n      Message Type\n      Local Session ID\n      Remote
      Session ID\n   The following AVPs MAY be present in the OCCN:\n      Random
      Vector\n      Message Digest\n      L2-Specific Sublayer\n      Tx Connect Speed\n
      \     Rx Connect Speed\n      Data Sequencing\n      Circuit Status\n"
    title: 6.11.  Outgoing-Call-Connected (OCCN)
  - contents:
    - "6.12.  Call-Disconnect-Notify (CDN)\n   The Call-Disconnect-Notify (CDN) is
      a control message sent by an LCCE\n   to request disconnection of a specific
      session.  Its purpose is to\n   inform the peer of the disconnection and the
      reason for the\n   disconnection.  The peer MUST clean up any resources, and
      does not\n   send back any indication of success or failure for such cleanup.\n
      \  The following AVPs MUST be present in the CDN:\n      Message Type\n      Result
      Code\n      Local Session ID\n      Remote Session ID\n   The following AVP
      MAY be present in the CDN:\n      Random Vector\n      Message Digest\n"
    title: 6.12.  Call-Disconnect-Notify (CDN)
  - contents:
    - "6.13.  WAN-Error-Notify (WEN)\n   The WAN-Error-Notify (WEN) is a control message
      sent from an LAC to\n   an LNS to indicate WAN error conditions.  The counters
      in this\n   message are cumulative.  This message should only be sent when an\n
      \  error occurs, and not more than once every 60 seconds.  The counters\n   are
      reset when a new call is established.\n   The following AVPs MUST be present
      in the WEN:\n      Message Type\n      Local Session ID\n      Remote Session
      ID\n      Circuit Errors\n   The following AVP MAY be present in the WEN:\n
      \     Random Vector\n      Message Digest\n"
    title: 6.13.  WAN-Error-Notify (WEN)
  - contents:
    - "6.14.  Set-Link-Info (SLI)\n   The Set-Link-Info control message is sent by
      an LCCE to convey link\n   or circuit status change information regarding the
      circuit associated\n   with this L2TP session.  For example, if PPP renegotiates
      LCP at an\n   LNS or between an LAC and a Remote System, or if a forwarded Frame\n
      \  Relay VC transitions to Active or Inactive at an LAC, an SLI message\n   SHOULD
      be sent to indicate this event.  Precise details of when the\n   SLI is sent,
      what PW type-specific AVPs must be present, and how\n   those AVPs should be
      interpreted by the receiving peer are outside\n   the scope of this document.
      \ These details should be described in the\n   associated pseudowire-specific
      documents that require use of this\n   message.\n   The following AVPs MUST
      be present in the SLI:\n      Message Type\n      Local Session ID\n      Remote
      Session ID\n   The following AVPs MAY be present in the SLI:\n      Random Vector\n
      \     Message Digest\n      Circuit Status\n"
    title: 6.14.  Set-Link-Info (SLI)
  - contents:
    - "6.15.  Explicit-Acknowledgement (ACK)\n   The Explicit Acknowledgement (ACK)
      message is used only to\n   acknowledge receipt of a message or messages on
      the control\n   connection (e.g., for purposes of updating Ns and Nr values).\n
      \  Receipt of this message does not trigger an event for the L2TP\n   protocol
      state machine.\n   A message received without any AVPs (including the Message
      Type AVP),\n   is referred to as a Zero Length Body (ZLB) message, and serves
      the\n   same function as the Explicit Acknowledgement.  ZLB messages are only\n
      \  permitted when Control Message Authentication defined in Section 4.3\n   is
      not enabled.\n   The following AVPs MAY be present in the ACK message:\n      Message
      Type\n      Message Digest\n"
    title: 6.15.  Explicit-Acknowledgement (ACK)
  title: 6.  Control Connection Protocol Specification
- contents:
  - "7.  Control Connection State Machines\n   The state tables defined in this section
    govern the exchange of\n   control messages defined in Section 6.  Tables are
    defined for\n   incoming call placement and outgoing call placement, as well as
    for\n   initiation of the control connection itself.  The state tables do not\n
    \  encode timeout and retransmission behavior, as this is handled in the\n   underlying
    reliable control message delivery mechanism (see Section\n   4.2).\n"
  - contents:
    - "7.1.  Malformed AVPs and Control Messages\n   Receipt of an invalid or unrecoverable
      malformed control message\n   SHOULD be logged appropriately and the control
      connection cleared to\n   ensure recovery to a known state.  The control connection
      may then be\n   restarted by the initiator.\n   An invalid control message is
      defined as (1) a message that contains\n   a Message Type marked as mandatory
      (see Section 5.4.1) but that is\n   unknown to the implementation, or (2) a
      control message that is\n   received in the wrong state.\n   Examples of malformed
      control messages include (1) a message that has\n   an invalid value in its
      header, (2) a message that contains an AVP\n   that is formatted incorrectly
      or whose value is out of range, and (3)\n   a message that is missing a required
      AVP.  A control message with a\n   malformed header MUST be discarded.\n   When
      possible, a malformed AVP should be treated as an unrecognized\n   AVP (see
      Section 5.2).  Thus, an attempt to inspect the M bit SHOULD\n   be made to determine
      the importance of the malformed AVP, and thus,\n   the severity of the malformation
      to the entire control message.  If\n   the M bit can be reasonably inspected
      within the malformed AVP and is\n   determined to be set, then as with an unrecognized
      AVP, the\n   associated session or control connection MUST be shut down.  If
      the M\n   bit is inspected and is found to be 0, the AVP MUST be ignored\n   (assuming
      recovery from the AVP malformation is indeed possible).\n   This policy must
      not be considered as a license to send malformed\n   AVPs, but rather, as a
      guide towards how to handle an improperly\n   formatted message if one is received.
      \ It is impossible to list all\n   potential malformations of a given message
      and give advice for each.\n   One example of a malformed AVP situation that
      should be recoverable\n   is if the Rx Connect Speed AVP is received with a
      length of 10 rather\n   than 14, implying that the connect speed bits-per-second
      is being\n   formatted in 4 octets rather than 8.  If the AVP does not have
      its M\n   bit set (as would typically be the case), this condition is not\n
      \  considered catastrophic.  As such, the control message should be\n   accepted
      as though the AVP were not present (though a local error\n   message may be
      logged).\n   In several cases in the following tables, a protocol message is
      sent,\n   and then a \"clean up\" occurs.  Note that, regardless of the initiator\n
      \  of the control connection destruction, the reliable delivery\n   mechanism
      must be allowed to run (see Section 4.2) before destroying\n   the control connection.
      \ This permits the control connection\n   management messages to be reliably
      delivered to the peer.\n   Appendix B.1 contains an example of lock-step control
      connection\n   establishment.\n"
    title: 7.1.  Malformed AVPs and Control Messages
  - contents:
    - "7.2.  Control Connection States\n   The L2TP control connection protocol is
      not distinguishable between\n   the two LCCEs but is distinguishable between
      the originator and\n   receiver.  The originating peer is the one that first
      initiates\n   establishment of the control connection.  (In a tie breaker\n
      \  situation, this is the winner of the tie.)  Since either the LAC or\n   the
      LNS can be the originator, a collision can occur.  See the\n   Control Connection
      Tie Breaker AVP in Section 5.4.3 for a description\n   of this and its resolution.\n
      \  State           Event              Action              New State\n   -----
      \          -----              ------              ---------\n   idle            Local
      open         Send SCCRQ          wait-ctl-reply\n                   request\n
      \  idle            Receive SCCRQ,     Send SCCRP          wait-ctl-conn\n                   acceptable\n
      \  idle            Receive SCCRQ,     Send StopCCN,       idle\n                   not
      acceptable     clean up\n   idle            Receive SCCRP      Send StopCCN,
      \      idle\n                                      clean up\n   idle            Receive
      SCCCN      Send StopCCN,       idle\n                                      clean
      up\n   wait-ctl-reply  Receive SCCRP,     Send SCCCN,         established\n
      \                  acceptable         send control-conn\n                                      open
      event to\n                                      waiting sessions\n   wait-ctl-reply
      \ Receive SCCRP,     Send StopCCN,       idle\n                   not acceptable
      \    clean up\n   wait-ctl-reply  Receive SCCRQ,     Send SCCRP,         wait-ctl-conn\n
      \                  lose tie breaker,  Clean up losing\n                   SCCRQ
      acceptable   connection\n   wait-ctl-reply  Receive SCCRQ,     Send StopCCN,
      \      idle\n                   lose tie breaker,  Clean up losing\n                   SCCRQ
      unacceptable connection\n   wait-ctl-reply  Receive SCCRQ,     Send StopCCN
      for    wait-ctl-reply\n                   win tie breaker    losing connection\n
      \  wait-ctl-reply  Receive SCCCN      Send StopCCN,       idle\n                                      clean
      up\n   wait-ctl-conn   Receive SCCCN,     Send control-conn   established\n
      \                  acceptable         open event to\n                                      waiting
      sessions\n   wait-ctl-conn   Receive SCCCN,     Send StopCCN,       idle\n                   not
      acceptable     clean up\n   wait-ctl-conn   Receive SCCRQ,     Send StopCCN,
      \      idle\n                   SCCRP              clean up\n   established
      \    Local open         Send control-conn   established\n                   request
      \           open event to\n                   (new call)         waiting sessions\n
      \  established     Administrative     Send StopCCN,       idle\n                   control-conn
      \      clean up\n                   close event\n   established     Receive
      SCCRQ,     Send StopCCN,       idle\n                   SCCRP, SCCCN       clean
      up\n   idle,           Receive StopCCN    Clean up            idle\n   wait-ctl-reply,\n
      \  wait-ctl-conn,\n   established\n   The states associated with an LCCE for
      control connection\n   establishment are as follows:\n   idle\n      Both initiator
      and recipient start from this state.  An initiator\n      transmits an SCCRQ,
      while a recipient remains in the idle state\n      until receiving an SCCRQ.\n
      \  wait-ctl-reply\n      The originator checks to see if another connection
      has been\n      requested from the same peer, and if so, handles the collision\n
      \     situation described in Section 5.4.3.\n   wait-ctl-conn\n      Awaiting
      an SCCCN.  If the SCCCN is valid, the control connection\n      is established;
      otherwise, it is torn down (sending a StopCCN with\n      the proper result
      and/or error code).\n   established\n      An established connection may be
      terminated by either a local\n      condition or the receipt of a StopCCN.  In
      the event of a local\n      termination, the originator MUST send a StopCCN
      and clean up the\n      control connection.  If the originator receives a StopCCN,
      it MUST\n      also clean up the control connection.\n"
    title: 7.2.  Control Connection States
  - contents:
    - "7.3.  Incoming Calls\n   An ICRQ is generated by an LCCE, typically in response
      to an incoming\n   call or a local event.  Once the LCCE sends the ICRQ, it
      waits for a\n   response from the peer.  However, it may choose to postpone\n
      \  establishment of the call (e.g., answering the call, bringing up the\n   circuit)
      until the peer has indicated with an ICRP that it will\n   accept the call.
      \ The peer may choose not to accept the call if, for\n   instance, there are
      insufficient resources to handle an additional\n   session.\n   If the peer
      chooses to accept the call, it responds with an ICRP.\n   When the local LCCE
      receives the ICRP, it attempts to establish the\n   call.  A final call connected
      message, the ICCN, is sent from the\n   local LCCE to the peer to indicate that
      the call states for both\n   LCCEs should enter the established state.  If the
      call is terminated\n   before the peer can accept it, a CDN is sent by the local
      LCCE to\n   indicate this condition.\n   When a call transitions to a \"disconnected\"
      or \"down\" state, the call\n   is cleared normally, and the local LCCE sends
      a CDN.  Similarly, if\n   the peer wishes to clear a call, it sends a CDN and
      cleans up its\n   session.\n"
    - contents:
      - "7.3.1.  ICRQ Sender States\n   State           Event              Action
        \          New State\n   -----           -----              ------           ---------\n
        \  idle            Call signal or     Initiate local   wait-control-conn\n
        \                  ready to receive   control-conn\n                   incoming
        conn      open\n   idle            Receive ICCN,      Clean up         idle\n
        \                  ICRP, CDN\n   wait-control-   Bearer line drop   Clean
        up         idle\n   conn            or local close\n                   request\n
        \  wait-control-   control-conn-open  Send ICRQ        wait-reply\n   conn\n
        \  wait-reply      Receive ICRP,      Send ICCN        established\n                   acceptable\n
        \  wait-reply      Receive ICRP,      Send CDN,        idle\n                   Not
        acceptable     clean up\n   wait-reply      Receive ICRQ,      Process as
        \      idle\n                   lose tie breaker   ICRQ Recipient\n                                      (Section
        7.3.2)\n   wait-reply      Receive ICRQ,      Send CDN         wait-reply\n
        \                  win tie breaker    for losing\n                                      session\n
        \  wait-reply      Receive CDN,       Clean up         idle\n                   ICCN\n
        \  wait-reply      Local close        Send CDN,        idle\n                   request
        \           clean up\n   established     Receive CDN        Clean up         idle\n
        \  established     Receive ICRQ,      Send CDN,        idle\n                   ICRP,
        ICCN         clean up\n   established     Local close        Send CDN,        idle\n
        \                  request            clean up\n   The states associated with
        the ICRQ sender are as follows:\n   idle\n      The LCCE detects an incoming
        call on one of its interfaces (e.g.,\n      an analog PSTN line rings, or
        an ATM PVC is provisioned), or a\n      local event occurs.  The LCCE initiates
        its control connection\n      establishment state machine and moves to a state
        waiting for\n      confirmation of the existence of a control connection.\n
        \  wait-control-conn\n      In this state, the session is waiting for either
        the control\n      connection to be opened or for verification that the control\n
        \     connection is already open.  Once an indication that the control\n      connection
        has been opened is received, session control messages\n      may be exchanged.
        \ The first of these messages is the ICRQ.\n   wait-reply\n      The ICRQ
        sender receives either (1) a CDN indicating the peer is\n      not willing
        to accept the call (general error or do not accept)\n      and moves back
        into the idle state, or (2) an ICRP indicating the\n      call is accepted.
        \ In the latter case, the LCCE sends an ICCN and\n      enters the established
        state.\n   established\n      Data is exchanged over the session.  The call
        may be cleared by\n      any of the following:\n         + An event on the
        connected interface: The LCCE sends a CDN.\n         + Receipt of a CDN: The
        LCCE cleans up, disconnecting the call.\n         + A local reason: The LCCE
        sends a CDN.\n"
      title: 7.3.1.  ICRQ Sender States
    - contents:
      - "7.3.2.  ICRQ Recipient States\n   State           Event              Action
        \           New State\n   -----           -----              ------            ---------\n
        \  idle            Receive ICRQ,      Send ICRP         wait-connect\n                   acceptable\n
        \  idle            Receive ICRQ,      Send CDN,         idle\n                   not
        acceptable     clean up\n   idle            Receive ICRP       Send CDN          idle\n
        \                                     clean up\n   idle            Receive
        ICCN       Clean up          idle\n   wait-connect    Receive ICCN,      Prepare
        for       established\n                   acceptable         data\n   wait-connect
        \   Receive ICCN,      Send CDN,         idle\n                   not acceptable
        \    clean up\n   wait-connect    Receive ICRQ,      Send CDN,         idle\n
        \                  ICRP               clean up\n   idle,           Receive
        CDN        Clean up          idle\n   wait-connect,\n   established\n   wait-connect
        \   Local close        Send CDN,         idle\n   established     request
        \           clean up\n   established     Receive ICRQ,      Send CDN,         idle\n
        \                  ICRP, ICCN         clean up\n   The states associated with
        the ICRQ recipient are as follows:\n   idle\n      An ICRQ is received.  If
        the request is not acceptable, a CDN is\n      sent back to the peer LCCE,
        and the local LCCE remains in the idle\n      state.  If the ICRQ is acceptable,
        an ICRP is sent.  The session\n      moves to the wait-connect state.\n   wait-connect\n
        \     The local LCCE is waiting for an ICCN from the peer.  Upon receipt\n
        \     of the ICCN, the local LCCE moves to established state.\n   established\n
        \     The session is terminated either by sending a CDN or by receiving\n
        \     a CDN from the peer.  Clean up follows on both sides regardless of\n
        \     the initiator.\n"
      title: 7.3.2.  ICRQ Recipient States
    title: 7.3.  Incoming Calls
  - contents:
    - "7.4.  Outgoing Calls\n   Outgoing calls instruct an LAC to place a call.  There
      are three\n   messages for outgoing calls: OCRQ, OCRP, and OCCN.  An LCCE first\n
      \  sends an OCRQ to an LAC to request an outgoing call.  The LAC MUST\n   respond
      to the OCRQ with an OCRP once it determines that the proper\n   facilities exist
      to place the call and that the call is\n   administratively authorized.  Once
      the outbound call is connected,\n   the LAC sends an OCCN to the peer indicating
      the final result of the\n   call attempt.\n"
    - contents:
      - "7.4.1.  OCRQ Sender States\n   State          Event              Action            New
        State\n   -----          -----              ------            ---------\n
        \  idle           Local open         Initiate local    wait-control-conn\n
        \                 request            control-conn-open\n   idle           Receive
        OCCN,      Clean up          idle\n                  OCRP\n   wait-control-
        \ control-conn-open  Send OCRQ         wait-reply\n   conn\n   wait-reply
        \    Receive OCRP,      none              wait-connect\n                  acceptable\n
        \  wait-reply     Receive OCRP,      Send CDN,         idle\n                  not
        acceptable     clean up\n   wait-reply     Receive OCCN       Send CDN,         idle\n
        \                                    clean up\n   wait-reply     Receive OCRQ,
        \     Process as        idle\n                  lose tie breaker   OCRQ Recipient\n
        \                                    (Section 7.4.2)\n   wait-reply     Receive
        OCRQ,      Send CDN          wait-reply\n                  win tie breaker
        \   for losing\n                                     session\n   wait-connect
        \  Receive OCCN       none              established\n   wait-connect   Receive
        OCRQ,      Send CDN,         idle\n                  OCRP               clean
        up\n   idle,          Receive CDN        Clean up          idle\n   wait-reply,\n
        \  wait-connect,\n   established\n   established    Receive OCRQ,      Send
        CDN,         idle\n                  OCRP, OCCN         clean up\n   wait-reply,
        \   Local close        Send CDN,         idle\n   wait-connect,  request            clean
        up\n   established\n   wait-control-  Local close        Clean up          idle\n
        \  conn           request\n   The states associated with the OCRQ sender are
        as follows:\n   idle, wait-control-conn\n      When an outgoing call request
        is initiated, a control connection\n      is created as described above, if
        not already present.  Once the\n      control connection is established, an
        OCRQ is sent to the LAC, and\n      the session moves into the wait-reply
        state.\n   wait-reply\n      If a CDN is received, the session is cleaned
        up and returns to\n      idle state.  If an OCRP is received, the call is
        in progress, and\n      the session moves to the wait-connect state.\n   wait-connect\n
        \     If a CDN is received, the session is cleaned up and returns to\n      idle
        state.  If an OCCN is received, the call has succeeded, and\n      the session
        may now exchange data.\n   established\n      If a CDN is received, the session
        is cleaned up and returns to\n      idle state.  Alternatively, if the LCCE
        chooses to terminate the\n      session, it sends a CDN to the LAC, cleans
        up the session, and\n      moves the session to idle state.\n"
      title: 7.4.1.  OCRQ Sender States
    - contents:
      - "7.4.2.  OCRQ Recipient (LAC) States\n   State           Event              Action
        \           New State\n   -----           -----              ------            ---------\n
        \  idle            Receive OCRQ,      Send OCRP,        wait-cs-answer\n                   acceptable
        \        Place call\n   idle            Receive OCRQ,      Send CDN,         idle\n
        \                  not acceptable     clean up\n   idle            Receive
        OCRP       Send CDN,         idle\n                                      clean
        up\n   idle            Receive OCCN,      Clean up          idle\n                   CDN\n
        \  wait-cs-answer  Call placement     Send OCCN         established\n                   successful\n
        \  wait-cs-answer  Call placement     Send CDN,         idle\n                   failed
        \            clean up\n   wait-cs-answer  Receive OCRQ,      Send CDN,         idle\n
        \                  OCRP, OCCN         clean up\n   established     Receive
        OCRQ,      Send CDN,         idle\n                   OCRP, OCCN         clean
        up\n   wait-cs-answer, Receive CDN        Clean up          idle\n   established\n
        \  wait-cs-answer, Local close        Send CDN,         idle\n   established
        \    request            clean up\n   The states associated with the LAC for
        outgoing calls are as follows:\n   idle\n      If the OCRQ is received in
        error, respond with a CDN.  Otherwise,\n      place the call, send an OCRP,
        and move to the wait-cs-answer\n      state.\n   wait-cs-answer\n      If
        the call is not completed or a timer expires while waiting for\n      the
        call to complete, send a CDN with the appropriate error\n      condition set,
        and go to idle state.  If a circuit-switched\n      connection is established,
        send an OCCN indicating success, and go\n      to established state.\n   established\n
        \     If the LAC receives a CDN from the peer, the call MUST be released\n
        \     via appropriate mechanisms, and the session cleaned up.  If the\n      call
        is disconnected because the circuit transitions to a\n      \"disconnected\"
        or \"down\" state, the LAC MUST send a CDN to the\n      peer and return to
        idle state.\n"
      title: 7.4.2.  OCRQ Recipient (LAC) States
    title: 7.4.  Outgoing Calls
  - contents:
    - "7.5.  Termination of a Control Connection\n   The termination of a control
      connection consists of either peer\n   issuing a StopCCN.  The sender of this
      message SHOULD wait a full\n   control message retransmission cycle (e.g., 1
      + 2 + 4 + 8 ...\n   seconds) for the acknowledgment of this message before releasing
      the\n   control information associated with the control connection.  The\n   recipient
      of this message should send an acknowledgment of the\n   message to the peer,
      then release the associated control information.\n   When to release a control
      connection is an implementation issue and\n   is not specified in this document.
      \ A particular implementation may\n   use whatever policy is appropriate for
      determining when to release a\n   control connection.  Some implementations
      may leave a control\n   connection open for a period of time or perhaps indefinitely
      after\n   the last session for that control connection is cleared.  Others may\n
      \  choose to disconnect the control connection immediately after the\n   last
      call on the control connection disconnects.\n"
    title: 7.5.  Termination of a Control Connection
  title: 7.  Control Connection State Machines
- contents:
  - "8.  Security Considerations\n   This section addresses some of the security issues
    that L2TP\n   encounters in its operation.\n"
  - contents:
    - "8.1.  Control Connection Endpoint and Message Security\n   If a shared secret
      (password) exists between two LCCEs, it may be\n   used to perform a mutual
      authentication between the two LCCEs, and\n   construct an authentication and
      integrity check of arriving L2TP\n   control messages.  The mechanism provided
      by L2TPv3 is described in\n   Section 4.3 and in the definition of the Message
      Digest and Control\n   Message Authentication Nonce AVPs in Section 5.4.1.\n
      \  This control message security mechanism provides for (1) mutual\n   endpoint
      authentication, and (2) individual control message integrity\n   and authenticity
      checking.  Mutual endpoint authentication ensures\n   that an L2TPv3 control
      connection is only established between two\n   endpoints that are configured
      with the proper password.  The\n   individual control message and integrity
      check guards against\n   accidental or intentional packet corruption (i.e.,
      those caused by a\n   control message spoofing or man-in-the-middle attack).\n
      \  The shared secret that is used for all control connection, control\n   message,
      and AVP security features defined in this document never\n   needs to be sent
      in the clear between L2TP tunnel endpoints.\n"
    title: 8.1.  Control Connection Endpoint and Message Security
  - contents:
    - "8.2.  Data Packet Spoofing\n   Packet spoofing for any type of Virtual Private
      Network (VPN)\n   protocol is of particular concern as insertion of carefully\n
      \  constructed rogue packets into the VPN transit network could result\n   in
      a violation of VPN traffic separation, leaking data into a\n   customer VPN.
      \ This is complicated by the fact that it may be\n   particularly difficult
      for the operator of the VPN to even be aware\n   that it has become a point
      of transit into or between customer VPNs.\n   L2TPv3 provides traffic separation
      for its VPNs via a 32-bit Session\n   ID in the L2TPv3 data header.  When present,
      the L2TPv3 Cookie\n   (described in Section 4.1), provides an additional check
      to ensure\n   that an arriving packet is intended for the identified session.\n
      \  Thus, use of a Cookie with the Session ID provides an extra guarantee\n   that
      the Session ID lookup was performed properly and that the\n   Session ID itself
      was not corrupted in transit.\n   In the presence of a blind packet spoofing
      attack, the Cookie may\n   also provide security against inadvertent leaking
      of frames into a\n   customer VPN.  To illustrate the type of security that
      it is provided\n   in this case, consider comparing the validation of a 64-bit
      Cookie in\n   the L2TPv3 header to the admission of packets that match a given\n
      \  source and destination IP address pair.  Both the source and\n   destination
      IP address pair validation and Cookie validation consist\n   of a fast check
      on cleartext header information on all arriving\n   packets.  However, since
      L2TPv3 uses its own value, it removes the\n   requirement for one to maintain
      a list of (potentially several)\n   permitted or denied IP addresses, and moreover,
      to guard knowledge of\n   the permitted IP addresses from hackers who may obtain
      and spoof\n   them.  Further, it is far easier to change a compromised L2TPv3\n
      \  Cookie than a compromised IP address,\" and a cryptographically random\n
      \  [RFC1750] value is far less likely to be discovered by brute-force\n   attacks
      compared to an IP address.\n   For protection against brute-force, blind, insertion
      attacks, a 64-\n   bit Cookie MUST be used with all sessions.  A 32-bit Cookie
      is\n   vulnerable to brute-force guessing at high packet rates, and as such,\n
      \  should not be considered an effective barrier to blind insertion\n   attacks
      (though it is still useful as an additional verification of a\n   successful
      Session ID lookup).  The Cookie provides no protection\n   against a sophisticated
      man-in-the-middle attacker who can sniff and\n   correlate captured data between
      nodes for use in a coordinated\n   attack.\n   The Assigned Cookie AVP is used
      to signal the value and size of the\n   Cookie that must be present in all data
      packets for a given session.\n   Each Assigned Cookie MUST be selected in a
      cryptographically random\n   manner [RFC1750] such that a series of Assigned
      Cookies does not\n   provide any indication of what a future Cookie will be.\n
      \  The L2TPv3 Cookie must not be regarded as a substitute for security\n   such
      as that provided by IPsec when operating over an open or\n   untrusted network
      where packets may be sniffed, decoded, and\n   correlated for use in a coordinated
      attack.  See Section 4.1.3 for\n   more information on running L2TP over IPsec.\n"
    title: 8.2.  Data Packet Spoofing
  title: 8.  Security Considerations
- contents:
  - "9.  Internationalization Considerations\n   The Host Name and Vendor Name AVPs
    are not internationalized.  The\n   Vendor Name AVP, although intended to be human-readable,
    would seem\n   to fit in the category of \"globally visible names\" [RFC2277]
    and so\n   is represented in US-ASCII.\n   If (1) an LCCE does not signify a language
    preference by the\n   inclusion of a Preferred Language AVP (see Section 5.4.3)
    in the\n   SCCRQ or SCCRP, (2) the Preferred Language AVP is unrecognized, or\n
    \  (3) the requested language is not supported by the peer LCCE, the\n   default
    language [RFC2277] MUST be used for all internationalized\n   strings sent by
    the peer.\n"
  title: 9.  Internationalization Considerations
- contents:
  - "10.  IANA Considerations\n   This document defines a number of \"magic\" numbers
    to be maintained by\n   the IANA.  This section explains the criteria used by
    the IANA to\n   assign additional numbers in each of these lists.  The following\n
    \  subsections describe the assignment policy for the namespaces defined\n   elsewhere
    in this document.\n   Sections 10.1 through 10.3 are requests for new values already\n
    \  managed by IANA according to [RFC3438].\n   The remaining sections are for
    new registries that have been added to\n   the existing L2TP registry and are
    maintained by IANA accordingly.\n"
  - contents:
    - "10.1.  Control Message Attribute Value Pairs (AVPs)\n   This number space is
      managed by IANA as per [RFC3438].\n   A summary of the new AVPs follows:\n   Control
      Message Attribute Value Pairs\n      Attribute\n      Type        Description\n
      \     ---------   ------------------\n         58       Extended Vendor ID AVP\n
      \        59       Message Digest\n         60       Router ID\n         61       Assigned
      Control Connection ID\n         62       Pseudowire Capabilities List\n         63
      \      Local Session ID\n         64       Remote Session ID\n         65       Assigned
      Cookie\n         66       Remote End ID\n         68       Pseudowire Type\n
      \        69       L2-Specific Sublayer\n         70       Data Sequencing\n
      \        71       Circuit Status\n         72       Preferred Language\n         73
      \      Control Message Authentication Nonce\n         74       Tx Connect Speed\n
      \        75       Rx Connect Speed\n"
    title: 10.1.  Control Message Attribute Value Pairs (AVPs)
  - contents:
    - "10.2.  Message Type AVP Values\n   This number space is managed by IANA as
      per [RFC3438].  There is one\n   new message type, defined in Section 3.1, that
      was allocated for this\n   specification:\n   Message Type AVP (Attribute Type
      0) Values\n   ------------------------------------------\n     Control Connection
      Management\n         20 (ACK)  Explicit Acknowledgement\n"
    title: 10.2.  Message Type AVP Values
  - contents:
    - "10.3.  Result Code AVP Values\n   This number space is managed by IANA as per
      [RFC3438].\n   New Result Code values for the CDN message are defined in Section\n
      \  5.4.  The following is a summary:\n   Result Code AVP (Attribute Type 1)
      Values\n   -----------------------------------------\n      General Error Codes\n
      \        13 - Session not established due to losing\n              tie breaker
      (L2TPv3).\n         14 - Session not established due to unsupported\n              PW
      type (L2TPv3).\n         15 - Session not established, sequencing required\n
      \             without valid L2-Specific Sublayer (L2TPv3).\n         16 - Finite
      state machine error or timeout.\n"
    title: 10.3.  Result Code AVP Values
  - contents:
    - "10.4.  AVP Header Bits\n   This is a new registry for IANA to maintain.\n   Leading
      Bits of the L2TP AVP Header\n   -----------------------------------\n   There
      six bits at the beginning of the L2TP AVP header.  New bits are\n   assigned
      via Standards Action [RFC2434].\n   Bit 0 - Mandatory (M bit)\n   Bit 1 - Hidden
      (H bit)\n   Bit 2 - Reserved\n   Bit 3 - Reserved\n   Bit 4 - Reserved\n   Bit
      5 - Reserved\n"
    title: 10.4.  AVP Header Bits
  - contents:
    - "10.5.  L2TP Control Message Header Bits\n   This is a new registry for IANA
      to maintain.\n   Leading Bits of the L2TP Control Message Header\n   -----------------------------------------------\n
      \  There are 12 bits at the beginning of the L2TP Control Message\n   Header.
      \ Reserved bits should only be defined by Standard\n   Action [RFC2434].\n   Bit
      \ 0 - Message Type (T bit)\n   Bit  1 - Length Field is Present (L bit)\n   Bit
      \ 2 - Reserved\n   Bit  3 - Reserved\n   Bit  4 - Sequence Numbers Present (S
      bit)\n   Bit  5 - Reserved\n   Bit  6 - Offset Field is Present [RFC2661]\n
      \  Bit  7 - Priority Bit (P bit) [RFC2661]\n   Bit  8 - Reserved\n   Bit  9
      - Reserved\n   Bit 10 - Reserved\n   Bit 11 - Reserved\n"
    title: 10.5.  L2TP Control Message Header Bits
  - contents:
    - "10.6.  Pseudowire Types\n   This is a new registry for IANA to maintain, there
      are no values\n   assigned within this document to maintain.\n   L2TPv3 Pseudowire
      Types\n   -----------------------\n   The Pseudowire Type (PW Type, see Section
      5.4) is a 2-octet value\n   used in the Pseudowire Type AVP and Pseudowire Capabilities
      List AVP\n   defined in Section 5.4.3.  0 to 32767 are assignable by Expert
      Review\n   [RFC2434], while 32768 to 65535 are assigned by a First Come First\n
      \  Served policy [RFC2434].  There are no specific pseudowire types\n   assigned
      within this document.  Each pseudowire-specific document\n   must allocate its
      own PW types from IANA as necessary.\n"
    title: 10.6.  Pseudowire Types
  - contents:
    - "10.7.  Circuit Status Bits\n   This is a new registry for IANA to maintain.\n
      \  Circuit Status Bits\n   -------------------\n   The Circuit Status field
      is a 16-bit mask, with the two low order\n   bits assigned.  Additional bits
      may be assigned by IETF Consensus\n   [RFC2434].\n   Bit 14 - New (N bit)\n
      \  Bit 15 - Active (A bit)\n"
    title: 10.7.  Circuit Status Bits
  - contents:
    - "10.8.  Default L2-Specific Sublayer bits\n   This is a new registry for IANA
      to maintain.\n   Default L2-Specific Sublayer Bits\n   ---------------------------------\n
      \  The Default L2-Specific Sublayer contains 8 bits in the low-order\n   portion
      of the header.  Reserved bits may be assigned by IETF\n   Consensus [RFC2434].\n
      \  Bit 0 - Reserved\n   Bit 1 - Sequence (S bit)\n   Bit 2 - Reserved\n   Bit
      3 - Reserved\n   Bit 4 - Reserved\n   Bit 5 - Reserved\n   Bit 6 - Reserved\n
      \  Bit 7 - Reserved\n"
    title: 10.8.  Default L2-Specific Sublayer bits
  - contents:
    - "10.9.  L2-Specific Sublayer Type\n   This is a new registry for IANA to maintain.\n
      \  L2-Specific Sublayer Type\n   -------------------------\n   The L2-Specific
      Sublayer Type is a 2-octet unsigned integer.\n   Additional values may be assigned
      by Expert Review [RFC2434].\n   0 - No L2-Specific Sublayer\n   1 - Default
      L2-Specific Sublayer present\n"
    title: 10.9.  L2-Specific Sublayer Type
  - contents:
    - "10.10.  Data Sequencing Level\n   This is a new registry for IANA to maintain.\n
      \  Data Sequencing Level\n   ---------------------\n   The Data Sequencing Level
      is a 2-octet unsigned integer\n   Additional values may be assigned by Expert
      Review [RFC2434].\n   0 - No incoming data packets require sequencing.\n   1
      - Only non-IP data packets require sequencing.\n   2 - All incoming data packets
      require sequencing.\n"
    title: 10.10.  Data Sequencing Level
  title: 10.  IANA Considerations
- contents:
  - '11.  References

    '
  - contents:
    - "11.1.  Normative References\n   [RFC2119] Bradner, S., \"Key words for use
      in RFCs to Indicate\n             Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC2277] Alvestrand, H., \"IETF Policy on Character Sets and\n             Languages\",
      BCP 18, RFC 2277, January 1998.\n   [RFC2434] Narten, T. and H. Alvestrand,
      \"Guidelines for Writing an\n             IANA Considerations section in RFCs\",
      BCP 26, RFC 2434,\n             October 1998.\n   [RFC2473] Conta, A. and S.
      Deering, \"Generic Packet Tunneling in IPv6\n             Specification\", RFC
      2473, December 1998.\n   [RFC2661] Townsley, W., Valencia, A., Rubens, A., Pall,
      G., Zorn, G.,\n             and Palter, B., \"Layer Two Tunneling Layer Two
      Tunneling\n             Protocol (L2TP)\", RFC 2661, August 1999.\n   [RFC2865]
      Rigney, C., Willens, S., Rubens, A., and W. Simpson,\n             \"Remote
      Authentication Dial In User Service (RADIUS)\", RFC\n             2865, June
      2000.\n   [RFC3066] Alvestrand, H., \"Tags for the Identification of Languages\",\n
      \            BCP 47, RFC 3066, January 2001.\n   [RFC3193] Patel, B., Aboba,
      B., Dixon, W., Zorn, G., and Booth, S.,\n             \"Securing L2TP using
      IPsec\", RFC 3193, November 2001.\n   [RFC3438] Townsley, W., \"Layer Two Tunneling
      Protocol (L2TP) Internet\n             Assigned Numbers Authority (IANA) Considerations
      Update\",\n             BCP 68, RFC 3438, December 2002.\n   [RFC3629] Yergeau,
      F., \"UTF-8, a transformation format of ISO 10646\",\n             STD 63, RFC
      3629, November 2003.\n"
    title: 11.1.  Normative References
  - contents:
    - "11.2.  Informative References\n   [RFC1034] Mockapetris, P., \"Domain Names
      - Concepts and Facilities\",\n             STD 13, RFC 1034, November 1987.\n
      \  [RFC1191] Mogul, J. and S. Deering, \"Path MTU Discovery\", RFC 1191,\n             November
      1990.\n   [RFC1321] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321,\n
      \            April 1992.\n   [RFC1661] Simpson, W., Ed., \"The Point-to-Point
      Protocol (PPP)\", STD\n             51, RFC 1661, July 1994.\n   [RFC1700] Reynolds,
      J. and Postel, J., \"Assigned Numbers\", STD 2, RFC\n             1700, October
      1994.\n   [RFC1750] Eastlake, D., Crocker, S., and Schiller, J., \"Randomness\n
      \            Recommendations for Security\", RFC 1750, December 1994.\n   [RFC1958]
      Carpenter, B., Ed., \"Architectural Principles of the\n             Internet\",
      RFC 1958, June 1996.\n   [RFC1981] McCann, J., Deering, S., and Mogul, J., \"Path
      MTU Discovery\n             for IP version 6\", RFC 1981, August 1996.\n   [RFC2072]
      Berkowitz, H., \"Router Renumbering Guide\", RFC 2072,\n             January
      1997.\n   [RFC2104] Krawczyk, H., Bellare, M., and Canetti, R., \"HMAC:  Keyed-\n
      \            Hashing for Message Authentication\", RFC 2104, February\n             1997.\n
      \  [RFC2341] Valencia, A., Littlewood, M., and Kolar, T., \"Cisco Layer\n             Two
      Forwarding (Protocol) L2F\", RFC 2341, May 1998.\n   [RFC2401] Kent, S. and
      Atkinson, R., \"Security Architecture for the\n             Internet Protocol\",
      RFC 2401, November 1998.\n   [RFC2581] Allman, M., Paxson, V., and Stevens,
      W., \"TCP Congestion\n             Control\", RFC 2581, April 1999.\n   [RFC2637]
      Hamzeh, K., Pall, G., Verthein, W., Taarud, J., Little, W.,\n             and
      Zorn, G., \"Point-to-Point Tunneling Protocol (PPTP)\",\n             RFC 2637,
      July 1999.\n   [RFC2732] Hinden, R., Carpenter, B., and Masinter, L., \"Format
      for\n             Literal IPv6 Addresses in URL's\", RFC 2732, December 1999.\n
      \  [RFC2809] Aboba, B. and Zorn, G., \"Implementation of L2TP Compulsory\n             Tunneling
      via RADIUS\", RFC 2809, April 2000.\n   [RFC3070] Rawat, V., Tio, R., Nanji,
      S., and Verma, R., \"Layer Two\n             Tunneling Protocol (L2TP) over
      Frame Relay\", RFC 3070,\n             February 2001.\n   [RFC3355] Singh, A.,
      Turner, R., Tio, R., and Nanji, S., \"Layer Two\n             Tunnelling Protocol
      (L2TP) Over ATM Adaptation Layer 5\n             (AAL5)\", RFC 3355, August
      2002.\n   [KPS]     Kaufman, C., Perlman, R., and Speciner, M., \"Network\n
      \            Security:  Private Communications in a Public World\",\n             Prentice
      Hall, March 1995, ISBN 0-13-061466-1.\n   [STEVENS] Stevens, W. Richard, \"TCP/IP
      Illustrated, Volume I: The\n             Protocols\", Addison-Wesley Publishing
      Company, Inc., March\n             1996, ISBN 0-201-63346-9.\n"
    title: 11.2.  Informative References
  title: 11.  References
- contents:
  - "12.  Acknowledgments\n   Many of the protocol constructs were originally defined
    in, and the\n   text of this document began with, RFC 2661, \"L2TPv2\".  RFC 2661\n
    \  authors are W. Townsley, A. Valencia, A. Rubens, G. Pall, G. Zorn and\n   B.
    Palter.\n   The basic concept for L2TP and many of its protocol constructs were\n
    \  adopted from L2F [RFC2341] and PPTP [RFC2637].  Authors of these\n   versions
    are A. Valencia, M. Littlewood, T. Kolar, K. Hamzeh, G.\n   Pall, W. Verthein,
    J. Taarud, W. Little, and G. Zorn.\n   Danny Mcpherson and Suhail Nanji published
    the first \"L2TP Service\n   Type\" version, which defined the use of L2TP for
    tunneling of various\n   L2 payload types (initially, Ethernet and Frame Relay).\n
    \  The team for splitting RFC 2661 into this base document and the\n   companion
    PPP document consisted of Ignacio Goyret, Jed Lau, Bill\n   Palter, Mark Townsley,
    and Madhvi Verma.  Skip Booth also provided\n   very helpful review and comment.\n
    \  Some constructs of L2TPv3 were based in part on UTI (Universal\n   Transport
    Interface), which was originally conceived by Peter\n   Lothberg and Tony Bates.\n
    \  Stewart Bryant and Simon Barber provided valuable input for the\n   L2TPv3
    over IP header.\n   Juha Heinanen provided helpful review in the early stages
    of this\n   effort.\n   Jan Vilhuber, Scott Fluhrer, David McGrew, Scott Wainner,
    Skip Booth\n   and Maria Dos Santos contributed to the Control Message\n   Authentication
    Mechanism as well as general discussions of security.\n   James Carlson, Thomas
    Narten, Maria Dos Santos, Steven Bellovin, Ted\n   Hardie, and Pekka Savola provided
    very helpful review of the final\n   versions of text.\n   Russ Housley provided
    valuable review and comment on security,\n   particularly with respect to the
    Control Message Authentication\n   mechanism.\n   Pekka Savola contributed to
    proper alignment with IPv6 and inspired\n   much of Section 4.1.4 on fragmentation.\n
    \  Aside of his original influence and co-authorship of RFC 2661, Glen\n   Zorn
    helped get all of the language and character references straight\n   in this document.\n
    \  A number of people provided valuable input and effort for RFC 2661,\n   on
    which this document was based:\n   John Bray, Greg Burns, Rich Garrett, Don Grosser,
    Matt Holdrege,\n   Terry Johnson, Dory Leifer, and Rich Shea provided valuable
    input and\n   review at the 43rd IETF in Orlando, FL, which led to improvement
    of\n   the overall readability and clarity of RFC 2661.\n   Thomas Narten provided
    a great deal of critical review and\n   formatting.  He wrote the first version
    of the IANA Considerations\n   section.\n   Dory Leifer made valuable refinements
    to the protocol definition of\n   L2TP and contributed to the editing of early
    versions leading to RFC\n   2661.\n   Steve Cobb and Evan Caves redesigned the
    state machine tables.\n   Barney Wolff provided a great deal of design input on
    the original\n   endpoint authentication mechanism.\n"
  title: 12.  Acknowledgments
- contents:
  - "Appendix A: Control Slow Start and Congestion Avoidance\n   Although each side
    has indicated the maximum size of its receive\n   window, it is recommended that
    a slow start and congestion avoidance\n   method be used to transmit control packets.
    \ The methods described\n   here are based upon the TCP congestion avoidance algorithm
    as\n   described in Section 21.6 of TCP/IP Illustrated, Volume I, by W.\n   Richard
    Stevens [STEVENS] (this algorithm is also described in\n   [RFC2581]).\n   Slow
    start and congestion avoidance make use of several variables.\n   The congestion
    window (CWND) defines the number of packets a sender\n   may send before waiting
    for an acknowledgment.  The size of CWND\n   expands and contracts as described
    below.  Note, however, that CWND\n   is never allowed to exceed the size of the
    advertised window obtained\n   from the Receive Window AVP.  (In the text below,
    it is assumed any\n   increase will be limited by the Receive Window Size.)  The
    variable\n   SSTHRESH determines when the sender switches from slow start to\n
    \  congestion avoidance.  Slow start is used while CWND is less than\n   SSHTRESH.\n
    \  A sender starts out in the slow start phase.  CWND is initialized to\n   one
    packet, and SSHTRESH is initialized to the advertised window\n   (obtained from
    the Receive Window AVP).  The sender then transmits\n   one packet and waits for
    its acknowledgment (either explicit or\n   piggybacked).  When the acknowledgment
    is received, the congestion\n   window is incremented from one to two.  During
    slow start, CWND is\n   increased by one packet each time an ACK (explicit ACK
    message or\n   piggybacked) is received.  Increasing CWND by one on each ACK has
    the\n   effect of doubling CWND with each round trip, resulting in an\n   exponential
    increase.  When the value of CWND reaches SSHTRESH, the\n   slow start phase ends
    and the congestion avoidance phase begins.\n   During congestion avoidance, CWND
    expands more slowly.  Specifically,\n   it increases by 1/CWND for every new ACK
    received.  That is, CWND is\n   increased by one packet after CWND new ACKs have
    been received.\n   Window expansion during the congestion avoidance phase is effectively\n
    \  linear, with CWND increasing by one packet each round trip.\n   When congestion
    occurs (indicated by the triggering of a\n   retransmission) one-half of the CWND
    is saved in SSTHRESH, and CWND\n   is set to one.  The sender then reenters the
    slow start phase.\n"
  title: 'Appendix A: Control Slow Start and Congestion Avoidance'
- contents:
  - 'Appendix B: Control Message Examples

    '
  - contents:
    - "B.1: Lock-Step Control Connection Establishment\n   In this example, an LCCE
      establishes a control connection, with the\n   exchange involving each side
      alternating in sending messages.  This\n   example shows the final acknowledgment
      explicitly sent within an ACK\n   message.  An alternative would be to piggyback
      the acknowledgment\n   within a message sent as a reply to the ICRQ or OCRQ
      that will likely\n   follow from the side that initiated the control connection.\n
      \     LCCE A                   LCCE B\n      ------                   ------\n
      \     SCCRQ     ->\n      Nr: 0, Ns: 0\n                               <-     SCCRP\n
      \                              Nr: 1, Ns: 0\n      SCCCN     ->\n      Nr: 1,
      Ns: 1\n                               <-       ACK\n                               Nr:
      2, Ns: 1\n"
    title: 'B.1: Lock-Step Control Connection Establishment'
  - contents:
    - "B.2: Lost Packet with Retransmission\n   An existing control connection has
      a new session requested by LCCE A.\n   The ICRP is lost and must be retransmitted
      by LCCE B.  Note that loss\n   of the ICRP has two effects: It not only keeps
      the upper level state\n   machine from progressing, but also keeps LCCE A from
      seeing a timely\n   lower level acknowledgment of its ICRQ.\n        LCCE A
      \                          LCCE B\n        ------                           ------\n
      \       ICRQ      ->\n        Nr: 1, Ns: 2\n                         (packet
      lost)   <-      ICRP\n                                         Nr: 3, Ns: 1\n
      \     (pause; LCCE A's timer started first, so fires first)\n       ICRQ      ->\n
      \      Nr: 1, Ns: 2\n      (Realizing that it has already seen this packet,\n
      \      LCCE B discards the packet and sends an ACK message)\n                                         <-
      \      ACK\n                                         Nr: 3, Ns: 2\n      (LCCE
      B's retransmit timer fires)\n                                         <-      ICRP\n
      \                                        Nr: 3, Ns: 1\n       ICCN      ->\n
      \      Nr: 2, Ns: 3\n                                         <-       ACK\n
      \                                        Nr: 4, Ns: 2\n"
    title: 'B.2: Lost Packet with Retransmission'
  title: 'Appendix B: Control Message Examples'
- contents:
  - "Appendix C: Processing Sequence Numbers\n   The Default L2-Specific Sublayer,
    defined in Section 4.6, provides a\n   24-bit field for sequencing of data packets
    within an L2TP session.\n   L2TP data packets are never retransmitted, so this
    sequence is used\n   only to detect packet order, duplicate packets, or lost packets.\n
    \  The 24-bit Sequence Number field of the Default L2-Specific Sublayer\n   contains
    a packet sequence number for the associated session.  Each\n   sequenced data
    packet that is sent must contain the sequence number,\n   incremented by one,
    of the previous sequenced packet sent on a given\n   L2TP session.  Upon receipt,
    any packet with a sequence number equal\n   to or greater than the current expected
    packet (the last received\n   in-order packet plus one) should be considered \"new\"
    and accepted.\n   All other packets are considered \"old\" or \"duplicate\" and
    discarded.\n   Note that the 24-bit sequence number space includes zero as a valid\n
    \  sequence number (as such, it may be implemented with a masked 32-bit\n   counter
    if desired).  All new sessions MUST begin sending sequence\n   numbers at zero.\n
    \  Larger or smaller sequence number fields are possible with L2TP if an\n   alternative
    format to the Default L2-Specific Sublayer defined in\n   this document is used.
    \ While 24 bits may be adequate in a number of\n   circumstances, a larger sequence
    number space will be less\n   susceptible to sequence number wrapping problems
    for very high\n   session data rates across long dropout periods.  The sequence
    number\n   processing recommendations below should hold for any size sequence\n
    \  number field.\n   When detecting whether a packet sequence number is \"greater\"
    or\n   \"less\" than a given sequence number value, wrapping of the sequence\n
    \  number must be considered.  This is typically accomplished by keeping\n   a
    window of sequence numbers beyond the current expected sequence\n   number for
    determination of whether a packet is \"new\" or not.  The\n   window may be sized
    based on the link speed and sequence number space\n   and SHOULD be configurable
    with a default equal to one half the size\n   of the available number space (e.g.,
    2^(n-1), where n is the number\n   of bits available in the sequence number).\n
    \  Upon receipt, packets that exactly match the expected sequence number\n   are
    processed immediately and the next expected sequence number\n   incremented.  Packets
    that fall within the window for new packets may\n   either be processed immediately
    and the next expected sequence number\n   updated to one plus that received in
    the new packet, or held for a\n   very short period of time in hopes of receiving
    the missing\n   packet(s).  This \"very short period\" should be configurable,
    with a\n   default corresponding to a time lapse that is at least an order of\n
    \  magnitude less than the retransmission timeout periods of higher\n   layer
    protocols such as TCP.\n   For typical transient packet mis-orderings, dropping
    out-of-order\n   packets alone should suffice and generally requires far less\n
    \  resources than actively reordering packets within L2TP.  An exception\n   is
    a case in which a pair of packet fragments are persistently\n   retransmitted
    and sent out-of-order.  For example, if an IP packet\n   has been fragmented into
    a very small packet followed by a very large\n   packet before being tunneled
    by L2TP, it is possible (though\n   admittedly wrong) that the two resulting L2TP
    packets may be\n   consistently mis-ordered by the PSN in transit between L2TP
    nodes.\n   If sequence numbers were being enforced at the receiving node without\n
    \  any buffering of out-of-order packets, then the fragmented IP packet\n   may
    never reach its destination.  It may be worth noting here that\n   this condition
    is true for any tunneling mechanism of IP packets that\n   includes sequence number
    checking on receipt (i.e., GRE [RFC2890]).\n   Utilization of a Data Sequencing
    Level (see Section 5.4.3) of 1 (only\n   non-IP data packets require sequencing)
    allows IP data packets being\n   tunneled by L2TP to not utilize sequence numbers,
    while utilizing\n   sequence numbers and enforcing packet order for any remaining
    non-IP\n   data packets.  Depending on the requirements of the link layer being\n
    \  tunneled and the network data traversing the data link, this is\n   sufficient
    in many cases to enforce packet order on frames that\n   require it (such as end-to-end
    data link control messages), while not\n   on IP packets that are known to be
    resilient to packet reordering.\n   If a large number of packets (i.e., more than
    one new packet window)\n   are dropped due to an extended outage or loss of sequence
    number\n   state on one side of the connection (perhaps as part of a forwarding\n
    \  plane reset or failover to a standby node), it is possible that a\n   large
    number of packets will be sent in-order, but be wrongly\n   detected by the peer
    as out-of-order.  This can be generally\n   characterized for a window size, w,
    sequence number space, s, and\n   number of packets lost in transit between L2TP
    endpoints, p, as\n   follows:\n   If s > p > w, then an additional (s - p) packets
    that were otherwise\n   received in-order, will be incorrectly classified as out-of-order
    and\n   dropped.  Thus, for a sequence number space, s = 128, window size, w\n
    \  = 64, and number of lost packets, p = 70; 128 - 70 = 58 additional\n   packets
    would be dropped after the outage until the sequence number\n   wrapped back to
    the current expected next sequence number.\n   To mitigate this additional packet
    loss, one MUST inspect the\n   sequence numbers of packets dropped due to being
    classified as \"old\"\n   and reset the expected sequence number accordingly.
    \ This may be\n   accomplished by counting the number of \"old\" packets dropped
    that\n   were in sequence among themselves and, upon reaching a threshold,\n   resetting
    the next expected sequence number to that seen in the\n   arriving data packets.
    \ Packet timestamps may also be used as an\n   indicator to reset the expected
    sequence number by detecting a period\n   of time over which \"old\" packets have
    been received in-sequence.  The\n   ideal thresholds will vary depending on link
    speed, sequence number\n   space, and link tolerance to out-of-order packets,
    and MUST be\n   configurable.\n"
  title: 'Appendix C: Processing Sequence Numbers'
- contents:
  - "Editors' Addresses\n   Jed Lau\n   cisco Systems\n   170 W. Tasman Drive\n   San
    Jose, CA  95134\n   EMail: jedlau@cisco.com\n   W. Mark Townsley\n   cisco Systems\n
    \  EMail: mark@townsley.net\n   Ignacio Goyret\n   Lucent Technologies\n   EMail:
    igoyret@lucent.com\n"
  title: Editors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This
    document is subject to the rights, licenses and restrictions\n   contained in
    BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at ietf-\n   ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
