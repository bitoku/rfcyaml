- title: __initial_text__
  contents:
  - '                    Domain Name System (DNS) Cookies

    '
- title: Abstract
  contents:
  - "Abstract\n   DNS Cookies are a lightweight DNS transaction security mechanism\
    \ that\n   provides limited protection to DNS servers and clients against a\n\
    \   variety of increasingly common denial-of-service and amplification/\n   forgery\
    \ or cache poisoning attacks by off-path attackers.  DNS\n   Cookies are tolerant\
    \ of NAT, NAT-PT (Network Address Translation -\n   Protocol Translation), and\
    \ anycast and can be incrementally deployed.\n   (Since DNS Cookies are only returned\
    \ to the IP address from which\n   they were originally received, they cannot\
    \ be used to generally track\n   Internet users.)\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7873.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Contents of This Document ..................................4\n  \
    \    1.2. Definitions ................................................5\n   2.\
    \ Threats Considered ..............................................5\n      2.1.\
    \ Denial-of-Service Attacks ..................................6\n           2.1.1.\
    \ DNS Amplification Attacks ...........................6\n           2.1.2. DNS\
    \ Server Denial of Service ........................6\n      2.2. Cache Poisoning\
    \ and Answer Forgery Attacks .................7\n   3. Comments on Existing DNS\
    \ Security ...............................7\n      3.1. Existing DNS Data Security\
    \ .................................7\n      3.2. DNS Message/Transaction Security\
    \ ...........................8\n      3.3. Conclusions on Existing DNS Security\
    \ .......................8\n   4. DNS COOKIE Option ...............................................8\n\
    \      4.1. Client Cookie .............................................10\n  \
    \    4.2. Server Cookie .............................................10\n   5.\
    \ DNS Cookies Protocol Specification .............................11\n      5.1.\
    \ Originating a Request .....................................11\n      5.2. Responding\
    \ to a Request ...................................11\n           5.2.1. No OPT\
    \ RR or No COOKIE Option ......................12\n           5.2.2. Malformed\
    \ COOKIE Option ............................12\n           5.2.3. Only a Client\
    \ Cookie ...............................12\n           5.2.4. A Client Cookie\
    \ and an Invalid Server Cookie .......13\n           5.2.5. A Client Cookie and\
    \ a Valid Server Cookie ..........13\n      5.3. Processing Responses ......................................14\n\
    \      5.4. Querying for a Server Cookie ..............................14\n  \
    \ 6. NAT Considerations and Anycast Server Considerations ...........15\n   7.\
    \ Operational and Deployment Considerations ......................17\n      7.1.\
    \ Client and Server Secret Rollover .........................17\n      7.2. Counters\
    \ ..................................................18\n   8. IANA Considerations\
    \ ............................................18\n   9. Security Considerations\
    \ ........................................19\n      9.1. Cookie Algorithm Considerations\
    \ ...........................20\n   10. Implementation Considerations .................................20\n\
    \   11. References ....................................................20\n  \
    \    11.1. Normative References .....................................20\n    \
    \  11.2. Informative References ...................................21\n   Appendix\
    \ A. Example Client Cookie Algorithms ......................23\n      A.1. A Simple\
    \ Algorithm ........................................23\n      A.2. A More Complex\
    \ Algorithm ..................................23\n   Appendix B. Example Server\
    \ Cookie Algorithms ......................23\n      B.1. A Simple Algorithm ........................................23\n\
    \      B.2. A More Complex Algorithm ..................................24\n  \
    \ Acknowledgments ...................................................25\n   Authors'\
    \ Addresses ................................................25\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   As with many core Internet protocols, the Domain Name System\
    \ (DNS)\n   was originally designed at a time when the Internet had only a small\n\
    \   pool of trusted users.  As the Internet has grown exponentially to a\n   global\
    \ information utility, the DNS has increasingly been subject to\n   abuse.\n \
    \  This document describes DNS Cookies, a lightweight DNS transaction\n   security\
    \ mechanism specified as an OPT [RFC6891] option.  The\n   DNS Cookie mechanism\
    \ provides limited protection to DNS servers and\n   clients against a variety\
    \ of increasingly common abuses by off-path\n   attackers.  It is compatible with,\
    \ and can be used in conjunction\n   with, other DNS transaction forgery resistance\
    \ measures such as those\n   in [RFC5452].  (Since DNS Cookies are only returned\
    \ to the IP address\n   from which they were originally received, they cannot\
    \ be used to\n   generally track Internet users.)\n   The protection provided\
    \ by DNS Cookies is similar to that provided by\n   using TCP for DNS transactions.\
    \  Bypassing the weak protection\n   provided by using TCP requires, among other\
    \ things, that an off-path\n   attacker guess the 32-bit TCP sequence number in\
    \ use.  Bypassing the\n   weak protection provided by DNS Cookies requires such\
    \ an attacker to\n   guess a 64-bit pseudorandom \"cookie\" quantity.  Where DNS\
    \ Cookies are\n   not available but TCP is, falling back to using TCP is reasonable.\n\
    \   If only one party to a DNS transaction supports DNS Cookies, the\n   mechanism\
    \ does not provide a benefit or significantly interfere, but\n   if both support\
    \ it, the additional security provided is automatically\n   available.\n   The\
    \ DNS Cookie mechanism is designed to work in the presence of NAT\n   and NAT-PT\
    \ (Network Address Translation - Protocol Translation)\n   boxes, and guidance\
    \ is provided herein on supporting the DNS Cookie\n   mechanism in anycast servers.\n"
- title: 1.1.  Contents of This Document
  contents:
  - "1.1.  Contents of This Document\n   In Section 2, we discuss the threats against\
    \ which the DNS Cookie\n   mechanism provides some protection.\n   Section 3 describes\
    \ existing DNS security mechanisms and why they are\n   not adequate substitutes\
    \ for DNS Cookies.\n   Section 4 describes the COOKIE option.\n   Section 5 provides\
    \ a protocol description.\n   Section 6 discusses some NAT considerations and\
    \ anycast-related\n   DNS Cookies design considerations.\n   Section 7 discusses\
    \ incremental deployment considerations.\n   Sections 8 and 9 describe IANA considerations\
    \ and security\n   considerations, respectively.\n"
- title: 1.2.  Definitions
  contents:
  - "1.2.  Definitions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT\
    \ RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   [RFC2119].\n   \"Off-path attacker\", for a particular DNS\
    \ client and server, is\n      defined as an attacker who cannot observe the DNS\
    \ request and\n      response messages between that client and server.\n   \"\
    Soft state\" indicates information that is learned or derived by a\n      host\
    \ and that may be discarded when indicated by the policies of\n      that host\
    \ but can be re-instantiated later if needed.  For\n      example, it could be\
    \ discarded after a period of time or when\n      storage for caching such data\
    \ becomes full.  If operations that\n      require soft state continue after the\
    \ information has been\n      discarded, the information will be automatically\
    \ regenerated,\n      albeit at some cost.\n   \"Silently discarded\" indicates\
    \ that there are no DNS protocol message\n      consequences.\n   \"IP address\"\
    \ is used herein as a length-independent term and includes\n      both IPv4 and\
    \ IPv6 addresses.\n"
- title: 2.  Threats Considered
  contents:
  - "2.  Threats Considered\n   DNS Cookies are intended to provide significant but\
    \ limited\n   protection against certain attacks by off-path attackers, as\n \
    \  described below.  These attacks include denial of service, cache\n   poisoning,\
    \ and answer forgery.\n"
- title: 2.1.  Denial-of-Service Attacks
  contents:
  - "2.1.  Denial-of-Service Attacks\n   The typical form of the denial-of-service\
    \ attacks considered herein\n   is to send DNS requests with forged source IP\
    \ addresses to a server.\n   The intent can be to attack that server or some other\
    \ selected host,\n   as described below.\n   There are also on-path denial-of-service\
    \ attacks that attempt to\n   saturate a server with DNS requests having correct\
    \ source addresses.\n   Cookies do not protect against such attacks, but successful\
    \ cookie\n   validation improves the probability that the correct source IP\n\
    \   address for the requests is known.  This facilitates contacting the\n   managers\
    \ of the networks from which the requests originate or taking\n   other actions\
    \ for those networks.\n"
- title: 2.1.1.  DNS Amplification Attacks
  contents:
  - "2.1.1.  DNS Amplification Attacks\n   A request with a forged source IP address\
    \ generally causes a response\n   to be sent to that forged IP address.  Thus,\
    \ the forging of many such\n   requests with a particular source IP address can\
    \ result in enough\n   traffic being sent to the forged IP address to interfere\
    \ with service\n   to the host at the IP address.  Furthermore, it is generally\
    \ easy in\n   the DNS to create short requests that produce much longer responses,\n\
    \   thus amplifying the attack.\n   The DNS Cookie mechanism can severely limit\
    \ the traffic amplification\n   obtained by requests from an attacker that is\
    \ off the path between\n   the server and the request's source address.  Enforced\
    \ DNS Cookies\n   would make it hard for an off-path attacker to cause any more\
    \ than\n   rate-limited short error responses to be sent to a forged IP address,\n\
    \   so the attack would be attenuated rather than amplified.  DNS Cookies\n  \
    \ make it more effective to implement a rate-limiting scheme for error\n   responses\
    \ from the server.  Such a scheme would further restrict\n   selected host denial-of-service\
    \ traffic from that server.\n"
- title: 2.1.2.  DNS Server Denial of Service
  contents:
  - "2.1.2.  DNS Server Denial of Service\n   DNS requests that are accepted cause\
    \ work on the part of DNS servers.\n   This is particularly true for recursive\
    \ servers that may issue one or\n   more requests and process the responses thereto,\
    \ in order to\n   determine their response to the initial request; the situation\
    \ can be\n   even worse for recursive servers implementing DNSSEC [RFC4033]\n\
    \   [RFC4034] [RFC4035], because they may be induced to perform\n   burdensome\
    \ cryptographic computations in attempts to verify the\n   authenticity of data\
    \ they retrieve in trying to answer the request.\n   The computational or communications\
    \ burden caused by such requests\n   may not depend on a forged source IP address,\
    \ but the use of such\n   addresses makes\n   + the source of the requests causing\
    \ the denial-of-service attack\n     harder to find and\n   + restriction of the\
    \ IP addresses from which such requests should be\n     honored hard or impossible\
    \ to specify or verify.\n   The use of DNS Cookies should enable a server to reject\
    \ forged\n   requests from an off-path attacker with relative ease and before\
    \ any\n   recursive queries or public key cryptographic operations are\n   performed.\n"
- title: 2.2.  Cache Poisoning and Answer Forgery Attacks
  contents:
  - "2.2.  Cache Poisoning and Answer Forgery Attacks\n   The form of the cache poisoning\
    \ attacks considered is to send forged\n   replies to a resolver.  Modern network\
    \ speeds for well-connected\n   hosts are such that, by forging replies from the\
    \ IP addresses of a\n   DNS server to a resolver for names that resolver has been\
    \ induced to\n   resolve or for common names whose resource records have short\n\
    \   time-to-live values, there can be an unacceptably high probability of\n  \
    \ randomly coming up with a reply that will be accepted and cause false\n   DNS\
    \ information to be cached by that resolver (the Dan Kaminsky\n   attack [Kaminsky]).\
    \  This can be used to facilitate phishing attacks\n   and other diversions of\
    \ legitimate traffic to a compromised or\n   malicious host such as a web server.\n\
    \   With the use of DNS Cookies, a resolver can generally reject such\n   forged\
    \ replies.\n"
- title: 3.  Comments on Existing DNS Security
  contents:
  - "3.  Comments on Existing DNS Security\n   Two forms of security have been added\
    \ to DNS: data security and\n   message/transaction security.\n"
- title: 3.1.  Existing DNS Data Security
  contents:
  - "3.1.  Existing DNS Data Security\n   DNS data security is one part of DNSSEC\
    \ and is described in\n   [RFC4033], [RFC4034], [RFC4035], and updates thereto.\
    \  It provides\n   data origin authentication and authenticated denial of existence.\n\
    \   DNSSEC is being deployed and can provide strong protection against\n   forged\
    \ data and cache poisoning; however, it has the unintended\n   effect of making\
    \ some denial-of-service attacks worse because of the\n   cryptographic computational\
    \ load it can require and the increased\n   size in DNS response packets that\
    \ it tends to produce.\n"
- title: 3.2.  DNS Message/Transaction Security
  contents:
  - "3.2.  DNS Message/Transaction Security\n   The second form of security that has\
    \ been added to DNS provides\n   \"transaction\" security through TSIG [RFC2845]\
    \ or SIG(0) [RFC2931].\n   TSIG could provide strong protection against the attacks\
    \ for which\n   the DNS Cookie mechanism provides weaker protection; however,\
    \ TSIG is\n   non-trivial to deploy in the general Internet because of the burdens\n\
    \   it imposes.  Among these burdens are pre-agreement and key\n   distribution\
    \ between client and server, keeping track of server-side\n   key state, and required\
    \ time synchronization between client and\n   server.\n   TKEY [RFC2930] can solve\
    \ the problem of key distribution for TSIG,\n   but some modes of TKEY impose\
    \ a substantial cryptographic computation\n   load and can be dependent on the\
    \ deployment of DNS data security (see\n   Section 3.1).\n   SIG(0) [RFC2931]\
    \ provides less denial-of-service protection than TSIG\n   or, in one way, even\
    \ DNS Cookies, because it authenticates complete\n   transactions but does not\
    \ authenticate requests.  In any case, it\n   also depends on the deployment of\
    \ DNS data security and requires\n   computationally burdensome public key cryptographic\
    \ operations.\n"
- title: 3.3.  Conclusions on Existing DNS Security
  contents:
  - "3.3.  Conclusions on Existing DNS Security\n   The existing DNS security mechanisms\
    \ do not provide the services\n   provided by the DNS Cookie mechanism: lightweight\
    \ message\n   authentication of DNS requests and responses with no requirement\
    \ for\n   pre-configuration or per-client server-side state.\n"
- title: 4.  DNS COOKIE Option
  contents:
  - "4.  DNS COOKIE Option\n   The DNS COOKIE option is an OPT RR [RFC6891] option\
    \ that can be\n   included in the RDATA portion of an OPT RR in DNS requests and\n\
    \   responses.  The option length varies, depending on the circumstances\n   in\
    \ which it is being used.  There are two cases, as described below.\n   Both use\
    \ the same OPTION-CODE; they are distinguished by their\n   length.\n   In a request\
    \ sent by a client to a server when the client does not\n   know the server's\
    \ cookie, its length is 8, consisting of an 8-byte\n   Client Cookie, as shown\
    \ in Figure 1.\n                         1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2\
    \ 2 3 3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |\
    \        OPTION-CODE = 10      |       OPTION-LENGTH = 8        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +-+-\
    \    Client Cookie (fixed size, 8 bytes)              -+-+-+-+\n    |        \
    \                                                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \              Figure 1: COOKIE Option, Unknown Server Cookie\n   In a request\
    \ sent by a client when a Server Cookie is known, and in\n   all responses to\
    \ such a request, the length is variable -- from 16 to\n   40 bytes, consisting\
    \ of an 8-byte Client Cookie followed by the\n   variable-length (8 bytes to 32\
    \ bytes) Server Cookie, as shown in\n   Figure 2.  The variability of the option\
    \ length stems from the\n   variable-length Server Cookie.  The Server Cookie\
    \ is an integer\n   number of bytes, with a minimum size of 8 bytes for security\
    \ and a\n   maximum size of 32 bytes for convenience of implementation.\n    \
    \                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n     0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        OPTION-CODE = 10      |   OPTION-LENGTH >= 16, <= 40   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +-+-\
    \    Client Cookie (fixed size, 8 bytes)              -+-+-+-+\n    |        \
    \                                                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    /\
    \       Server Cookie  (variable size, 8 to 32 bytes)           /\n    /     \
    \                                                          /\n    +-+-+-+-...\n\
    \               Figure 2: COOKIE Option, Known Server Cookie\n"
- title: 4.1.  Client Cookie
  contents:
  - "4.1.  Client Cookie\n   The Client Cookie SHOULD be a pseudorandom function of\
    \ the Client IP\n   Address, the Server IP Address, and a secret quantity known\
    \ only to\n   the client.  This Client Secret SHOULD have at least 64 bits of\n\
    \   entropy [RFC4086] and be changed periodically (see Section 7.1).  The\n  \
    \ selection of the pseudorandom function is a matter private to the\n   client,\
    \ as only the client needs to recognize its own DNS Cookies.\n   The Client IP\
    \ Address is included so that the Client Cookie cannot be\n   used to (1) track\
    \ a client if the Client IP Address changes due to\n   privacy mechanisms or (2)\
    \ impersonate the client by some network\n   device that was formerly on path\
    \ but is no longer on path when the\n   Client IP Address changes due to mobility.\
    \  However, if the Client IP\n   Address is being changed very often, it may be\
    \ necessary to fix the\n   Client Cookie for a particular server for several requests,\
    \ to avoid\n   undue inefficiency due to retries caused by that server not\n \
    \  recognizing the Client Cookie.\n   For further discussion of the Client Cookie\
    \ field, see Section 5.1.\n   For example methods of determining a Client Cookie,\
    \ see Appendix A.\n   In order to provide minimal authentication, a client MUST\
    \ send\n   Client Cookies that will usually be different for any two servers at\n\
    \   different IP addresses.\n"
- title: 4.2.  Server Cookie
  contents:
  - "4.2.  Server Cookie\n   The Server Cookie SHOULD consist of or include a 64-bit\
    \ or larger\n   pseudorandom function of the request source (client) IP address,\
    \ a\n   secret quantity known only to the server, and the request\n   Client Cookie.\
    \  (See Section 6 for a discussion of why the\n   Client Cookie is used as input\
    \ to the Server Cookie but the\n   Server Cookie is not used as an input to the\
    \ Client Cookie.)  This\n   Server Secret SHOULD have at least 64 bits of entropy\
    \ [RFC4086] and\n   be changed periodically (see Section 7.1).  The selection\
    \ of the\n   pseudorandom function is a matter private to the server, as only\
    \ the\n   server needs to recognize its own DNS Cookies.\n   For further discussion\
    \ of the Server Cookie field, see Section 5.2.\n   For example methods of determining\
    \ a Server Cookie, see Appendix B.\n   When implemented as recommended, the server\
    \ need not maintain any\n   cookie-related per-client state.\n   In order to provide\
    \ minimal authentication, a server MUST send\n   Server Cookies that will usually\
    \ be different for clients at any two\n   different IP addresses or with different\
    \ Client Cookies.\n"
- title: 5.  DNS Cookies Protocol Specification
  contents:
  - "5.  DNS Cookies Protocol Specification\n   This section discusses using DNS Cookies\
    \ in the DNS protocol.  The\n   cycle of originating a request, responding to\
    \ that request, and\n   processing responses is covered in Sections 5.1, 5.2,\
    \ and 5.3.  A\n   de facto extension to QUERY to allow the prefetching of a\n\
    \   Server Cookie is specified in Section 5.4.  Rollover of the Client\n   Secrets\
    \ and Server Secrets, and transient retention of the old cookie\n   or secret,\
    \ are covered in Section 7.1.\n   DNS clients and servers SHOULD implement DNS\
    \ Cookies to decrease\n   their vulnerability to the threats discussed in Section\
    \ 2.\n"
- title: 5.1.  Originating a Request
  contents:
  - "5.1.  Originating a Request\n   A DNS client that implements DNS Cookies includes\
    \ one DNS\n   COOKIE option containing a Client Cookie in every DNS request\n\
    \   it sends, unless DNS Cookies are disabled.\n   If the client has a cached\
    \ Server Cookie for the server against its\n   IP address, it uses the longer\
    \ cookie form and includes that\n   Server Cookie in the option along with the\
    \ Client Cookie (Figure 2).\n   Otherwise, it just sends the shorter-form option\
    \ with a Client Cookie\n   (Figure 1).\n"
- title: 5.2.  Responding to a Request
  contents:
  - "5.2.  Responding to a Request\n   The Server Cookie, when it occurs in a COOKIE\
    \ option in a request, is\n   intended to weakly assure the server that the request\
    \ came from a\n   client that is both at the source IP address of the request\
    \ and using\n   the Client Cookie included in the option.  This assurance is provided\n\
    \   by the Server Cookie that server sent to that client in an earlier\n   response\
    \ appearing as the Server Cookie field in the request.\n   At a server where DNS\
    \ Cookies are not implemented and enabled, the\n   presence of a COOKIE option\
    \ is ignored and the server responds as if\n   no COOKIE option had been included\
    \ in the request.\n   When DNS Cookies are implemented and enabled, there are\
    \ five\n   possibilities:\n   (1) There is no OPT RR at all in the request, or\
    \ there is an OPT RR\n       but the COOKIE option is absent from the OPT RR.\n\
    \   (2) A COOKIE option is present but is not a legal length or is\n       otherwise\
    \ malformed.\n   (3) There is a COOKIE option of valid length in the request with\
    \ no\n       Server Cookie.\n   (4) There is a COOKIE option of valid length in\
    \ the request with a\n       Server Cookie, but that Server Cookie is invalid.\n\
    \   (5) There is a COOKIE option of valid length in the request with a\n     \
    \  correct Server Cookie.\n   These five possibilities are discussed in the subsections\
    \ below.\n   In all cases of multiple COOKIE options in a request, only the first\n\
    \   (the one closest to the DNS header) is considered.  All others are\n   ignored.\n"
- title: 5.2.1.  No OPT RR or No COOKIE Option
  contents:
  - "5.2.1.  No OPT RR or No COOKIE Option\n   If there is no OPT record or no COOKIE\
    \ option present in the request,\n   then the server responds to the request as\
    \ if the server doesn't\n   implement the COOKIE option.\n"
- title: 5.2.2.  Malformed COOKIE Option
  contents:
  - "5.2.2.  Malformed COOKIE Option\n   If the COOKIE option is too short to contain\
    \ a Client Cookie, then\n   FORMERR is generated.  If the COOKIE option is longer\
    \ than that\n   required to hold a COOKIE option with just a Client Cookie (8\
    \ bytes)\n   but is shorter than the minimum COOKIE option with both a\n   Client\
    \ Cookie and a Server Cookie (16 bytes), then FORMERR is\n   generated.  If the\
    \ COOKIE option is longer than the maximum valid\n   COOKIE option (40 bytes),\
    \ then FORMERR is generated.\n   In summary, valid cookie lengths are 8 and 16\
    \ to 40 inclusive.\n"
- title: 5.2.3.  Only a Client Cookie
  contents:
  - "5.2.3.  Only a Client Cookie\n   Based on server policy, including rate limiting,\
    \ the server chooses\n   one of the following:\n   (1) Silently discard the request.\n\
    \   (2) Send a BADCOOKIE error response.\n   (3) Process the request and provide\
    \ a normal response.  The RCODE is\n       NOERROR, unless some non-cookie error\
    \ occurs in processing the\n       request.\n   If the server responds choosing\
    \ (2) or (3) above, it SHALL generate\n   its own COOKIE option containing both\
    \ the Client Cookie copied from\n   the request and a Server Cookie it has generated,\
    \ and it will add\n   this COOKIE option to the response's OPT record.  Servers\
    \ MUST, at\n   least occasionally, respond to such requests to inform the client\
    \ of\n   the correct Server Cookie.  This is necessary so that such a client\n\
    \   can bootstrap to the more secure state where requests and responses\n   have\
    \ recognized Server Cookies and Client Cookies.  A server is not\n   expected\
    \ to maintain per-client state to achieve this.  For example,\n   it could respond\
    \ to every Nth request across all clients.\n   If the request was received over\
    \ TCP, the server SHOULD take the\n   authentication provided by the use of TCP\
    \ into account and SHOULD\n   choose (3).  In this case, if the server is not\
    \ willing to accept the\n   security provided by TCP as a substitute for the security\
    \ provided by\n   DNS Cookies but instead chooses (2), there is some danger of\
    \ an\n   indefinite loop of retries (see Section 5.3).\n"
- title: 5.2.4.  A Client Cookie and an Invalid Server Cookie
  contents:
  - "5.2.4.  A Client Cookie and an Invalid Server Cookie\n   The server examines\
    \ the Server Cookie to determine if it is a valid\n   Server Cookie that it had\
    \ generated previously.  This determination\n   normally involves recalculating\
    \ the Server Cookie (or the Hash part\n   thereof) based on the Server Secret\
    \ (or the previous Server Secret,\n   if it has just changed); the received Client\
    \ Cookie; the Client IP\n   Address; and, possibly, other fields.  See Appendix\
    \ B.2 for an\n   example.  If the cookie is invalid, it could be because\n   +\
    \ it is too old\n   + a client's IP address or Client Cookie changed, and the\
    \ DNS server\n     is not aware of the change\n   + an anycast cluster of servers\
    \ is not consistently configured, or\n   + an attempt to spoof the client has\
    \ occurred\n   The server SHALL process the request as if the invalid Server Cookie\n\
    \   was not present, as described in Section 5.2.3.\n"
- title: 5.2.5.  A Client Cookie and a Valid Server Cookie
  contents:
  - "5.2.5.  A Client Cookie and a Valid Server Cookie\n   When a valid Server Cookie\
    \ is present in the request, the server can\n   assume that the request is from\
    \ a client that it has talked to before\n   and defensive measures for spoofed\
    \ UDP requests, if any, are no\n   longer required.\n   The server SHALL process\
    \ the request and include a COOKIE option in\n   the response by (a) copying the\
    \ complete COOKIE option from the\n   request or (b) generating a new COOKIE option\
    \ containing both the\n   Client Cookie copied from the request and a valid Server\
    \ Cookie it\n   has generated.\n"
- title: 5.3.  Processing Responses
  contents:
  - "5.3.  Processing Responses\n   The Client Cookie, when it occurs in a COOKIE\
    \ option in a DNS reply,\n   is intended to weakly assure the client that the\
    \ reply came from a\n   server at the source IP address used in the response packet,\
    \ because\n   the Client Cookie value is the value that client would send to that\n\
    \   server in a request.  In a DNS reply with multiple COOKIE options,\n   all\
    \ but the first (the one closest to the DNS header) are ignored.\n   A DNS client\
    \ where DNS Cookies are implemented and enabled examines\n   the response for\
    \ DNS Cookies and MUST discard the response if it\n   contains an illegal COOKIE\
    \ option length or an incorrect\n   Client Cookie value.  If the client is expecting\
    \ the response to\n   contain a COOKIE option and it is missing, the response\
    \ MUST be\n   discarded.  If the COOKIE option Client Cookie is correct, the client\n\
    \   caches the Server Cookie provided, even if the response is an error\n   response\
    \ (RCODE non-zero).\n   If the extended RCODE in the reply is BADCOOKIE and the\
    \ Client Cookie\n   in the reply matches what was sent, it means that the server\
    \ was\n   unwilling to process the request because it did not have the correct\n\
    \   Server Cookie in it.  The client SHOULD retry the request using the\n   new\
    \ Server Cookie from the response.  Repeated BADCOOKIE responses to\n   requests\
    \ that use the Server Cookie provided in the previous response\n   may be an indication\
    \ that either the shared secrets or the method for\n   generating secrets in an\
    \ anycast cluster of servers is inconsistent.\n   If the reply to a retried request\
    \ with a fresh Server Cookie is\n   BADCOOKIE, the client SHOULD retry using TCP\
    \ as the transport, since\n   the server will likely process the request normally\
    \ based on the\n   security provided by TCP (see Section 5.2.3).\n   If the RCODE\
    \ is some value other than BADCOOKIE, including zero, the\n   further processing\
    \ of the response proceeds normally.\n"
- title: 5.4.  Querying for a Server Cookie
  contents:
  - "5.4.  Querying for a Server Cookie\n   In many cases, a client will learn the\
    \ Server Cookie for a server as\n   the \"side effect\" of another transaction;\
    \ however, there may be times\n   when this is not desirable.  Therefore, a means\
    \ is provided for\n   obtaining a Server Cookie through an extension to the QUERY\
    \ opcode\n   for which opcode most existing implementations require that QDCOUNT\n\
    \   be one (1) (see Section 4.1.2 of [RFC1035]).\n   For servers with DNS Cookies\
    \ enabled, the QUERY opcode behavior is\n   extended to support queries with an\
    \ empty Question Section (a QDCOUNT\n   of zero (0)), provided that an OPT record\
    \ is present with a COOKIE\n   option.  Such servers will send a reply that has\
    \ an empty\n   Answer Section and has a COOKIE option containing the Client Cookie\n\
    \   and a valid Server Cookie.\n   If such a query provided just a Client Cookie\
    \ and no Server Cookie,\n   the response SHALL have the RCODE NOERROR.\n   This\
    \ mechanism can also be used to confirm/re-establish an existing\n   Server Cookie\
    \ by sending a cached Server Cookie with the\n   Client Cookie.  In this case,\
    \ the response SHALL have the RCODE\n   BADCOOKIE if the Server Cookie sent with\
    \ the query was invalid and\n   the RCODE NOERROR if it was valid.\n   Servers\
    \ that don't support the COOKIE option will normally send\n   FORMERR in response\
    \ to such a query, though REFUSED, NOTIMP, and\n   NOERROR without a COOKIE option\
    \ are also possible in such responses.\n"
- title: 6.  NAT Considerations and Anycast Server Considerations
  contents:
  - "6.  NAT Considerations and Anycast Server Considerations\n   In the classic Internet,\
    \ DNS Cookies could simply be a pseudorandom\n   function of the Client IP Address\
    \ and a Server Secret or the Server\n   IP Address and a Client Secret.  You would\
    \ want to compute the\n   Server Cookie that way, so a client could cache its\
    \ Server Cookie for\n   a particular server for an indefinite amount of time and\
    \ the server\n   could easily regenerate and check it.  You could consider the\n\
    \   Client Cookie to be a weak client signature over the Server IP\n   Address\
    \ that the client checks in replies, and you could extend this\n   signature to\
    \ cover the request ID, for example, or any other\n   information that is returned\
    \ unchanged in the reply.\n   But we have this reality called \"NAT\" [RFC3022]\
    \ (including, for the\n   purposes of this document, NAT-PT, which has been declared\
    \ Historic\n   [RFC4966]).  There is no problem with DNS transactions between\n\
    \   clients and servers behind a NAT box using local IP addresses.  Nor\n   is\
    \ there a problem with NAT translation of internal addresses to\n   external addresses\
    \ or translations between IPv4 and IPv6 addresses,\n   as long as the address\
    \ mapping is relatively stable.  Should the\n   external IP address to which an\
    \ internal client is being mapped\n   change occasionally, the disruption is little\
    \ more than when a client\n   rolls over its COOKIE secret.  Also, external access\
    \ to a DNS server\n   behind a NAT box is normally handled by a fixed mapping\
    \ that forwards\n   externally received DNS requests to a specific host.\n   However,\
    \ NAT devices sometimes also map ports.  This can cause\n   multiple DNS requests\
    \ and responses from multiple internal hosts to\n   be mapped to a smaller number\
    \ of external IP addresses, such as one\n   address.  Thus, there could be many\
    \ clients behind a NAT box that\n   appear to come from the same source IP address\
    \ to a server outside\n   that NAT box.  If one of these were an attacker (think\
    \ \"zombie\" or\n   \"botnet\") behind a NAT box, that attacker could get the\
    \ Server Cookie\n   for some server for the outgoing IP address by just making\
    \ some\n   random request to that server.  It could then include that\n   Server\
    \ Cookie in the COOKIE option of requests to the server with the\n   forged local\
    \ IP address of some other host and/or client behind the\n   NAT box.  (An attacker's\
    \ possession of this Server Cookie will not\n   help in forging responses to cause\
    \ cache poisoning, as such responses\n   are protected by the required Client\
    \ Cookie.)\n   To fix this potential defect, it is necessary to distinguish\n\
    \   different clients behind a NAT box from the point of view of the\n   server.\
    \  This is why the Server Cookie is specified as a pseudorandom\n   function of\
    \ both the request source IP address and the Client Cookie.\n   From this inclusion\
    \ of the Client Cookie in the calculation of the\n   Server Cookie, it follows\
    \ that, for any particular server, a stable\n   Client Cookie is needed.  If,\
    \ for example, the request ID was\n   included in the calculation of the Client\
    \ Cookie, it would normally\n   change with each request to a particular server.\
    \  This would mean\n   that each request would have to be sent twice: first, to\
    \ learn the\n   new Server Cookie based on this new Client Cookie based on the\
    \ new\n   ID, and then again using this new Client Cookie to actually get an\n\
    \   answer.  Thus, the input to the Client Cookie computation must be\n   limited\
    \ to the Server IP Address and one or more things that change\n   slowly, such\
    \ as the Client Secret.\n   In principle, there could be a similar problem for\
    \ servers, not due\n   to NAT but due to mechanisms like anycast that may cause\
    \ requests to\n   a DNS server at an IP address to be delivered to any one of\
    \ several\n   machines.  (External requests to a DNS server behind a NAT box\n\
    \   usually occur via port forwarding such that all such requests go to\n   one\
    \ host.)  However, it is impossible to solve this in the way that\n   the similar\
    \ problem was solved for NATed clients; if the\n   Server Cookie was included\
    \ in the calculation of the Client Cookie in\n   the same way that the Client\
    \ Cookie is included in the Server Cookie,\n   you would just get an almost infinite\
    \ series of errors as a request\n   was repeatedly retried.\n   For servers accessed\
    \ via anycast, to successfully support\n   DNS Cookies, either (1) the server\
    \ clones must all use the same\n   Server Secret or (2) the mechanism that distributes\
    \ requests to the\n   server clones must cause the requests from a particular\
    \ client to go\n   to a particular server for a sufficiently long period of time\
    \ that\n   extra requests due to changes in Server Cookies resulting from\n  \
    \ accessing different server machines are not unduly burdensome.  (When\n   such\
    \ anycast-accessed servers act as recursive servers or otherwise\n   act as clients,\
    \ they normally use a different unique address to\n   source their requests, to\
    \ avoid confusion in the delivery of\n   responses.)\n   For simplicity, it is\
    \ RECOMMENDED that the same Server Secret be used\n   by each DNS server in a\
    \ set of anycast servers.  If there is limited\n   time skew in updating this\
    \ secret in different anycast servers, this\n   can be handled by a server accepting\
    \ requests containing a\n   Server Cookie based on either its old or new secret\
    \ for the maximum\n   likely time period of such time skew (see also Section 7.1).\n"
- title: 7.  Operational and Deployment Considerations
  contents:
  - "7.  Operational and Deployment Considerations\n   The DNS Cookie mechanism is\
    \ designed for incremental deployment and\n   to complement the orthogonal techniques\
    \ in [RFC5452].  Either or both\n   techniques can be deployed independently at\
    \ each DNS server and\n   client.  Thus, installation at the client and server\
    \ end need not be\n   synchronized.\n   In particular, a DNS server or client\
    \ that implements the DNS Cookie\n   mechanism can interoperate successfully with\
    \ a DNS client or server\n   that does not implement this mechanism, although,\
    \ of course, in this\n   case it will not get the benefit of the mechanism and\
    \ the server\n   involved might choose to severely rate-limit responses.  When\
    \ such a\n   server or client interoperates with a client or server that also\n\
    \   implements the DNS Cookie mechanism, these servers and clients get\n   the\
    \ security benefits of the DNS Cookie mechanism.\n"
- title: 7.1.  Client and Server Secret Rollover
  contents:
  - "7.1.  Client and Server Secret Rollover\n   The longer a secret is used, the\
    \ higher the probability that it has\n   been compromised.  Thus, clients and\
    \ servers are configured with a\n   lifetime setting for their secret, and they\
    \ roll over to a new secret\n   when that lifetime expires, or earlier due to\
    \ deliberate jitter as\n   described below.  The default lifetime is one day,\
    \ and the maximum\n   permitted is one month.  To be precise and to make it practical\
    \ to\n   stay within limits despite long holiday weekends, daylight saving\n \
    \  time shifts, and the like, clients and servers MUST NOT continue to\n   use\
    \ the same secret in new requests and responses for more than\n   36 days and\
    \ SHOULD NOT continue to do so for more than 26 hours.\n   Many clients rolling\
    \ over their secret at the same time could briefly\n   increase server traffic,\
    \ and exactly predictable rollover times for\n   clients or servers might facilitate\
    \ guessing attacks.  For example,\n   an attacker might increase the priority\
    \ of attacking secrets they\n   believe will be in effect for an extended period\
    \ of time.  To avoid\n   rollover synchronization and predictability, it is RECOMMENDED\
    \ that\n   pseudorandom jitter in the range of plus zero to minus at least 40%\n\
    \   be applied to the time until a scheduled rollover of a COOKIE secret.\n  \
    \ It is RECOMMENDED that a client keep the Client Cookie it is\n   expecting in\
    \ a reply until there is no longer an outstanding request\n   associated with\
    \ that Client Cookie that the client is tracking.  This\n   avoids rejection of\
    \ replies due to a bad Client Cookie right after a\n   change in the Client Secret.\n\
    \   It is RECOMMENDED that a server retain its previous secret after a\n   rollover\
    \ to a new secret for a configurable period of time not less\n   than 1 second\
    \ or more than 300 seconds, with a default configuration\n   of 150 seconds. \
    \ Requests with Server Cookies based on its previous\n   secret are treated as\
    \ a correct Server Cookie during that time.  When\n   a server responds to a request\
    \ containing an old Server Cookie that\n   the server is treating as correct,\
    \ the server MUST include a new\n   Server Cookie in its response.\n"
- title: 7.2.  Counters
  contents:
  - "7.2.  Counters\n   It is RECOMMENDED that implementations include counters of\
    \ the\n   occurrences of the various types of requests and responses described\n\
    \   in Section 5.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   IANA has assigned the following DNS EDNS0 option\
    \ code:\n       Value       Name      Status        Reference\n      --------\
    \    ------    --------    ---------------\n         10       COOKIE    Standard\
    \       RFC 7873\n   IANA has assigned the following DNS error code as an early\
    \ allocation\n   per [RFC7120]:\n       RCODE       Name       Description   \
    \              Reference\n      --------  ---------  -------------------------\
    \   ---------------\n         23     BADCOOKIE  Bad/missing Server Cookie    \
    \  RFC 7873\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   DNS Cookies provide a weak form of authentication\
    \ of DNS requests and\n   responses.  In particular, they provide no protection\
    \ against\n   \"on-path\" adversaries; that is, they provide no protection against\n\
    \   any adversary that can observe the plaintext DNS traffic, such as an\n   on-path\
    \ router, bridge, or any device on an on-path shared link\n   (unless the DNS\
    \ traffic in question on that path is encrypted).\n   For example, if a host is\
    \ connected via an unsecured IEEE Std. 802.11\n   link (Wi-Fi), any device in\
    \ the vicinity that could receive and\n   decode the 802.11 transmissions must\
    \ be considered \"on path\".  On the\n   other hand, in a similar situation but\
    \ one where 802.11 Robust\n   Security (WPA2, also called \"Wi-Fi Protected Access\
    \ 2\") is\n   appropriately deployed on the Wi-Fi network nodes, only the\n  \
    \ Access Point via which the host is connecting is \"on path\" as far as\n   the\
    \ 802.11 link is concerned.\n   Despite these limitations, deployment of DNS Cookies\
    \ on the global\n   Internet is expected to provide a significant reduction in\
    \ the\n   available launch points for the traffic amplification and denial-of-\n\
    \   service forgery attacks described in Section 2 above.\n   Work is underway\
    \ in the IETF DPRIVE working group to provide\n   confidentiality for DNS requests\
    \ and responses that would be\n   compatible with DNS Cookies.\n   Should stronger\
    \ message/transaction security be desired, it is\n   suggested that TSIG or SIG(0)\
    \ security be used (see Section 3.2);\n   however, it may be useful to use DNS\
    \ Cookies in conjunction with\n   these features.  In particular, DNS Cookies\
    \ could screen out many DNS\n   messages before the cryptographic computations\
    \ of TSIG or SIG(0) are\n   required, and if SIG(0) is in use, DNS Cookies could\
    \ usefully screen\n   out many requests given that SIG(0) does not screen requests\
    \ but only\n   authenticates the response of complete transactions.\n   An attacker\
    \ that does not know the Server Cookie could do a variety\n   of things, such\
    \ as omitting the COOKIE option or sending a random\n   Server Cookie.  In general,\
    \ DNS servers need to take other measures,\n   including rate-limiting responses,\
    \ to protect from abuse in such\n   cases.  See further information in Section\
    \ 5.2.\n   When a server or client starts receiving an increased level of\n  \
    \ requests with bad Server Cookies or replies with bad Client Cookies,\n   it\
    \ would be reasonable for it to believe that it is likely under\n   attack, and\
    \ it should consider a more frequent rollover of its\n   secret.  More rapid rollover\
    \ decreases the benefit to a\n   cookie-guessing attacker if they succeed in guessing\
    \ a cookie.\n"
- title: 9.1.  Cookie Algorithm Considerations
  contents:
  - "9.1.  Cookie Algorithm Considerations\n   The cookie computation algorithm for\
    \ use in DNS Cookies SHOULD be\n   based on a pseudorandom function at least as\
    \ strong as 64-bit FNV\n   (Fowler/Noll/Vo [FNV]), because an excessively weak\
    \ or trivial\n   algorithm could enable adversaries to guess cookies.  However,\
    \ in\n   light of the lightweight plaintext token security provided by\n   DNS\
    \ Cookies, a strong cryptography hash algorithm may not be\n   warranted in many\
    \ cases and would cause an increased computational\n   burden.  Nevertheless,\
    \ there is nothing wrong with using something\n   stronger -- for example, HMAC-SHA-256\
    \ [RFC6234] truncated to 64 bits,\n   assuming that a DNS processor has adequate\
    \ computational resources\n   available.  DNS implementations or applications\
    \ that need somewhat\n   stronger security without a significant increase in computational\n\
    \   load should consider more frequent changes in their client and/or\n   Server\
    \ Secret; however, this does require more frequent generation of\n   a cryptographically\
    \ strong random number [RFC4086].  See Appendices A\n   and B for specific examples\
    \ of cookie computation algorithms.\n"
- title: 10.  Implementation Considerations
  contents:
  - "10.  Implementation Considerations\n   The DNS COOKIE option specified herein\
    \ is implemented in BIND 9.10\n   using an experimental option code.  BIND 9.10.3\
    \ (and later) use the\n   allocated option code.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC1035]  Mockapetris, P., \"Domain names -\
    \ implementation and\n              specification\", STD 13, RFC 1035, DOI 10.17487/RFC1035,\n\
    \              November 1987, <http://www.rfc-editor.org/info/rfc1035>.\n   [RFC2119]\
    \  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement\
    \ Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n\
    \              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC4086]  Eastlake\
    \ 3rd, D., Schiller, J., and S. Crocker,\n              \"Randomness Requirements\
    \ for Security\", BCP 106, RFC 4086,\n              DOI 10.17487/RFC4086, June\
    \ 2005,\n              <http://www.rfc-editor.org/info/rfc4086>.\n   [RFC6891]\
    \  Damas, J., Graff, M., and P. Vixie, \"Extension Mechanisms\n              for\
    \ DNS (EDNS(0))\", STD 75, RFC 6891,\n              DOI 10.17487/RFC6891, April\
    \ 2013,\n              <http://www.rfc-editor.org/info/rfc6891>.\n   [RFC7120]\
    \  Cotton, M., \"Early IANA Allocation of Standards Track Code\n             \
    \ Points\", BCP 100, RFC 7120, DOI 10.17487/RFC7120,\n              January 2014,\
    \ <http://www.rfc-editor.org/info/rfc7120>.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [FNV]      Fowler, G., Noll, L., Vo, K., and\
    \ D. Eastlake 3rd, \"The\n              FNV Non-Cryptographic Hash Algorithm\"\
    , Work in Progress,\n              draft-eastlake-fnv-10, October 2015.\n   [Kaminsky]\
    \ Olney, M., Mullen, P., and K. Miklavcic, \"Dan Kaminsky's\n              2008\
    \ DNS Vulnerability\", July 2008, <https://www.ietf.org/\n              mail-archive/web/dnsop/current/pdf2jgx6rzxN4.pdf>.\n\
    \   [RFC2845]  Vixie, P., Gudmundsson, O., Eastlake 3rd, D., and B.\n        \
    \      Wellington, \"Secret Key Transaction Authentication for DNS\n         \
    \     (TSIG)\", RFC 2845, DOI 10.17487/RFC2845, May 2000,\n              <http://www.rfc-editor.org/info/rfc2845>.\n\
    \   [RFC2930]  Eastlake 3rd, D., \"Secret Key Establishment for DNS\n        \
    \      (TKEY RR)\", RFC 2930, DOI 10.17487/RFC2930,\n              September 2000,\
    \ <http://www.rfc-editor.org/info/rfc2930>.\n   [RFC2931]  Eastlake 3rd, D., \"\
    DNS Request and Transaction Signatures\n              ( SIG(0)s )\", RFC 2931,\
    \ DOI 10.17487/RFC2931,\n              September 2000, <http://www.rfc-editor.org/info/rfc2931>.\n\
    \   [RFC3022]  Srisuresh, P. and K. Egevang, \"Traditional IP Network\n      \
    \        Address Translator (Traditional NAT)\", RFC 3022,\n              DOI\
    \ 10.17487/RFC3022, January 2001,\n              <http://www.rfc-editor.org/info/rfc3022>.\n\
    \   [RFC4033]  Arends, R., Austein, R., Larson, M., Massey, D., and S.\n     \
    \         Rose, \"DNS Security Introduction and Requirements\",\n            \
    \  RFC 4033, DOI 10.17487/RFC4033, March 2005,\n              <http://www.rfc-editor.org/info/rfc4033>.\n\
    \   [RFC4034]  Arends, R., Austein, R., Larson, M., Massey, D., and S.\n     \
    \         Rose, \"Resource Records for the DNS Security Extensions\",\n      \
    \        RFC 4034, DOI 10.17487/RFC4034, March 2005,\n              <http://www.rfc-editor.org/info/rfc4034>.\n\
    \   [RFC4035]  Arends, R., Austein, R., Larson, M., Massey, D., and S.\n     \
    \         Rose, \"Protocol Modifications for the DNS Security\n              Extensions\"\
    , RFC 4035, DOI 10.17487/RFC4035, March 2005,\n              <http://www.rfc-editor.org/info/rfc4035>.\n\
    \   [RFC4966]  Aoun, C. and E. Davies, \"Reasons to Move the Network\n       \
    \       Address Translator - Protocol Translator (NAT-PT) to\n              Historic\
    \ Status\", RFC 4966, DOI 10.17487/RFC4966,\n              July 2007, <http://www.rfc-editor.org/info/rfc4966>.\n\
    \   [RFC5452]  Hubert, A. and R. van Mook, \"Measures for Making DNS\n       \
    \       More Resilient against Forged Answers\", RFC 5452,\n              DOI\
    \ 10.17487/RFC5452, January 2009,\n              <http://www.rfc-editor.org/info/rfc5452>.\n\
    \   [RFC6234]  Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms\n \
    \             (SHA and SHA-based HMAC and HKDF)\", RFC 6234,\n              DOI\
    \ 10.17487/RFC6234, May 2011,\n              <http://www.rfc-editor.org/info/rfc6234>.\n"
- title: Appendix A.  Example Client Cookie Algorithms
  contents:
  - 'Appendix A.  Example Client Cookie Algorithms

    '
- title: A.1.  A Simple Algorithm
  contents:
  - "A.1.  A Simple Algorithm\n   A simple example method to compute Client Cookies\
    \ is the FNV64 [FNV]\n   of the Client IP Address, the Server IP Address, and\
    \ the Client\n   Secret:\n      Client Cookie =\n         FNV64( Client IP Address\
    \ | Server IP Address | Client Secret )\n   where \"|\" indicates concatenation.\
    \  Some computational resources may\n   be saved by pre-computing FNV64 through\
    \ the Client IP Address.  (If\n   the order of the items concatenated above is\
    \ changed to put the\n   Server IP Address last, it might be possible to further\
    \ reduce the\n   computational effort by pre-computing FNV64 through the bytes\
    \ of both\n   the Client IP Address and the Client Secret, but this would reduce\n\
    \   the strength of the Client Cookie and is NOT RECOMMENDED.)\n"
- title: A.2.  A More Complex Algorithm
  contents:
  - "A.2.  A More Complex Algorithm\n   A more complex algorithm to calculate Client\
    \ Cookies is given below.\n   It uses more computational resources than the simpler\
    \ algorithm shown\n   in Appendix A.1.\n      Client Cookie =\n         HMAC-SHA256-64(\
    \ Client IP Address | Server IP Address,\n                          Client Secret\
    \ )\n"
- title: Appendix B.  Example Server Cookie Algorithms
  contents:
  - 'Appendix B.  Example Server Cookie Algorithms

    '
- title: B.1.  A Simple Algorithm
  contents:
  - "B.1.  A Simple Algorithm\n   An example of a simple method producing a 64-bit\
    \ Server Cookie is the\n   FNV64 [FNV] of the request IP address, the Client Cookie,\
    \ and the\n   Server Secret.\n      Server Cookie =\n         FNV64( Client IP\
    \ Address | Client Cookie | Server Secret )\n   where \"|\" represents concatenation.\
    \  (If the order of the items\n   concatenated was changed, it might be possible\
    \ to reduce the\n   computational effort by pre-computing FNV64 through the bytes\
    \ of the\n   Server Secret and Client Cookie, but this would reduce the strength\n\
    \   of the Server Cookie and is NOT RECOMMENDED.)\n"
- title: B.2.  A More Complex Algorithm
  contents:
  - "B.2.  A More Complex Algorithm\n   Since the Server Cookie has a variable size,\
    \ the server can store\n   various information in that field as long as it is\
    \ hard for an\n   adversary to guess the entire quantity used for authentication.\n\
    \   There should be 64 bits of entropy in the Server Cookie; for example,\n  \
    \ it could have a sub-field of 64 bits computed pseudorandomly with the\n   Server\
    \ Secret as one of the inputs to the pseudorandom function.\n   Types of additional\
    \ information that could be stored include a\n   timestamp and/or a nonce.\n \
    \  The example below is one variation of the Server Cookie that has been\n   implemented\
    \ in BIND 9.10.3 (and later) releases, where the\n   Server Cookie is 128 bits,\
    \ composed as follows:\n         Sub-field      Size\n         ---------   ---------\n\
    \           Nonce      32 bits\n           Time       32 bits\n           Hash\
    \       64 bits\n   With this algorithm, the server sends a new 128-bit cookie\
    \ back with\n   every request.  The Nonce field assures a low probability that\
    \ there\n   would be a duplicate.\n   The Time field gives the server time and\
    \ makes it easy to reject old\n   cookies.\n   The Hash part of the Server Cookie\
    \ is the part that is hard to guess.\n   In BIND 9.10.3 (and later), its computation\
    \ can be configured to use\n   AES, HMAC-SHA-1, or, as shown below, HMAC-SHA-256:\n\
    \       hash =\n           HMAC-SHA256-64( Server Secret,\n               (Client\
    \ Cookie | Nonce | Time | Client IP Address) )\n   where \"|\" represents concatenation.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The suggestions and contributions of the following are gratefully\n\
    \   acknowledged:\n      Alissa Cooper, Bob Harold, Paul Hoffman, David Malone,\
    \ Yoav Nir,\n      Gayle Noble, Dan Romascanu, Tim Wicinski, and Peter Yee\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Donald E. Eastlake 3rd\n   Huawei Technologies\n   155\
    \ Beaver Street\n   Milford, MA  01757\n   United States\n   Phone: +1-508-333-2270\n\
    \   Email: d3e3e3@gmail.com\n   Mark Andrews\n   Internet Systems Consortium\n\
    \   950 Charter Street\n   Redwood City, CA  94063\n   United States\n   Email:\
    \ marka@isc.org\n"
