- title: __initial_text__
  contents:
  - '            Explicit Multicast (Xcast) Concepts and Options

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: IESG Note
  contents:
  - "IESG Note\n   This RFC is not a candidate for any level of Internet Standard.\
    \  The\n   IETF disclaims any knowledge of the fitness of this RFC for any\n \
    \  purpose and in particular notes that the decision to publish is not\n   based\
    \ on IETF review for such things as security, congestion control,\n   or inappropriate\
    \ interaction with deployed protocols.  The RFC Editor\n   has chosen to publish\
    \ this document at its discretion.  Readers of\n   this document should exercise\
    \ caution in evaluating its value for\n   implementation and deployment.  See\
    \ RFC 3932 for more information.\n"
- title: Abstract
  contents:
  - "Abstract\n   While traditional IP multicast schemes (RFC 1112) are scalable for\n\
    \   very large multicast groups, they have scalability issues with a very\n  \
    \ large number of distinct multicast groups.  This document describes\n   Xcast\
    \ (Explicit Multi-unicast), a new multicast scheme with\n   complementary scaling\
    \ properties: Xcast supports a very large number\n   of small multicast sessions.\
    \  Xcast achieves this by explicitly\n   encoding the list of destinations in\
    \ the data packets, instead of\n   using a multicast group address.\n   This document\
    \ discusses Xcast concepts and options in several areas;\n   it does not provide\
    \ a complete technical specification.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Xcast Overview ..................................................4\n  \
    \ 3. The Cost of the Traditional IP Multicast Schemes ................6\n   4.\
    \ Motivation ......................................................9\n   5. Application\
    \ ....................................................11\n   6. Xcast Flexibility\
    \ ..............................................12\n   7. Xcast Control Plane\
    \ Options ....................................13\n      7.1. SIP Control Plane\
    \ for Xcast ...............................14\n      7.2. Receiver-Initiated Join\
    \ for Xcast .........................14\n   8. Optional Information ...........................................15\n\
    \      8.1. List of Ports .............................................15\n  \
    \    8.2. List of DSCPs .............................................15\n    \
    \  8.3. Channel Identifier ........................................15\n   9. Possible\
    \ Xcast Packet Encoding .................................16\n      9.1. General\
    \ ...................................................16\n      9.2. IPv4 ......................................................17\n\
    \           9.2.1. IPv4 Header ........................................17\n  \
    \         9.2.2. Xcast4 Header ......................................17\n    \
    \  9.3. IPv6 ......................................................20\n      \
    \     9.3.1. IPv6 Header ........................................20\n        \
    \   9.3.2. Xcast6 Header ......................................20\n          \
    \        9.3.2.1. Routing Extension Header ..................21\n            \
    \      9.3.2.2. Destination Extension Header ..............21\n   10. Impact on\
    \ Upper-Layer Protocols ...............................22\n      10.1. Checksum\
    \ Calculation in Transport-Layer Headers ..........22\n      10.2. IPsec ....................................................22\n\
    \   11. Gradual Deployment ............................................23\n  \
    \    11.1. Tunneling ................................................23\n    \
    \  11.2. Premature X2U ............................................25\n      11.3.\
    \ Semi-Permeable Tunneling (IPv6 Only) .....................25\n      11.4. Special\
    \ Case: Deployment without Network Support .........26\n      11.5. Using a Small\
    \ Number of Xcast-Aware Routers to\n            Provide Xcast ............................................27\n\
    \   12. (Socket) API ..................................................28\n  \
    \ 13. Unresolved Issues .............................................28\n    \
    \  13.1. The Format of the \"List of Addresses\" ....................28\n    \
    \  13.2. The size of Channel Identifier ...........................28\n      13.3.\
    \ Incremental Deployment ...................................28\n      13.4. DSCP\
    \ usage ...............................................29\n      13.5. Traversing\
    \ a Firewall or NAT Products ....................29\n      13.6. The Size of BITMAP\
    \ .......................................29\n   14. Security Considerations .......................................29\n\
    \   15. IANA Considerations ...........................................30\n  \
    \ 16. Informative References ........................................31\n   17.\
    \ Contributors ..................................................33\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   While traditional IP multicast schemes [1112] are scalable\
    \ for very\n   large multicast groups, they have scalability issues with a very\n\
    \   large number of distinct multicast groups.  This document describes\n   Xcast\
    \ (Explicit Multi-unicast (Xcast)), a new multicast scheme with\n   complementary\
    \ scaling properties: Xcast supports a very large number\n   of small multicast\
    \ sessions.  Xcast achieves this by explicitly\n   encoding the list of destinations\
    \ in the data packets, instead of\n   using a multicast group address.  This document\
    \ discusses Xcast\n   concepts and options in several areas; it does not provide\
    \ a complete\n   technical specification.\n   Multicast, the ability to efficiently\
    \ send data to a group of\n   destinations, is becoming increasingly important\
    \ for applications\n   such as IP telephony and video-conferencing.\n   Two kinds\
    \ of multicast seem to be important: a broadcast-like\n   multicast that sends\
    \ data to a very large number of destinations, and\n   a \"narrowcast\" multicast\
    \ that sends data to a fairly small group\n   [BOIV].  An example of the first\
    \ is the audio and video multicasting\n   of a presentation to all employees in\
    \ a corporate intranet.  An\n   example of the second is a videoconference involving\
    \ three or four\n   parties.  For reasons described below, it seems prudent to\
    \ use\n   different mechanisms for these two cases.  As the Reliable Multicast\n\
    \   Transport working group has stated: \"it is believed that a 'one size\n  \
    \ fits all' protocol will be unable to meet the requirements of all\n   applications\"\
    \ [RMT].  Note that the 1998 IAB Routing Workshop [2902]\n   came to the same\
    \ conclusion:  \"For example, providing for many groups\n   of small conferences\
    \ (a small number of widely dispersed people) with\n   global topological scope\
    \ scales badly given the current multicast\n   model\".\n   Today's multicast\
    \ schemes can be used to minimize bandwidth\n   consumption.  Explicit Multi-Unicast\
    \ (Xcast) also can be used to\n   minimize bandwidth consumption for \"small groups\"\
    .  But it has an\n   additional advantage as well.  Xcast eliminates the per-session\n\
    \   signaling and per-session state information of traditional IP\n   multicast\
    \ schemes and this allows Xcast to support very large numbers\n   of multicast\
    \ sessions.  This scalability is important since it\n   enables important classes\
    \ of applications such as IP telephony,\n   videoconferencing, collaborative applications,\
    \ networked games, etc.,\n   where there are typically very large numbers of small\
    \ multicast\n   groups.\n   Interestingly, the idea for Xcast has been around\
    \ for some time,\n   although this was not immediately known to the three groups\
    \ that\n   independently re-invented it in the late 1990's.  In fact the very\n\
    \   first proposal of the multicast concept in the Internet community, by\n  \
    \ Lorenzo Aguilar in his 1984 SIGCOMM paper [AGUI] proposed the use of\n   an\
    \ explicit list of destinations discussed in more detail below.  At\n   about\
    \ the same time, David Cheriton and Stephen Deering developed\n   Host Group Multicast\
    \ in 1985 [CHER].\n   The Internet community compared the two proposals and concluded\
    \ that\n   a single mechanism was preferable to multiple mechanisms.  Further,\n\
    \   since Aguilar's proposal seemed to have serious scaling problems, the\n  \
    \ Host Group model was adopted.\n   However, for reasons described below, we believe\
    \ it makes sense to\n   use different mechanisms for the two different kinds of\
    \ multicast\n   discussed above.  While Host Group multicast may have been sufficient\n\
    \   in the Internet of 1985, we believe that Xcast can be an important\n   complement\
    \ to Host Group multicast in the Internet of the 21st\n   century.\n"
- title: 2.  Xcast Overview
  contents:
  - "2.  Xcast Overview\n   In this document, the following terminology will be used:\n\
    \   - Session: in Xcast, the term 'multicast session' will be used\n     instead\
    \ of 'multicast group' to avoid the strong association of\n     multicast groups\
    \ with multicast group addresses in traditional IP\n     multicast.\n   - Channel:\
    \ in a session with multiple senders (e.g., a video\n     conference), the flow\
    \ sourced by one sender will be called a\n     channel.  So, a session can contain\
    \ one or more channels.\n   In the Host Group Model, the packet carries a multicast\
    \ address as a\n   logical identifier of all group members.  In Xcast, the source\
    \ node\n   keeps track of the destinations in the multicast channel that it\n\
    \   wants to send packets to.\n   The source encodes the list of destinations\
    \ in the Xcast header, and\n   then sends the packet to a router.  Each router\
    \ along the way parses\n   the header, partitions the destinations based on each\
    \ destination's\n   next hop, and forwards a packet with an appropriate Xcast\
    \ header to\n   each of the next hops.\n   When there is only one destination\
    \ left, the Xcast packet can be\n   converted into a normal unicast packet, which\
    \ can be unicasted along\n   the remainder of the route.  This is called X2U (Xcast\
    \ to Unicast).\n   For example, suppose that A is trying to get packets distributed\
    \ to\n   B, C, and D in Figure 1 below:\n                                   R4\
    \ ---- B\n                                  /\n                              \
    \   /\n        A----- R1 ---- R2 ---- R3                      R8 ---- C\n    \
    \                             \\                    /\n                      \
    \            \\                  /\n                                   R5 ----\
    \ R6 ---- R7\n                                                    \\\n       \
    \                                              \\\n                          \
    \                             R9 ---- D\n                                 Figure\
    \ 1\n   This is accomplished as follows: A sends an Xcast packet with the\n  \
    \ list of destinations in its Xcast header to the first router, R1.\n   Since\
    \ the Xcast header will be slightly different for IPv4 and IPv6\n   [2460], we\
    \ won't reveal any details on the encoding of the Xcast\n   header in this section\
    \ (see Section 9).  So, ignoring the details,\n   the packet that A sends to R1\
    \ looks like this:\n       [ src = A | dest = B C D | payload ]\n   When R1 receives\
    \ this packet, it needs to properly process the Xcast\n   header.  The processing\
    \ that a router does on receiving one of these\n   Xcast packets is as follows:\n\
    \   - Perform a route table lookup to determine the next hop for each of\n   \
    \  the destinations listed in the packet.\n   - Partition the set of destinations\
    \ based on their next hops.\n   - Replicate the packet so that there's one copy\
    \ of the packet for\n     each of the next hops found in the previous steps.\n\
    \   - Modify the list of destinations in each of the copies so that the\n    \
    \ list in the copy for a given next hop includes just the\n     destinations that\
    \ ought to be routed through that next hop.\n   - Send the modified copies of\
    \ the packet on to the next hops.\n   - Optimization: If there is only one destination\
    \ for a particular\n     next hop, the packet can be sent as a standard unicast\
    \ packet to\n     the destination (X2U).\n   So, in the example above, R1 will\
    \ send a single packet on to R2 with\n   a destination list of < B C D >, and\
    \ R2 will send a single packet to\n   R3 with the same destination list.\n   When\
    \ R3 receives the packet, it will, by the algorithm above, send\n   one copy of\
    \ the packet to next hop R5 with an Xcast list of < C D >,\n   and one ordinary\
    \ unicast packet addressed to < B > to R4.  R4 will\n   receive a standard unicast\
    \ packet and forward it on to < B >.  R5\n   will forward the Xcast packet that\
    \ it receives on to R6, which will\n   pass it on to R7.  When the packet reaches\
    \ R7, R7 will transmit\n   ordinary unicast packets addressed to < C > and < D\
    \ >, respectively.\n   R8 and R9 will receive standard unicast packets, and forward\
    \ the\n   packets on to < C > and < D >, respectively.\n   It's important that\
    \ the Xcast packet that is sent to a given next hop\n   only includes destinations\
    \ for which that next hop is the next hop\n   listed in the route table.  If the\
    \ list of destinations in the packet\n   sent to R4, for example, had also included\
    \ C and D, R4 would send\n   duplicate packets.\n   Note that when routing topology\
    \ changes, the routing for an Xcast\n   channel will automatically adapt to the\
    \ new topology since the path\n   an Xcast packet takes to a given destination\
    \ always follows the\n   ordinary, unicast routing for that destination.\n"
- title: 3.  The Cost of the Traditional IP Multicast Schemes
  contents:
  - "3.  The Cost of the Traditional IP Multicast Schemes\n   Traditional IP multicast\
    \ schemes [DEER, DEE2, FARI] were designed to\n   handle very large multicast\
    \ groups.  These work well if one is trying\n   to distribute broadcast-like channels\
    \ all around the world but they\n   have scalability problems when there is a\
    \ very large number of\n   groups.\n   The characteristics of the traditional\
    \ IP multicast model are\n   determined by its two components: the Host Group\
    \ model [DEER] and a\n   Multicast Routing Protocol.  Both components make multicast\
    \ very\n   different from unicast.\n   In the Host Group model, a group of hosts\
    \ is identified by a\n   multicast group address, which is used both for subscriptions\
    \ and\n   forwarding.  This model has two main costs:\n      - Multicast address\
    \ allocation: The creator of a multicast group\n        must allocate a multicast\
    \ address that is unique in its scope\n        (scope will often be global). \
    \ This issue is being addressed by\n        the MALLOC working group, which is\
    \ proposing a set of Multicast\n        Address Allocation Servers (MAAS) and\
    \ three protocols (Multicast\n        Address Set Claim (MASC), Address Allocation\
    \ Protocol (AAP),\n        Multicast Address Dynamic Client Allocation Protocol\
    \ (MADCAP)).\n      - Destination unawareness: When a multicast packet arrives\
    \ in a\n        router, the router can determine the next hops for the packet,\n\
    \        but knows nothing about the ultimate destinations of the packet,\n  \
    \      nor about how many times the packet will be duplicated later on\n     \
    \   in the network.  This complicates the security, accounting and\n        policy\
    \ functions.\n   In addition to the Host Group model, a routing algorithm is required\n\
    \   to maintain the member state and the delivery tree.  This can be done\n  \
    \ using a (truncated) broadcast algorithm or a multicast algorithm\n   [DEER].\
    \  Since the former consumes too much bandwidth by\n   unnecessarily forwarding\
    \ packets to some routers, only the multicast\n   algorithms are considered. \
    \ These multicast routing protocols have\n   the following costs:\n      - Connection\
    \ state: The multicast routing protocols exchange\n        messages that create\
    \ state for each (source, multicast group) in\n        all the routers that are\
    \ part of the point-to-multipoint tree.\n        This can be viewed as \"per flow\"\
    \ signaling that creates\n        multicast connection state, possibly yielding\
    \ huge multicast\n        forwarding tables.  Some of these schemes even disseminate\
    \ this\n        multicast routing information to places where it isn't\n     \
    \   necessarily needed [1075].  Other schemes try to limit the\n        amount\
    \ of multicast routing information that needs to be\n        disseminated, processed,\
    \ and stored throughout the network.\n        These schemes (e.g., [2201]) use\
    \ a \"shared distribution tree\"\n        that is shared by all the members of\
    \ a multicast group and they\n        try to limit the distribution of multicast\
    \ routing information\n        to just those nodes that \"really need it\".  But\
    \ these schemes\n        also have problems.  Because of the shared tree, they\
    \ use less\n        than optimal paths in routing packets to their destinations\
    \ and\n        they tend to concentrate traffic in small portions of a network.\n\
    \        And these schemes still involve lots of \"per flow\" signaling and\n\
    \        \"per flow\" state.\n      - Source advertisement mechanism: Multicast\
    \ routing protocols\n        provide a mechanism by which members get 'connected'\
    \ to the\n        sources for a certain group without knowing the sources\n  \
    \      themselves.  In sparse-mode protocols [2201, DEE2], this is\n        achieved\
    \ by having a core node, which needs to be advertised in\n        the complete\
    \ domain.  On the other hand, in dense-mode protocols\n        [1075] this is\
    \ achieved by a \"flood and prune\" mechanism.  Both\n        approaches raise\
    \ additional scalability issues.\n      - Inter-domain routing: Multicast routing\
    \ protocols that rely on a\n        core node [2201, DEE2] additionally need an\
    \ inter-domain\n        multicast routing protocol (e.g., [FARI]).\n   The cost\
    \ of multicast address allocation, destination unawareness and\n   the above scalability\
    \ issues lead to a search for other multicast\n   schemes.  Source-Specific Multicast\
    \ (SSM) [4607] addresses some of\n   the above drawbacks: in SSM, a host joins\
    \ a specific source, thus the\n   channel is identified by the couple (source\
    \ address, multicast\n   address).  This approach avoids multicast address allocation\
    \ as well\n   as the need for an inter-domain routing protocol.  The source\n\
    \   advertisement is taken out of the multicast routing protocol and is\n   moved\
    \ to an out-of-band mechanism (e.g., web page).\n   Note that SSM still creates\
    \ state and signaling per multicast channel\n   in each on-tree node.  Figure\
    \ 2 depicts the above costs as a function\n   of the number of members in the\
    \ session or channel.  All the costs\n   have a hyperbolic behavior.\n       \
    \  cost of the traditional\n           IP multicast model\n               per\
    \ member\n                    ^\n                    | costly|  OK\n         \
    \           | <-----|----->\n                    |  .    |\n                 \
    \   |   ..  |\n                    |     ..|..\n                    |       |\
    \  .........\n                    |       |           ........\n             \
    \       +--------------------------->\n                        |             \
    \    number of members\n                        v\n                 alternative=Xcast\n\
    \                                 Figure 2\n   The traditional IP multicast model\
    \ becomes expensive for its members\n   if the groups are small.  Small groups\
    \ are typical for conferencing,\n   gaming, and collaborative applications.  These\
    \ applications are well-\n   served by Xcast.\n   In practice, traditional IP\
    \ multicast routing protocols impose\n   limitations on the number of groups and\
    \ the size of the network in\n   which they are deployed.  For Xcast, these limitations\
    \ do not exist.\n"
- title: 4.  Motivation
  contents:
  - "4.  Motivation\n   Xcast takes advantage of one of the fundamental tenets of\
    \ the\n   Internet \"philosophy\", namely, that one should move complexity to\
    \ the\n   edges of the network and keep the middle of the network simple.  This\n\
    \   is the principle that guided the design of IP and TCP and it's the\n   principle\
    \ that has made the incredible growth of the Internet\n   possible.  For example,\
    \ one reason that the Internet has been able to\n   scale so well is that the\
    \ routers in the core of the network deal\n   with large Classless Inter-Domain\
    \ Routing (CIDR) blocks as opposed to\n   individual hosts or individual \"connections\"\
    .  The routers in the\n   core don't need to keep track of the individual TCP\
    \ connections that\n   are passing through them.  Similarly, the IETF's Diffserv\
    \ effort is\n   based on the idea that the routers shouldn't have to keep track\
    \ of a\n   large number of individual Resource Reservation Protocol (RSVP) flows\n\
    \   that might be passing through them.  It's the authors' belief that\n   the\
    \ routers in the core shouldn't have to keep track of a large\n   number of individual\
    \ multicast flows, either.\n   Compared to traditional IP multicast, Xcast has\
    \ the following\n   advantages:\n   1) Routers do not have to maintain state per\
    \ session (or per channel)\n      [SOLA].  This makes Xcast very scalable in terms\
    \ of the number of\n      sessions that can be supported since the nodes in the\
    \ network do\n      not need to disseminate or store any multicast routing information\n\
    \      for these sessions.\n   2) No multicast address allocation required.\n\
    \   3) No need for multicast routing protocols (neither intra- nor\n      inter-domain).\
    \  Xcast packets always take the \"right\" path as\n      determined by the ordinary\
    \ unicast routing protocols.\n   4) No core node, so no single point of failure.\
    \  Unlike the shared\n      tree schemes, Xcast minimizes network latency and\
    \ maximizes\n      network \"efficiency\".\n   5) Symmetric paths are not required.\
    \  Traditional IP multicast\n      routing protocols create non-shortest-path\
    \ trees if paths are not\n      symmetric.  (A path between two nodes A and B\
    \ is symmetric if the\n      path is both the shortest path from A to B as well\
    \ as the shortest\n      path from B to A.)  It is expected that an increasing\
    \ number of\n      paths in the Internet will be asymmetric in the future as a\
    \ result\n      of traffic engineering and policy routing, and thus the\n    \
    \  traditional IP multicast schemes will result in an increasing\n      amount\
    \ of suboptimal routing.\n   6) Automatic reaction to unicast reroutes.  Xcast\
    \ will react\n      immediately to unicast route changes.  In traditional IP multicast\n\
    \      routing protocols, a communication between the unicast and the\n      multicast\
    \ routing protocol needs to be established.  In many\n      implementations, this\
    \ is on a polling basis, yielding a slower\n      reaction to, e.g., link failures.\
    \  It may also take some time for\n      traditional IP multicast routing protocols\
    \ to fix things up if\n      there is a large number of groups that need to be\
    \ fixed.\n   7) Easy security and accounting.  In contrast with the Host Group\n\
    \      Model, in Xcast all the sources know the members of the multicast\n   \
    \   channel, which gives the sources the means to, e.g., reject\n      certain\
    \ members or count the traffic going to certain members\n      quite easily. \
    \ Not only a source, but also a border router is able\n      to determine how\
    \ many times a packet will be duplicated in its\n      domain.  It also becomes\
    \ easier to restrict the number of senders\n      or the bandwidth per sender.\n\
    \   8) Heterogeneous receivers.  Besides the list of destinations, the\n     \
    \ packet could (optionally) also contain a list of Diffserv Code\n      Points\
    \ (DSCPs).  While traditional IP multicast protocols have to\n      create separate\
    \ groups for each service class, Xcast incorporates\n      the possibility of\
    \ having receivers with different service\n      requirements within one multicast\
    \ channel.\n   9) Xcast packets can make use of traffic-engineered unicast paths.\n\
    \   10) Simple implementation of reliable protocols on top of Xcast,\n       because\
    \ Xcast can easily address a subset of the original list of\n       destinations\
    \ to do a retransmission.\n   11) Flexibility (see Section 6).\n   12) Easy transition\
    \ mechanisms (see Section 11).\n   It should be noted that Xcast has a number\
    \ of disadvantages as well:\n   1) Overhead.  Each packet contains all remaining\
    \ destinations.  But,\n      the total amount of data is still much less than\
    \ for unicast\n      (payload is only sent once).  A method to compress the list\
    \ of\n      destination addresses might be useful.\n   2) More complex header\
    \ processing.  Each destination in the packet\n      needs a routing table lookup.\
    \  So, an Xcast packet with n\n      destinations requires the same number of\
    \ routing table lookups as\n      n unicast headers.  Additionally, a different\
    \ header has to be\n      constructed per next hop.  Note however that:\n    \
    \  a) Since Xcast will typically be used for super-sparse sessions,\n        \
    \ there will be a limited number of branching points, compared to\n         non-branching\
    \ points.  Only in a branching point do new headers\n         need to be constructed.\n\
    \      b) The header construction can be reduced to a very simple\n         operation:\
    \ overwriting a bitmap.\n      c) Among the non-branching points, a lot of them\
    \ will contain only\n         one destination.  In these cases, normal unicast\
    \ forwarding can\n         be applied.\n      d) By using a hierarchical encoding\
    \ of the list of destinations in\n         combination with the aggregation in\
    \ the forwarding tables the\n         forwarding can be accelerated [OOMS].\n\
    \      e) When the packet enters a region of the network where link\n        \
    \ bandwidth is not an issue anymore, the packet can be\n         transformed by\
    \ a Premature X2U.  Premature X2U (see Section\n         11.2) occurs when a router\
    \ decides to transform the Xcast\n         packet for one or more destinations\
    \ into unicast packets.  This\n         avoids more complex processing downstream.\n\
    \      f) Other mechanisms to reduce the processing have been described\n    \
    \     in [IMAI] (tractable list) and [OOMS] (caching), but are not\n         (yet)\
    \ part of the Xcast specification.\n   3) Xcast only works with a limited number\
    \ of receivers.\n"
- title: 5.  Application
  contents:
  - "5.  Application\n   While Xcast is not suitable for multicast sessions with a\
    \ large\n   number of members, such as the broadcast of an IETF meeting, it does\n\
    \   provide an important complement to existing multicast schemes in that\n  \
    \ it can support very large numbers of small sessions.  Thus, Xcast\n   enables\
    \ important applications such as IP telephony,\n   videoconferencing, multi-player\
    \ games, collaborative e-meetings, etc.\n   The number of these sessions will\
    \ become huge.\n   Some may argue that it is not worthwhile to use multicast for\n\
    \   sessions with a limited number of members, and that it's preferable\n   to\
    \ use unicast instead.  But in certain cases, limited bandwidth in\n   the \"\
    last mile\" makes it important to have some form of multicast, as\n   the following\
    \ example illustrates.  Assume n residential users set up\n   a video conference.\
    \  Typically, access technologies are asymmetric\n   (e.g., xDSL, General Packet\
    \ Radio Service (GPRS), or cable modem).\n   So, a host with xDSL has no problem\
    \ receiving n-1 basic 100 kb/s\n   video channels, but the host is not able to\
    \ send its own video data\n   n-1 times at this rate.  Because of the limited\
    \ and often asymmetric\n   access capacity, some type of multicast is mandatory.\n\
    \   A simple but important application of Xcast lies in bridging the\n   access\
    \ link.  The host sends the Xcast packet with the list of\n   unicast addresses\
    \ and the first router performs a Premature X2U.\n   Since Xcast is not suitable\
    \ for large groups, Xcast will not replace\n   the traditional IP multicast model,\
    \ but it does offer an alternative\n   for multipoint-to-multipoint communications\
    \ when there can be very\n   large numbers of small sessions.\n"
- title: 6.  Xcast Flexibility
  contents:
  - "6.  Xcast Flexibility\n   The main goal of multicast is to avoid duplicate information\
    \ flowing\n   over the same link.  By using traditional IP multicast instead of\n\
    \   unicast, bandwidth consumption decreases while the state and\n   signaling\
    \ per session increases.  Xcast has a cost of 0 in these two\n   dimensions, but\
    \ it does introduce a third dimension corresponding to\n   the header processing\
    \ per packet.  This three-dimensional space is\n   depicted in Figure 3.\n   \
    \        state&signaling\n             per session\n              in router\n\
    \                  ^\n                  |\n                  |\n             \
    \    ....\n                B |  ....\n                . |      ....\n        \
    \       .  |          ....\n              .   |              ....\n          \
    \   .    +------------------..---> processing\n            .    /            \
    \   .... C     per packet\n           .   /            .....           in router\n\
    \          .  /         .....\n         . /      .....\n        ./   .....\n \
    \      /A....\n     /\n   /\n  link bandwidth\n                              \
    \   Figure 3\n   One method of delivering identical information from a source\
    \ to n\n   destinations is to unicast the information n times (A in Figure 3).\n\
    \   A second method, the traditional IP multicast model (B in Figure 3),\n   sends\
    \ the information only once to a multicast address.  In Xcast,\n   the information\
    \ is sent only once, but the packet contains a list of\n   destinations (point\
    \ C).\n   The three points A, B, and C define a plane (indicated with dots in\n\
    \   Figure 3): a plane of conservation of misery.  All three approaches\n   have\
    \ disadvantages.  The link bandwidth is a scarce resource,\n   especially in access\
    \ networks.  State&signaling/session encounters\n   limitations when the number\
    \ of sessions becomes large, and an\n   increased processing/packet is cumbersome\
    \ for high-link speeds.\n   One advantage of Xcast is that it allows a router\
    \ to move within this\n   plane of conservation of misery based upon its location\
    \ in a network.\n   For example, in the core of the network, a cache could be\
    \ used to\n   move along the line from C to B without introducing any per-flow\n\
    \   signaling.  Another possibility, as suggested above, is to use\n   premature\
    \ X2U to move along the line from C to A in an access network\n   if there is\
    \ an abundance of bandwidth in the backbone.\n"
- title: 7.  Xcast Control Plane Options
  contents:
  - "7.  Xcast Control Plane Options\n   Unlike traditional IP multicast schemes,\
    \ Xcast does not specify a\n   \"control plane\".  There is no Internet Group\
    \ Management Protocol\n   (IGMP [3376]), and as mentioned above, there are no\
    \ intra- or inter-\n   domain multicast routing protocols.  With Xcast, the means\
    \ by which\n   multicast sessions are defined is an application-level issue and\n\
    \   applications are not confined to the model in which hosts use IGMP to\n  \
    \ join a multicast session.  For example:\n   - Some applications might want to\
    \ use an IGMP-like receiver-join\n     model.\n   - Other applications might want\
    \ to use a model in which a user places\n     a call to the party or parties that\
    \ he or she wants to talk to\n     (similar to the way that one puts together\
    \ a conference call today\n     using the buttons on one's telephone).\n   - One\
    \ might define a session based on the cells that are close to a\n     moving device\
    \ in order to provide for a \"smooth handoff\" between\n     cells when the moving\
    \ device crosses cell boundaries.\n   - In some applications, the members of the\
    \ session might be specified\n     as arguments on a command line.\n   - One might\
    \ define an application that uses GPS to send video from a\n     bank robbery\
    \ to the three police cars that are closest to the bank\n     being robbed.\n\
    \   Thus, the application developer is not limited to the receiver-\n   initiated\
    \ joins of the IGMP model.  There will be multiple ways in\n   which an Xcast\
    \ sender determines the addresses of the members of the\n   channel.\n   For the\
    \ purpose of establishing voice and multimedia conferences over\n   IP networks,\
    \ several control planes have already been defined,\n   including SIP [3261] and\
    \ H.323 [H323].\n"
- title: 7.1.  SIP Control Plane for Xcast
  contents:
  - "7.1.  SIP Control Plane for Xcast\n   In SIP, a host takes the initiative to\
    \ set up a session.  With the\n   assistance of a SIP server, a session is created.\
    \  The session state\n   is kept in the hosts.  Data delivery can be achieved\
    \ by several\n   mechanisms: meshed unicast, bridged, or multicast.  Note that\
    \ for the\n   establishment of multicast delivery, a multicast protocol and\n\
    \   communication with Multicast Address Allocation Servers (MAAS) are\n   still\
    \ required.\n   In \"meshed unicast\" or \"multi-unicasting\", the application\
    \ keeps\n   track of the participants' unicast addresses and sends a unicast to\n\
    \   each of those addresses.  For reasons described in Section 3, multi-\n   unicasting\
    \ (rather than multicast) is the prevalent solution in use\n   today.  It's a\
    \ simple matter to replace multi-unicast code with Xcast\n   code.  All that the\
    \ developer has to do is replace a loop that sends\n   a unicast to each of the\
    \ participants by a single \"xcast_send\" that\n   sends the data to the participants.\
    \  Thus it's easy to incorporate\n   Xcast into real conferencing applications.\n\
    \   Both Xcast and SIP address super-sparse multicast sessions.  It turns\n  \
    \ out that Xcast (a very flexible data plane mechanism) can be easily\n   integrated\
    \ with SIP (a very flexible control plane protocol).  When\n   an application\
    \ decides to use Xcast forwarding it does not affect its\n   interface to the\
    \ SIP agent: it can use the same SIP messages as it\n   would for multi-unicasting.\
    \  SIP could be used with Xcast to support\n   the conferencing model mentioned\
    \ above in which a caller places a\n   call to several parties.\n"
- title: 7.2.  Receiver-Initiated Join for Xcast
  contents:
  - "7.2.  Receiver-Initiated Join for Xcast\n   In the previous section, it was discussed\
    \ how to establish an Xcast\n   session among well known participants of a multi-party\
    \ conference.\n   In some cases, it is useful for participants to be able to join\
    \ a\n   session without being invited.  For example, the chairman of a video\n\
    \   chat may want to leave the door of their meeting open for newcomers.\n   The\
    \ IGMP-like receiver-initiated join model mentioned above can be\n   implemented\
    \ by introducing a server that hosts can talk to, to join a\n   conference.\n"
- title: 8.  Optional Information
  contents:
  - '8.  Optional Information

    '
- title: 8.1.  List of Ports
  contents:
  - "8.1.  List of Ports\n   Although an extension to SIP could be arranged such that\
    \ all\n   participants in a session use the same transport (UDP) port number,\n\
    \   in the general case, it is possible for each participant to listen on\n  \
    \ a different port number.  To cover this case, the Xcast packet\n   optionally\
    \ contains a list of port numbers.\n   If the list of port numbers is present,\
    \ the destination port number\n   in the transport-layer header will be set to\
    \ zero.  On X2U, the\n   destination port number in the transport-layer header\
    \ will be set to\n   the port number corresponding to the destination of the unicast\n\
    \   packet.\n"
- title: 8.2.  List of DSCPs
  contents:
  - "8.2.  List of DSCPs\n   The Xcast packet could (optionally) also contain a list\
    \ of Diffserv\n   Code Points (DSCPs).  While traditional IP multicast protocols\
    \ have\n   to create separate groups for each service class, Xcast incorporates\n\
    \   the possibility of having receivers with different service\n   requirements\
    \ within one channel.\n   The DSCP in the IP header will be set to the most demanding\
    \ DSCP of\n   the list of DSCPs.  This DSCP in the IP header will determine, e.g.,\n\
    \   the scheduler to use.\n   If two destinations, with the same next-hop, have\
    \ 'non-mergeable'\n   DSCPs, two Xcast packets will be created.  'Non-mergeable'\
    \ meaning\n   that one cannot say that one is more or less stringent than the\n\
    \   other.\n"
- title: 8.3.  Channel Identifier
  contents:
  - "8.3.  Channel Identifier\n   Optionally, a sender can decide to add an extra\
    \ number in the Xcast\n   header: the Channel Identifier.  If the source does\
    \ not want to use\n   this option, it must set the Channel Identifier to zero.\
    \  If the\n   Channel Identifier is non-zero, the pair (Source Address, Channel\n\
    \   Identifier) must uniquely identify the channel (note that this is\n   similar\
    \ to the (S, G) pair in SSM).  This document does not assign\n   any other semantics\
    \ to the Channel Identifier besides the one above.\n   This Channel Identifier\
    \ could be useful for several purposes:\n   1) A key to a caching table [OOMS].\n\
    \   2) \"Harmonization\" when used with Host Group Multicast  (to be\n      discussed\
    \ in greater detail in another document).\n   3) An identifier of the channel\
    \ in error, flow control, etc.,\n      messages.\n   4) It gives an extra demultiplexing\
    \ possibility (beside the port-\n      number).\n   5) ...\n   The size of the\
    \ channel identifier and its semantics are TBD.\n"
- title: 9.  Possible Xcast Packet Encoding
  contents:
  - '9.  Possible Xcast Packet Encoding

    '
- title: 9.1.  General
  contents:
  - "9.1.  General\n   The source address field of the IP header contains the address\
    \ of the\n   Xcast sender.  The destination address field carries the All-Xcast-\n\
    \   Routers address (to be assigned link-local multicast address); this\n   is\
    \ to have a fixed value.  Every Xcast router joins this multicast\n   group. \
    \ The reasons for putting a fixed number in the destination\n   field are:\n \
    \  1) The destination address field is part of the IP pseudo header and\n    \
    \  the latter is covered by transport layer checksums (e.g., UDP\n      checksum).\
    \  So, the fixed value avoids a (delta) recalculation of\n      the checksum.\n\
    \   2) The IPsec Authentication Header (AH) [4302] covers the IP header\n    \
    \  destination address, hence preventing any modification to that\n      field.\
    \  Also, both AHs and Encapsulating Security Payloads (ESPs)\n      cover the\
    \ whole UDP packet (via authentication and/or encryption).\n      The UDP checksum\
    \ cannot therefore be updated if the IP header\n      destination address were\
    \ to change.\n   3) In Xcast for IPv6, the Routing Extension shall be used; this\n\
    \      header extension is only checked by a router if the packet is\n      destined\
    \ to this router.  This is achieved by making all Xcast\n      routers part of\
    \ the All_Xcast_Routers group.\n   4) Normally Xcast packets are only visible\
    \ to Xcast routers.\n      However, if a non-Xcast router receives an Xcast packet\
    \ by\n      accident (or by criminal intent), it will not send ICMP errors\n \
    \     since the Xcast packet carries a multicast address in the\n      destination\
    \ address field [1812].\n   Note that some benefits only hold when the multicast\
    \ address stays in\n   the destination field until it reaches the end-node (thus\
    \ not\n   combinable with X2U).\n"
- title: 9.2.  IPv4
  contents:
  - "9.2.  IPv4\n   [AGUI] and [1770] proposed (for a slightly different purpose)\
    \ to\n   carry multiple destinations in the IPv4 option.  But because of the\n\
    \   limited flexibility (limited size of the header), Xcast will follow\n   another\
    \ approach.  The list of destinations will be encoded in a\n   separate header.\
    \  The Xcast header for IPv4 (in short, Xcast4) would\n   be carried between the\
    \ IPv4 header and the transport-layer header.\n         [IPv4 header | Xcast4\
    \ | transport header | payload ]\n   Note also that since the Xcast header is\
    \ added to the data portion of\n   the packet, if the sender wishes to avoid IP\
    \ fragmentation, it must\n   take the size of the Xcast header into account.\n"
- title: 9.2.1.  IPv4 Header
  contents:
  - "9.2.1.  IPv4 Header\n   The Xcast4 header is carried on top of an IP header.\
    \  The IP header\n   will carry the protocol number listed as usable for experimental\n\
    \   purposes in RFC 4727 [4727].  See also Section 15.  The source\n   address\
    \ field contains the address of the Xcast sender.  The\n   destination address\
    \ field carries the All_Xcast_Routers address.\n"
- title: 9.2.2.  Xcast4 Header
  contents:
  - "9.2.2.  Xcast4 Header\n   The Xcast4 header is format depicted in Figure 4. \
    \ It is composed of\n   two parts: a fixed part (first 12 octets) and two variable-length\n\
    \   parts that are specified by the fixed part.\n     0               1      \
    \         2               3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |VERSION|A|X|D|P|R| NBR_OF_DEST |          CHECKSUM             |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                     CHANNEL IDENTIFIER                      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |    PROT ID    |    LENGTH     |             RESV              |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                 List of Addresses and DSCPs                 |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                 List of Port Numbers (optional)               |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \                         Figure 4\n   VERSION = Xcast version number.  This document\
    \ describes version 1.\n   A = Anonymity bit: if this bit is set, the destination\
    \ addresses for\n   which the corresponding bit in the bitmap is zero must be\
    \ overwritten\n   by zero.\n   X = Xcast bit: if this bit is set, a router must\
    \ not reduce the Xcast\n   packet to unicast packet(s), i.e., the packet must\
    \ stay an Xcast\n   packet end-to-end.  This bit can be useful when IPsec [4301]\
    \ is\n   applied.  If this bit is cleared a router should apply X2U if there\n\
    \   is only one destination left in the Xcast packet.  In some cases a\n   router\
    \ could decide not to apply X2U to a packet with the Xcast bit\n   cleared, e.g.,\
    \ the router has no directly connected hosts and wants\n   to avoid the extra\
    \ processing required by X2U.\n   D = DSCP bit: if this bit is set, the packet\
    \ will contain a DS byte\n   for each destination.\n   P = Port bit: if this bit\
    \ is set, the packet will contain a port\n   number for each destination.\n  \
    \ NBR_OF_DEST = the number of original destinations.\n   CHECKSUM = A checksum\
    \ on the Xcast header only.  This is verified and\n   recomputed at each point\
    \ that the Xcast header is processed.  The\n   checksum field is the 16-bit one's\
    \ complement of the one's complement\n   sum of all the bytes in the header. \
    \ For purposes of computing the\n   checksum, the value of the checksum field\
    \ is zero.  It is not clear\n   yet whether a checksum is needed (for further\
    \ study).  If only one\n   destination is wrong it can still be useful to forward\
    \ the packet to\n   N-1 correct destinations and 1 incorrect destination.\n  \
    \ CHANNEL IDENTIFIER = 4-octet Channel Identifier (see Section 8.3).\n   Since\
    \ it is located within the first 8 bytes of the header, it will\n   be returned\
    \ in ICMP messages.\n   PROT ID = specifies the protocol of the following header.\n\
    \   LENGTH = length of the Xcast header in 4-octet words.  This field\n   puts\
    \ an upper boundary to the number of destinations.  This value is\n   also determined\
    \ by the NBR_OF_DEST field and the D and P bits.\n   RESV = R = Reserved.  It\
    \ must be zero on transmission and must be\n   ignored on receipt.\n   The first\
    \ variable part is the 'List of Addresses and DSCPs', the\n   second variable\
    \ part is the 'List of Port Numbers'.  Both are 4-octet\n   aligned.  The second\
    \ variable part is only present if the P-bit is\n   set.\n   Figure 5 gives an\
    \ example of the variable part for the case that the\n   P-bit is set and the\
    \ D-bit is cleared (in this example, N is odd):\n     0               1      \
    \         2               3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                            BITMAP                             |\n    \
    \ ~                                                               ~\n     |  \
    \                                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                          Destination 1                        |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     ~  \
    \                            ...                              ~\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                          Destination N                        |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \           Port 1            |         Port 2                |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     ~                              ...                              ~\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \           Port N            |         padding               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                                 Figure 5\n   BITMAP = every destination has\
    \ a corresponding bit in the bitmap to\n   indicate whether the destination is\
    \ still valid on this branch of the\n   tree.  The first bit corresponds to the\
    \ first destination in the\n   list.  This field is 4-octet aligned (e.g., for\
    \ 49 destinations,\n   there will be a 64-bit bitmap).  If Xcast is applied in\
    \ combination\n   with IPsec, the bitmap -- since it can change en route -- has\
    \ to be\n   moved to a new to-be-defined IPv4 option.\n   List of Destinations.\
    \  Each address size is 4 octets.\n   List of Port Numbers.  List of 2-octet destination\
    \ port number(s),\n   where each port corresponds in placement to the preceding\
    \ Destination\n   Address.\n"
- title: 9.3.  IPv6
  contents:
  - "9.3.  IPv6\n   The Xcast6 header encoding is similar to IPv4, except that Xcast\n\
    \   information would be stored in IPv6 extension headers.\n         [IPv6 header\
    \ | Xcast6 | transport header | payload ]\n"
- title: 9.3.1.  IPv6 Header
  contents:
  - "9.3.1.  IPv6 Header\n   The IPv6 header will carry the NextHeader value 'Routing\
    \ Extension'.\n   The source address field contains the address of the Xcast sender.\n\
    \   The destination address field carries the All_Xcast_Routers address.\n"
- title: 9.3.2.  Xcast6 Header
  contents:
  - "9.3.2.  Xcast6 Header\n   The Xcast6 header is also composed of a fixed part\
    \ and two variable\n   parts.  The fixed part and the first variable part are\
    \ carried in a\n   Routing Extension.  The second variable part is carried in\
    \ a\n   Destination Extension.\n"
- title: 9.3.2.1.  Routing Extension Header
  contents:
  - "9.3.2.1.  Routing Extension Header\n   The P-bit of Xcast4 is not present because\
    \ it is implicit by the\n   presence or absence of the Destination Extension (Figure\
    \ 6).\n     0               1               2               3\n     0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Next Header  |  HdrExtLen    |RouteType=Xcast|       0       |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |VERSION|A|X|D|\
    \ R | NBR_OF_DEST |          CHECKSUM             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                       CHANNEL IDENTIFIER                      |\n    \
    \ ~                                                               ~\n     |  \
    \                                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |              List of Addresses and DSCPs                      |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \                         Figure 6\n   HdrExtLen = The header length is expressed\
    \ in 8-octets; thus, a\n   maximum of 127 destinations can be listed (this is\
    \ why NBR_OF_DEST is\n   7 bits).\n   RouteType = Xcast (see Section 15)\n   The\
    \ fourth octet is set to 0.\n   R = Reserved.\n   CHANNEL IDENTIFIER = 16-octet\
    \ Channel Identifier (see Section 8.3).\n   The other fields are defined in Section\
    \ 9.2.2.\n   The 'List of Addresses and DSCPs' is 8-octet aligned.  The size of\n\
    \   the bitmap is determined by the number of destinations and is a\n   multiple\
    \ of 64 bits.\n"
- title: 9.3.2.2.  Destination Extension Header
  contents:
  - "9.3.2.2.  Destination Extension Header\n   Optionally, the Destination Extension\
    \ (Figure 7) is present to\n   specify the list of Port Numbers.  The destination\
    \ header is only\n   evaluated by the destination node.\n     0              \
    \ 1               2               3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Next Header  |  HdrExtLen    |Opt Type=Ports | Opt Data Len  |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                   List of Port Numbers                      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                                 Figure 7\n   For the Option Type for Ports,\
    \ see Section 15.  The first three bits\n   must be 010 to indicate that the packet\
    \ must be discarded if the\n   option is unknown and that the option cannot be\
    \ changed en-route.\n   The number of Ports must be equal to the number of destinations\n\
    \   specified in the Routing header.\n"
- title: 10.  Impact on Upper-Layer Protocols
  contents:
  - "10.  Impact on Upper-Layer Protocols\n   Some fields in the Xcast header(s) can\
    \ be modified as the packet\n   travels along its delivery path.  This has an\
    \ impact on:\n"
- title: 10.1.  Checksum Calculation in Transport-Layer Headers
  contents:
  - "10.1.  Checksum Calculation in Transport-Layer Headers\n   In transport-layer\
    \ headers, the target of the checksum calculation\n   includes the IP pseudo header,\
    \ transport header, and payload (IPv6\n   header extensions are not a target).\n\
    \   The transformation of an Xcast packet to a normal unicast packet --\n   (premature)\
    \ X2U -- replaces the multicast address in the IP header\n   destination field\
    \ by the address of a final destination.  If the\n   Xcast header contains a Port\
    \ List, the port number in the transport\n   layer (which should be zero) also\
    \ needs to be replaced by the port\n   number corresponding to the destination.\
    \  This requires a\n   recalculation of these checksums.  Note that this does\
    \ not require a\n   complete recalculation of the checksum, only a delta calculation,\n\
    \   e.g., for IPv4:\n     Checksum' = ~ (~Checksum + ~daH + ~daL + daH' + daL'\
    \ + ~dp + dp')\n   In which \"'\" indicates the new values, \"da\" the destination\
    \ address,\n   \"dp\" the destination port, and \"H\" and \"L\" the higher and\
    \ lower 16\n   bits, respectively.\n"
- title: 10.2.  IPsec
  contents:
  - "10.2.  IPsec\n   This is described in [PARI].\n"
- title: 11.  Gradual Deployment
  contents:
  - '11.  Gradual Deployment

    '
- title: 11.1.  Tunneling
  contents:
  - "11.1.  Tunneling\n   One way to deploy Xcast in a network that has routers that\
    \ have no\n   knowledge of Xcast is to setup \"tunnels\" between Xcast peers (MBone\n\
    \   approach [MBONE]).  This enables the creation of a virtual network\n   layered\
    \ on top of an existing network [2003].  The Xcast routers\n   exchange and maintain\
    \ Xcast routing information via any standard\n   unicast routing protocol (e.g.,\
    \ RIP, OSPF, IS-IS, BGP).  The Xcast\n   routing table that is created is simply\
    \ a standard unicast routing\n   table that contains the destinations that have\
    \ Xcast connectivity,\n   along with their corresponding Xcast next hops.  In\
    \ this way, packets\n   may be forwarded hop-by-hop to other Xcast routers, or\
    \ may be\n   \"tunneled\" through non- Xcast routers in the network.\n   For example,\
    \ suppose that A is trying to get packets distributed to\n   B, C, and D in Figure\
    \ 8 below, where \"X\" routers are Xcast-capable,\n   and \"R\" routers are not.\
    \  Figure 9 shows the routing tables created\n   via the Xcast tunnels:\n    \
    \                               R4 ---- B\n                                  /\n\
    \                                 /\n       A ----- X1 ---- R2 ---- X3       \
    \               R8 ---- C\n                                 \\               \
    \     /\n                                  \\                  /\n           \
    \                        R5 ---- R6 ---- X7\n                                \
    \                    \\\n                                                    \
    \ \\\n                                                       R9 ---- D\n     \
    \                            Figure 8\n   Router X1 establishes a tunnel to Xcast\
    \ peer X3.  Router X3\n   establishes a tunnel to Xcast peers X1 and X7.  Router\
    \ X7 establishes\n   a tunnel to Xcast peer X3.\n      X1 routing table:     X3\
    \ routing table:     X7 routing table:\n       Dest |  NextHop       Dest | NextHop\
    \        Dest | NextHop\n      ------+----------     ------+---------      ------+---------\n\
    \        B   |   X3             A  |   X1            A   |  X3\n        C   |\
    \   X3             C  |   X7            B   |  X3\n        D   |   X3        \
    \     D  |   X7\n                                 Figure 9\n   The source A will\
    \ send an Xcast packet to its default Xcast router,\n   X1, that includes the\
    \ list of destinations for the packet.  The\n   packet on the link between X1\
    \ and X3 is depicted in Figure 10:\n                              +----------+\n\
    \                              | payload  |\n                              +----------+\n\
    \                              |   UDP    |\n                              +----------+\n\
    \                              |  Xcast   |\n                              | \
    \ B,C,D   |\n                              | prot=UDP |\n                    \
    \          +----------+\n                              | inner IP |\n        \
    \                      |  src=A   |\n                              |dst=All_X_|\n\
    \                              |prot=Xcast|\n                              +----------+\n\
    \                              | outer IP |\n                              | \
    \ src=X1  |\n                              |  dst=X3  |\n                    \
    \          | prot=IP  |\n                              +----------+\n        \
    \                       Figure 10\n   When X3 receives this packet, it processes\
    \ it as follows:\n   - Perform a route table lookup in the Xcast routing table\
    \ to\n     determine the Xcast next hop for each of the destinations listed in\n\
    \     the packet.\n   - If no Xcast next hop is found, replicate the packet and\
    \ send a\n     standard unicast to the destination.\n   - For those destinations\
    \ for which an Xcast next hop is found,\n     partition the destinations based\
    \ on their next hops.\n   - Replicate the packet so that there's one copy of the\
    \ packet for\n     each of the Xcast next hops found in the previous steps.\n\
    \   - Modify the list of destinations in each of the copies so that the\n    \
    \ list in the copy for a given next hop includes just the\n     destinations that\
    \ ought to be routed through that next hop.\n   - Send the modified copies of\
    \ the packet on to the next hops.\n   - Optimization: If there is only one destination\
    \ for a particular\n     Xcast next hop, send the packet as a standard unicast\
    \ packet to the\n     destination, since there is no advantage to forwarding it\
    \ as an\n     Xcast packet.\n   So, in the example above, X1 will send a single\
    \ packet on to X3 with\n   a destination list of < B C D >.  This packet will\
    \ be received by R2\n   as a unicast packet with destination X3, and R2 will forward\
    \ it on,\n   having no knowledge of Xcast.  When X3 receives the packet, it will,\n\
    \   by the algorithm above, send one copy of the packet to destination\n   < B\
    \ > as an ordinary unicast packet, and 1 copy of the packet to X7\n   with a destination\
    \ list of < C D >.  R4, R5, and R6 will behave as\n   standard routers with no\
    \ knowledge of Xcast.  When X7 receives the\n   packet, it will parse the packet\
    \ and transmit ordinary unicast\n   packets addressed to < C > and < D >, respectively.\n\
    \   The updating of this route table, while simple in an intra-domain\n   environment,\
    \ would be more complex in an inter-domain environment.\n   Thus, the use of tunneling\
    \ in an inter-domain environment requires\n   further consideration.\n"
- title: 11.2.  Premature X2U
  contents:
  - "11.2.  Premature X2U\n   If a router discovers that its downstream neighbor is\
    \ not Xcast\n   capable, it can perform a Premature X2U, i.e., send a unicast\
    \ packet\n   for each destination in the Xcast header that has this neighbor as\
    \ a\n   next hop.  Thus, duplication is done before the Xcast packet reached\n\
    \   its actual branching point.\n   A mechanism (protocol/protocol extension)\
    \ to discover the Xcast\n   capability of a neighbor is for further study.  Among\
    \ others, one\n   could think of an extension to a routing protocol to advertise\
    \ Xcast\n   capabilities, or one could send periodic 'Xcast pings' to its\n  \
    \ neighbors (send an Xcast packet that contains its own address as a\n   destination\
    \ and check whether the packet returns).\n"
- title: 11.3.  Semi-Permeable Tunneling (IPv6 Only)
  contents:
  - "11.3.  Semi-Permeable Tunneling (IPv6 Only)\n   This is an optimization of tunneling\
    \ in the sense that it does not\n   require (manual) configuration of tunnels.\
    \  It is enabled by adding a\n   Hop-by-Hop Xcast6 header.  An IPv6 packet can\
    \ initiate/trigger\n   additional processing in the on-route routers by using\
    \ the IPv6 Hop-\n   by-hop option.\n   The type of the Xcast6 Hop-by-hop option\
    \ has a prefix '00' so that\n   routers that cannot recognize Xcast6 can treat\
    \ the Xcast6 datagram as\n   a normal IPv6 datagram and forward it toward the\
    \ destination in the\n   IPv6 header.\n   Packets will be delivered to all members\
    \ if at least all\n   participating hosts are upgraded.\n   When the source A\
    \ sends an Xcast packet via semi-permeable tunneling\n   to destinations B, C,\
    \ and D, it will create the packet of Figure 11.\n   One of the final destinations\
    \ will be put in the destination address\n   field of the outer IP header.\n \
    \                             +----------+\n                              | payload\
    \  |\n                              +----------+\n                           \
    \   |   UDP    |\n                              +----------+\n               \
    \               |  Xcast   |\n                              |          |\n   \
    \                           +----------+\n                              | inner\
    \ IP |\n                              |  src=A   |\n                         \
    \     |dst=All_X_|\n                              |prot=Xcast|\n             \
    \                 +----------+\n                              |  Xcast   |\n \
    \                             |SP-tunnel |\n                              |Hop-by-hop|\n\
    \                              +----------+\n                              | outer\
    \ IP |\n                              |  src=A   |\n                         \
    \     |  dst=B   |\n                              | prot=IP  |\n             \
    \                 +----------+\n                               Figure 11\n   Semi-permeable\
    \ tunneling is a special tunneling technology that\n   permits intermediate Xcast\
    \ routers on a tunnel to check the\n   destinations and branch if destinations\
    \ have a different next hop.\n   Note that with the introduction of an Xcast IPv4\
    \ option, this\n   technique could also be applied in IPv4 networks.\n"
- title: '11.4.  Special Case: Deployment without Network Support'
  contents:
  - "11.4.  Special Case: Deployment without Network Support\n   A special method\
    \ of deploying Xcast is possible by upgrading only the\n   hosts.  By applying\
    \ tunneling (see Sections 11.1 and 11.3) with one\n   of the final destinations\
    \ as a tunnel endpoint, the Xcast packet will\n   be delivered to all destinations\
    \ when all the hosts are Xcast aware.\n   Both normal and semi-permeable tunneling\
    \ can be used.\n   If host B receives this packet, in the above example, it will\
    \ notice\n   the other destinations in the Xcast header.  B will create a new\n\
    \   Xcast packet and will send it to one of the remaining destinations.\n   In\
    \ the case of Xcast6 and semi-permeable tunneling, Xcast routers can\n   be introduced\
    \ in the network without the need of configuring tunnels.\n   The disadvantages\
    \ of this method are:\n   - all hosts in the session need to be upgraded.\n  \
    \ - non-optimal routing.\n   - anonymity issue: hosts can know the identity of\
    \ other parties in\n   the session (which is not a big issue in conferencing,\
    \ but maybe for\n   some other application).\n   - host has to perform network\
    \ functions and needs an upstream link\n   which has the same bandwidth as its\
    \ downstream link.\n"
- title: 11.5.  Using a Small Number of Xcast-Aware Routers to Provide Xcast
  contents:
  - "11.5.  Using a Small Number of Xcast-Aware Routers to Provide Xcast\n       in\
    \ a Not-So-Small Network\n   In this approach, an Xcast packet uses a special\
    \ 32-bit unicast\n   address in the destination field of the IP header.  In the\
    \ simplest\n   version of this scheme, there might be only a single Xcast-aware\n\
    \   router in a network.  This Xcast-aware router looks like a \"server\"\n  \
    \ to the other routers and it is configured so that its IP address (or\n   one\
    \ of its IP addresses) corresponds to the \"special\" 32-bit address.\n   Thus,\
    \ when Xcast clients send Xcast packets, the non-Xcast-aware\n   routers will\
    \ route these packets to the Xcast-aware router and the\n   Xcast-aware router\
    \ can \"explode\" (X2U) them into an appropriate set\n   of unicast packets. \
    \ This allows clients anywhere in a network to use\n   Xcast to overcome the problem\
    \ of limited bandwidth in the \"first\n   mile\" with a minimum number of Xcast-aware\
    \ routers (i.e., 1).\n   Another possibility is to deploy a few of these Xcast-aware\
    \ routers\n   at various points in the network and to configure each of these\
    \ with\n   the special 32-bit address.  This provides redundancy, eliminating\n\
    \   the single point of failure, and reduces the distance an Xcast packet\n  \
    \ needs to travel to reach an Xcast-aware router, reducing network\n   latencies.\
    \  In this case, the Xcast-aware routers appear to be a\n   single server that\
    \ is \"multihomed\" (i.e., connected to the network at\n   more than one place)\
    \ and the non-Xcast-aware routers will, via\n   ordinary unicast routing, deliver\
    \ packets that are addressed to this\n   \"multihomed virtual server\" via the\
    \ shortest available path.\n   Note that this scheme of delivering packets to\
    \ any host in a group is\n   also known as an \"anycast\" and is described in\
    \ more detail in RFCs\n   [1546], [2526], and [3068].  Note too that RFC 1546\
    \ says:\n         The important observation is that multiple routes to an anycast\n\
    \         address appear to a router as multiple routes to a unicast\n       \
    \  destination, and the router can use standard algorithms to\n         choose\
    \ the best route.\n"
- title: 12.  (Socket) API
  contents:
  - "12.  (Socket) API\n   In the most simple use of Xcast, the final destinations\
    \ of an Xcast\n   packet receive an ordinary unicast UDP packet.  This means that\
    \ hosts\n   can receive an Xcast packet with a standard, unmodified TCP/IP stack.\n\
    \   Hosts can also transmit Xcast packets with a standard TCP/IP stack\n   with\
    \ a small Xcast library that sends Xcast packets on a raw socket.\n   This has\
    \ been used to implement Xcast-based applications on both Unix\n   and Windows\
    \ platforms without any kernel changes.\n   Another possibility is to modify the\
    \ sockets interface slightly.  For\n   example, one might add an \"xcast_sendto\"\
    \ function that works like\n   \"sendto\" but that uses a list of destination\
    \ addresses in place of\n   the single address that \"sendto\" uses.\n"
- title: 13.  Unresolved Issues
  contents:
  - "13.  Unresolved Issues\n   Additional work is needed in several areas.\n"
- title: 13.1.  The Format of the "List of Addresses"
  contents:
  - "13.1.  The Format of the \"List of Addresses\"\n   Additional details need to\
    \ be specified.  For example, in the IPv4\n   case, the format of the DSCPs option\
    \ needs to be specified.\n"
- title: 13.2.  The Size of Channel Identifier
  contents:
  - "13.2.  The Size of Channel Identifier\n   The size of the channel identifiers\
    \ in IPv4 and IPv6 are different in\n   this document. 32 bits might be sufficient\
    \ for both IPv6 and IPv4.\n"
- title: 13.3.  Incremental Deployment
  contents:
  - "13.3.  Incremental Deployment\n   Several possible methods of incremental deployment\
    \ are discussed in\n   this document including tunneling, premature X2U, etc.\
    \  Additional\n   work is needed to determine the best means of incremental deployment\n\
    \   for an intra-domain as well as an inter-domain deployment of Xcast.\n   If\
    \ tunneling is used, additional details need to be specified (e.g.,\n   tunneling\
    \ format, use of tunnels in the inter-domain case).\n"
- title: 13.4.  DSCP Usage
  contents:
  - "13.4.  DSCP Usage\n   DSCP usage needs some work.  DSCPs may have to be rewritten\
    \ as\n   packets cross inter-domain boundaries.\n"
- title: 13.5.  Traversing a Firewall or NAT Products
  contents:
  - "13.5.  Traversing a Firewall or NAT Products\n   The usage of a different, carried\
    \ protocol type for IPv4 may cause\n   difficulty in traversing some firewall\
    \ and NAT products.\n"
- title: 13.6.  The Size of BITMAP
  contents:
  - "13.6.  The Size of BITMAP\n   Given that this is designed for small groups, it\
    \ might make sense to\n   simply mandate a fixed size for the bitmap.\n"
- title: 14.  Security Considerations
  contents:
  - "14.  Security Considerations\n   The list of destinations in Xcast is provided\
    \ by an application layer\n   that manages group membership as well as authorization\
    \ if\n   authorization is desired.\n   Since a source has the list of destinations\
    \ and can make changes to\n   the list, it has more control over where its packets\
    \ go than in\n   traditional multicast and can prevent anonymous eavesdroppers\
    \ from\n   joining a multicast session, for example.\n   Some forms of denial-of-service\
    \ attack can use Xcast to increase\n   their \"effect\".  A smurf attack, for\
    \ example, sends an ICMP Echo\n   Request in which the source address in the packet\
    \ is set to the\n   address of the target of the attack so that the target will\
    \ receive\n   the ICMP echo reply.  With Xcast, the ICMP Echo Request could be\
    \ sent\n   to a list of destinations that could cause each member of the list\
    \ to\n   send an Echo Reply to the target.\n   Measures have been taken in traditional\
    \ multicast to avoid this kind\n   of attack.  A router or host can be configured\
    \ so that it will not\n   reply to ICMP requests addressed to a multicast address.\
    \  The Reverse\n   Path Forwarding check in traditional multicast architectures\
    \ also\n   helps limit these attacks.  In Xcast, it can be difficult for a host\n\
    \   to recognize that an ICMP request has been addressed to multiple\n   destinations\
    \ since the packet may be an ordinary unicast packet by\n   the time it reaches\
    \ the host.  On the other hand, a router can detect\n   Xcast packets that are\
    \ used to send ICMP requests to multiple\n   destinations and can be configured\
    \ to drop those packets.  Note, too,\n   that since Xcast sends packets to a short\
    \ list of destinations, the\n   problem of sending attack packets to multiple\
    \ destination is less of\n   a problem than in traditional multicast.  Obviously,\
    \ the use of IPsec\n   to provide confidentiality and/or authentication can further\
    \ diminish\n   the risk of this type of attack.\n   The problem of secure group\
    \ communications has been addressed by the\n   Multicast Security (MSEC) working\
    \ group, which has defined an\n   architecture for securing IP-multicast-based\
    \ group communications\n   [3740].  Many of the concepts discussed in the MSEC\
    \ working group,\n   such as managing group membership, identifying and authenticating\n\
    \   group members, protecting the confidentiality and integrity of\n   multicast\
    \ traffic, and managing and securely distributing and\n   refreshing keys, also\
    \ apply to Xcast-based group communications.  And\n   many of the same mechanisms\
    \ seem to apply.  One significant\n   difference between multicast and Xcast is\
    \ the fact that the Xcast\n   header (or at least a bitmap in the Xcast header)\
    \ needs to change as\n   an Xcast packet travels from a source to a destination.\
    \  This affects\n   the use of IPsec and suggests that at least the Xcast header\
    \ bitmap\n   must be in a \"mutable\" field.  A complete solution for securing\n\
    \   Xcast-based group communications addressing all the issues listed\n   above\
    \ will be the subject of additional work which will be discussed\n   in one or\
    \ more additional documents.  We expect that this effort will\n   build on the\
    \ work that has already been done in the msec working\n   group.\n"
- title: 15.  IANA Considerations
  contents:
  - "15.  IANA Considerations\n   Experimentation with the Xcast protocol requires\
    \ the use of protocol\n   numbers maintained by IANA.  For example, to implement\
    \ XCAST6,\n   implementations must agree on four protocol numbers:\n         \
    \ (1) Multicast Address for All_Xcast_Routers\n          (2) Routing Type of IPv6\
    \ Routing Header\n          (3) Option Type of IPv6 Destination Option Header\n\
    \          (4) Option Type of IPv6 Hop-by-Hop Options Header\n   A protocol implementer\
    \ may temporarily experiment with Xcast by using\n   the values set aside for\
    \ experimental use in RFC [4727].  An\n   implementer must verify that no other\
    \ experiment uses the same values\n   on the Xcast testbed at the same time.\n\
    \   A future revision of the Xcast specification published on the\n   standards\
    \ track is required before IANA can assign permanent registry\n   entries for\
    \ Xcast.  Implementers should be aware that they will need\n   to modify their\
    \ implementations when such permanent allocations are\n   made.\n"
- title: 16.  Informative References
  contents:
  - "16.  Informative References\n   [1546]  Partridge, C., Mendez, T., and W. Milliken,\
    \ \"Host Anycasting\n           Service\", RFC 1546, November 1993.\n   [2526]\
    \  Johnson, D. and S. Deering, \"Reserved IPv6 Subnet Anycast\n           Addresses\"\
    , RFC 2526, March 1999.\n   [3068]  Huitema, C., \"An Anycast Prefix for 6to4\
    \ Relay Routers\", RFC\n           3068, June 2001.\n   [1112]  Deering, S., \"\
    Host extensions for IP multicasting\", STD 5,\n           RFC 1112, August 1989.\n\
    \   [1075]  Waitzman, D., Partridge, C., and S. Deering, \"Distance Vector\n \
    \          Multicast Routing Protocol\", RFC 1075, November 1988.\n   [1770] \
    \ Graff, C., \"IPv4 Option for Sender Directed Multi-Destination\n           Delivery\"\
    , RFC 1770, March 1995.\n   [1812]  Baker, F., Ed., \"Requirements for IP Version\
    \ 4 Routers\", RFC\n           1812, June 1995.\n   [2003]  Perkins, C., \"IP\
    \ Encapsulation within IP\", RFC 2003, October\n           1996.\n   [2201]  Ballardie,\
    \ A., \"Core Based Trees (CBT) Multicast Routing\n           Architecture\", RFC\
    \ 2201, September 1997.\n   [2460]  Deering, S. and R. Hinden, \"Internet Protocol,\
    \ Version 6\n           (IPv6) Specification\", RFC 2460, December 1998.\n   [2902]\
    \  Deering, S., Hares, S., Perkins, C., and R. Perlman,\n           \"Overview\
    \ of the 1998 IAB Routing Workshop\", RFC 2902, August\n           2000.\n   [3261]\
    \  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A.,\n           Peterson,\
    \ J., Sparks, R., Handley, M., and E. Schooler, \"SIP:\n           Session Initiation\
    \ Protocol\", RFC 3261, June 2002.\n   [3376]  Cain, B., Deering, S., Kouvelas,\
    \ I., Fenner, B., and A.\n           Thyagarajan, \"Internet Group Management\
    \ Protocol, Version 3\",\n           RFC 3376, October 2002.\n   [3740]  Hardjono,\
    \ T. and B. Weis, \"The Multicast Group Security\n           Architecture\", RFC\
    \ 3740, March 2004.\n   [4301]  Kent, S. and K. Seo, \"Security Architecture for\
    \ the Internet\n           Protocol\", RFC 4301, December 2005.\n   [4302]  Kent,\
    \ S., \"IP Authentication Header\", RFC 4302, December\n           2005.\n   [4607]\
    \  Holbrook, H. and B. Cain, \"Source-Specific Multicast for IP\",\n         \
    \  RFC 4607, August 2006.\n   [4727]  Fenner, B., \"Experimental Values In IPv4,\
    \ IPv6, ICMPv4,\n           ICMPv6, UDP, and TCP Headers\", RFC 4727, November\
    \ 2006.\n   [AGUI]  L. Aguilar, \"Datagram Routing for Internet Multicasting\"\
    ,\n           SIGCOMM '84, March 1984.\n   [CHER]  David R. Cheriton, Stephen\
    \ E. Deering, \"Host groups: a\n           multicast extension for datagram internetworks\"\
    , Proceedings\n           of the ninth symposium on Data communications, p. 172-179,\n\
    \           September 1985, Whistler Moutain, British Columbia, Canada.\n   [BOIV]\
    \  Boivie, R. and N. Feldman, \"Small Group Multicast\", Work in\n           Progress,\
    \ February 2001.\n   [DEER]  S. Deering, \"Multicast Routing in a datagram internetwork\"\
    ,\n           PhD thesis, December 1991.\n   [DEE2]  S. Deering, D. Estrin, D.\
    \ Farinacci, V. Jacobson, C. Liu, and\n           L.  Wei, \"The Pim Architecture\
    \ for Wide-area Multicast\n           Routing\", ACM Transactions on Networks,\
    \ April 1996.\n   [FARI]  Farinacci, D., et al., \"Multicast Source Discovery\
    \ Protocol\",\n           Work in Progress, June 1998.\n   [H323]  ITU-T Recommendation\
    \ H.323 (2000), Packet-Based Multimedia\n           Communications Systems.\n\
    \   [IMAI]  Imai, Y., \"Multiple Destination option on IPv6 (MDO6)\", Work\n \
    \          in Progress, September 2000,\n   [MBONE] Casner, S., \"Frequently Asked\
    \ Questions (FAQ) on the\n           Multicast Backbone (MBONE)\",\n         \
    \  <ftp://ftp.isi.edu/mbone/faq.txt>.\n   [OOMS]  Ooms, D., Livens, W., and O.\
    \ Paridaens, \"Connectionless\n           Multicast\", Work in Progress, April\
    \ 2000.\n   [PARI]  Paridaens, O., Ooms, D., and B. Sales, \"Security Framework\n\
    \           for Explicit Multicast\", Work in Progress, June 2002.\n   [RMT] \
    \  Reliable Multicast Transport Working Group web site,\n           <http://www.ietf.org/html.charters/rmt-charter.html>,\
    \ June\n           15, 1999.\n   [SOLA]  M. Sola, M. Ohta, T. Maeno, \"Scalability\
    \ of Internet\n           Multicast Protocols\", INET'98,\n           <http://www.isoc.org/inet98/proceedings/6d/6d_3.htm>.\n"
- title: 17.  Contributors
  contents:
  - "17.  Contributors\n   Olivier Paridaens\n   Alcatel Network Strategy Group\n\
    \   Fr. Wellesplein 1, 2018\n   Antwerpen, Belgium\n   Phone: 32 3 2409320\n \
    \  EMail: Olivier.Paridaens@alcatel.be\n   Eiichi Muramoto\n   Matsushita Electric\
    \ Industrial Co., Ltd.\n   4-12-4 Higashi-shinagawa, Shinagawa-ku\n   Tokyo 140-8587,\
    \ Japan\n   Phone: +81-3-6710-2031\n   EMail: muramoto@xcast.jp\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Rick Boivie\n   IBM T. J. Watson Research Center\n   19\
    \ Skyline Drive\n   Hawthorne, NY 10532\n   Phone: 914-784-3251\n   EMail: rhboivie@us.ibm.com\n\
    \   Nancy Feldman\n   IBM T. J. Watson Research Center\n   19 Skyline Drive\n\
    \   Hawthorne, NY 10532\n   EMail: nkfeldman@yahoo.com\n   Yuji Imai\n   Fujitsu\
    \ Laboratories Ltd.\n   1-1, Kamikodanaka 4-Chome, Nakahara-ku\n   Kawasaki 211-8588,\
    \ Japan\n   Phone: +81-44-754-2628\n   Fax  : +81-44-754-2793\n   EMail: ug@xcast.jp\n\
    \   Wim Livens\n   ESCAUX\n   Krijtstraat 17, 2600\n   Berchem, Belgium\n   EMail:\
    \ wim@livens.net\n   Dirk Ooms\n   OneSparrow\n   Belegstraat 13; 2018\n   Antwerp,\
    \ Belgium\n   EMail: dirk@onesparrow.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78\
    \ and at www.rfc-editor.org/copyright.html, and\n   except as set forth therein,\
    \ the authors retain all their rights.\n   This document and the information contained\
    \ herein are provided on an\n   \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION\
    \ HE/SHE REPRESENTS\n   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE\
    \ IETF TRUST AND\n   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,\
    \ EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE\
    \ OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n\
    \   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
