- title: __initial_text__
  contents:
  - "      State Machines for Extensible Authentication Protocol (EAP)\n         \
    \                Peer and Authenticator\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a set of state machines for Extensible\n\
    \   Authentication Protocol (EAP) peer, EAP stand-alone authenticator\n   (non-pass-through),\
    \ EAP backend authenticator (for use on\n   Authentication, Authorization, and\
    \ Accounting (AAA) servers), and EAP\n   full authenticator (for both local and\
    \ pass-through).  This set of\n   state machines shows how EAP can be implemented\
    \ to support deployment\n   in either a peer/authenticator or peer/authenticator/AAA\
    \ Server\n   environment.  The peer and stand-alone authenticator machines are\n\
    \   illustrative of how the EAP protocol defined in RFC 3748 may be\n   implemented.\
    \  The backend and full/pass-through authenticators\n   illustrate how EAP/AAA\
    \ protocol support defined in RFC 3579 may be\n   implemented.  Where there are\
    \ differences, RFC 3748 and RFC 3579 are\n   authoritative.\n   The state machines\
    \ are based on the EAP \"Switch\" model.  This model\n   includes events and actions\
    \ for the interaction between the EAP\n   Switch and EAP methods.  A brief description\
    \ of the EAP \"Switch\"\n   model is given in the Introduction section.\n   The\
    \ state machine and associated model are informative only.\n   Implementations\
    \ may achieve the same results using different methods.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction: The EAP Switch Model ..............................3\n\
    \   2. Specification of Requirements ...................................4\n  \
    \ 3. Notational Conventions Used in State Diagrams ...................5\n    \
    \  3.1. Notational Specifics .......................................5\n      3.2.\
    \ State Machine Symbols ......................................7\n      3.3. Document\
    \ Authority .........................................8\n   4. Peer State Machine\
    \ ..............................................9\n      4.1. Interface between\
    \ Peer State Machine and Lower Layer .......9\n      4.2. Interface between Peer\
    \ State Machine and Methods ..........11\n      4.3. Peer State Machine Local\
    \ Variables ........................13\n      4.4. Peer State Machine Procedures\
    \ .............................14\n      4.5. Peer State Machine States .................................15\n\
    \   5. Stand-Alone Authenticator State Machine ........................17\n  \
    \    5.1. Interface between Stand-Alone Authenticator State\n           Machine\
    \ and Lower Layer ...................................17\n      5.2. Interface\
    \ between Stand-Alone Authenticator State\n           Machine and Methods .......................................19\n\
    \      5.3. Stand-Alone Authenticator State Machine Local Variables ...21\n  \
    \    5.4. EAP Stand-Alone Authenticator Procedures ..................22\n    \
    \  5.5. EAP Stand-Alone Authenticator States ......................24\n   6. EAP\
    \ Backend Authenticator ......................................26\n      6.1. Interface\
    \ between Backend Authenticator State\n           Machine and Lower Layer ...................................26\n\
    \      6.2. Interface between Backend Authenticator State\n           Machine\
    \ and Methods .......................................28\n      6.3. Backend Authenticator\
    \ State Machine Local Variables .......28\n      6.4. EAP Backend Authenticator\
    \ Procedures ......................28\n      6.5. EAP Backend Authenticator States\
    \ ..........................29\n   7. EAP Full Authenticator .........................................29\n\
    \      7.1. Interface between Full Authenticator State Machine\n           and\
    \ Lower Layer ...........................................30\n      7.2. Interface\
    \ between Full Authenticator State Machine\n           and Methods ...............................................31\n\
    \      7.3. Full Authenticator State Machine Local Variables ..........32\n  \
    \    7.4. EAP Full Authenticator Procedures .........................32\n    \
    \  7.5. EAP Full Authenticator States .............................32\n   8. Implementation\
    \ Considerations ..................................34\n      8.1. Robustness ................................................34\n\
    \      8.2. Method/Method and Method/Lower-Layer Interfaces ...........35\n  \
    \    8.3. Peer State Machine Interoperability with Deployed\n           Implementations\
    \ ...........................................35\n   9. Security Considerations\
    \ ........................................35\n   10. Acknowledgements ..............................................36\n\
    \   11. References ....................................................37\n  \
    \     11.1. Normative References ....................................37\n    \
    \   11.2. Informative References ..................................37\n   Appendix.\
    \ ASCII Versions of State Diagrams ........................38\n       A.1.  EAP\
    \ Peer State Machine (Figure 3) .......................38\n       A.2.  EAP Stand-Alone\
    \ Authenticator State Machine (Figure 4) ..41\n       A.3.  EAP Backend Authenticator\
    \ State Machine (Figure 5) ......44\n       A.4.  EAP Full Authenticator State\
    \ Machine (Figures 6 and 7) ..47\n"
- title: '1.  Introduction: The EAP Switch Model'
  contents:
  - "1.  Introduction: The EAP Switch Model\n   This document offers a proposed state\
    \ machine for RFCs [RFC3748] and\n   [RFC3579].  There are state machines for\
    \ the peer, the stand-alone\n   authenticator, a backend authenticator, and a\
    \ full/pass-through\n   authenticator.  Accompanying each state machine diagram\
    \ is a\n   description of the variables, the functions, and the states in the\n\
    \   diagram.  Whenever possible, the same notation has been used in each\n   of\
    \ the state machines.\n   An EAP authentication consists of one or more EAP methods\
    \ in sequence\n   followed by an EAP Success or EAP Failure sent from the authenticator\n\
    \   to the peer.  The EAP switches control negotiation of EAP methods and\n  \
    \ sequences of methods.\n      Peer             Peer  |  Authenticator       Auth\n\
    \      Method                 |                      Method\n              \\\
    \              |                    /\n               \\             |       \
    \            /\n                Peer         |             Auth\n            \
    \    EAP    <-----|---------->  EAP\n                Switch       |          \
    \   Switch\n                    Figure 1: EAP Switch Model\n   At both the peer\
    \ and authenticator, one or more EAP methods exist.\n   The EAP switches select\
    \ which methods each is willing to use, and\n   negotiate between themselves to\
    \ pick a method or sequence of methods.\n   Note that the methods may also have\
    \ state machines.  The details of\n   these are outside the scope of this paper.\n\
    \          Peer  |  Authenticator              | Backend\n                |  \
    \            /   Local      |\n                |             /    Method     |\n\
    \          Peer  |        Auth                 |        Backend\n          EAP\
    \  -|----->  EAP                  |    -->  EAP\n         Switch |       Switch\
    \                |   /    Server\n                |             \\           \
    \    |  /\n                |              \\ pass-through |\n                |\
    \                             |\n               Figure 2: EAP Pass-Through Model\n\
    \   The Full/Pass-Through state machine allows an NAS or edge device to\n   pass\
    \ EAP Response messages to a backend server where the\n   authentication method\
    \ resides.  This paper includes a state machine\n   for the EAP authenticator\
    \ that supports both local and pass-through\n   methods as well as a state machine\
    \ for the backend authenticator\n   existing at the AAA server.  A simple stand-alone\
    \ authenticator is\n   also provided to show a basic, non-pass-through authenticator's\n\
    \   behavior.\n   This document describes a set of state machines that can manage\
    \ EAP\n   authentication from the peer to an EAP method on the authenticator or\n\
    \   from the peer through the authenticator pass-through method to the\n   EAP\
    \ method on the backend EAP server.\n   Some environments where EAP is used, such\
    \ as PPP, may support peer-\n   to-peer operation.  That is, both parties act\
    \ as peers and\n   authenticators at the same time, in two simultaneous and independent\n\
    \   EAP conversations.  In this case, the implementation at each node has\n  \
    \ to perform demultiplexing of incoming EAP packets.  EAP packets with\n   code\
    \ set to Response are delivered to the authenticator state\n   machine, and EAP\
    \ packets with code set to Request, Success, or\n   Failure are delivered to the\
    \ peer state machine.\n   The state diagrams presented in this document have been\
    \ coordinated\n   with the diagrams in [1X-2004].  The format of the diagrams\
    \ is\n   adapted from the format therein.  The interface between the state\n \
    \  machines defined here and the IEEE 802.1X-2004 state machines is also\n   explained\
    \ in Appendix F of [1X-2004].\n"
- title: 2.  Specification of Requirements
  contents:
  - "2.  Specification of Requirements\n   In this document, several words are used\
    \ to signify the requirements\n   of the specification.  These words are often\
    \ capitalized.  The key\n   words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\", \"SHOULD\",\n   \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" are to be\n   interpreted as described in [RFC2119].\n"
- title: 3.  Notational Conventions Used in State Diagrams
  contents:
  - '3.  Notational Conventions Used in State Diagrams

    '
- title: 3.1.  Notational Specifics
  contents:
  - "3.1.  Notational Specifics\n   The following state diagrams have been completed\
    \ based on the\n   conventions specified in [1X-2004], section 8.2.1.  The complete\
    \ text\n   is reproduced here:\n      State diagrams are used to represent the\
    \ operation of the protocol\n      by a number of cooperating state machines,\
    \ each comprising a group\n      of connected, mutually exclusive states.  Only\
    \ one state of each\n      machine can be active at any given time.\n      Each\
    \ state is represented in the state diagram as a rectangular\n      box, divided\
    \ into two parts by a horizontal line.  The upper part\n      contains the state\
    \ identifier, written in uppercase letters.  The\n      lower part contains any\
    \ procedures that are executed upon entry to\n      the state.\n      All permissible\
    \ transitions between states are represented by\n      arrows, the arrowhead denoting\
    \ the direction of the possible\n      transition.  Labels attached to arrows\
    \ denote the condition(s)\n      that must be met in order for the transition\
    \ to take place.  All\n      conditions are expressions that evaluate to TRUE\
    \ or FALSE; if a\n      condition evaluates to TRUE, then the condition is met.\
    \  The label\n      UCT denotes an unconditional transition (i.e., UCT always\n\
    \      evaluates to TRUE).  A transition that is global in nature (i.e.,\n   \
    \   a transition that occurs from any of the possible states if the\n      condition\
    \ attached to the arrow is met) is denoted by an open\n      arrow; i.e., no specific\
    \ state is identified as the origin of the\n      transition.  When the condition\
    \ associated with a global\n      transition is met, it supersedes all other exit\
    \ conditions\n      including UCT.  The special global condition BEGIN supersedes\
    \ all\n      other global conditions, and once asserted it remains asserted\n\
    \      until all state blocks have executed to the point that variable\n     \
    \ assignments and other consequences of their execution remain\n      unchanged.\n\
    \      On entry to a state, the procedures defined for the state (if any)\n  \
    \    are executed exactly once, in the order that they appear on the\n      page.\
    \  Each action is deemed to be atomic; i.e., execution of a\n      procedure completes\
    \ before the next sequential procedure starts to\n      execute.  No procedures\
    \ execute outside a state block.  The\n      procedures in only one state block\
    \ execute at a time, even if the\n      conditions for execution of state blocks\
    \ in different state\n      machines are satisfied, and all procedures in an executing\
    \ state\n      block complete execution before the transition to and execution\
    \ of\n      any other state block occurs.  That is, the execution of any state\n\
    \      block appears to be atomic with respect to the execution of any\n     \
    \ other state block, and the transition condition to that state from\n      the\
    \ previous state is TRUE when execution commences.  The order of\n      execution\
    \ of state blocks in different state machines is undefined\n      except as constrained\
    \ by their transition conditions.  A variable\n      that is set to a particular\
    \ value in a state block retains this\n      value until a subsequent state block\
    \ executes a procedure that\n      modifies the value.\n      On completion of\
    \ all the procedures within a state, all exit\n      conditions for the state\
    \ (including all conditions associated with\n      global transitions) are evaluated\
    \ continuously until one of the\n      conditions is met.  The label ELSE denotes\
    \ a transition that\n      occurs if none of the other conditions for transitions\
    \ from the\n      state are met (i.e., ELSE evaluates to TRUE if all other possible\n\
    \      exit conditions from the state evaluate to FALSE).  Where two or\n    \
    \  more exit conditions with the same level of precedence become TRUE\n      simultaneously,\
    \ the choice as to which exit condition causes the\n      state transition to\
    \ take place is arbitrary.\n      Where it is necessary to split a state machine\
    \ description across\n      more than one diagram, a transition between two states\
    \ that appear\n      on different diagrams is represented by an exit arrow drawn\
    \ with\n      dashed lines, plus a reference to the diagram that contains the\n\
    \      destination state.  Similarly, dashed arrows and a dashed state\n     \
    \ box are used on the destination diagram to show the transition to\n      the\
    \ destination state.  In a state machine that has been split in\n      this way,\
    \ any global transitions that can cause entry to states\n      defined in one\
    \ of the diagrams are deemed potential exit\n      conditions for all the states\
    \ of the state machine, regardless of\n      which diagram the state boxes appear\
    \ in.\n      Should a conflict exist between the interpretation of a state\n \
    \     diagram and either the corresponding global transition tables or\n     \
    \ the textual description associated with the state machine, the\n      state\
    \ diagram takes precedence.  The interpretation of the special\n      symbols\
    \ and operators used in the state diagrams is as defined in\n      Section 3.2;\
    \ these symbols and operators are derived from the\n      notation of the C++\
    \ programming language, ISO/IEC 14882.  If a\n      boolean variable is described\
    \ in this clause as being set, it has\n      or is assigned the value TRUE; if\
    \ it is described as being reset\n      or clear, it has the value FALSE.\n  \
    \ In addition to the above notation, there are a couple of\n   clarifications\
    \ specific to this document.  First, all boolean\n   variables are initialized\
    \ to FALSE before the state machine execution\n   begins.  Second, the following\
    \ notational shorthand is specific to\n   this document:\n   <variable> = <expression1>\
    \ | <expression2> | ...\n      Execution of a statement of this form will result\
    \ in <variable>\n      having a value of exactly one of the expressions.  The\
    \ logic for\n      which of those expressions gets executed is outside of the\
    \ state\n      machine and could be environmental, configurable, or based on\n\
    \      another state machine, such as that of the method.\n"
- title: 3.2.  State Machine Symbols
  contents:
  - "3.2.  State Machine Symbols\n   ( )\n      Used to force the precedence of operators\
    \ in Boolean expressions\n      and to delimit the argument(s) of actions within\
    \ state boxes.\n   ;\n      Used as a terminating delimiter for actions within\
    \ state boxes.\n      If a state box contains multiple actions, the order of execution\n\
    \      follows the normal English language conventions for reading text.\n   =\n\
    \      Assignment action.  The value of the expression to the right of\n     \
    \ the operator is assigned to the variable to the left of the\n      operator.\
    \  If this operator is used to define multiple assignments\n      (e.g., a = b\
    \ = X), the action causes the value of the expression\n      following the right-most\
    \ assignment operator to be assigned to all\n      the variables that appear to\
    \ the left of the right-most assignment\n      operator.\n   !\n      Logical\
    \ NOT operator.\n   &&\n      Logical AND operator.\n   ||\n      Logical OR operator.\n\
    \   if...then...\n      Conditional action.  If the Boolean expression following\
    \ the \"if\"\n      evaluates to TRUE, then the action following the \"then\"\
    \ is\n      executed.\n   { statement 1, ... statement N }\n      Compound statement.\
    \  Braces are used to group statements that are\n      executed together as if\
    \ they were a single statement.\n   !=\n      Inequality.  Evaluates to TRUE if\
    \ the expression to the left of\n      the operator is not equal in value to the\
    \ expression to the right.\n   ==\n      Equality.  Evaluates to TRUE if the expression\
    \ to the left of the\n      operator is equal in value to the expression to the\
    \ right.\n   >\n      Greater than.  Evaluates to TRUE if the value of the expression\
    \ to\n      the left of the operator is greater than the value of the\n      expression\
    \ to the right.\n   <=\n      Less than or equal to.  Evaluates to TRUE if the\
    \ value of the\n      expression to the left of the operator is either less than\
    \ or\n      equal to the value of the expression to the right.\n   ++\n      Increment\
    \ the preceding integer operator by 1.\n   +\n      Arithmetic addition operator.\n\
    \   &\n      Bitwise AND operator.\n"
- title: 3.3.  Document Authority
  contents:
  - "3.3.  Document Authority\n   Should a conflict exist between the interpretation\
    \ of a state diagram\n   and either the corresponding global transition tables\
    \ or the textual\n   description associated with the state machine, the state\
    \ diagram\n   takes precedence.  When a discrepancy occurs between any part of\
    \ this\n   document (text or diagram) and any of the related documents\n   ([RFC3748],\
    \ [RFC3579], etc.), the latter (the other document) is\n   considered authoritative\
    \ and takes precedence.\n"
- title: 4.  Peer State Machine
  contents:
  - "4.  Peer State Machine\n   The following is a diagram of the EAP peer state machine.\
    \  Also\n   included is an explanation of the primitives and procedures\n   referenced\
    \ in the diagram, as well as a clarification of notation.\n               (see\
    \ the .pdf version for missing diagram or\n            refer to Appendix A.1 if\
    \ reading the .txt version)\n                     Figure 3: EAP Peer State Machine\n"
- title: 4.1.  Interface between Peer State Machine and Lower Layer
  contents:
  - "4.1.  Interface between Peer State Machine and Lower Layer\n   The lower layer\
    \ presents messages to the EAP peer state machine by\n   storing the packet in\
    \ eapReqData and setting the eapReq signal to\n   TRUE.  Note that despite the\
    \ name of the signal, the lower layer does\n   not actually inspect the contents\
    \ of the EAP packet (it could be a\n   Success or Failure message instead of a\
    \ Request).\n   When the EAP peer state machine has finished processing the message,\n\
    \   it sets either eapResp or eapNoResp.  If it sets eapResp, the\n   corresponding\
    \ response packet is stored in eapRespData.  The lower\n   layer is responsible\
    \ for actually transmitting this message.  When\n   the EAP peer state machine\
    \ authentication is complete, it will set\n   eapSuccess or eapFailure to indicate\
    \ to the lower layer that the\n   authentication has succeeded or failed.\n"
- title: 4.1.1.  Variables (Lower Layer to Peer)
  contents:
  - "4.1.1.  Variables (Lower Layer to Peer)\n   eapReq (boolean)\n      Set to TRUE\
    \ in lower layer, FALSE in peer state machine.\n      Indicates that a request\
    \ is available in the lower layer.\n   eapReqData (EAP packet)\n      Set in lower\
    \ layer when eapReq is set to TRUE.  The contents of\n      the available request.\n\
    \   portEnabled (boolean)\n      Indicates that the EAP peer state machine should\
    \ be ready for\n      communication.  This is set to TRUE when the EAP conversation\
    \ is\n      started by the lower layer.  If at any point the communication\n \
    \     port or session is not available, portEnabled is set to FALSE, and\n   \
    \   the state machine transitions to DISABLED.  To avoid unnecessary\n      resets,\
    \ the lower layer may dampen link down indications when it\n      believes that\
    \ the link is only temporarily down and that it will\n      soon be back up (see\
    \ [RFC3748], Section 7.12).  In this case,\n      portEnabled may not always be\
    \ equal to the \"link up\" flag of the\n      lower layer.\n   idleWhile (integer)\n\
    \      Outside timer used to indicate how much time remains before the\n     \
    \ peer will time out while waiting for a valid request.\n   eapRestart (boolean)\n\
    \      Indicates that the lower layer would like to restart\n      authentication.\n\
    \   altAccept (boolean)\n      Alternate indication of success, as described in\
    \ [RFC3748].\n   altReject (boolean)\n      Alternate indication of failure, as\
    \ described in [RFC3748].\n"
- title: 4.1.2.  Variables (peer to lower layer)
  contents:
  - "4.1.2.  Variables (peer to lower layer)\n   eapResp (boolean)\n      Set to TRUE\
    \ in peer state machine, FALSE in lower layer.\n      Indicates that a response\
    \ is to be sent.\n   eapNoResp (boolean)\n      Set to TRUE in peer state machine,\
    \ FALSE in lower layer.\n      Indicates that the request has been processed,\
    \ but that there is\n      no response to send.\n   eapSuccess (boolean)\n   \
    \   Set to TRUE in peer state machine, FALSE in lower layer.\n      Indicates\
    \ that the peer has reached the SUCCESS state.\n   eapFail (boolean)\n      Set\
    \ to TRUE in peer state machine, FALSE in lower layer.\n      Indicates that the\
    \ peer has reached the FAILURE state.\n   eapRespData (EAP packet)\n      Set\
    \ in peer state machine when eapResp is set to TRUE.  The EAP\n      packet that\
    \ is the response to send.\n   eapKeyData (EAP key)\n      Set in peer state machine\
    \ when keying material becomes available.\n      Set during the METHOD state.\
    \  Note that this document does not\n      define the structure of the type \"\
    EAP key\".  We expect that it\n      will be defined in [Keying].\n   eapKeyAvailable\
    \ (boolean)\n      Set to TRUE in the SUCCESS state if keying material is available.\n\
    \      The actual key is stored in eapKeyData.\n"
- title: 4.1.3.  Constants
  contents:
  - "4.1.3.  Constants\n   ClientTimeout (integer)\n      Configurable amount of time\
    \ to wait for a valid request before\n      aborting, initialized by implementation-specific\
    \ means (e.g., a\n      configuration setting).\n"
- title: 4.2.  Interface between Peer State Machine and Methods
  contents:
  - "4.2.  Interface between Peer State Machine and Methods\n   IN: eapReqData (includes\
    \ reqId)\n   OUT: ignore, eapRespData, allowNotifications, decision\n   IN/OUT:\
    \ methodState, (method-specific state)\n   The following describes the interaction\
    \ between the state machine and\n   EAP methods.\n   If methodState==INIT, the\
    \ method starts by initializing its own\n   method-specific state.\n   Next, the\
    \ method must decide whether to process the packet or to\n   discard it silently.\
    \  If the packet appears to have been sent by\n   someone other than the legitimate\
    \ authenticator (for instance, if\n   message integrity check fails) and the method\
    \ is capable of treating\n   such situations as non-fatal, the method can set\
    \ ignore=TRUE.  In\n   this case, the method should not modify any other variables.\n\
    \   If the method decides to process the packet, it behaves as follows.\n   o\
    \  It updates its own method-specific state.\n   o  If the method has derived\
    \ keying material it wants to export, it\n      stores the keying material to\
    \ eapKeyData.\n   o  It creates a response packet (with the same identifier as\
    \ the\n      request) and stores it to eapRespData.\n   o  It sets ignore=FALSE.\n\
    \   Next, the method must update methodState and decision according to\n   the\
    \ following rules.\n   methodState=CONT: The method always continues at this point\
    \ (and the\n      peer wants to continue it).  The decision variable is always\
    \ set\n      to FAIL.\n   methodState=MAY_CONT: At this point, the authenticator\
    \ can decide\n      either to continue the method or to end the conversation.\
    \  The\n      decision variable tells us what to do if the conversation ends.\n\
    \      If the current situation does not satisfy the peer's security\n      policy\
    \ (that is, if the authenticator now decides to allow access,\n      the peer\
    \ will not use it), set decision=FAIL.  Otherwise, set\n      decision=COND_SUCC.\n\
    \   methodState=DONE: The method never continues at this point (or the\n     \
    \ peer sees no point in continuing it).\n      If either (a) the authenticator\
    \ has informed us that it will not\n      allow access, or (b) we're not willing\
    \ to talk to this\n      authenticator (e.g., our security policy is not satisfied),\
    \ set\n      decision=FAIL.  (Note that this state can occur even if the method\n\
    \      still has additional messages left, if continuing it cannot change\n  \
    \    the peer's decision to success).\n      If both (a) the server has informed\
    \ us that it will allow access,\n      and the next packet will be EAP Success,\
    \ and (b) we're willing to\n      use this access, set decision=UNCOND_SUCC.\n\
    \      Otherwise, we do not know what the server's decision is, but are\n    \
    \  willing to use the access if the server allows.  In this case, set\n      decision=COND_SUCC.\n\
    \   Finally, the method must set the allowNotifications variable.  If the\n  \
    \ new methodState is either CONT or MAY_CONT, and if the method\n   specification\
    \ does not forbid the use of Notification messages, set\n   allowNotifications=TRUE.\
    \  Otherwise, set allowNotifications=FALSE.\n"
- title: 4.3.  Peer State Machine Local Variables
  contents:
  - '4.3.  Peer State Machine Local Variables

    '
- title: 4.3.1.  Long-Term (Maintained between Packets)
  contents:
  - "4.3.1.  Long-Term (Maintained between Packets)\n   selectMethod (EAP type)\n\
    \      Set in GET_METHOD state.  The method that the peer believes is\n      currently\
    \ \"in progress\"\n   methodState (enumeration)\n      As described above.\n \
    \  lastId (integer)\n      0-255 or NONE.  Set in SEND_RESPONSE state.  The EAP\
    \ identifier\n      value of the last request.\n   lastRespData (EAP packet)\n\
    \      Set in SEND_RESPONSE state.  The EAP packet last sent from the\n      peer.\n\
    \   decision (enumeration)\n      As described above.\n   NOTE: EAP type can be\
    \ normal type (0..253,255), or an extended type\n   consisting of type 254, Vendor-Id,\
    \ and Vendor-Type.\n"
- title: 4.3.2.  Short-Term (Not Maintained between Packets)
  contents:
  - "4.3.2.  Short-Term (Not Maintained between Packets)\n   rxReq (boolean)\n   \
    \   Set in RECEIVED state.  Indicates that the current received packet\n     \
    \ is an EAP request.\n   rxSuccess (boolean)\n      Set in RECEIVED state.  Indicates\
    \ that the current received packet\n      is an EAP Success.\n   rxFailure (boolean)\n\
    \      Set in RECEIVED state.  Indicates that the current received packet\n  \
    \    is an EAP Failure.\n   reqId (integer)\n      Set in RECEIVED state.  The\
    \ identifier value associated with the\n      current EAP request.\n   reqMethod\
    \ (EAP type)\n      Set in RECEIVED state.  The method type of the current EAP\n\
    \      request.\n   ignore (boolean)\n      Set in METHOD state.  Indicates whether\
    \ the method has decided to\n      drop the current packet.\n"
- title: 4.4.  Peer State Machine Procedures
  contents:
  - "4.4.  Peer State Machine Procedures\n   NOTE: For method procedures, the method\
    \ uses its internal state in\n   addition to the information provided by the EAP\
    \ layer.  The only\n   arguments that are explicitly shown as inputs to the procedures\
    \ are\n   those provided to the method by EAP.  Those inputs provided by the\n\
    \   method's internal state remain implicit.\n   parseEapReq()\n      Determine\
    \ the code, identifier value, and type of the current\n      request.  In the\
    \ case of a parsing error (e.g., the length field\n      is longer than the received\
    \ packet), rxReq, rxSuccess, and\n      rxFailure will all be set to FALSE.  The\
    \ values of reqId and\n      reqMethod may be undefined as a result.  Returns\
    \ three booleans,\n      one integer, and one EAP type.\n   processNotify()\n\
    \      Process the contents of Notification Request (for instance,\n      display\
    \ it to the user or log it).  The return value is undefined.\n   buildNotify()\n\
    \      Create the appropriate notification response.  Returns an EAP\n      packet.\n\
    \   processIdentity()\n      Process the contents of Identity Request.  Return\
    \ value is\n      undefined.\n   buildIdentity()\n      Create the appropriate\
    \ identity response.  Returns an EAP packet.\n   m.check()\n      Method-specific\
    \ procedure to test for the validity of a message.\n      Returns a boolean.\n\
    \   m.process()\n      Method procedure to parse and process a request for that\
    \ method.\n      Returns a methodState enumeration, a decision enumeration, and\
    \ a\n      boolean.\n   m.buildResp()\n      Method procedure to create a response\
    \ message.  Returns an EAP\n      packet.\n   m.getKey()\n      Method procedure\
    \ to obtain key material for use by EAP or lower\n      layers.  Returns an EAP\
    \ key.\n"
- title: 4.5.  Peer State Machine States
  contents:
  - "4.5.  Peer State Machine States\n   DISABLED\n      This state is reached whenever\
    \ service from the lower layer is\n      interrupted or unavailable.  Immediate\
    \ transition to INITIALIZE\n      occurs when the port becomes enabled.\n   INITIALIZE\n\
    \      Initializes variables when the state machine is activated.\n   IDLE\n \
    \     The state machine spends most of its time here, waiting for\n      something\
    \ to happen.\n   RECEIVED\n      This state is entered when an EAP packet is received.\
    \  The packet\n      header is parsed here.\n   GET_METHOD\n      This state is\
    \ entered when a request for a new type comes in.\n      Either the correct method\
    \ is started, or a Nak response is built.\n   METHOD\n      The method processing\
    \ happens here.  The request from the\n      authenticator is processed, and an\
    \ appropriate response packet is\n      built.\n   SEND_RESPONSE\n      This state\
    \ signals the lower layer that a response packet is ready\n      to be sent.\n\
    \   DISCARD\n      This state signals the lower layer that the request was discarded,\n\
    \      and no response packet will be sent at this time.\n   IDENTITY\n      Handles\
    \ requests for Identity method and builds a response.\n   NOTIFICATION\n     \
    \ Handles requests for Notification method and builds a response.\n   RETRANSMIT\n\
    \      Retransmits the previous response packet.\n   SUCCESS\n      A final state\
    \ indicating success.\n   FAILURE\n      A final state indicating failure.\n"
- title: 5.  Stand-Alone Authenticator State Machine
  contents:
  - "5.  Stand-Alone Authenticator State Machine\n   The following is a diagram of\
    \ the stand-alone EAP authenticator state\n   machine.  This diagram should be\
    \ used for those interested in a\n   self-contained, or non-pass-through, authenticator.\
    \  Included is an\n   explanation of the primitives and procedures referenced\
    \ in the\n   diagram, as well as a clarification of notation.\n              \
    \ (see the .pdf version for missing diagram or\n            refer to Appendix\
    \ A.2 if reading the .txt version)\n           Figure 4: EAP Stand-Alone Authenticator\
    \ State Machine\n"
- title: 5.1.  Interface between Stand-Alone Authenticator State Machine and
  contents:
  - "5.1.  Interface between Stand-Alone Authenticator State Machine and\n      Lower\
    \ Layer\n   The lower layer presents messages to the EAP authenticator state\n\
    \   machine by storing the packet in eapRespData and setting the eapResp\n   signal\
    \ to TRUE.\n   When the EAP authenticator state machine has finished processing\
    \ the\n   message, it sets one of the signals eapReq, eapNoReq, eapSuccess, and\n\
    \   eapFail.  If it sets eapReq, eapSuccess, or eapFail, the\n   corresponding\
    \ request (or success/failure) packet is stored in\n   eapReqData.  The lower\
    \ layer is responsible for actually transmitting\n   this message.\n"
- title: 5.1.1.  Variables (Lower Layer to Stand-Alone Authenticator)
  contents:
  - "5.1.1.  Variables (Lower Layer to Stand-Alone Authenticator)\n   eapResp (boolean)\n\
    \      Set to TRUE in lower layer, FALSE in authenticator state machine.\n   \
    \   Indicates that an EAP response is available for processing.\n   eapRespData\
    \ (EAP packet)\n      Set in lower layer when eapResp is set to TRUE.  The EAP\
    \ packet to\n      be processed.\n   portEnabled (boolean)\n      Indicates that\
    \ the EAP authenticator state machine should be ready\n      for communication.\
    \  This is set to TRUE when the EAP conversation\n      is started by the lower\
    \ layer.  If at any point the communication\n      port or session is not available,\
    \ portEnabled is set to FALSE, and\n      the state machine transitions to DISABLED.\
    \  To avoid unnecessary\n      resets, the lower layer may dampen link down indications\
    \ when it\n      believes that the link is only temporarily down and that it will\n\
    \      soon be back up (see [RFC3748], Section 7.12).  In this case,\n      portEnabled\
    \ may not always be equal to the \"link up\" flag of the\n      lower layer.\n\
    \   retransWhile (integer)\n      Outside timer used to indicate how long the\
    \ authenticator has\n      waited for a new (valid) response.\n   eapRestart (boolean)\n\
    \      Indicates that the lower layer would like to restart\n      authentication.\n\
    \   eapSRTT (integer)\n      Smoothed round-trip time.  (See [RFC3748], Section\
    \ 4.3.)\n   eapRTTVAR (integer)\n      Round-trip time variation.  (See [RFC3748],\
    \ Section 4.3.)\n"
- title: 5.1.2.  Variables (Stand-Alone Authenticator To Lower Layer)
  contents:
  - "5.1.2.  Variables (Stand-Alone Authenticator To Lower Layer)\n   eapReq (boolean)\n\
    \      Set to TRUE in authenticator state machine, FALSE in lower layer.\n   \
    \   Indicates that a new EAP request is ready to be sent.\n   eapNoReq (boolean)\n\
    \      Set to TRUE in authenticator state machine, FALSE in lower layer.\n   \
    \   Indicates the most recent response has been processed, but there\n      is\
    \ no new request to send.\n   eapSuccess (boolean)\n      Set to TRUE in authenticator\
    \ state machine, FALSE in lower layer.\n      Indicates that the state machine\
    \ has reached the SUCCESS state.\n   eapFail (boolean)\n      Set to TRUE in authenticator\
    \ state machine, FALSE in lower layer.\n      Indicates that the state machine\
    \ has reached the FAILURE state.\n   eapTimeout (boolean)\n      Set to TRUE in\
    \ the TIMEOUT_FAILURE state if the authenticator has\n      reached its maximum\
    \ number of retransmissions without receiving a\n      response.\n   eapReqData\
    \ (EAP packet)\n      Set in authenticator state machine when eapReq, eapSuccess,\
    \ or\n      eapFail is set to TRUE.  The actual EAP request to be sent (or\n \
    \     success/failure).\n   eapKeyData (EAP key)\n      Set in authenticator state\
    \ machine when keying material becomes\n      available.  Set during the METHOD\
    \ state.  Note that this document\n      does not define the structure of the\
    \ type \"EAP key\".  We expect\n      that it will be defined in [Keying].\n \
    \  eapKeyAvailable (boolean)\n      Set to TRUE in the SUCCESS state if keying\
    \ material is available.\n      The actual key is stored in eapKeyData.\n"
- title: 5.1.3.  Constants
  contents:
  - "5.1.3.  Constants\n   MaxRetrans (integer)\n      Configurable maximum for how\
    \ many retransmissions should be\n      attempted before aborting.\n"
- title: 5.2.  Interface between Stand-Alone Authenticator State Machine and
  contents:
  - "5.2.  Interface between Stand-Alone Authenticator State Machine and\n      Methods\n\
    \   IN: eapRespData, methodState\n   OUT: ignore, eapReqData\n   IN/OUT: currentId,\
    \ (method-specific state), (policy)\n   The following describes the interaction\
    \ between the state machine and\n   EAP methods.\n   m.init (in: -, out: -)\n\
    \   When the method is first started, it must initialize its own method-\n   specific\
    \ state, possibly using some information from Policy (e.g.,\n   identity).\n \
    \  m.buildReq (in: integer, out: EAP packet)\n   Next, the method creates a new\
    \ EAP Request packet, with the given\n   identifier value, and updates its method-specific\
    \ state accordingly.\n   m.getTimeout (in: -, out: integer or NONE)\n   The method\
    \ can also provide a hint for retransmission timeout with\n   m.getTimeout.\n\
    \   m.check (in: EAP packet, out: boolean)\n   When a new EAP Response is received,\
    \ the method must first decide\n   whether to process the packet or to discard\
    \ it silently.  If the\n   packet looks like it was not sent by the legitimate\
    \ peer (e.g., if it\n   has an invalid Message Integrity Check (MIC), which should\
    \ never\n   occur), the method can indicate this by returning FALSE.  In this\n\
    \   case, the method should not modify its own method-specific state.\n   m.process\
    \ (in: EAP packet, out: -)\n   m.isDone (in: -, out: boolean)\n   m.getKey (in:\
    \ -, out: EAP key or NONE)\n   Next, the method processes the EAP Response and\
    \ updates its own\n   method-specific state.  Now the options are to continue\
    \ the\n   conversation (send another request) or to end this method.\n   If the\
    \ method wants to end the conversation, it\n   o  Tells Policy about the outcome\
    \ of the method and possibly other\n      information.\n   o  If the method has\
    \ derived keying material it wants to export,\n      returns it from m.getKey().\n\
    \   o  Indicates that the method wants to end by returning TRUE from\n      m.isDone().\n\
    \   Otherwise, the method continues by sending another request, as\n   described\
    \ earlier.\n"
- title: 5.3.  Stand-Alone Authenticator State Machine Local Variables
  contents:
  - '5.3.  Stand-Alone Authenticator State Machine Local Variables

    '
- title: 5.3.1.  Long-Term (Maintained between Packets)
  contents:
  - "5.3.1.  Long-Term (Maintained between Packets)\n   currentMethod (EAP type)\n\
    \      EAP type, IDENTITY, or NOTIFICATION.\n   currentId (integer)\n      0-255\
    \ or NONE.  Usually updated in PROPOSE_METHOD state.\n      Indicates the identifier\
    \ value of the currently outstanding EAP\n      request.\n   methodState (enumeration)\n\
    \      As described above.\n   retransCount (integer)\n      Reset in SEND_REQUEST\
    \ state and updated in RETRANSMIT state.\n      Current number of retransmissions.\n\
    \   lastReqData (EAP packet)\n      Set in SEND_REQUEST state.  EAP packet containing\
    \ the last sent\n      request.\n   methodTimeout (integer)\n      Method-provided\
    \ hint for suitable retransmission timeout, or NONE.\n"
- title: 5.3.2.  Short-Term (Not Maintained between Packets)
  contents:
  - "5.3.2.  Short-Term (Not Maintained between Packets)\n   rxResp (boolean)\n  \
    \    Set in RECEIVED state.  Indicates that the current received packet\n    \
    \  is an EAP response.\n   respId (integer)\n      Set in RECEIVED state.  The\
    \ identifier from the current EAP\n      response.\n   respMethod (EAP type)\n\
    \      Set in RECEIVED state.  The method type of the current EAP\n      response.\n\
    \   ignore (boolean)\n      Set in METHOD state.  Indicates whether the method\
    \ has decided to\n      drop the current packet.\n   decision (enumeration)\n\
    \      Set in SELECT_ACTION state.  Temporarily stores the policy\n      decision\
    \ to succeed, fail, or continue.\n"
- title: 5.4.  EAP Stand-Alone Authenticator Procedures
  contents:
  - "5.4.  EAP Stand-Alone Authenticator Procedures\n   NOTE: For method procedures,\
    \ the method uses its internal state in\n   addition to the information provided\
    \ by the EAP layer.  The only\n   arguments that are explicitly shown as inputs\
    \ to the procedures are\n   those provided to the method by EAP.  Those inputs\
    \ provided by the\n   method's internal state remain implicit.\n   calculateTimeout()\n\
    \      Calculates the retransmission timeout, taking into account the\n      retransmission\
    \ count, round-trip time measurements, and method-\n      specific timeout hint\
    \ (see [RFC3748], Section 4.3).  Returns an\n      integer.\n   parseEapResp()\n\
    \      Determines the code, identifier value, and type of the current\n      response.\
    \  In the case of a parsing error (e.g., the length field\n      is longer than\
    \ the received packet), rxResp will be set to FALSE.\n      The values of respId\
    \ and respMethod may be undefined as a result.\n      Returns a boolean, an integer,\
    \ and an EAP type.\n   buildSuccess()\n      Creates an EAP Success Packet.  Returns\
    \ an EAP packet.\n   buildFailure()\n      Creates an EAP Failure Packet.  Returns\
    \ an EAP packet.\n   nextId()\n      Determines the next identifier value to use,\
    \ based on the previous\n      one.  Returns an integer.\n   Policy.update()\n\
    \      Updates all variables related to internal policy state.  The\n      return\
    \ value is undefined.\n   Policy.getNextMethod()\n      Determines the method\
    \ that should be used at this point in the\n      conversation based on predefined\
    \ policy.  Policy.getNextMethod()\n      MUST comply with [RFC3748] (Section 2.1),\
    \ which forbids the use of\n      sequences of authentication methods within an\
    \ EAP conversation.\n      Thus, if an authentication method has already been\
    \ executed within\n      an EAP dialog, Policy.getNextMethod() MUST NOT propose\
    \ another\n      authentication method within the same EAP dialog.  Returns an\
    \ EAP\n      type.\n   Policy.getDecision()\n      Determines if the policy will\
    \ allow SUCCESS, FAIL, or is yet to\n      determine (CONTINUE).  Returns a decision\
    \ enumeration.\n   m.check()\n      Method-specific procedure to test for the\
    \ validity of a message.\n      Returns a boolean.\n   m.process()\n      Method\
    \ procedure to parse and process a response for that method.\n      The return\
    \ value is undefined.\n   m.init()\n      Method procedure to initialize state\
    \ just before use.  The return\n      value is undefined.\n   m.reset()\n    \
    \  Method procedure to indicate that the method is ending in the\n      middle\
    \ of or before completion.  The return value is undefined.\n   m.isDone()\n  \
    \    Method procedure to check for method completion.  Returns a\n      boolean.\n\
    \   m.getTimeout()\n      Method procedure to determine an appropriate timeout\
    \ hint for that\n      method.  Returns an integer.\n   m.getKey()\n      Method\
    \ procedure to obtain key material for use by EAP or lower\n      layers.  Returns\
    \ an EAP key.\n   m.buildReq()\n      Method procedure to produce the next request.\
    \  Returns an EAP\n      packet.\n"
- title: 5.5.  EAP Stand-Alone Authenticator States
  contents:
  - "5.5.  EAP Stand-Alone Authenticator States\n   DISABLED\n      The authenticator\
    \ is disabled until the port is enabled by the\n      lower layer.\n   INITIALIZE\n\
    \      Initializes variables when the state machine is activated.\n   IDLE\n \
    \     The state machine spends most of its time here, waiting for\n      something\
    \ to happen.\n   RECEIVED\n      This state is entered when an EAP packet is received.\
    \  The packet\n      header is parsed here.\n   INTEGRITY_CHECK\n      A method\
    \ state in which the integrity of the incoming packet from\n      the peer is\
    \ verified by the method.\n   METHOD_RESPONSE\n      A method state in which the\
    \ incoming packet is processed.\n   METHOD_REQUEST\n      A method state in which\
    \ a new request is formulated if necessary.\n   PROPOSE_METHOD\n      A state\
    \ in which the authenticator decides which method to try\n      next in the authentication.\n\
    \   SELECT_ACTION\n      Between methods, the state machine re-evaluates whether\
    \ its policy\n      is satisfied and succeeds, fails, or remains undecided.\n\
    \   SEND_REQUEST\n      This state signals the lower layer that a request packet\
    \ is ready\n      to be sent.\n   DISCARD\n      This state signals the lower\
    \ layer that the response was\n      discarded, and no new request packet will\
    \ be sent at this time.\n   NAK\n      This state processes Nak responses from\
    \ the peer.\n   RETRANSMIT\n      Retransmits the previous request packet.\n \
    \  SUCCESS\n      A final state indicating success.\n   FAILURE\n      A final\
    \ state indicating failure.\n   TIMEOUT_FAILURE\n      A final state indicating\
    \ failure because no response has been\n      received.  Because no response was\
    \ received, no new message\n      (including failure) should be sent to the peer.\
    \  Note that this is\n      different from the FAILURE state, in which a message\
    \ indicating\n      failure is sent to the peer.\n"
- title: 6.  EAP Backend Authenticator
  contents:
  - "6.  EAP Backend Authenticator\n   When operating in pass-through mode, there\
    \ are conceptually two parts\n   to the authenticator: the part that passes packets\
    \ through, and the\n   backend that actually implements the EAP method.  The following\n\
    \   diagram shows a state machine for the backend part of this model when\n  \
    \ using a AAA server.  Note that this diagram is identical to Figure 4\n   except\
    \ that no retransmit is included in the IDLE state because with\n   RADIUS, retransmit\
    \ is handled by the NAS.  Also, a PICK_UP_METHOD\n   state and variable in INITIALIZE\
    \ state are added to allow the Method\n   to \"pick up\" a method started in a\
    \ NAS.  Included is an explanation\n   of the primitives and procedures referenced\
    \ in the diagram, many of\n   which are the same as above.  Note that the \"lower\
    \ layer\" in this\n   case is some AAA protocol (e.g., RADIUS).\n            \
    \   (see the .pdf version for missing diagram or\n            refer to Appendix\
    \ A.3 if reading the .txt version)\n             Figure 5: EAP Backend Authenticator\
    \ State Machine\n"
- title: 6.1.  Interface between Backend Authenticator State Machine and Lower
  contents:
  - "6.1.  Interface between Backend Authenticator State Machine and Lower\n     \
    \ Layer\n   The lower layer presents messages to the EAP backend authenticator\n\
    \   state machine by storing the packet in aaaEapRespData and setting the\n  \
    \ aaaEapResp signal to TRUE.\n   When the EAP backend authenticator state machine\
    \ has finished\n   processing the message, it sets one of the signals aaaEapReq,\n\
    \   aaaEapNoReq, aaaSuccess, and aaaFail.  If it sets eapReq, eapSuccess,\n  \
    \ or eapFail, the corresponding request (or success/failure) packet is\n   stored\
    \ in aaaEapReqData.  The lower layer is responsible for actually\n   transmitting\
    \ this message.\n"
- title: 6.1.1.  Variables (AAA Interface to Backend Authenticator)
  contents:
  - "6.1.1.  Variables (AAA Interface to Backend Authenticator)\n   aaaEapResp (boolean)\n\
    \      Set to TRUE in lower layer, FALSE in authenticator state machine.\n   \
    \   Usually indicates that an EAP response, stored in aaaEapRespData,\n      is\
    \ available for processing by the AAA server.  If aaaEapRespData\n      is set\
    \ to NONE, it indicates that the AAA server should send the\n      initial EAP\
    \ request.\n   aaaEapRespData (EAP packet)\n      Set in lower layer when eapResp\
    \ is set to TRUE.  The EAP packet to\n      be processed, or NONE.\n   backendEnabled\
    \ (boolean)\n      Indicates that there is a valid link to use for the communication.\n\
    \      If at any point the port is not available, backendEnabled is set\n    \
    \  to FALSE, and the state machine transitions to DISABLED.\n"
- title: 6.1.2.  Variables (Backend Authenticator to AAA Interface)
  contents:
  - "6.1.2.  Variables (Backend Authenticator to AAA Interface)\n   aaaEapReq (boolean)\n\
    \      Set to TRUE in authenticator state machine, FALSE in lower layer.\n   \
    \   Indicates that a new EAP request is ready to be sent.\n   aaaEapNoReq (boolean)\n\
    \      Set to TRUE in authenticator state machine, FALSE in lower layer.\n   \
    \   Indicates that the most recent response has been processed, but\n      there\
    \ is no new request to send.\n   aaaSuccess (boolean)\n      Set to TRUE in authenticator\
    \ state machine, FALSE in lower layer.\n      Indicates that the state machine\
    \ has reached the SUCCESS state.\n   aaaFail (boolean)\n      Set to TRUE in authenticator\
    \ state machine, FALSE in lower layer.\n      Indicates that the state machine\
    \ has reached the FAILURE state.\n   aaaEapReqData (EAP packet)\n      Set in\
    \ authenticator state machine when aaaEapReq, aaaSuccess, or\n      aaaFail is\
    \ set to TRUE.  The actual EAP request to be sent (or\n      success/failure).\n\
    \   aaaEapKeyData (EAP key)\n      Set in authenticator state machine when keying\
    \ material becomes\n      available.  Set during the METHOD_RESPONSE state.  Note\
    \ that this\n      document does not define the structure of the type \"EAP key\"\
    .  We\n      expect that it will be defined in [Keying].\n   aaaEapKeyAvailable\
    \ (boolean)\n      Set to TRUE in the SUCCESS state if keying material is available.\n\
    \      The actual key is stored in aaaEapKeyData.\n   aaaMethodTimeout (integer)\n\
    \      Method-provided hint for suitable retransmission timeout, or NONE.\n  \
    \    (Note that this hint is for the EAP retransmissions done by the\n      pass-through\
    \ authenticator, not for retransmissions of AAA\n      packets.)\n"
- title: 6.2.  Interface between Backend Authenticator State Machine and
  contents:
  - "6.2.  Interface between Backend Authenticator State Machine and\n      Methods\n\
    \   The backend method interface is almost the same as in stand-alone\n   authenticator\
    \ described in Section 5.2.  The only difference is that\n   some methods on the\
    \ backend may support \"picking up\" a conversation\n   started by the pass-through.\
    \  That is, the EAP Request packet was\n   sent by the pass-through, but the backend\
    \ must process the\n   corresponding EAP Response.  Usually only the Identity\
    \ method\n   supports this, but others are possible.\n   When \"picking up\" a\
    \ conversation, m.initPickUp() is called instead of\n   m.init().  Next, m.process()\
    \ must examine eapRespData and update its\n   own method-specific state to match\
    \ what it would have been if it had\n   actually sent the corresponding request.\
    \  (Obviously, this only works\n   for methods that can determine what the initial\
    \ request contained;\n   Identity and EAP-TLS are good examples.)\n   After this,\
    \ the processing continues as described in Section 5.2.\n"
- title: 6.3.  Backend Authenticator State Machine Local Variables
  contents:
  - "6.3.  Backend Authenticator State Machine Local Variables\n   For definitions\
    \ of the variables used in the Backend Authenticator,\n   see Section 5.3.\n"
- title: 6.4.  EAP Backend Authenticator Procedures
  contents:
  - "6.4.  EAP Backend Authenticator Procedures\n   Most of the procedures of the\
    \ backend authenticator have already been\n   defined in Section 5.4.  This section\
    \ contains definitions for those\n   not existent in the stand-alone version,\
    \ as well as those that are\n   defined differently.\n   NOTE: For method procedures,\
    \ the method uses its internal state in\n   addition to the information provided\
    \ by the EAP layer.  The only\n   arguments that are explicitly shown as inputs\
    \ to the procedures are\n   those provided to the method by EAP.  Those inputs\
    \ provided by the\n   method's internal state remain implicit.\n   Policy.doPickUp()\n\
    \      Notifies the policy that an already-chosen method is being picked\n   \
    \   up and will be completed.  Returns a boolean.\n   m.initPickUp()\n      Method\
    \ procedure to initialize state when continuing from an\n      already-started\
    \ method.  The return value is undefined.\n"
- title: 6.5.  EAP Backend Authenticator States
  contents:
  - "6.5.  EAP Backend Authenticator States\n   Most of the states of the backend\
    \ authenticator have already been\n   defined in Section 5.5.  This section contains\
    \ definitions for those\n   not existent in the stand-alone version, as well as\
    \ those that are\n   defined differently.\n   PICK_UP_METHOD\n      Sets an initial\
    \ state for a method that is being continued and\n      that was started elsewhere.\n"
- title: 7.  EAP Full Authenticator
  contents:
  - "7.  EAP Full Authenticator\n   The following two diagrams show the state machine\
    \ for a complete\n   authenticator.  The first diagram is identical to the stand-alone\n\
    \   state machine, shown in Figure 4, with the exception that the\n   SELECT_ACTION\
    \ state has an added transition to PASSTHROUGH.  The\n   second diagram also keeps\
    \ most of the logic, except the four method\n   states, and it shows how the state\
    \ machine works once it goes to\n   pass-through mode.\n   The first diagram is\
    \ largely a reproduction of that found above, with\n   the added hooks for a transition\
    \ to PASSTHROUGH mode.\n               (see the .pdf version for missing diagram\
    \ or\n            refer to Appendix A.4 if reading the .txt version)\n       \
    \   Figure 6: EAP Full Authenticator State Machine (Part 1)\n   The second diagram\
    \ describes the functionality necessary for an\n   authenticator operating in\
    \ pass-through mode.  This section of the\n   diagram is the counterpart of the\
    \ backend diagram above.\n               (see the .pdf version for missing diagram\
    \ or\n            refer to Appendix A.4 if reading the .txt version)\n       \
    \   Figure 7: EAP Full Authenticator State Machine (Part 2)\n"
- title: 7.1.  Interface between Full Authenticator State Machine and Lower
  contents:
  - "7.1.  Interface between Full Authenticator State Machine and Lower\n      Layers\n\
    \   The full authenticator is unique in that it interfaces to multiple\n   lower\
    \ layers in order to support pass-through mode.  The interface to\n   the primary\
    \ EAP transport layer is the same as described in Section\n   5.  The following\
    \ describes the interface to the second lower layer,\n   which represents an interface\
    \ to AAA.  Note that there is not\n   necessarily a direct interaction between\
    \ the EAP layer and the AAA\n   layer, as in the case of [1X-2004].\n"
- title: 7.1.1.  Variables (AAA Interface to Full Authenticator)
  contents:
  - "7.1.1.  Variables (AAA Interface to Full Authenticator)\n   aaaEapReq (boolean)\n\
    \      Set to TRUE in lower layer, FALSE in authenticator state machine.\n   \
    \   Indicates that a new EAP request is available from the AAA server.\n   aaaEapNoReq\
    \ (boolean)\n      Set to TRUE in lower layer, FALSE in authenticator state machine.\n\
    \      Indicates that the most recent response has been processed, but\n     \
    \ that there is no new request to send.\n   aaaSuccess (boolean)\n      Set to\
    \ TRUE in lower layer.  Indicates that the AAA backend\n      authenticator has\
    \ reached the SUCCESS state.\n   aaaFail (boolean)\n      Set to TRUE in lower\
    \ layer.  Indicates that the AAA backend\n      authenticator has reached the\
    \ FAILURE state.\n   aaaEapReqData (EAP packet)\n      Set in the lower layer\
    \ when aaaEapReq, aaaSuccess, or aaaFail is\n      set to TRUE.  The actual EAP\
    \ request to be sent (or success/\n      failure).\n   aaaEapKeyData (EAP key)\n\
    \      Set in lower layer when keying material becomes available from the\n  \
    \    AAA server.  Note that this document does not define the structure\n    \
    \  of the type \"EAP key\".  We expect that it will be defined in\n      [Keying].\n\
    \   aaaEapKeyAvailable (boolean)\n      Set to TRUE in the lower layer if keying\
    \ material is available.\n      The actual key is stored in aaaEapKeyData.\n \
    \  aaaMethodTimeout (integer)\n      Method-provided hint for suitable retransmission\
    \ timeout, or NONE.\n      (Note that this hint is for the EAP retransmissions\
    \ done by the\n      pass-through authenticator, not for retransmissions of AAA\n\
    \      packets.)\n"
- title: 7.1.2.  Variables (full authenticator to AAA interface)
  contents:
  - "7.1.2.  Variables (full authenticator to AAA interface)\n   aaaEapResp (boolean)\n\
    \      Set to TRUE in authenticator state machine, FALSE in the lower\n      layer.\
    \  Indicates that an EAP response is available for processing\n      by the AAA\
    \ server.\n   aaaEapRespData (EAP packet)\n      Set in authenticator state machine\
    \ when eapResp is set to TRUE.\n      The EAP packet to be processed.\n   aaaIdentity\
    \ (EAP packet)\n      Set in authenticator state machine when an IDENTITY response\
    \ is\n      received.  Makes that identity available to AAA lower layer.\n   aaaTimeout\
    \ (boolean)\n      Set in AAA_IDLE if, after a configurable amount of time, there\
    \ is\n      no response from the AAA layer.  The AAA layer in the NAS is\n   \
    \   itself alive and OK, but for some reason it has not received a\n      valid\
    \ Access-Accept/Reject indication from the backend.\n"
- title: 7.1.3.  Constants
  contents:
  - "7.1.3.  Constants\n   Same as Section 5.\n"
- title: 7.2.  Interface between Full Authenticator State Machine and Methods
  contents:
  - "7.2.  Interface between Full Authenticator State Machine and Methods\n   Same\
    \ as stand-alone authenticator (Section 5.2).\n"
- title: 7.3.  Full Authenticator State Machine Local Variables
  contents:
  - "7.3.  Full Authenticator State Machine Local Variables\n   Many of the variables\
    \ of the full authenticator have already been\n   defined in Section 5.  This\
    \ section contains definitions for those\n   not existent in the stand-alone version,\
    \ as well as those that are\n   defined differently.\n"
- title: 7.3.1.  Short-Term (Not Maintained between Packets)
  contents:
  - "7.3.1.  Short-Term (Not Maintained between Packets)\n   decision (enumeration)\n\
    \      Set in SELECT_ACTION state.  Temporarily stores the policy\n      decision\
    \ to succeed, fail, continue with a local method, or\n      continue in pass-through\
    \ mode.\n"
- title: 7.4.  EAP Full Authenticator Procedures
  contents:
  - "7.4.  EAP Full Authenticator Procedures\n   All the procedures defined in Section\
    \ 5 exist in the full version.\n   In addition, the following procedures are defined.\n\
    \   getId()\n      Determines the identifier value chosen by the AAA server for\
    \ the\n      current EAP request.  The return value is an integer.\n"
- title: 7.5.  EAP Full Authenticator States
  contents:
  - "7.5.  EAP Full Authenticator States\n   All the states defined in Section 5 exist\
    \ in the full version.  In\n   addition, the following states are defined.\n \
    \  INITIALIZE_PASSTHROUGH\n      Initializes variables when the pass-through portion\
    \ of the state\n      machine is activated.\n   IDLE2\n      The state machine\
    \ waits for a response from the primary lower\n      layer, which transports EAP\
    \ traffic from the peer.\n   IDLE\n      The state machine spends most of its\
    \ time here, waiting for\n      something to happen.\n   RECEIVED2\n      This\
    \ state is entered when an EAP packet is received and the\n      authenticator\
    \ is in PASSTHROUGH mode.  The packet header is parsed\n      here.\n   AAA_REQUEST\n\
    \      The incoming EAP packet is parsed for sending to the AAA server.\n   AAA_IDLE\n\
    \      Idle state that tells the AAA layer that it has a response and\n      then\
    \ waits for a new request, a no-request signal, or\n      success/failure.\n \
    \  AAA_RESPONSE\n      State in which the request from the AAA interface is processed\n\
    \      into an EAP request.\n   SEND_REQUEST2\n      This state signals the lower\
    \ layer that a request packet is ready\n      to be sent.\n   DISCARD2\n     \
    \ This state signals the lower layer that the response was\n      discarded, and\
    \ that no new request packet will be sent at this\n      time.\n   RETRANSMIT2\n\
    \      Retransmits the previous request packet.\n   SUCCESS2\n      A final state\
    \ indicating success.\n   FAILURE2\n      A final state indicating failure.\n\
    \   TIMEOUT_FAILURE2\n      A final state indicating failure because no response\
    \ has been\n      received.  Because no response was received, no new message\n\
    \      (including failure) should be sent to the peer.  Note that this is\n  \
    \    different from the FAILURE2 state, in which a message indicating\n      failure\
    \ is sent to the peer.\n"
- title: 8.  Implementation Considerations
  contents:
  - '8.  Implementation Considerations

    '
- title: 8.1.  Robustness
  contents:
  - "8.1.  Robustness\n   In order to deal with erroneous cases that are not directly\
    \ related\n   to the protocol behavior, implementations may need additional\n\
    \   considerations to provide robustness against errors.\n   For example, an implementation\
    \ of a state machine may spend a\n   significant amount of time in a particular\
    \ state performing the\n   procedure defined for the state without returning a\
    \ response.  If\n   such an implementation is made on a multithreading system,\
    \ the\n   procedure may be performed in a separate thread so that the\n   implementation\
    \ can perform appropriate action without blocking on the\n   state for a long\
    \ time (or forever if the procedure never completes\n   due to, e.g., a non-responding\
    \ user or a bug in an application\n   callback function).\n   The following states\
    \ are identified as the possible places of\n   blocking:\n   o  IDENTITY state\
    \ in the peer state machine.  It may take some time\n      to process Identity\
    \ request when a user input is needed for\n      obtaining an identity from the\
    \ user.  The user may never input an\n      identity.  An implementation may define\
    \ an additional state\n      transition from IDENTITY state to FAILURE state so\
    \ that\n      authentication can fail if no identity is obtained from the user\n\
    \      before ClientTimeout timer expires.\n   o  METHOD state in the peer state\
    \ machine and in METHOD_RESPONSE\n      state in the authenticator state machines.\
    \  It may take some time\n      to perform method-specific procedures in these\
    \ states.  An\n      implementation may define an additional state transition\
    \ from\n      METHOD state and METHOD_RESPONSE state to FAILURE or\n      TIMEOUT_FAILURE\
    \ state so that authentication can fail if no method\n      processing result\
    \ is obtained from the method before methodTimeout\n      timer expires.\n"
- title: 8.2.  Method/Method and Method/Lower-Layer Interfaces
  contents:
  - "8.2.  Method/Method and Method/Lower-Layer Interfaces\n   Implementations may\
    \ define additional interfaces to pass method-\n   specific information between\
    \ methods and lower layers.  These\n   interfaces are beyond the scope of this\
    \ document.\n"
- title: 8.3.  Peer State Machine Interoperability with Deployed Implementations
  contents:
  - "8.3.  Peer State Machine Interoperability with Deployed Implementations\n   Number\
    \ of deployed EAP authenticator implementations, mainly in\n   RADIUS authentication\
    \ servers, have been observed to increment the\n   Identifier field incorrectly\
    \ when generating EAP Success and EAP\n   Failure packets which is against the\
    \ MUST requirement in RFC 3748\n   section 4.2.  The peer state machine is based\
    \ on RFC 3748, and as\n   such it will discard such EAP Success and EAP Failure\
    \ packets.\n   As a workaround for the potential interoperability issue with\n\
    \   existing implementations, conditions for peer state machine\n   transitions\
    \ from RECEIVED state to SUCCESS and FAILURE states MAY be\n   changed from \"\
    (reqId == lastId)\" to \"((reqId == lastId) || (reqId ==\n   (lastId + 1) & 255))\"\
    .  However, because this behavior does not\n   conform to RFC 3748, such a workaround\
    \ is not recommended, and if\n   included, it should be implemented as an optional\
    \ workaround that can\n   be disabled.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   This document's intent is to describe the EAP\
    \ state machine fully.\n   To this end, any security concerns with this document\
    \ are likely a\n   reflection of security concerns with EAP itself.\n   An accurate\
    \ state machine can help reduce implementation errors.\n   Although [RFC3748]\
    \ remains the normative protocol description, this\n   state machine should help\
    \ in this regard.\n   As noted in [RFC3748], some security concerns arise because\
    \ of the\n   following EAP packets:\n      1. EAP-Request/Response Identity\n\
    \      2. EAP-Response/NAK\n      3. EAP-Success/Failure\n   Because these packets\
    \ are not cryptographically protected by\n   themselves, an attacker can modify\
    \ or insert them without immediate\n   detection by the peer or authenticator.\n\
    \   Following Figure 3 specification, an attacker may cause denial of\n   service\
    \ by:\n   o  Sending an EAP-Failure to the peer before the peer has started an\n\
    \      EAP authentication method.  As long as the peer has not modified\n    \
    \  the methodState variable (initialized to NONE), the peer MUST\n      accept\
    \ an EAP-Failure.\n   o  Forcing the peer to engage in endless EAP-Request/Response\n\
    \      Identity exchanges before it has started an EAP authentication\n      method.\
    \  As long as the peer has not modified the selectedMethod\n      variable (initialized\
    \ to NONE), the peer MUST accept an EAP-\n      Request/Identity and respond to\
    \ it with an EAP-Response/Identity.\n   Following Figure 4 specification, an attacker\
    \ may cause denial of\n   service by:\n   o  Sending a NAK to the authenticator\
    \ after the authenticator first\n      proposes an EAP authentication method to\
    \ the peer.  When the\n      methodState variable has the value PROPOSED, the\
    \ authenticator is\n      obliged to process a NAK that is received in response\
    \ to its first\n      packet of an EAP authentication method.\n   There MAY be\
    \ some cases when it is desired to prevent such attacks.\n   This can be done\
    \ by modifying initial values of some variables of the\n   EAP state machines.\
    \  However, such modifications are NOT RECOMMENDED.\n   There is a trade-off between\
    \ mitigating these denial-of-service\n   attacks and being able to deal with EAP\
    \ peers and authenticators in\n   general.  For instance, if a NAK is ignored\
    \ when it is sent to the\n   authenticator after it has just proposed an EAP authentication\
    \ method\n   to the peer, then a legitimate peer that is not able or willing to\n\
    \   process the proposed EAP authentication method would fail without an\n   opportunity\
    \ to negotiate another EAP method.\n"
- title: 10.  Acknowledgements
  contents:
  - "10.  Acknowledgements\n   The work in this document was done as part of the EAP\
    \ Design Team.\n   It was done primarily by Nick Petroni, John Vollbrecht, Pasi\
    \ Eronen,\n   and Yoshihiro Ohba.  Nick started this work with Bryan Payne and\
    \ Chuk\n   Seng at the University of Maryland.  John Vollbrecht of Meetinghouse\n\
    \   Data Communications started independently with help from Dave Spence\n   at\
    \ Interlink Networks.  John and Nick collaborated to create a common\n   document,\
    \ and then were joined by Pasi Eronen of Nokia, who has made\n   major contributions\
    \ in creating coherent state machines, and by\n   Yoshihiro Ohba of Toshiba, who\
    \ insisted on including pass-through\n   documentation and provided significant\
    \ support for understanding\n   implementation issues.\n   In addition, significant\
    \ response and conversation has come from the\n   design team, especially Jari\
    \ Arkko of Ericsson and Bernard Aboba of\n   Microsoft, as well as the rest of\
    \ the team.  It has also been\n   reviewed by IEEE 802.1, and has had input from\
    \ Jim Burns of\n   Meetinghouse and Paul Congdon of Hewlett Packard.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2119]   Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC3579]   Aboba, B. and P. Calhoun, \"RADIUS (Remote Authentication\n\
    \               Dial In User Service) Support For Extensible\n               Authentication\
    \ Protocol (EAP)\", RFC 3579, September 2003.\n   [RFC3748]   Aboba, B., Blunk,\
    \ L., Vollbrecht, J., Carlson, J., and H.\n               Levkowetz, Ed., \"Extensible\
    \ Authentication Protocol\n               (EAP)\", RFC 3748, June 2004.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [Keying]    Aboba, B., Simon, D., Arkko, J.,\
    \ Eronen, P., Levkowetz,\n               H., \"Extensible Authentication Protocol\
    \ (EAP) Key\n               Management Framework\", Work in Progress, July 2005.\n\
    \   [1X-2004]   Institute of Electrical and Electronics Engineers,\n         \
    \      \"Standard for Local and Metropolitan Area Networks:\n               Port-Based\
    \ Network Access Control\", IEEE 802.1X-2004,\n               December 2004.\n"
- title: Appendix A.  ASCII versions of state diagrams
  contents:
  - "Appendix A.  ASCII versions of state diagrams\n   This appendix contains the\
    \ state diagrams in ASCII format.  Please\n   use the PDF version whenever possible;\
    \ it is much easier to\n   understand.\n   The notation is as follows: state name\
    \ and pseudocode executed when\n   entering it are shown on the left; outgoing\
    \ transitions with their\n   conditions are shown on the right.\n"
- title: A.1.  EAP Peer State Machine (Figure 3)
  contents:
  - 'A.1.  EAP Peer State Machine (Figure 3)

    '
- title: '---------------------------------------------------------------------'
  contents:
  - '---------------------------------------------------------------------

    '
- title: (global transitions)         |      !portEnabled      |      DISABLED
  contents:
  - "(global transitions)         |      !portEnabled      |      DISABLED\n     \
    \                        |------------------------+--------------\n          \
    \                   |     eapRestart &&      |    INITIALIZE\n               \
    \              |      portEnabled       |\n"
- title: '-----------------------------+------------------------+--------------'
  contents:
  - '-----------------------------+------------------------+--------------

    '
- title: DISABLED                     |      portEnabled       |    INITIALIZE
  contents:
  - 'DISABLED                     |      portEnabled       |    INITIALIZE

    '
- title: '-----------------------------+------------------------+--------------'
  contents:
  - '-----------------------------+------------------------+--------------

    '
- title: INITIALIZE                   |                        |
  contents:
  - "INITIALIZE                   |                        |\n                   \
    \          |                        |\n"
- title: selectedMethod = NONE        |                        |
  contents:
  - 'selectedMethod = NONE        |                        |

    '
- title: methodState = NONE           |                        |
  contents:
  - 'methodState = NONE           |                        |

    '
- title: allowNotifications = TRUE    |                        |
  contents:
  - 'allowNotifications = TRUE    |                        |

    '
- title: decision = FAIL              |          UCT           |          IDLE
  contents:
  - 'decision = FAIL              |          UCT           |          IDLE

    '
- title: idleWhile = ClientTimeout    |                        |
  contents:
  - 'idleWhile = ClientTimeout    |                        |

    '
- title: lastId = NONE                |                        |
  contents:
  - 'lastId = NONE                |                        |

    '
- title: eapSuccess = FALSE           |                        |
  contents:
  - 'eapSuccess = FALSE           |                        |

    '
- title: eapFail = FALSE              |                        |
  contents:
  - 'eapFail = FALSE              |                        |

    '
- title: eapKeyData = NONE            |                        |
  contents:
  - 'eapKeyData = NONE            |                        |

    '
- title: eapKeyAvailable = FALSE      |                        |
  contents:
  - 'eapKeyAvailable = FALSE      |                        |

    '
- title: eapRestart = FALSE           |                        |
  contents:
  - 'eapRestart = FALSE           |                        |

    '
- title: '-----------------------------+------------------------+--------------'
  contents:
  - '-----------------------------+------------------------+--------------

    '
- title: IDLE                         |         eapReq         |      RECEIVED
  contents:
  - "IDLE                         |         eapReq         |      RECEIVED\n     \
    \                        |------------------------+--------------\n          \
    \                   |     (altAccept &&      |\n                             |\
    \  decision != FAIL) ||  |\n                             |   (idleWhile == 0 &&\
    \   |       SUCCESS\n                             |      decision ==       |\n\
    \                             |      UNCOND_SUCC)      |\n                   \
    \          |------------------------+--------------\n                        \
    \     |------------------------+--------------\n                             |\
    \      altReject ||      |\n                             |   (idleWhile == 0 &&\
    \   |\n                             |      decision !=       |\n             \
    \                |    UNCOND_SUCC) ||     |       FAILURE\n                  \
    \           |     (altAccept &&      |\n                             | methodState\
    \ != CONT && |\n                             |   decision == FAIL)    |\n"
- title: '-----------------------------+------------------------+--------------'
  contents:
  - '-----------------------------+------------------------+--------------

    '
- title: RECEIVED                     |        rxReq &&        |        METHOD
  contents:
  - "RECEIVED                     |        rxReq &&        |        METHOD\n     \
    \                        |  (reqId != lastId) &&  |\n"
- title: (rxReq,rxSuccess,rxFailure,  |     (reqMethod ==      |
  contents:
  - "(rxReq,rxSuccess,rxFailure,  |     (reqMethod ==      |\n  reqId,reqMethod) =\
    \         |   selectedMethod) &&   |\n  parseEapReq(eapReqData)    | (methodState\
    \ != DONE)  |\n                             |------------------------+--------------\n\
    \                             |        rxReq &&        |\n                   \
    \          |  (reqId != lastId) &&  |\n                             |   (selectedMethod\
    \ ==   |\n                             |        NONE) &&        |    GET_METHOD\n\
    \                             |     (reqMethod !=      |\n                   \
    \          |      IDENTITY) &&      |\n                             |     (reqMethod\
    \ !=      |\n                             |     NOTIFICATION)      |\n       \
    \                      |------------------------+--------------\n            \
    \                 |        rxReq &&        |\n                             | \
    \ (reqId != lastId) &&  |\n                             |   (selectedMethod ==\
    \   |      IDENTITY\n                             |        NONE) &&        |\n\
    \                             |     (reqMethod ==      |\n                   \
    \          |       IDENTITY)        |\n                             |------------------------+--------------\n\
    \                             |        rxReq &&        |\n                   \
    \          |  (reqId != lastId) &&  |\n                             |   (reqMethod\
    \ ==        |  NOTIFICATION\n                             |    NOTIFICATION) &&\
    \    |\n                             |   allowNotifications   |\n            \
    \                 |------------------------+--------------\n                 \
    \            |        rxReq &&        |    RETRANSMIT\n                      \
    \       |   (reqId == lastId)    |\n                             |------------------------+--------------\n\
    \                             |      rxSuccess &&      |\n                   \
    \          |  (reqId == lastId) &&  |       SUCCESS\n                        \
    \     |   (decision != FAIL)   |\n                             |------------------------+--------------\n\
    \                             |------------------------+--------------\n     \
    \                        | (methodState!=CONT) && |\n                        \
    \     |     ((rxFailure &&     |\n                             |      decision\
    \ !=       |\n                             |    UNCOND_SUCC) ||     |       FAILURE\n\
    \                             |     (rxSuccess &&      |\n                   \
    \          | decision == FAIL)) &&  |\n                             |   (reqId\
    \ == lastId)    |\n                             |------------------------+--------------\n\
    \                             |          else          |       DISCARD\n"
- title: '-----------------------------+------------------------+--------------'
  contents:
  - '-----------------------------+------------------------+--------------

    '
- title: METHOD                       |                        |
  contents:
  - "METHOD                       |                        |\n                   \
    \          |                        |\n"
- title: ignore = m.check(eapReqData) |         ignore         |       DISCARD
  contents:
  - 'ignore = m.check(eapReqData) |         ignore         |       DISCARD

    '
- title: if (!ignore) {               |                        |
  contents:
  - "if (!ignore) {               |                        |\n  (methodState, decision,\
    \    |                        |\n  allowNotifications) =      |------------------------+--------------\n\
    \  m.process(eapReqData)      |                        |\n  /* methodState is\
    \ CONT,    |                        |\n     MAY_CONT, or DONE */    | (methodState==DONE)\
    \ && |       FAILURE\n  /* decision is FAIL,       |   (decision == FAIL)   |\n\
    \     COND_SUCC, or           |                        |\n     UNCOND_SUCC */\
    \          |                        |\n  eapRespData =              |------------------------+--------------\n\
    \    m.buildResp(reqId)       |                        |\n  if (m.isKeyAvailable())\
    \    |          else          | SEND_RESPONSE\n    eapKeyData = m.getKey()  |\
    \                        |\n"
- title: '}                            |                        |'
  contents:
  - '}                            |                        |

    '
- title: '-----------------------------+------------------------+--------------'
  contents:
  - '-----------------------------+------------------------+--------------

    '
- title: GET_METHOD                   |                        |
  contents:
  - "GET_METHOD                   |                        |\n                   \
    \          |   selectedMethod ==    |\n"
- title: if (allowMethod(reqMethod)) {|       reqMethod        |        METHOD
  contents:
  - "if (allowMethod(reqMethod)) {|       reqMethod        |        METHOD\n  selectedMethod\
    \ = reqMethod |                        |\n  methodState = INIT         |     \
    \                   |\n"
- title: '} else {                     |------------------------+--------------'
  contents:
  - "} else {                     |------------------------+--------------\n  eapRespData\
    \ =              |                        |\n    buildNak(reqId)          |  \
    \        else          | SEND_RESPONSE\n"
- title: '}                            |                        |'
  contents:
  - '}                            |                        |

    '
- title: '-----------------------------+------------------------+--------------'
  contents:
  - '-----------------------------+------------------------+--------------

    '
- title: IDENTITY                     |                        |
  contents:
  - "IDENTITY                     |                        |\n                   \
    \          |                        |\n"
- title: processIdentity(eapReqData)  |          UCT           | SEND_RESPONSE
  contents:
  - 'processIdentity(eapReqData)  |          UCT           | SEND_RESPONSE

    '
- title: eapRespData =                |                        |
  contents:
  - "eapRespData =                |                        |\n  buildIdentity(reqId)\
    \       |                        |\n"
- title: '-----------------------------+------------------------+--------------'
  contents:
  - '-----------------------------+------------------------+--------------

    '
- title: '-----------------------------+------------------------+--------------'
  contents:
  - '-----------------------------+------------------------+--------------

    '
- title: NOTIFICATION                 |                        |
  contents:
  - "NOTIFICATION                 |                        |\n                   \
    \          |                        |\n"
- title: processNotify(eapReqData)    |          UCT           | SEND_RESPONSE
  contents:
  - 'processNotify(eapReqData)    |          UCT           | SEND_RESPONSE

    '
- title: eapRespData =                |                        |
  contents:
  - "eapRespData =                |                        |\n  buildNotify(reqId)\
    \         |                        |\n"
- title: '-----------------------------+------------------------+--------------'
  contents:
  - '-----------------------------+------------------------+--------------

    '
- title: RETRANSMIT                   |                        |
  contents:
  - "RETRANSMIT                   |                        |\n                   \
    \          |          UCT           | SEND_RESPONSE\n"
- title: eapRespData = lastRespData   |                        |
  contents:
  - 'eapRespData = lastRespData   |                        |

    '
- title: '-----------------------------+------------------------+--------------'
  contents:
  - '-----------------------------+------------------------+--------------

    '
- title: DISCARD                      |                        |
  contents:
  - "DISCARD                      |                        |\n                   \
    \          |          UCT           |          IDLE\n"
- title: eapReq = FALSE               |                        |
  contents:
  - 'eapReq = FALSE               |                        |

    '
- title: eapNoResp = TRUE             |                        |
  contents:
  - 'eapNoResp = TRUE             |                        |

    '
- title: '-----------------------------+------------------------+--------------'
  contents:
  - '-----------------------------+------------------------+--------------

    '
- title: SEND_RESPONSE                |                        |
  contents:
  - "SEND_RESPONSE                |                        |\n                   \
    \          |                        |\n"
- title: lastId = reqId               |                        |
  contents:
  - 'lastId = reqId               |                        |

    '
- title: lastRespData = eapRespData   |          UCT           |          IDLE
  contents:
  - 'lastRespData = eapRespData   |          UCT           |          IDLE

    '
- title: eapReq = FALSE               |                        |
  contents:
  - 'eapReq = FALSE               |                        |

    '
- title: eapResp = TRUE               |                        |
  contents:
  - 'eapResp = TRUE               |                        |

    '
- title: idleWhile = ClientTimeout    |                        |
  contents:
  - 'idleWhile = ClientTimeout    |                        |

    '
- title: '-----------------------------+------------------------+--------------'
  contents:
  - '-----------------------------+------------------------+--------------

    '
- title: SUCCESS                      |                        |
  contents:
  - "SUCCESS                      |                        |\n                   \
    \          |                        |\n"
- title: if (eapKeyData != NONE)      |                        |
  contents:
  - "if (eapKeyData != NONE)      |                        |\n  eapKeyAvailable =\
    \ TRUE     |                        |\n"
- title: eapSuccess = TRUE            |                        |
  contents:
  - 'eapSuccess = TRUE            |                        |

    '
- title: '-----------------------------+------------------------+--------------'
  contents:
  - '-----------------------------+------------------------+--------------

    '
- title: FAILURE                      |                        |
  contents:
  - "FAILURE                      |                        |\n                   \
    \          |                        |\n"
- title: eapFail = TRUE               |                        |
  contents:
  - 'eapFail = TRUE               |                        |

    '
- title: '---------------------------------------------------------------------'
  contents:
  - "---------------------------------------------------------------------\n     \
    \                           Figure 8\n"
- title: A.2.  EAP Stand-Alone Authenticator State Machine (Figure 4)
  contents:
  - 'A.2.  EAP Stand-Alone Authenticator State Machine (Figure 4)

    '
- title: '---------------------------------------------------------------------'
  contents:
  - '---------------------------------------------------------------------

    '
- title: (global transitions)          |    !portEnabled     |        DISABLED
  contents:
  - "(global transitions)          |    !portEnabled     |        DISABLED\n     \
    \                         |---------------------+----------------\n          \
    \                    |    eapRestart &&    |      INITIALIZE\n               \
    \               |     portEnabled     |\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: DISABLED                      |     portEnabled     |      INITIALIZE
  contents:
  - 'DISABLED                      |     portEnabled     |      INITIALIZE

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: INITIALIZE                    |                     |
  contents:
  - "INITIALIZE                    |                     |\n                     \
    \         |                     |\n"
- title: currentId = NONE              |                     |
  contents:
  - 'currentId = NONE              |                     |

    '
- title: eapSuccess = FALSE            |                     |
  contents:
  - 'eapSuccess = FALSE            |                     |

    '
- title: eapFail = FALSE               |         UCT         |   SELECT_ACTION
  contents:
  - 'eapFail = FALSE               |         UCT         |   SELECT_ACTION

    '
- title: eapTimeout = FALSE            |                     |
  contents:
  - 'eapTimeout = FALSE            |                     |

    '
- title: eapKeyData = NONE             |                     |
  contents:
  - 'eapKeyData = NONE             |                     |

    '
- title: eapKeyAvailable = FALSE       |                     |
  contents:
  - 'eapKeyAvailable = FALSE       |                     |

    '
- title: eapRestart = FALSE            |                     |
  contents:
  - 'eapRestart = FALSE            |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: IDLE                          |                     |
  contents:
  - "IDLE                          |                     |\n                     \
    \         |  retransWhile == 0  |      RETRANSMIT\n"
- title: retransWhile =                |                     |
  contents:
  - "retransWhile =                |                     |\n  calculateTimeout(  \
    \         |---------------------+----------------\n   retransCount, eapSRTT, \
    \    |       eapResp       |        RECEIVED\n   eapRTTVAR, methodTimeout)  |\
    \                     |\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: RETRANSMIT                    |                     |
  contents:
  - "RETRANSMIT                    |                     |\n                     \
    \         |   retransCount >    | TIMEOUT_FAILURE\n"
- title: retransCount++                |     MaxRetrans      |
  contents:
  - 'retransCount++                |     MaxRetrans      |

    '
- title: if (retransCount<=MaxRetrans){|                     |
  contents:
  - "if (retransCount<=MaxRetrans){|                     |\n  eapReqData = lastReqData\
    \    |---------------------+----------------\n  eapReq = TRUE               |\
    \        else         |            IDLE\n"
- title: '}                             |                     |'
  contents:
  - '}                             |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: RECEIVED                      |      rxResp &&      |
  contents:
  - "RECEIVED                      |      rxResp &&      |\n                     \
    \         |     (respId ==      |\n"
- title: (rxResp,respId,respMethod)=   |    currentId) &&    |
  contents:
  - "(rxResp,respId,respMethod)=   |    currentId) &&    |\n  parseEapResp(eapRespData)\
    \   | (respMethod == NAK  |\n                              |         ||      \
    \    |             NAK\n                              |    respMethod ==    |\n\
    \                              |  EXPANDED_NAK) &&   |\n                     \
    \         |   (methodState ==   |\n                              |      PROPOSED)\
    \      |\n                              |---------------------+----------------\n\
    \                              |      rxResp &&      |\n                     \
    \         |     (respId ==      |\n                              |    currentId)\
    \ &&    | INTEGRITY_CHECK\n                              |   (respMethod ==  \
    \  |\n                              |   currentMethod)    |\n                \
    \              |---------------------+----------------\n                     \
    \         |        else         |         DISCARD\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: NAK                           |                     |
  contents:
  - "NAK                           |                     |\n                     \
    \         |         UCT         |   SELECT_ACTION\n"
- title: m.reset()                     |                     |
  contents:
  - 'm.reset()                     |                     |

    '
- title: Policy.update(<...>)          |                     |
  contents:
  - 'Policy.update(<...>)          |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: SELECT_ACTION                 | decision == FAILURE |         FAILURE
  contents:
  - "SELECT_ACTION                 | decision == FAILURE |         FAILURE\n     \
    \                         |                     |\n"
- title: decision =                    |---------------------+----------------
  contents:
  - "decision =                    |---------------------+----------------\n  Policy.getDecision()\
    \        | decision == SUCCESS |         SUCCESS\n"
- title: /* SUCCESS, FAILURE, or       |---------------------+----------------
  contents:
  - "/* SUCCESS, FAILURE, or       |---------------------+----------------\n   CONTINUE\
    \ */                |        else         |  PROPOSE_METHOD\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: INTEGRITY_CHECK               |       ignore        |         DISCARD
  contents:
  - "INTEGRITY_CHECK               |       ignore        |         DISCARD\n     \
    \                         |---------------------+----------------\n"
- title: ignore = m.check(eapRespData) |       !ignore       | METHOD_RESPONSE
  contents:
  - 'ignore = m.check(eapRespData) |       !ignore       | METHOD_RESPONSE

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: METHOD_RESPONSE               |                     |
  contents:
  - "METHOD_RESPONSE               |                     |\n                     \
    \         | methodState == END  |   SELECT_ACTION\n"
- title: m.process(eapRespData)        |                     |
  contents:
  - 'm.process(eapRespData)        |                     |

    '
- title: if (m.isDone()) {             |                     |
  contents:
  - "if (m.isDone()) {             |                     |\n  Policy.update(<...>)\
    \        |---------------------+----------------\n  eapKeyData = m.getKey()  \
    \   |                     |\n  methodState = END           |        else     \
    \    |  METHOD_REQUEST\n"
- title: '} else                        |                     |'
  contents:
  - "} else                        |                     |\n  methodState = CONTINUE\
    \      |                     |\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: PROPOSE_METHOD                |                     |
  contents:
  - "PROPOSE_METHOD                |                     |\n                     \
    \         |                     |\n"
- title: currentMethod =               |                     |
  contents:
  - "currentMethod =               |                     |\n  Policy.getNextMethod()\
    \      |                     |\n"
- title: m.init()                      |         UCT         |  METHOD_REQUEST
  contents:
  - 'm.init()                      |         UCT         |  METHOD_REQUEST

    '
- title: if (currentMethod==IDENTITY |||                     |
  contents:
  - "if (currentMethod==IDENTITY |||                     |\n  currentMethod==NOTIFICATION)|\
    \                     |\n  methodState = CONTINUE      |                     |\n"
- title: else                          |                     |
  contents:
  - "else                          |                     |\n  methodState = PROPOSED\
    \      |                     |\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: METHOD_REQUEST                |                     |
  contents:
  - "METHOD_REQUEST                |                     |\n                     \
    \         |                     |\n"
- title: currentId = nextId(currentId) |         UCT         |    SEND_REQUEST
  contents:
  - 'currentId = nextId(currentId) |         UCT         |    SEND_REQUEST

    '
- title: eapReqData =                  |                     |
  contents:
  - "eapReqData =                  |                     |\n  m.buildReq(currentId)\
    \       |                     |\n"
- title: methodTimeout = m.getTimeout()|                     |
  contents:
  - 'methodTimeout = m.getTimeout()|                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: DISCARD                       |                     |
  contents:
  - "DISCARD                       |                     |\n                     \
    \         |         UCT         |            IDLE\n"
- title: eapResp = FALSE               |                     |
  contents:
  - 'eapResp = FALSE               |                     |

    '
- title: eapNoReq = TRUE               |                     |
  contents:
  - 'eapNoReq = TRUE               |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: SEND_REQUEST                  |                     |
  contents:
  - "SEND_REQUEST                  |                     |\n                     \
    \         |                     |\n"
- title: retransCount = 0              |         UCT         |            IDLE
  contents:
  - 'retransCount = 0              |         UCT         |            IDLE

    '
- title: lastReqData = eapReqData      |                     |
  contents:
  - 'lastReqData = eapReqData      |                     |

    '
- title: eapResp = FALSE               |                     |
  contents:
  - 'eapResp = FALSE               |                     |

    '
- title: eapReq = TRUE                 |                     |
  contents:
  - 'eapReq = TRUE                 |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: TIMEOUT_FAILURE               |                     |
  contents:
  - "TIMEOUT_FAILURE               |                     |\n                     \
    \         |                     |\n"
- title: eapTimeout = TRUE             |                     |
  contents:
  - 'eapTimeout = TRUE             |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: FAILURE                       |                     |
  contents:
  - "FAILURE                       |                     |\n                     \
    \         |                     |\n"
- title: eapReqData =                  |                     |
  contents:
  - "eapReqData =                  |                     |\n  buildFailure(currentId)\
    \     |                     |\n"
- title: eapFail = TRUE                |                     |
  contents:
  - 'eapFail = TRUE                |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: SUCCESS                       |                     |
  contents:
  - "SUCCESS                       |                     |\n                     \
    \         |                     |\n"
- title: eapReqData =                  |                     |
  contents:
  - "eapReqData =                  |                     |\n  buildSuccess(currentId)\
    \     |                     |\n"
- title: if (eapKeyData != NONE)       |                     |
  contents:
  - "if (eapKeyData != NONE)       |                     |\n  eapKeyAvailable = TRUE\
    \      |                     |\n"
- title: eapSuccess = TRUE             |                     |
  contents:
  - 'eapSuccess = TRUE             |                     |

    '
- title: '---------------------------------------------------------------------'
  contents:
  - "---------------------------------------------------------------------\n     \
    \                           Figure 9\n"
- title: A.3.  EAP Backend Authenticator State Machine (Figure 5)
  contents:
  - 'A.3.  EAP Backend Authenticator State Machine (Figure 5)

    '
- title: '---------------------------------------------------------------------'
  contents:
  - '---------------------------------------------------------------------

    '
- title: (global transitions)          |   !backendEnabled   |        DISABLED
  contents:
  - '(global transitions)          |   !backendEnabled   |        DISABLED

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: DISABLED                      |  backendEnabled &&  |      INITIALIZE
  contents:
  - "DISABLED                      |  backendEnabled &&  |      INITIALIZE\n     \
    \                         |     aaaEapResp      |\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: INITIALIZE                    |       !rxResp       |   SELECT_ACTION
  contents:
  - "INITIALIZE                    |       !rxResp       |   SELECT_ACTION\n     \
    \                         |---------------------+----------------\n"
- title: currentMethod = NONE          |      rxResp &&      |
  contents:
  - 'currentMethod = NONE          |      rxResp &&      |

    '
- title: (rxResp,respId,respMethod)=   | (respMethod == NAK  |
  contents:
  - "(rxResp,respId,respMethod)=   | (respMethod == NAK  |\n  parseEapResp(aaaEapRespData)|\
    \         ||          |             NAK\n"
- title: if (rxResp)                   |    respMethod ==    |
  contents:
  - "if (rxResp)                   |    respMethod ==    |\n  currentId = respId \
    \         |    EXPANDED_NAK)    |\n"
- title: else                          |---------------------+----------------
  contents:
  - "else                          |---------------------+----------------\n  currentId\
    \ = NONE            |        else         |  PICK_UP_METHOD\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: PICK_UP_METHOD                |                     |
  contents:
  - "PICK_UP_METHOD                |                     |\n                     \
    \         |  currentMethod ==   |   SELECT_ACTION\n"
- title: if (Policy.doPickUp(          |        NONE         |
  contents:
  - "if (Policy.doPickUp(          |        NONE         |\n    respMethod)) {   \
    \         |                     |\n  currentMethod = respMethod  |---------------------+----------------\n\
    \  m.initPickUp()              |        else         | METHOD_RESPONSE\n"
- title: '}                             |                     |'
  contents:
  - '}                             |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: IDLE                          |     aaaEapResp      |        RECEIVED
  contents:
  - 'IDLE                          |     aaaEapResp      |        RECEIVED

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: RECEIVED                      |      rxResp &&      |
  contents:
  - "RECEIVED                      |      rxResp &&      |\n                     \
    \         |     (respId ==      |\n"
- title: (rxResp,respId,respMethod)=   |    currentId) &&    |
  contents:
  - "(rxResp,respId,respMethod)=   |    currentId) &&    |\n  parseEapResp(aaaEapRespData)|\
    \ (respMethod == NAK  |\n                              |         ||          |\
    \             NAK\n                              |    respMethod ==    |\n   \
    \                           |  EXPANDED_NAK) &&   |\n                        \
    \      |   (methodState ==   |\n                              |      PROPOSED)\
    \      |\n                              |---------------------+----------------\n\
    \                              |      rxResp &&      |\n                     \
    \         |     (respId ==      |\n                              |    currentId)\
    \ &&    | INTEGRITY_CHECK\n                              |   (respMethod ==  \
    \  |\n                              |   currentMethod)    |\n                \
    \              |---------------------+----------------\n                     \
    \         |        else         |         DISCARD\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: NAK                           |                     |
  contents:
  - "NAK                           |                     |\n                     \
    \         |         UCT         |   SELECT_ACTION\n"
- title: m.reset()                     |                     |
  contents:
  - 'm.reset()                     |                     |

    '
- title: Policy.update(<...>)          |                     |
  contents:
  - 'Policy.update(<...>)          |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: SELECT_ACTION                 | decision == FAILURE |         FAILURE
  contents:
  - "SELECT_ACTION                 | decision == FAILURE |         FAILURE\n     \
    \                         |                     |\n"
- title: decision =                    |---------------------+----------------
  contents:
  - "decision =                    |---------------------+----------------\n  Policy.getDecision()\
    \        | decision == SUCCESS |         SUCCESS\n"
- title: /* SUCCESS, FAILURE, or       |---------------------+----------------
  contents:
  - "/* SUCCESS, FAILURE, or       |---------------------+----------------\n   CONTINUE\
    \ */                |        else         |  PROPOSE_METHOD\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: INTEGRITY_CHECK               |       ignore        |         DISCARD
  contents:
  - "INTEGRITY_CHECK               |       ignore        |         DISCARD\n     \
    \                         |                     |\n"
- title: ignore =                      |---------------------+----------------
  contents:
  - "ignore =                      |---------------------+----------------\n  m.check(aaaEapRespData)\
    \     |       !ignore       | METHOD_RESPONSE\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: METHOD_RESPONSE               |                     |
  contents:
  - "METHOD_RESPONSE               |                     |\n                     \
    \         | methodState == END  |   SELECT_ACTION\n"
- title: m.process(aaaEapRespData)     |                     |
  contents:
  - 'm.process(aaaEapRespData)     |                     |

    '
- title: if (m.isDone()) {             |                     |
  contents:
  - "if (m.isDone()) {             |                     |\n  Policy.update(<...>)\
    \        |---------------------+----------------\n  aaaEapKeyData = m.getKey()\
    \  |                     |\n  methodState = END           |        else      \
    \   |  METHOD_REQUEST\n"
- title: '} else                        |                     |'
  contents:
  - "} else                        |                     |\n  methodState = CONTINUE\
    \      |                     |\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: PROPOSE_METHOD                |                     |
  contents:
  - "PROPOSE_METHOD                |                     |\n                     \
    \         |                     |\n"
- title: currentMethod =               |                     |
  contents:
  - "currentMethod =               |                     |\n  Policy.getNextMethod()\
    \      |                     |\n"
- title: m.init()                      |         UCT         |  METHOD_REQUEST
  contents:
  - 'm.init()                      |         UCT         |  METHOD_REQUEST

    '
- title: if (currentMethod==IDENTITY |||                     |
  contents:
  - "if (currentMethod==IDENTITY |||                     |\n  currentMethod==NOTIFICATION)|\
    \                     |\n  methodState = CONTINUE      |                     |\n"
- title: else                          |                     |
  contents:
  - "else                          |                     |\n  methodState = PROPOSED\
    \      |                     |\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: METHOD_REQUEST                |                     |
  contents:
  - "METHOD_REQUEST                |                     |\n                     \
    \         |                     |\n"
- title: currentId = nextId(currentId) |                     |
  contents:
  - 'currentId = nextId(currentId) |                     |

    '
- title: aaaEapReqData =               |         UCT         |    SEND_REQUEST
  contents:
  - "aaaEapReqData =               |         UCT         |    SEND_REQUEST\n  m.buildReq(currentId)\
    \       |                     |\n"
- title: aaaMethodTimeout =            |                     |
  contents:
  - "aaaMethodTimeout =            |                     |\n  m.getTimeout()     \
    \         |                     |\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: DISCARD                       |                     |
  contents:
  - "DISCARD                       |                     |\n                     \
    \         |         UCT         |            IDLE\n"
- title: aaaEapResp = FALSE            |                     |
  contents:
  - 'aaaEapResp = FALSE            |                     |

    '
- title: aaaEapNoReq = TRUE            |                     |
  contents:
  - 'aaaEapNoReq = TRUE            |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: SEND_REQUEST                  |                     |
  contents:
  - "SEND_REQUEST                  |                     |\n                     \
    \         |         UCT         |            IDLE\n"
- title: aaaEapResp = FALSE            |                     |
  contents:
  - 'aaaEapResp = FALSE            |                     |

    '
- title: aaaEapReq = TRUE              |                     |
  contents:
  - 'aaaEapReq = TRUE              |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: FAILURE                       |                     |
  contents:
  - "FAILURE                       |                     |\n                     \
    \         |                     |\n"
- title: aaaEapReqData =               |                     |
  contents:
  - "aaaEapReqData =               |                     |\n  buildFailure(currentId)\
    \     |                     |\n"
- title: aaaEapFail = TRUE             |                     |
  contents:
  - 'aaaEapFail = TRUE             |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: SUCCESS                       |                     |
  contents:
  - "SUCCESS                       |                     |\n                     \
    \         |                     |\n"
- title: aaaEapReqData =               |                     |
  contents:
  - "aaaEapReqData =               |                     |\n  buildSuccess(currentId)\
    \     |                     |\n"
- title: if (aaaEapKeyData != NONE)    |                     |
  contents:
  - "if (aaaEapKeyData != NONE)    |                     |\n  aaaEapKeyAvailable =\
    \ TRUE   |                     |\n"
- title: aaaEapSuccess = TRUE          |                     |
  contents:
  - 'aaaEapSuccess = TRUE          |                     |

    '
- title: '---------------------------------------------------------------------'
  contents:
  - "---------------------------------------------------------------------\n     \
    \                          Figure 10\n"
- title: A.4.  EAP Full Authenticator State Machine (Figures 6 and 7)
  contents:
  - "A.4.  EAP Full Authenticator State Machine (Figures 6 and 7)\n   This state machine\
    \ contains all the states from EAP stand-alone\n   authenticator state machine,\
    \ except that SELECT_ACTION state is\n   replaced with the following:\n"
- title: '---------------------------------------------------------------------'
  contents:
  - '---------------------------------------------------------------------

    '
- title: SELECT_ACTION                 | decision == FAILURE |         FAILURE
  contents:
  - "SELECT_ACTION                 | decision == FAILURE |         FAILURE\n     \
    \                         |                     |\n"
- title: decision =                    |---------------------+----------------
  contents:
  - "decision =                    |---------------------+----------------\n  Policy.getDecision()\
    \        | decision == SUCCESS |         SUCCESS\n"
- title: /* SUCCESS, FAILURE, CONTINUE,|---------------------+----------------
  contents:
  - "/* SUCCESS, FAILURE, CONTINUE,|---------------------+----------------\n   or\
    \ PASSTHROUGH */          |     decision ==     |     INITIALIZE_\n          \
    \                    |     PASSTHROUGH     |     PASSTHROUGH\n               \
    \               |---------------------+----------------\n                    \
    \          |        else         |  PROPOSE_METHOD\n"
- title: '---------------------------------------------------------------------'
  contents:
  - "---------------------------------------------------------------------\n     \
    \                          Figure 11\n"
- title: 'And the following new states are added:'
  contents:
  - 'And the following new states are added:

    '
- title: '---------------------------------------------------------------------'
  contents:
  - '---------------------------------------------------------------------

    '
- title: INITIALIZE_PASSTHROUGH        |  currentId != NONE  |     AAA_REQUEST
  contents:
  - "INITIALIZE_PASSTHROUGH        |  currentId != NONE  |     AAA_REQUEST\n     \
    \                         |---------------------+----------------\n"
- title: aaaEapRespData = NONE         |  currentId == NONE  |        AAA_IDLE
  contents:
  - 'aaaEapRespData = NONE         |  currentId == NONE  |        AAA_IDLE

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: IDLE2                         |                     |
  contents:
  - "IDLE2                         |                     |\n                     \
    \         |  retransWhile == 0  |     RETRANSMIT2\n"
- title: retransWhile =                |                     |
  contents:
  - "retransWhile =                |                     |\n  calculateTimeout(  \
    \         |---------------------+----------------\n   retransCount, eapSRTT, \
    \    |       eapResp       |       RECEIVED2\n   eapRTTVAR, methodTimeout)  |\
    \                     |\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: RETRANSMIT2                   |                     |
  contents:
  - "RETRANSMIT2                   |                     |\n                     \
    \         |   retransCount >    |        TIMEOUT_\n"
- title: retransCount++                |     MaxRetrans      |        FAILURE2
  contents:
  - 'retransCount++                |     MaxRetrans      |        FAILURE2

    '
- title: if (retransCount<=MaxRetrans){|                     |
  contents:
  - "if (retransCount<=MaxRetrans){|                     |\n  eapReqData = lastReqData\
    \    |---------------------+----------------\n  eapReq = TRUE               |\
    \        else         |           IDLE2\n"
- title: '}                             |                     |'
  contents:
  - '}                             |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: RECEIVED2                     |      rxResp &&      |
  contents:
  - "RECEIVED2                     |      rxResp &&      |\n                     \
    \         |     (respId ==      |     AAA_REQUEST\n"
- title: (rxResp,respId,respMethod)=   |     currentId)      |
  contents:
  - "(rxResp,respId,respMethod)=   |     currentId)      |\n  parseEapResp(eapRespData)\
    \   |---------------------+----------------\n                              | \
    \       else         |        DISCARD2\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: AAA_REQUEST                   |                     |
  contents:
  - "AAA_REQUEST                   |                     |\n                     \
    \         |                     |\n"
- title: if (respMethod == IDENTITY) { |         UCT         |        AAA_IDLE
  contents:
  - "if (respMethod == IDENTITY) { |         UCT         |        AAA_IDLE\n  aaaIdentity\
    \ = eapRespData   |                     |\n"
- title: aaaEapRespData = eapRespData  |                     |
  contents:
  - 'aaaEapRespData = eapRespData  |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: AAA_IDLE                      |     aaaEapNoReq     |        DISCARD2
  contents:
  - "AAA_IDLE                      |     aaaEapNoReq     |        DISCARD2\n     \
    \                         |---------------------+----------------\n"
- title: aaaFail = FALSE               |      aaaEapReq      |    AAA_RESPONSE
  contents:
  - 'aaaFail = FALSE               |      aaaEapReq      |    AAA_RESPONSE

    '
- title: aaaSuccess = FALSE            |---------------------+----------------
  contents:
  - 'aaaSuccess = FALSE            |---------------------+----------------

    '
- title: aaaEapReq = FALSE             |     aaaTimeout      |        TIMEOUT_
  contents:
  - 'aaaEapReq = FALSE             |     aaaTimeout      |        TIMEOUT_

    '
- title: aaaEapNoReq = FALSE           |                     |        FAILURE2
  contents:
  - 'aaaEapNoReq = FALSE           |                     |        FAILURE2

    '
- title: aaaEapResp = TRUE             |---------------------+----------------
  contents:
  - "aaaEapResp = TRUE             |---------------------+----------------\n     \
    \                         |       aaaFail       |        FAILURE2\n          \
    \                    |---------------------+----------------\n               \
    \               |     aaaSuccess      |        SUCCESS2\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: AAA_RESPONSE                  |                     |
  contents:
  - "AAA_RESPONSE                  |                     |\n                     \
    \         |                     |\n"
- title: eapReqData = aaaEapReqData    |         UCT         |   SEND_REQUEST2
  contents:
  - 'eapReqData = aaaEapReqData    |         UCT         |   SEND_REQUEST2

    '
- title: currentId = getId(eapReqData) |                     |
  contents:
  - 'currentId = getId(eapReqData) |                     |

    '
- title: methodTimeout =               |                     |
  contents:
  - "methodTimeout =               |                     |\n  aaaMethodTimeout   \
    \         |                     |\n"
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: DISCARD2                      |                     |
  contents:
  - "DISCARD2                      |                     |\n                     \
    \         |         UCT         |           IDLE2\n"
- title: eapResp = FALSE               |                     |
  contents:
  - 'eapResp = FALSE               |                     |

    '
- title: eapNoReq = TRUE               |                     |
  contents:
  - 'eapNoReq = TRUE               |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: SEND_REQUEST2                 |                     |
  contents:
  - "SEND_REQUEST2                 |                     |\n                     \
    \         |                     |\n"
- title: retransCount = 0              |         UCT         |           IDLE2
  contents:
  - 'retransCount = 0              |         UCT         |           IDLE2

    '
- title: lastReqData = eapReqData      |                     |
  contents:
  - 'lastReqData = eapReqData      |                     |

    '
- title: eapResp = FALSE               |                     |
  contents:
  - 'eapResp = FALSE               |                     |

    '
- title: eapReq = TRUE                 |                     |
  contents:
  - 'eapReq = TRUE                 |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: TIMEOUT_FAILURE2              |                     |
  contents:
  - "TIMEOUT_FAILURE2              |                     |\n                     \
    \         |                     |\n"
- title: eapTimeout = TRUE             |                     |
  contents:
  - 'eapTimeout = TRUE             |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: FAILURE2                      |                     |
  contents:
  - "FAILURE2                      |                     |\n                     \
    \         |                     |\n"
- title: eapReqData = aaaEapReqData    |                     |
  contents:
  - 'eapReqData = aaaEapReqData    |                     |

    '
- title: eapFail = TRUE                |                     |
  contents:
  - 'eapFail = TRUE                |                     |

    '
- title: '------------------------------+---------------------+----------------'
  contents:
  - '------------------------------+---------------------+----------------

    '
- title: SUCCESS2                      |                     |
  contents:
  - "SUCCESS2                      |                     |\n                     \
    \         |                     |\n"
- title: eapReqData = aaaEapReqData    |                     |
  contents:
  - 'eapReqData = aaaEapReqData    |                     |

    '
- title: eapKeyData = aaaEapKeyData    |                     |
  contents:
  - 'eapKeyData = aaaEapKeyData    |                     |

    '
- title: eapKeyAvailable =             |                     |
  contents:
  - "eapKeyAvailable =             |                     |\n  aaaEapKeyAvailable \
    \         |                     |\n"
- title: eapSuccess = TRUE             |                     |
  contents:
  - 'eapSuccess = TRUE             |                     |

    '
- title: '---------------------------------------------------------------------'
  contents:
  - "---------------------------------------------------------------------\n     \
    \                          Figure 12\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   John Vollbrecht\n   Meetinghouse Data Communications\n\
    \   9682 Alice Hill Drive\n   Dexter, MI  48130\n   USA\n   EMail: jrv@mtghouse.com\n\
    \   Pasi Eronen\n   Nokia Research Center\n   P.O. Box 407\n   FIN-00045 Nokia\
    \ Group,\n   Finland\n   EMail: pasi.eronen@nokia.com\n   Nick L. Petroni, Jr.\n\
    \   University of Maryland, College Park\n   A.V. Williams Building\n   College\
    \ Park, MD  20742\n   USA\n   EMail: npetroni@cs.umd.edu\n   Yoshihiro Ohba\n\
    \   Toshiba America Research, Inc.\n   1 Telcordia Drive\n   Piscataway, NJ  08854\n\
    \   USA\n   EMail: yohba@tari.toshiba.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
