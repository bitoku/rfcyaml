- title: __initial_text__
  contents:
  - ' Securely Available Credentials (SACRED) - Credential Server Framework

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   As the number, and more particularly the number of different types,\n\
    \   of devices connecting to the Internet increases, credential mobility\n   becomes\
    \ an issue for IETF standardization.  This document responds to\n   the requirements\
    \ on protocols for secure exchange of credentials\n   listed in RFC 3157, by presenting\
    \ an abstract protocol framework.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  2\n   2.  Functional Overview. . . . . . . . . . . . . . . . .\
    \ . . . . .  2\n       2.1.  Definitions. . . . . . . . . . . . . . . . . . .\
    \ . . . .  2\n       2.2.  Credentials. . . . . . . . . . . . . . . . . . . .\
    \ . . .  4\n       2.3.  Network Architecture . . . . . . . . . . . . . . . .\
    \ . .  5\n   3.  Protocol Framework . . . . . . . . . . . . . . . . . . . . .\
    \ .  6\n       3.1.  Credential Upload. . . . . . . . . . . . . . . . . . . .\
    \  8\n       3.2.  Credential Download. . . . . . . . . . . . . . . . . . . 10\n\
    \       3.3.  Credential Removal . . . . . . . . . . . . . . . . . . . 11\n  \
    \     3.4.  Credential Management. . . . . . . . . . . . . . . . . . 12\n   4.\
    \  Protocol Considerations. . . . . . . . . . . . . . . . . . . . 12\n       4.1.\
    \  Secure Credential Formats. . . . . . . . . . . . . . . . 12\n       4.2.  Authentication\
    \ Methods . . . . . . . . . . . . . . . . . 13\n       4.3.  Transport Protocol\
    \ Suites. . . . . . . . . . . . . . . . 16\n   5.  Security Considerations. .\
    \ . . . . . . . . . . . . . . . . . . 17\n       5.1.  Communications Security.\
    \ . . . . . . . . . . . . . . . . 17\n       5.2.  Systems Security . . . . .\
    \ . . . . . . . . . . . . . . . 18\n   6.  References . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . 20\n       6.1.  Normative References . . . . .\
    \ . . . . . . . . . . . . . 20\n       6.2.  Informative References . . . . .\
    \ . . . . . . . . . . . . 20\n   7.  Authors' Addresses . . . . . . . . . . .\
    \ . . . . . . . . . . . 21\n   8.  Full Copyright Statement . . . . . . . . .\
    \ . . . . . . . . . . 22\n"
- title: 1 Introduction
  contents:
  - "1 Introduction\n   Digital credentials, such as private keys and corresponding\n\
    \   certificates, are used to support various Internet protocols, e.g.,\n   S/MIME,\
    \ IPSec, and TLS.  In a number of environments end users wish\n   to use the same\
    \ credentials on different end-user devices.  In a\n   \"typical\" desktop environment,\
    \ the user already has many tools\n   available to allow import/export of these\
    \ credentials.  However, this\n   is not very practical.  In addition, with some\
    \ devices, especially\n   wireless and other more constrained devices, the tools\
    \ required\n   simply do not exist.\n   This document proposes a general framework\
    \ for secure exchange of\n   such credentials and provides a high level outline\
    \ that will help\n   guide the development of one or more securely available credentials\n\
    \   (SACRED) credential exchange protocols.\n"
- title: 2.  Functional Overview
  contents:
  - "2.  Functional Overview\n   Requirements for SACRED are fully described in [RFC3157].\
    \  These\n   requirements assume that two distinctly different network\n   architectures\
    \ will be created to support credential exchange for\n   roaming users:\n   a)\
    \ Client/Server Credential Exchange\n   b) Peer-to-Peer Credential Exchange\n\
    \   This document describes the framework for one or more client/server\n   credential\
    \ exchange protocols.\n   In all cases, adequate user authentication methods will\
    \ be used to\n   ensure credentials are not divulged to unauthorized parties.\
    \  As\n   well, adequate server authentication methods will be used to ensure\n\
    \   that each client's authentication information (see Section 2.1) is\n   not\
    \ compromised, and to ensure that roaming users interact with\n   intended/authorized\
    \ credential servers.\n"
- title: 2.1.  Definitions
  contents:
  - "2.1.  Definitions\n   This section provides definitions for several terms or\
    \ phrases used\n   throughout this document.\n   The key words \"MUST\", \"MUST\
    \ NOT\", \"SHOULD\", \"SHOULD NOT\",\n   \"RECOMMENDED\" and \"MAY\" in this document\
    \ are to be interpreted as\n   described in [RFC2119].\n   client authentication\
    \ information: information that is presented by\n           the client to a server\
    \ to authenticate the client.  This may\n           include a password token,\
    \ a registration string that may have\n           been received out-of-band (and\
    \ possibly used for initially\n           registering a roaming user) or data\
    \ signed with a signature\n           key belonging to the client (e.g., as part\
    \ of TLS [RFC2246]\n           client authentication).\n   credentials: cryptographic\
    \ objects and related data used to support\n           secure communications over\
    \ the Internet.  Credentials may\n           consist of public/private key pairs,\
    \ symmetric keys, X.509\n           public key certificates, attribute certificates,\
    \ and/or\n           application data.  Several standardized formats for the\n\
    \           representation of credentials exist, e.g., [PKCS12], [PKCS15]\n  \
    \         (see \"secured credentials\" below).\n   passkey: a symmetric key, derived\
    \ from a password.\n   password: a string of characters known only to a client\
    \ and used for\n           the purposes of authenticating to a server and/or securing\n\
    \           credentials.  A user may be required to remember more than\n     \
    \      one password.\n   password token: a value derived from a password using\
    \ a one-way\n           function that may be used by a client to authenticate\
    \ to a\n           server.  A password token may be derived from a password\n\
    \           using a one-way hash function, for example.\n   secured credentials:\
    \ a set of one or more credentials that have been\n           cryptographically\
    \ secured, e.g., encrypted/MACed with a\n           passkey.  Secured credentials\
    \ may be protected using more\n           than one layer of encryption, e.g.,\
    \ the credential is secured\n           with a passkey corresponding to a user's\
    \ password and also by\n           a key known only to the server (the credential's\
    \ stored\n           form).  During network transfer, the passkey-protected\n\
    \           credential may be protected with an additional encryption\n      \
    \     layer using a symmetric key chosen by the Credential Server\n          \
    \ (e.g., the transmitted form).\n   strong password protocol: a protocol that\
    \ authenticates clients to\n           servers securely (see e.g., [SPEKE] for\
    \ a more detailed\n           definition of this), where the client need only\
    \ memorize a\n           small secret (a password) and carries no other secret\n\
    \           information, and where the server carries a verifier\n           (password\
    \ token) which allows it to authenticate the client.\n           A shared secret\
    \ is negotiated between client and server and\n           is used to protect data\
    \ subsequently exchanged.\n   Note the distinction between an \"account password\"\
    \ and a \"credential\n   password.\"  An account password (and corresponding password\
    \ token) is\n   used to authenticate to a Credential Server and to negotiate a\
    \ key\n   that provides session level encryption between client and server.\n\
    \   A credential password is used to derive a passkey that's used to\n   provide\
    \ persistent encryption and authentication for a stored\n   credential.  Applicable\
    \ secured credential standards documents (e.g.,\n   [PKCS15]) describe the technical\
    \ details of specific password-based-\n   encryption (pbe) techniques that are\
    \ used to protect credentials from\n   unauthorized use.\n   Although the same\
    \ password value may be used to provide both\n   services, it is likely that different,\
    \ algorithm specific passkeys\n   would be generated from this password (i.e.,\
    \ because of different\n   salt values, etc.).\n   In addition, although it may\
    \ be more convenient for a user to\n   remember only a single password, differing\
    \ security policies (e.g.,\n   password rules) between the credential server and\
    \ the credential\n   issuers may result in a user having to remember multiple\
    \ passwords.\n"
- title: 2.2.  Credentials
  contents:
  - "2.2.  Credentials\n   This document is concerned with the secure exchange and\
    \ online\n   management of credentials in a roaming or mobile environment.\n \
    \  Credentials MAY be usable with any end user device that can connect\n   to\
    \ the Internet, such as:\n   - desktop or laptop PC\n   - mobile phone\n   - personal\
    \ digital assistant (PDA)\n   - etc.\n   The end user system may, optionally,\
    \ store its credential information\n   on special hardware devices that provide\
    \ enhanced portability and\n   protection for user credentials.\n   Since the\
    \ credential usually contains sensitive information that is\n   known only to\
    \ the credential holder, credentials MUST NOT be sent in\n   the clear during\
    \ network transmission and SHOULD NOT be in the clear\n   when stored on an end\
    \ user device such as a diskette or hard drive.\n   For this reason, a secured\
    \ credential is defined.  Throughout this\n   document we assume that, at least\
    \ from the point of view of the\n   protocol, a secured credential is an opaque\
    \ (and at least partially\n   privacy and integrity protected) data object that\
    \ can be used by a\n   network connected device.  Once downloaded, clients must\
    \ be able to\n   recover their credentials from this opaque format.\n   At a minimum,\
    \ all supported credential formats SHOULD provide privacy\n   and integrity protection\
    \ for private keys, secret keys, and any other\n   data objects that must be protected\
    \ from disclosure or modification.\n   Typically, these security capabilities\
    \ are part of the basic\n   credential format such that the credential (e.g.,\
    \ a data file) is\n   protected when stored on hard drives, flexible diskettes,\
    \ etc.\n   During network transmission, the secured credential is protected with\n\
    \   a second (outer) encryption layer.  The outer encryption layer is\n   created\
    \ using a session-level encryption key that was derived during\n   the mutual\
    \ authentication process.  Effectively, secured credentials\n   traverse an \"\
    encrypted tunnel\" that provides an additional layer of\n   privacy protection\
    \ for credentials (and any other) information\n   exchanged.\n"
- title: 2.3.  Network Architecture
  contents:
  - "2.3.  Network Architecture\n   The network diagram below shows the components\
    \ involved in the SACRED\n   client/server framework.\n                     +--------+\
    \           +------------+\n                     | Client +-----------| Credential\
    \ |\n                     +--------+     1     |   Server   |\n              \
    \            \\               +-----+------+\n                           \\  \
    \                  |\n                            \\                   | 2\n \
    \                            \\                  |\n                         \
    \     \\    3      +-----+------+\n                               -----------|\
    \ Credential |\n                                          |  Store(s)  |\n   \
    \                                       +------------+\n   Client - The entity\
    \ that wants to retrieve their credentials from a\n            credential server.\n\
    \   Credential Server - The server that downloads secure credentials to\n    \
    \        and uploads them from the client.  The server is responsible\n      \
    \      for authenticating the client to ensure that the secured\n            credentials\
    \ are exchanged only with an appropriate end user.\n            The credential\
    \ server is authenticated to the client to\n            ensure that the client's\
    \ authentication information is not\n            compromised and so that the user\
    \ can trust the credentials\n            retrieved.\n   Credential Store - The\
    \ repository for secured credentials.  There\n            might be access control\
    \ features but those generally aren't\n            sufficient in themselves for\
    \ securing credentials.  The\n            credential server may be capable of\
    \ splitting credentials\n            across multiple credential stores for redundancy\
    \ or to\n            provide additional levels of protection for user\n      \
    \      credentials.\n   Protocol 1 - The protocol used to authenticate the client\
    \ and\n            credential server, and download and upload user credentials\n\
    \            from a credential server.\n   Protocol 2 - The protocol used by the\
    \ Credential Server to store and\n            retrieve user credentials (LDAP,\
    \ LDAP/SSL, or other).\n   Protocol 3 - The protocol used by the client to store\
    \ and retrieve\n            user credentials from the credential store (LDAP,\
    \ LDAP/SSL,\n            or other).\n   This framework describes the high level\
    \ design for protocol 1.\n   Protocols 2 and 3 are closely related (but out of\
    \ scope for this\n   document) and could be implemented using standard protocols,\
    \ such as\n   LDAP or secure LDAP, or other standard or proprietary protocols.\n\
    \   Note also that any administrator-credential server protocols are\n   assumed\
    \ to be server vendor specific and are not the subject of\n   SACRED standardization\
    \ efforts at this time.\n   Clients are not precluded from exchanging credentials\
    \ directly with a\n   credential store (or any other server of it's choosing).\
    \  However,\n   mutual authentication with roaming users and a consistent level\
    \ of\n   protection for credential data while stored on network servers and\n\
    \   while in transit is provided by SACRED protocols exchanged with the\n   credential\
    \ server.  Depending on credential server design, user\n   credentials may flow\
    \ through the credential server to the credential\n   store or directly between\
    \ the client and the credential store.\n   Also, users may upload their credentials\
    \ to several credential\n   servers to obtain enhanced levels of availability.\
    \  Coordination\n   (automatic replication) of user information or credential\
    \ data among\n   several credential servers is currently beyond the scope of this\n\
    \   document.\n"
- title: 3.  Protocol Framework
  contents:
  - "3.  Protocol Framework\n   This section provides a high level description of\
    \ client/server\n   protocols that can be used to exchange and manage SACRED credentials.\n\
    \   The client/server credential exchange protocol is based on three\n   basic\
    \ and abstract operations; \"GET\", \"PUT\", and \"DELETE\".  The\n   secured\
    \ credential exchange protocol is accomplished as follows:\n      connect - the\
    \ client initiates a connection to a credential server\n              for the\
    \ purpose of secure credential exchange.\n      mutual authentication/key negotiation\
    \ - using a strong password\n              protocol (or equivalent) the client\
    \ authenticates to the\n              server, the server authenticates to the\
    \ client, and a\n              session level encryption key is negotiated.  The\
    \ details\n              of the mutual authentication protocol exchange are\n\
    \              dependent upon the particular authentication method used.\n   \
    \           In all cases, the end result is to authenticate the client\n     \
    \         to the server and server to the client, and establish a\n          \
    \    strong, shared secret between the two parties.\n      client request(s) -\
    \ the SACRED client issues one or more high\n              level credential exchange\
    \ requests (e.g., GET, PUT, or\n              DELETE).\n      server response(s)\
    \ - the SACRED credential server responds to each\n              request, either\
    \ performing the operation successfully or\n              indicating an appropriate\
    \ error.\n      close - the client indicates it has no more requests for the\n\
    \              server at this time.  The security context between client\n   \
    \           and server is no longer needed.  Close is a logical,\n           \
    \   session management operation.\n      disconnect - the parties disconnect the\
    \ transport level connection\n              between client and server.  Note that\
    \ \"connect\" and\n              \"disconnect\" are logical, transport-layer dependent\n\
    \              operations that enclose the protocol exchange between the\n   \
    \           two communicating processes.\n      Each high-level credential exchange\
    \ operation is made up of a\n      series of request-response pairs.  The client\
    \ initiates each\n      request, which the server processes before returning an\n\
    \      appropriate response.  Each request must complete (server reports\n   \
    \   success or failure) before the client issues the next request. The\n     \
    \ server SHOULD be willing to service at least one upload or\n      download request\
    \ following successful mutual authentication but\n      either party can terminate\
    \ the logical connection at any time.\n   In the following sections, secured credentials\
    \ and related values are\n   represented using the following notation:\n     \
    \ SC-x is the secured credential file, which includes a format\n             \
    \ identifier field and credential data.  The credential data\n              is\
    \ an opaque, encrypted data object (e.g., PKCS#15 or\n              PKCS#12 file).\
    \  The format identifier is needed to\n              correctly parse the credential\
    \ data.\n      Name-x is an account-defined selector or locator (a user friendly\n\
    \              name) that is used to indicate a specific secured\n           \
    \   credential.  The name of each credential stored under a\n              given\
    \ user account MUST be unique e.g., there may be one\n              credential\
    \ called \"financial\" and another called\n              \"healthcare\", etc.\
    \  At a minimum, credential names MUST be\n              unique across a given\
    \ account/user name.  When no name is\n              supplied for a GET operation,\
    \ all credentials stored for\n              the given username will be returned.\n\
    \      ID-x is a distinct credential version indicator that MAY be used\n    \
    \          to request a conditional GET/PUT/DELETE operation.  This\n        \
    \      credential-ID value SHOULD contain the server's \"last-\n             \
    \ modified\" date and time (e.g., the time that this\n              particular\
    \ credential version was stored on the server)\n              and MAY contain\
    \ additional information such as a sequence\n              number or a (complete\
    \ or partial) credential fingerprint\n              that is used to ensure the\
    \ credential-ID is unique from\n              other credential versions stored\
    \ under the same user\n              account and credential name.\n   All named\
    \ credentials may be accessed by authenticating under a\n   single username. \
    \ If a user needs or prefers to use more than one\n   distinct authentication\
    \ password (and/or authentication method) to\n   protect access to several secured\
    \ credentials, he/she SHOULD register\n   those credentials under distinct user/account\
    \ names, one for each\n   different authentication method used.\n"
- title: 3.1.  Credential Upload
  contents:
  - "3.1.  Credential Upload\n   The purpose of a credential upload operation is to\
    \ allow a client to\n   register new credentials, or replace currently stored\
    \ credentials\n   (e.g., credentials that may have been updated by the client\
    \ using\n   appropriate key management software).\n   The framework for the credential\
    \ upload, as implemented using the PUT\n   operation, is:\n   -  The client and\
    \ server establish a mutually authenticated session\n      and negotiate a shared\
    \ secret.\n   -  The client will then issue a PUT message that contains the upload\n\
    \      credential and related data fields.\n   -  The server will respond to the\
    \ PUT, indicating the credential was\n      successfully stored on the server\
    \ or that an error occurred.\n   The client's PUT request MAY contain an optional\
    \ identifier\n   (credential-ID) field.  If present, the new credential will only\
    \ be\n   stored if a credential with the same name and credential-ID is\n   currently\
    \ stored on the server (e.g., a logical REPLACE operation is\n   performed). \
    \ The server MUST return an error if a client attempts to\n   replace a credential\
    \ that does not exist on the server.\n   The credential server's response to a\
    \ PUT request MUST contain a\n   credential version identifier (credential-ID)\
    \ for the newly stored\n   credential that MAY be used by clients to optimize\
    \ subsequent\n   download operations and avoid credential version mismatches.\n"
- title: 3.1.1.  Credential Upload Protocol Sequence
  contents:
  - "3.1.1.  Credential Upload Protocol Sequence\n   The following gives an example\
    \ of a \"credential upload\" protocol\n   sequence:\n        client          \
    \                     server\n        -------                              -------\n\
    \        < connect >                  -->\n        <--- mutual authentication\
    \ --->\n        < PUT SC-1, Name-1, [ID-1] > -->\n                           \
    \          <--     < Name-1, new-ID-1 >\n        < PUT SC-2, Name-2, [ID-2] >\
    \ -->\n                                     <--     < Name-2, new-ID-2 >\n   \
    \                                  ...\n        < close >                    -->\n\
    \                                     <--     OK (+ disconnect)\n   new-ID-x is\
    \ the credential-ID of the newly stored credential.\n"
- title: 3.2.  Credential Download
  contents:
  - "3.2.  Credential Download\n   Roaming clients can download their credentials\
    \ at any time after they\n   have been uploaded to the server.\n   The framework\
    \ for a credential download, as implemented using the GET\n   operation, is:\n\
    \   -  The client SHOULD authenticate the server.\n   -  The user MUST be authenticated\
    \ (by the server).\n   -  A GET request for the credential download is issued.\n\
    \   -  The response contains the credential and format identifier.\n   The specific\
    \ user credential being requested may be identified by\n   name in the message\
    \ sent to the credential server.  If successful,\n   the response MUST contain\
    \ the requested credential data element\n   (format ID and data) as defined above.\n\
    \   If the user issues a GET request with a NULL credential name field,\n   the\
    \ server SHOULD return all credentials stored under the current\n   user account.\n\
    \   Optionally, the client MAY include a credential-ID to indicate a\n   conditional\
    \ download request.  In this case, the server will return\n   the requested credential\
    \ if and only if the ID of the credential\n   currently stored on the server does\
    \ NOT match the ID specified.\n   The server should return either the requested\
    \ credential or a\n   distinct response indicating that the conditional download\
    \ was not\n   performed (e.g., the client already has a copy of this exact\n \
    \  credential).\n"
- title: 3.2.1.  Credential Download Protocol Sequence
  contents:
  - "3.2.1.  Credential Download Protocol Sequence\n   The following gives an example\
    \ of a \"credential download\" protocol\n   sequence:\n          client      \
    \                server\n          -------                    --------\n     \
    \   < connect >            -->\n        <--- mutual authentication -->\n     \
    \   < GET Name-1, [ID-1] >  -->\n                               <--     < SC-1,\
    \ ID-1' >\n        < GET Name-2, [ID-2] >  -->\n                             \
    \  <--     < GET response >\n                               ...\n        < close\
    \ >              -->\n                               <--     OK (+ disconnect)\n\
    \   Notice that for the second request, no credential has been returned\n   since\
    \ ID-2, as included in the client's request, matched the\n   identifier for the\
    \ Name-2 credential.\n"
- title: 3.3.  Credential Removal
  contents:
  - "3.3.  Credential Removal\n   The framework for the credential removal, as implemented\
    \ with the\n   DELETE operation, is:\n   -  The credential server MUST be authenticated\
    \ (by the client) using\n      a method-dependent protocol sequence.\n   -  The\
    \ user MUST be authenticated (by the server) using a method-\n      dependent\
    \ protocol sequence.\n   -  The user then sends a DELETE request message that\
    \ contains the\n      credential name indicating which credential to remove.\n\
    \   -  Optionally, the client may include a credential-ID in the DELETE\n    \
    \  request.  In this case, the credential will be deleted if the\n      request\
    \ ID matches the ID of the credential currently stored on\n      the server. \
    \ This may be done to ensure that a client intending to\n      delete their stored\
    \ credential does not mistakenly delete a\n      different version of the credential.\n"
- title: 3.3.1.  Credential Removal Protocol Sequence
  contents:
  - "3.3.1.  Credential Removal Protocol Sequence\n   The following gives an example\
    \ of a \"credential removal\" protocol\n   sequence:\n         client        \
    \                    server\n         -------                          --------\n\
    \       < connect >               -->\n       <-------- mutual authentication\
    \ -------->\n       < DEL Name-1, [ID1] >     -->\n                          \
    \       <--     < Name-1 deleted >\n       < DEL Name-2, [ID2] >     -->\n   \
    \                              <--     < Name-2 deleted >\n                  \
    \               ...\n       < close >                 -->\n                  \
    \               <--     OK (+ disconnect)\n"
- title: 3.4.  Credential Management
  contents:
  - "3.4.  Credential Management\n   Note that the three operations defined above\
    \ (GET, PUT, DELETE) can\n   be used to perform the basic credential management\
    \ operations:\n   -  add a new credential on the server,\n   -  update (replace)\
    \ an existing credential, and\n   -  delete an existing credential.\n   The information\
    \ provided for these basic operations might be used to\n   help guide the design\
    \ of more complex operations such as user\n   registration (add account), user\
    \ deregistration (remove account),\n   change account password, or list all credentials.\n\
    \   Note that, in the case where a credential with the same name exists\n   on\
    \ the server, uploading a NULL credential is logically equivalent to\n   removing\
    \ a previously stored credential.\n"
- title: 4.  Protocol Considerations
  contents:
  - '4.  Protocol Considerations

    '
- title: 4.1.  Secure Credential Formats
  contents:
  - "4.1.  Secure Credential Formats\n   To ensure that credentials created on, and\
    \ uploaded from, one device\n   can be downloaded and used on any other device,\
    \ there is a need to\n   define a single \"mandatory to implement\" credential\
    \ format that must\n   be supported by all conforming client implementations.\n\
    \   At least two well-defined credential formats are available today:\n   [PKCS12]\
    \ and [PKCS15].\n   Other optional credential formats may also be supported if\
    \ necessary.\n   For example, additional credential formats might be defined for\
    \ use\n   with specific (compatible) client devices.  Each credential format\n\
    \   MUST provide adequate privacy protection for user credentials when\n   they\
    \ are stored on flexible diskettes, hard disks, etc.\n   Throughout this document,\
    \ the credential is treated as an opaque\n   (encrypted) data object and, as such,\
    \ the credential format does not\n   affect the basic credential exchange protocol.\n"
- title: 4.2.  Authentication Methods
  contents:
  - "4.2.  Authentication Methods\n   Authentication is vitally important to ensure\
    \ that credentials are\n   accepted from and delivered to the authorized end user\
    \ only.  If an\n   unsecured credential is delivered to some other party, the\
    \ credential\n   may be more easily compromised.  If a credential is accepted\
    \ from an\n   unauthorized party, the user might be tricked into using a credential\n\
    \   that has been substituted by an attacker (e.g., an attacker might\n   replace\
    \ a newer credential with an older credential belonging to the\n   same user).\n\
    \   Ideally, the list of authentication methods should be open ended,\n   allowing\
    \ new methods to be added as needs are identified and as they\n   become available.\
    \  For all credentials, the user authentication\n   method and data is defined\
    \ when a user is first registered with the\n   credential server and may be updated\
    \ from time to time thereafter by\n   the authorized user.\n   To adequately protect\
    \ user credentials from unauthorized disclosure\n   or modification in a roaming\
    \ environment, all SACRED authentication\n   methods MUST provide protection for\
    \ user credentials in network\n   environments where attackers might attempt to\
    \ exploit potential\n   security vulnerabilities.  See SACRED Requirements [RFC3157],\
    \ Section\n   3.1, Vulnerabilities.\n   At a minimum, each SACRED authentication\
    \ method SHOULD ensure that:\n         -  The server authenticates the client\n\
    \         -  The client authenticates the server\n         -  The client and server\
    \ securely negotiate (or derive) a\n            cryptographically strong, secret\
    \ key (e.g., a session key).\n         -  The exchange of one or more user credentials\
    \ is protected\n            using this session key.\n   It is expected that all\
    \ SACRED client/server protocols will provide\n   each of these basic security\
    \ functions.  Some existing authentication\n   protocols that might be used for\
    \ this purpose include:\n   -  Strong password protocols\n   -  TLS\n   Sections\
    \ 4.2.1 and 4.2.2 provide some guidance about when to use\n   these authentication\
    \ methods based on the generic security\n   capabilities they provide and the\
    \ security elements (passwords, key\n   pairs, user certificates, CA certificates)\
    \ that must be available to\n   the SACRED client.\n"
- title: 4.2.1.  Strong Password Protocols
  contents:
  - "4.2.1.  Strong Password Protocols\n   Strong password protocols such as those\
    \ described in [RFC2945],\n   [BM92], [BM94], and [SPEKE] MAY be used to provide\
    \ mutual\n   authentication and privacy for SACRED protocols.\n   All strong password\
    \ protocols require that user-specific values\n   (i.e., a passtoken and related\
    \ values) be configured within the\n   server.  Only a party who knows the password\
    \ can calculate the\n   verifier value.  It must be securely delivered to the\
    \ server at a\n   time when the client establishes a relationship with the server.\
    \  At\n   connect time, messages are exchanged between the two parties and\n \
    \  complementary algorithms are used to compute a shared common value\n   known\
    \ only to the legitimate user and the server.  Both parties\n   derive a strong\
    \ (symmetric) key that may be used to secure\n   communications between the two\
    \ parties.\n"
- title: 4.2.2.  TLS Authentication
  contents:
  - "4.2.2.  TLS Authentication\n   TLS authentication may either be mutual between\
    \ the client and server\n   or unilateral where only the server is authenticated\
    \ to the client.\n   These options are described in the next two subsections.\n\
    \   In both cases, TLS can be used to authenticate the server whenever\n   the\
    \ TLS client has been pre-configured with the necessary\n   certificates needed\
    \ to validate the server's certificate chain\n   (including revocation status\
    \ checking).\n   TLS Server Authentication (sTLS)\n   TLS provides a basic secure\
    \ session capability (sometimes called\n   server-side TLS) whereby the client\
    \ authenticates the server and a\n   pair of session level encryption keys is\
    \ securely exchanged between\n   client and server.  Following server authentication\
    \ and security\n   context setup, all client requests and server responses exchanged\
    \ are\n   integrity and privacy protected.\n   Protocol designers and implementors\
    \ should be aware that the\n   flexibility of the certificate-based TLS server\
    \ authentication method\n   creates security risks that need to be mitigated.\
    \  Specifically, the\n   need to ensure the user is connected to the intended\
    \ credential\n   server (secure site), and no other.  The TLS v1.0 standard [RFC2246]\n\
    \   identifies the basis for managing this risk in section F.3 (see also\n   Section\
    \ 5.2 in this document):\n      \"Implementations and users must be careful when\
    \ deciding which\n      certificates and certificate authorities are acceptable;\
    \ a\n      dishonest certificate authority can do tremendous damage.\"\n   Note\
    \ also that a faulty implementation of (increasingly complex) TLS\n   server certificate\
    \ chain processing, by the SACRED client, could lead\n   to similar compromise,\
    \ allowing successful credential server\n   masquerade or man-in-the-middle attacks.\n\
    \   An engineering approach that provides an enhanced or augmented server\n  \
    \ authentication method may be warranted for SACRED protocol designs.\n   It is\
    \ also important to understand that simple layering of\n   independently developed\
    \ security protocols (e.g., using BEEP or\n   similar layering techniques) produces\
    \ a complex, multilayer security\n   protocol that might be easily defeated by\
    \ a combination-specific\n   attack that is able to expose and exploit known weaknesses\
    \ of the\n   individual protocol(s).\n   When necessary, and after a TLS session\
    \ has been established between\n   the two parties, the credential server can\
    \ request that the client\n   provide her user id and password information to\
    \ authenticate the\n   remote user.  Preferably, client and server can cooperate\
    \ to perform\n   an authentication operation that allows the server to authenticate\n\
    \   the client (and perhaps vice-versa) in a \"zero knowledge manner\".  In\n\
    \   such cases, the client need not have a security credential.\n   TLS with Client\
    \ Authentication (cTLS)\n   TLS provides an optional, secure session capability\
    \ (sometimes called\n   client-side TLS) whereby the TLS server can request client\n\
    \   authentication by verifying the client's digital signature.\n   In order to\
    \ use cTLS to provide mutual authentication, the client\n   must also be configured\
    \ with at least one security credential that is\n   acceptable to the TLS server\
    \ for remote client authentication\n   purposes.\n"
- title: 4.2.3.  Other Authentication Methods
  contents:
  - "4.2.3.  Other Authentication Methods\n   Other authentication methods that provide\
    \ the necessary security\n   capabilities MAY also be suitable for use with SACRED\
    \ credential\n   exchange protocols.\n"
- title: 4.3.  Transport Protocol Suites
  contents:
  - "4.3.  Transport Protocol Suites\n   It is intended that one or more underlying\
    \ protocol stacks may carry\n   the SACRED credential exchange protocols.  It\
    \ is recognized at the\n   outset that the use of several underlying protocol\
    \ suites, although\n   not ideal from an interoperability standpoint, may well\
    \ be required\n   to support the wide variety of needs anticipated.\n   The SACRED\
    \ list members have discussed several protocol suites that\n   have been considered\
    \ on their technical merits, each with distinct\n   benefits and protocol design/implementation\
    \ costs.  Among these\n   protocols are:\n      - TCP\n      - BEEP\n      - HTTP\n\
    \   All protocol suites listed here depend on TCP to provide a reliable,\n   end-to-end\
    \ transport layer protocol.  Each of these building block\n   approaches provides\
    \ a different way of handling the remaining\n   application layer issues (basic\
    \ session management, session level\n   security, presentation/formatting, application\
    \ functionality).\n"
- title: 4.3.1.  TCP
  contents:
  - "4.3.1.  TCP\n   This approach (layering a SACRED credential exchange protocol\n\
    \   directly on top of a TCP connection) requires the development of a\n   custom\
    \ credential exchange messaging protocol that interfaces to a\n   TCP connection/socket.\
    \  The primary benefit of this approach is the\n   ability to provide exactly\
    \ the protocol functionality needed and no\n   more.  Most server and client development\
    \ environments already\n   provide the socket level API needed.\n"
- title: 4.3.2.  BEEP
  contents:
  - "4.3.2.  BEEP\n   This approach builds on the Blocks Extensible Exchange Protocol\n\
    \   (BEEP) described in [RFC3080].  BEEP provides general purpose, peer-\n   to-peer\
    \ message exchange over any of several transport mechanisms\n   where the necessary\
    \ transport layer mappings have been defined for\n   operation over TCP, TLS,\
    \ etc.  See also [RFC3081].\n   BEEP provides the necessary user authentication/session\
    \ security and\n   session management capabilities needed to support SACRED credential\n\
    \   exchange operations.\n"
- title: 4.3.3.  HTTP
  contents:
  - "4.3.3.  HTTP\n   This approach builds on the Hypertext Transport Protocol (HTTP)\n\
    \   described in [RFC1945] and [RFC2616].  HTTP provides general purpose\n   typing\
    \ and negotiation of data representation, allowing systems to be\n   built independently\
    \ of the data objects being transferred.  HTTP\n   support is available in a wide\
    \ variety of server and client\n   platforms, including portable devices that\
    \ apply to roaming\n   environments (laptop PCs, PDAs, mobile phones, etc.).\n\
    \   HTTP is layered over TCP and can be used, optionally, with TLS to\n   provide\
    \ authenticated, session level security.  Either or both TLS\n   authentication\
    \ options, sTLS or cTLS, may be used whenever TLS is\n   supported.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   The following security considerations identify\
    \ general observations\n   and precautions to be considered for a framework supporting\n\
    \   credential mobility.  When designing or implementing a protocol to\n   support\
    \ this framework, one should recognize these security\n   considerations, and\
    \ furthermore consult the SACRED Requirements\n   document [RFC3157] Security\
    \ Considerations.\n"
- title: 5.1.  Communications Security
  contents:
  - "5.1.  Communications Security\n   A SACRED PDU will contain information pertaining\
    \ to client or server\n   authentication, or communication of credentials. This\
    \ information is\n   subject to the traditional security concerns identified below.\n"
- title: 5.1.1.  Confidentiality
  contents:
  - "5.1.1.  Confidentiality\n   The password or password verifier should be protected\
    \ when\n   communicated from the client to credential server.  The communicated\n\
    \   value should be resistant to a dictionary attack.\n   Similarly, the entity\
    \ credentials must be confidentiality protected,\n   when communicated from the\
    \ client to the server and vice-versa.  The\n   communicated value should also\
    \ resist a dictionary attack.\n"
- title: 5.1.2.  Integrity
  contents:
  - "5.1.2.  Integrity\n   Communication integrity between the client and the credential\
    \ server\n   is required.  In this way, intended client operations may not be\n\
    \   altered (e.g., from an update to a deletion of credentials), nor may\n   clients\
    \ be maliciously given \"old\" credentials (e.g., possibly by an\n   attacker\
    \ replaying a previous credential download).\n"
- title: 5.1.3.  Entity Authentication
  contents:
  - "5.1.3.  Entity Authentication\n   Proper authentication of the client and server\
    \ is required to achieve\n   communication confidentiality and integrity.\n  \
    \ The server must properly authenticate the client, so that credentials\n   are\
    \ not mistakenly revealed to an attacker. The client must ensure\n   the proper\
    \ identification of the credential server so as to prevent\n   revealing their\
    \ password to an attacker.  These goals may be achieved\n   implicitly with a\
    \ strong password-based protocol or explicitly.  If\n   the server is identified\
    \ explicitly, the user or client must ensure\n   that the user password is conveyed\
    \ to a trusted server.  This might\n   be achieved by installing appropriate trusted\
    \ key(s) in the client.\n"
- title: 5.1.4.  Non-repudiation
  contents:
  - "5.1.4.  Non-repudiation\n   There are no requirements upon the SACRED protocol\
    \ itself to support\n   non-repudiation, although the context in which the credentials\
    \ are\n   being used may have such requirements.\n"
- title: 5.2.  Systems Security
  contents:
  - "5.2.  Systems Security\n   Systems security is concerned with protection of the\
    \ protocol\n   endpoints (i.e., the client and server) and information stored\
    \ at the\n   server in support of the SACRED protocol.\n"
- title: 5.2.1.  Client Security
  contents:
  - "5.2.1.  Client Security\n   As with most security protocols, secure use of the\
    \ client often\n   relies, in part, upon secure behavior by the user.  In the\
    \ case of a\n   password-based SACRED protocol, users should be educated, or enforced\n\
    \   through policy, to choose passwords with a reasonable amount of\n   entropy.\
    \  Additionally, users should be made aware of the importance\n   of protecting\
    \ the confidentiality of their account password.\n   In addition, the client interface\
    \ should be designed to thwart\n   \"shoulder surfing\" where an attacker can\
    \ observe the password as\n   entered by a user.  This is often achieved by not\
    \ echoing the exact\n   characters of the password when entered.\n   As well,\
    \ the interface should encourage the entering of the password\n   in the appropriate\
    \ interface field so that protections can be\n   properly enforced.  For example,\
    \ a user should be guided to not\n   mistakenly enter their password in the \"\
    username\" field (since their\n   password would likely be echoed to the screen\
    \ in this case, and might\n   not be encrypted when communicated to the server).\
    \  This might be\n   accomplished via the automatic insertion of the user name\
    \ or several\n   user name choices in the appropriate on-screen dialog field,\
    \ for\n   example.\n"
- title: 5.2.2.  Client Security, TLS Server Authentication
  contents:
  - "5.2.2.  Client Security, TLS Server Authentication\n   When TLS is used as the\
    \ SACRED transport protocol, the client\n   interface should be designed to allow\
    \ the user to verify that she is\n   connected to the intended credential server.\
    \  For example, client\n   software should allow for the visual display of identifying\n\
    \   components from the TLS server's X.509 certificate, like the server's\n  \
    \ name, the certificate fingerprint, etc.\n   Users should be guided to verify\
    \ this information regularly, allowing\n   ready recognition of trusted credential\
    \ servers.  In addition, users\n   should be made aware of the importance of verifying\
    \ their credential\n   server's identity before initiating any credential exchange\n\
    \   operations.\n   A SACRED client SHOULD only be configured with those SACRED\
    \ trust\n   anchors that are to be used by the client.  Re-use of trust anchors\n\
    \   from other applications, e.g., Internet browsers is NOT RECOMMENDED.\n"
- title: 5.2.3.  Server Security
  contents:
  - "5.2.3.  Server Security\n   Password verifiers and user credentials must be afforded\
    \ a high level\n   of protection at the credential server.  In addition to salting\
    \ and\n   super-encrypting each (to ensure resistance to offline dictionary\n\
    \   attacks), a system should ensure that credential server keys are\n   protected\
    \ using sufficient procedural and physical access controls.\n   The login to the\
    \ credential server should be resistant to replay\n   attacks.\n   Online attempts\
    \ to access a particular user account should be\n   controlled, or at least monitored.\
    \  Control might be enforced by\n   incorporating a time delay after a number\
    \ of unsuccessful logins to a\n   particular account, or possibly the locking\
    \ of the account\n   altogether.  Alternatively, one might simply log unsuccessful\n\
    \   attempts where an administrative notice is produced once a threshold\n   of\
    \ unsuccessful credential access attempts is reached.\n"
- title: 5.2.4.  Denial of Service
  contents:
  - "5.2.4.  Denial of Service\n   As with most protocols, Denial of Service (DoS)\
    \ issues must also be\n   considered.  In the case of SACRED, most DoS issues\
    \ are a concern for\n   the underlying transport protocol.  However, some concerns\
    \ may still\n   be mitigated.\n   Service to a user might be denied in case their\
    \ account is locked\n   after numerous unsuccessful login attempts.  Consideration\
    \ of\n   protection against online attacks must therefore be considered (as\n\
    \   described above).  Proper user authentication should ensure that an\n   attacker\
    \ does not maliciously overwrite a user's credentials.\n   Credential servers\
    \ should be wary of repeated logins to a particular\n   account (which also identifies\
    \ a possible security breach, as\n   described above) or abnormal volumes of requests\
    \ to a number of\n   accounts (possibly identifying a DoS attack).\n"
- title: 6.  References
  contents:
  - '6.  References

    '
- title: 6.1.  Normative References
  contents:
  - "6.1.  Normative References\n   [RFC2119] Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n             Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC3157] Arsenault, A. and S. Farrell, \"Securely Available\n   \
    \          Credentials - Requirements\", RFC 3157, August 2001.\n"
- title: 6.2.  Informative References
  contents:
  - "6.2.  Informative References\n   [BM92]    Bellovin, S. and M. Merritt, \"Encrypted\
    \ Key Exchange:\n             Password-based protocols secure against dictionary\n\
    \             attacks\", Proceedings of the IEEE Symposium on Research in\n  \
    \           Security and Privacy, May 1992.\n   [BM94]    Bellovin, S. and M.\
    \ Merritt, \"Augmented Encrypted Key\n             Exchange: a Password-Based\
    \ Protocol Secure Against\n             Dictionary Attacks and Password File Compromise,\
    \ ATT Labs\n             Technical Report, 1994.\n   [PKCS12]  \"PKCS 12 v1.0:\
    \ Personal Information Exchange Syntax\", RSA\n             Laboratories, June\
    \ 24, 1999.\n   [PKCS15]  \"PKCS #15 v1.1: Cryptographic Token Information Syntax\n\
    \             Standard\", RSA Laboratories, June 2000.\n   [RFC1945] Berners-Lee,\
    \ T., Fielding, R. and H. Frystyk, \"Hypertext\n             Transfer Protocol--\
    \ HTTP/1.0\", RFC 1945, May 1996.\n   [RFC2246] Dierks, T. and C. Allen, \"The\
    \ TLS Protocol Version 1.0\",\n             RFC 2246, January 1999.\n   [RFC2616]\
    \ Fielding, R., Gettys, J., Mogul, J., Frysyk, H., Masinter,\n             L.,\
    \ Leach, M. and T. Berners-Lee, \"Hypertext Transfer\n             Protocol -\
    \ HTTP/1.1\", RFC 2616, June 1999.\n   [RFC2945] Wu, T., \"The SRP Authentication\
    \ and Key Exchange System\",\n             RFC 2945, September 2000.\n   [RFC3080]\
    \ Rose, M., \"The Blocks Extensible Exchange Protocol Core\",\n             RFC\
    \ 3080, March 2001.\n   [RFC3081] Rose, M., \"Mapping the BEEP Core onto TCP\"\
    , RFC 3081, March\n             2001.\n   [SPEKE]   Jablon, D., \"Strong Password-Only\
    \ Authenticated Key\n             Exchange\", September 1996.\n"
- title: 7.  Authors' Addresses
  contents:
  - "7.  Authors' Addresses\n   Dale Gustafson\n   Future Foundation Inc.\n   EMail:\
    \ degustafson@comcast.net\n   Mike Just\n   Treasury Board of Canada, Secretariat\n\
    \   EMail: Just.Mike@tbs-sct.gc.ca\n   Magnus Nystrom\n   RSA Security Inc.\n\
    \   EMail: magnus@rsasecurity.com\n"
- title: 8.  Full Copyright Statement
  contents:
  - "8.  Full Copyright Statement\n   Copyright (C) The Internet Society (2004). \
    \ This document is subject\n   to the rights, licenses and restrictions contained\
    \ in BCP 78 and\n   except as set forth therein, the authors retain all their\
    \ rights.\n   This document and the information contained herein are provided\
    \ on an\n   \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n\
    \   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
