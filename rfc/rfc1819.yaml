- title: __initial_text__
  contents:
  - "                Internet Stream Protocol Version 2 (ST2)\n                 Protocol\
    \ Specification - Version ST2+\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  This memo does not specify an Internet standard of any\n   kind.\
    \  Discussion and suggestions for improvement are requested.\n   Distribution\
    \ of this memo is unlimited.\n"
- title: IESG NOTE
  contents:
  - "IESG NOTE\n   This document is a revision of RFC1190. The charter of this effort\n\
    \   was clarifying, simplifying and removing errors from RFC1190 to\n   ensure\
    \ interoperability of implementations.\n   NOTE WELL: Neither the version of the\
    \ protocol described in this\n   document nor the previous version is an Internet\
    \ Standard or under\n   consideration for that status.\n   Since the publication\
    \ of the original version of the protocol, there\n   have been significant developments\
    \ in the state of the art.  Readers\n   should note that standards and technology\
    \ addressing alternative\n   approaches to the resource reservation problem are\
    \ currently under\n   development within the IETF.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo contains a revised specification of the Internet STream\n\
    \   Protocol Version 2 (ST2). ST2 is an experimental resource reservation\n  \
    \ protocol intended to provide end-to-end real-time guarantees over an\n   internet.\
    \ It allows applications to build multi-destination simplex\n   data streams with\
    \ a desired quality of service. The revised version\n   of ST2 specified in this\
    \ memo is called ST2+.\n   This specification is a product of the STream Protocol\
    \ Working Group\n   of the Internet Engineering Task Force.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n     1  Introduction                                     \
    \              6\n             1.1  What is ST2?                             \
    \            6\n             1.2  ST2 and IP                                 \
    \          8\n             1.3  Protocol History                             \
    \        8\n             1.3.1  RFC1190 ST and ST2+ Major Differences        \
    \      9\n             1.4  Supporting Modules for ST2                       \
    \   10\n             1.4.1  Data Transfer Protocol                           \
    \ 11\n             1.4.2  Setup Protocol                                    11\n\
    \             1.4.3  Flow Specification                                11\n  \
    \           1.4.4  Routing Function                                  12\n    \
    \         1.4.5  Local Resource Manager                            12\n      \
    \       1.5  ST2 Basic Concepts                                  15\n        \
    \     1.5.1  Streams                                           16\n          \
    \   1.5.2  Data Transmission                                 16\n            \
    \ 1.5.3  Flow Specification                                17\n             1.6\
    \  Outline of This Document                            19\n     2  ST2 User Service\
    \ Description                                  19\n             2.1  Stream Operations\
    \ and Primitive Functions           19\n             2.2  State Diagrams     \
    \                                 21\n             2.3  State Transition Tables\
    \                             25\n     3  The ST2 Data Transfer Protocol     \
    \                           26\n             3.1  Data Transfer with ST      \
    \                         26\n             3.2  ST Protocol Functions        \
    \                       27\n             3.2.1  Stream Identification        \
    \                     27\n             3.2.2  Packet Discarding based on Data\
    \ Priority          27\n     4  SCMP Functional Description                  \
    \                 28\n             4.1  Types of Streams                     \
    \               29\n             4.1.1  Stream Building                      \
    \             30\n             4.1.2  Knowledge of Receivers                 \
    \           30\n             4.2  Control PDUs                               \
    \         31\n             4.3  SCMP Reliability                             \
    \       32\n             4.4  Stream Options                                 \
    \     33\n             4.4.1  No Recovery                                    \
    \   33\n             4.4.2  Join Authorization Level                         \
    \ 34\n             4.4.3  Record Route                                      34\n\
    \             4.4.4  User Data                                         35\n  \
    \           4.5  Stream Setup                                        35\n    \
    \         4.5.1  Information from the Application                  35\n      \
    \       4.5.2  Initial Setup at the Origin                       35\n        \
    \     4.5.2.1  Invoking the Routing Function                   36\n          \
    \   4.5.2.2  Reserving Resources                             36\n            \
    \ 4.5.3  Sending CONNECT Messages                          37\n             4.5.3.1\
    \  Empty Target List                               37\n             4.5.4  CONNECT\
    \ Processing by an Intermediate ST agent    37\n             4.5.5  CONNECT Processing\
    \ at the Targets                 38\n             4.5.6  ACCEPT Processing by\
    \ an Intermediate ST agent     38\n             4.5.7  ACCEPT Processing by the\
    \ Origin                   39\n             4.5.8  REFUSE Processing by the Intermediate\
    \ ST agent    39\n             4.5.9  REFUSE Processing by the Origin        \
    \           39\n             4.5.10  Other Functions during Stream Setup     \
    \         40\n             4.6  Modifying an Existing Stream                 \
    \       40\n             4.6.1  The Origin Adding New Targets                \
    \     41\n             4.6.2  The Origin Removing a Target                   \
    \   41\n             4.6.3  A Target Joining a Stream                        \
    \ 42\n             4.6.3.1  Intermediate Agent (Router) as Origin           43\n\
    \             4.6.4  A Target Deleting Itself                          43\n  \
    \           4.6.5  Changing a Stream's FlowSpec                      44\n    \
    \         4.7  Stream Tear Down                                    45\n     5\
    \  Exceptional Cases                                             45\n        \
    \     5.1  Long ST Messages                                    45\n          \
    \   5.1.1  Handling of Long Data Packets                     45\n            \
    \ 5.1.2  Handling of Long Control Packets                  46\n             5.2\
    \  Timeout Failures                                    47\n             5.2.1\
    \  Failure due to ACCEPT Acknowledgment Timeout      47\n             5.2.2  Failure\
    \ due to CHANGE Acknowledgment Timeout      47\n             5.2.3  Failure due\
    \ to CHANGE Response Timeout            48\n             5.2.4  Failure due to\
    \ CONNECT Acknowledgment Timeout     48\n             5.2.5  Failure due to CONNECT\
    \ Response Timeout           48\n             5.2.6  Failure due to DISCONNECT\
    \ Acknowledgment Timeout  48\n             5.2.7  Failure due to JOIN Acknowledgment\
    \ Timeout        48\n             5.2.8  Failure due to JOIN Response Timeout\
    \              49\n             5.2.9  Failure due to JOIN-REJECT Acknowledgment\
    \ Timeout 49\n             5.2.10  Failure due to NOTIFY Acknowledgment Timeout\
    \     49\n             5.2.11  Failure due to REFUSE Acknowledgment Timeout  \
    \   49\n             5.2.12  Failure due to STATUS Response Timeout          \
    \ 49\n             5.3  Setup Failures due to Routing Failures              50\n\
    \             5.3.1  Path Convergence                                  50\n  \
    \           5.3.2  Other Cases                                       51\n    \
    \         5.4  Problems due to Routing Inconsistency               52\n      \
    \       5.5  Problems in Reserving Resources                     53\n        \
    \     5.5.1  Mismatched FlowSpecs                              53\n          \
    \   5.5.2  Unknown FlowSpec Version                          53\n            \
    \ 5.5.3  LRM Unable to Process FlowSpec                    53\n             5.5.4\
    \  Insufficient Resources                            53\n             5.6  Problems\
    \ Caused by CHANGE Messages                  54\n             5.7  Unknown Targets\
    \ in DISCONNECT and CHANGE            55\n     6  Failure Detection and Recovery\
    \                                55\n             6.1  Failure Detection     \
    \                              55\n             6.1.1  Network Failures      \
    \                            56\n             6.1.2  Detecting ST Agents Failures\
    \                      56\n             6.2  Failure Recovery                \
    \                    58\n             6.2.1  Problems in Stream Recovery     \
    \                  60\n             6.3  Stream Preemption                   \
    \                62\n     7  A Group of Streams                              \
    \              63\n             7.1  Basic Group Relationships               \
    \            63\n             7.1.1  Bandwidth Sharing                       \
    \          63\n             7.1.2  Fate Sharing                              \
    \        64\n             7.1.3  Route Sharing                               \
    \      65\n             7.1.4  Subnet Resources Sharing                      \
    \    65\n             7.2  Relationships Orthogonality                       \
    \  65\n     8  Ancillary Functions                                           66\n\
    \             8.1  Stream ID Generation                                66\n  \
    \           8.2  Group Name Generator                                66\n    \
    \         8.3  Checksum Computation                                67\n      \
    \       8.4  Neighbor ST Agent Identification and\n                     Information\
    \ Collection                           67\n             8.5  Round Trip Time Estimation\
    \                          68\n             8.6  Network MTU Discovery       \
    \                        68\n             8.7  IP Encapsulation of ST        \
    \                      69\n             8.8  IP Multicasting                 \
    \                    70\n     9  The ST2+ Flow Specification                 \
    \                  71\n             9.1  FlowSpec Version #0 - (Null FlowSpec)\
    \               72\n             9.2  FlowSpec Version #7 - ST2+ FlowSpec    \
    \             72\n             9.2.1  QoS Classes                            \
    \           73\n             9.2.2  Precedence                               \
    \         74\n             9.2.3  Maximum Data Size                          \
    \       74\n             9.2.4  Message Rate                                 \
    \     74\n             9.2.5  Delay and Delay Jitter                         \
    \   74\n             9.2.6  ST2+ FlowSpec Format                             \
    \ 75\n     10  ST2 Protocol Data Units Specification                        77\n\
    \             10.1  Data PDU                                           77\n  \
    \           10.1.1  ST Data Packets                                  78\n    \
    \         10.2  Control PDUs                                       78\n      \
    \       10.3  Common SCMP Elements                               80\n        \
    \     10.3.1  FlowSpec                                         80\n          \
    \   10.3.2  Group                                            81\n            \
    \ 10.3.3  MulticastAddress                                 82\n             10.3.4\
    \  Origin                                           82\n             10.3.5  RecordRoute\
    \                                      83\n             10.3.6  Target and TargetList\
    \                            84\n             10.3.7  UserData               \
    \                          85\n             10.3.8  Handling of Undefined Parameters\
    \                 86\n             10.4  ST Control Message PDUs             \
    \               86\n             10.4.1  ACCEPT                              \
    \             86\n             10.4.2  ACK                                   \
    \           88\n             10.4.3  CHANGE                                  \
    \         89\n             10.4.4  CONNECT                                   \
    \       89\n             10.4.5  DISCONNECT                                  \
    \     92\n             10.4.6  ERROR                                         \
    \   93\n             10.4.7  HELLO                                           \
    \ 94\n             10.4.8  JOIN                                             95\n\
    \             10.4.9  JOIN-REJECT                                      96\n  \
    \           10.4.10  NOTIFY                                          97\n    \
    \         10.4.11  REFUSE                                          98\n      \
    \       10.4.12  STATUS                                         100\n        \
    \     10.4.13  STATUS-RESPONSE                                100\n          \
    \   10.5  Suggested Protocol Constants                      101\n            \
    \ 10.5.1  SCMP Messages                                   102\n             10.5.2\
    \  SCMP Parameters                                 102\n             10.5.3  ReasonCode\
    \                                      102\n             10.5.4  Timeouts and\
    \ Other Constants                    104\n             10.6  Data Notations  \
    \                                  105\n     11  References                  \
    \                                106\n     12  Security Considerations       \
    \                              108\n     13  Acknowledgments and Authors' Addresses\
    \                      108\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1  What is ST2?
  contents:
  - "1.1  What is ST2?\n   The Internet Stream Protocol, Version 2 (ST2) is an experimental\n\
    \   connection-oriented internetworking protocol that operates at the\n   same\
    \ layer as connectionless IP. It has been developed to support the\n   efficient\
    \ delivery of data streams to single or multiple destinations\n   in applications\
    \ that require guaranteed quality of service. ST2 is\n   part of the IP protocol\
    \ family and serves as an adjunct to, not a\n   replacement for, IP. The main\
    \ application areas of the protocol are\n   the real-time transport of multimedia\
    \ data, e.g., digital audio and\n   video packet streams, and distributed simulation/gaming,\
    \ across\n   internets.\n   ST2 can be used to reserve bandwidth for real-time\
    \ streams across\n   network routes. This reservation, together with appropriate\
    \ network\n   access and packet scheduling mechanisms in all nodes running the\n\
    \   protocol, guarantees a well-defined Quality of Service (QoS) to ST2\n   applications.\
    \ It ensures that real-time packets are delivered within\n   their deadlines,\
    \ that is, at the time where they need to be\n   presented.  This facilitates\
    \ a smooth delivery of data that is\n   essential for time- critical applications,\
    \ but can typically not be\n   provided by best- effort IP communication.\n  \
    \                    DATA PATH                         CONTROL PATH\n        \
    \              =========                         ============\n       Upper  \
    \   +------------------+                     +---------+\n       Layer     | Application\
    \ data |                     | Control |\n                 +------------------+\
    \                     +---------+\n                          |               \
    \                     |\n                          |                         \
    \           V\n                          |                     +-------------------+\n\
    \       SCMP               |                     |   SCMP  |         |\n     \
    \                     |                     +-------------------+\n          \
    \                |                             |\n                          V\
    \                             V\n            +-----------------------+      +------------------------+\n\
    \       ST   | ST |                  |      | ST |         |         |\n     \
    \       +-----------------------+      +------------------------+\n          \
    \  D-bit=1                       D-bit=0\n                   Figure 1: ST2 Data\
    \ and Control Path\n   Just like IP, ST2 actually consists of two protocols: ST\
    \ for the data\n   transport and SCMP, the Stream Control Message Protocol, for\
    \ all\n   control functions. ST is simple and contains only a single PDU format\n\
    \   that is designed for fast and efficient data forwarding in order to\n   achieve\
    \ low communication delays. SCMP, however, is more complex than\n   IP's ICMP.\
    \ As with ICMP and IP, SCMP packets are transferred within\n   ST packets as shown\
    \ in Figure 1.\n    +--------------------+\n    | Conference Control |\n    +--------------------+\n\
    \   +-------+ +-------+ |\n   | Video | | Voice | | +-----+ +------+ +-----+ \
    \    +-----+ Application\n   | Appl  | | Appl  | | | SNMP| |Telnet| | FTP | ...\
    \ |     |    Layer\n   +-------+ +-------+ | +-----+ +------+ +-----+     +-----+\n\
    \       |        |      |     |        |     |            |\n       V        V\
    \      |     |        |     |            |   ------------\n    +-----+  +-----+\
    \   |     |        |     |            |\n    | PVP |  | NVP |   |     |      \
    \  |     |            |\n    +-----+  +-----+   +     |        |     |       \
    \     |\n     |   \\      | \\     \\    |        |     |            |\n     |\
    \    +-----|--+-----+   |        |     |            |\n     |     Appl.|control\
    \  V  V        V     V            V\n     | ST  data |         +-----+    +-------+\
    \        +-----+\n     | & control|         | UDP |    |  TCP  |    ... | RTP\
    \ | Transport\n     |          |         +-----+    +-------+        +-----+ \
    \  Layer\n     |         /|          / | \\       / / |          / /|\n     |\\\
    \       / |  +------+--|--\\-----+-/--|--- ... -+ / |\n     | \\     /  |  | \
    \        |   \\     /   |          /  |\n     |  \\   /   |  |         |    \\\
    \   +----|--- ... -+   |   -----------\n     |   \\ /    |  |         |     \\\
    \ /     |             |\n     |    V     |  |         |      V      |        \
    \     |\n     | +------+ |  |         |   +------+  |   +------+  |\n     | |\
    \ SCMP | |  |         |   | ICMP |  |   | IGMP |  |    Internet\n     | +------+\
    \ |  |         |   +------+  |   +------+  |     Layer\n     |    |     |  | \
    \        |      |      |      |      |\n     V    V     V  V         V      V\
    \      V      V      V\n   +-----------------+  +-----------------------------------+\n\
    \   | STream protocol |->|      Internet     Protocol        |\n   +-----------------+\
    \  +-----------------------------------+\n                  | \\   / |\n     \
    \             |  \\ /  |\n                  |   X   |                        \
    \          ------------\n                  |  / \\  |\n                  | / \
    \  \\ |\n                  VV     VV\n   +----------------+   +----------------+\n\
    \   | (Sub-) Network |...| (Sub-) Network |                  (Sub-)Network\n \
    \  |    Protocol    |   |    Protocol    |                     Layer\n   +----------------+\
    \   +----------------+\n                   Figure 2.  Protocol Relationships\n"
- title: 1.2  ST2 and IP
  contents:
  - "1.2  ST2 and IP\n   ST2 is designed to coexist with IP on each node. A typical\n\
    \   distributed multimedia application would use both protocols: IP for\n   the\
    \ transfer of traditional data and control information, and ST2 for\n   the transfer\
    \ of real-time data. Whereas IP typically will be accessed\n   from TCP or UDP,\
    \ ST2 will be accessed via new end-to-end real-time\n   protocols. The position\
    \ of ST2 with respect to the other protocols of\n   the Internet family is represented\
    \ in Figure 2.\n   Both ST2 and IP apply the same addressing schemes to identify\n\
    \   different hosts. ST2 and IP packets differ in the first four bits,\n   which\
    \ contain the internetwork protocol version number: number 5 is\n   reserved for\
    \ ST2 (IP itself has version number 4). As a network layer\n   protocol, like\
    \ IP, ST2 operates independently of its underlying\n   subnets. Existing implementations\
    \ use ARP for address resolution, and\n   use the same Layer 2 SAPs as IP.\n \
    \  As a special function, ST2 messages can be encapsulated in IP\n   packets.\
    \  This is represented in Figure 2 as a link between ST2 and\n   IP. This link\
    \ allows ST2 messages to pass through routers which do\n   not run ST2.  Resource\
    \ management is typically not available for\n   these IP route segments. IP encapsulation\
    \ is, therefore, suggested\n   only for portions of the network which do not constitute\
    \ a system\n   bottleneck.\n   In Figure 2, the RTP protocol is shown as an example\
    \ of transport\n   layer on top of ST2. Others include the Packet Video Protocol\
    \ (PVP)\n   [Cole81], the Network Voice Protocol (NVP) [Cohe81], and others such\n\
    \   as the Heidelberg Transport Protocol (HeiTP) [DHHS92].\n"
- title: 1.3  Protocol History
  contents:
  - "1.3  Protocol History\n   The first version of ST was published in the late 1970's\
    \ and was used\n   throughout the 1980's for experimental transmission of voice,\
    \ video,\n   and distributed simulation. The experience gained in these\n   applications\
    \ led to the development of the revised protocol version\n   ST2. The revision\
    \ extends the original protocol to make it more\n   complete and more applicable\
    \ to emerging multimedia environments. The\n   specification of this protocol\
    \ version is contained in Internet RFC\n   1190 which was published in October\
    \ 1990 [RFC1190].\n   With more and more developments of commercial distributed\
    \ multimedia\n   applications underway and with a growing dissatisfaction at the\n\
    \   transmission quality for audio and video over IP in the MBONE,\n   interest\
    \ in ST2 has grown over the last years. Companies have\n   products available\
    \ incorporating the protocol. The BERKOM MMTS\n   project of the German PTT [DeAl92]\
    \ uses ST2 as its core protocol for\n   the provision of multimedia teleservices\
    \ such as conferencing and\n   mailing. In addition, implementations of ST2 for\
    \ Digital Equipment,\n   IBM, NeXT, Macintosh, PC, Silicon Graphics, and Sun platforms\
    \ are\n   available.\n   In 1993, the IETF started a new working group on ST2\
    \ as part of\n   ongoing efforts to develop protocols that address resource\n\
    \   reservation issues.  The group's mission was to clean up the existing\n  \
    \ protocol specification to ensure better interoperability between the\n   existing\
    \ and emerging implementations. It was also the goal to\n   produce an updated\
    \ experimental protocol specification that reflected\n   the experiences gained\
    \ with the existing ST2 implementations and\n   applications. Which led to the\
    \ specification of the ST2+ protocol\n   contained in this document.\n"
- title: 1.3.1  RFC1190 ST and ST2+ Major Differences
  contents:
  - "1.3.1  RFC1190 ST and ST2+ Major Differences\n   The protocol changes from RFC1190\
    \ were motivated by protocol\n   simplification and clarification, and codification\
    \ of extensions in\n   existing implementations. This section provides a list\
    \ of major\n   differences, and is probably of interest only to those who have\n\
    \   knowledge of RFC1190. The major differences between the versions are:\n"
- title: o   Elimination of "Hop IDentifiers" or HIDs. HIDs added much complexity
  contents:
  - "o   Elimination of \"Hop IDentifiers\" or HIDs. HIDs added much complexity\n\
    \    to the protocol and was found to be a major impediment to\n    interoperability.\
    \ HIDs have been replaced by globally unique\n    identifiers called \"Stream\
    \ IDentifiers\" or SIDs.\n"
- title: o   Elimination of a number of stream options. A number of options were
  contents:
  - "o   Elimination of a number of stream options. A number of options were\n   \
    \ found to not be used by any implementation, or were thought to add\n    more\
    \ complexity than value. These options were removed. Removed\n    options include:\
    \ point-to-point, full-duplex, reverse charge, and\n    source route.\n"
- title: o   Elimination of the concept of "subset" implementations. RFC1190
  contents:
  - "o   Elimination of the concept of \"subset\" implementations. RFC1190\n    permitted\
    \ subset implementations, to allow for easy implementation\n    and experimentation.\
    \ This led to interoperability problems. Agents\n    implementing the protocol\
    \ specified in this document, MUST implement\n    the full protocol. A number\
    \ of the protocol functions are best-\n    effort. It is expected that some implementations\
    \ will make more\n    effort than others in satisfying particular protocol requests.\n"
- title: o   Clarification of the capability of targets to request to join a
  contents:
  - "o   Clarification of the capability of targets to request to join a\n    steam.\
    \ RFC1190 can be interpreted to support target requests, but\n    most implementors\
    \ did not understand this and did not add support\n    for this capability. The\
    \ lack of this capability was found to be a\n    significant limitation in the\
    \ ability to scale the number of\n    participants in a single ST stream. This\
    \ clarification is based on\n    work done by IBM Heidelberg.\n"
- title: o   Separation of functions between ST and supporting modules. An effort
  contents:
  - "o   Separation of functions between ST and supporting modules. An effort\n  \
    \  was made to improve the separation of functions provided by ST and\n    those\
    \ provided by other modules. This is reflected in reorganization\n    of some\
    \ text and some PDU formats. ST was also made FlowSpec\n    independent, although\
    \ it does define a FlowSpec for testing and\n    interoperability purposes.\n"
- title: o   General reorganization and re-write of the specification. This
  contents:
  - "o   General reorganization and re-write of the specification. This\n    document\
    \ has been organized with the goal of improved readability\n    and clarity. Some\
    \ sections have been added, and an effort was made\n    to improve the introduction\
    \ of concepts.\n"
- title: 1.4  Supporting Modules for ST2
  contents:
  - "1.4  Supporting Modules for ST2\n   ST2 is one piece of a larger mosaic. This\
    \ section presents the\n   overall communication architecture and clarifies the\
    \ role of ST2 with\n   respect to its supporting modules.\n   ST2 proposes a two-step\
    \ communication model. In the first step, the\n   real-time channels for the subsequent\
    \ data transfer are built. This\n   is called stream setup. It includes selecting\
    \ the routes to the\n   destinations and reserving the correspondent resources.\
    \ In the second\n   step, the data is transmitted over the previously established\n\
    \   streams.  This is called data transfer. While stream setup does not\n   have\
    \ to be completed in real-time, data transfer has stringent real-\n   time requirements.\
    \ The architecture used to describe the ST2\n   communication model includes:\n"
- title: o   a data transfer protocol for the transmission of real-time data
  contents:
  - "o   a data transfer protocol for the transmission of real-time data\n    over\
    \ the established streams,\n"
- title: o   a setup protocol to establish real-time streams based on the flow
  contents:
  - "o   a setup protocol to establish real-time streams based on the flow\n    specification,\n"
- title: o   a flow specification to express user real-time requirements,
  contents:
  - 'o   a flow specification to express user real-time requirements,

    '
- title: o   a routing function to select routes in the Internet,
  contents:
  - 'o   a routing function to select routes in the Internet,

    '
- title: o   a local resource manager to appropriately handle resources involved
  contents:
  - "o   a local resource manager to appropriately handle resources involved\n   \
    \ in the communication.\n   This document defines a data protocol (ST), a setup\
    \ protocol (SCMP),\n   and a flow specification (ST2+ FlowSpec). It does not define\
    \ a\n   routing function and a local resource manager. However, ST2 assumes\n\
    \   their existence.\n   Alternative architectures are possible, see [RFC1633]\
    \ for an example\n   alternative architecture that could be used when implementing\
    \ ST2.\n"
- title: 1.4.1  Data Transfer Protocol
  contents:
  - "1.4.1  Data Transfer Protocol\n   The data transfer protocol defines the format\
    \ of the data packets\n   belonging to the stream. Data packets are delivered\
    \ to the targets\n   along the stream paths previously established by the setup\
    \ protocol.\n   Data packets are delivered with the quality of service associated\n\
    \   with the stream.\n   Data packets contain a globally unique stream identifier\
    \ that\n   indicates which stream they belong to. The stream identifier is also\n\
    \   known by the setup protocol, which uses it during stream\n   establishment.\
    \ The data transfer protocol for ST2, known simply as\n   ST, is completely defined\
    \ by this document.\n"
- title: 1.4.2  Setup Protocol
  contents:
  - "1.4.2  Setup Protocol\n   The setup protocol is responsible for establishing,\
    \ maintaining, and\n   releasing real-time streams. It relies on the routing function\
    \ to\n   select the paths from the source to the destinations. At each\n   host/router\
    \ on these paths, it presents the flow specification\n   associated with the stream\
    \ to the local resource manager. This causes\n   the resource managers to reserve\
    \ appropriate resources for the\n   stream.  The setup protocol for ST2 is called\
    \ Stream Control Message\n   Protocol, or SCMP, and is completely defined by this\
    \ document.\n"
- title: 1.4.3  Flow Specification
  contents:
  - "1.4.3  Flow Specification\n   The flow specification is a data structure including\
    \ the ST2\n   applications' QoS requirements. At each host/router, it is used\
    \ by\n   the local resource manager to appropriately handle resources so that\n\
    \   such requirements are met. Distributing the flow specification to all\n  \
    \ resource managers along the communication paths is the task of the\n   setup\
    \ protocol. However, the contents of the flow specification are\n   transparent\
    \ to the setup protocol, which simply carries the flow\n   specification. Any\
    \ operations on the flow specification, including\n   updating internal fields\
    \ and comparing flow specifications are\n   performed by the resource managers.\n\
    \   This document defines a specific flow specification format that\n   allows\
    \ for interoperability among ST2 implementations. This flow\n   specification\
    \ is intended to support a flow with a single\n   transmission rate for all destinations\
    \ in the stream. Implementations\n   may support more than one flow specification\
    \ format and the means are\n   provided to add new formats as they are defined\
    \ in the future.\n   However, the flow specification format has to be consistent\n\
    \   throughout the stream, i.e., it is not possible to use different flow\n  \
    \ specification formats for different parts of the same stream.\n"
- title: 1.4.4  Routing Function
  contents:
  - "1.4.4  Routing Function\n   The routing function is an external unicast route\
    \ generation\n   capability. It provides the setup protocol with the path to reach\n\
    \   each of the desired destinations. The routing function is called on a\n  \
    \ hop-by-hop basis and provides next-hop information. Once a route is\n   selected\
    \ by the routing function, it persists for the whole stream\n   lifetime. The\
    \ routing function may try to optimize based on the\n   number of targets, the\
    \ requested resources, or use of local network\n   multicast or bandwidth capabilities.\
    \ Alternatively, the routing\n   function may even be based on simple connectivity\
    \ information.\n   The setup protocol is not necessarily aware of the criteria\
    \ used by\n   the routing function to select routes. It works with any routing\n\
    \   function algorithm. The algorithm adopted is a local matter at each\n   host/router\
    \ and different hosts/routers may use different algorithms.\n   The interface\
    \ between setup protocol and routing function is also a\n   local matter and therefore\
    \ it is not specified by this document.\n   This version of ST does not support\
    \ source routing. It does support\n   route recording. It does include provisions\
    \ that allow identification\n   of ST capable neighbors. Identification of remote\
    \ ST hosts/routers is\n   not specifically addressed.\n"
- title: 1.4.5  Local Resource Manager
  contents:
  - "1.4.5  Local Resource Manager\n   At each host/router traversed by a stream,\
    \ the Local Resource Manager\n   (LRM) is responsible for handling local resources.\
    \ The LRM knows\n   which resources are on the system and what capacity they can\
    \ provide.\n   Resources include:\n"
- title: o   CPUs on end systems and routers to execute the application and
  contents:
  - "o   CPUs on end systems and routers to execute the application and\n    protocol\
    \ software,\n"
- title: o   main memory space for this software (as in all real-time systems,
  contents:
  - "o   main memory space for this software (as in all real-time systems,\n    code\
    \ should be pinned in main memory, as swapping it out would have\n    detrimental\
    \ effects on system performance),\n"
- title: o   buffer space to store the data, e.g., communication packets, passing
  contents:
  - "o   buffer space to store the data, e.g., communication packets, passing\n  \
    \  through the nodes,\n"
- title: o   network adapters, and
  contents:
  - 'o   network adapters, and

    '
- title: o   transmission networks between the nodes. Networks may be as simple
  contents:
  - "o   transmission networks between the nodes. Networks may be as simple\n    as\
    \ point-to-point links or as complex as switched networks such as\n    Frame Relay\
    \ and ATM networks.\n   During stream setup and modification, the LRM is presented\
    \ by the\n   setup protocol with the flow specification associated to the stream.\n\
    \   For each resource it handles, the LRM is expected to perform the\n   following\
    \ functions:\n"
- title: 'o   Stream Admission Control: it checks whether, given the flow'
  contents:
  - "o   Stream Admission Control: it checks whether, given the flow\n    specification,\
    \ there are sufficient resources left to handle the new\n    data stream. If the\
    \ available resources are insufficient, the new\n    data stream must be rejected.\n"
- title: 'o   QoS Computation: it calculates the best possible performance the'
  contents:
  - "o   QoS Computation: it calculates the best possible performance the\n    resource\
    \ can provide for the new data stream under the current\n    traffic conditions,\
    \ e.g., throughput and delay values are computed.\n"
- title: 'o   Resource Reservation: it reserves the resource capacities required'
  contents:
  - "o   Resource Reservation: it reserves the resource capacities required\n    to\
    \ meet the desired QoS.\n   During data transfer, the LRM is responsible for:\n"
- title: 'o   QoS Enforcement: it enforces the QoS requirements by appropriate'
  contents:
  - "o   QoS Enforcement: it enforces the QoS requirements by appropriate\n    scheduling\
    \ of resource access. For example, data packets from an\n    application with\
    \ a short guaranteed delay must be served prior to\n    data from an application\
    \ with a less strict delay bound.\n   The LRM may also provide the following additional\
    \ functions:\n"
- title: 'o   Data Regulation: to smooth a stream''s data traffic, e.g., as with the'
  contents:
  - "o   Data Regulation: to smooth a stream's data traffic, e.g., as with the\n \
    \   leaky bucket algorithm.\n"
- title: 'o   Policing: to prevent applications exceed their negotiated QoS, e.g.,'
  contents:
  - "o   Policing: to prevent applications exceed their negotiated QoS, e.g.,\n  \
    \  to send data at a higher rate than indicated in the flow\n    specification.\n"
- title: 'o   Stream Preemption: to free up resources for other streams with'
  contents:
  - "o   Stream Preemption: to free up resources for other streams with\n    higher\
    \ priority or importance.\n   The strategies adopted by the LRMs to handle resources\
    \ are resource-\n   dependent and may vary at every host/router. However, it is\
    \ necessary\n   that all LRMs have the same understanding of the flow specification.\n\
    \   The interface between setup protocol and LRM is a local matter at\n   every\
    \ host and therefore it is not specified by this document. An\n   example of LRM\
    \ is the Heidelberg Resource Administration Technique\n   (HeiRAT) [VoHN93].\n\
    \   It is also assumed that the LRM provides functions to compare flow\n   specifications,\
    \ i.e., to decide whether a flow specification requires\n   a greater, equal,\
    \ or smaller amount of resource capacities to be\n   reserved.\n"
- title: 1.5  ST2 Basic Concepts
  contents:
  - "1.5  ST2 Basic Concepts\n   The following sections present at an introductory\
    \ level some of the\n   fundamental ST2 concepts including streams, data transfer,\
    \ and flow\n   specification.\n            Hosts Connections...              \
    \  :      ...and Streams\n            ====================                :  \
    \    ==============\n        data       Origin                       :       \
    \   Origin\n       packets +-----------+                    :          +----+\n\
    \          +----|Application|                    :          |    |\n         \
    \ |    |-----------|                    :          +----+\n          +--->| ST\
    \ Agent  |                    :           |  |\n               +-----------+ \
    \                   :           |  |\n                     |                 \
    \         :           |  |\n                     V                          :\
    \           |  |\n              +-------------+                   :          \
    \ |  |\n              |             |                   :           |  |\n"
- title: '+-------------|  Network A  |                   :   +-------+  +--+'
  contents:
  - '+-------------|  Network A  |                   :   +-------+  +--+

    '
- title: '|             |             |                   :   |             |'
  contents:
  - '|             |             |                   :   |             |

    '
- title: '|             +-------------+                   :   |     Target 2|'
  contents:
  - '|             +-------------+                   :   |     Target 2|

    '
- title: '|                    |     Target 2             :   |     & Router|'
  contents:
  - '|                    |     Target 2             :   |     & Router|

    '
- title: '|     Target 1       |    and Router            :   |             |'
  contents:
  - '|     Target 1       |    and Router            :   |             |

    '
- title: '|  +-----------+     |  +-----------+           :   V             V'
  contents:
  - '|  +-----------+     |  +-----------+           :   V             V

    '
- title: '|  |Application|<-+  |  |Application|<-+        : +----+        +----+'
  contents:
  - '|  |Application|<-+  |  |Application|<-+        : +----+        +----+

    '
- title: '|  |-----------|  |  |  |-----------|  |        : |    |        |    |'
  contents:
  - '|  |-----------|  |  |  |-----------|  |        : |    |        |    |

    '
- title: '+->| ST Agent  |--+  +->| ST Agent  |--+        : +----+        +----+'
  contents:
  - "+->| ST Agent  |--+  +->| ST Agent  |--+        : +----+        +----+\n   +-----------+\
    \        +-----------+           :Target 1         |  |\n                    \
    \          |                 :                 |  |\n                        \
    \      V                 :                 |  |\n                    +-------------+\
    \             :                 |  |\n                    |             |    \
    \         :                 |  |\n      +-------------|  Network B  |        \
    \     :           +-----+  |\n      |             |             |            \
    \ :           |        |\n      |             +-------------+             :  \
    \         |        |\n      |    Target 3        |    Target 4        :      \
    \     |        |\n      |  +-----------+     |  +-----------+     :          \
    \ V        V\n      |  |Application|<-+  |  |Application|<-+  :         +----+\
    \ +----+\n      |  |-----------|  |  |  |-----------|  |  :         |    | | \
    \   |\n      +->| ST Agent  |--+  +->| ST Agent  |--+  :         +----+ +----+\n\
    \         +-----------+        +-----------+     :      Target 3 Target 4\n  \
    \                                              :\n                         Figure\
    \ 3: The Stream Concept\n"
- title: 1.5.1  Streams
  contents:
  - "1.5.1  Streams\n   Streams form the core concepts of ST2. They are established\
    \ between a\n   sending origin and one or more receiving targets in the form of\
    \ a\n   routing tree. Streams are uni-directional from the origin to the\n   targets.\
    \ Nodes in the tree represent so-called ST agents, entities\n   executing the\
    \ ST2 protocol; links in the tree are called hops. Any\n   node in the middle\
    \ of the tree is called an intermediate agent, or\n   router. An agent may have\
    \ any combination of origin, target, or\n   intermediate capabilities.\n   Figure\
    \ 3 illustrates a stream from an origin to four targets, where\n   the ST agent\
    \ on Target 2 also functions as an intermediate agent. Let\n   us use this Target\
    \ 2/Router node to explain some basic ST2\n   terminology: the direction of the\
    \ stream from this node to Target 3\n   and 4 is called downstream, the direction\
    \ towards the Origin node\n   upstream. ST agents that are one hop away from a\
    \ given node are\n   called previous-hops in the upstream, and next-hops in the\
    \ downstream\n   direction.\n   Streams are maintained using SCMP messages. Typical\
    \ SCMP messages are\n   CONNECT and ACCEPT to build a stream, DISCONNECT and REFUSE\
    \ to close\n   a stream, CHANGE to modify the quality of service associated with\
    \ a\n   stream, and JOIN to request to be added to a stream.\n   Each ST agent\
    \ maintains state information describing the streams\n   flowing through it. It\
    \ can actively gather and distribute such\n   information. It can recognize failed\
    \ neighbor ST agents through the\n   use of periodic HELLO message exchanges.\
    \ It can ask other ST agents\n   about a particular stream via a STATUS message.\
    \ These ST agents then\n   send back a STATUS-RESPONSE message. NOTIFY messages\
    \ can be used to\n   inform other ST agents of significant events.\n   ST2 offers\
    \ a wealth of functionalities for stream management. Streams\n   can be grouped\
    \ together to minimize allocated resources or to process\n   them in the same\
    \ way in case of failures. During audio conferences,\n   for example, only a limited\
    \ set of participants may talk at once.\n   Using the group mechanism, resources\
    \ for only a portion of the audio\n   streams of the group need to be reserved.\
    \ Using the same concept, an\n   entire group of related audio and video streams\
    \ can be dropped if one\n   of them is preempted.\n"
- title: 1.5.2  Data Transmission
  contents:
  - "1.5.2  Data Transmission\n   Data transfer in ST2 is simplex in the downstream\
    \ direction. Data\n   transport through streams is very simple. ST2 puts only\
    \ a small\n   header in front of the user data. The header contains a protocol\n\
    \   identification that distinguishes ST2 from IP packets, an ST2 version\n  \
    \ number, a priority field (specifying a relative importance of streams\n   in\
    \ cases of conflict), a length counter, a stream identification, and\n   a checksum.\
    \ These elements form a 12-byte header.\n   Efficiency is also achieved by avoiding\
    \ fragmentation and reassembly\n   on all agents. Stream establishment yields\
    \ a maximum message size for\n   data packets on a stream. This maximum message\
    \ size is communicated\n   to the upper layers, so that they provide data packets\
    \ of suitable\n   size to ST2.\n   Communication with multiple next-hops can be\
    \ made even more efficient\n   using MAC Layer multicast when it is available.\
    \ If a subnet supports\n   multicast, a single multicast packet is sufficient\
    \ to reach all\n   next-hops connected to this subnet. This leads to a significant\n\
    \   reduction of the bandwidth requirements of a stream. If multicast is\n   not\
    \ provided, separate packets need to be sent to each next-hop.\n   As ST2 relies\
    \ on reservation, it does not contain error correction\n   mechanisms features\
    \ for data exchange such as those found in TCP. It\n   is assumed that real-time\
    \ data, such as digital audio and video,\n   require partially correct delivery\
    \ only. In many cases, retransmitted\n   packets would arrive too late to meet\
    \ their real-time delivery\n   requirements. Also, depending on the data encoding\
    \ and the particular\n   application, a small number of errors in stream data\
    \ are acceptable.\n   In any case, reliability can be provided by layers on top\
    \ of ST2 when\n   needed.\n"
- title: 1.5.3  Flow Specification
  contents:
  - "1.5.3  Flow Specification\n   As part of establishing a connection, SCMP handles\
    \ the negotiation of\n   quality-of-service parameters for a stream. In ST2 terminology,\
    \ these\n   parameters form a flow specification (FlowSpec) which is associated\n\
    \   with the stream. Different versions of FlowSpecs exist, see\n   [RFC1190],\
    \ [DHHS92] and [RFC1363], and can be distinguished by a\n   version number.  Typically,\
    \ they contain parameters such as average\n   and maximum throughput, end-to-end\
    \ delay, and delay variance of a\n   stream. SCMP itself only provides the mechanism\
    \ for relaying the\n   quality-of-service parameters.\n   Three kinds of entities\
    \ participate in the quality-of-service\n   negotiation: application entities\
    \ on the origin and target sites as\n   the service users, ST agents, and local\
    \ resource managers (LRM). The\n   origin application supplies the initial FlowSpec\
    \ requesting a\n   particular service quality. Each ST agent which obtains the\
    \ FlowSpec\n   as part of a connection establishment message, it presents the\
    \ local\n   resource manager with it. ST2 does not determine how resource\n  \
    \ managers make reservations and how resources are scheduled according\n   to\
    \ these reservations; ST2, however, assumes these mechanisms as its\n   basis.\n\
    \   An example of the FlowSpec negotiation procedure is illustrated in\n   Figure\
    \ 4. Depending on the success of its local reservations, the LRM\n   updates the\
    \ FlowSpec fields and returns the FlowSpec to the ST agent,\n   which passes it\
    \ downstream as part of the connection message.\n   Eventually, the FlowSpec is\
    \ communicated to the application at the\n   target which may base its accept/reject\
    \ decision for establishing the\n   connection on it and may finally also modify\
    \ the FlowSpec. If a\n   target accepts the connection, the (possibly modified)\
    \ FlowSpec is\n   propagated back to the origin which can then calculate an overall\n\
    \   service quality for all targets. The application entity at the origin\n  \
    \ may later request a CHANGE to adjust reservations.\n                 Origin\
    \                 Router               Target 1\n                +------+    \
    \  1a       +------+      1b      +------+\n                |      |-------------->|\
    \      |------------->|      |\n                +------+               +------+\
    \              +------+\n                 ^  | ^                             \
    \             |\n                 |  | |                    2                \
    \     |\n                 |  | +------------------------------------------+\n\
    \                 +  +\n +-------------+  \\  \\             +-------------+ \
    \      +-------------+\n |Max Delay: 12|   \\  \\            |Max Delay: 12| \
    \      |Max Delay: 12|\n |-------------|    \\  \\           |-------------| \
    \      |-------------|\n |Min Delay:  2|     \\  \\          |Min Delay:  5| \
    \      |Min Delay:  9|\n |-------------|      \\  \\         |-------------| \
    \      |-------------|\n |Max Size:4096|       +  +        |Max Size:2048|   \
    \    |Max Size:2048|\n +-------------+       |  |        +-------------+     \
    \  +-------------+\n    FlowSpec           |  | 1\n                       |  +---------------+\n\
    \                       |                  |\n                       |       \
    \           V\n                     2 |               +------+\n             \
    \          +---------------|      |\n                                       +------+\n\
    \                                       Target 2\n                           \
    \        +-------------+\n                                   |Max Delay: 12|\n\
    \                                   |-------------|\n                        \
    \           |Min Delay:  4|\n                                   |-------------|\n\
    \                                   |Max Size:4096|\n                        \
    \           +-------------+\n        Figure 4:  Quality-of-Service Negotiation\
    \ with FlowSpecs\n"
- title: 1.6  Outline of This Document
  contents:
  - "1.6  Outline of This Document\n   This document contains the specification of\
    \ the ST2+ version of the\n   ST2 protocol. In the rest of the document, whenever\
    \ the terms \"ST\" or\n   \"ST2\" are used, they refer to the ST2+ version of\
    \ ST2.\n   The document is organized as follows:\n"
- title: o   Section 2 describes the ST2 user service from an application point
  contents:
  - "o   Section 2 describes the ST2 user service from an application point\n    of\
    \ view.\n"
- title: o   Section 3 illustrates the ST2 data transfer protocol, ST.
  contents:
  - 'o   Section 3 illustrates the ST2 data transfer protocol, ST.

    '
- title: o   Section 4 through Section 8 specify the ST2 setup protocol, SCMP.
  contents:
  - 'o   Section 4 through Section 8 specify the ST2 setup protocol, SCMP.

    '
- title: o   the ST2 flow specification is presented in Section 9.
  contents:
  - 'o   the ST2 flow specification is presented in Section 9.

    '
- title: o   the formats of protocol elements and PDUs are defined in Section 10.
  contents:
  - 'o   the formats of protocol elements and PDUs are defined in Section 10.

    '
- title: 2.  ST2 User Service Description
  contents:
  - "2.  ST2 User Service Description\n   This section describes the ST user service\
    \ from the high-level point\n   of view of an application. It defines the ST stream\
    \ operations and\n   primitive functions. It specifies which operations on streams\
    \ can be\n   invoked by the applications built on top of ST and when the ST\n\
    \   primitive functions can be legally executed. Note that the presented\n   ST\
    \ primitives do not specify an API. They are used here with the only\n   purpose\
    \ of illustrating the service model for ST.\n"
- title: 2.1  Stream Operations and Primitive Functions
  contents:
  - "2.1  Stream Operations and Primitive Functions\n   An ST application at the origin\
    \ may create, expand, reduce, change,\n   send data to, and delete a stream. When\
    \ a stream is expanded, new\n   targets are added to the stream; when a stream\
    \ is reduced, some of\n   the current targets are dropped from it. When a stream\
    \ is changed,\n   the associated quality of service is modified.\n   An ST application\
    \ at the target may join, receive data from, and\n   leave a stream. This translates\
    \ into the following stream operations:\n"
- title: 'o   OPEN: create new stream [origin], CLOSE: delete stream [origin],'
  contents:
  - 'o   OPEN: create new stream [origin], CLOSE: delete stream [origin],

    '
- title: 'o   ADD: expand stream, i.e., add new targets to it [origin],'
  contents:
  - 'o   ADD: expand stream, i.e., add new targets to it [origin],

    '
- title: 'o   DROP: reduce stream, i.e., drop targets from it [origin],'
  contents:
  - 'o   DROP: reduce stream, i.e., drop targets from it [origin],

    '
- title: 'o   JOIN: join a stream [target], LEAVE: leave a stream [target],'
  contents:
  - 'o   JOIN: join a stream [target], LEAVE: leave a stream [target],

    '
- title: 'o   DATA: send data through stream [origin],'
  contents:
  - 'o   DATA: send data through stream [origin],

    '
- title: 'o   CHG: change a stream''s QoS [origin],'
  contents:
  - "o   CHG: change a stream's QoS [origin],\n   Each stream operation may require\
    \ the execution of several primitive\n   functions to be completed. For instance,\
    \ to open a new stream, a\n   request is first issued by the sender and an indication\
    \ is generated\n   at one or more receivers; then, the receivers may each accept\
    \ or\n   refuse the request and the correspondent indications are generated at\n\
    \   the sender. A single receiver case is shown in Figure 5 below.\n         \
    \       Sender             Network             Receiver\n                  | \
    \                  |                   |\n     OPEN.req     |                \
    \   |                   |\n                  |-----------------> |           \
    \        |\n                  |                   |-----------------> |\n    \
    \              |                   |                   | OPEN.ind\n          \
    \        |                   |                   | OPEN.accept\n             \
    \     |                   |<----------------- |\n                  |<-----------------\
    \ |                   |\n  OPEN.accept-ind |                   |             \
    \      |\n                  |                   |                   |\n      \
    \     Figure 5: Primitives for the OPEN Stream Operation\n   Table 1 defines the\
    \ ST service primitive functions associated to each\n   stream operation. The\
    \ column labelled \"O/T\" indicates whether the\n   primitive is executed at the\
    \ origin or at the target.\n           +===================================================+\n\
    \           |Primitive      | Descriptive                   |O/T|\n          \
    \ |===================================================|\n           |OPEN.req\
    \       | open a stream                 | O |\n           |OPEN.ind       | connection\
    \ request indication | T |\n           |OPEN.accept    | accept stream       \
    \          | T |\n           |OPEN.refuse    | refuse stream                 |\
    \ T |\n           |OPEN.accept-ind| connection accept indication  | O |\n    \
    \       |OPEN.refuse-ind| connection refuse indication  | O |\n           |ADD.req\
    \        | add targets to stream         | O |\n           |ADD.ind        | add\
    \ request indication        | T |\n           |ADD.accept     | accept stream\
    \                 | T |\n           |ADD.refuse     | refuse stream          \
    \       | T |\n           |ADD.accept-ind | add accept indication         | O\
    \ |\n           |ADD.refuse-ind | add refuse indication         | O |\n      \
    \     |JOIN.req       | join a stream                 | T |\n           |JOIN.ind\
    \       | join request indication       | O |\n           |JOIN.reject    | reject\
    \ a join                 | O |\n           |JOIN.reject-ind| join reject indication\
    \        | T |\n           |DATA.req       | send data                     | O\
    \ |\n           |DATA.ind       | receive data indication       | T |\n      \
    \     |CHG.req        | change stream QoS             | O |\n           |CHG.ind\
    \        | change request indication     | T |\n           |CHG.accept     | accept\
    \ change                 | T |\n           |CHG.refuse     | refuse change   \
    \              | T |\n           |CHG.accept-ind | change accept indication  \
    \    | O |\n           |CHG.refuse-ind | change refuse indication      | O |\n\
    \           |DROP.req       | drop targets                  | O |\n          \
    \ |DROP.ind       | disconnect indication         | T |\n           |LEAVE.req\
    \      | leave stream                  | T |\n           |LEAVE.ind      | leave\
    \ stream indication       | O |\n           |CLOSE.req      | close stream   \
    \               | O |\n           |CLOSE.ind      | close stream indication  \
    \     | T |\n           +---------------------------------------------------+\n\
    \                              Table 1: ST Primitives\n"
- title: 2.2  State Diagrams
  contents:
  - "2.2  State Diagrams\n   It is not sufficient to define the set of ST stream operations.\
    \ It is\n   also necessary to specify when the operations can be legally\n   executed.\
    \  For this reason, a set of states is now introduced and the\n   transitions\
    \ from one state to the others are specified. States are\n   defined with respect\
    \ to a single stream. The previously defined\n   stream operations can be legally\
    \ executed only from an appropriate\n   state.\n   An ST agent may, with respect\
    \ to an ST stream, be in one of the\n   following states:\n"
- title: 'o   IDLE: the stream has not been created yet.'
  contents:
  - 'o   IDLE: the stream has not been created yet.

    '
- title: 'o   PENDING: the stream is in the process of being established.'
  contents:
  - 'o   PENDING: the stream is in the process of being established.

    '
- title: 'o   ACTIVE: the stream is established and active.'
  contents:
  - 'o   ACTIVE: the stream is established and active.

    '
- title: 'o   ADDING: the stream is established. A stream expansion is underway.'
  contents:
  - 'o   ADDING: the stream is established. A stream expansion is underway.

    '
- title: 'o   CHGING: the stream is established. A stream change is underway.'
  contents:
  - "o   CHGING: the stream is established. A stream change is underway.\n   Previous\
    \ experience with ST has lead to limits on stream operations\n   that can be executed\
    \ simultaneously. These restrictions are:\n   1.  A single ADD or CHG operation\
    \ can be processed at one time. If\n       an ADD or CHG is already underway,\
    \ further requests are queued\n       by the ST agent and handled only after the\
    \ previous operation\n       has been completed. This also applies to two subsequent\n\
    \       requests of the same kind, e.g., two ADD or two CHG operations.\n    \
    \   The second operation is not executed until the first one has\n       been\
    \ completed.\n   2.  Deleting a stream, leaving a stream, or dropping targets\
    \ from a\n       stream is possible only after stream establishment has been\n\
    \       completed. A stream is considered to be established when all\n       the\
    \ next-hops of the origin have either accepted or refused the\n       stream.\
    \  Note that stream refuse is automatically forced after\n       timeout if no\
    \ reply comes from a next-hop.\n   3.  An ST agent forwards data only along already\
    \ established paths\n       to the targets, see also Section 3.1. A path is considered\
    \ to\n       be established when the next-hop on the path has explicitly\n   \
    \    accepted the stream. This implies that the target and all other\n       intermediate\
    \ ST agents are ready to handle the incoming data\n       packets. In no cases\
    \ an ST agent will forward data to a\n       next-hop ST agent that has not explicitly\
    \ accepted the stream.\n       To be sure that all targets receive the data, an\
    \ application\n       should send the data only after all paths have been\n  \
    \     established, i.e., the stream is established.\n   4.  It is allowed to send\
    \ data from the CHGING and ADDING states.\n       While sending data from the\
    \ CHGING state, the quality of\n       service to the targets affected by the\
    \ change should be assumed\n       to be the more restrictive quality of service.\
    \ When sending\n       data from the ADDING state, the targets that receive the\
    \ data\n       include at least all the targets that were already part of the\n\
    \       stream at the time the ADD operation was invoked.\n   The rules introduced\
    \ above require ST agents to queue incoming\n   requests when the current state\
    \ does not allow to process them\n   immediately. In order to preserve the semantics,\
    \ ST agents have to\n   maintain the order of the requests, i.e., implement FIFO\
    \ queuing.\n   Exceptionally, the CLOSE request at the origin and the LEAVE request\n\
    \   at the target may be immediately processed: in these cases, the queue\n  \
    \ is deleted and it is possible that requests in the queue are not\n   processed.\n\
    \   The following state diagrams define the ST service. Separate diagrams\n  \
    \ are presented for the origin and the targets.\n   The symbol (a/r)* indicates\
    \ that all targets in the target list have\n   explicitly accepted or refused\
    \ the stream, or refuse has been forced\n   after timeout. If the target list\
    \ is empty, i.e., it contains no\n   targets, the (a/r)* condition is immediately\
    \ satisfied, so the empty\n   stream is created and state ESTBL is entered.\n\
    \   The separate OPEN and ADD primitives at the target are for conceptual\n  \
    \ purposes only. The target is actually unable to distinguish between\n   an OPEN\
    \ and an ADD. This is reflected in Figure 7 and Table 3 through\n   the notation\
    \ OPEN/ADD.\n                        +------------+\n                        |\
    \            |<-------------------+\n            +---------->|    IDLE    |-------------+\
    \      |\n            |           |            |    OPEN.req |      |\n      \
    \      |           +------------+             |      |\n CLOSE.req  |      CLOSE.req\
    \ ^   ^ CLOSE.req       V      | CLOSE.req\n            |                |   |\
    \            +---------+ |\n            |                |   |            | PENDING\
    \ |-|-+ JOIN.reject\n            |                |   -------------|         |<|-+\n\
    \            |    JOIN.reject |                +---------+ |\n            |  \
    \  DROP.req +----------+             |      |\n            |       +-----|   \
    \       |             |      |\n            |       |     |  ESTDL   | OPEN.(a/r)*\
    \ |      |\n            |       +---->|          |<------------+      |\n    \
    \        |             +----------+                    |\n            |      \
    \        |  ^  |  ^                     |\n            |              |  |  |\
    \  |                     |\n       +----------+ CHG.req|  |  |  | Add.(a/r)* \
    \   +----------+\n       |          |<-------+  |  |  +-------------- |      \
    \    |\n       |  CHGING  |           |  |                  |  ADDING  |\n   \
    \    |          |-----------+  +----------------->|          |\n       +----------+\
    \ CHG.(a/r)*         JOIN.ind     +----------+\n           |   ^             \
    \            ADD.req        |   ^\n           |   |                          \
    \              |   |\n           +---+                                       \
    \ +---+\n           DROP.req                                    DROP.req\n   \
    \        JOIN.reject                                 JOIN.reject\n           \
    \       Figure 6: ST Service at the Origin\n                 +--------+\n    \
    \             |        |-----------------------+\n                 |  IDLE  |\
    \                       |\n                 |        |<---+                  |\
    \ OPEN/ADD.ind\n                 +--------+    | CLOSE.ind        | JOIN.req\n\
    \                     ^         | OPEN/ADD.refuse  |\n                     | \
    \        | JOIN.refect-ind  |\n         CLOSE.ind   |         |              \
    \    V\n         DROP.ind    |         |             +---------+\n         LEAVE.req\
    \   |         +-------------|         |\n                     |              \
    \         | PENDING |\n                 +-------+                   |        \
    \ |\n                 |       |                   +---------+\n              \
    \   | ESTBL |    OPEN/ADD.accept     |\n                 |       |<-----------------------+\n\
    \                 +-------+\n                     Figure 7: ST Service at the\
    \ Target\n"
- title: 2.3  State Transition Tables
  contents:
  - "2.3  State Transition Tables\n   Table 2 and Table 3 define which primitives\
    \ can be processed from\n   which states and the possible state transitions.\n"
- title: +======================================================================+
  contents:
  - '+======================================================================+

    '
- title: '|Primitive      |IDLE|    PENDING    |  ESTBL |    CHGING  |    ADDING |'
  contents:
  - '|Primitive      |IDLE|    PENDING    |  ESTBL |    CHGING  |    ADDING |

    '
- title: '|======================================================================|'
  contents:
  - '|======================================================================|

    '
- title: '|OPEN.req       | ok | -             | -      | -          | -         |'
  contents:
  - '|OPEN.req       | ok | -             | -      | -          | -         |

    '
- title: '|OPEN.accept-ind| -  |if(a,r)*->ESTBL| -      | -          | -         |'
  contents:
  - '|OPEN.accept-ind| -  |if(a,r)*->ESTBL| -      | -          | -         |

    '
- title: '|OPEN.refuse-ind| -  |if(a,r)*->ESTBL| -      | -          | -         |'
  contents:
  - '|OPEN.refuse-ind| -  |if(a,r)*->ESTBL| -      | -          | -         |

    '
- title: '|ADD.req        | -  | queued        |->ADDING| queued     | queued    |'
  contents:
  - '|ADD.req        | -  | queued        |->ADDING| queued     | queued    |

    '
- title: '|ADD.accept-ind | -  | -             | -      | -          |if(a,r)*   |'
  contents:
  - '|ADD.accept-ind | -  | -             | -      | -          |if(a,r)*   |

    '
- title: '|               | -  | -             | -      | -          |->ESTBL    |'
  contents:
  - '|               | -  | -             | -      | -          |->ESTBL    |

    '
- title: '|ADD.refuse-ind | -  | -             | -      | -          |if(a,r)*   |'
  contents:
  - '|ADD.refuse-ind | -  | -             | -      | -          |if(a,r)*   |

    '
- title: '|               | -  | -             | -      | -          |->ESTBL    |'
  contents:
  - '|               | -  | -             | -      | -          |->ESTBL    |

    '
- title: '|JOIN.ind       | -  | queued        |->ADDING| queued     |queued     |'
  contents:
  - '|JOIN.ind       | -  | queued        |->ADDING| queued     |queued     |

    '
- title: '|JOIN.reject    | -  | OK            | ok     | ok         | ok        |'
  contents:
  - '|JOIN.reject    | -  | OK            | ok     | ok         | ok        |

    '
- title: '|DATA.req       | -  | -             | ok     | ok         | ok        |'
  contents:
  - '|DATA.req       | -  | -             | ok     | ok         | ok        |

    '
- title: '|CHG.req        | -  | queued        |->CHGING| queued     |queued     |'
  contents:
  - '|CHG.req        | -  | queued        |->CHGING| queued     |queued     |

    '
- title: '|CHG.accept-ind | -  | -             | -      |if(a,r)*    | -         |'
  contents:
  - '|CHG.accept-ind | -  | -             | -      |if(a,r)*    | -         |

    '
- title: '|               | -  | -             | -      |->ESTBL     | -         |'
  contents:
  - '|               | -  | -             | -      |->ESTBL     | -         |

    '
- title: '|CHG.refuse.ind | -  | -             | -      |if(a,r)*    | -         |'
  contents:
  - '|CHG.refuse.ind | -  | -             | -      |if(a,r)*    | -         |

    '
- title: '|               | -  | -             | -      |->ESTBL     | -         |'
  contents:
  - '|               | -  | -             | -      |->ESTBL     | -         |

    '
- title: '|DROP.req       | -  | -             | ok     | ok         | ok        |'
  contents:
  - '|DROP.req       | -  | -             | ok     | ok         | ok        |

    '
- title: '|LEAVE.ind      | -  | OK            | ok     | ok         | ok        |'
  contents:
  - '|LEAVE.ind      | -  | OK            | ok     | ok         | ok        |

    '
- title: '|CLOSE.req      | -  | OK            | ok     | ok         | ok        |'
  contents:
  - '|CLOSE.req      | -  | OK            | ok     | ok         | ok        |

    '
- title: +----------------------------------------------------------------------+
  contents:
  - "+----------------------------------------------------------------------+\n  \
    \              Table 2: Primitives and States at the Origin\n             +======================================================+\n\
    \             | Primitive       |   IDLE    |  PENDING   |   ESTBL   |\n     \
    \        |======================================================|\n          \
    \   | OPEN/ADD.ind    | ->PENDING | -          | -         |\n             | OPEN/ADD.accept\
    \ | -         | ->ESTBL    | -         |\n             | OPEN/ADD.refuse | - \
    \        | ->IDLE     | -         |\n             | JOIN.req        | ->PENDING\
    \ | -          | -         |\n             | JOIN.reject-ind |-          | ->IDLE\
    \     | -         |\n             | DATA.ind        | -         | -          |\
    \ ok        |\n             | CHG.ind         | -         | -          | ok  \
    \      |\n             | CHG.accept      | -         | -          | ok       \
    \ |\n             | DROP.ind        | -         | ok         | ok        |\n \
    \            | LEAVE.req       | -         | ok         | ok        |\n      \
    \       | CLOSE.ind       | -         | ok         | ok        |\n           \
    \  | CHG.ind         | -         | -          | ok        |\n             +------------------------------------------------------+\n\
    \                Table 3: Primitives and States at the Target\n"
- title: 3.  The ST2 Data Transfer Protocol
  contents:
  - "3.  The ST2 Data Transfer Protocol\n   This section presents the ST2 data transfer\
    \ protocol, ST. First, data\n   transfer is described in Section 3.1, then, the\
    \ data transfer\n   protocol functions are illustrated in Section 3.2.\n"
- title: 3.1  Data Transfer with ST
  contents:
  - "3.1  Data Transfer with ST\n   Data transmission with ST is unreliable. An application\
    \ is not\n   guaranteed that the data reaches its destinations and ST makes no\n\
    \   attempts to recover from packet loss, e.g., due to the underlying\n   network.\
    \ However, if the data reaches its destination, it should do\n   so according\
    \ to the quality of service associated with the stream.\n   Additionally, ST may\
    \ deliver data corrupted in transmission. Many\n   types of real-time data, such\
    \ as digital audio and video, require\n   partially correct delivery only. In\
    \ many cases, retransmitted packets\n   would arrive too late to meet their real-time\
    \ delivery requirements.\n   On the other hand, depending on the data encoding\
    \ and the particular\n   application, a small number of errors in stream data\
    \ are acceptable.\n   In any case, reliability can be provided by layers on top\
    \ of ST2 if\n   needed.\n   Also, no data fragmentation is supported during the\
    \ data transfer\n   phase. The application is expected to segment its data PDUs\
    \ according\n   to the minimum MTU over all paths in the stream. The application\n\
    \   receives information on the MTUs relative to the paths to the targets\n  \
    \ as part of the ACCEPT message, see Section 8.6. The minimum MTU over\n   all\
    \ paths can be calculated from the MTUs relative to the single\n   paths. ST agents\
    \ silently discard too long data packets, see also\n   Section 5.1.1.\n   An ST\
    \ agent forwards the data only along already established paths to\n   targets.\
    \ A path is considered to be established once the next-hop ST\n   agent on the\
    \ path sends an ACCEPT message, see Section 2.2. This\n   implies that the target\
    \ and all other intermediate ST agents on the\n   path to the target are ready\
    \ to handle the incoming data packets. In\n   no cases will an ST agent forward\
    \ data to a next-hop ST agent that\n   has not explicitly accepted the stream.\n\
    \   To be reasonably sure that all targets receive the data with the\n   desired\
    \ quality of service, an application should send the data only\n   after the whole\
    \ stream has been established. Depending on the local\n   API, an application\
    \ may not be prevented from sending data before the\n   completion of stream setup,\
    \ but it should be aware that the data\n   could be lost or not reach all intended\
    \ targets. This behavior may\n   actually be desirable to applications, such as\
    \ those application that\n   have multiple targets which can each process data\
    \ as soon as it is\n   available (e.g., a lecture or distributed gaming).\n  \
    \ It is desirable for implementations to take advantage of networks\n   that support\
    \ multicast. If a network does not support multicast, or\n   for the case where\
    \ the next-hops are on different networks, multiple\n   copies of the data packet\
    \ must be sent.\n"
- title: 3.2  ST Protocol Functions
  contents:
  - "3.2  ST Protocol Functions\n   The ST protocol provides two functions:\n   o\
    \   stream identification\n   o   data priority\n"
- title: 3.2.1  Stream Identification
  contents:
  - "3.2.1  Stream Identification\n   ST data packets are encapsulated by an ST header\
    \ containing the\n   Stream IDentifier (SID). This SID is selected at the origin\
    \ so that\n   it is globally unique over the Internet. The SID must be known by\
    \ the\n   setup protocol as well. At stream establishment time, the setup\n  \
    \ protocol builds, at each agent traversed by the stream, an entry into\n   its\
    \ local database containing stream information. The SID can be used\n   as a reference\
    \ into this database, to obtain quickly the necessary\n   replication and forwarding\
    \ information.\n   Stream IDentifiers are intended to be used to make the packet\n\
    \   forwarding task most efficient. The time-critical operation is an\n   intermediate\
    \ ST agent receiving a packet from the previous-hop ST\n   agent and forwarding\
    \ it to the next-hop ST agents.\n   The format of data PDUs including the SID\
    \ is defined in Section 10.1.\n   Stream IDentifier generation is discussed in\
    \ Section 8.1.\n"
- title: 3.2.2  Packet Discarding based on Data Priority
  contents:
  - "3.2.2  Packet Discarding based on Data Priority\n   ST provides a well defined\
    \ quality of service to its applications.\n   However, there may be cases where\
    \ the network is temporarily\n   congested and the ST agents have to discard certain\
    \ packets to\n   minimize the overall impact to other streams. The ST protocol\n\
    \   provides a mechanism to discard data packets based on the Priority\n   field\
    \ in the data PDU, see Section 10.1. The application assigns each\n   data packet\
    \ with a discard-priority level, carried into the Priority\n   field. ST agents\
    \ will attempt to discard lower priority packets first\n   during periods of network\
    \ congestion. Applications may choose to send\n   data at multiple priority levels\
    \ so that less important data may be\n   discarded first.\n"
- title: 4.  SCMP Functional Description
  contents:
  - "4.  SCMP Functional Description\n   ST agents create and manage streams using\
    \ the ST Control Message\n   Protocol (SCMP). Conceptually, SCMP resides immediately\
    \ above ST (as\n   does ICMP above IP). SCMP follows a request-response model.\
    \ SCMP\n   messages are made reliable through the use of retransmission after\n\
    \   timeout.\n   This section contains a functional description of stream management\n\
    \   with SCMP. To help clarify the SCMP exchanges used to setup and\n   maintain\
    \ ST streams, we include an example of a simple network\n   topology, represented\
    \ in Figure 8. Using the SCMP messages described\n   in this section it will be\
    \ possible for an ST application to:\n   o   Create a stream from A to the peers\
    \ at B, C and D,\n   o   Add a peer at E,\n   o   Drop peers B and C, and\n  \
    \ o   Let F join the stream\n   o   Delete the stream.\n                     \
    \                          +---------+    +---+\n                            \
    \                   |         |----| B |\n               +---------+      +----------+\
    \   |         |    +---+\n               |         |------| Router 1 |---| Subnet2\
    \ |\n               |         |      +----------+   |         |\n            \
    \   |         |                     |         |\n               |         |  \
    \                   +---------+\n               |         |                  \
    \       |\n               | Subnet1 |                         |\n            \
    \   |         |                     +----------+\n               |         | \
    \                    | Router 3 |\n       +---+   |         |                \
    \     +----------+\n       | A |---|         |    +----------+           |\n \
    \      +---+   |         |----| Router 2 |           |\n               |     \
    \    |    +----------+           |\n               +---------+         |     \
    \            |\n                                   |                 |\n     \
    \                              |          +----------+    +---+\n            \
    \                       +----------|          |----| C |\n                   \
    \                           |          |    +---+\n                         +---------+\
    \          |  Subnet3 |\n                 +---+   |         |   +---+  |     \
    \     |    +---+\n                 | F |---| Subnet4 |---| E |--|          |----|\
    \ D |\n                 +---+   |         |   +---+  +----------+    +---+\n \
    \                        +---------+\n                Figure 8:  Sample Topology\
    \ for an ST Stream\n   We first describe the possible types of stream in Section\
    \ 4.1;\n   Section 4.2 introduces SCMP control message types; SCMP reliability\n\
    \   is discussed in Section 4.3; stream options are covered in Section\n   4.4;\
    \ stream setup is presented in Section 4.5; Section 4.6\n   illustrates stream\
    \ modification including stream expansion,\n   reduction, changes of the quality\
    \ of service associated to a stream.\n   Finally, stream deletion is handled in\
    \ Section 4.7.\n"
- title: 4.1  Types of Streams
  contents:
  - "4.1  Types of Streams\n   SCMP allows for the setup and management of different\
    \ types of\n   streams. Streams differ in the way they are built and the information\n\
    \   maintained on connected targets.\n"
- title: 4.1.1  Stream Building
  contents:
  - "4.1.1  Stream Building\n   Streams may be built in a sender-oriented fashion,\
    \ receiver-oriented\n   fashion, or with a mixed approach:\n"
- title: o   in the sender-oriented fashion, the application at the origin
  contents:
  - "o   in the sender-oriented fashion, the application at the origin\n    provides\
    \ the ST agent with the list of receivers for the stream. New\n    targets, if\
    \ any, are also added from the origin.\n"
- title: o   in the receiver-oriented approach, the application at the origin
  contents:
  - "o   in the receiver-oriented approach, the application at the origin\n    creates\
    \ an empty stream that contains no targets. Each target then\n    joins the stream\
    \ autonomously.\n"
- title: o   in the mixed approach, the application at the origin creates a
  contents:
  - "o   in the mixed approach, the application at the origin creates a\n    stream\
    \ that contains some targets and other targets join the stream\n    autonomously.\n\
    \   ST2 provides stream options to support sender-oriented and mixed\n   approach\
    \ steams. Receiver-oriented streams can be emulated through\n   the use of mixed\
    \ streams. The fashion by which targets may be added\n   to a particular stream\
    \ is controlled via join authorization levels.\n   Join authorization levels are\
    \ described in Section 4.4.2.\n"
- title: 4.1.2  Knowledge of Receivers
  contents:
  - "4.1.2  Knowledge of Receivers\n   When streams are built in the sender-oriented\
    \ fashion, all ST agents\n   will have full information on all targets down stream\
    \ of a particular\n   agent. In this case, target information is relayed down\
    \ stream from\n   agent-to-agent during stream set-up.\n   When targets add themselves\
    \ to mixed approach streams, upstream ST\n   agents may or may not be informed.\
    \ Propagation of information on\n   targets that \"join\" a stream is also controlled\
    \ via join\n   authorization levels. As previously mentioned, join authorization\n\
    \   levels are described in Section 4.4.2.\n   This leads to two types of streams:\n"
- title: o   full target information is propagated in a full-state stream. For
  contents:
  - "o   full target information is propagated in a full-state stream. For\n    such\
    \ streams, all agents are aware of all downstream targets\n    connected to the\
    \ stream. This results in target information being\n    maintained at the origin\
    \ and at intermediate agents. Operations on\n    single targets are always possible,\
    \ i.e., change a certain target,\n    or, drop that target from the stream. It\
    \ is also always possible for\n    any ST agent to attempt recovery of all downstream\
    \ targets.\n"
- title: o   in light-weight streams, it is possible that the origin and other
  contents:
  - "o   in light-weight streams, it is possible that the origin and other\n    upstream\
    \ agents have no knowledge about some targets. This results\n    in less maintained\
    \ state and easier stream management, but it limits\n    operations on specific\
    \ targets. Special actions may be required to\n    support change and drop operations\
    \ on unknown targets, see Section\n    5.7. Also, stream recovery may not be possible.\
    \ Of course, generic\n    functions such as deleting the whole stream, are still\
    \ possible. It\n    is expected that applications that will have a large number\
    \ of\n    targets will use light-weight streams in order to limit state in\n \
    \   agents and the number of targets per control message.\n   Full-state streams\
    \ serve well applications as video conferencing or\n   distributed gaming, where\
    \ it is important to have knowledge on the\n   connected receivers, e.g., to limit\
    \ who participates. Light-weight\n   streams may be exploited by applications\
    \ such as remote lecturing or\n   playback applications of radio and TV broadcast\
    \ where the receivers\n   do not need to be known by the sender. Section 4.4.2\
    \ defines join\n   authorization levels, which support two types of full-state\
    \ streams\n   and one type of light-weight stream.\n"
- title: 4.2  Control PDUs
  contents:
  - "4.2  Control PDUs\n   SCMP defines the following PDUs (the main purpose of each\
    \ PDU is also\n   indicated):\n"
- title: 1.      ACCEPT          to accept a new stream
  contents:
  - '1.      ACCEPT          to accept a new stream

    '
- title: 2.      ACK             to acknowledge an incoming message
  contents:
  - '2.      ACK             to acknowledge an incoming message

    '
- title: 3.      CHANGE          to change the quality of service associated with
  contents:
  - "3.      CHANGE          to change the quality of service associated with\n  \
    \                              a stream\n"
- title: 4.      CONNECT         to establish a new stream or add new targets to
  contents:
  - "4.      CONNECT         to establish a new stream or add new targets to\n   \
    \                             an existing stream\n"
- title: 5.      DISCONNECT      to remove some or all of the stream's targets
  contents:
  - '5.      DISCONNECT      to remove some or all of the stream''s targets

    '
- title: 6.      ERROR           to indicate an error contained in an incoming
  contents:
  - "6.      ERROR           to indicate an error contained in an incoming\n     \
    \                           message\n"
- title: 7.      HELLO           to detect failures of neighbor ST agents
  contents:
  - '7.      HELLO           to detect failures of neighbor ST agents

    '
- title: 8.      JOIN            to request stream joining from a target
  contents:
  - '8.      JOIN            to request stream joining from a target

    '
- title: 9.      JOIN-REJECT     to reject a stream joining request from a target
  contents:
  - '9.      JOIN-REJECT     to reject a stream joining request from a target

    '
- title: 10.     NOTIFY          to inform an ST agent of a significant event
  contents:
  - '10.     NOTIFY          to inform an ST agent of a significant event

    '
- title: 11.     REFUSE          to refuse the establishment of a new stream
  contents:
  - '11.     REFUSE          to refuse the establishment of a new stream

    '
- title: 12.     STATUS          to query an ST agent on a specific stream
  contents:
  - '12.     STATUS          to query an ST agent on a specific stream

    '
- title: 13.     STATUS-RESPONSE to reply queries on a specific stream
  contents:
  - "13.     STATUS-RESPONSE to reply queries on a specific stream\n   SCMP follows\
    \ a request-response model with all requests expecting\n   responses. Retransmission\
    \ after timeout is used to allow for lost or\n   ignored messages. Control messages\
    \ do not extend across packet\n   boundaries; if a control message is too large\
    \ for the MTU of a hop,\n   its information is partitioned and a control message\
    \ per partition is\n   sent, as described in Section 5.1.2.\n   CONNECT and CHANGE\
    \ request messages are answered with ACCEPT messages\n   which indicate success,\
    \ and with REFUSE messages which indicate\n   failure. JOIN messages are answered\
    \ with either a CONNECT message\n   indicating success, or with a JOIN-REJECT\
    \ message indicating failure.\n   Targets may be removed from a stream by either\
    \ the origin or the\n   target via the DISCONNECT and REFUSE messages.\n   The\
    \ ACCEPT, CHANGE, CONNECT, DISCONNECT, JOIN, JOIN-REJECT, NOTIFY\n   and REFUSE\
    \ messages must always be explicitly acknowledged:\n"
- title: o   with an ACK message, if the message was received correctly and it
  contents:
  - "o   with an ACK message, if the message was received correctly and it\n    was\
    \ possible to parse and correctly extract and interpret its\n    header, fields\
    \ and parameters,\n"
- title: o   with an ERROR message, if a syntax error was detected in the header,
  contents:
  - "o   with an ERROR message, if a syntax error was detected in the header,\n  \
    \  fields, or parameters included in the message. The errored PDU may\n    be\
    \ optionally returned as part of the ERROR message. An ERROR\n    message indicates\
    \ a syntax error only. If any other errors are\n    detected, it is necessary\
    \ to first acknowledge with ACK and then\n    take appropriate actions. For instance,\
    \ suppose a CHANGE message\n    contains an unknown SID: first, an ACK message\
    \ has to be sent, then\n    a REFUSE message with ReasonCode (SIDUnknown) follows.\n\
    \   If no ACK or ERROR message are received before the correspondent\n   timer\
    \ expires, a timeout failure occurs. The way an ST agent should\n   handle timeout\
    \ failures is described in Section 5.2.\n   ACK, ERROR, and STATUS-RESPONSE messages\
    \ are never acknowledged.\n   HELLO messages are a special case. If they contain\
    \ a syntax error, an\n   ERROR message should be generated in response. Otherwise,\
    \ no\n   acknowledgment or response should be generated. Use of HELLO messages\n\
    \   is discussed in Section 6.1.2.\n   STATUS messages containing a syntax error\
    \ should be answered with an\n   ERROR message. Otherwise, a STATUS-RESPONSE message\
    \ should be sent\n   back in response. Use of STATUS and STATUS-RESPONSE are discussed\
    \ in\n   Section 8.4.\n"
- title: 4.3  SCMP Reliability
  contents:
  - "4.3  SCMP Reliability\n   SCMP is made reliable through the use of retransmission\
    \ when a\n   response is not received in a timely manner. The ACCEPT, CHANGE,\n\
    \   CONNECT, DISCONNECT, JOIN, JOIN-REJECT, NOTIFY, and REFUSE messages\n   all\
    \ must be answered with an ACK message, see Section 4.2. In\n   general, when\
    \ sending a SCMP message which requires an ACK response,\n   the sending ST agent\
    \ needs to set the Toxxxx timer (where xxxx is the\n   SCMP message type, e.g.,\
    \ ToConnect). If it does not receive an ACK\n   before the Toxxxx timer expires,\
    \ the ST agent should retransmit the\n   SCMP message. If no ACK has been received\
    \ within Nxxxx\n   retransmissions, then a SCMP timeout condition occurs and the\
    \ ST\n   agent enters its SCMP timeout recovery state. The actions performed\n\
    \   by the ST agent as the result of the SCMP timeout condition differ\n   for\
    \ different SCMP messages and are described in Section 5.2.\n   For some SCMP\
    \ messages (CONNECT, CHANGE, JOIN, and STATUS) the\n   sending ST agent also expects\
    \ a response back (ACCEPT/REFUSE,\n   CONNECT/JOIN- REJECT) after ACK has been\
    \ received. For these cases,\n   the ST agent needs to set the ToxxxxResp timer\
    \ after it receives the\n   ACK. (As before, xxxx is the initiating SCMP message\
    \ type, e.g.,\n   ToConnectResp).  If it does not receive the appropriate response\
    \ back\n   when ToxxxxResp expires, the ST agent updates its state and performs\n\
    \   appropriate recovery action as described in Section 5.2. Suggested\n   constants\
    \ are given in Section 10.5.4.\n   The timeout and retransmission algorithm is\
    \ implementation dependent\n   and it is outside the scope of this document. Most\
    \ existing\n   algorithms are based on an estimation of the Round Trip Time (RTT)\n\
    \   between two agents. Therefore, SCMP contains a mechanism, see Section\n  \
    \ 8.5, to estimate this RTT. Note that the timeout related variable\n   names\
    \ described above are for reference purposes only, implementors\n   may choose\
    \ to combine certain variables.\n"
- title: 4.4  Stream Options
  contents:
  - "4.4  Stream Options\n   An application may select among some stream options.\
    \ The desired\n   options are indicated to the ST agent at the origin when a new\
    \ stream\n   is created. Options apply to single streams and are valid during\
    \ the\n   whole stream's lifetime. The options chosen by the application at the\n\
    \   origin are included into the initial CONNECT message, see Section\n   4.5.3.\
    \ When a CONNECT message reaches a target, the application at\n   the target is\
    \ notified of the stream options that have been selected,\n   see Section 4.5.5.\n"
- title: 4.4.1  No Recovery
  contents:
  - "4.4.1  No Recovery\n   When a stream failure is detected, an ST agent would normally\
    \ attempt\n   stream recovery, as described in Section 6.2. The NoRecovery option\n\
    \   is used to indicate that ST agents should not attempt recovery for\n   the\
    \ stream. The protocol behavior in the case that the NoRecovery\n   option has\
    \ been selected is illustrated in Section 6.2. The\n   NoRecovery option is specified\
    \ by setting the S-bit in the CONNECT\n   message, see Section 10.4.4. The S-bit\
    \ can be set only by the origin\n   and it is never modified by intermediate and\
    \ target ST agents.\n"
- title: 4.4.2  Join Authorization Level
  contents:
  - "4.4.2  Join Authorization Level\n   When a new stream is created, it is necessary\
    \ to define the join\n   authorization level associated with the stream. This\
    \ level determines\n   the protocol behavior in case of stream joining, see Section\
    \ 4.1 and\n   Section 4.6.3. The join authorization level for a stream is defined\n\
    \   by the J-bit and N-bit in the CONNECT message header, see Section\n   10.4.4.\
    \  One of the following authorization levels has to be\n   selected:\n   o   Level\
    \ 0 - Refuse Join (JN = 00): No targets are allowed to join this\n       stream.\n\
    \   o   Level 1 - OK, Notify Origin (JN = 01): Targets are allowed to join\n \
    \      the stream. The origin is notified that the target has joined.\n   o  \
    \ Level 2 - OK (JN = 10): Targets are allowed to join the stream. No\n       notification\
    \ is sent to the stream origin.\n   Some applications may choose to maintain tight\
    \ control on their\n   streams and will not permit any connections without the\
    \ origin's\n   permission. For such streams, target applications may request to\
    \ be\n   added by sending an out-of-band, i.e., via regular IP, request to the\n\
    \   origin. The origin, if it so chooses, can then add the target\n   following\
    \ the process described in Section 4.6.1.\n   The selected authorization level\
    \ impacts stream handling and the\n   state that is maintained for the stream,\
    \ as described in Section 4.1.\n"
- title: 4.4.3  Record Route
  contents:
  - "4.4.3  Record Route\n   The RecordRoute option can be used to request the route\
    \ between the\n   origin and a target be recorded and delivered to the application.\n\
    \   This option may be used while connecting, accepting, changing, or\n   refusing\
    \ a stream. The results of a RecordRoute option requested by\n   the origin, i.e.,\
    \ as part of the CONNECT or CHANGE messages, are\n   delivered to the target.\
    \ The results of a RecordRoute option\n   requested by the target, i.e., as part\
    \ of the ACCEPT or REFUSE\n   messages, are delivered to the origin.\n   The RecordRoute\
    \ option is specified by adding the RecordRoute\n   parameter to the mentioned\
    \ SCMP messages. The format of the\n   RecordRoute parameter is shown in Section\
    \ 10.3.5. When adding this\n   parameter, the ST agent at the origin must determine\
    \ the number of\n   entries that may be recorded as explained in Section 10.3.5.\n"
- title: 4.4.4  User Data
  contents:
  - "4.4.4  User Data\n   The UserData option can be used by applications to transport\n\
    \   application specific data along with some SCMP control messages. This\n  \
    \ option can be included with ACCEPT, CHANGE, CONNECT, DISCONNECT, and\n   REFUSE\
    \ messages. The format of the UserData parameter is shown in\n   Section 10.3.7.\
    \ This option may be included by the origin, or the\n   target, by adding the\
    \ UserData parameter to the mentioned SCMP\n   messages. This option may only\
    \ be included once per SCMP message.\n"
- title: 4.5  Stream Setup
  contents:
  - "4.5  Stream Setup\n   This section presents a description of stream setup. For\
    \ simplicity,\n   we assume that everything succeeds, e.g., any required resources\
    \ are\n   available, messages are properly delivered, and the routing is\n   correct.\
    \ Possible failures in the setup phase are handled in Section\n   5.2.\n"
- title: 4.5.1  Information from the Application
  contents:
  - "4.5.1  Information from the Application\n   Before stream setup can be started,\
    \ the application has to collect\n   the necessary information to determine the\
    \ characteristics for the\n   connection. This includes identifying the participants\
    \ and selecting\n   the QoS parameters of the data flow. Information passed to\
    \ the ST\n   agent by the application includes:\n"
- title: o   the list of the stream's targets (Section 10.3.6). The list may be
  contents:
  - "o   the list of the stream's targets (Section 10.3.6). The list may be\n    empty\
    \ (Section 4.5.3.1),\n"
- title: o   the flow specification containing the desired quality of service for
  contents:
  - "o   the flow specification containing the desired quality of service for\n  \
    \  the stream (Section 9),\n"
- title: o   information on the groups in which the stream is a member, if any
  contents:
  - "o   information on the groups in which the stream is a member, if any\n    (Section\
    \ 7),\n"
- title: o   information on the options selected for the stream (Section 4.4).
  contents:
  - 'o   information on the options selected for the stream (Section 4.4).

    '
- title: 4.5.2  Initial Setup at the Origin
  contents:
  - "4.5.2  Initial Setup at the Origin\n   The ST agent at the origin then performs\
    \ the following operations:\n"
- title: o   allocates a stream ID (SID) for the stream (Section 8.1),
  contents:
  - 'o   allocates a stream ID (SID) for the stream (Section 8.1),

    '
- title: o   invokes the routing function to determine the set of next-hops for
  contents:
  - "o   invokes the routing function to determine the set of next-hops for\n    the\
    \ stream (Section 4.5.2.1),\n"
- title: o   invokes the Local Resource Manager (LRM) to reserve resources
  contents:
  - "o   invokes the Local Resource Manager (LRM) to reserve resources\n    (Section\
    \ 4.5.2.2),\n"
- title: o   creates local database entries to store information on the new
  contents:
  - "o   creates local database entries to store information on the new\n    stream,\n"
- title: o   propagates the stream creation request to the next-hops determined
  contents:
  - "o   propagates the stream creation request to the next-hops determined\n    by\
    \ the routing function (Section 4.5.3).\n"
- title: 4.5.2.1  Invoking the Routing Function
  contents:
  - "4.5.2.1  Invoking the Routing Function\n   An ST agent that is setting up a stream\
    \ invokes the routing function\n   to find the next-hop to reach each of the targets\
    \ specified by the\n   target list provided by the application. This is similar\
    \ to the\n   routing decision in IP. However, in this case the route is to a\n\
    \   multitude of targets with QoS requirements rather than to a single\n   destination.\n\
    \   The result of the routing function is a set of next-hop ST agents.\n   The\
    \ set of next-hops selected by the routing function is not\n   necessarily the\
    \ same as the set of next-hops that IP would select\n   given a number of independent\
    \ IP datagrams to the same destinations.\n   The routing algorithm may attempt\
    \ to optimize parameters other than\n   the number of hops that the packets will\
    \ take, such as delay, local\n   network bandwidth consumption, or total internet\
    \ bandwidth\n   consumption.  Alternatively, the routing algorithm may use a simple\n\
    \   route lookup for each target.\n   Once a next-hop is selected by the routing\
    \ function, it persists for\n   the whole stream lifetime, unless a network failure\
    \ occurs.\n"
- title: 4.5.2.2  Reserving Resources
  contents:
  - "4.5.2.2  Reserving Resources\n   The ST agent invokes the Local Resource Manager\
    \ (LRM) to perform the\n   appropriate reservations. The ST agent presents the\
    \ LRM with\n   information including:\n"
- title: o   the flow specification with the desired quality of service for the
  contents:
  - "o   the flow specification with the desired quality of service for the\n    stream\
    \ (Section 9),\n"
- title: o   the version number associated with the flow specification
  contents:
  - "o   the version number associated with the flow specification\n    (Section 9).\n"
- title: o   information on the groups the stream is member in, if any
  contents:
  - "o   information on the groups the stream is member in, if any\n    (Section 7),\n\
    \   The flow specification contains information needed by the LRM to\n   allocate\
    \ resources. The LRM updates the flow specification contents\n   information before\
    \ returning it to the ST agent. Section 9.2.3\n   defines the fields of the flow\
    \ specification to be updated by the\n   LRM.\n   The membership of a stream in\
    \ a group may affect the amount of\n   resources that have to be allocated by\
    \ the LRM, see Section 7.\n"
- title: 4.5.3  Sending CONNECT Messages
  contents:
  - "4.5.3  Sending CONNECT Messages\n   The ST agent sends a CONNECT message to each\
    \ of the next-hop ST\n   agents identified by the routing function. Each CONNECT\
    \ message\n   contains the SID, the selected stream options, the FlowSpec, and\
    \ a\n   TargetList. The format of the CONNECT message is defined by Section\n\
    \   10.4.4. In general, the FlowSpec and TargetList depend on both the\n   next-hop\
    \ and the intervening network. Each TargetList is a subset of\n   the original\
    \ TargetList, identifying the targets that are to be\n   reached through the next-hop\
    \ to which the CONNECT message is being\n   sent.\n   The TargetList may be empty,\
    \ see Section 4.5.3.1; if the TargetList\n   causes a too long CONNECT message\
    \ to be generated, the CONNECT\n   message is partitioned as explained in Section\
    \ 5.1.2. If multiple\n   next-hops are to be reached through a network that supports\
    \ network\n   level multicast, a different CONNECT message must nevertheless be\n\
    \   sent to each next-hop since each will have a different TargetList.\n"
- title: 4.5.3.1  Empty Target List
  contents:
  - "4.5.3.1  Empty Target List\n   An application at the origin may request the local\
    \ ST agent to create\n   an empty stream. It does so by passing an empty TargetList\
    \ to the\n   local ST agent during the initial stream setup. When the local ST\n\
    \   agent receives a request to create an empty stream, it allocates the\n   stream\
    \ ID (SID), updates its local database entries to store\n   information on the\
    \ new stream and notifies the application that\n   stream setup is complete. The\
    \ local ST agent does not generate any\n   CONNECT message for streams with an\
    \ empty TargetList. Targets may be\n   later added by the origin, see Section\
    \ 4.6.1, or they may\n   autonomously join the stream, see Section 4.6.3.\n"
- title: 4.5.4  CONNECT Processing by an Intermediate ST agent
  contents:
  - "4.5.4  CONNECT Processing by an Intermediate ST agent\n   An ST agent receiving\
    \ a CONNECT message, assuming no errors, responds\n   to the previous-hop with\
    \ an ACK. The ACK message must identify the\n   CONNECT message to which it corresponds\
    \ by including the reference\n   number indicated by the Reference field of the\
    \ CONNECT message. The\n   intermediate ST agent calls the routing function, invokes\
    \ the LRM to\n   reserve resources, and then propagates the CONNECT messages to\
    \ its\n   next-hops, as described in the previous sections.\n"
- title: 4.5.5  CONNECT Processing at the Targets
  contents:
  - "4.5.5  CONNECT Processing at the Targets\n   An ST agent that is the target of\
    \ a CONNECT message, assuming no\n   errors, responds to the previous-hop with\
    \ an ACK. The ST agent\n   invokes the LRM to reserve local resources and then\
    \ queries the\n   specified application process whether or not it is willing to\
    \ accept\n   the connection.\n   The application is presented with parameters\
    \ from the CONNECT message\n   including the SID, the selected stream options,\
    \ Origin, FlowSpec,\n   TargetList, and Group, if any, to be used as a basis for\
    \ its\n   decision.  The application is identified by a combination of the\n \
    \  NextPcol field, from the Origin parameter, and the service access\n   point,\
    \ or SAP, field included in the correspondent (usually single\n   remaining) Target\
    \ of the TargetList. The contents of the SAP field\n   may specify the port or\
    \ other local identifier for use by the\n   protocol layer above the host ST layer.\
    \ Subsequently received data\n   packets will carry the SID, that can be mapped\
    \ into this information\n   and be used for their delivery.\n   Finally, based\
    \ on the application's decision, the ST agent sends to\n   the previous-hop from\
    \ which the CONNECT message was received either\n   an ACCEPT or REFUSE message.\
    \ Since the ACCEPT (or REFUSE) message has\n   to be acknowledged by the previous-hop,\
    \ it is assigned a new\n   Reference number that will be returned in the ACK.\
    \ The CONNECT\n   message to which ACCEPT (or REFUSE) is a reply is identified\
    \ by\n   placing the CONNECT's Reference number in the LnkReference field of\n\
    \   ACCEPT (or REFUSE). The ACCEPT message contains the FlowSpec as\n   accepted\
    \ by the application at the target.\n"
- title: 4.5.6  ACCEPT Processing by an Intermediate ST agent
  contents:
  - "4.5.6  ACCEPT Processing by an Intermediate ST agent\n   When an intermediate\
    \ ST agent receives an ACCEPT, it first verifies\n   that the message is a response\
    \ to an earlier CONNECT. If not, it\n   responds to the next-hop ST agent with\
    \ an ERROR message, with\n   ReasonCode (LnkRefUnknown). Otherwise, it responds\
    \ to the next-hop ST\n   agent with an ACK, and propagates the individual ACCEPT\
    \ message to\n   the previous-hop along the same path traced by the CONNECT but\
    \ in the\n   reverse direction toward the origin.\n   The FlowSpec is included\
    \ in the ACCEPT message so that the origin and\n   intermediate ST agents can\
    \ gain access to the information that was\n   accumulated as the CONNECT traversed\
    \ the internet. Note that the\n   resources, as specified in the FlowSpec in the\
    \ ACCEPT message, may\n   differ from the resources that were reserved when the\
    \ CONNECT was\n   originally processed. Therefore, the ST agent presents the LRM\
    \ with\n   the FlowSpec included in the ACCEPT message. It is expected that each\n\
    \   LRM adjusts local reservations releasing any excess resources. The\n   LRM\
    \ may choose not to adjust local reservations when that adjustment\n   may result\
    \ in the loss of needed resources. It may also choose to\n   wait to adjust allocated\
    \ resources until all targets in transition\n   have been accepted or refused.\n\
    \   In the case where the intermediate ST agent is acting as the origin\n   with\
    \ respect to this target, see Section 4.6.3.1, the ACCEPT message\n   is not propagated\
    \ upstream.\n"
- title: 4.5.7  ACCEPT Processing by the Origin
  contents:
  - "4.5.7  ACCEPT Processing by the Origin\n   The origin will eventually receive\
    \ an ACCEPT (or REFUSE) message from\n   each of the targets. As each ACCEPT is\
    \ received, the application is\n   notified of the target and the resources that\
    \ were successfully\n   allocated along the path to it, as specified in the FlowSpec\n\
    \   contained in the ACCEPT message. The application may then use the\n   information\
    \ to either adopt or terminate the portion of the stream to\n   each target.\n\
    \   When an ACCEPT is received by the origin, the path to the target is\n   considered\
    \ to be established and the ST agent is allowed to forward\n   the data along\
    \ this path as explained in Section 2 and in Section\n   3.1.\n"
- title: 4.5.8  REFUSE Processing by the Intermediate ST agent
  contents:
  - "4.5.8  REFUSE Processing by the Intermediate ST agent\n   If an application at\
    \ a target does not wish to participate in the\n   stream, it sends a REFUSE message\
    \ back to the origin with ReasonCode\n   (ApplDisconnect). An intermediate ST\
    \ agent that receives a REFUSE\n   message with ReasonCode (ApplDisconnect) acknowledges\
    \ it by sending\n   an ACK to the next-hop, invokes the LRM to adjusts reservations\
    \ as\n   appropriate, deletes the target entry from the internal database, and\n\
    \   propagates the REFUSE message back to the previous-hop ST agent.\n   In the\
    \ case where the intermediate ST agent is acting as the origin\n   with respect\
    \ to this target, see Section 4.6.3.1, the REFUSE message\n   is only propagated\
    \ upstream when there are no more downstream agents\n   participating in the stream.\
    \ In this case, the agent indicates that\n   the agent is to be removed from the\
    \ stream propagating the REFUSE\n   message with the G-bit set (1).\n"
- title: 4.5.9  REFUSE Processing by the Origin
  contents:
  - "4.5.9  REFUSE Processing by the Origin\n   When the REFUSE message reaches the\
    \ origin, the ST agent at the\n   origin sends an ACK and notifies the application\
    \ that the target is\n   no longer part of the stream and also if the stream has\
    \ no remaining\n   targets. If there are no remaining targets, the application\
    \ may wish\n   to terminate the stream, or keep the stream active to allow addition\n\
    \   of targets or stream joining as described in Section 4.6.3.\n"
- title: 4.5.10  Other Functions during Stream Setup
  contents:
  - "4.5.10  Other Functions during Stream Setup\n   Some other functions have to\
    \ be accomplished by an ST agent as\n   CONNECT messages travel downstream and\
    \ ACCEPT (or REFUSE) messages\n   travel upstream during the stream setup phase.\
    \ They were not\n   mentioned in the previous sections to keep the discussion\
    \ as simple\n   as possible. These functions include:\n   o   computing the smallest\
    \ Maximum Transmission Unit size over the path\n       to the targets, as part\
    \ of the MTU discovery mechanism presented in\n       Section 8.6. This is done\
    \ by updating the MaxMsgSize field of the\n       CONNECT message, see Section\
    \ 10.4.4. This value is carried back to\n       origin in the MaxMsgSize field\
    \ of the ACCEPT message, see Section\n       10.4.1.\n   o   counting the number\
    \ of IP clouds to be traversed to reach the\n       targets, if any. IP clouds\
    \ are traversed when the IP encapsulation\n       mechanism is used. This mechanism\
    \ described in Section 8.7.\n       Encapsulating agents update the IPHops field\
    \ of the CONNECT message,\n       see Section 10.4.4. The resulting value is carried\
    \ back to origin in\n       the IPHops field of the ACCEPT message, see Section\
    \ 10.4.1.\n   o   updating the RecoveryTimeout value for the stream based on what\
    \ can\n       the agent can support. This is part of the stream recovery\n   \
    \    mechanism, in Section 6.2. This is done by updating the\n       RecoveryTimeout\
    \ field of the CONNECT message, see Section 10.4.4.\n       This value is carried\
    \ back to origin in the RecoveryTimeout field of\n       the ACCEPT message, see\
    \ Section 10.4.1.\n"
- title: 4.6  Modifying an Existing Stream
  contents:
  - "4.6  Modifying an Existing Stream\n   Some applications may wish to modify a\
    \ stream after it has been\n   created. Possible changes include expanding a stream,\
    \ reducing it,\n   and changing its FlowSpec. The origin may add or remove targets\
    \ as\n   described in Section 4.6.1 and Section 4.6.2. Targets may request to\n\
    \   join the stream as described in Section 4.6.3 or, they may decide to\n   leave\
    \ a stream as described in Section 4.6.4. Section 4.6.5 explains\n   how to change\
    \ a stream's FlowSpec.\n   As defined by Section 2, an ST agent can handle only\
    \ one stream\n   modification at a time. If a stream modification operation is\
    \ already\n   underway, further requests are queued and handled when the previous\n\
    \   operation has been completed. This also applies to two subsequent\n   requests\
    \ of the same kind, e.g., two subsequent changes to the\n   FlowSpec.\n"
- title: 4.6.1  The Origin Adding New Targets
  contents:
  - "4.6.1  The Origin Adding New Targets\n   It is possible for an application at\
    \ the origin to add new targets to\n   an existing stream any time after the stream\
    \ has been established.\n   Before new targets are added, the application has\
    \ to collect the\n   necessary information on the new targets. Such information\
    \ is passed\n   to the ST agent at the origin.\n   The ST agent at the origin\
    \ issues a CONNECT message that contains the\n   SID, the FlowSpec, and the TargetList\
    \ specifying the new targets.\n   This is similar to sending a CONNECT message\
    \ during stream\n   establishment, with the following exceptions: the origin checks\
    \ that\n   a) the SID is valid, b) the targets are not already members of the\n\
    \   stream, c) that the LRM evaluates the FlowSpec of the new target to\n   be\
    \ the same as the FlowSpec of the existing stream, i.e., it requires\n   an equal\
    \ or smaller amount of resources to be allocated. If the\n   FlowSpec of the new\
    \ target does not match the FlowSpec of the\n   existing stream, an error is generated\
    \ with ReasonCode\n   (FlowSpecMismatch). Functions to compare flow specifications\
    \ are\n   provided by the LRM, see Section 1.4.5.\n   An intermediate ST agent\
    \ that is already a participant in the stream\n   looks at the SID and StreamCreationTime,\
    \ and verifies that the stream\n   is the same. It then checks if the intersection\
    \ of the TargetList and\n   the targets of the established stream is empty. If\
    \ this is not the\n   case, it responds with a REFUSE message with ReasonCode\n\
    \   (TargetExists) that contains a TargetList of those targets that were\n   duplicates.\
    \ To indicate that the stream exists, and includes the\n   listed targets, the\
    \ ST agent sets to one (1) the E-bit of the REFUSE\n   message, see Section 10.4.11.\
    \  The agent then proceeds processing\n   each new target in the TargetList.\n\
    \   For each new target in the TargetList, processing is much the same as\n  \
    \ for the original CONNECT. The CONNECT is acknowledged, propagated,\n   and network\
    \ resources are reserved. Intermediate or target ST agents\n   that are not already\
    \ participants in the stream behave as in the case\n   of stream setup (see Section\
    \ 4.5.4 and Section 4.5.5).\n"
- title: 4.6.2  The Origin Removing a Target
  contents:
  - "4.6.2  The Origin Removing a Target\n   It is possible for an application at\
    \ the origin to remove existing\n   targets of a stream any time after the targets\
    \ have accepted the\n   stream. The application at the origin specifies the set\
    \ of targets\n   that are to be removed and informs the local ST agent. Based\
    \ on this\n   information, the ST agent sends DISCONNECT messages with the\n \
    \  ReasonCode (ApplDisconnect) to the next-hops relative to the targets.\n   An\
    \ ST agent that receives a DISCONNECT message must acknowledge it by\n   sending\
    \ an ACK to the previous-hop. The ST agent updates its state\n   and notifies\
    \ the LRM of the target deletion so that the LRM can\n   modify reservations as\
    \ appropriate. When the DISCONNECT message\n   reaches the target, the ST agent\
    \ also notifies the application that\n   the target is no longer part of the stream.\
    \ When there are no\n   remaining targets that can be reached through a particular\
    \ next-hop,\n   the ST agent informs the LRM and it deletes the next-hop from\
    \ its\n   next-hops set.\n   SCMP also provides a flooding mechanism to delete\
    \ targets that joined\n   the stream without notifying the origin. The special\
    \ case of target\n   deletion via flooding is described in Section 5.7.\n"
- title: 4.6.3  A Target Joining a Stream
  contents:
  - "4.6.3  A Target Joining a Stream\n   An application may request to join an existing\
    \ stream. It has to\n   collect information on the stream including the stream\
    \ ID (SID) and\n   the IP address of the stream's origin. This can be done out-of-band,\n\
    \   e.g., via regular IP. The information is then passed to the local ST\n   agent.\
    \ The ST agent generates a JOIN message containing the\n   application's request\
    \ to join the stream and sends it toward the\n   stream origin.\n   An ST agent\
    \ receiving a JOIN message, assuming no errors, responds\n   with an ACK. The\
    \ ACK message must identify the JOIN message to which\n   it corresponds by including\
    \ the Reference number indicated by the\n   Reference field of the JOIN message.\
    \ If the ST agent is not traversed\n   by the stream that has to be joined, it\
    \ propagates the JOIN message\n   toward the stream's origin. Once a JOIN message\
    \ has been\n   acknowledged, ST agents do not retain any state information related\n\
    \   to the JOIN message.\n   Eventually, an ST agent traversed by the stream or\
    \ the stream's\n   origin itself is reached. This agent must respond to a received\
    \ JOIN\n   first with an ACK to the ST agent from which the message was\n   received,\
    \ then, it issues either a CONNECT or a JOIN-REJECT message\n   and sends it toward\
    \ the target. The response to the join request is\n   based on the join authorization\
    \ level associated with the stream, see\n   Section 4.4.2:\n"
- title: 'o   If the stream has authorization level #0 (refuse join):'
  contents:
  - "o   If the stream has authorization level #0 (refuse join):\n    The ST agent\
    \ sends a JOIN-REJECT message toward the target with\n    ReasonCode (JoinAuthFailure).\n"
- title: 'o   If the stream has authorization level #1 (ok, notify origin):'
  contents:
  - "o   If the stream has authorization level #1 (ok, notify origin):\n    The ST\
    \ agent sends a CONNECT message toward the target with a\n    TargetList including\
    \ the target that requested to join the stream.\n    This eventually results in\
    \ adding the target to the stream. When\n    the ST agent receives the ACCEPT\
    \ message indicating that the new\n    target has been added, it does not propagate\
    \ the ACCEPT message\n    backwards (Section 4.5.6). Instead, it issues a NOTIFY\
    \ message\n    with ReasonCode (TargetJoined) so that upstream agents, including\n\
    \    the origin, may add the new target to maintained state\n    information.\
    \ The NOTIFY message includes all target specific\n    information.\n"
- title: 'o   If the stream has authorization level #2 (ok):'
  contents:
  - "o   If the stream has authorization level #2 (ok):\n    The ST agent sends a\
    \ CONNECT message toward the target with a\n    TargetList including the target\
    \ that requested to join the stream.\n    This eventually results in adding the\
    \ target to the stream. When\n    the ST agent receives the ACCEPT message indicating\
    \ that the new\n    target has been added, it does not propagate the ACCEPT message\n\
    \    backwards (Section 4.5.6), nor does it notify the origin. A NOTIFY\n    message\
    \ is generated with ReasonCode (TargetJoined) if the target\n    specific information\
    \ needs to be propagated back to the origin. An\n    example of such information\
    \ is change in MTU, see Section 8.6.\n"
- title: 4.6.3.1  Intermediate Agent (Router) as Origin
  contents:
  - "4.6.3.1  Intermediate Agent (Router) as Origin\n   When a stream has join authorization\
    \ level #2, see Section 4.4.2, it\n   is possible that the stream origin is unaware\
    \ of some targets\n   participating in the stream. In this case, the ST intermediate\
    \ agent\n   that first sent a CONNECT message to this target has to act as the\n\
    \   stream origin for the given target. This includes:\n"
- title: o   if the whole stream is deleted, the intermediate agent must
  contents:
  - "o   if the whole stream is deleted, the intermediate agent must\n    disconnect\
    \ the target.\n"
- title: o   if the stream FlowSpec is changed, the intermediate agent must
  contents:
  - "o   if the stream FlowSpec is changed, the intermediate agent must\n    change\
    \ the FlowSpec for the target as appropriate.\n"
- title: o   proper handling of ACCEPT and REFUSE messages, without propagation
  contents:
  - "o   proper handling of ACCEPT and REFUSE messages, without propagation\n    to\
    \ upstream ST agents.\n"
- title: o   generation of NOTIFY messages when needed. (As described above.)
  contents:
  - "o   generation of NOTIFY messages when needed. (As described above.)\n   The\
    \ intermediate agent behaves normally for all other targets added\n   to the stream\
    \ as a consequence of a CONNECT message issued by the\n   origin.\n"
- title: 4.6.4  A Target Deleting Itself
  contents:
  - "4.6.4  A Target Deleting Itself\n   The application at the target may inform\
    \ the local ST agent that it\n   wants to be removed from the stream. The ST agent\
    \ then forms a REFUSE\n   message with the target itself as the only entry in\
    \ the TargetList\n   and with ReasonCode (ApplDisconnect). The REFUSE message\
    \ is sent back\n   to the origin via the previous-hop. If a stream has multiple\
    \ targets\n   and one target leaves the stream using this REFUSE mechanism, the\n\
    \   stream to the other targets is not affected; the stream continues to\n   exist.\n\
    \   An ST agent that receives a REFUSE message acknowledges it by sending\n  \
    \ an ACK to the next-hop. The target is deleted and the LRM is notified\n   so\
    \ that it adjusts reservations as appropriate. The REFUSE message is\n   also\
    \ propagated back to the previous-hop ST agent except in the case\n   where the\
    \ agent is acting as the origin. In this case a NOTIFY may be\n   propagated instead,\
    \ see Section 4.6.3.\n   When the REFUSE reaches the origin, the origin sends\
    \ an ACK and\n   notifies the application that the target is no longer part of\
    \ the\n   stream.\n"
- title: 4.6.5  Changing a Stream's FlowSpec
  contents:
  - "4.6.5  Changing a Stream's FlowSpec\n   The application at the origin may wish\
    \ to change the FlowSpec of an\n   established stream. Changing the FlowSpec is\
    \ a critical operation and\n   it may even lead in some cases to the deletion\
    \ of the affected\n   targets. Possible problems with FlowSpec changes are discussed\
    \ in\n   Section 5.6.\n   To change the stream's FlowSpec, the application informs\
    \ the ST agent\n   at the origin of the new FlowSpec and of the list of targets\
    \ relative\n   to the change. The ST agent at the origin then issues one CHANGE\n\
    \   message per next-hop including the new FlowSpec and sends it to the\n   relevant\
    \ next-hop ST agents. If the G-bit field of the CHANGE message\n   is set (1),\
    \ the change affects all targets in the stream.\n   The CHANGE message contains\
    \ a bit called I-bit, see Section 10.4.3.\n   By default, the I-bit is set to\
    \ zero (0) to indicate that the LRM is\n   expected to try and perform the requested\
    \ FlowSpec change without\n   risking to tear down the stream. Applications that\
    \ desire a higher\n   probability of success and are willing to take the risk\
    \ of breaking\n   the stream can indicate this by setting the I-bit to one (1).\n\
    \   Applications that require the requested modification in order to\n   continue\
    \ operating are expected to set this bit.\n   An intermediate ST agent that receives\
    \ a CHANGE message first sends\n   an ACK to the previous-hop and then provides\
    \ the FlowSpec to the LRM.\n   If the LRM can perform the change, the ST agent\
    \ propagates the CHANGE\n   messages along the established paths.\n   If the whole\
    \ process succeeds, the CHANGE messages will eventually\n   reach the targets.\
    \ Targets respond with an ACCEPT (or REFUSE) message\n   that is propagated back\
    \ to the origin. In processing the ACCEPT\n   message on the way back to the origin,\
    \ excess resources may be\n   released by the LRM as described in Section 4.5.6.\
    \ The REFUSE message\n   must have the ReasonCode (ApplRefused).\n   SCMP also\
    \ provides a flooding mechanism to change targets that joined\n   the stream without\
    \ notifying the origin. The special case of target\n   change via flooding is\
    \ described in Section 5.7.\n"
- title: 4.7  Stream Tear Down
  contents:
  - "4.7  Stream Tear Down\n   A stream is usually terminated by the origin when it\
    \ has no further\n   data to send. A stream is also torn down if the application\
    \ should\n   terminate abnormally or if certain network failures are encountered.\n\
    \   Processing in this case is identical to the previous descriptions\n   except\
    \ that the ReasonCode (ApplAbort, NetworkFailure, etc.) is\n   different.\n  \
    \ When all targets have left a stream, the origin notifies the\n   application\
    \ of that fact, and the application is then responsible for\n   terminating the\
    \ stream. Note, however, that the application may\n   decide to add targets to\
    \ the stream instead of terminating it, or may\n   just leave the stream open\
    \ with no targets in order to permit stream\n   joins.\n"
- title: 5.  Exceptional Cases
  contents:
  - "5.  Exceptional Cases\n   The previous descriptions covered the simple cases\
    \ where everything\n   worked. We now discuss what happens when things do not\
    \ succeed.\n   Included are situations where messages exceed a network MTU, are\n\
    \   lost, the requested resources are not available, the routing fails or\n  \
    \ is inconsistent.\n"
- title: 5.1  Long ST Messages
  contents:
  - "5.1  Long ST Messages\n   It is possible that an ST agent, or an application,\
    \ will need to send\n   a message that exceeds a network's Maximum Transmission\
    \ Unit (MTU).\n   This case must be handled but not via generic fragmentation,\
    \ since\n   ST2 does not support generic fragmentation of either data or control\n\
    \   messages.\n"
- title: 5.1.1  Handling of Long Data Packets
  contents:
  - "5.1.1  Handling of Long Data Packets\n   ST agents discard data packets that\
    \ exceed the MTU of the next-hop\n   network. No error message is generated. Applications\
    \ should avoid\n   sending data packets larger than the minimum MTU supported\
    \ by a given\n   stream. The application, both at the origin and targets, can\
    \ learn\n   the stream minimum MTU through the MTU discovery mechanism described\n\
    \   in Section 8.6.\n"
- title: 5.1.2  Handling of Long Control Packets
  contents:
  - "5.1.2  Handling of Long Control Packets\n   Each ST agent knows the MTU of the\
    \ networks to which it is connected,\n   and those MTUs restrict the size of the\
    \ SCMP message it can send. An\n   SCMP message size can exceed the MTU of a given\
    \ network for a number\n   of reasons:\n"
- title: o   the TargetList parameter (Section 10.3.6) may be too long;
  contents:
  - 'o   the TargetList parameter (Section 10.3.6) may be too long;

    '
- title: o   the RecordRoute parameter (Section 10.3.5) may be too long.
  contents:
  - 'o   the RecordRoute parameter (Section 10.3.5) may be too long.

    '
- title: o   the UserData parameter (Section 10.3.7) may be too long;
  contents:
  - 'o   the UserData parameter (Section 10.3.7) may be too long;

    '
- title: o   the PDUInError field of the ERROR message (Section 10.4.6) may be
  contents:
  - "o   the PDUInError field of the ERROR message (Section 10.4.6) may be\n    too\
    \ long;\n   An ST agent receiving or generating a too long SCMP message should:\n"
- title: o   break the message into multiple messages, each carrying part of the
  contents:
  - "o   break the message into multiple messages, each carrying part of the\n   \
    \ TargetList. Any RecordRoute and UserData parameters are replicated\n    in each\
    \ message for delivery to all targets. Applications that\n    support a large\
    \ number of targets may avoid using long TargetList\n    parameters, and are expected\
    \ to do so, by exploiting the stream\n    joining functions, see Section 4.6.3.\
    \ One exception to this rule\n    exists. In the case of a long TargetList parameter\
    \ to be included in\n    a STATUS-RESPONSE message, the TargetList parameter is\
    \ just\n    truncated to the point where the list can fit in a single message,\n\
    \    see Section 8.4.\n"
- title: 'o   for down stream agents: if the TargetList parameter contains a'
  contents:
  - "o   for down stream agents: if the TargetList parameter contains a\n    single\
    \ Target element and the message size is still too long, the ST\n    agent should\
    \ issue a REFUSE message with ReasonCode\n    (RecordRouteSize) if the size of\
    \ the RecordRoute parameter causes\n    the SCMP message size to exceed the network\
    \ MTU, or with ReasonCode\n    (UserDataSize) if the size of the UserData parameter\
    \ causes the SCMP\n    message size to exceed the network MTU. If both RecordRoute\
    \ and\n    UserData parameters are present the ReasonCode (UserDataSize) should\n\
    \    be sent. For messages generated at the target: the target ST agent\n    must\
    \ check for SCMP messages that may exceed the MTU on the complete\n    target-to-origin\
    \ path, and inform the application that a too long\n    SCMP messages has been\
    \ generated. The format for the error reporting\n    is a local implementation\
    \ issue. The error codes are the same as\n    previously stated.\n   ST agents\
    \ generating too long ERROR messages, simply truncate the\n   PDUInError field\
    \ to the point where the message is smaller than the\n   network MTU.\n"
- title: 5.2  Timeout Failures
  contents:
  - "5.2  Timeout Failures\n   As described in Section 4.3, SCMP message delivery\
    \ is made reliable\n   through the use of acknowledgments, timeouts, and retransmission.\
    \ The\n   ACCEPT, CHANGE, CONNECT, DISCONNECT, JOIN, JOIN-REJECT, NOTIFY, and\n\
    \   REFUSE messages must always be acknowledged, see Section 4.2. In\n   addition,\
    \ for some SCMP messages (CHANGE, CONNECT, JOIN) the sending\n   ST agent also\
    \ expects a response back (ACCEPT/REFUSE, CONNECT/JOIN-\n   REJECT) after an ACK\
    \ has been received. Also, the STATUS message must\n   be answered with a STATUS-RESPONSE\
    \ message.\n   The following sections describe the handling of each of the possible\n\
    \   failure cases due to timeout situations while waiting for an\n   acknowledgment\
    \ or a response. The timeout related variables, and\n   their names, used in the\
    \ next sections are for reference purposes\n   only. They may be implementation\
    \ specific. Different implementations\n   are not required to share variable names,\
    \ or even the mechanism by\n   which the timeout and retransmission behavior is\
    \ implemented.\n"
- title: 5.2.1  Failure due to ACCEPT Acknowledgment Timeout
  contents:
  - "5.2.1  Failure due to ACCEPT Acknowledgment Timeout\n   An ST agent that sends\
    \ an ACCEPT message upstream expects an ACK from\n   the previous-hop ST agent.\
    \ If no ACK is received before the ToAccept\n   timeout expires, the ST agent\
    \ should retry and send the ACCEPT\n   message again. After NAccept unsuccessful\
    \ retries, the ST agent sends\n   a REFUSE message toward the origin, and a DISCONNECT\
    \ message toward\n   the targets. Both REFUSE and DISCONNECT must identify the\
    \ affected\n   targets and specify the ReasonCode (RetransTimeout).\n"
- title: 5.2.2  Failure due to CHANGE Acknowledgment Timeout
  contents:
  - "5.2.2  Failure due to CHANGE Acknowledgment Timeout\n   An ST agent that sends\
    \ a CHANGE message downstream expects an ACK\n   from the next-hop ST agent. If\
    \ no ACK is received before the ToChange\n   timeout expires, the ST agent should\
    \ retry and send the CHANGE\n   message again. After NChange unsuccessful retries,\
    \ the ST agent\n   aborts the change attempt by sending a REFUSE message toward\
    \ the\n   origin, and a DISCONNECT message toward the targets. Both REFUSE and\n\
    \   DISCONNECT must identify the affected targets and specify the\n   ReasonCode\
    \ (RetransTimeout).\n"
- title: 5.2.3  Failure due to CHANGE Response Timeout
  contents:
  - "5.2.3  Failure due to CHANGE Response Timeout\n   Only the origin ST agent implements\
    \ this timeout. After correctly\n   receiving the ACK to a CHANGE message, an\
    \ ST agent expects to receive\n   an ACCEPT, or REFUSE message in response. If\
    \ one of these messages is\n   not received before the ToChangeResp timer expires,\
    \ the ST agent at\n   the origin aborts the change attempt, and behaves as if\
    \ a REFUSE\n   message with the E-bit set and with ReasonCode (ResponseTimeout)\
    \ is\n   received.\n"
- title: 5.2.4  Failure due to CONNECT Acknowledgment Timeout
  contents:
  - "5.2.4  Failure due to CONNECT Acknowledgment Timeout\n   An ST agent that sends\
    \ a CONNECT message downstream expects an ACK\n   from the next-hop ST agent.\
    \ If no ACK is received before the\n   ToConnect timeout expires, the ST agent\
    \ should retry and send the\n   CONNECT message again. After NConnect unsuccessful\
    \ retries, the ST\n   agent sends a REFUSE message toward the origin, and a DISCONNECT\n\
    \   message toward the targets. Both REFUSE and DISCONNECT must identify\n   the\
    \ affected targets and specify the ReasonCode (RetransTimeout).\n"
- title: 5.2.5  Failure due to CONNECT Response Timeout
  contents:
  - "5.2.5  Failure due to CONNECT Response Timeout\n   Only the origin ST agent implements\
    \ this timeout. After correctly\n   receiving the ACK to a CONNECT message, an\
    \ ST agent expects to\n   receive an ACCEPT or REFUSE message in response. If\
    \ one of these\n   messages is not received before the ToConnectResp timer expires,\
    \ the\n   origin ST agent aborts the connection setup attempt, acts as if a\n\
    \   REFUSE message is received, and it sends a DISCONNECT message toward\n   the\
    \ targets.  Both REFUSE and DISCONNECT must identify the affected\n   targets\
    \ and specify the ReasonCode (ResponseTimeout).\n"
- title: 5.2.6  Failure due to DISCONNECT Acknowledgment Timeout
  contents:
  - "5.2.6  Failure due to DISCONNECT Acknowledgment Timeout\n   An ST agent that\
    \ sends a DISCONNECT message downstream expects an ACK\n   from the next-hop ST\
    \ agent. If no ACK is received before the\n   ToDisconnect timeout expires, the\
    \ ST agent should retry and send the\n   DISCONNECT message again. After NDisconnect\
    \ unsuccessful retries, the\n   ST agent simply gives up and it assumes the next-hop\
    \ ST agent is not\n   part in the stream any more.\n"
- title: 5.2.7  Failure due to JOIN Acknowledgment Timeout
  contents:
  - "5.2.7  Failure due to JOIN Acknowledgment Timeout\n   An ST agent that sends\
    \ a JOIN message toward the origin expects an\n   ACK from a neighbor ST agent.\
    \ If no ACK is received before the ToJoin\n   timeout expires, the ST agent should\
    \ retry and send the JOIN message\n   again. After NJoin unsuccessful retries,\
    \ the ST agent sends a JOIN-\n   REJECT message back in the direction of the target\
    \ with ReasonCode\n   (RetransTimeout).\n"
- title: 5.2.8  Failure due to JOIN Response Timeout
  contents:
  - "5.2.8  Failure due to JOIN Response Timeout\n   Only the target agent implements\
    \ this timeout. After correctly\n   receiving the ACK to a JOIN message, the ST\
    \ agent at the target\n   expects to receive a CONNECT or JOIN-REJECT message\
    \ in response. If\n   one of these message is not received before the ToJoinResp\
    \ timer\n   expires, the ST agent aborts the stream join attempt and returns an\n\
    \   error corresponding with ReasonCode (RetransTimeout) to the\n   application.\n\
    \   Note that, after correctly receiving the ACK to a JOIN message,\n   intermediate\
    \ ST agents do not maintain any state on the stream\n   joining attempt. As a\
    \ consequence, they do not set the ToJoinResp\n   timer and do not wait for a\
    \ CONNECT or JOIN-REJECT message. This is\n   described in Section 4.6.3.\n"
- title: 5.2.9  Failure due to JOIN-REJECT Acknowledgment Timeout
  contents:
  - "5.2.9  Failure due to JOIN-REJECT Acknowledgment Timeout\n   An ST agent that\
    \ sends a JOIN-REJECT message toward the target\n   expects an ACK from a neighbor\
    \ ST agent. If no ACK is received before\n   the ToJoinReject timeout expires,\
    \ the ST agent should retry and send\n   the JOIN-REJECT message again. After\
    \ NJoinReject unsuccessful\n   retries, the ST agent simply gives up.\n"
- title: 5.2.10  Failure due to NOTIFY Acknowledgment Timeout
  contents:
  - "5.2.10  Failure due to NOTIFY Acknowledgment Timeout\n   An ST agent that sends\
    \ a NOTIFY message to a neighbor ST agent\n   expects an ACK from that neighbor\
    \ ST agent. If no ACK is received\n   before the ToNotify timeout expires, the\
    \ ST agent should retry and\n   send the NOTIFY message again. After NNotify unsuccessful\
    \ retries,\n   the ST agent simply gives up and behaves as if the ACK message\
    \ was\n   received.\n"
- title: 5.2.11  Failure due to REFUSE Acknowledgment Timeout
  contents:
  - "5.2.11  Failure due to REFUSE Acknowledgment Timeout\n   An ST agent that sends\
    \ a REFUSE message upstream expects an ACK from\n   the previous-hop ST agent.\
    \ If no ACK is received before the ToRefuse\n   timeout expires, the ST agent\
    \ should retry and send the REFUSE\n   message again. After NRefuse unsuccessful\
    \ retries, the ST agent gives\n   up and it assumes it is not part in the stream\
    \ any more.\n"
- title: 5.2.12  Failure due to STATUS Response Timeout
  contents:
  - "5.2.12  Failure due to STATUS Response Timeout\n   After sending a STATUS message\
    \ to a neighbor ST agent, an ST agent\n   expects to receive a STATUS-RESPONSE\
    \ message in response. If this\n   message is not received before the ToStatusResp\
    \ timer expires, the ST\n   agent sends the STATUS message again. After NStatus\
    \ unsuccessful\n   retries, the ST agent gives up and assumes that the neighbor\
    \ ST agent\n   is not active.\n"
- title: 5.3  Setup Failures due to Routing Failures
  contents:
  - "5.3  Setup Failures due to Routing Failures\n   It is possible for an ST agent\
    \ to receive a CONNECT message that\n   contains a known SID, but from an ST agent\
    \ other than the previous-\n   hop ST agent of the stream with that SID. This\
    \ may be:\n   1.  that two branches of the tree forming the stream have joined\n\
    \       back together,\n   2.  the result of an attempted recovery of a partially\
    \ failed\n       stream, or\n   3.  a routing loop.\n   The TargetList contained\
    \ in the CONNECT is used to distinguish the\n   different cases by comparing each\
    \ newly received target with those of\n   the previously existing stream:\n"
- title: 'o   if the IP address of the target(s) differ, it is case #1;'
  contents:
  - 'o   if the IP address of the target(s) differ, it is case #1;

    '
- title: o   if the target matches a target in the existing stream, it may be
  contents:
  - "o   if the target matches a target in the existing stream, it may be\n    case\
    \ #2 or #3.\n   Case #1 is handled in Section 5.3.1, while the other cases are\n\
    \   handled in Section 5.3.2.\n"
- title: 5.3.1  Path Convergence
  contents:
  - "5.3.1  Path Convergence\n   It is possible for an ST agent to receive a CONNECT\
    \ message that\n   contains a known SID, but from an ST agent other than the previous-\n\
    \   hop ST agent of the stream with that SID. This might be the result of\n  \
    \ two branches of the tree forming the stream have joined back\n   together. \
    \ Detection of this case and other possible sources was\n   discussed in Section\
    \ 5.2.\n   SCMP does not allow for streams which have converged paths, i.e.,\n\
    \   streams are always tree-shaped and not graph-like. At the point of\n   convergence,\
    \ the ST agent which detects the condition generates a\n   REFUSE message with\
    \ ReasonCode (PathConvergence). Also, as a help to\n   the upstream ST agent,\
    \ the detecting agent places the IP address of\n   one of the stream's connected\
    \ targets in the ValidTargetIPAddress\n   field of the REFUSE message. This IP\
    \ address will be used by upstream\n   ST agents to avoid splitting the stream.\n\
    \   An upstream ST agent that receives the REFUSE with ReasonCode\n   (PathConvergence)\
    \ will check to see if the listed IP address is one\n   of the known stream targets.\
    \ If it is not, the REFUSE is propagated\n   to the previous-hop agent. If the\
    \ listed IP address is known by the\n   upstream ST agent, this ST agent is the\
    \ ST agent that caused the\n   split in the stream. (This agent may even be the\
    \ origin.) This agent\n   then avoids splitting the stream by using the next-hop\
    \ of that known\n   target as the next-hop for the refused targets. It sends a\
    \ CONNECT\n   with the affected targets to the existing valid next-hop.\n   The\
    \ above process will proceed, hop by hop, until the\n   ValidTargetIPAddress matches\
    \ the IP address of a known target. The\n   only case where this process will\
    \ fail is when the known target is\n   deleted prior to the REFUSE propagating\
    \ to the origin. In this case\n   the origin can just reissue the CONNECT and\
    \ start the whole process\n   over again.\n"
- title: 5.3.2  Other Cases
  contents:
  - "5.3.2  Other Cases\n   The remaining cases including a partially failed stream\
    \ and a routing\n   loop, are not easily distinguishable. In attempting recovery\
    \ of a\n   failed stream, an ST agent may issue new CONNECT messages to the\n\
    \   affected targets. Such a CONNECT may reach an ST agent downstream of\n   the\
    \ failure before that ST agent has received a DISCONNECT from the\n   neighborhood\
    \ of the failure. Until that ST agent receives the\n   DISCONNECT, it cannot distinguish\
    \ between a failure recovery and an\n   erroneous routing loop. That ST agent\
    \ must therefore respond to the\n   CONNECT with a REFUSE message with the affected\
    \ targets specified in\n   the TargetList and an appropriate ReasonCode (StreamExists).\n\
    \   The ST agent immediately preceding that point, i.e., the latest ST\n   agent\
    \ to send the CONNECT message, will receive the REFUSE message.\n   It must release\
    \ any resources reserved exclusively for traffic to the\n   listed targets. If\
    \ this ST agent was not the one attempting the\n   stream recovery, then it cannot\
    \ distinguish between a failure\n   recovery and an erroneous routing loop. It\
    \ should repeat the CONNECT\n   after a ToConnect timeout, see Section 5.2.4.\
    \ If after NConnect\n   retransmissions it continues to receive REFUSE messages,\
    \ it should\n   propagate the REFUSE message toward the origin, with the TargetList\n\
    \   that specifies the affected targets, but with a different ReasonCode\n   (RouteLoop).\n\
    \   The REFUSE message with this ReasonCode (RouteLoop) is propagated by\n   each\
    \ ST agent without retransmitting any CONNECT messages. At each ST\n   agent,\
    \ it causes any resources reserved exclusively for the listed\n   targets to be\
    \ released. The REFUSE will be propagated to the origin\n   in the case of an\
    \ erroneous routing loop. In the case of stream\n   recovery, it will be propagated\
    \ to the ST agent that is attempting\n   the recovery, which may be an intermediate\
    \ ST agent or the origin\n   itself. In the case of a stream recovery, the ST\
    \ agent attempting the\n   recovery may issue new CONNECT messages to the same\
    \ or to different\n   next-hops.\n   If an ST agent receives both a REFUSE message\
    \ and a DISCONNECT\n   message with a target in common then it can, for the each\
    \ target in\n   common, release the relevant resources and propagate neither the\n\
    \   REFUSE nor the DISCONNECT.\n   If the origin receives such a REFUSE message,\
    \ it should attempt to\n   send a new CONNECT to all the affected targets. Since\
    \ routing errors\n   in an internet are assumed to be temporary, the new CONNECTs\
    \ will\n   eventually find acceptable routes to the targets, if one exists. If\n\
    \   no further routes exist after NRetryRoute tries, the application\n   should\
    \ be informed so that it may take whatever action it seems\n   necessary.\n"
- title: 5.4  Problems due to Routing Inconsistency
  contents:
  - "5.4  Problems due to Routing Inconsistency\n   When an intermediate ST agent\
    \ receives a CONNECT, it invokes the\n   routing algorithm to select the next-hop\
    \ ST agents based on the\n   TargetList and the networks to which it is connected.\
    \ If the\n   resulting next-hop to any of the targets is across the same network\n\
    \   from which it received the CONNECT (but not the previous-hop itself),\n  \
    \ there may be a routing problem. However, the routing algorithm at the\n   previous-\
    \ hop may be optimizing differently than the local algorithm\n   would in the\
    \ same situation. Since the local ST agent cannot\n   distinguish the two cases,\
    \ it should permit the setup but send back\n   to the previous- hop ST agent an\
    \ informative NOTIFY message with the\n   appropriate ReasonCode (RouteBack),\
    \ pertinent TargetList, and in the\n   NextHopIPAddress element the address of\
    \ the next-hop ST agent\n   returned by its routing algorithm.\n   The ST agent\
    \ that receives such a NOTIFY should ACK it. If the ST\n   agent is using an algorithm\
    \ that would produce such behavior, no\n   further action is taken; if not, the\
    \ ST agent should send a\n   DISCONNECT to the next-hop ST agent to correct the\
    \ problem.\n   Alternatively, if the next-hop returned by the routing function\
    \ is in\n   fact the previous-hop, a routing inconsistency has been detected.\
    \ In\n   this case, a REFUSE is sent back to the previous-hop ST agent\n   containing\
    \ an appropriate ReasonCode (RouteInconsist), pertinent\n   TargetList, and in\
    \ the NextHopIPAddress element the address of the\n   previous-hop. When the previous-hop\
    \ receives the REFUSE, it will\n   recompute the next-hop for the affected targets.\
    \ If there is a\n   difference in the routing databases in the two ST agents,\
    \ they may\n   exchange CONNECT and REFUSE messages again. Since such routing\
    \ errors\n   in the internet are assumed to be temporary, the situation should\n\
    \   eventually stabilize.\n"
- title: 5.5  Problems in Reserving Resources
  contents:
  - "5.5  Problems in Reserving Resources\n   As mentioned in Section 1.4.5, resource\
    \ reservation is handled by the\n   LRM. The LRM may not be able to satisfy a\
    \ particular request during\n   stream setup or modification for a number of reasons,\
    \ including a\n   mismatched FlowSpec, an unknown FlowSpec version, an error in\n\
    \   processing a FlowSpec, and an inability to allocate the requested\n   resource.\
    \ This section discusses these cases and specifies the\n   ReasonCodes that should\
    \ be used when these error cases are\n   encountered.\n"
- title: 5.5.1  Mismatched FlowSpecs
  contents:
  - "5.5.1  Mismatched FlowSpecs\n   In some cases the LRM may require a requested\
    \ FlowSpec to match an\n   existing FlowSpec, e.g., when adding new targets to\
    \ an existing\n   stream, see Section 4.6.1. In case of FlowSpec mismatch the\
    \ LRM\n   notifies the processing ST agent which should respond with ReasonCode\n\
    \   (FlowSpecMismatch).\n"
- title: 5.5.2  Unknown FlowSpec Version
  contents:
  - "5.5.2  Unknown FlowSpec Version\n   When the LRM is invoked, it is passed information\
    \ including the\n   version of the FlowSpec, see Section 4.5.2.2. If this version\
    \ is not\n   known by the LRM, the LRM notifies the ST agent. The ST agent should\n\
    \   respond with a REFUSE message with ReasonCode (FlowVerUnknown).\n"
- title: 5.5.3  LRM Unable to Process FlowSpec
  contents:
  - "5.5.3  LRM Unable to Process FlowSpec\n   The LRM may encounter an LRM or FlowSpec\
    \ specific error while\n   attempting to satisfy a request. An example of such\
    \ an error is given\n   in Section 9.2.1. These errors are implementation specific\
    \ and will\n   not be enumerated with ST ReasonCodes. They are covered by a single,\n\
    \   generic ReasonCode. When an LRM encounters such an error, it should\n   notify\
    \ the ST agent which should respond with the generic ReasonCode\n   (FlowSpecError).\n"
- title: 5.5.4  Insufficient Resources
  contents:
  - "5.5.4  Insufficient Resources\n   If the LRM cannot make the necessary reservations\
    \ because sufficient\n   resources are not available, an ST agent may:\n"
- title: 'o   try alternative paths to the targets: the ST agent calls the routing'
  contents:
  - "o   try alternative paths to the targets: the ST agent calls the routing\n  \
    \  function to find a different path to the targets. If an alternative\n    path\
    \ is found, stream connection setup continues in the usual way,\n    as described\
    \ in Section 4.5.\n"
- title: 'o   refuse to establish the stream along this path: the origin ST agent'
  contents:
  - "o   refuse to establish the stream along this path: the origin ST agent\n   \
    \ informs the application of the stream setup failure; intermediate\n    and target\
    \ ST agents issue a REFUSE message (as described in Section\n    4.5.8) with ReasonCode\
    \ (CantGetResrc).\n   It depends on the local implementations whether an ST agent\
    \ tries\n   alternative paths or refuses to establish the stream. In any case,\
    \ if\n   enough resources cannot be found over different paths, the ST agent\n\
    \   has to explicitly refuse to establish the stream.\n"
- title: 5.6  Problems Caused by CHANGE Messages
  contents:
  - "5.6  Problems Caused by CHANGE Messages\n   A CHANGE might fail for several reasons,\
    \ including:\n"
- title: 'o   insufficient resources: the request may be for a larger amount of'
  contents:
  - "o   insufficient resources: the request may be for a larger amount of\n    network\
    \ resources when those resources are not available, ReasonCode\n    (CantGetResrc);\n"
- title: o   a target application not agreeing to the change, ReasonCode
  contents:
  - "o   a target application not agreeing to the change, ReasonCode\n    (ApplRefused);\n\
    \   The affected stream can be left in one of two states as a result of\n   change\
    \ failures: a) the stream can revert back to the state it was in\n   prior to\
    \ the CHANGE message being processed, or b) the stream may be\n   torn down.\n\
    \   The expected common case of failure will be when the requested change\n  \
    \ cannot be satisfied, but the pre-change resources remain allocated\n   and available\
    \ for use by the stream. In this case, the ST agent at\n   the point where the\
    \ failure occurred must inform upstream ST agents\n   of the failure. (In the\
    \ case where this ST agent is the target, there\n   may not actually be a failure,\
    \ the application may merely have not\n   agreed to the change). The ST agent\
    \ informs upstream ST agents by\n   sending a REFUSE message with ReasonCode (CantGetResrc\
    \ or\n   ApplRefused). To indicate that the pre-change FlowSpec is still\n   available\
    \ and that the stream still exists, the ST agent sets the E-\n   bit of the REFUSE\
    \ message to one (1), see Section 10.4.11. Upstream\n   ST agents receiving the\
    \ REFUSE message inform the LRM so that it can\n   attempt to revert back to the\
    \ pre-change FlowSpec. It is permissible,\n   but not desirable, for excess resources\
    \ to remain allocated.\n   For the case when the attempt to change the stream\
    \ results in the\n   loss of previously reserved resources, the stream is torn\
    \ down. This\n   can happen, for instance, when the I-bit is set (Section 4.6.5)\
    \ and\n   the LRM releases pre-change stream resources before the new ones are\n\
    \   reserved, and neither new nor former resources are available. In this\n  \
    \ case, the ST agent where the failure occurs must inform other ST\n   agents\
    \ of the break in the affected portion of the stream. This is\n   done by the\
    \ ST agent by sending a REFUSE message upstream and a\n   DISCONNECT message downstream,\
    \ both with the ReasonCode\n   (CantGetResrc). To indicate that pre-change stream\
    \ resources have\n   been lost, the E-bit of the REFUSE message is set to zero\
    \ (0).\n   Note that a failure to change the resources requested for specific\n\
    \   targets should not cause other targets in the stream to be deleted.\n"
- title: 5.7  Unknown Targets in DISCONNECT and CHANGE
  contents:
  - "5.7  Unknown Targets in DISCONNECT and CHANGE\n   The handling of unknown targets\
    \ listed in a DISCONNECT or CHANGE\n   message is dependent on a stream's join\
    \ authorization level, see\n   Section 4.4.2. For streams with join authorization\
    \ levels #0 and #1,\n   see Section 4.4.2, all targets must be known. In this\
    \ case, when\n   processing a CHANGE message, the agent should generate a REFUSE\n\
    \   message with ReasonCode (TargetUnknown). When processing a DISCONNECT\n  \
    \ message, it is possible that the DISCONNECT is a duplicate of an old\n   request\
    \ so the agent should respond as if it has successfully\n   disconnected the target.\
    \ That is, it should respond with an ACK\n   message.\n   For streams with join\
    \ authorization level #2, it is possible that the\n   origin is not aware of some\
    \ targets that participate in the stream.\n   The origin may delete or change\
    \ these targets via the following\n   flooding mechanism.\n   If no next-hop ST\
    \ agent can be associated with a target, the CHANGE/\n   DISCONNECT message including\
    \ the target is replicated to all known\n   next-hop ST agents. This has the effect\
    \ of propagating the CHANGE/\n   DISCONNECT message to all downstream ST agents.\
    \ Eventually, the ST\n   agent that acts as the origin for the target (Section\
    \ 4.6.3.1) is\n   reached and the target is deleted.\n   Target deletion/change\
    \ via flooding is not expected to be the normal\n   case. It is included to present\
    \ the applications with uniform\n   capabilities for all stream types. Flooding\
    \ only applies to streams\n   with join authorization level #2.\n"
- title: 6.  Failure Detection and Recovery
  contents:
  - '6.  Failure Detection and Recovery

    '
- title: 6.1  Failure Detection
  contents:
  - "6.1  Failure Detection\n   The SCMP failure detection mechanism is based on two\
    \ assumptions:\n"
- title: 1.  If a neighbor of an ST agent is up, and has been up without a
  contents:
  - "1.  If a neighbor of an ST agent is up, and has been up without a\n    disruption,\
    \ and has not notified the ST agent of a problem with\n    streams that pass through\
    \ both, then the ST agent can assume that\n    there has not been any problem\
    \ with those streams.\n"
- title: 2.  A network through which an ST agent has routed a stream will notify
  contents:
  - "2.  A network through which an ST agent has routed a stream will notify\n   \
    \ the ST agent if there is a problem that affects the stream data\n    packets\
    \ but does not affect the control packets.\n   The purpose of the robustness protocol\
    \ defined here is for ST agents\n   to determine that the streams through a neighbor\
    \ have been broken by\n   the failure of the neighbor or the intervening network.\
    \ This protocol\n   should detect the overwhelming majority of failures that can\
    \ occur.\n   Once a failure is detected, the recovery procedures described in\n\
    \   Section 6.2 are initiated by the ST agents.\n"
- title: 6.1.1  Network Failures
  contents:
  - "6.1.1  Network Failures\n   An ST agent can detect network failures by two mechanisms:\n\
    \   o   the network can report a failure, or\n   o   the ST agent can discover\
    \ a failure by itself.\n   They differ in the amount of information that an ST\
    \ agent has\n   available to it in order to make a recovery decision. For example,\
    \ a\n   network may be able to report that reserved bandwidth has been lost\n\
    \   and the reason for the loss and may also report that connectivity to\n   the\
    \ neighboring ST agent remains intact. On the other hand, an ST\n   agent may\
    \ discover that communication with a neighboring ST agent has\n   ceased because\
    \ it has not received any traffic from that neighbor in\n   some time period.\
    \ If an ST agent detects a failure, it may not be\n   able to determine if the\
    \ failure was in the network while the\n   neighbor remains available, or the\
    \ neighbor has failed while the\n   network remains intact.\n"
- title: 6.1.2  Detecting ST Agents Failures
  contents:
  - "6.1.2  Detecting ST Agents Failures\n   Each ST agent periodically sends each\
    \ neighbor with which it shares\n   one or more streams a HELLO message. This\
    \ message exchange is between\n   ST agents, not entities representing streams\
    \ or applications. That\n   is, an ST agent need only send a single HELLO message\
    \ to a neighbor\n   regardless of the number of streams that flow between them.\
    \ All ST\n   agents (host as well as intermediate) must participate in this\n\
    \   exchange. However, only ST agents that share active streams can\n   participate\
    \ in this exchange and it is an error to send a HELLO\n   message to a neighbor\
    \ ST agent with no streams in common, e.g., to\n   check whether it is active.\
    \ STATUS messages can be used to poll the\n   status of neighbor ST agents, see\
    \ Section 8.4.\n   For the purpose of HELLO message exchange, stream existence\
    \ is\n   bounded by ACCEPT and DISCONNECT/REFUSE processing and is defined for\n\
    \   both the upstream and downstream case. A stream to a previous-hop is\n   defined\
    \ to start once an ACCEPT message has been forwarded upstream.\n   A stream to\
    \ a next-hop is defined to start once the received ACCEPT\n   message has been\
    \ acknowledged. A stream is defined to terminate once\n   an acknowledgment is\
    \ sent for a received DISCONNECT or REFUSE\n   message, and an acknowledgment\
    \ for a sent DISCONNECT or REFUSE\n   message has been received.\n   The HELLO\
    \ message has two fields:\n   o   a HelloTimer field that is in units of milliseconds\
    \ modulo the\n       maximum for the field size, and\n   o   a Restarted-bit specifying\
    \ that the ST agent has been restarted\n       recently.\n   The HelloTimer must\
    \ appear to be incremented every millisecond\n   whether a HELLO message is sent\
    \ or not. The HelloTimer wraps around\n   to zero after reaching the maximum value.\
    \ Whenever an ST agent\n   suffers a catastrophic event that may result in it\
    \ losing ST state\n   information, it must reset its HelloTimer to zero and must\
    \ set the\n   Restarted-bit in all HELLO messages sent in the following\n   HelloTimerHoldDown\
    \ seconds.\n   If an ST agent receives a HELLO message that contains the Restarted-\n\
    \   bit set, it must assume that the sending ST agent has lost its state.\n  \
    \ If it shares streams with that neighbor, it must initiate stream\n   recovery\
    \ activity, see Section 6.2. If it does not share streams with\n   that neighbor,\
    \ it should not attempt to create one until that bit is\n   no longer set. If\
    \ an ST agent receives a CONNECT message from a\n   neighbor whose Restarted-bit\
    \ is still set, the agent must respond\n   with an ERROR message with the appropriate\
    \ ReasonCode\n   (RestartRemote). If an agent receives a CONNECT message while\
    \ the\n   agent's own Restarted- bit is set, the agent must respond with an\n\
    \   ERROR message with the appropriate ReasonCode (RestartLocal).\n   Each ST\
    \ stream has an associated RecoveryTimeout value. This value is\n   assigned by\
    \ the origin and carried in the CONNECT message, see\n   Section 4.5.10. Each\
    \ agent checks to see if it can support the\n   requested value. If it can not,\
    \ it updates the value to the smallest\n   timeout interval it can support. The\
    \ RecoveryTimeout used by a\n   particular stream is obtained from the ACCEPT\
    \ message, see Section\n   4.5.10, and is the smallest value seen across all ACCEPT\
    \ messages\n   from participating targets.\n   An ST agent must send HELLO messages\
    \ to its neighbor with a period\n   shorter than the smallest RecoveryTimeout\
    \ of all the active streams\n   that pass between the two ST agents, regardless\
    \ of direction. This\n   period must be smaller by a factor, called HelloLossFactor,\
    \ which is\n   at least as large as the greatest number of consecutive HELLO\n\
    \   messages that could credibly be lost while the communication between\n   the\
    \ two ST agents is still viable.\n   An ST agent may send simultaneous HELLO messages\
    \ to all its neighbors\n   at the rate necessary to support the smallest RecoveryTimeout\
    \ of any\n   active stream. Alternately, it may send HELLO messages to different\n\
    \   neighbors independently at different rates corresponding to\n   RecoveryTimeouts\
    \ of individual streams.\n   An ST agent must expect to receive at least one new\
    \ HELLO message\n   from each neighbor at least as frequently as the smallest\n\
    \   RecoveryTimeout of any active stream in common with that neighbor.\n   The\
    \ agent can detect duplicate or delayed HELLO messages by comparing\n   the HelloTimer\
    \ field of the most recent valid HELLO message from that\n   neighbor with the\
    \ HelloTimer field of an incoming HELLO message.\n   Valid incoming HELLO messages\
    \ will have a HelloTimer field that is\n   greater than the field contained in\
    \ the previously received valid\n   HELLO message by the time elapsed since the\
    \ previous message was\n   received. Actual evaluation of the elapsed time interval\
    \ should take\n   into account the maximum likely delay variance from that neighbor.\n\
    \   If the ST agent does not receive a valid HELLO message within the\n   RecoveryTimeout\
    \ period of a stream, it must assume that the\n   neighboring ST agent or the\
    \ communication link between the two has\n   failed and it must initiate stream\
    \ recovery activity, as described\n   below in Section 6.2.\n"
- title: 6.2  Failure Recovery
  contents:
  - "6.2  Failure Recovery\n   If an intermediate ST agent fails or a network or part\
    \ of a network\n   fails, the previous-hop ST agent and the various next-hop ST\
    \ agents\n   will discover the fact by the failure detection mechanism described\n\
    \   in Section 6.1.\n   The recovery of an ST stream is a relatively complex and\
    \ time\n   consuming effort because it is designed in a general manner to\n  \
    \ operate across a large number of networks with diverse\n   characteristics.\
    \  Therefore, it may require information to be\n   distributed widely, and may\
    \ require relatively long timers. On the\n   other hand, since a network is typically\
    \ a homogeneous system,\n   failure recovery in the network may be a relatively\
    \ faster and\n   simpler operation. Therefore an ST agent that detects a failure\n\
    \   should attempt to fix the network failure before attempting recovery\n   of\
    \ the ST stream. If the stream that existed between two ST agents\n   before the\
    \ failure cannot be reconstructed by network recovery\n   mechanisms alone, then\
    \ the ST stream recovery mechanism must be\n   invoked.\n   If stream recovery\
    \ is necessary, the different ST agents will need to\n   perform different functions,\
    \ depending on their relation to the\n   failure:\n"
- title: o   An ST agent that is a next-hop from a failure should first verify
  contents:
  - "o   An ST agent that is a next-hop from a failure should first verify\n    that\
    \ there was a failure. It can do this using STATUS messages to\n    query its\
    \ upstream neighbor. If it cannot communicate with that\n    neighbor, then for\
    \ each active stream from that neighbor it should\n    first send a REFUSE message\
    \ upstream with the appropriate ReasonCode\n    (STAgentFailure). This is done\
    \ to the neighbor to speed up the\n    failure recovery in case the hop is unidirectional,\
    \ i.e., the\n    neighbor can hear the ST agent but the ST agent cannot hear the\n\
    \    neighbor. The ST agent detecting the failure must then, for each\n    active\
    \ stream from that neighbor, send DISCONNECT messages with the\n    same ReasonCode\
    \ toward the targets. All downstream ST agents process\n    this DISCONNECT message\
    \ just like the DISCONNECT that tears down the\n    stream. If recovery is successful,\
    \ targets will receive new CONNECT\n    messages.\n"
- title: o   An ST agent that is the previous-hop before the failed component
  contents:
  - "o   An ST agent that is the previous-hop before the failed component\n    first\
    \ verifies that there was a failure by querying the downstream\n    neighbor using\
    \ STATUS messages. If the neighbor has lost its state\n    but is available, then\
    \ the ST agent may try and reconstruct\n    (explained below) the affected streams,\
    \ for those streams that do\n    not have the NoRecovery option selected. If it\
    \ cannot communicate\n    with the next-hop, then the ST agent detecting the failure\
    \ sends a\n    DISCONNECT message, for each affected stream, with the appropriate\n\
    \    ReasonCode (STAgentFailure) toward the affected targets. It does so\n   \
    \ to speed up failure recovery in case the communication may be\n    unidirectional\
    \ and this message might be delivered successfully.\n   Based on the NoRecovery\
    \ option, the ST agent that is the previous-hop\n   before the failed component\
    \ takes the following actions:\n"
- title: o   If the NoRecovery option is selected, then the ST agent sends, per
  contents:
  - "o   If the NoRecovery option is selected, then the ST agent sends, per\n    affected\
    \ stream, a REFUSE message with the appropriate ReasonCode\n    (STAgentFailure)\
    \ to the previous-hop. The TargetList in these\n    messages contains all the\
    \ targets that were reached through the\n    broken branch. As discussed in Section\
    \ 5.1.2, multiple REFUSE\n    messages may be required if the PDU is too long\
    \ for the MTU of the\n    intervening network. The REFUSE message is propagated\
    \ all the way to\n    the origin. The application at the origin can attempt recovery\
    \ of\n    the stream by sending a new CONNECT to the affected targets. For\n \
    \   established streams, the new CONNECT will be treated by intermediate\n   \
    \ ST agents as an addition of new targets into the established stream.\n"
- title: o   If the NoRecovery option is not selected, the ST agent can attempt
  contents:
  - "o   If the NoRecovery option is not selected, the ST agent can attempt\n    recovery\
    \ of the affected streams. It does so one a stream by stream\n    basis by issuing\
    \ a new CONNECT message to the affected targets. If\n    the ST agent cannot find\
    \ new routes to some targets, or if the only\n    route to some targets is through\
    \ the previous-hop, then it sends one\n    or more REFUSE messages to the previous-hop\
    \ with the appropriate\n    ReasonCode (CantRecover) specifying the affected targets\
    \ in the\n    TargetList. The previous-hop can then attempt recovery of the stream\n\
    \    by issuing a CONNECT to those targets. If it cannot find an\n    appropriate\
    \ route, it will propagate the REFUSE message toward the\n    origin.\n   Regardless\
    \ of which ST agent attempts recovery of a damaged stream,\n   it will issue one\
    \ or more CONNECT messages to the affected targets.\n   These CONNECT messages\
    \ are treated by intermediate ST agents as\n   additions of new targets into the\
    \ established stream. The FlowSpecs\n   of the new CONNECT messages are the same\
    \ as the ones contained in the\n   most recent CONNECT or CHANGE messages that\
    \ the ST agent had sent\n   toward the affected targets when the stream was operational.\n\
    \   Upon receiving an ACCEPT during the a stream recovery, the agent\n   reconstructing\
    \ the stream must ensure that the FlowSpec and other\n   stream attributes (e.g.,\
    \ MaxMsgSize and RecoveryTimeout) of the re-\n   established stream are equal\
    \ to, or are less restrictive, than the\n   pre-failure stream. If they are more\
    \ restrictive, the recovery\n   attempt must be aborted. If they are equal, or\
    \ are less restrictive,\n   then the recovery attempt is successful. When the\
    \ attempt is a\n   success, failure recovery related ACCEPTs are not forwarded\
    \ upstream\n   by the recovering agent.\n   Any ST agent that decides that enough\
    \ recovery attempts have been\n   made, or that recovery attempts have no chance\
    \ of succeeding, may\n   indicate that no further attempts at recovery should\
    \ be made. This is\n   done by setting the N-bit in the REFUSE message, see Section\
    \ 10.4.11.\n   This bit must be set by agents, including the target, that know\
    \ that\n   there is no chance of recovery succeeding. An ST agent that receives\n\
    \   a REFUSE message with the N-bit set (1) will not attempt recovery,\n   regardless\
    \ of the NoRecovery option, and it will set the N-bit when\n   propagating the\
    \ REFUSE message upstream.\n"
- title: 6.2.1  Problems in Stream Recovery
  contents:
  - "6.2.1  Problems in Stream Recovery\n   The reconstruction of a broken stream\
    \ may not proceed smoothly. Since\n   there may be some delay while the information\
    \ concerning the failure\n   is propagated throughout an internet, routing errors\
    \ may occur for\n   some time after a failure. As a result, the ST agent attempting\
    \ the\n   recovery may receive ERROR messages for the new CONNECTs that are\n\
    \   caused by internet routing errors. The ST agent attempting the\n   recovery\
    \ should be prepared to resend CONNECTs before it succeeds in\n   reconstructing\
    \ the stream. If the failure partitions the internet and\n   a new set of routes\
    \ cannot be found to the targets, the REFUSE\n   messages will eventually be propagated\
    \ to the origin, which can then\n   inform the application so it can decide whether\
    \ to terminate or to\n   continue to attempt recovery of the stream.\n   The new\
    \ CONNECT may at some point reach an ST agent downstream of the\n   failure before\
    \ the DISCONNECT does. In this case, the ST agent that\n   receives the CONNECT\
    \ is not yet aware that the stream has suffered a\n   failure, and will interpret\
    \ the new CONNECT as resulting from a\n   routing failure. It will respond with\
    \ an ERROR message with the\n   appropriate ReasonCode (StreamExists). Since the\
    \ timeout that the ST\n   agents immediately preceding the failure and immediately\
    \ following\n   the failure are approximately the same, it is very likely that\
    \ the\n   remnants of the broken stream will soon be torn down by a DISCONNECT\n\
    \   message. Therefore, the ST agent that receives the ERROR message with\n  \
    \ ReasonCode (StreamExists) should retransmit the CONNECT message after\n   the\
    \ ToConnect timeout expires. If this fails again, the request will\n   be retried\
    \ for NConnect times. Only if it still fails will the ST\n   agent send a REFUSE\
    \ message with the appropriate ReasonCode\n   (RouteLoop) to its previous-hop.\
    \ This message will be propagated back\n   to the ST agent that is attempting\
    \ recovery of the damaged stream.\n   That ST agent can issue a new CONNECT message\
    \ if it so chooses. The\n   REFUSE is matched to a CONNECT message created by\
    \ a recovery\n   operation through the LnkReference field in the CONNECT.\n  \
    \ ST agents that have propagated a CONNECT message and have received a\n   REFUSE\
    \ message should maintain this information for some period of\n   time. If an\
    \ ST agent receives a second CONNECT message for a target\n   that recently resulted\
    \ in a REFUSE, that ST agent may respond with a\n   REFUSE immediately rather\
    \ than attempting to propagate the CONNECT.\n   This has the effect of pruning\
    \ the tree that is formed by the\n   propagation of CONNECT messages to a target\
    \ that is not reachable by\n   the routes that are selected first. The tree will\
    \ pass through any\n   given ST agent only once, and the stream setup phase will\
    \ be\n   completed faster.\n   If a CONNECT message reaches a target, the target\
    \ should as\n   efficiently as possible use the state that it has saved from before\n\
    \   the stream failed during recovery of the stream. It will then issue\n   an\
    \ ACCEPT message toward the origin. The ACCEPT message will be\n   intercepted\
    \ by the ST agent that is attempting recovery of the\n   damaged stream, if not\
    \ the origin. If the FlowSpec contained in the\n   ACCEPT specifies the same selection\
    \ of parameters as were in effect\n   before the failure, then the ST agent that\
    \ is attempting recovery\n   will not propagate the ACCEPT. FlowSpec comparison\
    \ is done by the\n   LRM. If the selections of the parameters are different, then\
    \ the ST\n   agent that is attempting recovery will send the origin a NOTIFY\n\
    \   message with the appropriate ReasonCode (FailureRecovery) that\n   contains\
    \ a FlowSpec that specifies the new parameter values. The\n   origin may then\
    \ have to change its data generation characteristics\n   and the stream's parameters\
    \ with a CHANGE message to use the newly\n   recovered subtree.\n"
- title: 6.3  Stream Preemption
  contents:
  - "6.3  Stream Preemption\n   As mentioned in Section 1.4.5, it is possible that\
    \ the LRM decides to\n   break a stream intentionally. This is called stream preemption.\n\
    \   Streams are expected to be preempted in order to free resources for a\n  \
    \ new stream which has a higher priority.\n   If the LRM decides that it is necessary\
    \ to preempt one or more of the\n   stream traversing it, the decision on which\
    \ streams have to be\n   preempted has to be made. There are two ways for an application\
    \ to\n   influence such decision:\n   1.  based on FlowSpec information. For instance,\
    \ with the ST2+\n       FlowSpec, streams can be assigned a precedence value from\
    \ 0\n       (least important) to 256 (most important). This value is\n       carried\
    \ in the FlowSpec when the stream is setup, see Section\n       9.2, so that the\
    \ LRM is informed about it.\n   2.  with the group mechanism. An application may\
    \ specify that a set\n       of streams are related to each other and that they\
    \ are all\n       candidate for preemption if one of them gets preempted. It can\n\
    \       be done by using the fate-sharing relationship defined in\n       Section\
    \ 7.1.2. This helps the LRM making a good choice when\n       more than one stream\
    \ have to be preempted, because it leads to\n       breaking a single application\
    \ as opposed to as many\n       applications as the number of preempted streams.\n\
    \   If the LRM preempts a stream, it must notify the local ST agent. The\n   following\
    \ actions are performed by the ST agent:\n"
- title: o   The ST agent at the host where the stream was preempted sends
  contents:
  - "o   The ST agent at the host where the stream was preempted sends\n    DISCONNECT\
    \ messages with the appropriate ReasonCode\n    (StreamPreempted) toward the affected\
    \ targets. It sends a REFUSE\n    message with the appropriate ReasonCode (StreamPreempted)\
    \ to the\n    previous-hop.\n"
- title: o   A previous-hop ST agent of the preempted stream acts as in case of
  contents:
  - "o   A previous-hop ST agent of the preempted stream acts as in case of\n    failure\
    \ recovery, see Section 6.2.\n"
- title: o   A next-hop ST agent of the preempted stream acts as in case of
  contents:
  - "o   A next-hop ST agent of the preempted stream acts as in case of\n    failure\
    \ recovery, see Section 6.2.\n   Note that, as opposite to failure recovery, there\
    \ is no need to\n   verify that the failure actually occurred, because this is\
    \ explicitly\n   indicated by the ReasonCode (StreamPreempted).\n"
- title: 7.  A Group of Streams
  contents:
  - "7.  A Group of Streams\n   There may be need to associate related streams. The\
    \ group mechanism\n   is simply an association technique that allows ST agents\
    \ to identify\n   the different streams that are to be associated.\n   A group\
    \ consists of a set of streams and a relationship. The set of\n   streams may\
    \ be empty. The relationship applies to all group members.\n   Each group is identified\
    \ by a group name. The group name must be\n   globally unique.\n   Streams belong\
    \ to the same group if they have the same GroupName in\n   the GroupName field\
    \ of the Group parameter, see Section 10.3.2. The\n   relationship is defined\
    \ by the Relationship field. Group membership\n   must be specified at stream\
    \ creation time and persists for the whole\n   stream lifetime. A single stream\
    \ may belong to multiple groups.\n   The ST agent that creates a new group is\
    \ called group initiator. Any\n   ST agent can be a group initiator. The initiator\
    \ allocates the\n   GroupName and the Relationship among group members. The initiator\
    \ may\n   or may not be the origin of a stream belonging to the group.\n   GroupName\
    \ generation is described in Section 8.2.\n"
- title: 7.1  Basic Group Relationships
  contents:
  - "7.1  Basic Group Relationships\n   This version of ST defines four basic group\
    \ relationships. An ST2+\n   implementation must support all four basic relationships.\
    \ Adherence\n   to specified relationships are usually best effort. The basic\n\
    \   relationships are described in detail below in Section 7.1.1 -\n   Section\
    \ 7.1.4.\n"
- title: 7.1.1  Bandwidth Sharing
  contents:
  - "7.1.1  Bandwidth Sharing\n   Streams associated with the same group share the\
    \ same network\n   bandwidth. The intent is to support applications such as audio\n\
    \   conferences where, of all participants, only some are allowed to\n   speak\
    \ at one time. In such a scenario, global bandwidth utilization\n   can be lowered\
    \ by allocating only those resources that can be used at\n   once, e.g., it is\
    \ sufficient to reserve bandwidth for a small set of\n   audio streams.\n   The\
    \ basic concept of a shared bandwidth group is that the LRM will\n   allocate\
    \ up to some specified multiplier of the most demanding stream\n   that it knows\
    \ about in the group. The LRM will allocate resources\n   incrementally, as stream\
    \ setup requests are received, until the total\n   group requirements are satisfied.\
    \ Subsequent setup requests will\n   share the group's resources and will not\
    \ need any additional\n   resources allocated. The procedure will result in standard\
    \ allocation\n   where only one stream in a group traverses an agent, and shared\n\
    \   allocations where multiple streams traverse an agent.\n   To illustrate, let's\
    \ call the multiplier mentioned above \"N\", and the\n   most demanding stream\
    \ that an agent knows about in a group Bmax. For\n   an application that intends\
    \ to allow three participants to speak at\n   the same time, N has a value of\
    \ three and each LRM will allocate for\n   the group an amount of bandwidth up\
    \ to 3*Bmax even when there are\n   many more steams in the group. The LRM will\
    \ reserve resources\n   incrementally, per stream request, until N*Bmax resources\
    \ are\n   allocated. Each agent may be traversed by a different set and number\n\
    \   of streams all belonging to the same group.\n   An ST agent receiving a stream\
    \ request presents the LRM with all\n   necessary group information, see Section\
    \ 4.5.2.2. If maximum\n   bandwidth, N*Bmax, for the group has already been allocated\
    \ and a new\n   stream with a bandwidth demand less than Bmax is being established,\n\
    \   the LRM won't allocate any further bandwidth.\n   If there is less than N*Bmax\
    \ resources allocated, the LRM will expand\n   the resources allocated to the\
    \ group by the amount requested in the\n   new FlowSpec, up to N*Bmax resources.\
    \ The LRM will update the\n   FlowSpec based on what resources are available to\
    \ the stream, but not\n   the total resources allocated for the group.\n   It\
    \ should be noted that ST agents and LRMs become aware of a group's\n   requirements\
    \ only when the streams belonging to the group are\n   created.  In case of the\
    \ bandwidth sharing relationship, an\n   application should attempt to establish\
    \ the most demanding streams\n   first to minimize stream setup efforts. If on\
    \ the contrary the less\n   demanding streams are built first, it will be always\
    \ necessary to\n   allocate additional bandwidth in consecutive steps as the most\n\
    \   demanding streams are built. It is also up to the applications to\n   coordinate\
    \ their different FlowSpecs and decide upon an appropriate\n   value for N.\n"
- title: 7.1.2  Fate Sharing
  contents:
  - "7.1.2  Fate Sharing\n   Streams belonging to this group share the same fate.\
    \ If a stream is\n   deleted, the other members of the group are also deleted.\
    \ This is\n   intended to support stream preemption by indicating which streams\
    \ are\n   mutually related. If preemption of multiple streams is necessary,\n\
    \   this information can be used by the LRM to delete a set of related\n   streams,\
    \ e.g., with impact on a single application, instead of making\n   a random choice\
    \ with the possible effect of interrupting several\n   different applications.\
    \ This attribute does not apply to normal\n   stream shut down, i.e., ReasonCode\
    \ (ApplDisconnect). On normal\n   disconnect, other streams belonging to such\
    \ groups remain active.\n   This relationship provides a hint on which streams\
    \ should be\n   preempted. Still, the LRM responsible for the preemption is not\n\
    \   forced to behave accordingly, and other streams could be preempted\n   first\
    \ based on different criteria.\n"
- title: 7.1.3  Route Sharing
  contents:
  - "7.1.3  Route Sharing\n   Streams belonging to this group share the same paths\
    \ as much as is\n   possible. This can be desirable for several reasons, e.g.,\
    \ to exploit\n   the same allocated resources or in the attempt to maintain the\n\
    \   transmission order. An ST agent attempts to select the same path\n   although\
    \ the way this is implemented depends heavily on the routing\n   algorithm which\
    \ is used.\n   If the routing algorithm is sophisticated enough, an ST agent can\n\
    \   suggest that a stream is routed over an already established path.\n   Otherwise,\
    \ it can ask the routing algorithm for a set of legal routes\n   to the destination\
    \ and check whether the desired path is included in\n   those feasible.\n   Route\
    \ sharing is a hint to the routing algorithm used by ST. Failing\n   to route\
    \ a stream through a shared path should not prevent the\n   creation of a new\
    \ stream or result in the deletion of an existing\n   stream.\n"
- title: 7.1.4  Subnet Resources Sharing
  contents:
  - "7.1.4  Subnet Resources Sharing\n   This relationship provides a hint to the\
    \ data link layer functions.\n   Streams belonging to this group may share the\
    \ same MAC layer\n   resources. As an example, the same MAC layer multicast address\
    \ may be\n   used for all the streams in a given group. This mechanism allows\
    \ for\n   a better utilization of MAC layer multicast addresses and it is\n  \
    \ especially useful when used with network adapters that offer a very\n   small\
    \ number of MAC layer multicast addresses.\n"
- title: 7.2  Relationships Orthogonality
  contents:
  - "7.2  Relationships Orthogonality\n   The four basic relationships, as they have\
    \ been defined, are\n   orthogonal. This means, any combinations of the basic\
    \ relationships\n   are allowed. For instance, let's consider an application that\n\
    \   requires full-duplex service for a stream with multiple targets.\n   Also,\
    \ let's suppose that only N targets are allowed to send data back\n   to the origin\
    \ at the same time. In this scenario, all the reverse\n   streams could belong\
    \ to the same group. They could be sharing both\n   the paths and the bandwidth\
    \ attributes. The Path&Bandwidth sharing\n   relationship is obtained from the\
    \ basic set of relationships. This\n   example is important because it shows how\
    \ full-duplex service can be\n   efficiently obtained in ST.\n"
- title: 8.  Ancillary Functions
  contents:
  - "8.  Ancillary Functions\n   Certain functions are required by ST host and intermediate\
    \ agent\n   implementations. Such functions are described in this section.\n"
- title: 8.1  Stream ID Generation
  contents:
  - "8.1  Stream ID Generation\n   The stream ID, or SID, is composed of 16-bit unique\
    \ identifier and\n   the stream origin's 32-bit IP address. Stream IDs must be\
    \ globally\n   unique.  The specific definition and format of the 16 -bit field\
    \ is\n   left to the implementor. This field is expected to have only local\n\
    \   significance.\n   An ST implementation has to provide a stream ID generator\
    \ facility,\n   so that an application or higher layer protocol can obtain a unique\n\
    \   IDs from the ST layer. This is a mechanism for the application to\n   request\
    \ the allocation of stream ID that is independent of the\n   request to create\
    \ a stream. The Stream ID is used by the application\n   or higher layer protocol\
    \ when creating the streams.\n   For instance, the following two functions could\
    \ be made available:\n   o   AllocateStreamID() -> result, StreamID\n   o   ReleaseStreamID(StreamID)\
    \ -> result\n   An implementation may also provide a StreamID deletion function.\n"
- title: 8.2  Group Name Generator
  contents:
  - "8.2  Group Name Generator\n   GroupName generation is similar to Stream ID generation.\
    \ The\n   GroupName includes a 16-bit unique identifier, a 32-bit creation\n \
    \  timestamp, and a 32-bit IP address. Group names are globally unique.\n   A\
    \ GroupName includes the creator's IP address, so this reduces a\n   global uniqueness\
    \ problem to a simple local problem. The specific\n   definitions and formats\
    \ of the 16-bit field and the 32-bit creation\n   timestamp are left to the implementor.\
    \ These fields must be locally\n   unique, and only have local significance.\n\
    \   An ST implementation has to provide a group name generator facility,\n   so\
    \ that an application or higher layer protocol can obtain a unique\n   GroupName\
    \ from the ST layer. This is a mechanism for the application\n   to request the\
    \ allocation of a GroupName that is independent of the\n   request to create a\
    \ stream. The GroupName is used by the application\n   or higher layer protocol\
    \ when creating the streams that are to be\n   part of the group.\n   For instance,\
    \ the following two functions could be made available:\n   o   AllocateGroupName()\
    \ -> result, GroupName\n   o   ReleaseGroupName(GroupName) -> result\n   An implementation\
    \ may also provide a GroupName deletion function.\n"
- title: 8.3  Checksum Computation
  contents:
  - "8.3  Checksum Computation\n   The standard Internet checksum algorithm is used\
    \ for ST: \"The\n   checksum field is the 16-bit one's complement of the one's\
    \ complement\n   sum of all 16-bit words in the header. For purposes of computing\
    \ the\n   checksum, the value of the checksum field is zero (0).\" See\n   [RFC1071],\
    \ [RFC1141], and [RFC791] for suggestions for efficient\n   checksum algorithms.\n"
- title: 8.4  Neighbor ST Agent Identification and Information Collection
  contents:
  - "8.4  Neighbor ST Agent Identification and Information Collection\n   The STATUS\
    \ message can be used to collect information about neighbor\n   ST agents, streams\
    \ the neighbor supports, and specific targets of\n   streams the neighbor supports.\
    \ An agent receiving a STATUS message\n   provides the requested information via\
    \ a STATUS-RESPONSE message.\n   The STATUS message can be used to collect different\
    \ information from\n   a neighbor. It can be used to:\n"
- title: o   identify ST capable neighbors. If an ST agent wishes to check if
  contents:
  - "o   identify ST capable neighbors. If an ST agent wishes to check if\n    a neighbor\
    \ is ST capable, it should generate a STATUS message with\n    an SID which has\
    \ all its fields set to zero. An agent receiving a\n    STATUS message with such\
    \ SID should answer with a STATUS-RESPONSE\n    containing the same SID, and no\
    \ other stream information. The\n    receiving ST agent must answer as soon as\
    \ possible to aid in Round\n    Trip Time estimation, see Section 8.5;\n"
- title: o   obtain information on a particular stream. If an ST agent wishes to
  contents:
  - "o   obtain information on a particular stream. If an ST agent wishes to\n   \
    \ check a neighbor's general information related to a specific\n    stream, it\
    \ should generate a STATUS message containing the stream's\n    SID. An ST agent\
    \ receiving such a message, will first check to see\n    if the stream is known.\
    \ If not known, the receiving ST agent sends a\n    STATUS-RESPONSE containing\
    \ the same SID, and no other stream\n    information. If the stream is known,\
    \ the receiving ST agent sends a\n    STATUS-RESPONSE containing the stream's\
    \ SID, IPHops, FlowSpec, group\n    membership (if any), and as many targets as\
    \ can be included in a\n    single message as limited by MTU, see Section 5.1.2.\
    \ Note that all\n    targets may not be included in a response to a request for\
    \ general\n    stream information. If information on a specific target in a stream\n\
    \    is desired, the mechanism described next should be used.\n"
- title: o   obtain information on particular targets in a stream. If an ST agent
  contents:
  - "o   obtain information on particular targets in a stream. If an ST agent\n  \
    \  wishes to check a neighbor's information related to one or more\n    specific\
    \ targets of a specific stream, it should generate a STATUS\n    message containing\
    \ the stream's SID and a TargetList parameter\n    listing the relevant targets.\
    \ An ST agent receiving such a message,\n    will first check to see if the stream\
    \ and target are known. If the\n    stream is not known, the agent follows the\
    \ process described above.\n    If both the stream and targets are known, the\
    \ agent responds with\n    STATUS-RESPONSE containing the stream's SID, IPHops,\
    \ FlowSpec, group\n    membership (if any), and the requested targets that are\
    \ known. If\n    the stream is known but the target is not, the agent responds\
    \ with a\n    STATUS-RESPONSE containing the stream's SID, IPHops, FlowSpec, group\n\
    \    membership (if any), but no targets.\n   The specific formats for STATUS\
    \ and STATUS-RESPONSE messages are\n   defined in Section 10.4.12 and Section\
    \ 10.4.13.\n"
- title: 8.5  Round Trip Time Estimation
  contents:
  - "8.5  Round Trip Time Estimation\n   SCMP is made reliable through use of retransmission\
    \ when an expected\n   acknowledgment is not received in a timely manner. Timeout\
    \ and\n   retransmission algorithms are implementation dependent and are\n   outside\
    \ the scope of this document. However, it must be reasonable\n   enough not to\
    \ cause excessive retransmission of SCMP messages while\n   maintaining the robustness\
    \ of the protocol. Algorithms on this\n   subject are described in [WoHD95], [Jaco88],\
    \ [KaPa87].\n   Most existing algorithms are based on an estimation of the Round\
    \ Trip\n   Time (RTT) between two hosts. With SCMP, if an ST agent wishes to\n\
    \   have an estimate of the RTT to and from a neighbor, it should\n   generate\
    \ a STATUS message with an SID which has all its fields set to\n   zero. An ST\
    \ agent receiving a STATUS message with such SID should\n   answer as rapidly\
    \ as possible with a STATUS-RESPONSE message\n   containing the same SID, and\
    \ no other stream information. The time\n   interval between the send and receive\
    \ operations can be used as an\n   estimate of the RTT to and from the neighbor.\n"
- title: 8.6  Network MTU Discovery
  contents:
  - "8.6  Network MTU Discovery\n   At connection setup, the application at the origin\
    \ asks the local ST\n   agent to create streams with certain QoS requirements.\
    \ The local ST\n   agent fills out its network MTU value in the MaxMsgSize parameter\
    \ in\n   the CONNECT message and forwards it to the next-hop ST agents. Each\n\
    \   ST agent in the path checks to see if it's network MTU is smaller\n   than\
    \ the one specified in the CONNECT message and, if it is, the ST\n   agent updates\
    \ the MaxMsgSize in the CONNECT message to it's network\n   MTU. If the target\
    \ application decides to accept the stream, the ST\n   agent at the target copies\
    \ the MTU value in the CONNECT message to\n   the MaxMsgSize field in the ACCEPT\
    \ message and sends it back to the\n   application at the origin. The MaxMsgSize\
    \ field in the ACCEPT message\n   is the minimum MTU of the intervening networks\
    \ to that target. If the\n   application has multiple targets then the minimum\
    \ MTU of the stream\n   is the smallest MaxMsgSize received from all the ACCEPT\
    \ messages. It\n   is the responsibility of the application to segment its PDUs\n\
    \   according to the minimum MaxMsgSize of the stream since no data\n   fragmentation\
    \ is supported during the data transfer phase. If a\n   particular target's MaxMsgSize\
    \ is unacceptable to an application, it\n   may disconnect the target from the\
    \ stream and assume that the target\n   cannot be supported.  When evaluating\
    \ a particular target's\n   MaxMsgSize, the application or the application interface\
    \ will need to\n   take into account the size of the ST data header.\n"
- title: 8.7  IP Encapsulation of ST
  contents:
  - "8.7  IP Encapsulation of ST\n   ST packets may be encapsulated in IP to allow\
    \ them to pass through\n   routers that don't support the ST Protocol. Of course,\
    \ ST resource\n   management is precluded over such a path, and packet overhead\
    \ is\n   increased by encapsulation, but if the performance is reasonably\n  \
    \ predictable this may be better than not communicating at all.\n   IP-encapsulated\
    \ ST packets begin with a normal IP header. Most fields\n   of the IP header should\
    \ be filled in according to the same rules that\n   apply to any other IP packet.\
    \ Three fields of special interest are:\n"
- title: o   Protocol is 5, see [RFC1700], to indicate an ST packet is enclosed,
  contents:
  - "o   Protocol is 5, see [RFC1700], to indicate an ST packet is enclosed,\n   \
    \ as opposed to TCP or UDP, for example.\n"
- title: o   Destination Address is that of the next-hop ST agent. This may or
  contents:
  - "o   Destination Address is that of the next-hop ST agent. This may or\n    may\
    \ not be the target of the ST stream. There may be an intermediate\n    ST agent\
    \ to which the packet should be routed to take advantage of\n    service guarantees\
    \ on the path past that agent. Such an intermediate\n    agent would not be on\
    \ a directly-connected network (or else IP\n    encapsulation wouldn't be needed),\
    \ so it would probably not be\n    listed in the normal routing table. Additional\
    \ routing mechanisms,\n    not defined here, will be required to learn about such\
    \ agents.\n"
- title: o   Type-of-Service may be set to an appropriate value for the service
  contents:
  - "o   Type-of-Service may be set to an appropriate value for the service\n    being\
    \ requested, see [RFC1700]. This feature is not implemented\n    uniformly in\
    \ the Internet, so its use can't be precisely defined\n    here.\n   IP encapsulation\
    \ adds little difficulty for the ST agent that\n   receives the packet. However,\
    \ when IP encapsulation is performed it\n   must be done in both directions. To\
    \ process the encapsulated IP\n   message, the ST agents simply remove the IP\
    \ header and proceed with\n   ST header as usual.\n   The more difficult part\
    \ is during setup, when the ST agent must\n   decide whether or not to encapsulate.\
    \ If the next-hop ST agent is on\n   a remote network and the route to that network\
    \ is through a router\n   that supports IP but not ST, then encapsulation is required.\
    \ The\n   routing function provides ST agents with the route and capability\n\
    \   information needed to support encapsulation.\n   On forwarding, the (mostly\
    \ constant) IP Header must be inserted and\n   the IP checksum appropriately updated.\n\
    \   Applications are informed about the number of IP hops traversed on\n   the\
    \ path to each target. The IPHops field of the CONNECT message, see\n   Section\
    \ 10.4.4, carries the number of traversed IP hops to the target\n   application.\
    \ The field is incremented by each ST agent when IP\n   encapsulation will be\
    \ used to reach the next-hop ST agent. The number\n   of IP hops traversed is\
    \ returned to the origin in the IPHops field of\n   the ACCEPT message, Section\
    \ 10.4.1.\n   When using IP Encapsulation, the MaxMsgSize field will not reflect\n\
    \   the MTU of the IP encapsulated segments. This means that IP\n   fragmentation\
    \ and reassembly may be needed in the IP cloud to support\n   a message of MaxMsgSize.\
    \ IP fragmentation can only occur when the MTU\n   of the IP cloud, less IP header\
    \ length, is the smallest MTU in a\n   stream's network path.\n"
- title: 8.8  IP Multicasting
  contents:
  - "8.8  IP Multicasting\n   If an ST agent must use IP encapsulation to reach multiple\
    \ next-hops\n   toward different targets, then either the packet must be replicated\n\
    \   for transmission to each next-hop, or IP multicasting may be used if\n   it\
    \ is implemented in the next-hop ST agents and in the intervening IP\n   routers.\n\
    \   When the stream is established, the collection of next-hop ST agents\n   must\
    \ be set up as an IP multicast group. The ST agent must allocate\n   an appropriate\
    \ IP multicast address (see Section 10.3.3) and fill\n   that address in the IPMulticastAddress\
    \ field of the CONNECT message.\n   The IP multicast address in the CONNECT message\
    \ is used to inform the\n   next-hop ST agents that they should join the multicast\
    \ group to\n   receive subsequent PDUs. Obviously, the CONNECT message itself\
    \ must\n   be sent using unicast. The next-hop ST agents must be able to receive\n\
    \   on the specified multicast address in order to accept the connection.\n  \
    \ If the next-hop ST agent can not receive on the specified multicast\n   address,\
    \ it sends a REFUSE message with ReasonCode (BadMcastAddress).\n   Upon receiving\
    \ the REFUSE, the upstream agent can choose to retry\n   with a different multicast\
    \ address. Alternatively, it can choose to\n   lose the efficiency of multicast\
    \ and use unicast delivery.\n   The following permanent IP multicast addresses\
    \ have been assigned to\n   ST:\n           224.0.0.7 All ST routers (intermediate\
    \ agents)\n           224.0.0.8 All ST hosts (agents)\n   In addition, a block\
    \ of transient IP multicast addresses, 224.1.0.0 -\n   224.1.255.255, has been\
    \ allocated for ST multicast groups. For\n   instance, the following two functions\
    \ could be made available:\n   o   AllocateMcastAddr() -> result, McastAddr\n\
    \   o   ListenMcastAddr(McastAddr) -> result\n   o   ReleaseMcastAddr(McastAddr)\
    \ -> result\n"
- title: 9.  The ST2+ Flow Specification
  contents:
  - "9.  The ST2+ Flow Specification\n   This section defines the ST2+ flow specification.\
    \ The flow\n   specification contains the user application requirements in terms\
    \ of\n   quality of service. Its contents are LRM dependent and are\n   transparent\
    \ to the ST2 setup protocol. ST2 carries the flow\n   specification as part of\
    \ the FlowSpec parameter, which is described\n   in Section 10.3.1. The required\
    \ ST2+ flow specification is included\n   in the protocol only to support interoperability.\
    \ ST2+ also defines a\n   \"null\" flow specification to be used only to support\
    \ testing.\n   ST2 is not dependent on a particular flow specification format\
    \ and it\n   is expected that other versions of the flow specification will be\n\
    \   needed in the future. Different flow specification formats are\n   distinguished\
    \ by the value of the Version field of the FlowSpec\n   parameter, see Section\
    \ 10.3.1. A single stream is always associated\n   with a single flow specification\
    \ format, i.e., the Version field is\n   consistent throughout the whole stream.\
    \ The following Version field\n   values are defined:\n   0 - Null FlowSpec  \
    \     /* must be supported */\n   1 - ST Version 1\n   2 - ST Version 1.5\n  \
    \ 3 - RFC 1190 FlowSpec\n   4 - HeiTS FlowSpec\n   5 - BerKom FlowSpec\n   6 -\
    \ RFC 1363 FlowSpec\n   7 - ST2+ FlowSpec       /* must be supported */\n   FlowSpecs\
    \ version #0 and #7 must be supported by ST2+\n   implementations.  Version numbers\
    \ in the range 1-6 indicate flow\n   specifications are currently used in existing\
    \ ST2 implementations.\n   Values in the 128-255 range are reserved for private\
    \ and experimental\n   use.\n   In general, a flow specification may support sophisticated\
    \ flow\n   descriptions. For example, a flow specification could represent sub-\n\
    \   flows of a particular stream. This could then be used to by a\n   cooperating\
    \ application and LRM to forward designated packets to\n   specific targets based\
    \ on the different sub-flows. The reserved bits\n   in the ST2 Data PDU, see Section\
    \ 10.1, may be used with such a flow\n   specification to designate packets associated\
    \ with different sub-\n   flows. The ST2+ FlowSpec is not so sophisticated, and\
    \ is intended for\n   use with applications that generate traffic at a single\
    \ rate for\n   uniform delivery to all targets.\n"
- title: '9.1  FlowSpec Version #0 - (Null FlowSpec)'
  contents:
  - "9.1  FlowSpec Version #0 - (Null FlowSpec)\n   The flow specification identified\
    \ by a #0 value of the Version field\n   is called the Null FlowSpec. This flow\
    \ specification causes no\n   resources to be allocated. It is ignored by the\
    \ LRMs. Its contents\n   are never updated. Stream setup takes place in the usual\
    \ way leading\n   to successful stream establishment, but no resources are actually\n\
    \   reserved.\n   The purpose of the Null FlowSpec is that of facilitating\n \
    \  interoperability tests by allowing streams to be built without\n   actually\
    \ allocating the correspondent amount of resources. The Null\n   FlowSpec may\
    \ also be used for testing and debugging purposes.\n   The Null FlowSpec comprises\
    \ the 4-byte FlowSpec parameter only, see\n   Section 10.3.1. The third byte (Version\
    \ field) must be set to 0.\n"
- title: '9.2  FlowSpec Version #7 - ST2+ FlowSpec'
  contents:
  - "9.2  FlowSpec Version #7 - ST2+ FlowSpec\n   The flow specification identified\
    \ by a #7 value of the Version field\n   is the ST2+ FlowSpec, to be used by all\
    \ ST2+ implementations. It\n   allows the user applications to express their real-time\
    \ requirements\n   in the form of a QoS class, precedence, and three basic QoS\n\
    \   parameters:\n   o   message size,\n   o   message rate,\n   o   end-to-end\
    \ delay.\n   The QoS class indicates what kind of QoS guarantees are expected\
    \ by\n   the application, e.g., strict guarantees or predictive, see Section\n\
    \   9.2.1. QoS parameters are expressed via a set of values:\n"
- title: o   the "desired" values indicate the QoS desired by the application.
  contents:
  - "o   the \"desired\" values indicate the QoS desired by the application.\n   \
    \ These values are assigned by the application and never modified by\n    the\
    \ LRM.\n"
- title: o   the "limit" values indicate the lowest QoS the application is
  contents:
  - "o   the \"limit\" values indicate the lowest QoS the application is\n    willing\
    \ to accept. These values are also assigned by the application\n    and never\
    \ modified by the LRM.\n"
- title: o   the "actual" values indicate the QoS that the system is able to
  contents:
  - "o   the \"actual\" values indicate the QoS that the system is able to\n    provide.\
    \ They are updated by the LRM at each node. The \"actual\"\n    values are always\
    \ bounded by the \"limit\" and \"desired\" values.\n"
- title: 9.2.1  QoS Classes
  contents:
  - "9.2.1  QoS Classes\n   Two QoS classes are defined:\n   1 - QOS_PREDICTIVE  \
    \    /* QoSClass field value = 0x01, must be\n                              supported*/\n\
    \   2 - QOS_GUARANTEED      /* QoSClass field value = 0x10, optional */\n"
- title: o   The QOS_PREDICTIVE class implies that the negotiated QoS may be
  contents:
  - "o   The QOS_PREDICTIVE class implies that the negotiated QoS may be\n    violated\
    \ for short time intervals during the data transfer. An\n    application has to\
    \ provide values that take into account the\n    \"normal\" case, e.g., the \"\
    desired\" message rate is the allocated rate\n    for the transmission. Reservations\
    \ are done for the \"normal\" case as\n    opposite to the peak case required\
    \ by the QOS_GUARANTEED service\n    class. This QoS class must be supported by\
    \ all implementations.\n"
- title: o   The QOS_GUARANTEED class implies that the negotiated QoS for the
  contents:
  - "o   The QOS_GUARANTEED class implies that the negotiated QoS for the\n    stream\
    \ is never violated during the data transfer. An application\n    has to provide\
    \ values that take into account the worst possible\n    case, e.g., the \"desired\"\
    \ message rate is the peak rate for the\n    transmission. As a result, sufficient\
    \ resources to handle the peak\n    rate are reserved. This strategy may lead\
    \ to overbooking of\n    resources, but it provides strict real-time guarantees.\
    \ Support of\n    this QoS class is optional.\n   If a LRM that doesn't support\
    \ class QOS_GUARANTEED receives a\n   FlowSpec containing QOS_GUARANTEED class,\
    \ it informs the local ST\n   agent. The ST agent may try different paths or delete\
    \ the\n   correspondent portion of the stream as described in Section 5.5.3,\n\
    \   i.e., ReasonCode (FlowSpecError).\n"
- title: 9.2.2  Precedence
  contents:
  - "9.2.2  Precedence\n   Precedence is the importance of the connection being established.\n\
    \   Zero represents the lowest precedence. The lowest level is expected\n   to\
    \ be used by default. In general, the distinction between precedence\n   and priority\
    \ is that precedence specifies streams that are permitted\n   to take previously\
    \ committed resources from another stream, while\n   priority identifies those\
    \ PDUs that a stream is most willing to have\n   dropped.\n"
- title: 9.2.3  Maximum Data Size
  contents:
  - "9.2.3  Maximum Data Size\n   This parameter is expressed in bytes. It represents\
    \ the maximum\n   amount of data, excluding ST and other headers, allowed to be\
    \ sent in\n   a messages as part of the stream. The LRM first checks whether it\
    \ is\n   possible to get the value desired by the application (DesMaxSize). If\n\
    \   not, it updates the actual value (ActMaxSize) with the available size\n  \
    \ unless this value is inferior to the minimum allowed by the\n   application\
    \ (LimitMaxSize), in which case it informs the local ST\n   agent that it is not\
    \ possible to build the stream along this path.\n"
- title: 9.2.4  Message Rate
  contents:
  - "9.2.4  Message Rate\n   This parameter is expressed in messages/second. It represents\
    \ the\n   transmission rate for the stream. The LRM first checks whether it is\n\
    \   possible to get the value desired by the application (DesRate). If\n   not,\
    \ it updates the actual value (ActRate) with the available rate\n   unless this\
    \ value is inferior to the minimum allowed by the\n   application (LimitRate),\
    \ in which case it informs the local ST agent\n   that it is not possible to build\
    \ the stream along this path.\n"
- title: 9.2.5  Delay and Delay Jitter
  contents:
  - "9.2.5  Delay and Delay Jitter\n   The delay parameter is expressed in milliseconds.\
    \ It represents the\n   maximum end-to-end delay for the stream. The LRM first\
    \ checks whether\n   it is possible to get the value desired by the application\n\
    \   (DesMaxDelay). If not, it updates the actual value (ActMaxDelay) with\n  \
    \ the available delay unless this value is greater than the maximum\n   delay\
    \ allowed by the application (LimitMaxDelay), in which case it\n   informs the\
    \ local ST agent that it is not possible to build the\n   stream along this path.\n\
    \   The LRM also updates at each node the MinDelay field by incrementing\n   it\
    \ by the minimum possible delay to the next-hop. Information on the\n   minimum\
    \ possible delay allows to calculate the maximum end-to-end\n   delay range, i.e.,\
    \ the time interval in which a data packet can be\n   received. This interval\
    \ should not exceed the DesMaxDelayRange value\n   indicated by the application.\
    \ The maximum end-to-end delay range is\n   an upper bound of the delay jitter.\n"
- title: 9.2.6  ST2+ FlowSpec Format
  contents:
  - "9.2.6  ST2+ FlowSpec Format\n   The ST2+ FlowSpec has the following format:\n\
    \        0                   1                   2                   3\n     \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |    QosClass   |  Precedence   |            0(unused)          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                             DesRate                           |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                            LimitRate                          |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                             ActRate                           |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |            DesMaxSize         |           LimitMaxSize        |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \            ActMaxSize         |           DesMaxDelay         |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |            LimitMaxDelay      |           ActMaxDelay         |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |            DesMaxDelayRange   |           ActMinDelay         |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \                Figure 9: The ST2+ FlowSpec.\n   The LRM modifies only \"actual\"\
    \ fields, i.e., those beginning with\n   \"Act\". The user application assigns\
    \ values to all other fields.\n"
- title: o   QoSClass indicates which of the two defined classes of service
  contents:
  - "o   QoSClass indicates which of the two defined classes of service\n    applies.\
    \ The two classes are: QOS_PREDICTIVE (QoSClass = 1) and\n    QOS_GUARANTEED (QoSClass\
    \ = 2).\n"
- title: o   Precedence indicates the stream's precedence. Zero represents the
  contents:
  - "o   Precedence indicates the stream's precedence. Zero represents the\n    lowest\
    \ precedence, and should be the default value.\n"
- title: o   DesRate is the desired transmission rate for the stream in messages/
  contents:
  - "o   DesRate is the desired transmission rate for the stream in messages/\n  \
    \  second. This field is set by the origin and is not modified by\n    intermediate\
    \ agents.\n"
- title: o   LimitRate is the minimum acceptable transmission rate in messages/
  contents:
  - "o   LimitRate is the minimum acceptable transmission rate in messages/\n    second.\
    \ This field is set by the origin and is not modified by\n    intermediate agents.\n"
- title: o   ActRate is the actual transmission rate allocated for the stream in
  contents:
  - "o   ActRate is the actual transmission rate allocated for the stream in\n   \
    \ messages/second. Each agent updates this field with the available\n    rate\
    \ unless this value is less than LimitRate, in which case a\n    REFUSE is generated.\n"
- title: o   DesMaxSize is the desired maximum data size in bytes that will be
  contents:
  - "o   DesMaxSize is the desired maximum data size in bytes that will be\n    sent\
    \ in a message in the stream. This field is set by the origin.\n"
- title: o   LimitMaxSize is the minimum acceptable data size in bytes. This
  contents:
  - "o   LimitMaxSize is the minimum acceptable data size in bytes. This\n    field\
    \ is set by the origin\n"
- title: o   ActMaxSize is the actual maximum data size that may be sent in a
  contents:
  - "o   ActMaxSize is the actual maximum data size that may be sent in a\n    message\
    \ in the stream. This field is updated by each agent based on\n    MTU and available\
    \ resources. If available maximum size is less than\n    LimitMaxSize, the connection\
    \ must be refused with ReasonCode\n    (CantGetResrc).\n"
- title: o   DesMaxDelay is the desired maximum end-to-end delay for the stream
  contents:
  - "o   DesMaxDelay is the desired maximum end-to-end delay for the stream\n    in\
    \ milliseconds. This field is set by the origin.\n"
- title: o   LimitMaxDelay is the upper-bound of acceptable end-to-end delay for
  contents:
  - "o   LimitMaxDelay is the upper-bound of acceptable end-to-end delay for\n   \
    \ the stream in milliseconds. This field is set by the origin.\n"
- title: o   ActMaxDelay is the maximum end-to-end delay that will be seen by
  contents:
  - "o   ActMaxDelay is the maximum end-to-end delay that will be seen by\n    data\
    \ in the stream. Each ST agent adds to this field the maximum\n    delay that\
    \ will be introduced by the agent, including transmission\n    time to the next-hop\
    \ ST agent. If the actual maximum exceeds\n    LimitMaxDelay, then the connection\
    \ is refused with ReasonCode\n    (CantGetResrc).\n"
- title: o   DesMaxDelayRange is the desired maximum delay range that may be
  contents:
  - "o   DesMaxDelayRange is the desired maximum delay range that may be\n    encountered\
    \ end-to-end by stream data in milliseconds. This value is\n    set by the application\
    \ at the origin.\n"
- title: o   ActMinDelay is the actual minimum end-to-end delay that will be
  contents:
  - "o   ActMinDelay is the actual minimum end-to-end delay that will be\n    encountered\
    \ by stream data in milliseconds. Each ST agent adds to\n    this field the minimum\
    \ delay that will be introduced by the agent,\n    including transmission time\
    \ to the next-hop ST agent. Each agent\n    must add at least 1 millisecond. The\
    \ delay range for the stream can\n    be calculated from the actual maximum and\
    \ minimum delay fields. It\n    is expected that the range will be important to\
    \ some applications.\n"
- title: 10.  ST2 Protocol Data Units Specification
  contents:
  - '10.  ST2 Protocol Data Units Specification

    '
- title: 10.1  Data PDU
  contents:
  - "10.1  Data PDU\n   IP and ST packets can be distinguished by the IP Version Number\n\
    \   field, i.e., the first four (4) bits of the packet; ST has been\n   assigned\
    \ the value 5 (see [RFC1700]). There is no requirement for\n   compatibility between\
    \ IP and ST packet headers beyond the first four\n   bits. (IP uses value 4.)\n\
    \   The ST PDUs sent between ST agents consist of an ST Header\n   encapsulating\
    \ either a higher layer PDU or an ST Control Message.\n   Data packets are distinguished\
    \ from control messages via the D-bit\n   (bit 8) in the ST header.\n   The ST\
    \ Header also includes an ST Version Number, a total length\n   field, a header\
    \ checksum, a unique id, and the stream origin 32-bit\n   IP address. The unique\
    \ id and the stream origin 32-bit IP address\n   form the stream id (SID). This\
    \ is shown in Figure 10. Please refer to\n   Section 10.6 for an explanation of\
    \ the notation.\n        0                   1                   2           \
    \        3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  ST=5 | Ver=3 |D| Pri |   0   |            TotalBytes         |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |          HeaderChecksum       |            UniqueID           |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                         OriginIPAddress                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                            Figure 10: ST Header\n"
- title: o   ST is the IP Version Number assigned to identify ST packets. The
  contents:
  - "o   ST is the IP Version Number assigned to identify ST packets. The\n    value\
    \ for ST is 5.\n"
- title: o   Ver is the ST Version Number. The value for the current ST2+ version
  contents:
  - "o   Ver is the ST Version Number. The value for the current ST2+ version\n  \
    \  is 3.\n"
- title: o   D (bit 8) is set to 1 in all ST data packets and to 0 in all SCMP
  contents:
  - "o   D (bit 8) is set to 1 in all ST data packets and to 0 in all SCMP\n    control\
    \ messages.\n"
- title: o   Pri (bits 9-11) is the packet-drop priority field with zero (0)
  contents:
  - "o   Pri (bits 9-11) is the packet-drop priority field with zero (0)\n    being\
    \ lowest priority and seven the highest. The field is to be used\n    as described\
    \ in Section 3.2.2.\n"
- title: o   TotalBytes is the length, in bytes, of the entire ST packet, it
  contents:
  - "o   TotalBytes is the length, in bytes, of the entire ST packet, it\n    includes\
    \ the ST Header but does not include any local network\n    headers or trailers.\
    \ In general, all length fields in the ST\n    Protocol are in units of bytes.\n"
- title: o   HeaderChecksum covers only the ST Header (12 bytes). The ST Protocol
  contents:
  - "o   HeaderChecksum covers only the ST Header (12 bytes). The ST Protocol\n  \
    \  uses 16-bit checksums here in the ST Header and in each Control\n    Message.\
    \ For checksum computation, see Section 8.3.\n"
- title: o   UniqueID is the first element of the stream ID (SID). It is locally
  contents:
  - "o   UniqueID is the first element of the stream ID (SID). It is locally\n   \
    \ unique at the stream origin, see Section 8.1.\n"
- title: o   OriginIPAddress is the second element of the SID. It is the 32-bit
  contents:
  - "o   OriginIPAddress is the second element of the SID. It is the 32-bit\n    IP\
    \ address of the stream origin, see Section 8.1.\n   Bits 12-15 must be set to\
    \ zero (0) when using the flow specifications\n   defined in this document, see\
    \ Section 9. They may be set accordingly\n   when other flow specifications are\
    \ used, e.g., as described in\n   [WoHD95].\n"
- title: 10.1.1  ST Data Packets
  contents:
  - "10.1.1  ST Data Packets\n   ST packets whose D-bit is non-zero are data packets.\
    \ Their\n   interpretation is a matter for the higher layer protocols and\n  \
    \ consequently is not specified here. The data packets are not\n   protected by\
    \ an ST checksum and will be delivered to the higher layer\n   protocol even with\
    \ errors. ST agents will not pass data packets over\n   a new hop whose setup\
    \ is not complete.\n"
- title: 10.2  Control PDUs
  contents:
  - "10.2  Control PDUs\n   SCMP control messages are exchanged between neighbor ST\
    \ agents using\n   a D-bit of zero (0). The control protocol follows a request-response\n\
    \   model with all requests expecting responses. Retransmission after\n   timeout\
    \ (see Section 4.3) is used to allow for lost or ignored\n   messages. Control\
    \ messages do not extend across packet boundaries; if\n   a control message is\
    \ too large for the MTU of a hop, its information\n   is partitioned and a control\
    \ message per partition is sent (see\n   Section 5.1.2). All control messages\
    \ have the following format\n        0                   1                   2\
    \                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  OpCode       |     Options   |           TotalBytes          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |          Reference            |          LnkReference         |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                         SenderIPAddress                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |            Checksum           |            ReasonCode         |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ :                      OpCodeSpecificData                       :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 11: ST Control Message Format\n"
- title: o   OpCode identifies the type of control message.
  contents:
  - 'o   OpCode identifies the type of control message.

    '
- title: o   Options is used to convey OpCode-specific variations for a control
  contents:
  - "o   Options is used to convey OpCode-specific variations for a control\n    message.\n"
- title: o   TotalBytes is the length of the control message, in bytes, including
  contents:
  - "o   TotalBytes is the length of the control message, in bytes, including\n  \
    \  all OpCode specific fields and optional parameters. The value is\n    always\
    \ divisible by four (4).\n"
- title: o   Reference is a transaction number. Each sender of a request control
  contents:
  - "o   Reference is a transaction number. Each sender of a request control\n   \
    \ message assigns a Reference number to the message that is unique\n    with respect\
    \ to the stream. The Reference number is used by the\n    receiver to detect and\
    \ discard duplicates. Each acknowledgment\n    carries the Reference number of\
    \ the request being acknowledged.\n    Reference zero (0) is never used, and Reference\
    \ numbers are assumed\n    to be monotonically increasing with wraparound so that\
    \ the older-\n    than and more-recent-than relations are well defined.\n"
- title: o   LnkReference contains the Reference field of the request control
  contents:
  - "o   LnkReference contains the Reference field of the request control\n    message\
    \ that caused this request control message to be created. It\n    is used in situations\
    \ where a single request leads to multiple\n    responses from the same ST agent.\
    \ Examples are CONNECT and CHANGE\n    messages that are first acknowledged hop-by-hop\
    \ and then lead to an\n    ACCEPT or REFUSE response from each target.\n"
- title: o   SenderIPAddress is the 32-bit IP address of the network interface
  contents:
  - "o   SenderIPAddress is the 32-bit IP address of the network interface\n    that\
    \ the ST agent used to send the control message. This value\n    changes each\
    \ time the packet is forwarded by an ST agent (hop-by-\n    hop).\n"
- title: o   Checksum is the checksum of the control message. Because the control
  contents:
  - "o   Checksum is the checksum of the control message. Because the control\n  \
    \  messages are sent in packets that may be delivered with bits in\n    error,\
    \ each control message must be checked to be error free before\n    it is acted\
    \ upon.\n"
- title: o   ReasonCode is set to zero (0 = NoError) in most SCMP messages.
  contents:
  - "o   ReasonCode is set to zero (0 = NoError) in most SCMP messages.\n    Otherwise,\
    \ it can be set to an appropriate value to indicate an\n    error situation as\
    \ defined in Section 10.5.3.\n"
- title: o   OpCodeSpecificData contains any additional information that is
  contents:
  - "o   OpCodeSpecificData contains any additional information that is\n    associated\
    \ with the control message. It depends on the specific\n    control message and\
    \ is explained further below. In some response\n    control messages, fields of\
    \ zero (0) are included to allow the\n    format to match that of the corresponding\
    \ request message. The\n    OpCodeSpecificData may also contain optional parameters.\
    \ The\n    specifics of OpCodeSpecificData are defined in Section 10.3.\n"
- title: 10.3  Common SCMP Elements
  contents:
  - "10.3  Common SCMP Elements\n   Several fields and parameters (referred to generically\
    \ as elements)\n   are common to two or more PDUs. They are described in detail\
    \ here\n   instead of repeating their description several times. In many cases,\n\
    \   the presence of a parameter is optional. To permit the parameters to\n   be\
    \ easily defined and parsed, each is identified with a PCode byte\n   that is\
    \ followed by a PBytes byte indicating the length of the\n   parameter in bytes\
    \ (including the PCode, PByte, and any padding\n   bytes). If the length of the\
    \ information is not a multiple of four\n   (4) bytes, the parameter is padded\
    \ with one to three zero (0) bytes.\n   PBytes is thus always a multiple of four\
    \ (4). Parameters can be\n   present in any order.\n"
- title: 10.3.1  FlowSpec
  contents:
  - "10.3.1  FlowSpec\n   The FlowSpec parameter (PCode = 1) is used in several SCMP\
    \ messages\n   to convey the ST2 flow specification. The FlowSpec parameter has\
    \ the\n   following format:\n        0                   1                   2\
    \                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |   PCode = 1   |    PBytes     |   Version     |       0       |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ :                        FlowSpec detail                        :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure 12: FlowSpec Parameter\n"
- title: o   the Version field contains the FlowSpec version.
  contents:
  - 'o   the Version field contains the FlowSpec version.

    '
- title: o   the FlowSpec detail field contains the flow specification and is
  contents:
  - "o   the FlowSpec detail field contains the flow specification and is\n    transparent\
    \ to the ST agent. It is the data structure to be passed\n    to the LRM. It must\
    \ be 4-byte aligned.\n   The Null FlowSpec, see Section 9.1, has no FlowSpec detail\
    \ field.\n   PBytes is set to four (4), and Version is set to zero (0). The ST2+\n\
    \   FlowSpec, see Section 9.2, is a 32-byte data structure. PBytes is set\n  \
    \ to 36, and Version is set to seven (7).\n"
- title: 10.3.2  Group
  contents:
  - "10.3.2  Group\n   The Group parameter (PCode = 2) is an optional argument used\
    \ to\n   indicate that the stream is a member in the specified group.\n      \
    \  0                   1                   2                   3\n        0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  PCode = 2    |   PBytes = 16 |           GroupUniqueID       |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                        GroupCreationTime                      |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                     GroupInitiatorIPAddress                   |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |            Relationship       |                 N             |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \                     Figure 13: Group Parameter\n"
- title: o   GroupUniqueID, GroupInitiatorIPAddress, and GroupCreationTime
  contents:
  - "o   GroupUniqueID, GroupInitiatorIPAddress, and GroupCreationTime\n    together\
    \ form the GroupName field. They are allocated by the group\n    name generator\
    \ function, see Section 8.2. GroupUniqueID and\n    GroupCreationTime are implementation\
    \ specific and have only local\n    definitions.\n"
- title: 'o   Relationship has the following format:'
  contents:
  - "o   Relationship has the following format:\n                                \
    \            0\n                        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n    \
    \                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                      \
    \ |    0 (unused)         |S|P|F|B|\n                       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure 14: Relationship Field\n   The B, F, P, S bits\
    \ correspond to Bandwidth, Fate, Path, and Subnet\n   resources sharing, see Section\
    \ 7. A value of 1 indicates that the\n   relationship exists for this group. All\
    \ combinations of the four bits\n   are allowed. Bits 0-11 of the Relationship\
    \ field are reserved for\n   future use and must be set to 0.\n"
- title: o   N contains a legal value only if the B-bit is set. It is the value
  contents:
  - "o   N contains a legal value only if the B-bit is set. It is the value\n    of\
    \ the N parameter to be used as explained in Section 7.1.1.\n"
- title: 10.3.3  MulticastAddress
  contents:
  - "10.3.3  MulticastAddress\n   The MulticastAddress parameter (PCode = 3) is an\
    \ optional parameter\n   that is used when using IP encapsulation and setting\
    \ up an IP\n   multicast group. This parameter is used to communicate the desired\
    \ IP\n   multicast address to next-hop ST agents that should become members of\n\
    \   the group, see Section 8.8.\n        0                   1               \
    \    2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  PCode = 3    |   PBytes = 8  |                0              |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                        IPMulticastAddress                     |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \                Figure 15:  MulticastAddress\n"
- title: o   IPMulticastAddress is the 32-bit IP multicast address to be used to
  contents:
  - "o   IPMulticastAddress is the 32-bit IP multicast address to be used to\n   \
    \ receive data packets for the stream.\n"
- title: 10.3.4  Origin
  contents:
  - "10.3.4  Origin\n   The Origin parameter (PCode = 4) is used to identify the next\
    \ higher\n   protocol, and the SAP being used in conjunction with that protocol.\n\
    \        0                   1                   2                   3\n     \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  PCode = 5    |   PBytes      | NextPcol      |OriginSAPBytes |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   :                OriginSAP                      :     Padding   |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \                     Figure 16: Origin\n"
- title: o   NextPcol is an 8-bit field used in demultiplexing operations to
  contents:
  - "o   NextPcol is an 8-bit field used in demultiplexing operations to\n    identify\
    \ the protocol to be used above ST. The values of NextPcol\n    are in the same\
    \ number space as the IP header's Protocol field and\n    are consequently defined\
    \ in the Assigned Numbers RFC [RFC1700].\n"
- title: o   OriginSAPBytes specifies the length of the OriginSAP, exclusive of
  contents:
  - "o   OriginSAPBytes specifies the length of the OriginSAP, exclusive of\n    any\
    \ padding required to maintain 32-bit alignment.\n"
- title: o   OriginSAP identifies the origin's SAP associated with the NextPcol
  contents:
  - "o   OriginSAP identifies the origin's SAP associated with the NextPcol\n    protocol.\n\
    \   Note that the 32-bit IP address of the stream origin is not included\n   in\
    \ this parameter because it is always available as part of the ST\n   header.\n"
- title: 10.3.5  RecordRoute
  contents:
  - "10.3.5  RecordRoute\n   The RecordRoute parameter (PCode = 5) is used to request\
    \ that the\n   route between the origin and a target be recorded and delivered\
    \ to\n   the user application. The ST agent at the origin (or target)\n   including\
    \ this parameter, has to determine the parameter's length,\n   indicated by the\
    \ PBytes field. ST agents processing messages\n   containing this parameter add\
    \ their receiving IP address in the\n   position indicated by the FreeOffset field,\
    \ space permitting. If no\n   space is available, the parameter is passed unchanged.\
    \ When included\n   by the origin, all agents between the origin and the target\
    \ add their\n   IP addresses and this information is made available to the\n \
    \  application at the target. When included by the target, all agents\n   between\
    \ the target and the origin, inclusive, add their IP addresses\n   and this information\
    \ is made available to the application at the\n   origin.\n        0         \
    \          1                   2                   3\n        0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |   PCode = 5   |     PBytes    |       0       |  FreeOffset   |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                          IP Address 1                         |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       :\
    \                              ...                              :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                          IP Address N                         |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \                       Figure 17: RecordRoute\n"
- title: o   PBytes is the length of the parameter in bytes. Length is determined
  contents:
  - "o   PBytes is the length of the parameter in bytes. Length is determined\n  \
    \  by the agent (target or origin) that first introduces the parameter.\n    Once\
    \ set, the length of the parameter remains unchanged.\n"
- title: o   FreeOffset indicates the offset, relative to the start of the
  contents:
  - "o   FreeOffset indicates the offset, relative to the start of the\n    parameter,\
    \ for the next IP address to be recorded. When the\n    FreeOffset is greater\
    \ than, or equal to, PBytes the RecordRoute\n    parameter is full.\n"
- title: o   IP Address is filled in, space permitting, by each ST agent
  contents:
  - "o   IP Address is filled in, space permitting, by each ST agent\n    processing\
    \ this parameter.\n"
- title: 10.3.6  Target and TargetList
  contents:
  - "10.3.6  Target and TargetList\n   Several control messages use a parameter called\
    \ TargetList (PCode =\n   6), which contains information about the targets to\
    \ which the message\n   pertains. For each Target in the TargetList, the information\
    \ includes\n   the 32-bit IP address of the target, the SAP applicable to the\
    \ next\n   higher layer protocol, and the length of the SAP (SAPBytes).\n   Consequently,\
    \ a Target structure can be of variable length. Each\n   entry has the format\
    \ shown in Figure 18.\n        0                   1                   2     \
    \              3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                        Target IP Address                      |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |  TargetBytes  |  SAPBytes     |     SAP       :    Padding    |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \                     Figure 18: Target\n"
- title: o   TargetIPAddress is the 32-bit IP Address of the Target.
  contents:
  - 'o   TargetIPAddress is the 32-bit IP Address of the Target.

    '
- title: o   TargetBytes is the length of the Target structure, beginning with
  contents:
  - "o   TargetBytes is the length of the Target structure, beginning with\n    the\
    \ TargetIPAddress.\n"
- title: o   SAPBytes is the length of the SAP, excluding any padding required to
  contents:
  - "o   SAPBytes is the length of the SAP, excluding any padding required to\n  \
    \  maintain 32-bit alignment.\n"
- title: o   SAP may be longer than 2 bytes and it includes a padding when
  contents:
  - "o   SAP may be longer than 2 bytes and it includes a padding when\n    required.\
    \ There would be no padding required for SAPs with lengths\n    of 2, 6, 10, etc.,\
    \ bytes.\n        0                   1                   2                  \
    \ 3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \     |  PCode = 6    |   PBytes      |           TargetCount = N     |\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ |                           Target 1                            |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       :                               :                               :\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                           Target N                            |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \                   Figure 19: TargetList\n"
- title: 10.3.7  UserData
  contents:
  - "10.3.7  UserData\n   The UserData parameter (PCode = 7) is an optional parameter\
    \ that may\n   be used by the next higher protocol or an application to convey\n\
    \   arbitrary information to its peers. This parameter is propagated in\n   some\
    \ control messages and its contents have no significance to ST\n   agents. Note\
    \ that since the size of control messages is limited by\n   the smallest MTU in\
    \ the path to the targets, the maximum size of this\n   parameter cannot be specified\
    \ a priori. If the size of this parameter\n   causes a message to exceed the network\
    \ MTU, an ST agent behaves as\n   described in Section 5.1.2. The parameter must\
    \ be padded to a\n   multiple of 32 bits.\n        0                   1     \
    \              2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  PCode = 7    |   PBytes      |           UserBytes           |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   :                      UserInfo                 :   Padding     |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \                    Figure 20:  UserData\n"
- title: o   UserBytes specifies the number of valid UserInfo bytes.
  contents:
  - 'o   UserBytes specifies the number of valid UserInfo bytes.

    '
- title: o   UserInfo is arbitrary data meaningful to the next higher protocol
  contents:
  - "o   UserInfo is arbitrary data meaningful to the next higher protocol\n    layer\
    \ or application.\n"
- title: 10.3.8  Handling of Undefined Parameters
  contents:
  - "10.3.8  Handling of Undefined Parameters\n   An ST agent must be able to handle\
    \ all parameters listed above. To\n   support possible future uses, parameters\
    \ with unknown PCodes must\n   also be supported. If an agent receives a message\
    \ containing a\n   parameter with an unknown Pcode value, the agent should handle\
    \ the\n   parameter as if it was a UserData parameter. That is, the contents of\n\
    \   the parameter should be ignored, and the message should be\n   propagated,\
    \ as appropriate, along with the related control message.\n"
- title: 10.4  ST Control Message PDUs
  contents:
  - "10.4  ST Control Message PDUs\n   ST Control messages are described in the following\
    \ section. Please\n   refer to Section 10.6 for an explanation of the notation.\n"
- title: 10.4.1  ACCEPT
  contents:
  - "10.4.1  ACCEPT\n   ACCEPT (OpCode = 1) is issued by a target as a positive response\
    \ to a\n   CONNECT message. It implies that the target is prepared to accept\n\
    \   data from the origin along the stream that was established by the\n   CONNECT.\
    \  ACCEPT is also issued as a positive response to a CHANGE\n   message. It implies\
    \ that the target accepts the proposed stream\n   modification.\n   ACCEPT is\
    \ relayed by the ST agents from the target to the origin\n   along the path established\
    \ by CONNECT (or CHANGE) but in the reverse\n   direction. ACCEPT must be acknowledged\
    \ with ACK at each hop.\n        0                   1                   2   \
    \                3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  OpCode = 1   |      0        |           TotalBytes          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |      Reference                |         LnkReference          |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                         SenderIPAddress                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |            Checksum           |          ReasonCode = 0       |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |          MaxMsgSize           |          RecoveryTimeout      |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                      StreamCreationTime                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |   IPHops      |                        0                      |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   :                           FlowSpec                            :\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       :\
    \                           TargetList                          :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \     :                           RecordRoute                         :\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       :\
    \                           UserData                            :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     Figure 21: ACCEPT Control Message\n"
- title: o   Reference contains a number assigned by the ST agent sending ACCEPT
  contents:
  - "o   Reference contains a number assigned by the ST agent sending ACCEPT\n   \
    \ for use in the acknowledging ACK.\n"
- title: o   LnkReference is the Reference number from the corresponding CONNECT
  contents:
  - "o   LnkReference is the Reference number from the corresponding CONNECT\n   \
    \ (or CHANGE)\n"
- title: o   MaxMsgSize indicates the smallest MTU along the path traversed by
  contents:
  - "o   MaxMsgSize indicates the smallest MTU along the path traversed by\n    the\
    \ stream. This field is only set when responding to a CONNECT\n    request.\n"
- title: o   RecoveryTimeout reflects the nominal number of milliseconds that the
  contents:
  - "o   RecoveryTimeout reflects the nominal number of milliseconds that the\n  \
    \  application is willing to wait for a failed system component to be\n    detected\
    \ and any corrective action to be taken. This field\n    represents what can actually\
    \ be supported by each participating\n    agent, and is only set when responding\
    \ to a CONNECT request.\n"
- title: o   StreamCreationTime is the 32- bits system dependent timestamp copied
  contents:
  - "o   StreamCreationTime is the 32- bits system dependent timestamp copied\n  \
    \  from the corresponding CONNECT request.\n"
- title: o   IPHops is the number of IP encapsulated hops traversed by the
  contents:
  - "o   IPHops is the number of IP encapsulated hops traversed by the\n    stream.\
    \ This field is set to zero by the origin, and is incremented\n    at each IP\
    \ encapsulating agent.\n"
- title: 10.4.2  ACK
  contents:
  - "10.4.2  ACK\n   ACK (OpCode = 2) is used to acknowledge a request. The ACK message\
    \ is\n   not propagated beyond the previous-hop or next-hop ST agent.\n      \
    \  0                   1                   2                   3\n        0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  OpCode = 2   |     0         |           TotalBytes          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |       Reference               |           LnkReference = 0    |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                         SenderIPAddress                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |       Checksum                |           ReasonCode          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \                   Figure 22: ACK Control Message\n"
- title: o   Reference is the Reference number of the control message being
  contents:
  - "o   Reference is the Reference number of the control message being\n    acknowledged.\n"
- title: o   ReasonCode is usually NoError, but other possibilities exist, e.g.,
  contents:
  - "o   ReasonCode is usually NoError, but other possibilities exist, e.g.,\n   \
    \ DuplicateIgn.\n"
- title: 10.4.3  CHANGE
  contents:
  - "10.4.3  CHANGE\n   CHANGE (OpCode = 3) is used to change the FlowSpec of an established\n\
    \   stream. The CHANGE message is processed similarly to CONNECT, except\n   that\
    \ it travels along the path of an established stream. CHANGE must\n   be propagated\
    \ until it reaches the related stream's targets. CHANGE\n   must be acknowledged\
    \ with ACK at each hop.\n        0                   1                   2   \
    \                3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  OpCode = 3   |G|I|     0     |           TotalBytes          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |           Reference           |          LnkReference = 0     |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                        SenderIPAddress                        |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |            Checksum           |          ReasonCode = 0       |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   :                            FlowSpec                           :\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       :                           TargetList                          :\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ :                           RecordRoute                         :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \     :                            UserData                           :\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \               Figure 23: CHANGE Control Message\n"
- title: o   G (bit 8) is used to request a global, stream-wide change; the
  contents:
  - "o   G (bit 8) is used to request a global, stream-wide change; the\n    TargetList\
    \ parameter should be omitted when the G bit is specified.\n"
- title: o   I (bit 7) is used to indicate that the LRM is permitted to interrupt
  contents:
  - "o   I (bit 7) is used to indicate that the LRM is permitted to interrupt\n  \
    \  and, if needed, break the stream in the process of trying to satisfy\n    the\
    \ requested change.\n"
- title: o   Reference contains a number assigned by the ST agent sending CHANGE
  contents:
  - "o   Reference contains a number assigned by the ST agent sending CHANGE\n   \
    \ for use in the acknowledging ACK.\n"
- title: 10.4.4  CONNECT
  contents:
  - "10.4.4  CONNECT\n   CONNECT (OpCode = 4) requests the setup of a new stream or\
    \ an\n   addition to or recovery of an existing stream. Only the origin can\n\
    \   issue the initial set of CONNECTs to setup a stream, and the first\n   CONNECT\
    \ to each next-hop is used to convey the SID.\n   The next-hop initially responds\
    \ with an ACK, which implies that the\n   CONNECT was valid and is being processed.\
    \ The next-hop will later\n   relay back either an ACCEPT or REFUSE from each\
    \ target. An\n   intermediate ST agent that receives a CONNECT behaves as explained\
    \ in\n   Section 4.5.\n        0                   1                   2     \
    \              3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  OpCode = 4   |J N|S|    0    |           TotalBytes          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |           Reference           |          LnkReference = 0     |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                         SenderIPAddress                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |           Checksum            |          ReasonCode = 0       |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |           MaxMsgSize          |          RecoveryTimeout      |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                        StreamCreationTime                     |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |   IPHops      |                        0                      |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   :                             Origin                            :\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       :\
    \                           FlowSpec                            :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \     :                          TargetList                           :\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       :\
    \                          RecordRoute                          :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \     :                             Group                             :\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       :\
    \                        MulticastAddress                       :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \     :                            UserData                           :\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \               Figure 24: CONNECT Control Message\n"
- title: o   JN (bits 8 and 9) indicate the join authorization level for the
  contents:
  - "o   JN (bits 8 and 9) indicate the join authorization level for the\n    stream,\
    \ see Section 4.4.2.\n"
- title: o   S (bit 10) indicates the NoRecovery option (Section 4.4.1). When the
  contents:
  - "o   S (bit 10) indicates the NoRecovery option (Section 4.4.1). When the\n  \
    \  S-bit is set (1), the NoRecovery option is specified for the stream.\n"
- title: o   Reference contains a number assigned by the ST agent sending CONNECT
  contents:
  - "o   Reference contains a number assigned by the ST agent sending CONNECT\n  \
    \  for use in the acknowledging ACK.\n"
- title: o   MaxMsgSize indicates the smallest MTU along the path traversed by
  contents:
  - "o   MaxMsgSize indicates the smallest MTU along the path traversed by\n    the\
    \ stream. This field is initially set to the network MTU of the\n    agent issues\
    \ the CONNECT.\n"
- title: o   RecoveryTimeout is the nominal number of milliseconds that the
  contents:
  - "o   RecoveryTimeout is the nominal number of milliseconds that the\n    application\
    \ is willing to wait for failed system component to be\n    detected and any corrective\
    \ action to be taken.\n"
- title: o   StreamCreationTime is the 32- bits system dependent timestamp
  contents:
  - "o   StreamCreationTime is the 32- bits system dependent timestamp\n    generated\
    \ by the ST agent issuing the CONNECT.\n"
- title: o   IPHops is the number of IP encapsulated hops traversed by the
  contents:
  - "o   IPHops is the number of IP encapsulated hops traversed by the\n    stream.\
    \ This field is set to zero by the origin, and is incremented\n    at each IP\
    \ encapsulating agent.\n"
- title: 10.4.5  DISCONNECT
  contents:
  - "10.4.5  DISCONNECT\n   DISCONNECT (OpCode = 5) is used by an origin to tear down\
    \ an\n   established stream or part of a stream, or by an intermediate ST\n  \
    \ agent that detects a failure between itself and its previous-hop, as\n   distinguished\
    \ by the ReasonCode. The DISCONNECT message specifies the\n   list of targets\
    \ that are to be disconnected. An ACK is required in\n   response to a DISCONNECT\
    \ message. The DISCONNECT message is\n   propagated all the way to the specified\
    \ targets. The targets are\n   expected to terminate their participation in the\
    \ stream.\n        0                   1                   2                 \
    \  3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \     |  OpCode = 5   |G|    0        |           TotalBytes          |\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ |      Reference                |     LnkReference = 0          |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                         SenderIPAddress                       |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |            Checksum           |          ReasonCode           |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                      GeneratorIPAddress                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \     :                           TargetList                          :\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       :\
    \                            UserData                           :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 25: DISCONNECT Control Message\n"
- title: o   G (bit 8) is used to request a DISCONNECT of all the stream's
  contents:
  - "o   G (bit 8) is used to request a DISCONNECT of all the stream's\n    targets.\
    \ TargetList should be omitted when the G-bit is set (1). If\n    TargetList is\
    \ present, it is ignored.\n"
- title: o   Reference contains a number assigned by the ST agent sending
  contents:
  - "o   Reference contains a number assigned by the ST agent sending\n    DISCONNECT\
    \ for use in the acknowledging ACK.\n"
- title: o   ReasonCode reflects the event that initiated the message.
  contents:
  - 'o   ReasonCode reflects the event that initiated the message.

    '
- title: o   GeneratorIPAddress is the 32-bit IP address of the host that first
  contents:
  - "o   GeneratorIPAddress is the 32-bit IP address of the host that first\n    generated\
    \ the DISCONNECT message.\n"
- title: 10.4.6  ERROR
  contents:
  - "10.4.6  ERROR\n   ERROR (OpCode = 6) is sent in acknowledgment to a request in\
    \ which an\n   error is detected. No action is taken on the erroneous request.\
    \ No\n   ACK is expected. The ERROR message is not propagated beyond the\n   previous-hop\
    \ or next-hop ST agent. An ERROR is never sent in response\n   to another ERROR.\
    \ The receiver of an ERROR is encouraged to try again\n   without waiting for\
    \ a retransmission timeout.\n        0                   1                   2\
    \                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  OpCode = 6   |       0       |           TotalBytes          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |      Reference                |     LnkReference = 0          |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                         SenderIPAddress                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |            Checksum           |        ReasonCode             |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   :                           PDUInError                          :\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \              Figure 26: ERROR Control Message\n"
- title: o   Reference is the Reference number of the erroneous request.
  contents:
  - 'o   Reference is the Reference number of the erroneous request.

    '
- title: o   ReasonCode indicates the error that triggered the message.
  contents:
  - 'o   ReasonCode indicates the error that triggered the message.

    '
- title: o   PDUInError is the PDU in error, beginning with the ST Header. This
  contents:
  - "o   PDUInError is the PDU in error, beginning with the ST Header. This\n    parameter\
    \ is optional. Its length is limited by network MTU, and may\n    be truncated\
    \ when too long.\n"
- title: 10.4.7  HELLO
  contents:
  - "10.4.7  HELLO\n   HELLO (OpCode = 7) is used as part of the ST failure detection\n\
    \   mechanism, see Section 6.1.\n        0                   1               \
    \    2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  OpCode = 7   |R|    0        |           TotalBytes          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |       Reference = 0           |        LnkReference = 0       |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                         SenderIPAddress                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |         Checksum              |          ReasonCode = 0       |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                          HelloTimer                           |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \              Figure 27: HELLO Control Message\n"
- title: o   R (bit 8) is used for the Restarted-bit.
  contents:
  - 'o   R (bit 8) is used for the Restarted-bit.

    '
- title: o   HelloTimer represents the time in millisecond since the agent was
  contents:
  - "o   HelloTimer represents the time in millisecond since the agent was\n    restarted,\
    \ modulo the precision of the field. It is used to detect\n    duplicate or delayed\
    \ HELLO messages.\n"
- title: 10.4.8  JOIN
  contents:
  - "10.4.8  JOIN\n   JOIN (OpCode = 8) is used as part of the ST steam joining mechanism,\n\
    \   see Section 4.6.3.\n        0                   1                   2    \
    \               3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  OpCode = 8   |      0        |           TotalBytes          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |      Reference                |         LnkReference = 0      |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                         SenderIPAddress                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |            Checksum           |          ReasonCode = 0       |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                      GeneratorIPAddress                       |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       :\
    \                          TargetList                           :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure 28: JOIN Control Message\n"
- title: o   Reference contains a number assigned by the ST agent sending JOIN
  contents:
  - "o   Reference contains a number assigned by the ST agent sending JOIN\n    for\
    \ use in the acknowledging ACK.\n"
- title: o   GeneratorIPAddress is the 32-bit IP address of the host that
  contents:
  - "o   GeneratorIPAddress is the 32-bit IP address of the host that\n    generated\
    \ the JOIN message.\n"
- title: o   TargetList is the information associated with the target to be added
  contents:
  - "o   TargetList is the information associated with the target to be added\n  \
    \  to the stream.\n"
- title: 10.4.9  JOIN-REJECT
  contents:
  - "10.4.9  JOIN-REJECT\n   JOIN-REJECT (OpCode = 9) is used as part of the ST steam\
    \ joining\n   mechanism, see Section 4.6.3.\n        0                   1   \
    \                2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  OpCode = 9   |      0        |           TotalBytes          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |      Reference                |          LnkReference         |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                         SenderIPAddress                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |            Checksum           |          ReasonCode           |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                      GeneratorIPAddress                       |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \           Figure 29: JOIN-REJECT Control Message\n"
- title: o   Reference contains a number assigned by the ST agent sending the
  contents:
  - "o   Reference contains a number assigned by the ST agent sending the\n    REFUSE\
    \ for use in the acknowledging ACK.\n"
- title: o   LnkReference is the Reference number from the corresponding JOIN
  contents:
  - "o   LnkReference is the Reference number from the corresponding JOIN\n    message.\n"
- title: o   ReasonCode reflects the reason why the JOIN request was rejected.
  contents:
  - 'o   ReasonCode reflects the reason why the JOIN request was rejected.

    '
- title: o   GeneratorIPAddress is the 32-bit IP address of the host that first
  contents:
  - "o   GeneratorIPAddress is the 32-bit IP address of the host that first\n    generated\
    \ the JOIN-REJECT message.\n"
- title: 10.4.10  NOTIFY
  contents:
  - "10.4.10  NOTIFY\n   NOTIFY (OpCode = 10) is issued by an ST agent to inform other\
    \ ST\n   agents of events that may be significant. NOTIFY may be propagated\n\
    \   beyond the previous-hop or next-hop ST agent depending on the\n   ReasonCode,\
    \ see Section 10.5.3; NOTIFY must be acknowledged with an\n   ACK.\n        0\
    \                   1                   2                   3\n        0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  OpCode = 10  |      0        |           TotalBytes          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |      Reference                |         LnkReference = 0      |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                         SenderIPAddress                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |            Checksum           |          ReasonCode           |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                      DetectorIPAddress                        |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \          MaxMsgSize           |          RecoveryTimeout      |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \     :                           FlowSpec                            :\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       :\
    \                           TargetList                          :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \     :                           UserData                            :\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \               Figure 30: NOTIFY Control Message\n"
- title: o   Reference contains a number assigned by the ST agent sending the
  contents:
  - "o   Reference contains a number assigned by the ST agent sending the\n    NOTIFY\
    \ for use in the acknowledging ACK.\n"
- title: o   ReasonCode identifies the reason for the notification.
  contents:
  - 'o   ReasonCode identifies the reason for the notification.

    '
- title: o   DetectorIPAddress is the 32-bit IP address of the ST agent that
  contents:
  - "o   DetectorIPAddress is the 32-bit IP address of the ST agent that\n    detects\
    \ the event.\n"
- title: o   MaxMsgSize is set when the MTU of the listed targets has changed
  contents:
  - "o   MaxMsgSize is set when the MTU of the listed targets has changed\n    (e.g.,\
    \ due to recovery), or when the notification is generated after\n    a successful\
    \ JOIN. Otherwise it is set to zero (0).\n"
- title: o   RecoveryTimeout is set when the notification is generated after a
  contents:
  - "o   RecoveryTimeout is set when the notification is generated after a\n    successful\
    \ JOIN. Otherwise it is set to zero (0).\n"
- title: o   FlowSpec is present when the notification is generated after a
  contents:
  - "o   FlowSpec is present when the notification is generated after a\n    successful\
    \ JOIN.\n"
- title: o   TargetList is present when the notification is related to one or
  contents:
  - "o   TargetList is present when the notification is related to one or\n    more\
    \ targets, or when MaxMsgSize is set\n"
- title: o   UserData is present if the notification is generated after a
  contents:
  - "o   UserData is present if the notification is generated after a\n    successful\
    \ JOIN and the UserData parameter was set in the ACCEPT\n    message.\n"
- title: 10.4.11  REFUSE
  contents:
  - "10.4.11  REFUSE\n   REFUSE (OpCode = 11) is issued by a target that either does\
    \ not wish\n   to accept a CONNECT message or wishes to remove itself from an\n\
    \   established stream. It might also be issued by an intermediate ST\n   agent\
    \ in response to a CONNECT or CHANGE either to terminate a\n   routing loop, or\
    \ when a satisfactory next-hop to a target cannot be\n   found. It may also be\
    \ a separate command when an existing stream has\n   been preempted by a higher\
    \ precedence stream or an ST agent detects\n   the failure of a previous-hop,\
    \ next-hop, or the network between them.\n   In all cases, the TargetList specifies\
    \ the targets that are affected\n   by the condition. Each REFUSE must be acknowledged\
    \ by an ACK.\n   The REFUSE is relayed back by the ST agents to the origin (or\n\
    \   intermediate ST agent that created the CONNECT or CHANGE) along the\n   path\
    \ traced by the CONNECT. The ST agent receiving the REFUSE will\n   process it\
    \ differently depending on the condition that caused it, as\n   specified in the\
    \ ReasonCode field. No special effort is made to\n   combine multiple REFUSE messages\
    \ since it is considered most unlikely\n   that separate REFUSEs will happen to\
    \ both pass through an ST agent at\n   the same time and be easily combined, e.g.,\
    \ have identical\n   ReasonCodes and parameters.\n        0                  \
    \ 1                   2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  OpCode = 11  |G|E|N|    0    |           TotalBytes          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |      Reference                |         LnkReference          |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                         SenderIPAddress                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |            Checksum           |          ReasonCode           |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                       DetectorIPAddress                       |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                       ValidTargetIPAddress                    |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \     :                          TargetList                           :\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       :\
    \                         RecordRoute                           :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \     :                            UserData                           :\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \               Figure 31: REFUSE Control Message\n"
- title: o   G (bit 8) is used to indicate that all targets down stream from the
  contents:
  - "o   G (bit 8) is used to indicate that all targets down stream from the\n   \
    \ sender are refusing. It is expected that this will be set most\n    commonly\
    \ due to network failures. The TargetList parameter is\n    ignored or not present\
    \ when this bit is set, and must be included\n    when not set.\n"
- title: o   E (bit 9) is set by an ST agent to indicate that the request failed
  contents:
  - "o   E (bit 9) is set by an ST agent to indicate that the request failed\n   \
    \ and that the pre-change stream attributes, including resources, and\n    the\
    \ stream itself still exist.\n"
- title: o   N (bit 10) is used to indicate that no further attempts to recover
  contents:
  - "o   N (bit 10) is used to indicate that no further attempts to recover\n    the\
    \ stream should be made. This bit must be set when stream recovery\n    should\
    \ not be attempted, even in the case where the target\n    application has shut\
    \ down normally (ApplDisconnect).\n"
- title: o   Reference contains a number assigned by the ST agent sending the
  contents:
  - "o   Reference contains a number assigned by the ST agent sending the\n    REFUSE\
    \ for use in the acknowledging ACK.\n"
- title: o   LnkReference is either the Reference number from the corresponding
  contents:
  - "o   LnkReference is either the Reference number from the corresponding\n    CONNECT\
    \ or CHANGE, if it is the result of such a message, or zero\n    when the REFUSE\
    \ was originated as a separate command.\n"
- title: o   DetectorIPAddress is the 32-bit IP address of the host that first
  contents:
  - "o   DetectorIPAddress is the 32-bit IP address of the host that first\n    generated\
    \ the REFUSE message.\n"
- title: o   ValidTargetIPAddress is the 32-bit IP address of a host that is
  contents:
  - "o   ValidTargetIPAddress is the 32-bit IP address of a host that is\n    properly\
    \ connected as part of the stream. This parameter is only\n    used when recovering\
    \ from stream convergence, otherwise it is set to\n    zero (0).\n"
- title: 10.4.12  STATUS
  contents:
  - "10.4.12  STATUS\n   STATUS (OpCode = 12) is used to inquire about the existence\
    \ of a\n   particular stream identified by the SID. Use of STATUS is intended\n\
    \   for collecting information from an neighbor ST agent, including\n   general\
    \ and specific stream information, and round trip time\n   estimation. The use\
    \ of this message type is described in Section 8.4.\n        0               \
    \    1                   2                   3\n        0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       | OpCode = 12   |       0       |           TotalBytes          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |      Reference                |       LnkReference = 0        |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                         SenderIPAddress                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |            Checksum           |          ReasonCode = 0       |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ :                          TargetList                           :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     Figure 32: STATUS Control Message\n"
- title: o   Reference contains a number assigned by the ST agent sending STATUS
  contents:
  - "o   Reference contains a number assigned by the ST agent sending STATUS\n   \
    \ for use in the replying STATUS-RESPONSE.\n"
- title: o   TargetList is an optional parameter that when present indicates that
  contents:
  - "o   TargetList is an optional parameter that when present indicates that\n  \
    \  only information related to the specific targets should be relayed\n    in\
    \ the STATUS-RESPONSE.\n"
- title: 10.4.13  STATUS-RESPONSE
  contents:
  - "10.4.13  STATUS-RESPONSE\n   STATUS-RESPONSE (OpCode = 13) is the reply to a\
    \ STATUS message. If\n   the stream specified in the STATUS message is not known,\
    \ the STATUS-\n   RESPONSE will contain the specified SID but no other parameters.\
    \ It\n   will otherwise contain the current SID, FlowSpec, TargetList, and\n \
    \  possibly Groups of the stream. It the full target list can not fit in\n   a\
    \ single message, only those targets that can be included in one\n   message will\
    \ be included. As mentioned in Section 10.4.12, it is\n   possible to request\
    \ information on a specific target.\n        0                   1           \
    \        2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |  OpCode = 13  |    0          |           TotalBytes          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |      Reference                |       LnkReference = 0        |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                         SenderIPAddress                       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |            Checksum           |       ReasonCode = 0          |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ :                           FlowSpec                            :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \     :                           Groups                              :\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       :\
    \                          TargetList                           :\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure 33: STATUS-RESPONSE Control Message\n"
- title: o   Reference contains a number assigned by the ST agent sending the
  contents:
  - "o   Reference contains a number assigned by the ST agent sending the\n    STATUS.\n"
- title: 10.5  Suggested Protocol Constants
  contents:
  - "10.5  Suggested Protocol Constants\n   The ST Protocol uses several fields that\
    \ must have specific values\n   for the protocol to work, and also several values\
    \ that an\n   implementation must select. This section specifies the required\n\
    \   values and suggests initial values for others. It is recommended that\n  \
    \ the latter be implemented as variables so that they may be easily\n   changed\
    \ when experience indicates better values. Eventually, they\n   should be managed\
    \ via the normal network management facilities.\n   ST uses IP Version Number\
    \ 5.\n   When encapsulated in IP, ST uses IP Protocol Number 5.\n"
- title: 10.5.1  SCMP Messages
  contents:
  - "10.5.1  SCMP Messages\n   1)      ACCEPT\n   2)      ACK\n   3)      CHANGE\n\
    \   4)      CONNECT\n   5)      DISCONNECT\n   6)      ERROR\n   7)      HELLO\n\
    \   8)      JOIN\n   9)      JOIN-REJECT\n   10)     NOTIFY\n   11)     REFUSE\n\
    \   12)     STATUS\n   13)     STATUS-RESPONSE\n"
- title: 10.5.2  SCMP Parameters
  contents:
  - "10.5.2  SCMP Parameters\n   1)      FlowSpec\n   2)      Group\n   3)      MulticastAddress\n\
    \   4)      Origin\n   5)      RecordRoute\n   6)      TargetList\n   7)     \
    \ UserData\n"
- title: 10.5.3  ReasonCode
  contents:
  - "10.5.3  ReasonCode\n   Several errors may occur during protocol processing. All\
    \ ST error\n   codes are taken from a single number space. The currently defined\n\
    \   values and their meaning is presented in the list below. Note that\n   new\
    \ error codes may be defined from time to time. All implementations\n   are expected\
    \ to handle new codes in a graceful manner. If an unknown\n   ReasonCode is encountered,\
    \ it should be assumed to be fatal. The\n   ReasonCode is an 8-bit field. Following\
    \ values are defined:\n"
- title: 1       NoError         No error has occurred.
  contents:
  - '1       NoError         No error has occurred.

    '
- title: 2       ErrorUnknown    An error not contained in this list has been
  contents:
  - "2       ErrorUnknown    An error not contained in this list has been\n      \
    \                  detected.\n"
- title: 3       AccessDenied    Access denied.
  contents:
  - '3       AccessDenied    Access denied.

    '
- title: 4       AckUnexpected   An unexpected ACK was received.
  contents:
  - '4       AckUnexpected   An unexpected ACK was received.

    '
- title: 5       ApplAbort       The application aborted the stream abnormally.
  contents:
  - '5       ApplAbort       The application aborted the stream abnormally.

    '
- title: 6       ApplDisconnect  The application closed the stream normally.
  contents:
  - '6       ApplDisconnect  The application closed the stream normally.

    '
- title: 7       ApplRefused     Applications refused requested connection or
  contents:
  - "7       ApplRefused     Applications refused requested connection or\n      \
    \                  change.\n"
- title: 8       AuthentFailed   The authentication function failed.
  contents:
  - '8       AuthentFailed   The authentication function failed.

    '
- title: 9       BadMcastAddress IP Multicast address is unacceptable in CONNECT
  contents:
  - '9       BadMcastAddress IP Multicast address is unacceptable in CONNECT

    '
- title: 10      CantGetResrc    Unable to acquire (additional) resources.
  contents:
  - '10      CantGetResrc    Unable to acquire (additional) resources.

    '
- title: 11      CantRelResrc    Unable to release excess resources.
  contents:
  - '11      CantRelResrc    Unable to release excess resources.

    '
- title: 12      CantRecover     Unable to recover failed stream.
  contents:
  - '12      CantRecover     Unable to recover failed stream.

    '
- title: 13      CksumBadCtl     Control PDU has a bad message checksum.
  contents:
  - '13      CksumBadCtl     Control PDU has a bad message checksum.

    '
- title: 14      CksumBadST      PDU has a bad ST Header checksum.
  contents:
  - '14      CksumBadST      PDU has a bad ST Header checksum.

    '
- title: 15      DuplicateIgn    Control PDU is a duplicate and is being
  contents:
  - "15      DuplicateIgn    Control PDU is a duplicate and is being\n           \
    \             acknowledged.\n"
- title: 16      DuplicateTarget Control PDU contains a duplicate target, or an
  contents:
  - "16      DuplicateTarget Control PDU contains a duplicate target, or an\n    \
    \                    attempt to add an existing target.\n"
- title: 17      FlowSpecMismatch        FlowSpec in request does not match
  contents:
  - "17      FlowSpecMismatch        FlowSpec in request does not match\n        \
    \                        existing FlowSpec.\n"
- title: 18      FlowSpecError   An error occurred while processing the FlowSpec
  contents:
  - '18      FlowSpecError   An error occurred while processing the FlowSpec

    '
- title: 19      FlowVerUnknown  Control PDU has a FlowSpec Version Number that
  contents:
  - "19      FlowVerUnknown  Control PDU has a FlowSpec Version Number that\n    \
    \                    is not supported.\n"
- title: 20      GroupUnknown    Control PDU contains an unknown Group Name.
  contents:
  - '20      GroupUnknown    Control PDU contains an unknown Group Name.

    '
- title: 21      InconsistGroup  An inconsistency has been detected with the
  contents:
  - "21      InconsistGroup  An inconsistency has been detected with the\n       \
    \                 streams forming a group.\n"
- title: 22      IntfcFailure    A network interface failure has been detected.
  contents:
  - '22      IntfcFailure    A network interface failure has been detected.

    '
- title: 23      InvalidSender   Control PDU has an invalid SenderIPAddress
  contents:
  - "23      InvalidSender   Control PDU has an invalid SenderIPAddress\n        \
    \                field.\n"
- title: 24      InvalidTotByt   Control PDU has an invalid TotalBytes field.
  contents:
  - '24      InvalidTotByt   Control PDU has an invalid TotalBytes field.

    '
- title: 25      JoinAuthFailure Join failed due to stream authorization level.
  contents:
  - '25      JoinAuthFailure Join failed due to stream authorization level.

    '
- title: 26      LnkRefUnknown   Control PDU contains an unknown LnkReference.
  contents:
  - '26      LnkRefUnknown   Control PDU contains an unknown LnkReference.

    '
- title: 27      NetworkFailure  A network failure has been detected.
  contents:
  - '27      NetworkFailure  A network failure has been detected.

    '
- title: 28      NoRouteToAgent  Cannot find a route to an ST agent.
  contents:
  - '28      NoRouteToAgent  Cannot find a route to an ST agent.

    '
- title: 29      NoRouteToHost   Cannot find a route to a host.
  contents:
  - '29      NoRouteToHost   Cannot find a route to a host.

    '
- title: 30      NoRouteToNet    Cannot find a route to a network.
  contents:
  - '30      NoRouteToNet    Cannot find a route to a network.

    '
- title: 31      OpCodeUnknown   Control PDU has an invalid OpCode field.
  contents:
  - '31      OpCodeUnknown   Control PDU has an invalid OpCode field.

    '
- title: 32      PCodeUnknown    Control PDU has a parameter with an invalid
  contents:
  - "32      PCodeUnknown    Control PDU has a parameter with an invalid\n       \
    \                 PCode.\n"
- title: 33      ParmValueBad    Control PDU contains an invalid parameter value.
  contents:
  - '33      ParmValueBad    Control PDU contains an invalid parameter value.

    '
- title: 34      PathConvergence Two branches of the stream join during the
  contents:
  - "34      PathConvergence Two branches of the stream join during the\n        \
    \                CONNECT setup.\n"
- title: 35      ProtocolUnknown Control PDU contains an unknown next-higher
  contents:
  - "35      ProtocolUnknown Control PDU contains an unknown next-higher\n       \
    \                 layer protocol identifier.\n"
- title: 36      RecordRouteSize RecordRoute parameter is too long to permit
  contents:
  - "36      RecordRouteSize RecordRoute parameter is too long to permit\n       \
    \                 message to fit a network's MTU.\n"
- title: 37      RefUnknown      Control PDU contains an unknown Reference.
  contents:
  - '37      RefUnknown      Control PDU contains an unknown Reference.

    '
- title: 38      ResponseTimeout Control message has been acknowledged but not
  contents:
  - "38      ResponseTimeout Control message has been acknowledged but not\n     \
    \                   answered by an appropriate control message.\n"
- title: 39      RestartLocal    The local ST agent has recently restarted.
  contents:
  - '39      RestartLocal    The local ST agent has recently restarted.

    '
- title: 40      RestartRemote   The remote ST agent has recently restarted.
  contents:
  - '40      RestartRemote   The remote ST agent has recently restarted.

    '
- title: 41      RetransTimeout  An acknowledgment has not been received after
  contents:
  - "41      RetransTimeout  An acknowledgment has not been received after\n     \
    \                   several retransmissions.\n"
- title: 42      RouteBack       Route to next-hop through same interface as
  contents:
  - "42      RouteBack       Route to next-hop through same interface as\n       \
    \                 previous-hop and is not previous-hop.\n"
- title: 43      RouteInconsist  A routing inconsistency has been detected.
  contents:
  - '43      RouteInconsist  A routing inconsistency has been detected.

    '
- title: 44      RouteLoop       A routing loop has been detected.
  contents:
  - '44      RouteLoop       A routing loop has been detected.

    '
- title: 45      SAPUnknown      Control PDU contains an unknown next-higher
  contents:
  - "45      SAPUnknown      Control PDU contains an unknown next-higher\n       \
    \                 layer SAP (port).\n"
- title: 46      SIDUnknown      Control PDU contains an unknown SID.
  contents:
  - '46      SIDUnknown      Control PDU contains an unknown SID.

    '
- title: 47      STAgentFailure  An ST agent failure has been detected.
  contents:
  - '47      STAgentFailure  An ST agent failure has been detected.

    '
- title: 48      STVer3Bad       A received PDU is not ST Version 3.
  contents:
  - '48      STVer3Bad       A received PDU is not ST Version 3.

    '
- title: 49      StreamExists    A stream with the given SID already exists.
  contents:
  - '49      StreamExists    A stream with the given SID already exists.

    '
- title: 50      StreamPreempted The stream has been preempted by one with a
  contents:
  - "50      StreamPreempted The stream has been preempted by one with a\n       \
    \                 higher precedence.\n"
- title: 51      TargetExists    A CONNECT was received that specified an
  contents:
  - "51      TargetExists    A CONNECT was received that specified an\n          \
    \              existing target.\n"
- title: 52      TargetUnknown   A target is not a member of the specified
  contents:
  - "52      TargetUnknown   A target is not a member of the specified\n         \
    \               stream.\n"
- title: 53      TargetMissing   A target parameter was expected and is not
  contents:
  - "53      TargetMissing   A target parameter was expected and is not\n        \
    \                included, or is empty.\n"
- title: 54      TruncatedCtl    Control PDU is shorter than expected.
  contents:
  - '54      TruncatedCtl    Control PDU is shorter than expected.

    '
- title: 55      TruncatedPDU    A received ST PDU is shorter than the ST Header
  contents:
  - "55      TruncatedPDU    A received ST PDU is shorter than the ST Header\n   \
    \                     indicates.\n"
- title: 56      UserDataSize    UserData parameter too large to permit a
  contents:
  - "56      UserDataSize    UserData parameter too large to permit a\n          \
    \              message to fit into a network's MTU.\n"
- title: 10.5.4  Timeouts and Other Constants
  contents:
  - "10.5.4  Timeouts and Other Constants\n   SCMP uses retransmission to effect reliability\
    \ and thus has several\n   \"retransmission timers\". Each \"timer\" is modeled\
    \ by an initial time\n   interval (ToXxx), which may get updated dynamically through\n\
    \   measurement of control traffic, and a number of times (NXxx) to\n   retransmit\
    \ a message before declaring a failure. All time intervals\n   are in units of\
    \ milliseconds. Note that the variables are described\n   for reference purposes\
    \ only, different implementations may not\n   include the identical variables.\n"
- title: Value   Timeout Name    Meaning
  contents:
  - 'Value   Timeout Name    Meaning

    '
- title: '------------------------------------------------------------------------'
  contents:
  - "------------------------------------------------------------------------\n  500\
    \   ToAccept        Initial hop-by-hop timeout for acknowledgment of\n       \
    \                 ACCEPT\n    3   NAccept         ACCEPT retries before failure\n\
    \  500   ToChange        Initial hop-by-hop timeout for acknowledgment of\n  \
    \                      CHANGE\n    3   NChange         CHANGE retries before failure\n\
    \ 5000   ToChangeResp    End-to-End CHANGE timeout for receipt of ACCEPT\n   \
    \                     or REFUSE\n  500   ToConnect       Initial hop-by-hop timeout\
    \ for acknowledgment of\n                        CONNECT\n    5   NConnect   \
    \     CONNECT retries before failure\n 5000   ToConnectResp   End-to-End CONNECT\
    \ timeout for receipt of ACCEPT\n                        or REFUSE from targets\
    \ by origin\n  500   ToDisconnect    Initial hop-by-hop timeout for acknowledgment\
    \ of\n                        DISCONNECT\n    3   NDisconnect     DISCONNECT retries\
    \ before failure\n  500   ToJoin          Initial hop-by-hop timeout for acknowledgment\
    \ of\n                        JOIN\n    3   NJoin           JOIN retries before\
    \ failure\n  500   ToJoinReject    Initial hop-by-hop timeout for acknowledgment\
    \ of\n                        JOIN-REJECT\n    3   NJoinReject     JOIN-REJECT\
    \ retries before failure\n 5000   ToJoinResp      Timeout for receipt of CONNECT\
    \ or JOIN-REJECT\n                        from origin or intermediate hop\n  500\
    \   ToNotify        Initial hop-by-hop timeout for acknowledgment of\n       \
    \                 NOTIFY\n    3   NNotify         NOTIFY retries before failure\n\
    \  500   ToRefuse        Initial hop-by-hop timeout for acknowledgment of\n  \
    \                      REFUSE\n    3   NRefuse         REFUSE retries before failure\n\
    \  500   ToRetryRoute    Timeout for receipt of ACCEPT or REFUSE from\n      \
    \                  targets during failure recovery\n    5   NRetryRoute     CONNECT\
    \ retries before failure\n 1000   ToStatusResp    Timeout for receipt of STATUS-RESPONSE\n\
    \    3   NStatus         STATUS retries before failure\n"
- title: 10000   HelloTimerHoldDown      Interval that Restarted bit must be set
  contents:
  - "10000   HelloTimerHoldDown      Interval that Restarted bit must be set\n   \
    \                             after ST restart\n    5   HelloLossFactor      \
    \   Number of consecutively missed HELLO\n                                messages\
    \ before declaring link failure\n 2000   DefaultRecoveryTimeout  Interval between\
    \ successive HELLOs\n                                to/from active neighbors\n"
- title: 10.6  Data Notations
  contents:
  - "10.6  Data Notations\n   The convention in the documentation of Internet Protocols\
    \ is to\n   express numbers in decimal and to picture data with the most\n   significant\
    \ octet on the left and the least significant octet on the\n   right.\n   The\
    \ order of transmission of the header and data described in this\n   document\
    \ is resolved to the octet level. Whenever a diagram shows a\n   group of octets,\
    \ the order of transmission of those octets is the\n   normal order in which they\
    \ are read in English. For example, in the\n   following diagram the octets are\
    \ transmitted in the order they are\n   numbered.\n        0                 \
    \  1                   2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |       1       |       2       |       3       |       4       |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |       5       |       6       |       7       |       8       |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \       9       |      10       |      11       |      12       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 34:  Transmission Order of Bytes\n   Whenever an octet\
    \ represents a numeric quantity the left most bit in\n   the diagram is the high\
    \ order or most significant bit. That is, the\n   bit labeled 0 is the most significant\
    \ bit. For example, the following\n   diagram represents the value 170 (decimal).\n\
    \                                0 1 2 3 4 5 6 7\n                           \
    \    +-+-+-+-+-+-+-+-+\n                               |1 0 1 0 1 0 1 0|\n   \
    \                            +-+-+-+-+-+-+-+-+\n                      Figure 35:\
    \ Significance of Bits\n   Similarly, whenever a multi-octet field represents\
    \ a numeric quantity\n   the left most bit of the whole field is the most significant\
    \ bit.\n   When a multi-octet quantity is transmitted the most significant octet\n\
    \   is transmitted first.\n   Fields whose length is fixed and fully illustrated\
    \ are shown with a\n   vertical bar (|) at the end; fixed fields whose contents\
    \ are\n   abbreviated are shown with an exclamation point (!); variable fields\n\
    \   are shown with colons (:). Optional parameters are separated from\n   control\
    \ messages with a blank line. The order of parameters is not\n   meaningful.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: '[RFC1071]       Braden, R., Borman, D., and C. Partridge,'
  contents:
  - "[RFC1071]       Braden, R., Borman, D., and C. Partridge,\n                \"\
    Computing the Internet Checksum\", RFC 1071,\n                USC/Information\
    \ Sciences Institute,\n                Cray Research, BBN Laboratories, September\
    \ 1988.\n"
- title: '[RFC1112]       Deering, S., "Host Extensions for IP Multicasting",'
  contents:
  - "[RFC1112]       Deering, S., \"Host Extensions for IP Multicasting\",\n     \
    \           STD 5, RFC 1112, Stanford University, August 1989.\n"
- title: '[WoHD95]        L. Wolf, R. G. Herrtwich, L. Delgrossi: Filtering'
  contents:
  - "[WoHD95]        L. Wolf, R. G. Herrtwich, L. Delgrossi: Filtering\n         \
    \       Multimedia Data in Reservation-based Networks,\n                Kommunikation\
    \ in Verteilten Systemen 1995 (KiVS),\n                Chemnitz-Zwickau, Germany,\
    \ February 1995.\n"
- title: '[RFC1122]       Braden, R., "Requirements for Internet Hosts --'
  contents:
  - "[RFC1122]       Braden, R., \"Requirements for Internet Hosts --\n          \
    \      Communication Layers\", STD 3, RFC 1122,\n                USC/Information\
    \ Sciences Institute, October 1989.\n"
- title: '[Jaco88]        Jacobson, V.: Congestion Avoidance and Control, ACM'
  contents:
  - "[Jaco88]        Jacobson, V.: Congestion Avoidance and Control, ACM\n       \
    \         SIGCOMM-88, August 1988.\n"
- title: '[KaPa87]        Karn, P. and C. Partridge: Round Trip Time Estimation,'
  contents:
  - "[KaPa87]        Karn, P. and C. Partridge: Round Trip Time Estimation,\n    \
    \            ACM SIGCOMM-87, August 1987.\n"
- title: '[RFC1141]       Mallory, T., and A. Kullberg, "Incremental Updating'
  contents:
  - "[RFC1141]       Mallory, T., and A. Kullberg, \"Incremental Updating\n      \
    \          of the Internet Checksum\", RFC 1141, BBN, January 1990.\n"
- title: '[RFC1363]       Partridge, C., "A Proposal Flow Specification",'
  contents:
  - "[RFC1363]       Partridge, C., \"A Proposal Flow Specification\",\n         \
    \       RFC 1363, BBN, September 1992.\n"
- title: '[RFC791]        Postel, J., "Internet Protocol", STD 5, RFC 791,'
  contents:
  - "[RFC791]        Postel, J., \"Internet Protocol\", STD 5, RFC 791,\n        \
    \        DARPA, September 1981.\n"
- title: '[RFC1700]       Reynolds, J., and J. Postel, "Assigned Numbers",'
  contents:
  - "[RFC1700]       Reynolds, J., and J. Postel, \"Assigned Numbers\",\n        \
    \        STD 2, RFC 1700, USC/Information Sciences Institute,\n              \
    \  October 1994.\n"
- title: '[RFC1190]       Topolcic C., "Internet Stream Protocol Version 2'
  contents:
  - "[RFC1190]       Topolcic C., \"Internet Stream Protocol Version 2\n         \
    \       (ST-II)\", RFC 1190, CIP Working Group, October 1990.\n"
- title: '[RFC1633]       Braden, R., Clark, D., and S. Shenker, "Integrated'
  contents:
  - "[RFC1633]       Braden, R., Clark, D., and S. Shenker, \"Integrated\n       \
    \         Services in the Internet Architecture: an Overview\",\n            \
    \    RFC 1633, USC/Information Sciences Institute,\n                MIT, Xerox\
    \ PARC, June 1994.\n"
- title: '[VoHN93]        C. Vogt, R. G. Herrtwich, R. Nagarajan: HeiRAT: the'
  contents:
  - "[VoHN93]        C. Vogt, R. G. Herrtwich, R. Nagarajan: HeiRAT: the\n       \
    \         Heidelberg Resource Administration Technique - Design\n            \
    \    Philosophy and Goals, Kommunikation In Verteilten\n                Systemen,\
    \ Munich, Informatik Aktuell, Springer-Verlag,\n                Heidelberg, 1993.\n"
- title: '[Cohe81]        D. Cohen: A Network Voice Protocol NVP-II, University of'
  contents:
  - "[Cohe81]        D. Cohen: A Network Voice Protocol NVP-II, University of\n  \
    \              Southern California, Los Angeles, 1981.\n"
- title: '[Cole81]        R. Cole: PVP - A Packet Video Protocol, University of'
  contents:
  - "[Cole81]        R. Cole: PVP - A Packet Video Protocol, University of\n     \
    \           Southern California, Los Angeles, 1981.\n"
- title: '[DeAl92]        L. Delgrossi (Ed.) The BERKOM-II Multimedia Transport'
  contents:
  - "[DeAl92]        L. Delgrossi (Ed.) The BERKOM-II Multimedia Transport\n     \
    \           System, Version 1, BERKOM Working Document, October,\n           \
    \     1992.\n"
- title: '[DHHS92]        L. Delgrossi, C. Halstrick, R. G. Herrtwich, H.'
  contents:
  - "[DHHS92]        L. Delgrossi, C. Halstrick, R. G. Herrtwich, H.\n           \
    \     Stuettgen: HeiTP: a Transport Protocol for ST-II,\n                GLOBECOM'92,\
    \ Orlando (Florida), December 1992.\n"
- title: '[Schu94]        H. Schulzrinne: RTP: A Transport Protocol for Real-Time'
  contents:
  - "[Schu94]        H. Schulzrinne: RTP: A Transport Protocol for Real-Time\n   \
    \             Applications. Work in Progress, 1994.\n"
- title: 12.  Security Considerations
  contents:
  - "12.  Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: 13.  Acknowledgments and Authors' Addresses
  contents:
  - "13.  Acknowledgments and Authors' Addresses\n   Many individuals have contributed\
    \ to the work described in this memo.\n   We thank the participants in the ST\
    \ Working Group for their input,\n   review, and constructive comments. George\
    \ Mason University C3I Center\n   for hosting an interim meeting. Murali Rajagopal\
    \ for his efforts on\n   ST2+ state machines. Special thanks are due to Steve\
    \ DeJarnett, who\n   served as working group co-chair until summer 1993.\n   We\
    \ would also like to acknowledge the authors of [RFC1190]. All\n   authors of\
    \ [RFC1190] should be considered authors of this document\n   since this document\
    \ contains much of their text and ideas.\n   Louis Berger\n   BBN Systems and\
    \ Technologies\n   1300 North 17th Street, Suite 1200\n   Arlington, VA 22209\n\
    \   Phone: 703-284-4651\n   EMail: lberger@bbn.com\n   Luca Delgrossi\n   Andersen\
    \ Consulting Technology Park\n   449, Route des Cretes\n   06902 Sophia Antipolis,\
    \ France\n   Phone: +33.92.94.80.92\n   EMail: luca@andersen.fr\n   Dat Duong\n\
    \   BBN Systems and Technologies\n   1300 North 17th Street, Suite 1200\n   Arlington,\
    \ VA 22209\n   Phone: 703-284-4760\n   EMail: dat@bbn.com\n   Steve Jackowski\n\
    \   Syzygy Communications Incorporated\n   269 Mt. Hermon Road\n   Scotts Valley,\
    \ CA 95066\n   Phone: 408-439-6834\n   EMail: stevej@syzygycomm.com\n   Sibylle\
    \ Schaller\n   IBM ENC\n   Broadband Multimedia Communications\n   Vangerowstr.\
    \ 18\n   D69020 Heidelberg, Germany\n   Phone: +49-6221-5944553\n   EMail: schaller@heidelbg.ibm.com\n"
