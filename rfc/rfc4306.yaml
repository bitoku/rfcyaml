- title: __initial_text__
  contents:
  - '                 Internet Key Exchange (IKEv2) Protocol

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes version 2 of the Internet Key Exchange (IKE)\n\
    \   protocol.  IKE is a component of IPsec used for performing mutual\n   authentication\
    \ and establishing and maintaining security associations\n   (SAs).\n   This version\
    \ of the IKE specification combines the contents of what\n   were previously separate\
    \ documents, including Internet Security\n   Association and Key Management Protocol\
    \ (ISAKMP, RFC 2408), IKE (RFC\n   2409), the Internet Domain of Interpretation\
    \ (DOI, RFC 2407), Network\n   Address Translation (NAT) Traversal, Legacy authentication,\
    \ and\n   remote address acquisition.\n   Version 2 of IKE does not interoperate\
    \ with version 1, but it has\n   enough of the header format in common that both\
    \ versions can\n   unambiguously run over the same UDP port.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Usage Scenarios ............................................5\n  \
    \    1.2. The Initial Exchanges ......................................7\n    \
    \  1.3. The CREATE_CHILD_SA Exchange ...............................9\n      1.4.\
    \ The INFORMATIONAL Exchange ................................11\n      1.5. Informational\
    \ Messages outside of an IKE_SA ...............12\n   2. IKE Protocol Details\
    \ and Variations ............................12\n      2.1. Use of Retransmission\
    \ Timers ..............................13\n      2.2. Use of Sequence Numbers\
    \ for Message ID ....................14\n      2.3. Window Size for Overlapping\
    \ Requests ......................14\n      2.4. State Synchronization and Connection\
    \ Timeouts .............15\n      2.5. Version Numbers and Forward Compatibility\
    \ .................17\n      2.6. Cookies ...................................................18\n\
    \      2.7. Cryptographic Algorithm Negotiation .......................21\n  \
    \    2.8. Rekeying ..................................................22\n    \
    \  2.9. Traffic Selector Negotiation ..............................24\n      2.10.\
    \ Nonces ...................................................26\n      2.11. Address\
    \ and Port Agility .................................26\n      2.12. Reuse of Diffie-Hellman\
    \ Exponentials .....................27\n      2.13. Generating Keying Material\
    \ ...............................27\n      2.14. Generating Keying Material for\
    \ the IKE_SA ................28\n      2.15. Authentication of the IKE_SA .............................29\n\
    \      2.16. Extensible Authentication Protocol Methods ...............31\n  \
    \    2.17. Generating Keying Material for CHILD_SAs .................33\n    \
    \  2.18. Rekeying IKE_SAs Using a CREATE_CHILD_SA exchange ........34\n      2.19.\
    \ Requesting an Internal Address on a Remote Network .......34\n      2.20. Requesting\
    \ the Peer's Version ............................35\n      2.21. Error Handling\
    \ ...........................................36\n      2.22. IPComp ...................................................37\n\
    \      2.23. NAT Traversal ............................................38\n  \
    \    2.24. Explicit Congestion Notification (ECN) ...................40\n   3.\
    \ Header and Payload Formats .....................................41\n      3.1.\
    \ The IKE Header ............................................41\n      3.2. Generic\
    \ Payload Header ....................................44\n      3.3. Security Association\
    \ Payload ..............................46\n      3.4. Key Exchange Payload ......................................56\n\
    \      3.5. Identification Payloads ...................................56\n  \
    \    3.6. Certificate Payload .......................................59\n    \
    \  3.7. Certificate Request Payload ...............................61\n      3.8.\
    \ Authentication Payload ....................................63\n      3.9. Nonce\
    \ Payload .............................................64\n      3.10. Notify\
    \ Payload ...........................................64\n      3.11. Delete Payload\
    \ ...........................................72\n      3.12. Vendor ID Payload\
    \ ........................................73\n      3.13. Traffic Selector Payload\
    \ .................................74\n      3.14. Encrypted Payload ........................................77\n\
    \      3.15. Configuration Payload ....................................79\n  \
    \    3.16. Extensible Authentication Protocol (EAP) Payload .........84\n   4.\
    \ Conformance Requirements .......................................85\n   5. Security\
    \ Considerations ........................................88\n   6. IANA Considerations\
    \ ............................................90\n   7. Acknowledgements ...............................................91\n\
    \   8. References .....................................................91\n  \
    \    8.1. Normative References ......................................91\n    \
    \  8.2. Informative References ....................................92\n   Appendix\
    \ A: Summary of Changes from IKEv1 .........................96\n   Appendix B:\
    \ Diffie-Hellman Groups .................................97\n      B.1. Group\
    \ 1 - 768 Bit MODP ....................................97\n      B.2. Group 2\
    \ - 1024 Bit MODP ...................................97\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   IP Security (IPsec) provides confidentiality, data integrity,\
    \ access\n   control, and data source authentication to IP datagrams.  These\n\
    \   services are provided by maintaining shared state between the source\n   and\
    \ the sink of an IP datagram.  This state defines, among other\n   things, the\
    \ specific services provided to the datagram, which\n   cryptographic algorithms\
    \ will be used to provide the services, and\n   the keys used as input to the\
    \ cryptographic algorithms.\n   Establishing this shared state in a manual fashion\
    \ does not scale\n   well.  Therefore, a protocol to establish this state dynamically\
    \ is\n   needed.  This memo describes such a protocol -- the Internet Key\n  \
    \ Exchange (IKE).  This is version 2 of IKE.  Version 1 of IKE was\n   defined\
    \ in RFCs 2407, 2408, and 2409 [Pip98, MSST98, HC98].  This\n   single document\
    \ is intended to replace all three of those RFCs.\n   Definitions of the primitive\
    \ terms in this document (such as Security\n   Association or SA) can be found\
    \ in [RFC4301].\n   Keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHOULD\"\
    , \"SHOULD NOT\" and\n   \"MAY\" that appear in this document are to be interpreted\
    \ as described\n   in [Bra97].\n   The term \"Expert Review\" is to be interpreted\
    \ as defined in\n   [RFC2434].\n   IKE performs mutual authentication between\
    \ two parties and\n   establishes an IKE security association (SA) that includes\
    \ shared\n   secret information that can be used to efficiently establish SAs\
    \ for\n   Encapsulating Security Payload (ESP) [RFC4303] and/or Authentication\n\
    \   Header (AH) [RFC4302] and a set of cryptographic algorithms to be\n   used\
    \ by the SAs to protect the traffic that they carry.  In this\n   document, the\
    \ term \"suite\" or \"cryptographic suite\" refers to a\n   complete set of algorithms\
    \ used to protect an SA.  An initiator\n   proposes one or more suites by listing\
    \ supported algorithms that can\n   be combined into suites in a mix-and-match\
    \ fashion.  IKE can also\n   negotiate use of IP Compression (IPComp) [IPCOMP]\
    \ in connection with\n   an ESP and/or AH SA.  We call the IKE SA an \"IKE_SA\"\
    .  The SAs for\n   ESP and/or AH that get set up through that IKE_SA we call\n\
    \   \"CHILD_SAs\".\n   All IKE communications consist of pairs of messages: a\
    \ request and a\n   response.  The pair is called an \"exchange\".  We call the\
    \ first\n   messages establishing an IKE_SA IKE_SA_INIT and IKE_AUTH exchanges\n\
    \   and subsequent IKE exchanges CREATE_CHILD_SA or INFORMATIONAL\n   exchanges.\
    \  In the common case, there is a single IKE_SA_INIT\n   exchange and a single\
    \ IKE_AUTH exchange (a total of four messages) to\n   establish the IKE_SA and\
    \ the first CHILD_SA.  In exceptional cases,\n   there may be more than one of\
    \ each of these exchanges.  In all cases,\n   all IKE_SA_INIT exchanges MUST complete\
    \ before any other exchange\n   type, then all IKE_AUTH exchanges MUST complete,\
    \ and following that\n   any number of CREATE_CHILD_SA and INFORMATIONAL exchanges\
    \ may occur\n   in any order.  In some scenarios, only a single CHILD_SA is needed\n\
    \   between the IPsec endpoints, and therefore there would be no\n   additional\
    \ exchanges.  Subsequent exchanges MAY be used to establish\n   additional CHILD_SAs\
    \ between the same authenticated pair of endpoints\n   and to perform housekeeping\
    \ functions.\n   IKE message flow always consists of a request followed by a response.\n\
    \   It is the responsibility of the requester to ensure reliability.  If\n   the\
    \ response is not received within a timeout interval, the requester\n   needs\
    \ to retransmit the request (or abandon the connection).\n   The first request/response\
    \ of an IKE session (IKE_SA_INIT) negotiates\n   security parameters for the IKE_SA,\
    \ sends nonces, and sends Diffie-\n   Hellman values.\n   The second request/response\
    \ (IKE_AUTH) transmits identities, proves\n   knowledge of the secrets corresponding\
    \ to the two identities, and\n   sets up an SA for the first (and often only)\
    \ AH and/or ESP CHILD_SA.\n   The types of subsequent exchanges are CREATE_CHILD_SA\
    \ (which creates\n   a CHILD_SA) and INFORMATIONAL (which deletes an SA, reports\
    \ error\n   conditions, or does other housekeeping).  Every request requires a\n\
    \   response.  An INFORMATIONAL request with no payloads (other than the\n   empty\
    \ Encrypted payload required by the syntax) is commonly used as a\n   check for\
    \ liveness.  These subsequent exchanges cannot be used until\n   the initial exchanges\
    \ have completed.\n   In the description that follows, we assume that no errors\
    \ occur.\n   Modifications to the flow should errors occur are described in\n\
    \   section 2.21.\n"
- title: 1.1.  Usage Scenarios
  contents:
  - "1.1.  Usage Scenarios\n   IKE is expected to be used to negotiate ESP and/or\
    \ AH SAs in a number\n   of different scenarios, each with its own special requirements.\n"
- title: 1.1.1.  Security Gateway to Security Gateway Tunnel
  contents:
  - "1.1.1.  Security Gateway to Security Gateway Tunnel\n                    +-+-+-+-+-+\
    \            +-+-+-+-+-+\n                    !         ! IPsec      !       \
    \  !\n       Protected    !Tunnel   ! tunnel     !Tunnel   !     Protected\n \
    \      Subnet   <-->!Endpoint !<---------->!Endpoint !<--> Subnet\n          \
    \          !         !            !         !\n                    +-+-+-+-+-+\
    \            +-+-+-+-+-+\n             Figure 1:  Security Gateway to Security\
    \ Gateway Tunnel\n   In this scenario, neither endpoint of the IP connection implements\n\
    \   IPsec, but network nodes between them protect traffic for part of the\n  \
    \ way.  Protection is transparent to the endpoints, and depends on\n   ordinary\
    \ routing to send packets through the tunnel endpoints for\n   processing.  Each\
    \ endpoint would announce the set of addresses\n   \"behind\" it, and packets\
    \ would be sent in tunnel mode where the inner\n   IP header would contain the\
    \ IP addresses of the actual endpoints.\n"
- title: 1.1.2.  Endpoint-to-Endpoint Transport
  contents:
  - "1.1.2.  Endpoint-to-Endpoint Transport\n       +-+-+-+-+-+                  \
    \                        +-+-+-+-+-+\n       !         !                 IPsec\
    \ transport          !         !\n       !Protected!                or tunnel\
    \ mode SA         !Protected!\n       !Endpoint !<---------------------------------------->!Endpoint\
    \ !\n       !         !                                          !         !\n\
    \       +-+-+-+-+-+                                          +-+-+-+-+-+\n   \
    \                    Figure 2:  Endpoint to Endpoint\n   In this scenario, both\
    \ endpoints of the IP connection implement\n   IPsec, as required of hosts in\
    \ [RFC4301].  Transport mode will\n   commonly be used with no inner IP header.\
    \  If there is an inner IP\n   header, the inner addresses will be the same as\
    \ the outer addresses.\n   A single pair of addresses will be negotiated for packets\
    \ to be\n   protected by this SA.  These endpoints MAY implement application\n\
    \   layer access controls based on the IPsec authenticated identities of\n   the\
    \ participants.  This scenario enables the end-to-end security that\n   has been\
    \ a guiding principle for the Internet since [RFC1958],\n   [RFC2775], and a method\
    \ of limiting the inherent problems with\n   complexity in networks noted by [RFC3439].\
    \  Although this scenario\n   may not be fully applicable to the IPv4 Internet,\
    \ it has been\n   deployed successfully in specific scenarios within intranets\
    \ using\n   IKEv1.  It should be more broadly enabled during the transition to\n\
    \   IPv6 and with the adoption of IKEv2.\n   It is possible in this scenario that\
    \ one or both of the protected\n   endpoints will be behind a network address\
    \ translation (NAT) node, in\n   which case the tunneled packets will have to\
    \ be UDP encapsulated so\n   that port numbers in the UDP headers can be used\
    \ to identify\n   individual endpoints \"behind\" the NAT (see section 2.23).\n"
- title: 1.1.3.  Endpoint to Security Gateway Tunnel
  contents:
  - "1.1.3.  Endpoint to Security Gateway Tunnel\n       +-+-+-+-+-+             \
    \             +-+-+-+-+-+\n       !         !         IPsec            !     \
    \    !     Protected\n       !Protected!         tunnel           !Tunnel   !\
    \     Subnet\n       !Endpoint !<------------------------>!Endpoint !<--- and/or\n\
    \       !         !                          !         !     Internet\n      \
    \ +-+-+-+-+-+                          +-+-+-+-+-+\n                 Figure 3:\
    \  Endpoint to Security Gateway Tunnel\n   In this scenario, a protected endpoint\
    \ (typically a portable roaming\n   computer) connects back to its corporate network\
    \ through an IPsec-\n   protected tunnel.  It might use this tunnel only to access\n\
    \   information on the corporate network, or it might tunnel all of its\n   traffic\
    \ back through the corporate network in order to take advantage\n   of protection\
    \ provided by a corporate firewall against Internet-based\n   attacks.  In either\
    \ case, the protected endpoint will want an IP\n   address associated with the\
    \ security gateway so that packets returned\n   to it will go to the security\
    \ gateway and be tunneled back.  This IP\n   address may be static or may be dynamically\
    \ allocated by the security\n   gateway.  In support of the latter case, IKEv2\
    \ includes a mechanism\n   for the initiator to request an IP address owned by\
    \ the security\n   gateway for use for the duration of its SA.\n   In this scenario,\
    \ packets will use tunnel mode.  On each packet from\n   the protected endpoint,\
    \ the outer IP header will contain the source\n   IP address associated with its\
    \ current location (i.e., the address\n   that will get traffic routed to the\
    \ endpoint directly), while the\n   inner IP header will contain the source IP\
    \ address assigned by the\n   security gateway (i.e., the address that will get\
    \ traffic routed to\n   the security gateway for forwarding to the endpoint).\
    \  The outer\n   destination address will always be that of the security gateway,\n\
    \   while the inner destination address will be the ultimate destination\n   for\
    \ the packet.\n   In this scenario, it is possible that the protected endpoint\
    \ will be\n   behind a NAT.  In that case, the IP address as seen by the security\n\
    \   gateway will not be the same as the IP address sent by the protected\n   endpoint,\
    \ and packets will have to be UDP encapsulated in order to be\n   routed properly.\n"
- title: 1.1.4.  Other Scenarios
  contents:
  - "1.1.4.  Other Scenarios\n   Other scenarios are possible, as are nested combinations\
    \ of the\n   above.  One notable example combines aspects of 1.1.1 and 1.1.3.\
    \ A\n   subnet may make all external accesses through a remote security\n   gateway\
    \ using an IPsec tunnel, where the addresses on the subnet are\n   routed to the\
    \ security gateway by the rest of the Internet.  An\n   example would be someone's\
    \ home network being virtually on the\n   Internet with static IP addresses even\
    \ though connectivity is\n   provided by an ISP that assigns a single dynamically\
    \ assigned IP\n   address to the user's security gateway (where the static IP\
    \ addresses\n   and an IPsec relay are provided by a third party located elsewhere).\n"
- title: 1.2.  The Initial Exchanges
  contents:
  - "1.2.  The Initial Exchanges\n   Communication using IKE always begins with IKE_SA_INIT\
    \ and IKE_AUTH\n   exchanges (known in IKEv1 as Phase 1).  These initial exchanges\n\
    \   normally consist of four messages, though in some scenarios that\n   number\
    \ can grow.  All communications using IKE consist of\n   request/response pairs.\
    \  We'll describe the base exchange first,\n   followed by variations.  The first\
    \ pair of messages (IKE_SA_INIT)\n   negotiate cryptographic algorithms, exchange\
    \ nonces, and do a\n   Diffie-Hellman exchange [DH].\n   The second pair of messages\
    \ (IKE_AUTH) authenticate the previous\n   messages, exchange identities and certificates,\
    \ and establish the\n   first CHILD_SA.  Parts of these messages are encrypted\
    \ and integrity\n   protected with keys established through the IKE_SA_INIT exchange,\
    \ so\n   the identities are hidden from eavesdroppers and all fields in all\n\
    \   the messages are authenticated.\n   In the following descriptions, the payloads\
    \ contained in the message\n   are indicated by names as listed below.\n   Notation\
    \    Payload\n   AUTH      Authentication\n   CERT      Certificate\n   CERTREQ\
    \   Certificate Request\n   CP        Configuration\n   D         Delete\n   E\
    \         Encrypted\n   EAP       Extensible Authentication\n   HDR       IKE\
    \ Header\n   IDi       Identification - Initiator\n   IDr       Identification\
    \ - Responder\n   KE        Key Exchange\n   Ni, Nr    Nonce\n   N         Notify\n\
    \   SA        Security Association\n   TSi       Traffic Selector - Initiator\n\
    \   TSr       Traffic Selector - Responder\n   V         Vendor ID\n   The details\
    \ of the contents of each payload are described in section\n   3.  Payloads that\
    \ may optionally appear will be shown in brackets,\n   such as [CERTREQ], indicate\
    \ that optionally a certificate request\n   payload can be included.\n   The initial\
    \ exchanges are as follows:\n       Initiator                          Responder\n\
    \      -----------                        -----------\n       HDR, SAi1, KEi,\
    \ Ni   -->\n   HDR contains the Security Parameter Indexes (SPIs), version numbers,\n\
    \   and flags of various sorts.  The SAi1 payload states the\n   cryptographic\
    \ algorithms the initiator supports for the IKE_SA.  The\n   KE payload sends\
    \ the initiator's Diffie-Hellman value.  Ni is the\n   initiator's nonce.\n  \
    \                          <--    HDR, SAr1, KEr, Nr, [CERTREQ]\n   The responder\
    \ chooses a cryptographic suite from the initiator's\n   offered choices and expresses\
    \ that choice in the SAr1 payload,\n   completes the Diffie-Hellman exchange with\
    \ the KEr payload, and sends\n   its nonce in the Nr payload.\n   At this point\
    \ in the negotiation, each party can generate SKEYSEED,\n   from which all keys\
    \ are derived for that IKE_SA.  All but the headers\n   of all the messages that\
    \ follow are encrypted and integrity\n   protected.  The keys used for the encryption\
    \ and integrity protection\n   are derived from SKEYSEED and are known as SK_e\
    \ (encryption) and SK_a\n   (authentication, a.k.a.  integrity protection).  A\
    \ separate SK_e and\n   SK_a is computed for each direction.  In addition to the\
    \ keys SK_e\n   and SK_a derived from the DH value for protection of the IKE_SA,\n\
    \   another quantity SK_d is derived and used for derivation of further\n   keying\
    \ material for CHILD_SAs.  The notation SK { ... } indicates\n   that these payloads\
    \ are encrypted and integrity protected using that\n   direction's SK_e and SK_a.\n\
    \       HDR, SK {IDi, [CERT,] [CERTREQ,] [IDr,]\n                  AUTH, SAi2,\
    \ TSi, TSr}     -->\n   The initiator asserts its identity with the IDi payload,\
    \ proves\n   knowledge of the secret corresponding to IDi and integrity protects\n\
    \   the contents of the first message using the AUTH payload (see section\n  \
    \ 2.15).  It might also send its certificate(s) in CERT payload(s) and\n   a list\
    \ of its trust anchors in CERTREQ payload(s).  If any CERT\n   payloads are included,\
    \ the first certificate provided MUST contain\n   the public key used to verify\
    \ the AUTH field.  The optional payload\n   IDr enables the initiator to specify\
    \ which of the responder's\n   identities it wants to talk to.  This is useful\
    \ when the machine on\n   which the responder is running is hosting multiple identities\
    \ at the\n   same IP address.  The initiator begins negotiation of a CHILD_SA\n\
    \   using the SAi2 payload.  The final fields (starting with SAi2) are\n   described\
    \ in the description of the CREATE_CHILD_SA exchange.\n                      \
    \             <--    HDR, SK {IDr, [CERT,] AUTH,\n                           \
    \                     SAr2, TSi, TSr}\n   The responder asserts its identity with\
    \ the IDr payload, optionally\n   sends one or more certificates (again with the\
    \ certificate containing\n   the public key used to verify AUTH listed first),\
    \ authenticates its\n   identity and protects the integrity of the second message\
    \ with the\n   AUTH payload, and completes negotiation of a CHILD_SA with the\n\
    \   additional fields described below in the CREATE_CHILD_SA exchange.\n   The\
    \ recipients of messages 3 and 4 MUST verify that all signatures\n   and MACs\
    \ are computed correctly and that the names in the ID payloads\n   correspond\
    \ to the keys used to generate the AUTH payload.\n"
- title: 1.3.  The CREATE_CHILD_SA Exchange
  contents:
  - "1.3.  The CREATE_CHILD_SA Exchange\n   This exchange consists of a single request/response\
    \ pair, and was\n   referred to as a phase 2 exchange in IKEv1.  It MAY be initiated\
    \ by\n   either end of the IKE_SA after the initial exchanges are completed.\n\
    \   All messages following the initial exchange are cryptographically\n   protected\
    \ using the cryptographic algorithms and keys negotiated in\n   the first two\
    \ messages of the IKE exchange.  These subsequent\n   messages use the syntax\
    \ of the Encrypted Payload described in section\n   3.14.  All subsequent messages\
    \ included an Encrypted Payload, even if\n   they are referred to in the text\
    \ as \"empty\".\n   Either endpoint may initiate a CREATE_CHILD_SA exchange, so\
    \ in this\n   section the term \"initiator\" refers to the endpoint initiating\
    \ this\n   exchange.\n   A CHILD_SA is created by sending a CREATE_CHILD_SA request.\
    \  The\n   CREATE_CHILD_SA request MAY optionally contain a KE payload for an\n\
    \   additional Diffie-Hellman exchange to enable stronger guarantees of\n   forward\
    \ secrecy for the CHILD_SA.  The keying material for the\n   CHILD_SA is a function\
    \ of SK_d established during the establishment\n   of the IKE_SA, the nonces exchanged\
    \ during the CREATE_CHILD_SA\n   exchange, and the Diffie-Hellman value (if KE\
    \ payloads are included\n   in the CREATE_CHILD_SA exchange).\n   In the CHILD_SA\
    \ created as part of the initial exchange, a second KE\n   payload and nonce MUST\
    \ NOT be sent.  The nonces from the initial\n   exchange are used in computing\
    \ the keys for the CHILD_SA.\n   The CREATE_CHILD_SA request contains:\n     \
    \  Initiator                                 Responder\n      -----------    \
    \                           -----------\n       HDR, SK {[N], SA, Ni, [KEi],\n\
    \           [TSi, TSr]}             -->\n   The initiator sends SA offer(s) in\
    \ the SA payload, a nonce in the Ni\n   payload, optionally a Diffie-Hellman value\
    \ in the KEi payload, and\n   the proposed traffic selectors in the TSi and TSr\
    \ payloads.  If this\n   CREATE_CHILD_SA exchange is rekeying an existing SA other\
    \ than the\n   IKE_SA, the leading N payload of type REKEY_SA MUST identify the\
    \ SA\n   being rekeyed.  If this CREATE_CHILD_SA exchange is not rekeying an\n\
    \   existing SA, the N payload MUST be omitted.  If the SA offers include\n  \
    \ different Diffie-Hellman groups, KEi MUST be an element of the group\n   the\
    \ initiator expects the responder to accept.  If it guesses wrong,\n   the CREATE_CHILD_SA\
    \ exchange will fail, and it will have to retry\n   with a different KEi.\n  \
    \ The message following the header is encrypted and the message\n   including\
    \ the header is integrity protected using the cryptographic\n   algorithms negotiated\
    \ for the IKE_SA.\n   The CREATE_CHILD_SA response contains:\n               \
    \                   <--    HDR, SK {SA, Nr, [KEr],\n                         \
    \                      [TSi, TSr]}\n   The responder replies (using the same Message\
    \ ID to respond) with the\n   accepted offer in an SA payload, and a Diffie-Hellman\
    \ value in the\n   KEr payload if KEi was included in the request and the selected\n\
    \   cryptographic suite includes that group.  If the responder chooses a\n   cryptographic\
    \ suite with a different group, it MUST reject the\n   request.  The initiator\
    \ SHOULD repeat the request, but now with a KEi\n   payload from the group the\
    \ responder selected.\n   The traffic selectors for traffic to be sent on that\
    \ SA are specified\n   in the TS payloads, which may be a subset of what the initiator\
    \ of\n   the CHILD_SA proposed.  Traffic selectors are omitted if this\n   CREATE_CHILD_SA\
    \ request is being used to change the key of the\n   IKE_SA.\n"
- title: 1.4.  The INFORMATIONAL Exchange
  contents:
  - "1.4.  The INFORMATIONAL Exchange\n   At various points during the operation of\
    \ an IKE_SA, peers may desire\n   to convey control messages to each other regarding\
    \ errors or\n   notifications of certain events.  To accomplish this, IKE defines\
    \ an\n   INFORMATIONAL exchange.  INFORMATIONAL exchanges MUST ONLY occur\n  \
    \ after the initial exchanges and are cryptographically protected with\n   the\
    \ negotiated keys.\n   Control messages that pertain to an IKE_SA MUST be sent\
    \ under that\n   IKE_SA.  Control messages that pertain to CHILD_SAs MUST be sent\n\
    \   under the protection of the IKE_SA which generated them (or its\n   successor\
    \ if the IKE_SA was replaced for the purpose of rekeying).\n   Messages in an\
    \ INFORMATIONAL exchange contain zero or more\n   Notification, Delete, and Configuration\
    \ payloads.  The Recipient of\n   an INFORMATIONAL exchange request MUST send\
    \ some response (else the\n   Sender will assume the message was lost in the network\
    \ and will\n   retransmit it).  That response MAY be a message with no payloads.\n\
    \   The request message in an INFORMATIONAL exchange MAY also contain no\n   payloads.\
    \  This is the expected way an endpoint can ask the other\n   endpoint to verify\
    \ that it is alive.\n   ESP and AH SAs always exist in pairs, with one SA in each\
    \ direction.\n   When an SA is closed, both members of the pair MUST be closed.\
    \  When\n   SAs are nested, as when data (and IP headers if in tunnel mode) are\n\
    \   encapsulated first with IPComp, then with ESP, and finally with AH\n   between\
    \ the same pair of endpoints, all of the SAs MUST be deleted\n   together.  Each\
    \ endpoint MUST close its incoming SAs and allow the\n   other endpoint to close\
    \ the other SA in each pair.  To delete an SA,\n   an INFORMATIONAL exchange with\
    \ one or more delete payloads is sent\n   listing the SPIs (as they would be expected\
    \ in the headers of inbound\n   packets) of the SAs to be deleted.  The recipient\
    \ MUST close the\n   designated SAs.  Normally, the reply in the INFORMATIONAL\
    \ exchange\n   will contain delete payloads for the paired SAs going in the other\n\
    \   direction.  There is one exception.  If by chance both ends of a set\n   of\
    \ SAs independently decide to close them, each may send a delete\n   payload and\
    \ the two requests may cross in the network.  If a node\n   receives a delete\
    \ request for SAs for which it has already issued a\n   delete request, it MUST\
    \ delete the outgoing SAs while processing the\n   request and the incoming SAs\
    \ while processing the response.  In that\n   case, the responses MUST NOT include\
    \ delete payloads for the deleted\n   SAs, since that would result in duplicate\
    \ deletion and could in\n   theory delete the wrong SA.\n   A node SHOULD regard\
    \ half-closed connections as anomalous and audit\n   their existence should they\
    \ persist.  Note that this specification\n   nowhere specifies time periods, so\
    \ it is up to individual endpoints\n   to decide how long to wait.  A node MAY\
    \ refuse to accept incoming\n   data on half-closed connections but MUST NOT unilaterally\
    \ close them\n   and reuse the SPIs.  If connection state becomes sufficiently\
    \ messed\n   up, a node MAY close the IKE_SA; doing so will implicitly close all\n\
    \   SAs negotiated under it.  It can then rebuild the SAs it needs on a\n   clean\
    \ base under a new IKE_SA.\n   The INFORMATIONAL exchange is defined as:\n   \
    \    Initiator                        Responder\n      -----------           \
    \           -----------\n       HDR, SK {[N,] [D,] [CP,] ...} -->\n          \
    \                         <-- HDR, SK {[N,] [D,] [CP], ...}\n   The processing\
    \ of an INFORMATIONAL exchange is determined by its\n   component payloads.\n"
- title: 1.5.  Informational Messages outside of an IKE_SA
  contents:
  - "1.5.  Informational Messages outside of an IKE_SA\n   If an encrypted IKE packet\
    \ arrives on port 500 or 4500 with an\n   unrecognized SPI, it could be because\
    \ the receiving node has recently\n   crashed and lost state or because of some\
    \ other system malfunction or\n   attack.  If the receiving node has an active\
    \ IKE_SA to the IP address\n   from whence the packet came, it MAY send a notification\
    \ of the\n   wayward packet over that IKE_SA in an INFORMATIONAL exchange.  If\
    \ it\n   does not have such an IKE_SA, it MAY send an Informational message\n\
    \   without cryptographic protection to the source IP address.  Such a\n   message\
    \ is not part of an informational exchange, and the receiving\n   node MUST NOT\
    \ respond to it.  Doing so could cause a message loop.\n"
- title: 2.  IKE Protocol Details and Variations
  contents:
  - "2.  IKE Protocol Details and Variations\n   IKE normally listens and sends on\
    \ UDP port 500, though IKE messages\n   may also be received on UDP port 4500\
    \ with a slightly different\n   format (see section 2.23).  Since UDP is a datagram\
    \ (unreliable)\n   protocol, IKE includes in its definition recovery from transmission\n\
    \   errors, including packet loss, packet replay, and packet forgery.\n   IKE\
    \ is designed to function so long as (1) at least one of a series\n   of retransmitted\
    \ packets reaches its destination before timing out;\n   and (2) the channel is\
    \ not so full of forged and replayed packets so\n   as to exhaust the network\
    \ or CPU capacities of either endpoint.  Even\n   in the absence of those minimum\
    \ performance requirements, IKE is\n   designed to fail cleanly (as though the\
    \ network were broken).\n   Although IKEv2 messages are intended to be short,\
    \ they contain\n   structures with no hard upper bound on size (in particular,\
    \ X.509\n   certificates), and IKEv2 itself does not have a mechanism for\n  \
    \ fragmenting large messages.  IP defines a mechanism for fragmentation\n   of\
    \ oversize UDP messages, but implementations vary in the maximum\n   message size\
    \ supported.  Furthermore, use of IP fragmentation opens\n   an implementation\
    \ to denial of service attacks [KPS03].  Finally,\n   some NAT and/or firewall\
    \ implementations may block IP fragments.\n   All IKEv2 implementations MUST be\
    \ able to send, receive, and process\n   IKE messages that are up to 1280 bytes\
    \ long, and they SHOULD be able\n   to send, receive, and process messages that\
    \ are up to 3000 bytes\n   long.  IKEv2 implementations SHOULD be aware of the\
    \ maximum UDP\n   message size supported and MAY shorten messages by leaving out\
    \ some\n   certificates or cryptographic suite proposals if that will keep\n \
    \  messages below the maximum.  Use of the \"Hash and URL\" formats rather\n \
    \  than including certificates in exchanges where possible can avoid\n   most\
    \ problems.  Implementations and configuration should keep in\n   mind, however,\
    \ that if the URL lookups are possible only after the\n   IPsec SA is established,\
    \ recursion issues could prevent this\n   technique from working.\n"
- title: 2.1.  Use of Retransmission Timers
  contents:
  - "2.1.  Use of Retransmission Timers\n   All messages in IKE exist in pairs: a\
    \ request and a response.  The\n   setup of an IKE_SA normally consists of two\
    \ request/response pairs.\n   Once the IKE_SA is set up, either end of the security\
    \ association may\n   initiate requests at any time, and there can be many requests\
    \ and\n   responses \"in flight\" at any given moment.  But each message is\n\
    \   labeled as either a request or a response, and for each\n   request/response\
    \ pair one end of the security association is the\n   initiator and the other\
    \ is the responder.\n   For every pair of IKE messages, the initiator is responsible\
    \ for\n   retransmission in the event of a timeout.  The responder MUST never\n\
    \   retransmit a response unless it receives a retransmission of the\n   request.\
    \  In that event, the responder MUST ignore the retransmitted\n   request except\
    \ insofar as it triggers a retransmission of the\n   response.  The initiator\
    \ MUST remember each request until it receives\n   the corresponding response.\
    \  The responder MUST remember each\n   response until it receives a request whose\
    \ sequence number is larger\n   than the sequence number in the response plus\
    \ its window size (see\n   section 2.3).\n   IKE is a reliable protocol, in the\
    \ sense that the initiator MUST\n   retransmit a request until either it receives\
    \ a corresponding reply\n   OR it deems the IKE security association to have failed\
    \ and it\n   discards all state associated with the IKE_SA and any CHILD_SAs\n\
    \   negotiated using that IKE_SA.\n"
- title: 2.2.  Use of Sequence Numbers for Message ID
  contents:
  - "2.2.  Use of Sequence Numbers for Message ID\n   Every IKE message contains a\
    \ Message ID as part of its fixed header.\n   This Message ID is used to match\
    \ up requests and responses, and to\n   identify retransmissions of messages.\n\
    \   The Message ID is a 32-bit quantity, which is zero for the first IKE\n   request\
    \ in each direction.  The IKE_SA initial setup messages will\n   always be numbered\
    \ 0 and 1.  Each endpoint in the IKE Security\n   Association maintains two \"\
    current\" Message IDs: the next one to be\n   used for a request it initiates\
    \ and the next one it expects to see in\n   a request from the other end.  These\
    \ counters increment as requests\n   are generated and received.  Responses always\
    \ contain the same\n   message ID as the corresponding request.  That means that\
    \ after the\n   initial exchange, each integer n may appear as the message ID\
    \ in four\n   distinct messages: the nth request from the original IKE initiator,\n\
    \   the corresponding response, the nth request from the original IKE\n   responder,\
    \ and the corresponding response.  If the two ends make very\n   different numbers\
    \ of requests, the Message IDs in the two directions\n   can be very different.\
    \  There is no ambiguity in the messages,\n   however, because the (I)nitiator\
    \ and (R)esponse bits in the message\n   header specify which of the four messages\
    \ a particular one is.\n   Note that Message IDs are cryptographically protected\
    \ and provide\n   protection against message replays.  In the unlikely event that\n\
    \   Message IDs grow too large to fit in 32 bits, the IKE_SA MUST be\n   closed.\
    \  Rekeying an IKE_SA resets the sequence numbers.\n"
- title: 2.3.  Window Size for Overlapping Requests
  contents:
  - "2.3.  Window Size for Overlapping Requests\n   In order to maximize IKE throughput,\
    \ an IKE endpoint MAY issue\n   multiple requests before getting a response to\
    \ any of them if the\n   other endpoint has indicated its ability to handle such\
    \ requests.\n   For simplicity, an IKE implementation MAY choose to process requests\n\
    \   strictly in order and/or wait for a response to one request before\n   issuing\
    \ another.  Certain rules must be followed to ensure\n   interoperability between\
    \ implementations using different strategies.\n   After an IKE_SA is set up, either\
    \ end can initiate one or more\n   requests.  These requests may pass one another\
    \ over the network.  An\n   IKE endpoint MUST be prepared to accept and process\
    \ a request while\n   it has a request outstanding in order to avoid a deadlock\
    \ in this\n   situation.  An IKE endpoint SHOULD be prepared to accept and process\n\
    \   multiple requests while it has a request outstanding.\n   An IKE endpoint\
    \ MUST wait for a response to each of its messages\n   before sending a subsequent\
    \ message unless it has received a\n   SET_WINDOW_SIZE Notify message from its\
    \ peer informing it that the\n   peer is prepared to maintain state for multiple\
    \ outstanding messages\n   in order to allow greater throughput.\n   An IKE endpoint\
    \ MUST NOT exceed the peer's stated window size for\n   transmitted IKE requests.\
    \  In other words, if the responder stated\n   its window size is N, then when\
    \ the initiator needs to make a request\n   X, it MUST wait until it has received\
    \ responses to all requests up\n   through request X-N.  An IKE endpoint MUST\
    \ keep a copy of (or be able\n   to regenerate exactly) each request it has sent\
    \ until it receives the\n   corresponding response.  An IKE endpoint MUST keep\
    \ a copy of (or be\n   able to regenerate exactly) the number of previous responses\
    \ equal to\n   its declared window size in case its response was lost and the\n\
    \   initiator requests its retransmission by retransmitting the request.\n   An\
    \ IKE endpoint supporting a window size greater than one SHOULD be\n   capable\
    \ of processing incoming requests out of order to maximize\n   performance in\
    \ the event of network failures or packet reordering.\n"
- title: 2.4.  State Synchronization and Connection Timeouts
  contents:
  - "2.4.  State Synchronization and Connection Timeouts\n   An IKE endpoint is allowed\
    \ to forget all of its state associated with\n   an IKE_SA and the collection\
    \ of corresponding CHILD_SAs at any time.\n   This is the anticipated behavior\
    \ in the event of an endpoint crash\n   and restart.  It is important when an\
    \ endpoint either fails or\n   reinitializes its state that the other endpoint\
    \ detect those\n   conditions and not continue to waste network bandwidth by sending\n\
    \   packets over discarded SAs and having them fall into a black hole.\n   Since\
    \ IKE is designed to operate in spite of Denial of Service (DoS)\n   attacks from\
    \ the network, an endpoint MUST NOT conclude that the\n   other endpoint has failed\
    \ based on any routing information (e.g.,\n   ICMP messages) or IKE messages that\
    \ arrive without cryptographic\n   protection (e.g., Notify messages complaining\
    \ about unknown SPIs).\n   An endpoint MUST conclude that the other endpoint has\
    \ failed only\n   when repeated attempts to contact it have gone unanswered for\
    \ a\n   timeout period or when a cryptographically protected INITIAL_CONTACT\n\
    \   notification is received on a different IKE_SA to the same\n   authenticated\
    \ identity.  An endpoint SHOULD suspect that the other\n   endpoint has failed\
    \ based on routing information and initiate a\n   request to see whether the other\
    \ endpoint is alive.  To check whether\n   the other side is alive, IKE specifies\
    \ an empty INFORMATIONAL message\n   that (like all IKE requests) requires an\
    \ acknowledgement (note that\n   within the context of an IKE_SA, an \"empty\"\
    \ message consists of an\n   IKE header followed by an Encrypted payload that\
    \ contains no\n   payloads).  If a cryptographically protected message has been\n\
    \   received from the other side recently, unprotected notifications MAY\n   be\
    \ ignored.  Implementations MUST limit the rate at which they take\n   actions\
    \ based on unprotected messages.\n   Numbers of retries and lengths of timeouts\
    \ are not covered in this\n   specification because they do not affect interoperability.\
    \  It is\n   suggested that messages be retransmitted at least a dozen times over\n\
    \   a period of at least several minutes before giving up on an SA, but\n   different\
    \ environments may require different rules.  To be a good\n   network citizen,\
    \ retranmission times MUST increase exponentially to\n   avoid flooding the network\
    \ and making an existing congestion\n   situation worse.  If there has only been\
    \ outgoing traffic on all of\n   the SAs associated with an IKE_SA, it is essential\
    \ to confirm\n   liveness of the other endpoint to avoid black holes.  If no\n\
    \   cryptographically protected messages have been received on an IKE_SA\n   or\
    \ any of its CHILD_SAs recently, the system needs to perform a\n   liveness check\
    \ in order to prevent sending messages to a dead peer.\n   Receipt of a fresh\
    \ cryptographically protected message on an IKE_SA\n   or any of its CHILD_SAs\
    \ ensures liveness of the IKE_SA and all of its\n   CHILD_SAs.  Note that this\
    \ places requirements on the failure modes\n   of an IKE endpoint.  An implementation\
    \ MUST NOT continue sending on\n   any SA if some failure prevents it from receiving\
    \ on all of the\n   associated SAs.  If CHILD_SAs can fail independently from\
    \ one another\n   without the associated IKE_SA being able to send a delete message,\n\
    \   then they MUST be negotiated by separate IKE_SAs.\n   There is a Denial of\
    \ Service attack on the initiator of an IKE_SA\n   that can be avoided if the\
    \ initiator takes the proper care.  Since\n   the first two messages of an SA\
    \ setup are not cryptographically\n   protected, an attacker could respond to\
    \ the initiator's message\n   before the genuine responder and poison the connection\
    \ setup attempt.\n   To prevent this, the initiator MAY be willing to accept multiple\n\
    \   responses to its first message, treat each as potentially legitimate,\n  \
    \ respond to it, and then discard all the invalid half-open connections\n   when\
    \ it receives a valid cryptographically protected response to any\n   one of its\
    \ requests.  Once a cryptographically valid response is\n   received, all subsequent\
    \ responses should be ignored whether or not\n   they are cryptographically valid.\n\
    \   Note that with these rules, there is no reason to negotiate and agree\n  \
    \ upon an SA lifetime.  If IKE presumes the partner is dead, based on\n   repeated\
    \ lack of acknowledgement to an IKE message, then the IKE SA\n   and all CHILD_SAs\
    \ set up through that IKE_SA are deleted.\n   An IKE endpoint may at any time\
    \ delete inactive CHILD_SAs to recover\n   resources used to hold their state.\
    \  If an IKE endpoint chooses to\n   delete CHILD_SAs, it MUST send Delete payloads\
    \ to the other end\n   notifying it of the deletion.  It MAY similarly time out\
    \ the IKE_SA.\n   Closing the IKE_SA implicitly closes all associated CHILD_SAs.\
    \  In\n   this case, an IKE endpoint SHOULD send a Delete payload indicating\n\
    \   that it has closed the IKE_SA.\n"
- title: 2.5.  Version Numbers and Forward Compatibility
  contents:
  - "2.5.  Version Numbers and Forward Compatibility\n   This document describes version\
    \ 2.0 of IKE, meaning the major version\n   number is 2 and the minor version\
    \ number is zero.  It is likely that\n   some implementations will want to support\
    \ both version 1.0 and\n   version 2.0, and in the future, other versions.\n \
    \  The major version number should be incremented only if the packet\n   formats\
    \ or required actions have changed so dramatically that an\n   older version node\
    \ would not be able to interoperate with a newer\n   version node if it simply\
    \ ignored the fields it did not understand\n   and took the actions specified\
    \ in the older specification.  The minor\n   version number indicates new capabilities,\
    \ and MUST be ignored by a\n   node with a smaller minor version number, but used\
    \ for informational\n   purposes by the node with the larger minor version number.\
    \  For\n   example, it might indicate the ability to process a newly defined\n\
    \   notification message.  The node with the larger minor version number\n   would\
    \ simply note that its correspondent would not be able to\n   understand that\
    \ message and therefore would not send it.\n   If an endpoint receives a message\
    \ with a higher major version number,\n   it MUST drop the message and SHOULD\
    \ send an unauthenticated\n   notification message containing the highest version\
    \ number it\n   supports.  If an endpoint supports major version n, and major\
    \ version\n   m, it MUST support all versions between n and m.  If it receives\
    \ a\n   message with a major version that it supports, it MUST respond with\n\
    \   that version number.  In order to prevent two nodes from being\n   tricked\
    \ into corresponding with a lower major version number than the\n   maximum that\
    \ they both support, IKE has a flag that indicates that\n   the node is capable\
    \ of speaking a higher major version number.\n   Thus, the major version number\
    \ in the IKE header indicates the\n   version number of the message, not the highest\
    \ version number that\n   the transmitter supports.  If the initiator is capable\
    \ of speaking\n   versions n, n+1, and n+2, and the responder is capable of speaking\n\
    \   versions n and n+1, then they will negotiate speaking n+1, where the\n   initiator\
    \ will set the flag indicating its ability to speak a higher\n   version.  If\
    \ they mistakenly (perhaps through an active attacker\n   sending error messages)\
    \ negotiate to version n, then both will notice\n   that the other side can support\
    \ a higher version number, and they\n   MUST break the connection and reconnect\
    \ using version n+1.\n   Note that IKEv1 does not follow these rules, because\
    \ there is no way\n   in v1 of noting that you are capable of speaking a higher\
    \ version\n   number.  So an active attacker can trick two v2-capable nodes into\n\
    \   speaking v1.  When a v2-capable node negotiates down to v1, it SHOULD\n  \
    \ note that fact in its logs.\n   Also for forward compatibility, all fields marked\
    \ RESERVED MUST be\n   set to zero by a version 2.0 implementation and their content\
    \ MUST be\n   ignored by a version 2.0 implementation (\"Be conservative in what\
    \ you\n   send and liberal in what you receive\").  In this way, future versions\n\
    \   of the protocol can use those fields in a way that is guaranteed to\n   be\
    \ ignored by implementations that do not understand them.\n   Similarly, payload\
    \ types that are not defined are reserved for future\n   use; implementations\
    \ of version 2.0 MUST skip over those payloads and\n   ignore their contents.\n\
    \   IKEv2 adds a \"critical\" flag to each payload header for further\n   flexibility\
    \ for forward compatibility.  If the critical flag is set\n   and the payload\
    \ type is unrecognized, the message MUST be rejected\n   and the response to the\
    \ IKE request containing that payload MUST\n   include a Notify payload UNSUPPORTED_CRITICAL_PAYLOAD,\
    \ indicating an\n   unsupported critical payload was included.  If the critical\
    \ flag is\n   not set and the payload type is unsupported, that payload MUST be\n\
    \   ignored.\n   Although new payload types may be added in the future and may\
    \ appear\n   interleaved with the fields defined in this specification,\n   implementations\
    \ MUST send the payloads defined in this specification\n   in the order shown\
    \ in the figures in section 2 and implementations\n   SHOULD reject as invalid\
    \ a message with those payloads in any other\n   order.\n"
- title: 2.6.  Cookies
  contents:
  - "2.6.  Cookies\n   The term \"cookies\" originates with Karn and Simpson [RFC2522]\
    \ in\n   Photuris, an early proposal for key management with IPsec, and it has\n\
    \   persisted.  The Internet Security Association and Key Management\n   Protocol\
    \ (ISAKMP) [MSST98] fixed message header includes two eight-\n   octet fields\
    \ titled \"cookies\", and that syntax is used by both IKEv1\n   and IKEv2 though\
    \ in IKEv2 they are referred to as the IKE SPI and\n   there is a new separate\
    \ field in a Notify payload holding the cookie.\n   The initial two eight-octet\
    \ fields in the header are used as a\n   connection identifier at the beginning\
    \ of IKE packets.  Each endpoint\n   chooses one of the two SPIs and SHOULD choose\
    \ them so as to be unique\n   identifiers of an IKE_SA.  An SPI value of zero\
    \ is special and\n   indicates that the remote SPI value is not yet known by the\
    \ sender.\n   Unlike ESP and AH where only the recipient's SPI appears in the\n\
    \   header of a message, in IKE the sender's SPI is also sent in every\n   message.\
    \  Since the SPI chosen by the original initiator of the\n   IKE_SA is always\
    \ sent first, an endpoint with multiple IKE_SAs open\n   that wants to find the\
    \ appropriate IKE_SA using the SPI it assigned\n   must look at the I(nitiator)\
    \ Flag bit in the header to determine\n   whether it assigned the first or the\
    \ second eight octets.\n   In the first message of an initial IKE exchange, the\
    \ initiator will\n   not know the responder's SPI value and will therefore set\
    \ that field\n   to zero.\n   An expected attack against IKE is state and CPU\
    \ exhaustion, where the\n   target is flooded with session initiation requests\
    \ from forged IP\n   addresses.  This attack can be made less effective if an\n\
    \   implementation of a responder uses minimal CPU and commits no state\n   to\
    \ an SA until it knows the initiator can receive packets at the\n   address from\
    \ which it claims to be sending them.  To accomplish this,\n   a responder SHOULD\
    \ -- when it detects a large number of half-open\n   IKE_SAs -- reject initial\
    \ IKE messages unless they contain a Notify\n   payload of type COOKIE.  It SHOULD\
    \ instead send an unprotected IKE\n   message as a response and include COOKIE\
    \ Notify payload with the\n   cookie data to be returned.  Initiators who receive\
    \ such responses\n   MUST retry the IKE_SA_INIT with a Notify payload of type\
    \ COOKIE\n   containing the responder supplied cookie data as the first payload\n\
    \   and all other payloads unchanged.  The initial exchange will then be\n   as\
    \ follows:\n       Initiator                          Responder\n       -----------\
    \                        -----------\n       HDR(A,0), SAi1, KEi, Ni   -->\n \
    \                                <-- HDR(A,0), N(COOKIE)\n       HDR(A,0), N(COOKIE),\
    \ SAi1, KEi, Ni   -->\n                                 <-- HDR(A,B), SAr1, KEr,\
    \ Nr, [CERTREQ]\n       HDR(A,B), SK {IDi, [CERT,] [CERTREQ,] [IDr,]\n       \
    \    AUTH, SAi2, TSi, TSr} -->\n                                 <-- HDR(A,B),\
    \ SK {IDr, [CERT,] AUTH,\n                                                SAr2,\
    \ TSi, TSr}\n   The first two messages do not affect any initiator or responder\
    \ state\n   except for communicating the cookie.  In particular, the message\n\
    \   sequence numbers in the first four messages will all be zero and the\n   message\
    \ sequence numbers in the last two messages will be one. 'A' is\n   the SPI assigned\
    \ by the initiator, while 'B' is the SPI assigned by\n   the responder.\n   An\
    \ IKE implementation SHOULD implement its responder cookie\n   generation in such\
    \ a way as to not require any saved state to\n   recognize its valid cookie when\
    \ the second IKE_SA_INIT message\n   arrives.  The exact algorithms and syntax\
    \ they use to generate\n   cookies do not affect interoperability and hence are\
    \ not specified\n   here.  The following is an example of how an endpoint could\
    \ use\n   cookies to implement limited DOS protection.\n   A good way to do this\
    \ is to set the responder cookie to be:\n      Cookie = <VersionIDofSecret> |\
    \ Hash(Ni | IPi | SPIi | <secret>)\n   where <secret> is a randomly generated\
    \ secret known only to the\n   responder and periodically changed and | indicates\
    \ concatenation.\n   <VersionIDofSecret> should be changed whenever <secret> is\n\
    \   regenerated.  The cookie can be recomputed when the IKE_SA_INIT\n   arrives\
    \ the second time and compared to the cookie in the received\n   message.  If\
    \ it matches, the responder knows that the cookie was\n   generated since the\
    \ last change to <secret> and that IPi must be the\n   same as the source address\
    \ it saw the first time.  Incorporating SPIi\n   into the calculation ensures\
    \ that if multiple IKE_SAs are being set\n   up in parallel they will all get\
    \ different cookies (assuming the\n   initiator chooses unique SPIi's).  Incorporating\
    \ Ni into the hash\n   ensures that an attacker who sees only message 2 can't\
    \ successfully\n   forge a message 3.\n   If a new value for <secret> is chosen\
    \ while there are connections in\n   the process of being initialized, an IKE_SA_INIT\
    \ might be returned\n   with other than the current <VersionIDofSecret>.  The\
    \ responder in\n   that case MAY reject the message by sending another response\
    \ with a\n   new cookie or it MAY keep the old value of <secret> around for a\n\
    \   short time and accept cookies computed from either one.  The\n   responder\
    \ SHOULD NOT accept cookies indefinitely after <secret> is\n   changed, since\
    \ that would defeat part of the denial of service\n   protection.  The responder\
    \ SHOULD change the value of <secret>\n   frequently, especially if under attack.\n"
- title: 2.7.  Cryptographic Algorithm Negotiation
  contents:
  - "2.7.  Cryptographic Algorithm Negotiation\n   The payload type known as \"SA\"\
    \ indicates a proposal for a set of\n   choices of IPsec protocols (IKE, ESP,\
    \ and/or AH) for the SA as well\n   as cryptographic algorithms associated with\
    \ each protocol.\n   An SA payload consists of one or more proposals.  Each proposal\n\
    \   includes one or more protocols (usually one).  Each protocol contains\n  \
    \ one or more transforms -- each specifying a cryptographic algorithm.\n   Each\
    \ transform contains zero or more attributes (attributes are\n   needed only if\
    \ the transform identifier does not completely specify\n   the cryptographic algorithm).\n\
    \   This hierarchical structure was designed to efficiently encode\n   proposals\
    \ for cryptographic suites when the number of supported\n   suites is large because\
    \ multiple values are acceptable for multiple\n   transforms.  The responder MUST\
    \ choose a single suite, which MAY be\n   any subset of the SA proposal following\
    \ the rules below:\n      Each proposal contains one or more protocols.  If a\
    \ proposal is\n      accepted, the SA response MUST contain the same protocols\
    \ in the\n      same order as the proposal.  The responder MUST accept a single\n\
    \      proposal or reject them all and return an error. (Example: if a\n     \
    \ single proposal contains ESP and AH and that proposal is accepted,\n      both\
    \ ESP and AH MUST be accepted.  If ESP and AH are included in\n      separate\
    \ proposals, the responder MUST accept only one of them).\n      Each IPsec protocol\
    \ proposal contains one or more transforms.\n      Each transform contains a transform\
    \ type.  The accepted\n      cryptographic suite MUST contain exactly one transform\
    \ of each\n      type included in the proposal.  For example: if an ESP proposal\n\
    \      includes transforms ENCR_3DES, ENCR_AES w/keysize 128, ENCR_AES\n     \
    \ w/keysize 256, AUTH_HMAC_MD5, and AUTH_HMAC_SHA, the accepted\n      suite MUST\
    \ contain one of the ENCR_ transforms and one of the\n      AUTH_ transforms.\
    \  Thus, six combinations are acceptable.\n   Since the initiator sends its Diffie-Hellman\
    \ value in the\n   IKE_SA_INIT, it must guess the Diffie-Hellman group that the\n\
    \   responder will select from its list of supported groups.  If the\n   initiator\
    \ guesses wrong, the responder will respond with a Notify\n   payload of type\
    \ INVALID_KE_PAYLOAD indicating the selected group.  In\n   this case, the initiator\
    \ MUST retry the IKE_SA_INIT with the\n   corrected Diffie-Hellman group.  The\
    \ initiator MUST again propose its\n   full set of acceptable cryptographic suites\
    \ because the rejection\n   message was unauthenticated and otherwise an active\
    \ attacker could\n   trick the endpoints into negotiating a weaker suite than\
    \ a stronger\n   one that they both prefer.\n"
- title: 2.8.  Rekeying
  contents:
  - "2.8.  Rekeying\n   IKE, ESP, and AH security associations use secret keys that\
    \ SHOULD be\n   used only for a limited amount of time and to protect a limited\n\
    \   amount of data.  This limits the lifetime of the entire security\n   association.\
    \  When the lifetime of a security association expires,\n   the security association\
    \ MUST NOT be used.  If there is demand, new\n   security associations MAY be\
    \ established.  Reestablishment of\n   security associations to take the place\
    \ of ones that expire is\n   referred to as \"rekeying\".\n   To allow for minimal\
    \ IPsec implementations, the ability to rekey SAs\n   without restarting the entire\
    \ IKE_SA is optional.  An implementation\n   MAY refuse all CREATE_CHILD_SA requests\
    \ within an IKE_SA.  If an SA\n   has expired or is about to expire and rekeying\
    \ attempts using the\n   mechanisms described here fail, an implementation MUST\
    \ close the\n   IKE_SA and any associated CHILD_SAs and then MAY start new ones.\n\
    \   Implementations SHOULD support in-place rekeying of SAs, since doing\n   so\
    \ offers better performance and is likely to reduce the number of\n   packets\
    \ lost during the transition.\n   To rekey a CHILD_SA within an existing IKE_SA,\
    \ create a new,\n   equivalent SA (see section 2.17 below), and when the new one\
    \ is\n   established, delete the old one.  To rekey an IKE_SA, establish a new\n\
    \   equivalent IKE_SA (see section 2.18 below) with the peer to whom the\n   old\
    \ IKE_SA is shared using a CREATE_CHILD_SA within the existing\n   IKE_SA.  An\
    \ IKE_SA so created inherits all of the original IKE_SA's\n   CHILD_SAs.  Use\
    \ the new IKE_SA for all control messages needed to\n   maintain the CHILD_SAs\
    \ created by the old IKE_SA, and delete the old\n   IKE_SA.  The Delete payload\
    \ to delete itself MUST be the last request\n   sent over an IKE_SA.\n   SAs SHOULD\
    \ be rekeyed proactively, i.e., the new SA should be\n   established before the\
    \ old one expires and becomes unusable.  Enough\n   time should elapse between\
    \ the time the new SA is established and the\n   old one becomes unusable so that\
    \ traffic can be switched over to the\n   new SA.\n   A difference between IKEv1\
    \ and IKEv2 is that in IKEv1 SA lifetimes\n   were negotiated.  In IKEv2, each\
    \ end of the SA is responsible for\n   enforcing its own lifetime policy on the\
    \ SA and rekeying the SA when\n   necessary.  If the two ends have different lifetime\
    \ policies, the end\n   with the shorter lifetime will end up always being the\
    \ one to request\n   the rekeying.  If an SA bundle has been inactive for a long\
    \ time and\n   if an endpoint would not initiate the SA in the absence of traffic,\n\
    \   the endpoint MAY choose to close the SA instead of rekeying it when\n   its\
    \ lifetime expires.  It SHOULD do so if there has been no traffic\n   since the\
    \ last time the SA was rekeyed.\n   If the two ends have the same lifetime policies,\
    \ it is possible that\n   both will initiate a rekeying at the same time (which\
    \ will result in\n   redundant SAs).  To reduce the probability of this happening,\
    \ the\n   timing of rekeying requests SHOULD be jittered (delayed by a random\n\
    \   amount of time after the need for rekeying is noticed).\n   This form of rekeying\
    \ may temporarily result in multiple similar SAs\n   between the same pairs of\
    \ nodes.  When there are two SAs eligible to\n   receive packets, a node MUST\
    \ accept incoming packets through either\n   SA.  If redundant SAs are created\
    \ though such a collision, the SA\n   created with the lowest of the four nonces\
    \ used in the two exchanges\n   SHOULD be closed by the endpoint that created\
    \ it.\n   Note that IKEv2 deliberately allows parallel SAs with the same\n   traffic\
    \ selectors between common endpoints.  One of the purposes of\n   this is to support\
    \ traffic quality of service (QoS) differences among\n   the SAs (see [RFC2474],\
    \ [RFC2475], and section 4.1 of [RFC2983]).\n   Hence unlike IKEv1, the combination\
    \ of the endpoints and the traffic\n   selectors may not uniquely identify an\
    \ SA between those endpoints, so\n   the IKEv1 rekeying heuristic of deleting\
    \ SAs on the basis of\n   duplicate traffic selectors SHOULD NOT be used.\n  \
    \ The node that initiated the surviving rekeyed SA SHOULD delete the\n   replaced\
    \ SA after the new one is established.\n   There are timing windows -- particularly\
    \ in the presence of lost\n   packets -- where endpoints may not agree on the\
    \ state of an SA.  The\n   responder to a CREATE_CHILD_SA MUST be prepared to\
    \ accept messages on\n   an SA before sending its response to the creation request,\
    \ so there\n   is no ambiguity for the initiator.  The initiator MAY begin sending\n\
    \   on an SA as soon as it processes the response.  The initiator,\n   however,\
    \ cannot receive on a newly created SA until it receives and\n   processes the\
    \ response to its CREATE_CHILD_SA request.  How, then, is\n   the responder to\
    \ know when it is OK to send on the newly created SA?\n   From a technical correctness\
    \ and interoperability perspective, the\n   responder MAY begin sending on an\
    \ SA as soon as it sends its response\n   to the CREATE_CHILD_SA request.  In\
    \ some situations, however, this\n   could result in packets unnecessarily being\
    \ dropped, so an\n   implementation MAY want to defer such sending.\n   The responder\
    \ can be assured that the initiator is prepared to\n   receive messages on an\
    \ SA if either (1) it has received a\n   cryptographically valid message on the\
    \ new SA, or (2) the new SA\n   rekeys an existing SA and it receives an IKE request\
    \ to close the\n   replaced SA.  When rekeying an SA, the responder SHOULD continue\
    \ to\n   send messages on the old SA until one of those events occurs.  When\n\
    \   establishing a new SA, the responder MAY defer sending messages on a\n   new\
    \ SA until either it receives one or a timeout has occurred.  If an\n   initiator\
    \ receives a message on an SA for which it has not received a\n   response to\
    \ its CREATE_CHILD_SA request, it SHOULD interpret that as\n   a likely packet\
    \ loss and retransmit the CREATE_CHILD_SA request.  An\n   initiator MAY send\
    \ a dummy message on a newly created SA if it has no\n   messages queued in order\
    \ to assure the responder that the initiator\n   is ready to receive messages.\n"
- title: 2.9.  Traffic Selector Negotiation
  contents:
  - "2.9.  Traffic Selector Negotiation\n   When an IP packet is received by an RFC4301-compliant\
    \ IPsec subsystem\n   and matches a \"protect\" selector in its Security Policy\
    \ Database\n   (SPD), the subsystem MUST protect that packet with IPsec.  When\
    \ no SA\n   exists yet, it is the task of IKE to create it.  Maintenance of a\n\
    \   system's SPD is outside the scope of IKE (see [PFKEY] for an example\n   protocol),\
    \ though some implementations might update their SPD in\n   connection with the\
    \ running of IKE (for an example scenario, see\n   section 1.1.3).\n   Traffic\
    \ Selector (TS) payloads allow endpoints to communicate some of\n   the information\
    \ from their SPD to their peers.  TS payloads specify\n   the selection criteria\
    \ for packets that will be forwarded over the\n   newly set up SA.  This can serve\
    \ as a consistency check in some\n   scenarios to assure that the SPDs are consistent.\
    \  In others, it\n   guides the dynamic update of the SPD.\n   Two TS payloads\
    \ appear in each of the messages in the exchange that\n   creates a CHILD_SA pair.\
    \  Each TS payload contains one or more\n   Traffic Selectors.  Each Traffic Selector\
    \ consists of an address\n   range (IPv4 or IPv6), a port range, and an IP protocol\
    \ ID.  In\n   support of the scenario described in section 1.1.3, an initiator\
    \ may\n   request that the responder assign an IP address and tell the\n   initiator\
    \ what it is.\n   IKEv2 allows the responder to choose a subset of the traffic\
    \ proposed\n   by the initiator.  This could happen when the configurations of\
    \ the\n   two endpoints are being updated but only one end has received the new\n\
    \   information.  Since the two endpoints may be configured by different\n   people,\
    \ the incompatibility may persist for an extended period even\n   in the absence\
    \ of errors.  It also allows for intentionally different\n   configurations, as\
    \ when one end is configured to tunnel all addresses\n   and depends on the other\
    \ end to have the up-to-date list.\n   The first of the two TS payloads is known\
    \ as TSi (Traffic Selector-\n   initiator).  The second is known as TSr (Traffic\
    \ Selector-responder).\n   TSi specifies the source address of traffic forwarded\
    \ from (or the\n   destination address of traffic forwarded to) the initiator\
    \ of the\n   CHILD_SA pair.  TSr specifies the destination address of the traffic\n\
    \   forwarded to (or the source address of the traffic forwarded from)\n   the\
    \ responder of the CHILD_SA pair.  For example, if the original\n   initiator\
    \ request the creation of a CHILD_SA pair, and wishes to\n   tunnel all traffic\
    \ from subnet 192.0.1.* on the initiator's side to\n   subnet 192.0.2.* on the\
    \ responder's side, the initiator would include\n   a single traffic selector\
    \ in each TS payload.  TSi would specify the\n   address range (192.0.1.0 - 192.0.1.255)\
    \ and TSr would specify the\n   address range (192.0.2.0 - 192.0.2.255).  Assuming\
    \ that proposal was\n   acceptable to the responder, it would send identical TS\
    \ payloads\n   back.  (Note: The IP address range 192.0.2.* has been reserved\
    \ for\n   use in examples in RFCs and similar documents.  This document needed\n\
    \   two such ranges, and so also used 192.0.1.*. This should not be\n   confused\
    \ with any actual address.)\n   The responder is allowed to narrow the choices\
    \ by selecting a subset\n   of the traffic, for instance by eliminating or narrowing\
    \ the range of\n   one or more members of the set of traffic selectors, provided\
    \ the set\n   does not become the NULL set.\n   It is possible for the responder's\
    \ policy to contain multiple smaller\n   ranges, all encompassed by the initiator's\
    \ traffic selector, and with\n   the responder's policy being that each of those\
    \ ranges should be sent\n   over a different SA.  Continuing the example above,\
    \ the responder\n   might have a policy of being willing to tunnel those addresses\
    \ to and\n   from the initiator, but might require that each address pair be on\
    \ a\n   separately negotiated CHILD_SA.  If the initiator generated its\n   request\
    \ in response to an incoming packet from 192.0.1.43 to\n   192.0.2.123, there\
    \ would be no way for the responder to determine\n   which pair of addresses should\
    \ be included in this tunnel, and it\n   would have to make a guess or reject\
    \ the request with a status of\n   SINGLE_PAIR_REQUIRED.\n   To enable the responder\
    \ to choose the appropriate range in this case,\n   if the initiator has requested\
    \ the SA due to a data packet, the\n   initiator SHOULD include as the first traffic\
    \ selector in each of TSi\n   and TSr a very specific traffic selector including\
    \ the addresses in\n   the packet triggering the request.  In the example, the\
    \ initiator\n   would include in TSi two traffic selectors: the first containing\
    \ the\n   address range (192.0.1.43 - 192.0.1.43) and the source port and IP\n\
    \   protocol from the packet and the second containing (192.0.1.0 -\n   192.0.1.255)\
    \ with all ports and IP protocols.  The initiator would\n   similarly include\
    \ two traffic selectors in TSr.\n   If the responder's policy does not allow it\
    \ to accept the entire set\n   of traffic selectors in the initiator's request,\
    \ but does allow him\n   to accept the first selector of TSi and TSr, then the\
    \ responder MUST\n   narrow the traffic selectors to a subset that includes the\n\
    \   initiator's first choices.  In this example, the responder might\n   respond\
    \ with TSi being (192.0.1.43 - 192.0.1.43) with all ports and\n   IP protocols.\n\
    \   If the initiator creates the CHILD_SA pair not in response to an\n   arriving\
    \ packet, but rather, say, upon startup, then there may be no\n   specific addresses\
    \ the initiator prefers for the initial tunnel over\n   any other.  In that case,\
    \ the first values in TSi and TSr MAY be\n   ranges rather than specific values,\
    \ and the responder chooses a\n   subset of the initiator's TSi and TSr that are\
    \ acceptable.  If more\n   than one subset is acceptable but their union is not,\
    \ the responder\n   MUST accept some subset and MAY include a Notify payload of\
    \ type\n   ADDITIONAL_TS_POSSIBLE to indicate that the initiator might want to\n\
    \   try again.  This case will occur only when the initiator and\n   responder\
    \ are configured differently from one another.  If the\n   initiator and responder\
    \ agree on the granularity of tunnels, the\n   initiator will never request a\
    \ tunnel wider than the responder will\n   accept.  Such misconfigurations SHOULD\
    \ be recorded in error logs.\n"
- title: 2.10.  Nonces
  contents:
  - "2.10.  Nonces\n   The IKE_SA_INIT messages each contain a nonce.  These nonces\
    \ are used\n   as inputs to cryptographic functions.  The CREATE_CHILD_SA request\n\
    \   and the CREATE_CHILD_SA response also contain nonces.  These nonces\n   are\
    \ used to add freshness to the key derivation technique used to\n   obtain keys\
    \ for CHILD_SA, and to ensure creation of strong pseudo-\n   random bits from\
    \ the Diffie-Hellman key.  Nonces used in IKEv2 MUST\n   be randomly chosen, MUST\
    \ be at least 128 bits in size, and MUST be at\n   least half the key size of\
    \ the negotiated prf. (\"prf\" refers to\n   \"pseudo-random function\", one of\
    \ the cryptographic algorithms\n   negotiated in the IKE exchange.)  If the same\
    \ random number source is\n   used for both keys and nonces, care must be taken\
    \ to ensure that the\n   latter use does not compromise the former.\n"
- title: 2.11.  Address and Port Agility
  contents:
  - "2.11.  Address and Port Agility\n   IKE runs over UDP ports 500 and 4500, and\
    \ implicitly sets up ESP and\n   AH associations for the same IP addresses it\
    \ runs over.  The IP\n   addresses and ports in the outer header are, however,\
    \ not themselves\n   cryptographically protected, and IKE is designed to work\
    \ even through\n   Network Address Translation (NAT) boxes.  An implementation\
    \ MUST\n   accept incoming requests even if the source port is not 500 or 4500,\n\
    \   and MUST respond to the address and port from which the request was\n   received.\
    \  It MUST specify the address and port at which the request\n   was received\
    \ as the source address and port in the response.  IKE\n   functions identically\
    \ over IPv4 or IPv6.\n"
- title: 2.12.  Reuse of Diffie-Hellman Exponentials
  contents:
  - "2.12.  Reuse of Diffie-Hellman Exponentials\n   IKE generates keying material\
    \ using an ephemeral Diffie-Hellman\n   exchange in order to gain the property\
    \ of \"perfect forward secrecy\".\n   This means that once a connection is closed\
    \ and its corresponding\n   keys are forgotten, even someone who has recorded\
    \ all of the data\n   from the connection and gets access to all of the long-term\
    \ keys of\n   the two endpoints cannot reconstruct the keys used to protect the\n\
    \   conversation without doing a brute force search of the session key\n   space.\n\
    \   Achieving perfect forward secrecy requires that when a connection is\n   closed,\
    \ each endpoint MUST forget not only the keys used by the\n   connection but also\
    \ any information that could be used to recompute\n   those keys.  In particular,\
    \ it MUST forget the secrets used in the\n   Diffie-Hellman calculation and any\
    \ state that may persist in the\n   state of a pseudo-random number generator\
    \ that could be used to\n   recompute the Diffie-Hellman secrets.\n   Since the\
    \ computing of Diffie-Hellman exponentials is computationally\n   expensive, an\
    \ endpoint may find it advantageous to reuse those\n   exponentials for multiple\
    \ connection setups.  There are several\n   reasonable strategies for doing this.\
    \  An endpoint could choose a new\n   exponential only periodically though this\
    \ could result in less-than-\n   perfect forward secrecy if some connection lasts\
    \ for less than the\n   lifetime of the exponential.  Or it could keep track of\
    \ which\n   exponential was used for each connection and delete the information\n\
    \   associated with the exponential only when some corresponding\n   connection\
    \ was closed.  This would allow the exponential to be reused\n   without losing\
    \ perfect forward secrecy at the cost of maintaining\n   more state.\n   Decisions\
    \ as to whether and when to reuse Diffie-Hellman exponentials\n   is a private\
    \ decision in the sense that it will not affect\n   interoperability.  An implementation\
    \ that reuses exponentials MAY\n   choose to remember the exponential used by\
    \ the other endpoint on past\n   exchanges and if one is reused to avoid the second\
    \ half of the\n   calculation.\n"
- title: 2.13.  Generating Keying Material
  contents:
  - "2.13.  Generating Keying Material\n   In the context of the IKE_SA, four cryptographic\
    \ algorithms are\n   negotiated: an encryption algorithm, an integrity protection\n\
    \   algorithm, a Diffie-Hellman group, and a pseudo-random function\n   (prf).\
    \  The pseudo-random function is used for the construction of\n   keying material\
    \ for all of the cryptographic algorithms used in both\n   the IKE_SA and the\
    \ CHILD_SAs.\n   We assume that each encryption algorithm and integrity protection\n\
    \   algorithm uses a fixed-size key and that any randomly chosen value of\n  \
    \ that fixed size can serve as an appropriate key.  For algorithms that\n   accept\
    \ a variable length key, a fixed key size MUST be specified as\n   part of the\
    \ cryptographic transform negotiated.  For algorithms for\n   which not all values\
    \ are valid keys (such as DES or 3DES with key\n   parity), the algorithm by which\
    \ keys are derived from arbitrary\n   values MUST be specified by the cryptographic\
    \ transform.  For\n   integrity protection functions based on Hashed Message Authentication\n\
    \   Code (HMAC), the fixed key size is the size of the output of the\n   underlying\
    \ hash function.  When the prf function takes a variable\n   length key, variable\
    \ length data, and produces a fixed-length output\n   (e.g., when using HMAC),\
    \ the formulas in this document apply.  When\n   the key for the prf function\
    \ has fixed length, the data provided as a\n   key is truncated or padded with\
    \ zeros as necessary unless exceptional\n   processing is explained following\
    \ the formula.\n   Keying material will always be derived as the output of the\n\
    \   negotiated prf algorithm.  Since the amount of keying material needed\n  \
    \ may be greater than the size of the output of the prf algorithm, we\n   will\
    \ use the prf iteratively.  We will use the terminology prf+ to\n   describe the\
    \ function that outputs a pseudo-random stream based on\n   the inputs to a prf\
    \ as follows: (where | indicates concatenation)\n   prf+ (K,S) = T1 | T2 | T3\
    \ | T4 | ...\n   where:\n   T1 = prf (K, S | 0x01)\n   T2 = prf (K, T1 | S | 0x02)\n\
    \   T3 = prf (K, T2 | S | 0x03)\n   T4 = prf (K, T3 | S | 0x04)\n   continuing\
    \ as needed to compute all required keys.  The keys are\n   taken from the output\
    \ string without regard to boundaries (e.g., if\n   the required keys are a 256-bit\
    \ Advanced Encryption Standard (AES)\n   key and a 160-bit HMAC key, and the prf\
    \ function generates 160 bits,\n   the AES key will come from T1 and the beginning\
    \ of T2, while the HMAC\n   key will come from the rest of T2 and the beginning\
    \ of T3).\n   The constant concatenated to the end of each string feeding the\
    \ prf\n   is a single octet. prf+ in this document is not defined beyond 255\n\
    \   times the size of the prf output.\n"
- title: 2.14.  Generating Keying Material for the IKE_SA
  contents:
  - "2.14.  Generating Keying Material for the IKE_SA\n   The shared keys are computed\
    \ as follows.  A quantity called SKEYSEED\n   is calculated from the nonces exchanged\
    \ during the IKE_SA_INIT\n   exchange and the Diffie-Hellman shared secret established\
    \ during that\n   exchange.  SKEYSEED is used to calculate seven other secrets:\
    \ SK_d\n   used for deriving new keys for the CHILD_SAs established with this\n\
    \   IKE_SA; SK_ai and SK_ar used as a key to the integrity protection\n   algorithm\
    \ for authenticating the component messages of subsequent\n   exchanges; SK_ei\
    \ and SK_er used for encrypting (and of course\n   decrypting) all subsequent\
    \ exchanges; and SK_pi and SK_pr, which are\n   used when generating an AUTH payload.\n\
    \   SKEYSEED and its derivatives are computed as follows:\n       SKEYSEED = prf(Ni\
    \ | Nr, g^ir)\n       {SK_d | SK_ai | SK_ar | SK_ei | SK_er | SK_pi | SK_pr }\
    \ = prf+\n                 (SKEYSEED, Ni | Nr | SPIi | SPIr )\n   (indicating\
    \ that the quantities SK_d, SK_ai, SK_ar, SK_ei, SK_er,\n   SK_pi, and SK_pr are\
    \ taken in order from the generated bits of the\n   prf+).  g^ir is the shared\
    \ secret from the ephemeral Diffie-Hellman\n   exchange.  g^ir is represented\
    \ as a string of octets in big endian\n   order padded with zeros if necessary\
    \ to make it the length of the\n   modulus.  Ni and Nr are the nonces, stripped\
    \ of any headers.  If the\n   negotiated prf takes a fixed-length key and the\
    \ lengths of Ni and Nr\n   do not add up to that length, half the bits must come\
    \ from Ni and\n   half from Nr, taking the first bits of each.\n   The two directions\
    \ of traffic flow use different keys.  The keys used\n   to protect messages from\
    \ the original initiator are SK_ai and SK_ei.\n   The keys used to protect messages\
    \ in the other direction are SK_ar\n   and SK_er.  Each algorithm takes a fixed\
    \ number of bits of keying\n   material, which is specified as part of the algorithm.\
    \  For integrity\n   algorithms based on a keyed hash, the key size is always\
    \ equal to the\n   length of the output of the underlying hash function.\n"
- title: 2.15.  Authentication of the IKE_SA
  contents:
  - "2.15.  Authentication of the IKE_SA\n   When not using extensible authentication\
    \ (see section 2.16), the\n   peers are authenticated by having each sign (or\
    \ MAC using a shared\n   secret as the key) a block of data.  For the responder,\
    \ the octets to\n   be signed start with the first octet of the first SPI in the\
    \ header\n   of the second message and end with the last octet of the last payload\n\
    \   in the second message.  Appended to this (for purposes of computing\n   the\
    \ signature) are the initiator's nonce Ni (just the value, not the\n   payload\
    \ containing it), and the value prf(SK_pr,IDr') where IDr' is\n   the responder's\
    \ ID payload excluding the fixed header.  Note that\n   neither the nonce Ni nor\
    \ the value prf(SK_pr,IDr') are transmitted.\n   Similarly, the initiator signs\
    \ the first message, starting with the\n   first octet of the first SPI in the\
    \ header and ending with the last\n   octet of the last payload.  Appended to\
    \ this (for purposes of\n   computing the signature) are the responder's nonce\
    \ Nr, and the value\n   prf(SK_pi,IDi').  In the above calculation, IDi' and IDr'\
    \ are the\n   entire ID payloads excluding the fixed header.  It is critical to\
    \ the\n   security of the exchange that each side sign the other side's nonce.\n\
    \   Note that all of the payloads are included under the signature,\n   including\
    \ any payload types not defined in this document.  If the\n   first message of\
    \ the exchange is sent twice (the second time with a\n   responder cookie and/or\
    \ a different Diffie-Hellman group), it is the\n   second version of the message\
    \ that is signed.\n   Optionally, messages 3 and 4 MAY include a certificate,\
    \ or\n   certificate chain providing evidence that the key used to compute a\n\
    \   digital signature belongs to the name in the ID payload.  The\n   signature\
    \ or MAC will be computed using algorithms dictated by the\n   type of key used\
    \ by the signer, and specified by the Auth Method\n   field in the Authentication\
    \ payload.  There is no requirement that\n   the initiator and responder sign\
    \ with the same cryptographic\n   algorithms.  The choice of cryptographic algorithms\
    \ depends on the\n   type of key each has.  In particular, the initiator may be\
    \ using a\n   shared key while the responder may have a public signature key and\n\
    \   certificate.  It will commonly be the case (but it is not required)\n   that\
    \ if a shared secret is used for authentication that the same key\n   is used\
    \ in both directions.  Note that it is a common but typically\n   insecure practice\
    \ to have a shared key derived solely from a user-\n   chosen password without\
    \ incorporating another source of randomness.\n   This is typically insecure because\
    \ user-chosen passwords are unlikely\n   to have sufficient unpredictability to\
    \ resist dictionary attacks and\n   these attacks are not prevented in this authentication\
    \ method.\n   (Applications using password-based authentication for bootstrapping\n\
    \   and IKE_SA should use the authentication method in section 2.16,\n   which\
    \ is designed to prevent off-line dictionary attacks.)  The pre-\n   shared key\
    \ SHOULD contain as much unpredictability as the strongest\n   key being negotiated.\
    \  In the case of a pre-shared key, the AUTH\n   value is computed as:\n     \
    \ AUTH = prf(prf(Shared Secret,\"Key Pad for IKEv2\"), <msg octets>)\n   where\
    \ the string \"Key Pad for IKEv2\" is 17 ASCII characters without\n   null termination.\
    \  The shared secret can be variable length.  The pad\n   string is added so that\
    \ if the shared secret is derived from a\n   password, the IKE implementation\
    \ need not store the password in\n   cleartext, but rather can store the value\
    \ prf(Shared Secret,\"Key Pad\n   for IKEv2\"), which could not be used as a password\
    \ equivalent for\n   protocols other than IKEv2.  As noted above, deriving the\
    \ shared\n   secret from a password is not secure.  This construction is used\n\
    \   because it is anticipated that people will do it anyway.  The\n   management\
    \ interface by which the Shared Secret is provided MUST\n   accept ASCII strings\
    \ of at least 64 octets and MUST NOT add a null\n   terminator before using them\
    \ as shared secrets.  It MUST also accept\n   a HEX encoding of the Shared Secret.\
    \  The management interface MAY\n   accept other encodings if the algorithm for\
    \ translating the encoding\n   to a binary string is specified.  If the negotiated\
    \ prf takes a\n   fixed-size key, the shared secret MUST be of that fixed size.\n"
- title: 2.16.  Extensible Authentication Protocol Methods
  contents:
  - "2.16.  Extensible Authentication Protocol Methods\n   In addition to authentication\
    \ using public key signatures and shared\n   secrets, IKE supports authentication\
    \ using methods defined in RFC\n   3748 [EAP].  Typically, these methods are asymmetric\
    \ (designed for a\n   user authenticating to a server), and they may not be mutual.\
    \  For\n   this reason, these protocols are typically used to authenticate the\n\
    \   initiator to the responder and MUST be used in conjunction with a\n   public\
    \ key signature based authentication of the responder to the\n   initiator.  These\
    \ methods are often associated with mechanisms\n   referred to as \"Legacy Authentication\"\
    \ mechanisms.\n   While this memo references [EAP] with the intent that new methods\
    \ can\n   be added in the future without updating this specification, some\n \
    \  simpler variations are documented here and in section 3.16.  [EAP]\n   defines\
    \ an authentication protocol requiring a variable number of\n   messages.  Extensible\
    \ Authentication is implemented in IKE as\n   additional IKE_AUTH exchanges that\
    \ MUST be completed in order to\n   initialize the IKE_SA.\n   An initiator indicates\
    \ a desire to use extensible authentication by\n   leaving out the AUTH payload\
    \ from message 3.  By including an IDi\n   payload but not an AUTH payload, the\
    \ initiator has declared an\n   identity but has not proven it.  If the responder\
    \ is willing to use\n   an extensible authentication method, it will place an\
    \ Extensible\n   Authentication Protocol (EAP) payload in message 4 and defer\
    \ sending\n   SAr2, TSi, and TSr until initiator authentication is complete in\
    \ a\n   subsequent IKE_AUTH exchange.  In the case of a minimal extensible\n \
    \  authentication, the initial SA establishment will appear as follows:\n    \
    \   Initiator                          Responder\n      -----------          \
    \              -----------\n       HDR, SAi1, KEi, Ni         -->\n          \
    \                        <--    HDR, SAr1, KEr, Nr, [CERTREQ]\n       HDR, SK\
    \ {IDi, [CERTREQ,] [IDr,]\n                SAi2, TSi, TSr}   -->\n           \
    \                       <--    HDR, SK {IDr, [CERT,] AUTH,\n                 \
    \                               EAP }\n       HDR, SK {EAP}              -->\n\
    \                                  <--    HDR, SK {EAP (success)}\n       HDR,\
    \ SK {AUTH}             -->\n                                  <--    HDR, SK\
    \ {AUTH, SAr2, TSi, TSr }\n   For EAP methods that create a shared key as a side\
    \ effect of\n   authentication, that shared key MUST be used by both the initiator\n\
    \   and responder to generate AUTH payloads in messages 7 and 8 using the\n  \
    \ syntax for shared secrets specified in section 2.15.  The shared key\n   from\
    \ EAP is the field from the EAP specification named MSK.  The\n   shared key generated\
    \ during an IKE exchange MUST NOT be used for any\n   other purpose.\n   EAP methods\
    \ that do not establish a shared key SHOULD NOT be used, as\n   they are subject\
    \ to a number of man-in-the-middle attacks [EAPMITM]\n   if these EAP methods\
    \ are used in other protocols that do not use a\n   server-authenticated tunnel.\
    \  Please see the Security Considerations\n   section for more details.  If EAP\
    \ methods that do not generate a\n   shared key are used, the AUTH payloads in\
    \ messages 7 and 8 MUST be\n   generated using SK_pi and SK_pr, respectively.\n\
    \   The initiator of an IKE_SA using EAP SHOULD be capable of extending\n   the\
    \ initial protocol exchange to at least ten IKE_AUTH exchanges in\n   the event\
    \ the responder sends notification messages and/or retries\n   the authentication\
    \ prompt.  Once the protocol exchange defined by the\n   chosen EAP authentication\
    \ method has successfully terminated, the\n   responder MUST send an EAP payload\
    \ containing the Success message.\n   Similarly, if the authentication method\
    \ has failed, the responder\n   MUST send an EAP payload containing the Failure\
    \ message.  The\n   responder MAY at any time terminate the IKE exchange by sending\
    \ an\n   EAP payload containing the Failure message.\n   Following such an extended\
    \ exchange, the EAP AUTH payloads MUST be\n   included in the two messages following\
    \ the one containing the EAP\n   Success message.\n"
- title: 2.17.  Generating Keying Material for CHILD_SAs
  contents:
  - "2.17.  Generating Keying Material for CHILD_SAs\n   A single CHILD_SA is created\
    \ by the IKE_AUTH exchange, and additional\n   CHILD_SAs can optionally be created\
    \ in CREATE_CHILD_SA exchanges.\n   Keying material for them is generated as follows:\n\
    \      KEYMAT = prf+(SK_d, Ni | Nr)\n   Where Ni and Nr are the nonces from the\
    \ IKE_SA_INIT exchange if this\n   request is the first CHILD_SA created or the\
    \ fresh Ni and Nr from the\n   CREATE_CHILD_SA exchange if this is a subsequent\
    \ creation.\n   For CREATE_CHILD_SA exchanges including an optional Diffie-Hellman\n\
    \   exchange, the keying material is defined as:\n      KEYMAT = prf+(SK_d, g^ir\
    \ (new) | Ni | Nr )\n   where g^ir (new) is the shared secret from the ephemeral\
    \ Diffie-\n   Hellman exchange of this CREATE_CHILD_SA exchange (represented as\
    \ an\n   octet string in big endian order padded with zeros in the high-order\n\
    \   bits if necessary to make it the length of the modulus).\n   A single CHILD_SA\
    \ negotiation may result in multiple security\n   associations.  ESP and AH SAs\
    \ exist in pairs (one in each direction),\n   and four SAs could be created in\
    \ a single CHILD_SA negotiation if a\n   combination of ESP and AH is being negotiated.\n\
    \   Keying material MUST be taken from the expanded KEYMAT in the\n   following\
    \ order:\n      All keys for SAs carrying data from the initiator to the responder\n\
    \      are taken before SAs going in the reverse direction.\n      If multiple\
    \ IPsec protocols are negotiated, keying material is\n      taken in the order\
    \ in which the protocol headers will appear in\n      the encapsulated packet.\n\
    \      If a single protocol has both encryption and authentication keys,\n   \
    \   the encryption key is taken from the first octets of KEYMAT and\n      the\
    \ authentication key is taken from the next octets.\n   Each cryptographic algorithm\
    \ takes a fixed number of bits of keying\n   material specified as part of the\
    \ algorithm.\n"
- title: 2.18.  Rekeying IKE_SAs Using a CREATE_CHILD_SA exchange
  contents:
  - "2.18.  Rekeying IKE_SAs Using a CREATE_CHILD_SA exchange\n   The CREATE_CHILD_SA\
    \ exchange can be used to rekey an existing IKE_SA\n   (see section 2.8).  New\
    \ initiator and responder SPIs are supplied in\n   the SPI fields.  The TS payloads\
    \ are omitted when rekeying an IKE_SA.\n   SKEYSEED for the new IKE_SA is computed\
    \ using SK_d from the existing\n   IKE_SA as follows:\n       SKEYSEED = prf(SK_d\
    \ (old), [g^ir (new)] | Ni | Nr)\n   where g^ir (new) is the shared secret from\
    \ the ephemeral Diffie-\n   Hellman exchange of this CREATE_CHILD_SA exchange\
    \ (represented as an\n   octet string in big endian order padded with zeros if\
    \ necessary to\n   make it the length of the modulus) and Ni and Nr are the two\
    \ nonces\n   stripped of any headers.\n   The new IKE_SA MUST reset its message\
    \ counters to 0.\n   SK_d, SK_ai, SK_ar, SK_ei, and SK_er are computed from SKEYSEED\
    \ as\n   specified in section 2.14.\n"
- title: 2.19.  Requesting an Internal Address on a Remote Network
  contents:
  - "2.19.  Requesting an Internal Address on a Remote Network\n   Most commonly occurring\
    \ in the endpoint-to-security-gateway scenario,\n   an endpoint may need an IP\
    \ address in the network protected by the\n   security gateway and may need to\
    \ have that address dynamically\n   assigned.  A request for such a temporary\
    \ address can be included in\n   any request to create a CHILD_SA (including the\
    \ implicit request in\n   message 3) by including a CP payload.\n   This function\
    \ provides address allocation to an IPsec Remote Access\n   Client (IRAC) trying\
    \ to tunnel into a network protected by an IPsec\n   Remote Access Server (IRAS).\
    \  Since the IKE_AUTH exchange creates an\n   IKE_SA and a CHILD_SA, the IRAC\
    \ MUST request the IRAS-controlled\n   address (and optionally other information\
    \ concerning the protected\n   network) in the IKE_AUTH exchange.  The IRAS may\
    \ procure an address\n   for the IRAC from any number of sources such as a DHCP/BOOTP\
    \ server\n   or its own address pool.\n       Initiator                      \
    \     Responder\n      -----------------------------       ---------------------------\n\
    \       HDR, SK {IDi, [CERT,] [CERTREQ,]\n        [IDr,] AUTH, CP(CFG_REQUEST),\n\
    \        SAi2, TSi, TSr}              -->\n                                  \
    \   <--   HDR, SK {IDr, [CERT,] AUTH,\n                                      \
    \      CP(CFG_REPLY), SAr2,\n                                            TSi,\
    \ TSr}\n   In all cases, the CP payload MUST be inserted before the SA payload.\n\
    \   In variations of the protocol where there are multiple IKE_AUTH\n   exchanges,\
    \ the CP payloads MUST be inserted in the messages\n   containing the SA payloads.\n\
    \   CP(CFG_REQUEST) MUST contain at least an INTERNAL_ADDRESS attribute\n   (either\
    \ IPv4 or IPv6) but MAY contain any number of additional\n   attributes the initiator\
    \ wants returned in the response.\n   For example, message from initiator to responder:\n\
    \      CP(CFG_REQUEST)=\n        INTERNAL_ADDRESS(0.0.0.0)\n        INTERNAL_NETMASK(0.0.0.0)\n\
    \        INTERNAL_DNS(0.0.0.0)\n      TSi = (0, 0-65535,0.0.0.0-255.255.255.255)\n\
    \      TSr = (0, 0-65535,0.0.0.0-255.255.255.255)\n   NOTE: Traffic Selectors\
    \ contain (protocol, port range, address\n   range).\n   Message from responder\
    \ to initiator:\n      CP(CFG_REPLY)=\n        INTERNAL_ADDRESS(192.0.2.202)\n\
    \        INTERNAL_NETMASK(255.255.255.0)\n        INTERNAL_SUBNET(192.0.2.0/255.255.255.0)\n\
    \      TSi = (0, 0-65535,192.0.2.202-192.0.2.202)\n      TSr = (0, 0-65535,192.0.2.0-192.0.2.255)\n\
    \   All returned values will be implementation dependent.  As can be seen\n  \
    \ in the above example, the IRAS MAY also send other attributes that\n   were\
    \ not included in CP(CFG_REQUEST) and MAY ignore the non-mandatory\n   attributes\
    \ that it does not support.\n   The responder MUST NOT send a CFG_REPLY without\
    \ having first received\n   a CP(CFG_REQUEST) from the initiator, because we do\
    \ not want the IRAS\n   to perform an unnecessary configuration lookup if the\
    \ IRAC cannot\n   process the REPLY.  In the case where the IRAS's configuration\n\
    \   requires that CP be used for a given identity IDi, but IRAC has\n   failed\
    \ to send a CP(CFG_REQUEST), IRAS MUST fail the request, and\n   terminate the\
    \ IKE exchange with a FAILED_CP_REQUIRED error.\n"
- title: 2.20.  Requesting the Peer's Version
  contents:
  - "2.20.  Requesting the Peer's Version\n   An IKE peer wishing to inquire about\
    \ the other peer's IKE software\n   version information MAY use the method below.\
    \  This is an example of\n   a configuration request within an INFORMATIONAL exchange,\
    \ after the\n   IKE_SA and first CHILD_SA have been created.\n   An IKE implementation\
    \ MAY decline to give out version information\n   prior to authentication or even\
    \ after authentication to prevent\n   trolling in case some implementation is\
    \ known to have some security\n   weakness.  In that case, it MUST either return\
    \ an empty string or no\n   CP payload if CP is not supported.\n       Initiator\
    \                           Responder\n      -----------------------------   \
    \    --------------------------\n      HDR, SK{CP(CFG_REQUEST)}      -->\n   \
    \                                 <--    HDR, SK{CP(CFG_REPLY)}\n      CP(CFG_REQUEST)=\n\
    \        APPLICATION_VERSION(\"\")\n      CP(CFG_REPLY) APPLICATION_VERSION(\"\
    foobar v1.3beta, (c) Foo Bar\n        Inc.\")\n"
- title: 2.21.  Error Handling
  contents:
  - "2.21.  Error Handling\n   There are many kinds of errors that can occur during\
    \ IKE processing.\n   If a request is received that is badly formatted or unacceptable\
    \ for\n   reasons of policy (e.g., no matching cryptographic algorithms), the\n\
    \   response MUST contain a Notify payload indicating the error.  If an\n   error\
    \ occurs outside the context of an IKE request (e.g., the node is\n   getting\
    \ ESP messages on a nonexistent SPI), the node SHOULD initiate\n   an INFORMATIONAL\
    \ exchange with a Notify payload describing the\n   problem.\n   Errors that occur\
    \ before a cryptographically protected IKE_SA is\n   established must be handled\
    \ very carefully.  There is a trade-off\n   between wanting to be helpful in diagnosing\
    \ a problem and responding\n   to it and wanting to avoid being a dupe in a denial\
    \ of service attack\n   based on forged messages.\n   If a node receives a message\
    \ on UDP port 500 or 4500 outside the\n   context of an IKE_SA known to it (and\
    \ not a request to start one), it\n   may be the result of a recent crash of the\
    \ node.  If the message is\n   marked as a response, the node MAY audit the suspicious\
    \ event but\n   MUST NOT respond.  If the message is marked as a request, the\
    \ node\n   MAY audit the suspicious event and MAY send a response.  If a\n   response\
    \ is sent, the response MUST be sent to the IP address and\n   port from whence\
    \ it came with the same IKE SPIs and the Message ID\n   copied.  The response\
    \ MUST NOT be cryptographically protected and\n   MUST contain a Notify payload\
    \ indicating INVALID_IKE_SPI.\n   A node receiving such an unprotected Notify\
    \ payload MUST NOT respond\n   and MUST NOT change the state of any existing SAs.\
    \  The message might\n   be a forgery or might be a response the genuine correspondent\
    \ was\n   tricked into sending.  A node SHOULD treat such a message (and also\
    \ a\n   network message like ICMP destination unreachable) as a hint that\n  \
    \ there might be problems with SAs to that IP address and SHOULD\n   initiate\
    \ a liveness test for any such IKE_SA.  An implementation\n   SHOULD limit the\
    \ frequency of such tests to avoid being tricked into\n   participating in a denial\
    \ of service attack.\n   A node receiving a suspicious message from an IP address\
    \ with which\n   it has an IKE_SA MAY send an IKE Notify payload in an IKE\n \
    \  INFORMATIONAL exchange over that SA.  The recipient MUST NOT change\n   the\
    \ state of any SA's as a result but SHOULD audit the event to aid\n   in diagnosing\
    \ malfunctions.  A node MUST limit the rate at which it\n   will send messages\
    \ in response to unprotected messages.\n"
- title: 2.22.  IPComp
  contents:
  - "2.22.  IPComp\n   Use of IP compression [IPCOMP] can be negotiated as part of\
    \ the setup\n   of a CHILD_SA.  While IP compression involves an extra header\
    \ in each\n   packet and a compression parameter index (CPI), the virtual\n  \
    \ \"compression association\" has no life outside the ESP or AH SA that\n   contains\
    \ it.  Compression associations disappear when the\n   corresponding ESP or AH\
    \ SA goes away.  It is not explicitly mentioned\n   in any DELETE payload.\n \
    \  Negotiation of IP compression is separate from the negotiation of\n   cryptographic\
    \ parameters associated with a CHILD_SA.  A node\n   requesting a CHILD_SA MAY\
    \ advertise its support for one or more\n   compression algorithms through one\
    \ or more Notify payloads of type\n   IPCOMP_SUPPORTED.  The response MAY indicate\
    \ acceptance of a single\n   compression algorithm with a Notify payload of type\
    \ IPCOMP_SUPPORTED.\n   These payloads MUST NOT occur in messages that do not\
    \ contain SA\n   payloads.\n   Although there has been discussion of allowing\
    \ multiple compression\n   algorithms to be accepted and to have different compression\n\
    \   algorithms available for the two directions of a CHILD_SA,\n   implementations\
    \ of this specification MUST NOT accept an IPComp\n   algorithm that was not proposed,\
    \ MUST NOT accept more than one, and\n   MUST NOT compress using an algorithm\
    \ other than one proposed and\n   accepted in the setup of the CHILD_SA.\n   A\
    \ side effect of separating the negotiation of IPComp from\n   cryptographic parameters\
    \ is that it is not possible to propose\n   multiple cryptographic suites and\
    \ propose IP compression with some of\n   them but not others.\n"
- title: 2.23.  NAT Traversal
  contents:
  - "2.23.  NAT Traversal\n   Network Address Translation (NAT) gateways are a controversial\n\
    \   subject.  This section briefly describes what they are and how they\n   are\
    \ likely to act on IKE traffic.  Many people believe that NATs are\n   evil and\
    \ that we should not design our protocols so as to make them\n   work better.\
    \  IKEv2 does specify some unintuitive processing rules in\n   order that NATs\
    \ are more likely to work.\n   NATs exist primarily because of the shortage of\
    \ IPv4 addresses,\n   though there are other rationales.  IP nodes that are \"\
    behind\" a NAT\n   have IP addresses that are not globally unique, but rather\
    \ are\n   assigned from some space that is unique within the network behind the\n\
    \   NAT but that are likely to be reused by nodes behind other NATs.\n   Generally,\
    \ nodes behind NATs can communicate with other nodes behind\n   the same NAT and\
    \ with nodes with globally unique addresses, but not\n   with nodes behind other\
    \ NATs.  There are exceptions to that rule.\n   When those nodes make connections\
    \ to nodes on the real Internet, the\n   NAT gateway \"translates\" the IP source\
    \ address to an address that\n   will be routed back to the gateway.  Messages\
    \ to the gateway from the\n   Internet have their destination addresses \"translated\"\
    \ to the\n   internal address that will route the packet to the correct endnode.\n\
    \   NATs are designed to be \"transparent\" to endnodes.  Neither software\n \
    \  on the node behind the NAT nor the node on the Internet requires\n   modification\
    \ to communicate through the NAT.  Achieving this\n   transparency is more difficult\
    \ with some protocols than with others.\n   Protocols that include IP addresses\
    \ of the endpoints within the\n   payloads of the packet will fail unless the\
    \ NAT gateway understands\n   the protocol and modifies the internal references\
    \ as well as those in\n   the headers.  Such knowledge is inherently unreliable,\
    \ is a network\n   layer violation, and often results in subtle problems.\n  \
    \ Opening an IPsec connection through a NAT introduces special\n   problems. \
    \ If the connection runs in transport mode, changing the IP\n   addresses on packets\
    \ will cause the checksums to fail and the NAT\n   cannot correct the checksums\
    \ because they are cryptographically\n   protected.  Even in tunnel mode, there\
    \ are routing problems because\n   transparently translating the addresses of\
    \ AH and ESP packets\n   requires special logic in the NAT and that logic is heuristic\
    \ and\n   unreliable in nature.  For that reason, IKEv2 can negotiate UDP\n  \
    \ encapsulation of IKE and ESP packets.  This encoding is slightly less\n   efficient\
    \ but is easier for NATs to process.  In addition, firewalls\n   may be configured\
    \ to pass IPsec traffic over UDP but not ESP/AH or\n   vice versa.\n   It is a\
    \ common practice of NATs to translate TCP and UDP port numbers\n   as well as\
    \ addresses and use the port numbers of inbound packets to\n   decide which internal\
    \ node should get a given packet.  For this\n   reason, even though IKE packets\
    \ MUST be sent from and to UDP port\n   500, they MUST be accepted coming from\
    \ any port and responses MUST be\n   sent to the port from whence they came. \
    \ This is because the ports\n   may be modified as the packets pass through NATs.\
    \  Similarly, IP\n   addresses of the IKE endpoints are generally not included\
    \ in the IKE\n   payloads because the payloads are cryptographically protected\
    \ and\n   could not be transparently modified by NATs.\n   Port 4500 is reserved\
    \ for UDP-encapsulated ESP and IKE.  When working\n   through a NAT, it is generally\
    \ better to pass IKE packets over port\n   4500 because some older NATs handle\
    \ IKE traffic on port 500 cleverly\n   in an attempt to transparently establish\
    \ IPsec connections between\n   endpoints that don't handle NAT traversal themselves.\
    \  Such NATs may\n   interfere with the straightforward NAT traversal envisioned\
    \ by this\n   document, so an IPsec endpoint that discovers a NAT between it and\n\
    \   its correspondent MUST send all subsequent traffic to and from port\n   4500,\
    \ which NATs should not treat specially (as they might with port\n   500).\n \
    \  The specific requirements for supporting NAT traversal [RFC3715] are\n   listed\
    \ below.  Support for NAT traversal is optional.  In this\n   section only, requirements\
    \ listed as MUST apply only to\n   implementations supporting NAT traversal.\n\
    \      IKE MUST listen on port 4500 as well as port 500.  IKE MUST\n      respond\
    \ to the IP address and port from which packets arrived.\n      Both IKE initiator\
    \ and responder MUST include in their IKE_SA_INIT\n      packets Notify payloads\
    \ of type NAT_DETECTION_SOURCE_IP and\n      NAT_DETECTION_DESTINATION_IP.  Those\
    \ payloads can be used to\n      detect if there is NAT between the hosts, and\
    \ which end is behind\n      the NAT.  The location of the payloads in the IKE_SA_INIT\
    \ packets\n      are just after the Ni and Nr payloads (before the optional CERTREQ\n\
    \      payload).\n      If none of the NAT_DETECTION_SOURCE_IP payload(s) received\
    \ matches\n      the hash of the source IP and port found from the IP header of\
    \ the\n      packet containing the payload, it means that the other end is\n \
    \     behind NAT (i.e., someone along the route changed the source\n      address\
    \ of the original packet to match the address of the NAT\n      box).  In this\
    \ case, this end should allow dynamic update of the\n      other ends IP address,\
    \ as described later.\n      If the NAT_DETECTION_DESTINATION_IP payload received\
    \ does not\n      match the hash of the destination IP and port found from the\
    \ IP\n      header of the packet containing the payload, it means that this\n\
    \      end is behind a NAT.  In this case, this end SHOULD start sending\n   \
    \   keepalive packets as explained in [Hutt05].\n      The IKE initiator MUST\
    \ check these payloads if present and if they\n      do not match the addresses\
    \ in the outer packet MUST tunnel all\n      future IKE and ESP packets associated\
    \ with this IKE_SA over UDP\n      port 4500.\n      To tunnel IKE packets over\
    \ UDP port 4500, the IKE header has four\n      octets of zero prepended and the\
    \ result immediately follows the\n      UDP header.  To tunnel ESP packets over\
    \ UDP port 4500, the ESP\n      header immediately follows the UDP header.  Since\
    \ the first four\n      bytes of the ESP header contain the SPI, and the SPI cannot\n\
    \      validly be zero, it is always possible to distinguish ESP and IKE\n   \
    \   messages.\n      The original source and destination IP address required for\
    \ the\n      transport mode TCP and UDP packet checksum fixup (see [Hutt05])\n\
    \      are obtained from the Traffic Selectors associated with the\n      exchange.\
    \  In the case of NAT traversal, the Traffic Selectors\n      MUST contain exactly\
    \ one IP address, which is then used as the\n      original IP address.\n    \
    \  There are cases where a NAT box decides to remove mappings that\n      are\
    \ still alive (for example, the keepalive interval is too long,\n      or the\
    \ NAT box is rebooted).  To recover in these cases, hosts\n      that are not\
    \ behind a NAT SHOULD send all packets (including\n      retransmission packets)\
    \ to the IP address and port from the last\n      valid authenticated packet from\
    \ the other end (i.e., dynamically\n      update the address).  A host behind\
    \ a NAT SHOULD NOT do this\n      because it opens a DoS attack possibility. \
    \ Any authenticated IKE\n      packet or any authenticated UDP-encapsulated ESP\
    \ packet can be\n      used to detect that the IP address or the port has changed.\n\
    \      Note that similar but probably not identical actions will likely\n    \
    \  be needed to make IKE work with Mobile IP, but such processing is\n      not\
    \ addressed by this document.\n"
- title: 2.24.  Explicit Congestion Notification (ECN)
  contents:
  - "2.24.  Explicit Congestion Notification (ECN)\n   When IPsec tunnels behave as\
    \ originally specified in [RFC2401], ECN\n   usage is not appropriate for the\
    \ outer IP headers because tunnel\n   decapsulation processing discards ECN congestion\
    \ indications to the\n   detriment of the network.  ECN support for IPsec tunnels\
    \ for IKEv1-\n   based IPsec requires multiple operating modes and negotiation\
    \ (see\n   [RFC3168]).  IKEv2 simplifies this situation by requiring that ECN\
    \ be\n   usable in the outer IP headers of all tunnel-mode IPsec SAs created\n\
    \   by IKEv2.  Specifically, tunnel encapsulators and decapsulators for\n   all\
    \ tunnel-mode SAs created by IKEv2 MUST support the ECN full-\n   functionality\
    \ option for tunnels specified in [RFC3168] and MUST\n   implement the tunnel\
    \ encapsulation and decapsulation processing\n   specified in [RFC4301] to prevent\
    \ discarding of ECN congestion\n   indications.\n"
- title: 3.  Header and Payload Formats
  contents:
  - '3.  Header and Payload Formats

    '
- title: 3.1.  The IKE Header
  contents:
  - "3.1.  The IKE Header\n   IKE messages use UDP ports 500 and/or 4500, with one\
    \ IKE message per\n   UDP datagram.  Information from the beginning of the packet\
    \ through\n   the UDP header is largely ignored except that the IP addresses and\n\
    \   UDP ports from the headers are reversed and used for return packets.\n   When\
    \ sent on UDP port 500, IKE messages begin immediately following\n   the UDP header.\
    \  When sent on UDP port 4500, IKE messages have\n   prepended four octets of\
    \ zero.  These four octets of zero are not\n   part of the IKE message and are\
    \ not included in any of the length\n   fields or checksums defined by IKE.  Each\
    \ IKE message begins with the\n   IKE header, denoted HDR in this memo.  Following\
    \ the header are one\n   or more IKE payloads each identified by a \"Next Payload\"\
    \ field in the\n   preceding payload.  Payloads are processed in the order in\
    \ which they\n   appear in an IKE message by invoking the appropriate processing\n\
    \   routine according to the \"Next Payload\" field in the IKE header and\n  \
    \ subsequently according to the \"Next Payload\" field in the IKE payload\n  \
    \ itself until a \"Next Payload\" field of zero indicates that no\n   payloads\
    \ follow.  If a payload of type \"Encrypted\" is found, that\n   payload is decrypted\
    \ and its contents parsed as additional payloads.\n   An Encrypted payload MUST\
    \ be the last payload in a packet and an\n   Encrypted payload MUST NOT contain\
    \ another Encrypted payload.\n   The Recipient SPI in the header identifies an\
    \ instance of an IKE\n   security association.  It is therefore possible for a\
    \ single instance\n   of IKE to multiplex distinct sessions with multiple peers.\n\
    \   All multi-octet fields representing integers are laid out in big\n   endian\
    \ order (aka most significant byte first, or network byte\n   order).\n   The\
    \ format of the IKE header is shown in Figure 4.\n                           1\
    \                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                       IKE_SA Initiator's SPI                  !\n   \
    \   !                                                               !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                       IKE_SA Responder's SPI                  !\n   \
    \   !                                                               !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !  Next Payload ! MjVer ! MnVer ! Exchange Type !     Flags     !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \                          Message ID                           !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                            Length                             !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \                 Figure 4:  IKE Header Format\n      o  Initiator's SPI (8 octets)\
    \ - A value chosen by the\n         initiator to identify a unique IKE security\
    \ association.  This\n         value MUST NOT be zero.\n      o  Responder's SPI\
    \ (8 octets) - A value chosen by the\n         responder to identify a unique\
    \ IKE security association.  This\n         value MUST be zero in the first message\
    \ of an IKE Initial\n         Exchange (including repeats of that message including\
    \ a\n         cookie) and MUST NOT be zero in any other message.\n      o  Next\
    \ Payload (1 octet) - Indicates the type of payload that\n         immediately\
    \ follows the header.  The format and value of each\n         payload are defined\
    \ below.\n      o  Major Version (4 bits) - Indicates the major version of the\
    \ IKE\n         protocol in use.  Implementations based on this version of IKE\n\
    \         MUST set the Major Version to 2.  Implementations based on\n       \
    \  previous versions of IKE and ISAKMP MUST set the Major Version\n         to\
    \ 1.  Implementations based on this version of IKE MUST reject\n         or ignore\
    \ messages containing a version number greater than\n         2.\n      o  Minor\
    \ Version (4 bits) - Indicates the minor version of the\n         IKE protocol\
    \ in use.  Implementations based on this version of\n         IKE MUST set the\
    \ Minor Version to 0.  They MUST ignore the\n         minor version number of\
    \ received messages.\n      o  Exchange Type (1 octet) - Indicates the type of\
    \ exchange being\n         used.  This constrains the payloads sent in each message\
    \ and\n         orderings of messages in an exchange.\n                      \
    \ Exchange Type            Value\n                       RESERVED            \
    \     0-33\n                       IKE_SA_INIT              34\n             \
    \          IKE_AUTH                 35\n                       CREATE_CHILD_SA\
    \          36\n                       INFORMATIONAL            37\n          \
    \             RESERVED TO IANA         38-239\n                       Reserved\
    \ for private use 240-255\n      o  Flags (1 octet) - Indicates specific options\
    \ that are set\n         for the message.  Presence of options are indicated by\
    \ the\n         appropriate bit in the flags field being set.  The bits are\n\
    \         defined LSB first, so bit 0 would be the least significant\n       \
    \  bit of the Flags octet.  In the description below, a bit\n         being 'set'\
    \ means its value is '1', while 'cleared' means\n         its value is '0'.\n\
    \       --  X(reserved) (bits 0-2) - These bits MUST be cleared\n           when\
    \ sending and MUST be ignored on receipt.\n       --  I(nitiator) (bit 3 of Flags)\
    \ - This bit MUST be set in\n           messages sent by the original initiator\
    \ of the IKE_SA\n           and MUST be cleared in messages sent by the original\n\
    \           responder.  It is used by the recipient to determine\n           which\
    \ eight octets of the SPI were generated by the\n           recipient.\n     \
    \  --  V(ersion) (bit 4 of Flags) - This bit indicates that\n           the transmitter\
    \ is capable of speaking a higher major\n           version number of the protocol\
    \ than the one indicated\n           in the major version number field.  Implementations\
    \ of\n           IKEv2 must clear this bit when sending and MUST ignore\n    \
    \       it in incoming messages.\n       --  R(esponse) (bit 5 of Flags) - This\
    \ bit indicates that\n           this message is a response to a message containing\n\
    \           the same message ID.  This bit MUST be cleared in all\n          \
    \ request messages and MUST be set in all responses.\n           An IKE endpoint\
    \ MUST NOT generate a response to a\n           message that is marked as being\
    \ a response.\n       --  X(reserved) (bits 6-7 of Flags) - These bits MUST be\n\
    \           cleared when sending and MUST be ignored on receipt.\n      o  Message\
    \ ID (4 octets) - Message identifier used to control\n      retransmission of\
    \ lost packets and matching of requests and\n      responses.  It is essential\
    \ to the security of the protocol\n      because it is used to prevent message\
    \ replay attacks.\n      See sections 2.1 and 2.2.\n      o  Length (4 octets)\
    \ - Length of total message (header + payloads)\n      in octets.\n"
- title: 3.2.  Generic Payload Header
  contents:
  - "3.2.  Generic Payload Header\n   Each IKE payload defined in sections 3.3 through\
    \ 3.16 begins with a\n   generic payload header, shown in Figure 5.  Figures for\
    \ each payload\n   below will include the generic payload header, but for brevity\
    \ the\n   description of each field will be omitted.\n                       \
    \    1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! Next Payload  !C!  RESERVED   !         Payload Length        !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \                   Figure 5:  Generic Payload Header\n   The Generic Payload\
    \ Header fields are defined as follows:\n   o  Next Payload (1 octet) - Identifier\
    \ for the payload type of the\n      next payload in the message.  If the current\
    \ payload is the last\n      in the message, then this field will be 0.  This\
    \ field provides a\n      \"chaining\" capability whereby additional payloads\
    \ can be added to\n      a message by appending it to the end of the message and\
    \ setting\n      the \"Next Payload\" field of the preceding payload to indicate\
    \ the\n      new payload's type.  An Encrypted payload, which must always be\n\
    \      the last payload of a message, is an exception.  It contains data\n   \
    \   structures in the format of additional payloads.  In the header of\n     \
    \ an Encrypted payload, the Next Payload field is set to the payload\n      type\
    \ of the first contained payload (instead of 0).\n      Payload Type Values\n\
    \          Next Payload Type               Notation  Value\n          No Next\
    \ Payload                              0\n          RESERVED                 \
    \                  1-32\n          Security Association             SA       \
    \  33\n          Key Exchange                     KE         34\n          Identification\
    \ - Initiator       IDi        35\n          Identification - Responder      \
    \ IDr        36\n          Certificate                      CERT       37\n  \
    \        Certificate Request              CERTREQ    38\n          Authentication\
    \                   AUTH       39\n          Nonce                           \
    \ Ni, Nr     40\n          Notify                           N          41\n  \
    \        Delete                           D          42\n          Vendor ID \
    \                       V          43\n          Traffic Selector - Initiator\
    \     TSi        44\n          Traffic Selector - Responder     TSr        45\n\
    \          Encrypted                        E          46\n          Configuration\
    \                    CP         47\n          Extensible Authentication      \
    \  EAP        48\n          RESERVED TO IANA                          49-127\n\
    \          PRIVATE USE                              128-255\n      Payload type\
    \ values 1-32 should not be used so that there is no\n      overlap with the code\
    \ assignments for IKEv1.  Payload type values\n      49-127 are reserved to IANA\
    \ for future assignment in IKEv2 (see\n      section 6).  Payload type values\
    \ 128-255 are for private use among\n      mutually consenting parties.\n   o\
    \  Critical (1 bit) - MUST be set to zero if the sender wants the\n      recipient\
    \ to skip this payload if it does not understand the\n      payload type code\
    \ in the Next Payload field of the previous\n      payload.  MUST be set to one\
    \ if the sender wants the recipient to\n      reject this entire message if it\
    \ does not understand the payload\n      type.  MUST be ignored by the recipient\
    \ if the recipient\n      understands the payload type code.  MUST be set to zero\
    \ for\n      payload types defined in this document.  Note that the critical\n\
    \      bit applies to the current payload rather than the \"next\" payload\n \
    \     whose type code appears in the first octet.  The reasoning behind\n    \
    \  not setting the critical bit for payloads defined in this document\n      is\
    \ that all implementations MUST understand all payload types\n      defined in\
    \ this document and therefore must ignore the Critical\n      bit's value.  Skipped\
    \ payloads are expected to have valid Next\n      Payload and Payload Length fields.\n\
    \   o  RESERVED (7 bits) - MUST be sent as zero; MUST be ignored on\n      receipt.\n\
    \   o  Payload Length (2 octets) - Length in octets of the current\n      payload,\
    \ including the generic payload header.\n"
- title: 3.3.  Security Association Payload
  contents:
  - "3.3.  Security Association Payload\n   The Security Association Payload, denoted\
    \ SA in this memo, is used to\n   negotiate attributes of a security association.\
    \  Assembly of Security\n   Association Payloads requires great peace of mind.\
    \  An SA payload MAY\n   contain multiple proposals.  If there is more than one,\
    \ they MUST be\n   ordered from most preferred to least preferred.  Each proposal\
    \ may\n   contain multiple IPsec protocols (where a protocol is IKE, ESP, or\n\
    \   AH), each protocol MAY contain multiple transforms, and each\n   transform\
    \ MAY contain multiple attributes.  When parsing an SA, an\n   implementation\
    \ MUST check that the total Payload Length is consistent\n   with the payload's\
    \ internal lengths and counts.  Proposals,\n   Transforms, and Attributes each\
    \ have their own variable length\n   encodings.  They are nested such that the\
    \ Payload Length of an SA\n   includes the combined contents of the SA, Proposal,\
    \ Transform, and\n   Attribute information.  The length of a Proposal includes\
    \ the lengths\n   of all Transforms and Attributes it contains.  The length of\
    \ a\n   Transform includes the lengths of all Attributes it contains.\n   The\
    \ syntax of Security Associations, Proposals, Transforms, and\n   Attributes is\
    \ based on ISAKMP; however, the semantics are somewhat\n   different.  The reason\
    \ for the complexity and the hierarchy is to\n   allow for multiple possible combinations\
    \ of algorithms to be encoded\n   in a single SA.  Sometimes there is a choice\
    \ of multiple algorithms,\n   whereas other times there is a combination of algorithms.\
    \  For\n   example, an initiator might want to propose using (AH w/MD5 and ESP\n\
    \   w/3DES) OR (ESP w/MD5 and 3DES).\n   One of the reasons the semantics of the\
    \ SA payload has changed from\n   ISAKMP and IKEv1 is to make the encodings more\
    \ compact in common\n   cases.\n   The Proposal structure contains within it a\
    \ Proposal # and an IPsec\n   protocol ID.  Each structure MUST have the same\
    \ Proposal # as the\n   previous one or be one (1) greater.  The first Proposal\
    \ MUST have a\n   Proposal # of one (1).  If two successive structures have the\
    \ same\n   Proposal number, it means that the proposal consists of the first\n\
    \   structure AND the second.  So a proposal of AH AND ESP would have two\n  \
    \ proposal structures, one for AH and one for ESP and both would have\n   Proposal\
    \ #1.  A proposal of AH OR ESP would have two proposal\n   structures, one for\
    \ AH with Proposal #1 and one for ESP with Proposal\n   #2.\n   Each Proposal/Protocol\
    \ structure is followed by one or more transform\n   structures.  The number of\
    \ different transforms is generally\n   determined by the Protocol.  AH generally\
    \ has a single transform: an\n   integrity check algorithm.  ESP generally has\
    \ two: an encryption\n   algorithm and an integrity check algorithm.  IKE generally\
    \ has four\n   transforms: a Diffie-Hellman group, an integrity check algorithm,\
    \ a\n   prf algorithm, and an encryption algorithm.  If an algorithm that\n  \
    \ combines encryption and integrity protection is proposed, it MUST be\n   proposed\
    \ as an encryption algorithm and an integrity protection\n   algorithm MUST NOT\
    \ be proposed.  For each Protocol, the set of\n   permissible transforms is assigned\
    \ transform ID numbers, which appear\n   in the header of each transform.\n  \
    \ If there are multiple transforms with the same Transform Type, the\n   proposal\
    \ is an OR of those transforms.  If there are multiple\n   Transforms with different\
    \ Transform Types, the proposal is an AND of\n   the different groups.  For example,\
    \ to propose ESP with (3DES or\n   IDEA) and (HMAC_MD5 or HMAC_SHA), the ESP proposal\
    \ would contain two\n   Transform Type 1 candidates (one for 3DES and one for\
    \ IDEA) and two\n   Transform Type 2 candidates (one for HMAC_MD5 and one for\
    \ HMAC_SHA).\n   This effectively proposes four combinations of algorithms.  If\
    \ the\n   initiator wanted to propose only a subset of those, for example (3DES\n\
    \   and HMAC_MD5) or (IDEA and HMAC_SHA), there is no way to encode that\n   as\
    \ multiple transforms within a single Proposal.  Instead, the\n   initiator would\
    \ have to construct two different Proposals, each with\n   two transforms.\n \
    \  A given transform MAY have one or more Attributes.  Attributes are\n   necessary\
    \ when the transform can be used in more than one way, as\n   when an encryption\
    \ algorithm has a variable key size.  The transform\n   would specify the algorithm\
    \ and the attribute would specify the key\n   size.  Most transforms do not have\
    \ attributes.  A transform MUST NOT\n   have multiple attributes of the same type.\
    \  To propose alternate\n   values for an attribute (for example, multiple key\
    \ sizes for the AES\n   encryption algorithm), and implementation MUST include\
    \ multiple\n   Transforms with the same Transform Type each with a single Attribute.\n\
    \   Note that the semantics of Transforms and Attributes are quite\n   different\
    \ from those in IKEv1.  In IKEv1, a single Transform carried\n   multiple algorithms\
    \ for a protocol with one carried in the Transform\n   and the others carried\
    \ in the Attributes.\n                           1                   2       \
    \            3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! Next Payload  !C!  RESERVED   !         Payload Length        !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \                                                               !\n      ~   \
    \                       <Proposals>                          ~\n      !      \
    \                                                         !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 6:  Security Association Payload\n      o  Proposals (variable)\
    \ - One or more proposal substructures.\n      The payload type for the Security\
    \ Association Payload is thirty\n      three (33).\n"
- title: 3.3.1.  Proposal Substructure
  contents:
  - "3.3.1.  Proposal Substructure\n                           1                 \
    \  2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! 0 (last) or 2 !   RESERVED    !         Proposal Length       !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \ Proposal #    !  Protocol ID  !    SPI Size   !# of Transforms!\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ~                        SPI (variable)                         ~\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \                                                               !\n      ~   \
    \                     <Transforms>                           ~\n      !      \
    \                                                         !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 7:  Proposal Substructure\n      o  0 (last) or 2 (more)\
    \ (1 octet) - Specifies whether this is the\n         last Proposal Substructure\
    \ in the SA.  This syntax is inherited\n         from ISAKMP, but is unnecessary\
    \ because the last Proposal could\n         be identified from the length of the\
    \ SA.  The value (2)\n         corresponds to a Payload Type of Proposal in IKEv1,\
    \ and the\n         first 4 octets of the Proposal structure are designed to look\n\
    \         somewhat like the header of a Payload.\n      o  RESERVED (1 octet)\
    \ - MUST be sent as zero; MUST be ignored on\n         receipt.\n      o  Proposal\
    \ Length (2 octets) - Length of this proposal, including\n         all transforms\
    \ and attributes that follow.\n      o  Proposal # (1 octet) - When a proposal\
    \ is made, the first\n         proposal in an SA payload MUST be #1, and subsequent\
    \ proposals\n         MUST either be the same as the previous proposal (indicating\
    \ an\n         AND of the two proposals) or one more than the previous\n     \
    \    proposal (indicating an OR of the two proposals).  When a\n         proposal\
    \ is accepted, all of the proposal numbers in the SA\n         payload MUST be\
    \ the same and MUST match the number on the\n         proposal sent that was accepted.\n\
    \      o  Protocol ID (1 octet) - Specifies the IPsec protocol identifier\n  \
    \       for the current negotiation.  The defined values are:\n          Protocol\
    \               Protocol ID\n          RESERVED                0\n          IKE\
    \                     1\n          AH                      2\n          ESP  \
    \                   3\n          RESERVED TO IANA        4-200\n          PRIVATE\
    \ USE             201-255\n      o  SPI Size (1 octet) - For an initial IKE_SA\
    \ negotiation, this\n         field MUST be zero; the SPI is obtained from the\
    \ outer header.\n         During subsequent negotiations, it is equal to the size,\
    \ in\n         octets, of the SPI of the corresponding protocol (8 for IKE, 4\n\
    \         for ESP and AH).\n      o  # of Transforms (1 octet) - Specifies the\
    \ number of transforms\n         in this proposal.\n      o  SPI (variable) -\
    \ The sending entity's SPI. Even if the SPI Size\n         is not a multiple of\
    \ 4 octets, there is no padding applied to\n         the payload.  When the SPI\
    \ Size field is zero, this field is\n         not present in the Security Association\
    \ payload.\n      o  Transforms (variable) - One or more transform substructures.\n"
- title: 3.3.2.  Transform Substructure
  contents:
  - "3.3.2.  Transform Substructure\n                           1                \
    \   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! 0 (last) or 3 !   RESERVED    !        Transform Length       !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !Transform\
    \ Type !   RESERVED    !          Transform ID         !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                                                               !\n   \
    \   ~                      Transform Attributes                     ~\n      !\
    \                                                               !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 8:  Transform Substructure\n      o  0 (last) or 3 (more)\
    \ (1 octet) - Specifies whether this is the\n         last Transform Substructure\
    \ in the Proposal.  This syntax is\n         inherited from ISAKMP, but is unnecessary\
    \ because the last\n         Proposal could be identified from the length of the\
    \ SA.  The\n         value (3) corresponds to a Payload Type of Transform in IKEv1,\n\
    \         and the first 4 octets of the Transform structure are designed\n   \
    \      to look somewhat like the header of a Payload.\n      o  RESERVED - MUST\
    \ be sent as zero; MUST be ignored on receipt.\n      o  Transform Length - The\
    \ length (in octets) of the Transform\n         Substructure including Header\
    \ and Attributes.\n      o  Transform Type (1 octet) - The type of transform being\n\
    \         specified in this transform.  Different protocols support\n        \
    \ different transform types.  For some protocols, some of the\n         transforms\
    \ may be optional.  If a transform is optional and the\n         initiator wishes\
    \ to propose that the transform be omitted, no\n         transform of the given\
    \ type is included in the proposal.  If\n         the initiator wishes to make\
    \ use of the transform optional to\n         the responder, it includes a transform\
    \ substructure with\n         transform ID = 0 as one of the options.\n      o\
    \  Transform ID (2 octets) - The specific instance of the\n         transform\
    \ type being proposed.\n   Transform Type Values\n                           \
    \          Transform    Used In\n                                        Type\n\
    \          RESERVED                        0\n          Encryption Algorithm (ENCR)\
    \     1  (IKE and ESP)\n          Pseudo-random Function (PRF)    2  (IKE)\n \
    \         Integrity Algorithm (INTEG)     3  (IKE, AH, optional in ESP)\n    \
    \      Diffie-Hellman Group (D-H)      4  (IKE, optional in AH & ESP)\n      \
    \    Extended Sequence Numbers (ESN) 5  (AH and ESP)\n          RESERVED TO IANA\
    \                6-240\n          PRIVATE USE                     241-255\n  \
    \ For Transform Type 1 (Encryption Algorithm), defined Transform IDs\n   are:\n\
    \          Name                     Number           Defined In\n          RESERVED\
    \                    0\n          ENCR_DES_IV64               1              (RFC1827)\n\
    \          ENCR_DES                    2              (RFC2405), [DES]\n     \
    \     ENCR_3DES                   3              (RFC2451)\n          ENCR_RC5\
    \                    4              (RFC2451)\n          ENCR_IDEA           \
    \        5              (RFC2451), [IDEA]\n          ENCR_CAST               \
    \    6              (RFC2451)\n          ENCR_BLOWFISH               7       \
    \       (RFC2451)\n          ENCR_3IDEA                  8              (RFC2451)\n\
    \          ENCR_DES_IV32               9\n          RESERVED                 \
    \  10\n          ENCR_NULL                  11              (RFC2410)\n      \
    \    ENCR_AES_CBC               12              (RFC3602)\n          ENCR_AES_CTR\
    \               13              (RFC3664)\n          values 14-1023 are reserved\
    \ to IANA.  Values 1024-65535 are\n          for private use among mutually consenting\
    \ parties.\n   For Transform Type 2 (Pseudo-random Function), defined Transform\
    \ IDs\n   are:\n          Name                     Number               Defined\
    \ In\n          RESERVED                    0\n          PRF_HMAC_MD5        \
    \        1                 (RFC2104), [MD5]\n          PRF_HMAC_SHA1         \
    \      2                 (RFC2104), [SHA]\n          PRF_HMAC_TIGER          \
    \    3                 (RFC2104)\n          PRF_AES128_XCBC             4    \
    \             (RFC3664)\n          values 5-1023 are reserved to IANA.  Values\
    \ 1024-65535 are for\n          private use among mutually consenting parties.\n\
    \   For Transform Type 3 (Integrity Algorithm), defined Transform IDs\n   are:\n\
    \          Name                     Number                 Defined In\n      \
    \    NONE                       0\n          AUTH_HMAC_MD5_96           1    \
    \                 (RFC2403)\n          AUTH_HMAC_SHA1_96          2          \
    \           (RFC2404)\n          AUTH_DES_MAC               3\n          AUTH_KPDK_MD5\
    \              4                     (RFC1826)\n          AUTH_AES_XCBC_96   \
    \        5                     (RFC3566)\n          values 6-1023 are reserved\
    \ to IANA.  Values 1024-65535 are for\n          private use among mutually consenting\
    \ parties.\n   For Transform Type 4 (Diffie-Hellman Group), defined Transform\
    \ IDs\n   are:\n          Name                                Number\n       \
    \   NONE                               0\n          Defined in Appendix B    \
    \          1 - 2\n          RESERVED                           3 - 4\n       \
    \   Defined in [ADDGROUP]              5\n          RESERVED TO IANA         \
    \          6 - 13\n          Defined in [ADDGROUP]              14 - 18\n    \
    \      RESERVED TO IANA                   19 - 1023\n          PRIVATE USE   \
    \                     1024-65535\n   For Transform Type 5 (Extended Sequence Numbers),\
    \ defined Transform\n   IDs are:\n          Name                             \
    \   Number\n          No Extended Sequence Numbers       0\n          Extended\
    \ Sequence Numbers          1\n          RESERVED                           2\
    \ - 65535\n"
- title: 3.3.3.  Valid Transform Types by Protocol
  contents:
  - "3.3.3.  Valid Transform Types by Protocol\n   The number and type of transforms\
    \ that accompany an SA payload are\n   dependent on the protocol in the SA itself.\
    \  An SA payload proposing\n   the establishment of an SA has the following mandatory\
    \ and optional\n   transform types.  A compliant implementation MUST understand\
    \ all\n   mandatory and optional types for each protocol it supports (though it\n\
    \   need not accept proposals with unacceptable suites).  A proposal MAY\n   omit\
    \ the optional types if the only value for them it will accept is\n   NONE.\n\
    \          Protocol  Mandatory Types        Optional Types\n            IKE  \
    \   ENCR, PRF, INTEG, D-H\n            ESP     ENCR, ESN              INTEG, D-H\n\
    \            AH      INTEG, ESN             D-H\n"
- title: 3.3.4.  Mandatory Transform IDs
  contents:
  - "3.3.4.  Mandatory Transform IDs\n   The specification of suites that MUST and\
    \ SHOULD be supported for\n   interoperability has been removed from this document\
    \ because they are\n   likely to change more rapidly than this document evolves.\n\
    \   An important lesson learned from IKEv1 is that no system should only\n   implement\
    \ the mandatory algorithms and expect them to be the best\n   choice for all customers.\
    \  For example, at the time that this\n   document was written, many IKEv1 implementers\
    \ were starting to\n   migrate to AES in Cipher Block Chaining (CBC) mode for\
    \ Virtual\n   Private Network (VPN) applications.  Many IPsec systems based on\n\
    \   IKEv2 will implement AES, additional Diffie-Hellman groups, and\n   additional\
    \ hash algorithms, and some IPsec customers already require\n   these algorithms\
    \ in addition to the ones listed above.\n   It is likely that IANA will add additional\
    \ transforms in the future,\n   and some users may want to use private suites,\
    \ especially for IKE\n   where implementations should be capable of supporting\
    \ different\n   parameters, up to certain size limits.  In support of this goal,\
    \ all\n   implementations of IKEv2 SHOULD include a management facility that\n\
    \   allows specification (by a user or system administrator) of Diffie-\n   Hellman\
    \ (DH) parameters (the generator, modulus, and exponent lengths\n   and values)\
    \ for new DH groups.  Implementations SHOULD provide a\n   management interface\
    \ via which these parameters and the associated\n   transform IDs may be entered\
    \ (by a user or system administrator), to\n   enable negotiating such groups.\n\
    \   All implementations of IKEv2 MUST include a management facility that\n   enables\
    \ a user or system administrator to specify the suites that are\n   acceptable\
    \ for use with IKE.  Upon receipt of a payload with a set of\n   transform IDs,\
    \ the implementation MUST compare the transmitted\n   transform IDs against those\
    \ locally configured via the management\n   controls, to verify that the proposed\
    \ suite is acceptable based on\n   local policy.  The implementation MUST reject\
    \ SA proposals that are\n   not authorized by these IKE suite controls.  Note\
    \ that cryptographic\n   suites that MUST be implemented need not be configured\
    \ as acceptable\n   to local policy.\n"
- title: 3.3.5.  Transform Attributes
  contents:
  - "3.3.5.  Transform Attributes\n   Each transform in a Security Association payload\
    \ may include\n   attributes that modify or complete the specification of the\n\
    \   transform.  These attributes are type/value pairs and are defined\n   below.\
    \  For example, if an encryption algorithm has a variable-length\n   key, the\
    \ key length to be used may be specified as an attribute.\n   Attributes can have\
    \ a value with a fixed two octet length or a\n   variable-length value.  For the\
    \ latter, the attribute is encoded as\n   type/length/value.\n               \
    \            1                   2                   3\n       0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !A!       Attribute Type        !    AF=0  Attribute Length     !\n   \
    \   !F!                             !    AF=1  Attribute Value      !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                   AF=0  Attribute Value                       !\n   \
    \   !                   AF=1  Not Transmitted                       !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure 9:  Data Attributes\n      o  Attribute Type (2\
    \ octets) - Unique identifier for each type of\n         attribute (see below).\n\
    \         The most significant bit of this field is the Attribute Format\n   \
    \      bit (AF).  It indicates whether the data attributes follow the\n      \
    \   Type/Length/Value (TLV) format or a shortened Type/Value (TV)\n         format.\
    \  If the AF bit is zero (0), then the Data Attributes\n         are of the Type/Length/Value\
    \ (TLV) form.  If the AF bit is a\n         one (1), then the Data Attributes\
    \ are of the Type/Value form.\n      o  Attribute Length (2 octets) - Length in\
    \ octets of the Attribute\n         Value.  When the AF bit is a one (1), the\
    \ Attribute Value is\n         only 2 octets and the Attribute Length field is\
    \ not present.\n      o  Attribute Value (variable length) - Value of the Attribute\n\
    \         associated with the Attribute Type.  If the AF bit is a zero\n     \
    \    (0), this field has a variable length defined by the Attribute\n        \
    \ Length field.  If the AF bit is a one (1), the Attribute Value\n         has\
    \ a length of 2 octets.\n   Note that only a single attribute type (Key Length)\
    \ is defined, and\n   it is fixed length.  The variable-length encoding specification\
    \ is\n   included only for future extensions.  The only algorithms defined in\n\
    \   this document that accept attributes are the AES-based encryption,\n   integrity,\
    \ and pseudo-random functions, which require a single\n   attribute specifying\
    \ key width.\n   Attributes described as basic MUST NOT be encoded using the\n\
    \   variable-length encoding.  Variable-length attributes MUST NOT be\n   encoded\
    \ as basic even if their value can fit into two octets.  NOTE:\n   This is a change\
    \ from IKEv1, where increased flexibility may have\n   simplified the composer\
    \ of messages but certainly complicated the\n   parser.\n         Attribute Type\
    \                 Value        Attribute Format\n      --------------------------------------------------------------\n\
    \      RESERVED                           0-13 Key Length (in bits)\n      14\
    \                 TV RESERVED                           15-17\n      RESERVED\
    \ TO IANA                   18-16383 PRIVATE USE\n      16384-32767\n   Values\
    \ 0-13 and 15-17 were used in a similar context in IKEv1 and\n   should not be\
    \ assigned except to matching values.  Values 18-16383\n   are reserved to IANA.\
    \  Values 16384-32767 are for private use among\n   mutually consenting parties.\n\
    \   - Key Length\n      When using an Encryption Algorithm that has a variable-length\
    \ key,\n      this attribute specifies the key length in bits (MUST use network\n\
    \      byte order).  This attribute MUST NOT be used when the specified\n    \
    \  Encryption Algorithm uses a fixed-length key.\n"
- title: 3.3.6.  Attribute Negotiation
  contents:
  - "3.3.6.  Attribute Negotiation\n   During security association negotiation, initiators\
    \ present offers to\n   responders.  Responders MUST select a single complete\
    \ set of\n   parameters from the offers (or reject all offers if none are\n  \
    \ acceptable).  If there are multiple proposals, the responder MUST\n   choose\
    \ a single proposal number and return all of the Proposal\n   substructures with\
    \ that Proposal number.  If there are multiple\n   Transforms with the same type,\
    \ the responder MUST choose a single\n   one.  Any attributes of a selected transform\
    \ MUST be returned\n   unmodified.  The initiator of an exchange MUST check that\
    \ the\n   accepted offer is consistent with one of its proposals, and if not\n\
    \   that response MUST be rejected.\n   Negotiating Diffie-Hellman groups presents\
    \ some special challenges.\n   SA offers include proposed attributes and a Diffie-Hellman\
    \ public\n   number (KE) in the same message.  If in the initial exchange the\n\
    \   initiator offers to use one of several Diffie-Hellman groups, it\n   SHOULD\
    \ pick the one the responder is most likely to accept and\n   include a KE corresponding\
    \ to that group.  If the guess turns out to\n   be wrong, the responder will indicate\
    \ the correct group in the\n   response and the initiator SHOULD pick an element\
    \ of that group for\n   its KE value when retrying the first message.  It SHOULD,\
    \ however,\n   continue to propose its full supported set of groups in order to\n\
    \   prevent a man-in-the-middle downgrade attack.\n   Implementation Note:\n \
    \     Certain negotiable attributes can have ranges or could have\n      multiple\
    \ acceptable values.  These include the key length of a\n      variable key length\
    \ symmetric cipher.  To further interoperability\n      and to support upgrading\
    \ endpoints independently, implementers of\n      this protocol SHOULD accept\
    \ values that they deem to supply\n      greater security.  For instance, if a\
    \ peer is configured to accept\n      a variable-length cipher with a key length\
    \ of X bits and is\n      offered that cipher with a larger key length, the implementation\n\
    \      SHOULD accept the offer if it supports use of the longer key.\n   Support\
    \ of this capability allows an implementation to express a\n   concept of \"at\
    \ least\" a certain level of security -- \"a key length of\n   _at least_ X bits\
    \ for cipher Y\".\n"
- title: 3.4.  Key Exchange Payload
  contents:
  - "3.4.  Key Exchange Payload\n   The Key Exchange Payload, denoted KE in this memo,\
    \ is used to\n   exchange Diffie-Hellman public numbers as part of a Diffie-Hellman\n\
    \   key exchange.  The Key Exchange Payload consists of the IKE generic\n   payload\
    \ header followed by the Diffie-Hellman public value itself.\n               \
    \            1                   2                   3\n       0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! Next Payload  !C!  RESERVED   !         Payload Length        !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \          DH Group #           !           RESERVED            !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                                                               !\n   \
    \   ~                       Key Exchange Data                       ~\n      !\
    \                                                               !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 10:  Key Exchange Payload Format\n   A key exchange payload\
    \ is constructed by copying one's Diffie-Hellman\n   public value into the \"\
    Key Exchange Data\" portion of the payload.\n   The length of the Diffie-Hellman\
    \ public value MUST be equal to the\n   length of the prime modulus over which\
    \ the exponentiation was\n   performed, prepending zero bits to the value if necessary.\n\
    \   The DH Group # identifies the Diffie-Hellman group in which the Key\n   Exchange\
    \ Data was computed (see section 3.3.2).  If the selected\n   proposal uses a\
    \ different Diffie-Hellman group, the message MUST be\n   rejected with a Notify\
    \ payload of type INVALID_KE_PAYLOAD.\n   The payload type for the Key Exchange\
    \ payload is thirty four (34).\n"
- title: 3.5.  Identification Payloads
  contents:
  - "3.5.  Identification Payloads\n   The Identification Payloads, denoted IDi and\
    \ IDr in this memo, allow\n   peers to assert an identity to one another.  This\
    \ identity may be\n   used for policy lookup, but does not necessarily have to\
    \ match\n   anything in the CERT payload; both fields may be used by an\n   implementation\
    \ to perform access control decisions.\n   NOTE: In IKEv1, two ID payloads were\
    \ used in each direction to hold\n   Traffic Selector (TS) information for data\
    \ passing over the SA.  In\n   IKEv2, this information is carried in TS payloads\
    \ (see section 3.13).\n   The Identification Payload consists of the IKE generic\
    \ payload header\n   followed by identification fields as follows:\n         \
    \                  1                   2                   3\n       0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! Next Payload  !C!  RESERVED   !         Payload Length        !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \   ID Type     !                 RESERVED                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                                                               !\n   \
    \   ~                   Identification Data                         ~\n      !\
    \                                                               !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 11:  Identification Payload Format\n   o  ID Type (1 octet)\
    \ - Specifies the type of Identification being\n      used.\n   o  RESERVED -\
    \ MUST be sent as zero; MUST be ignored on receipt.\n   o  Identification Data\
    \ (variable length) - Value, as indicated by the\n      Identification Type. \
    \ The length of the Identification Data is\n      computed from the size in the\
    \ ID payload header.\n   The payload types for the Identification Payload are\
    \ thirty five (35)\n   for IDi and thirty six (36) for IDr.\n   The following\
    \ table lists the assigned values for the Identification\n   Type field, followed\
    \ by a description of the Identification Data\n   which follows:\n      ID Type\
    \                           Value\n      -------                           -----\n\
    \      RESERVED                            0\n      ID_IPV4_ADDR             \
    \           1\n            A single four (4) octet IPv4 address.\n      ID_FQDN\
    \                             2\n            A fully-qualified domain name string.\
    \  An example of a\n            ID_FQDN is, \"example.com\".  The string MUST\
    \ not contain any\n            terminators (e.g., NULL, CR, etc.).\n      ID_RFC822_ADDR\
    \                      3\n            A fully-qualified RFC822 email address string,\
    \ An example of\n            a ID_RFC822_ADDR is, \"jsmith@example.com\".  The\
    \ string MUST\n            not contain any terminators.\n      Reserved to IANA\
    \                    4\n      ID_IPV6_ADDR                        5\n        \
    \    A single sixteen (16) octet IPv6 address.\n      Reserved to IANA       \
    \             6 - 8\n      ID_DER_ASN1_DN                      9\n           \
    \ The binary Distinguished Encoding Rules (DER) encoding of an\n            ASN.1\
    \ X.500 Distinguished Name [X.501].\n      ID_DER_ASN1_GN                    \
    \  10\n            The binary DER encoding of an ASN.1 X.500 GeneralName\n   \
    \         [X.509].\n      ID_KEY_ID                           11\n           \
    \ An opaque octet stream which may be used to pass vendor-\n            specific\
    \ information necessary to do certain proprietary\n            types of identification.\n\
    \      Reserved to IANA                    12-200\n      Reserved for private\
    \ use            201-255\n   Two implementations will interoperate only if each\
    \ can generate a\n   type of ID acceptable to the other.  To assure maximum\n\
    \   interoperability, implementations MUST be configurable to send at\n   least\
    \ one of ID_IPV4_ADDR, ID_FQDN, ID_RFC822_ADDR, or ID_KEY_ID, and\n   MUST be\
    \ configurable to accept all of these types.  Implementations\n   SHOULD be capable\
    \ of generating and accepting all of these types.\n   IPv6-capable implementations\
    \ MUST additionally be configurable to\n   accept ID_IPV6_ADDR.  IPv6-only implementations\
    \ MAY be configurable\n   to send only ID_IPV6_ADDR.\n"
- title: 3.6.  Certificate Payload
  contents:
  - "3.6.  Certificate Payload\n   The Certificate Payload, denoted CERT in this memo,\
    \ provides a means\n   to transport certificates or other authentication-related\
    \ information\n   via IKE.  Certificate payloads SHOULD be included in an exchange\
    \ if\n   certificates are available to the sender unless the peer has\n   indicated\
    \ an ability to retrieve this information from elsewhere\n   using an HTTP_CERT_LOOKUP_SUPPORTED\
    \ Notify payload.  Note that the\n   term \"Certificate Payload\" is somewhat\
    \ misleading, because not all\n   authentication mechanisms use certificates and\
    \ data other than\n   certificates may be passed in this payload.\n   The Certificate\
    \ Payload is defined as follows:\n                           1               \
    \    2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! Next Payload  !C!  RESERVED   !         Payload Length        !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \ Cert Encoding !                                               !\n      +-+-+-+-+-+-+-+-+\
    \                                               !\n      ~                   \
    \    Certificate Data                        ~\n      !                      \
    \                                         !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 12:  Certificate Payload Format\n      o  Certificate\
    \ Encoding (1 octet) - This field indicates the type\n         of certificate\
    \ or certificate-related information contained in\n         the Certificate Data\
    \ field.\n           Certificate Encoding               Value\n           --------------------\
    \               -----\n           RESERVED                             0\n   \
    \        PKCS #7 wrapped X.509 certificate    1\n           PGP Certificate  \
    \                    2\n           DNS Signed Key                       3\n  \
    \         X.509 Certificate - Signature        4\n           Kerberos Token  \
    \                     6\n           Certificate Revocation List (CRL)    7\n \
    \          Authority Revocation List (ARL)      8\n           SPKI Certificate\
    \                     9\n           X.509 Certificate - Attribute       10\n \
    \          Raw RSA Key                         11\n           Hash and URL of\
    \ X.509 certificate   12\n           Hash and URL of X.509 bundle        13\n\
    \           RESERVED to IANA                  14 - 200\n           PRIVATE USE\
    \                      201 - 255\n      o  Certificate Data (variable length)\
    \ - Actual encoding of\n         certificate data.  The type of certificate is\
    \ indicated by the\n         Certificate Encoding field.\n   The payload type\
    \ for the Certificate Payload is thirty seven (37).\n   Specific syntax is for\
    \ some of the certificate type codes above is\n   not defined in this document.\
    \  The types whose syntax is defined in\n   this document are:\n      X.509 Certificate\
    \ - Signature (4) contains a DER encoded X.509\n      certificate whose public\
    \ key is used to validate the sender's AUTH\n      payload.\n      Certificate\
    \ Revocation List (7) contains a DER encoded X.509\n      certificate revocation\
    \ list.\n      Raw RSA Key (11) contains a PKCS #1 encoded RSA key (see [RSA]\
    \ and\n      [PKCS1]).\n      Hash and URL encodings (12-13) allow IKE messages\
    \ to remain short\n      by replacing long data structures with a 20 octet SHA-1\
    \ hash (see\n      [SHA]) of the replaced value followed by a variable-length\
    \ URL\n      that resolves to the DER encoded data structure itself.  This\n \
    \     improves efficiency when the endpoints have certificate data\n      cached\
    \ and makes IKE less subject to denial of service attacks\n      that become easier\
    \ to mount when IKE messages are large enough to\n      require IP fragmentation\
    \ [KPS03].\n      Use the following ASN.1 definition for an X.509 bundle:\n  \
    \          CertBundle\n              { iso(1) identified-organization(3) dod(6)\
    \ internet(1)\n                security(5) mechanisms(5) pkix(7) id-mod(0)\n \
    \               id-mod-cert-bundle(34) }\n            DEFINITIONS EXPLICIT TAGS\
    \ ::=\n            BEGIN\n            IMPORTS\n              Certificate, CertificateList\n\
    \              FROM PKIX1Explicit88\n                 { iso(1) identified-organization(3)\
    \ dod(6)\n                   internet(1) security(5) mechanisms(5) pkix(7)\n \
    \                  id-mod(0) id-pkix1-explicit(18) } ;\n           CertificateOrCRL\
    \ ::= CHOICE {\n             cert [0] Certificate,\n             crl  [1] CertificateList\
    \ }\n           CertificateBundle ::= SEQUENCE OF CertificateOrCRL\n         \
    \  END\n   Implementations MUST be capable of being configured to send and\n \
    \  accept up to four X.509 certificates in support of authentication,\n   and\
    \ also MUST be capable of being configured to send and accept the\n   first two\
    \ Hash and URL formats (with HTTP URLs).  Implementations\n   SHOULD be capable\
    \ of being configured to send and accept Raw RSA\n   keys.  If multiple certificates\
    \ are sent, the first certificate MUST\n   contain the public key used to sign\
    \ the AUTH payload.  The other\n   certificates may be sent in any order.\n"
- title: 3.7.  Certificate Request Payload
  contents:
  - "3.7.  Certificate Request Payload\n   The Certificate Request Payload, denoted\
    \ CERTREQ in this memo,\n   provides a means to request preferred certificates\
    \ via IKE and can\n   appear in the IKE_INIT_SA response and/or the IKE_AUTH request.\n\
    \   Certificate Request payloads MAY be included in an exchange when the\n   sender\
    \ needs to get the certificate of the receiver.  If multiple CAs\n   are trusted\
    \ and the cert encoding does not allow a list, then\n   multiple Certificate Request\
    \ payloads SHOULD be transmitted.\n   The Certificate Request Payload is defined\
    \ as follows:\n                           1                   2              \
    \     3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! Next Payload  !C!  RESERVED   !         Payload Length        !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \ Cert Encoding !                                               !\n      +-+-+-+-+-+-+-+-+\
    \                                               !\n      ~                   \
    \ Certification Authority                    ~\n      !                      \
    \                                         !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 13:  Certificate Request Payload Format\n   o  Certificate\
    \ Encoding (1 octet) - Contains an encoding of the type\n      or format of certificate\
    \ requested.  Values are listed in section\n      3.6.\n   o  Certification Authority\
    \ (variable length) - Contains an encoding\n      of an acceptable certification\
    \ authority for the type of\n      certificate requested.\n   The payload type\
    \ for the Certificate Request Payload is thirty eight\n   (38).\n   The Certificate\
    \ Encoding field has the same values as those defined\n   in section 3.6. The\
    \ Certification Authority field contains an\n   indicator of trusted authorities\
    \ for this certificate type.  The\n   Certification Authority value is a concatenated\
    \ list of SHA-1 hashes\n   of the public keys of trusted Certification Authorities\
    \ (CAs).  Each\n   is encoded as the SHA-1 hash of the Subject Public Key Info\
    \ element\n   (see section 4.1.2.7 of [RFC3280]) from each Trust Anchor\n   certificate.\
    \  The twenty-octet hashes are concatenated and included\n   with no other formatting.\n\
    \   Note that the term \"Certificate Request\" is somewhat misleading, in\n  \
    \ that values other than certificates are defined in a \"Certificate\"\n   payload\
    \ and requests for those values can be present in a Certificate\n   Request Payload.\
    \  The syntax of the Certificate Request payload in\n   such cases is not defined\
    \ in this document.\n   The Certificate Request Payload is processed by inspecting\
    \ the \"Cert\n   Encoding\" field to determine whether the processor has any\n\
    \   certificates of this type.  If so, the \"Certification Authority\"\n   field\
    \ is inspected to determine if the processor has any certificates\n   that can\
    \ be validated up to one of the specified certification\n   authorities.  This\
    \ can be a chain of certificates.\n   If an end-entity certificate exists that\
    \ satisfies the criteria\n   specified in the CERTREQ, a certificate or certificate\
    \ chain SHOULD\n   be sent back to the certificate requestor if the recipient\
    \ of the\n   CERTREQ:\n   - is configured to use certificate authentication,\n\
    \   - is allowed to send a CERT payload,\n   - has matching CA trust policy governing\
    \ the current negotiation, and\n   - has at least one time-wise and usage appropriate\
    \ end-entity\n     certificate chaining to a CA provided in the CERTREQ.\n   Certificate\
    \ revocation checking must be considered during the\n   chaining process used\
    \ to select a certificate.  Note that even if two\n   peers are configured to\
    \ use two different CAs, cross-certification\n   relationships should be supported\
    \ by appropriate selection logic.\n   The intent is not to prevent communication\
    \ through the strict\n   adherence of selection of a certificate based on CERTREQ,\
    \ when an\n   alternate certificate could be selected by the sender that would\n\
    \   still enable the recipient to successfully validate and trust it\n   through\
    \ trust conveyed by cross-certification, CRLs, or other out-\n   of-band configured\
    \ means.  Thus, the processing of a CERTREQ should\n   be seen as a suggestion\
    \ for a certificate to select, not a mandated\n   one.  If no certificates exist,\
    \ then the CERTREQ is ignored.  This is\n   not an error condition of the protocol.\
    \  There may be cases where\n   there is a preferred CA sent in the CERTREQ, but\
    \ an alternate might\n   be acceptable (perhaps after prompting a human operator).\n"
- title: 3.8.  Authentication Payload
  contents:
  - "3.8.  Authentication Payload\n   The Authentication Payload, denoted AUTH in\
    \ this memo, contains data\n   used for authentication purposes.  The syntax of\
    \ the Authentication\n   data varies according to the Auth Method as specified\
    \ below.\n   The Authentication Payload is defined as follows:\n             \
    \              1                   2                   3\n       0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! Next Payload  !C!  RESERVED   !         Payload Length        !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \ Auth Method   !                RESERVED                       !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                                                               !\n   \
    \   ~                      Authentication Data                      ~\n      !\
    \                                                               !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure 14:  Authentication Payload Format\n   o  Auth Method\
    \ (1 octet) - Specifies the method of authentication\n      used.  Values defined\
    \ are:\n        RSA Digital Signature (1) - Computed as specified in section\n\
    \        2.15 using an RSA private key over a PKCS#1 padded hash (see\n      \
    \  [RSA] and [PKCS1]).\n        Shared Key Message Integrity Code (2) - Computed\
    \ as specified in\n        section 2.15 using the shared key associated with the\
    \ identity\n        in the ID payload and the negotiated prf function\n      \
    \  DSS Digital Signature (3) - Computed as specified in section\n        2.15\
    \ using a DSS private key (see [DSS]) over a SHA-1 hash.\n        The values 0\
    \ and 4-200 are reserved to IANA.  The values 201-255\n        are available for\
    \ private use.\n   o  Authentication Data (variable length) - see section 2.15.\n\
    \   The payload type for the Authentication Payload is thirty nine (39).\n"
- title: 3.9.  Nonce Payload
  contents:
  - "3.9.  Nonce Payload\n   The Nonce Payload, denoted Ni and Nr in this memo for\
    \ the initiator's\n   and responder's nonce respectively, contains random data\
    \ used to\n   guarantee liveness during an exchange and protect against replay\n\
    \   attacks.\n   The Nonce Payload is defined as follows:\n                  \
    \         1                   2                   3\n       0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! Next Payload  !C!  RESERVED   !         Payload Length        !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \                                                               !\n      ~   \
    \                         Nonce Data                         ~\n      !      \
    \                                                         !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 15:  Nonce Payload Format\n   o  Nonce Data (variable\
    \ length) - Contains the random data generated\n      by the transmitting entity.\n\
    \   The payload type for the Nonce Payload is forty (40).\n   The size of a Nonce\
    \ MUST be between 16 and 256 octets inclusive.\n   Nonce values MUST NOT be reused.\n"
- title: 3.10.  Notify Payload
  contents:
  - "3.10.  Notify Payload\n   The Notify Payload, denoted N in this document, is\
    \ used to transmit\n   informational data, such as error conditions and state\
    \ transitions,\n   to an IKE peer.  A Notify Payload may appear in a response\
    \ message\n   (usually specifying why a request was rejected), in an INFORMATIONAL\n\
    \   Exchange (to report an error not in an IKE request), or in any other\n   message\
    \ to indicate sender capabilities or to modify the meaning of\n   the request.\n\
    \   The Notify Payload is defined as follows:\n                           1  \
    \                 2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! Next Payload  !C!  RESERVED   !         Payload Length        !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \  Protocol ID  !   SPI Size    !      Notify Message Type      !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                                                               !\n   \
    \   ~                Security Parameter Index (SPI)                 ~\n      !\
    \                                                               !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                                                               !\n   \
    \   ~                       Notification Data                       ~\n      !\
    \                                                               !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 16:  Notify Payload Format\n   o  Protocol ID (1 octet)\
    \ - If this notification concerns an existing\n      SA, this field indicates\
    \ the type of that SA.  For IKE_SA\n      notifications, this field MUST be one\
    \ (1).  For notifications\n      concerning IPsec SAs this field MUST contain\
    \ either (2) to\n      indicate AH or (3) to indicate ESP.  For notifications\
    \ that do not\n      relate to an existing SA, this field MUST be sent as zero\
    \ and MUST\n      be ignored on receipt.  All other values for this field are\n\
    \      reserved to IANA for future assignment.\n   o  SPI Size (1 octet) - Length\
    \ in octets of the SPI as defined by the\n      IPsec protocol ID or zero if no\
    \ SPI is applicable.  For a\n      notification concerning the IKE_SA, the SPI\
    \ Size MUST be zero.\n   o  Notify Message Type (2 octets) - Specifies the type\
    \ of\n      notification message.\n   o  SPI (variable length) - Security Parameter\
    \ Index.\n   o  Notification Data (variable length) - Informational or error data\n\
    \      transmitted in addition to the Notify Message Type.  Values for\n     \
    \ this field are type specific (see below).\n   The payload type for the Notify\
    \ Payload is forty one (41).\n"
- title: 3.10.1.  Notify Message Types
  contents:
  - "3.10.1.  Notify Message Types\n   Notification information can be error messages\
    \ specifying why an SA\n   could not be established.  It can also be status data\
    \ that a process\n   managing an SA database wishes to communicate with a peer\
    \ process.\n   The table below lists the Notification messages and their\n   corresponding\
    \ values.  The number of different error statuses was\n   greatly reduced from\
    \ IKEv1 both for simplification and to avoid\n   giving configuration information\
    \ to probers.\n   Types in the range 0 - 16383 are intended for reporting errors.\
    \  An\n   implementation receiving a Notify payload with one of these types\n\
    \   that it does not recognize in a response MUST assume that the\n   corresponding\
    \ request has failed entirely.  Unrecognized error types\n   in a request and\
    \ status types in a request or response MUST be\n   ignored except that they SHOULD\
    \ be logged.\n   Notify payloads with status types MAY be added to any message\
    \ and\n   MUST be ignored if not recognized.  They are intended to indicate\n\
    \   capabilities, and as part of SA negotiation are used to negotiate\n   non-cryptographic\
    \ parameters.\n        NOTIFY MESSAGES - ERROR TYPES           Value\n       \
    \ -----------------------------           -----\n        RESERVED            \
    \                      0\n        UNSUPPORTED_CRITICAL_PAYLOAD              1\n\
    \            Sent if the payload has the \"critical\" bit set and the\n      \
    \      payload type is not recognized.  Notification Data contains\n         \
    \   the one-octet payload type.\n        INVALID_IKE_SPI                     \
    \      4\n            Indicates an IKE message was received with an unrecognized\n\
    \            destination SPI.  This usually indicates that the recipient\n   \
    \         has rebooted and forgotten the existence of an IKE_SA.\n        INVALID_MAJOR_VERSION\
    \                     5\n            Indicates the recipient cannot handle the\
    \ version of IKE\n            specified in the header.  The closest version number\
    \ that\n            the recipient can support will be in the reply header.\n \
    \       INVALID_SYNTAX                            7\n            Indicates the\
    \ IKE message that was received was invalid\n            because some type, length,\
    \ or value was out of range or\n            because the request was rejected for\
    \ policy reasons.  To\n            avoid a denial of service attack using forged\
    \ messages, this\n            status may only be returned for and in an encrypted\
    \ packet\n            if the message ID and cryptographic checksum were valid.\
    \  To\n            avoid leaking information to someone probing a node, this\n\
    \            status MUST be sent in response to any error not covered by\n   \
    \         one of the other status types.  To aid debugging, more\n           \
    \ detailed error information SHOULD be written to a console or\n            log.\n\
    \        INVALID_MESSAGE_ID                        9\n            Sent when an\
    \ IKE message ID outside the supported window is\n            received.  This\
    \ Notify MUST NOT be sent in a response; the\n            invalid request MUST\
    \ NOT be acknowledged.  Instead, inform\n            the other side by initiating\
    \ an INFORMATIONAL exchange with\n            Notification data containing the\
    \ four octet invalid message\n            ID.  Sending this notification is optional,\
    \ and\n            notifications of this type MUST be rate limited.\n        INVALID_SPI\
    \                              11\n            MAY be sent in an IKE INFORMATIONAL\
    \ exchange when a node\n            receives an ESP or AH packet with an invalid\
    \ SPI.  The\n            Notification Data contains the SPI of the invalid packet.\n\
    \            This usually indicates a node has rebooted and forgotten an\n   \
    \         SA.  If this Informational Message is sent outside the\n           \
    \ context of an IKE_SA, it should be used by the recipient\n            only as\
    \ a \"hint\" that something might be wrong (because it\n            could easily\
    \ be forged).\n        NO_PROPOSAL_CHOSEN                       14\n         \
    \   None of the proposed crypto suites was acceptable.\n        INVALID_KE_PAYLOAD\
    \                       17\n            The D-H Group # field in the KE payload\
    \ is not the group #\n            selected by the responder for this exchange.\
    \  There are two\n            octets of data associated with this notification:\
    \ the\n            accepted D-H Group # in big endian order.\n        AUTHENTICATION_FAILED\
    \                    24\n            Sent in the response to an IKE_AUTH message\
    \ when for some\n            reason the authentication failed.  There is no associated\n\
    \            data.\n        SINGLE_PAIR_REQUIRED                     34\n    \
    \    This error indicates that a CREATE_CHILD_SA request is\n        unacceptable\
    \ because its sender is only willing to accept\n        traffic selectors specifying\
    \ a single pair of addresses.  The\n        requestor is expected to respond by\
    \ requesting an SA for only\n        the specific traffic it is trying to forward.\n\
    \        NO_ADDITIONAL_SAS                        35\n        This error indicates\
    \ that a CREATE_CHILD_SA request is\n        unacceptable because the responder\
    \ is unwilling to accept any\n        more CHILD_SAs on this IKE_SA.  Some minimal\
    \ implementations may\n        only accept a single CHILD_SA setup in the context\
    \ of an initial\n        IKE exchange and reject any subsequent attempts to add\
    \ more.\n        INTERNAL_ADDRESS_FAILURE                 36\n        Indicates\
    \ an error assigning an internal address (i.e.,\n        INTERNAL_IP4_ADDRESS\
    \ or INTERNAL_IP6_ADDRESS) during the\n        processing of a Configuration Payload\
    \ by a responder.  If this\n        error is generated within an IKE_AUTH exchange,\
    \ no CHILD_SA will\n        be created.\n        FAILED_CP_REQUIRED          \
    \             37\n        Sent by responder in the case where CP(CFG_REQUEST)\
    \ was expected\n        but not received, and so is a conflict with locally configured\n\
    \        policy.  There is no associated data.\n        TS_UNACCEPTABLE      \
    \                    38\n        Indicates that none of the addresses/protocols/ports\
    \ in the\n        supplied traffic selectors is acceptable.\n        INVALID_SELECTORS\
    \                        39\n            MAY be sent in an IKE INFORMATIONAL exchange\
    \ when a node\n            receives an ESP or AH packet whose selectors do not\
    \ match\n            those of the SA on which it was delivered (and that caused\n\
    \            the packet to be dropped).  The Notification Data contains\n    \
    \        the start of the offending packet (as in ICMP messages) and\n       \
    \     the SPI field of the notification is set to match the SPI of\n         \
    \   the IPsec SA.\n        RESERVED TO IANA - Error types         40 - 8191\n\
    \        Private Use - Errors                8192 - 16383\n        NOTIFY MESSAGES\
    \ - STATUS TYPES           Value\n        ------------------------------     \
    \      -----\n        INITIAL_CONTACT                          16384\n       \
    \     This notification asserts that this IKE_SA is the only\n            IKE_SA\
    \ currently active between the authenticated\n            identities.  It MAY\
    \ be sent when an IKE_SA is established\n            after a crash, and the recipient\
    \ MAY use this information to\n            delete any other IKE_SAs it has to\
    \ the same authenticated\n            identity without waiting for a timeout.\
    \  This notification\n            MUST NOT be sent by an entity that may be replicated\
    \ (e.g.,\n            a roaming user's credentials where the user is allowed to\n\
    \            connect to the corporate firewall from two remote systems at\n  \
    \          the same time).\n        SET_WINDOW_SIZE                          16385\n\
    \            This notification asserts that the sending endpoint is\n        \
    \    capable of keeping state for multiple outstanding exchanges,\n          \
    \  permitting the recipient to send multiple requests before\n            getting\
    \ a response to the first.  The data associated with a\n            SET_WINDOW_SIZE\
    \ notification MUST be 4 octets long and\n            contain the big endian representation\
    \ of the number of\n            messages the sender promises to keep.  Window\
    \ size is always\n            one until the initial exchanges complete.\n    \
    \    ADDITIONAL_TS_POSSIBLE                   16386\n            This notification\
    \ asserts that the sending endpoint narrowed\n            the proposed traffic\
    \ selectors but that other traffic\n            selectors would also have been\
    \ acceptable, though only in a\n            separate SA (see section 2.9).  There\
    \ is no data associated\n            with this Notify type.  It may be sent only\
    \ as an additional\n            payload in a message including accepted TSs.\n\
    \        IPCOMP_SUPPORTED                         16387\n            This notification\
    \ may be included only in a message\n            containing an SA payload negotiating\
    \ a CHILD_SA and\n            indicates a willingness by its sender to use IPComp\
    \ on this\n            SA.  The data associated with this notification includes\
    \ a\n            two-octet IPComp CPI followed by a one-octet transform ID\n \
    \           optionally followed by attributes whose length and format\n      \
    \      are defined by that transform ID.  A message proposing an SA\n        \
    \    may contain multiple IPCOMP_SUPPORTED notifications to\n            indicate\
    \ multiple supported algorithms.  A message accepting\n            an SA may contain\
    \ at most one.\n            The transform IDs currently defined are:\n       \
    \          NAME         NUMBER  DEFINED IN\n                 -----------  ------\
    \  -----------\n                 RESERVED       0\n                 IPCOMP_OUI\
    \     1\n                 IPCOMP_DEFLATE 2     RFC 2394\n                 IPCOMP_LZS\
    \     3     RFC 2395\n                 IPCOMP_LZJH    4     RFC 3051\n       \
    \          values 5-240 are reserved to IANA.  Values 241-255 are\n          \
    \       for private use among mutually consenting parties.\n        NAT_DETECTION_SOURCE_IP\
    \                  16388\n            This notification is used by its recipient\
    \ to determine\n            whether the source is behind a NAT box.  The data\
    \ associated\n            with this notification is a SHA-1 digest of the SPIs\
    \ (in the\n            order they appear in the header), IP address, and port\
    \ on\n            which this packet was sent.  There MAY be multiple Notify\n\
    \            payloads of this type in a message if the sender does not\n     \
    \       know which of several network attachments will be used to\n          \
    \  send the packet.  The recipient of this notification MAY\n            compare\
    \ the supplied value to a SHA-1 hash of the SPIs,\n            source IP address,\
    \ and port, and if they don't match it\n            SHOULD enable NAT traversal\
    \ (see section 2.23).\n            Alternately, it MAY reject the connection attempt\
    \ if NAT\n            traversal is not supported.\n        NAT_DETECTION_DESTINATION_IP\
    \             16389\n            This notification is used by its recipient to\
    \ determine\n            whether it is behind a NAT box.  The data associated\
    \ with\n            this notification is a SHA-1 digest of the SPIs (in the\n\
    \            order they appear in the header), IP address, and port to\n     \
    \       which this packet was sent.  The recipient of this\n            notification\
    \ MAY compare the supplied value to a hash of the\n            SPIs, destination\
    \ IP address, and port, and if they don't\n            match it SHOULD invoke\
    \ NAT traversal (see section 2.23).  If\n            they don't match, it means\
    \ that this end is behind a NAT and\n            this end SHOULD start sending\
    \ keepalive packets as defined\n            in [Hutt05].  Alternately, it MAY\
    \ reject the connection\n            attempt if NAT traversal is not supported.\n\
    \        COOKIE                                   16390\n            This notification\
    \ MAY be included in an IKE_SA_INIT\n            response.  It indicates that\
    \ the request should be retried\n            with a copy of this notification\
    \ as the first payload.  This\n            notification MUST be included in an\
    \ IKE_SA_INIT request\n            retry if a COOKIE notification was included\
    \ in the initial\n            response.  The data associated with this notification\
    \ MUST\n            be between 1 and 64 octets in length (inclusive).\n      \
    \  USE_TRANSPORT_MODE                       16391\n            This notification\
    \ MAY be included in a request message that\n            also includes an SA payload\
    \ requesting a CHILD_SA.  It\n            requests that the CHILD_SA use transport\
    \ mode rather than\n            tunnel mode for the SA created.  If the request\
    \ is accepted,\n            the response MUST also include a notification of type\n\
    \            USE_TRANSPORT_MODE.  If the responder declines the request,\n   \
    \         the CHILD_SA will be established in tunnel mode.  If this is\n     \
    \       unacceptable to the initiator, the initiator MUST delete the\n       \
    \     SA.  Note: Except when using this option to negotiate\n            transport\
    \ mode, all CHILD_SAs will use tunnel mode.\n            Note: The ECN decapsulation\
    \ modifications specified in\n            [RFC4301] MUST be performed for every\
    \ tunnel mode SA created\n            by IKEv2.\n        HTTP_CERT_LOOKUP_SUPPORTED\
    \               16392\n            This notification MAY be included in any message\
    \ that can\n            include a CERTREQ payload and indicates that the sender\
    \ is\n            capable of looking up certificates based on an HTTP-based\n\
    \            URL (and hence presumably would prefer to receive\n            certificate\
    \ specifications in that format).\n        REKEY_SA                          \
    \       16393\n            This notification MUST be included in a CREATE_CHILD_SA\n\
    \            exchange if the purpose of the exchange is to replace an\n      \
    \      existing ESP or AH SA.  The SPI field identifies the SA\n            being\
    \ rekeyed.  There is no data.\n        ESP_TFC_PADDING_NOT_SUPPORTED         \
    \   16394\n            This notification asserts that the sending endpoint will\
    \ NOT\n            accept packets that contain Flow Confidentiality (TFC)\n  \
    \          padding.\n        NON_FIRST_FRAGMENTS_ALSO                 16395\n\
    \            Used for fragmentation control.  See [RFC4301] for\n            explanation.\n\
    \        RESERVED TO IANA - STATUS TYPES      16396 - 40959\n        Private Use\
    \ - STATUS TYPES           40960 - 65535\n"
- title: 3.11.  Delete Payload
  contents:
  - "3.11.  Delete Payload\n   The Delete Payload, denoted D in this memo, contains\
    \ a protocol-\n   specific security association identifier that the sender has\
    \ removed\n   from its security association database and is, therefore, no longer\n\
    \   valid.  Figure 17 shows the format of the Delete Payload.  It is\n   possible\
    \ to send multiple SPIs in a Delete payload; however, each SPI\n   MUST be for\
    \ the same protocol.  Mixing of protocol identifiers MUST\n   NOT be performed\
    \ in a Delete payload.  It is permitted, however, to\n   include multiple Delete\
    \ payloads in a single INFORMATIONAL exchange\n   where each Delete payload lists\
    \ SPIs for a different protocol.\n   Deletion of the IKE_SA is indicated by a\
    \ protocol ID of 1 (IKE) but\n   no SPIs.  Deletion of a CHILD_SA, such as ESP\
    \ or AH, will contain the\n   IPsec protocol ID of that protocol (2 for AH, 3\
    \ for ESP), and the SPI\n   is the SPI the sending endpoint would expect in inbound\
    \ ESP or AH\n   packets.\n   The Delete Payload is defined as follows:\n     \
    \                      1                   2                   3\n       0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! Next Payload  !C!  RESERVED   !         Payload Length        !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \ Protocol ID   !   SPI Size    !           # of SPIs           !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                                                               !\n   \
    \   ~               Security Parameter Index(es) (SPI)              ~\n      !\
    \                                                               !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 17:  Delete Payload Format\n   o  Protocol ID (1 octet)\
    \ - Must be 1 for an IKE_SA, 2 for AH, or 3\n      for ESP.\n   o  SPI Size (1\
    \ octet) - Length in octets of the SPI as defined by the\n      protocol ID. \
    \ It MUST be zero for IKE (SPI is in message header)\n      or four for AH and\
    \ ESP.\n   o  # of SPIs (2 octets) - The number of SPIs contained in the Delete\n\
    \      payload.  The size of each SPI is defined by the SPI Size field.\n   o\
    \  Security Parameter Index(es) (variable length) - Identifies the\n      specific\
    \ security association(s) to delete.  The length of this\n      field is determined\
    \ by the SPI Size and # of SPIs fields.\n   The payload type for the Delete Payload\
    \ is forty two (42).\n"
- title: 3.12.  Vendor ID Payload
  contents:
  - "3.12.  Vendor ID Payload\n   The Vendor ID Payload, denoted V in this memo, contains\
    \ a vendor\n   defined constant.  The constant is used by vendors to identify\
    \ and\n   recognize remote instances of their implementations.  This mechanism\n\
    \   allows a vendor to experiment with new features while maintaining\n   backward\
    \ compatibility.\n   A Vendor ID payload MAY announce that the sender is capable\
    \ to\n   accepting certain extensions to the protocol, or it MAY simply\n   identify\
    \ the implementation as an aid in debugging.  A Vendor ID\n   payload MUST NOT\
    \ change the interpretation of any information defined\n   in this specification\
    \ (i.e., the critical bit MUST be set to 0).\n   Multiple Vendor ID payloads MAY\
    \ be sent.  An implementation is NOT\n   REQUIRED to send any Vendor ID payload\
    \ at all.\n   A Vendor ID payload may be sent as part of any message.  Reception\
    \ of\n   a familiar Vendor ID payload allows an implementation to make use of\n\
    \   Private USE numbers described throughout this memo -- private\n   payloads,\
    \ private exchanges, private notifications, etc.  Unfamiliar\n   Vendor IDs MUST\
    \ be ignored.\n   Writers of Internet-Drafts who wish to extend this protocol\
    \ MUST\n   define a Vendor ID payload to announce the ability to implement the\n\
    \   extension in the Internet-Draft.  It is expected that Internet-Drafts\n  \
    \ that gain acceptance and are standardized will be given \"magic\n   numbers\"\
    \ out of the Future Use range by IANA, and the requirement to\n   use a Vendor\
    \ ID will go away.\n   The Vendor ID Payload fields are defined as follows:\n\
    \                           1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! Next Payload  !C!  RESERVED   !         Payload Length        !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \                                                               !\n      ~   \
    \                     Vendor ID (VID)                        ~\n      !      \
    \                                                         !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure 18:  Vendor ID Payload Format\n   o  Vendor ID (variable\
    \ length) - It is the responsibility of the\n      person choosing the Vendor\
    \ ID to assure its uniqueness in spite of\n      the absence of any central registry\
    \ for IDs.  Good practice is to\n      include a company name, a person name,\
    \ or some such.  If you want\n      to show off, you might include the latitude\
    \ and longitude and time\n      where you were when you chose the ID and some\
    \ random input.  A\n      message digest of a long unique string is preferable\
    \ to the long\n      unique string itself.\n   The payload type for the Vendor\
    \ ID Payload is forty three (43).\n"
- title: 3.13.  Traffic Selector Payload
  contents:
  - "3.13.  Traffic Selector Payload\n   The Traffic Selector Payload, denoted TS\
    \ in this memo, allows peers\n   to identify packet flows for processing by IPsec\
    \ security services.\n   The Traffic Selector Payload consists of the IKE generic\
    \ payload\n   header followed by individual traffic selectors as follows:\n  \
    \                         1                   2                   3\n       0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! Next Payload  !C!  RESERVED   !         Payload Length        !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \ Number of TSs !                 RESERVED                      !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                                                               !\n   \
    \   ~                       <Traffic Selectors>                     ~\n      !\
    \                                                               !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 19:  Traffic Selectors Payload Format\n   o  Number of\
    \ TSs (1 octet) - Number of traffic selectors being\n      provided.\n   o  RESERVED\
    \ - This field MUST be sent as zero and MUST be ignored on\n      receipt.\n \
    \  o  Traffic Selectors (variable length) - One or more individual\n      traffic\
    \ selectors.\n   The length of the Traffic Selector payload includes the TS header\
    \ and\n   all the traffic selectors.\n   The payload type for the Traffic Selector\
    \ payload is forty four (44)\n   for addresses at the initiator's end of the SA\
    \ and forty five (45)\n   for addresses at the responder's end.\n"
- title: 3.13.1.  Traffic Selector
  contents:
  - "3.13.1.  Traffic Selector\n                           1                   2 \
    \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !   TS Type     !IP Protocol ID*|       Selector Length         |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \           Start Port*         |           End Port*           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                                                               !\n   \
    \   ~                         Starting Address*                     ~\n      !\
    \                                                               !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                                                               !\n   \
    \   ~                         Ending Address*                       ~\n      !\
    \                                                               !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 20: Traffic Selector\n   * Note: All fields other than\
    \ TS Type and Selector Length depend on\n   the TS Type.  The fields shown are\
    \ for TS Types 7 and 8, the only two\n   values currently defined.\n   o  TS Type\
    \ (one octet) - Specifies the type of traffic selector.\n   o  IP protocol ID\
    \ (1 octet) - Value specifying an associated IP\n      protocol ID (e.g., UDP/TCP/ICMP).\
    \  A value of zero means that the\n      protocol ID is not relevant to this traffic\
    \ selector -- the SA can\n      carry all protocols.\n   o  Selector Length -\
    \ Specifies the length of this Traffic Selector\n      Substructure including\
    \ the header.\n   o  Start Port (2 octets) - Value specifying the smallest port\
    \ number\n      allowed by this Traffic Selector.  For protocols for which port\
    \ is\n      undefined, or if all ports are allowed, this field MUST be zero.\n\
    \      For the ICMP protocol, the two one-octet fields Type and Code are\n   \
    \   treated as a single 16-bit integer (with Type in the most\n      significant\
    \ eight bits and Code in the least significant eight\n      bits) port number\
    \ for the purposes of filtering based on this\n      field.\n   o  End Port (2\
    \ octets) - Value specifying the largest port number\n      allowed by this Traffic\
    \ Selector.  For protocols for which port is\n      undefined, or if all ports\
    \ are allowed, this field MUST be 65535.\n      For the ICMP protocol, the two\
    \ one-octet fields Type and Code are\n      treated as a single 16-bit integer\
    \ (with Type in the most\n      significant eight bits and Code in the least significant\
    \ eight\n      bits) port number for the purposed of filtering based on this\n\
    \      field.\n   o  Starting Address - The smallest address included in this\
    \ Traffic\n      Selector (length determined by TS type).\n   o  Ending Address\
    \ - The largest address included in this Traffic\n      Selector (length determined\
    \ by TS type).\n   Systems that are complying with [RFC4301] that wish to indicate\
    \ \"ANY\"\n   ports MUST set the start port to 0 and the end port to 65535; note\n\
    \   that according to [RFC4301], \"ANY\" includes \"OPAQUE\".  Systems\n   working\
    \ with [RFC4301] that wish to indicate \"OPAQUE\" ports, but not\n   \"ANY\" ports,\
    \ MUST set the start port to 65535 and the end port to 0.\n   The following table\
    \ lists the assigned values for the Traffic\n   Selector Type field and the corresponding\
    \ Address Selector Data.\n      TS Type                           Value\n    \
    \  -------                           -----\n      RESERVED                   \
    \        0-6\n      TS_IPV4_ADDR_RANGE                  7\n            A range\
    \ of IPv4 addresses, represented by two four-octet\n            values.  The first\
    \ value is the beginning IPv4 address\n            (inclusive) and the second\
    \ value is the ending IPv4 address\n            (inclusive).  All addresses falling\
    \ between the two\n            specified addresses are considered to be within\
    \ the list.\n      TS_IPV6_ADDR_RANGE                  8\n            A range\
    \ of IPv6 addresses, represented by two sixteen-octet\n            values.  The\
    \ first value is the beginning IPv6 address\n            (inclusive) and the second\
    \ value is the ending IPv6 address\n            (inclusive).  All addresses falling\
    \ between the two\n            specified addresses are considered to be within\
    \ the list.\n      RESERVED TO IANA                    9-240\n      PRIVATE USE\
    \                         241-255\n"
- title: 3.14.  Encrypted Payload
  contents:
  - "3.14.  Encrypted Payload\n   The Encrypted Payload, denoted SK{...} or E in this\
    \ memo, contains\n   other payloads in encrypted form.  The Encrypted Payload,\
    \ if present\n   in a message, MUST be the last payload in the message.  Often,\
    \ it is\n   the only payload in the message.\n   The algorithms for encryption\
    \ and integrity protection are negotiated\n   during IKE_SA setup, and the keys\
    \ are computed as specified in\n   sections 2.14 and 2.18.\n   The encryption\
    \ and integrity protection algorithms are modeled after\n   the ESP algorithms\
    \ described in RFCs 2104 [KBC96], 4303 [RFC4303],\n   and 2451 [ESPCBC].  This\
    \ document completely specifies the\n   cryptographic processing of IKE data,\
    \ but those documents should be\n   consulted for design rationale.  We require\
    \ a block cipher with a\n   fixed block size and an integrity check algorithm\
    \ that computes a\n   fixed-length checksum over a variable size message.\n  \
    \ The payload type for an Encrypted payload is forty six (46).  The\n   Encrypted\
    \ Payload consists of the IKE generic payload header followed\n   by individual\
    \ fields as follows:\n                           1                   2       \
    \            3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! Next Payload  !C!  RESERVED   !         Payload Length        !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \                     Initialization Vector                     !\n      !   \
    \      (length is block size for encryption algorithm)       !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ~                    Encrypted IKE Payloads                     ~\n   \
    \   +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \               !             Padding (0-255 octets)            !\n      +-+-+-+-+-+-+-+-+\
    \                               +-+-+-+-+-+-+-+-+\n      !                   \
    \                            !  Pad Length   !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ~                    Integrity Checksum Data                    ~\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \         Figure 21:  Encrypted Payload Format\n   o  Next Payload - The payload\
    \ type of the first embedded payload.\n      Note that this is an exception in\
    \ the standard header format,\n      since the Encrypted payload is the last payload\
    \ in the message and\n      therefore the Next Payload field would normally be\
    \ zero.  But\n      because the content of this payload is embedded payloads and\
    \ there\n      was no natural place to put the type of the first one, that type\n\
    \      is placed here.\n   o  Payload Length - Includes the lengths of the header,\
    \ IV, Encrypted\n      IKE Payloads, Padding, Pad Length, and Integrity Checksum\
    \ Data.\n   o  Initialization Vector - A randomly chosen value whose length is\n\
    \      equal to the block length of the underlying encryption algorithm.\n   \
    \   Recipients MUST accept any value.  Senders SHOULD either pick this\n     \
    \ value pseudo-randomly and independently for each message or use\n      the final\
    \ ciphertext block of the previous message sent.  Senders\n      MUST NOT use\
    \ the same value for each message, use a sequence of\n      values with low hamming\
    \ distance (e.g., a sequence number), or use\n      ciphertext from a received\
    \ message.\n   o  IKE Payloads are as specified earlier in this section. This\
    \ field\n      is encrypted with the negotiated cipher.\n   o  Padding MAY contain\
    \ any value chosen by the sender, and MUST have\n      a length that makes the\
    \ combination of the Payloads, the Padding,\n      and the Pad Length to be a\
    \ multiple of the encryption block size.\n      This field is encrypted with the\
    \ negotiated cipher.\n   o  Pad Length is the length of the Padding field. The\
    \ sender SHOULD\n      set the Pad Length to the minimum value that makes the\
    \ combination\n      of the Payloads, the Padding, and the Pad Length a multiple\
    \ of the\n      block size, but the recipient MUST accept any length that results\n\
    \      in proper alignment.  This field is encrypted with the negotiated\n   \
    \   cipher.\n   o  Integrity Checksum Data is the cryptographic checksum of the\n\
    \      entire message starting with the Fixed IKE Header through the Pad\n   \
    \   Length.  The checksum MUST be computed over the encrypted message.\n     \
    \ Its length is determined by the integrity algorithm negotiated.\n"
- title: 3.15.  Configuration Payload
  contents:
  - "3.15.  Configuration Payload\n   The Configuration payload, denoted CP in this\
    \ document, is used to\n   exchange configuration information between IKE peers.\
    \  The exchange\n   is for an IRAC to request an internal IP address from an IRAS\
    \ and to\n   exchange other information of the sort that one would acquire with\n\
    \   Dynamic Host Configuration Protocol (DHCP) if the IRAC were directly\n   connected\
    \ to a LAN.\n   Configuration payloads are of type CFG_REQUEST/CFG_REPLY or\n\
    \   CFG_SET/CFG_ACK (see CFG Type in the payload description below).\n   CFG_REQUEST\
    \ and CFG_SET payloads may optionally be added to any IKE\n   request.  The IKE\
    \ response MUST include either a corresponding\n   CFG_REPLY or CFG_ACK or a Notify\
    \ payload with an error type\n   indicating why the request could not be honored.\
    \  An exception is\n   that a minimal implementation MAY ignore all CFG_REQUEST\
    \ and CFG_SET\n   payloads, so a response message without a corresponding CFG_REPLY\
    \ or\n   CFG_ACK MUST be accepted as an indication that the request was not\n\
    \   supported.\n   \"CFG_REQUEST/CFG_REPLY\" allows an IKE endpoint to request\
    \ information\n   from its peer.  If an attribute in the CFG_REQUEST Configuration\n\
    \   Payload is not zero-length, it is taken as a suggestion for that\n   attribute.\
    \  The CFG_REPLY Configuration Payload MAY return that\n   value, or a new one.\
    \  It MAY also add new attributes and not include\n   some requested ones.  Requestors\
    \ MUST ignore returned attributes that\n   they do not recognize.\n   Some attributes\
    \ MAY be multi-valued, in which case multiple attribute\n   values of the same\
    \ type are sent and/or returned.  Generally, all\n   values of an attribute are\
    \ returned when the attribute is requested.\n   For some attributes (in this version\
    \ of the specification only\n   internal addresses), multiple requests indicates\
    \ a request that\n   multiple values be assigned.  For these attributes, the number\
    \ of\n   values returned SHOULD NOT exceed the number requested.\n   If the data\
    \ type requested in a CFG_REQUEST is not recognized or not\n   supported, the\
    \ responder MUST NOT return an error type but rather\n   MUST either send a CFG_REPLY\
    \ that MAY be empty or a reply not\n   containing a CFG_REPLY payload at all.\
    \  Error returns are reserved\n   for cases where the request is recognized but\
    \ cannot be performed as\n   requested or the request is badly formatted.\n  \
    \ \"CFG_SET/CFG_ACK\" allows an IKE endpoint to push configuration data\n   to\
    \ its peer.  In this case, the CFG_SET Configuration Payload\n   contains attributes\
    \ the initiator wants its peer to alter.  The\n   responder MUST return a Configuration\
    \ Payload if it accepted any of\n   the configuration data and it MUST contain\
    \ the attributes that the\n   responder accepted with zero-length data.  Those\
    \ attributes that it\n   did not accept MUST NOT be in the CFG_ACK Configuration\
    \ Payload.  If\n   no attributes were accepted, the responder MUST return either\
    \ an\n   empty CFG_ACK payload or a response message without a CFG_ACK\n   payload.\
    \  There are currently no defined uses for the CFG_SET/CFG_ACK\n   exchange, though\
    \ they may be used in connection with extensions based\n   on Vendor IDs.  An\
    \ minimal implementation of this specification MAY\n   ignore CFG_SET payloads.\n\
    \   Extensions via the CP payload SHOULD NOT be used for general purpose\n   management.\
    \  Its main intent is to provide a bootstrap mechanism to\n   exchange information\
    \ within IPsec from IRAS to IRAC.  While it MAY be\n   useful to use such a method\
    \ to exchange information between some\n   Security Gateways (SGW) or small networks,\
    \ existing management\n   protocols such as DHCP [DHCP], RADIUS [RADIUS], SNMP,\
    \ or LDAP [LDAP]\n   should be preferred for enterprise management as well as\
    \ subsequent\n   information exchanges.\n   The Configuration Payload is defined\
    \ as follows:\n                           1                   2              \
    \     3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ! Next Payload  !C! RESERVED    !         Payload Length        !\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      !\
    \   CFG Type    !                    RESERVED                   !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !                                                               !\n   \
    \   ~                   Configuration Attributes                    ~\n      !\
    \                                                               !\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 22:  Configuration Payload Format\n   The payload type\
    \ for the Configuration Payload is forty seven (47).\n   o  CFG Type (1 octet)\
    \ - The type of exchange represented by the\n      Configuration Attributes.\n\
    \             CFG Type       Value\n             ===========    =====\n      \
    \       RESERVED         0\n             CFG_REQUEST      1\n             CFG_REPLY\
    \        2\n             CFG_SET          3\n             CFG_ACK          4\n\
    \      values 5-127 are reserved to IANA.  Values 128-255 are for private\n  \
    \    use among mutually consenting parties.\n   o  RESERVED (3 octets)  - MUST\
    \ be sent as zero; MUST be ignored on\n      receipt.\n   o  Configuration Attributes\
    \ (variable length) - These are type length\n      values specific to the Configuration\
    \ Payload and are defined\n      below.  There may be zero or more Configuration\
    \ Attributes in this\n      payload.\n"
- title: 3.15.1.  Configuration Attributes
  contents:
  - "3.15.1.  Configuration Attributes\n                           1             \
    \      2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      !R|         Attribute Type      !            Length             |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      ~   \
    \                          Value                             ~\n      |      \
    \                                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 23:  Configuration Attribute Format\n   o  Reserved (1\
    \ bit) - This bit MUST be set to zero and MUST be\n      ignored on receipt.\n\
    \   o  Attribute Type (15 bits) - A unique identifier for each of the\n      Configuration\
    \ Attribute Types.\n   o  Length (2 octets) - Length in octets of Value.\n   o\
    \  Value (0 or more octets) - The variable-length value of this\n      Configuration\
    \ Attribute.\n   The following attribute types have been defined:\n          \
    \                            Multi-\n        Attribute Type          Value Valued\
    \ Length\n        ======================= ===== ====== ==================\n  \
    \       RESERVED                 0\n         INTERNAL_IP4_ADDRESS     1    YES*\
    \  0 or 4 octets\n         INTERNAL_IP4_NETMASK     2    NO    0 or 4 octets\n\
    \         INTERNAL_IP4_DNS         3    YES   0 or 4 octets\n         INTERNAL_IP4_NBNS\
    \        4    YES   0 or 4 octets\n         INTERNAL_ADDRESS_EXPIRY  5    NO \
    \   0 or 4 octets\n         INTERNAL_IP4_DHCP        6    YES   0 or 4 octets\n\
    \         APPLICATION_VERSION      7    NO    0 or more\n         INTERNAL_IP6_ADDRESS\
    \     8    YES*  0 or 17 octets\n         RESERVED                 9\n       \
    \  INTERNAL_IP6_DNS        10    YES   0 or 16 octets\n         INTERNAL_IP6_NBNS\
    \       11    YES   0 or 16 octets\n         INTERNAL_IP6_DHCP       12    YES\
    \   0 or 16 octets\n         INTERNAL_IP4_SUBNET     13    YES   0 or 8 octets\n\
    \         SUPPORTED_ATTRIBUTES    14    NO    Multiple of 2\n         INTERNAL_IP6_SUBNET\
    \     15    YES   17 octets\n      * These attributes may be multi-valued on return\
    \ only if multiple\n      values were requested.\n      Types 16-16383 are reserved\
    \ to IANA.  Values 16384-32767 are for\n      private use among mutually consenting\
    \ parties.\n      o  INTERNAL_IP4_ADDRESS, INTERNAL_IP6_ADDRESS - An address on\
    \ the\n         internal network, sometimes called a red node address or\n   \
    \      private address and MAY be a private address on the Internet.\n       \
    \  In a request message, the address specified is a requested\n         address\
    \ (or zero if no specific address is requested).  If a\n         specific address\
    \ is requested, it likely indicates that a\n         previous connection existed\
    \ with this address and the requestor\n         would like to reuse that address.\
    \  With IPv6, a requestor MAY\n         supply the low-order address bytes it\
    \ wants to use.  Multiple\n         internal addresses MAY be requested by requesting\
    \ multiple\n         internal address attributes.  The responder MAY only send\
    \ up to\n         the number of addresses requested.  The INTERNAL_IP6_ADDRESS\
    \ is\n         made up of two fields: the first is a sixteen-octet IPv6\n    \
    \     address and the second is a one-octet prefix-length as defined\n       \
    \  in [ADDRIPV6].\n         The requested address is valid until the expiry time\
    \ defined\n         with the INTERNAL_ADDRESS EXPIRY attribute or there are no\n\
    \         IKE_SAs between the peers.\n      o  INTERNAL_IP4_NETMASK - The internal\
    \ network's netmask.  Only\n         one netmask is allowed in the request and\
    \ reply messages (e.g.,\n         255.255.255.0), and it MUST be used only with\
    \ an\n         INTERNAL_IP4_ADDRESS attribute.\n      o  INTERNAL_IP4_DNS, INTERNAL_IP6_DNS\
    \ - Specifies an address of a\n         DNS server within the network.  Multiple\
    \ DNS servers MAY be\n         requested.  The responder MAY respond with zero\
    \ or more DNS\n         server attributes.\n      o  INTERNAL_IP4_NBNS, INTERNAL_IP6_NBNS\
    \ - Specifies an address of\n         a NetBios Name Server (WINS) within the\
    \ network.  Multiple NBNS\n         servers MAY be requested.  The responder MAY\
    \ respond with zero\n         or more NBNS server attributes.\n      o  INTERNAL_ADDRESS_EXPIRY\
    \ - Specifies the number of seconds that\n         the host can use the internal\
    \ IP address.  The host MUST renew\n         the IP address before this expiry\
    \ time.  Only one of these\n         attributes MAY be present in the reply.\n\
    \      o  INTERNAL_IP4_DHCP, INTERNAL_IP6_DHCP - Instructs the host to\n     \
    \    send any internal DHCP requests to the address contained within\n       \
    \  the attribute.  Multiple DHCP servers MAY be requested.  The\n         responder\
    \ MAY respond with zero or more DHCP server attributes.\n      o  APPLICATION_VERSION\
    \ - The version or application information of\n         the IPsec host.  This\
    \ is a string of printable ASCII characters\n         that is NOT null terminated.\n\
    \      o  INTERNAL_IP4_SUBNET - The protected sub-networks that this\n       \
    \  edge-device protects.  This attribute is made up of two fields:\n         the\
    \ first is an IP address and the second is a netmask.\n         Multiple sub-networks\
    \ MAY be requested.  The responder MAY\n         respond with zero or more sub-network\
    \ attributes.\n      o  SUPPORTED_ATTRIBUTES - When used within a Request, this\n\
    \         attribute MUST be zero-length and specifies a query to the\n       \
    \  responder to reply back with all of the attributes that it\n         supports.\
    \  The response contains an attribute that contains a\n         set of attribute\
    \ identifiers each in 2 octets.  The length\n         divided by 2 (octets) would\
    \ state the number of supported\n         attributes contained in the response.\n\
    \      o  INTERNAL_IP6_SUBNET - The protected sub-networks that this\n       \
    \  edge-device protects.  This attribute is made up of two fields:\n         the\
    \ first is a sixteen-octet IPv6 address and the second is a\n         one-octet\
    \ prefix-length as defined in [ADDRIPV6].  Multiple\n         sub-networks MAY\
    \ be requested.  The responder MAY respond with\n         zero or more sub-network\
    \ attributes.\n      Note that no recommendations are made in this document as\
    \ to how\n      an implementation actually figures out what information to send\
    \ in\n      a reply.  That is, we do not recommend any specific method of an\n\
    \      IRAS determining which DNS server should be returned to a\n      requesting\
    \ IRAC.\n"
- title: 3.16.  Extensible Authentication Protocol (EAP) Payload
  contents:
  - "3.16.  Extensible Authentication Protocol (EAP) Payload\n   The Extensible Authentication\
    \ Protocol Payload, denoted EAP in this\n   memo, allows IKE_SAs to be authenticated\
    \ using the protocol defined\n   in RFC 3748 [EAP] and subsequent extensions to\
    \ that protocol.  The\n   full set of acceptable values for the payload is defined\
    \ elsewhere,\n   but a short summary of RFC 3748 is included here to make this\n\
    \   document stand alone in the common cases.\n                            1 \
    \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       ! Next Payload  !C!  RESERVED   !         Payload Length        !\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   !                                                               !\n      \
    \ ~                       EAP Message                             ~\n       !\
    \                                                               !\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure 24:  EAP Payload Format\n      The payload type\
    \ for an EAP Payload is forty eight (48).\n                            1     \
    \              2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       !     Code      ! Identifier    !           Length              !\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   !     Type      ! Type_Data...\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n\
    \                      Figure 25:  EAP Message Format\n   o  Code (1 octet) indicates\
    \ whether this message is a Request (1),\n      Response (2), Success (3), or\
    \ Failure (4).\n   o  Identifier (1 octet) is used in PPP to distinguish replayed\n\
    \      messages from repeated ones.  Since in IKE, EAP runs over a\n      reliable\
    \ protocol, it serves no function here.  In a response\n      message, this octet\
    \ MUST be set to match the identifier in the\n      corresponding request.  In\
    \ other messages, this field MAY be set\n      to any value.\n   o  Length (2\
    \ octets) is the length of the EAP message and MUST be\n      four less than the\
    \ Payload Length of the encapsulating payload.\n   o  Type (1 octet) is present\
    \ only if the Code field is Request (1) or\n      Response (2).  For other codes,\
    \ the EAP message length MUST be\n      four octets and the Type and Type_Data\
    \ fields MUST NOT be present.\n      In a Request (1) message, Type indicates\
    \ the data being requested.\n      In a Response (2) message, Type MUST either\
    \ be Nak or match the\n      type of the data requested.  The following types\
    \ are defined in\n      RFC 3748:\n      1  Identity\n      2  Notification\n\
    \      3  Nak (Response Only)\n      4  MD5-Challenge\n      5  One-Time Password\
    \ (OTP)\n      6  Generic Token Card\n   o  Type_Data (Variable Length) varies\
    \ with the Type of Request and\n      the associated Response.  For the documentation\
    \ of the EAP\n      methods, see [EAP].\n   Note that since IKE passes an indication\
    \ of initiator identity in\n   message 3 of the protocol, the responder SHOULD\
    \ NOT send EAP Identity\n   requests.  The initiator SHOULD, however, respond\
    \ to such requests if\n   it receives them.\n"
- title: 4.  Conformance Requirements
  contents:
  - "4.  Conformance Requirements\n   In order to assure that all implementations\
    \ of IKEv2 can\n   interoperate, there are \"MUST support\" requirements in addition\
    \ to\n   those listed elsewhere.  Of course, IKEv2 is a security protocol, and\n\
    \   one of its major functions is to allow only authorized parties to\n   successfully\
    \ complete establishment of SAs.  So a particular\n   implementation may be configured\
    \ with any of a number of restrictions\n   concerning algorithms and trusted authorities\
    \ that will prevent\n   universal interoperability.\n   IKEv2 is designed to permit\
    \ minimal implementations that can\n   interoperate with all compliant implementations.\
    \  There are a series\n   of optional features that can easily be ignored by a\
    \ particular\n   implementation if it does not support that feature.  Those features\n\
    \   include:\n      Ability to negotiate SAs through a NAT and tunnel the resulting\n\
    \      ESP SA over UDP.\n      Ability to request (and respond to a request for)\
    \ a temporary IP\n      address on the remote end of a tunnel.\n      Ability\
    \ to support various types of legacy authentication.\n      Ability to support\
    \ window sizes greater than one.\n      Ability to establish multiple ESP and/or\
    \ AH SAs within a single\n      IKE_SA.\n      Ability to rekey SAs.\n   To assure\
    \ interoperability, all implementations MUST be capable of\n   parsing all payload\
    \ types (if only to skip over them) and to ignore\n   payload types that it does\
    \ not support unless the critical bit is set\n   in the payload header.  If the\
    \ critical bit is set in an unsupported\n   payload header, all implementations\
    \ MUST reject the messages\n   containing those payloads.\n   Every implementation\
    \ MUST be capable of doing four-message\n   IKE_SA_INIT and IKE_AUTH exchanges\
    \ establishing two SAs (one for IKE,\n   one for ESP and/or AH).  Implementations\
    \ MAY be initiate-only or\n   respond-only if appropriate for their platform.\
    \  Every implementation\n   MUST be capable of responding to an INFORMATIONAL\
    \ exchange, but a\n   minimal implementation MAY respond to any INFORMATIONAL\
    \ message with\n   an empty INFORMATIONAL reply (note that within the context\
    \ of an\n   IKE_SA, an \"empty\" message consists of an IKE header followed by\
    \ an\n   Encrypted payload with no payloads contained in it).  A minimal\n   implementation\
    \ MAY support the CREATE_CHILD_SA exchange only in so\n   far as to recognize\
    \ requests and reject them with a Notify payload of\n   type NO_ADDITIONAL_SAS.\
    \  A minimal implementation need not be able to\n   initiate CREATE_CHILD_SA or\
    \ INFORMATIONAL exchanges.  When an SA\n   expires (based on locally configured\
    \ values of either lifetime or\n   octets passed), and implementation MAY either\
    \ try to renew it with a\n   CREATE_CHILD_SA exchange or it MAY delete (close)\
    \ the old SA and\n   create a new one.  If the responder rejects the CREATE_CHILD_SA\n\
    \   request with a NO_ADDITIONAL_SAS notification, the implementation\n   MUST\
    \ be capable of instead closing the old SA and creating a new one.\n   Implementations\
    \ are not required to support requesting temporary IP\n   addresses or responding\
    \ to such requests.  If an implementation does\n   support issuing such requests,\
    \ it MUST include a CP payload in\n   message 3 containing at least a field of\
    \ type INTERNAL_IP4_ADDRESS or\n   INTERNAL_IP6_ADDRESS.  All other fields are\
    \ optional.  If an\n   implementation supports responding to such requests, it\
    \ MUST parse\n   the CP payload of type CFG_REQUEST in message 3 and recognize\
    \ a field\n   of type INTERNAL_IP4_ADDRESS or INTERNAL_IP6_ADDRESS.  If it supports\n\
    \   leasing an address of the appropriate type, it MUST return a CP\n   payload\
    \ of type CFG_REPLY containing an address of the requested\n   type.  The responder\
    \ SHOULD include all of the other related\n   attributes if it has them.\n   A\
    \ minimal IPv4 responder implementation will ignore the contents of\n   the CP\
    \ payload except to determine that it includes an\n   INTERNAL_IP4_ADDRESS attribute\
    \ and will respond with the address and\n   other related attributes regardless\
    \ of whether the initiator\n   requested them.\n   A minimal IPv4 initiator will\
    \ generate a CP payload containing only\n   an INTERNAL_IP4_ADDRESS attribute\
    \ and will parse the response\n   ignoring attributes it does not know how to\
    \ use.  The only attribute\n   it MUST be able to process is INTERNAL_ADDRESS_EXPIRY,\
    \ which it must\n   use to bound the lifetime of the SA unless it successfully\
    \ renews the\n   lease before it expires.  Minimal initiators need not be able\
    \ to\n   request lease renewals and minimal responders need not respond to\n \
    \  them.\n   For an implementation to be called conforming to this specification,\n\
    \   it MUST be possible to configure it to accept the following:\n   PKIX Certificates\
    \ containing and signed by RSA keys of size 1024 or\n   2048 bits, where the ID\
    \ passed is any of ID_KEY_ID, ID_FQDN,\n   ID_RFC822_ADDR, or ID_DER_ASN1_DN.\n\
    \   Shared key authentication where the ID passes is any of ID_KEY_ID,\n   ID_FQDN,\
    \ or ID_RFC822_ADDR.\n   Authentication where the responder is authenticated using\
    \ PKIX\n   Certificates and the initiator is authenticated using shared key\n\
    \   authentication.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   While this protocol is designed to minimize disclosure\
    \ of\n   configuration information to unauthenticated peers, some such\n   disclosure\
    \ is unavoidable.  One peer or the other must identify\n   itself first and prove\
    \ its identity first.  To avoid probing, the\n   initiator of an exchange is required\
    \ to identify itself first, and\n   usually is required to authenticate itself\
    \ first.  The initiator can,\n   however, learn that the responder supports IKE\
    \ and what cryptographic\n   protocols it supports.  The responder (or someone\
    \ impersonating the\n   responder) can probe the initiator not only for its identity,\
    \ but\n   using CERTREQ payloads may be able to determine what certificates the\n\
    \   initiator is willing to use.\n   Use of EAP authentication changes the probing\
    \ possibilities somewhat.\n   When EAP authentication is used, the responder proves\
    \ its identity\n   before the initiator does, so an initiator that knew the name\
    \ of a\n   valid initiator could probe the responder for both its name and\n \
    \  certificates.\n   Repeated rekeying using CREATE_CHILD_SA without additional\
    \ Diffie-\n   Hellman exchanges leaves all SAs vulnerable to cryptanalysis of\
    \ a\n   single key or overrun of either endpoint.  Implementers should take\n\
    \   note of this fact and set a limit on CREATE_CHILD_SA exchanges\n   between\
    \ exponentiations.  This memo does not prescribe such a limit.\n   The strength\
    \ of a key derived from a Diffie-Hellman exchange using\n   any of the groups\
    \ defined here depends on the inherent strength of\n   the group, the size of\
    \ the exponent used, and the entropy provided by\n   the random number generator\
    \ used.  Due to these inputs, it is\n   difficult to determine the strength of\
    \ a key for any of the defined\n   groups.  Diffie-Hellman group number two, when\
    \ used with a strong\n   random number generator and an exponent no less than\
    \ 200 bits, is\n   common for use with 3DES.  Group five provides greater security\
    \ than\n   group two.  Group one is for historic purposes only and does not\n\
    \   provide sufficient strength except for use with DES, which is also\n   for\
    \ historic use only.  Implementations should make note of these\n   estimates\
    \ when establishing policy and negotiating security\n   parameters.\n   Note that\
    \ these limitations are on the Diffie-Hellman groups\n   themselves.  There is\
    \ nothing in IKE that prohibits using stronger\n   groups nor is there anything\
    \ that will dilute the strength obtained\n   from stronger groups (limited by\
    \ the strength of the other algorithms\n   negotiated including the prf function).\
    \  In fact, the extensible\n   framework of IKE encourages the definition of more\
    \ groups; use of\n   elliptical curve groups may greatly increase strength using\
    \ much\n   smaller numbers.\n   It is assumed that all Diffie-Hellman exponents\
    \ are erased from\n   memory after use.  In particular, these exponents MUST NOT\
    \ be derived\n   from long-lived secrets like the seed to a pseudo-random generator\n\
    \   that is not erased after use.\n   The strength of all keys is limited by the\
    \ size of the output of the\n   negotiated prf function.  For this reason, a prf\
    \ function whose\n   output is less than 128 bits (e.g., 3DES-CBC) MUST NOT be\
    \ used with\n   this protocol.\n   The security of this protocol is critically\
    \ dependent on the\n   randomness of the randomly chosen parameters.  These should\
    \ be\n   generated by a strong random or properly seeded pseudo-random source\n\
    \   (see [RFC4086]).  Implementers should take care to ensure that use of\n  \
    \ random numbers for both keys and nonces is engineered in a fashion\n   that\
    \ does not undermine the security of the keys.\n   For information on the rationale\
    \ of many of the cryptographic design\n   choices in this protocol, see [SIGMA]\
    \ and [SKEME].  Though the\n   security of negotiated CHILD_SAs does not depend\
    \ on the strength of\n   the encryption and integrity protection negotiated in\
    \ the IKE_SA,\n   implementations MUST NOT negotiate NONE as the IKE integrity\n\
    \   protection algorithm or ENCR_NULL as the IKE encryption algorithm.\n   When\
    \ using pre-shared keys, a critical consideration is how to assure\n   the randomness\
    \ of these secrets.  The strongest practice is to ensure\n   that any pre-shared\
    \ key contain as much randomness as the strongest\n   key being negotiated.  Deriving\
    \ a shared secret from a password,\n   name, or other low-entropy source is not\
    \ secure.  These sources are\n   subject to dictionary and social engineering\
    \ attacks, among others.\n   The NAT_DETECTION_*_IP notifications contain a hash\
    \ of the addresses\n   and ports in an attempt to hide internal IP addresses behind\
    \ a NAT.\n   Since the IPv4 address space is only 32 bits, and it is usually very\n\
    \   sparse, it would be possible for an attacker to find out the internal\n  \
    \ address used behind the NAT box by trying all possible IP addresses\n   and\
    \ trying to find the matching hash.  The port numbers are normally\n   fixed to\
    \ 500, and the SPIs can be extracted from the packet.  This\n   reduces the number\
    \ of hash calculations to 2^32.  With an educated\n   guess of the use of private\
    \ address space, the number of hash\n   calculations is much smaller.  Designers\
    \ should therefore not assume\n   that use of IKE will not leak internal address\
    \ information.\n   When using an EAP authentication method that does not generate\
    \ a\n   shared key for protecting a subsequent AUTH payload, certain man-in-\n\
    \   the-middle and server impersonation attacks are possible [EAPMITM].\n   These\
    \ vulnerabilities occur when EAP is also used in protocols that\n   are not protected\
    \ with a secure tunnel.  Since EAP is a general-\n   purpose authentication protocol,\
    \ which is often used to provide\n   single-signon facilities, a deployed IPsec\
    \ solution that relies on an\n   EAP authentication method that does not generate\
    \ a shared key (also\n   known as a non-key-generating EAP method) can become\
    \ compromised due\n   to the deployment of an entirely unrelated application that\
    \ also\n   happens to use the same non-key-generating EAP method, but in an\n\
    \   unprotected fashion.  Note that this vulnerability is not limited to\n   just\
    \ EAP, but can occur in other scenarios where an authentication\n   infrastructure\
    \ is reused.  For example, if the EAP mechanism used by\n   IKEv2 utilizes a token\
    \ authenticator, a man-in-the-middle attacker\n   could impersonate the web server,\
    \ intercept the token authentication\n   exchange, and use it to initiate an IKEv2\
    \ connection.  For this\n   reason, use of non-key-generating EAP methods SHOULD\
    \ be avoided where\n   possible.  Where they are used, it is extremely important\
    \ that all\n   usages of these EAP methods SHOULD utilize a protected tunnel,\
    \ where\n   the initiator validates the responder's certificate before initiating\n\
    \   the EAP exchange.  Implementers SHOULD describe the vulnerabilities\n   of\
    \ using non-key-generating EAP methods in the documentation of their\n   implementations\
    \ so that the administrators deploying IPsec solutions\n   are aware of these\
    \ dangers.\n   An implementation using EAP MUST also use a public-key-based\n\
    \   authentication of the server to the client before the EAP exchange\n   begins,\
    \ even if the EAP method offers mutual authentication.  This\n   avoids having\
    \ additional IKEv2 protocol variations and protects the\n   EAP data from active\
    \ attackers.\n   If the messages of IKEv2 are long enough that IP-level fragmentation\n\
    \   is necessary, it is possible that attackers could prevent the\n   exchange\
    \ from completing by exhausting the reassembly buffers.  The\n   chances of this\
    \ can be minimized by using the Hash and URL encodings\n   instead of sending\
    \ certificates (see section 3.6).  Additional\n   mitigations are discussed in\
    \ [KPS03].\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   This document defines a number of new field types\
    \ and values where\n   future assignments will be managed by the IANA.\n   The\
    \ following registries have been created by the IANA:\n      IKEv2 Exchange Types\
    \ (section 3.1)\n      IKEv2 Payload Types (section 3.2)\n      IKEv2 Transform\
    \ Types (section 3.3.2)\n          IKEv2 Transform Attribute Types (section 3.3.2)\n\
    \          IKEv2 Encryption Transform IDs (section 3.3.2)\n          IKEv2 Pseudo-random\
    \ Function Transform IDs (section 3.3.2)\n          IKEv2 Integrity Algorithm\
    \ Transform IDs (section 3.3.2)\n          IKEv2 Diffie-Hellman Transform IDs\
    \ (section 3.3.2)\n      IKEv2 Identification Payload ID Types (section 3.5)\n\
    \      IKEv2 Certificate Encodings (section 3.6)\n      IKEv2 Authentication Method\
    \ (section 3.8)\n      IKEv2 Notify Message Types (section 3.10.1)\n         \
    \ IKEv2 Notification IPCOMP Transform IDs (section 3.10.1)\n      IKEv2 Security\
    \ Protocol Identifiers (section 3.3.1)\n      IKEv2 Traffic Selector Types (section\
    \ 3.13.1)\n      IKEv2 Configuration Payload CFG Types (section 3.15)\n      IKEv2\
    \ Configuration Payload Attribute Types (section 3.15.1)\n   Note: When creating\
    \ a new Transform Type, a new registry for it must\n   be created.\n   Changes\
    \ and additions to any of those registries are by expert\n   review.\n"
- title: 7.  Acknowledgements
  contents:
  - "7.  Acknowledgements\n   This document is a collaborative effort of the entire\
    \ IPsec WG.  If\n   there were no limit to the number of authors that could appear\
    \ on an\n   RFC, the following, in alphabetical order, would have been listed:\n\
    \   Bill Aiello, Stephane Beaulieu, Steve Bellovin, Sara Bitan, Matt\n   Blaze,\
    \ Ran Canetti, Darren Dukes, Dan Harkins, Paul Hoffman, John\n   Ioannidis, Charlie\
    \ Kaufman, Steve Kent, Angelos Keromytis, Tero\n   Kivinen, Hugo Krawczyk, Andrew\
    \ Krywaniuk, Radia Perlman, Omer\n   Reingold, and Michael Richardson.  Many other\
    \ people contributed to\n   the design.  It is an evolution of IKEv1, ISAKMP,\
    \ and the IPsec DOI,\n   each of which has its own list of authors.  Hugh Daniel\
    \ suggested the\n   feature of having the initiator, in message 3, specify a name\
    \ for the\n   responder, and gave the feature the cute name \"You Tarzan, Me Jane\"\
    .\n   David Faucher and Valery Smyzlov helped refine the design of the\n   traffic\
    \ selector negotiation.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [ADDGROUP] Kivinen, T. and M. Kojo, \"More Modular\
    \ Exponential (MODP)\n              Diffie-Hellman groups for Internet Key Exchange\
    \ (IKE)\",\n              RFC 3526, May 2003.\n   [ADDRIPV6] Hinden, R. and S.\
    \ Deering, \"Internet Protocol Version 6\n              (IPv6) Addressing Architecture\"\
    , RFC 3513, April 2003.\n   [Bra97]    Bradner, S., \"Key Words for use in RFCs\
    \ to indicate\n              Requirement Levels\", BCP 14, RFC 2119, March 1997.\n\
    \   [EAP]      Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H.\n   \
    \           Levkowetz, \"Extensible Authentication Protocol (EAP)\", RFC\n   \
    \           3748, June 2004.\n   [ESPCBC]   Pereira, R. and R. Adams, \"The ESP\
    \ CBC-Mode Cipher\n              Algorithms\", RFC 2451, November 1998.\n   [Hutt05]\
    \   Huttunen, A., Swander, B., Volpe, V., DiBurro, L., and M.\n              Stenberg,\
    \ \"UDP Encapsulation of IPsec ESP Packets\", RFC\n              3948, January\
    \ 2005.\n   [RFC2434]  Narten, T. and H. Alvestrand, \"Guidelines for Writing\
    \ an\n              IANA Considerations Section in RFCs\", BCP 26, RFC 2434,\n\
    \              October 1998.\n   [RFC3168]  Ramakrishnan, K., Floyd, S., and D.\
    \ Black, \"The Addition\n              of Explicit Congestion Notification (ECN)\
    \ to IP\", RFC\n              3168, September 2001.\n   [RFC3280]  Housley, R.,\
    \ Polk, W., Ford, W., and D. Solo, \"Internet\n              X.509 Public Key\
    \ Infrastructure Certificate and\n              Certificate Revocation List (CRL)\
    \ Profile\", RFC 3280,\n              April 2002.\n   [RFC4301]  Kent, S. and\
    \ K. Seo, \"Security Architecture for the\n              Internet Protocol\",\
    \ RFC 4301, December 2005.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [DES]      ANSI X3.106, \"American National\
    \ Standard for Information\n              Systems-Data Link Encryption\", American\
    \ National Standards\n              Institute, 1983.\n   [DH]       Diffie, W.,\
    \ and Hellman M., \"New Directions in\n              Cryptography\", IEEE Transactions\
    \ on Information Theory, V.\n              IT-22, n. 6, June 1977.\n   [DHCP]\
    \     Droms, R., \"Dynamic Host Configuration Protocol\", RFC\n              2131,\
    \ March 1997.\n   [DSS]      NIST, \"Digital Signature Standard\", FIPS 186, National\n\
    \              Institute of Standards and Technology, U.S. Department of\n   \
    \           Commerce, May, 1994.\n   [EAPMITM]  Asokan, N., Nierni, V., and Nyberg,\
    \ K., \"Man-in-the-Middle\n              in Tunneled Authentication Protocols\"\
    ,\n              http://eprint.iacr.org/2002/163, November 2002.\n   [HC98]  \
    \   Harkins, D. and D. Carrel, \"The Internet Key Exchange\n              (IKE)\"\
    , RFC 2409, November 1998.\n   [IDEA]     Lai, X., \"On the Design and Security\
    \ of Block Ciphers,\"\n              ETH Series in Information Processing, v.\
    \ 1, Konstanz:\n              Hartung-Gorre Verlag, 1992.\n   [IPCOMP]   Shacham,\
    \ A., Monsour, B., Pereira, R., and M.  Thomas, \"IP\n              Payload Compression\
    \ Protocol (IPComp)\", RFC 3173,\n              September 2001.\n   [KPS03]  \
    \  Kaufman, C., Perlman, R., and Sommerfeld, B., \"DoS\n              protection\
    \ for UDP-based protocols\", ACM Conference on\n              Computer and Communications\
    \ Security, October 2003.\n   [KBC96]    Krawczyk, H., Bellare, M., and R. Canetti,\
    \ \"HMAC: Keyed-\n              Hashing for Message Authentication\", RFC 2104,\
    \ February\n              1997.\n   [LDAP]     Wahl, M., Howes, T., and S  Kille,\
    \ \"Lightweight Directory\n              Access Protocol (v3)\", RFC 2251, December\
    \ 1997.\n   [MD5]      Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321,\n\
    \              April 1992.\n   [MSST98]   Maughan, D., Schertler, M., Schneider,\
    \ M., and J. Turner,\n              \"Internet Security Association and Key Management\
    \ Protocol\n              (ISAKMP)\", RFC 2408, November 1998.\n   [Orm96]   \
    \ Orman, H., \"The OAKLEY Key Determination Protocol\", RFC\n              2412,\
    \ November 1998.\n   [PFKEY]    McDonald, D., Metz, C., and B. Phan, \"PF_KEY\
    \ Key\n              Management API, Version 2\", RFC 2367, July 1998.\n   [PKCS1]\
    \    Jonsson, J. and B. Kaliski, \"Public-Key Cryptography\n              Standards\
    \ (PKCS) #1: RSA Cryptography Specifications\n              Version 2.1\", RFC\
    \ 3447, February 2003.\n   [PK01]     Perlman, R., and Kaufman, C., \"Analysis\
    \ of the IPsec key\n              exchange Standard\", WET-ICE Security Conference,\
    \ MIT,2001,\n              http://sec.femto.org/wetice-2001/papers/radia-paper.pdf.\n\
    \   [Pip98]    Piper, D., \"The Internet IP Security Domain Of\n             \
    \ Interpretation for ISAKMP\", RFC 2407, November 1998.\n   [RADIUS]   Rigney,\
    \ C., Willens, S., Rubens, A., and W. Simpson,\n              \"Remote Authentication\
    \ Dial In User Service (RADIUS)\", RFC\n              2865, June 2000.\n   [RFC4086]\
    \  Eastlake, D., 3rd, Schiller, J., and S. Crocker,\n              \"Randomness\
    \ Requirements for Security\", BCP 106, RFC 4086,\n              June 2005.\n\
    \   [RFC1958]  Carpenter, B., \"Architectural Principles of the Internet\",\n\
    \              RFC 1958, June 1996.\n   [RFC2401]  Kent, S. and R. Atkinson, \"\
    Security Architecture for the\n              Internet Protocol\", RFC 2401, November\
    \ 1998.\n   [RFC2474]  Nichols, K., Blake, S., Baker, F., and D. Black,\n    \
    \          \"Definition of the Differentiated Services Field (DS\n           \
    \   Field) in the IPv4 and IPv6 Headers\", RFC 2474, December\n              1998.\n\
    \   [RFC2475]  Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z.,\n    \
    \          and W. Weiss, \"An Architecture for Differentiated\n              Service\"\
    , RFC 2475, December 1998.\n   [RFC2522]  Karn, P. and W. Simpson, \"Photuris:\
    \ Session-Key Management\n              Protocol\", RFC 2522, March 1999.\n  \
    \ [RFC2775]  Carpenter, B., \"Internet Transparency\", RFC 2775, February\n  \
    \            2000.\n   [RFC2983]  Black, D., \"Differentiated Services and Tunnels\"\
    , RFC\n              2983, October 2000.\n   [RFC3439]  Bush, R. and D. Meyer,\
    \ \"Some Internet Architectural\n              Guidelines and Philosophy\", RFC\
    \ 3439, December 2002.\n   [RFC3715]  Aboba, B. and W. Dixon, \"IPsec-Network\
    \ Address Translation\n              (NAT) Compatibility Requirements\", RFC 3715,\
    \ March 2004.\n   [RFC4302]  Kent, S., \"IP Authentication Header\", RFC 4302,\
    \ December\n              2005.\n   [RFC4303]  Kent, S., \"IP Encapsulating Security\
    \ Payload (ESP)\", RFC\n              4303, December 2005.\n   [RSA]      Rivest,\
    \ R., Shamir, A., and Adleman, L., \"A Method for\n              Obtaining Digital\
    \ Signatures and Public-Key\n              Cryptosystems\", Communications of\
    \ the ACM, v. 21, n. 2,\n              February 1978.\n   [SHA]      NIST, \"\
    Secure Hash Standard\", FIPS 180-1, National\n              Institute of Standards\
    \ and Technology, U.S. Department of\n              Commerce, May 1994.\n   [SIGMA]\
    \    Krawczyk, H., \"SIGMA: the `SIGn-and-MAc' Approach to\n              Authenticated\
    \ Diffie-Hellman and its Use in the IKE\n              Protocols\", in Advances\
    \ in Cryptography - CRYPTO 2003\n              Proceedings, LNCS 2729, Springer,\
    \ 2003.  Available at:\n              http://www.informatik.uni-trier.de/~ley/db/conf/\n\
    \              crypto/crypto2003.html.\n   [SKEME]    Krawczyk, H., \"SKEME: A\
    \ Versatile Secure Key Exchange\n              Mechanism for Internet\", from\
    \ IEEE Proceedings of the 1996\n              Symposium on Network and Distributed\
    \ Systems Security.\n   [X.501]    ITU-T Recommendation X.501: Information Technology\
    \ - Open\n              Systems Interconnection - The Directory: Models, 1993.\n\
    \   [X.509]    ITU-T Recommendation X.509 (1997 E): Information\n            \
    \  Technology - Open Systems Interconnection - The Directory:\n              Authentication\
    \ Framework, June 1997.\n"
- title: 'Appendix A: Summary of changes from IKEv1'
  contents:
  - "Appendix A: Summary of changes from IKEv1\n   The goals of this revision to IKE\
    \ are:\n   1) To define the entire IKE protocol in a single document, replacing\n\
    \   RFCs 2407, 2408, and 2409 and incorporating subsequent changes to\n   support\
    \ NAT Traversal, Extensible Authentication, and Remote Address\n   acquisition;\n\
    \   2) To simplify IKE by replacing the eight different initial exchanges\n  \
    \ with a single four-message exchange (with changes in authentication\n   mechanisms\
    \ affecting only a single AUTH payload rather than\n   restructuring the entire\
    \ exchange) see [PK01];\n   3) To remove the Domain of Interpretation (DOI), Situation\
    \ (SIT), and\n   Labeled Domain Identifier fields, and the Commit and Authentication\n\
    \   only bits;\n   4) To decrease IKE's latency in the common case by making the\
    \ initial\n   exchange be 2 round trips (4 messages), and allowing the ability\
    \ to\n   piggyback setup of a CHILD_SA on that exchange;\n   5) To replace the\
    \ cryptographic syntax for protecting the IKE\n   messages themselves with one\
    \ based closely on ESP to simplify\n   implementation and security analysis;\n\
    \   6) To reduce the number of possible error states by making the\n   protocol\
    \ reliable (all messages are acknowledged) and sequenced.\n   This allows shortening\
    \ CREATE_CHILD_SA exchanges from 3 messages to\n   2;\n   7) To increase robustness\
    \ by allowing the responder to not do\n   significant processing until it receives\
    \ a message proving that the\n   initiator can receive messages at its claimed\
    \ IP address, and not\n   commit any state to an exchange until the initiator\
    \ can be\n   cryptographically authenticated;\n   8) To fix cryptographic weaknesses\
    \ such as the problem with\n   symmetries in hashes used for authentication documented\
    \ by Tero\n   Kivinen;\n   9) To specify Traffic Selectors in their own payloads\
    \ type rather\n   than overloading ID payloads, and making more flexible the Traffic\n\
    \   Selectors that may be specified;\n   10) To specify required behavior under\
    \ certain error conditions or\n   when data that is not understood is received,\
    \ to make it easier to\n   make future revisions that do not break backward compatibility;\n\
    \   11) To simplify and clarify how shared state is maintained in the\n   presence\
    \ of network failures and Denial of Service attacks; and\n   12) To maintain existing\
    \ syntax and magic numbers to the extent\n   possible to make it likely that implementations\
    \ of IKEv1 can be\n   enhanced to support IKEv2 with minimum effort.\n"
- title: 'Appendix B: Diffie-Hellman Groups'
  contents:
  - "Appendix B: Diffie-Hellman Groups\n   There are two Diffie-Hellman groups defined\
    \ here for use in IKE.\n   These groups were generated by Richard Schroeppel at\
    \ the University\n   of Arizona.  Properties of these primes are described in\
    \ [Orm96].\n   The strength supplied by group one may not be sufficient for the\n\
    \   mandatory-to-implement encryption algorithm and is here for historic\n   reasons.\n\
    \   Additional Diffie-Hellman groups have been defined in [ADDGROUP].\n"
- title: B.1.  Group 1 - 768 Bit MODP
  contents:
  - "B.1.  Group 1 - 768 Bit MODP\n   This group is assigned id 1 (one).\n   The prime\
    \ is: 2^768 - 2 ^704 - 1 + 2^64 * { [2^638 pi] + 149686 } Its\n   hexadecimal\
    \ value is:\n        FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08\n\
    \        8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B\n    \
    \    302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9\n        A63A3620\
    \ FFFFFFFF FFFFFFFF\n   The generator is 2.\n"
- title: B.2.  Group 2 - 1024 Bit MODP
  contents:
  - "B.2.  Group 2 - 1024 Bit MODP\n   This group is assigned id 2 (two).\n   The\
    \ prime is 2^1024 - 2^960 - 1 + 2^64 * { [2^894 pi] + 129093 }.\n   Its hexadecimal\
    \ value is:\n        FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 29024E08\n\
    \        8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD EF9519B3 CD3A431B\n    \
    \    302B0A6D F25F1437 4FE1356D 6D51C245 E485B576 625E7EC6 F44C42E9\n        A637ED6B\
    \ 0BFF5CB6 F406B7ED EE386BFB 5A899FA5 AE9F2411 7C4B1FE6\n        49286651 ECE65381\
    \ FFFFFFFF FFFFFFFF\n   The generator is 2.\n"
- title: Editor's Address
  contents:
  - "Editor's Address\n   Charlie Kaufman\n   Microsoft Corporation\n   1 Microsoft\
    \ Way\n   Redmond, WA 98052\n   Phone: 1-425-707-3335\n   EMail: charliek@microsoft.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
