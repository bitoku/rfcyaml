- title: __initial_text__
  contents:
  - "         STATUS REPORT ON PROPOSED DATA RECONFIGURATION SERVICE\n         Alternate\
    \ Specification of Form Machine Syntax    8\n           Restrictions and Interpretations\
    \ of\n             Term Functions ...........................   14\n         Term\
    \ and Rule Sequencing .....................   16\n    IV.  EXAMPLES .....................................\
    \   16\n         Remarks ......................................   16\n       \
    \  Field Insertion ..............................   17\n         Deletion .....................................\
    \   17\n         Variable Length Records ......................   17\n       \
    \  String Length Computation ....................   18\n         Transposition\
    \ ................................   18\n         Character Packing and Unpacking\
    \ ..............   18\n     V.  PROPOSED USES OF DATA RECONFIGURATION SERVICE\
    \    19\n    VI.  IMPLEMENTATION PLANS .........................   20\n   Appendix\
    \ A .........................................   21\n         Note 1 to the DRS\
    \ Working Group ..............   21\n         Note 2 to the DRS Working Group\
    \ ..............   22\n"
- title: I.  INTRODUCTION
  contents:
  - "I.  INTRODUCTION\n   PURPOSE OF THIS RFC\n   The purpose of this RFC is to describe,\
    \ in part, a proposed Network\n   experiment and to solicit comments on any aspect\
    \ of the experiment.\n   The experiment involves a software mechanism to reformat\
    \ Network data\n   streams.  The mechanism can be adapted to numerous Network\n\
    \   application programs.  We hope that the results of the experiment\n   will\
    \ lead to a further standard service that embodies the principles\n   described\
    \ in this RFC.   We would like comments on the\n   appropriateness of this work\
    \ as a Network experiment and also\n   comments on particular Network data reformatting\
    \ needs that could not\n   easily be accomplished using these techniques.\n"
- title: MOTIVATION
  contents:
  - "MOTIVATION\n   Application programs require specific data I/O formats yet the\n\
    \   formats are different from program to program.  We take the position\n   that\
    \ the Network should adapt to the individual program requirements\n   rather than\
    \ changing each program to comply with a standard.  This\n   position doesn't\
    \ preclude the use of standards that describe the\n   formats of regular message\
    \ contents; it is merely an interpretation\n   of a standard as being a desirable\
    \ mode of operation but not a\n   necessary one.\n   In addition to differing\
    \ program requirements, a format mismatch\n   problem occurs where users wish\
    \ to employ many different kinds of\n   consoles to attach to a single service\
    \ program.  It is desirable to\n   have the Network adapt to individual console\
    \ configurations rather\n   than requiring unique software packages for each console\n\
    \   transformation.\n   One approach to providing adaptation is for those sites\
    \ with\n   substantial computing power to offer a data reconfiguration service;\n\
    \   a proposed example of such a service is described here.\n   The envisioned\
    \ modus operandi of the service is that an applications\n   programmer defines\
    \ _forms_ that describe data reconfigurations.  The\n   service stores the forms\
    \ by name.  At a later time, a user (perhaps a\n   non-programmer) employs the\
    \ service to accomplish a particular\n   transformation of a Network data stream,\
    \ simply by calling the form\n   by name.\n   We have attempted to provide a notation\
    \ tailored to some specifically\n   needed instances of data reformatting while\
    \ keeping the notation and\n   its underlying implementation within some utility\
    \ range that is\n   bounded on the lower end by a notation expressive enough to\
    \ make the\n   experimental service useful, and that is bounded on the upper end\
    \ by\n   a notation short of a general purpose programming language.\n"
- title: II.  OVERVIEW OF THE DATA RECONFIGURATION SERVICE
  contents:
  - 'II.  OVERVIEW OF THE DATA RECONFIGURATION SERVICE

    '
- title: ELEMENTS OF THE DATA RECONFIGURATION SERVICE
  contents:
  - "ELEMENTS OF THE DATA RECONFIGURATION SERVICE\n   An implementation of the Data\
    \ Reconfiguration Service (DRS) includes\n   modules for connection protocols,\
    \ a handler of some requests that can\n   be made of the service, a compiler and/or\
    \ interpreter (called the\n   Form Machine) to act on those requests, and a file\
    \ storage module for\n   saving and retrieving definitions of data reconfigurations\
    \ (forms).\n   This section highlights connection protocols and requests.  The\
    \ next\n   section covers the Form Machine language in some detail.  File\n  \
    \ storage is not described in this document because it is transparent\n   to the\
    \ use of the service and its implementation is different at each\n   DRS host.\n"
- title: CONCEPTUAL NETWORK CONNECTIONS
  contents:
  - "CONCEPTUAL NETWORK CONNECTIONS\n   There are three conceptual Network connections\
    \ to the DRS, see Fig.\n   1.\n         1)  The control connection (CC) is between\
    \ an originating user\n             and the DRS.  A form specifying data reconfiguration\
    \ is\n             defined over this connection and is applied to data passing\n\
    \             over the two connections described below.\n         2)  The user\
    \ connection (UC) is between a user process and the\n             DRS.\n     \
    \    3)  The server connection (SC) is between the DRS and the\n             serving\
    \ process.\n   Since the goal is to adapt the Network to user and server processes,\n\
    \   a minimum of requirements are imposed on the UC and SC.\n      +-------------+\
    \   CC   +-----------+   SC   +-----------+\n      | ORIGINATING +--------+  \
    \  DRS    +--------+ SERVER    |\n      |    USER     |   ^    |           | \
    \   ^   | PROCESS   |\n      +-------------+   |    +------+----+    |   +-----------+\n\
    \                        |          /          |\n                     Telnet\
    \       / <------ Simplex or Duplex\n                    Protocol   UC/      \
    \      Connections\n                   Connection   /\n                      \
    \         /\n                        +-----+-----+\n                        |\
    \ USER      |\n                        | PROCESS   |\n                       \
    \ +-----------+\n                Figure 1.  DRS Network Connections\n"
- title: CONNECTION PROTOCOLS AND MESSAGE FORMATS
  contents:
  - "CONNECTION PROTOCOLS AND MESSAGE FORMATS\n   Over a control connection the dialog\
    \ is directly between an\n   originating user and the DRS.  Here the user is defining\
    \ forms or\n   assigning forms to connections for reformatting.\n   The user connects\
    \ to the DRS via the initial connection protocol\n   (ICP) specified in NWG/RFC\
    \ #80, version 1.  Rather than going through\n   a logger, the user calls on a\
    \ particular socket on which the DRS\n   always listens.  DRS switches the user\
    \ to another socket pair.\n   Messages sent over a control connection are of the\
    \ types and formats\n   to be specified for TELNET.  Thus, a user at a terminal\
    \ should be\n   able to connect to a DRS via his local TELNET, for example, as\
    \ shown\n   in Fig.  2.\n                                          +--------------+\n\
    \                         +--------+  CC   |              |\n                \
    \ +-------+ TELNET +-------+     DRS      |\n                 |       +--------+\
    \       |              |\n                 |                        +--------------+\n\
    \      +----------+---------+\n      |      USER          |\n      |(TERMINAL\
    \ OR PROGRAM|\n      +--------------------+\n           Figure 2.  A TELNET Connection\
    \ to DRS\n   When a user connects to DRS he supplies a six-character user ID (UID)\n\
    \   as a qualifier to guarantee the uniqueness of his form names.  He\n   will\
    \ have (at least) the following commands:\n         1.  DEFFORM (name)\n     \
    \    2.  ENDFORM (name)\n             These two commands define a form, the text\
    \ of which is\n             chronologically entered between them.  The (name)\
    \ is six\n             characters.  The form is stored in the DRS local file\n\
    \             system.\n         3.  PURGE (name)\n             The named form,\
    \ as qualified by the current UID, is purged\n             from the DRS file system.\n\
    \         4.  LISTNAMES (UID)\n             The unqualified names of all forms\
    \ assigned to UID are\n             returned.\n         5.  LISTFORM (name)\n\
    \             The source text of a named form is returned.\n         6.  DUPLEXCONNECT\
    \ (user site, user send, user receive,\n                        user method, server\
    \ site, server\n                        send, server receive, server method,\n\
    \                        user-to-server form, server-to-user form)\n         7.\
    \  SIMPLEXCONNECT (send site, send socket, send\n                          method,\
    \ receive site, receive\n                          socket, receive method, form)\n\
    \   Either one, both, or neither of the two parties specified in 6 or 7\n   may\
    \ be at the same host as the party issuing the request.  Sites and\n   sockets\
    \ specify user and server for the connection.  Method indicates\n   the way in\
    \ which the connection is established.  Three options are\n   provided:\n    \
    \    1)  Site/socket already connected to DRS as a dummy\n            control\
    \ connection.  (A dummy control connection\n            should not also be the\
    \ real control connection.)\n        2)  Connect via standard ICP. (Only for command\
    \ no. 6.)\n        3)  Connect directly via STR, RTS.\n"
- title: EXAMPLE CONNECTION CONFIGURATIONS
  contents:
  - "EXAMPLE CONNECTION CONFIGURATIONS\n   There are basically two modes of DRS operation:\
    \ 1) the user wishes to\n   establish a DRS UC/SC connection(s) between two programs\
    \ and 2) the\n   user wants to establish the same connection(s) where he (his\n\
    \   terminal) is at the end of the UC or the SC.  The latter case is\n   appropriate\
    \ when the user wishes to interact from his terminal with\n   the serving process\
    \ (e.g., a logger).\n   In the first case (Fig. 1, where the originating user\
    \ is either a\n   terminal or a program) the user issues the appropriate CONNECT\n\
    \   command.  The UC/SC can be simplex or duplex.\n   The second case has two\
    \ possible configurations, shown in Figs. 3 and\n   4.\n               +--------+\
    \  CC  +--------+      +------+\n               |        +------+        |  SC\
    \  |      |\n     +------+ /| TELNET |  UC  |  DRS   +------+  SP  |\n     | \
    \     |/ |        +------+        |      |      |\n     | USER | /+--------+ \
    \     +--------+      +------+\n     |      |/\n     +------+\n            Figure\
    \ 3.  Use of Dummy Control Connection\n               +--------+\n     +------+\
    \ /|  USER  |  CC  +--------+      +------+\n     |      |/ |  SIDE  +------+\
    \        |  SC  |      |\n     | USER |  +--------+  UC  |  DRS   +------+  SP\
    \  |\n     |      |\\ | SERVING+------+        |      |      |\n     +------+\
    \ \\|  SIDE  |      +--------+      +------+\n               +--------+\n    \
    \        Figure 4.  Use of Server TELNET\n   In Fig. 3 the user instructs his\
    \ TELNET to make two duplex\n   connections to DRS.  One is used for control information\
    \ (the CC) and\n   the other is a dummy.  When he issues the CONNECT he references\
    \ the\n   dummy duplex connection (UC) using the \"already connected\" option.\n\
    \   In Fig. 4 the user has his TELNET (user side) call the DRS.  When he\n   issues\
    \ the CONNECT the DRS calls the TELNET (server side) which\n   accepts the call\
    \ on behalf of the console.  This distinction is known\n   only to the user since\
    \ to the DRS the configuration in Fig. 4 appears\n   identical to that in Fig.\
    \ 1.  Two points should be noted:\n        1)  TELNET protocol is needed only\
    \ to define forms and direct\n            connections.  It is not required for\
    \ the using and serving\n            processes.\n        2)  The using and serving\
    \ processes need only a minimum of\n            modification for Network use,\
    \ i.e., an NCP interface.\n"
- title: III.  THE FORM MACHINE
  contents:
  - 'III.  THE FORM MACHINE

    '
- title: INPUT/OUTPUT STREAMS AND FORMS
  contents:
  - "INPUT/OUTPUT STREAMS AND FORMS\n   This section describes the syntax and semantics\
    \ of forms that specify\n   the data reconfigurations.  The Form Machine gets\
    \ an input stream,\n   reformats the input stream according to a form describing\
    \ the\n   reconfiguration, and emits the reformatted data as an output stream.\n\
    \   In reading this section it will be helpful to envision the\n   application\
    \ of a form to the data stream as depicted in Fig. 5.  An\n   input stream pointer\
    \ identifies the position of data (in the input\n   stream) that is being analyzed\
    \ at any given time by a part of the\n   form.  Likewise, an output stream pointer\
    \ locates data being emitted\n   in the output stream.\n       /\\/\\        \
    \                                          /\\/\\\n  ^    |  |               \
    \      FORM                         |  |   ^\n  |    |  |                -----------------\
    \                 |  |   |\n  |    |  |            +-  -----------------  -+ \
    \            |  |   |\n  |    |  |            |   CURRENT PART OF     |      \
    \       |  |   |\n"
- title: INPUT  |  |<= CURRENT <    -----------------    > CURRENT => |  | OUTPUT
  contents:
  - 'INPUT  |  |<= CURRENT <    -----------------    > CURRENT => |  | OUTPUT

    '
- title: STREAM |  |   POINTER  |   FORM BEING APPLIED  |  POINTER    |  | STREAM
  contents:
  - "STREAM |  |   POINTER  |   FORM BEING APPLIED  |  POINTER    |  | STREAM\n  \
    \     |  |            +-  -----------------  -+             |  |\n       |  |\
    \                -----------------                 |  |\n       |  |         \
    \       -----------------                 |  |\n       |  |                -----------------\
    \                 |  |\n       \\/\\/                                        \
    \          \\/\\/\n              Figure 5.  Application of Form to Data Streams\n"
- title: FORM MACHINE BNF SYNTAX
  contents:
  - "FORM MACHINE BNF SYNTAX\n   form           ::=  rule | rule form\n   rule   \
    \        ;;=  label  inputstream  outputstream ;\n   label          ::=  INTEGER\
    \ | <null>\n   inputstream    ::=  terms | <null>\n   terms          ::=  term\
    \ | terms , term\n   outputstream   ::=  : terms | <null>\n   term           ::=\
    \  identifier | identifier  descriptor |\n                       descriptor |\
    \ comparator\n   identifier     ::=  an alpha character followed by 0 to 3\n \
    \                      alphamerics\n   descriptor     ::=  (replicationexpression\
    \ , datatype ,\n                       valueexpression , lengthexpression  control)\n\
    \   comparator     ::=  (value  connective  value  control)  |\n             \
    \          (identifier .<=>. control)\n   replicationexpression  ::=  arithmeticexpression\
    \ | <null>\n   datatype       ::=  B | O | X | E | A\n   valueexpression  ::=\
    \  value | <null>\n   lengthexpression  ::=  # | arithmeticexpression | <null>\n\
    \   connective     ::=  .LE. | .LT. | .GE. | .GT. | .EQ. | .NE.\n   value    \
    \      ::=  literal | arithmeticexpression\n   arithmeticexpression  ::=  primary\
    \ | primary operator\n                              arithmeticexpression\n   primary\
    \        ::=  identifier | L(identifier) | V(identifier) |\n                 \
    \      INTEGER\n   operator       ::=  + | - | * | /\n   literal        ::=  literaltype\
    \ \"string\"\n   literaltype    ::=  B | O | X | E | A\n   string         ::=\
    \  from 0 to 256 characters\n   control        ::=  :  options | <null>\n   options\
    \        ::=  S(where) | F(where) | U(where) |\n                       S(where)\
    \ , F(where) |\n                       F(where) , S(where)\n   where         \
    \ ::=  arithmeticexpression | R(arithmeticexpression)\n"
- title: ALTERNATE SPECIFICATION OF FORM MACHINE SYNTAX
  contents:
  - "ALTERNATE SPECIFICATION OF FORM MACHINE SYNTAX\n                            \
    \       infinity\n"
- title: form                    ::=  {rule}
  contents:
  - "form                    ::=  {rule}\n                                   1\n \
    \                                     1         1          1\n"
- title: rule                    ::=  {INTEGER}   {terms}   {:terms} ;
  contents:
  - "rule                    ::=  {INTEGER}   {terms}   {:terms} ;\n             \
    \                         0         0          0\n                           \
    \              infinity\n"
- title: terms                   ::=  term {,term}
  contents:
  - "terms                   ::=  term {,term}\n                                 \
    \        0\n                                                      1\n"
- title: term                    ::=  identifier | {identifier}   descriptor
  contents:
  - "term                    ::=  identifier | {identifier}   descriptor\n       \
    \                                               0\n                          \
    \   | comparator\n                                                    1\n"
- title: descriptor              ::=  ({arithmeticexpression}  , datatype ,
  contents:
  - "descriptor              ::=  ({arithmeticexpression}  , datatype ,\n        \
    \                                            0\n                             \
    \       1                     1           1\n                             {value}\
    \ ,  {lengthexpression}  {:options}\n                                    0   \
    \                  0           0\n                                           \
    \                      1\n"
- title: comparator              ::=  (value  connective  value {:options} ) |
  contents:
  - "comparator              ::=  (value  connective  value {:options} ) |\n     \
    \                                                            0\n             \
    \                                                 1\n                        \
    \     (identifier .<=. value {:options} )\n                                  \
    \                            0\n"
- title: connective              ::=  .LE. | .LT. | .GE. | .GT. | .EQ. | .NE.
  contents:
  - 'connective              ::=  .LE. | .LT. | .GE. | .GT. | .EQ. | .NE.

    '
- title: 'lengthexpression        ::=  # | arithmeticexpression'
  contents:
  - 'lengthexpression        ::=  # | arithmeticexpression

    '
- title: datatype                ::=  B | O | X | E | A
  contents:
  - 'datatype                ::=  B | O | X | E | A

    '
- title: value                   ::=  literal | arithmeticexpression
  contents:
  - "value                   ::=  literal | arithmeticexpression\n               \
    \                                          infinity\n"
- title: arithmeticexpression    ::=  primary  {operator  primary}
  contents:
  - "arithmeticexpression    ::=  primary  {operator  primary}\n                 \
    \                                        0\n"
- title: operator                ::= + | - | * | /
  contents:
  - 'operator                ::= + | - | * | /

    '
- title: primary                 ::=  identifier | L(identifier) |
  contents:
  - "primary                 ::=  identifier | L(identifier) |\n                 \
    \            V(identifier) | INTEGER\n                                       \
    \               256\n"
- title: literal                 ::=  literaltype  "{CHARACTER}   "
  contents:
  - "literal                 ::=  literaltype  \"{CHARACTER}   \"\n              \
    \                                        0\n"
- title: literaltype             ::=  B | O | X | A | E
  contents:
  - "literaltype             ::=  B | O | X | A | E\n                            \
    \                     1\n"
- title: options                 ::=  S(where) {,F(where)}  |
  contents:
  - "options                 ::=  S(where) {,F(where)}  |\n                      \
    \                           0\n                                              \
    \   1\n                             F(where) {,S(where)}  | U(where)\n       \
    \                                          0\n"
- title: where                   ::=  arithmeticexpression |
  contents:
  - "where                   ::=  arithmeticexpression |\n                       \
    \      R(arithmeticexpression)\n                                             \
    \        3\n"
- title: identifier              ::=  ALPHABETIC  {ALPHAMERIC}
  contents:
  - "identifier              ::=  ALPHABETIC  {ALPHAMERIC}\n                     \
    \                                0\n"
- title: FORMS
  contents:
  - "FORMS\n   A form is an ordered set of rules.\n         form ::=  rule | rule\
    \ form\n   The current rule is applied to the current position of the input\n\
    \   stream.  If the (input stream part of a) rule fails to correctly\n   describe\
    \ the contents of the current input then another rule is made\n   current and\
    \ applied to the current position of the input stream.  The\n   next rule to be\
    \ made current is either explicitly specified by the\n   current term in the current\
    \ rule or it is the next sequential rule by\n   default.  Flow of control is more\
    \ fully described under TERM AND RULE\n   SEQUENCING.\n   If the (input stream\
    \ part of a) rule succeeds in correctly describing\n   the current input stream,\
    \ then some data may be emitted at the\n   current position in the output stream\
    \ according to the rule.  The\n   input and output stream pointers are advanced\
    \ over the described and\n   emitted data, respectively, and the next rule is\
    \ applied to the now\n   current position of the input stream.\n   Application\
    \ of the form is terminated when an explicit return\n   (R(arithmeticexpression))\
    \ is encountered in a rule.  The user and\n   server connections are closed and\
    \ the return code\n   (arithmeticexpression) is sent to the originating user.\n"
- title: RULES
  contents:
  - "RULES\n   A rule is a replacement, comparison, and/or an assignment operation\n\
    \   of the form shown below.\n         rule ::= label  inputstream  outputstream\
    \ ;\n   A label is the name of a rule and it exists so that the rule may be\n\
    \   referenced elsewhere in the form for explicit rule transfer of\n   control.\
    \  Labels are of the form below.\n         label ::=  INTEGER | <null>\n   The\
    \ optional integer labels are in the range 0 >= INTEGER >= 9999.\n   The rules\
    \ need not be labeled in ascending numerical order.\n"
- title: TERMS
  contents:
  - "TERMS\n   The inputstream (describing the input stream to be matched) and the\n\
    \   outputstream (describing data to be emitted in the output stream)\n   consist\
    \ of zero or more terms and are of the form shown below.\n         inputstream\
    \   ::=  terms | <null>\n         outputstream  ::=  :terms | <null>\n       \
    \  terms         ::=  term | terms , term\n   Terms are of one of four formats\
    \ as indicated below.\n         term ::=  identifier | identifier  descriptor\
    \ |\n                   descriptor | comparator\n"
- title: Term Format 1
  contents:
  - "Term Format 1\n   The first term format is shown below.\n         identifier\n\
    \   The identifier is a symbolic reference to a previously identified\n   term\
    \ (term format 2) in the form.  It takes on the same attributes\n   (value, length,\
    \ type) as the term by that name.  Term format 1 is\n   normally used to emit\
    \ data in the output stream.\n   Identifiers are formed by an alpha character\
    \ followed by 0 to 3\n   alphameric characters.\n"
- title: Term Format 2
  contents:
  - "Term Format 2\n   The second term format is shown below.\n         identifier\
    \ descriptor\n   Term format 2 is generally used as an input stream term but can\
    \ be\n   used as an output stream term.\n   A descriptor is defined as shown below.\n\
    \         descriptor ::= (replicationexpression, datatype,\n                 \
    \       valueexpression, lengthexpression\n                        control)\n\
    \   The identifier is the symbolic name of the term in the usual\n   programming\
    \ language sense.  It takes on the type, length, and value\n   attributes of the\
    \ term and it may be referenced elsewhere in the\n   form.\n   The replication\
    \ expression is defined below.\n         replicationexpression ::= arithmeticexpression\
    \ | <null>\n         arithmeticexpression ::= primary | primary operator\n   \
    \                                    arithmeticexpression\n         operator ::=\
    \ + | - | * | /\n         primary ::= identifier | L(identifier) | V(identifier)\
    \ |\n                     INTEGER\n   The replication expression is a repeat function\
    \ applied to the\n   combined data type and value expression.  It expresses the\
    \ number of\n   times that the value (of the data type/value expression) is to\
    \ be\n   repeated within the field length denoted by the data type/length\n  \
    \ expression.\n   A null replication expression has the value of one.  Arithmetic\n\
    \   expressions are evaluated from left-to-right with no precedence.  (It\n  \
    \ is anticipated that this interpretation might be changed, if\n   necessary.)\n\
    \   The L(identifier) is a length operator that generates a 32-bit binary\n  \
    \ integer corresponding to the length of the term named.  The\n   V(identifier)\
    \ is a value operator that generates a 32-bit binary\n   integer corresponding\
    \ to the value of the term named.  (See\n   Restrictions and Interpretations of\
    \ Term Functions.)  The value\n   operator is intended to convert character strings\
    \ to their numerical\n   correspondents.\n   The data type is defined below.\n\
    \             datatype ::= B | O | X | E | A\n   The data type describes the kind\
    \ of data that the term represents.\n   (It is expected that additional data types,\
    \ such as floating point\n   and user-defined types, will be added as needed.)\n\
    \        Data Type         Meaning              Unit Length\n            B   \
    \          Bit string              1 bit\n            O             Bit string\
    \              3 bits\n            X             Bit string              4 bits\n\
    \            E             EBCDIC character        8 bits\n            A     \
    \        Network ASCII character 8 bits\n        The value expression is defined\
    \ below.\n                 valueexpression ::= value | <null>\n              \
    \   value ::= literal | arithmeticexpression\n                 literal ::= literaltype\
    \ \"string\"\n                 literaltype ::= B | O | X | E | A\n   The value\
    \ expression is the unit value of a term expressed in the\n   format indicated\
    \ by the data type.  It is repeated according to the\n   replication expression,\
    \ in a field whose length is constrained by the\n   length expression.\n   A null\
    \ value expression in the input stream defaults to the data\n   present in the\
    \ input stream.  The data must comply with the datatype\n   attribute, however.\n\
    \   A null value expression generates padding according to Restrictions\n   and\
    \ Interpretations of Term Functions.\n   The length expression is defined below.\n\
    \         lengthexpression ::= # | arithmeticexpression | <null>\n   The length\
    \ expression states the length of the field containing the\n   value expression\
    \ as expanded by the replication expression.  If the\n   value of the length expression\
    \ is less then the length implied by the\n   expanded value expression, then the\
    \ expanded value expression is\n   truncated, see Restrictions and Interpretations\
    \ of Term Functions.\n   The terminal symbol # means an arbitrary length, explicitly\n\
    \   terminated by the value of the next term.  The # is legal only in the\n  \
    \ input stream and not in the output stream.\n   If the length expression is less\
    \ than or equal to zero, the term\n   succeeds but the appropriate stream pointer\
    \ is not advanced.\n   Positive lengths cause the appropriate stream pointer to\
    \ be advanced\n   if the term otherwise succeeds.\n   Control is defined under\
    \ TERM AND RULE SEQUENCING.\n"
- title: Term Format 3
  contents:
  - "Term Format 3\n   Term format 3 is shown below.\n         descriptor\n   It is\
    \ identical to term format 2 with the omission of the identifier.\n   Term format\
    \ 3 is generally used in the output stream.  It is used in\n   the input stream\
    \ where input data is to be passed over but not\n   retained for emission or later\
    \ reference.\n"
- title: Term Format 4
  contents:
  - "Term Format 4\n   The fourth term format is shown below.\n         comparator\
    \    ::= (value connective value control) |\n                           (identifier\
    \ .<=. value control)\n         value         ::= literal | arithmeticexpression\n\
    \         literal       ::= literaltype \"string\"\n         literaltype   ::=\
    \ B | O | X | E | A\n         string        ::= from 0 to 256 characters\n   \
    \      connective    ::= .LE. | .LT. | .GE. | .GT. | .EQ. | .NE.\n   The fourth\
    \ term format is used for assignment and comparison.\n   The assignment operator\
    \ .<=. assigns the value to the identifier.\n   The connectives have their usual\
    \ meaning.  Values to be compared must\n   have the same type and length attributes\
    \ or an error condition arises\n   and the form fails.\n"
- title: The Application of a Term
  contents:
  - "The Application of a Term\n   The elements of a term are applied by the following\
    \ sequence of\n   steps.\n         1.  The data type and value expression together\
    \ specify a unit\n             value, call it x.\n         2.  The replication\
    \ expression specifies the number of times x\n             is to be repeated (or\
    \ copied) in concatenated fashion.  The\n             value of the concatenated\
    \ xs becomes, say, y of length L1.\n         3.  The data type and the length\
    \ expression together specify a\n             field length of the input area (call\
    \ it L2) that begins at\n             the current stream pointer position.\n \
    \        4.  The value of y is truncated to y' if L1 > L2.  Call the\n       \
    \      truncated length L1'.\n         5.  If the term is an input stream term,\
    \ then the value y' of\n             length L1' is compared to the input value\
    \ beginning at the\n             current input pointer position.\n         6.\
    \  If the values are identical over the length L1' then the\n             input\
    \ value of length L2 (may be greater than L1') starting\n             at the current\
    \ pointer position in the input area, becomes\n             the value of the term.\n\
    \   In an output stream term, the procedure is the same except that the\n   source\
    \ of input is the value of the term(s) named in the value\n   expression and the\
    \ data is emitted in the output stream.\n   The above procedure is modified to\
    \ include a one term look-ahead\n   where lengths are indefinite because of the\
    \ arbitrary symbol, #.\n"
- title: Restrictions and Interpretations of Term Functions
  contents:
  - "Restrictions and Interpretations of Term Functions\n   1.  Terms specifying indefinite\
    \ lengths, through the use of the #\n         symbol must be separated by some\
    \ type-specific data such as a\n         literal.  (A literal isn't specifically\
    \ required, however.  An\n         arbitrary number of ASCII characters could\
    \ be terminated by a\n         non-ASCII character.)  # is legal only in the input\
    \ stream, not\n         in the output stream.\n   2.  Truncation and padding is\
    \ as follows:\n         a)  Character to character (A <--> E) conversion is left\n\
    \             justified and truncated or padded on the right with blanks.\n  \
    \       b)  Character to numeric and numeric to numeric conversions are\n    \
    \         right-justified and truncated or padded on the left with\n         \
    \    zeros.\n         c)  Numeric to character conversion is right-justified and\n\
    \             left-padded with blanks.\n   3.  The following are ignored in a\
    \ form definition over the control\n         connection.\n         a)  TAB, carriage\
    \ return, etc.\n         b)  blanks except within quotes.\n         c)  /* string\
    \ */ is treated as comments except within quotes.\n   4.  The following defaults\
    \ prevail where the term part is omitted.\n         a)  The replication expression\
    \ defaults to one.\n         b)  The data type defaults to type B.\n         c)\
    \  The value expression of an input stream term defaults to\n             the\
    \ value found in the input stream, but the input stream\n             must conform\
    \ to data type and length expression.  The value\n             expression of an\
    \ output stream term defaults to padding\n             only.\n         d)  The\
    \ length expression defaults to the size of the quantity\n             determined\
    \ by replication expression, data type, and value\n             expression.\n\
    \         e)  Control defaults to the next sequential term if a term is\n    \
    \         successfully applied; else control defaults to the next\n          \
    \   sequential rule.  If _where_ evaluates to an undefined\n             _label_\
    \ the form fails.\n   5.  Arithmetic expressions are evaluated left-to-right with\
    \ no\n         precedence.\n   6.  The following limits prevail.\n         a)\
    \  Binary lengths are <= 32 bits\n         b)  Character strings are <= 256 8-bit\
    \ characters\n         c)  Identifier names are <= 4 characters\n         d) \
    \ Maximum number of identifiers is <= 256\n         e)  Label integers are >=\
    \ 0 and <= 9999\n   7.  Value and length operators product 32-bit binary integers.\
    \  The\n         value operator is currently intended for converting A or E type\n\
    \         decimal character strings to their binary correspondents.  For\n   \
    \      example, the value of E'12' would be 0......01100.  The value\n       \
    \  of E'AB' would cause the form to fail.\n"
- title: TERM AND RULE SEQUENCING
  contents:
  - "TERM AND RULE SEQUENCING\n   Sequencing may be explicitly controlled by including\
    \ control in a\n   term.\n        control ::=  :options | <null>\n        options\
    \ ::=  S(where) | F(where) | U(where)\n                     S(where) , F(where)\
    \ |\n                     F(where) , S(where)\n        where   ::=  arithmeticexpression\
    \ | R(arithmeticexpression)\n   S, F, and U denote success, fail, and unconditional\
    \ transfers,\n   respectively.  _Where_ evaluates to a _rule_ label, thus transfer\
    \ can\n   be effected from within a rule (at the end of a term) to the\n   beginning\
    \ of another rule.  R means terminate the form and return the\n   evaluated expression\
    \ to the initiator over the control connection (if\n   still open).\n   If terms\
    \ are not explicitly sequenced, the following defaults\n   prevail.\n   1)  When\
    \ a term fails go to the next sequential rule.\n   2)  When a term succeeds go\
    \ to the next sequential\n       term within the rule.\n   (3) At the end of a\
    \ rule, go to the next sequential\n       rule.\n   Note in the following example,\
    \ the correlation between transfer of\n   control and movement of the input pointer.\n\
    \        1   XYZ(,B,,8:S(2),F(3)) : XYZ ;\n        2   . . . . . . .\n       \
    \ 3   . . . . . . .\n   The value of XYZ will never be emitted in the output stream\
    \ since\n   control is transferred out of the rule upon either success or\n  \
    \ failure.  If the term succeeds, the 8 bits of input will be assigned\n   as\
    \ the value of XYZ and rule 2 will then be applied to the same input\n   stream\
    \ data.  That is, since the complete rule 1 was not successfully\n   applied,\
    \ then the input stream pointer is not advanced.\n"
- title: IV.  EXAMPLES
  contents:
  - 'IV.  EXAMPLES

    '
- title: REMARKS
  contents:
  - "REMARKS\n   The following examples (forms and also single rules) are simple\n\
    \   representative uses of the Form Machine.  The examples are expressed\n   in\
    \ a term-per-line format only to aid the explanation.  Typically, a\n   single\
    \ rule might be written as a single line.\n"
- title: FIELD INSERTION
  contents:
  - "FIELD INSERTION\n   To insert a field, separate the input into the two terms\
    \ to allow the\n   inserted field between them.  For example, to do line numbering\
    \ for a\n   121 character/line printer with a leading carriage control character,\n\
    \   use the following form.\n   (NUMB.<=>.1);       /*initialize line number counter\
    \ to one*/\n   1 CC(,E,,1:F(R(99))),  /*pick up control character and save\n \
    \                           as CC*/\n                          /*return a code\
    \ of 99 upon exhaustion*/\n   LINE(,E,,121 : F(R(98)))    /*save text as LINE*/\n\
    \   :CC,               /*emit control character*/\n   (,E,NUMB,2),       /*emit\
    \ counter in first two columns*/\n   (,E,E\".\",1),       /*emit period after\
    \ line number*/\n   (,E,LINE,117),     /*emit text, truncated in 117 byte field*/\n\
    \   (NUMB.<=.NUMB+1:U(1));    /*increment line counter and go to\n           \
    \                    rule one*/;;\n"
- title: DELETION
  contents:
  - "DELETION\n   Data to be deleted should be isolated as separate terms on the left,\n\
    \   so they may be omitted (by not emitting them) on the right.\n   (,B,,8), \
    \          /*isolate 8 bits to ignore*/\n   SAVE(,A,,10)       /*extract 10 ASCII\
    \ characters from\n                        input stream*/\n   :(,E,SAVE,);   \
    \   /*emit the characters in SAVE as EBCDIC\n                       characters\
    \ whose length defaults to the\n                       length of SAVE, i.e., 10,\
    \ and advance to\n                       the next rule*/\n   In the above example,\
    \ if either input stream term fails,\n   the next sequential rule is applied.\n"
- title: VARIABLE LENGTH RECORDS
  contents:
  - "VARIABLE LENGTH RECORDS\n   Some devices, terminals and programs generate variable\
    \ length\n   records.  To following rule picks up variable length EBCDIC records\n\
    \   and translates them to ASCII.\n   CHAR(,E,,#),       /*pick up all (an arbitrary\
    \ number of)\n                        EBCDIC characters in the input stream*/\n\
    \   (,X,X\"FF\",2)       /*followed by a hexadecimal literal,\n              \
    \          FF (terminal signal)*/\n   :(,A,CHAR,),       /*emit them as ASCII*/\n\
    \   (,X,X\"25\",2);      /*emit an ASCII carriage return*/\n"
- title: STRING LENGTH COMPUTATION
  contents:
  - "STRING LENGTH COMPUTATION\n   It is often necessary to prefix a length field\
    \ to an arbitrarily long\n   character string.  The following rule prefixes an\
    \ EBCDIC string with\n   a one-byte length field.\n   Q(,E,,#),          /*pick\
    \ up all EBCDIC characters*/\n   TS(,X,X\"FF\",2)     /*followed by a hexadecimal\
    \ literal, FF*/\n   :(,B,L(Q)+2,8),    /*emit the length of the characters\n \
    \                       plus the length of the literal plus\n                \
    \        the length of the count field itself,\n                        in an\
    \ 8-bit field*/\n   Q,                 */emit the characters*/\n   TS;       \
    \         */emit the terminal*/\n"
- title: TRANSPOSITION
  contents:
  - "TRANSPOSITION\n   It is often desirable to reorder fields, such as the following\n\
    \   example.\n   Q(,E,,20), R(,E,,10) , S(,E,,15), T(,E,,5) : R, T, S, Q ;\n \
    \  The terms are emitted in a different order.\n"
- title: CHARACTER PACKING AND UNPACKING
  contents:
  - "CHARACTER PACKING AND UNPACKING\n   In systems such as HASP, repeated sequences\
    \ of characters are packed\n   into a count followed by the character, for more\
    \ efficient storage\n   and transmission.  The first form packs multiple characters\
    \ and the\n   second unpacks them.\n   /*form to pack EBCDIC streams*/\n   /*returns\
    \ 99 if OK, input exhausted*/\n   /*returns 98 if illegal EBCDIC*/\n   /*look\
    \ for terminal signal FF which is not a legal EBCDIC*/\n   /*duplication count\
    \ must be 0-254*/\n   1 (,X,X\"FF\",2 : S(R(99))) ;\n   /*pick up the EBCDIC and\
    \ initialize count/*\n     CHAR(,E,,1 : F(R(98))) , (CNT .<=. 1) ;\n   /*count\
    \ consecutive EBCDICs like CHAR*/\n   2 (,E,CHAR,1 : F(3)) , (CNT .<=. CNT+1 :\
    \ U(2)) ;\n   /*emit count and current character*/\n   3 : (,B,CNT,8), CHAR, (:U(1));\n\
    \   /*end of form*/;;\n   /*form to unpack EBCDIC streams*/\n   /*look for terminal*/\n\
    \   1 (,X,X\"FF\",2 : S(R(99))) ;\n   /*emit character the number of times indicated*/\n\
    \   /*by the counter contents*/\n   CNT(,B,,8), CHAR(,E,,1) : (CNT,E,CHAR,CNT:U(1));\n\
    \   /*failure of form*/\n   (:U(R(98))) ;;\n"
- title: V.  PROPOSED USES OF DATA RECONFIGURATION SERVICE
  contents:
  - "V.  PROPOSED USES OF DATA RECONFIGURATION SERVICE\n   The following are some\
    \ proposed uses of the DRS that were submitted\n   by the sites indicated.\n \
    \  UCLA\n   1.  Pack/unpack text files.\n   2.  Preprocessor to scan META compiler\
    \ input.\n   3.  Perhaps graphics.\n   MIT\n   1.  Reformatting within file transfer\
    \ service.\n   2.  Character conversions.\n   3.  Possible graphics service (Evans\
    \ and Sutherland output\n       format).\n   4.  Reformat arguments of subroutines\
    \ remote to each other.\n   U. OF ILLINOIS\n   1.  Dependent upon remote use of\
    \ DRS for many remote\n       services.\n   SDC\n   1.  Would be essential to\
    \ data transfer in general.\n   2.  Could be used in relation to data management\
    \ language.\n   UCSB\n   1.  Checkout of I/O formats of file system.\n   2.  Debugging\
    \ Network services in general.\n   3.  Mapping their services into future standards.\n\
    \   RAND\n   1.  To describe RJO/RJE message formats at UCSB.\n   2.  To describe\
    \ RJS message formats at UCLA.\n   3.  To adapt Network to existing services,\
    \ in general.\n   MITRE\n   1.  Character conversions.\n   2.  Testing data formats\
    \ going into data bases for correct\n       field formatting.\n   VI.  IMPLEMENTATION\
    \ PLANS\n   Four sites currently plan to implement and offer the service on an\n\
    \   experimental basis.\n   1.  MIT    Implementation of forms interpreter in\
    \ MIDAS\n              (assembly).  Perhaps Tree Meta compiler of\n          \
    \    forms.  Implementation on PDP-10.\n   2.  UCLA   Implementation on SIGMA-7\
    \ employing META-7\n              to compile forms.\n   3.  UCSB   Implementation\
    \ on 360/75.\n   4.  RAND   Initial implementation on 360/65; compiler to be written\n\
    \               in graphics CPS; compiled intermediate forms to be\n         \
    \      interpreted by assembler language subroutine.  Later\n               implemented\
    \ on PDP-10.\n   In addition to the above sites, the University of Illinois and\
    \ Mitre\n   plan to experiment with the service.\n                           \
    \     APPENDIX A\n"
- title: Note 1 to the DRS Working Group
  contents:
  - "Note 1 to the DRS Working Group\n   As you recall, we spent considerable time\
    \ in discussing the use and\n   meaning of the arbitrary symbol, #.  To summarize,\
    \ it was clear that\n   inclusion of the # in both replication and length expressions\
    \ led to\n   ambiguities.  We settled on its restricted use in the length\n  \
    \ expression of an input term, although no one was entirely satisfied\n   with\
    \ this definition.\n   Recently, Jim White has again commented on the #.  Jim\
    \ feels that it\n   is curious that one can pick up an arbitrary number of EBCDIC\n\
    \   characters, for example, but can't pick up an arbitrary number of\n   specific\
    \ EBCDIC characters such as EBCDIC A's.  Jim feels that a more\n   natural way\
    \ to interpret the length, value, and replication\n   expressions would be as\
    \ the IBM OS assembler interprets the\n   attributes of the pseudo instruction,\
    \ define constant (CD).\n   The IBM OS assembler uses the following format.\n\
    \        1             2              3           4\n   duplication       type\
    \        modifiers   nominal value\n     factor\n   The duplication factor, if\
    \ specified, causes the constant to be\n   generated the number of times indicated\
    \ by the factor.  The type\n   defines the type of constant being specified. \
    \ Modifiers describe the\n   length, scaling, and exponent of the constant.  Nominal\
    \ value\n   supplies the constant described by the subfields that precede it.\n\
    \   Assume that we use the # only as a duplication factor (replication\n   expression).\
    \  Hence, in the example of the form to pack EBCDIC\n   characters, the counter\
    \ and looping can be eliminated.\n   CHAR(,E,,1) ;\n   LEN(#,#,CHAR,1) : (,B,L(LEN)+1,*)\
    \ , CHAR ;\n   The interpretation is that the data type, length expression, and\n\
    \   value expression make up the unit value.  This quantity can then be\n   replicated.\
    \  As our document now stands, only the data type and value\n   expression make\
    \ up the unit value.\n   The application of a term according to Jim's suggestion\
    \ is as\n   follows.\n   1.  The data type, value expression, and length expression\
    \ together\n       specify a unit value, call it x.\n   2.  The replication expression\
    \ specifies the number of times x is to\n       be repeated.  The value of the\
    \ concatenated xs becomes y of\n       length L.\n   3.  If the term is an input\
    \ stream term then the value beginning at\n       the current input pointer position.\n\
    \   4.  If the input value satisfies the constraints of y over length L\n    \
    \   then the input value of length L becomes the value of the term.\n"
- title: Note 2 to the DRS Working Group
  contents:
  - "Note 2 to the DRS Working Group\n   There has been recent debate of whether the\
    \ input pointer should be\n   advanced upon successful completion of a rule (as\
    \ it now is defined)\n   or upon successful completion of each term.  See the\
    \ example on page\n   22.  If the input pointer is advanced upon successful completion\
    \ of a\n   term, then rules become equivalent to terms.\n   I would like to for\
    \ us to discuss at the SJCC both the term\n   attributes and the input pointer\
    \ advance issues.\n                                                John\n    \
    \   [ This RFC was put into machine readable form for entry ]\n       [ into the\
    \ online RFC archives by Katsunori Tanaka 4/99 ]\n"
