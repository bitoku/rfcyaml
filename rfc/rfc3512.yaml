- title: __initial_text__
  contents:
  - "                 Configuring Networks and Devices with\n               Simple\
    \ Network Management Protocol (SNMP)\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document is written for readers interested in the Internet\n\
    \   Standard Management Framework and its protocol, the Simple Network\n   Management\
    \ Protocol (SNMP).  In particular, it offers guidance in the\n   effective use\
    \ of SNMP for configuration management.  This information\n   is relevant to vendors\
    \ that build network elements, management\n   application developers, and those\
    \ that acquire and deploy this\n   technology in their networks.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n      1.1. The Internet Standard Management Framework. . . .\
    \ . . . .   3\n      1.2. Configuration and the Internet Standard Management\n\
    \           Frame-work. . . . . . . . . . . . . . . . . . . . . . . .   4\n  \
    \ 2. Using SNMP as a Configuration Mechanism. . . . . . . . . . . .   5\n    \
    \  2.1. Transactions and SNMP . . . . . . . . . . . . . . . . . .   6\n      2.2.\
    \ Practical Requirements for Transactional Control. . . . .   6\n      2.3. Practices\
    \ in Configuration--Verification. . . . . . . . .   7\n   3. Designing a MIB Module\
    \ . . . . . . . . . . . . . . . . . . . .   9\n      3.1. MIB Module Design -\
    \ General Issues. . . . . . . . . . . .  10\n      3.2. Naming MIB modules and\
    \ Managed Objects. . . . . . . . . .  11\n      3.3. Transaction Control And State\
    \ Tracking. . . . . . . . . .  12\n           3.3.1. Conceptual Table Row Modification\
    \ Practices. . . .  12\n           3.3.2. Fate sharing with multiple tables. .\
    \ . . . . . . .  13\n           3.3.3. Transaction Control MIB Objects. . . .\
    \ . . . . . .  14\n           3.3.4. Creating And Activating New Table Rows .\
    \ . . . . .  15\n           3.3.5. Summary Objects and State Tracking . . . .\
    \ . . . .  15\n           3.3.6. Optimizing Configuration Data Transfer . . .\
    \ . . .  18\n      3.4. More Index Design Issues. . . . . . . . . . . . . . .\
    \ . .  22\n           3.4.1. Simple Integer Indexing. . . . . . . . . . . . .\
    \ .  23\n           3.4.2. Indexing with Network Addresses. . . . . . . . . .\
    \  23\n      3.5. Conflicting Controls. . . . . . . . . . . . . . . . . . .  24\n\
    \      3.6. Textual Convention Usage. . . . . . . . . . . . . . . . .  25\n  \
    \    3.7. Persistent Configuration. . . . . . . . . . . . . . . . .  26\n    \
    \  3.8. Configuration Sets and Activation . . . . . . . . . . . .  28\n      \
    \     3.8.1. Operational Activation Considerations. . . . . . .  28\n        \
    \   3.8.2. RowStatus and Deactivation . . . . . . . . . . . .  30\n      3.9.\
    \ SET Operation Latency . . . . . . . . . . . . . . . . . .  31\n           3.9.1.\
    \ Subsystem Latency, Persistence Latency,\n                  and Activation Latency\
    \ . . . . . . . . . . . . . .  33\n      3.10. Notifications and Error Reporting.\
    \ . . . . . . . . . . .  33\n           3.10.1. Identifying Source of Configuration\
    \ Changes . . .  34\n           3.10.2. Limiting Unnecessary Transmission of\n\
    \                   Notifications . . . . . . . . . . . . . . . . . .  34\n  \
    \         3.10.3. Control of Notification Subsystem . . . . . . . .  36\n    \
    \  3.11 Application Error Reporting . . . . . . . . . . . . . . .  36\n      3.12\
    \ Designing MIB Modules for Multiple Managers . . . . . . .  37\n      3.13 Other\
    \ MIB Module Design Issues. . . . . . . . . . . . . .  39\n           3.13.1.\
    \ Octet String Aggregations . . . . . . . . . . . .  39\n           3.13.2 Supporting\
    \ multiple instances of a MIB Module. . .  40\n           3.13.3 Use of Special\
    \ Optional Clauses. . . . . . . . . .  41\n   4. Implementing SNMP Configuration\
    \ Agents . . . . . . . . . . . .  41\n      4.1. Operational Consistency . . .\
    \ . . . . . . . . . . . . . .  41\n      4.2. Handling Multiple Managers. . .\
    \ . . . . . . . . . . . . .  43\n      4.3. Specifying Row Modifiability. . .\
    \ . . . . . . . . . . . .  44\n      4.4. Implementing Write-only Access Objects.\
    \ . . . . . . . . .  44\n   5. Designing Configuration Management Software. .\
    \ . . . . . . . .  44\n      5.1. Configuration Application Interactions\n   \
    \        with Managed Systems. . . . . . . . . . . . . . . . . . .  45\n     \
    \      5.1.1. SET Operations . . . . . . . . . . . . . . . . . .  46\n       \
    \    5.1.2. Configuration Transactions . . . . . . . . . . . .  46\n         \
    \  5.1.3. Tracking Configuration Changes . . . . . . . . . .  47\n           5.1.4.\
    \ Scalability of Data Retrieval. . . . . . . . . . .  48\n   6. Deployment and\
    \ Security Issues . . . . . . . . . . . . . . . .  48\n      6.1. Basic assumptions\
    \ about Configuration . . . . . . . . . .  48\n      6.2. Secure Agent Considerations\
    \ . . . . . . . . . . . . . . .  49\n      6.3. Authentication Notifications.\
    \ . . . . . . . . . . . . . .  49\n      6.4. Sensitive Information Handling.\
    \ . . . . . . . . . . . . .  50\n   7. Policy-based Management. . . . . . . .\
    \ . . . . . . . . . . . .  51\n      7.1. What Is the Meaning of 'Policy-based'\
    \ . . . . . . . . . .  51\n      7.2. Organization of Data in an SNMP-Based Policy\
    \ System . . .  53\n      7.3. Information Related to Policy-based Configuration\
    \ . . . .  54\n      7.4. Schedule and Time Issues. . . . . . . . . . . . . .\
    \ . . .  56\n      7.5. Conflict Detection, Resolution and Error Reporting. .\
    \ . .  56\n           7.5.1. Changes to Configuration Outside of the\n       \
    \           Policy System. . . . . . . . . . . . . . . . . . .  57\n      7.6.\
    \ More about Notifications in a Policy System . . . . . . .  57\n      7.7. Using\
    \ Policy to Move Less Configuration Data. . . . . . .  57\n   8. Example MIB Module\
    \ With Template-based Data. . . . . . . . . .  58\n      8.1. MIB Module Definition.\
    \ . . . . . . .  . . . . . . . . . .  61\n      8.2. Notes on MIB Module with\
    \ Template-based Data. . . . . . .  73\n      8.3. Examples of Usage of the MIB\
    \ . . . . . . .. . . . . . . .  74\n   9. Security Considerations . . . . . .\
    \ . . . . .. . . . . . . . .  77\n   10. Acknowledgments. . . . . . . . . . .\
    \ . . . .  . . . . . . . .  78\n   11. Normative References. . . . . . . . . .\
    \ . . . . . . . . . . .  78\n   12. Informative References. . . . . . . . . .\
    \ . . . . . . . . . .  79\n   13. Intellectual Property . . . . . . . . . . .\
    \ . . . . . . . . .  81\n   14. Editors' Addresses. . . . . . . . . . . . . .\
    \ . . . . . . . .  82\n   15. Full Copyright Statement. . . . . . . . . . . .\
    \ . . . . . . .  83\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1.  The Internet Standard Management Framework
  contents:
  - "1.1.  The Internet Standard Management Framework\n   The Internet Standard Management\
    \ Framework has many components.  The\n   purpose of this document is to describe\
    \ effective ways of applying\n   those components to the problems of configuration\
    \ management.\n   For reference purposes, the Internet Standard Management Framework\n\
    \   presently consists of five major components:\n   o  An overall architecture,\
    \ described in RFC 3411 [1].\n   o  Mechanisms for describing and naming objects\
    \ and events for the\n      purpose of management.  The first version of this\
    \ Structure of\n      Management Information (SMI) is called SMIv1 and described\
    \ in STD\n      16, RFC 1155 [15], STD 16, RFC 1212 [16] and RFC 1215 [17].  The\n\
    \      second version, called SMIv2, is described in STD 58, RFC 2578\n      [2],\
    \ STD 58, RFC 2579 [3] and STD 58, RFC 2580 [4].\n   o  Message protocols for\
    \ transferring management information.  The\n      first version of the SNMP message\
    \ protocol is called SNMPv1 and\n      described in STD 15, RFC 1157 [18].  A\
    \ second version of the SNMP\n      message protocol, which is not an Internet\
    \ standards track\n      protocol, is called SNMPv2c and described in RFC 1901\
    \ [19].  The\n      third version of the message protocol is called SNMPv3 and\n\
    \      described in RFC 3417 [5], RFC 3412 [6] and RFC 3414 [7].\n   o  Protocol\
    \ operations for accessing management information.  The\n      first set of protocol\
    \ operations and associated PDU formats is\n      described in STD 15, RFC 1157\
    \ [18].  A second set of protocol\n      operations and associated PDU formats\
    \ is described in RFC 3416\n      [8].\n   o  A set of fundamental applications\
    \ described in RFC 3413 [9] and\n      the view-based access control mechanism\
    \ described in RFC 3415\n      [10].\n   A more detailed introduction to the current\
    \ SNMP Management Framework\n   can be found in RFC 3410 [12].\n   Managed objects\
    \ are accessed via a virtual information store, termed\n   the Management Information\
    \ Base or MIB.  Objects in the MIB are\n   defined using the mechanisms defined\
    \ in the SMI.\n"
- title: 1.2.  Configuration and the Internet Standard Management Framework
  contents:
  - "1.2.  Configuration and the Internet Standard Management Framework\n   Data networks\
    \ have grown significantly over the past decade.  This\n   growth can be seen\
    \ in terms of:\n   Scale - Networks have more network elements, and the network\n\
    \      elements are larger and place more demands on the systems managing\n  \
    \    them.  For example, consider a typical number and speed of\n      interfaces\
    \ in a modern core network element.  A managed\n      metropolitan area network\
    \ switch can have a port density much\n      greater than the port density built\
    \ into the expectations of the\n      management systems that predated it.  There\
    \ are also many more\n      interrelationships within and between devices and\
    \ device\n      functions.\n   Functionality - network devices perform more functions.\n\
    \      More protocols and network layers are required for the successful\n   \
    \   deployment of network services which depend on them.\n   Rate of Change -\
    \ the nature of modern network services\n      causes updates, additions, and\
    \ deletions of device configuration\n      information more often than in the\
    \ past.  No longer can it be\n      assumed that a configuration will be specified\
    \ once and then be\n      updated rarely.  On the contrary, the trend has been\
    \ towards much\n      more frequent changes of configuration information.\n  \
    \ Correct configuration of network elements that make up data networks\n   is\
    \ a prerequisite to the successful deployment of the services on\n   them.  The\
    \ growth in size and complexity of modern networks increases\n   the need for\
    \ a standard configuration mechanism that is tightly\n   integrated with performance\
    \ and fault management systems.\n   The Internet Standard Management Framework\
    \ has been used successfully\n   to develop configuration management systems for\
    \ a broad range of\n   devices and networks.  A standard configuration mechanism\
    \ that\n   tightly integrates with performance and fault systems is needed not\n\
    \   only to help reduce the complexity of management, but also to enable\n   verification\
    \ of configuration activities that create revenue-\n   producing services.\n \
    \  This document describes Current Practices that have been used when\n   designing\
    \ effective configuration management systems using the\n   Internet Standard Management\
    \ Framework (colloquially known as SNMP).\n   It covers many basic practices as\
    \ well as more complex agent and\n   manager design issues that are raised by\
    \ configuration management.\n   We are not endeavoring to present a comprehensive\
    \ how-to document for\n   generalized SNMP agent, MIB module, or management application\
    \ design\n   and development.  We will, however, cover points of generalized SNMP\n\
    \   software design and implementation practice, where the practice has\n   been\
    \ seen to benefit configuration management software.  So, for\n   example, the\
    \ requirement for management applications to be aware of\n   agent limitations\
    \ is discussed in the context of configuration\n   operations, but many issues\
    \ that a management application developer\n   should consider with regard to manager-agent\
    \ interactions are left\n   for other documents and resources.\n   Significant\
    \ experience has been gained over the past ten years in\n   configuring public\
    \ and private data networks with SNMP.  During this\n   time, networks have grown\
    \ significantly as described above.  A\n   response to this explosive growth has\
    \ been the development of\n   policy-based configuration management.  Policy-Based\
    \ Configuration\n   Management is a methodology wherein configuration information\
    \ is\n   derived from rules and network-wide objectives, and is distributed to\n\
    \   potentially many network elements with the goal of achieving\n   consistent\
    \ network behavior throughout an administrative domain.\n   This document presents\
    \ lessons learned from these experiences and\n   applies them to both conventional\
    \ and policy-based configuration\n   systems based on SNMP.\n"
- title: 2.  Using SNMP as a Configuration Mechanism
  contents:
  - "2.  Using SNMP as a Configuration Mechanism\n   Configuration activity causes\
    \ one or more state changes in an\n   element.  While it often takes an arbitrary\
    \ number of commands and\n   amount of data to make up configuration change, it\
    \ is critical that\n   the configuration system treat the overall change operation\n\
    \   atomically so that the number of states into which an element\n   transitions\
    \ is minimized.  The goal is for a change request either to\n   be completely\
    \ executed or not at all.  This is called transactional\n   integrity.  Transactional\
    \ integrity makes it possible to develop\n   reliable configuration systems that\
    \ can invoke transactions and keep\n   track of an element's overall state and\
    \ work in the presence of error\n   states.\n"
- title: 2.1.  Transactions and SNMP
  contents:
  - "2.1.  Transactions and SNMP\n   Transactions can logically take place at very\
    \ fine-grained levels\n   such as an individual object instance or in very large\
    \ aggregations\n   that could include many object instances located in many tables\
    \ on a\n   managed device.  For this reason, reliance on transactional integrity\n\
    \   only at the SNMP protocol level is insufficient.\n"
- title: 2.2.  Practical Requirements for Transactional Control
  contents:
  - "2.2.  Practical Requirements for Transactional Control\n   A well-designed and\
    \ deployed configuration system should have the\n   following features with regard\
    \ to transactions and transactional\n   integrity.\n   1) Provide for flexible\
    \ transaction control at many different levels\n      of granularity.  At one\
    \ extreme, an entire configuration may be\n      delivered and installed on an\
    \ element, or alternately one small\n      attribute may be changed.\n   2) The\
    \ transaction control component should work at and understand a\n      notion\
    \ of the kind of multi-level \"defaulting\" as described in\n      Section 7.1.\
    \  The key point here is that it may make most sense to\n      configure systems\
    \ at an abstract level rather than on an\n      individual instance by instance\
    \ basis as has been commonly\n      practiced.  In some cases it is more effective\
    \ to send a\n      configuration command to a system that contains a set of\n\
    \      'defaults' to be applied to instances that meet certain criteria.\n   3)\
    \ An effective configuration management system must allow\n      flexibility in\
    \ the definition of a successful transaction.  This\n      cannot be done at the\
    \ protocol level alone, but rather must be\n      provided for throughout the\
    \ application and the information that\n      is being managed.  In the case of\
    \ SNMP, the information would be\n      in properly defined MIB modules.\n   4)\
    \ A configuration management system should provide time-indexed\n      transaction\
    \ control.  For effective rollback control, the\n      configuration transactions\
    \ and their successful or unsuccessful\n      completion status must be reported\
    \ by the managed elements and\n      stored in a repository that supports such\
    \ time indexing and can\n      record the user that made the change, even if the\
    \ change was not\n      carried out by the system recording the change.\n   5)\
    \ The managed system must support transactional security.  This\n      means that\
    \ depending on who is making the configuration request\n      and where it is\
    \ being made, it may be accepted or denied based on\n      security policy that\
    \ is in effect in the managed element.\n   Effective transactional control is\
    \ a responsibility shared between\n   design, implementation, and operational\
    \ practice.  Transaction\n   control techniques for MIB module design are discussed\
    \ in Section\n   3.3.  Transaction control considerations for the agent implementation\n\
    \   are discussed in Section 5.2.2.\n"
- title: 2.3.  Practices in Configuration--Verification
  contents:
  - "2.3.  Practices in Configuration--Verification\n   Verification of expected behavior\
    \ subsequent to the commitment of\n   change is an integral part of the configuration\
    \ process.  To reduce\n   the chance of making simple errors in configuration,\
    \ many\n   organizations employ the following change management procedure:\n \
    \  pre-test - verify that the system is presently working properly\n   change\
    \   - make configuration changes and wait for convergence\n              (system\
    \ or network stability)\n   re-test  - verify once again that the system is working\
    \ properly\n   This procedure is commonly used to verify configuration changes\
    \ to\n   critical systems such as the domain name system (DNS).  DNS software\n\
    \   kits provide diagnostic tools that allow automatic test\n   procedures/scripts\
    \ to be conducted.\n   A planned configuration sequence can be aborted if the\
    \ pre-\n   configuration test result shows the state of the system as unstable.\n\
    \   Debugging the unintended effects of two sets of changes in large\n   systems\
    \ is often more challenging than an analysis of the effects of\n   a single set\
    \ after test termination.\n   Networks and devices under SNMP configuration readily\
    \ support this\n   change management procedure since the SNMP provides integrated\n\
    \   monitoring, configuration and diagnostic capabilities.  The key is\n   the\
    \ sequencing of SNMP protocol operations to effect an integrated\n   change procedure\
    \ like the one described above.  This is usually a\n   well-bounded affair for\
    \ changes within a single network element or\n   node.  However, there are times\
    \ when configuration of a given element\n   can impact other elements in a network.\
    \  Configuring network\n   protocols such as IEEE 802.1D Spanning Tree or OSPF\
    \ is especially\n   challenging since the impact of a configuration change can\
    \ directly\n   affect stability (convergence) of the network the device is connected\n\
    \   to.\n   An integrated view of configuration and monitoring provides an ideal\n\
    \   platform from which to evaluate such changes.  For example, the MIB\n   module\
    \ governing IEEE 802.1D Spanning Tree (RFC 1493 [24]) provides\n   the following\
    \ object to monitor stability per logical bridge.\n      dot1dStpTopChanges OBJECT-TYPE\n\
    \          SYNTAX  Counter\n          ACCESS  read-only\n          STATUS  mandatory\n\
    \          DESCRIPTION\n             \"The total number of topology changes detected\
    \ by\n             this bridge since the management entity was last\n        \
    \     reset or initialized.\"\n          REFERENCE\n             \"IEEE 802.1D-1990:\
    \ Section 6.8.1.1.3\"\n          ::= { dot1dStp 4 }\n   Likewise, the OSPF MIB\
    \ module provides a similar metric for stability\n   per OSPF area.\n      ospfSpfRuns\
    \ OBJECT-TYPE\n          SYNTAX   Counter32\n          MAX-ACCESS   read-only\n\
    \          STATUS   current\n          DESCRIPTION\n             \"The number\
    \ of times that the intra-area route\n             table has been calculated using\
    \ this area's\n             link-state database.  This is typically done\n   \
    \          using Dijkstra's algorithm.\"\n         ::= { ospfAreaEntry 4 }\n \
    \  The above object types are good examples of a means of facilitating\n   the\
    \ principles described in Section 2.3.  That is, one needs to\n   understand the\
    \ behavior of a subsystem before configuration change,\n   then be able to use\
    \ the same means to retest and verify proper\n   operation subsequent to configuration\
    \ change.\n   The operational effects of a given implementation often differ from\n\
    \   one to another for any given standard configuration object.  The\n   impact\
    \ of a change to stability of systems such as OSPF should be\n   documented in\
    \ an agent-capabilities statement which is consistent\n   with \"Requirements\
    \ for IP Version 4 Routers\" [22], Section 1.3.4:\n      A vendor needs to provide\
    \ adequate documentation on all\n      configuration parameters, their limits\
    \ and effects.\n   Adherence to the above model is not fail-safe, especially when\n\
    \   configuration errors are masked by long latencies or when\n   configuration\
    \ errors lead to oscillations in network stability.  For\n   example, consider\
    \ the situation of loading a new software version on\n   a device, which leads\
    \ to small, slow, cumulative memory leaks brought\n   on by a certain traffic\
    \ pattern that was not caught during vendor and\n   customer test lab trials.\n\
    \   In a network-based example, convergence in an autonomous system\n   cannot\
    \ be guaranteed when configuration changes are made since there\n   are factors\
    \ beyond the control of the operator, such as the state of\n   other network elements.\
    \  Problems affecting this convergence may not\n   be detected for a significant\
    \ period of time after the configuration\n   change.  Even for factors within\
    \ the operator's control, there is\n   often little verification done to prevent\
    \ mis-configuration (as shown\n   in the following example).\n   Consider a change\
    \ made to ospfIfHelloInterval and\n   ospfIfRtrDeadInterval [24] timers in the\
    \ OSPF routing protocol such\n   that both are set to the same value.  Two routers\
    \ may form an\n   adjacency but then begin to cycle in and out of adjacency, and\
    \ thus\n   never reach a stable (converged) state.  Had the configuration\n  \
    \ process described at the beginning of this section been employed,\n   this particular\
    \ situation would have been discovered without\n   impacting the production network.\n\
    \   The important point to remember from this discussion is that\n   configuration\
    \ systems should be designed and implemented with\n   verification tests in mind.\n"
- title: 3.  Designing a MIB Module
  contents:
  - "3.  Designing a MIB Module\n   Carefully considered MIB module designs are crucial\
    \ to practical\n   configuration with SNMP.  As we have just seen, MIB objects\
    \ designed\n   for configuration can be very effective since they can be associated\n\
    \   with integrated diagnostic, monitoring, and fault objects.  MIB\n   modules\
    \ for configuration also scale when they expose their notion of\n   template object\
    \ types.  Template objects can represent information at\n   a higher level of\
    \ abstraction than instance-level ones.  This has the\n   benefit of reducing\
    \ the amount of instance-level data to move from\n   management application to\
    \ the agent on the managed element, when that\n   instance-level data is brought\
    \ about by applying a template object on\n   the agent.  Taken together, all of\
    \ these objects can provide a robust\n   configuration subsystem.\n   The remainder\
    \ of this section provides specific practices used in MIB\n   module design with\
    \ SMIv2 and SNMPv3.\n"
- title: 3.1.  MIB Module Design - General Issues
  contents:
  - "3.1.  MIB Module Design - General Issues\n   One of the first tasks in defining\
    \ a MIB module is the creation of a\n   model that reflects the scope and organization\
    \ of the management\n   information an agent will expose.\n   MIB modules can\
    \ be thought of as logical models providing one or more\n   aspects/views of a\
    \ subsystem.  The objective for all MIB modules\n   should be to serve one or\
    \ more operational requirements such as\n   accounting information collection,\
    \ configuration of one or more parts\n   of a system, or fault identification.\
    \  However, it is important to\n   include only those aspects of a subsystem that\
    \ are proven to be\n   operationally useful.\n   In 1993, one of most widely deployed\
    \ MIB modules supporting\n   configuration was published, RFC 1493, which contained\
    \ the BRIDGE-\n   MIB.  It defined the criteria used to develop the MIB module\
    \ as\n   follows:\n      To be consistent with IAB directives and good engineering\n\
    \      practice, an explicit attempt was made to keep this MIB as simple\n   \
    \   as possible.  This was accomplished by applying the following\n      criteria\
    \ to objects proposed for inclusion:\n   (1)  Start with a small set of essential\
    \ objects and add only as\n        further objects are needed.\n   (2)  Require\
    \ objects be essential for either fault or configuration\n        management.\n\
    \   (3)  Consider evidence of current use and/or utility.\n   (4)  Limit the total\
    \ (sic) of objects.\n   (5)  Exclude objects which are simply derivable from others\
    \ in this\n        or other MIBs.\n   (6)  Avoid causing critical sections to\
    \ be heavily instrumented.  The\n        guideline that was followed is one counter\
    \ per critical section\n        per layer.\n   Over the past eight years additional\
    \ experience has shown a need to\n   expand these criteria as follows:\n   (7)\
    \  Before designing a MIB module, identify goals and objectives for\n        the\
    \ MIB module.  How much of the underlying system will be\n        exposed depends\
    \ on these goals.\n   (8)  Minimizing the total number of objects is not an explicit\
    \ goal,\n        but usability is.  Be sure to consider deployment and usability\n\
    \        requirements.\n   (9)  During configuration, consider supporting explicit\
    \ error state,\n        capability and capacity objects.\n   (10) When evaluating\
    \ rule (5) above, consider the impact on a\n        management application.  If\
    \ an object can help reduce a\n        management application's complexity, consider\
    \ defining objects\n        that can be derived.\n"
- title: 3.2.  Naming MIB modules and Managed Objects
  contents:
  - "3.2.  Naming MIB modules and Managed Objects\n   Naming of MIB modules and objects\
    \ informally follows a set of best\n   practices.  Originally, standards track\
    \ MIB modules used RFC names.\n   As the MIB modules evolved, the practice changed\
    \ to using more\n   descriptive names.  Presently, Standards Track MIB modules\
    \ define a\n   given area of technology such as ATM-MIB, and vendors then extend\n\
    \   such MIB modules by prefixing the company name to a given MIB module\n   as\
    \ in ACME-ATM-MIB.\n   Object descriptors (the \"human readable names\" assigned\
    \ to object\n   identifiers [2]) defined in standard MIB modules should be unique\n\
    \   across all MIB modules.  Generally, a prefix is added to each managed\n  \
    \ object that can help reference the MIB module it was defined in.  For\n   example,\
    \ the IF-MIB uses \"if\" prefix for descriptors of object types\n   such as ifTable,\
    \ ifStackTable and so forth.\n   MIB module object type descriptors can include\
    \ an abbreviation for\n   the function they perform.  For example the objects\
    \ that control\n   configuration in the example MIB module in Section 8 include\
    \ \"Cfg\" as\n   part of the object descriptor, as in bldgHVACCfgDesiredTemp.\n\
    \   This is more fully realized when the object descriptors that include\n   the\
    \ fault, configuration, accounting, performance and security [33]\n   abbreviations\
    \ are combined with an organized OID assignment approach.\n   For example, a vendor\
    \ could create a configuration branch in their\n   private enterprises area. \
    \ In some cases this might be best done on a\n   per product basis.  Whatever\
    \ the approach used, \"Cfg\" might be\n   included in every object descriptor\
    \ in the configuration branch.\n   This has two operational benefits.  First,\
    \ for those that do look at\n   instances of MIB objects, descriptors as seen\
    \ through MIB browsers or\n   other command line tools assist in conveying the\
    \ meaning of the\n   object type.  Secondly, management applications can be pointed\
    \ at\n   specific subtrees for fault or configuration, causing a more\n   efficient\
    \ retrieval of data and a simpler management application with\n   potentially\
    \ better performance.\n"
- title: 3.3.  Transaction Control And State Tracking
  contents:
  - "3.3.  Transaction Control And State Tracking\n   Transactions and keeping track\
    \ of their state is an important\n   consideration when performing any type of\
    \ configuration activity\n   regardless of the protocol.  Here are a few areas\
    \ to consider when\n   designing transaction support into an SNMP-based configuration\n\
    \   system.\n"
- title: 3.3.1.  Conceptual Table Row Modification Practices
  contents:
  - "3.3.1.  Conceptual Table Row Modification Practices\n   Any discussion of transaction\
    \ control as it pertains to MIB module\n   design often begins with how the creation\
    \ or modification of object\n   instances in a conceptual row in the MIB module\
    \ is controlled.\n   RowStatus [3] is a standard textual convention for the management\
    \ of\n   conceptual rows in a table.  Specifically, the RowStatus textual\n  \
    \ convention that is used for the SYNTAX value of a single column in a\n   table\
    \ controls the creation, deletion, activation, and deactivation\n   of conceptual\
    \ rows of the table.  When a table has been defined with\n   a RowStatus object\
    \ as one of its columns, changing an instance of the\n   object to 'active' causes\
    \ the row in which that object instance\n   appears to become 'committed'.\n \
    \  In a multi-table scenario where the configuration data must be spread\n   over\
    \ many columnar objects, a RowStatus object in one table can be\n   used to cause\
    \ the entire set of data to be put in operation or stored\n   based on the definition\
    \ of the objects.\n   In some cases, very large amounts of data may need to be\
    \ 'committed'\n   all at once.  In these cases, another approach is to configure\
    \ all of\n   the rows in all the tables required and have an \"activate\" object\n\
    \   that has a set method that commits all the modified rows.\n   The RowStatus\
    \ textual convention specifies that, when used in a\n   conceptual row, a description\
    \ must define what can be modified.\n   While the description of the conceptual\
    \ row and its columnar object\n   types is the correct place to derive this information\
    \ on instance\n   modifiability, it is often wrongly assumed in some implementations\n\
    \   that:\n   1) objects either must all be presently set or none need be set\
    \ to\n      make a conceptual RowStatus object transition to active(1)\n   2)\
    \ objects in a conceptual row cannot be modified once a RowStatus\n      object\
    \ is active(1).  Restricting instance modifiability like\n      this, so that\
    \ after a RowStatus object is set to active(1) is in\n      fact a reasonable\
    \ limitation, since such a set of RowStatus may\n      have agent system side-effects\
    \ which depend on committed columnar\n      object instance values.  However,\
    \ where this restriction exists on\n      an object, it should be made clear in\
    \ a DESCRIPTION clause such as\n      the following:\n      protocolDirDescr OBJECT-TYPE\n\
    \        SYNTAX      DisplayString (SIZE (1..64))\n        MAX-ACCESS  read-create\n\
    \        STATUS      current\n        DESCRIPTION\n            \"A textual description\
    \ of the protocol encapsulation.\n            A probe may choose to describe only\
    \ a subset of the\n            entire encapsulation (e.g., only the highest layer).\n\
    \            This object is intended for human consumption only.\n           \
    \ This object may not be modified if the associated\n            protocolDirStatus\
    \ object is equal to active(1).\"\n        ::= { protocolDirEntry 4 }\n   Any\
    \ such restrictions on columnar object instance modification while\n   a row's\
    \ RowStatus object instance is set to active(1) should appear\n   in the DESCRIPTION\
    \ clause of the RowStatus columnar OBJECT-TYPE as\n   well.\n"
- title: 3.3.2.  Fate sharing with multiple tables
  contents:
  - "3.3.2.  Fate sharing with multiple tables\n   An important principle associated\
    \ with transaction control is fate\n   sharing of rows in different tables.  Consider\
    \ the case where a\n   relationship has been specified between two conceptual\
    \ tables of a\n   MIB module (or tables in two different MIB modules).  In this\n\
    \   context, fate sharing means that when a row of a table is deleted,\n   the\
    \ corresponding row in the other table is also deleted.  Fate\n   sharing in a\
    \ transaction control context can also be used with the\n   activation of very\
    \ large configuration changes.  If we have two\n   tables that hold a set of configuration\
    \ information, a row in one\n   table might have to be put in the 'ready' state\
    \ before the second can\n   be put in the 'ready' state.  When that second table\
    \ can be placed in\n   the 'ready' state, then the entire transaction can be considered\
    \ to\n   have been 'committed'.\n   Fate sharing of SNMP table data should be\
    \ explicitly defined where\n   possible using the SMI index qualifier AUGMENTS.\
    \  If the relationship\n   between tables cannot be defined using SMIv2 macros,\
    \ then the\n   DESCRIPTION clause of the object types which particularly effect\
    \ the\n   cross-table relationship should define what should happen when rows\n\
    \   in related tables are added or deleted.\n   Consider the relationship between\
    \ the dot1dBasePortTable and the\n   ifTable.  These tables have a sparse relationship.\
    \  If a given\n   ifEntry supports 802.1D bridging then there is a dot1dBasePortEntry\n\
    \   that has a pointer to it via dot1dBasePortIfIndex.\n   Now, what should happen\
    \ if an ifEntry that can bridge is deleted?\n   Should the object dot1dBasePortIfIndex\
    \ simply be set to 0 or should\n   the dot1dBasePortEntry be deleted as well?\
    \  A number of acceptable\n   design and practice techniques can provide the answer\
    \ to these\n   questions, so it is important for the MIB module designer to provide\n\
    \   the guidance to guarantee consistency and interoperability.\n   To this end,\
    \ when two tables are related in such a way, ambiguities\n   such as this should\
    \ be avoided by having the DESCRIPTION clauses of\n   the pertinent row object\
    \ types define the fate sharing of entries in\n   the respective tables.\n"
- title: 3.3.3.  Transaction Control MIB Objects
  contents:
  - "3.3.3.  Transaction Control MIB Objects\n   When a MIB module is defined that\
    \ includes configuration object\n   types, consider providing transaction control\
    \ objects.  These objects\n   can be used to cause a large transaction to be committed.\
    \  For\n   example, we might have several tables that define the configuration\n\
    \   of a portion of a system.  In order to avoid churn in the operational\n  \
    \ state of the system we might create a single scalar object that, when\n   set\
    \ to a particular value, will cause the activation of the rows in\n   all the\
    \ necessary tables.  Here are some examples of further usage\n   for such object\
    \ types:\n   o  Control objects that are the 'write' or 'commit' objects.\n  \
    \    Such objects can cause all pending transactions (change MIB object\n    \
    \  values as a result of SET operations) to be committed to a\n      permanent\
    \ repository or operational memory, as defined by the\n      semantics of the\
    \ MIB objects.\n   o  Control objects at different levels of configuration granularity.\n\
    \      One of the decisions for a MIB module designer is what are the\n      levels\
    \ of granularity that make sense in practice.  For example,\n      in the routing\
    \ area, would changes be allowed on a per protocol\n      basis such as BGP? If\
    \ allowed at the BGP level, are sub-levels\n      permitted such as per autonomous\
    \ system? The design of these\n      control objects will be impacted by the underlying\
    \ software\n      design.  RowStatus (see Section 3.3.1) also has important\n\
    \      relevance as a general transaction control object.\n"
- title: 3.3.4.  Creating And Activating New Table Rows
  contents:
  - "3.3.4.  Creating And Activating New Table Rows\n   When designing read-create\
    \ objects in a table, a MIB module designer\n   should first consider the default\
    \ state of each object in the table\n   when a row is created.  Should an implementation\
    \ of a standard MIB\n   module vary in terms of the objects that need to be set\
    \ in order to\n   create an instance of a given row, an agent capabilities statement\n\
    \   should be used to name the additional objects in that table using the\n  \
    \ CREATION-REQUIRES clause.\n   It is useful when configuring new rows to use\
    \ the notReady status to\n   indicate row activation cannot proceed.\n   When\
    \ creating a row instance of a conceptual table, one should\n   consider the state\
    \ of instances of required columnar objects in the\n   row.  The DESCRIPTION clause\
    \ of such a required columnar object\n   should specify it as such.\n   During\
    \ the period of time when a management application is attempting\n   to create\
    \ a row, there may be a period of time when not all of these\n   required (and\
    \ non-defaultable) columnar object instances have been\n   set. Throughout this\
    \ time, an agent should return a noSuchInstance\n   error for a GET of any object\
    \ instance of the row until such time\n   that all of these required instance\
    \ values are set.  The exception is\n   the RowStatus object instance, for which\
    \ a notReady(3) value should\n   be returned during this period.\n   One need\
    \ only be concerned with the notReady value return for a\n   RowStatus object\
    \ when the row under creation does not yet have all of\n   the required, non-defaultable\
    \ instance values for the row.  One\n   approach to simplifying in-row configuration\
    \ transactions when\n   designing MIB modules is to construct table rows that\
    \ have no more\n   instance data for columnar objects than will fit inside a single\
    \ SET\n   PDU.  In this case, the createAndWait() value for the RowStatus\n  \
    \ columnar object is not required.  It is possible to use createAndGo()\n   in\
    \ the same SET PDU, thus simplifying transactional management.\n"
- title: 3.3.5.  Summary Objects and State Tracking
  contents:
  - "3.3.5.  Summary Objects and State Tracking\n   Before beginning a new set of\
    \ configuration transactions, a\n   management application might want to checkpoint\
    \ the state of the\n   managed devices whose configuration it is about to change.\
    \  There are\n   a number of techniques that a MIB module designer can provide\
    \ to\n   assist in the (re-)synchronization of the managed systems.  These\n \
    \  objects can also be used to verify that the management application's\n   notion\
    \ of the managed system state is the same as that of the managed\n   device.\n\
    \   These techniques include:\n   1. Provide an object that reports the number\
    \ of rows in a table\n   2. Provide an object that flags when data in the table\
    \ was last\n      modified.\n   3. Send a notification message (InformRequests\
    \ are preferable) to\n      deliver configuration change.\n   By providing an\
    \ object containing the number of rows in a table,\n   management applications\
    \ can decide how best to retrieve a given\n   table's data and may choose different\
    \ retrieval strategies depending\n   on table size.  Note that the availability\
    \ of and application\n   monitoring of such an object is not sufficient for determining\
    \ the\n   presence of table data change over a checkpointed duration since an\n\
    \   equal number of row creates and deletes over that duration would\n   reflect\
    \ no change in the object instance value.  Additionally, table\n   data change\
    \ which does not change the number of rows in the table\n   would not be reflected\
    \ through simple monitoring of such an object\n   instance.\n   Instead, the change\
    \ in the value of any table object instance data\n   can be tracked through an\
    \ object that monitors table change state as\n   a function of time.  An example\
    \ is found in RFC 2790, Host Resources\n   MIB:\n   hrSWInstalledLastUpdateTime\
    \ OBJECT-TYPE\n       SYNTAX     TimeTicks\n       MAX-ACCESS read-only\n    \
    \   STATUS     current\n       DESCRIPTION\n           \"The value of sysUpTime\
    \ when the hrSWInstalledTable\n           was last completely updated.  Because\
    \ caching of this\n           data will be a popular implementation strategy,\n\
    \           retrieval of this object allows a management station\n           to\
    \ obtain a guarantee that no data in this table is\n           older than the\
    \ indicated time.\"\n       ::= { hrSWInstalled 2 }\n   A similar convention found\
    \ in many standards track MIB modules is the\n   \"LastChange\" type object.\n\
    \   For example, the ENTITY-MIB, RFC 2737 [34], provides the following\n   object:\n\
    \   entLastChangeTime OBJECT-TYPE\n     SYNTAX      TimeStamp\n     MAX-ACCESS\
    \  read-only\n     STATUS      current\n     DESCRIPTION\n             \"The value\
    \ of sysUpTime at the time a conceptual row is\n             created, modified,\
    \ or deleted in any of these tables:\n                     - entPhysicalTable\n\
    \                     - entLogicalTable\n                     - entLPMappingTable\n\
    \                     - entAliasMappingTable\n                     - entPhysicalContainsTable\"\
    \n     ::= { entityGeneral 1 }\n   This convention is not formalized.  There tend\
    \ to be small\n   differences in what a table's LastChanged object reflects. \
    \ IF-MIB\n   (RFC 2863 [20]) defines the following:\n   ifTableLastChange  OBJECT-TYPE\n\
    \       SYNTAX      TimeTicks\n       MAX-ACCESS  read-only\n       STATUS   \
    \   current\n       DESCRIPTION\n               \"The value of sysUpTime at the\
    \ time of the last\n               creation or deletion of an entry in the ifTable.\
    \  If\n               the number of entries has been unchanged since the\n   \
    \            last re-initialization of the local network management\n        \
    \       subsystem, then this object contains a zero value.\"\n       ::= { ifMIBObjects\
    \ 5 }\n   So, if an agent modifies a row with an SNMP SET on ifAdminStatus, the\n\
    \   value of ifTableLastChange will not be updated.  It is important to\n   be\
    \ specific about what can cause an object to update so that\n   management applications\
    \ will be able to detect and more properly act\n   on these changes.\n   The final\
    \ way to keep distributed configuration data consistent is to\n   use an event-driven\
    \ model, where configuration changes are\n   communicated as they occur.  When\
    \ the frequency of change to\n   configuration is relatively low or polling a\
    \ cache object is not\n   desired, consider defining a notification that can be\
    \ used to report\n   all configuration change details.\n   When doing so, the\
    \ option is available to an SNMPv3 (or SNMPv2c)\n   agent to deliver the notification\
    \ using either a trap or an inform.\n   The decision as to which PDU to deliver\
    \ to the recipient is generally\n   a matter of local configuration.  Vendors\
    \ should recommend the use of\n   informs over traps for NOTIFICATION-TYPE data\
    \ since the agent can use\n   the presence or absence of a response to help know\
    \ whether it needs\n   to retransmit or not.  Overall, it is preferable to use\
    \ an inform\n   instead of a trap so that changes have a higher likelihood of\n\
    \   confirmed end-to-end delivery.\n   As a matter of MIB module design, when\
    \ practical, the NOTIFICATION-\n   TYPE should include in the PDU all of the modified\
    \ columnar objects\n   in a row of a table.  This makes it easier for the management\n\
    \   application receiving the notification to keep track of what has\n   changed\
    \ in the row of a table and perform addition analysis on the\n   state of the\
    \ managed elements.\n   However, the use of notifications to communicate the state\
    \ of a\n   rapidly changing object may not be ideal either.  This leads us back\n\
    \   to the MIB module design question of what is the right level of\n   granularity\
    \ to expose.\n   Finally, having to poll many \"LastChange\" objects does not\
    \ scale\n   well.  Consider providing a global LastChange type object to\n   represent\
    \ overall configuration in a given agent implementation.\n"
- title: 3.3.6.  Optimizing Configuration Data Transfer
  contents:
  - "3.3.6.  Optimizing Configuration Data Transfer\n   Configuration management software\
    \ should keep track of the current\n   configuration of all devices under its\
    \ control.  It should ensure\n   that the result is a consistent view of the configuration\
    \ of the\n   network, which can help reduce inadvertent configuration errors.\n\
    \   In devices that have very large amounts of configuration data, it can\n  \
    \ be costly to both the agent and the manager to have the manager\n   periodically\
    \ poll the entire contents of these configuration tables\n   for synchronization\
    \ purposes.  A benefit of good synchronization\n   between the manager and the\
    \ agent is that the manager can determine\n   the smallest and most effective\
    \ set of data to send to managed\n   devices when configuration changes are required.\
    \  Depending on the\n   table organization in the managed device and the agent\n\
    \   implementation, this practice can reduce the burden on the managed\n   device\
    \ for activation of these configuration changes.\n   In the previous section,\
    \ we discussed the \"LastChange\" style of\n   object.  When viewed against the\
    \ requirements just described, the\n   LastChange object is insufficient for large\
    \ amounts of data.\n   There are three design options that can be used to assist\
    \ with the\n   synchronization of the configuration data found in the managed\
    \ device\n   with the manager:\n   1) Design multiple indices to partition the\
    \ data in a table logically\n      or break a table into a set of tables to partition\
    \ the data based\n      on what an application will use the table for\n   2) Use\
    \ a time-based indexing technique\n   3) Define a control MIB module that manages\
    \ a separate data delivery\n      protocol\n"
- title: 3.3.6.1.  Index Design
  contents:
  - "3.3.6.1.  Index Design\n   Index design has a major impact on the amount of data\
    \ that must be\n   transferred between SNMP entities and can help to mitigate\
    \ scaling\n   issues with large tables.\n   Many tables in standard MIB modules\
    \ follow one of two indexing\n   models:\n   - Indexing based upon increasing\
    \ Integer32 or Unsigned32 values of\n      the kind one might find in an array.\n\
    \   - Associative indexing, which refers to the technique of using\n      potentially\
    \ sparse indices based upon a \"key\" of the sort one\n      would use for a hash\
    \ table.\n   When tables grow to a very large number of rows, using an associative\n\
    \   indexing scheme offers the useful ability to efficiently retrieve\n   only\
    \ the rows of interest.\n   For example, if an SNMP entity exposes a copy of the\
    \ default-free\n   Internet routing table as defined in the ipCidrRouteTable,\
    \ it will\n   presently contain around 100,000 rows.\n   Associative indexing\
    \ is used in the ipCidrRouteTable and allows one\n   to retrieve, for example,\
    \ all routes for a given IPv4 destination\n   192.0.2/24.\n   Yet, if the goal\
    \ is to extract a copy of the table, the associative\n   indexing reduces the\
    \ throughput and potentially the performance of\n   retrieval.  This is because\
    \ each of the index objects are appended to\n   the object identifiers for every\
    \ object instance returned.\n   ipCidrRouteEntry OBJECT-TYPE\n      SYNTAX   IpCidrRouteEntry\n\
    \      MAX-ACCESS not-accessible\n      STATUS   current\n      DESCRIPTION\n\
    \       \"A particular route to a particular destination,\n       under a particular\
    \ policy.\"\n      INDEX {\n        ipCidrRouteDest,\n        ipCidrRouteMask,\n\
    \        ipCidrRouteTos,\n        ipCidrRouteNextHop\n        }\n   A simple array-like\
    \ index works efficiently since it minimizes the\n   index size and complexity\
    \ while increasing the number of rows that\n   can be sent in a PDU.  If the indexing\
    \ is not sparse, concurrency can\n   be gained by sending multiple asynchronous\
    \ non-overlapping collection\n   requests as is explained in RFC 2819 [32], Page\
    \ 41 (in the section\n   pertaining to Host Group indexing).\n      Should requirements\
    \ dictate new methods of access, multiple\n      indices can be defined such that\
    \ both associative and simple\n      indexing can coexist to access a single logical\
    \ table.\n   Two examples follow.\n   First, consider the ifStackTable found in\
    \ RFC 2863 [20] and the\n   ifInvStackTable RFC 2864 [33].  They are logical equivalents\
    \ with the\n   order of the auxiliary (index) objects simply reversed.\n   ifStackEntry\
    \  OBJECT-TYPE\n        SYNTAX        IfStackEntry\n        MAX-ACCESS    not-accessible\n\
    \        STATUS        current\n        DESCRIPTION\n                \"Information\
    \ on a particular relationship between\n                two sub-layers, specifying\
    \ that one sub-layer runs\n                on 'top' of the other sub-layer.  Each\
    \ sub-layer\n                corresponds to a conceptual row in the ifTable.\"\
    \n                INDEX { ifStackHigherLayer, ifStackLowerLayer }\n        ::=\
    \ { ifStackTable 1 }\n   ifInvStackEntry  OBJECT-TYPE\n      SYNTAX        IfInvStackEntry\n\
    \      MAX-ACCESS    not-accessible\n      STATUS        current\n      DESCRIPTION\n\
    \          \"Information on a particular relationship between two\n          sub-layers,\
    \ specifying that one sub-layer runs underneath\n          the other sub-layer.\
    \  Each sub-layer corresponds to a\n          conceptual row in the ifTable.\"\
    \n          INDEX { ifStackLowerLayer, ifStackHigherLayer }\n      ::= { ifInvStackTable\
    \ 1 }\n   Second, table designs that can factor data into multiple tables with\n\
    \   well-defined relationships can help reduce overall data transfer\n   requirements.\
    \  The RMON-MIB, RFC 2819 [32], demonstrates a very\n   useful technique of organizing\
    \ tables into control and data\n   components.  Control tables contain those objects\
    \ that are configured\n   and change infrequently, and the data tables contain\
    \ information to\n   be collected that can be large and may change quite frequently.\n\
    \   As an example, the RMON hostControlTable provides a way to specify\n   how\
    \ to collect MAC addresses learned as a source or destination from\n   a given\
    \ port that provides transparent bridging of Ethernet packets.\n   Configuration\
    \ is accomplished using the hostControlTable.  It is\n   indexed by a simple integer.\
    \  While this may seem to be array-like,\n   it is common practice for command\
    \ generators to encode the ifIndex\n   into this simple integer to provide associative\
    \ lookup capability.\n   The RMON hostTable and hostTimeTable represent dependent\
    \ tables that\n   contain the results indexed by the hostControlTable entry.\n\
    \   The hostTable is further indexed by the MAC address which provides\n   the\
    \ ability to reasonably search for a collection, such as the\n   Organizationally\
    \ Unique Identifier (OUI), the first three octets of\n   the MAC address.\n  \
    \ The hostTimeTable is designed explicitly for fast transfer of bulk\n   RMON\
    \ data.  It demonstrates how to handle collecting large number of\n   rows in\
    \ the face of deletions and insertions by providing\n   hostControlLastDeleteTime.\n\
    \   hostControlLastDeleteTime OBJECT-TYPE\n   SYNTAX     TimeTicks\n   MAX-ACCESS\
    \ read-only\n   STATUS     current\n   DESCRIPTION\n       \"The value of sysUpTime\
    \ when the last entry\n       was deleted from the portion of the hostTable\n\
    \       associated with this hostControlEntry.  If no\n       deletions have occurred,\
    \ this value shall be zero.\"\n   ::= { hostControlEntry 4 }\n"
- title: 3.3.6.2.  Time Based Indexing
  contents:
  - "3.3.6.2.  Time Based Indexing\n   The TimeFilter as defined in RFC 2021 [44]\
    \ and used in RMON2-MIB and\n   Q-BRIDGE-MIB (RFC 2674 [26]) provides a way to\
    \ obtain only those rows\n   that have changed on or after some specified period\
    \ of time has\n   passed.\n   One drawback to TimeFilter index tables is that\
    \ a given row can\n   appear at many points in time, which artificially inflates\
    \ the size\n   of the table when performing standard getNext or getBulk data\n\
    \   retrieval.\n"
- title: 3.3.6.3.  Alternate Data Delivery Mechanisms
  contents:
  - "3.3.6.3.  Alternate Data Delivery Mechanisms\n   If the amount of data to transfer\
    \ is larger than current SNMP design\n   restrictions permit, as in the case of\
    \ OCTET STRINGS (64k minus\n   overhead of IP/UDP header plus SNMP header plus\
    \ varbind list plus\n   varbind encoding), consider delivery of the data via an\
    \ alternate\n   method, such as FTP and use a MIB module to control that data\n\
    \   delivery process.  In many cases, this problem can be avoided via\n   effective\
    \ MIB design.  In other words, object types requiring this\n   kind of transfer\
    \ size should be used judiciously, if at all.\n   There are many enterprise MIB\
    \ modules that provide control of the\n   TFTP or FTP protocol.  Often the SNMP\
    \ part defines what to send where\n   and setting an object initiates the operation\
    \ (for an example, refer\n   to the CISCO-FTP-CLIENT-MIB, discussed in [38]).\n\
    \   Various approaches exist for allowing a local agent process running\n   within\
    \ the managed node to take a template for an object instance\n   (for example\
    \ for a set of interfaces), and adapt and apply it to all\n   of the actual instances\
    \ within the node.  This is an architecture for\n   one form of policy-based configuration\
    \ (see [36], for example).  Such\n   an architecture, which must be designed into\
    \ the agent and some\n   portions of the MIB module, affords the efficiency of\
    \ specifying many\n   copies of instance data only once, along with the execution\n\
    \   efficiency of distributing the application of the instance data to\n   the\
    \ agent.\n   Other work is currently underway to improve efficiency for bulk SNMP\n\
    \   transfer operations [37].  The objective of these efforts is simply\n   the\
    \ conveyance of more information with less overhead.\n"
- title: 3.4.  More Index Design Issues
  contents:
  - "3.4.  More Index Design Issues\n   Section 3.3.5 described considerations for\
    \ table row index design as\n   it pertains to the synchronization of changes\
    \ within sizable table\n   rows. This section simply considers how to specify\
    \ this syntactically\n   and how to manage indices semantically.\n   In many respects,\
    \ the design issues associated with indices in a MIB\n   module are similar to\
    \ those in a database.  Care must be taken during\n   the design phase to determine\
    \ how often and what kind of information\n   must be set or retrieved.  The next\
    \ few points provide some guidance.\n"
- title: 3.4.1.  Simple Integer Indexing
  contents:
  - "3.4.1.  Simple Integer Indexing\n   When indexing tables using simple Integer32\
    \ or Unsigned32, start with\n   one (1) and specify the maximum range of the value.\
    \  Since object\n   identifiers are unsigned long values, a question that arises\
    \ is why\n   not index from zero (0) instead of one(1)?\n   RFC 2578 [2], Section\
    \ 7.7, page 28 states the following: Instances\n   identified by use of integer-valued\
    \ objects should be numbered\n   starting from one (i.e., not from zero).  The\
    \ use of zero as a value\n   for an integer-valued index object type should be\
    \ avoided, except in\n   special cases.  Consider the provisions afforded by the\
    \ following\n   textual convention from the Interfaces Group MIB module [33]:\n\
    \   InterfaceIndexOrZero ::= TEXTUAL-CONVENTION\n       DISPLAY-HINT \"d\"\n \
    \      STATUS       current\n       DESCRIPTION\n           \"This textual convention\
    \ is an extension of the\n           InterfaceIndex convention.  The latter defines\
    \ a greater\n           than zero value used to identify an interface or interface\n\
    \           sub-layer in the managed system.  This extension permits the\n   \
    \        additional value of zero.  the value zero is object-specific\n      \
    \     and must therefore be defined as part of the description of\n          \
    \ any object which uses this syntax.  Examples of the usage of\n           zero\
    \ might include situations where interface was unknown,\n           or when none\
    \ or all interfaces need to be referenced.\"\n       SYNTAX       Integer32 (0..2147483647)\n"
- title: 3.4.2.  Indexing with Network Addresses
  contents:
  - "3.4.2.  Indexing with Network Addresses\n   There are many objects that use IPv4\
    \ addresses (SYNTAX IpAddress) as\n   indexes.  One such table is the ipAddrTable\
    \ from RFC 2011 [14] IP-\n   MIB.  This limits the usefulness of the MIB module\
    \ to IPv4.  To avoid\n   such limitations, use the addressing textual conventions\
    \ INET-\n   ADDRESS-MIB [13] (or updates to that MIB module), which provides a\n\
    \   generic way to represent addresses for Internet Protocols.  In using\n   the\
    \ InetAddress textual convention in this MIB, however, pay heed to\n   the following\
    \ advisory found in its description clause:\n      When this textual convention\
    \ is used as the syntax of an index\n      object, there may be issues with the\
    \ limit of 128 sub-identifiers\n      specified in SMIv2, STD 58.  In this case,\
    \ the OBJECT-TYPE\n      declaration MUST include a 'SIZE' clause to limit the\
    \ number of\n      potential instance sub-identifiers.\n   One should consider\
    \ the SMI limitation on the 128 sub-identifier\n   specification when using certain\
    \ kinds of network address index\n   types.  The most likely practical liability\
    \ encountered in practice\n   has been with DNS names, which can in fact be in\
    \ excess of 128 bytes.\n   The problem can be, of course, compounded when multiple\
    \ indices of\n   this type are specified for a table.\n"
- title: 3.5.  Conflicting Controls
  contents:
  - "3.5.  Conflicting Controls\n   MIB module designers should avoid specifying read-write\
    \ objects that\n   overlap in function partly or completely.\n   Consider the\
    \ following situation where two read-write objects\n   partially overlap when\
    \ a dot1dBasePortEntry has a corresponding\n   ifEntry.\n   The BRIDGE-MIB defines\
    \ the following managed object:\n   dot1dStpPortEnable OBJECT-TYPE\n       SYNTAX\
    \  INTEGER {\n                   enabled(1),\n                   disabled(2) \
    \           }\n       ACCESS  read-write\n       STATUS  mandatory\n       DESCRIPTION\n\
    \           \"The enabled/disabled status of the port.\"\n       REFERENCE\n \
    \          \"IEEE 802.1D-1990: Section 4.5.5.2\"\n       ::= { dot1dStpPortEntry\
    \ 4 }\n   The IF-MIB defines a similar managed object:\n   ifAdminStatus OBJECT-TYPE\n\
    \       SYNTAX  INTEGER {\n                   up(1),       -- ready to pass packets\n\
    \                   down(2),\n                   testing(3)   -- in some test\
    \ mode\n               }\n       MAX-ACCESS  read-write\n       STATUS      current\n\
    \       DESCRIPTION\n           \"The desired state of the interface.  The testing(3)\n\
    \           state indicates that no operational packets can be\n           passed.\
    \  When a managed system initializes, all\n           interfaces start with ifAdminStatus\
    \ in the down(2) state.\n           As a result of either explicit management\
    \ action or per\n           configuration information retained by the managed\
    \ system,\n           ifAdminStatus is then changed to either the up(1) or\n \
    \          testing(3) states (or remains in the down(2) state).\"\n       ::=\
    \ { ifEntry 7 }\n   If ifAdminStatus is set to testing(3), the value to be returned\
    \ for\n   dot1dStpPortEnable is not defined.  Without clarification on how\n \
    \  these two objects interact, management implementations will have to\n   monitor\
    \ both objects if bridging is detected and correlate behavior.\n   The dot1dStpPortEnable\
    \ object type could have been written with more\n   information about the behavior\
    \ of this object when values of\n   ifAdminStatus which impact it change.  For\
    \ example, text could be\n   added that described proper return values for the\
    \ dot1dStpPortEnable\n   object instance for each of the possible values of ifAdminStatus.\n\
    \   In those cases where overlap between objects is unavoidable, then as\n   we\
    \ have just described, care should be taken in the description of\n   each of\
    \ the objects to describe their possible interactions.  In the\n   case of an\
    \ object type defined after an incumbent object type, it is\n   necessary to include\
    \ in the DESCRIPTION of this later object type the\n   details of these interactions.\n"
- title: 3.6.  Textual Convention Usage
  contents:
  - "3.6.  Textual Convention Usage\n   Textual conventions should be used whenever\
    \ possible to create a\n   consistent semantic for an oft-recurring datatype.\n\
    \   MIB modules often define a binary state object such as enable/disable\n  \
    \ or on/off.  Current practice is to use existing Textual Conventions\n   and\
    \ define the read-write object in terms of a TruthValue from\n   SNMPv2-TC [3].\
    \  For example, the Q-BRIDGE-MIB [26] defines:\n   dot1dTrafficClassesEnabled\
    \ OBJECT-TYPE\n       SYNTAX      TruthValue\n       MAX-ACCESS  read-write\n\
    \       STATUS      current\n       DESCRIPTION\n          \"The value true(1)\
    \ indicates that Traffic Classes are\n          enabled on this bridge.  When\
    \ false(2), the bridge\n          operates with a single priority level for all\
    \ traffic.\"\n       DEFVAL      { true }\n       ::= { dot1dExtBase 2 }\n   Textual\
    \ conventions that have a reasonable chance of being reused in\n   other MIB modules\
    \ ideally should also be defined in a separate MIB\n   module to facilitate sharing\
    \ of such object types.  For example, all\n   ATM MIB modules draw on the ATM-TC-MIB\
    \ [39] to reference and utilize\n   common definitions for addressing, service\
    \ class values, and the\n   like.\n   To simplify management, it is recommended\
    \ that existing SNMPv2-TC\n   based definitions be used when possible.  For example,\
    \ consider the\n   following object definition:\n   acmePatioLights OBJECT-TYPE\n\
    \       SYNTAX  INTEGER {\n                   on(1),\n                   off(2),\n\
    \       }\n       MAX-ACCESS  read-write\n       STATUS      current\n       DESCRIPTION\n\
    \           \"Current status of outdoor lighting.\"\n       ::= { acmeOutDoorElectricalEntry\
    \ 3 }\n   This could be defined as follows using existing SNMPv2-TC TruthValue.\n\
    \   acmePatioLightsOn OBJECT-TYPE\n       SYNTAX  TruthValue\n       MAX-ACCESS\
    \  read-write\n       STATUS      current\n       DESCRI2096PTION\n          \
    \ \"Current status of outdoor lighting.  When set to true (1),\n           this\
    \ means that the lights are enabled and turned on.\n           When set to false\
    \ (2), the lights are turned off.\"\n        ::= { acmeOutDoorElectricalEntry\
    \ 3 }\n"
- title: 3.7.  Persistent Configuration
  contents:
  - "3.7.  Persistent Configuration\n   Many network devices have two levels of persistence\
    \ with regard to\n   configuration data.  In the first case, the configuration\
    \ data sent\n   to the device is persistent only until changed with a subsequent\n\
    \   configuration operation, or the system is reinitialized.  The second\n   level\
    \ is where the data is made persistent as an inherent part of the\n   acceptance\
    \ of the configuration information.  Some configuration\n   shares both these\
    \ properties, that is, that on acceptance of new\n   configuration data it is\
    \ saved permanently and in memory.  Neither of\n   these necessarily means that\
    \ the data is used by the operational\n   code.  Sometimes separate objects are\
    \ required to activate this new\n   configuration data for use by the operational\
    \ code.\n   However, many SNMP agents presently implement simple persistence\n\
    \   models, which do not reflect all the relationships of the\n   configuration\
    \ data to the actual persistence model as described\n   above.  Some SNMP set\
    \ requests against MIB objects with MAX-ACCESS\n   read-write are written automatically\
    \ to a persistent store. In other\n   cases, they are not.  In some of the latter\
    \ cases, enterprise MIB\n   objects are required in order to get standard configuration\
    \ stored,\n   thus making it difficult for a generic application to have a\n \
    \  consistent effect.\n   There are standard conventions for saving configuration\
    \ data.  The\n   first method uses the Textual Convention known as StorageType\
    \ [3]\n   which explicitly defines a given row's persistence requirement.\n  \
    \ Examples include the RFC 3231 [25] definition for the schedTable row\n   object\
    \ schedStorageType of syntax StorageType, as well as similar row\n   objects for\
    \ virtually all of the tables of the SNMP View-based Access\n   Control Model\
    \ MIB [10].\n   A second method for persistence simply uses the DESCRIPTION clause\
    \ to\n   define how instance data should persist.  RFC 2674 [26] explicitly\n\
    \   defines Dot1qVlanStaticEntry data persistence as follows:\n   dot1qVlanStaticTable\
    \ OBJECT-TYPE\n       SYNTAX      SEQUENCE OF Dot1qVlanStaticEntry\n       MAX-ACCESS\
    \  not-accessible\n       STATUS      current\n       DESCRIPTION\n        \"\
    A table containing static configuration information for\n        each VLAN configured\
    \ into the device by (local or\n        network) management.  All entries are\
    \ permanent and will\n        be restored after the device is reset.\"\n     \
    \  ::= { dot1qVlan 3 }\n   The current practice is a dual persistence model where\
    \ one can make\n   changes to run-time configuration as well as to a non-volatile\n\
    \   configuration read at device initialization.  The DISMAN-SCHEDULE-MIB\n  \
    \ module [25] provides an example of this practice.  A row entry of its\n   SchedTable\
    \ specifies the parameters by which an agent MIB variable\n   instance can be\
    \ set to a specific value at some point in time and\n   governed by other constraints\
    \ and directives.  One of those is:\n   schedStorageType OBJECT-TYPE\n       \
    \ SYNTAX      StorageType\n        MAX-ACCESS  read-create\n        STATUS   \
    \   current\n        DESCRIPTION\n            \"This object defines whether this\
    \ scheduled action is kept\n             in volatile storage and lost upon reboot\
    \ or if this row is\n             backed up by non-volatile or permanent storage.\n\
    \             Conceptual rows having the value `permanent' must allow\n      \
    \       write access to the columnar objects schedDescr,\n             schedInterval,\
    \ schedContextName, schedVariable, schedValue,\n             and schedAdminStatus.\
    \  If an implementation supports the\n             schedCalendarGroup, write access\
    \ must be also allowed to\n             the columnar objects schedWeekDay, schedMonth,\
    \ schedDay,\n             schedHour, schedMinute.\"\n        DEFVAL { volatile\
    \ }\n        ::= { schedEntry 19 }\n   It is important, however, to reiterate\
    \ that the persistence is\n   ultimately controlled by the capabilities and features\
    \ (with respect\n   to the storage model of management data) of the underlying\
    \ system on\n   which the MIB Module agent is being implemented.  This falls into\n\
    \   very much the same kind of issue set as, for example, the situation\n   where\
    \ the size of data storage in the system for a Counter object\n   type is not\
    \ the same as that in the corresponding MIB Object Type.\n   To generalize, the\
    \ final word on the \"when\" and \"how\" of storage of\n   persistent data is\
    \ dictated by the system and the implementor of the\n   agent on the system.\n"
- title: 3.8.  Configuration Sets and Activation
  contents:
  - "3.8.  Configuration Sets and Activation\n   An essential notion for configuration\
    \ of network elements with SNMP\n   is awareness of the difference between the\
    \ set of one or more\n   configuration objects from the activation of those configuration\n\
    \   changes in the actual subsystem.  That is, it often only makes sense\n   to\
    \ activate a group of objects as a single 'transaction'.\n"
- title: 3.8.1.  Operational Activation Considerations
  contents:
  - "3.8.1.  Operational Activation Considerations\n   A MIB module design must consider\
    \ the implications of the preceding\n   in the context of changes that will occur\
    \ throughout a subsystem when\n   changes are activated.  This is particularly\
    \ true for configuration\n   changes that are complex.  This complexity can be\
    \ in terms of\n   configuration data or the operational ramifications of the activation\n\
    \   of the changes in the managed subsystem.  A practical technique to\n   accommodate\
    \ this kind of activation is the partitioning of contained\n   configuration sets,\
    \ as it pertains to their being activated as\n   changes.  Any complex configuration\
    \ should have a master on/off\n   switch (MIB object type) as well as strategically\
    \ placed on/off\n   switches that partition the activation of configuration data\
    \ in the\n   managed subsystem.  These controls play a pivotal role during the\n\
    \   configuration process as well as during subsequent diagnostics.\n   Generally,\
    \ a series of set operations should not cause an agent to\n   activate each object,\
    \ causing operational instability to be\n   introduced with every changed object\
    \ instance.  To avoid this\n   liability, ideally a series of Set PDUs can install\
    \ the configuration\n   and a final set series of PDUs can activate the changes.\n\
    \   During diagnostic situations, certain on/off switches can be set to\n   localize\
    \ the perceived error instead of having to remove the\n   configuration.\n   An\
    \ example of such an object from the OSPF Version 2 MIB [29] is the\n   global\
    \ ospfAdminStat:\n   ospfAdminStat OBJECT-TYPE\n       SYNTAX   Status\n     \
    \  MAX-ACCESS   read-write\n       STATUS   current\n       DESCRIPTION\n    \
    \      \"The administrative status of  OSPF  in the\n          router.  The value\
    \ 'enabled' denotes that the\n          OSPF Process is active on at least one\
    \ interface;\n          'disabled' disables it on all interfaces.\"\n      ::=\
    \ { ospfGeneralGroup 2 }\n   Elsewhere in the OSPF MIB, the semantics of setting\
    \ ospfAdminStat to\n   enabled(2) are clearly spelled out.\n   The Scheduling\
    \ MIB [25] exposes such an object on each entry in the\n   scheduled actions table,\
    \ along with the corresponding stats object\n   type (with read-only ACCESS) on\
    \ the scheduled actions row instance.\n   This reflects a recurring basic design\
    \ pattern which brings about\n   semantic clarity in the object type usage.  A\
    \ table can expose one\n   columnar object type which is strictly for administrative\
    \ control.\n   When read, an instance of this object type will reflect its last\
    \ set\n   or defaulted value.  A companion operational columnar object type,\n\
    \   with MAX-ACCESS of read-only, provides the current state of\n   activation\
    \ or deactivation resulting from the last set of the\n   administrative columnar\
    \ instance.  It is fully expected that these\n   administrative and operational\
    \ columnar instances may reflect\n   different values over some period of time\
    \ of activation latency,\n   which is why they are separate.  Further sections\
    \ display some of the\n   problems which can result from attempting to combine\
    \ the operational\n   and administrative row columns into a single object type.\n\
    \   Note that all of this is independent of the RowStatus columnar\n   object,\
    \ and the notion of 'activation' as it pertains to RowStatus.\n   A defined RowStatus\
    \ object type should be strictly concerned with the\n   management of the table\
    \ row itself (with 'activation' indicating \"the\n   conceptual row is available\
    \ for use by the managed device\" [3], and\n   not to be confused with any operational\
    \ activation semantics).\n   In the following example, schedAdminStatus controls\
    \ activation of the\n   scheduled action, and schedOperStatus reports on its operational\n\
    \   status:\n   schedAdminStatus OBJECT-TYPE\n       SYNTAX      INTEGER {\n \
    \                      enabled(1),\n                       disabled(2)\n     \
    \              }\n       MAX-ACCESS  read-create\n       STATUS      current\n\
    \       DESCRIPTION\n           \"The desired state of the schedule.\"\n     \
    \  DEFVAL { disabled }\n       ::= { schedEntry 14 }\n   schedOperStatus OBJECT-TYPE\n\
    \       SYNTAX      INTEGER {\n                       enabled(1),\n          \
    \             disabled(2),\n                       finished(3)\n             \
    \      }\n       MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \           \"The current operational state of this schedule.  The state\n   \
    \         enabled(1) indicates this entry is active and that the\n           \
    \ scheduler will invoke actions at appropriate times.  The\n            disabled(2)\
    \ state indicates that this entry is currently\n            inactive and ignored\
    \ by the scheduler.  The finished(3)\n            state indicates that the schedule\
    \ has ended.  Schedules\n            in the finished(3) state are ignored by the\
    \ scheduler.\n            A one-shot schedule enters the finished(3) state when\
    \ it\n            deactivates itself.\"\n       ::= { schedEntry 15 }\n"
- title: 3.8.2.  RowStatus and Deactivation
  contents:
  - "3.8.2.  RowStatus and Deactivation\n   RowStatus objects should not be used to\
    \ control\n   activation/deactivation of a configuration.  While RowStatus looks\n\
    \   ideally suited for such a purpose since a management application can\n   set\
    \ a row to active(1), then set it to notInService(2) to disable it\n   then make\
    \ it active(1) again, there is no guarantee that the agent\n   won't discard the\
    \ row while it is in the notInService(2) state.  RFC\n   2579 [3], page 15 states:\n\
    \      The agent must detect conceptual rows that have been in either\n      state\
    \ for an abnormally long period of time and remove them.  It\n      is the responsibility\
    \ of the DESCRIPTION clause of the status\n      column to indicate what an abnormally\
    \ long period of time would\n      be.\n   The DISMAN-SCHEDULE-MIB's managed object\
    \ schedAdminStatus\n   demonstrates how to separate row control from row activation.\n\
    \   Setting the schedAdminStatus to disabled(2) does not cause the row to\n  \
    \ be aged out/removed from the table.\n   Finally, a reasonable agent implementation\
    \ must consider how many\n   rows will be allowed to be created in the notReady/notInService\
    \ state\n   such that resources are not exhausted by an errant application.\n"
- title: 3.9.  SET Operation Latency
  contents:
  - "3.9.  SET Operation Latency\n   Many standards track and enterprise MIB modules\
    \ that contain read-\n   write objects assume that an agent can complete a set\
    \ operation as\n   quickly as an agent can send back the status of the set operation\
    \ to\n   the application.\n   Consider the subtle operational shortcomings in\
    \ the following object.\n   It both reports the current state and allows a SET\
    \ operation to\n   change to a possibly new state.\n"
- title: wheelRotationState  OBJECT-TYPE
  contents:
  - "wheelRotationState  OBJECT-TYPE\n      SYNTAX        INTEGER { unknown(0),\n\
    \                              idle(1),\n                              spinClockwise(2),\n\
    \                              spinCounterClockwise(3)\n                     \
    \        }\n      MAX-ACCESS    read-write\n      STATUS        current\n    \
    \  DESCRIPTION\n      \"The current state of a wheel.\"\n  ::= { XXX 2 }\n"
- title: With the object defined, the following example represents one possible
  contents:
  - 'With the object defined, the following example represents one possible

    '
- title: transaction.
  contents:
  - 'transaction.

    '
- title: Time  Command Generator --------> <--- Command Responder
  contents:
  - 'Time  Command Generator --------> <--- Command Responder

    '
- title: '----- -----------------                -----------------'
  contents:
  - '----- -----------------                -----------------

    '
- title: '|'
  contents:
  - '|

    '
- title: A  GetPDU(wheelRotationState.1.1)
  contents:
  - 'A  GetPDU(wheelRotationState.1.1)

    '
- title: '|'
  contents:
  - '|

    '
- title: '|                          ResponsePDU(error-index 0,'
  contents:
  - '|                          ResponsePDU(error-index 0,

    '
- title: '|                                       error-code 0)'
  contents:
  - '|                                       error-code 0)

    '
- title: '|'
  contents:
  - '|

    '
- title: B                          wheelRotationState.1.1 == spinClockwise(2)
  contents:
  - 'B                          wheelRotationState.1.1 == spinClockwise(2)

    '
- title: '|'
  contents:
  - '|

    '
- title: C  SetPDU(wheelRotationState.1.1 =
  contents:
  - 'C  SetPDU(wheelRotationState.1.1 =

    '
- title: '|                   spinCounterClockwise(3)'
  contents:
  - '|                   spinCounterClockwise(3)

    '
- title: '|'
  contents:
  - '|

    '
- title: '|                          ResponsePDU(error-index 0,'
  contents:
  - '|                          ResponsePDU(error-index 0,

    '
- title: '|                                       error-code 0)'
  contents:
  - '|                                       error-code 0)

    '
- title: '|'
  contents:
  - '|

    '
- title: D                          wheelRotationState.1.1
  contents:
  - "D                          wheelRotationState.1.1\n                         \
    \                  == spinCounterClockwise(3)\n"
- title: '|'
  contents:
  - '|

    '
- title: E  GetPDU(wheelRotationState.1.1)
  contents:
  - 'E  GetPDU(wheelRotationState.1.1)

    '
- title: '|'
  contents:
  - '|

    '
- title: F                          ResponsePDU(error-index 0,
  contents:
  - 'F                          ResponsePDU(error-index 0,

    '
- title: '|                                       error-code 0)'
  contents:
  - '|                                       error-code 0)

    '
- title: '|'
  contents:
  - '|

    '
- title: V                          wheelRotationState.1.1 == spinClockwise(2)
  contents:
  - "V                          wheelRotationState.1.1 == spinClockwise(2)\n   ....some\
    \ time, perhaps seconds, later....\n"
- title: '|'
  contents:
  - '|

    '
- title: G       GetPDU(wheelRotationState.1.1)
  contents:
  - 'G       GetPDU(wheelRotationState.1.1)

    '
- title: '|'
  contents:
  - '|

    '
- title: H                         ResponsePDU(error-index 0,
  contents:
  - 'H                         ResponsePDU(error-index 0,

    '
- title: '|                                      error-code 0)'
  contents:
  - '|                                      error-code 0)

    '
- title: '|                       wheelRotationState.1.1'
  contents:
  - '|                       wheelRotationState.1.1

    '
- title: V                                          == spinCounterClockwise(3)
  contents:
  - "V                                          == spinCounterClockwise(3)\n   The\
    \ response to the GET request at time E will often confuse\n   management applications\
    \ that assume the state of the object should be\n   spinCounterClockwise(3). \
    \ In reality, the wheel is slowing down in\n   order to come to the idle state\
    \ then begin spinning counter\n   clockwise.\n   This possibility of confusing\
    \ and paradoxical interactions of\n   administrative and operational state is\
    \ inevitable when a single\n   object type is used to control and report on both\
    \ types of state.\n   One common practice which we have already seen is to separate\
    \ out the\n   desired (settable) state from current state.  The objects\n   ifAdminStatus\
    \ and ifOperStatus from RFC 2863 [20] provide such an\n   example of the separation\
    \ of objects into desired and current state.\n"
- title: 3.9.1.  Subsystem Latency, Persistence Latency, and Activation Latency
  contents:
  - "3.9.1.  Subsystem Latency, Persistence Latency, and Activation Latency\n   A\
    \ second way latency can be introduced in SET operations is caused by\n   delay\
    \ in agent implementations that must interact with loosely\n   coupled subsystems.\
    \  The time it takes the instrumented system to\n   accept the new configuration\
    \ information from the SNMP agent, process\n   it and 'install' the updated configuration\
    \ in the system or otherwise\n   process the directives can often be longer than\
    \ the SNMP response\n   timeout.\n   In these cases, it is desirable to provide\
    \ a \"current state\" object\n   type which can be polled by the management application\
    \ to determine\n   the state of control of the loosely coupled subsystem which\
    \ was\n   affected by its configuration update.\n   More generally, some MIB objects\
    \ may have high latencies associated\n   with changes to their values.  This could\
    \ be either a function of\n   saving the changed value to a persistent storage\
    \ type, and/or\n   activating a subsystem that inherently has high latency as\
    \ discussed\n   above.  When defining such MIB objects, it might be wise to have\
    \ the\n   agent process set operations in the managed subsystem as soon as the\n\
    \   Set PDU has been processed, and then update appropriate status\n   objects\
    \ when the save-to- persistent storage and (if applicable)\n   activation has\
    \ succeeded or is otherwise complete.  Another approach\n   would be to cause\
    \ a notification to be sent that indicates that the\n   operation has been completed.\n\
    \   When you describe an activation object, the DESCRIPTION clauses for\n   these\
    \ objects should give a hint about the likely latency for the\n   completion of\
    \ the operation.  Keep in mind that from a management\n   software perspective\
    \ (as presented in the example of schedAdminStatus\n   in Section 3.8.1), the\
    \ combined latency of saving-to-persistence and\n   activation are not distinguishable\
    \ when they are part of a single\n   operation.\n"
- title: 3.10.  Notifications and Error Reporting
  contents:
  - "3.10.  Notifications and Error Reporting\n   For the purpose of this section,\
    \ a 'notification' is as described in\n   the SMIv2, RFC 2578 [2], by the NOTIFICATION-TYPE\
    \ macro.\n   Notifications can be sent in either SNMPv2c [19] or SNMPv3 TRAP or\n\
    \   InformRequest PDUs.  Given the sensitivity of configuration\n   information,\
    \ it is recommended that configuration operations always\n   be performed using\
    \ SNMPv3 due to its enhanced security capabilities.\n   InformRequest PDUs should\
    \ be used in preference to TRAP PDUs since\n   the recipient of the InformRequest\
    \ PDUs responds with a Response PDU.\n   This acknowledgment can be used to avoid\
    \ unnecessary retransmission\n   of NOTIFICATION-TYPE information when retransmissions\
    \ are in fact\n   required.  The use of InformRequest PDUs (as opposed to TRAPs)\
    \ is not\n   at the control of the MIB module designer or agent implementor. \
    \ The\n   determination as to whether or not a TRAP or InformRequest PDU is\n\
    \   sent from an SNMPv2c or SNMPv3 agent is generally a function of the\n   agent's\
    \ local configuration (but can be controlled with MIB objects\n   in SNMPv3).\
    \  To the extent notification timeout and retry values are\n   determined by local\
    \ configuration parameters, care should be taken to\n   avoid unnecessary retransmission\
    \ of InformRequest PDUs.\n   Configuration change and error information conveyed\
    \ in InformRequest\n   PDUs can be an important part of an effective SNMP-based\
    \ management\n   system.  They also have the potential to be overused.  This section\n\
    \   offers some guidance for effective definition of NOTIFICATION-TYPE\n   information\
    \ about configuration changes that can be carried in\n   InformRequest PDUs. \
    \ Notifications can also play a key role for all\n   kinds of error reporting\
    \ from hardware failures to configuration and\n   general policy errors.  These\
    \ types of notifications should be\n   designed as described in Section 3.11 (Application\
    \ Error Reporting).\n"
- title: 3.10.1.  Identifying Source of Configuration Changes
  contents:
  - "3.10.1.  Identifying Source of Configuration Changes\n   A NOTIFICATION-TYPE\
    \ designed to report configuration changes should\n   report the identity of the\
    \ management entity initiating the\n   configuration change.  Specifically, if\
    \ the entity is known to be a\n   SNMP command generator, the transport address\
    \ and SNMP parameters as\n   found in table snmpTargetParamsTable from RFC 3413\
    \ SNMP-TARGET-MIB\n   should be reported where  possible.  For reporting of configuration\n\
    \   changes outside of the SNMP domain, the applicable change mechanism\n   (for\
    \ example, CLI vs. HTTP-based management client access) should be\n   reported,\
    \ along with whatever notion of \"user ID\" of the change\n   initiator is applicable\
    \ and available.\n"
- title: 3.10.2.  Limiting Unnecessary Transmission of Notifications
  contents:
  - "3.10.2.  Limiting Unnecessary Transmission of Notifications\n   The design of\
    \ event-driven synchronization models, essential to\n   configuration management,\
    \ can use notifications as an important\n   enabling technique.  Proper usage\
    \ of notifications allows the\n   manager's view of the managed element's configuration\
    \ to be in close\n   synchronization with the actual state of the configuration\
    \ of the\n   managed element.\n   When designing new NOTIFICATION-TYPEs, consider\
    \ how to limit the\n   number of notifications PDUs that will be sent with the\
    \ notification\n   information defined in the NOTIFICATION-TYPE in response to\
    \ a\n   configuration change or error event.\n   InformRequest PDUs, when compared\
    \ to TRAP PDUs, have an inherent\n   advantage when the concern is the reduction\
    \ of unnecessary messages\n   from the system generating the NOTIFICATION-TYPE\
    \ data, when in fact\n   retransmission of this data is required.  That is, an\
    \ InformRequest\n   PDU is acknowledged by the receiving entity with a Response\
    \ PDU.  The\n   receipt of this response allows the entity which generated the\n\
    \   InformRequest PDU to verify (and record an audit entry, where such\n   facilities\
    \ exist on the agent system) that the message was received.\n   As a matter of\
    \ notification protocol, this receipt guarantee is not\n   available when using\
    \ TRAP PDUs, and if it is required, must be\n   accomplished by the agent using\
    \ some mechanism out of band to SNMP,\n   and usually requiring the penalty of\
    \ polling.\n   Regardless of the specific PDUs used to convey them, one way to\
    \ limit\n   the unnecessary generation of notifications is to include in the\n\
    \   NOTIFICATION-TYPE definition situations where it need not be sent.  A\n  \
    \ good example is the frDLCIStatusChange defined in FRAME-RELAY-DTE-\n   MIB,\
    \ RFC 2115 [21].\n   frDLCIStatusChange NOTIFICATION-TYPE\n       OBJECTS  { frCircuitState\
    \ }\n       STATUS      current\n       DESCRIPTION\n          \"This trap indicates\
    \ that the indicated Virtual Circuit\n          has changed state.  It has either\
    \ been created or\n          invalidated, or has toggled between the active and\n\
    \          inactive states.  If, however, the reason for the state\n         \
    \ change is due to the DLCMI going down, per-DLCI traps\n          should not\
    \ be generated.\"\n   ::= { frameRelayTraps 1 }\n   There are a number of other\
    \ techniques which can be used to reduce\n   the unwanted generation of NOTIFICATION-TYPE\
    \ information.  When\n   defining notifications, the designer can specify a number\
    \ of temporal\n   limitations on the generation of specific instances of a\n \
    \  NOTIFICATION-TYPE.  For example, a definition could specify that\n   messages\
    \ will not be sent more frequently than once every 60 seconds\n   while the condition\
    \ which led to the generation of the notification\n   persists.  Alternately,\
    \ a NOTIFICATION-TYPE DESCRIPTION clause could\n   provide a fixed limit on the\
    \ number of messages sent over the\n   duration of the condition leading to sending\
    \ the notification.\n   If NOTIFICATION-TYPE transmission is \"aggregated\" in\
    \ some way -\n   bounded either temporally or by absolute system state change\
    \ as\n   described above - the optimal design technique is to have the data\n\
    \   delivered with the notification reference the actual number of\n   underlying\
    \ managed element transitions which brought about the\n   notification.  No matter\
    \ which threshold is chosen to govern the\n   actual transmission of NOTIFICATION-TYPEs,\
    \ the idea is to describe an\n   aggregated event or related set of events in\
    \ as few PDUs as possible.\n"
- title: 3.10.3.  Control of Notification Subsystem
  contents:
  - "3.10.3.  Control of Notification Subsystem\n   There are standards track MIB\
    \ modules that define objects that either\n   augment or overlap control of notifications.\
    \  For instance, FRAME-\n   RELAY-DTE-MIB RFC 2115 defines frTrapMaxRate and DOCS-CABLE-DEVICE-\n\
    \   MIB defines a set of objects in docsDevEvent that provide for rate\n   limiting\
    \ and filtering of notifications.\n   In the past, agents did not have a standard\
    \ means to configure a\n   notification generator.  With the availability of the\
    \ SNMP-\n   NOTIFICATION-MIB module in RFC 3413 [9], it is strongly recommended\n\
    \   that the filtering functions of this MIB module be used.  This MIB\n   facilitates\
    \ the mapping of given NOTIFICATION-TYPEs and their\n   intended recipients.\n\
    \   If the mechanisms of the SNMP-NOTIFICATION-MIB are not suitable for\n   this\
    \ application, a explanation of why they are not suitable should\n   be included\
    \ in the DESCRIPTION clause of any replacement control\n   objects.\n"
- title: 3.11.  Application Error Reporting
  contents:
  - "3.11.  Application Error Reporting\n   MIB module designers should not rely on\
    \ the SNMP protocol error\n   reporting mechanisms alone to report application\
    \ layer error state\n   for objects that accept SET operations.\n   Most MIB modules\
    \ that exist today provide very little detail as to\n   why a configuration request\
    \ has failed.  Often the only information\n   provided is via SNMP protocol errors\
    \ which generally does not provide\n   enough information about why an agent rejected\
    \ a set request.\n   Typically, there is an incumbent and sizable burden on the\n\
    \   configuration application to determine if the configuration request\n   failure\
    \ is the result of a resource issue, a security issue, or an\n   application error.\n\
    \   Ideally, when a \"badValue\" error occurs for a given set request, an\n  \
    \ application can query the agent for more details on the error.  A\n   badValue\
    \ does not necessarily mean the command generator sent bad\n   data.  An agent\
    \ could be at fault.  Additional detailed diagnostic\n   information may aid in\
    \ diagnosing conditions in the integrated\n   system.\n   Consider the requirement\
    \ of conveying error information about a MIB\n   expression 'object' set within\
    \ the DISMAN-EXPRESSION-MIB [40] that\n   occurs when the expression is evaluated.\
    \  Clearly, none of the\n   available protocol errors are relevant when reporting\
    \ an error\n   condition that occurs when an expression is evaluated.  Instead,\
    \ the\n   DISMAN-EXPRESSION-MIB provides objects to report such errors (the\n\
    \   expErrorTable).  Instead, the expErrorTable maintains information\n   about\
    \ errors that occur at evaluation time:\n    expErrorEntry OBJECT-TYPE\n     \
    \   SYNTAX      ExpErrorEntry\n        MAX-ACCESS  not-accessible\n        STATUS\
    \      current\n        DESCRIPTION\n        \"Information about errors in processing\
    \ an expression.\n        Entries appear in this table only when there is a matching\n\
    \        expExpressionEntry and then only when there has been an\n        error\
    \ for that expression as reflected by the error codes\n        defined for expErrorCode.\"\
    \n   INDEX       { expExpressionOwner, expExpressionName }\n   More specifically,\
    \ a MIB module can provide configuration\n   applications with information about\
    \ errors on the managed device by\n   creating columnar object types in log tables\
    \ that contain error\n   information particular to errors that occur on row activation.\n\
    \   Notifications with detailed failure information objects can also be\n   used\
    \ to signal configuration failures.  If this approach is used, the\n   configuration\
    \ of destinations for NOTIFICATION-TYPE data generated\n   from configuration\
    \ failures should be considered independently of the\n   those for other NOTIFICATION-TYPEs\
    \ which are generated for other\n   operational reasons.  In other words, in many\
    \ management\n   environments, the network operators interested in NOTIFICATION-TYPEs\n\
    \   generated from configuration failures may not completely overlap with\n  \
    \ the community of network operators interested in NOTIFICATION-TYPEs\n   generated\
    \ from, for example, network interface failures.\n"
- title: 3.12.  Designing MIB Modules for Multiple Managers
  contents:
  - "3.12.  Designing MIB Modules for Multiple Managers\n   When designing a MIB module\
    \ for configuration, there are several\n   pertinent considerations to provide\
    \ support for multiple managers.\n   The first is to avoid any race conditions\
    \ between two or more\n   authorized management applications issuing SET protocol\
    \ operations\n   spanning over more than a single PDU.\n   The standard textual\
    \ convention document [3] defines TestAndIncr,\n   often called a spinlock, which\
    \ is used to avoid race conditions.\n   A MIB module designer may explicitly define\
    \ a synchronization object\n   of syntax TestAndIncr or may choose to rely on\
    \ snmpSetSerialNo (a\n   global spinlock object) as defined in SNMPv2-MIB.\n \
    \  snmpSetSerialNo OBJECT-TYPE\n   SYNTAX     TestAndIncr\n   MAX-ACCESS read-write\n\
    \   STATUS     current\n   DESCRIPTION\n           \"An advisory lock used to\
    \ allow several cooperating\n           command generator applications to coordinate\
    \ their\n           use of the SNMP set operation.\n           This object is\
    \ used for coarse-grain coordination.\n           To achieve fine-grain coordination,\
    \ one or more similar\n           objects might be defined within each MIB group,\
    \ as\n           appropriate.\"\n   ::= { snmpSet 1 }\n   Another prominent TestAndIncr\
    \ example can be found in the SNMP-\n   TARGET- MIB [9], snmpTargetSpinLock.\n\
    \   Secondly, an agent should be able to report configuration as set by\n   different\
    \ entities as distinguishable from configuration defined\n   external to the SNMP\
    \ domain, such as application of a default or\n   through an alternate management\
    \ interface like a command line\n   interface.  Section 3.10.1 describes considerations\
    \ for this practice\n   when designing NOTIFICATION-TYPEs.  The OwnerString textual\n\
    \   convention from RMON-MIB RFC 2819 [32] has been used successfully for\n  \
    \ this purpose.  More recently, RFC 3411 [1] introduced the\n   SnmpAdminString\
    \ which has been designed as a UTF8 string.  This is\n   more suitable for representing\
    \ names in many languages.\n   Experience has shown that usage of OwnerString\
    \ to represent row\n   ownership can be a useful diagnostic tool as well.  Specifically,\
    \ the\n   use of the string \"monitor\" to identify configuration set by an\n\
    \   agent/local management has been prevalent and useful in applications.\n  \
    \ Thirdly, consider whether there is a need for multiple managers to\n   configure\
    \ the same set of tables.  If so, an \"OwnerString\" may be\n   used as the first\
    \ component of a table's index to allow VACM to be\n   used to protect access\
    \ to subsets of rows, at least at the level of\n   securityName or groupName provided.\
    \  RFC 3231 [25], Section 6\n   presents this technique in detail.  This technique\
    \ does add\n   complexity to the managed device and to the configuration management\n\
    \   application since the manager will need to be aware of these\n   additional\
    \ columnar objects in configuration tables and act\n   appropriately to set them.\
    \  Additionally, the agent must be\n   configured to provide the appropriate instance-level\
    \ restrictions on\n   the modifiability of the instances.\n"
- title: 3.13.  Other MIB Module Design Issues
  contents:
  - '3.13.  Other MIB Module Design Issues

    '
- title: 3.13.1.  Octet String Aggregations
  contents:
  - "3.13.1.  Octet String Aggregations\n   The OCTET STRING syntax can be used as\
    \ an extremely flexible and\n   useful datatype when defining managed objects\
    \ that allow SET\n   operation.  An octet string is capable of modeling many things\
    \ and is\n   limited in size to 65535 octets by SMIv2[2].\n   Since OCTET STRINGS\
    \ are very flexible, the need to make them useful\n   to applications requires\
    \ careful definition.  Otherwise, applications\n   will at most simply be able\
    \ to display and set them.\n   Consider the following object from RFC 3418 SNMPv2-MIB\
    \ [11].\n   sysLocation OBJECT-TYPE\n   SYNTAX      DisplayString (SIZE (0..255))\n\
    \   MAX-ACCESS  read-write\n   STATUS      current\n   DESCRIPTION\n         \
    \  \"The physical location of this node (e.g., `telephone\n           closet,\
    \ 3rd floor').  If the location is unknown, the value\n           is the zero-length\
    \ string.\"\n   ::= { system 6 }\n   Such informational object types have come\
    \ to be colloquially known as\n   \"scratch pad objects\".  While often useful,\
    \ should an application be\n   required to do more with this information than\
    \ be able to read and\n   set the value of this object, a more precise definition\
    \ of the\n   contents of the OCTET STRING is needed, since the actual format of\
    \ an\n   instance for such an object is unstructured.  Hence, alternatively,\n\
    \   dividing the object type into several object type definitions can\n   provide\
    \ the required additional structural detail.\n   When using OCTET STRINGS, avoid\
    \ platform dependent data formats.\n   Also avoid using OCTET STRINGS where a\
    \ more precise SMI syntax such\n   as SnmpAdminString or BITS would work.\n  \
    \ There are many MIB modules that attempt to optimize the amount of\n   data sent/received\
    \ in a SET/GET PDU by packing octet strings with\n   aggregate data.  For example,\
    \ the PortList syntax as defined in the\n   Q-BRIDGE-MIB (RFC 2674 [26]) is defined\
    \ as follows:\n   PortList ::= TEXTUAL-CONVENTION\n    STATUS      current\n \
    \   DESCRIPTION\n        \"Each octet within this value specifies a set of eight\n\
    \        ports, with the first octet specifying ports 1 through\n        8, the\
    \ second octet specifying ports 9 through 16, etc.\n        Within each octet,\
    \ the most significant bit represents\n        the lowest numbered port, and the\
    \ least significant bit\n        represents the highest numbered port.  Thus,\
    \ each port\n        of the bridge is represented by a single bit within the\n\
    \        value of this object.  If that bit has a value of '1'\n        then that\
    \ port is included in the set of ports; the port\n        is not included if its\
    \ bit has a value of '0'.\"\n    SYNTAX      OCTET STRING\n   This compact representation\
    \ saves on data transfer but has some\n   limitations.  Such complex instance\
    \ information is difficult to\n   reference outside of the object or use as an\
    \ index to a table.\n   Additionally, with this approach, if a value within the\
    \ aggregate\n   requires change, the entire aggregated object instance must be\n\
    \   written.\n   Providing an SNMP table to represent aggregate data avoids the\n\
    \   limitations of encoding data into OCTET STRINGs and is thus the\n   better\
    \ general practice.\n   Finally, as previously mentioned in Section 3.3.6.3, one\
    \ should\n   consider the practical ramifications of instance transfer for object\n\
    \   types of SYNTAX OCTET STRING where they have typical instance data\n   requirements\
    \ close to the upper boundary of SMIv2 OCTET STRING\n   instance encoding.  Where\
    \ such object types are truly necessary at\n   all, SNMP/UDP may not be a very\
    \ scalable means of transfer and\n   alternatives should be explored.\n"
- title: 3.13.2.  Supporting multiple instances of a MIB Module
  contents:
  - "3.13.2.  Supporting multiple instances of a MIB Module\n   When defining new\
    \ MIB modules, one should consider if there could\n   ever be multiple instances\
    \ of this MIB module in a single SNMP\n   entity.\n   MIB modules exist that assume\
    \ a one to many relationship, such as\n   MIBs for routing protocols which can\
    \ accommodate multiple \"processes\"\n   of the underlying protocol and its administrative\
    \ framework.\n   However, the majority of MIB modules assume a one-to-one relationship\n\
    \   between the objects found in the MIB module and how many instances\n   will\
    \ exist on a given SNMP agent.  The OSPF-MIB, IP-MIB, BRIDGE-MIB\n   are all examples\
    \ that are defined for a single instance of the\n   technology.\n   It is clear\
    \ that single instancing of these MIB modules limits\n   implementations that\
    \ might support multiple instances of OSPF, IP\n   stacks or logical bridges.\n\
    \   In such cases, the ENTITY-MIB [RFC2737] can provide a means for\n   supporting\
    \ the one-to-many relationship through naming scopes using\n   the entLogicalTable.\
    \  Keep in mind, however, that there are some\n   drawbacks to this approach.\n\
    \   1) One cannot issue a PDU request that spans naming scopes.  For\n      example,\
    \ given two instances of BRIDGE-MIB active in a single\n      agent, one PDU cannot\
    \ contain a request for dot1dBaseNumPorts from\n      both the first and second\
    \ instances.\n   2) Reliance on this technique creates a dependency on the Entity\
    \ MIB\n      for an application to be able to access multiple instances of\n \
    \     information.\n   Alternately, completely independently of the Entity MIB,\
    \ multiple MIB\n   module instances can be scoped by different SNMP contexts.\
    \  This\n   does, however, require the coordination of this technique with the\n\
    \   administrative establishment of contexts in the configured agent\n   system.\n"
- title: 3.13.3.  Use of Special Optional Clauses
  contents:
  - "3.13.3.  Use of Special Optional Clauses\n   When defining integer-based objects\
    \ for read-create, read-write and\n   read-only semantics, using the UNITS clause\
    \ is recommended in\n   addition to specification in the DESCRIPTION clause of\
    \ any particular\n   details of how UNITs are to be interpreted.\n   The REFERENCE\
    \ clause is also recommended as a way to help an\n   implementer track down related\
    \ information on a given object.  By\n   adding a REFERENCE clause to the specific\
    \ underlying technology\n   document, multiple separate implementations will be\
    \ more likely to\n   interoperate.\n"
- title: 4.  Implementing SNMP Configuration Agents
  contents:
  - '4.  Implementing SNMP Configuration Agents

    '
- title: 4.1.  Operational Consistency
  contents:
  - "4.1.  Operational Consistency\n   Successful deployment of SNMP configuration\
    \ systems depends on\n   understanding the roles of MIB module design and agent\
    \ design.\n   Both module and agent design need to be undertaken with an\n   understanding\
    \ of how UDP/IP-based SNMP behaves.  A current practice\n   in MIB design is to\
    \ consider the idempotency of settable objects.\n   Idempotency basically means\
    \ being able to invoke the same set\n   operation repeatedly but resulting in\
    \ only a single activation.\n   Here is an example of the idempotency in action:\n"
- title: Manager                              Agent
  contents:
  - 'Manager                              Agent

    '
- title: '--------                             ------'
  contents:
  - '--------                             ------

    '
- title: Set1 (Object A, Value B) --->        receives set OK and responds
  contents:
  - "Set1 (Object A, Value B) --->        receives set OK and responds\n         \
    \                 X<-------- Response PDU(OK) is dropped by\n                \
    \                     network\n"
- title: Manager times out
  contents:
  - 'Manager times out

    '
- title: and sends again
  contents:
  - 'and sends again

    '
- title: Set2 (Object A, Value B) --->       receives set OK (does nothing),
  contents:
  - "Set2 (Object A, Value B) --->       receives set OK (does nothing),\n       \
    \                             responds\n                          <-------- with\
    \ a Response PDU(OK)\n"
- title: Manager receives OK
  contents:
  - "Manager receives OK\n   Had object A been defined in a stateful way, the set\
    \ operation might\n   have caused the Set2 operation to fail as a result of interaction\n\
    \   with Set1.  If the agent implementation is not aware of such a\n   possible\
    \ situation on the second request, the agent may behave poorly\n   by performing\
    \ the set request again rather than doing nothing.\n   The example above shows\
    \ that all of the software that runs on a\n   managed element and in managed applications\
    \ should be designed in\n   concert when possible.  Particular emphasis should\
    \ be placed at the\n   logical boundaries of the management system components\
    \ in order to\n   ensure correct operation.\n   1. The first interface is between\
    \ SNMP agents in managed devices and\n      the management applications themselves.\
    \  The MIB document is a\n      contract between these two entities that defines\
    \ expected behavior\n      - it is a type of API.\n   2. The second interface\
    \ is between the agent and the instrumented\n      subsystem.  In some cases,\
    \ the instrumented subsystem will require\n      modification to allow for the\
    \ dynamic nature of SNMP-based\n      configuration, control and monitoring operations.\
    \  Agent\n      implementors must also be sensitive to the operational code and\n\
    \      device in order to minimize the impact of management on the\n      primary\
    \ subsystems.\n   Additionally, while the SNMP protocol-level and MIB module-level\n\
    \   modeling of configuration operations may be idempotent and stateless\n   from\
    \ one set operation to another, it may not be that way in the\n   underlying subsystem.\
    \  It is possible that an agent may need to\n   manage this state in these subsystem\
    \ architectures explicitly when it\n   has placed the underlying subsystem into\
    \ an \"intermediate\" state at a\n   point in processing a series of SET PDUs.\
    \  Alternatively, depending\n   on the underlying subsystem in question, the agent\
    \ may be able to\n   buffer all of the configuration set operations prior to activating\n\
    \   them in the subsystem all at once (to accommodate the nature of the\n   subsystem).\n\
    \   As an example, it would be reasonable to define a MIB module to\n   control\
    \ Virtual Private Network (VPN) forwarding, in which a\n   management station\
    \ could set a set of ingress/egress IP addresses for\n   the VPN gateway.  Perhaps\
    \ the MIB module presumes that the level of\n   transactionality is the establishment\
    \ of a single row in a table\n   defining the address of the ingress/egress gateway,\
    \ along with some\n   prefix information to assist in routing at the VPN layer\
    \ to that\n   gateway.  However, it would be conceivable that in an underlying\n\
    \   Layer 2 VPN subsystem instrumentation, the requirement is that all\n   existing\
    \ gateways for a VPN be deleted before a new one can be\n   defined--that, in\
    \ other words, in order to add a new gateway, g(n),\n   to a VPN, gateways g(1)..g(n-1)\
    \ need to be removed, and then all n\n   gateways reestablished with the VPN forwarding\
    \ service.  In this\n   case, one could imagine an agent which has some sort of\
    \ timer to\n   establish a bounded window for receipt of SETs for new VPN gateways,\n\
    \   and to activate them in this removal-then-reestablishment of existing\n  \
    \ and new gateways at the end of this window.\n"
- title: 4.2.  Handling Multiple Managers
  contents:
  - "4.2.  Handling Multiple Managers\n   Devices are often modified by multiple management\
    \ entities and with\n   different management techniques.  It is sometimes the\
    \ case that an\n   element is managed by different organizations such as when\
    \ a device\n   sits between administrative domains.\n   There are a variety of\
    \ approaches that management software can use to\n   ensure synchronization of\
    \ information between the manager(s) and the\n   managed elements.\n   An agent\
    \ should report configuration changes performed by different\n   entities.  It\
    \ should also distinguish configuration defined locally\n   such as a default\
    \ or locally specified configuration made through an\n   alternate management\
    \ interface such as a command line interface.\n   When a change has been made\
    \ to the system via SNMP, CLI, or other\n   method, a managed element should send\
    \ an notification to the\n   manager(s) configured as recipients of these applicable\n\
    \   notifications.  These management applications should update their\n   local\
    \ configuration repositories and then take whatever additional\n   action is appropriate.\
    \  This approach can also be an early warning of\n   undesired configuration changes.\n\
    \   Managers should also develop mechanisms to ensure that they are\n   synchronized\
    \ with each other.\n"
- title: 4.3.  Specifying Row Modifiability
  contents:
  - "4.3.  Specifying Row Modifiability\n   Once a RowStatus value is active(1) for\
    \ a given row, the management\n   application should be able to determine what\
    \ the semantics are for\n   making additional changes to a row.  The RMON MIB\
    \ control table\n   objects spell out explicitly what managed objects in a row\
    \ can and\n   cannot be changed once a given RowStatus goes active.\n   As described\
    \ earlier, some operations take some time to complete.\n   Some systems also require\
    \ that they remain in a particular state for\n   some period before moving to\
    \ another.  In some cases, a change to one\n   value may require re-initialization\
    \ of the system.  In all of these\n   cases, the DESCRIPTION clause should contain\
    \ information about\n   requirements of the managed system and special restrictions\
    \ that\n   managers should observe.\n"
- title: 4.4.  Implementing Write-only Access Objects
  contents:
  - "4.4.  Implementing Write-only Access Objects\n   The second version of the SNMP\
    \ SMI dropped direct support for a\n   write-only object. It is therefore necessary\
    \ to return something when\n   reading an object that you may have wished to have\
    \ write-only\n   semantics.  Such objects should have a DESCRIPTION clause that\n\
    \   details what the return values should be.  However, regardless of the\n  \
    \ approach, the value returned when reading the object instance should\n   be\
    \ meaningful in the context of the object's semantics.\n"
- title: 5.  Designing Configuration Management Software
  contents:
  - "5.  Designing Configuration Management Software\n   In this section, we describe\
    \ practices that should be used when\n   creating and deploying management software\
    \ that configures one or\n   more systems using SNMP.  Functions all configuration\
    \ management\n   software should provide, regardless of the method used to convey\n\
    \   configuration information to the managed systems are backup, fail-\n   over,\
    \ and restoration.  A management system should have the following\n   features:\n\
    \   1. A method for restoring a previous configuration to one or more\n      devices.\
    \  Ideally this restoration should be time indexed so that\n      a network can\
    \ be restored to a configured state as of a specific\n      time and date.\n \
    \  2. A method for saving back up versions of the configuration data in\n    \
    \  case of hardware or software failure.\n   3. A method of providing fail-over\
    \ to a secondary (management) system\n      in case of a primary failure.  This\
    \ capability should be deployed\n      in such a way that it does not cause duplicate\
    \ polling of\n      configuration.\n   These three capabilities are of course\
    \ important for other types of\n   management that are not the focus of this BCP.\n"
- title: 5.1.  Configuration Application Interactions with Managed Systems
  contents:
  - "5.1.  Configuration Application Interactions with Managed Systems\n   From the\
    \ point of view of the design of the management application,\n   there are three\
    \ basic requirements to evaluate relevant to SNMP\n   protocol operations and\
    \ configuration:\n      o Set and configuration activation operations\n      o\
    \ Notifications from the device\n      o Data retrieval and collection\n   Depending\
    \ on the requirements of the specific services being\n   configured, many other\
    \ requirements may, and probably will, also be\n   present.\n   The design of\
    \ the system should not assume that the objects in a\n   device that represent\
    \ configuration data will remain unchanged over\n   time.\n   As standard MIB\
    \ modules evolve and vendors add private extensions,\n   the specific configuration\
    \ parameters for a given operation are\n   likely to change over time.  Even in\
    \ the case of a configuration\n   application that is designed for a single vendor,\
    \ the management\n   application should allow for variability in the MIB objects\
    \ that will\n   be used to configure the device for a particular purpose.  The\
    \ best\n   method to accomplish this is by separating, as much as possible, the\n\
    \   operational semantics of a configuration operation from the actual\n   data.\
    \ One way that some applications achieve this is by having the\n   specific configuration\
    \ objects that are associated with a particular\n   device be table driven rather\
    \ than hard coded.  Ideally, management\n   software should verify the support\
    \ in the devices it is expected to\n   manage and report any unexpected deviations\
    \ to the operator.  This\n   approach is particularly valuable when developing\
    \ applications that\n   are intended to support equipment or software from multiple\
    \ vendors.\n"
- title: 5.1.1.  SET Operations
  contents:
  - "5.1.1.  SET Operations\n   Management software should be mindful of the environment\
    \ in which SET\n   operations are being deployed.  The intent here is to move\n\
    \   configuration information as efficiently as possible to the managed\n   device.\
    \  There are many ways to achieve efficiency and some are\n   specific to given\
    \ devices.  One general case that all management\n   software should employ is\
    \ to reduce the number of SET PDU exchanges\n   between the managed device and\
    \ the management software to the\n   smallest reasonable number.  One approach\
    \ to this is to verify the\n   largest number of variable bindings that can fit\
    \ into a SET PDU for a\n   managed device.  In some cases, the number of variable\
    \ bindings to be\n   sent in a particular PDU will be influenced by the device,\
    \ the\n   specific MIB objects and other factors.\n   Maximizing the number of\
    \ variable bindings in a SET PDU also has\n   benefits in the area of management\
    \ application transaction\n   initiation, as we will discuss in the following\
    \ section.\n   There are, though, agents that may have implementation limitations\
    \ on\n   the number and order of varbinds they can handle in a single SET PDU.\n\
    \   In this case, sending fewer varbinds will be necessary.\n   As stated at the\
    \ outset of this section, the management application\n   software designer must\
    \ be sensitive to the design of the SNMP\n   software in the managed device. \
    \ For example, the software in the\n   managed device may require that all that\
    \ all related configuration\n   information for an operation be conveyed in a\
    \ single PDU because it\n   has no concept of a transaction beyond a single SNMP\
    \ PDU.  Another\n   example has to do with the RowStatus textual convention. \
    \ Some SNMP\n   agents implement a subset of the features available and as such\
    \ the\n   management application must avoid using features that may not be\n \
    \  supported in a specific table implementation (such as createAndWait).\n"
- title: 5.1.2.  Configuration Transactions
  contents:
  - "5.1.2.  Configuration Transactions\n   There are several types of configuration\
    \ transactions that can be\n   supported by SNMP-based configuration applications.\
    \  They include\n   transactions on a scalar object, transactions in a single\
    \ table\n   (within and across row instances), transactions across several tables\n\
    \   in a managed device and transactions across many devices.  The\n   manager's\
    \ ability to support these different transactions is partly\n   dependent on the\
    \ design of the MIB objects used in the configuration\n   operation.\n   To make\
    \ use of any kind of transaction semantics effectively, SNMP\n   management software\
    \ must be aware of the information in the MIB\n   modules that it is to configure\
    \ so that it can effectively utilize\n   RowStatus objects for the control of\
    \ transactions on one or more\n   tables.  Such software must also be aware of\
    \ control tables that the\n   device supports that are used to control the status\
    \ of one or more\n   other tables.\n   To the greatest extent possible, the management\
    \ application should\n   provide the facility to support transactions across multiple\
    \ devices.\n   This means that if a configuration operation is desired across\n\
    \   multiple devices, the manager can coordinate these configuration\n   operations\
    \ such that they become active as close to simultaneously as\n   possible.\n \
    \  Several practical means are present in the SNMP model that support\n   management\
    \ application level transactions.  One was mentioned in the\n   preceding section,\
    \ that transactions can be optimized by including\n   the maximum number of SET\
    \ variable bindings possible in a single PDU\n   sent to the agent.\n   There\
    \ is an important refinement to this.  The set of read-create row\n   data objects\
    \ for tables should be sent in a single PDU, and only\n   placed across multiple\
    \ PDUs if absolutely necessary.  The success of\n   these set operations should\
    \ be verified through the response(s) to\n   the Set PDU or subsequent polling\
    \ of the row data objects.  The\n   applicable RowStatus object(s), may be set\
    \ to active only after this\n   verification.  This is the only tractable means\
    \ of affording an\n   opportunity for per-row rollback, particularly when the\
    \ configuration\n   change is across table row instances on multiple managed devices.\n\
    \   Finally, where a MIB module exposes the kind of helpful transaction\n   management\
    \ object types that were discussed in Section 3.3.5, it is\n   clearly beneficial\
    \ to the integrity of the management application's\n   capacity to handle transactions\
    \ to make use of them.\n"
- title: 5.1.3.  Tracking Configuration Changes
  contents:
  - "5.1.3.  Tracking Configuration Changes\n   As previously described in Section\
    \ 3.3.5 (Summary Objects and State\n   Tracking), agents should provide the capability\
    \ for notifications to\n   be sent to their configured management systems whenever\
    \ a\n   configuration operation is completed or is detected to have failed.\n\
    \   The management application must be prepared to accept these\n   notifications\
    \ so that it knows the current configured state of the\n   devices under its control.\
    \  Upon receipt of the notification, the\n   management application should use\
    \ getBulk or getNext to retrieve the\n   configuration from the agent and store\
    \ the relevant contents in the\n   management application database.  The GetBulkRequest-PDU\
    \ is useful\n   for this whenever supported by the managed device, since it is\
    \ more\n   efficient than the GetNextRequest-PDU when retrieving large amounts\n\
    \   of data.  For the purposes of backward compatibility, the management\n   station\
    \ should also support and make use of the GetNextRequest-PDU\n   when the agent\
    \ does not support the GetBulkRequest-PDU.\n   Management systems should also\
    \ provide configuration options with\n   defaults for users that tend to retrieve\
    \ the smallest amount of data\n   to achieve the particular goal of the application,\
    \ to avoid\n   unnecessary load on managed devices for the most common retrieval\n\
    \   operations.\n"
- title: 5.1.4.  Scalability of Data Retrieval
  contents:
  - "5.1.4.  Scalability of Data Retrieval\n   The techniques for efficient data retrieval\
    \ described in the\n   preceding sections comprise only one aspect of what application\n\
    \   developers should consider in this regard when developing\n   configuration\
    \ applications.  Management applications should provide\n   for distributed processing\
    \ of the configuration operations.  This\n   also extends to management functions\
    \ that are not the focus of this\n   document.  Techniques of distributed processing\
    \ can also be used to\n   provide resilience in the case of network failures.\
    \  An SNMP-based\n   configuration management system might be deployed in a distributed\n\
    \   fashion where three systems in different locations keep each other\n   synchronized.\
    \  This synchronization can be accomplished without\n   additional polling of\
    \ network devices through a variety of\n   techniques.  In the case of a failure,\
    \ a 'backup' system can take\n   over the configuration responsibilities from\
    \ the failed manager\n   without having to re-synchronize with the managed elements\
    \ since it\n   will already be up to date.\n"
- title: 6.  Deployment and Security Issues
  contents:
  - "6.  Deployment and Security Issues\n   Now that we have considered the design\
    \ of SNMP MIB data for\n   configuration, agent implementation of its access,\
    \ and management\n   application issues in configuration using SNMP, we turn to\
    \ a variety\n   of operational considerations which transcend all three areas.\n"
- title: 6.1.  Basic assumptions about Configuration
  contents:
  - "6.1.  Basic assumptions about Configuration\n   The following basic assumptions\
    \ are made about real world\n   configuration models.\n   1) Operations must understand\
    \ and must be trained in the operation of\n      a given technology.  No configuration\
    \ system can prevent an\n      untrained operator from causing outages due to\
    \ misconfiguration.\n   2) Systems undergoing configuration changes must be able\
    \ to cope with\n      unexpected loss of communication at any time.\n      During\
    \ configuration operations, network elements must take\n      appropriate measures\
    \ to leave the configuration in a\n      consistent/recognizable state by either\
    \ rolling back to a\n      previously valid state or changing to a well-defined\
    \ or default\n      state.\n   3) Configuration exists on a scale from relatively\
    \ unchanging to a\n      high volume, high rate of change.  The former is often\
    \ referred to\n      as \"set and forget\" to indicate that the configuration\
    \ changes\n      quite infrequently.  The latter, \"near real-time change control\"\
    \n      implies a high frequency of configuration change.  Design of\n      configuration\
    \ management must take into account the rate and\n      volume of change expected\
    \ in a given configuration subsystem.\n"
- title: 6.2.  Secure Agent Considerations
  contents:
  - "6.2.  Secure Agent Considerations\n   Vendors should not ship a device with a\
    \ community string 'public' or\n   'private', and agents should not define default\
    \ community strings\n   except when needed to bootstrap devices that do not have\
    \ secondary\n   management interfaces.  Defaults lead to security issues that\
    \ have\n   been recognized and exploited.  When using SNMPv1, supporting read-\n\
    \   only community strings is a common practice.\n   Version 3 of the SNMP represents\
    \ the current standard for the\n   Internet Management Framework and is recommended\
    \ for all network\n   management applications.  In particular, SNMPv3 provides\n\
    \   authorization, authentication, and confidentiality protection and is\n   essential\
    \ to meeting the security considerations for all management\n   of devices that\
    \ support SNMP-based configuration.\n"
- title: 6.3.  Authentication Notifications
  contents:
  - "6.3.  Authentication Notifications\n   The default state of RFC 1215 [17] Authentication\
    \ notifications\n   should be off.  One does not want to risk accidentally sending\
    \ out\n   authentication failure information, which by itself could constitute\n\
    \   a security liability.  Enabling authentication Notifications should\n   be\
    \ done in the context of a management security scheme which\n   considers the\
    \ proper recipients of this information.\n   There are other liabilities where\
    \ authentication notifications are\n   generated without proper security infrastructure.\
    \  When notifications\n   are sent in SNMPv1 trap PDUs, unsolicited packets to\
    \ a device can\n   causes one or more trap PDUs to be created and sent to management\n\
    \   stations.  If these traps flow on shared access media and links, the\n   community\
    \ string from the trap may be gleaned and exploited to gain\n   access to the\
    \ device.  At the very least, this risk should be\n   mitigated by having the\
    \ authentication trap PDU be conveyed with a\n   community string which is only\
    \ used for authentication traps from the\n   agent, and would be useless for access\
    \ inbound to the agent to get at\n   other management data.\n   A further liability\
    \ of authentication traps can be seen when they are\n   being generated in the\
    \ face of a Denial Of Service (DOS) attack, in\n   the form of a flood of PDUs\
    \ with invalid community strings, on the\n   agent system.  If it is bad enough\
    \ that the system is having to\n   respond to and recover from the invalid agent\
    \ data accesses, but the\n   problem will be compounded if a separate Authentication\
    \ notification\n   PDU is sent to each recipient on the management network.\n"
- title: 6.4.  Sensitive Information Handling
  contents:
  - "6.4.  Sensitive Information Handling\n   Some MIB modules contain objects that\
    \ may contain data for keys,\n   passwords and other such sensitive information\
    \ and hence must be\n   protected from unauthorized access.  MIB documents that\
    \ are created\n   in the IETF must have a 'Security Considerations' section, which\n\
    \   details how sensitive information should be protected.  Similarly,\n   MIB\
    \ module designers who create MIB documents for private MIB objects\n   should\
    \ include similar information so that users of the products\n   containing these\
    \ objects can take appropriate precautions.\n   Even if a device does support\
    \ DES, it should be noted that\n   configuration of keys for other protocols via\
    \ SNMP Sets protected by\n   DES should not be allowed if the other keys are longer\
    \ than the 56\n   bit DES keys protecting the SNMP transmission.\n   The DESCRIPTION\
    \ clause for these object types and their Security\n   Considerations sections\
    \ in the documents which define them should\n   make it clear how and why these\
    \ specific objects are sensitive and\n   that a user should only make them accessible\
    \ for encrypted SNMP\n   access.  Vendors should also document sensitive objects\
    \ in a similar\n   fashion.\n   Confidentiality is not a mandatory portion of\
    \ the SNMPv3 management\n   framework [6].\n   Prior to SNMPv3, providing customized\
    \ views of MIB module data was\n   difficult.  This led to objects being defined\
    \ such as the following\n   from [41].\n   docsDevNmAccessEntry OBJECT-TYPE\n\
    \       SYNTAX      DocsDevNmAccessEntry\n       MAX-ACCESS  not-accessible\n\
    \       STATUS      current\n       DESCRIPTION\n           \"An entry describing\
    \ access to SNMP objects by a\n            particular network management station.\
    \  An entry in\n            this table is not readable unless the management station\n\
    \            has read-write permission (either implicit if the table\n       \
    \     is empty, or explicit through an entry in this table.\n            Entries\
    \ are ordered by docsDevNmAccessIndex.  The first\n            matching entry\
    \ (e.g., matching IP address and community\n            string) is used to derive\
    \ access.\"\n       INDEX { docsDevNmAccessIndex  }\n       ::= {  docsDevNmAccessTable\
    \ 1 }\n   New MIB modules should capitalize on existing security capabilities\n\
    \   of SNMPv3 Framework.  One way they can do this is by indicating the\n   level\
    \ of security appropriate to different object types.  For\n   example, objects\
    \ that change the configuration of the system might be\n   protected by using\
    \ the authentication mechanisms in SNMPv3.\n   Specifically, it is useful to design\
    \ MIB module object grouping with\n   considerations for VACM views definition,\
    \ such that users can define\n   and properly scope what tables are visible to\
    \ a given user and view.\n"
- title: 7.  Policy-based Management
  contents:
  - "7.  Policy-based Management\n   In some designs and implementations, a common\
    \ practice used to move\n   large amounts of data involves using SNMP as a control\
    \ channel in\n   combination with other protocols defined for transporting bulk\
    \ data.\n   This approach is sub-optimal since it raises a number of security\
    \ and\n   other concerns.  Transferring large amounts of configuration data via\n\
    \   SNMP can be efficiently performed with several of the techniques\n   described\
    \ earlier in this document.  This policy section shows how\n   even greater efficiency\
    \ can be achieved using a set of relatively new\n   design mechanisms.  This section\
    \ gives background and defines terms\n   that are relevant to this field and describes\
    \ some deployment\n   approaches.\n"
- title: 7.1.  What Is the Meaning of 'Policy-based'?
  contents:
  - "7.1.  What Is the Meaning of 'Policy-based'?\n   In the past few years of output\
    \ from standards organizations and\n   networking vendor marketing departments,\
    \ the term 'policy' has been\n   heavily used, touted, and contorted in meaning.\
    \  The result is that\n   the true meaning of 'policy' is unclear without greater\
    \ qualification\n   where it is used.\n   [42] gives the term 'policy' two explicit\
    \ definitions:\n   -  A definite goal, course or method of action to guide and\
    \ determine\n      present and future decisions.  \"Policies\" are implemented\
    \ or\n      executed within a particular context (such as policies defined\n \
    \     within a business unit).\n   -  Policies as a set of rules to administer,\
    \ manage, and control\n      access to network resources.\n      Note that these\
    \ two views are not contradictory since individual\n      rules may be defined\
    \ in support of business goals.\n   As it pertains to our discussion of the term\
    \ 'policy-based\n   configuration', the meaning is significantly more specific.\
    \  In this\n   context, we refer to a way of integrating data and the management\n\
    \   actions which use it in such a way that:\n   -  there is the ability to specify\
    \ \"default\" configuration data for a\n      number of instances of managed elements,\
    \ where those instances can\n      be correlated in some data driven or algorithmic\
    \ way.  The engine\n      to do this correlation and activate instances from defaults\
    \ may\n      reside in the agent or externally.  Where the representation of\n\
    \      these defaults are in the MIB design itself, the object types\n      supporting\
    \ this notion are referred to as \"template objects\".\n   -  the activation of\
    \ instance data derived from template object types\n      results from minimal\
    \ activation directives from the management\n      application, once the instances\
    \ of the template object types have\n      been established.\n   -  somewhat independently,\
    \ the architecture of the overall management\n      agent may accommodate the\
    \ definition and evaluation of management\n      and configuration policies. \
    \ The side-effects of the evaluation of\n      these policies typically include\
    \ the activation of certain\n      configuration directives.  Where management\
    \ data design exposes\n      template object types, the policy-driven activation\
    \ can (and\n      ideally, should) include the application of template object\n\
    \      instances to the analogous managed element instance-level values.\n   As\
    \ it pertains to template object data, the underlying notions\n   implied here\
    \ have been prevalent for some time in non-SNMP management\n   regimes.  A common\
    \ feature of many command line interfaces for\n   configuring routers is the specification\
    \ of one or more access\n   control lists.  These typically provide a set of IP\
    \ prefixes, BGP\n   autonomous system numbers, or other such identifying constructs\
    \ (see,\n   for example, [42]).  Once these access control lists are assembled,\n\
    \   their application to various interfaces, routing processes, and the\n   like\
    \ are specified typically in the configuration of what the access\n   control\
    \ list is applied to.  Consistent with the prior properties to\n   define our\
    \ use of policy-based configuration, a) the access list is\n   defined independent\
    \ from its point of application, and b) its\n   application is independent of\
    \ the access list definition.  For\n   example, changing the application of an\
    \ access list from one\n   interface to the other does not require a change in\
    \ the access list\n   itself.  The first point just mentioned suggests what is\
    \ necessary\n   for template-based data organization.  The second suggests its\n\
    \   application in a policy-based manner.\n   Let us now examine the motivation\
    \ for such a system or subsystem\n   (perhaps bounded at the level of a 'template-enabled'\
    \ MIB module,\n   given the above definition).  Let us explore the importance\
    \ of\n   policy-based techniques to configuration specifically.\n"
- title: 7.2.  Organization of Data in an SNMP-Based Policy System
  contents:
  - "7.2.  Organization of Data in an SNMP-Based Policy System\n   The number of configurable\
    \ parameters and 'instances' such as\n   interfaces has increased as equipment\
    \ has become larger and more\n   complex.\n   At the same time, there is a need\
    \ to configure many of these systems\n   to operate in a coordinated fashion.\
    \  This enables the delivery of\n   new specialized services that require this\
    \ coordinated configuration.\n   Examples include delivery of virtual private\
    \ networks and connections\n   that guarantee specific service levels.\n   The\
    \ growth in size and complexity of configuration information has\n   significant\
    \ implications for its organization as well as its\n   efficient transfer to the\
    \ management agent.  As an example, an agent\n   that implements the Bridge MIB\
    \ [24] could be used to represent a\n   large VLAN with some 65,000 port entries.\
    \  Configuring such a VLAN\n   would require the establishment of dot1dStpPortTable\
    \ and\n   dot1DStaticTable entries for each such virtual port.  Each table\n \
    \  entry would contain several parameters.  A more efficient approach is\n   to\
    \ provide default values for the creation of new entries that are\n   appropriate\
    \ to the VLAN environment in our example.  The local\n   management infrastructure\
    \ should then iterate across the system\n   setting the default values to the\
    \ selected ports as groups.\n   To date, this kind of large-scale configuration\
    \ has been accomplished\n   with file transfer, by setting individual MIB objects,\
    \ or with many\n   CLI commands.  In each of these approaches the details for\
    \ each\n   instance are contained in the file, CLI commands or MIB objects.\n\
    \   That is, they contain not only the value, and type of object, but\n   also\
    \ the exact instance of the object to which to apply the value.\n   It is this\
    \ property that tends to make configuration operations\n   explode as the number\
    \ of instances (such as interfaces) grows.  This\n   per-instance approach can\
    \ work for a few machines configured by\n   experts, but there is a need for a\
    \ more scalable solution.\n   Template-based data organization and policy-based\
    \ management\n   abstracts the details above the instance level, which means that\n\
    \   fewer SET requests are sent to a managed device.\n   Realization of such a\
    \ policy-driven system requires agents that can\n   take defaults and apply them\
    \ to instances based on a rule that\n   defines under what conditions the defaults\
    \ (policy) are to be\n   applied.  A policy-driven configuration system which\
    \ is to be\n   scalable needs to expose a means of layering its application of\n\
    \   defaults at discrete ranges of granularity.  The spectrum of that\n   granularity\
    \ might have a starting hierarchy point to apply defaults\n   at the breadth of\
    \ a network service.\n   Ultimately, such a layering ends up with features to\
    \ support\n   instance-level object instance data within the running agent.\n\
    \   An example of this kind of layering is implicit in the principle of\n   operations\
    \ of a SNMPCONF Policy-Based Management MIB [36] (PM-MIB)\n   implementation.\
    \  However, other entity management systems have been\n   employing these kinds\
    \ of techniques end-to-end for some time, in some\n   cases using SNMP, in some\
    \ cases using other encodings and transfer\n   technologies.  What the PM-MIB\
    \ seeks to establish, in an environment\n   ideal for its deployment, is an adaptation\
    \ between MIB module data\n   which was not designed using template object types,\
    \ and the ability\n   to allow the PM-MIB agent engine to apply instances of that\
    \ data as\n   though it were template-based.\n"
- title: 7.3.  Information Related to Policy-based Configuration
  contents:
  - "7.3.  Information Related to Policy-based Configuration\n   In order for effective\
    \ policy management to take place, a range of\n   information about the network\
    \ elements is needed to avoid making poor\n   policy decisions.  Even in those\
    \ cases where policy-based\n   configuration is not in use, much of the information\
    \ described in\n   this section can be useful input to the decision-making process\
    \ about\n   what type of configuration operations to do.\n   For this discussion\
    \ it is important to make distinctions between\n   distribution of policy to a\
    \ system, activation of a policy in a\n   system, and changes/failures that take\
    \ place during the time the\n   policy is expected to be active.  For example,\
    \ if an interface is\n   down that is included in a policy that is distributed,\
    \ there may not\n   be an error since the policy may not be scheduled for activation\n\
    \   until a later time.\n   On the other hand, if a policy is distributed and\
    \ applied to an\n   interface that should be operational and it is not, clearly\
    \ this is a\n   problem, although it is not an error in the configuration policy\n\
    \   itself.  With this as background, here are some areas to consider\n   that\
    \ are important to making good policy configuration decisions and\n   establishing\
    \ when a policy has 'failed'.\n   o  The operational state of network elements\
    \ that are to be\n      configured.\n      Care should be taken to determine if\
    \ the sub-components to be\n      configured are available for use.  In some cases\
    \ the elements may\n      not be available.  The policy configuration software\
    \ should\n      determine if this is a prerequisite to policy installation or\
    \ if\n      the condition is even acceptable.  This decision is separate from\n\
    \      the one to be made about policy activation.  Installation is when\n   \
    \   the policy is sent from the policy manager to the managed device\n      and\
    \ activation is turning on the policy.  In those cases where\n      policy is\
    \ distributed when the sub-component such as an interface\n      or disk is not\
    \ available, the managed system should send a\n      notification to the designated\
    \ management station when the policy\n      is to become active or if the resource\
    \ is still not available.\n   o  The capabilities of the devices in the network.\n\
    \      A capability can be almost any unit of work a network element can\n   \
    \   perform.  These include routing protocols supported, Web server\n      and\
    \ OS versions, queuing mechanisms supported on each interface\n      that can\
    \ be used to support different qualities of service, and\n      many others. \
    \ This information can be obtained from the\n      capabilities table of the Policy\
    \ MIB module [36].\n      Historically, management applications have had to obtain\
    \ this type\n      of information by issuing get requests for objects they might\
    \ want\n      to use.  This approach is far less efficient since it requires\n\
    \      many get requests and is more error prone since some instances\n      will\
    \ not exist until configured.  The new capabilities table is an\n      improvement\
    \ on the current technique.\n   o  The capacity of the devices to perform the\
    \ desired work.\n      Capability is an ability to perform the desired work while\
    \ a\n      capacity is a measure of how much of that capability the system\n \
    \     has.  The policy configuration application should, wherever\n      possible,\
    \ evaluate the capacity of the network element to perform\n      the work identified\
    \ by the policy.  In some systems it will not be\n      possible to obtain the\
    \ capacity of the managed elements to perform\n      the desired work directly,\
    \ even though it may be possible to\n      monitor the amount of work the element\
    \ performs.  In these cases,\n      the management application may benefit from\
    \ pre-configured\n      information about the capacity of different network elements\
    \ so\n      that evaluations of the resources available can be done before\n \
    \     distributing new policies.\n      Utilization refers to how much capacity\
    \ for a particular\n      capability has been consumed.  For devices that have\
    \ been under\n      policy configuration control for any period of time, a certain\n\
    \      percentage of the available capacity of the managed elements will\n   \
    \   be used.  Policies should not be distributed to systems that do\n      not\
    \ have the resources to carry out the policy in a reasonable\n      period of\
    \ time.\n"
- title: 7.4.  Schedule and Time Issues
  contents:
  - "7.4.  Schedule and Time Issues\n   This section applies equally to systems that\
    \ are not policy-based as\n   well as policy-based systems, since configuration\
    \ operations often\n   need to be synchronized across time zones.  Wherever possible,\
    \ the\n   network elements should support time information using the standard\n\
    \   DateAndTime TC that includes local time zone information.  Policy-\n   based\
    \ management often requires more complex time expressions than\n   can be conveyed\
    \ with the DateAndTime TC.  See the Policy-Based\n   Management MIB document [36]\
    \ for more information.  Some deployed\n   systems do not store complex notions\
    \ of local time and thus may not\n   be able to process policy directives properly\
    \ that contain time zone\n   relevant data.  For this reason, policy management\
    \ applications\n   should have the ability to ascertain the time keeping abilities\
    \ of\n   the managed system and make adjustments to the policy for those\n   systems\
    \ that are time-zone challenged.\n"
- title: 7.5.  Conflict Detection, Resolution and Error Reporting
  contents:
  - "7.5.  Conflict Detection, Resolution and Error Reporting\n   Policies sent to\
    \ a device may contain conflicting instructions.\n   Detection of such commands\
    \ can occur at the device or management\n   level and may be resolved using any\
    \ number of mechanisms (examples\n   are, last configuration set wins, or abort\
    \ change).  These unintended\n   conflicts should be reported.  Conflicts can\
    \ occur at different\n   levels in a chain of commands.  Each 'layer' in policy\
    \ management\n   system should be able to check for some errors and report them.\
    \  This\n   is conceptually identical to programs raising an exception and\n \
    \  passing that information on to software that can do something\n   meaningful\
    \ with it.\n   At the instance level, conflict detection has been performed in\
    \ a\n   limited way for some time in software that realizes MIB objects at\n \
    \  this level of resolution.  This detection is independent of policy.\n   The\
    \ types of 'conflicts' usually checked for are resource\n   availability and validity\
    \ of the set operations.  In a policy enabled\n   system, there are no additional\
    \ requirements for this software\n   assuming that good error detection and reporting\
    \ appropriate to this\n   level have already been implemented.\n"
- title: 7.5.1.  Changes to Configuration Outside of the Policy System
  contents:
  - "7.5.1.  Changes to Configuration Outside of the Policy System\n   It is essential\
    \ to consider changes to configuration that are\n   initiated outside of the policy\
    \ system.  A goal of SNMP-based policy\n   management is to coexist with other\
    \ kinds of management software that\n   have historically been instance based\
    \ management.  The best example\n   is the command line interface.\n   A notification\
    \ should be sent whenever an out-of-policy control\n   change is made to an element\
    \ that is under the control of policy.\n   This notification should include the\
    \ policy that was affected, the\n   instance of the element that was changed and\
    \ the object and value\n   that it was changed to.\n   Even for those systems\
    \ that have no concept of policy control, the\n   ideas presented above make sense.\
    \  That is, if SNMP co-exists with\n   other access methods such as a CLI, it\
    \ is essential that the\n   management station remain synchronized with changes\
    \ that might have\n   been made to the managed device using other methods.  As\
    \ a result,\n   the approach of sending a notification when another access method\n\
    \   makes a change is a good one.  Of course this should be configurable\n   by\
    \ the user.\n"
- title: 7.6.  More about Notifications in a Policy System
  contents:
  - "7.6.  More about Notifications in a Policy System\n   Notifications can be useful\
    \ in determining a failure of a policy as a\n   result of an error in the policy\
    \ or element(s) under policy control.\n   As with all notifications, they should\
    \ be defined and controlled in\n   such a way that they do not create a problem\
    \ by sending more than are\n   helpful over a specific period of time.  For example,\
    \ if a policy is\n   controlling 1,000 interfaces and fails, one notification\
    \ rather than\n   1,000 may be the better approach.  In addition, such notifications\n\
    \   should be defined to include as much information as possible to aid\n   in\
    \ problem resolution.\n"
- title: 7.7.  Using Policy to Move Less Configuration Data
  contents:
  - "7.7.  Using Policy to Move Less Configuration Data\n   One of the advantages\
    \ of policy-based configuration with SNMP is that\n   many configuration operations\
    \ can be conveyed with a small amount of\n   data.  Changing a single configuration\
    \ parameter for each of 100\n   interfaces on a system might require 100 CLI commands\
    \ or 100 SNMP\n   variable bindings using conventional techniques.\n   Using policy-based\
    \ configuration with SNMP, a single SET PDU can be\n   sent with the policy information\
    \ necessary to apply a configuration\n   change to 100 similar interfaces.  This\
    \ efficiency gain is the result\n   of eliminating the need to send the value\
    \ for each instance to be\n   configured.  The 'default' for each of the instances\
    \ included in the\n   policy is sent, and the rule for selection of the instances\
    \ that the\n   default is to be applied to can also be carried (see the Policy\
    \ MIB\n   module [36]).\n   To extend the example above, assume that there are\
    \ 10 parameters that\n   need to change.  Using conventional techniques, there\
    \ would now be\n   1,000 variable bindings, one for each instance of each new\
    \ value for\n   each interface.  Using policy-based configuration with SNMP, it\
    \ is\n   still likely that all the information can be conveyed in one SET PDU.\n\
    \   The only difference in this case is that there are ten parameters\n   sent\
    \ that will be the 'template' used to create instances on the\n   managed interfaces.\n\
    \   This efficiency gain not only applies to SET operations, but also to\n   those\
    \ management operations that require configuration information.\n   Since the\
    \ policy is also held in the storage for cross-instance\n   defaults (for example,\
    \ the pmPolicyTable in [36]), an entire data set\n   that potentially controls\
    \ hundreds of rows of information can be\n   retrieved in a single GET request.\n\
    \   A policy-friendly data organization such as this is consistent and\n   integrates\
    \ well with MIB module objects which support \"summary\"\n   activation and activation\
    \ reporting, of the kind discussed in Section\n   3.3.5.\n"
- title: 8.  Example MIB Module With Template-based Data
  contents:
  - "8.  Example MIB Module With Template-based Data\n   This section defines a MIB\
    \ module that controls the heating and air\n   conditioning system for a large\
    \ building.  It contains both\n   configuration and counter objects that allow\
    \ operators to see how\n   much cooling or heating a particular configuration\
    \ has consumed.\n   Objects that represent the configuration information at a\
    \ \"default\"\n   level (as referenced above) are also included.\n   These tables,\
    \ in combination with the application of the tables' row\n   instance data as\
    \ templated 'defaults', will allow operators to\n   configure and monitor many\
    \ rooms at once, change the configuration\n   parameters based on time of day,\
    \ and make a number of other\n   sophisticated decisions based on the 'policy'\
    \ implied by these\n   defaults and their application.  For this reason, these\
    \ configuration\n   controls have their instances specified from template object\
    \ types.\n   In our simplified Heating Ventilation and Air Conditioning (HVAC)\n\
    \   model we will create three tables based on a simple analysis.  More\n   complicated\
    \ systems will need more tables, but the principles will be\n   the same.\n"
- title: 'Step 1: As with any other MIB module design, the first step'
  contents:
  - "Step 1: As with any other MIB module design, the first step\n        is to determine\
    \ what objects are necessary for\n        configuration and control operations.\
    \  The first table\n        to be created is a fairly traditional monitoring\n\
    \        table.  It includes indices so that we will know what\n        rooms\
    \ the counters and status objects are for.  It\n        includes an object that\
    \ is a RowPointer to a table\n        that contains configuration information.\
    \  The objects\n        for the bldgHVACTable, our first table in the HVAC\n \
    \       MIB module are:\n"
- title: Index objects that identify what floor and office we are
  contents:
  - 'Index objects that identify what floor and office we are

    '
- title: 'managing:'
  contents:
  - "managing:\n       bldgHVACFloor\n       bldgHVACOffice\n"
- title: A single index reference to a table that 'glues' configuration
  contents:
  - 'A single index reference to a table that ''glues'' configuration

    '
- title: 'information defaults with descriptive information:'
  contents:
  - "information defaults with descriptive information:\n       bldgHVACCfgTemplate\n"
- title: A set of objects that show status and units of
  contents:
  - 'A set of objects that show status and units of

    '
- title: work (bldgHVACCoolOrHeatMins) and standard per-row
  contents:
  - 'work (bldgHVACCoolOrHeatMins) and standard per-row

    '
- title: SnmpAdminString, StorageType, and RowStatus columnar
  contents:
  - 'SnmpAdminString, StorageType, and RowStatus columnar

    '
- title: 'objects:'
  contents:
  - "objects:\n        bldgHVACFanSpeed\n        bldgHVACCurrentTemp\n        bldgHVACCoolOrHeatMins\n\
    \        bldgHVACDiscontinuityTime\n        bldgHVACOwner\n        bldgHVACStatus\n"
- title: 'Step 2: A configuration description table.  The purpose of this'
  contents:
  - "Step 2: A configuration description table.  The purpose of this\n        table\
    \ is to provide a unique string identifier for\n        templates.  These may\
    \ be driven by policies in a\n        network.  If it were necessary to configure\
    \ devices\n        to deliver a particular quality of service, the\n        index\
    \ string of this table could be the name and the\n        description part, it\
    \ could be a brief description of the\n        underlying motivation such as:\
    \ \"provides extra heat to\n        corner offices to counteract excessive exterior\
    \ wind\n        chill\".  Standard owner and status objects may also\n       \
    \ be helpful and are included here.  The row columnar\n        objects are:\n\
    \       bldgHVACCfgTemplateInfoIndex\n       bldgHVACCfgTemplateInfoID\n     \
    \  bldgHVACCfgTemplateInfoDescr\n       bldgHVACCfgTemplateInfoOwner\n       bldgHVACCfgTemplateInfoStatus\n"
- title: Notice that to this point we have provided no
  contents:
  - 'Notice that to this point we have provided no

    '
- title: configuration information.  That will be in the next
  contents:
  - 'configuration information.  That will be in the next

    '
- title: table.  Some readers may wonder why this table is not
  contents:
  - 'table.  Some readers may wonder why this table is not

    '
- title: combined with the configuration template table described
  contents:
  - 'combined with the configuration template table described

    '
- title: in the next step.  In fact, they can be.  The reason for
  contents:
  - 'in the next step.  In fact, they can be.  The reason for

    '
- title: having a separate table is that as systems become more
  contents:
  - 'having a separate table is that as systems become more

    '
- title: complex, there may be more than one configuration table
  contents:
  - 'complex, there may be more than one configuration table

    '
- title: that points to these descriptions.  Another reason for
  contents:
  - 'that points to these descriptions.  Another reason for

    '
- title: two tables is that this in not reproduced for every
  contents:
  - 'two tables is that this in not reproduced for every

    '
- title: template and instance, which can save some additional
  contents:
  - 'template and instance, which can save some additional

    '
- title: data movement.  Every designer will have to evaluate the
  contents:
  - 'data movement.  Every designer will have to evaluate the

    '
- title: tradeoffs between number of objects and data movement
  contents:
  - 'tradeoffs between number of objects and data movement

    '
- title: efficiency just as with other MIB modules.
  contents:
  - 'efficiency just as with other MIB modules.

    '
- title: 'Step 3: The bldgHVACCfgTemplateTable contains the specific'
  contents:
  - "Step 3: The bldgHVACCfgTemplateTable contains the specific\n        configuration\
    \ parameters that are pointed to by the\n        bldgHVACConfigPtr object.  Note\
    \ that many rows in the\n        bldgHVACTable can point to an entry in this table.\
    \  It\n        is also possible for entries to be used by 1 or 0 rows\n      \
    \  of the bldgHVACTable.  It is the property of allowing\n        multiple rows\
    \ (instances) in the bldgHVACTable to\n        point to a row in this table that\
    \ can produce such\n        efficiency gains from policy-based management with\n\
    \        SNMP.  Also notice that the configuration data is tied\n        directly\
    \ to the counter data so that people can see\n        how configurations impact\
    \ behavior.\n"
- title: The objects in this table are all that are necessary
  contents:
  - 'The objects in this table are all that are necessary

    '
- title: for configuration and connection to the other tables as
  contents:
  - 'for configuration and connection to the other tables as

    '
- title: well as the usual SnmpAdminString, StorageType, and
  contents:
  - 'well as the usual SnmpAdminString, StorageType, and

    '
- title: 'RowStatus objects:'
  contents:
  - 'RowStatus objects:

    '
- title: 'A simple index to the table:'
  contents:
  - "A simple index to the table:\n       bldgHVACCfgTemplateIndex\n"
- title: 'The configuration objects:'
  contents:
  - "The configuration objects:\n      bldgHVACCfgTemplateDesiredTemp\n      bldgHVACCfgTemplateCoolOrHeat\n"
- title: Administrative objects for SnmpAdminString and
  contents:
  - 'Administrative objects for SnmpAdminString and

    '
- title: 'RowStatus:'
  contents:
  - "RowStatus:\n       bldgHVACCfgTemplateInfo\n       bldgHVACCfgTemplateOwner\n\
    \       bldgHVACCfgTemplateStorage\n       bldgHVACCfgTemplateStatus\n"
- title: 8.1.  MIB Module Definition
  contents:
  - '8.1.  MIB Module Definition

    '
- title: BLDG-HVAC-MIB DEFINITIONS ::= BEGIN
  contents:
  - 'BLDG-HVAC-MIB DEFINITIONS ::= BEGIN

    '
- title: IMPORTS
  contents:
  - "IMPORTS\n    MODULE-IDENTITY, Counter32,\n    Gauge32, OBJECT-TYPE, Unsigned32,\
    \ experimental\n        FROM SNMPv2-SMI\n    MODULE-COMPLIANCE, OBJECT-GROUP\n\
    \       FROM SNMPv2-CONF\n    TEXTUAL-CONVENTION,\n    TimeStamp, RowStatus, StorageType\n\
    \        FROM SNMPv2-TC\n    SnmpAdminString\n        FROM SNMP-FRAMEWORK-MIB;\n"
- title: bldgHVACMIB MODULE-IDENTITY
  contents:
  - "bldgHVACMIB MODULE-IDENTITY\n    LAST-UPDATED \"200303270000Z\"\n    ORGANIZATION\
    \ \"SNMPCONF working group\n                  E-mail: snmpconf@snmp.com\"\n  \
    \  CONTACT-INFO\n        \"Jon Saperia\n        Postal:     JDS Consulting\n \
    \                   174 Chapman Street\n                    Watertown, MA 02472\n\
    \                    U.S.A.\n        Phone:      +1 617 744 1079\n        E-mail:\
    \     saperia@jdscons.com\n        Wayne Tackabury\n        Postal:     Gold Wire\
    \ Technology\n                    411 Waverley Oaks Rd.\n                    Waltham,\
    \ MA 02452\n                    U.S.A.\n        Phone:      +1 781 398 8800\n\
    \        E-mail:     wayne@goldwiretech.com\n        Michael MacFaden\n      \
    \  Postal:     Riverstone Networks\n                    5200 Great America Pkwy.\n\
    \                    Santa Clara, CA 95054\n                    U.S.A.\n     \
    \   Phone:      +1 408 878 6500\n        E-mail:     mrm@riverstonenet.com\n \
    \       David Partain\n        Postal:     Ericsson AB\n                    P.O.\
    \ Box 1248\n                    SE-581 12  Linkoping\n                    Sweden\n\
    \        E-mail:     David.Partain@ericsson.com\"\n    DESCRIPTION\n        \"\
    This example MIB module defines a set of management objects\n        for heating\
    \ ventilation and air conditioning systems.  It\n        also includes objects\
    \ that can be used to create policies\n        that are applied to rooms.  This\
    \ eliminates the need to send\n        per-instance configuration commands to\
    \ the system.\n        Copyright (C) The Internet Society (2003).  This version\
    \ of\n        this MIB module is part of RFC 3512; see the RFC itself for\n  \
    \      full legal notices.\"\n    REVISION \"200303270000Z\"\n    DESCRIPTION\n\
    \        \"Initial version of BLDG-HVAC-MIB as published in RFC 3512.\"\n    ::=\
    \ { experimental 122 }\n"
- title: bldgHVACObjects         OBJECT IDENTIFIER ::= { bldgHVACMIB 1 }
  contents:
  - 'bldgHVACObjects         OBJECT IDENTIFIER ::= { bldgHVACMIB 1 }

    '
- title: bldgConformance         OBJECT IDENTIFIER ::= { bldgHVACMIB 2 }
  contents:
  - 'bldgConformance         OBJECT IDENTIFIER ::= { bldgHVACMIB 2 }

    '
- title: --
  contents:
  - '--

    '
- title: -- Textual Conventions
  contents:
  - '-- Textual Conventions

    '
- title: --
  contents:
  - '--

    '
- title: BldgHvacOperation  ::= TEXTUAL-CONVENTION
  contents:
  - "BldgHvacOperation  ::= TEXTUAL-CONVENTION\n    STATUS             current\n \
    \   DESCRIPTION\n        \"Operations supported by a heating and cooling system.\n\
    \        A reference to underlying general systems would go here.\"\n    SYNTAX\
    \      INTEGER {\n                         heat(1),\n                        \
    \ cool(2)\n                }\n"
- title: --
  contents:
  - '--

    '
- title: -- HVAC Objects Group
  contents:
  - '-- HVAC Objects Group

    '
- title: --
  contents:
  - '--

    '
- title: bldgHVACTable    OBJECT-TYPE
  contents:
  - "bldgHVACTable    OBJECT-TYPE\n    SYNTAX      SEQUENCE OF BldgHVACEntry\n   \
    \ MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n     \
    \   \"This table is the representation and data control\n        for building\
    \ HVAC by each individual office.\n        The table has rows for, and is indexed\
    \ by a specific\n        floor and office number.  Each such row includes\n  \
    \      HVAC statistical and current status information for\n        the associated\
    \ office.  The row also contains a\n        bldgHVACCfgTemplate columnar object\
    \ that relates the\n        bldgHVACTable row to a row in the bldgHVACCfgTemplateTable.\n\
    \        If this value is nonzero, then the instance in the row\n        that\
    \ has a value for how the HVAC has been configured\n        in the associated\
    \ template (bldgHVACCfgTeplateTable row).\n        Hence, the bldgHVACCfgTeplateTable\
    \ row contains the\n        specific configuration values for the offices as described\n\
    \        in this table.\"\n    ::= { bldgHVACObjects 1 }\n"
- title: bldgHVACEntry  OBJECT-TYPE
  contents:
  - "bldgHVACEntry  OBJECT-TYPE\n    SYNTAX       BldgHVACEntry\n    MAX-ACCESS  \
    \ not-accessible\n    STATUS       current\n    DESCRIPTION\n        \"A row in\
    \ the bldgHVACTable.  Each row represents a particular\n        office in the\
    \ building, qualified by its floor and office\n        number.  A given row instance\
    \ can be created or deleted by\n        set operations  upon its bldgHVACStatus\
    \ columnar\n        object instance.\"\n    INDEX { bldgHVACFloor, bldgHVACOffice\
    \ }\n        ::= { bldgHVACTable 1 }\n"
- title: BldgHVACEntry ::= SEQUENCE {
  contents:
  - "BldgHVACEntry ::= SEQUENCE {\n        bldgHVACFloor             Unsigned32,\n\
    \        bldgHVACOffice            Unsigned32,\n        bldgHVACCfgTemplate  \
    \     Unsigned32,\n        bldgHVACFanSpeed          Gauge32,\n        bldgHVACCurrentTemp\
    \       Gauge32,\n        bldgHVACCoolOrHeatMins    Counter32,\n        bldgHVACDiscontinuityTime\
    \ TimeStamp,\n        bldgHVACOwner             SnmpAdminString,\n        bldgHVACStorageType\
    \       StorageType,\n        bldgHVACStatus            RowStatus\n        }\n"
- title: bldgHVACFloor    OBJECT-TYPE
  contents:
  - "bldgHVACFloor    OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..1000)\n    MAX-ACCESS\
    \  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"This portion\
    \ of the index indicates the floor of the\n         building.  The ground floor\
    \ is considered the\n         first floor.  For the purposes of this example,\n\
    \         floors under the ground floor cannot be\n         controlled using this\
    \ MIB module.\"\n    ::= { bldgHVACEntry 1 }\n"
- title: bldgHVACOffice    OBJECT-TYPE
  contents:
  - "bldgHVACOffice    OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..2147483647)\n \
    \   MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n   \
    \     \"This second component of the index specifies the\n        office number.\"\
    \n    ::= { bldgHVACEntry 2 }\n"
- title: bldgHVACCfgTemplate  OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplate  OBJECT-TYPE\n    SYNTAX          Unsigned32\n    MAX-ACCESS\
    \      read-create\n    STATUS          current\n    DESCRIPTION\n        \"The\
    \ index (bldgHVACCfgTemplateIndex instance)\n        of an entry in the 'bldgHVACCfgTemplateTable'.\n\
    \        The bldgHVACCfgTable row instance referenced\n        is a pre-made configuration\
    \ 'template'\n        that represents the configuration described\n        by\
    \ the bldgHVACCfgTemplateInfoDescr object.  Note\n        that not all configurations\
    \ will be under a\n        defined template.  As a result, a row in this\n   \
    \     bldgHVACTable may point to an entry in the\n        bldgHVACCfgTemplateTable\
    \ that does not in turn\n        have a reference (bldgHVACCfgTemplateInfo) to\
    \ an\n        entry in the bldgHVACCfgTemplateInfoTable.  The\n        benefit\
    \ of this approach is that all\n        configuration information is available\
    \ in one\n        table whether all elements in the system are\n        derived\
    \ from configured templates or not.\n        Where the instance value for this\
    \ colunmar object\n        is zero, this row represents data for an office\n \
    \       whose HVAC status can be monitored using the\n        read-only columnar\
    \ object instances of this\n        row, but is not under the configuration control\n\
    \        of the agent.\"\n    ::= { bldgHVACEntry 3 }\n"
- title: bldgHVACFanSpeed  OBJECT-TYPE
  contents:
  - "bldgHVACFanSpeed  OBJECT-TYPE\n    SYNTAX            Gauge32\n    UNITS     \
    \        \"revolutions per minute\"\n    MAX-ACCESS        read-only\n    STATUS\
    \            current\n    DESCRIPTION\n        \"Shows the revolutions per minute\
    \ of the fan.  Fan speed\n        will vary based on the difference between\n\
    \        bldgHVACCfgTemplateDesiredTemp and bldgHVACCurrentTemp.  The\n      \
    \  speed is measured in revolutions of the fan blade per minute.\"\n    ::= {\
    \ bldgHVACEntry 4 }\n"
- title: bldgHVACCurrentTemp  OBJECT-TYPE
  contents:
  - "bldgHVACCurrentTemp  OBJECT-TYPE\n    SYNTAX            Gauge32\n    UNITS  \
    \           \"degrees in celsius\"\n    MAX-ACCESS        read-only\n    STATUS\
    \            current\n    DESCRIPTION\n        \"The current measured temperature\
    \ in the office.  Should\n        the current temperature be measured at a value\
    \ of less\n        than zero degrees celsius, a read of the instance\n       \
    \ for this object will return a value of zero.\"\n    ::= { bldgHVACEntry 5 }\n"
- title: bldgHVACCoolOrHeatMins  OBJECT-TYPE
  contents:
  - "bldgHVACCoolOrHeatMins  OBJECT-TYPE\n    SYNTAX            Counter32\n    UNITS\
    \             \"minutes\"\n    MAX-ACCESS        read-only\n    STATUS       \
    \     current\n    DESCRIPTION\n        \"The total number of heating or cooling\
    \ minutes that have\n        been consumed since the row was activated.  Notice\
    \ that\n        whether the minutes represent heating or cooling is a\n      \
    \  function of the configuration of this row.  If the system\n        is re-initialized\
    \ from a cooling to heating function or\n        vice versa, then the counter\
    \ would start over again.  This\n        effect is similar to a reconfiguration\
    \ of some network\n        interface cards.  When parameters that impact\n   \
    \     configuration are changed, the subsystem must be\n        re-initialized.\
    \  Discontinuities in the value of this counter\n        can occur at re-initialization\
    \ of the management system,\n        and at other times as indicated by the value\
    \ of\n        bldgHVACDiscontinuityTime.\"\n    ::= { bldgHVACEntry 6 }\n"
- title: bldgHVACDiscontinuityTime OBJECT-TYPE
  contents:
  - "bldgHVACDiscontinuityTime OBJECT-TYPE\n    SYNTAX      TimeStamp\n    MAX-ACCESS\
    \  read-only\n    STATUS      current\n    DESCRIPTION\n        \"The value of\
    \ sysUpTime on the most recent occasion at which\n        any heating or cooling\
    \ operation for the office designated\n        by this row instance experienced\
    \ a discontinuity.  If\n        no such discontinuities have occurred since the\
    \ last re-\n        initialization of the this row, then this object contains\
    \ a\n        zero value.\"\n    ::= { bldgHVACEntry 7 }\n"
- title: bldgHVACOwner  OBJECT-TYPE
  contents:
  - "bldgHVACOwner  OBJECT-TYPE\n    SYNTAX            SnmpAdminString\n    MAX-ACCESS\
    \        read-create\n    STATUS            current\n    DESCRIPTION\n       \
    \ \"The identity of the operator/system that\n        last modified this entry.\
    \  When a new entry\n        is created, a valid SnmpAdminString must\n      \
    \  be supplied.  If, on the other hand, this\n        entry is populated by the\
    \ agent 'discovering'\n        unconfigured rooms, the empty string is a valid\n\
    \        value for this object.\"\n    ::= { bldgHVACEntry 8 }\n"
- title: bldgHVACStorageType  OBJECT-TYPE
  contents:
  - "bldgHVACStorageType  OBJECT-TYPE\n    SYNTAX            StorageType\n    MAX-ACCESS\
    \        read-create\n    STATUS            current\n    DESCRIPTION\n       \
    \ \"The persistence of this row of the table in system storage,\n        as it\
    \ pertains to permanence across system resets.  A columnar\n        instance of\
    \ this object with value 'permanent' need not allow\n        write-access to any\
    \ of the columnar object instances in the\n        containing row.\"\n    ::=\
    \ { bldgHVACEntry 9  }\n"
- title: bldgHVACStatus  OBJECT-TYPE
  contents:
  - "bldgHVACStatus  OBJECT-TYPE\n    SYNTAX            RowStatus\n    MAX-ACCESS\
    \        read-create\n    STATUS            current\n    DESCRIPTION\n       \
    \ \"Controls and reflects the creation and activation status of\n        a row\
    \ in this table.\n        No attempt to modify a row columnar object instance\
    \ value in\n        the bldgHVACTable should be issued while the value of\n  \
    \      bldgHVACStatus is active(1).  Should an agent receive a SET\n        PDU\
    \ attempting such a modification in this state, an\n        inconsistentValue\
    \ error should be returned as a result of\n        the SET attempt.\"\n    ::=\
    \ { bldgHVACEntry 10 }\n"
- title: --
  contents:
  - '--

    '
- title: -- HVAC Configuration Template Table
  contents:
  - '-- HVAC Configuration Template Table

    '
- title: --
  contents:
  - '--

    '
- title: bldgHVACCfgTemplateInfoTable  OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateInfoTable  OBJECT-TYPE\n    SYNTAX      SEQUENCE OF BldgHVACCfgTemplateInfoEntry\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \      \"This table provides unique string identification for\n        HVAC templates\
    \ in a network.  If it were necessary to\n        configure rooms to deliver a\
    \ particular quality of climate\n        control with regard to cooling or heating,\
    \ the index string\n        of a row in this table could be the template name.\n\
    \        The bldgHVACCfgCfgTemplateInfoDescription\n        contains a brief description\
    \ of the template service objective\n        such as: provides summer cooling\
    \ settings for executive\n        offices.  The bldgHVACCfgTemplateInfo in the\n\
    \        bldgHVACCfgTemplateTable will contain the pointer to the\n        relevant\
    \ row in this table if it is intended that items\n        that point to a row\
    \ in the bldgHVACCfgTemplateInfoTable be\n        identifiable as being under\
    \ template control though this\n        mechanism.\"\n    ::= { bldgHVACObjects\
    \ 2 }\n"
- title: bldgHVACCfgTemplateInfoEntry  OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateInfoEntry  OBJECT-TYPE\n    SYNTAX       BldgHVACCfgTemplateInfoEntry\n\
    \    MAX-ACCESS   not-accessible\n    STATUS       current\n    DESCRIPTION\n\
    \        \"Each row represents a particular template and\n        description.\
    \  A given row instance can be created or\n        deleted by set operations upon\
    \ its\n        bldgHVACCfgTemplateInfoStatus columnar object\n        instance.\"\
    \n    INDEX { bldgHVACCfgTemplateInfoIndex }\n    ::= { bldgHVACCfgTemplateInfoTable\
    \ 1 }\n"
- title: BldgHVACCfgTemplateInfoEntry ::= SEQUENCE {
  contents:
  - "BldgHVACCfgTemplateInfoEntry ::= SEQUENCE {\n        bldgHVACCfgTemplateInfoIndex\
    \          Unsigned32,\n        bldgHVACCfgTemplateInfoID             SnmpAdminString,\n\
    \        bldgHVACCfgTemplateInfoDescr          SnmpAdminString,\n        bldgHVACCfgTemplateInfoOwner\
    \          SnmpAdminString,\n        bldgHVACCfgTemplateInfoStatus         RowStatus,\n\
    \        bldgHVACCfgTemplateInfoStorType       StorageType\n        }\n"
- title: bldgHVACCfgTemplateInfoIndex   OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateInfoIndex   OBJECT-TYPE\n       SYNTAX       Unsigned32 (1..2147483647)\n\
    \       MAX-ACCESS   not-accessible\n       STATUS       current\n       DESCRIPTION\n\
    \           \"The unique index to a row in this table.\"\n        ::= { bldgHVACCfgTemplateInfoEntry\
    \ 1 }\n"
- title: bldgHVACCfgTemplateInfoID  OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateInfoID  OBJECT-TYPE\n    SYNTAX       SnmpAdminString\n  \
    \  MAX-ACCESS   read-create\n    STATUS       current\n    DESCRIPTION\n     \
    \   \"Textual identifier for this table row, and, consequently\n        the template.\
    \  This should be a unique name within\n        an administrative domain for a\
    \ particular template so that\n        all systems in a network that are under\
    \ the same template\n        can have the same 'handle' (e.g., 'Executive Offices',\n\
    \        'Lobby Areas').\"\n    ::= { bldgHVACCfgTemplateInfoEntry 2 }\n"
- title: bldgHVACCfgTemplateInfoDescr   OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateInfoDescr   OBJECT-TYPE\n    SYNTAX       SnmpAdminString\n\
    \    MAX-ACCESS   read-create\n    STATUS       current\n    DESCRIPTION\n   \
    \     \"A general description of the template.  One example might\n        be\
    \ - Controls the cooling for offices on higher floors\n        during the summer.\"\
    \n    ::= { bldgHVACCfgTemplateInfoEntry 3 }\n"
- title: bldgHVACCfgTemplateInfoOwner  OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateInfoOwner  OBJECT-TYPE\n    SYNTAX            SnmpAdminString\n\
    \    MAX-ACCESS        read-create\n    STATUS            current\n    DESCRIPTION\n\
    \        \"The identity of the operator/system that last modified\n        this\
    \ entry.\"\n    ::= { bldgHVACCfgTemplateInfoEntry 4 }\n"
- title: bldgHVACCfgTemplateInfoStatus  OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateInfoStatus  OBJECT-TYPE\n    SYNTAX            RowStatus\n\
    \    MAX-ACCESS        read-create\n    STATUS            current\n    DESCRIPTION\n\
    \        \"The activation status of this row.\n        No attempt to modify a\
    \ row columnar object instance value in\n        the bldgHVACCfgTemplateInfo Table\
    \ should be issued while the\n        value of bldgHVACCfgTemplateInfoStatus is\
    \ active(1).\n        Should an agent receive a SET PDU attempting such a modification\n\
    \        in this state, an inconsistentValue error should be returned as\n   \
    \     a result of the SET attempt.\"\n    ::= { bldgHVACCfgTemplateInfoEntry 5\
    \ }\n"
- title: bldgHVACCfgTemplateInfoStorType   OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateInfoStorType   OBJECT-TYPE\n    SYNTAX            StorageType\n\
    \    MAX-ACCESS        read-create\n    STATUS            current\n    DESCRIPTION\n\
    \        \"The persistence of this row of the table in system storage,\n     \
    \    as it pertains to permanence across system resets.  A columnar\n        instance\
    \ of this object with value 'permanent' need not allow\n        write-access to\
    \ any of the columnar object instances in the\n        containing row.\"\n   \
    \ ::= { bldgHVACCfgTemplateInfoEntry 6  }\n"
- title: --
  contents:
  - '--

    '
- title: -- HVAC Configuration Template Table
  contents:
  - '-- HVAC Configuration Template Table

    '
- title: --
  contents:
  - '--

    '
- title: bldgHVACCfgTemplateTable    OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateTable    OBJECT-TYPE\n    SYNTAX      SEQUENCE OF BldgHVACCfgTemplateEntry\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \      \"This table contains the templates, which\n        can be used to set\
    \ defaults that will\n        be applied to specific offices.  The application\n\
    \        of those values is accomplished by having a row\n        instance of\
    \ the bldgHVACTable reference a row of\n        this table (by the value of the\
    \ former's\n        bldgHVACCfgTemplate columnar instance).  Identifying\n   \
    \     information concerning a row instance of this table\n        can be found\
    \ in the columnar data of the row instance\n        of the bldgHVACCfgTemplateInfoTable\
    \ entry referenced\n        by the bldgHVACCfgTemplateInfo columnar object of\n\
    \        this table.\"\n    ::= { bldgHVACObjects 3 }\n"
- title: bldgHVACCfgTemplateEntry  OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateEntry  OBJECT-TYPE\n    SYNTAX       BldgHVACCfgTemplateEntry\n\
    \    MAX-ACCESS   not-accessible\n    STATUS       current\n    DESCRIPTION\n\
    \        \"Each row represents a single set of template parameters\n        that\
    \ can be applied to selected instances - in this case\n        offices.  These\
    \ policies will be turned on and off by the\n        policy module through its\
    \ scheduling facilities.\n        A given row instance can be created or\n   \
    \     deleted by set operations upon its\n        bldgHVACCfgTemplateStatus columnar\
    \ object instance.\"\n    INDEX { bldgHVACCfgTemplateIndex }\n    ::= { bldgHVACCfgTemplateTable\
    \ 1 }\n"
- title: BldgHVACCfgTemplateEntry ::= SEQUENCE {
  contents:
  - "BldgHVACCfgTemplateEntry ::= SEQUENCE {\n        bldgHVACCfgTemplateIndex   \
    \        Unsigned32,\n        bldgHVACCfgTemplateDesiredTemp     Gauge32,\n  \
    \      bldgHVACCfgTemplateCoolOrHeat      BldgHvacOperation,\n        bldgHVACCfgTemplateInfo\
    \            Unsigned32,\n        bldgHVACCfgTemplateOwner           SnmpAdminString,\n\
    \        bldgHVACCfgTemplateStorage         StorageType,\n        bldgHVACCfgTemplateStatus\
    \          RowStatus\n"
- title: '}'
  contents:
  - '}

    '
- title: bldgHVACCfgTemplateIndex    OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateIndex    OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..2147483647)\n\
    \    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n  \
    \      \"A unique value for each defined template in this\n        table.  This\
    \ value can be referenced as a row index\n        by any MIB module that needs\
    \ access to this information.\n        The bldgHVACCfgTemplate will point to entries\
    \ in this\n        table.\"\n    ::= { bldgHVACCfgTemplateEntry 1 }\n"
- title: bldgHVACCfgTemplateDesiredTemp OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateDesiredTemp OBJECT-TYPE\n    SYNTAX            Gauge32\n \
    \   UNITS             \"degrees in celsius\"\n    MAX-ACCESS        read-create\n\
    \    STATUS            current\n    DESCRIPTION\n        \"This is the desired\
    \ temperature setting.  It might be\n        changed at different times of the\
    \ day or based on\n        seasonal conditions.  It is permitted to change this\
    \ value\n        by first moving the row to an inactive state, making the\n  \
    \      change and then reactivating the row.\"\n    ::= { bldgHVACCfgTemplateEntry\
    \ 2 }\n"
- title: bldgHVACCfgTemplateCoolOrHeat  OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateCoolOrHeat  OBJECT-TYPE\n    SYNTAX             BldgHvacOperation\n\
    \    MAX-ACCESS         read-create\n    STATUS             current\n    DESCRIPTION\n\
    \        \"This controls the heating and cooling mechanism and is\n        set-able\
    \ by building maintenance.  It is permitted to\n        change this value by first\
    \ moving the row to an inactive\n        state, making the change and then reactivating\
    \ the row.\"\n    ::= { bldgHVACCfgTemplateEntry 3 }\n"
- title: bldgHVACCfgTemplateInfo OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateInfo OBJECT-TYPE\n    SYNTAX             Unsigned32\n    MAX-ACCESS\
    \         read-create\n    STATUS             current\n    DESCRIPTION\n     \
    \   \"This object points to a row in the\n        bldgHVACCfgTemplateInfoTable.\
    \  This controls the\n        heating and cooling mechanism and is set-able by\n\
    \        building maintenance.  It is permissible to change\n        this value\
    \ by first moving the row to an inactive\n        state, making the change and\
    \ then reactivating\n        the row.  A value of zero means that this entry\n\
    \        is not associated with a named template found\n        in the bldgHVACCfgTemplateInfoTable.\"\
    \n    ::= { bldgHVACCfgTemplateEntry 4 }\n"
- title: bldgHVACCfgTemplateOwner  OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateOwner  OBJECT-TYPE\n    SYNTAX            SnmpAdminString\n\
    \    MAX-ACCESS        read-create\n    STATUS            current\n    DESCRIPTION\n\
    \        \"The identity of the administrative entity\n        that created this\
    \ row of the table.\"\n    ::= { bldgHVACCfgTemplateEntry 5 }\n"
- title: bldgHVACCfgTemplateStorage  OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateStorage  OBJECT-TYPE\n    SYNTAX            StorageType\n\
    \    MAX-ACCESS        read-create\n    STATUS            current\n    DESCRIPTION\n\
    \        \"The persistence of this row of the table across\n         system resets.\
    \  A columnar instance of this object with\n         value 'permanent' need not\
    \ allow write-access to any\n         of the columnar object instances in the\
    \ containing row.\"\n    ::= { bldgHVACCfgTemplateEntry 6 }\n"
- title: bldgHVACCfgTemplateStatus  OBJECT-TYPE
  contents:
  - "bldgHVACCfgTemplateStatus  OBJECT-TYPE\n    SYNTAX            RowStatus\n   \
    \ MAX-ACCESS        read-create\n    STATUS            current\n    DESCRIPTION\n\
    \        \"The activation status of this row of the table.\n        No attempt\
    \ to modify a row columnar object instance value in\n        the bldgHVACCfgTemplateTable\
    \ should be issued while the\n        value of bldgHVACCfgTemplateStatus is active(1).\n\
    \        Should an agent receive a SET PDU attempting such a modification\n  \
    \      in this state, an inconsistentValue error should be returned as\n     \
    \   a result of the SET attempt.\"\n    ::= { bldgHVACCfgTemplateEntry 7 }\n"
- title: --
  contents:
  - '--

    '
- title: -- Conformance Information
  contents:
  - '-- Conformance Information

    '
- title: --
  contents:
  - '--

    '
- title: bldgCompliances  OBJECT IDENTIFIER ::= { bldgConformance 1 }
  contents:
  - 'bldgCompliances  OBJECT IDENTIFIER ::= { bldgConformance 1 }

    '
- title: bldgGroups       OBJECT IDENTIFIER ::= { bldgConformance 2 }
  contents:
  - 'bldgGroups       OBJECT IDENTIFIER ::= { bldgConformance 2 }

    '
- title: -- Compliance Statements
  contents:
  - '-- Compliance Statements

    '
- title: bldgCompliance MODULE-COMPLIANCE
  contents:
  - "bldgCompliance MODULE-COMPLIANCE\n    STATUS current\n    DESCRIPTION\n     \
    \   \"The requirements for conformance to the BLDG-HVAC-MIB.  The\n         bldgHVACObjects\
    \ group must be implemented to conform to the\n         BLDG-HVAC-MIB.\"\n   \
    \ MODULE -- this module\n    GROUP bldgHVACObjectsGroup\n    DESCRIPTION\n   \
    \     \"The bldgHVACObjects is mandatory for all systems that\n        support\
    \ HVAC systems.\"\n    ::= { bldgCompliances 1 }\n"
- title: bldgHVACObjectsGroup OBJECT-GROUP
  contents:
  - "bldgHVACObjectsGroup OBJECT-GROUP\n    OBJECTS {\n        bldgHVACCfgTemplate,\n\
    \        bldgHVACFanSpeed, bldgHVACCurrentTemp,\n        bldgHVACCoolOrHeatMins,\
    \ bldgHVACDiscontinuityTime,\n        bldgHVACOwner, bldgHVACStatus,\n       \
    \ bldgHVACStorageType, bldgHVACCfgTemplateInfoID,\n        bldgHVACCfgTemplateInfoDescr,\
    \ bldgHVACCfgTemplateInfoOwner,\n        bldgHVACCfgTemplateInfoStatus,\n    \
    \    bldgHVACCfgTemplateInfoStorType,\n        bldgHVACCfgTemplateDesiredTemp,\n\
    \        bldgHVACCfgTemplateCoolOrHeat,\n        bldgHVACCfgTemplateInfo,\n  \
    \      bldgHVACCfgTemplateOwner,bldgHVACCfgTemplateStorage,\n        bldgHVACCfgTemplateStatus\n\
    \    }\n    STATUS current\n    DESCRIPTION\n        \"The bldgHVACObjects Group.\"\
    \n    ::= { bldgGroups 1 }\n"
- title: END
  contents:
  - 'END

    '
- title: 8.2.  Notes on MIB Module with Template-based Data
  contents:
  - "8.2.  Notes on MIB Module with Template-based Data\n   The primary purpose of\
    \ the example \"HVAC\" MIB module is to show how\n   to construct a single module\
    \ that includes configuration, template,\n   counter and state information in\
    \ a single module.  If this were a\n   'real' module we would also have included\
    \ definitions for\n   notifications for the configuration change operations as\
    \ previously\n   described.  We also would have included notifications for faults\
    \ and\n   other counter threshold events.\n   Implementation and Instance Extensions:\n\
    \   Just as with networking technologies, vendors may wish to add\n   extensions\
    \ that can distinguish their products from the competition.\n   If an HVAC vendor\
    \ also wanted to support humidity control, they could\n   add that facility to\
    \ their equipment and use AUGMENTS for the\n   bldgHVACTemplateTable with two\
    \ objects, one that indicates the\n   desired humidity and the other, the actual.\
    \  The\n   bldgHVACTemplateTable could also be extended using this same approach\n\
    \   so that HVAC policies could easily be extended to support this\n   vendor.\n"
- title: 8.3.  Examples of Usage of the MIB
  contents:
  - "8.3.  Examples of Usage of the MIB\n   The following two examples use two templates\
    \ to configure the\n   temperature in executive offices and in conference rooms.\
    \  The\n   \"conference rooms\" template is applied to all conference rooms (which\n\
    \   happen to be office 104 on each floor), and the \"executive offices\"\n  \
    \ template is applied to executive offices.\n   If offices 24, 25, and 26 on the\
    \ third floor are executive offices,\n   the values in the bldgHVACTable might\
    \ be:\n   bldgHVACCfgTemplate.3.24 = 2\n   bldgHVACFanSpeed.3.24 = 2989\n   bldgHVACCurrentTemp.3.24\
    \ = 24\n   bldgHVACCoolOrHeatMins.3.24 = 123\n   bldgHVACDiscontinuityTime.3.24\
    \ = sysUpTime + 12h + 21m\n   bldgHVACOwner.3.24 = \"policy engine\"\n   bldgHVACStorageType.3.24\
    \ = nonVolatile(3)\n   bldgHVACStatus.3.24 = active(1)\n   bldgHVACCfgTemplate.3.25\
    \ = 2\n   bldgHVACFanSpeed.3.25 = 0\n   bldgHVACCurrentTemp.3.25 = 22\n   bldgHVACCoolOrHeatMins.3.25\
    \ = 298\n   bldgHVACDiscontinuityTime.3.25 = sysUpTime + 4h + 2m\n   bldgHVACOwner.3.25\
    \ = \"policy engine\"\n   bldgHVACStorageType.3.25 = nonVolatile(3)\n   bldgHVACStatus.3.25\
    \ = active(1)\n   bldgHVACCfgTemplate.3.26 = 2\n   bldgHVACFanSpeed.3.26 = 0\n\
    \   bldgHVACCurrentTemp.3.26 = 22\n   bldgHVACCoolOrHeatMins.3.26 = 982\n   bldgHVACOwner.3.26\
    \ = \"policy engine\"\n   bldgHVACStorageType.3.26 = nonVolatile(3)\n   bldgHVACStatus.3.26\
    \ = active(1)\n   The second entry in the bldgHVACCfgTemplateTable, to which all\
    \ of the\n   above point, might have the following configuration:\n   bldgHVACCfgTemplateDesiredTemp.2\
    \ = 22\n   bldgHVACCfgTemplateCoolOrHeat.2 = cool(2)\n   bldgHVACCfgTemplateInfo.2\
    \ = 2\n   bldgHVACCfgTemplateOwner.2 = \"Senior Executive assistant\"\n   bldgHVACCfgTemplateStorage.2\
    \ = nonVolatile(3)\n   bldgHVACCfgTemplateStatus.2 = active(1)\n   and the associated\
    \ template information (\"executive offices\") might\n   be:\n   bldgHVACCfgTemplateInfoID.2\
    \ = \"executive offices\"\n   bldgHVACCfgTemplateInfoDescr.2 = \"Controls temperature\
    \ for executive\n                                     offices\"\n   bldgHVACCfgTemplateInfoOwner.2\
    \ = \"Senior Executive assistant\"\n   bldgHVACCfgTemplateInfoStorType.2 = nonVolatile(3)\n\
    \   bldgHVACCfgTemplateInfoStatus.2 = active(1)\n   The policy engine can now\
    \ associate instances of executive offices\n   with the template called \"executive\
    \ offices\" and apply the values in\n   the second entry of the bldgHVACCfgTemplateTable\
    \ to each of the\n   instances of the executive offices.  This will then attempt\
    \ to set\n   the temperature in executive offices to 22 degrees celsius.\n   It\
    \ is also possible that there may be an office configured for a\n   particular\
    \ temperature, but without using a template.  For example,\n   office 28 on the\
    \ third floor might look like this:\n   bldgHVACCfgTemplate.3.28 = 3\n   bldgHVACFanSpeed.3.28\
    \ = 50\n   bldgHVACCurrentTemp.3.28 = 26\n   bldgHVACCoolOrHeatMins.3.28 = 0\n\
    \   bldgHVACDiscontinuityTime.3.28 = 0\n   bldgHVACOwner.3.28 = \"Executive with\
    \ poor circulation\"\n   bldgHVACStorageType.3.28 = nonVolatile(3)\n   bldgHVACStatus.3.28\
    \ = active(1)\n   The entry in the bldgHVACCfgTemplateTable (to which\n   bldgHVACCfgTemplate.3.28\
    \ points) might instead look like:\n   bldgHVACCfgTemplateDesiredTemp.3 = 28\n\
    \   bldgHVACCfgTemplateCoolOrHeat.3 = cool(2)\n   bldgHVACCfgTemplateInfo.3 =\
    \ 0.0\n   bldgHVACCfgTemplateOwner.3 = \"Executive with poor circulation\"\n \
    \  bldgHVACCfgTemplateStorage.3 = nonVolatile(3)\n   bldgHVACCfgTemplateStatus.3\
    \ = active(1)\n   Note that this entry does not point to a template.\n   If the\
    \ executive's circulation improves so that the temperature\n   should be aligned\
    \ with other executive offices, this is accomplished\n   by changing the value\
    \ of bldgHVACCfgTemplate.3.28 from\n   bldgHVACCfgTemplateInfoID.3 to bldgHVACCfgTemplateInfoID.2\
    \ (shown\n   above).\n   Finally, there might be offices for which there is no\
    \ configured\n   temperature but management applications can read the current\n\
    \   temperature, fan speed, and cooling or heating minutes from the\n   bldgHVACTable.\
    \  In that case, the value of bldgHVACCfgTemplate will\n   be a zero index (\"\
    null\"), as will the value of bldgHVACOwner.\n   bldgHVACCfgTemplate.4.2 = 0\n\
    \   bldgHVACFanSpeed.3.28 = 50\n   bldgHVACCurrentTemp.3.28 = 26\n   bldgHVACCoolOrHeatMins.3.28\
    \ = 0\n   bldgHVACDiscontinuityTime.3.28 = 0\n   bldgHVACOwner.3.28 = \"\"\n \
    \  bldgHVACStorageType.3.28 = nonVolatile(3)\n   bldgHVACStatus.3.28 = active(1)\n\
    \   As a second example, the conference rooms on several floors are\n   configured\
    \ using the \"conference rooms\" template.  When the values in\n   the bldgHVACTable\
    \ pertaining to conference rooms are read, it might\n   look like:\n   bldgHVACCfgTemplate.12.104\
    \ = bldgHVACCfgTemplateDesiredTemp.1\n   bldgHVACFanSpeed.12.104 = 1423\n   bldgHVACCurrentTemp.12.104\
    \ = 21\n   bldgHVACCoolOrHeatMins.12.104 = 2193\n   bldgHVACDiscontinuityTime.12.104\
    \ = sysUpTime + 36h + 15m\n   bldgHVACOwner.12.104 =  = \"Bob the Conference Guy\"\
    \n   bldgHVACStorageType.12.104 = nonVolatile(3)\n   bldgHVACStatus.12.104 = active(1)\n\
    \   bldgHVACCfgTemplate.14.104 = bldgHVACCfgTemplateDesiredTemp.1\n   bldgHVACFanSpeed.14.104\
    \ = 1203\n   bldgHVACCurrentTemp.14.104 = 20\n   bldgHVACCoolOrHeatMins.14.104\
    \ = 293\n   bldgHVACDiscontinuityTime.14.104 = sysUpTime + 5h + 54m\n   bldgHVACOwner.14.104\
    \ =  = \"Bob the Conference Guy\"\n   bldgHVACStorageType.14.104 = nonVolatile(3)\n\
    \   bldgHVACStatus.14.104 = active(1)\n   bldgHVACCfgTemplate.15.104 = bldgHVACCfgTemplateDesiredTemp.1\n\
    \   bldgHVACFanSpeed.15.104 = 12\n   bldgHVACCurrentTemp.15.104 = 19\n   bldgHVACCoolOrHeatMins.15.104\
    \ = 1123\n   bldgHVACDiscontinuityTime.15.103 = sysUpTime + 2d + 2h + 7m\n   bldgHVACOwner.15.104\
    \ =  = \"Bob the Conference Guy\"\n   bldgHVACStorageType.15.104 = nonVolatile(3)\n\
    \   bldgHVACStatus.15.104 = active(1)\n   The desired temperature and whether\
    \ to heat or cool is configured in\n   the first entry of the bldgHVACCfgTemplateTable,\
    \ which tries to set\n   the temperature to 19 degrees celsius in conference rooms:\n\
    \   bldgHVACCfgTemplateDesiredTemp.1 = 19\n   bldgHVACCfgTemplateCoolOrHeat.1\
    \ = cool(2)\n   bldgHVACCfgTemplateInfo.1 = bldgHVACCfgTemplateInfoID.1\n   bldgHVACCfgTemplateOwner.1\
    \ = \"Bob the Conference Guy\"\n   bldgHVACCfgTemplateStorage.1 = nonVolatile(3)\n\
    \   bldgHVACCfgTemplateStatus.1 = active(1)\n   The associated template information\
    \ would then have:\n   bldgHVACCfgTemplateInfoID.1 = \"conference rooms\"\n  \
    \ bldgHVACCfgTemplateInfoDescr.1 = \"Controls temperature in conference\n   rooms\"\
    \ bldgHVACCfgTemplateInfoOwner.1 = \"Bob the Conference Guy\"\n   bldgHVACCfgTemplateInfoStorType.1\
    \ = nonVolatile(3)\n   bldgHVACCfgTemplateInfoStatus.1 = active(1)\n   The policy\
    \ system can then apply this template (cool to 19 degrees\n   Celsius) to its\
    \ notion of all of the conference rooms in the\n   building.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   This document discusses practices and methods\
    \ for using the SNMP for\n   management and distribution of configuration information\
    \ for network\n   elements.  Any effective use of the SNMP in this application\
    \ must\n   concern itself with issues of authentication of the management\n  \
    \ entities initiating configuration change and management, in addition\n   to\
    \ the integrity of the configuration data itself.  Other more subtle\n   considerations\
    \ also exist.\n   To that end, the section of this document entitled \"Deployment\
    \ and\n   Security Issues\" covers these security considerations to the extent\n\
    \   they affect the current practices described throughout this document.\n  \
    \ In particular, in the subsection entitled \"Secure Agent\n   Considerations\"\
    , there is a recommendation for the usage of Version 3\n   of the SNMP, and its\
    \ essential presumption as a foundation for other\n   practices described throughout.\
    \  With the exception of a small number\n   of cases where a mention is made to\
    \ the contrary to illustrate\n   techniques for coexistence with application entities\
    \ dependent upon\n   earlier versions of the SNMP, that recommendation of usage\
    \ of Version\n   3 of the SNMP is reiterated here.\n"
- title: 10.  Acknowledgments
  contents:
  - "10.  Acknowledgments\n   This document was produced by the SNMPCONF Working Group.\
    \ In\n   particular, the editors wish to thank:\n      Christopher Anderson\n\
    \      Andy Bierman\n      Greg Bruell\n      Dr Jeffrey Case\n      Chris Elliott\n\
    \      Joel Halpern\n      Pablo Halpern\n      Wes Hardaker\n      David Harrington\n\
    \      Harrie Hazewinkel\n      Thippanna Hongal\n      Bob Moore\n      David\
    \ T. Perkins\n      Randy Presuhn\n      Dan Romascanu\n      Shawn Routhier\n\
    \      Steve Waldbusser\n      Bert Wijnen\n"
- title: 11.  Normative References
  contents:
  - "11.  Normative References\n   [1]  Harrington, D., Presuhn, R. and B. Wijnen,\
    \ \"An Architecture for\n        Describing Simple Network Management Protocol\
    \ (SNMP) Management\n        Frameworks\", STD 62, RFC 3411, December 2002.\n\
    \   [2]  McCloghrie, K., Perkins, D. and J. Schoenwaelder, \"Structure of\n  \
    \      Management Information Version 2 (SMIv2)\", STD 58, RFC 2578,\n       \
    \ April 1999.\n   [3]  McCloghrie, K., Perkins, D. and J. Schoenwaelder, \"Textual\n\
    \        Conventions for SMIv2\", STD 58, RFC 2579, April 1999.\n   [4]  McCloghrie,\
    \ K., Perkins, D. and J. Schoenwaelder, \"Conformance\n        Statements for\
    \ SMIv2\", STD 58, RFC 2580, April 1999.\n   [5]  Presuhn, R. (Ed.), \"Transport\
    \ Mappings for the Simple Network\n        Management Protocol (SNMPv2)\", STD\
    \ 62, RFC 3417, December 2002.\n   [6]  Case, J., Harrington D., Presuhn R. and\
    \ B. Wijnen, \"Message\n        Processing and Dispatching for the Simple Network\
    \ Management\n        Protocol (SNMP)\", STD 62, RFC 3412, December 2002.\n  \
    \ [7]  Blumenthal, U. and B. Wijnen, \"User-based Security Model (USM)\n     \
    \   for version 3 of the Simple Network Management Protocol\n        (SNMPv3)\"\
    , STD 62, RFC 3414, December 2002.\n   [8]  Presuhn, R. (Ed.), \"Version 2 of\
    \ the Protocol Operations for the\n        Simple Network Management Protocol\
    \ (SNMP)\", STD 62, RFC 3416,\n        December 2002.\n   [9]  Levi, D., Meyer,\
    \ P., and B. Stewart, \"Simple Network Management\n        Protocol Applications\"\
    , STD 62, RFC 3413, December 2002.\n   [10] Wijnen, B., Presuhn, R. and K. McCloghrie,\
    \ \"View-based Access\n        Control Model (VACM) for the Simple Network Management\
    \ Protocol\n        (SNMP)\", STD 62, RFC 3415, December 2002.\n   [11] Presuhn,\
    \ R. (Ed.), \"Management Information Base for the Simple\n        Network Management\
    \ Protocol (SNMPv2)\", STD 62, RFC 3418,\n        December 2002.\n   [12] Case,\
    \ J., Mundy, R., Partain, D. and B. Stewart, \"Introduction\n        and Applicability\
    \ Statements for Internet-Standard Management\n        Framework\", RFC 3410,\
    \ December 2002.\n   [13] Daniele, M., Haberman, B., Routhier, S. and J. Schoenwaelder,\n\
    \        \"Textual Conventions for Internet Network Addresses\", RFC 3291,\n \
    \       May 2002.\n   [14] McCloghrie, K. (Ed.), \"SNMPv2 Management Information\
    \ Base for\n        the Internet Protocol using SMIv2\", RFC 2011, November 1996.\n"
- title: 12.  Informative References
  contents:
  - "12.  Informative References\n   [15] Rose, M. and K. McCloghrie, \"Structure\
    \ and Identification of\n        Management Information for TCP/IP-based Internets\"\
    , STD 16, RFC\n        1155, May 1990.\n   [16] Rose, M. and K. McCloghrie, \"\
    Concise MIB Definitions\", STD 16,\n        RFC 1212, March 1991.\n   [17] Rose,\
    \ M., \"A Convention for Defining Traps for use with the\n        SNMP\", RFC\
    \ 1215, March 1991.\n   [18] Case, J., Fedor, M., Schoffstall, M. and J. Davin,\
    \ \"Simple\n        Network Management Protocol\", STD 15, RFC 1157, May 1990.\n\
    \   [19] Case, J., McCloghrie, K., Rose, M., and S. Waldbusser,\n        \"Introduction\
    \ to Community-based SNMPv2\", RFC 1901, January\n        1996.\n   [20] McCloghrie,\
    \ K. and F. Kastenholz, \"The Interfaces Group MIB\",\n        RFC 2863, June\
    \ 2000.\n   [21] Brown, C. and F. Baker, \"Management Information Base for Frame\n\
    \        Relay DTEs Using SMIv2\", RFC 2115, September 1997.\n   [22] Baker, F.\
    \ (Ed.), \"Requirements for IP Version 4 Routers\", RFC\n        1812, June 1995.\n\
    \   [23] Hawkinson, J. and T. Bates, \"Guidelines for Creation, Selection,\n \
    \       and Registration of an Autonomous System (AS)\", BCP 6, RFC 1930,\n  \
    \      March 1996.\n   [24] Decker, E., Langille, P., Rijsinghani, A. and K. McCloghrie,\n\
    \        \"Definitions of Managed Objects for Bridges\", RFC 1493, July\n    \
    \    1993.\n   [25] Levi, D. and J. Schoenwaelder \"Definitions of Managed Objects\n\
    \        for Scheduling Management Operations\", RFC 3231, January 2002.\n   [26]\
    \ Bell, E., Smith, A., Langille, P., Rijsinghani, A. and K.\n        McCloghrie,\
    \ \"Definitions of Managed Objects for Bridges with\n        Traffic Classes,\
    \ Multicast Filtering and Virtual LAN\n        Extensions\", RFC 2674, August\
    \ 1999.\n   [27] Baker, F., \"IP Forwarding Table MIB\", RFC 2096, January 1997.\n\
    \   [28] St. Johns, M. (Ed.), \"Radio Frequency (RF) Interface Management\n  \
    \      Information Base for MCNS/DOCSIS compliant RF interfaces\", RFC\n     \
    \   2670, August 1999.\n   [29] Baker, F. and R. Coltun, \"OSPF Version 2 Management\
    \ Information\n        Base\", RFC 1850, November 1995.\n   [30] Blake, S., Black,\
    \ D., Carlson M., Davies, E., Wang, Z. and W.\n        Weiss, \"An Architecture\
    \ for Differentiated Services \", RFC 2475,\n        December 1998.\n   [31] Willis,\
    \ S., Burruss, J. and J. Chu (Ed.), \"Definitions of\n        Managed Objects\
    \ for the Fourth Version of the Border Gateway\n        Protocol (BGP-4) using\
    \ SMIv2\", RFC 1657, July 1994.\n   [32] Waldbusser, S., \"Remote Network Monitoring\
    \ Management\n        Information Base\", RFC 2819, May 2000.\n   [33] McCloghrie,\
    \ K. and G. Hanson, \"The Inverted Stack Table\n        Extension to the Interfaces\
    \ Group MIB\", RFC 2864, June 2000.\n   [34] McCloghrie, K. and A. Bierman, \"\
    Entity MIB (Version 2)\", RFC\n        2737, December 1999.\n   [35] ITU-T,, Recommendation\
    \ M.3010., PRINCIPLES FOR A\n        TELECOMMUNICATIONS MANAGEMENT NETWORK.  February,\
    \ 2000.\n   [36] Waldbusser, S., Saperia, J., and Hongal, T., \"Policy Based\n\
    \        Management MIB\", Work-in-progress.\n   [37] Heintz, L., \"SNMP Row Operations\
    \ Extensions\", Work-in-progress.\n   [38] Zeltserman, D., \"A Practical Guide\
    \ to Snmpv3 and Network\n        Management\", Prentice Hall, 1999.\n   [39] Noto,\
    \ M., Spiegel, E. and K. Tesink, \"Definitions of Textual\n        Conventions\
    \ and OBJECT-IDENTITIES for ATM Management\", RFC 2514,\n        February 1999.\n\
    \   [40] Kassaveri, R., Editor, \"Distributed Management Expression MIB\",\n \
    \       RFC 2982, October 2000.\n   [41] St. Johns, M., \"DOCSIS Cable Device\
    \ MIB Cable Device Management\n        Information Base for DOCSIS compliant Cable\
    \ Modems and Cable\n        Modem Termination Systems\", RFC 2669, August 1999.\n\
    \   [42] Westerinen, A., Schnizlein, J., Strassner, J., Scherling, M.,\n     \
    \   Quinn, B., Herzog, S., Huynh, A., Carlson, M., Perry, J. and S.\n        Waldbusser,\
    \ \"Terminology for Policy-Based Management\", RFC 3198,\n        November 2001.\n\
    \   [43] http://wwww.cisco.com/univercd/cc/td/product/software/ios113ed/\n   \
    \     11ed_cr/secur_c/scprt/scacls.pdf.\n   [44] Waldbusser, S., \"Remote Network\
    \ Monitoring Management\n        Information Base Version 2 using SMIv2\", RFC\
    \ 2021, January 1997.\n"
- title: 13.  Intellectual Property
  contents:
  - "13.  Intellectual Property\n   The IETF takes no position regarding the validity\
    \ or scope of any\n   intellectual property or other rights that might be claimed\
    \ to\n   pertain to the implementation or use of the technology described in\n\
    \   this document or the extent to which any license under such rights\n   might\
    \ or might not be available; neither does it represent that it\n   has made any\
    \ effort to identify any such rights.  Information on the\n   IETF's procedures\
    \ with respect to rights in standards-track and\n   standards-related documentation\
    \ can be found in BCP-11.  Copies of\n   claims of rights made available for publication\
    \ and any assurances of\n   licenses to be made available, or the result of an\
    \ attempt made to\n   obtain a general license or permission for the use of such\n\
    \   proprietary rights by implementors or users of this specification can\n  \
    \ be obtained from the IETF Secretariat.\n   The IETF invites any interested party\
    \ to bring to its attention any\n   copyrights, patents or patent applications,\
    \ or other proprietary\n   rights which may cover technology that may be required\
    \ to practice\n   this standard.  Please address the information to the IETF Executive\n\
    \   Director.\n"
- title: 14. Editors' Addresses
  contents:
  - "14. Editors' Addresses\n   Michael R. MacFaden\n   Riverstone Networks, Inc\n\
    \   5200 Great America Parkway\n   Santa Clara, CA 95054\n   EMail: mrm@riverstonenet.com\n\
    \   David Partain\n   Ericsson AB\n   P.O. Box 1248\n   SE-581 12  Linkoping\n\
    \   Sweden\n   EMail: David.Partain@ericsson.com\n   Jon Saperia\n   JDS Consulting\n\
    \   174 Chapman Street\n   Watertown, MA 02472\n   EMail: saperia@jdscons.com\n\
    \   Wayne F. Tackabury\n   Gold Wire Technology\n   411 Waverley Oaks Rd.\n  \
    \ Waltham, MA  02452\n   EMail: wayne@goldwiretech.com\n"
- title: 15.  Full Copyright Statement
  contents:
  - "15.  Full Copyright Statement\n   Copyright (C) The Internet Society (2003).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
