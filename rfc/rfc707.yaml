- title: __initial_text__
  contents:
  - "NCC 76         A High-Level Framework for Network-Based Resource Sharing\nTHE\
    \ GOAL, RESOURCE SHARING                                             1\n   The\
    \ principal goal of all resource-sharing computer networks,\nincluding the now\
    \ international ARPA Network (the ARPANET), is to\nusefully interconnect geographically\
    \ distributed hardware, software,\nand human resources [1].  Achieving this goal\
    \ requires the design\nand implementation of various levels of support software\
    \ within each\nconstituent computer, and the specification of network-wide\n\"\
    protocols\" (that is, conventions regarding the format and the\nrelative timing\
    \ of network messages) governing their interaction.\nThis paper outlines an alternative\
    \ to the approach that ARPANET\nsystem builders have been taking since work in\
    \ this area began in\n1970, and suggests a strategy for modeling distributed systems\n\
    within any large computer network.                                    1a\n   The\
    \ first section of this paper describes the prevailing ARPANET\nprotocol strategy,\
    \ which involves specifying a family of\napplication-dependent protocols with\
    \ a network-wide inter-process\ncommunication facility as their common foundation.\
    \  In the second\nsection, the application-independent command/response discipline\n\
    that characterizes this protocol family is identified and its\nisolation as a\
    \ separate protocol proposed.  Such isolation would\nreduce the work of the applications\
    \ programmer by allowing the\nsoftware that implements the protocol to be factored\
    \ out of each\napplications program and supplied as a single,\ninstallation-maintained\
    \ module.  The final section of this paper\nproposes an extensible model for this\
    \ class of network interaction\nthat in itself would even further encourage the\
    \ use of network\nresources.                                                 \
    \           1b\n                                  -1-\fNWG/RFC# 707          \
    \                        JEW 14-JAN-76 19:51  34263\nNCC 76         A High-Level\
    \ Framework for Network-Based Resource Sharing\n                       The Current\
    \ Software Approach to Resource Sharing\nTHE CURRENT SOFTWARE APPROACH TO RESOURCE\
    \ SHARING                      2\nFunction-Oriented Protocols                \
    \                           2a\n   The current ARPANET software approach to facilitating\
    \ resource\nsharing has been detailed elsewhere in the literature [2, 3, 4].\n\
    Briefly, it involves defining a Host-Host Protocol by which the\noperating systems\
    \ of the various \"host\" computers cooperate to\nsupport a network-wide inter-process\
    \ communication (IPC) facility,\nand then various function-oriented protocols\
    \ by which processes\ndeliver and receive specific services via IPC.  Each\nfunction-oriented\
    \ protocol regulates the dialog between a resident\n\"server process\" providing\
    \ the service, and a \"user process\" seeking\nthe service on behalf of a user\
    \ (the terms \"user\" and \"user process\"\nwill be used consistently throughout\
    \ this paper to distinguish the\nhuman user from the computer process acting on\
    \ his behalf).          2a1\n   The current Host-Host Protocol has been in service\
    \ since 1970.\nSince its initial design and implementation, a variety of\ndeficiencies\
    \ have been recognized and several alternative protocols\nsuggested [5, 6].  Although\
    \ improvements at this level would surely\nhave a positive effect upon Network\
    \ resource sharing, the present\npaper simply assumes the existence of some form\
    \ of IPC and focuses\nattention upon higher level protocol design issues.    \
    \              2a2\n   Each of the function-oriented protocols mentioned in this\
    \ paper\nconstitutes the official ARPANET protocol for its respective\napplication\
    \ domain and is therefore implemented at nearly all of the\n75 host installations\
    \ that now comprise the Network.  It is\nprimarily upon this widely implemented\
    \ protocol family (and the\nphilosophy it represents) that the present paper focuses.\
    \  Needless\nto say, other important resource sharing tools have also been\nconstructed\
    \ within the ARPANET.  The Resource Sharing Executive\n(RSEXEC), designed and\
    \ implemented by Bolt, Beranek and Newman, Inc\n[7], provides an excellent example\
    \ of such work.                     2a3\nExperience with and Limitations of Hands-On\
    \ Resource Sharing          2b\n   The oldest and still by far the most heavily\
    \ used\nfunction-oriented protocol is the Telecommunications Network\nprotocol\
    \ (TELNET) [8], which effectively attaches a terminal on one\ncomputer to an interactive\
    \ time-sharing system on another, and\nallows a user to interact with the remote\
    \ system via the terminal as\nif he were one of its local users.             \
    \                      2b1\n                                  -2-\fNWG/RFC# 707\
    \                                  JEW 14-JAN-76 19:51  34263\nNCC 76        \
    \ A High-Level Framework for Network-Based Resource Sharing\n                \
    \       The Current Software Approach to Resource Sharing\n   As depicted in Figure\
    \ 1, TELNET specifies the means by which a\nuser process monitoring the user's\
    \ terminal is interconnected, via\nan IPC communication channel, with a server\
    \ process with access to\nthe target time-sharing system.  TELNET also legislates\
    \ a standard\ncharacter set in which the user's commands and the system's\nresponses\
    \ are to be represented in transmission between machines.\nThe syntax and semantics\
    \ of these interchanges, however, vary from\none system to another and are unregulated\
    \ by the protocol; the user\nand server processes simply shuttle characters between\
    \ the human\nuser and the target system.                                     \
    \     2b2\n   Although the hands-on use of remote resources that TELNET makes\n\
    possible is a natural and highly visible form of resource sharing,\nseveral limitations\
    \ severely reduce its long-term utility:           2b3\n   (1) It forces upon\
    \ the user all of the trappings of the\n       resource's own system.\n      \
    \   To exploit a remote resource, the user must leave the\n      familiar working\
    \ environment provided by his local system and\n      enter an alien one with\
    \ its own peculiar system structure\n      (login, logout, and subsystem entry\
    \ and exit procedures) and\n      command language discipline (command recognition\
    \ and\n      completion conventions, editing characters, and so on).\n      Hands-on\
    \ resource sharing thus fails to provide the user with\n      the kind of organized\
    \ and consistent workshop he requires to\n      work effectively [9].\n   (2)\
    \ It provides no basis for bootstrapping new composite\n       resources from\
    \ existing ones.\n         Because the network access discipline imposed by each\n\
    \      resource is a human-engineered command language, rather than a\n      machine-oriented\
    \ communication protocol, it is virtually\n      impossible for one resource to\
    \ programatically draw upon the\n      services of others.  Doing so would require\
    \ that the program\n      deal successfully with complicated echoing and feedback\n\
    \      characteristics; unstructured, even unsolicited system\n      responses;\
    \ and so forth.  Hands-on resource sharing thus does\n      nothing to provide\
    \ an environment in which existing resources\n      can be used as building blocks\
    \ to construct new, more powerful\n      ones.\n   These inherent limitations\
    \ of hands-on resource sharing are\nremoved by a protocol that simplifies and\
    \ standardizes the dialog\nbetween user and server processes.  Given such a protocol,\
    \ the\n                                  -3-\fNWG/RFC# 707                   \
    \               JEW 14-JAN-76 19:51  34263\nNCC 76         A High-Level Framework\
    \ for Network-Based Resource Sharing\n                       The Current Software\
    \ Approach to Resource Sharing\nvarious remote resources upon which a user might\
    \ wish to draw can\nindeed be made to appear as a single, coherent workshop by\n\
    interposing between him and them a command language interpreter that\ntransforms\
    \ his commands into the appropriate protocol utterances\n[10, 11].  The construction\
    \ of composite resources also becomes\nfeasible, since each resource is accessible\
    \ by means of a\nmachine-oriented protocol and can thus be readily employed by\
    \ other\nprocesses within the network.                                       \
    \ 2b4\nStandardizing the Inter-Machine Dialog in Specific Application Areas  2c\n\
    \   After the TELNET protocol had been designed and widely\nimplemented within\
    \ the ARPANET, work began on a family of\nfunction-oriented protocols designed\
    \ for use by programs, rather\nthan human users.  Each such protocol standardizes\
    \ the inter-machine\ndialog in a particular application area.  While TELNET dictates\
    \ only\nthe manner in which user and server processes are interconnected via\n\
    the IPC facility, and the character set in which the two processes\ncommunicate\
    \ once connected, each member of this family specifies in\naddition the syntax\
    \ and semantics of the commands and responses that\ncomprise their dialog.   \
    \                                            2c1\n   Protocols within this family\
    \ necessarily differ in substance,\neach specifying its own application-specific\
    \ command set.  The File\nTransfer Protocol (FTP) [12], for example, specifies\
    \ commands for\nmanipulating files, and the Remote Job Entry Protocol (RJE) [13]\n\
    specifies commands for manipulating batch jobs.  Protocols\nthroughout the family\
    \ are, however, similar in form, each successive\nfamily member having simply\
    \ inherited the physical features of its\npredecessors.  Thus FTP and RJE enforce\
    \ the same conventions for\nformulating commands and responses.              \
    \                    2c2\n   This common command/response discipline requires\
    \ that commands\nand responses have the following respective formats:        \
    \         2c3\n   command-name    <SP> parameter <CRLF>\n   response-number <SP>\
    \ text      <CRLF>\nEach command invoked by the user process is identified by\
    \ NAME and\nis allowed a single PARAMETER.  Each response generated by the\nserver\
    \ process contains a three-digit decimal response NUMBER (to be\ninterpreted by\
    \ the user process) and explanatory TEXT (for\npresentation, if necessary, to\
    \ the user).  Response numbers are\nassigned in such a way that, for example,\
    \ positive and negative\nacknowledgments can be easily distinguished by the user\
    \ process.     2c4\n                                  -4-\fNWG/RFC# 707      \
    \                            JEW 14-JAN-76 19:51  34263\nNCC 76         A High-Level\
    \ Framework for Network-Based Resource Sharing\n                       The Current\
    \ Software Approach to Resource Sharing\n   FTP contains, among others, the following\
    \ commands (each listed\nwith one of its possible responses) for retrieving, appending\
    \ to,\nreplacing, and deleting files, respectively, within the server\nprocess'\
    \ file system:                                                2c5\n   Command\
    \                    Response\n   RETR <SP> filename <CRLF>  250 <SP> Beginning\
    \ transfer. <CRLF>\n   APPE <SP> filename <CRLF>  400 <SP> Not implemented.  \
    \  <CRLF>\n   STOR <SP> filename <CRLF>  453 <SP> Directory overflow. <CRLF>\n\
    \   DELE <SP> filename <CRLF>  450 <SP> File not found.     <CRLF>\nThe first\
    \ three commands serve only to initiate the transfer of a\nfile from one machine\
    \ to another.  The transfer itself occurs on a\nseparate IPC channel and is governed\
    \ by what amounts to a separate\nprotocol.                                   \
    \                         2c6\n   Since the general command format admits but\
    \ a single parameter,\nmultiparameter operations must be implemented as sequences\
    \ of\ncommands.  Thus two commands are required to rename a file:          2c7\n\
    \   Command                    Response\n   RNFR <SP> oldname  <CRLF>  200 <SP>\
    \ Next parameter.     <CRLF>\n   RNTO <SP> newname  <CRLF>  253 <SP> File renamed.\
    \       <CRLF>\n                                  -5-\fNWG/RFC# 707          \
    \                        JEW 14-JAN-76 19:51  34263\nNCC 76         A High-Level\
    \ Framework for Network-Based Resource Sharing\n      A Command/Response Protocol,\
    \ the Basis for an Alternative Approach\nA COMMAND/RESPONSE PROTOCOL, THE BASIS\
    \ FOR AN ALTERNATIVE APPROACH     3\nThe Importance of Factoring Out the Command/Response\
    \ Discipline       3a\n   That FTP, RJE, and the other protocols within this family\
    \ share a\ncommon command/response discipline is a fact not formally recognized\n\
    within the protocol literature, and each new protocol document\ndescribes it in\
    \ detail, as if for the first time.  Nowhere are these\nconventions codified in\
    \ isolation from the various contexts in which\nthey find use, being viewed as\
    \ a necessary but relatively\nunimportant facet of each function-oriented protocol.\
    \  \"This common\ncommand/response discipline has thus gone unrecognized as the\n\
    important, application-independent protocol that it is.\"             3a1\n  \
    \ This oversight has had two important negative effects upon the\ngrowth of resource\
    \ sharing within the ARPANET:                       3a2\n   (1) It has allowed\
    \ the command/response discipline to remain\n       crude.\n         As already\
    \ noted, operations that require more than a\n      single parameter are consistently\
    \ implemented as two or more\n      separate commands, each of which requires\
    \ a response and thus\n      incurs the overhead of a full round-trip network\
    \ delay.\n      Furthermore, there are no standards for encoding parameter\n \
    \     types other than character strings, nor is there provision for\n      returning\
    \ results in a command response.\n   (2) It has placed upon the applications programmer\
    \ the burden of\n       implementing the network \"run-time environment (RTE)\"\
    \ that\n       enables him to access remote processes at the desired,\n      \
    \ functional level.\n         Before he can address remote processes in terms\
    \ like the\n      following:\n         execute function DELE with argument TEXTFILE\n\
    \            on machine X\n      the applications programmer must first construct\
    \ (as he\n      invariably does in every program he writes) a module that\n  \
    \    provides the desired program interface while implementing the\n      agreed\
    \ upon command/response discipline.  This run-time\n      environment contains\
    \ the code required to properly format\n      outgoing commands, to interface\
    \ with the IPC facility, and to\n      parse incoming responses.  Because the\
    \ system provides only\n                                  -6-\fNWG/RFC# 707  \
    \                                JEW 14-JAN-76 19:51  34263\nNCC 76         A\
    \ High-Level Framework for Network-Based Resource Sharing\n      A Command/Response\
    \ Protocol, the Basis for an Alternative Approach\n      the IPC facility as a\
    \ foundation, the applications programmer\n      is deterred from using remote\
    \ resources by the amount of\n      specialized knowledge and software that must\
    \ first be\n      acquired.\n         If, on the other hand, the command/response\
    \ discipline were\n      formalized as a separate protocol, its use in subsequent\n\
    \      function-oriented protocols could rightly be anticipated by\n      the\
    \ systems programmer, and a single run-time environment\n      constructed for\
    \ use throughout an installation (in the worst\n      case, one implementation\
    \ per programming language per machine\n      might be required).  This module\
    \ could then be placed in a\n      library and, as depicted in Figure 2, link\
    \ loaded with (or\n      otherwise made available to) each new applications program,\n\
    \      thereby greatly simplifying its use of remote resources.\n         Furthermore,\
    \ since enhancements to it would pay dividends\n      to every applications program\
    \ employing its services, the\n      run-time environment would gradually be augmented\
    \ to provide\n      additional new services to the programmer.\n   The thesis\
    \ of the present paper is that one of the keys to\nfacilitating network resource\
    \ sharing lies in (1) isolating as a\nseparate protocol the command/response discipline\
    \ common to a large\nclass of applications protocols; (2) making this new,\napplication-independent\
    \ protocol flexible and efficient; and (3)\nconstructing at each installation\
    \ a RTE that employs it to give the\napplications programmer easy and high-level\
    \ access to remote\nresources.                                               \
    \            3a3\nSpecifications for the Command/Response Protocol           \
    \           3b\n   Having argued the value of a command/response protocol (hereafter\n\
    termed the Protocol) as the foundation for a large class of\napplications protocols,\
    \ there remains the task of suggesting the\nform that the Protocol might take.\
    \  There are eight requirements.\nFirst, it must reproduce the capabilities of\
    \ the discipline it\nreplaces:                                               \
    \             3b1\n   (1) Permit invocation of arbitrary, named commands (or functions)\n\
    \       implemented by the remote process.\n   (2) Permit command outcomes to\
    \ be reported in a way that aids\n       both the program invoking the commmand\
    \ and the user under\n       whose control it may be executing.\n            \
    \                      -7-\fNWG/RFC# 707                                  JEW\
    \ 14-JAN-76 19:51  34263\nNCC 76         A High-Level Framework for Network-Based\
    \ Resource Sharing\n      A Command/Response Protocol, the Basis for an Alternative\
    \ Approach\nSecond, the Protocol should remove the known deficiencies of its\n\
    predecessor, that is:                                                3b2\n   (3)\
    \ Allow an arbitrary number of parameters to be supplied as\n       arguments\
    \ to a single command.\n   (4) Provide representations for a variety of parameter\
    \ types,\n       including but not limited to character strings.\n   (5) Permit\
    \ commands to return parameters as results as well as\n       accept them as arguments.\n\
    And, finally, the Protocol should provide whatever additional\ncapabilities are\
    \ required by the more complex distributed systems\nwhose creation the Protocol\
    \ seeks to encourage.  Although others may\nlater be identified, the three capabilities\
    \ below are recognized now\nto be important:                                 \
    \                    3b3\n   (6) Permit the server process to invoke commands\
    \ in the user\n       process, that is, eliminate entirely the often inappropriate\n\
    \       user/server distinction, and allow each process to invoke\n       commands\
    \ in the other.\n         In the workshop environment alluded to earlier, for\n\
    \      example, the user process is the command language interpreter\n      and\
    \ the server process is any of the software tools available\n      to the user.\
    \  While most commands are issued by the\n      interpreter and addressed to the\
    \ tool, occasionally the tool\n      must invoke commands in the interpreter or\
    \ in another tool.  A\n      graphical text editor, for example, must invoke commands\n\
    \      within the interpreter to update the user's display screen\n      after\
    \ an editing operation.\n   (7) Permit a process to accept two or more commands\
    \ for\n      concurrrent execution.\n         The text editor may wish to permit\
    \ the user to initiate a\n      long formatting operation with one command and\
    \ yet continue to\n      issue additional, shorter commands before there is a\
    \ response\n      to the first.\n   (8) Allow the process issuing a command to\
    \ suppress the response\n       the command would otherwise elicit.\n        \
    \ This feature would permit network traffic to be reduced in\n      those cases\
    \ in which the process invoking the command deems a\n                        \
    \          -8-\fNWG/RFC# 707                                  JEW 14-JAN-76 19:51\
    \  34263\nNCC 76         A High-Level Framework for Network-Based Resource Sharing\n\
    \      A Command/Response Protocol, the Basis for an Alternative Approach\n  \
    \    response unnecessary.  Commands that always succeed but never\n      return\
    \ results are obvious candidates for this kind of\n      treatment.\nA Formulation\
    \ of the Protocol That Meets These Specifications         3c\n   The eight requirements\
    \ listed above are met by a protocol in\nwhich the following two messages are\
    \ defined:                        3c1\n   message-type=COMMAND  [tid] command-name\
    \ arguments\n   message-type=RESPONSE  tid  outcome      results\nHere and in\
    \ subsequent protocol descriptions, elements enclosed in\nsquare brackets are\
    \ optional.                                        3c2\n   The first message invokes\
    \ the command whose NAME is specified\nusing the ARGUMENTS provided.  The second\
    \ is issued in eventual\nresponse to the first and returns the OUTCOME and RESULTS\
    \ of the\ncompleted command.  Whenever OUTCOME indicates that a command has\n\
    failed, the command's RESULTS are required to be an error number and\ndiagnostic\
    \ message, the former to help the invoking program\ndetermine what to do next,\
    \ the latter for possible presentation to\nthe user.  The protocol thus provides\
    \ a framework for reporting\nerrors, while leaving to the applications program\
    \ the tasks of\nassigning error numbers and composing the text of error messages.\
    \    3c3\n   There are several elements of the Protocol that are absent from\n\
    the existing command/response discipline:                            3c4\n   (1)\
    \ RESULTS, in fulfillment of Requirement 5.\n   (2) A MESSAGE TYPE that distinguishes\
    \ commands from responses,\n       arising from Requirement 6.\n         In the\
    \ existing discipline, this distinction is implicit,\n      since user and server\
    \ processes receive only responses and\n      commands, respectively.\n   (3)\
    \ An optional transaction identifier TID by which a command and\n       its response\
    \ are associated, arising from Requirements 7 and\n       8.\n         The presence\
    \ of a transaction identifier in a command\n      implies the necessity of a response\
    \ echoing the identifier;\n      and no two concurrently outstanding commands\
    \ may bear the same\n      identifier.\n                                  -9-\f\
    NWG/RFC# 707                                  JEW 14-JAN-76 19:51  34263\nNCC\
    \ 76         A High-Level Framework for Network-Based Resource Sharing\n     \
    \ A Command/Response Protocol, the Basis for an Alternative Approach\n   Requirements\
    \ 3 and 4--the ability to transmit an arbitrary number\nof parameters of various\
    \ types with each command or response--are\nmost economically and effectively\
    \ met by defining a small set of\nprimitive \"data types\" (for example, booleans,\
    \ integers, character\nstrings) from which concrete parameters can be modeled,\
    \ and a\n\"transmission format\" in which such parameters can be encoded.\nAppendix\
    \ A suggests a set of data types suitable for a large class\nof applications;\
    \ Appendix B defines some possible transmission\nformats.                    \
    \                                         3c5\n   The protocol description given\
    \ above is, of course, purely\nsymbolic.  Appendix C explores one possible encoding\
    \ of the Protocol\nin detail.                                                \
    \           3c6\nSummarizing the Arguments Advanced So Far                   \
    \          3d\n   The author trusts that little of what has been presented thus\
    \ far\nwill be considered controversial by the reader.  The following\nprincipal\
    \ arguments have been made:                                  3d1\n   (1) The more\
    \ effective forms of resource sharing depend upon\n       remote resources being\
    \ usefully accessible to other programs,\n       not just to human users.\n  \
    \ (2) Application-dependent protocols providing such access using\n       the\
    \ current approach leave to the applications programmer the\n       task of constructing\
    \ the additional layer of software (above\n       the IPC facility provided by\
    \ the system) required to make\n       remote resources accessible at the functional\
    \ level, thus\n       discouraging their use.\n   (3) A single, resource-independent\
    \ protocol providing flexible\n       and efficient access at the functional level\
    \ to arbitrary\n       remote resources can be devised.\n   (4) This protocol\
    \ would make possible the construction at each\n       installation of an application-independent,\
    \ network run-time\n       environment making remote resources accessible at the\n\
    \       functional level and thus encouraging their use by the\n       applications\
    \ programmer.\n   A protocol as simple as that suggested here has great potential\n\
    for stimulating the sharing of resources within a computer network.\nFirst, it\
    \ would reduce the cost of adapting existing resources for\nnetwork use by eliminating\
    \ the need for the design, documentation,\nand implementation of specialized delivery\
    \ protocols.  Second, it\n                                  -10-\fNWG/RFC# 707\
    \                                  JEW 14-JAN-76 19:51  34263\nNCC 76        \
    \ A High-Level Framework for Network-Based Resource Sharing\n      A Command/Response\
    \ Protocol, the Basis for an Alternative Approach\nwould encourage the use of\
    \ remote resources by eliminating the need\nfor application-specific interface\
    \ software.  And finally, it would\nencourage the construction of new resources\
    \ built expressly for\nremote access, because of the ease with which they could\
    \ be offered\nand used within the network software marketplace.              \
    \      3d2\n                                  -11-\fNWG/RFC# 707             \
    \                     JEW 14-JAN-76 19:51  34263\nNCC 76         A High-Level\
    \ Framework for Network-Based Resource Sharing\n                           A High-Level\
    \ Model of the Network Environment\nA HIGH-LEVEL MODEL OF THE NETWORK ENVIRONMENT\
    \                          4\nThe Importance of the Model Imposed by the Protocol\
    \                   4a\n   The Protocol proposed above imposes upon the applications\n\
    programmer a particular model of the network environment.  In a\nheterogeneous\
    \ computer network, nearly every protocol intended for\ngeneral implementation\
    \ has this effect, since it idealizes a class\nof operations that have concrete\
    \ but slightly different equivalents\nin each system.  Thus the ARPANET's TELNET\
    \ Protocol alluded to\nearlier, for example, specifies a Network Virtual Terminal\
    \ that\nattempts to provide a best fit to the many real terminals in use\naround\
    \ the Network.                                                  4a1\n   As now\
    \ formulated, the Protocol models a remote resource as an\ninteractive program\
    \ with a simple, rigidly specified command\nlanguage.  This model follows naturally\
    \ from the fact that the\nfunction-oriented protocols from which the Protocol\
    \ was extracted\nwere necessitated by the complexity and diversity of user-oriented\n\
    command languages.  The Protocol may thus legitimately be viewed as\na vehicle\
    \ for providing, as an adjunct to the sophisticated command\nlanguages already\
    \ available to users, a family of simple command\nlanguages that can readily be\
    \ employed by programs.                  4a2\n   While the command/response model\
    \ is a natural one, others are\npossible.  A remote resource might also be modeled\
    \ as a process that\nservices and replies to requests it receives from other computer\n\
    processes.  This request/reply model would emphasize the fact that\nthe Protocol\
    \ is a vehicle for inter-process communication and that\nno human user is directly\
    \ involved.                                  4a3\n   Substituting the request/reply\
    \ model for the command/response\nmodel requires only cosmetic changes to the\
    \ Protocol:                4a4\n   message-type=REQUEST [tid] op-code arguments\n\
    \   message-type=REPLY    tid  outcome results\nIn the formulation above, the\
    \ terms \"REQUEST\", \"REPLY\", and\n\"op-code\" have simply been substituted\
    \ for \"COMMAND\", \"RESPONSE\",\nand \"command-name\", respectively.        \
    \                            4a5\n   The choice of model need affect neither the\
    \ content of the\nProtocol nor the behavior of the processes whose dialog it governs.\n\
    Use of the word \"command\" in the command/response model, for\nexample, is not\
    \ meant to imply that the remote process can be\ncoerced into action.  Whatever\
    \ model is adopted, a process has\n                                  -12-\fNWG/RFC#\
    \ 707                                  JEW 14-JAN-76 19:51  34263\nNCC 76    \
    \     A High-Level Framework for Network-Based Resource Sharing\n            \
    \               A High-Level Model of the Network Environment\ncomplete freedom\
    \ to reject an incoming remote request that it is\nincapable of or unwilling to\
    \ fulfill.                                4a6\n   But even though it has no substantive\
    \ effect upon the Protocol,\nthe selection of a model--command/response, request/reply,\
    \ and so\non--is an important task because it determines the way in which both\n\
    applications and systems programmers perceive the network\nenvironment.  If the\
    \ network environment is made to appear foreign\nto him, the applications programmer\
    \ may be discouraged from using\nit.  The choice of model also constrains the\
    \ kind and range of\nprotocol extensions that are likely to occur to the systems\n\
    programmer; one model may suggest a rich set of useful extensions,\nanother lead\
    \ nowhere (or worse still, in the wrong direction).       4a7\n   In this final\
    \ section of the paper, the author suggests a network\nmodel (hereafter termed\
    \ the Model) that he believes will both\nencourage the use of remote resources\
    \ by the applications programmer\nand suggest to the systems programmer a wide\
    \ variety of useful\nProtocol extensions.  Unlike the substance of the Protocol,\
    \ however,\nthe Model has already proven quite controversial within the ARPANET\n\
    community.                                                           4a8\nModeling\
    \ Resources As Collections of Procedures                       4b\n   Ideally,\
    \ the goal of both the Protocol and its accompanying RTE\nis to make remote resources\
    \ as easy to use as local ones.  Since\nlocal resources usually take the form\
    \ of resident and/or library\nsubroutines, the possibility of modeling remote\
    \ commands as\n\"procedures\" immediately suggests itself.  The Model is further\n\
    confirmed by the similarity that exists between local procedures and\nthe remote\
    \ commands to which the Protocol provides access.  Both\ncarry out arbitrarily\
    \ complex, named operations on behalf of the\nrequesting program (the caller);\
    \ are governed by arguments supplied\nby the caller; and return to it results\
    \ that reflect the outcome of\nthe operation.  The procedure call model thus acknowledges\
    \ that, in\na network environment, programs must sometimes call subroutines in\n\
    machines other than their own.                                       4b1\n   Like\
    \ the request/reply model already described, the procedure\ncall model requires\
    \ only cosmetic changes to the Protocol:           4b2\n   message-type=CALL \
    \  [tid] procedure-name arguments\n   message-type=RETURN  tid  outcome      \
    \  results\nIn this third formulation, the terms \"CALL\", \"RETURN\", and\n\"\
    procedure-name\" have been substituted for \"COMMAND, \"RESPONSE\", and\n    \
    \                              -13-\fNWG/RFC# 707                            \
    \      JEW 14-JAN-76 19:51  34263\nNCC 76         A High-Level Framework for Network-Based\
    \ Resource Sharing\n                           A High-Level Model of the Network\
    \ Environment\n\"command-name\", respectively.  And in this form, the Protocol\
    \ might\naptly be designated a \"procedure call protocol (PCP)\".            \
    \   4b3\n   \"The procedure call model would elevate the task of creating\napplications\
    \ protocols to that of defining procedures and their\ncalling sequences.  It would\
    \ also provide the foundation for a true\ndistributed programming system (DPS)\
    \ that encourages and facilitates\nthe work of the applications programmer by\
    \ gracefully extending the\nlocal programming environment, via the RTE, to embrace\
    \ modules on\nother machines.\"  This integration of local and network programming\n\
    environments can even be carried as far as modifying compilers to\nprovide minor\
    \ variants of their normal procedure-calling constructs\nfor addressing remote\
    \ procedures (for which calls to the appropriate\nRTE primitives would be dropped\
    \ out).                                4b4\n   Finally, the Model is one that\
    \ can be naturally extended in a\nvariety of ways (for example, coroutine linkages\
    \ and signals) to\nfurther enhance the distributed programming environment.  \
    \           4b5\nClarifying the Procedure Call Model                         \
    \          4c\n   Although in many ways it accurately portrays the class of network\n\
    interactions with which this paper deals, the Model suggested above\nmay in other\
    \ respects tend to mislead the applications programmer.\nThe Model must therefore\
    \ be clarified:                               4c1\n   (1) Local procedure calls\
    \ are cheap; remote procedure calls are\n       not.\n         Local procedure\
    \ calls are often effected by means of a\n      single machine instruction and\
    \ are therefore relatively\n      inexpensive.  Remote procedure calls, on the\
    \ other hand, would\n      be effected by means of a primitive provided by the\
    \ local RTE\n      and require an exchange of messages via IPC.\n         Because\
    \ of this cost differential, the applications\n      programmer must exercise\
    \ discretion in his use of remote\n      resources, even though the mechanics\
    \ of their use will have\n      been greatly simplified by the RTE.  Like virtual\
    \ memory, the\n      procedure call model offers great convenience, and therefore\n\
    \      power, in exchange for reasonable alertness to the\n      possibilities\
    \ of abuse.\n   (2) Conventional programs usually have a single locus of control;\n\
    \       distributed programs need not.\n                                  -14-\f\
    NWG/RFC# 707                                  JEW 14-JAN-76 19:51  34263\nNCC\
    \ 76         A High-Level Framework for Network-Based Resource Sharing\n     \
    \                      A High-Level Model of the Network Environment\n       \
    \  Conventional programs are usually implemented as a single\n      process with\
    \ exactly one locus of control.  A procedure call,\n      therefore, traditionally\
    \ implies a transfer of control from\n      caller to callee.  Distributed systems,\
    \ on the other hand, are\n      implemented as two or more processes, each of\
    \ which is capable\n      of independent execution.  In this new environment,\
    \ a remote\n      procedure call need not suspend the caller, which is capable\n\
    \      of continuing execution in parallel with the called procedure.\n      \
    \   The RTE can therefore be expected to provide, for\n      convenience, two\
    \ modes of remote procedure invocation:  a\n      blocking mode that suspends\
    \ the caller until the procedure\n      returns; and a non-blocking mode that\
    \ releases the caller as\n      soon as the CALL message has been sent or queued.\
    \  Most\n      conventional operating systems already provide such a mode\n  \
    \    choice for I/O operations.  For non-blocking calls, the RTE\n      must also,\
    \ of course, either arrange to asynchronously notify\n      the program when the\
    \ call is complete, or provide an\n      additional primitive by which the applications\
    \ program can\n      periodically test for that condition.\n   Finally, the applications\
    \ programmer must recognize that by no\nmeans all useful forms of network communication\
    \ are effectively\nmodeled as procedure calls.  The lower level IPC facility that\n\
    remains directly accessible to him must therefore be employed in\nthose applications\
    \ for which the procedure call model is\ninappropriate and RTE-provided primitives\
    \ simply will not do.        4c2\n                                  -15-\fNWG/RFC#\
    \ 707                                  JEW 14-JAN-76 19:51  34263\nNCC 76    \
    \     A High-Level Framework for Network-Based Resource Sharing\n            \
    \                                           Some Expectations\nSOME EXPECTATIONS\
    \                                                      5\n   Both the Procedure\
    \ Call Protocol and its associated Run-Time\nEnvironment have great potential\
    \ for facilitating the work of the\nnetwork programmer; only a small percentage\
    \ of that potential has\nbeen discussed in the present paper.  Upon the foundation\
    \ provided\nby PCP can be erected higher level application-independent protocol\n\
    layers that further enhance the distributed programming environment\nby providing\
    \ even more powerful capabilities (see Appendix D).        5a\n   As the importance\
    \ of the RTE becomes fully evident, additional\ntasks will gradually be assigned\
    \ to it, including perhaps those of:   5b\n   (1) Converting parameters between\
    \ the format employed internally\n       by the applications program, and that\
    \ imposed by the\n       Protocol.                                           \
    \          5b1\n   (2) Automatically selecting the most appropriate inter-process\n\
    \       transmission format on the basis of the two machines' word\n       sizes.\
    \                                                        5b2\n   (3) Automatically\
    \ substituting for network IPC a more efficient\n       form of communication\
    \ when both processes reside on the same\n       machine.                    \
    \                                  5b3\nThe RTE will eventually offer the programmer\
    \ a wide variety of\napplication-independent, network-programming conveniences,\
    \ and so,\nby means of the Protocol, become an increasingly powerful\ndistributed-system-building\
    \ tool.                                     5c\n                             \
    \     -16-\fNWG/RFC# 707                                  JEW 14-JAN-76 19:51\
    \  34263\nNCC 76         A High-Level Framework for Network-Based Resource Sharing\n\
    \                                                         Acknowledgments\nACKNOWLEDGMENTS\
    \                                                        6\n   Many individuals\
    \ within both SRI's Augmentation Research Center\n(ARC) and the larger ARPANET\
    \ community have contributed their time\nand ideas to the development of the Protocol\
    \ and Model described in\nthis paper.  The contributions of the following individuals\
    \ are\nexpressly acknowledged:  Dick Watson, Jon Postel, Charles Irby, Ken\nVictor,\
    \ Dave Maynard, and Larry Garlick of ARC; and Bob Thomas and\nRick Schantz of\
    \ Bolt, Beranek and Newman, Inc.                        6a\n   ARC has been working\
    \ toward a high-level framework for\nnetwork-based distributed systems for a number\
    \ of years now [14].\nThe particular Protocol and Model described here result\
    \ from\nresearch begun by ARC in July of 1974.  This research included\ndeveloping\
    \ the Model; designing and documenting the Protocol\nrequired to support it [15];\
    \ and designing, documenting, and\nimplementing a prototype run-time environment\
    \ for a particular\nmachine [16, 17], specifically a PDP-10 running the Tenex\
    \ operating\nsystem developed by Bolt, Beranek and Newman, Inc [18].  Three\n\
    design iterations were carried out during a 12-month period, and the\nresulting\
    \ specification implemented for Tenex.  The Tenex RTE\nprovides a superset of\
    \ the capabilities presented in the body of\nthis paper and Appendices A through\
    \ C as well as those alluded to in\nAppendix D.                              \
    \                             6b\n   The work reported here was supported by the\
    \ Advanced Research\nProjects Agency of the Department of Defense, and by the\
    \ Rome Air\nDevelopment Center of the Air Force.                             \
    \     6c\n                                  -17-\fNWG/RFC# 707               \
    \                   JEW 14-JAN-76 19:51  34263\nNCC 76         A High-Level Framework\
    \ for Network-Based Resource Sharing\n                                       Appendix\
    \ A:  Suggested Data Types\nAPPENDIX A:  SUGGESTED DATA TYPES                \
    \                      7\n   The Protocol requires that every parameter or \"\
    data object\" be\nrepresented by one of several primitive data types defined by\
    \ the\nModel.  The set of data types below is sufficient to conveniently\nmodel\
    \ a large class of data objects, but since the need for\nadditional data types\
    \ (for example, floating-point numbers) will\nsurely arise, the set must remain\
    \ open-ended.  Throughout the\ndescriptions below, N is confined to the range\
    \ [0, 2**15-1]:          7a\n      LIST:  A list is an ordered sequence of N data\
    \ objects called\n   \"elements\".  A LIST may contain other LISTs as elements,\
    \ and can\n   therefore be employed to construct arbitrarily complex composite\n\
    \   data objects.                                                     7a1\n  \
    \    CHARSTR:  A character string is an ordered sequence of N ASCII\n   characters,\
    \ and conveniently models a variety of textual\n   entities, from short user names\
    \ to whole paragraphs of text.      7a2\n      BITSTR:  A bit string is an ordered\
    \ sequence of N bits and,\n   therefore, provides a means for representing arbitrary\
    \ binary\n   data (for example, the contents of a word of memory).           \
    \  7a3\n      INTEGER:  An integer is a fixed-point number in the range\n   [-2**31,\
    \ 2**31-1], and conveniently models various kinds of\n   numerical data, including\
    \ time intervals, distances, and so on.   7a4\n      INDEX:  An index is an integer\
    \ in the range [1, 2**15-1].  As\n   its name and value range suggest, an INDEX\
    \ can be used to address\n   a particular bit or character within a string, or\
    \ element within\n   a list.  INDEXes have other uses as well, including the modeling\n\
    \   of handles or identifiers for open files, created processes, and\n   the like.\
    \  Also, because of their restricted range, INDEXes are\n   more compact in transmission\
    \ than INTEGERs (see Appendix B).      7a5\n      BOOLEAN:  A boolean represents\
    \ a single bit of information,\n   and has either the value true or false.   \
    \                        7a6\n      EMPTY:  An empty is a valueless place holder\
    \ within a LIST or\n   parameter list.                                       \
    \            7a7\n                                  -18-\fNWG/RFC# 707       \
    \                           JEW 14-JAN-76 19:51  34263\nNCC 76         A High-Level\
    \ Framework for Network-Based Resource Sharing\n                             Appendix\
    \ B:  Suggested Transmission Formats\nAPPENDIX B:  SUGGESTED TRANSMISSION FORMATS\
    \                            8\n   Parameters must be encoded in a standard transmission\
    \ format\nbefore they can be sent from one process to another via the\nProtocol.\
    \  An effective strategy is to define several formats and\nselect the most appropriate\
    \ one at run-time, adding to the Protocol\na mechanism for format negotiation.\
    \  Format negotiation would be\nanother responsibility of the RTE and could thus\
    \ be made completely\ninvisible to the applications program.                 \
    \               8a\n   Suggested below are two transmission formats.  The first\
    \ is a\n36-bit binary format for use between 36-bit machines, the second an\n\
    8-bit binary, \"universal\" format for use between dissimilar\nmachines.  Data\
    \ objects are fully typed in each format to enable the\nRTE to automatically decode\
    \ and internalize incoming parameters\nshould it be desired to provide this service\
    \ to the applications\nprogram.                                              \
    \                8b\nPCPB36, For Use Between 36-Bit Machines                 \
    \              8c\n   Bits  0-13 Unused (zero)                               \
    \           8c1\n   Bits 14-17 Data type                                     \
    \         8c2\n      EMPTY  =1  INTEGER=4  LIST=7\n      BOOLEAN=2  BITSTR =5\n\
    \      INDEX  =3  CHARSTR=6\n   Bits 18-20 Unused (zero)                     \
    \                     8c3\n   Bits 21-35 Value or length N                   \
    \                   8c4\n      EMPTY    unused (zero)\n      BOOLEAN  14 zero-bits\
    \ + 1-bit value (TRUE=1/FALSE=0)\n      INDEX    unsigned value\n      INTEGER\
    \  unused (zero)\n      BITSTR   unsigned bit count N\n      CHARSTR  unsigned\
    \ character count N\n      LIST     unsigned element count N\n   Bits 36-   Value\
    \                                                  8c5\n      EMPTY    unused\
    \ (nonexistent)\n      BOOLEAN  unused (nonexistent)\n      INDEX    unused (nonexistent)\n\
    \      INTEGER  two's complement full-word value\n      BITSTR   bit string +\
    \ zero padding to word boundary\n      CHARSTR  ASCII string + zero padding to\
    \ word boundary\n      LIST     element data objects\n                       \
    \           -19-\fNWG/RFC# 707                                  JEW 14-JAN-76\
    \ 19:51  34263\nNCC 76         A High-Level Framework for Network-Based Resource\
    \ Sharing\n                             Appendix B:  Suggested Transmission Formats\n\
    PCPB8, For Use Between Dissimilar Machines                            8d\n   Byte\
    \    0  Data type                                              8d1\n      EMPTY\
    \  =1  INTEGER=4  LIST=7\n      BOOLEAN=2  BITSTR =5\n      INDEX  =3  CHARSTR=6\n\
    \   Bytes 1-   Value                                                  8d2\n  \
    \    EMPTY     unused (nonexistent)\n      BOOLEAN   7 zero-bits + 1-bit value\
    \ (TRUE=1/FALSE=0)\n      INDEX     2-byte unsigned value\n      INTEGER   4-byte\
    \ two's complement value\n      BITSTR    2-byte unsigned bit count N + bit string\n\
    \                 + zero padding to byte boundary\n      CHARSTR   2-byte unsigned\
    \ character count N + ASCII string\n      LIST      2-byte element count N + element\
    \ data objects\n                                  -20-\fNWG/RFC# 707         \
    \                         JEW 14-JAN-76 19:51  34263\nNCC 76         A High-Level\
    \ Framework for Network-Based Resource Sharing\n         Appendix C:  A Detailed\
    \ Encoding of the Procedure Call Protocol\nAPPENDIX C:  A DETAILED ENCODING OF\
    \ THE PROCEDURE CALL PROTOCOL        9\n   Although the data types and transmission\
    \ formats detailed in the\nprevious appendixes serve primarily as vehicles for\
    \ representing the\narguments and results of remote procedures, they can just\
    \ as readily\nand effectively be employed to represent the commands and responses\n\
    by which those parameters are transmitted.                            9a\n   Taking\
    \ this approach, one might model each of the two Protocol\nmessages as a PCP data\
    \ object, specifically a LIST whose first\nelement is an INDEX message type. \
    \ The following concise statement\nof the Protocol then results:             \
    \                            9b\n   LIST (CALL,   tid,        procedure, arguments)\n\
    \         INDEX=1 INDEX/EMPTY CHARSTR    LIST                         9b1\n  \
    \ LIST (RETURN, tid,        outcome,   results)\n         INDEX=2 INDEX      \
    \ BOOLEAN    LIST                         9b2\nThe RESULTS of an unsuccessful\
    \ procedure would be represented as\nfollows:                                \
    \                              9c\n   LIST (error, diagnostic)\n         INDEX\
    \  CHARSTR                                              9c1\n                \
    \                  -21-\fNWG/RFC# 707                                  JEW 14-JAN-76\
    \ 19:51  34263\nNCC 76         A High-Level Framework for Network-Based Resource\
    \ Sharing\n            Appendix D:  A Look at Some Possible Extensions to the\
    \ Model\nAPPENDIX D:  A LOOK AT SOME POSSIBLE EXTENSIONS TO THE MODEL        \
    \  10\n   The result of the distributed-system-building strategy proposed\nin\
    \ the body of this paper and the preceeding appendices is depicted\nin Figure\
    \ D-1.  At the core of each process is the inter-process\ncommunication facility\
    \ provided by the operating system, which\neffects the transmission of arbitrary\
    \ binary data between distant\nprocesses.  Surrounding this core are conventions\
    \ regarding first\nthe format in which a few, primitive types of data objects\
    \ are\nencoded in binary for IPC, and then the formats of several composite\n\
    data objects (that is, messages) whose transmission either invokes\nor acknowledges\
    \ the previous invocation of a remote procedure.\nImmediately above lies an open-ended\
    \ protocol layer in which an\narbitrary number of enhancements to the distributed\
    \ programming\nenvironment can be implemented.  Encapsulating these various\n\
    protocol layers is the installation-provided run-time environment,\nwhich delivers\
    \ DPS services to the applications program according to\nmachine- and possibly\
    \ programming-language-dependent conventions.    10a\n   The Protocol proposed\
    \ in the present paper recognizes only the\nmost fundamental aspects of remote\
    \ procedure calling.  It permits\nthe caller to identify the procedure to be called,\
    \ supply the\nnecessary arguments, determine the outcome of the procedure, and\n\
    recover its results.  In a second paper [19], the author proposes\nsome extensions\
    \ to this simple procedure call model, and attempts to\nidentify other common\
    \ forms of inter-process interaction whose\nstandardization would enhance the\
    \ distributed programming\nenvironment.  Included among the topics discussed are:\
    \               10b\n   (1) Coroutine linkages and other forms of communication\
    \ between\n       the caller and callee.                                     \
    \  10b1\n   (2) Propagation of notices and requests up the thread of control\n\
    \       that results from nested procedure calls.                    10b2\n  \
    \ (3) Standard mechanisms for remotely reading or writing\n       system-global\
    \ data objects within another program.           10b3\n   (4) Access controls\
    \ for collections of related procedures.       10b4\n   (5) A standard means for\
    \ creating and initializing processes,\n       that is, for establishing contact\
    \ with and logging into a\n       remote machine, identifying the program to be\
    \ executed, and\n       so forth.  This facility would permit arbitrarily complex\n\
    \       process hierarchies to be created.                           10b5\n  \
    \                                -22-\fNWG/RFC# 707                          \
    \        JEW 14-JAN-76 19:51  34263\nNCC 76         A High-Level Framework for\
    \ Network-Based Resource Sharing\n            Appendix D:  A Look at Some Possible\
    \ Extensions to the Model\n   (6) A mechanism for introducing processes to one\
    \ another, that\n       is, for superimposing more general communication paths\
    \ upon\n       the process hierarchy.                                       10b6\n\
    These and other extensions can all find a place in the open-ended\nprotocol layer\
    \ of Figure D-1.  The particular extensions explored in\n[19] are offered not\
    \ as dogma but rather as a means of suggesting\nthe possibilities and stimulating\
    \ further research.                  10c\n                                  -23-\f\
    NWG/RFC# 707                                  JEW 14-JAN-76 19:51  34263\nNCC\
    \ 76         A High-Level Framework for Network-Based Resource Sharing\n     \
    \                                                         References\nREFERENCES\
    \                                                            11\n 1. Kahn, R.\
    \ E., \"Resource-Sharing Computer Communications\n    Networks,\" Proceedings\
    \ of the IEEE, Vol. 60, No. 11, pp.\n    1397-1407, November 1972.           \
    \                             11a\n 2. Crocker, S. D., Heafner, J. F., Metcalfe,\
    \ R. M., Postel, J. B.,\n    \"Function-oriented Protocols for the ARPA Computer\
    \ Network,\"\n    AFIPS Proceedings, Spring Joint Computer Conference, Vol. 40,\n\
    \    pp. 271-279, 1972.                                               11b\n 3.\
    \ Carr, C. S., Crocker, S. D., Cerf, V. G., \"Host-Host\n    Communication Protocol\
    \ in the ARPA Network,\" AFIPS Proceedings,\n    Spring Joint Computer Conference,\
    \ Vol. 36, pp. 589-597, 1970.    11c\n 4. Mc Kenzie, A. A., Host/Host Protocol\
    \ for the ARPA Network, Bolt\n    Beranek and Newman Inc., Cambridge, Massachusetts,\
    \ January 1972\n    (SRI-ARC Catalog Item 8246).                             \
    \        11d\n 5. Walden, D. C., \"A System for Interprocess Communication in\
    \ a\n    Resource Sharing Computer Network,\" Communications of the ACM,\n   \
    \ Vol. 15, No. 4, pp. 221-230, April 1972.                         11e\n 6. Cerf,\
    \ V. G., Kahn, R. E., \"A Protocol for Packet Network\n    Intercommunication,\"\
    \ IEEE Transactions on Communications, Vol.\n    Com-22, No. 5, pp. 637-648, May\
    \ 1974.                            11f\n 7. Thomas, R. H., \"A Resource-Sharing\
    \ Executive for the ARPANET,\"\n    AFIPS Proceedings, National Computer Conference,\
    \ Vol. 42, pp.\n    155-163, 1973.                                           \
    \        11g\n 8. TELNET Protocol Specification, Stanford Research Institute,\n\
    \    Menlo Park, California, August 1973 (SRI-ARC Catalog Item\n    18639).  \
    \                                                        11h\n 9. Engelbart, D.\
    \ C., Watson, R. W., Norton, J. C., \"The Augmented\n    Knowledge Workshop,\"\
    \ AFIPS Proceedings, National Computer\n    Conference, Vol. 42, pp. 9-21, 1973.\
    \                             11i\n10. Engelbart, D. C., English, W. K., \"A Research\
    \ Center for\n    Augmenting Human Intellect,\" AFIPS Proceedings, Fall Joint\n\
    \    Computer Conference, Vol. 33, pp. 395-410, 1968.                 11j\n11.\
    \ Irby, C. H., Dornbush, C. F., Victor, K. E., Wallace, D. C., \"A\n    Command\
    \ Meta Language for NLS,\" Final Report, Contract\n                          \
    \        -24-\fNWG/RFC# 707                                  JEW 14-JAN-76 19:51\
    \  34263\nNCC 76         A High-Level Framework for Network-Based Resource Sharing\n\
    \                                                              References\n  \
    \  RADC-TR-75-304, SRI Project 1868, Stanford Research Institute,\n    Menlo Park,\
    \ California, December, 1975.                          11k\n12. Neigus, N. J.,\
    \ File Transfer Protocol, ARPA Network Working\n    Group Request for Comments\
    \ 542, Bolt Beranek and Newman Inc.,\n    Cambridge, Massachusetts, July 1973\
    \ (SRI-ARC Catalog Item\n    17759).                                         \
    \                 11l\n13. Bressler, R. D., Guida, R., Mc Kenzie, A. A., Remote\
    \ Job Entry\n    Protocol, ARPA Network Working Group Request for Comments 360,\n\
    \    Dynamic Modeling Group, Massachusetts Institute of Technology,\n    Cambridge,\
    \ Massachusetts, (undated) (SRI-ARC Catalog Item\n    12112).                \
    \                                          11m\n14. Watson, R. W., Some Thoughts\
    \ on System Design to Facilitate\n    Resource Sharing, ARPA Network Working Group\
    \ Request for\n    Comments 592, Augmentation Research Center, Stanford Research\n\
    \    Institute, Menlo Park, California, November 20, 1973 (SRI-ARC\n    Catalog\
    \ Item 20391).                                             11n\n15. White, J.\
    \ E., DPS-10 Version 2.5 Implementer's Guide,\n    Augmentation Research Center,\
    \ Stanford Research Institute, Menlo\n    Park, California, August 15, 1975 (SRI-ARC\
    \ Catalog Item 26282).  11o\n16. White, J. E., DPS-10 Version 2.5 Programmer's\
    \ Guide,\n    Augmentation Research Center, Stanford Research Institute, Menlo\n\
    \    Park, California, August 13, 1975 (SRI-ARC Catalog Item 26271).  11p\n17.\
    \ White, J. E., DPS-10 Version 2.5 Source Code, Augmentation\n    Research Center,\
    \ Stanford Research Institute, Menlo Park,\n    California, August 13, 1975 (SRI-ARC\
    \ Catalog Item 26267).        11q\n18. Bobrow, D. G., Burchfiel, J. D., Murphy,\
    \ D. L., Tomlinson, R.\n    S., \"TENEX, a Paged Time Sharing System for the PDP-10,\"\
    \n    Communications of the ACM, Vol. 15, No. 3, pp. 135-143, March\n    1972.\
    \                                                            11r\n19. White, J.\
    \ E., \"Elements of a Distributed Programming System,\"\n    Submitted for publication\
    \ in the Journal of Computer Languages,\n    1976.                           \
    \                                 11s\n                                  -25-\f\
    NWG/RFC# 707                                  JEW 14-JAN-76 19:51  34263\nNCC\
    \ 76         A High-Level Framework for Network-Based Resource Sharing\n     \
    \                                                        Figure List\nFIGURE LIST\
    \                                                           12\nFigure   1.  Interfacing\
    \ a remote terminal to a local time-sharing\n             system via the TELNET\
    \ Protocol.                         12a\nFigure   2.  Interfacing distant applications\
    \ programs via their\n             run-time environments.                    \
    \              12b\nFigure D-1.  Software and protocol layers comprising a process\n\
    \             within the distributed programming system.              12c\n  \
    \                                -26-\fNWG/RFC# 707                          \
    \        JEW 14-JAN-76 19:51  34263\n                                  -27-\f\
    NWG/RFC# 707                                  JEW 14-JAN-76 19:51  34263\n   \
    \  A High-Level Framework for Network-Based Resource Sharing\n               \
    \              23-DEC-75\n                           James E. White\n        \
    \            Augmentation Research Center\n                    Stanford Research\
    \ Institute\n                   Menlo Park, California  94025\n              \
    \          (415) 326-6200 x2960\n      This paper proposes a high-level, application-independent\n\
    \   protocol and software framework that would extend the local\n   programming\
    \ environment to embrace modules in other computers\n   within a resource sharing\
    \ computer network, and thereby\n   facilitate the construction of distributed\
    \ systems and encourage\n   the sharing of resources.\n      The work reported\
    \ here was supported by the Advanced Research\n   Projects Agency of the Department\
    \ of Defense, and by the Rome Air\n   Development Center of the Air Force.\n"
