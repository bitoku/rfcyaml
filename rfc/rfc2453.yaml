- title: __initial_text__
  contents:
  - '                             RIP Version 2

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1998).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies an extension of the Routing Information\n\
    \   Protocol (RIP), as defined in [1], to expand the amount of useful\n   information\
    \ carried in RIP messages and to add a measure of security.\n   A companion document\
    \ will define the SNMP MIB objects for RIP-2 [2].\n   An additional document will\
    \ define cryptographic security\n   improvements for RIP-2 [3].\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   I would like to thank the IETF RIP Working Group for their\
    \ help in\n   improving the RIP-2 protocol. Much of the text for the background\n\
    \   discussions about distance vector protocols and some of the\n   descriptions\
    \ of the operation of RIP were taken from \"Routing\n   Information Protocol\"\
    \ by C. Hedrick [1]. Some of the final editing on\n   the document was done by\
    \ Scott Bradner.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Justification  . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n   2.  Current RIP  . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  3\n   3.  Basic Protocol . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  3\n   3.1   Introduction   . . . . . . . . . . . . . . . . . . . .\
    \ . . .  3\n   3.2   Limitations of the Protocol  . . . . . . . . . . . . . .\
    \ . .  5\n   3.3.  Organization of this document  . . . . . . . . . . . . . .\
    \ .  6\n   3.4   Distance Vector Algorithms . . . . . . . . . . . . . . . . .\
    \  6\n   3.4.1    Dealing with changes in topology  . . . . . . . . . . . . 12\n\
    \   3.4.2    Preventing instability  . . . . . . . . . . . . . . . . . 13\n  \
    \ 3.4.3    Split horizon . . . . . . . . . . . . . . . . . . . . . . 15\n   3.4.4\
    \    Triggered updates . . . . . . . . . . . . . . . . . . . . 17\n   3.5   Protocol\
    \ Specification   . . . . . . . . . . . . . . . . . . 18\n   3.6   Message Format\
    \ . . . . . . . . . . . . . . . . . . . . . . . 20\n   3.7   Addressing Considerations\
    \  . . . . . . . . . . . . . . . . . 22\n   3.8   Timers . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . 24\n   3.9   Input Processing . . . . . . .\
    \ . . . . . . . . . . . . . . . 25\n   3.9.1    Request Messages  . . . . . .\
    \ . . . . . . . . . . . . . . 25\n   3.9.2    Response Messages . . . . . . .\
    \ . . . . . . . . . . . . . 26\n   3.10  Output Processing  . . . . . . . . .\
    \ . . . . . . . . . . . . 28\n   3.10.1   Triggered Updates . . . . . . . . .\
    \ . . . . . . . . . . . 29\n   3.10.2   Generating Response Messages. . . . .\
    \ . . . . . . . . . . 30\n   4.  Protocol Extensions  . . . . . . . . . . . .\
    \ . . . . . . . . . 31\n   4.1   Authentication . . . . . . . . . . . . . . .\
    \ . . . . . . . . 31\n   4.2   Route Tag  . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . 32\n   4.3   Subnet Mask  . . . . . . . . . . . . . . . . . .\
    \ . . . . . . 32\n   4.4   Next Hop . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . 33\n   4.5   Multicasting . . . . . . . . . . . . . . . . . . . .\
    \ . . . . 33\n   4.6   Queries  . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . 33\n   5.  Compatibility  . . . . . . . . . . . . . . . . . . . . . .\
    \ . . 34\n   5.1   Compatibility Switch . . . . . . . . . . . . . . . . . . .\
    \ . 34\n   5.2   Authentication . . . . . . . . . . . . . . . . . . . . . . .\
    \ 34\n   5.3   Larger Infinity  . . . . . . . . . . . . . . . . . . . . . . 35\n\
    \   5.4   Addressless Links  . . . . . . . . . . . . . . . . . . . . . 35\n  \
    \ 6.  Interaction between version 1 and version 2  . . . . . . . . . 35\n   7.\
    \  Security Considerations  . . . . . . . . . . . . . . . . . . . 36\n   Appendices\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n   References .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n   Author's Address\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . 38\n   Full Copyright Statement\
    \ . . . . . . . . . . . . . . . . . . . . . 39\n"
- title: 1.  Justification
  contents:
  - "1.  Justification\n   With the advent of OSPF and IS-IS, there are those who\
    \ believe that\n   RIP is obsolete.  While it is true that the newer IGP routing\n\
    \   protocols are far superior to RIP, RIP does have some advantages.\n   Primarily,\
    \ in a small network, RIP has very little overhead in terms\n   of bandwidth used\
    \ and configuration and management time.  RIP is also\n   very easy to implement,\
    \ especially in relation to the newer IGPs.\n   Additionally, there are many,\
    \ many more RIP implementations in the\n   field than OSPF and IS-IS combined.\
    \  It is likely to remain that way\n   for some years yet.\n   Given that RIP\
    \ will be useful in many environments for some period of\n   time, it is reasonable\
    \ to increase RIP's usefulness.  This is\n   especially true since the gain is\
    \ far greater than the expense of the\n   change.\n"
- title: 2. Current RIP
  contents:
  - "2. Current RIP\n   The current RIP-1 message contains the minimal amount of information\n\
    \   necessary for routers to route messages through a network.  It also\n   contains\
    \ a large amount of unused space, owing to its origins.\n   The current RIP-1\
    \ protocol does not consider autonomous systems and\n   IGP/EGP interactions,\
    \ subnetting [11], and authentication since\n   implementations of these postdate\
    \ RIP-1.  The lack of subnet masks is\n   a particularly serious problem for routers\
    \ since they need a subnet\n   mask to know how to determine a route.  If a RIP-1\
    \ route is a network\n   route (all non-network bits 0), the subnet mask equals\
    \ the network\n   mask.  However, if some of the non-network bits are set, the\
    \ router\n   cannot determine the subnet mask.  Worse still, the router cannot\n\
    \   determine if the RIP-1 route is a subnet route or a host route.\n   Currently,\
    \ some routers simply choose the subnet mask of the\n   interface over which the\
    \ route was learned and determine the route\n   type from that.\n"
- title: 3.  Basic Protocol
  contents:
  - '3.  Basic Protocol

    '
- title: 3.1 Introduction
  contents:
  - "3.1 Introduction\n   RIP is a routing protocol based on the Bellman-Ford (or\
    \ distance\n   vector) algorithm.  This algorithm has been used for routing\n\
    \   computations in computer networks since the early days of the\n   ARPANET.\
    \  The particular packet formats and protocol described here\n   are based on\
    \ the program \"routed,\" which is included with the\n   Berkeley distribution\
    \ of Unix.\n   In an international network, such as the Internet, it is very\n\
    \   unlikely that a single routing protocol will used for the entire\n   network.\
    \  Rather, the network will be organized as a collection of\n   Autonomous Systems\
    \ (AS), each of which will, in general, be\n   administered by a single entity.\
    \  Each AS will have its own routing\n   technology, which may differ among AS's.\
    \  The routing protocol used\n   within an AS is referred to as an Interior Gateway\
    \ Protocol (IGP).  A\n   separate protocol, called an Exterior Gateway Protocol\
    \ (EGP), is used\n   to transfer routing information among the AS's.  RIP was\
    \ designed to\n   work as an IGP in moderate-size AS's.  It is not intended for\
    \ use in\n   more complex environments.  For information on the context into which\n\
    \   RIP-1 is expected to fit, see Braden and Postel [6].\n   RIP uses one of a\
    \ class of routing algorithms known as Distance\n   Vector algorithms.  The earliest\
    \ description of this class of\n   algorithms known to the author is in Ford and\
    \ Fulkerson [8].  Because\n   of this, they are sometimes known as Ford-Fulkerson\
    \ algorithms.  The\n   term Bellman-Ford is also used, and derives from the fact\
    \ that the\n   formulation is based on Bellman's equation [4].  The presentation\
    \ in\n   this document is closely based on [5].  This document contains a\n  \
    \ protocol specification.  For an introduction to the mathematics of\n   routing\
    \ algorithms, see [1].  The basic algorithms used by this\n   protocol were used\
    \ in computer routing as early as 1969 in the\n   ARPANET.  However, the specific\
    \ ancestry of this protocol is within\n   the Xerox network protocols.  The PUP\
    \ protocols [7] used the Gateway\n   Information Protocol to exchange routing\
    \ information.  A somewhat\n   updated version of this protocol was adopted for\
    \ the Xerox Network\n   Systems (XNS) architecture, with the name Routing Information\n\
    \   Protocol [9].  Berkeley's routed is largely the same as the Routing\n   Information\
    \ Protocol, with XNS addresses replaced by a more general\n   address format capable\
    \ of handling IPv4 and other types of address,\n   and with routing updates limited\
    \ to one every 30 seconds.  Because of\n   this similarity, the term Routing Information\
    \ Protocol (or just RIP)\n   is used to refer to both the XNS protocol and the\
    \ protocol used by\n   routed.\n   RIP is intended for use within the IP-based\
    \ Internet.  The Internet\n   is organized into a number of networks connected\
    \ by special purpose\n   gateways known as routers.  The networks may be either\
    \ point-to-point\n   links or more complex networks such as Ethernet or token\
    \ ring.  Hosts\n   and routers are presented with IP datagrams addressed to some\
    \ host.\n   Routing is the method by which the host or router decides where to\n\
    \   send the datagram.  It may be able to send the datagram directly to\n   the\
    \ destination, if that destination is on one of the networks that\n   are directly\
    \ connected to the host or router.  However, the\n   interesting case is when\
    \ the destination is not directly reachable.\n   In this case, the host or router\
    \ attempts to send the datagram to a\n   router that is nearer the destination.\
    \  The goal of a routing\n   protocol is very simple: It is to supply the information\
    \ that is\n   needed to do routing.\n"
- title: 3.2 Limitations of the Protocol
  contents:
  - "3.2 Limitations of the Protocol\n   This protocol does not solve every possible\
    \ routing problem.  As\n   mentioned above, it is primary intended for use as\
    \ an IGP in networks\n   of moderate size.  In addition, the following specific\
    \ limitations\n   are be mentioned:\n   - The protocol is limited to networks\
    \ whose longest path (the\n     network's diameter) is 15 hops.  The designers\
    \ believe that the\n     basic protocol design is inappropriate for larger networks.\
    \  Note\n     that this statement of the limit assumes that a cost of 1 is used\n\
    \     for each network.  This is the way RIP is normally configured.  If\n   \
    \  the system administrator chooses to use larger costs, the upper\n     bound\
    \ of 15 can easily become a problem.\n   - The protocol depends upon \"counting\
    \ to infinity\" to resolve certain\n     unusual situations. (This will be explained\
    \ in the next section.)\n     If the system of networks has several hundred networks,\
    \ and a\n     routing loop was formed involving all of them, the resolution of\n\
    \     the loop would require either much time (if the frequency of\n     routing\
    \ updates were limited) or bandwidth (if updates were sent\n     whenever changes\
    \ were detected).  Such a loop would consume a large\n     amount of network bandwidth\
    \ before the loop was corrected.  We\n     believe that in realistic cases, this\
    \ will not be a problem except\n     on slow lines.  Even then, the problem will\
    \ be fairly unusual,\n     since various precautions are taken that should prevent\
    \ these\n     problems in most cases.\n   - This protocol uses fixed \"metrics\"\
    \ to compare alternative routes.\n     It is not appropriate for situations where\
    \ routes need to be chosen\n     based on real-time parameters such a measured\
    \ delay, reliability,\n     or load.  The obvious extensions to allow metrics\
    \ of this type are\n     likely to introduce instabilities of a sort that the\
    \ protocol is\n     not designed to handle.\n"
- title: 3.3. Organization of this document
  contents:
  - "3.3. Organization of this document\n   The main body of this document is organized\
    \ into two parts, which\n   occupy the next two sections:\n        A conceptual\
    \ development and justification of distance vector\n        algorithms in general.\n\
    \        The actual protocol description.\n   Each of these two sections can largely\
    \ stand on its own.  Section 3.4\n   attempts to give an informal presentation\
    \ of the mathematical\n   underpinnings of the algorithm.  Note that the presentation\
    \ follows a\n   \"spiral\" method.  An initial, fairly simple algorithm is described.\n\
    \   Then refinements are added to it in successive sections.  Section 3.5\n  \
    \ is the actual protocol description.  Except where specific references\n   are\
    \ made to section 3.4, it should be possible to implement RIP\n   entirely from\
    \ the specifications given in section 3.5.\n"
- title: 3.4 Distance Vector Algorithms
  contents:
  - "3.4 Distance Vector Algorithms\n   Routing is the task of finding a path from\
    \ a sender to a desired\n   destination.  In the IP \"Internet model\" this reduces\
    \ primarily to a\n   matter of finding a series of routers between the source\
    \ and\n   destination networks.  As long as a message or datagram remains on a\n\
    \   single network or subnet, any forwarding problems are the\n   responsibility\
    \ of technology that is specific to the network.  For\n   example, Ethernet and\
    \ the ARPANET each define a way in which any\n   sender can talk to any specified\
    \ destination within that one network.\n   IP routing comes in primarily when\
    \ messages must go from a sender on\n   one network to a destination on a different\
    \ one.  In that case, the\n   message must pass through one or more routers connecting\
    \ the\n   networks.  If the networks are not adjacent, the message may pass\n\
    \   through several intervening networks, and the routers connecting\n   them.\
    \  Once the message gets to a router that is on the same network\n   as the destination,\
    \ that network's own technology is used to get to\n   the destination.\n   Throughout\
    \ this section, the term \"network\" is used generically to\n   cover a single\
    \ broadcast network (e.g., an Ethernet), a point to\n   point line, or the ARPANET.\
    \  The critical point is that a network is\n   treated as a single entity by IP.\
    \  Either no forwarding decision is\n   necessary (as with a point to point line),\
    \ or that forwarding is done\n   in a manner that is transparent to IP, allowing\
    \ IP to treat the\n   entire network as a single fully-connected system (as with\
    \ an\n   Ethernet or the ARPANET).  Note that the term \"network\" is used in\
    \ a\n   somewhat different way in discussions of IP addressing.  We are using\n\
    \   the term \"network\" here to refer to subnets in cases where subnet\n   addressing\
    \ is in use.\n   A number of different approaches for finding routes between networks\n\
    \   are possible.  One useful way of categorizing these approaches is on\n   the\
    \ basis of the type of information the routers need to exchange in\n   order to\
    \ be able to find routes.  Distance vector algorithms are\n   based on the exchange\
    \ of only a small amount of information.  Each\n   entity (router or host) that\
    \ participates in the routing protocol is\n   assumed to keep information about\
    \ all of the destinations within the\n   system.  Generally, information about\
    \ all entities connected to one\n   network is summarized by a single entry, which\
    \ describes the route to\n   all destinations on that network.  This summarization\
    \ is possible\n   because as far as IP is concerned, routing within a network\
    \ is\n   invisible.  Each entry in this routing database includes the next\n \
    \  router to which datagrams destined for the entity should be sent.  In\n   addition,\
    \ it includes a \"metric\" measuring the total distance to the\n   entity.  Distance\
    \ is a somewhat generalized concept, which may cover\n   the time delay in getting\
    \ messages to the entity, the dollar cost of\n   sending messages to it, etc.\
    \  Distance vector algorithms get their\n   name from the fact that it is possible\
    \ to compute optimal routes when\n   the only information exchanged is the list\
    \ of these distances.\n   Furthermore, information is only exchanged among entities\
    \ that are\n   adjacent, that is, entities that share a common network.\n   Although\
    \ routing is most commonly based on information about\n   networks, it is sometimes\
    \ necessary to keep track of the routes to\n   individual hosts.  The RIP protocol\
    \ makes no formal distinction\n   between networks and hosts.  It simply describes\
    \ exchange of\n   information about destinations, which may be either networks\
    \ or\n   hosts.  (Note however, that it is possible for an implementor to\n  \
    \ choose not to support host routes.  See section 3.2.)  In fact, the\n   mathematical\
    \ developments are most conveniently thought of in terms\n   of routes from one\
    \ host or router to another.  When discussing the\n   algorithm in abstract terms,\
    \ it is best to think of a routing entry\n   for a network as an abbreviation\
    \ for routing entries for all of the\n   entities connected to that network. \
    \ This sort of abbreviation makes\n   sense only because we think of networks\
    \ as having no internal\n   structure that is visible at the IP level.  Thus,\
    \ we will generally\n   assign the same distance to every entity in a given network.\n\
    \   We said above that each entity keeps a routing database with one\n   entry\
    \ for every possible destination in the system.  An actual\n   implementation\
    \ is likely to need to keep the following information\n   about each destination:\n\
    \   - address: in IP implementations of these algorithms, this will be\n     the\
    \ IP address of the host or network.\n   - router: the first router along the\
    \ route to the destination.\n   - interface: the physical network which must be\
    \ used to reach the\n     first router.\n   - metric: a number, indicating the\
    \ distance to the destination.\n   - timer: the amount of time since the entry\
    \ was last updated.\n   In addition, various flags and other internal information\
    \ will\n   probably be included.  This database is initialized with a\n   description\
    \ of the entities that are directly connected to the\n   system.  It is updated\
    \ according to information received in messages\n   from neighboring routers.\n\
    \   The most important information exchanged by the hosts and routers is\n   carried\
    \ in update messages.  Each entity that participates in the\n   routing scheme\
    \ sends update messages that describe the routing\n   database as it currently\
    \ exists in that entity.  It is possible to\n   maintain optimal routes for the\
    \ entire system by using only\n   information obtained from neighboring entities.\
    \  The algorithm used\n   for that will be described in the next section.\n  \
    \ As we mentioned above, the purpose of routing is to find a way to get\n   datagrams\
    \ to their ultimate destinations.  Distance vector algorithms\n   are based on\
    \ a table in each router listing the best route to every\n   destination in the\
    \ system.  Of course, in order to define which route\n   is best, we have to have\
    \ some way of measuring goodness.  This is\n   referred to as the \"metric\".\n\
    \   In simple networks, it is common to use a metric that simply counts\n   how\
    \ many routers a message must go through.  In more complex\n   networks, a metric\
    \ is chosen to represent the total amount of delay\n   that the message suffers,\
    \ the cost of sending it, or some other\n   quantity which may be minimized. \
    \ The main requirement is that it\n   must be possible to represent the metric\
    \ as a sum of \"costs\" for\n   individual hops.\n   Formally, if it is possible\
    \ to get from entity i to entity j directly\n   (i.e., without passing through\
    \ another router between), then a cost,\n   d(i,j), is associated with the hop\
    \ between i and j.  In the normal\n   case where all entities on a given network\
    \ are considered to be the\n   same, d(i,j) is the same for all destinations on\
    \ a given network, and\n   represents the cost of using that network.  To get\
    \ the metric of a\n   complete route, one just adds up the costs of the individual\
    \ hops\n   that make up the route.  For the purposes of this memo, we assume\n\
    \   that the costs are positive integers.\n   Let D(i,j) represent the metric\
    \ of the best route from entity i to\n   entity j.  It should be defined for every\
    \ pair of entities.  d(i,j)\n   represents the costs of the individual steps.\
    \  Formally, let d(i,j)\n   represent the cost of going directly from entity i\
    \ to entity j.  It\n   is infinite if i and j are not immediate neighbors. (Note\
    \ that d(i,i)\n   is infinite.  That is, we don't consider there to be a direct\n\
    \   connection from a node to itself.)  Since costs are additive, it is\n   easy\
    \ to show that the best metric must be described by\n      D(i,i) = 0,       \
    \               all i\n      D(i,j) = min [d(i,k) + D(k,j)],  otherwise\n    \
    \                  k\n   and that the best routes start by going from i to those\
    \ neighbors k\n   for which d(i,k) + D(k,j) has the minimum value.  (These things\
    \ can\n   be shown by induction on the number of steps in the routes.)  Note\n\
    \   that we can limit the second equation to k's that are immediate\n   neighbors\
    \ of i.  For the others, d(i,k) is infinite, so the term\n   involving them can\
    \ never be the minimum.\n   It turns out that one can compute the metric by a\
    \ simple algorithm\n   based on this.  Entity i gets its neighbors k to send it\
    \ their\n   estimates of their distances to the destination j.  When i gets the\n\
    \   estimates from k, it adds d(i,k) to each of the numbers.  This is\n   simply\
    \ the cost of traversing the network between i and k.  Now and\n   then i compares\
    \ the values from all of its neighbors and picks the\n   smallest.\n   A proof\
    \ is given in [2] that this algorithm will converge to the\n   correct estimates\
    \ of D(i,j) in finite time in the absence of topology\n   changes.  The authors\
    \ make very few assumptions about the order in\n   which the entities send each\
    \ other their information, or when the min\n   is recomputed.  Basically, entities\
    \ just can't stop sending updates\n   or recomputing metrics, and the networks\
    \ can't delay messages\n   forever.  (Crash of a routing entity is a topology\
    \ change.)  Also,\n   their proof does not make any assumptions about the initial\
    \ estimates\n   of D(i,j), except that they must be non-negative.  The fact that\n\
    \   these fairly weak assumptions are good enough is important.  Because\n   we\
    \ don't have to make assumptions about when updates are sent, it is\n   safe to\
    \ run the algorithm asynchronously.  That is, each entity can\n   send updates\
    \ according to its own clock.  Updates can be dropped by\n   the network, as long\
    \ as they don't all get dropped.  Because we don't\n   have to make assumptions\
    \ about the starting condition, the algorithm\n   can handle changes.  When the\
    \ system changes, the routing algorithm\n   starts moving to a new equilibrium,\
    \ using the old one as its starting\n   point.  It is important that the algorithm\
    \ will converge in finite\n   time no matter what the starting point.  Otherwise\
    \ certain kinds of\n   changes might lead to non-convergent behavior.\n   The\
    \ statement of the algorithm given above (and the proof) assumes\n   that each\
    \ entity keeps copies of the estimates that come from each of\n   its neighbors,\
    \ and now and then does a min over all of the neighbors.\n   In fact real implementations\
    \ don't necessarily do that.  They simply\n   remember the best metric seen so\
    \ far, and the identity of the\n   neighbor that sent it.  They replace this information\
    \ whenever they\n   see a better (smaller) metric.  This allows them to compute\
    \ the\n   minimum incrementally, without having to store data from all of the\n\
    \   neighbors.\n   There is one other difference between the algorithm as described\
    \ in\n   texts and those used in real protocols such as RIP: the description\n\
    \   above would have each entity include an entry for itself, showing a\n   distance\
    \ of zero.  In fact this is not generally done.  Recall that\n   all entities\
    \ on a network are normally summarized by a single entry\n   for the network.\
    \  Consider the situation of a host or router G that\n   is connected to network\
    \ A.  C represents the cost of using network A\n   (usually a metric of one).\
    \  (Recall that we are assuming that the\n   internal structure of a network is\
    \ not visible to IP, and thus the\n   cost of going between any two entities on\
    \ it is the same.)  In\n   principle, G should get a message from every other\
    \ entity H on\n   network A, showing a cost of 0 to get from that entity to itself.\
    \  G\n   would then compute C + 0 as the distance to H.  Rather than having G\n\
    \   look at all of these identical messages, it simply starts out by\n   making\
    \ an entry for network A in its table, and assigning it a metric\n   of C.  This\
    \ entry for network A should be thought of as summarizing\n   the entries for\
    \ all other entities on network A.  The only entity on\n   A that can't be summarized\
    \ by that common entry is G itself, since\n   the cost of going from G to G is\
    \ 0, not C.  But since we never need\n   those 0 entries, we can safely get along\
    \ with just the single entry\n   for network A.  Note one other implication of\
    \ this strategy: because\n   we don't need to use the 0 entries for anything,\
    \ hosts that do not\n   function as routers don't need to send any update messages.\
    \  Clearly\n   hosts that don't function as routers (i.e., hosts that are connected\n\
    \   to only one network) can have no useful information to contribute\n   other\
    \ than their own entry D(i,i) = 0.  As they have only the one\n   interface, it\
    \ is easy to see that a route to any other network\n   through them will simply\
    \ go in that interface and then come right\n   back out it.  Thus the cost of\
    \ such a route will be greater than the\n   best cost by at least C.  Since we\
    \ don't need the 0 entries, non-\n   routers need not participate in the routing\
    \ protocol at all.\n   Let us summarize what a host or router G does.  For each\
    \ destination\n   in the system, G will keep a current estimate of the metric\
    \ for that\n   destination (i.e., the total cost of getting to it) and the identity\n\
    \   of the neighboring router on whose data that metric is based.  If the\n  \
    \ destination is on a network that is directly connected to G, then G\n   simply\
    \ uses an entry that shows the cost of using the network, and\n   the fact that\
    \ no router is needed to get to the destination.  It is\n   easy to show that\
    \ once the computation has converged to the correct\n   metrics, the neighbor\
    \ that is recorded by this technique is in fact\n   the first router on the path\
    \ to the destination.  (If there are\n   several equally good paths, it is the\
    \ first router on one of them.)\n   This combination of destination, metric, and\
    \ router is typically\n   referred to as a route to the destination with that\
    \ metric, using\n   that router.\n   4.ne The method so far only has a way to\
    \ lower the metric, as the\n   existing metric is kept until a smaller one shows\
    \ up.  It is possible\n   that the initial estimate might be too low.  Thus, there\
    \ must be a\n   way to increase the metric.  It turns out to be sufficient to\
    \ use the\n   following rule: suppose the current route to a destination has metric\n\
    \   D and uses router G.  If a new set of information arrived from some\n   source\
    \ other than G, only update the route if the new metric is\n   better than D.\
    \  But if a new set of information arrives from G\n   itself, always update D\
    \ to the new value.  It is easy to show that\n   with this rule, the incremental\
    \ update process produces the same\n   routes as a calculation that remembers\
    \ the latest information from\n   all the neighbors and does an explicit minimum.\
    \  (Note that the\n   discussion so far assumes that the network configuration\
    \ is static.\n   It does not allow for the possibility that a system might fail.)\n\
    \   To summarize, here is the basic distance vector algorithm as it has\n   been\
    \ developed so far.  (Note that this is not a statement of the RIP\n   protocol.\
    \  There are several refinements still to be added.)  The\n   following procedure\
    \ is carried out by every entity that participates\n   in the routing protocol.\
    \  This must include all of the routers in the\n   system.  Hosts that are not\
    \ routers may participate as well.\n   - Keep a table with an entry for every\
    \ possible destination in the\n     system.  The entry contains the distance D\
    \ to the destination, and\n     the first router G on the route to that network.\
    \  Conceptually,\n     there should be an entry for the entity itself, with metric\
    \ 0, but\n     this is not actually included.\n   - Periodically, send a routing\
    \ update to every neighbor.  The update\n     is a set of messages that contain\
    \ all of the information from the\n     routing table.  It contains an entry for\
    \ each destination, with the\n     distance shown to that destination.\n   - When\
    \ a routing update arrives from a neighbor G', add the cost\n     associated with\
    \ the network that is shared with G'.  (This should\n     be the network over\
    \ which the update arrived.)  Call the resulting\n     distance D'.  Compare the\
    \ resulting distances with the current\n     routing table entries.  If the new\
    \ distance D' for N is smaller\n     than the existing value D, adopt the new\
    \ route.  That is, change\n     the table entry for N to have metric D' and router\
    \ G'.  If G' is\n     the router from which the existing route came, i.e., G'\
    \ = G, then\n     use the new metric even if it is larger than the old one.\n"
- title: 3.4.1 Dealing with changes in topology
  contents:
  - "3.4.1 Dealing with changes in topology\n   The discussion above assumes that\
    \ the topology of the network is\n   fixed.  In practice, routers and lines often\
    \ fail and come back up.\n   To handle this possibility, we need to modify the\
    \ algorithm slightly.\n   The theoretical version of the algorithm involved a\
    \ minimum over all\n   immediate neighbors.  If the topology changes, the set\
    \ of neighbors\n   changes.  Therefore, the next time the calculation is done,\
    \ the\n   change will be reflected.  However, as mentioned above, actual\n   implementations\
    \ use an incremental version of the minimization.  Only\n   the best route to\
    \ any given destination is remembered.  If the router\n   involved in that route\
    \ should crash, or the network connection to it\n   break, the calculation might\
    \ never reflect the change.  The algorithm\n   as shown so far depends upon a\
    \ router notifying its neighbors if its\n   metrics change.  If the router crashes,\
    \ then it has no way of\n   notifying neighbors of a change.\n   In order to handle\
    \ problems of this kind, distance vector protocols\n   must make some provision\
    \ for timing out routes.  The details depend\n   upon the specific protocol. \
    \ As an example, in RIP every router that\n   participates in routing sends an\
    \ update message to all its neighbors\n   once every 30 seconds.  Suppose the\
    \ current route for network N uses\n   router G.  If we don't hear from G for\
    \ 180 seconds, we can assume\n   that either the router has crashed or the network\
    \ connecting us to it\n   has become unusable.  Thus, we mark the route as invalid.\
    \  When we\n   hear from another neighbor that has a valid route to N, the valid\n\
    \   route will replace the invalid one.  Note that we wait for 180\n   seconds\
    \ before timing out a route even though we expect to hear from\n   each neighbor\
    \ every 30 seconds.  Unfortunately, messages are\n   occasionally lost by networks.\
    \  Thus, it is probably not a good idea\n   to invalidate a route based on a single\
    \ missed message.\n   As we will see below, it is useful to have a way to notify\
    \ neighbors\n   that there currently isn't a valid route to some network.  RIP,\
    \ along\n   with several other protocols of this class, does this through a\n\
    \   normal update message, by marking that network as unreachable.  A\n   specific\
    \ metric value is chosen to indicate an unreachable\n   destination; that metric\
    \ value is larger than the largest valid\n   metric that we expect to see.  In\
    \ the existing implementation of RIP,\n   16 is used.  This value is normally\
    \ referred to as \"infinity\", since\n   it is larger than the largest valid metric.\
    \  16 may look like a\n   surprisingly small number.  It is chosen to be this\
    \ small for reasons\n   that we will see shortly.  In most implementations, the\
    \ same\n   convention is used internally to flag a route as invalid.\n"
- title: 3.4.2 Preventing instability
  contents:
  - "3.4.2 Preventing instability\n   The algorithm as presented up to this point\
    \ will always allow a host\n   or router to calculate a correct routing table.\
    \  However, that is\n   still not quite enough to make it useful in practice.\
    \  The proofs\n   referred to above only show that the routing tables will converge\
    \ to\n   the correct values in finite time.  They do not guarantee that this\n\
    \   time will be small enough to be useful, nor do they say what will\n   happen\
    \ to the metrics for networks that become inaccessible.\n   It is easy enough\
    \ to extend the mathematics to handle routes becoming\n   inaccessible.  The convention\
    \ suggested above will do that.  We\n   choose a large metric value to represent\
    \ \"infinity\".  This value must\n   be large enough that no real metric would\
    \ ever get that large.  For\n   the purposes of this example, we will use the\
    \ value 16.  Suppose a\n   network becomes inaccessible.  All of the immediately\
    \ neighboring\n   routers time out and set the metric for that network to 16.\
    \  For\n   purposes of analysis, we can assume that all the neighboring routers\n\
    \   have gotten a new piece of hardware that connects them directly to\n   the\
    \ vanished network, with a cost of 16.  Since that is the only\n   connection\
    \ to the vanished network, all the other routers in the\n   system will converge\
    \ to new routes that go through one of those\n   routers.  It is easy to see that\
    \ once convergence has happened, all\n   the routers will have metrics of at least\
    \ 16 for the vanished\n   network.  Routers one hop away from the original neighbors\
    \ would end\n   up with metrics of at least 17; routers two hops away would end\
    \ up\n   with at least 18, etc.  As these metrics are larger than the maximum\n\
    \   metric value, they are all set to 16.  It is obvious that the system\n   will\
    \ now converge to a metric of 16 for the vanished network at all\n   routers.\n\
    \   Unfortunately, the question of how long convergence will take is not\n   amenable\
    \ to quite so simple an answer.  Before going any further, it\n   will be useful\
    \ to look at an example (taken from [2]).  Note that\n   what we are about to\
    \ show will not happen with a correct\n   implementation of RIP.  We are trying\
    \ to show why certain features\n   are needed.  In the following example the letters\
    \ correspond to\n   routers, and the lines to networks.\n     A-----B\n      \\\
    \   / \\\n       \\ /  |\n        C  /    all networks have cost 1, except\n \
    \       | /     for the direct link from C to D, which\n        |/      has cost\
    \ 10\n        D\n        |<=== target network\n   Each router will have a table\
    \ showing a route to each network.\n   However, for purposes of this illustration,\
    \ we show only the routes\n   from each router to the network marked at the bottom\
    \ of the diagram.\n           D:  directly connected, metric 1\n           B:\
    \  route via D, metric 2\n           C:  route via B, metric 3\n           A:\
    \  route via B, metric 3\n   Now suppose that the link from B to D fails.  The\
    \ routes should now\n   adjust to use the link from C to D.  Unfortunately, it\
    \ will take a\n   while for this to this to happen.  The routing changes start\
    \ when B\n   notices that the route to D is no longer usable.  For simplicity,\
    \ the\n   chart below assumes that all routers send updates at the same time.\n\
    \   The chart shows the metric for the target network, as it appears in\n   the\
    \ routing table at each router.\n       time ------>\n       D: dir, 1   dir,\
    \ 1   dir, 1   dir, 1  ...  dir, 1   dir, 1\n       B: unreach  C,   4   C,  \
    \ 5   C,   6       C,  11   C,  12\n       C: B,   3   A,   4   A,   5   A,  \
    \ 6       A,  11   D,  11\n       A: B,   3   C,   4   C,   5   C,   6       C,\
    \  11   C,  12\n       dir = directly connected\n       unreach = unreachable\n\
    \   Here's the problem:  B is able to get rid of its failed route using a\n  \
    \ timeout mechanism, but vestiges of that route persist in the system\n   for\
    \ a long time.  Initially, A and C still think they can get to D\n   via B.  So,\
    \ they keep sending updates listing metrics of 3.  In the\n   next iteration,\
    \ B will then claim that it can get to D via either A\n   or C.  Of course, it\
    \ can't.  The routes being claimed by A and C are\n   now gone, but they have\
    \ no way of knowing that yet.  And even when\n   they discover that their routes\
    \ via B have gone away, they each think\n   there is a route available via the\
    \ other.  Eventually the system\n   converges, as all the mathematics claims it\
    \ must.  But it can take\n   some time to do so.  The worst case is when a network\
    \ becomes\n   completely inaccessible from some part of the system.  In that case,\n\
    \   the metrics may increase slowly in a pattern like the one above until\n  \
    \ they finally reach infinity.  For this reason, the problem is called\n   \"\
    counting to infinity\".\n   You should now see why \"infinity\" is chosen to be\
    \ as small as\n   possible.  If a network becomes completely inaccessible, we\
    \ want\n   counting to infinity to be stopped as soon as possible.  Infinity\n\
    \   must be large enough that no real route is that big.  But it\n   shouldn't\
    \ be any bigger than required.  Thus the choice of infinity\n   is a tradeoff\
    \ between network size and speed of convergence in case\n   counting to infinity\
    \ happens.  The designers of RIP believed that the\n   protocol was unlikely to\
    \ be practical for networks with a diameter\n   larger than 15.\n   There are\
    \ several things that can be done to prevent problems like\n   this.  The ones\
    \ used by RIP are called \"split horizon with poisoned\n   reverse\", and \"triggered\
    \ updates\".\n"
- title: 3.4.3 Split horizon
  contents:
  - "3.4.3 Split horizon\n   Note that some of the problem above is caused by the\
    \ fact that A and\n   C are engaged in a pattern of mutual deception.  Each claims\
    \ to be\n   able to get to D via the other.  This can be prevented by being a\
    \ bit\n   more careful about where information is sent.  In particular, it is\n\
    \   never useful to claim reachability for a destination network to the\n   neighbor(s)\
    \ from which the route was learned.  \"Split horizon\" is a\n   scheme for avoiding\
    \ problems caused by including routes in updates\n   sent to the router from which\
    \ they were learned.  The \"simple split\n   horizon\" scheme omits routes learned\
    \ from one neighbor in updates\n   sent to that neighbor.  \"Split horizon with\
    \ poisoned reverse\"\n   includes such routes in updates, but sets their metrics\
    \ to infinity.\n   If A thinks it can get to D via C, its messages to C should\
    \ indicate\n   that D is unreachable.  If the route through C is real, then C\
    \ either\n   has a direct connection to D, or a connection through some other\n\
    \   router.  C's route can't possibly go back to A, since that forms a\n   loop.\
    \  By telling C that D is unreachable, A simply guards against\n   the possibility\
    \ that C might get confused and believe that there is a\n   route through A. \
    \ This is obvious for a point to point line.  But\n   consider the possibility\
    \ that A and C are connected by a broadcast\n   network such as an Ethernet, and\
    \ there are other routers on that\n   network.  If A has a route through C, it\
    \ should indicate that D is\n   unreachable when talking to any other router on\
    \ that network.  The\n   other routers on the network can get to C themselves.\
    \  They would\n   never need to get to C via A.  If A's best route is really through\
    \ C,\n   no other router on that network needs to know that A can reach D.\n \
    \  This is fortunate, because it means that the same update message that\n   is\
    \ used for C can be used for all other routers on the same network.\n   Thus,\
    \ update messages can be sent by broadcast.\n   In general, split horizon with\
    \ poisoned reverse is safer than simple\n   split horizon.  If two routers have\
    \ routes pointing at each other,\n   advertising reverse routes with a metric\
    \ of 16 will break the loop\n   immediately.  If the reverse routes are simply\
    \ not advertised, the\n   erroneous routes will have to be eliminated by waiting\
    \ for a timeout.\n   However, poisoned reverse does have a disadvantage: it increases\
    \ the\n   size of the routing messages.  Consider the case of a campus backbone\n\
    \   connecting a number of different buildings.  In each building, there\n   is\
    \ a router connecting the backbone to a local network.  Consider\n   what routing\
    \ updates those routers should broadcast on the backbone\n   network.  All that\
    \ the rest of the network really needs to know about\n   each router is what local\
    \ networks it is connected to.  Using simple\n   split horizon, only those routes\
    \ would appear in update messages sent\n   by the router to the backbone network.\
    \  If split horizon with\n   poisoned reverse is used, the router must mention\
    \ all routes that it\n   learns from the backbone, with metrics of 16.  If the\
    \ system is\n   large, this can result in a large update message, almost all of\
    \ whose\n   entries indicate unreachable networks.\n   In a static sense, advertising\
    \ reverse routes with a metric of 16\n   provides no additional information. \
    \ If there are many routers on one\n   broadcast network, these extra entries\
    \ can use significant bandwidth.\n   The reason they are there is to improve dynamic\
    \ behavior.  When\n   topology changes, mentioning routes that should not go through\
    \ the\n   router as well as those that should can speed up convergence.\n   However,\
    \ in some situations, network managers may prefer to accept\n   somewhat slower\
    \ convergence in order to minimize routing overhead.\n   Thus implementors may\
    \ at their option implement simple split horizon\n   rather than split horizon\
    \ with poisoned reverse, or they may provide\n   a configuration option that allows\
    \ the network manager to choose\n   which behavior to use.  It is also permissible\
    \ to implement hybrid\n   schemes that advertise some reverse routes with a metric\
    \ of 16 and\n   omit others.  An example of such a scheme would be to use a metric\
    \ of\n   16 for reverse routes for a certain period of time after routing\n  \
    \ changes involving them, and thereafter omitting them from updates.\n   The router\
    \ requirements RFC [11] specifies that all implementation of\n   RIP must use\
    \ split horizon and should also use split horizon with\n   poisoned reverse, although\
    \ there may be a knob to disable poisoned\n   reverse.\n"
- title: 3.4.4  Triggered updates
  contents:
  - "3.4.4  Triggered updates\n   Split horizon with poisoned reverse will prevent\
    \ any routing loops\n   that involve only two routers.  However, it is still possible\
    \ to end\n   up with patterns in which three routers are engaged in mutual\n \
    \  deception.  For example, A may believe it has a route through B, B\n   through\
    \ C, and C through A.  Split horizon cannot stop such a loop.\n   This loop will\
    \ only be resolved when the metric reaches infinity and\n   the network involved\
    \ is then declared unreachable.  Triggered updates\n   are an attempt to speed\
    \ up this convergence.  To get triggered\n   updates, we simply add a rule that\
    \ whenever a router changes the\n   metric for a route, it is required to send\
    \ update messages almost\n   immediately, even if it is not yet time for one of\
    \ the regular update\n   message.  (The timing details will differ from protocol\
    \ to protocol.\n   Some distance vector protocols, including RIP, specify a small\
    \ time\n   delay, in order to avoid having triggered updates generate excessive\n\
    \   network traffic.)  Note how this combines with the rules for\n   computing\
    \ new metrics.  Suppose a router's route to destination N\n   goes through router\
    \ G.  If an update arrives from G itself, the\n   receiving router is required\
    \ to believe the new information, whether\n   the new metric is higher or lower\
    \ than the old one.  If the result is\n   a change in metric, then the receiving\
    \ router will send triggered\n   updates to all the hosts and routers directly\
    \ connected to it.  They\n   in turn may each send updates to their neighbors.\
    \  The result is a\n   cascade of triggered updates.  It is easy to show which\
    \ routers and\n   hosts are involved in the cascade.  Suppose a router G times\
    \ out a\n   route to destination N.  G will send triggered updates to all of its\n\
    \   neighbors.  However, the only neighbors who will believe the new\n   information\
    \ are those whose routes for N go through G.  The other\n   routers and hosts\
    \ will see this as information about a new route that\n   is worse than the one\
    \ they are already using, and ignore it.  The\n   neighbors whose routes go through\
    \ G will update their metrics and\n   send triggered updates to all of their neighbors.\
    \  Again, only those\n   neighbors whose routes go through them will pay attention.\
    \  Thus, the\n   triggered updates will propagate backwards along all paths leading\
    \ to\n   router G, updating the metrics to infinity.  This propagation will\n\
    \   stop as soon as it reaches a portion of the network whose route to\n   destination\
    \ N takes some other path.\n   If the system could be made to sit still while\
    \ the cascade of\n   triggered updates happens, it would be possible to prove\
    \ that\n   counting to infinity will never happen.  Bad routes would always be\n\
    \   removed immediately, and so no routing loops could form.\n   Unfortunately,\
    \ things are not so nice.  While the triggered updates\n   are being sent, regular\
    \ updates may be happening at the same time.\n   Routers that haven't received\
    \ the triggered update yet will still be\n   sending out information based on\
    \ the route that no longer exists.  It\n   is possible that after the triggered\
    \ update has gone through a\n   router, it might receive a normal update from\
    \ one of these routers\n   that hasn't yet gotten the word.  This could reestablish\
    \ an orphaned\n   remnant of the faulty route.  If triggered updates happen quickly\n\
    \   enough, this is very unlikely.  However, counting to infinity is\n   still\
    \ possible.\n   The router requirements RFC [11] specifies that all implementation\
    \ of\n   RIP must implement triggered update for deleted routes and may\n   implement\
    \ triggered updates for new routes or change of routes.  RIP\n   implementations\
    \ must also limit the rate which of triggered updates\n   may be trandmitted.\
    \ (see section 3.10.1)\n"
- title: 3.5 Protocol Specification
  contents:
  - "3.5 Protocol Specification\n   RIP is intended to allow routers to exchange information\
    \ for\n   computing routes through an IPv4-based network.  Any router that uses\n\
    \   RIP is assumed to have interfaces to one or more networks, otherwise\n   it\
    \ isn't really a router.  These are referred to as its directly-\n   connected\
    \ networks.  The protocol relies on access to certain\n   information about each\
    \ of these networks, the most important of which\n   is its metric.  The RIP metric\
    \ of a network is an integer between 1\n   and 15, inclusive.  It is set in some\
    \ manner not specified in this\n   protocol; however, given the maximum path limit\
    \ of 15, a value of 1\n   is usually used.  Implementations should allow the system\n\
    \   administrator to set the metric of each network.  In addition to the\n   metric,\
    \ each network will have an IPv4 destination address and subnet\n   mask associated\
    \ with it.  These are to be set by the system\n   administrator in a manner not\
    \ specified in this protocol.\n   Any host that uses RIP is assumed to have interfaces\
    \ to one or more\n   networks.  These are referred to as its \"directly-connected\n\
    \   networks\".  The protocol relies on access to certain information\n   about\
    \ each of these networks.  The most important is its metric or\n   \"cost\". \
    \ The metric of a network is an integer between 1 and 15\n   inclusive.  It is\
    \ set in some manner not specified in this protocol.\n   Most existing implementations\
    \ always use a metric of 1.  New\n   implementations should allow the system administrator\
    \ to set the cost\n   of each network.  In addition to the cost, each network\
    \ will have an\n   IPv4 network number and a subnet mask associated with it. \
    \ These are\n   to be set by the system administrator in a manner not specified\
    \ in\n   this protocol.\n   Note that the rules specified in section 3.7 assume\
    \ that there is a\n   single subnet mask applying to each IPv4 network, and that\
    \ only the\n   subnet masks for directly-connected networks are known.  There\
    \ may be\n   systems that use different subnet masks for different subnets within\n\
    \   a single network.  There may also be instances where it is desirable\n   for\
    \ a system to know the subnets masks of distant networks. Network-\n   wide distribution\
    \ of routing information which contains different\n   subnet masks is permitted\
    \ if all routers in the network are running\n   the extensions presented in this\
    \ document. However, if all routers in\n   the network are not running these extensions\
    \ distribution of routing\n   information containing different subnet masks must\
    \ be limited to\n   avoid interoperability problems. See sections 3.7 and 4.3\
    \ for the\n   rules governing subnet distribution.\n   Each router that implements\
    \ RIP is assumed to have a routing table.\n   This table has one entry for every\
    \ destination that is reachable\n   throughout the system operating RIP.  Each\
    \ entry contains at least\n   the following information:\n   - The IPv4 address\
    \ of the destination.\n   - A metric, which represents the total cost of getting\
    \ a datagram\n     from the router to that destination.  This metric is the sum\
    \ of the\n     costs associated with the networks that would be traversed to get\n\
    \     to the destination.\n   - The IPv4 address of the next router along the\
    \ path to the\n     destination (i.e., the next hop).  If the destination is on\
    \ one of\n     the directly-connected networks, this item is not needed.\n   -\
    \ A flag to indicate that information about the route has changed\n     recently.\
    \  This will be referred to as the \"route change flag.\"\n   - Various timers\
    \ associated with the route.  See section 3.6 for more\n     details on timers.\n\
    \   The entries for the directly-connected networks are set up by the\n   router\
    \ using information gathered by means not specified in this\n   protocol.  The\
    \ metric for a directly-connected network is set to the\n   cost of that network.\
    \  As mentioned, 1 is the usual cost.  In that\n   case, the RIP metric reduces\
    \ to a simple hop-count.  More complex\n   metrics may be used when it is desirable\
    \ to show preference for some\n   networks over others (e.g., to indicate of differences\
    \ in bandwidth\n   or reliability).\n   To support the extensions detailed in\
    \ this document, each entry must\n   additionally contain a subnet mask. The subnet\
    \ mask allows the router\n   (along with the IPv4 address of the destination)\
    \ to identify the\n   different subnets within a single network as well as the\
    \ subnets\n   masks of distant networks.\n   Implementors may also choose to allow\
    \ the system administrator to\n   enter additional routes.  These would most likely\
    \ be routes to hosts\n   or networks outside the scope of the routing system.\
    \  They are\n   referred to as \"static routes.\"  Entries for destinations other\
    \ than\n   these initial ones are added and updated by the algorithms described\n\
    \   in the following sections.\n   In order for the protocol to provide complete\
    \ information on routing,\n   every router in the AS must participate in the protocol.\
    \  In cases\n   where multiple IGPs are in use, there must be at least one router\n\
    \   which can leak routing information between the protocols.\n"
- title: 3.6 Message Format
  contents:
  - "3.6 Message Format\n   RIP is a UDP-based protocol.  Each router that uses RIP\
    \ has a routing\n   process that sends and receives datagrams on UDP port number\
    \ 520, the\n   RIP-1/RIP-2 port.  All communications intended for another routers's\n\
    \   RIP process are sent to the RIP port.  All routing update messages\n   are\
    \ sent from the RIP port.  Unsolicited routing update messages have\n   both the\
    \ source and destination port equal to the RIP port.  Update\n   messages sent\
    \ in response to a request are sent to the port from\n   which the request came.\
    \  Specific queries may be sent from ports\n   other than the RIP port, but they\
    \ must be directed to the RIP port on\n   the target machine.\n   The RIP packet\
    \ format is:\n       0                   1                   2               \
    \    3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   \
    \   |  command (1)  |  version (1)  |       must be zero (2)        |\n      +---------------+---------------+-------------------------------+\n\
    \      |                                                               |\n   \
    \   ~                         RIP Entry (20)                        ~\n      |\
    \                                                               |\n      +---------------+---------------+---------------+---------------+\n\
    \   There may be between 1 and 25 (inclusive) RIP entries.  A RIP-1 entry\n  \
    \ has the following format:\n       0                   1                   2\
    \                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | address family identifier (2) |      must be zero (2)         |\n   \
    \   +-------------------------------+-------------------------------+\n      |\
    \                        IPv4 address (4)                       |\n      +---------------------------------------------------------------+\n\
    \      |                        must be zero (4)                       |\n   \
    \   +---------------------------------------------------------------+\n      |\
    \                        must be zero (4)                       |\n      +---------------------------------------------------------------+\n\
    \      |                           metric (4)                          |\n   \
    \   +---------------------------------------------------------------+\n   Field\
    \ sizes are given in octets.  Unless otherwise specified, fields\n   contain binary\
    \ integers, in network byte order, with the most-\n   significant octet first\
    \ (big-endian).  Each tick mark represents one\n   bit.\n   Every message contains\
    \ a RIP header which consists of a command and a\n   version number.  This section\
    \ of the document describes version 1 of\n   the protocol; section 4 describes\
    \ the version 2 extensions.  The\n   command field is used to specify the purpose\
    \ of this message.  The\n   commands implemented in version 1 and 2 are:\n   1\
    \ - request    A request for the responding system to send all or\n          \
    \        part of its routing table.\n   2 - response   A message containing all\
    \ or part of the sender's\n                  routing table.  This message may\
    \ be sent in response\n                  to a request, or it may be an unsolicited\
    \ routing\n                  update generated by the sender.\n   For each of these\
    \ message types, in version 1, the remainder of the\n   datagram contains a list\
    \ of Route Entries (RTEs).  Each RTE in this\n   list contains an Address Family\
    \ Identifier (AFI), destination IPv4\n   address, and the cost to reach that destination\
    \ (metric).\n   The AFI is the type of address.  For RIP-1, only AF_INET (2) is\n\
    \   generally supported.\n   The metric field contains a value between 1 and 15\
    \ (inclusive) which\n   specifies the current metric for the destination; or the\
    \ value 16\n   (infinity), which indicates that the destination is not reachable.\n"
- title: 3.7 Addressing Considerations
  contents:
  - "3.7 Addressing Considerations\n   Distance vector routing can be used to describe\
    \ routes to individual\n   hosts or to networks.  The RIP protocol allows either\
    \ of these\n   possibilities.  The destinations appearing in request and response\n\
    \   messages can be networks, hosts, or a special code used to indicate a\n  \
    \ default address.  In general, the kinds of routes actually used will\n   depend\
    \ upon the routing strategy used for the particular network.\n   Many networks\
    \ are set up so that routing information for individual\n   hosts is not needed.\
    \  If every node on a given network or subnet is\n   accessible through the same\
    \ routers, then there is no reason to\n   mention individual hosts in the routing\
    \ tables.  However, networks\n   that include point-to-point lines sometimes require\
    \ routers to keep\n   track of routes to certain nodes.  Whether this feature\
    \ is required\n   depends upon the addressing and routing approach used in the\
    \ system.\n   Thus, some implementations may choose not to support host routes.\
    \  If\n   host routes are not supported, they are to be dropped when they are\n\
    \   received in response messages (see section 3.7.2).\n   The RIP-1 packet format\
    \ does not distinguish among various types of\n   address.  Fields that are labeled\
    \ \"address\" can contain any of the\n   following:\n   host address subnet number\
    \ network number zero (default route)\n   Entities which use RIP-1 are assumed\
    \ to use the most specific\n   information available when routing a datagram.\
    \  That is, when routing\n   a datagram, its destination address must first be\
    \ checked against the\n   list of node addresses.  Then it must be checked to\
    \ see whether it\n   matches any known subnet or network number.  Finally, if\
    \ none of\n   these match, the default route is used.\n   When a node evaluates\
    \ information that it receives via RIP-1, its\n   interpretation of an address\
    \ depends upon whether it knows the subnet\n   mask that applies to the net. \
    \ If so, then it is possible to\n   determine the meaning of the address.  For\
    \ example, consider net\n   128.6.  It has a subnet mask of 255.255.255.0.  Thus\
    \ 128.6.0.0 is a\n   network number, 128.6.4.0 is a subnet number, and 128.6.4.1\
    \ is a node\n   address.  However, if the node does not know the subnet mask,\n\
    \   evaluation of an address may be ambiguous.  If there is a non-zero\n   node\
    \ part, there is no clear way to determine whether the address\n   represents\
    \ a subnet number or a node address.  As a subnet number\n   would be useless\
    \ without the subnet mask, addresses are assumed to\n   represent nodes in this\
    \ situation.  In order to avoid this sort of\n   ambiguity, when using version\
    \ 1, nodes must not send subnet routes to\n   nodes that cannot be expected to\
    \ know the appropriate subnet mask.\n   Normally hosts only know the subnet masks\
    \ for directly-connected\n   networks.  Therefore, unless special provisions have\
    \ been made,\n   routes to a subnet must not be sent outside the network of which\
    \ the\n   subnet is a part.  RIP-2 (see section 4) eliminates the subnet/host\n\
    \   ambiguity by including the subnet mask in the routing entry.\n   This \"subnet\
    \ filtering\" is carried out by the routers at the \"border\"\n   of the subnetted\
    \ network.  These are routers which connect that\n   network with some other network.\
    \  Within the subnetted network, each\n   subnet is treated as an individual network.\
    \  Routing entries for each\n   subnet are circulated by RIP.  However, border\
    \ routers send only a\n   single entry for the network as a whole to nodes in\
    \ other networks.\n   This means that a border router will send different information\
    \ to\n   different neighbors.  For neighbors connected to the subnetted\n   network,\
    \ it generates a list of all subnets to which it is directly\n   connected, using\
    \ the subnet number.  For neighbors connected to other\n   networks, it makes\
    \ a single entry for the network as a whole, showing\n   the metric associated\
    \ with that network.  This metric would normally\n   be the smallest metric for\
    \ the subnets to which the router is\n   attached.\n   Similarly, border routers\
    \ must not mention host routes for nodes\n   within one of the directly-connected\
    \ networks in messages to other\n   networks.  Those routes will be subsumed by\
    \ the single entry for the\n   network as a whole.\n   The router requirements\
    \ RFC [11] specifies that all implementation of\n   RIP should support host routes\
    \ but if they do not then they must\n   ignore any received host routes.\n   The\
    \ special address 0.0.0.0 is used to describe a default route.  A\n   default\
    \ route is used when it is not convenient to list every\n   possible network in\
    \ the RIP updates, and when one or more closely-\n   connected routers in the\
    \ system are prepared to handle traffic to the\n   networks that are not listed\
    \ explicitly.  These routers should create\n   RIP entries for the address 0.0.0.0,\
    \ just as if it were a network to\n   which they are connected.  The decision\
    \ as to how routers create\n   entries for 0.0.0.0 is left to the implementor.\
    \  Most commonly, the\n   system administrator will be provided with a way to\
    \ specify which\n   routers should create entries for 0.0.0.0; however, other\
    \ mechanisms\n   are possible.  For example, an implementor might decide that\
    \ any\n   router which speaks BGP should be declared to be a default router.\n\
    \   It may be useful to allow the network administrator to choose the\n   metric\
    \ to be used in these entries.  If there is more than one\n   default router,\
    \ this will make it possible to express a preference\n   for one over the other.\
    \  The entries for 0.0.0.0 are handled by RIP\n   in exactly the same manner as\
    \ if there were an actual network with\n   this address.  System administrators\
    \ should take care to make sure\n   that routes to 0.0.0.0 do not propagate further\
    \ than is intended.\n   Generally, each autonomous system has its own preferred\
    \ default\n   router.  Thus, routes involving 0.0.0.0 should generally not leave\n\
    \   the boundary of an autonomous system.  The mechanisms for enforcing\n   this\
    \ are not specified in this document.\n"
- title: 3.8 Timers
  contents:
  - "3.8 Timers\n   This section describes all events that are triggered by timers.\n\
    \   Every 30 seconds, the RIP process is awakened to send an unsolicited\n   Response\
    \ message containing the complete routing table (see section\n   3.9 on Split\
    \ Horizon) to every neighboring router.  When there are\n   many routers on a\
    \ single network, there is a tendency for them to\n   synchronize with each other\
    \ such that they all issue updates at the\n   same time.  This can happen whenever\
    \ the 30 second timer is affected\n   by the processing load on the system.  It\
    \ is undesirable for the\n   update messages to become synchronized, since it\
    \ can lead to\n   unnecessary collisions on broadcast networks.  Therefore,\n\
    \   implementations are required to take one of two precautions:\n   - The 30-second\
    \ updates are triggered by a clock whose rate is not\n     affected by system\
    \ load or the time required to service the\n     previous update timer.\n   -\
    \ The 30-second timer is offset by a small random time (+/- 0 to 5\n     seconds)\
    \ each time it is set.  (Implementors may wish to consider\n     even larger variation\
    \ in the light of recent research results [10])\n   There are two timers associated\
    \ with each route, a \"timeout\" and a\n   \"garbage-collection\" time.  Upon\
    \ expiration of the timeout, the route\n   is no longer valid; however, it is\
    \ retained in the routing table for\n   a short time so that neighbors can be\
    \ notified that the route has\n   been dropped.  Upon expiration of the garbage-collection\
    \ timer, the\n   route is finally removed from the routing table.\n   The timeout\
    \ is initialized when a route is established, and any time\n   an update message\
    \ is received for the route.  If 180 seconds elapse\n   from the last time the\
    \ timeout was initialized, the route is\n   considered to have expired, and the\
    \ deletion process described below\n   begins for that route.\n   Deletions can\
    \ occur for one of two reasons: the timeout expires, or\n   the metric is set\
    \ to 16 because of an update received from the\n   current router (see section\
    \ 3.7.2 for a discussion of processing\n   updates from other routers).  In either\
    \ case, the following events\n   happen:\n   - The garbage-collection timer is\
    \ set for 120 seconds.\n   - The metric for the route is set to 16 (infinity).\
    \  This causes the\n     route to be removed from service.\n   - The route change\
    \ flag is set to indicate that this entry has been\n     changed.\n   - The output\
    \ process is signalled to trigger a response.\n   Until the garbage-collection\
    \ timer expires, the route is included in\n   all updates sent by this router.\
    \  When the garbage-collection timer\n   expires, the route is deleted from the\
    \ routing table.\n   Should a new route to this network be established while the\
    \ garbage-\n   collection timer is running, the new route will replace the one\
    \ that\n   is about to be deleted.  In this case the garbage-collection timer\n\
    \   must be cleared.\n   Triggered updates also use a small timer; however, this\
    \ is best\n   described in section 3.9.1.\n"
- title: 3.9 Input Processing
  contents:
  - "3.9 Input Processing\n   This section will describe the handling of datagrams\
    \ received on the\n   RIP port.  Processing will depend upon the value in the\
    \ command\n   field.\n   See sections 4.6 and 5.1 for details on handling version\
    \ numbers.\n"
- title: 3.9.1 Request Messages
  contents:
  - "3.9.1 Request Messages\n   A Request is used to ask for a response containing\
    \ all or part of a\n   router's routing table.  Normally, Requests are sent as\
    \ broadcasts\n   (multicasts for RIP-2), from the RIP port, by routers which have\
    \ just\n   come up and are seeking to fill in their routing tables as quickly\
    \ as\n   possible.  However, there may be situations (e.g., router monitoring)\n\
    \   where the routing table of only a single router is needed.  In this\n   case,\
    \ the Request should be sent directly to that router from a UDP\n   port other\
    \ than the RIP port.  If such a Request is received, the\n   router responds directly\
    \ to the requestor's address and port.\n   The Request is processed entry by entry.\
    \  If there are no entries, no\n   response is given.  There is one special case.\
    \  If there is exactly\n   one entry in the request, and it has an address family\
    \ identifier of\n   zero and a metric of infinity (i.e., 16), then this is a request\
    \ to\n   send the entire routing table.  In that case, a call is made to the\n\
    \   output process to send the routing table to the requesting\n   address/port.\
    \  Except for this special case, processing is quite\n   simple.  Examine the\
    \ list of RTEs in the Request one by one.  For\n   each entry, look up the destination\
    \ in the router's routing database\n   and, if there is a route, put that route's\
    \ metric in the metric field\n   of the RTE.  If there is no explicit route to\
    \ the specified\n   destination, put infinity in the metric field.  Once all the\
    \ entries\n   have been filled in, change the command from Request to Response\
    \ and\n   send the datagram back to the requestor.\n   Note that there is a difference\
    \ in metric handling for specific and\n   whole-table requests.  If the request\
    \ is for a complete routing\n   table, normal output processing is done, including\
    \ Split Horizon (see\n   section 3.9 on Split Horizon).  If the request is for\
    \ specific\n   entries, they are looked up in the routing table and the information\n\
    \   is returned as is; no Split Horizon processing is done.  The reason\n   for\
    \ this distinction is the expectation that these requests are\n   likely to be\
    \ used for different purposes.  When a router first comes\n   up, it multicasts\
    \ a Request on every connected network asking for a\n   complete routing table.\
    \  It is assumed that these complete routing\n   tables are to be used to update\
    \ the requestor's routing table.  For\n   this reason, Split Horizon must be done.\
    \  It is further assumed that\n   a Request for specific networks is made only\
    \ by diagnostic software,\n   and is not used for routing.  In this case, the\
    \ requester would want\n   to know the exact contents of the routing table and\
    \ would not want\n   any information hidden or modified.\n"
- title: 3.9.2 Response Messages
  contents:
  - "3.9.2 Response Messages\n   A Response can be received for one of several different\
    \ reasons:\n   - response to a specific query\n   - regular update (unsolicited\
    \ response)\n   - triggered update caused by a route change\n   Processing is\
    \ the same no matter why the Response was generated.\n   Because processing of\
    \ a Response may update the router's routing\n   table, the Response must be checked\
    \ carefully for validity.  The\n   Response must be ignored if it is not from\
    \ the RIP port.  The\n   datagram's IPv4 source address should be checked to see\
    \ whether the\n   datagram is from a valid neighbor; the source of the datagram\
    \ must be\n   on a directly-connected network.  It is also worth checking to see\n\
    \   whether the response is from one of the router's own addresses.\n   Interfaces\
    \ on broadcast networks may receive copies of their own\n   broadcasts/multicasts\
    \ immediately.  If a router processes its own\n   output as new input, confusion\
    \ is likely so such datagrams must be\n   ignored.\n   Once the datagram as a\
    \ whole has been validated, process the RTEs in\n   the Response one by one. \
    \ Again, start by doing validation.\n   Incorrect metrics and other format errors\
    \ usually indicate\n   misbehaving neighbors and should probably be brought to\
    \ the\n   administrator's attention.  For example, if the metric is greater\n\
    \   than infinity, ignore the entry but log the event.  The basic\n   validation\
    \ tests are:\n   - is the destination address valid (e.g., unicast; not net 0\
    \ or 127)\n   - is the metric valid (i.e., between 1 and 16, inclusive)\n   If\
    \ any check fails, ignore that entry and proceed to the next.\n   Again, logging\
    \ the error is probably a good idea.\n   Once the entry has been validated, update\
    \ the metric by adding the\n   cost of the network on which the message arrived.\
    \  If the result is\n   greater than infinity, use infinity.  That is,\n   metric\
    \ = MIN (metric + cost, infinity)\n   Now, check to see whether there is already\
    \ an explicit route for the\n   destination address.  If there is no such route,\
    \ add this route to\n   the routing table, unless the metric is infinity (there\
    \ is no point\n   in adding a route which is unusable).  Adding a route to the\
    \ routing\n   table consists of:\n   - Setting the destination address to the\
    \ destination address in the\n     RTE\n   - Setting the metric to the newly calculated\
    \ metric (as described\n     above)\n   - Set the next hop address to be the address\
    \ of the router from which\n     the datagram came\n   - Initialize the timeout\
    \ for the route.  If the garbage-collection\n     timer is running for this route,\
    \ stop it (see section 3.6 for a\n     discussion of the timers)\n   - Set the\
    \ route change flag\n   - Signal the output process to trigger an update (see\
    \ section 3.8.1)\n   If there is an existing route, compare the next hop address\
    \ to the\n   address of the router from which the datagram came.  If this datagram\n\
    \   is from the same router as the existing route, reinitialize the\n   timeout.\
    \  Next, compare the metrics.  If the datagram is from the\n   same router as\
    \ the existing route, and the new metric is different\n   than the old one; or,\
    \ if the new metric is lower than the old one; do\n   the following actions:\n\
    \   - Adopt the route from the datagram (i.e., put the new metric in and\n   \
    \  adjust the next hop address, if necessary).\n   - Set the route change flag\
    \ and signal the output process to trigger\n     an update\n   - If the new metric\
    \ is infinity, start the deletion process\n     (described above); otherwise,\
    \ re-initialize the timeout\n   If the new metric is infinity, the deletion process\
    \ begins for the\n   route, which is no longer used for routing packets.  Note\
    \ that the\n   deletion process is started only when the metric is first set to\n\
    \   infinity.  If the metric was already infinity, then a new deletion\n   process\
    \ is not started.\n   If the new metric is the same as the old one, it is simplest\
    \ to do\n   nothing further (beyond re-initializing the timeout, as specified\n\
    \   above); but, there is a heuristic which could be applied.  Normally,\n   it\
    \ is senseless to replace a route if the new route has the same\n   metric as\
    \ the existing route; this would cause the route to bounce\n   back and forth,\
    \ which would generate an intolerable number of\n   triggered updates.  However,\
    \ if the existing route is showing signs\n   of timing out, it may be better to\
    \ switch to an equally-good\n   alternative route immediately, rather than waiting\
    \ for the timeout to\n   happen.  Therefore, if the new metric is the same as\
    \ the old one,\n   examine the timeout for the existing route.  If it is at least\n\
    \   halfway to the expiration point, switch to the new route.  This\n   heuristic\
    \ is optional, but highly recommended.\n   Any entry that fails these tests is\
    \ ignored, as it is no better than\n   the current route.\n"
- title: 3.10 Output Processing
  contents:
  - "3.10 Output Processing\n   This section describes the processing used to create\
    \ response\n   messages that contain all or part of the routing table.  This\n\
    \   processing may be triggered in any of the following ways:\n   - By input processing,\
    \ when a Request is received (this Response is\n     unicast to the requestor;\
    \ see section 3.7.1)\n   - By the regular routing update (broadcast/multicast\
    \ every 30\n     seconds) router.\n   - By triggered updates (broadcast/multicast\
    \ when a route changes)\n   When a Response is to be sent to all neighbors (i.e.,\
    \ a regular or\n   triggered update), a Response message is directed to the router\
    \ at\n   the far end of each connected point-to-point link, and is broadcast\n\
    \   (multicast for RIP-2) on all connected networks which support\n   broadcasting.\
    \  Thus, one Response is prepared for each directly-\n   connected network, and\
    \ sent to the appropriate address (direct or\n   broadcast/multicast).  In most\
    \ cases, this reaches all neighboring\n   routers.  However, there are some cases\
    \ where this may not be good\n   enough.  This may involve a network that is not\
    \ a broadcast network\n   (e.g., the ARPANET), or a situation involving dumb routers.\
    \  In such\n   cases, it may be necessary to specify an actual list of neighboring\n\
    \   routers and send a datagram to each one explicitly.  It is left to\n   the\
    \ implementor to determine whether such a mechanism is needed, and\n   to define\
    \ how the list is specified.\n"
- title: 3.10.1 Triggered Updates
  contents:
  - "3.10.1 Triggered Updates\n   Triggered updates require special handling for two\
    \ reasons.  First,\n   experience shows that triggered updates can cause excessive\
    \ load on\n   networks with limited capacity or networks with many routers on\
    \ them.\n   Therefore, the protocol requires that implementors include provisions\n\
    \   to limit the frequency of triggered updates.  After a triggered\n   update\
    \ is sent, a timer should be set for a random interval between 1\n   and 5 seconds.\
    \  If other changes that would trigger updates occur\n   before the timer expires,\
    \ a single update is triggered when the timer\n   expires.  The timer is then\
    \ reset to another random value between 1\n   and 5 seconds.  A triggered update\
    \ should be suppressed if a regular\n   update is due by the time the triggered\
    \ update would be sent.\n   Second, triggered updates do not need to include the\
    \ entire routing\n   table.  In principle, only those routes which have changed\
    \ need to be\n   included.  Therefore, messages generated as part of a triggered\n\
    \   update must include at least those routes that have their route\n   change\
    \ flag set.  They may include additional routes, at the\n   discretion of the\
    \ implementor; however, sending complete routing\n   updates is strongly discouraged.\
    \  When a triggered update is\n   processed, messages should be generated for\
    \ every directly-connected\n   network.  Split Horizon processing is done when\
    \ generating triggered\n   updates as well as normal updates (see section 3.9).\
    \  If, after Split\n   Horizon processing for a given network, a changed route\
    \ will appear\n   unchanged on that network (e.g., it appears with an infinite\
    \ metric),\n   the route need not be sent.  If no routes need be sent on that\n\
    \   network, the update may be omitted.  Once all of the triggered\n   updates\
    \ have been generated, the route change flags should be\n   cleared.\n   If input\
    \ processing is allowed while output is being generated,\n   appropriate interlocking\
    \ must be done.  The route change flags should\n   not be changed as a result\
    \ of processing input while a triggered\n   update message is being generated.\n\
    \   The only difference between a triggered update and other update\n   messages\
    \ is the possible omission of routes that have not changed.\n   The remaining\
    \ mechanisms, described in the next section, must be\n   applied to all updates.\n"
- title: 3.10.2  Generating Response Messages
  contents:
  - "3.10.2  Generating Response Messages\n   This section describes how a Response\
    \ message is generated for a\n   particular directly-connected network:\n   Set\
    \ the version number to either 1 or 2.  The mechanism for deciding\n   which version\
    \ to send is implementation specific; however, if this is\n   the Response to\
    \ a Request, the Response version should match the\n   Request version.  Set the\
    \ command to Response.  Set the bytes labeled\n   \"must be zero\" to zero.  Start\
    \ filling in RTEs.  Recall that there is\n   a limit of 25 RTEs to a Response;\
    \ if there are more, send the current\n   Response and start a new one.  There\
    \ is no defined limit to the\n   number of datagrams which make up a Response.\n\
    \   To fill in the RTEs, examine each route in the routing table.  If a\n   triggered\
    \ update is being generated, only entries whose route change\n   flags are set\
    \ need be included.  If, after Split Horizon processing,\n   the route should\
    \ not be included, skip it.  If the route is to be\n   included, then the destination\
    \ address and metric are put into the\n   RTE.  Routes must be included in the\
    \ datagram even if their metrics\n   are infinite.\n"
- title: 4. Protocol Extensions
  contents:
  - "4. Protocol Extensions\n   This section does not change the RIP protocol per\
    \ se.  Rather, it\n   provides extensions to the message format which allows routers\
    \ to\n   share important additional information.\n   The same header format is\
    \ used for RIP-1 and RIP-2 messages (see\n   section 3.4).  The format for the\
    \ 20-octet route entry (RTE) for\n   RIP-2 is:\n    0                   1    \
    \               2                   3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Address Family Identifier (2) |        Route Tag (2)          |\n   +-------------------------------+-------------------------------+\n\
    \   |                         IP Address (4)                        |\n   +---------------------------------------------------------------+\n\
    \   |                         Subnet Mask (4)                       |\n   +---------------------------------------------------------------+\n\
    \   |                         Next Hop (4)                          |\n   +---------------------------------------------------------------+\n\
    \   |                         Metric (4)                            |\n   +---------------------------------------------------------------+\n\
    \   The Address Family Identifier, IP Address, and Metric all have the\n   meanings\
    \ defined in section 3.4.  The Version field will specify\n   version number 2\
    \ for RIP messages which use authentication or carry\n   information in any of\
    \ the newly defined fields.\n"
- title: 4.1 Authentication
  contents:
  - "4.1 Authentication\n   Since authentication is a per message function, and since\
    \ there is\n   only one 2-octet field available in the message header, and since\
    \ any\n   reasonable authentication scheme will require more than two octets,\n\
    \   the authentication scheme for RIP version 2 will use the space of an\n   entire\
    \ RIP entry.  If the Address Family Identifier of the first (and\n   only the\
    \ first) entry in the message is 0xFFFF, then the remainder of\n   the entry contains\
    \ the authentication.  This means that there can be,\n   at most, 24 RIP entries\
    \ in the remainder of the message.  If\n   authentication is not in use, then\
    \ no entries in the message should\n   have an Address Family Identifier of 0xFFFF.\
    \  A RIP message which\n   contains an authentication entry would begin with the\
    \ following\n   format:\n    0                   1                   2       \
    \            3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Command (1)   | Version (1)   |            unused             |\n   +---------------+---------------+-------------------------------+\n\
    \   |             0xFFFF            |    Authentication Type (2)    |\n   +-------------------------------+-------------------------------+\n\
    \   ~                       Authentication (16)                     ~\n   +---------------------------------------------------------------+\n\
    \   Currently, the only Authentication Type is simple password and it is\n   type\
    \ 2.  The remaining 16 octets contain the plain text password.  If\n   the password\
    \ is under 16 octets, it must be left-justified and padded\n   to the right with\
    \ nulls (0x00).\n"
- title: 4.2 Route Tag
  contents:
  - "4.2 Route Tag\n   The Route Tag (RT) field is an attribute assigned to a route\
    \ which\n   must be preserved and readvertised with a route.  The intended use\
    \ of\n   the Route Tag is to provide a method of separating \"internal\" RIP\n\
    \   routes (routes for networks within the RIP routing domain) from\n   \"external\"\
    \ RIP routes, which may have been imported from an EGP or\n   another IGP.\n \
    \  Routers supporting protocols other than RIP should be configurable to\n   allow\
    \ the Route Tag to be configured for routes imported from\n   different sources.\
    \  For example, routes imported from EGP or BGP\n   should be able to have their\
    \ Route Tag either set to an arbitrary\n   value, or at least to the number of\
    \ the Autonomous System from which\n   the routes were learned.\n   Other uses\
    \ of the Route Tag are valid, as long as all routers in the\n   RIP domain use\
    \ it consistently.  This allows for the possibility of a\n   BGP-RIP protocol\
    \ interactions document, which would describe methods\n   for synchronizing routing\
    \ in a transit network.\n"
- title: 4.3 Subnet mask
  contents:
  - "4.3 Subnet mask\n   The Subnet Mask field contains the subnet mask which is applied\
    \ to\n   the IP address to yield the non-host portion of the address.  If this\n\
    \   field is zero, then no subnet mask has been included for this entry.\n   On\
    \ an interface where a RIP-1 router may hear and operate on the\n   information\
    \ in a RIP-2 routing entry the following rules apply:\n   1) information internal\
    \ to one network must never be advertised into\n      another network,\n   2)\
    \ information about a more specific subnet may not be advertised\n      where\
    \ RIP-1 routers would consider it a host route, and\n   3) supernet routes (routes\
    \ with a netmask less specific than the\n      \"natural\" network mask) must\
    \ not be advertised where they could be\n      misinterpreted by RIP-1 routers.\n"
- title: 4.4 Next Hop
  contents:
  - "4.4 Next Hop\n   The immediate next hop IP address to which packets to the destination\n\
    \   specified by this route entry should be forwarded.  Specifying a\n   value\
    \ of 0.0.0.0 in this field indicates that routing should be via\n   the originator\
    \ of the RIP advertisement.  An address specified as a\n   next hop must, per\
    \ force, be directly reachable on the logical subnet\n   over which the advertisement\
    \ is made.\n   The purpose of the Next Hop field is to eliminate packets being\n\
    \   routed through extra hops in the system.  It is particularly useful\n   when\
    \ RIP is not being run on all of the routers on a network.  A\n   simple example\
    \ is given in Appendix A.  Note that Next Hop is an\n   \"advisory\" field.  That\
    \ is, if the provided information is ignored, a\n   possibly sub-optimal, but\
    \ absolutely valid, route may be taken.  If\n   the received Next Hop is not directly\
    \ reachable, it should be treated\n   as 0.0.0.0.\n"
- title: 4.5 Multicasting
  contents:
  - "4.5 Multicasting\n   In order to reduce unnecessary load on those hosts which\
    \ are not\n   listening to RIP-2 messages, an IP multicast address will be used\
    \ for\n   periodic broadcasts.  The IP multicast address is 224.0.0.9.  Note\n\
    \   that IGMP is not needed since these are inter-router messages which\n   are\
    \ not forwarded.\n   On NBMA networks, unicast addressing may be used.  However,\
    \ if a\n   response addressed to the RIP-2 multicast address is received, it\n\
    \   should be accepted.\n   In order to maintain backwards compatibility, the\
    \ use of the\n   multicast address will be configurable, as described in section\
    \ 5.1.\n   If multicasting is used, it should be used on all interfaces which\n\
    \   support it.\n"
- title: 4.6 Queries
  contents:
  - "4.6 Queries\n   If a RIP-2 router receives a RIP-1 Request, it should respond\
    \ with a\n   RIP-1 Response.  If the router is configured to send only RIP-2\n\
    \   messages, it should not respond to a RIP-1 Request.\n"
- title: 5. Compatibility
  contents:
  - "5. Compatibility\n   RFC [1] showed considerable forethought in its specification\
    \ of the\n   handling of version numbers.  It specifies that RIP messages of\n\
    \   version 0 are to be discarded, that RIP messages of version 1 are to\n   be\
    \ discarded if any Must Be Zero (MBZ) field is non-zero, and that\n   RIP messages\
    \ of any version greater than 1 should not be discarded\n   simply because an\
    \ MBZ field contains a value other than zero.  This\n   means that the new version\
    \ of RIP is totally backwards compatible\n   with existing RIP implementations\
    \ which adhere to this part of the\n   specification.\n"
- title: 5.1 Compatibility Switch
  contents:
  - "5.1 Compatibility Switch\n   A compatibility switch is necessary for two reasons.\
    \  First, there\n   are implementations of RIP-1 in the field which do not follow\
    \ RFC [1]\n   as described above.  Second, the use of multicasting would prevent\n\
    \   RIP-1 systems from receiving RIP-2 updates (which may be a desired\n   feature\
    \ in some cases).  This switch should be configurable on a\n   per-interface basis.\n\
    \   The switch has four settings: RIP-1, in which only RIP-1 messages are\n  \
    \ sent; RIP-1 compatibility, in which RIP-2 messages are broadcast;\n   RIP-2,\
    \ in which RIP-2 messages are multicast; and \"none\", which\n   disables the\
    \ sending of RIP messages.  It is recommended that the\n   default setting be\
    \ either RIP-1 or RIP-2, but not RIP-1\n   compatibility.  This is because of\
    \ the potential problems which can\n   occur on some topologies.  RIP-1 compatibility\
    \ should only be used\n   when all of the consequences of its use are well understood\
    \ by the\n   network administrator.\n   For completeness, routers should also\
    \ implement a receive control\n   switch which would determine whether to accept,\
    \ RIP-1 only, RIP-2\n   only, both, or none.  It should also be configurable on\
    \ a per-\n   interface basis.  It is recommended that the default be compatible\n\
    \   with the default chosen for sending updates.\n"
- title: 5.2 Authentication
  contents:
  - "5.2 Authentication\n   The following algorithm should be used to authenticate\
    \ a RIP message.\n   If the router is not configured to authenticate RIP-2 messages,\
    \ then\n   RIP-1 and unauthenticated RIP-2 messages will be accepted;\n   authenticated\
    \ RIP-2 messages shall be discarded.  If the router is\n   configured to authenticate\
    \ RIP-2 messages, then RIP-1 messages and\n   RIP-2 messages which pass authentication\
    \ testing shall be accepted;\n   unauthenticated and failed authentication RIP-2\
    \ messages shall be\n   discarded.  For maximum security, RIP-1 messages should\
    \ be ignored\n   when authentication is in use (see section 4.1); otherwise, the\n\
    \   routing information from authenticated messages will be propagated by\n  \
    \ RIP-1 routers in an unauthenticated manner.\n   Since an authentication entry\
    \ is marked with an Address Family\n   Identifier of 0xFFFF, a RIP-1 system would\
    \ ignore this entry since it\n   would belong to an address family other than\
    \ IP.  It should be noted,\n   therefore, that use of authentication will not\
    \ prevent RIP-1 systems\n   from seeing RIP-2 messages.  If desired, this may\
    \ be done using\n   multicasting, as described in sections 4.5 and 5.1.\n"
- title: 5.3 Larger Infinity
  contents:
  - "5.3 Larger Infinity\n   While on the subject of compatibility, there is one item\
    \ which people\n   have requested: increasing infinity.  The primary reason that\
    \ this\n   cannot be done is that it would violate backwards compatibility.  A\n\
    \   larger infinity would obviously confuse older versions of rip.  At\n   best,\
    \ they would ignore the route as they would ignore a metric of\n   16.  There\
    \ was also a proposal to make the Metric a single octet and\n   reuse the high\
    \ three octets, but this would break any implementations\n   which treat the metric\
    \ as a 4-octet entity.\n"
- title: 5.4 Addressless Links
  contents:
  - "5.4 Addressless Links\n   As in RIP-1, addressless links will not be supported\
    \ by RIP-2.\n"
- title: 6. Interaction between version 1 and version 2
  contents:
  - "6. Interaction between version 1 and version 2\n   Because version 1 packets\
    \ do not contain subnet information, the\n   semantics employed by routers on\
    \ networks that contain both version 1\n   and version 2 networks should be limited\
    \ to that of version 1.\n   Otherwise it is possible either to create blackhole\
    \ routes (i.e.,\n   routes for networks that do not exist) or to create excessive\
    \ routing\n   information in a version 1 environment.\n   Some implementations\
    \ attempt to automatically summarize groups of\n   adjacent routes into single\
    \ entries, the goal being to reduce the\n   total number of entries.  This is\
    \ called auto-summarization.\n   Specifically, when using both version 1 and version\
    \ 2 within a\n   network, a single subnet mask should be used throughout the network.\n\
    \   In addition, auto-summarization mechanisms should be disabled for\n   such\
    \ networks, and implementations must provide mechanisms to disable\n   auto-summarization.\n"
- title: 7. Security Considerations
  contents:
  - "7. Security Considerations\n   The basic RIP protocol is not a secure protocol.\
    \  To bring RIP-2 in\n   line with more modern routing protocols, an extensible\
    \ authentication\n   mechanism has been incorporated into the protocol enhancements.\
    \  This\n   mechanism is described in sections 4.1 and 5.2.  Security is further\n\
    \   enhanced by the mechanism described in [3].\n"
- title: Appendix A
  contents:
  - "Appendix A\n   This is a simple example of the use of the next hop field in a\
    \ rip\n   entry.\n      -----   -----   -----           -----   -----   -----\n\
    \      |IR1|   |IR2|   |IR3|           |XR1|   |XR2|   |XR3|\n      --+--   --+--\
    \   --+--           --+--   --+--   --+--\n        |       |       |         \
    \      |       |       |\n      --+-------+-------+---------------+-------+-------+--\n\
    \        <-------------RIP-2------------->\n   Assume that IR1, IR2, and IR3 are\
    \ all \"internal\" routers which are\n   under one administration (e.g. a campus)\
    \ which has elected to use\n   RIP-2 as its IGP. XR1, XR2, and XR3, on the other\
    \ hand, are under\n   separate administration (e.g. a regional network, of which\
    \ the campus\n   is a member) and are using some other routing protocol (e.g.\
    \ OSPF).\n   XR1, XR2, and XR3 exchange routing information among themselves such\n\
    \   that they know that the best routes to networks N1 and N2 are via\n   XR1,\
    \ to N3, N4, and N5 are via XR2, and to N6 and N7 are via XR3. By\n   setting\
    \ the Next Hop field correctly (to XR2 for N3/N4/N5, to XR3 for\n   N6/N7), only\
    \ XR1 need exchange RIP-2 routes with IR1/IR2/IR3 for\n   routing to occur without\
    \ additional hops through XR1. Without the\n   Next Hop (for example, if RIP-1\
    \ were used) it would be necessary for\n   XR2 and XR3 to also participate in\
    \ the RIP-2 protocol to eliminate\n   extra hops.\n"
- title: References
  contents:
  - "References\n   [1] Hedrick, C., \"Routing Information Protocol\", STD 34, RFC\
    \ 1058,\n       Rutgers  University, June 1988.\n   [2] Malkin, G., and F. Baker,\
    \ \"RIP Version 2 MIB Extension\", RFC\n       1389, January 1993.\n   [3] Baker,\
    \ F., and R. Atkinson, \"RIP-II MD5 Authentication\", RFC\n       2082, January\
    \ 1997.\n   [4] Bellman, R. E., \"Dynamic Programming\", Princeton University\n\
    \       Press, Princeton, N.J., 1957.\n   [5] Bertsekas, D. P., and Gallaher,\
    \ R. G., \"Data Networks\",\n       Prentice-Hall, Englewood Cliffs, N.J., 1987.\n\
    \   [6] Braden, R., and Postel, J., \"Requirements for Internet Gateways\",\n\
    \       STD 4, RFC 1009, June 1987.\n   [7] Boggs, D. R., Shoch, J. F., Taft,\
    \ E. A., and Metcalfe, R. M.,\n       \"Pup: An Internetwork Architecture\", IEEE\
    \ Transactions on\n       Communications, April 1980.\n   [8] Ford, L. R. Jr.,\
    \ and Fulkerson, D. R., \"Flows in Networks\",\n       Princeton University Press,\
    \ Princeton, N.J., 1962.\n   [9] Xerox Corp., \"Internet Transport Protocols\"\
    , Xerox System\n       Integration Standard XSIS 028112, December 1981.\n   [10]\
    \ Floyd, S., and V. Jacobson, \"The synchronization of Periodic\n        Routing\
    \ Messages,\" ACM Sigcom '93 symposium, September 1993.\n   [11] Baker, F., \"\
    Requirements for IP Version 4 Routers.\" RFC 1812,\n        June 1995.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Gary Scott Malkin\n   Bay Networks\n   8 Federal Street\n\
    \   Billerica, MA 01821\n   Phone:  (978) 916-4237\n   EMail:  gmalkin@baynetworks.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1998).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
