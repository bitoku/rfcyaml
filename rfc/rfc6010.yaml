- title: __initial_text__
  contents:
  - '    Cryptographic Message Syntax (CMS) Content Constraints Extension

    '
- title: Abstract
  contents:
  - "Abstract\n   This document specifies the syntax and semantics for the\n   Cryptographic\
    \ Message Syntax (CMS) content constraints extension.\n   This extension is used\
    \ to determine whether a public key is\n   appropriate to use in the processing\
    \ of a protected content.  In\n   particular, the CMS content constraints extension\
    \ is one part of the\n   authorization decision; it is used when validating a\
    \ digital\n   signature on a CMS SignedData content or validating a message\n\
    \   authentication code (MAC) on a CMS AuthenticatedData content or CMS\n   AuthEnvelopedData\
    \ content.  The signed or authenticated content type\n   is identified by an ASN.1\
    \ object identifier, and this extension\n   indicates the content types that the\
    \ public key is authorized to\n   validate.  If the authorization check is successful,\
    \ the CMS content\n   constraints extension also provides default values for absent\n\
    \   attributes.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6010.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n     1.1.  CMS Data Structures  . . . . . . . . . . . . . .\
    \ . . . . .  5\n     1.2.  CMS Content Constraints Model  . . . . . . . . . .\
    \ . . . . 10\n     1.3.  Attribute Processing . . . . . . . . . . . . . . . .\
    \ . . . 11\n     1.4.  Abstract Syntax Notation . . . . . . . . . . . . . . .\
    \ . . 13\n     1.5.  Terminology  . . . . . . . . . . . . . . . . . . . . . .\
    \ . 13\n   2.  CMS Content Constraints Extension  . . . . . . . . . . . . . .\
    \ 13\n   3.  Certification Path Processing  . . . . . . . . . . . . . . . . 16\n\
    \     3.1.  Inputs . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n  \
    \   3.2.  Initialization . . . . . . . . . . . . . . . . . . . . . . 18\n    \
    \ 3.3.  Basic Certificate Processing . . . . . . . . . . . . . . . 19\n     3.4.\
    \  Preparation for Certificate i+1  . . . . . . . . . . . . . 20\n     3.5.  Wrap-Up\
    \ Procedure  . . . . . . . . . . . . . . . . . . . . 20\n     3.6.  Outputs  .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . 21\n   4.  CMS Content Constraints\
    \ Processing . . . . . . . . . . . . . . 21\n     4.1.  CMS Processing and CCC\
    \ Information Collection  . . . . . . 22\n       4.1.1.  Collection of Signer\
    \ or Originator Information . . . . 24\n       4.1.2.  Collection of Attributes\
    \ . . . . . . . . . . . . . . . 25\n       4.1.3.  Leaf Node Classification .\
    \ . . . . . . . . . . . . . . 25\n     4.2.  Content Type and Constraint Checking\
    \ . . . . . . . . . . . 26\n       4.2.1.  Inputs . . . . . . . . . . . . . .\
    \ . . . . . . . . . . 27\n       4.2.2.  Processing . . . . . . . . . . . . .\
    \ . . . . . . . . . 27\n       4.2.3.  Outputs  . . . . . . . . . . . . . . .\
    \ . . . . . . . . 27\n   5.  Subordination Processing in TAMP . . . . . . . .\
    \ . . . . . . . 28\n   6.  Security Considerations  . . . . . . . . . . . . .\
    \ . . . . . . 29\n   7.  Acknowledgments  . . . . . . . . . . . . . . . . . .\
    \ . . . . . 32\n   8.  References . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . 33\n     8.1.  Normative References . . . . . . . . . . . . . . . .\
    \ . . . 33\n     8.2.  Informative References . . . . . . . . . . . . . . . .\
    \ . . 34\n   Appendix A.  ASN.1 Modules . . . . . . . . . . . . . . . . . . .\
    \ . 35\n     A.1.  ASN.1 Module Using 1993 Syntax . . . . . . . . . . . . . .\
    \ 35\n     A.2.  ASN.1 Module Using 1988 Syntax . . . . . . . . . . . . . . 37\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Cryptographic Message Syntax (CMS) SignedData [RFC5652]\
    \ construct\n   is used to sign many things, including cryptographic module firmware\n\
    \   packages [RFC4108] and certificate management messages [RFC5272].\n   Similarly,\
    \ the CMS AuthenticatedData and CMS AuthEnvelopedData\n   constructs provide authentication,\
    \ which can be affiliated with an\n   originator's static public key.  CMS Content\
    \ Constraints (CCC)\n   information is conveyed via an extension in a certificate\
    \ or trust\n   anchor object that contains the originator's or signer's public\
    \ key.\n   This document assumes a particular authorization model, where each\n\
    \   originator is associated with one or more authorized content types.\n   A\
    \ CMS SignedData, AuthenticatedData, or AuthEnvelopedData will be\n   considered\
    \ valid only if the signature or message authentication code\n   (MAC) verification\
    \ process is successful and the originator is\n   authorized for the encapsulated\
    \ content type.  For example, one\n   originator might be acceptable for verifying\
    \ signatures on firmware\n   packages, but that same originator may be unacceptable\
    \ for verifying\n   signatures on certificate management messages.\n   An originator's\
    \ constraints are derived from the certification path\n   used to validate the\
    \ originator's public key.  Constraints are\n   associated with trust anchors\
    \ [RFC5914], and constraints are\n   optionally included in public key certificates\
    \ [RFC5280].  Using the\n   CMS Content Constraints (CCC) extension, a trust anchor\
    \ lists the\n   content types for which it may be used.  A trust anchor may also\n\
    \   include further constraints associated with each of the content\n   types.\
    \  Certificates in a certification path may contain a CCC\n   extension that further\
    \ constrains the authorization for subordinate\n   certificates in the certification\
    \ path.\n   Delegation of authorizations is accomplished using the CCC\n   certificate\
    \ extension.  An entity may delegate none, some, or all of\n   its authorizations\
    \ to another entity by issuing it a certificate with\n   an appropriate CCC extension.\
    \  Absence of a CCC certificate extension\n   in a certificate means that the\
    \ subject is not authorized for any\n   content type.  If the entity is an end\
    \ entity, it may perform CCC\n   delegation, i.e., through the use of proxy certificates.\
    \  However,\n   usage of proxy certificates is not described in this specification.\n\
    \   While processing the certification path, relying parties MUST ensure\n   that\
    \ authorizations of a subject of a certificate are constrained by\n   the authorizations\
    \ of the issuer of that certificate.  In other\n   words, when a content signature\
    \ or MAC is validated, checks MUST be\n   performed to ensure that the encapsulated\
    \ content type is within the\n   permitted set for the trust anchor (TA) and each\
    \ certificate in the\n   path and that the constraints associated with the specific\
    \ content\n   type, if any, are satisfied by the TA and each certificate in the\n\
    \   path.\n   Additionally, this document provides subordination rules for\n \
    \  processing CCC extensions within the Trust Anchor Management Protocol\n   (TAMP)\
    \ and relies on vocabulary from that document [RFC5934].\n"
- title: 1.1.  CMS Data Structures
  contents:
  - "1.1.  CMS Data Structures\n   CMS encapsulation can be used to compose structures\
    \ of arbitrary\n   breadth and depth.  This is achieved using a variety of content\
    \ types\n   that achieve different compositional goals.  A content type is an\n\
    \   arbitrary structure that is identified using an object identifier.\n   This\
    \ document defines two categories of content types: intermediate\n   content types\
    \ and leaf content types.  Intermediate content types are\n   those designed specifically\
    \ to encapsulate one or more additional\n   content types with the addition of\
    \ some service (such as a\n   signature).  Leaf content types are those designed\
    \ to carry specific\n   information.  (Leaf content types may contain other content\
    \ types.)\n   CCC is not used to constrain MIME encapsulated data, i.e., CCC\n\
    \   processing stops when a MIME encapsulation layer is encountered.\n   SignedData\
    \ [RFC5652] and ContentCollection [RFC4073] are examples of\n   intermediate content\
    \ types.  FirmwarePkgData [RFC4108] and TSTInfo\n   [RFC3161] are examples of\
    \ leaf content types.  Protocol designers may\n   provide an indication regarding\
    \ the classification of content types\n   within the protocol.  Four documents\
    \ define the primary intermediate\n   content types:\n   RFC 5652 [RFC5652]: Cryptographic\
    \ Message Syntax (CMS)\n      - SignedData\n      - EnvelopedData\n      - EncryptedData\n\
    \      - DigestedData\n      - AuthenticatedData\n   RFC 5083 [RFC5083]: The Cryptographic\
    \ Message Syntax (CMS)\n   AuthEnvelopedData Content Type\n      - AuthEnvelopedData\n\
    \   RFC 4073 [RFC4073]: Protecting Multiple Contents with the\n   Cryptographic\
    \ Message Syntax (CMS)\n      - ContentCollection\n      - ContentWithAttributes\n\
    \   RFC 3274 [RFC3274]: Compressed Data Content Type for Cryptographic\n   Message\
    \ Syntax (CMS)\n      - CompressedData\n   Some intermediate nodes can also function\
    \ as leaf nodes in some\n   situations.  EncryptedData, EnvelopedData, and AuthEnvelopedData\n\
    \   nodes will function as intermediate nodes for recipients that can\n   decrypt\
    \ the content and as encrypted leaf nodes for recipients who\n   cannot decrypt\
    \ the content.\n   When using CMS, the outermost structure is always ContentInfo.\n\
    \   ContentInfo consists of an object identifier and an associated\n   content.\
    \  The object identifier describes the structure of the\n   content.  Object identifiers\
    \ are used throughout the CMS family of\n   specifications to identify structures.\n\
    \   Using the content types listed above, ignoring for the moment\n   ContentCollection,\
    \ encapsulation can be used to create structures of\n   arbitrary depth.  Two\
    \ examples based on [RFC4108] are shown in Figure\n   1 and Figure 2.\n   When\
    \ ContentCollection is used in conjunction with the other content\n   types, tree-like\
    \ structures can be defined, as shown in Figure 3.\n   The examples in Figures\
    \ 1, 2, and 3 can each be represented as a\n   tree: the root node is the outermost\
    \ ContentInfo, and the leaf nodes\n   are the encapsulated contents.  The trees\
    \ are shown in Figure 4.\n         +---------------------------------------------------------+\n\
    \         | ContentInfo                                             |\n      \
    \   |                                                         |\n         | +-----------------------------------------------------+\
    \ |\n         | | SignedData                                          | |\n  \
    \       | |                                                     | |\n        \
    \ | | +-------------------------------------------------+ | |\n         | | |\
    \ FirmwarePackage                                 | | |\n         | | |      \
    \                                           | | |\n         | | |            \
    \                                     | | |\n         | | +-------------------------------------------------+\
    \ | |\n         | +-----------------------------------------------------+ |\n\
    \         +---------------------------------------------------------+\n      \
    \          Figure 1.  Example of a Signed Firmware Package\n         +---------------------------------------------------------+\n\
    \         | ContentInfo                                             |\n      \
    \   |                                                         |\n         | +-----------------------------------------------------+\
    \ |\n         | | SignedData                                          | |\n  \
    \       | |                                                     | |\n        \
    \ | | +-------------------------------------------------+ | |\n         | | |\
    \ EncryptedData                                   | | |\n         | | |      \
    \                                           | | |\n         | | | +---------------------------------------------+\
    \ | | |\n         | | | | FirmwarePackage                             | | | |\n\
    \         | | | |                                             | | | |\n      \
    \   | | | |                                             | | | |\n         | |\
    \ | +---------------------------------------------+ | | |\n         | | +-------------------------------------------------+\
    \ | |\n         | +-----------------------------------------------------+ |\n\
    \         +---------------------------------------------------------+\n      \
    \  Figure 2.  Example of a Signed and Encrypted Firmware Package\n         +---------------------------------------------------------+\n\
    \         | ContentInfo                                             |\n      \
    \   |                                                         |\n         | +-----------------------------------------------------+\
    \ |\n         | | SignedData                                          | |\n  \
    \       | |                                                     | |\n        \
    \ | | +-------------------------------------------------+ | |\n         | | |\
    \ ContentCollection                               | | |\n         | | |      \
    \                                           | | |\n         | | | +----------------------+\
    \ +--------------------+ | | |\n         | | | | SignedData           | | SignedData\
    \         | | | |\n         | | | |                      | |                 \
    \   | | | |\n         | | | | +------------------+ | | +----------------+ | |\
    \ | |\n         | | | | | EncryptedData    | | | | Firmware       | | | | |\n\
    \         | | | | |                  | | | | Package        | | | | |\n      \
    \   | | | | | +--------------+ | | | |                | | | | |\n         | |\
    \ | | | | Firmware     | | | | +----------------+ | | | |\n         | | | | |\
    \ | Package      | | | +--------------------+ | | |\n         | | | | | |    \
    \          | | |                        | | |\n         | | | | | +--------------+\
    \ | |                        | | |\n         | | | | +------------------+ |  \
    \                      | | |\n         | | | +----------------------+        \
    \                | | |\n         | | +-------------------------------------------------+\
    \ | |\n         | +-----------------------------------------------------+ |\n\
    \         +---------------------------------------------------------+\n      \
    \   Figure 3.  Example of Two Firmware Packages in a Collection\n         +---------------------------------------------------------+\n\
    \         |                                                         |\n      \
    \   |     CMS PATH RESULTING            CMS PATH RESULTING    |\n         |  \
    \     FROM FIGURE 1.                FROM FIGURE 2.      |\n         |        \
    \                                                 |\n         |       ContentInfo\
    \                   ContentInfo         |\n         |           |            \
    \                 |               |\n         |           V                  \
    \           V               |\n         |       SignedData                   \
    \ SignedData          |\n         |           |                             |\
    \               |\n         |           V                             V      \
    \         |\n         |       FirmwarePackage               EncryptedData    \
    \   |\n         |                                         |               |\n\
    \         |                                         V               |\n      \
    \   |                                     FirmwarePackage     |\n         |  \
    \                                                       |\n         |        \
    \                                                 |\n         |            CMS\
    \ PATHS RESULTING FROM FIGURE 3.           |\n         |                     \
    \                                    |\n         |                       ContentInfo\
    \                       |\n         |                           |            \
    \                 |\n         |                           V                  \
    \           |\n         |                       SignedData                   \
    \     |\n         |                           |                             |\n\
    \         |                           V                             |\n      \
    \   |                       ContentCollection                 |\n         |  \
    \                         |                             |\n         |        \
    \        +----------+--------------+              |\n         |              \
    \  |                         |              |\n         |                V   \
    \                      V              |\n         |            SignedData    \
    \            SignedData         |\n         |                |               \
    \          |              |\n         |                V                     \
    \    V              |\n         |            EncryptedData             FirmwarePackage\
    \    |\n         |                |                                        |\n\
    \         |                V                                        |\n      \
    \   |            FirmwarePackage                              |\n         |  \
    \                                                       |\n         +---------------------------------------------------------+\n\
    \                     Figure 4.  Example CMS Path Structures\n   These examples\
    \ do not illustrate all of the details of CMS\n   structures; most CMS protecting\
    \ content types, and some leaf-node\n   content types, contain attributes.  Attributes\
    \ from intermediate\n   nodes can influence processing and handling of the CMS\
    \ protecting\n   content type or the encapsulated content type.  Attributes from\
    \ leaf\n   nodes may be checked independent of the CCC processing, but such\n\
    \   processing is not addressed in this document.  Throughout this\n   document,\
    \ paths through the tree structure from a root node to a leaf\n   node in a CMS-protected\
    \ message are referred to as CMS paths.\n"
- title: 1.2.  CMS Content Constraints Model
  contents:
  - "1.2.  CMS Content Constraints Model\n   The CCC extension is used to restrict\
    \ the types of content for which\n   a particular public key can be used to verify\
    \ a signature or MAC.\n   Trust in a public key is established by building and\
    \ validating a\n   certification path from a trust anchor to the subject public\
    \ key.\n   Section 6 of [RFC5280] describes the algorithm for certification path\n\
    \   validation, and the basic path validation algorithm is augmented, as\n   described\
    \ in Section 3 of this document, to include processing\n   required to determine\
    \ the CMS content constraints that have been\n   delegated to the subject public\
    \ key.  If the subject public key is\n   explicitly trusted (the public key belongs\
    \ to a trust anchor), then\n   any CMS content constraints associated with the\
    \ trust anchor are used\n   directly.  If the subject public key is not explicitly\
    \ trusted, then\n   the CMS content constraints are determined by calculating\
    \ the\n   intersection of the CMS content constraints included in all the\n  \
    \ certificates in a valid certification path from the trust anchor to\n   the\
    \ subject public key, including those associated with the trust\n   anchor.\n\
    \   CMS enables the use of multiple nested signatures or MACs.  Each\n   signature\
    \ or MAC can protect and associate attributes with an\n   encapsulated data object.\
    \  The CMS content constraints extension is\n   associated with a public key,\
    \ and that public key is used to verify a\n   signature or a MAC.\n   The CMS\
    \ content constraints mechanism can be used to place limits on\n   the use of\
    \ the subject public key used for authentication or\n   signature verification\
    \ for one or more specific content types.\n   Furthermore, within each permitted\
    \ content type, a permitted set of\n   values can be expressed for one or more\
    \ specific attribute types.\n   When a leaf content type is encapsulated by multiple\
    \ intermediate\n   authentication layers, the signer or originator closest to\
    \ a leaf\n   node must be authorized to serve as a source for the leaf content\n\
    \   type; outer signers or originators need not be authorized to serve as\n  \
    \ a source, but must be authorized for the leaf content type.  All\n   signers\
    \ or originators must be authorized for the attributes that\n   appear in a CMS\
    \ path.\n   A signer or originator may be constrained to use a specific set of\n\
    \   attribute values for some attribute types when producing a particular\n  \
    \ content type.  If a signer or originator is constrained for a\n   particular\
    \ attribute that does not appear in a protected content of\n   the type for which\
    \ the constraint is defined, the constraint serves\n   as a default attribute,\
    \ i.e., the payload should be processed as if\n   an attribute equal to the constraint\
    \ appeared in the protected\n   content.  However, in some cases, the processing\
    \ rules for a\n   particular content type may disallow the usage of default values\
    \ for\n   some attribute types and require a signer to explicitly assert the\n\
    \   attribute to satisfy the constraint.  Signer constraints are output\n   for\
    \ use in leaf node processing or other processing not addressed by\n   this specification.\n\
    \   Three models for processing attributes were considered:\n   o  Each signer\
    \ or originator must be authorized for attributes it\n      asserts.\n   o  Each\
    \ signer or originator must be authorized for attributes it\n      asserts and\
    \ attributes contained in the content it authenticates.\n   o  Each signer or\
    \ originator must be authorized for attributes it\n      asserts, attributes contained\
    \ in the content it authenticates, and\n      attributes contained in content\
    \ that authenticates it, i.e., all\n      signers or originators must be authorized\
    \ for all attributes\n      appearing in the CMS path.\n   The third model is\
    \ used in this specification.\n"
- title: 1.3.  Attribute Processing
  contents:
  - "1.3.  Attribute Processing\n   This specification defines a mechanism for enforcing\
    \ constraints on\n   content types and attributes.  Where content types are\n\
    \   straightforward to process because there is precisely one content\n   type\
    \ of interest for a given CMS path, attributes are more\n   challenging.  Attributes\
    \ can be asserted at many different points in\n   a CMS path.  Some attributes\
    \ may, by their nature, be applicable to a\n   specific node of a CMS path; for\
    \ example, ContentType and\n   MessageDigest attributes apply to a specific SignerInfo\
    \ object.\n   Other attributes may apply to a less well-defined target; for\n\
    \   example, a ContentCollection may appear as the payload within a\n   ContentWithAttributes\
    \ object.\n   Since there is no automated means of determining what an arbitrary\n\
    \   attribute applies to or how the attribute should be used, CCC\n   processing\
    \ simply collects attributes and makes them available for\n   applications to\
    \ use during leaf node processing.  Implementations\n   SHOULD refrain from collecting\
    \ attributes that are known to be\n   inapplicable to leaf node processing, for\
    \ example, ContentType and\n   MessageDigest attributes.\n   Some attributes contain\
    \ multiple values.  Attribute constraints\n   expressed in a CCC extension may\
    \ contain multiple values.  Attributes\n   expressed in a constraint that do not\
    \ appear in a CMS path are\n   returned as default attributes.  Default attributes\
    \ may have multiple\n   values.  Attributes are returned to an application via\
    \ two output\n   variables: cms_effective_attributes and cms_default_attributes.\
    \  An\n   attribute may be absent, present with one value, or present with\n \
    \  multiple values in a CMS path and/or in CMS content constraints.  A\n   summary\
    \ of the resulting nine possible combinations is below.\n      Attribute absent\
    \ in CMS path; absent in cms_constraints: no\n      action.\n      Attribute absent\
    \ in CMS path; single value in cms_constraints: the\n      value from cms_constraints\
    \ is added to cms_default_attributes.\n      Attribute absent in CMS path; multiple\
    \ values in cms_constraints:\n      the values from cms_constraints are added\
    \ to\n      cms_default_attributes.\n      Attribute is present with a single\
    \ value in CMS path; absent in\n      cms_constraints: the value from CMS path\
    \ is returned in\n      cms_effective_attributes.\n      Attribute is present\
    \ with a single value in CMS path; single value\n      in cms_constraints: the\
    \ value from CMS path must match the value\n      from cms_constraints.  If successful\
    \ match, the value is returned\n      in cms_effective_attribute.  If no match,\
    \ constraints processing\n      fails.\n      Attribute is present with a single\
    \ value in CMS path; multiple\n      values in cms_constraints: the value from\
    \ CMS path must match a\n      value from cms_constraints.  If successful match,\
    \ the value from\n      the CMS path is returned in cms_effective_attribute. \
    \ If no match,\n      constraints processing fails.\n      Attribute is present\
    \ with multiple values in CMS path; absent in\n      cms_constraints: the values\
    \ from CMS path are returned in\n      cms_effective_attributes.\n      Attribute\
    \ is present with multiple values; single value in\n      cms_constraints: the\
    \ values from CMS path must match the value\n      from cms_constraints (i.e.,\
    \ all values must be identical).  If\n      successful match, the values from\
    \ the CMS path are returned in\n      cms_effective_attribute.  If no match, constraints\
    \ processing\n      fails.\n      Attribute is present with multiple values; multiple\
    \ values in\n      cms_constraints: each value from CMS path must match a value\
    \ from\n      cms_constraints.  If each comparison is successful, the values\n\
    \      from the CMS path are returned in cms_effective_attribute.  If a\n    \
    \  comparison fails, constraints processing fails.\n"
- title: 1.4.  Abstract Syntax Notation
  contents:
  - "1.4.  Abstract Syntax Notation\n   All X.509 certificate [RFC5280] extensions\
    \ are defined using ASN.1\n   [X.680][X.690].\n   CMS content types [RFC5652]\
    \ are also defined using ASN.1.\n   CMS uses the Attribute type.  The syntax of\
    \ Attribute is compatible\n   with X.501 [X.501].\n"
- title: 1.5.  Terminology
  contents:
  - "1.5.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\"\
    , and \"OPTIONAL\" in this\n   document are to be interpreted as described in\
    \ RFC 2119 [RFC2119].\n"
- title: 2.  CMS Content Constraints Extension
  contents:
  - "2.  CMS Content Constraints Extension\n   The CMS content constraints extension\
    \ provides a mechanism to\n   constrain authorization during delegation.  If the\
    \ CMS content\n   constraints extension is not present, then the subject of the\
    \ trust\n   anchor or certificate is not authorized for any content type, with\
    \ an\n   exception for apex trust anchors, which are implicitly authorized for\n\
    \   all content types.  A certificate issuer may use the CMS content\n   constraints\
    \ extension for one or more of the following purposes:\n   o  Limit the certificate\
    \ subject to a subset of the content types for\n      which the certificate issuer\
    \ is authorized.\n   o  Add constraints to a previously unconstrained content\
    \ type.\n   o  Add additional constraints to a previously constrained content\n\
    \      type.\n   The CMS content constraints extension MAY be critical, and it\
    \ MUST\n   appear at most one time in a trust anchor or certificate.  The CMS\n\
    \   content constraints extension is identified by the\n   id-pe-cmsContentConstraints\
    \ object identifier:\n         id-pe-cmsContentConstraints OBJECT IDENTIFIER ::=\n\
    \             { iso(1) identified-organization(3) dod(6) internet(1)\n       \
    \        security(5) mechanisms(5) pkix(7) pe(1) 18 }\n   The syntax for the CMS\
    \ content constraints extension is:\n     CMSContentConstraints ::= SEQUENCE SIZE\
    \ (1..MAX) OF\n       ContentTypeConstraint\n     ContentTypeGeneration ::= ENUMERATED\
    \ {\n         canSource(0),\n         cannotSource(1)}\n     ContentTypeConstraint\
    \ ::= SEQUENCE {\n       contentType           OBJECT IDENTIFIER,\n       canSource\
    \             ContentTypeGeneration DEFAULT canSource,\n       attrConstraints\
    \       AttrConstraintList OPTIONAL }\n     AttrConstraintList ::= SEQUENCE SIZE\
    \ (1..MAX) OF AttrConstraint\n     AttrConstraint ::= SEQUENCE {\n       attrType\
    \               AttributeType,\n       attrValues             SET SIZE (1..MAX)\
    \ OF AttributeValue }\n     id-ct-anyContentType OBJECT IDENTIFIER ::= { iso(1)\
    \ member-body(2)\n            us(840) rsadsi(113549) pkcs(1) pkcs-9(9) smime(16)\n\
    \            ct(1) 0 }\n   The CMSContentConstraints is a list of permitted content\
    \ types and\n   associated constraints.  A particular content type MUST NOT appear\n\
    \   more than once in a CMSContentConstraints.  When the extension is\n   present,\
    \ the certificate subject is being authorized by the\n   certificate issuer to\
    \ sign or authenticate the content types in the\n   permitted list as long as\
    \ the provided constraints, if any, are met.\n   The relying party MUST ensure\
    \ that the certificate issuer is\n   authorized to delegate the privileges.  When\
    \ the extension is absent,\n   the certificate subject is not authorized for any\
    \ content type.\n   The special id-ct-anyContentType value indicates the certificate\n\
    \   subject is being authorized for any content type without any\n   constraints.\
    \  Where id-ct-anyContentType appears alongside a specific\n   content type, the\
    \ specific content type is authoritative.  The\n   id-ct-anyContentType object\
    \ identifier can be used in trust anchors\n   when the trust anchor is unconstrained.\
    \  Where id-ct-anyContentType\n   is asserted in the contentType field, the canSource\
    \ field MUST be\n   equal to the canSource enumerated value and attrConstraints\
    \ MUST be\n   absent, indicating that the trust anchor can serve as a source for\n\
    \   any content type without any constraints.\n   The fields of the ContentTypeConstraint\
    \ type have the following\n   meanings:\n   contentType  is an object identifier\
    \ that specifies a permitted\n      content type.  When the extension appears\
    \ in an end entity\n      certificate, it indicates that a content of this type\
    \ can be\n      verified using the public key in the certificate.  When the\n\
    \      extension appears in a certification authority (CA) certificate,\n    \
    \  it indicates that a content of this type can be verified using the\n      public\
    \ key in the CA certificate or the public key in an\n      appropriately authorized\
    \ subordinate certificate.  For example,\n      this field contains id-ct-firmwarePackage\
    \ when the public key can\n      be used to verify digital signatures on firmware\
    \ packages defined\n      in [RFC4108].  A particular content type MUST NOT appear\
    \ more than\n      once in the list.  Intermediate content types MUST NOT be included\n\
    \      in the list of permitted content types.  Since the content type of\n  \
    \    intermediate nodes is not subject to CMS Constraint Processing,\n      originators\
    \ need not be authorized for intermediate node content\n      types.  The intermediate\
    \ content types are:\n         id-signedData,\n         id-envelopedData,\n  \
    \       id-digestedData,\n         id-encryptedData,\n         id-ct-authEnvelopedData,\n\
    \         id-ct-authData,\n         id-ct-compressedData,\n         id-ct-contentCollection,\
    \ and\n         id-ct-contentWithAttrs.\n   canSource  is an enumerated value.\
    \  If the canSource field is equal\n      to canSource, then the subject can be\
    \ the innermost authenticator\n      of the specified content type.  For a subject\
    \ to be authorized to\n      source a content type, the issuer of the subject\
    \ certificate MUST\n      also be authorized to source the content type.  Regardless\
    \ of the\n      flag value, a subject can sign or authenticate a content that\
    \ is\n      already authenticated (when SignedData, AuthenticatedData, or\n  \
    \    AuthEnvelopedData is already present).\n   attrConstraints  is an optional\
    \ field that contains constraints that\n      are specific to the content type.\
    \  If the attrConstraints field is\n      absent, the public key can be used to\
    \ verify the specified content\n      type without further checking.  If the attrConstraints\
    \ field is\n      present, then the public key can only be used to verify the\n\
    \      specified content type if all of the constraints are satisfied.  A\n  \
    \    particular constraint type, i.e., attrValues structure for a\n      particular\
    \ attribute type, MUST NOT appear more than once in the\n      attrConstraints\
    \ for a specified content type.  Constraints are\n      checked by matching the\
    \ values in the constraint against the\n      corresponding attribute value(s)\
    \ in the CMS path.  Constraints\n      processing fails if the attribute is present\
    \ and the value is not\n      one of the values provided in the constraint.  Constraint\
    \ checking\n      is described fully in Section 4.\n      The fields of the AttrConstraint\
    \ type have the following meanings:\n      attrType  is an AttributeType, which\
    \ is an object identifier that\n         names an attribute.  For a content encapsulated\
    \ in a CMS\n         SignedData, AuthenticatedData, or AuthEnvelopedData to satisfy\n\
    \         the constraint, if the attributes that are covered by the\n        \
    \ signature or MAC include an attribute of the same type, then\n         the attribute\
    \ value MUST be equal to one of the values supplied\n         in the attrValues\
    \ field.  Attributes that are not covered by\n         the signature or MAC are\
    \ not checked against constraints.\n         Attribute types that do not appear\
    \ as an AttrConstraint are\n         unconstrained, i.e., the signer or originator\
    \ is free to assert\n         any value.\n      attrValues  is a set of AttributeValue.\
    \  The structure of each of\n         the values in attrValues is determined by\
    \ attrType.  Constraint\n         checking is described fully in Section 4.\n"
- title: 3.  Certification Path Processing
  contents:
  - "3.  Certification Path Processing\n   When CMS content constraints are used for\
    \ authorization, the\n   processing described in this section SHOULD be included\
    \ in the\n   certification path validation.  The processing is presented as an\n\
    \   augmentation to the certification path validation algorithm described\n  \
    \ in Section 6 of [RFC5280], as shown in the figure below.  Alternative\n   implementations\
    \ are allowed but MUST yield the same results as\n   described below.\n   CCC-related\
    \ inputs\n   + inhibitAnyContentType flag\n   + absenceEqualsUnconstrained flag\n\
    \   + Trust anchor CCC extension\n   + Content type of interest (cms_content_type)\n\
    \   + Attributes of interest (cms_effective_attributes)\n                    \
    \ |\n                     |\n      _______________V________________________\n\
    \     |                                        |\n     | CCC-aware Certification\
    \ Path Processor |\n     |________________________________________|\n        \
    \             |\n                     |\n                     V\n   CCC-related\
    \ outputs upon success\n   + Applicable content type constraints (subject_constraints)\n\
    \   + Constrained attributes not present in cms_effective_attributes\n      (subject_default_attributes)\n\
    \   + Content types not propagated to end entity (excluded_content_types)\n  \
    \       Figure 5.  Certification Path Processing Inputs and Outputs\n   Certification\
    \ path processing validates the binding between the\n   subject and subject public\
    \ key.  If a valid certification path cannot\n   be found, then the corresponding\
    \ CMS path MUST be rejected.\n"
- title: 3.1.  Inputs
  contents:
  - "3.1.  Inputs\n   Two boolean values are provided as input: inhibitAnyContentType\
    \ and\n   absenceEqualsUnconstrained.\n   The inhibitAnyContentType flag is used\
    \ to govern processing of the\n   special id-ct-anyContentType value.  When inhibitAnyContentType\
    \ is\n   true, id-ct-anyContentType is not considered to match a content type.\n\
    \   When inhibitAnyContentType is false, id-ct-anyContentType is\n   considered\
    \ to match any content type.\n   The absenceEqualsUnconstrained flag is used to\
    \ govern the meaning of\n   CCC absence.  When absenceEqualsUnconstrained is true,\
    \ a trust anchor\n   without a CCC extension is considered to be unconstrained\
    \ and a\n   certificate without a CCC extension is considered to have the same\n\
    \   CCC privileges as its issuer.  When absenceEqualsUnconstrained is\n   false,\
    \ a trust anchor or certificate without a CCC extension is not\n   authorized\
    \ for any content types.\n   Neither of these flags has any bearing on an apex\
    \ trust anchor, which\n   is always unconstrained by definition.\n   If a trust\
    \ anchor used for path validation is authorized, then the\n   trust anchor MAY\
    \ include a CCC extension.  A trust anchor may be\n   constrained or unconstrained.\
    \  If unconstrained, the trust anchor\n   MUST either include a CMS Content Constraints\
    \ extension containing\n   the special id-ct-anyContentType value and inhibitAnyContentType\
    \ is\n   false or the trust anchor MUST have no CCC extension and\n   absenceEqualsUnconstrained\
    \ is true.  If the trust anchor does not\n   contain a CMS Content Constraints\
    \ structure and\n   absenceEqualsUnconstrained is false, the CMS content constraints\n\
    \   processing fails.  If the trust anchor contains a CCC extension with\n   a\
    \ single entry containing id-ct-anyContentType and\n   inhibitAnyContentType is\
    \ true, the CMS content constraints processing\n   fails.\n   The content type\
    \ of the protected content being verified can be\n   provided as input along with\
    \ the set of attributes collected from the\n   CMS path in order to determine\
    \ if the certification path is valid for\n   a given context.  Alternatively,\
    \ the id-ct-anyContentType value can\n   be provided as the content type input,\
    \ along with an empty set of\n   attributes, to determine the full set of constraints\
    \ associated with\n   a public key in the end entity certificate in the certification\
    \ path\n   being validated.\n   Trust anchors may produce CMS-protected contents.\
    \  When validating\n   messages originated by a trust anchor, certification path\
    \ validation\n   as described in Section 6 of [RFC5280] is not necessary, but\n\
    \   constraints processing MUST still be performed for the trust anchor.\n   In\
    \ such cases, the initialization and wrap-up steps described below\n   can be\
    \ performed to determine if the public key in the trust anchor\n   is appropriate\
    \ to use in the processing of a protected content.\n"
- title: 3.2.  Initialization
  contents:
  - "3.2.  Initialization\n   Create an input variable named cms_content_type and\
    \ set it equal to\n   the content type provided as input.\n   Create an input\
    \ variable named cms_effective_attributes and set it\n   equal to the set of attributes\
    \ provided as input.\n   Create a state variable named working_permitted_content_types.\
    \  The\n   initial value of working_permitted_content_types is the permitted\n\
    \   content type list from the trust anchor, including any associated\n   constraints.\n\
    \   Create a state variable named excluded_content_types.  The initial\n   value\
    \ of excluded_content_types is empty.\n   Create a state variable of type SEQUENCE\
    \ OF AttrConstraint named\n   subject_default_attributes and initialize it to\
    \ empty.\n   Create a state variable of type SEQUENCE OF ContentTypeConstraint\n\
    \   named subject_constraints and initialize it to empty.\n"
- title: 3.3.  Basic Certificate Processing
  contents:
  - "3.3.  Basic Certificate Processing\n   If the CCC extension is not present in\
    \ the certificate, check the\n   value of absenceEqualsUnconstrained.  If false,\
    \ set\n   working_permitted_content_types to empty.  If true,\n   working_permitted_content_types\
    \ is unchanged.  In either case, no\n   further CCC processing is required for\
    \ the certificate.\n   If inhibitAnyContenType is true, discard any entries in\
    \ the CCC\n   extension with a content type value equal to id-ct-anyContentType.\n\
    \   For each entry in the permitted content type list sequence in the CMS\n  \
    \ content constraints extension, the following steps are performed:\n   -  If\
    \ the entry contains the special id-ct-anyContentType value, skip\n      to the\
    \ next entry.\n   -  If the entry contains a content type that is present in\n\
    \      excluded_content_types, skip to the next entry.\n   -  If the entry includes\
    \ a content type that is not present in\n      working_permitted_content_types,\
    \ determine if\n      working_permitted_content_types contains an entry equal\
    \ to the\n      special id-ct-anyContentType value.  If no, no action is taken\
    \ and\n      working_permitted_content_types is unchanged.  If yes, add the\n\
    \      entry to working_permitted_content_types.\n   -  If the entry includes\
    \ a content type that is already present in\n      working_permitted_content_types,\
    \ then the constraints in the entry\n      can further reduce the authorization\
    \ by adding constraints to\n      previously unconstrained attributes or by removing\
    \ attribute\n      values from the attrValues set of a constrained attribute.\
    \  The\n      canSource flag is set to cannotSource unless it is canSource in\n\
    \      the working_permitted_content_types entry and in the entry.  The\n    \
    \  processing actions to be performed for each constraint in the\n      AttrConstraintList\
    \ follow:\n      -- If the constraint includes an attribute type that is not\n\
    \         present in the corresponding working_permitted_content_types\n     \
    \    entry, add the attribute type and the associated set of\n         attribute\
    \ values to working_permitted_content_types entry.\n      -- If the constraint\
    \ includes an attribute type that is already\n         present in the corresponding\
    \ working_permitted_content_types\n         entry, then compute the intersection\
    \ of the set of attribute\n         values from the working_permitted_content_types\
    \ entry and the\n         constraint.  If the intersection contains at least one\n\
    \         attribute value, then the set of attribute values in\n         working_permitted_content_types\
    \ entry is assigned the\n         intersection.  If the intersection is empty,\
    \ then the entry is\n         removed from working_permitted_content_types and\
    \ the content\n         type from the entry is added to excluded_content_types.\n\
    \   Remove each entry in working_permitted_content_types that includes a\n   content\
    \ type that is not present in the CMS content constraints\n   extension.  For\
    \ values other than id-ct-anyContentType, add the\n   removed content type to\
    \ excluded_content_types.\n"
- title: 3.4.  Preparation for Certificate i+1
  contents:
  - "3.4.  Preparation for Certificate i+1\n   No additional action associated with\
    \ the CMS content constraints\n   extension is taken during this phase of certification\
    \ path validation\n   as described in Section 6 of [RFC5280].\n"
- title: 3.5.  Wrap-Up Procedure
  contents:
  - "3.5.  Wrap-Up Procedure\n   If cms_content_type equals the special value anyContentType,\
    \ the CCC\n   processing portion of path validation succeeds.  Set\n   subject_constraints\
    \ equal to working_permitted_content_types.  If\n   cms_content_type is not equal\
    \ to the special value anyContentType,\n   perform the following steps:\n   -\
    \  If cms_content_type is present in excluded_content_types, the CCC\n      processing\
    \ portion of path validation fails.\n   -  If working_permitted_content_types\
    \ is equal to the special value\n      anyContentType, set subject_constraints\
    \ equal to\n      working_permitted_content_types; the CCC processing portion\
    \ of\n      path validation succeeds.\n   -  If cms_content_type does not equal\
    \ the content type of an entry in\n      working_permitted_content_types, constraints\
    \ processing fails and\n      path validation fails.\n   -  If cms_content_type\
    \ equals the content type of an entry in\n      working_permitted_content_types,\
    \ add the entry from\n      working_permitted_content_types to subject_constraints.\
    \  If the\n      corresponding entry in working_permitted_content_types contains\n\
    \      the special value anyContentType, set subject_constraints equal to\n  \
    \    cms_content_type; the CCC processing portion of path validation\n      succeeds.\n\
    \   -  If the attrConstraints field of the corresponding entry in\n      working_permitted_content_types\
    \ is absent; the CCC processing\n      portion of path validation succeeds.\n\
    \   -  If the attrConstraints field of the corresponding entry in\n      working_permitted_content_types\
    \ is present, then the constraints\n      MUST be checked.  For each attrType\
    \ in the attrConstraints, the\n      constraint is satisfied if either the attribute\
    \ type is absent\n      from cms_effective_attributes or each attribute value\
    \ in the\n      attrValues field of the corresponding entry in\n      cms_effective_attributes\
    \ is equal to one of the values for this\n      attribute type in the attrConstraints\
    \ field.  If\n      cms_effective_attributes does not contain an attribute of\
    \ that\n      type, then the entry from attrConstraints is added to the\n    \
    \  subject_default_attributes for use in processing the payload.\n"
- title: 3.6.  Outputs
  contents:
  - "3.6.  Outputs\n   If certification path validation processing succeeds, return\
    \ the\n   value of the subject_constraints, subject_default_attributes, and\n\
    \   excluded_content_types variables.\n"
- title: 4.  CMS Content Constraints Processing
  contents:
  - "4.  CMS Content Constraints Processing\n   CMS contents constraints processing\
    \ is performed on a per-CMS-path\n   basis.  The processing consists of traditional\
    \ CMS processing\n   augmented by collection of information required to perform\
    \ content\n   type and constraint checking.  Content type and constraint checking\n\
    \   uses the collected information to build and validate a certification\n   path\
    \ to each public key used to authenticate nodes in the CMS path\n   per the certification\
    \ path processing steps described above.\n"
- title: 4.1.  CMS Processing and CCC Information Collection
  contents:
  - "4.1.  CMS Processing and CCC Information Collection\n   Traditional CMS content\
    \ processing is augmented by the following\n   three steps to support enforcement\
    \ of CMS content constraints:\n      Collection of signer or originator keys\n\
    \      Collection of attributes\n      Leaf node classification\n   CMS processing\
    \ and CCC information collection takes a CMS path as\n   input and returns a collection\
    \ of public keys used to authenticate\n   protected content, a collection of authenticated\
    \ attributes, and the\n   leaf node, as shown in the figure below.\n   Inputs\n\
    \   + CMS path\n             |\n             |\n    _________V___________________\n\
    \   |                             |\n   | CMS processing and CCC      |\n   |\
    \  information collection     |\n   |_____________________________|\n        \
    \     |\n             |\n             V\n   Outputs upon success\n   + Leaf node\n\
    \   + Public keys used to authenticate content (cms_public_keys)\n   + Authenticated\
    \ attributes (cms_effective_attributes)\n         Figure 6.  CMS Processing and\
    \ CCC Information Collection\n   Processing is performed for each CMS path from\
    \ the root node of a\n   CMS-protected content to a leaf node, proceeding from\
    \ the root node\n   to the leaf node.  Each path is processed independently of\
    \ the other\n   paths.  Thus, it is possible that some leaf nodes in a content\n\
    \   collection may be acceptable while other nodes are not acceptable.\n   The\
    \ processing described in this section applies to CMS paths that\n   contain at\
    \ least one SignedData, AuthEnvelopedData, or\n   AuthenticatedData node.  Since\
    \ countersignatures are defined as not\n   having a content, CMS content constraints\
    \ are not used with\n   countersignatures.\n   Signer or originator public keys\
    \ are collected when verifying\n   signatures or message authentication codes\
    \ (MACs).  These keys will\n   be used to determine the constraints of each signer\
    \ or originator by\n   building and validating a certification path to the public\
    \ key.\n   Public key values, public key certificates, or public key identifiers\n\
    \   are accumulated in a state variable named cms_public_keys, which is\n   either\
    \ initialized to empty or to an application-provided set of keys\n   when processing\
    \ begins.  The variable will be updated each time a\n   SignedData, AuthEnvelopedData,\
    \ or AuthenticatedData node is\n   encountered in the CMS path.\n   All authenticated\
    \ attributes appearing in a CMS path are collected,\n   beginning with the attributes\
    \ protected by the outermost SignedData,\n   AuthEnvelopedData, or AuthenticatedData\
    \ and proceeding to the leaf\n   node.  During processing, attributes collected\
    \ from the nodes in the\n   CMS path are maintained in a state variable named\n\
    \   cms_effective_attributes, and default attributes derived from message\n  \
    \ originator authorizations are collected in a state variable named\n   cms_default_attributes.\
    \  A default attribute value comes from a\n   constraint that does not correspond\
    \ to an attribute contained in the\n   CMS path and may be used during payload\
    \ processing in lieu of an\n   explicitly included attribute.  This prevents an\
    \ originator from\n   avoiding a constraint through omission.  When processing\
    \ begins,\n   cms_effective_attributes and cms_default_attributes are initialized\n\
    \   to empty.  Alternatively, cms_effective_attributes may be initialized\n  \
    \ to an application-provided sequence of attributes.  The\n   cms_effective_attributes\
    \ value will be updated each time an attribute\n   set is encountered in a SignedData,\
    \ AuthEnvelopedData,\n   AuthenticatedData, or (authenticated) ContentWithAttributes\
    \ node\n   while processing a CMS path.\n   The output of content type and constraint\
    \ checking always includes a\n   set of attributes collected from the various\
    \ nodes in a CMS path.\n   When processing terminates at an encrypted node, the\
    \ set of signer or\n   originator public keys is also returned.  When processing\
    \ terminates\n   at a leaf node, a set of default attribute values is also returned\n\
    \   along with a set of constraints that apply to the CMS-protected\n   content.\n\
    \   The output from CMS Content Constraints processing will depend on the\n  \
    \ type of the leaf node that terminates the CMS path.  Four different\n   output\
    \ variables are possible.  The conditions under which each is\n   returned is\
    \ described in the following sections.  The variables are:\n   cms_public_keys\
    \  is a list of public key values, public key\n      certificates, or public key\
    \ identifiers.  Information maintained\n      in cms_public_keys will be used\
    \ to perform the certification path\n      operations required to determine if\
    \ a particular signer or\n      originator is authorized to produce a specific\
    \ object.\n   cms_effective_attributes  contains the attributes collected from\
    \ the\n      nodes in a CMS path. cms_effective_attributes is a SEQUENCE OF\n\
    \      Attribute, which is the same as the AttrConstraintList structure\n    \
    \  except that it may have zero entries in the sequence.  An\n      attribute\
    \ can occur multiple times in the cms_effective_attribute\n      set, potentially\
    \ with different values.\n   cms_default_attributes  contains default attributes\
    \ derived from\n      message signer or originator authorizations.  A default\
    \ attribute\n      value is taken from a constraint that does not correspond to\
    \ an\n      attribute contained in the CMS path. cms_default_attributes is a\n\
    \      SEQUENCE OF Attribute, which is the same as the AttrConstraintList\n  \
    \    structure except that it may have zero entries in the sequence.\n   cms_constraints\
    \  contains the constraints associated with the message\n      signer or originator\
    \ for the content type of the leaf node.\n      cms_constraints is a SEQUENCE\
    \ OF Attribute, which is the same as\n      the AttrConstraintList structure except\
    \ that it may have zero\n      entries in the sequence.\n"
- title: 4.1.1.  Collection of Signer or Originator Information
  contents:
  - "4.1.1.  Collection of Signer or Originator Information\n   Signer or originator\
    \ constraints are identified using the public keys\n   to verify each SignedData,\
    \ AuthEnvelopedData, or AuthenticatedData\n   layer encountered in a CMS path.\
    \  The public key value, public key\n   certificate, or public key identifier\
    \ of each signer or originator\n   are collected in a state variable named cms_public_keys.\
    \  Constraints\n   are determined by building and validating a certification path\
    \ for\n   each public key after the content type and attributes of the CMS-\n\
    \   protected object have been identified.  If the CMS path has no\n   SignedData,\
    \ AuthEnvelopedData, or AuthenticatedData nodes, CCC\n   processing succeeds and\
    \ all output variables are set to empty.\n   The signature or MAC generated by\
    \ the originator MUST be verified.\n   If signature or MAC verification fails,\
    \ then the CMS path containing\n   the signature or MAC MUST be rejected.  Signature\
    \ and MAC\n   verification procedures are defined in [RFC5652] [RFC5083].  The\n\
    \   public key or public key certificate used to verify each signature or\n  \
    \ MAC in a CMS path is added to the cms_public_keys state variable for\n   use\
    \ in content type and constraint checking.  Additional checks may\n   be performed\
    \ during this step, such as timestamp verification\n   [RFC3161] and ESSCertId\
    \ [RFC5035] processing.\n"
- title: 4.1.1.1.  Handling Multiple SignerInfo Elements
  contents:
  - "4.1.1.1.  Handling Multiple SignerInfo Elements\n   CMS content constraints MAY\
    \ be applied to CMS-protected contents\n   featuring multiple parallel signers,\
    \ i.e., SignedData contents\n   containing more than one SignerInfo.  When multiple\
    \ SignerInfo\n   elements are present, each may represent a distinct entity or\
    \ each\n   may represent the same entity via different keys or certificates,\n\
    \   e.g., in the event of key rollover or when the entity has been issued\n  \
    \ certificates from multiple organizations.  For simplicity, signers\n   represented\
    \ by multiple SignerInfos within a single SignedData are\n   not considered to\
    \ be collaborating with regard to a particular\n   content, unlike signers represented\
    \ in distinct SignedData contents.\n   Thus, for the purposes of CCC processing,\
    \ each SignerInfo is treated\n   as if it were the only SignerInfo.  A content\
    \ is considered valid if\n   there is at least one valid CMS path employing one\
    \ SignerInfo within\n   each SignedData content.  Where collaboration is desired,\
    \ usage of\n   multiple SignedData contents is RECOMMENDED.\n   Though not required\
    \ by this specification, some applications may\n   require successful processing\
    \ of all or multiple SignerInfo elements\n   within a single SignedData content.\
    \  There are a number of potential\n   ways of treating the evaluation process,\
    \ including the following two\n   possibilities:\n   -  All signatures are meant\
    \ to be collaborative: In this case, the\n      public keys associated with each\
    \ SignerInfo are added to the\n      cms_public_keys variable, the attributes\
    \ from each SignerInfo are\n      added to the cms_effective_attributes variable,\
    \ and normal\n      processing is performed.\n   -  All signatures are meant to\
    \ be completely independent: In this\n      case, each of the SignerInfos is processed\
    \ as if it were a fork in\n      the CMS path construction process.  The application\
    \ may require\n      more than one CMS path to be valid in order to accept a content.\n\
    \   The exact processing will be a matter of application and local\n   policy.\
    \  See [RFC5752] for an example of an attribute that requires\n   processing multiple\
    \ SignerInfo elements within a SignedData content.\n"
- title: 4.1.2.  Collection of Attributes
  contents:
  - "4.1.2.  Collection of Attributes\n   Attributes are collected from all authenticated\
    \ nodes in a CMS path.\n   That is, attributes are not collected from content\
    \ types that are\n   unauthenticated, i.e., those that are not covered by a SignedData,\n\
    \   AuthEnvelopedData, or AuthenticatedData layer.  Additionally, an\n   application\
    \ MAY specify a set of attributes that it has\n   authenticated, perhaps from\
    \ processing one or more content types that\n   encapsulate a CMS-protected content.\
    \  Leaf node attributes MAY be\n   checked independent of the CCC processing,\
    \ but such processing is not\n   addressed in this document.  Applications are\
    \ free to perform further\n   processing using all or some of the attributes returned\
    \ from CCC\n   processing.\n"
- title: 4.1.3.  Leaf Node Classification
  contents:
  - "4.1.3.  Leaf Node Classification\n   The type of leaf node that terminates a\
    \ CMS path determines the types\n   of information that are returned and the type\
    \ of processing that is\n   performed.  There are two types of leaf nodes: encrypted\
    \ leaf nodes\n   and payload leaf nodes.\n   A node in a CMS path is a leaf node\
    \ if the content type of the node\n   is not one of the following content types:\n\
    \      id-signedData (SignedData),\n      id-digestedData (DigestedData),\n  \
    \    id-ct-authData (AuthenticatedData),\n      id-ct-compressedData (CompressedData),\n\
    \      id-ct-contentCollection (ContentCollection), or\n      id-ct-contentWithAttrs\
    \ (ContentWithAttributes).\n   A leaf node is an encrypted leaf node if the content\
    \ type of the node\n   is one of the following content types:\n      id-encryptedData\
    \ (EncryptedData),\n      id-envelopedData (EnvelopedData), or\n      id-ct-authEnvelopedData\
    \ (AuthEnvelopedData).\n   All other leaf nodes are payload leaf nodes, since\
    \ no further CMS\n   encapsulation can occur beyond that node.  However, specifications\n\
    \   may define content types that provide protection similar to the CMS\n   content\
    \ types, may augment the lists of possible leaf and encrypted\n   leaf nodes,\
    \ or may define some encrypted types as payload leaf nodes.\n   When an encrypted\
    \ leaf node is encountered, processing terminates and\n   returns information\
    \ that may be used as input when processing the\n   decrypted contents.  Content\
    \ type and constraints checking are only\n   performed for payload leaf nodes.\
    \  When an encrypted leaf node\n   terminates a CMS path, the attributes collected\
    \ in\n   cms_effective_attributes are returned along with the public key\n   information\
    \ collected in cms_public_keys.  When a payload leaf node\n   terminates a CMS\
    \ path, content type and constraint checking MUST be\n   performed, as described\
    \ in the next section.\n"
- title: 4.2.  Content Type and Constraint Checking
  contents:
  - "4.2.  Content Type and Constraint Checking\n   Content type and constraint checking\
    \ is performed when a payload leaf\n   node is encountered.  This section does\
    \ not apply to CMS paths that\n   are terminated by an encrypted leaf node nor\
    \ to CMS paths that have\n   no SignedData, AuthEnvelopedData, or AuthenticatedData\
    \ nodes.\n"
- title: 4.2.1.  Inputs
  contents:
  - "4.2.1.  Inputs\n   The inputs to content type and constraint checking are the\
    \ values\n   collected in cms_public_keys and cms_effective_attributes from a\
    \ CMS\n   path, along with the payload leaf node that terminates the CMS path,\n\
    \   as shown in the figure below.\n   Inputs\n   + leaf node\n   + cms_public_keys\n\
    \   + cms_effective_attributes\n                    |\n                    |\n\
    \    ________________V_________________________________________\n   |        \
    \                                                  |\n   | Content type and constraint\
    \ checking                     |\n   |  (uses CCC-aware Certification Path Processor\
    \ internally)|\n   |__________________________________________________________|\n\
    \                    |\n                    |\n                    V\n   Outputs\
    \ upon success\n   + cms_constraints\n   + cms_default_attributes\n   + cms_effective_attributes\n\
    \         Figure 7.  Content Type and Constraint Checking\n"
- title: 4.2.2.  Processing
  contents:
  - "4.2.2.  Processing\n   When a payload leaf node is encountered in a CMS path\
    \ and a signed or\n   authenticated content type is present in the CMS path, content\
    \ type\n   and constraint checking MUST be performed.  Content type and\n   constraint\
    \ checking need not be performed for CMS paths that do not\n   contain at least\
    \ one SignedData, AuthEnvelopedData, or\n   AuthenticatedData content type.  The\
    \ cms_effective_attributes and\n   cms_public_keys variables are used to perform\
    \ constraint checking.\n   Two additional state variables are used during the\
    \ processing:\n   cms_constraints and cms_default_attributes, both of which are\n\
    \   initialized to empty.  The steps required to perform content type and\n  \
    \ constraint checking are below.\n   For each public key in cms_public_keys, build\
    \ and validate a\n   certification path from a trust anchor to the public key,\
    \ providing\n   the content type of the payload leaf node and\n   cms_effective_attributes\
    \ as input.  Observe any limitations imposed\n   by intermediate layers.  For\
    \ example, if the SigningCertificateV2\n   [RFC5035] attribute is used, the certificate\
    \ identified by the\n   attribute is required to serve as the target certificate.\n\
    \   o  If path validation is successful, add the contents of\n      subject_default_attributes\
    \ to cms_default_attributes.  The\n      subject_constraints variable returned\
    \ from certification path\n      validation will contain a single entry.  If the\n\
    \      subject_constraints entry is equal to the special value\n      anyContentType,\
    \ content type and constraints checking succeeds.\n      If the subject_constraints\
    \ entry is not equal to the special value\n      anyContentType, for each entry\
    \ in the attrConstraints field of the\n      entry in subject_constraints,\n \
    \     *  If there is an entry in cms_constraints with the same attrType\n    \
    \     value, add the value from the attrValues entry to the entry in\n       \
    \  cms_constraints if that value does not already appear.\n      *  If there is\
    \ no entry in cms_constraints with the same attrType\n         value, add a new\
    \ entry to cms_constraints equal to the entry\n         from the attrConstraints\
    \ field.\n   o  If the value of the canSource field of the entry in the\n    \
    \  subject_constraints variable for the public key used to verify the\n      signature\
    \ or MAC closest to the payload leaf node is set to\n      cannotSource, constraints\
    \ checking fails and the CMS path MUST be\n      rejected.\n   If no valid certification\
    \ path can be found, constraints checking\n   fails and the CMS path MUST be rejected.\n"
- title: 4.2.3.  Outputs
  contents:
  - "4.2.3.  Outputs\n   When a payload leaf node is encountered and content type\
    \ and\n   constraint checking succeeds, return cms_constraints,\n   cms_default_attributes,\
    \ and cms_effective_attributes for use in leaf\n   node payload processing.\n\
    \   When an encrypted leaf node is encountered and constraint checking is\n  \
    \ not performed, return cms_public_keys and cms_effective_attributes\n   for use\
    \ in continued processing (as described in Section 4.2.1).\n   The cms_effective_attributes\
    \ list may contain multiple instances of\n   the same attribute type.  An instance\
    \ of an attribute may contain\n   multiple values.  Leaf node processing, which\
    \ might take advantage of\n   these effective attributes, needs to describe the\
    \ proper handling of\n   this situation.  Leaf node processing is described in\
    \ other\n   documents, and it is expected to be specific to a particular content\n\
    \   type.\n   The cms_default_attributes list may contain attributes with multiple\n\
    \   values.  Payload processing, which might take advantage of these\n   default\
    \ attributes, needs to describe the proper handling of this\n   situation.  Payload\
    \ processing is described in other documents, and\n   it is expected to be specific\
    \ to a particular content type.\n"
- title: 5.  Subordination Processing in TAMP
  contents:
  - "5.  Subordination Processing in TAMP\n   TAMP [RFC5934] does not define an authorization\
    \ mechanism.  CCC can\n   be used to authorize TAMP message signers and to delegate\
    \ TAMP\n   message-signing authority.  TAMP requires trust anchors managed by\
    \ a\n   TAMP message signer to be subordinate to the signer.  This section\n \
    \  describes subordination processing for CCC extensions of trust\n   anchors\
    \ contained in a TrustAnchorUpdate message where CCC is used to\n   authorize\
    \ TAMP messages.\n   For a Trust Anchor Update message that is not signed with\
    \ the apex\n   trust anchor operational public key to be valid, the digital\n\
    \   signature MUST be validated using a management trust anchor\n   associated\
    \ with the id-ct-TAMP-update content type, either directly\n   or via an X.509\
    \ certification path originating with an authorized\n   trust anchor.  The following\
    \ subordination checks MUST also be\n   performed as part of validation.\n   Each\
    \ Trust Anchor Update message contains one or more individual\n   updates, each\
    \ of which is used to add, modify, or remove a trust\n   anchor.  For each individual\
    \ update, the constraints of the TAMP\n   message signer MUST be greater than\
    \ or equal to the constraints of\n   the trust anchor in the update.  The constraints\
    \ of the TAMP message\n   signer and the to-be-updated trust anchor are determined\
    \ based on the\n   applicable CMS Content Constraints.  Specifically, the constraints\
    \ of\n   the TAMP message signer are determined as described in Section 3,\n \
    \  passing the special value id-ct-anyContentType and an empty set of\n   attributes\
    \ as input; the constraints of the to-be-updated trust\n   anchor are determined\
    \ as described below.  If the constraints of a\n   trust anchor in an update exceed\
    \ the constraints of the signer, that\n   update MUST be rejected.  Each update\
    \ is considered and accepted or\n   rejected individually without regard to other\
    \ updates in the TAMP\n   message.  The constraints of the to-be-updated trust\
    \ anchors are\n   determined as follows:\n   o  If the to-be-updated trust anchor\
    \ is the subject of an add\n      operation, the constraints are read from the\
    \ CMSContentConstraints\n      extension of the corresponding trust anchor in\
    \ the update.\n   o  If the to-be-updated trust anchor is the subject of a remove\n\
    \      operation, the trust anchor is located in the message recipient's\n   \
    \   trust anchor store using the public key included in the update.\n   o  If\
    \ the to-be-updated trust anchor is the subject of a change\n      operation,\
    \ the trust anchor has two distinct sets of constraints\n      that MUST be checked.\
    \  The trust anchor's pre-change constraints\n      are determined by locating\
    \ the trust anchor in the message\n      recipient's trust anchor store using\
    \ the public key included in\n      the update and reading the constraints from\
    \ the\n      CMSContentConstraints extension in the trust anchor.  The trust\n\
    \      anchor's post-change constraints are read from the\n      CMSContentConstraints\
    \ extension of the corresponding\n      TBSCertificateChangeInfo or the TrustAnchorChangeInfo\
    \ in the\n      update.  If the CMSContentConstraints extension is not present,\n\
    \      then the trust anchor's post-change constraints are equivalent to\n   \
    \   the trust anchor's pre-change constraints.\n   The following steps can be\
    \ used to determine if a Trust Anchor Update\n   message signer is authorized\
    \ to manage each to-be-updated trust\n   anchor contained in a Trust Anchor Update\
    \ message.\n   o  The TAMP message signer's CMS Content Constraints are determined\n\
    \      as described in Section 3, passing the special value\n      id-ct-anyContentType\
    \ and an empty set of attributes as input.  The\n      message signer MUST be\
    \ authorized for the Trust Anchor Update\n      message.  This can be confirmed\
    \ using the steps described in\n      Section 4.\n   o  The constraints of each\
    \ to-be-updated trust anchor in the TAMP\n      message MUST be checked against\
    \ the message signer's constraints\n      (represented in the message signer's\
    \ subject_constraints computed\n      above) using the following steps.  For change\
    \ operations, the\n      following steps MUST be performed for the trust anchor's\
    \ pre-\n      change constraints and the trust anchor's post-change constraints.\n\
    \      *  If the to-be-updated trust anchor is unconstrained, the message\n  \
    \       signer MUST also be unconstrained, i.e., the message signer's\n      \
    \   subject_constraints MUST be set to the special value\n         anyContentType.\
    \  If the to-be-updated trust anchor is\n         unconstrained and the message\
    \ signer is not, then the message\n         signer is not authorized to manage\
    \ the trust anchor and the\n         update MUST be rejected.\n      *  The message\
    \ signer's authorization for each permitted content\n         type MUST be checked\
    \ using the state variables and procedures\n         similar to those described\
    \ in Sections 3.2 and 3.3.  For each\n         permitted content type in the to-be-updated\
    \ trust anchor's\n         constraints,\n         +  Set cms_effective_attributes\
    \ equal to the value of the\n            attrConstraints field from the permitted\
    \ content type.\n         +  If the content type does not match an entry in the\
    \ message\n            signer's subject_constraints, the message signer is not\n\
    \            authorized to manage the trust anchor and the update MUST be\n  \
    \          rejected.  Note, the special value id-ct-anyContentType\n         \
    \   produces a match for all content types that have the\n            resulting\
    \ matching entry containing the content type,\n            canSource set to canSource,\
    \ and attrConstraints absent.\n         +  If the content type matches an entry\
    \ in the message signer's\n            subject_constraints, the canSource field\
    \ of the entry is\n            cannotSource, and the canSource field in the to-be-updated\n\
    \            trust anchor's privilege is canSource, the message signer is\n  \
    \          not authorized to manage the trust anchor and the update\n        \
    \    MUST be rejected.\n         +  If the content type matches an entry in the\
    \ message signer's\n            subject_constraints and the entry's attrConstraints\
    \ field is\n            present, then constraints MUST be checked.  For each\n\
    \            attrType in the entry's attrConstraints, a corresponding\n      \
    \      attribute MUST be present in cms_effective_attributes\n            containing\
    \ values from the entry's attrConstraints.  If\n            values appear in the\
    \ corresponding attribute that are not in\n            the entry's attrConstraints\
    \ or if there is no corresponding\n            attribute, the message signer is\
    \ not authorized to manage\n            the trust anchor and the update MUST be\
    \ rejected.\n   Once these steps are completed, if the update has not been rejected,\n\
    \   then the message signer is authorized to manage the to-be-updated\n   trust\
    \ anchor.\n   Note that a management trust anchor that has only the\n   id-ct-TAMP-update\
    \ permitted content type is useful only for managing\n   identity trust anchors.\
    \  It can sign a Trust Anchor Update message,\n   but it cannot impact a management\
    \ trust anchor that is associated\n   with any other content type.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   For any given certificate, multiple certification\
    \ paths may exist,\n   and each one can yield different results for CMS content\
    \ constraints\n   processing.  For example, default attributes can change when\
    \ multiple\n   certification paths exist, as each path can potentially have\n\
    \   different attribute requirements or default values.\n   Compromise of a trust\
    \ anchor private key permits unauthorized parties\n   to generate signed messages\
    \ that will be acceptable to all\n   applications that use a trust anchor store\
    \ containing the\n   corresponding management trust anchor.  For example, if the\
    \ trust\n   anchor is authorized to sign firmware packages, then the unauthorized\n\
    \   private key holder can generate firmware that may be successfully\n   installed\
    \ and used by applications that trust the management trust\n   anchor.\n   For\
    \ implementations that support validation of TAMP messages using\n   X.509 certificates,\
    \ it is possible for the TAMP message signer to\n   have more than one possible\
    \ certification path that will authorize it\n   to sign Trust Anchor Update messages,\
    \ with each certification path\n   resulting in different CMS Content Constraints.\
    \  The update is\n   authorized if the processing below succeeds for any one certification\n\
    \   path of the TAMP message signer.  The resulting subject_constraints\n   variable\
    \ is used to check each to-be-updated trust anchor contained\n   in the update\
    \ message.\n   CMS does not provide a mechanism for indicating that an attribute\n\
    \   applies to a particular content within a ContentCollection or a set\n   CMS\
    \ layers.  For the sake of simplicity, this specification collects\n   all attributes\
    \ that appear in a CMS path.  These attributes are\n   processed as part of CCC\
    \ processing and are made available for use in\n   processing leaf node contents.\
    \  This can result in a collection of\n   attributes that have no relationship\
    \ with the leaf node contents.\n   CMS does not provide a means for indicating\
    \ what element within a CMS\n   message an attribute applies to.  For example,\
    \ a MessageDigest\n   attribute included in a SignedData signedAttributes collection\n\
    \   applies to a specific signature, but a Firmware Package Identifier\n   attribute\
    \ appearing in the same list of attributes describes the\n   encapsulated content.\
    \  As such, CCC treats all attributes as applying\n   to the encapsulated content\
    \ type.  Care should be taken to avoid\n   provisioning trust anchors or certificates\
    \ that include constraints\n   on attribute types that are never used to describe\
    \ a leaf content\n   type, such as a MessageDigest attribute.\n   The CMS Constraint\
    \ Processing algorithm is designed to collect signer\n   information for processing\
    \ when all information for a CMS path is\n   available.  In cases where the certification\
    \ path discovered during\n   SignedData layer processing is not acceptable, an\
    \ alternative\n   certification path may be discovered that is acceptable.  These\n\
    \   alternatives may include an alternative signer certificate.  When the\n  \
    \ ESSCertId attribute is used, alternative signer certificates are not\n   permitted.\
    \  The certificate referenced by ESSCertId must be used,\n   possibly resulting\
    \ in failure where alternative certificates would\n   yield success.\n"
- title: 7.  Acknowledgments
  contents:
  - "7.  Acknowledgments\n   Thanks to Jim Schaad for thorough review and many suggestions.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC3274]  Gutmann, P., \"Compressed Data Content Type for\n     \
    \         Cryptographic Message Syntax (CMS)\", RFC 3274, June 2002.\n   [RFC4073]\
    \  Housley, R., \"Protecting Multiple Contents with the\n              Cryptographic\
    \ Message Syntax (CMS)\", RFC 4073, May 2005.\n   [RFC5083]  Housley, R., \"Cryptographic\
    \ Message Syntax (CMS)\n              Authenticated-Enveloped-Data Content Type\"\
    , RFC 5083,\n              November 2007.\n   [RFC5280]  Cooper, D., Santesson,\
    \ S., Farrell, S., Boeyen, S.,\n              Housley, R., and W. Polk, \"Internet\
    \ X.509 Public Key\n              Infrastructure Certificate and Certificate Revocation\
    \ List\n              (CRL) Profile\", RFC 5280, May 2008.\n   [RFC5652]  Housley,\
    \ R., \"Cryptographic Message Syntax (CMS)\", STD 70,\n              RFC 5652,\
    \ September 2009.\n   [RFC5911]  Hoffman, P. and J. Schaad, \"New ASN.1 Modules\
    \ for\n              Cryptographic Message Syntax (CMS) and S/MIME\", RFC 5911,\n\
    \              June 2010.\n   [RFC5912]  Hoffman, P. and J. Schaad, \"New ASN.1\
    \ Modules for the\n              Public Key Infrastructure Using X.509 (PKIX)\"\
    , RFC 5912,\n              June 2010.\n   [X.208]    \"ITU-T Recommendation X.208\
    \ - Specification of Abstract\n              Syntax Notation One (ASN.1)\", 1988.\n\
    \   [X.501]    ITU-T Recommendation X.501, \"Information technology - Open\n \
    \             Systems Interconnection - The Directory: Models\", ISO/\n      \
    \        IEC 9594-2:2005, 2005.\n   [X.680]    \"ITU-T Recommendation X.680: Information\
    \ Technology -\n              Abstract Syntax Notation One\", 2002.\n   [X.690]\
    \    \"ITU-T Recommendation X.690 Information Technology - ASN.1\n           \
    \   encoding rules: Specification of Basic Encoding Rules\n              (BER),\
    \ Canonical Encoding Rules (CER) and Distinguished\n              Encoding Rules\
    \ (DER)\", 2002.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [RFC3161]  Adams, C., Cain, P., Pinkas, D.,\
    \ and R. Zuccherato,\n              \"Internet X.509 Public Key Infrastructure\
    \ Time-Stamp\n              Protocol (TSP)\", RFC 3161, August 2001.\n   [RFC4108]\
    \  Housley, R., \"Using Cryptographic Message Syntax (CMS) to\n              Protect\
    \ Firmware Packages\", RFC 4108, August 2005.\n   [RFC5035]  Schaad, J., \"Enhanced\
    \ Security Services (ESS) Update:\n              Adding CertID Algorithm Agility\"\
    , RFC 5035, August 2007.\n   [RFC5272]  Schaad, J. and M. Myers, \"Certificate\
    \ Management over CMS\n              (CMC)\", RFC 5272, June 2008.\n   [RFC5752]\
    \  Schaad, J. and S. Turner, \"Multiple Signatures in\n              Cryptographic\
    \ Message Syntax (CMS)\", December 2009.\n   [RFC5914]  Housley, R., Ashmore,\
    \ S., and C. Wallace, \"Trust Anchor\n              Format\", RFC 5914, June 2010.\n\
    \   [RFC5934]  Housley, R., Ashmore, S., and C. Wallace, \"Trust Anchor\n    \
    \          Management Protocol (TAMP)\", RFC 5934, August 2010.\n"
- title: Appendix A.  ASN.1 Modules
  contents:
  - "Appendix A.  ASN.1 Modules\n   Appendix A.1 provides the normative ASN.1 definitions\
    \ for the\n   structures described in this specification using ASN.1 as defined\
    \ in\n   [X.680].  Appendix A.2 provides a module using ASN.1 as defined in\n\
    \   [X.208].  The module in A.2 removes usage of newer ASN.1 features\n   that\
    \ provide support for limiting the types of elements that may\n   appear in certain\
    \ SEQUENCE and SET constructions.  Otherwise, the\n   modules are compatible in\
    \ terms of encoded representation, i.e., the\n   modules are bits-on-the-wire\
    \ compatible aside from the limitations on\n   SEQUENCE and SET constituents.\
    \  A.2 is included as a courtesy to\n   developers using ASN.1 compilers that\
    \ do not support current ASN.1.\n   A.1 references an ASN.1 module from [RFC5912]\
    \ and [RFC5911].\n"
- title: A.1.  ASN.1 Module Using 1993 Syntax
  contents:
  - "A.1.  ASN.1 Module Using 1993 Syntax\n   CMSContentConstraintsCertExtn\n    \
    \ { iso(1) identified-organization(3) dod(6) internet(1) security(5)\n       mechanisms(5)\
    \ pkix(7) id-mod(0) cmsContentConstr-93(42) }\n   DEFINITIONS IMPLICIT TAGS ::=\
    \ BEGIN\n   IMPORTS\n       EXTENSION, ATTRIBUTE\n         FROM  -- from [RFC5912]\n\
    \           PKIX-CommonTypes-2009\n               {iso(1) identified-organization(3)\
    \ dod(6) internet(1)\n               security(5) mechanisms(5) pkix(7) id-mod(0)\n\
    \               id-mod-pkixCommon-02(57)}\n       CONTENT-TYPE, ContentSet, SignedAttributesSet,\
    \ ContentType\n       FROM  -- from [RFC5911]\n           CryptographicMessageSyntax-2009\n\
    \               { iso(1) member-body(2) us(840) rsadsi(113549)\n             \
    \  pkcs(1) pkcs-9(9) smime(16) modules(0)\n               id-mod-cms-2004-02(41)\
    \ }\n       ;\n   id-ct-anyContentType ContentType ::=\n       { iso(1) member-body(2)\n\
    \         us(840) rsadsi(113549) pkcs(1) pkcs-9(9) smime(16)\n         ct(1) 0\
    \ }\n   ct-Any CONTENT-TYPE ::= {NULL IDENTIFIED BY id-ct-anyContentType }\n \
    \  --\n   --  Add this to CertExtensions in PKIX1Implicit-2009\n   --\n   ext-cmsContentConstraints\
    \ EXTENSION ::= {\n       SYNTAX         CMSContentConstraints\n       IDENTIFIED\
    \ BY  id-pe-cmsContentConstraints }\n   id-pe-cmsContentConstraints OBJECT IDENTIFIER\
    \ ::=\n       { iso(1) identified-organization(3) dod(6) internet(1)\n       \
    \  security(5) mechanisms(5) pkix(7) pe(1) 18 }\n   CMSContentConstraints ::=\
    \ SEQUENCE SIZE (1..MAX) OF\n                             ContentTypeConstraint\n\
    \   ContentTypeGeneration ::= ENUMERATED  {\n       canSource(0),\n       cannotSource(1)}\n\
    \   ContentTypeConstraint ::= SEQUENCE {\n       contentType           CONTENT-TYPE.&id\
    \ ({ContentSet|ct-Any,...}),\n       canSource             ContentTypeGeneration\
    \ DEFAULT canSource,\n       attrConstraints       AttrConstraintList OPTIONAL\
    \ }\n   Constraint { ATTRIBUTE:ConstraintList } ::= SEQUENCE {\n       attrType\
    \           ATTRIBUTE.\n               &id({ConstraintList}),\n       attrValues\
    \         SET SIZE (1..MAX) OF ATTRIBUTE.\n               &Type({ConstraintList}{@attrType})\
    \  }\n   SupportedConstraints ATTRIBUTE ::= {SignedAttributesSet, ... }\n   AttrConstraintList\
    \ ::=\n       SEQUENCE SIZE (1..MAX) OF Constraint {{ SupportedConstraints }}\n\
    \   END\n"
- title: A.2.  ASN.1 Module Using 1988 Syntax
  contents:
  - "A.2.  ASN.1 Module Using 1988 Syntax\n   CMSContentConstraintsCertExtn-88\n \
    \    { iso(1) identified-organization(3) dod(6) internet(1) security(5)\n    \
    \   mechanisms(5) pkix(7) id-mod(0) cmsContentConstr-88(41) }\n   DEFINITIONS\
    \ IMPLICIT TAGS ::=\n   BEGIN\n   IMPORTS\n       AttributeType, AttributeValue\n\
    \         FROM PKIX1Explicit88 -- from [RFC5280]\n           { iso(1) identified-organization(3)\
    \ dod(6) internet(1)\n             security(5) mechanisms(5) pkix(7) id-mod(0)\n\
    \             id-pkix1-explicit(18) } ;\n   id-ct-anyContentType OBJECT IDENTIFIER\
    \ ::=\n       { iso(1) member-body(2)\n         us(840) rsadsi(113549) pkcs(1)\
    \ pkcs-9(9) smime(16)\n         ct(1) 0}\n   -- Extension object identifier\n\
    \   id-pe-cmsContentConstraints OBJECT IDENTIFIER ::=\n       { iso(1) identified-organization(3)\
    \ dod(6) internet(1)\n         security(5) mechanisms(5) pkix(7) pe(1) 18 }\n\
    \   -- CMS Content Constraints Extension\n   CMSContentConstraints ::= SEQUENCE\
    \ SIZE (1..MAX) OF\n                             ContentTypeConstraint\n   ContentTypeGeneration\
    \ ::= ENUMERATED  {\n       canSource(0),\n       cannotSource(1)}\n   ContentTypeConstraint\
    \ ::= SEQUENCE {\n       contentType           OBJECT IDENTIFIER,\n       canSource\
    \             ContentTypeGeneration DEFAULT canSource,\n       attrConstraints\
    \       AttrConstraintList OPTIONAL }\n   AttrConstraintList ::= SEQUENCE SIZE\
    \ (1..MAX) OF AttrConstraint\n   AttrConstraint ::= SEQUENCE {\n       attrType\
    \               AttributeType,\n       attrValues             SET SIZE (1..MAX)\
    \ OF AttributeValue }\n   END\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Russ Housley\n   Vigil Security, LLC\n   918 Spring Knoll\
    \ Drive\n   Herndon, VA  20170\n   EMail: housley@vigilsec.com\n   Sam Ashmore\n\
    \   National Security Agency\n   Suite 6751\n   9800 Savage Road\n   Fort Meade,\
    \ MD  20755\n   EMail: srashmo@radium.ncsc.mil\n   Carl Wallace\n   Cygnacom Solutions\n\
    \   Suite 5400\n   7925 Jones Branch Drive\n   McLean, VA  22102\n   EMail: cwallace@cygnacom.com\n"
