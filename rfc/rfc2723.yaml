- title: __initial_text__
  contents:
  - "            SRL: A Language for Describing Traffic Flows and\n              \
    \     Specifying Actions for Flow Groups\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a language for specifying rulesets, i.e.\n\
    \   configuration files which may be loaded into a traffic flow meter so\n   as\
    \ to specify which traffic flows are measured by the meter, and the\n   information\
    \ it will store for each flow.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1  Purpose and Scope . . . . . . . . . . . . . . . . .\
    \ . . . . .    2\n      1.1 RTFM Meters and Traffic Flows . . . . . . . . . .\
    \ . . . .    2\n      1.2 SRL Overview  . . . . . . . . . . . . . . . . . . .\
    \ . . .    3\n   2  SRL Language Description  . . . . . . . . . . . . . . . .\
    \ . .    4\n      2.1 Define Directive  . . . . . . . . . . . . . . . . . . .\
    \ .    4\n      2.2 Program . . . . . . . . . . . . . . . . . . . . . . . . .\
    \    5\n      2.3 Declaration . . . . . . . . . . . . . . . . . . . . . . .  \
    \  5\n   3  Statement . . . . . . . . . . . . . . . . . . . . . . . . . .    5\n\
    \      3.1 IF_statement  . . . . . . . . . . . . . . . . . . . . . .    6\n  \
    \        3.1.1 expression  . . . . . . . . . . . . . . . . . . . .    6\n    \
    \      3.1.2 term  . . . . . . . . . . . . . . . . . . . . . . .    6\n      \
    \    3.1.3 factor  . . . . . . . . . . . . . . . . . . . . . .    6\n        \
    \  3.1.4 operand_list  . . . . . . . . . . . . . . . . . . .    6\n          3.1.5\
    \ operand . . . . . . . . . . . . . . . . . . . . . .    6\n          3.1.6 Test\
    \ Part . . . . . . . . . . . . . . . . . . . . .    7\n          3.1.7 Action\
    \ Part . . . . . . . . . . . . . . . . . . . .    8\n          3.1.8 ELSE Clause\
    \ . . . . . . . . . . . . . . . . . . . .    8\n      3.2 Compound_statement \
    \ . . . . . . . . . . . . . . . . . . .    8\n      3.3 Imperative_statement \
    \ . . . . . . . . . . . . . . . . . .    9\n          3.3.1 SAVE Statement  .\
    \ . . . . . . . . . . . . . . . . .    9\n          3.3.2 COUNT Statement . .\
    \ . . . . . . . . . . . . . . . .   10\n          3.3.3 EXIT Statement  . . .\
    \ . . . . . . . . . . . . . . .   10\n          3.3.4 IGNORE Statement  . . .\
    \ . . . . . . . . . . . . . .   10\n          3.3.5 NOMATCH Statement . . . .\
    \ . . . . . . . . . . . . .   10\n          3.3.6 STORE Statement . . . . . .\
    \ . . . . . . . . . . . .   11\n          3.3.7 RETURN Statement  . . . . . .\
    \ . . . . . . . . . . .   11\n      3.4 Subroutine_declaration  . . . . . . .\
    \ . . . . . . . . . .   11\n      3.5 CALL_statement  . . . . . . . . . . . .\
    \ . . . . . . . . .   12\n   4  Example Programs  . . . . . . . . . . . . . .\
    \ . . . . . . . .   13\n      4.1 Classify IP Port Numbers  . . . . . . . . .\
    \ . . . . . . .   13\n      4.2 Classify Traffic into Groups of Networks  . .\
    \ . . . . . .   14\n   5  Security Considerations . . . . . . . . . . . . . .\
    \ . . . . .   15\n   6  IANA Considerations . . . . . . . . . . . . . . . . .\
    \ . . . .   15\n   7  APPENDICES  . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   16\n      7.1 Appendix A: SRL Syntax in BNF . . . . . . . . . . . .\
    \ . .   16\n      7.2 Appendix B: Syntax for Values and Masks . . . . . . . .\
    \ .   18\n      7.3 Appendix C: RTFM Attribute Information  . . . . . . . . .\
    \   19\n   8  Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .  \
    \ 20\n   9  References  . . . . . . . . . . . . . . . . . . . . . . . . .   20\n\
    \   10 Author's Address  . . . . . . . . . . . . . . . . . . . . . .   21\n  \
    \ 11 Full Copyright Statement  . . . . . . . . . . . . . . . . . .   22\n"
- title: 1  Purpose and Scope
  contents:
  - "1  Purpose and Scope\n   A ruleset for an RTFM Meter is a sequence of instructions\
    \ to be\n   executed by the meter's Pattern Matching Engine (PME).  The form of\n\
    \   these instructions is described in detail in the 'RTFM Architecture'\n   and\
    \ 'RTFM Meter MIB' documents [RTFM-ARC, RTFM-MIB], but most users -\n   at least\
    \ initially - find them confusing and difficult to write,\n   mainly because the\
    \ effect of each instruction is strongly dependent\n   on the state of the meter's\
    \ Packet Matching Engine at the moment of\n   its execution.\n   SRL (the Simple\
    \ Ruleset Language) is a procedural language for\n   creating RTFM rulesets. \
    \ It has been designed to be simple for people\n   to understand, using statements\
    \ which help to clarify the execution\n   context in which they operate.  SRL\
    \ programs will be compiled into\n   rulesets which can then be downloaded to\
    \ RTFM meters.\n   An SRL compiler is available as part of NeTraMet (a free-software\n\
    \   implementation of the RTFM meter and manager), version 4.2\n   [NETRAMET].\n"
- title: 1.1  RTFM Meters and Traffic Flows
  contents:
  - "1.1  RTFM Meters and Traffic Flows\n   The RTFM Architecture [RTFM-ARC] defines\
    \ a set of 'attributes' which\n   apply to network traffic.  Among the attributes\
    \ are 'address\n   attributes,' such as PeerType, PeerAddress, TransType and\n\
    \   TransAddress, which have meaning for many protocols, e.g. for IPv4\n   traffic\
    \ (PeerType == 1) PeerAddress is an IP address, TransType is\n   TCP(6), UDP(17),\
    \ ICMP(1), etc., and TransAddress is usually an IP\n   port number.\n   An 'RTFM\
    \ Traffic Flow' is simply a stream of packets observed by a\n   meter as they\
    \ pass across a network between two end points (or\n   to/from a single end point).\
    \  Each 'end point' of a flow is specified\n   by the set of values of its address\
    \ attributes.\n   An 'RTFM Meter' is a measuring device - e.g. a program running\
    \ on a\n   Unix or PC host - which observes passing packets and builds 'Flow\n\
    \   Data Records' for the flows of interest.\n   RTFM traffic flows have another\
    \ important property - they are bi-\n   directional.  This means that each flow\
    \ data record in the meter has\n   two sets of counters, one for packets travelling\
    \ from source to\n   destination, the other for returning packets.  Within the\
    \ RTFM\n   architecture such counters appear as further attributes of the flow.\n\
    \   An RTFM meter must be configured by the user, which means creating a\n   'Ruleset'\
    \ so as to specify which flows are to be measured, and how\n   much information\
    \ (i.e. which attributes) should be stored for each of\n   them.  A ruleset is\
    \ effectively a program for a minimal virtual\n   machine, the 'Packet Matching\
    \ Engine (PME),' which is described in\n   detail in [RTFM-ARC]. An RTFM meter\
    \ may run multiple rule sets, with\n   every passing packet being processed by\
    \ each of the rulesets.  The\n   rule 'actions' in this document are described\
    \ as though only a single\n   ruleset were running.\n   In the past creating a\
    \ ruleset has meant writing machine code for the\n   PME, which has proved rather\
    \ difficult to do.  SRL provides a high-\n   level language which should enable\
    \ users to create effective rulesets\n   without having to understand the details\
    \ of the PME.\n   The language may be useful in other applications, being suitable\
    \ for\n   any application area which involves selecting traffic flows from a\n\
    \   stream of packets.\n"
- title: 1.2  SRL Overview
  contents:
  - "1.2  SRL Overview\n   An SRL program is executed from the beginning for each\
    \ new packet\n   arriving at the meter.  It has two essential goals.\n   (a) Decide\
    \ whether the current packet is part of a flow which is of\n       interest and,\
    \ if necessary, determine its direction (i.e. decide\n       which of its end-points\
    \ is considered to be its source).  Other\n       packets will be ignored.\n \
    \  (b) SAVE whatever information is required to identify the flow and\n      \
    \ accumulate (COUNT) quantitative information for that flow.\n   At execution,\
    \ the meter's Packet Matching Engine (PME) begins by\n   using source and destination\
    \ attributes as they appear 'on the wire.'\n   If the attributes do not match\
    \ those of a flow to be recorded, the\n   PME will normally execute the program\
    \ again, this time with the\n   source and destination addresses interchanged.\
    \  Because of this bi-\n   directional matching, an RTFM meter is able to build\
    \ up tables of\n   flows with two sets of counters - one for forward packets,\
    \ the other\n   for backward packets.  The programmer can, if required, suppress\
    \ the\n   reverse-direction matching and assign 'forward' and 'backward'\n   directions\
    \ which conform to the conventions of the external context.\n   Goal (a) is achieved\
    \ using IF statements which perform comparisons on\n   information from the packet\
    \ or from SRL variables.  Goal (b) is\n   achieved using one or more SAVE statements\
    \ to store the flow's\n   identification attributes; a COUNT statement then increments\
    \ the\n   statistical data accumulating for it.\n"
- title: 2  SRL Language Description
  contents:
  - "2  SRL Language Description\n   The SRL language is explained below using 'railway\
    \ diagrams' to\n   describe the syntax.  Flow through a diagram is from left to\
    \ right.\n   The only exception to this is that lines carrying a left arrow may\n\
    \   only be traversed right to left.  In the diagrams, keywords are\n   written\
    \ in capital letters; in practice an SRL compiler must be\n   insensitive to case.\
    \  Lower-case identifiers are explained in the\n   text, or they refer to another\
    \ diagram.\n   The tokens of an SRL program obey the following rules:\n   -  Comments\
    \ may appear on any line of an SRL program, following a #\n   -  White space is\
    \ used to separate tokens\n   -  Semicolon is used as the terminator for most\
    \ statements\n   -  Identifiers (e.g. for defines and labels) must start with\
    \ a letter\n   -  Identifiers may contain letters, digits and underscores\n  \
    \ -  The case of letters is not significant\n   -  Reserved words (shown in upper\
    \ case in this document) may not be\n      used as identifiers\n"
- title: 2.1  Define Directive
  contents:
  - "2.1  Define Directive\n   --- DEFINE -- defname ---- = ---- defined_text ------------------\
    \ ;\n   Simple parameterless defines are supported via the syntax above.  The\n\
    \   define name, defname, is an identifier.  The defined text starts\n   after\
    \ the equal sign, and continues up to (but not including) the\n   closing semicolon.\
    \  If a semicolon is required within the defined\n   text it must be preceded\
    \ by a backslash, i.e. \\; in an SRL define\n   produces ; in the text.\n   Wherever\
    \ defname appears elsewhere in the program, it will be\n   replaced by the defined\
    \ text.\n   For example,\n   DEFINE ftp = (20, 21);  # Well-known Port numbers\
    \ from [ASG-NBR]\n   DEFINE telnet = 23;\n   DEFINE www = 80;\n"
- title: 2.2  Program
  contents:
  - "2.2  Program\n   ------------+-------+-------- Statement -------+-------+-----------\n\
    \               |       |                          |       |\n               |\
    \       +------- Declaration ------+       |\n               |               \
    \                           |\n               +---------------------<--------------------+\n\
    \   An SRL program is a sequence of statements or declarations.  It does\n   not\
    \ have any special enclosing symbols.  Statements and declarations\n   terminate\
    \ with a semicolon, except for compound statements, which\n   terminate with a\
    \ right brace.\n"
- title: 2.3  Declaration
  contents:
  - "2.3  Declaration\n   ---------------------- Subroutine_declaration ---------------------\n\
    \   SRL's only explicit declaration is the subroutine declaration.  Other\n  \
    \ implicit declarations are labels (declared where they appear in front\n   of\
    \ a statement) and subroutine parameters (declared in the subroutine\n   header).\n"
- title: 3  Statement
  contents:
  - "3  Statement\n   ----------------+---- IF_statement ----------------+---------------\n\
    \                   |                                  |\n                   +----\
    \ Compound_statement ----------+\n                   |                       \
    \           |\n                   +---- Imperative_statement --------+\n     \
    \              |                                  |\n                   +----\
    \ CALL_statement --------------+\n   An SRL program is a sequence of SRL statements.\
    \  There are four kinds\n   of statements, as follows.\n"
- title: 3.1  IF_statement
  contents:
  - "3.1  IF_statement\n               Test Part                Action Part\n    \
    \         .............            ...............\n   --- IF --- expression ---+------------+----\
    \ Statement ----+--->\n                            |            |            \
    \       |\n                            +-- SAVE , --+                   |\n  \
    \                          |                                |\n              \
    \              +-- SAVE ; ----------------------+\n          >-----------+-----------------------------+-----------------\n\
    \                      |                             |\n                     \
    \ +-----ELSE --- Statement -----+\n"
- title: 3.1.1  expression
  contents:
  - "3.1.1  expression\n   -------- term --------+------------------------+-------------------\n\
    \                         |                        |\n                       \
    \  +--<-- term ----- || ----+    logical OR\n"
- title: 3.1.2  term
  contents:
  - "3.1.2  term\n   ------- factor -------+------------------------+-------------------\n\
    \                         |                        |\n                       \
    \  +--<-- factor --- && ----+    logical AND\n"
- title: 3.1.3  factor
  contents:
  - "3.1.3  factor\n   ------------+-------- attrib  ==  operand_list --------+-----------\n\
    \               |                                          |\n               +------------\
    \ ( expression ) --------------+\n"
- title: 3.1.4  operand_list
  contents:
  - "3.1.4  operand_list\n   ----------+------------------ operand -----------------+-----------\n\
    \             |                                            |\n             +--\
    \ ( operand ---+-------------------+-- ) --+\n                              |\
    \                   |\n                              +-<-- operand  , ---+\n"
- title: 3.1.5  operand
  contents:
  - "3.1.5  operand\n   ------------- value ---------+----------------------+--------------\n\
    \                                |                      |\n                  \
    \              +------- / width ------+\n                                |   \
    \                   |\n                                +------- & mask -------+\n"
- title: 3.1.6  Test Part
  contents:
  - "3.1.6  Test Part\n   The IF statement evaluates a logical expression.  If the\
    \ expression\n   value is TRUE, the action indicated in the 'Action Part' of the\n\
    \   diagram is executed.  If the value is FALSE and the IF has an ELSE\n   clause,\
    \ that ELSE clause is executed (see below).\n   The simplest form of expression\
    \ is a test for equality (== operator);\n   in this an RTFM attribute value (from\
    \ the packet or from an SRL\n   variable) is ANDed with a mask and compared with\
    \ a value.  A list of\n   RTFM attributes is given in Appendix C. More complicated\
    \ expressions\n   may be built up using parentheses and the && (logical AND) and\
    \ ||\n   (logical OR) operators.\n   Operand values may be specified as dotted\
    \ decimal, hexadecimal or as\n   a character constant (enclosed in apostrophes).\
    \  The syntax for\n   operand values is given in Appendix B.\n   Masks may be\
    \ specified as numbers,\n           dotted decimal  e.g. &255.255\n        or\
    \ hexadecimal     e.g. &FF-FF\n   or as a width in bits   e.g. /16\n   If a mask\
    \ is not specified, an all-ones mask is used.\n   In SRL a value is always combined\
    \ with a mask; this combination is\n   referred to as an operand.  For example,\
    \ if we were interested in\n   flows originating from IP network 130.216, we might\
    \ write:\n      IF SourcePeerAddress == 130.216.0.0 & 255.255.0.0  SAVE;\n   or\
    \ equivalently\n      IF SourcePeerAddress == 130.216/16  SAVE;\n   A list of\
    \ values enclosed in parentheses may also be specified; the\n   test succeeds\
    \ if the masked attribute equals any of the values in the\n   list.  For example:\n\
    \      IF SourcePeerAddress == ( 130.216.7/24, 130.216.34/24 ) SAVE;\n   As this\
    \ last example indicates, values are right-padded with zeroes,\n   i.e. the given\
    \ numbers specify the leading bytes of masks and values.\n   The operand values\
    \ and masks used in an IF statement must be\n   consistent with the attribute\
    \ being tested.  For example, a four-byte\n   value is acceptable as a peer address,\
    \ but would not be accepted as a\n   transport address (which may not be longer\
    \ than two bytes).\n"
- title: 3.1.7  Action Part
  contents:
  - "3.1.7  Action Part\n   A SAVE action (i.e. SAVE , or SAVE ;) saves attribute(s),\
    \ mask(s) and\n   value(s) as given in the statement.  If the IF expression tests\
    \ more\n   than one attribute, the masks and values are saved for all the\n  \
    \ matched attributes.  For each value_list in the statement the value\n   saved\
    \ is the one which the packet actually matched.  See below for\n   further description\
    \ of SAVE statements.\n   Other actions are described in detail under \"Imperative\
    \ statements\"\n   below.  Note that the RETURN action is valid only within subroutines.\n"
- title: 3.1.8  ELSE Clause
  contents:
  - "3.1.8  ELSE Clause\n   An ELSE Clause provides a statement which will be executed\
    \ if the\n   IF's test fails.  The statement following ELSE will often be another\n\
    \   IF statement, providing SRL's version of a 'select' statement.  Note\n   that\
    \ an ELSE clause always matches the immediately preceding IF.\n"
- title: 3.2  Compound_statement
  contents:
  - "3.2  Compound_statement\n   -------+-------------+----- { ---+---- Statement\
    \ ----+--- } -------\n          |             |           |                  \
    \ |\n          +-- label : --+           +--------<----------+\n   A compound\
    \ statement is a sequence of statements enclosed in braces.\n   Each statement\
    \ will terminate with a semicolon, unless it is another\n   compound statement\
    \ (which terminates with a right brace).\n   A compound statement may be labelled,\
    \ i.e. preceded by an identifier\n   followed by a semi-colon.  Each statement\
    \ inside the braces is\n   executed in sequence unless an EXIT statement is performed,\
    \ as\n   explained below.\n   Labels have a well-defined scope, within which they\
    \ must be unique.\n   Labels within a subroutine (i.e. between a SUBROUTINE and\
    \ its\n   matching ENDSUB) are local to that subroutine and are not visible\n\
    \   outside it.  Labels outside subroutines are part of a program's outer\n  \
    \ block.\n"
- title: 3.3  Imperative_statement
  contents:
  - "3.3  Imperative_statement\n   ------+---------------------------------------------------+------\
    \ ;\n         |                                                   |\n        \
    \ +-- SAVE attrib --+--+-----------+--+---------------+\n         |          \
    \       |  |           |  |               |\n         |                 |  +-\
    \ / width -+  |               |\n         |                 |  |           | \
    \ |               |\n         |                 |  +- & mask --+  |          \
    \     |\n         |                 |                 |               |\n    \
    \     |                 +--- = operand ---+               |\n         |      \
    \                                             |\n         +-- COUNT ------------------------------------------+\n\
    \         |                                                   |\n         +--\
    \ EXIT label  ------------------------------------+\n         |              \
    \                                     |\n         +-- IGNORE -----------------------------------------+\n\
    \         |                                                   |\n         +--\
    \ NOMATCH ----------------------------------------+\n         |              \
    \                                     |\n         +-- RETURN --+-------+------------------------------+\n\
    \         |            |       |                              |\n         |  \
    \          +-- n --+                              |\n         |              \
    \                                     |\n         +-- STORE variable := value\
    \ ------------------------+\n"
- title: 3.3.1  SAVE Statement
  contents:
  - "3.3.1  SAVE Statement\n   The SAVE statement saves information which will (later)\
    \ identify the\n   flow in the meter's flow table.  It does not actually record\
    \ anything\n   in the table; this is done when a subsequent COUNT statement\n\
    \   executes.\n   SAVE has two possible forms:\n   SAVE attrib = operand ; saves\
    \ the attribute, mask and value as given\n        in the statement.  This form\
    \ of the SAVE statement is similar to\n        that allowed in an IF statement,\
    \ except that - since imperative\n        statements do not perform a test - you\
    \ may save an arbitrary\n        value.\n   SAVE attrib ;\n   SAVE attrib / width\
    \ ;\n   SAVE attrib & mask ; saves the attribute and mask from the statement,\n\
    \        and the value resulting from their application to the current\n     \
    \   packet.  This is most useful when used to save a value with a\n        wider\
    \ mask than than was used to select the packet.  For\n        example:\n     \
    \        IF DestPeerAddress == 130.216/16\n                     NOMATCH;\n   \
    \          ELSE IF SourcePeerAddress == 130.216/16 {\n                     SAVE\
    \ SourcePeerAddress /24;\n                     COUNT;\n                     }\n\
    \             ELSE IGNORE;\n"
- title: 3.3.2  COUNT Statement
  contents:
  - "3.3.2  COUNT Statement\n   The COUNT statement appears after all testing and\
    \ saving is complete;\n   it instructs the PME to build the flow identifier from\
    \ the attributes\n   which have been SAVEd, find it in the meter's flow table\
    \ (creating a\n   new entry if this is the first packet observed for the flow),\
    \ and\n   increment its counters.  The meter then moves on to examine the next\n\
    \   incoming packet.\n"
- title: 3.3.3  EXIT Statement
  contents:
  - "3.3.3  EXIT Statement\n   The EXIT statement exits a labelled compound statement.\
    \  The next\n   statement to be executed will be the one following that compound\n\
    \   statement.  This provides a well-defined way to jump to a clearly\n   identified\
    \ point in a program.  For example:\n   outer: {\n      ...\n      if SourcePeerAddress\
    \ == 192.168/16\n         exit outer;  # exits the statement labelled 'outer'\n\
    \      ...\n      }\n   # execution resumes here\n   In practice the language\
    \ provides sufficient logical structure that\n   one seldom - if ever - needs\
    \ to use the EXIT statement.\n"
- title: 3.3.4  IGNORE Statement
  contents:
  - "3.3.4  IGNORE Statement\n   The IGNORE statement terminates examination of the\
    \ current packet\n   without saving any information from it.  The meter then moves\
    \ on to\n   examine the next incoming packet, beginning again at the first\n \
    \  statement of its program.\n"
- title: 3.3.5  NOMATCH Statement
  contents:
  - "3.3.5  NOMATCH Statement\n   The NOMATCH statement indicates that matching has\
    \ failed for this\n   execution of the program.  If it is executed when a packet\
    \ is being\n   processed with its addresses in 'on the wire' order, the PME will\n\
    \   perform the program again from the beginning with source and\n   destination\
    \ addresses interchanged.  If it is executed following such\n   an interchange,\
    \ the packet will be IGNOREd.\n   NOMATCH is illustrated in the SAVE example (section\
    \ 3.3.1), where it\n   is used to ensure that flows having 130.216/16 as an end-point\
    \ are\n   counted as though 130.216 had been those flows' source peer (IP)\n \
    \  address.\n"
- title: 3.3.6  STORE Statement
  contents:
  - "3.3.6  STORE Statement\n   The STORE statement assigns a value to an SRL variable\
    \ and SAVEs it.\n   There are six SRL variables:\n           SourceClass     \
    \   SourceKind\n           DestClass          DestKind\n           FlowClass \
    \         FlowKind\n   Their names have no particular significance; they were\
    \ arbitrarily\n   chosen as likely RTFM attributes but can be used to store any\n\
    \   single-byte integer values.  Their values are set to zero each time\n   examination\
    \ of a new packet begins.  For example:\n   STORE SourceClass := 3;\n   STORE\
    \ FlowKind := 'W'\n"
- title: 3.3.7  RETURN Statement
  contents:
  - "3.3.7  RETURN Statement\n   The RETURN statement is used to return from subroutines\
    \ and can be\n   used only within the context of a subroutine.  It is described\
    \ in\n   detail below (CALL statement).\n"
- title: 3.4  Subroutine_declaration
  contents:
  - "3.4  Subroutine_declaration\n   -- SUBROUTINE subname ( --+-----------------------------+--\
    \ ) -->\n                             |                             |\n      \
    \                       +--+-- ADDRESS --- pname --+--+\n                    \
    \            |                       |\n                                +-- VARIABLE\
    \ -- pname --+\n                                |                       |\n  \
    \                              +------<------- , ------+\n          >------+--------\
    \ Statement ---------+----- ENDSUB -------- ;\n                 |            \
    \                |\n                 +-------------<--------------+\n   A Subroutine\
    \ declaration has three parts:\n      the subname is an identifier, used to name\
    \ the subroutine.\n      the parameter list specifies the subroutine's parameters.\
    \  Each\n         parameter is preceded with a keyword indicating its type -\n\
    \         VARIABLE indicates an SRL variable (see the STORE statement\n      \
    \   above), ADDRESS indicates any other RTFM attribute.  A\n         parameter\
    \ name may be any identifier, and its scope is limited\n         to the subroutine's\
    \ body.\n      the body specifies what processing the subroutine will perform.\n\
    \         This is simply a sequence of Statements, terminated by the\n       \
    \  ENDSUB keyword.\n   Note that EXITs in a subroutine may not refer to labels\
    \ outside it.\n   The only way to leave a subroutine is via a RETURN statement.\n"
- title: 3.5  CALL_statement
  contents:
  - "3.5  CALL_statement\n   ---- CALL subname ( --+---------------------+-- ) ---->\n\
    \                         |                     |\n                         +--+--\
    \ parameter --+--+\n                            |               |\n          \
    \                  +----<--- , ----+\n         >---+-------------------------------------+---\
    \ ENDCALL ---- ;\n             |                                     |\n     \
    \        +---+--+-- n : --+--- Statement --+---+\n                 |  |      \
    \   |                |\n                 |  +----<----+                |\n   \
    \              |                             |\n                 +--------------<--------------+\n\
    \   The CALL statement invokes an SRL subroutine.  The parameters are SRL\n  \
    \ variables or other RTFM attributes, and their types must match those\n   in\
    \ the subroutine declaration.  Following the parameters is a\n   sequence of statements,\
    \ each preceded by an integer label.  These\n   labels will normally be 1:, 2:,\
    \ 3:, etc, but they do not have to be\n   contiguous, nor in any particular order.\
    \  They are referred to in\n   RETURN statements within the subroutine body.\n\
    \   e.g. RETURN 2;   would return to the statement labelled 2:\n             \
    \          within in the CALL statement.\n   Execution of the labelled statement\
    \ completes the CALL.\n   If the return statement does not specify a return label,\
    \ the first\n   statement executed after RETURN will be the statement immediately\n\
    \   following ENDCALL.\n"
- title: 4  Example Programs
  contents:
  - '4  Example Programs

    '
- title: 4.1  Classify IP Port Numbers
  contents:
  - "4.1  Classify IP Port Numbers\n   #\n   #  Classify IP port numbers\n   #\n \
    \     define IPv4 = 1;  # Address Family number from [ASG-NBR]\n   #\n      define\
    \ ftp = (20, 21);  # Well-Known Port numbers from [ASG-NBR]\n      define telnet\
    \ = 23;\n      define www = 80;\n   #\n      define tcp = 6;  # Protocol numbers\
    \ from [ASG-NBR]\n      define udp = 17;\n   #\n      if SourcePeerType == IPv4\
    \ save;\n      else ignore;  # Not an IPv4 packet\n   #\n      if (SourceTransType\
    \ == tcp || SourceTransType == udp) save, {\n         if SourceTransAddress ==\
    \ (www, ftp, telnet)  nomatch;\n            # We want the well-known port as Dest\n\
    \   #\n         if DestTransAddress == telnet\n            save, store FlowKind\
    \ := 'T';\n         else if DestTransAddress == www\n            save, store FlowKind\
    \ := 'W';\n         else if DestTransAddress == ftp\n            save, store FlowKind\
    \ := 'F';\n         else {\n            save DestTransAddress;\n            store\
    \ FlowKind := '?';\n            }\n         }\n      else save SourceTransType\
    \ = 0;\n   #\n      save SourcePeerAddress /32;\n      save DestPeerAddress  \
    \ /32;\n      count;\n   #\n   This program counts only IP packets, saving SourceTransType\
    \ (tcp, udp\n   or 0), Source- and DestPeerAddress (32-bit IP addresses) and FlowKind\n\
    \   ('W' for www, 'F' for ftp, 'T' for telnet, '?' for unclassified).\n   The\
    \ program uses a NOMATCH action to specify the packet direction -\n   its resulting\
    \ flows will have the well-known ports as their\n   destination.\n"
- title: 4.2  Classify Traffic into Groups of Networks
  contents:
  - "4.2  Classify Traffic into Groups of Networks\n   #\n   # SRL program to classify\
    \ traffic into network groups\n   #\n   define my_net = 130.216/16;\n   define\
    \ k_nets = ( 130.217/16, 130.123/16, 130.195/16,\n                    132.181/16,\
    \ 138.75/16, 139.80/16 );\n   #\n      call net_kind (SourcePeerAddress, SourceKind)\n\
    \         endcall;\n      call net_kind (DestPeerAddress,   DestKind)\n      \
    \   endcall;\n      count;\n   #\n      subroutine net_kind (address addr, variable\
    \ net)\n         if addr == my_net save, {\n            store net := 10;  return\
    \ 1;\n            }\n         else if addr == k_nets save, {\n            store\
    \ net := 20;  return 2;\n            }\n         save addr/24;  # Not my_net or\
    \ in k_nets\n         store net := 30;  return 3;\n         endsub;\n   #\n  \
    \ The net_kind subroutine determines whether addr is my network\n   (130.216),\
    \ one of the Kawaihiko networks (in the k_nets list), or\n   some other network.\
    \  It saves the network address from addr (16 bits\n   for my_net and the k_net\
    \ networks, 24 bits for others), stores a\n   value of 10, 20 or 30 in net, and\
    \ returns to 1:, 2:  or 3:.  Note\n   that the network numbers used are contained\
    \ within the two DEFINEs,\n   making them easy to change.\n   net_kind is called\
    \ twice, saving Source- and DestPeerAddress and\n   Source- and DestKind; the\
    \ COUNT statement produces flows identified\n   by these four RTFM attributes,\
    \ with no particular source-dest\n   ordering.\n   In the program no use is made\
    \ of return numbers and they could have\n   been omitted.  However, we might wish\
    \ to re-use the subroutine in\n   another program doing different things for different\
    \ return numbers,\n   as in the version below.\n   call net_kind (DestPeerAddress,\
    \ DestKind)\n      1: nomatch;  # We want my_net as source\n         endcall;\n\
    \   call net_kind (SourcePeerAddress, SourceKind)\n      1: count;    # my_net\
    \ -> other networks\n         endcall;\n   save SourcePeerAddress /24;\n   save\
    \ DestPeerAddress /24;\n   count;\n   This version uses a NOMATCH statement to\
    \ ensure that its resulting\n   flows have my_net as their source.  The NOMATCH\
    \ also rejects my_net\n   -> my_net traffic.  Traffic which doesn't have my_net\
    \ as source or\n   destination saves 24 bits of its peer addresses (the subroutine\
    \ might\n   only have saved 16) before counting such an unusual flow.\n"
- title: 5  Security Considerations
  contents:
  - "5  Security Considerations\n   SRL is a language for creating rulesets (i.e.\
    \ configuration files)\n   for RTFM Traffic Meters - it does not present any security\
    \ issues in\n   itself.\n   On the other hand, flow data gathered using such rulesets\
    \ may well be\n   valuable.  It is therefore important to take proper precautions\
    \ to\n   ensure that access to the meter and its data is secure.  Ways to\n  \
    \ achieve this are discussed in detail in the Architecture and Meter\n   MIB documents\
    \ [RTFM-ARC, RTFM-MIB].\n"
- title: 6  IANA Considerations
  contents:
  - "6  IANA Considerations\n   Appendix C below lists the RTFM attributes by name.\
    \  Since SRL only\n   refers to attributes by name, SRL users do not have to know\
    \ the\n   attribute numbers.\n   The size (in bytes) of the various attribute\
    \ values is also listed in\n   Appendix C. These sizes reflect the object sizes\
    \ for the attribute\n   values as they are stored in the RTFM Meter MIB [RTFM-MIB].\n\
    \   IANA considerations for allocating new attributes are discussed in\n   detail\
    \ in the RTFM Architecture document [RTFM-ARC].\n"
- title: 7  APPENDICES
  contents:
  - '7  APPENDICES

    '
- title: '7.1  Appendix A: SRL Syntax in BNF'
  contents:
  - "7.1  Appendix A: SRL Syntax in BNF\n      <SRL program>    ::=  <S or D> | <SRL\
    \ program> <S or D>\n      <S or D>         ::=  <statement> | <declaration>\n\
    \      <declaration>    ::=  <Subroutine declaration>\n      <statement>     \
    \ ::=  <IF statement> |\n                            <Compound statement> |\n\
    \                            <Imperative statement> |\n                      \
    \      <CALL statement>\n      <IF statement>   ::=  IF <expression> <if action>\
    \ <opt else>\n      <if action>      ::=  SAVE ; |\n                         \
    \   SAVE , <statement> |\n                            <statement>\n      <opt\
    \ else>       ::=  <null> |\n                            ELSE <statement>\n  \
    \    <expression>     ::=  <term> | <term> || <term>\n      <term>           ::=\
    \  <factor> | <factor> && <factor>\n      <factor>         ::=  <attribute> ==\
    \ <operand list> |\n                            ( <expression> )\n      <operand\
    \ list>   ::=  <operand> | ( <actual operand list> )\n      <actual operand list>\
    \ ::= <operand> |\n                            <actual operand list> , <operand>\n\
    \      <operand>        ::=  <value> |\n                            <value> /\
    \ <width> |\n                            <value> & <mask>\n      <Compound statement>\
    \ ::= <opt label> { <statement seq> }\n      <opt label>      ::=  <null> |\n\
    \                            <identifier> :\n      <statement seq>  ::=  <statement>\
    \ | <statement seq> <statement>\n      <Imperative statement> ::=  ; |\n     \
    \                       SAVE <attribute> <opt operand> ; |\n                 \
    \           COUNT ; |\n                            EXIT <label> ; |\n        \
    \                    IGNORE ; |\n                            NOMATCH ; |\n   \
    \                         RETURN <integer> ; |\n                            RETURN\
    \ ; |\n                            STORE <variable> := <value> ;\n      <opt operand>\
    \    ::=  <null> |\n                            <width or mask> |\n          \
    \                  = <operand>\n      <width or mask>   ::= / <width> | & <mask>\n\
    \      <Subroutine declaration> ::=\n                            SUBROUTINE <sub\
    \ header> <sub body> ENDSUB ;\n      <sub header>     ::=  <subname> ( ) |\n \
    \                           <subname> ( <sub param list> )\n      <sub param list>\
    \ ::= <sub param> | <sub param list> , <sub param>\n      <sub param>      ::=\
    \  ADDRESS <pname> | VARIABLE <pname>\n      <pname>          ::=  <identifier>\n\
    \      <sub body>       ::=  <statement sequence>\n      <CALL statement> ::=\
    \  CALL <call header> <opt call body> ENDCALL ;\n      <call header>    ::=  <subname>\
    \ ( ) |\n                            <subname> ( <call param list> )\n      <call\
    \ param list> ::= <call param> |\n                            <call param list>\
    \ , <call param>\n      <call param>     ::=  <attribute> | <variable>\n     \
    \ <opt call body>  ::=  <null> |\n                            <actual call body>\n\
    \      <actual call body> ::=  <numbered statement> |\n                      \
    \      <actual call body> <numbered statement>\n      <numbered statement> ::=\
    \ <int label seq> <statement>\n      <int label seq>  ::=  <integer> : | <int\
    \ label seq> <integer> :\n   The following are terminals, recognised by the scanner:\n\
    \      <identifier>     Described in section 2\n      <integer>        A decimal\
    \ integer\n      <attribute>      Attribute name, as listed in Appendix C\n  \
    \    <value>, <mask>  Described in section 5.2\n      <width>     ::= <integer>\n\
    \      <label>     ::= <identifier>\n      <variable>  ::=  SourceClass | DestClass\
    \ | FlowClass |\n                        SourceKind | DestKind | FlowKind\n"
- title: '7.2  Appendix B: Syntax for Values and Masks'
  contents:
  - "7.2  Appendix B: Syntax for Values and Masks\n   Values and masks consist of\
    \ sequences of numeric fields, each of one\n   or more bytes.  The non-blank character\
    \ following a field indicates\n   the field width, and whether the number is decimal\
    \ or hexadecimal.\n   These 'field type' characters may be:\n     .  period  \
    \    decimal, single byte\n     -  minus       hex,     single byte\n     !  exclaim\
    \     decimal, two bytes\n   For example, 130.216.0.0 is an IP address (in dotted\
    \ decimal), and\n   FF-FF-00-00 is an IP address in hexadecimal.\n   The last\
    \ field of a value or mask has no field width character.\n   Instead it takes\
    \ the same width as the preceding field.  For example,\n   1.3.10!50 and 1.3.0.10.0.50\
    \ are two different ways to specify the\n   same value.\n   Unspecified fields\
    \ (at the right-hand side of a value or mask) are\n   set to zero, i.e. 130.216\
    \ is the same as 130.216.0.0.\n   If only a single field is specified (no field\
    \ width character), the\n   value given fills the whole field.  For example, 23\
    \ and 0.23 specify\n   the same value for a SourceTransAddress operand.  For variables\n\
    \   (which have one-byte values) a C-style character constant may also be\n  \
    \ used.\n   IPv6 addresses and masks may also be used, following the conventions\n\
    \   set out in the IP Version 6 Addressing Architecture RFC [V6-ADR].\n"
- title: '7.3  Appendix C: RTFM Attribute Information'
  contents:
  - "7.3  Appendix C: RTFM Attribute Information\n   The following attributes may\
    \ be tested in an IF statement, and their\n   values may be SAVEd (except for\
    \ MatchingStoD). Their maximum size (in\n   bytes) is shown to the left, and a\
    \ brief description is given for\n   each.  The names given here are reserved\
    \ words in SRL (they are\n   <attribute> terminals in the grammar given in Appendix\
    \ A).\n   Note that this table gives only a very brief summary.  The Meter MIB\n\
    \   [RTFM-MIB] provides the definitive specification of attributes and\n   their\
    \ allowed values.  The MIB variables which represent flow\n   attributes have\
    \ 'flowData' prepended to their names to indicate that\n   they belong to the\
    \ MIB's flowData table.\n   1  SourceInterface, DestInterface\n         Interface(s)\
    \ on which the flow was observed\n   1  SourceAdjacentType, DestAdjacentType\n\
    \         Indicates the interface type(s), i.e. an ifType from [ASG-NBR],\n  \
    \       or an Address Family Number (if metering within a tunnel)\n   0  SourceAdjacentAddress,\
    \ DestAdjacentAddress\n         For IEEE 802.x interfaces, the MAC addresses for\
    \ the flow\n   1  SourcePeerType, DestPeerType\n         Peer protocol types,\
    \ i.e. Address Family Number from [ASG-NBR],\n         such as IPv4, Novell, Ethertalk,\
    \ ..\n   0  SourcePeerAddress, DestPeerAddress\n         Peer Addresses (size\
    \ varies, e.g. 4 for IPv4, 3 for Ethertalk))\n   1  SourceTransType, DestTransType\n\
    \         Transport layer type, i.e. Protocol Number from [ASG-NBR]\n        \
    \ such as tcp(6), udp(17), ospf(89), ..\n   2  SourceTransAddress, DestTransAddress\n\
    \         Transport layer addresses (e.g. port numbers for TCP and UDP)\n   1\
    \  FlowRuleset\n         Rule set number for the flow\n   1  MatchingStoD\n  \
    \       Indicates whether the packet is being matched with its\n         addresses\
    \ in 'wire order.'  See [RTFM-ARC] for details.\n   The following variables may\
    \ be tested in an IF, and their values may\n   be set by a STORE. They all have\
    \ one-byte values.\n      SourceClass, DestClass, FlowClass,\n      SourceKind,\
    \  DestKind,  FlowKind\n   The following RTFM attributes are not address attributes\
    \ - they are\n   measured attributes of a flow.  Their values may be read from\
    \ an RTFM\n   meter.  (For example, NeTraMet uses a FORMAT statement to specify\n\
    \   which attribute values are to be read from the meter.)\n   8  ToOctets, FromOctets\n\
    \         Total number of octets seen for each direction of the flow\n   8  ToPDUs,\
    \ FromPDUs\n         Total number of PDUs seen for each direction of the flow\n\
    \   4  FirstTime, LastActiveTime\n         Time (in centiseconds) that first and\
    \ last PDUs were seen\n         for the flow\n   Other attributes will be defined\
    \ by the RTFM working group from time\n   to time.\n"
- title: 8  Acknowledgments
  contents:
  - "8  Acknowledgments\n   The SRL language is part of the RTFM Working Group's efforts\
    \ to make\n   the RTFM traffic measurement system easier to use.  Initial work\
    \ on\n   the language was done by Cyndi Mills and Brad Frazee in Boston.  SRL\n\
    \   was developed in Auckland; it was greatly assisted by detailed\n   discussion\
    \ with John White and Russell Fulton.  Discussion has\n   continued on the RTFM\
    \ and NeTraMet mailing lists.\n"
- title: 9  References
  contents:
  - "9  References\n   [ASG-NBR]  Reynolds, J. and J. Postel, \"Assigned Numbers\"\
    ,\n              STD 2, RFC 1700, October 1994.\n   [NETRAMET] Brownlee, N., NeTraMet\
    \ home page,\n              http://www.auckland.ac.nz/net/NeTraMet\n   [RTFM-ARC]\
    \ Brownlee, N., Mills, C. and G. Ruth, \"Traffic Flow\n              Measurement:\
    \ Architecture\", RFC 2722, October 1999.\n   [RTFM-MIB] Brownlee, N., \"Traffic\
    \ Flow Measurement: Meter MIB\",\n              RFC 2720, October 1999.\n   [V6-ADDR]\
    \  Hinden, R. and S. Deering, \"IP Version 6 Addressing\n              Architecture,\"\
    \ RFC 2373, July 1998.\n"
- title: 10  Author's Address
  contents:
  - "10  Author's Address\n   Nevil Brownlee\n   Information Technology Systems &\
    \ Services\n   The University of Auckland\n   Private Bag 92-019\n   Auckland,\
    \ New Zealand\n   Phone: +64 9 373 7599 x8941\n   EMail: n.brownlee@auckland.ac.nz\n"
- title: 11  Full Copyright Statement
  contents:
  - "11  Full Copyright Statement\n   Copyright (C) The Internet Society (1999). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
