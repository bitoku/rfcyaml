- contents:
  - "             Managed Objects for Controlling the Collection\n               and
    Storage of Accounting Information for\n                      Connection-Oriented
    Networks\n"
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1 Introduction ....................................................
    2\n   2 The SNMP Network Management Framework ........................... 2\n
    \  3 Overview ........................................................ 3\n   3.1
    Operational Model ............................................. 3\n   3.2 Selection
    of Accounting Data .................................. 5\n   3.3 Format of Collection
    File ..................................... 6\n   4 Definitions .....................................................
    9\n   5 Acknowledgements ................................................25\n
    \  6 References ......................................................25\n   7
    Security Considerations .........................................27\n   8 IANA
    Considerations .............................................27\n   9 Authors'
    Addresses ..............................................28\n   10 Full Copyright
    Statement .......................................29\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This memo defines a portion of the Management Information
    Base (MIB)\n   for use with network management protocols in the Internet community.\n
    \  In particular, it describes managed objects used for controlling the\n   collection
    and storage of accounting information for connection-\n   oriented networks such
    as ATM.  The accounting data is collected into\n   files for later retrieval via
    a file transfer protocol.  For\n   information on data which can be collected
    for ATM networks, see\n   [19].\n"
  title: 1.  Introduction
- contents:
  - "2.  The SNMP Network Management Framework\n   The SNMP Management Framework presently
    consists of five major\n   components:\n   o    An overall architecture, described
    in RFC 2271 [1].\n   o    Mechanisms for describing and naming objects and events
    for the\n        purpose of management.  The first version of this Structure of\n
    \       Management Information (SMI) is called SMIv1 and described in\n        STD
    16, RFC 1155 [2], STD 16, RFC 1212 [3] and RFC 1215 [4].\n        The second version,
    called SMIv2, is described in RFC 1902 [5],\n        RFC 1903 [6] and RFC 1904
    [7].\n   o    Message protocols for transferring management information.  The\n
    \       first version of the SNMP message protocol is called SNMPv1 and\n        described
    in STD 15, RFC 1157 [8].  A second version of the SNMP\n        message protocol,
    which is not an Internet standards track\n        protocol, is called SNMPv2c
    and described in RFC 1901 [9] and\n        RFC 1906 [10].  The third version of
    the message protocol is\n        called SNMPv3 and described in RFC 1906 [10],
    RFC 2272 [11] and\n        RFC 2274 [12].\n   o    Protocol operations for accessing
    management information.  The\n        first set of protocol operations and associated
    PDU formats is\n        described in STD 15, RFC 1157 [8].  A second set of protocol\n
    \       operations and associated PDU formats is described in RFC 1905\n        [13].\n
    \  o    A set of fundamental applications described in RFC 2273 [14] and\n        the
    view-based access control mechanism described in RFC 2275\n        [15].\n   Managed
    objects are accessed via a virtual information store, termed\n   the Management
    Information Base or MIB.  Objects in the MIB are\n   defined using the mechanisms
    defined in the SMI.\n   This memo specifies a MIB module that is compliant to
    the SMIv2.  A\n   MIB conforming to the SMIv1 can be produced through the appropriate\n
    \  translations.  The resulting translated MIB must be semantically\n   equivalent,
    except where objects or events are omitted because no\n   translation is possible
    (e.g., use of Counter64).  Some machine\n   readable information in SMIv2 will
    be converted into textual\n   descriptions in SMIv1 during the translation process.
    \ However, this\n   loss of machine readable information is not considered to
    change the\n   semantics of the MIB.\n"
  title: 2.  The SNMP Network Management Framework
- contents:
  - "3.  Overview\n   In some connection-oriented network environments, there is a
    need for\n   the network administrator to be able to collect accounting data on\n
    \  the usage of bandwidth/resources by connections (e.g., ATM\n   connections)
    within the network.  Data collection should be available\n   for switched virtual
    connections (SVCs and SVPs), and permanent\n   virtual connections (PVCs and PVPs),
    including soft-permanent virtual\n   connections (SPVCCs and SPVPCs).  This need
    exists for ATM networks,\n   and may well exist for other connection-oriented
    networks, such as\n   Frame Relay.\n   The potential quantity of such accounting
    information is such that it\n   is not, in general, feasible to retrieve the information
    via SNMP.  A\n   better method is to store the collected accounting information
    in a\n   file which can be subsequently retrieved via a file transfer\n   protocol.\n
    \  It is, however, appropriate to provide management control of the\n   selection
    and collection of such accounting data via SNMP.  This memo\n   describes a MIB
    module which provides such control in a manner\n   independent of the type of
    network.  One or more other documents\n   provide definitions of particular items
    of accounting data which can\n   be selected; for example, a particular set of
    data items which can be\n   collected for ATM networks is specified in [19].\n"
  - contents:
    - "3.1.  Operational Model\n   The requirement is for switches (e.g., ATM switches)
      to collect data\n   concerning the connections which are routed across some
      subset of\n   their interfaces (e.g., ATM UNI and/or NNI interfaces).  The\n
      \  collected data is stored into one or more \"files\".  The use of\n   multiple
      files allows, for example, the data collected for PVCs to be\n   different from
      that collected for SVCs.\n   In order to retrieve the data currently being stored
      in a file, the\n   administrator instructs the switch to terminate the collection
      of\n   data into that file, and start collecting data into a new file.\n   After
      this operation, the data in the old file is available for\n   retrieval via
      file transfer.\n   A collection file is defined to have a maximum size.  When
      the size\n   of the file currently being collected exceeds a threshold percentage\n
      \  of that maximum size, an SNMP notification (e.g., a trap) can be\n   optionally
      generated.  An SNMP notification might also be generated\n   if the file reaches
      its maximum size.\n   The accounting data collected for each connection consists
      of a set\n   of objects and their values.  The set of objects and their values
      are\n   collected on one or more of the following occasions:\n   (1)  on the
      release (termination) of a connection optionally\n        including failed connection
      attempts;\n   (2)  for each active connection (having a particular minimum age)
      on\n        a periodic basis;\n   (3)  for each active connection (having a
      particular minimum age)\n        when so commanded by a management application.\n
      \  While collecting data to be stored in a particular file, the same set\n   of
      objects is collected for each connection on each occasion.  Having\n   the same
      set of objects stored on each occasion allows the\n   optimization of storing
      only the values of those objects.  This\n   results in a significantly smaller
      file size, since it allows the\n   names of the objects to be stored once and
      only once at the beginning\n   of the file, rather than having to store every
      value as a (name,\n   value) pair.\n   Two modes of agent behaviour are allowed
      on the event of a file\n   reaching its maximum size:\n   (1)  management application
      in control:\n        The agent does not automatically swap to a new file; rather,
      it\n        discards newly collected data until the management application\n
      \       subsequently instructs it to swap to a new file.  Before\n        swapping
      to a new file, the name of the file into which data is\n        currently being
      collected is an implementation issue of no\n        concern to an NM application;
      after swapping to a new file, the\n        name of the file available for retrieval
      is as specified by the\n        controlling MIB objects.  This behaviour allows
      the application\n        to know exactly how many files need to be retrieved
      and their\n        names without having to perform any type of file directory\n
      \       operation, but also results in the possibility that data will be\n        discarded
      if the application does not instruct the agent to swap\n        within the required
      time frame.\n   (2)  agent automatically swaps to new file:\n        The agent
      terminates collection into the current (full) file,\n        and begins collecting
      data into a new version of the same base\n        file name.  This behaviour
      aims to avoid loss of data by\n        assuming that additional storage space
      is actually available to\n        create a new version of the file.  To support
      this behaviour,\n        files are named using suffixes, such that when the
      current\n        version of the file becomes full, the agent begins collecting\n
      \       data into a file with the same base file-name but with an\n        incremented
      (or otherwise modified) suffix.  This requires the\n        application to perform
      file directory operations prior to\n        retrieving completed files in order
      to know how many and which\n        suffixes have been used.\n   With either
      behaviour, any completed file must be an integral number\n   of connection records
      (see below).  When a file reaches its maximum\n   size, collection into that
      file is terminated either immediately\n   before or immediately after storing
      the whole of the current\n   connection record into the file.  The former causes
      the file to be\n   just less than its maximum size, and the latter causes the
      file to be\n   just greater than its maximum size.\n"
    title: 3.1.  Operational Model
  - contents:
    - "3.2.  Selection of Accounting Data\n   The items of accounting data to be collected
      are specified as a set\n   of objects.  Which objects are contained in such
      a set is selectable\n   by an administrator through the specification of one
      or more\n   (subtree, list) tuples, where the set of objects to be collected
      is\n   the union of the subsets specified by each tuple:\n       'subtree' specifies
      an OBJECT IDENTIFIER value such that every\n           object in the subset
      is named by the subtree's value appended\n           with a single additional
      sub-identifier.\n       'list' specifies an OCTET STRING value, such that if
      the N-th bit\n           of the string's value is set then the the subset contains
      the\n           object named by appending N as a single additional sub-\n           identifier
      to the subtree.\n   The rationale for defining each subset as a (subtree,list)
      tuple is\n   that one and only one OBJECT IDENTIFIER and one OCTET STRING is\n
      \  needed to define the subset of objects.  This simplifies the MIB\n   mechanisms
      needed for selection: an NM application needs to create\n   only one conceptual
      row in a MIB table for each subset (rather than\n   needing to create a conceptual
      row in a table for each and every\n   object in the set).\n   The number of
      tuples supported by a particular switch is an\n   implementation choice.  One
      possibility is to support two (subtree,\n   list) tuples so that one such tuple
      can specify a standard 'subtree'\n   (e.g., the atmAcctngDataObjects subtree
      defined in [19]), and the\n   second tuple can specify an enterprise-specific
      'subtree'; this would\n   allow the selected set of objects to be the union
      of a set of\n   standard objects and a set of enterprise-defined objects.\n"
    title: 3.2.  Selection of Accounting Data
  - contents:
    - "3.3.  Format of Collection File\n   A collection file generated by this process
      contains the values of\n   MIB objects defined using the SMIv2.  The standard
      way to encode the\n   values of SNMP MIB objects in a device-independent manner
      is through\n   the use of ASN.1's Basic Encoding Rules (BER) [18].  Thus, the\n
      \  standard format of an accounting file is defined here using the same\n   adapted
      subset of ASN.1 [17] as the SMIv2.\n   The file consists of a set of header
      information followed by a\n   sequence of zero or more collection records.  The
      header information\n   identifies (via sysName [16]) the switch which collected
      the data,\n   the date and time at which the collection in to this file started,\n
      \  and the sequence of one or more (subtree, list) tuples identifying\n   the
      objects whose values are contained in each connection record.\n   The header
      information also includes a textual description of the\n   data contained in
      the file.\n   Each connection record contains a sequence of values for each\n
      \  identified tuple, in the same order as the tuples are identified in\n   the
      header information.  For each tuple, the sequence of values are\n   in ascending
      order of the sub-identifier which identifies them within\n   the subtree.\n
      \  Formally, an accounting file is an ASN.1 value with the following\n   syntax:\n"
    - "File ::=\n   [1]\n      IMPLICIT SEQUENCE {\n                           --
      header information\n          sysName               -- name of the switch\n
      \             DisplayString,\n          description           -- textual description
      of the collection\n              DisplayString,\n          startTime             --
      start time of the collection\n              DateAndTime,\n          SEQUENCE
      OF {         -- sequence of (subtree, list) tuples\n              SEQUENCE {\n
      \                 subtree\n                      OBJECT IDENTIFIER,\n                  list\n
      \                     OCTET STRING\n              }\n          }\n                           --
      sequence of connection records\n          SEQUENCE OF {\n                                --
      each record containing a sequence\n              SEQUENCE OF {     -- per identified
      tuple\n                  SEQUENCE OF {     -- each per-tuple sequence containing\n
      \                     value         -- a sequence of object values\n                          ObjectSyntax\n
      \                 }\n              }\n          }\n      }\n   where:\n   (1)
      \ the value of the sysName component is that of the sysName object\n        in
      the System group [16].\n   (2)  each (subtree, list) specifies the set of objects
      contained in\n        that tuple's sequence within each and every connection
      record.\n   (3)  the tuples' sequences within each connection record occur in
      the\n        same order as the (subtree, list) tuples occur in the header\n
      \       information.\n   (4)  the object values within each connection record
      occur in the\n        same order as they are represented by the bits in the\n
      \       corresponding list value.\n   (5)  ObjectSyntax is defined by the SMIv2
      [5].\n   (6)  One particular category of object values deserves special\n        attention:
      an object defined to hold the checksum value of an\n        accounting record
      (e.g., atmAcctngRecordCrc16, defined in [19]).\n        An object in this category
      will generally have a SYNTAX of a\n        fixed-length OCTET STRING, and have
      its value initialized to the\n        string of all zeros when composing the
      accounting record\n        containing it, with the location of these zeros being
      saved.\n        Once the record is generated, the checksum is calculated over\n
      \       the whole connection record (including the starting SEQUENCE OF\n        and
      the trailing end-of-contents octets, if used), and then the\n        zeros are
      overwritten (at the saved location) by the calculated\n        value of the
      checksum.\n   The encoding of the above syntax using the Basic Encoding Rules
      is\n   the same as defined by the SNMPv2 [10], with the following exception:\n
      \    - when encoding the length field for a structured type, i.e., a\n       SEQUENCE
      or SEQUENCE OF, the indefinite form encoding is\n       permitted.\n   For example,
      the file containing the data:\n   [1] IMPLICIT SEQUENCE     a1 80\n         OCTET
      STRING        04 09 73 77 69 74 63 68 2d 31 32\n         OCTET STRING        04
      0a 41 63 63 6f 75 6e 74 69 6e 67\n         OCTET STRING        04 08 07 cc 07
      14 10 05 00 00\n         SEQUENCE OF         30 0e\n           SEQUENCE             30
      0c\n             OBJECT IDENTIFIER     06 07 2b 06 01 03 7f 01 01\n             OCTET
      STRING          04 01 c0\n         SEQUENCE OF         30 80\n           SEQUENCE
      OF          30 08\n             SEQUENCE OF           30 06\n               INTEGER
      \               02 01 00\n               INTEGER                02 01 21\n           SEQUENCE
      OF          30 08\n             SEQUENCE OF           30 06\n               INTEGER
      \               02 01 00\n               INTEGER                02 01 22\n         end-of-contents
      \    00 00\n       end-of-contents       00 00\n   contains two connection records,
      each containing one tuple listing\n   two (integer) data items in a (fictitious)
      subtree:\n   1.3.6.1.3.127.1.1.  Its header indicates it's for \"switch-12\",
      with\n   description \"Accounting\", and was collected at 16:05:00 on 20 July\n
      \  1996.\n   As well as the standard format defined above, the MIB allows other\n
      \  enterprise-specific formats to be used.\n"
    title: 3.3.  Format of Collection File
  title: 3.  Overview
- contents:
  - '4.  Definitions

    '
  - 'ACCOUNTING-CONTROL-MIB DEFINITIONS ::= BEGIN

    '
  - "IMPORTS\n    MODULE-IDENTITY, OBJECT-TYPE, NOTIFICATION-TYPE,\n    mib-2, Integer32
    \                             FROM SNMPv2-SMI\n    TEXTUAL-CONVENTION, RowStatus,
    TestAndIncr,\n    DisplayString, TruthValue                     FROM SNMPv2-TC\n
    \   MODULE-COMPLIANCE, OBJECT-GROUP, NOTIFICATION-GROUP\n                                                  FROM
    SNMPv2-CONF\n    ifIndex                                       FROM IF-MIB;\n"
  - "accountingControlMIB MODULE-IDENTITY\n    LAST-UPDATED \"9809281000Z\"\n    ORGANIZATION
    \"IETF AToM MIB Working Group\"\n    CONTACT-INFO \"Keith McCloghrie\n                  Cisco
    Systems, Inc.\n                  170 West Tasman Drive,\n                  San
    Jose CA 95134-1706.\n                  Phone: +1 408 526 5260\n                  Email:
    kzm@cisco.com\"\n    DESCRIPTION\n            \"The MIB module for managing the
    collection and storage of\n            accounting information for connections
    in a connection-\n            oriented network such as ATM.\"\n    ::= { mib-2
    60 }\n"
  - 'acctngMIBObjects       OBJECT IDENTIFIER ::= { accountingControlMIB 1 }

    '
  - 'acctngSelectionControl OBJECT IDENTIFIER ::= { acctngMIBObjects 1 }

    '
  - 'acctngFileControl      OBJECT IDENTIFIER ::= { acctngMIBObjects 2 }

    '
  - 'acctngInterfaceControl OBJECT IDENTIFIER ::= { acctngMIBObjects 3 }

    '
  - 'acctngTrapControl      OBJECT IDENTIFIER ::= { acctngMIBObjects 4 }

    '
  - '-- Textual Conventions

    '
  - "DataCollectionSubtree ::= TEXTUAL-CONVENTION\n    STATUS       current\n    DESCRIPTION\n
    \           \"The subtree component of a (subtree, list) tuple.  Such a\n            (subtree,
    list) tuple defines a set of objects and their\n            values to be collected
    as accounting data for a connection.\n            The subtree specifies a single
    OBJECT IDENTIFIER value such\n            that each object in the set is named
    by the subtree value\n            appended with a single additional sub-identifier.\"\n
    \   SYNTAX       OBJECT IDENTIFIER\n"
  - "DataCollectionList ::= TEXTUAL-CONVENTION\n    STATUS       current\n    DESCRIPTION\n
    \           \"The list component of a (subtree, list) tuple.  Such a\n            (subtree,
    list) tuple defines a set of objects and their\n            values to be collected
    as accounting data for a connection.\n            The subtree specifies a single
    OBJECT IDENTIFIER value such\n            that each object in the set is named
    by the subtree value\n            appended with a single additional sub-identifier.
    \ The list\n            specifies a set of data items, where the presence of an
    item\n            in the list indicates that the item is (to be) present in\n
    \           the data collected for a connection; the absence of an item\n            from
    the list indicates that the item is not (to be) present\n            in the data
    collected for a connection.  Each data item is\n            represented by an
    integer which when appended (as as\n            additional sub-identifier) to
    the OBJECT IDENTIFIER value of\n            the subtree identified by the tuple,
    is the name of an\n            object defining that data item (its description
    and its\n            syntax).\n            The list is specified as an OCTET STRING
    in which each data\n            item is represented by a single bit, where data
    items 1\n            through 8 are represented by the bits in the first octet,\n
    \           data items 9 through 16 by the bits in the second octet,\n            etc.
    \ In each octet, the lowest numbered data item is\n            represented by
    the most significant bit, and the highest\n            numbered data item by the
    least significant bit.  A data\n            item is present in the list when its
    bit is set, and absent\n            when its bit is reset.  If the length of an
    OCTET STRING\n            value is too short to represent one or more data items\n
    \           defined in a subtree, then those data items are absent from\n            the
    set identified by the tuple of that subtree and that\n            OCTET STRING
    value.\"\n    SYNTAX       OCTET STRING (SIZE(0..8))\n"
  - "FileIndex ::= TEXTUAL-CONVENTION\n    STATUS       current\n    DESCRIPTION\n
    \           \"An arbitrary integer value identifying a file into which\n            accounting
    data is being collected.\"\n    SYNTAX       Integer32 (1..65535)\n"
  - '-- The Accounting Information Selection table

    '
  - "acctngSelectionTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF AcctngSelectionEntry\n
    \   MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n            \"A
    list of accounting information selection entries.\n            Note that additions,
    modifications and deletions of entries\n            in this table can occur at
    any time, but such changes only\n            take effect on the next occasion
    when collection begins into\n            a new file.  Thus, between modification
    and the next 'swap',\n            the content of this table does not reflect the
    current\n            selection.\"\n    ::= { acctngSelectionControl 1 }\n"
  - "acctngSelectionEntry OBJECT-TYPE\n    SYNTAX      AcctngSelectionEntry\n    MAX-ACCESS
    \ not-accessible\n    STATUS      current\n    DESCRIPTION\n            \"An entry
    identifying an (subtree, list) tuple used to\n            select a set of accounting
    information which is to be\n            collected.\"\n    INDEX   { acctngSelectionIndex
    }\n    ::= { acctngSelectionTable 1 }\n"
  - "AcctngSelectionEntry ::=\n    SEQUENCE {\n        acctngSelectionIndex     Integer32,\n
    \       acctngSelectionSubtree   DataCollectionSubtree,\n        acctngSelectionList
    \     DataCollectionList,\n        acctngSelectionFile      FileIndex,\n        acctngSelectionType
    \     BITS,\n        acctngSelectionRowStatus RowStatus\n    }\n"
  - "acctngSelectionIndex OBJECT-TYPE\n    SYNTAX      Integer32 (1..65535)\n    MAX-ACCESS
    \ not-accessible\n    STATUS      current\n    DESCRIPTION\n            \"An arbitrary
    integer value which uniquely identifies a\n            tuple stored in this table.
    \ This value is required to be\n            the permanent 'handle' for an entry
    in this table for as\n            long as that entry exists, including across
    restarts and\n            power outages.\"\n    ::= { acctngSelectionEntry 1 }\n"
  - "acctngSelectionSubtree OBJECT-TYPE\n    SYNTAX      DataCollectionSubtree\n    MAX-ACCESS
    \ read-create\n    STATUS      current\n    DESCRIPTION\n            \"The combination
    of acctngSelectionSubtree and\n            acctngSelectionList specifies one (subtree,
    list) tuple\n            which is to be collected.\"\n    ::= { acctngSelectionEntry
    2 }\n"
  - "acctngSelectionList OBJECT-TYPE\n    SYNTAX      DataCollectionList\n    MAX-ACCESS
    \ read-create\n    STATUS      current\n    DESCRIPTION\n            \"The combination
    of acctngSelectionSubtree and\n            acctngSelectionList specifies one (subtree,
    list) tuple\n            which is to be collected.\"\n    ::= { acctngSelectionEntry
    3 }\n"
  - "acctngSelectionFile OBJECT-TYPE\n    SYNTAX      FileIndex\n    MAX-ACCESS  read-create\n
    \   STATUS      current\n    DESCRIPTION\n            \"An indication of the file
    into which the accounting\n            information identified by this entry is
    to be stored.  If\n            there is no conceptual row in the acctngFileTable
    for which\n            the value of acctngFileIndex has the same value as this\n
    \           object, then the information selected by this entry is not\n            collected.\"\n
    \   ::= { acctngSelectionEntry 4 }\n"
  - "acctngSelectionType OBJECT-TYPE\n    SYNTAX      BITS { svcIncoming(0),\n                       svcOutgoing(1),\n
    \                      svpIncoming(2),\n                       svpOutgoing(3),\n
    \                      pvc(4),\n                       pvp(5),\n                       spvcOriginator(6),\n
    \                      spvcTarget(7),\n                       spvpOriginator(8),\n
    \                      spvpTarget(9) }\n    MAX-ACCESS  read-create\n    STATUS
    \     current\n    DESCRIPTION\n            \"Indicates the types of connections
    for which the\n            information selected by this entry are to be collected.\"\n
    \   DEFVAL      { { svcIncoming, svcOutgoing,\n                    svpIncoming,
    svpOutgoing } }\n    ::= { acctngSelectionEntry 5 }\n"
  - "acctngSelectionRowStatus OBJECT-TYPE\n    SYNTAX      RowStatus\n    MAX-ACCESS
    \ read-create\n    STATUS      current\n    DESCRIPTION\n            \"The status
    of this conceptual row.  An agent may refuse to\n            create new conceptual
    rows and/or modify existing conceptual\n            rows, if such creation/modification
    would cause multiple\n            rows to have the same values of acctngSelectionSubtree
    and\n            acctngSelectionList.\n            A conceptual row can not have
    the status of 'active' until\n            values have been assigned to the acctngSelectionSubtree,\n
    \           acctngSelectionList and acctngSelectionFile columnar objects\n            within
    that row.\n            An agent must not refuse to change the values of the\n
    \           acctngSelectionSubtree, acctngSelectionList and\n            acctngSelectionFile
    columnar objects within a conceptual row\n            even while that row's status
    is 'active'.  Similarly, an\n            agent must not refuse to destroy an existing
    conceptual row\n            while the file referenced by that row's instance of\n
    \           acctngSelectionFile is in active use, i.e., while the\n            corresponding
    instance of acctngFileRowStatus has the value\n            'active'.  However,
    such changes only take effect upon the\n            next occasion when collection
    begins into a new (version of\n            the) file.\"\n    ::= { acctngSelectionEntry
    6 }\n"
  - '-- The Accounting File table

    '
  - "acctngFileTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF AcctngFileEntry\n    MAX-ACCESS
    \ not-accessible\n    STATUS      current\n    DESCRIPTION\n            \"A list
    of files into which accounting information is to be\n            stored.\"\n    ::=
    { acctngFileControl 1 }\n"
  - "acctngFileEntry OBJECT-TYPE\n    SYNTAX      AcctngFileEntry\n    MAX-ACCESS
    \ not-accessible\n    STATUS      current\n    DESCRIPTION\n            \"An entry
    identifying a file into which accounting\n            information is to be collected.\"\n
    \   INDEX   { acctngFileIndex }\n    ::= { acctngFileTable 1 }\n"
  - "AcctngFileEntry ::=\n    SEQUENCE {\n        acctngFileIndex                 FileIndex,\n
    \       acctngFileName                  DisplayString,\n        acctngFileNameSuffix
    \           DisplayString,\n        acctngFileDescription           DisplayString,\n
    \       acctngFileCommand               INTEGER,\n        acctngFileMaximumSize
    \          Integer32,\n        acctngFileCurrentSize           Integer32,\n        acctngFileFormat
    \               INTEGER,\n        acctngFileCollectMode           BITS,\n        acctngFileCollectFailedAttempts
    BITS,\n        acctngFileInterval              Integer32,\n        acctngFileMinAge
    \               Integer32,\n        acctngFileRowStatus             RowStatus\n
    \   }\n"
  - "acctngFileIndex OBJECT-TYPE\n    SYNTAX      FileIndex\n    MAX-ACCESS  not-accessible\n
    \   STATUS      current\n    DESCRIPTION\n            \"A unique value identifying
    a file into which accounting\n            data is to be stored.  This value is
    required to be the\n            permanent 'handle' for an entry in this table
    for as long as\n            that entry exists, including across restarts and power\n
    \           outages.\"\n    ::= { acctngFileEntry 1 }\n"
  - "acctngFileName OBJECT-TYPE\n    SYNTAX      DisplayString (SIZE(1..32))\n    MAX-ACCESS
    \ read-create\n    STATUS      current\n    DESCRIPTION\n            \"The name
    of the file into which accounting data is to be\n            stored.  If files
    are named using suffixes, then the name of\n            the current file is the
    concatenation of acctngFileName and\n            acctngFileNameSuffix.\n            An
    agent will respond with an error (e.g., 'wrongValue') to\n            a management
    set operation which attempts to modify the\n            value of this object to
    the same value as already held by\n            another instance of acctngFileName.
    \ An agent will also\n            respond with an error (e.g., 'wrongValue') if
    the new value\n            is invalid for use as a file name on the local file
    system\n            (e.g., many file systems do not support white space embedded\n
    \           in file names).\n            The value of this object can not be modified
    while the\n            corresponding instance of acctngFileRowStatus is 'active'.\"\n
    \   ::= { acctngFileEntry 2 }\n"
  - "acctngFileNameSuffix OBJECT-TYPE\n    SYNTAX      DisplayString (SIZE(0..8))\n
    \   MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n            \"The
    suffix, if any, of the name of a file into which\n            accounting data
    is currently being stored.  If suffixes are\n            not used, then the value
    of this object is the zero-length\n            string.  Note that if a separator,
    such as a period, is used\n            in appending the suffix to the file name,
    then that\n            separator appears as the first character of this value.\"\n
    \   ::= { acctngFileEntry 3 }\n"
  - "acctngFileDescription OBJECT-TYPE\n    SYNTAX      DisplayString\n    MAX-ACCESS
    \ read-create\n    STATUS      current\n    DESCRIPTION\n            \"The textual
    description of the accounting data which will\n            be stored (on the next
    occasion) when header information is\n            stored in the file.  The value
    of this object may be\n            modified at any time.\"\n    DEFVAL      {
    \"\" }\n    ::= { acctngFileEntry 4 }\n"
  - "acctngFileCommand OBJECT-TYPE\n    SYNTAX      INTEGER {\n                    --
    the following two values are states:\n                    -- they may be read
    but not written\n                    idle(1),\n                    cmdInProgress(2),\n
    \                   -- the following two values are actions:\n                    --
    they may be written, but are never read\n                    swapToNewFile(3),\n
    \                   collectNow(4)\n                }\n    MAX-ACCESS  read-create\n
    \   STATUS      current\n    DESCRIPTION\n            \"A control object for the
    collection of accounting data.\n            When read the value is either 'idle'
    or 'cmdInProgress'.\n            Writing a value is only allowed when the current
    value is\n            'idle'.  When a value is successfully written, the value\n
    \           changes to 'cmdInProgress' until completion of the action,\n            at
    which time the value reverts to 'idle'.  Actions are\n            invoked by writing
    the following values:\n               'swapToNewFile' - the collection of data
    into the current\n                      file is terminated, and collection continues
    into\n                      a new (version of the) file.\n               'collectNow'
    - the agent creates and stores a connection\n                      record into
    the current file for each active\n                      connection having a type
    matching\n                      acctngSelectionType and an age greater than\n
    \                     acctngFileMinAge.\"\n    DEFVAL      { idle }\n    ::= {
    acctngFileEntry 5 }\n"
  - "acctngFileMaximumSize OBJECT-TYPE\n    SYNTAX      Integer32 (100..2147483647)\n
    \   UNITS       \"bytes\"\n    MAX-ACCESS  read-create\n    STATUS      current\n
    \   DESCRIPTION\n            \"The maximum size of the file (including header\n
    \           information).  When the file of collected data reaches this\n            size,
    either the agent automatically swaps to a new version\n            (i.e., a new
    value acctngFileNameSuffix) of the file, or new\n            records are discarded.
    \ Since a file must contain an\n            integral number of connection records,
    the actual maximum\n            size of the file may be just less OR Just greater
    than the\n            value of this object.\n            The value of this object
    can not be modified while the\n            corresponding instance of acctngFileRowStatus
    is 'active'.\n            The largest value of the maximum file size in some agents\n
    \           will be less than 2147483647 bytes.\"\n    DEFVAL      { 5000000 }\n
    \   ::= { acctngFileEntry 6 }\n"
  - "acctngFileCurrentSize OBJECT-TYPE\n    SYNTAX      Integer32 (0..2147483647)\n
    \   UNITS       \"bytes\"\n    MAX-ACCESS  read-only\n    STATUS      current\n
    \   DESCRIPTION\n            \"The current size of the file into which data is
    currently\n            being collected, including header information.\"\n    ::=
    { acctngFileEntry 7 }\n"
  - "acctngFileFormat OBJECT-TYPE\n    SYNTAX      INTEGER { other(1), ber(2) }\n
    \   MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n            \"An
    indication of the format in which the accounting data is\n            to be stored
    in the file.  If the value is modified, the new\n            value takes effect
    after the next 'swap' to a new file.  The\n            value ber(2) indicates
    the standard format.\"\n    DEFVAL      { ber }\n    ::= { acctngFileEntry 8 }\n"
  - "acctngFileCollectMode OBJECT-TYPE\n    SYNTAX      BITS { onRelease(0), periodically(1)
    }\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n            \"An
    indication of when accounting data is to be written into\n            this file.
    \ Note that in addition to the occasions indicated\n            by the value of
    this object, an agent always writes\n            information on appropriate connections
    to the file when the\n            corresponding instance of acctngFileCommand
    is set to\n            'collectNow'.\n              - 'onRelease' - whenever a
    connection (or possibly,\n                      connection attempt) is terminated,
    either through\n                      a Release message or through management
    removal,\n                      information on that connection is written.\n              -
    'periodically' - information on appropriate connections\n                      is
    written on the expiry of a periodic timer,\n            This value may be modified
    at any time.\"\n    DEFVAL      { { onRelease } }\n    ::= { acctngFileEntry 9
    }\n"
  - "acctngFileCollectFailedAttempts OBJECT-TYPE\n    SYNTAX      BITS { soft(0),
    regular(1) }\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n
    \           \"An indication of whether connection data is to be collected\n            for
    failed connection attempts when the value of the\n            corresponding instance
    of acctngFileCollectMode includes\n            'onRelease'.  The individual values
    have the following\n            meaning:\n              'soft' - indicates that
    connection data is to be collected\n            for failed Soft PVCs/PVPs which
    originate or terminate at\n            the relevant interface.\n              'regular'
    - indicates that connection data is to be\n            collected for failed SVCs,
    including Soft PVCs/PVPs not\n            originating or terminating at the relevant
    interface.\n            This value may be modified at any time.\"\n    DEFVAL
    \     { { soft, regular } }\n    ::= { acctngFileEntry 10 }\n"
  - "acctngFileInterval OBJECT-TYPE\n    SYNTAX      Integer32 (60..86400)\n    UNITS
    \      \"seconds\"\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n
    \           \"The number of seconds between the periodic collections of\n            accounting
    data when the value of the corresponding instance\n            of acctngFileCollectMode
    includes 'periodically'.  Some\n            agents may impose restrictions on
    the range of this\n            interval.  This value may be modified at any time.\"\n
    \   DEFVAL     { 3600 }\n    ::= { acctngFileEntry 11 }\n"
  - "acctngFileMinAge OBJECT-TYPE\n    SYNTAX      Integer32 (60..86400)\n    UNITS
    \      \"seconds\"\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n
    \           \"The minimum age of a connection, as used to determine the\n            set
    of connections for which data is to be collected at the\n            periodic
    intervals and/or when acctngFileCommand is set to\n            'collectNow'.  The
    age of a connection is the elapsed time\n            since it was last installed.\n
    \           When the periodic interval expires for a file or when\n            acctngFileCommand
    is set to 'collectNow', accounting data is\n            collected and stored in
    the file for each connection having\n            a type matching acctngSelectionType
    and whose age at that\n            time is greater than the value of acctngFileMinAge\n
    \           associated with the file.  This value may be modified at any\n            time.\"\n
    \   DEFVAL     { 3600 }\n    ::= { acctngFileEntry 12 }\n"
  - "acctngFileRowStatus OBJECT-TYPE\n    SYNTAX      RowStatus\n    MAX-ACCESS  read-create\n
    \   STATUS      current\n    DESCRIPTION\n            \"The status of this conceptual
    row.\n            This object can not be set to 'active' until a value has\n            been
    assigned to the corresponding instance of\n            acctngFileName.  Collection
    of data into the file does not\n            begin until this object has the value
    'active' and one or\n            more (active) instances of acctngSelectionFile
    refer to it.\n            If this value is modified after a collection has begun,\n
    \           collection into this file terminates and a new (or new\n            version
    of the) file is immediately made ready for future\n            collection (as
    if acctngFileCommand had been set to\n            'swapToNewFile'), but collection
    into the new (or new\n            version of the) file does not begin until the
    value is\n            subsequently set back to active.\"\n    ::= { acctngFileEntry
    13 }\n"
  - '-- Overall Control

    '
  - "acctngAdminStatus OBJECT-TYPE\n    SYNTAX      INTEGER { enabled(1), disabled(2)
    }\n    MAX-ACCESS  read-write\n    STATUS      current\n    DESCRIPTION\n            \"A
    control object to indicate the administratively desired\n            state of
    the collection of accounting records across all\n            interfaces.\n            Modifying
    the value of acctngAdminStatus to 'disabled' does\n            not remove or change
    the current configuration as\n            represented by the active rows in the
    acctngSelectionTable,\n            acctngFileTable and acctngInterfaceTable tables.\"\n
    \   ::= { acctngInterfaceControl 1 }\n"
  - "acctngOperStatus OBJECT-TYPE\n    SYNTAX      INTEGER { enabled(1), disabled(2)
    }\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n            \"A
    status object to indicate the operational state of the\n            collection
    of accounting records across all interfaces.\n            When the value of acctngAdminStatus
    is modified to be\n            'enabled', the value of this object will change
    to 'enabled'\n            providing it is possible to begin collecting accounting\n
    \           records.\n            When the value of acctngAdminStatus is modified
    to be\n            'disabled', the value of this object will change to\n            'disabled'
    as soon as the collection of accounting records\n            has terminated.\"\n
    \   ::= { acctngInterfaceControl 2 }\n"
  - "acctngProtection OBJECT-TYPE\n    SYNTAX      TestAndIncr\n    MAX-ACCESS  read-write\n
    \   STATUS      current\n    DESCRIPTION\n            \"A control object to protect
    against duplication of control\n            commands.  Over some transport/network
    protocols, it is\n            possible for SNMP messages to get duplicated.  Such\n
    \           duplication, if it occurred at just the wrong time could\n            cause
    serious disruption to the collection and retrieval of\n            accounting
    data, e.g., if a SNMP message setting\n            acctngFileCommand to 'swapToNewFile'
    were to be duplicated,\n            a whole file of accounting data could be lost.\n
    \           To protect against such duplication, a management\n            application
    should retrieve the value of this object, and\n            include in the Set
    operation needing protection, a variable\n            binding which sets this
    object to the retrieved value.\"\n    ::= { acctngInterfaceControl 3 }\n"
  - "acctngAgentMode OBJECT-TYPE\n    SYNTAX      INTEGER { swapOnCommand(1), swapOnFull(2)
    }\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n            \"An
    indication of the behaviour mode of the agent when a\n            file becomes
    full:\n               'swapOnCommand' - the agent does not automatically swap\n
    \                     to a new file; rather, it discards newly collected\n                      data
    until a management application subsequently\n                      instructs it
    to swap to a new file.\n               'swapOnFull' - the agent terminates collection
    into the\n                      current file as and when that file becomes full.\"\n
    \   ::= { acctngInterfaceControl 4 }\n"
  - '--  Per-interface control table

    '
  - "acctngInterfaceTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF AcctngInterfaceEntry\n
    \   MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n            \"A
    table controlling the collection of accounting data on\n            specific interfaces
    of the switch.\"\n    ::= { acctngInterfaceControl 5 }\n"
  - "acctngInterfaceEntry OBJECT-TYPE\n    SYNTAX      AcctngInterfaceEntry\n    MAX-ACCESS
    \ not-accessible\n    STATUS      current\n    DESCRIPTION\n            \"An entry
    which controls whether accounting data is to be\n            collected on an interface.
    \ The types of interfaces which\n            are represented in this table is
    implementation-specific.\"\n    INDEX   { ifIndex }\n    ::= { acctngInterfaceTable
    1 }\n"
  - "AcctngInterfaceEntry ::=\n    SEQUENCE {\n        acctngInterfaceEnable     TruthValue\n
    \   }\n"
  - "acctngInterfaceEnable OBJECT-TYPE\n    SYNTAX      TruthValue\n    MAX-ACCESS
    \ read-write\n    STATUS      current\n    DESCRIPTION\n            \"Indicates
    whether the collection of accounting data is\n            enabled on this interface.\"\n
    \   ::= { acctngInterfaceEntry 1 }\n"
  - '-- Objects for controlling the use of Notifications

    '
  - "acctngControlTrapThreshold OBJECT-TYPE\n    SYNTAX      INTEGER (0..99)\n    MAX-ACCESS
    \ read-write\n    STATUS      current\n    DESCRIPTION\n            \"A percentage
    of the maximum file size at which a 'nearly-\n            full' trap is generated.
    \ The value of 0 indicates that no\n            'nearly-full' trap is to be generated.\"\n
    \   ::= { acctngTrapControl 1 }\n"
  - "acctngControlTrapEnable OBJECT-TYPE\n    SYNTAX      TruthValue\n    MAX-ACCESS
    \ read-write\n    STATUS      current\n    DESCRIPTION\n            \"An indication
    of whether the acctngFileNearlyFull and\n            acctngFileFull traps are
    enabled.\"\n    ::= { acctngTrapControl 2 }\n"
  - '-- notifications

    '
  - 'acctngNotifications OBJECT IDENTIFIER ::= { accountingControlMIB 2 }

    '
  - 'acctngNotifyPrefix OBJECT IDENTIFIER ::= { acctngNotifications 0 }

    '
  - "acctngFileNearlyFull NOTIFICATION-TYPE\n    OBJECTS     { acctngFileName,\n                  acctngFileMaximumSize,\n
    \                 acctngControlTrapThreshold,\n                  acctngFileNameSuffix
    }\n    STATUS      current\n    DESCRIPTION\n            \"An indication that
    the size of the file into which\n            accounting information is currently
    being collected has\n            exceeded the threshold percentage of its maximum
    file size.\n            This notification is generated only at the time of the\n
    \           transition from not-exceeding to exceeding.\"\n    ::= { acctngNotifyPrefix
    1 }\n"
  - "acctngFileFull NOTIFICATION-TYPE\n    OBJECTS     { acctngFileName,\n                  acctngFileMaximumSize,\n
    \                 acctngFileNameSuffix }\n    STATUS      current\n    DESCRIPTION\n
    \           \"An indication that the size of the file into which\n            accounting
    information is currently being collected has\n            transistioned to its
    maximum file size.  This notification\n            is generated (for all values
    of acctngAgentMode) at the time\n            of the transition from not-full to
    full.  If acctngAgentMode\n            has the value 'swapOnCommand', it is also
    generated\n            periodically thereafter until such time as collection of\n
    \           data is no longer inhibited by the file full condition.\"\n    ::=
    { acctngNotifyPrefix 2 }\n"
  - '-- conformance information

    '
  - 'acctngConformance OBJECT IDENTIFIER ::= { accountingControlMIB 3 }

    '
  - 'acctngGroups      OBJECT IDENTIFIER ::= { acctngConformance 1 }

    '
  - 'acctngCompliances OBJECT IDENTIFIER ::= { acctngConformance 2 }

    '
  - "acctngCompliance MODULE-COMPLIANCE\n    STATUS  current\n    DESCRIPTION\n            \"The
    compliance statement for switches which implement the\n            Accounting
    Control MIB.\"\n    MODULE  -- this module\n        MANDATORY-GROUPS { acctngBasicGroup,\n
    \                          acctngNotificationsGroup }\n        OBJECT      acctngSelectionType\n
    \       SYNTAX      BITS { svcIncoming(0), svcOutgoing(1) }\n        DESCRIPTION
    \"The minimal requirement is collection for SVCs.\"\n        OBJECT      acctngSelectionRowStatus\n
    \       MIN-ACCESS  read-only\n        DESCRIPTION \"Write access is not required.\"\n
    \       OBJECT      acctngFileName\n        MIN-ACCESS  read-only\n        DESCRIPTION
    \"Write access is not required.\"\n        OBJECT      acctngFileCommand\n        MIN-ACCESS
    \ read-only\n        DESCRIPTION \"Write access is not required.\"\n        OBJECT
    \     acctngFileFormat\n        SYNTAX      INTEGER { ber(2) }\n        MIN-ACCESS
    \ read-only\n        DESCRIPTION \"Only the standard format is required, and write\n
    \                   access is not required.\"\n        OBJECT      acctngFileMaximumSize\n
    \       MIN-ACCESS  read-only\n        DESCRIPTION \"Write access is not required.\"\n
    \       OBJECT      acctngFileCollectMode\n        SYNTAX      BITS { onRelease(0)
    }\n        MIN-ACCESS  read-only\n        DESCRIPTION \"The minimal requirement
    is for collection on\n                    connection release.\"\n        OBJECT
    \     acctngFileInterval\n        MIN-ACCESS  read-only\n        DESCRIPTION \"Write
    access is not required.\"\n        OBJECT      acctngFileCollectFailedAttempts\n
    \       MIN-ACCESS  read-only\n        DESCRIPTION \"Write access is not required.\"\n
    \       OBJECT      acctngFileRowStatus\n        MIN-ACCESS  read-only\n        DESCRIPTION
    \"Write access is not required.\"\n    ::= { acctngCompliances 1 }\n"
  - '-- units of conformance

    '
  - "acctngBasicGroup    OBJECT-GROUP\n    OBJECTS { acctngSelectionSubtree, acctngSelectionList,\n
    \             acctngSelectionFile, acctngSelectionType,\n              acctngSelectionRowStatus,
    acctngFileName,\n              acctngFileNameSuffix, acctngFileDescription,\n
    \             acctngFileCommand, acctngFileMaximumSize,\n              acctngFileCurrentSize,
    acctngFileRowStatus,\n              acctngFileFormat, acctngFileCollectMode,\n
    \             acctngFileCollectFailedAttempts, acctngFileInterval,\n              acctngFileMinAge,\n
    \             acctngAdminStatus, acctngOperStatus,\n              acctngProtection,
    acctngAgentMode,\n              acctngInterfaceEnable,\n              acctngControlTrapThreshold,\n
    \             acctngControlTrapEnable\n            }\n    STATUS  current\n    DESCRIPTION\n
    \           \"A collection of objects providing control of the basic\n            collection
    of accounting data for connection-oriented\n            networks.\"\n    ::= {
    acctngGroups 1 }\n"
  - "acctngNotificationsGroup NOTIFICATION-GROUP\n    NOTIFICATIONS { acctngFileNearlyFull,
    acctngFileFull }\n    STATUS        current\n    DESCRIPTION\n            \"The
    notifications of events relating to controlling the\n            collection of
    accounting data.\"\n    ::= { acctngGroups 2 }\n"
  - 'END

    '
  title: 4.  Definitions
- contents:
  - "5.  Acknowledgements\n   The comments of the IETF's AToM MIB Working Group are
    acknowledged.\n"
  title: 5.  Acknowledgements
- contents:
  - "6.  References\n   [1]  Harrington, D., Presuhn, R. and B. Wijnen, \"An Architecture
    for\n        Describing SNMP Management Frameworks\", RFC 2271, January 1998.\n
    \  [2]  Rose, M. and K. McCloghrie, \"Structure and Identification of\n        Management
    Information for TCP/IP-based Internets\", STD 16, RFC\n        1155, May 1990.\n
    \  [3]  Rose, M. and K. McCloghrie, \"Concise MIB Definitions\", STD 16,\n        RFC
    1212, March 1991.\n   [4]  Rose, M., \"A Convention for Defining Traps for use
    with the\n        SNMP\", RFC 1215, March 1991.\n   [5]  SNMPv2 Working Group,
    Case, J., McCloghrie, K., Rose, M. and S.\n        Waldbusser, \"Structure of
    Management Information for Version 2\n        of the Simple Network Management
    Protocol (SNMPv2)\", RFC 1902,\n        January 1996.\n   [6]  SNMPv2 Working
    Group, Case, J., McCloghrie, K., Rose, M. and S.\n        Waldbusser, \"Textual
    Conventions for Version 2 of the Simple\n        Network Management Protocol (SNMPv2)\",
    RFC 1903, January 1996.\n   [7]  SNMPv2 Working Group, Case, J., McCloghrie, K.,
    Rose, M. and S.\n        Waldbusser, \"Conformance Statements for Version 2 of
    the Simple\n        Network Management Protocol (SNMPv2)\", RFC 1904, January
    1996.\n   [8]  Case, J., Fedor, M., Schoffstall, M. and J. Davin, \"Simple\n        Network
    Management Protocol\", STD 15, RFC 1157, May 1990.\n   [9]  SNMPv2 Working Group,
    Case, J., McCloghrie, K., Rose, M. and S.\n        Waldbusser, \"Introduction
    to Community-based SNMPv2\", RFC 1901,\n        January 1996.\n   [10] SNMPv2
    Working Group, Case, J., McCloghrie, K., Rose, M. and S.\n        Waldbusser,
    \"Transport Mappings for Version 2 of the Simple\n        Network Management Protocol
    (SNMPv2)\", RFC 1906, January 1996.\n   [11] Case, J., Harrington D., Presuhn
    R. and B. Wijnen, \"Message\n        Processing and Dispatching for the Simple
    Network Management\n        Protocol (SNMP)\", RFC 2272, January 1998.\n   [12]
    Blumenthal, U. and B. Wijnen, \"User-based Security Model (USM)\n        for version
    3 of the Simple Network Management Protocol\n        (SNMPv3)\", RFC 2274, January
    1998.\n   [13] SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M. and S.\n
    \       Waldbusser, \"Protocol Operations for Version 2 of the Simple\n        Network
    Management Protocol (SNMPv2)\", RFC 1905, January 1996.\n   [14] Levi, D., Meyer,
    P. and B. Stewart, \"SNMPv3 Applications\", RFC\n        2273, January 1998.\n
    \  [15] Wijnen, B., Presuhn, R. and K. McCloghrie, \"View-based Access\n        Control
    Model (VACM) for the Simple Network Management Protocol\n        (SNMP)\", RFC
    2275, January 1998.\n   [16] SNMPv2 Working Group, Case, J., McCloghrie, K., Rose,
    M. and S.\n        Waldbusser, \"Management Information Base for version 2 of
    the\n        Simple Network Management Protocol (SNMPv2)\", RFC 1907, January\n
    \       1996.\n   [17] Information processing systems - Open Systems Interconnection,\n
    \       \"Specification of Abstract Syntax Notation One (ASN.1)\",\n        International
    Organization for Standardization, Internation\n        Standard 8824, December
    1987.\n   [18] Information processing systems - Open Systems Interconnection,\n
    \       \"Specification of Basic Encoding Rules for Abstract Syntax\n        Notation
    One (ASN.1)\", International Organization for\n        Standardization, Internation
    Standard 8825, December 1987.\n   [19] McCloghrie, K., Heinanen, J., Greene, W.
    and A. Prasad,\n        \"Accounting Information for ATM Networks\", RFC 2512,
    February\n        1999.\n   [20] Noto, M., Spiegel, E., and K. Tesink, \"Definitions
    of Textual\n        Conventions and OBJECT-IDENTITIES for ATM Management\", RFC
    2514,\n        February 1999.\n"
  title: 6.  References
- contents:
  - "7.  Security Considerations\n   The MIB defined in this memo controls and monitors
    the collection of\n   accounting data.  Care should be taken to prohibit unauthorized\n
    \  access to this control capability in order to prevent the disruption\n   of
    data collection, possibly with fraudulent intent.  Example of such\n   disruption
    are disabling the collection of data, or causing the wrong\n   set of data items
    to be collected.\n   SNMPv1 by itself is not a secure environment.  Even if the
    network\n   itself is secure (for example by using IPSec), even then, there is
    no\n   control as to who on the secure network is allowed to access and\n   GET/SET
    (read/change/create/delete) the objects in this MIB.\n   It is recommended that
    the implementers consider the security\n   features as provided by the SNMPv3
    framework.  Specifically, the use\n   of the User-based Security Model RFC 2274
    [12] and the View-based\n   Access Control Model RFC 2275 [15] is recommended.\n
    \  It is then a customer/user responsibility to ensure that the SNMP\n   entity
    giving access to an instance of this MIB, is properly\n   configured to give access
    to the objects only to those principals\n   (users) that have legitimate rights
    to indeed GET or SET\n   (change/create/delete) them.\n"
  title: 7.  Security Considerations
- contents:
  - "8.  IANA Considerations\n   Prior to publication of this memo as an RFC, IANA
    is requested to\n   make a suitable OBJECT IDENTIFIER assignment.\n"
  title: 8.  IANA Considerations
- contents:
  - "9.  Authors' Addresses\n   Keith McCloghrie\n   Cisco Systems, Inc.\n   170 West
    Tasman Drive,\n   San Jose CA 95134\n   Phone: +1 408 526 5260\n   EMail: kzm@cisco.com\n
    \  Juha Heinanen\n   Telia Finland, Inc.\n   Myyrmaentie 2\n   01600 VANTAA\n
    \  Finland\n   Phone +358 303 944 808\n   EMail: jh@telia.fi\n   Wedge Greene\n
    \  MCI Telecommunications Corporation\n   901 International Parkway\n   Richardson,
    Texas 75081\n   Phone: 214-498-1232 or 972-729-1232\n   EMail: wedge.greene@mci.com\n
    \  Anil Prasad\n   Cisco Systems, Inc.\n   170 West Tasman Drive,\n   San Jose
    CA 95134\n   Phone: 408 525-7209\n   EMail: aprasad@cisco.com\n"
  title: 9.  Authors' Addresses
- contents:
  - "10.  Full Copyright Statement\n   Copyright (C) The Internet Society (1999).
    \ All Rights Reserved.\n   This document and translations of it may be copied
    and furnished to\n   others, and derivative works that comment on or otherwise
    explain it\n   or assist in its implementation may be prepared, copied, published\n
    \  and distributed, in whole or in part, without restriction of any\n   kind,
    provided that the above copyright notice and this paragraph are\n   included on
    all such copies and derivative works.  However, this\n   document itself may not
    be modified in any way, such as by removing\n   the copyright notice or references
    to the Internet Society or other\n   Internet organizations, except as needed
    for the purpose of\n   developing Internet standards in which case the procedures
    for\n   copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 10.  Full Copyright Statement
