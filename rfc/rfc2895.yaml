- contents:
  - '      Remote Network Monitoring MIB Protocol Identifier Reference

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This memo defines a notation describing protocol layers in a protocol\n
    \  encapsulation, specifically for use in encoding INDEX values for the\n   protocolDirTable,
    found in the RMON-2 MIB (Remote Network Monitoring\n   Management Information
    Base) [RFC2021].  The definitions for the\n   standard protocol directory base
    layer identifiers are also included.\n   The first version of the RMON Protocol
    Identifiers Document [RFC2074]\n   has been split into a standards-track Reference
    portion (this\n   document), and an Informational document.  The RMON Protocol\n
    \  Identifier Macros document [RFC2896] now contains the non-normative\n   portion
    of that specification.\n   This document obsoletes RFC 2074.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1 The SNMP Network Management Framework ..........................
    \ 3\n   2 Overview .......................................................  3\n
    \  2.1 Terms ........................................................  4\n   2.2
    Relationship to the Remote Network Monitoring MIB ............  6\n   2.3 Relationship
    to the RMON Protocol Identifier Macros Document .  6\n   2.4 Relationship to the
    ATM-RMON MIB .............................  7\n   2.4.1 Port Aggregation ...........................................
    \ 7\n   2.4.2 Encapsulation Mappings .....................................  7\n
    \  2.4.3 Counting ATM Traffic in RMON-2 Collections .................  8\n   2.5
    Relationship to Other MIBs ...................................  9\n   3 Protocol
    Identifier Encoding ...................................  9\n   3.1 ProtocolDirTable
    INDEX Format Examples ....................... 11\n   3.2 Protocol Identifier Macro
    Format ............................. 12\n   3.2.1 Lexical Conventions ........................................
    12\n   3.2.2 Notation for Syntax Descriptions ........................... 13\n
    \  3.2.3 Grammar for the PI Language ................................ 13\n   3.2.4
    Mapping of the Protocol Name ............................... 15\n   3.2.5 Mapping
    of the VARIANT-OF Clause ........................... 16\n   3.2.6 Mapping of the
    PARAMETERS Clause ........................... 17\n   3.2.6.1 Mapping of the 'countsFragments(0)'
    BIT .................. 18\n   3.2.6.2 Mapping of the 'tracksSessions(1)' BIT ...................
    18\n   3.2.7 Mapping of the ATTRIBUTES Clause ........................... 18\n
    \  3.2.8 Mapping of the DESCRIPTION Clause .......................... 19\n   3.2.9
    Mapping of the CHILDREN Clause ............................. 19\n   3.2.10 Mapping
    of the ADDRESS-FORMAT Clause ...................... 20\n   3.2.11 Mapping of the
    DECODING Clause ............................ 20\n   3.2.12 Mapping of the REFERENCE
    Clause ........................... 20\n   3.3 Evaluating an Index of the ProtocolDirTable
    .................. 21\n   4 Base Layer Protocol Identifier Macros ..........................
    22\n   4.1 Base Identifier Encoding ..................................... 22\n
    \  4.1.1 Protocol Identifier Functions .............................. 22\n   4.1.1.1
    Function 0: None ......................................... 23\n   4.1.1.2 Function
    1: Protocol Wildcard Function ................... 23\n   4.2 Base Layer Protocol
    Identifiers .............................. 24\n   4.3 Encapsulation Layers .........................................
    31\n   4.3.1 IEEE 802.1Q ................................................ 31\n
    \  5 Intellectual Property .......................................... 34\n   6
    Acknowledgements ............................................... 35\n   7 References
    ..................................................... 35\n   8 IANA Considerations
    ............................................ 39\n   9 Security Considerations
    ........................................ 39\n   10 Authors' Addresses ............................................
    40\n   Appendix A ....................................................... 41\n
    \  11 Full Copyright Statement ...................................... 42\n"
  title: Table of Contents
- contents:
  - "1.  The SNMP Network Management Framework\n   The SNMP Management Framework presently
    consists of five major\n   components:\n   o  An overall architecture, described
    in RFC 2571 [RFC2571].\n   o  Mechanisms for describing and naming objects and
    events for the\n      purpose of management. The first version of this Structure
    of\n      Management Information (SMI) is called SMIv1 and described in STD\n
    \     16, RFC 1155 [RFC1155], STD 16, RFC 1212 [RFC1212] and RFC 1215\n      [RFC1215].
    \ The second version, called SMIv2, is described in STD\n      58, RFC 2578 [RFC2578],
    STD 58, RFC 2579 [RFC2579] and STD 58, RFC\n      2580 [RFC2580].\n   o  Message
    protocols for transferring management information. The\n      first version of
    the SNMP message protocol is called SNMPv1 and\n      described in STD 15, RFC
    1157 [RFC1157]. A second version of the\n      SNMP message protocol, which is
    not an Internet standards track\n      protocol, is called SNMPv2c and described
    in RFC 1901 [RFC1901]\n      and RFC 1906 [RFC1906].  The third version of the
    message protocol\n      is called SNMPv3 and described in RFC 1906 [RFC1906],
    RFC 2572\n      [RFC2572] and RFC 2574 [RFC2574].\n   o  Protocol operations for
    accessing management information. The\n      first set of protocol operations
    and associated PDU formats is\n      described in STD 15, RFC 1157 [RFC1157].
    A second set of protocol\n      operations and associated PDU formats is described
    in RFC 1905\n      [RFC1905].\n   o  A set of fundamental applications described
    in RFC 2573 [RFC2573]\n      and the view-based access control mechanism described
    in RFC 2575\n      [RFC2575].\n   A more detailed introduction to the current
    SNMP Management Framework\n   can be found in RFC 2570 [RFC2570].\n   Managed
    objects are accessed via a virtual information store, termed\n   the Management
    Information Base or MIB.  Objects in the MIB are\n   defined using the mechanisms
    defined in the SMI.\n   This memo does not specify a MIB module.\n"
  title: 1.  The SNMP Network Management Framework
- contents:
  - "2.  Overview\n   The RMON-2 MIB [RFC2021] uses hierarchically formatted OCTET
    STRINGs\n   to globally identify individual protocol encapsulations in the\n   protocolDirTable.\n
    \  This guide contains algorithms and the authoritative set of base\n   layer
    protocol identifier macros, for use within INDEX values in the\n   protocolDirTable.\n
    \  This is the second revision of this document, and is intended to\n   replace
    the first half of the first RMON-2 Protocol Identifiers\n   document. [RFC2074].\n"
  title: 2.  Overview
- contents:
  - "2.1.  Terms\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and
    \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC 2119
    [RFC2119].\n   Several terms are used throughout this document, as well as in
    the\n   RMON-2 MIB [RFC2021], that should be introduced:\n   parent protocol:\n
    \       Also called 'parent'; The encapsulating protocol identifier for\n        a
    specific protocol layer, e.g., IP is the parent protocol of\n        UDP.  Note
    that base layers cannot have parent protocols.  This\n        term may be used
    to refer to a specific encapsulating protocol,\n        or it may be used generically
    to refer to any encapsulating\n        protocol.\n   child protocol:\n        Also
    called 'child'; An encapsulated protocol identifier for a\n        specific protocol
    layer. e.g., UDP is a child protocol of IP.\n        This term may be used to
    refer to a specific encapsulated\n        protocol, or it may be used generically
    to refer to any\n        encapsulated protocol.\n   layer-identifier:\n        An
    octet string fragment representing a particular protocol\n        encapsulation
    layer or sub-layer.  A fragment consists of\n        exactly four octets, encoded
    in network byte order.  If present,\n        child layer-identifiers for a protocol
    MUST have unique values\n        among each other. (See section 3.3 for more details.)\n
    \  protocol:\n        A particular protocol layer, as specified by encoding rules
    in\n        this document. Usually refers to a single layer in a given\n        encapsulation.
    Note that this term is sometimes used in the\n        RMON-2 MIB [RFC2021] to
    name a fully-specified protocol-\n        identifier string.  In such a case,
    the protocol-identifier\n        string is named for its upper-most layer. A named
    protocol may\n        also refer to any encapsulation of that protocol.\n   protocol-identifier
    string:\n        An octet string representing a particular protocol\n        encapsulation,
    as specified by the encoding rules in this\n        document. This string is identified
    in the RMON-2 MIB [RFC2021]\n        as the protocolDirID object.  A protocol-identifier
    string is\n        composed of one or more layer-identifiers read from left to\n
    \       right.  The left-most layer-identifier specifies a base layer\n        encapsulation.
    Each layer-identifier to the right specifies a\n        child layer protocol encapsulation.\n
    \  protocol-identifier macro:  Also called a PI macro; A macro-like\n        textual
    construct used to describe a particular networking\n        protocol. Only protocol
    attributes which are important for RMON\n        use are documented. Note that
    the term 'macro' is historical,\n        and PI macros are not real macros, nor
    are they ASN.1 macros.\n        The current set of published RMON PI macros can
    be found in the\n        RMON Protocol Identifier Macros document [RFC2896].\n
    \       The PI macro serves several purposes:\n        - Names the protocol for
    use within the RMON-2 MIB [RFC2021].\n        - Describes how the protocol is
    encoded into an octet string.\n        - Describes how child protocols are identified
    (if applicable),\n          and encoded into an octet string.\n        - Describes
    which protocolDirParameters are allowed for the\n          protocol.\n        -
    Describes how the associated protocolDirType object is encoded\n          for
    the protocol.\n        - Provides reference(s) to authoritative documentation
    for the\n          protocol.\n   protocol-variant-identifier macro:\n        Also
    called a PI-variant macro; A special kind of PI macro, used\n        to describe
    a particular protocol layer, which cannot be\n        identified with a deterministic,
    and (usually) hierarchical\n        structure, like most networking protocols.\n
    \       Note that the PI-variant macro and the PI-macro are defined with\n        a
    single set of syntax rules (see section 3.2), except that\n        different sub-clauses
    are required for each type.\n        A protocol identified with a PI-variant macro
    is actually a\n        variant of a well known encapsulation that may be present
    in the\n        protocolDirTable. This is used to document the IANA assigned\n
    \       protocols, which are needed to identify protocols which cannot\n        be
    practically identified by examination of 'appropriate network\n        traffic'
    (e.g. the packets which carry them).  All other\n        protocols (which can
    be identified by examination of appropriate\n        network traffic) SHOULD be
    documented using the protocol-\n        identifier macro.  (See section 3.2 for
    details.)\n   protocol-parameter:\n        A single octet, corresponding to a
    specific layer-identifier in\n        the protocol-identifier. This octet is a
    bit-mask indicating\n        special functions or capabilities that this agent
    is providing\n        for the corresponding protocol.  (See section 3.2.6 for\n
    \       details.)\n   protocol-parameters string:\n        An octet string, which
    contains one protocol-parameter for each\n        layer-identifier in the protocol-identifier.
    \ This string is\n        identified in the RMON-2 MIB [RFC2021] as the\n        protocolDirParameters
    object. (See the section 3.2.6 for\n        details.)\n   protocolDirTable INDEX:\n
    \       A protocol-identifier and protocol-parameters octet string pair\n        that
    have been converted to an INDEX value, according to the\n        encoding rules
    in section 7.7 of RFC 1902 [RFC1902].\n   pseudo-protocol:\n        A convention
    or algorithm used only within this document for the\n        purpose of encoding
    protocol-identifier strings.\n   protocol encapsulation tree:\n        Protocol
    encapsulations can be organized into an inverted tree.\n        The nodes of the
    root are the base encapsulations. The children\n        nodes, if any, of a node
    in the tree are the encapsulations of\n        child protocols.\n"
  title: 2.1.  Terms
- contents:
  - "2.2.  Relationship to the Remote Network Monitoring MIB\n   This document is
    intended to identify the encoding rules for the\n   OCTET STRING objects protocolDirID
    and protocolDirParameters.  RMON-2\n   tables, such as those in the new Protocol
    Distribution, Host, and\n   Matrix groups, use a local INTEGER INDEX (protocolDirLocalIndex)\n
    \  rather than complete protocolDirTable INDEX strings, to identify\n   protocols
    for counting purposes.  Only the protocolDirTable uses the\n   protocolDirID and
    protocolDirParameters strings described in this\n   document.\n   This document
    is intentionally separated from the RMON-2 MIB objects\n   [RFC2021] to allow
    updates to this document without any republication\n   of MIB objects.\n   This
    document does not discuss auto-discovery and auto-population of\n   the protocolDirTable.
    This functionality is not explicitly defined by\n   the RMON standard. An agent
    SHOULD populate the directory with the\n   'interesting' protocols on which the
    intended applications depend.\n"
  title: 2.2.  Relationship to the Remote Network Monitoring MIB
- contents:
  - "2.3.  Relationship to the RMON Protocol Identifier Macros Document\n   The original
    RMON Protocol Identifiers document [RFC2074] contains\n   the protocol directory
    reference material, as well as many examples\n   of protocol identifier macros.\n
    \  These macros have been moved to a separate document called the RMON\n   Protocol
    Identifier Macros document [RFC2896].  This will allow the\n   normative text
    (this document) to advance on the standards track with\n   the RMON-2 MIB [RFC2021],
    while the collection of PI macros is\n   maintained in an Informational RFC.\n
    \  The PI Macros document is intentionally separated from this document\n   to
    allow updates to the list of published PI macros without any\n   republication
    of MIB objects or encoding rules.  Protocol Identifier\n   macros submitted from
    the RMON working group and community at large\n   (to the RMONMIB WG mailing list
    at 'rmonmib@ietf.org') will be\n   collected, screened by the RMONMIB working
    group, and (if approved)\n   added to a subsequent version of the PI Macros document.\n
    \  Macros submissions will be collected in the IANA's MIB files under\n   the
    directory \"ftp://ftp.isi.edu/mib/rmonmib/rmon2_pi_macros/\" and in\n   the RMONMIB
    working group mailing list message archive file\n   www.ietf.org/mail-archive/working-\n
    \  groups/rmonmib/current/maillist.htm.\n"
  title: 2.3.  Relationship to the RMON Protocol Identifier Macros Document
- contents:
  - "2.4.  Relationship to the ATM-RMON MIB\n   The ATM Forum has standardized \"Remote
    Monitoring MIB Extensions for\n   ATM Networks\" (ATM-RMON MIB) [AF-NM-TEST-0080.000],
    which provides\n   RMON-like stats, host, matrix, and matrixTopN capability for
    NSAP\n   address-based (ATM Adaption Layer 5, AAL-5) cell traffic.\n"
  title: 2.4.  Relationship to the ATM-RMON MIB
- contents:
  - "2.4.1.  Port Aggregation\n   It it possible to correlate ATM-RMON MIB data with
    packet-based\n   RMON-2 [RFC2021] collections, but only if the ATM-RMON\n   'portSelGrpTable'
    and 'portSelTable' are configured to provide the\n   same level of port aggregation
    as used in the packet-based\n   collection.  This will require an ATM-RMON 'portSelectGroup'
    to\n   contain a single port, in the case of traditional RMON dataSources.\n"
  title: 2.4.1.  Port Aggregation
- contents:
  - "2.4.2.  Encapsulation Mappings\n   The RMON PI document does not contain explicit
    PI macro support for\n   \"Multiprotocol Encapsulation over ATM Adaptation Layer
    5\" [RFC1483],\n   or ATM Forum \"LAN Emulation over ATM\" (LANE) [AF-LANE-0021.000].\n
    \  Instead, a probe must 'fit' the ATM encapsulation to one of the base\n   layers
    defined in this document (i.e., llc, snap, or vsnap),\n   regardless of how the
    raw data is obtained by the agent (e.g., VC-\n   muxing vs. LLC-muxing, or routed
    vs. bridged formats).  See section\n   3.2 for details on identifying and decoding
    a particular base layer.\n   An NMS can determine some of the omitted encapsulation
    details by\n   examining the interface type (ifType) of the dataSource for a\n
    \  particular RMON collection:\n      RFC 1483 dataSource ifTypes:\n           -
    aal5(49)\n      LANE dataSource ifTypes:\n           - aflane8023(59)\n           -
    aflane8025(60)\n   These dataSources require implementation of the ifStackTable
    from the\n   Interfaces MIB [RFC2233].  It is possible that some implementations\n
    \  will use dataSource values which indicate an ifType of 'atm(37)'\n   (because
    the ifStackTable is not supported), however this is strongly\n   discouraged by
    the RMONMIB WG.\n"
  title: 2.4.2.  Encapsulation Mappings
- contents:
  - "2.4.3.  Counting ATM Traffic in RMON-2 Collections\n   The RMON-2 Application
    Layer (AL) and Network Layer (NL)\n   (host/matrix/topN) tables require that octet
    counters be incremented\n   by the size of the particular frame, not by the size
    of the frame\n   attributed to a given protocol.\n   Probe implementations must
    use the AAL-5 frame size (not the AAL-5\n   payload size or encapsulated MAC frame
    size) as the 'frame size' for\n   the purpose of incrementing RMON-2 octet counters
    (e.g.,\n   'nlHostInOctets', 'alHostOutOctets').\n   The RMONMIB WG has not addressed
    issues relating to packet capture of\n   AAL-5 based traffic. Therefore, it is
    an implementation-specific\n   matter whether padding octets (i.e., RFC 1483 VC-muxed,
    bridged 802.3\n   or 802.5 traffic, or LANE traffic) are represented in the RMON-1\n
    \  'captureBufferPacketData' MIB object.   Normally, the first octet of\n   the
    captured frame is the first octet of the destination MAC address\n   (DA).\n"
  title: 2.4.3.  Counting ATM Traffic in RMON-2 Collections
- contents:
  - "2.5.  Relationship to Other MIBs\n   The RMON Protocol Identifiers Reference
    document is intended for use\n   with the protocolDirTable within the RMON MIB.
    It is not relevant to\n   any other MIB, or intended for use with any other MIB.\n"
  title: 2.5.  Relationship to Other MIBs
- contents:
  - "3.  Protocol Identifier Encoding\n   The protocolDirTable is indexed by two OCTET
    STRINGs, protocolDirID\n   and protocolDirParameters. To encode the table index,
    each variable-\n   length string is converted to an OBJECT IDENTIFIER fragment,\n
    \  according to the encoding rules in section 7.7 of RFC 1902 [RFC1902].\n   Then
    the index fragments are simply concatenated.  (Refer to figures\n   1a - 1d below
    for more detail.)\n   The first OCTET STRING (protocolDirID) is composed of one
    or more 4-\n   octet \"layer-identifiers\". The entire string uniquely identifies
    a\n   particular node in the protocol encapsulation tree. The second OCTET\n   STRING,
    (protocolDirParameters) which contains a corresponding number\n   of 1-octet protocol-specific
    parameters, one for each 4-octet layer-\n   identifier in the first string.\n
    \  A protocol layer is normally identified by a single 32-bit value.\n   Each
    layer-identifier is encoded in the ProtocolDirID OCTET STRING\n   INDEX as four
    sub-components [ a.b.c.d ], where 'a' - 'd' represent\n   each byte of the 32-bit
    value in network byte order.  If a particular\n   protocol layer cannot be encoded
    into 32 bits, then it must be\n   defined as an 'ianaAssigned' protocol (see below
    for details on IANA\n   assigned protocols).\n   The following figures show the
    differences between the OBJECT\n   IDENTIFIER and OCTET STRING encoding of the
    protocol identifier\n   string.\n                 Fig. 1a\n       protocolDirTable
    INDEX Format\n       -----------------------------\n   +---+--------------------------+---+---------------+\n
    \  | c !                          | c !  protocolDir  |\n   | n !  protocolDirID
    \          | n !  Parameters   |\n   | t !                          | t !               |\n
    \  +---+--------------------------+---+---------------+\n                 Fig.
    1b\n       protocolDirTable OCTET STRING Format\n       ------------------------------------\n
    \   protocolDirID\n   +----------------------------------------+\n   |                                        |\n
    \  |              4 * N octets              |\n   |                                        |\n
    \  +----------------------------------------+\n   protocolDirParameters\n   +----------+\n
    \  |          |\n   | N octets |\n   |          |\n   +----------+\n   N is the
    number of protocol-layer-identifiers required\n   for the entire encapsulation
    of the named protocol.  Note\n   that the layer following the base layer usually
    identifies\n   a network layer protocol, but this is not always the case,\n   (most
    notably for children of the 'vsnap' base-layer).\n                  Fig. 1c\n
    \     protocolDirTable INDEX Format Example\n      -------------------------------------\n
    \  protocolDirID                   protocolDirParameters\n   +---+--------+--------+--------+--------+---+---+---+---+---+\n
    \  | c |  proto |  proto |  proto |  proto | c |par|par|par|par|\n   | n |  base
    \ | L(B+1) | L(B+2) | L(B+3) | n |ba-| L3| L4| L5|\n   | t |(+flags)|   L3   |
    \  L4   |   L5   | t |se |   |   |   |\n   +---+--------+--------+--------+--------+---+---+---+---+---+
    subOID\n   | 1 |   4    |    4   |    4   |    4   | 1 | 1 | 1 | 1 | 1 | count\n
    \  When encoded in a protocolDirTable INDEX, each of the two\n   strings must
    be preceded by a length sub-component. In this\n   example, N equals '4', the
    first 'cnt' field would contain\n   the value '16', and the second 'cnt' field
    would contain\n   the value '4'.\n                  Fig. 1d\n     protocolDirTable
    OCTET STRING Format Example\n     --------------------------------------------\n
    \  protocolDirID\n   +--------+--------+--------+--------+\n   |  proto |  proto
    |  proto |  proto |\n   |   base |    L3  |   L4   |   L5   |\n   |        |        |
    \       |        |\n   +--------+--------+--------+--------+ octet\n   |    4
    \  |    4   |    4   |    4   | count\n   protocolDirParameters\n   +---+---+---+---+\n
    \  |par|par|par|par|\n   |ba-| L3| L4| L5|\n   |se |   |   |   |\n   +---+---+---+---+
    octet\n   | 1 | 1 | 1 | 1 | count\n   Although this example indicates four encapsulated
    protocols, in\n   practice, any non-zero number of layer-identifiers may be present,\n
    \  theoretically limited only by OBJECT IDENTIFIER length restrictions,\n   as
    specified in section 3.5 of RFC 1902 [RFC1902].\n"
  title: 3.  Protocol Identifier Encoding
- contents:
  - "3.1.  ProtocolDirTable INDEX Format Examples\n   The following PI identifier
    fragments are examples of some fully\n   encoded protocolDirTable INDEX values
    for various encapsulations.\n    -- HTTP; fragments counted from IP and above\n
    \   ether2.ip.tcp.www-http =\n       16.0.0.0.1.0.0.8.0.0.0.0.6.0.0.0.80.4.0.1.0.0\n
    \   -- SNMP over UDP/IP over SNAP\n    snap.ip.udp.snmp =\n       16.0.0.0.3.0.0.8.0.0.0.0.17.0.0.0.161.4.0.0.0.0\n
    \   -- SNMP over IPX over SNAP\n    snap.ipx.snmp =\n       12.0.0.0.3.0.0.129.55.0.0.144.15.3.0.0.0\n
    \   -- SNMP over IPX over raw8023\n    ianaAssigned.ipxOverRaw8023.snmp =\n       12.0.0.0.5.0.0.0.1.0.0.144.15.3.0.0.0\n
    \   -- IPX over LLC\n    llc.ipx =\n       8.0.0.0.2.0.0.0.224.2.0.0\n    -- SNMP
    over UDP/IP over any link layer\n    ether2.ip.udp.snmp\n       16.1.0.0.1.0.0.8.0.0.0.0.17.0.0.0.161.4.0.0.0.0\n
    \   -- IP over any link layer; base encoding is IP over ether2\n    ether2.ip\n
    \      8.1.0.0.1.0.0.8.0.2.0.0\n    -- AppleTalk Phase 2 over ether2\n    ether2.atalk\n
    \     8.0.0.0.1.0.0.128.155.2.0.0\n    -- AppleTalk Phase 2 over vsnap\n    vsnap.apple-oui.atalk\n
    \     12.0.0.0.4.0.8.0.7.0.0.128.155.3.0.0.0\n"
  title: 3.1.  ProtocolDirTable INDEX Format Examples
- contents:
  - "3.2.  Protocol Identifier Macro Format\n   The following example is meant to
    introduce the protocol-identifier\n   macro. This macro-like construct is used
    to represent both protocols\n   and protocol-variants.\n   If the 'VariantOfPart'
    component of the macro is present, then the\n   macro represents a protocol-variant
    instead of a protocol.  This\n   clause is currently used only for IANA assigned
    protocols, enumerated\n   under the 'ianaAssigned' base-layer.  The VariantOfPart
    component\n   MUST be present for IANA assigned protocols.\n"
  title: 3.2.  Protocol Identifier Macro Format
- contents:
  - "3.2.1.  Lexical Conventions\n   The PI language defines the following keywords:\n
    \        ADDRESS-FORMAT\n         ATTRIBUTES\n         CHILDREN\n         DECODING\n
    \        DESCRIPTION\n         PARAMETERS\n         PROTOCOL-IDENTIFIER\n         REFERENCE\n
    \        VARIANT-OF\n   The PI language defines the following punctuation elements:\n
    \       {     left curly brace\n        }     right curly brace\n        (     left
    parenthesis\n        )     right parenthesis\n        ,     comma\n        ::=
    \  two colons and an equal sign\n        --    two dashes\n"
  title: 3.2.1.  Lexical Conventions
- contents:
  - "3.2.2.  Notation for Syntax Descriptions\n   An extended form of the BNF notation
    is used to specify the syntax of\n   the PI language. The rules for this notation
    are shown below:\n     *  Literal values are specified in quotes, for example
    \"REFERENCE\"\n     *  Non-terminal items are surrounded by less than (<) and
    greater\n        than (>) characters, for example <parmList>\n     *  Terminal
    items are specified without surrounding quotes or less\n        than and greater
    than characters, for example 'lcname'\n     *  A vertical bar (|) is used to indicate
    a choice between items,\n        for example 'number | hstr'\n     *  Ellipsis
    are used to indicate that the previous item may be\n        repeated one or more
    times, for example <parm>...\n     *  Square brackets are used to enclose optional
    items, for example\n        [ \",\" <parm> ]\n     *  An equals character (=)
    is used to mean \"defined as,\" for\n        example '<protoName> = pname'\n"
  title: 3.2.2.  Notation for Syntax Descriptions
- contents:
  - "3.2.3.  Grammar for the PI Language\n   The following are \"terminals\" of the
    grammar and are identical to the\n   same lexical elements from the MIB module
    language, except for hstr\n   and pname:\n       <lc>     = \"a\" | \"b\" | \"c\"
    | ... | \"z\"\n       <uc>     = \"A\" | \"B\" | \"C\" | ... | \"Z\"\n       <letter>
    = <lc> | <uc>\n       <digit>  = \"0\" | \"1\" | ... | \"9\"\n       <hdigit>
    = <digit> | \"a\" | \"A\" | \"b\" | \"B\" | ... | \"f\" | \"F\"\n       <lcname>
    = <lc> [ <lcrest> ]\n       <lcrest> = ( <letter> | <digit> | \"-\" ) [ <lcrest>
    ]\n       <pname>  = ( <letter> | <digit> ) [ <pnrest> ]\n       <pnrest> = (
    <letter> | <digit> | \"-\" | \"_\" | \"*\" ) [ <pnrest> ]\n       <number> = <digit>
    [ <number> ]  -- to a max dec. value of 4g-1\n       <hstr>   = \"0x\" <hrest>
    \         -- to a max dec. value of 4g-1\n       <hrest>  = <hdigit> [ <hrest>
    ]\n       <lf>     = linefeed char\n       <cr>     = carriage return char\n       <eoln>
    \  = <cr><lf> | <lf>\n       <sp>     = \" \"\n       <tab>    = \"    \"\n       <wspace>
    = { <sp> | <tab> | <eoln> } [<wspace>]\n       <string> = \"\"\" [ <strest> ]
    \"\"\"\n       <strest> = ( <letter> | <digit> | <wspace> ) [ <strest> ]\n   The
    following is the extended BNF notation for the grammar with\n   starting symbol
    <piFile>:\n       -- a file containing one or more Protocol Identifier (PI)\n
    \      -- definitions\n       <piFile> = <piDefinition>...\n       -- a PI definition\n
    \      <piDefinition> =\n         <protoName> \"PROTOCOL-IDENTIFIER\"\n             [
    \"VARIANT-OF\" <protoName> ]\n               \"PARAMETERS\" \"{\" [ <parmList>
    ] \"}\"\n               \"ATTRIBUTES\" \"{\" [ <attrList> ] \"}\"\n               \"DESCRIPTION\"
    string\n             [ \"CHILDREN\" string ]\n             [ \"ADDRESS-FORMAT\"
    string ]\n             [ \"DECODING\" string ]\n             [ \"REFERENCE\" string
    ]\n               \"::=\" \"{\" <encapList> \"}\"\n       -- a protocol name\n
    \      <protoName> = pname\n       -- a list of parameters\n       <parmList>
    = <parm> [ \",\" <parm> ]...\n       -- a parameter\n       <parm> = lcname [<wspace>]
    \"(\" [<wspace>]\n                 <nonNegNum> [<wspace>] \")\" [<wspace>]\n       --
    list of attributes\n       <attrList> = <attr> [ [<wspace>] \",\" [<wspace>] <attr>
    ]...\n       -- an attribute\n       <attr> = lcname [<wspace>] \"(\" [<wspace>]\n
    \                <nonNegNum> [<wspace>] \")\"\n       -- a non-negative number\n
    \      <nonNegNum> = number | hstr\n       -- list of encapsulation values\n       <encapList>
    = <encapValue> [ [<wspace>] \",\"\n                       [<wspace>] <encapValue>
    ]...\n       -- an encapsulation value\n       <encapValue> = <baseEncapValue>
    | <normalEncapValue>\n       -- base encapsulation value\n       <baseEncapValue>
    = <nonNegNum>\n       -- normal encapsulation value\n        <normalEncapValue>
    = <protoName> <wspace> <nonNegNum>\n       -- comment\n       <two dashes> <text>
    <end-of-line>\n"
  title: 3.2.3.  Grammar for the PI Language
- contents:
  - "3.2.4.  Mapping of the Protocol Name\n   The \"protoName\" value, called the
    \"protocol name\" shall be an ASCII\n   string consisting of one up to 64 characters
    from the following:\n        \"A\" through \"Z\"\n        \"a\" through \"z\"\n
    \       \"0\" through \"9\"\n        dash (-)\n        underbar (_)\n        asterisk
    (*)\n        plus(+)\n   The first character of the protocol name is limited to
    one of the\n   following:\n        \"A\" through \"Z\"\n        \"a\" through
    \"z\"\n        \"0\" through \"9\"\n   This value SHOULD be the name or acronym
    identifying the protocol.\n   Note that case is significant.  The value selected
    for the protocol\n   name SHOULD match the \"most well-known\" name or acronym
    for the\n   indicated protocol.  For example, the document indicated by the URL:\n
    \      ftp://ftp.isi.edu/in-notes/iana/assignments/protocol-numbers\n   defines
    IP Protocol field values, so protocol-identifier macros for\n   children of IP
    SHOULD be given names consistent with the protocol\n   names found in this authoritative
    document.  Likewise, children of\n   UDP and TCP SHOULD be given names consistent
    with the port number\n   name assignments found in:\n       ftp://ftp.isi.edu/in-notes/iana/assignments/port-numbers\n
    \  When the \"well-known name\" contains characters not allowed in\n   protocol
    names, they MUST be changed to a dash character (\"-\") . In\n   the event that
    the first character must be changed, the protocol name\n   is prepended with the
    letter \"p\", so the former first letter may be\n   changed to a dash.\n   For
    example, z39.50 becomes z39-50 and 914c/g becomes 914c-g.  The\n   following protocol
    names are legal:\n       ftp, ftp-data, whois++, sql*net, 3com-tsmux, ocs_cmu\n
    \  Note that it is possible in actual implementation that different\n   encapsulations
    of the same protocol (which are represented by\n   different entries in the protocolDirTable)
    will be assigned the same\n   protocol name.  The protocolDirID INDEX value defines
    a particular\n   protocol, not the protocol name string.\n"
  title: 3.2.4.  Mapping of the Protocol Name
- contents:
  - "3.2.5.  Mapping of the VARIANT-OF Clause\n   This clause is present for IANA
    assigned protocols only.  It\n   identifies the protocol-identifier macro that
    most closely represents\n   this particular protocol, and is known as the \"reference
    protocol\".\n   A protocol-identifier macro MUST exist for the reference protocol.\n
    \  When this clause is present in a protocol-identifier macro, the macro\n   is
    called a 'protocol-variant-identifier'.\n   Any clause (e.g. CHILDREN, ADDRESS-FORMAT)
    in the reference\n   protocol-identifier macro SHOULD NOT be duplicated in the
    protocol-\n   variant-identifier macro, if the 'variant' protocols' semantics
    are\n   identical for a given clause.\n   Since the PARAMETERS and ATTRIBUTES
    clauses MUST be present in a\n   protocol-identifier, an empty 'ParamList' and
    'AttrList' (i.e.\n   \"PARAMETERS {}\") MUST be present in a protocol-variant-identifier\n
    \  macro, and the 'ParamList' and 'AttrList' found in the reference\n   protocol-identifier
    macro examined instead.\n   Note that if an 'ianaAssigned' protocol is defined
    that is not a\n   variant of any other documented protocol, then the protocol-\n
    \  identifier macro SHOULD be used instead of the protocol-variant-\n   identifier
    version of the macro.\n"
  title: 3.2.5.  Mapping of the VARIANT-OF Clause
- contents:
  - "3.2.6.  Mapping of the PARAMETERS Clause\n   The protocolDirParameters object
    provides an NMS the ability to turn\n   on and off expensive probe resources.
    An agent may support a given\n   parameter all the time, not at all, or subject
    to current resource\n   load.\n   The PARAMETERS clause is a list of bit definitions
    which can be\n   directly encoded into the associated ProtocolDirParameters octet
    in\n   network byte order. Zero or more bit definitions may be present. Only\n
    \  bits 0-7 are valid encoding values. This clause defines the entire\n   BIT
    set allowed for a given protocol. A conforming agent may choose\n   to implement
    a subset of zero or more of these PARAMETERS.\n   By convention, the following
    common bit definitions are used by\n   different protocols.  These bit positions
    MUST NOT be used for other\n   parameters. They MUST be reserved if not used by
    a given protocol.\n   Bits are encoded in a single octet. Bit 0 is the high order
    (left-\n   most) bit in the octet, and bit 7 is the low order (right-most) bit\n
    \  in the first octet. Reserved bits and unspecified bits in the octet\n   are
    set to zero.\n     Table 3.1  Reserved PARAMETERS Bits\n     ------------------------------------\n
    Bit Name              Description\n ---------------------------------------------------------------------\n
    0   countsFragments   higher-layer protocols encapsulated within\n                       this
    protocol will be counted correctly even\n                       if this protocol
    fragments the upper layers\n                       into multiple packets.\n 1
    \  tracksSessions    correctly attributes all packets of a protocol\n                       which
    starts sessions on well known ports or\n                       sockets and then
    transfers them to dynamically\n                       assigned ports or sockets
    thereafter (e.g. TFTP).\n   The PARAMETERS clause MUST be present in all protocol-identifier\n
    \  macro declarations, but may be equal to zero (empty).\n"
  title: 3.2.6.  Mapping of the PARAMETERS Clause
- contents:
  - "3.2.6.1.  Mapping of the 'countsFragments(0)' BIT\n   This bit indicates whether
    the probe is correctly attributing all\n   fragmented packets of the specified
    protocol, even if individual\n   frames carrying this protocol cannot be identified
    as such.  Note\n   that the probe is not required to actually present any re-assembled\n
    \  datagrams (for address-analysis, filtering, or any other purpose) to\n   the
    NMS.\n   This bit MUST only be set in a protocolDirParameters octet which\n   corresponds
    to a protocol that supports fragmentation and reassembly\n   in some form. Note
    that TCP packets are not considered 'fragmented-\n   streams' and so TCP is not
    eligible.\n   This bit MAY be set in more than one protocolDirParameters octet\n
    \  within a protocolDirTable INDEX, in the event an agent can count\n   fragments
    at more than one protocol layer.\n"
  title: 3.2.6.1.  Mapping of the 'countsFragments(0)' BIT
- contents:
  - "3.2.6.2.  Mapping of the 'tracksSessions(1)' BIT\n   The 'tracksSessions(1)'
    bit indicates whether frames which are part\n   of remapped sessions (e.g. TFTP
    download sessions) are correctly\n   counted by the probe. For such a protocol,
    the probe must usually\n   analyze all packets received on the indicated interface,
    and maintain\n   some state information, (e.g. the remapped UDP port number for
    TFTP).\n   The semantics of the 'tracksSessions' parameter are independent of\n
    \  the other protocolDirParameters definitions, so this parameter MAY be\n   combined
    with any other legal parameter configurations.\n"
  title: 3.2.6.2.  Mapping of the 'tracksSessions(1)' BIT
- contents:
  - "3.2.7.  Mapping of the ATTRIBUTES Clause\n   The protocolDirType object provides
    an NMS with an indication of a\n   probe's capabilities for decoding a given protocol,
    or the general\n   attributes of the particular protocol.\n   The ATTRIBUTES clause
    is a list of bit definitions which are encoded\n   into the associated instance
    of ProtocolDirType. The BIT definitions\n   are specified in the SYNTAX clause
    of the protocolDirType MIB object.\n        Table 3.2  Reserved ATTRIBUTES Bits\n
    \       ------------------------------------\n    Bit Name              Description\n
    \   ---------------------------------------------------------------------\n    0
    \ hasChildren        indicates that there may be children of\n                          this
    protocol defined in the protocolDirTable\n                          (by either
    the agent or the manager).\n    1  addressRecognitionCapable\n                          indicates
    that this protocol can be used\n                          to generate host and
    matrix table entries.\n   The ATTRIBUTES clause MUST be present in all protocol-identifier\n
    \  macro declarations, but MAY be empty.\n"
  title: 3.2.7.  Mapping of the ATTRIBUTES Clause
- contents:
  - "3.2.8.  Mapping of the DESCRIPTION Clause\n   The DESCRIPTION clause provides
    a textual description of the protocol\n   identified by this macro.  Notice that
    it SHOULD NOT contain details\n   about items covered by the CHILDREN, ADDRESS-FORMAT,
    DECODING and\n   REFERENCE clauses.\n   The DESCRIPTION clause MUST be present
    in all protocol-identifier\n   macro declarations.\n"
  title: 3.2.8.  Mapping of the DESCRIPTION Clause
- contents:
  - "3.2.9.  Mapping of the CHILDREN Clause\n   The CHILDREN clause provides a description
    of child protocols for\n   protocols which support them. It has three sub-sections:\n
    \ -  Details on the field(s)/value(s) used to select the child protocol,\n     and
    how that selection process is performed\n  -  Details on how the value(s) are
    encoded in the protocol identifier\n     octet string\n  -  Details on how child
    protocols are named with respect to their\n     parent protocol label(s)\n   The
    CHILDREN clause MUST be present in all protocol-identifier macro\n   declarations
    in which the 'hasChildren(0)' BIT is set in the\n   ATTRIBUTES clause.\n"
  title: 3.2.9.  Mapping of the CHILDREN Clause
- contents:
  - "3.2.10.  Mapping of the ADDRESS-FORMAT Clause\n   The ADDRESS-FORMAT clause provides
    a description of the OCTET-STRING\n   format(s) used when encoding addresses.\n
    \  This clause MUST be present in all protocol-identifier macro\n   declarations
    in which the 'addressRecognitionCapable(1)' BIT is set\n   in the ATTRIBUTES clause.\n"
  title: 3.2.10.  Mapping of the ADDRESS-FORMAT Clause
- contents:
  - "3.2.11.  Mapping of the DECODING Clause\n   The DECODING clause provides a description
    of the decoding procedure\n   for the specified protocol. It contains useful decoding
    hints for the\n   implementor, but SHOULD NOT over-replicate information in documents\n
    \  cited in the REFERENCE clause.  It might contain a complete\n   description
    of any decoding information required.\n   For 'extensible' protocols ('hasChildren(0)'
    BIT set) this includes\n   offset and type information for the field(s) used for
    child selection\n   as well as information on determining the start of the child\n
    \  protocol.\n   For 'addressRecognitionCapable' protocols this includes offset
    and\n   type information for the field(s) used to generate addresses.\n   The
    DECODING clause is optional, and MAY be omitted if the REFERENCE\n   clause contains
    pointers to decoding information for the specified\n   protocol.\n"
  title: 3.2.11.  Mapping of the DECODING Clause
- contents:
  - "3.2.12.  Mapping of the REFERENCE Clause\n   If a publicly available reference
    document exists for this protocol\n   it SHOULD be listed here.  Typically this
    will be a URL if possible;\n   if not then it will be the name and address of
    the controlling body.\n   The CHILDREN, ADDRESS-FORMAT, and DECODING clauses SHOULD
    limit the\n   amount of information which may currently be obtained from an\n
    \  authoritative document, such as the Assigned Numbers document\n   [RFC1700].
    \ Any duplication or paraphrasing of information should be\n   brief and consistent
    with the authoritative document.\n   The REFERENCE clause is optional, but SHOULD
    be implemented if an\n   authoritative reference exists for the protocol (especially
    for\n   standard protocols).\n"
  title: 3.2.12.  Mapping of the REFERENCE Clause
- contents:
  - "3.3.  Evaluating an Index of the ProtocolDirTable\n   The following evaluation
    is done after a protocolDirTable INDEX value\n   has been converted into two OCTET
    STRINGs according to the INDEX\n   encoding rules specified in the SMI [RFC1902].\n
    \  Protocol-identifiers are evaluated left to right, starting with the\n   protocolDirID,
    which length MUST be evenly divisible by four. The\n   protocolDirParameters length
    MUST be exactly one quarter of the\n   protocolDirID string length.\n   Protocol-identifier
    parsing starts with the base layer identifier,\n   which MUST be present, and
    continues for one or more upper layer\n   identifiers, until all OCTETs of the
    protocolDirID have been used.\n   Layers MUST NOT be skipped, so identifiers such
    as 'SNMP over IP' or\n   'TCP over ether2' can not exist.\n   The base-layer-identifier
    also contains a 'special function\n   identifier' which may apply to the rest
    of the protocol identifier.\n   Wild-carding at the base layer within a protocol
    encapsulation is the\n   only supported special function at this time. (See section
    4.1.1.2\n   for details.)\n   After the protocol-identifier string (which is the
    value of\n   protocolDirID) has been parsed, each octet of the protocol-parameters\n
    \  string is evaluated, and applied to the corresponding protocol layer.\n   A
    protocol-identifier label MAY map to more than one value.  For\n   instance, 'ip'
    maps to 5 distinct values, one for each supported\n   encapsulation.  (see the
    'IP' section under 'L3 Protocol Identifiers'\n   in the RMON Protocol Identifier
    Macros document [RFC2896]).\n   It is important to note that these macros are
    conceptually expanded\n   at implementation time, not at run time.\n   If all
    the macros are expanded completely by substituting all\n   possible values of
    each label for each child protocol, a list of all\n   possible protocol-identifiers
    is produced.  So 'ip' would result in 5\n   distinct protocol-identifiers.  Likewise
    each child of 'ip' would map\n   to at least 5 protocol-identifiers, one for each
    encapsulation (e.g.\n   ip over ether2, ip over LLC, etc.).\n"
  title: 3.3.  Evaluating an Index of the ProtocolDirTable
- contents:
  - "4.  Base Layer Protocol Identifier Macros\n   The following PROTOCOL IDENTIFIER
    macros can be used to construct\n   protocolDirID and protocolDirParameters strings.\n
    \  An identifier is encoded by constructing the base-identifier, then\n   adding
    one layer-identifier for each encapsulated protocol.\n   Refer to the RMON Protocol
    Identifier Macros document [RFC2896] for a\n   listing of the non-base layer PI
    macros published by the working\n   group. Note that other PI macro documents
    may exist, and it should be\n   possible for an implementor to populate the protocolDirTable
    without\n   the use of the PI Macro document [RFC2896].\n"
  title: 4.  Base Layer Protocol Identifier Macros
- contents:
  - "4.1.  Base Identifier Encoding\n   The first layer encapsulation is called the
    base identifier and it\n   contains optional protocol-function information and
    the base layer\n   (e.g.  MAC layer) enumeration value used in this protocol identifier.\n
    \  The base identifier is encoded as four octets as shown in figure 2.\n             Fig.
    2\n        base-identifier format\n        +---+---+---+---+\n        |   |   |
    \  |   |\n        | f |op1|op2| m |\n        |   |   |   |   |\n        +---+---+---+---+
    octet\n        | 1 | 1 | 1 | 1 | count\n   The first octet ('f') is the special
    function code, found in table\n   4.1.  The next two octets ('op1' and 'op2')
    are operands for the\n   indicated function. If not used, an operand must be set
    to zero.  The\n   last octet, 'm', is the enumerated value for a particular base
    layer\n   encapsulation, found in table 4.2.  All four octets are encoded in\n
    \  network-byte-order.\n"
  title: 4.1.  Base Identifier Encoding
- contents:
  - "4.1.1.  Protocol Identifier Functions\n   The base layer identifier contains
    information about any special\n   functions to perform during collections of this
    protocol, as well as\n   the base layer encapsulation identifier.\n   The first
    three octets of the identifier contain the function code\n   and two optional
    operands. The fourth octet contains the particular\n   base layer encapsulation
    used in this protocol (fig. 2).\n      Table 4.1  Assigned Protocol Identifier
    Functions\n      -------------------------------------------------\n            Function
    \    ID    Param1               Param2\n            ----------------------------------------------------\n
    \           none          0    not used (0)         not used (0)\n            wildcard
    \     1    not used (0)         not used (0)\n"
  title: 4.1.1.  Protocol Identifier Functions
- contents:
  - "4.1.1.1.  Function 0: None\n   If the function ID field (1st octet) is equal
    to zero, the 'op1' and\n   'op2' fields (2nd and 3rd octets) must also be equal
    to zero. This\n   special value indicates that no functions are applied to the
    protocol\n   identifier encoded in the remaining octets. The identifier represents\n
    \  a normal protocol encapsulation.\n"
  title: '4.1.1.1.  Function 0: None'
- contents:
  - "4.1.1.2.  Function 1: Protocol Wildcard Function\n   The wildcard function (function-ID
    = 1), is used to aggregate\n   counters, by using a single protocol value to indicate
    potentially\n   many base layer encapsulations of a particular network layer\n
    \  protocol. A protocolDirEntry of this type will match any base-layer\n   encapsulation
    of the same network layer protocol.\n   The 'op1' field (2nd octet) is not used
    and MUST be set to zero.\n   The 'op2' field (3rd octet) is not used and MUST
    be set to zero.\n   Each wildcard protocol identifier MUST be defined in terms
    of a 'base\n   encapsulation'. This SHOULD be as 'standard' as possible for\n
    \  interoperability purposes.  The lowest possible base layer value\n   SHOULD
    be chosen.  So, if an encapsulation over 'ether2' is\n   permitted, than this
    should be used as the base encapsulation. If not\n   then an encapsulation over
    LLC should be used, if permitted.  And so\n   on for each of the defined base
    layers.\n   It should be noted that an agent does not have to support the non-\n
    \  wildcard protocol identifier over the same base layer.  For instance\n   a
    token ring only device would not normally support IP over the\n   ether2 base
    layer.  Nevertheless it should use the ether2 base layer\n   for defining the
    wildcard IP encapsulation.  The agent MAY also\n   support counting some or all
    of the individual encapsulations for the\n   same protocols, in addition to wildcard
    counting.  Note that the\n   RMON-2 MIB [RFC2021] does not require that agents
    maintain counters\n   for multiple encapsulations of the same protocol.  It is
    an\n   implementation-specific matter as to how an agent determines which\n   protocol
    combinations to allow in the protocolDirTable at any given\n   time.\n"
  title: '4.1.1.2.  Function 1: Protocol Wildcard Function'
- contents:
  - "4.2.  Base Layer Protocol Identifiers\n   The base layer is mandatory, and defines
    the base encapsulation of\n   the packet and any special functions for this identifier.\n
    \  There are no suggested protocolDirParameters bits for the base layer.\n   The
    suggested value for the ProtocolDirDescr field for the base layer\n   is given
    by the corresponding \"Name\" field in the table 4.2 below.\n   However, implementations
    are only required to use the appropriate\n   integer identifier values.\n   For
    most base layer protocols, the protocolDirType field should\n   contain bits set
    for  the 'hasChildren(0)' and '\n   addressRecognitionCapable(1)' attributes.
    \ However, the special\n   'ianaAssigned' base layer should have no parameter
    or attribute bits\n   set.\n   By design, only 255 different base layer encapsulations
    are\n   supported.  There are five base encapsulation values defined at this\n
    \  time. Very few new base encapsulations (e.g. for new media types) are\n   expected
    to be added over time.\n     Table 4.2  Base Layer Encoding Values\n     --------------------------------------\n
    \          Name          ID\n           ------------------\n           ether2
    \       1\n           llc           2\n           snap          3\n           vsnap
    \        4\n           ianaAssigned  5\n -- Ether2 Encapsulation\n"
  title: 4.2.  Base Layer Protocol Identifiers
- contents:
  - "ether2 PROTOCOL-IDENTIFIER\n    PARAMETERS { }\n    ATTRIBUTES {\n     hasChildren(0),\n
    \       addressRecognitionCapable(1)\n    }\n    DESCRIPTION\n       \"DIX Ethernet,
    also called Ethernet-II.\"\n    CHILDREN\n       \"The Ethernet-II type field
    is used to select child protocols.\n       This is a 16-bit field.  Child protocols
    are deemed to start at\n       the first octet after this type field.\n       Children
    of this protocol are encoded as [ 0.0.0.1 ], the\n       protocol identifier for
    'ether2' followed by [ 0.0.a.b ] where\n       'a' and 'b' are the network byte
    order encodings of the high\n       order byte and low order byte of the Ethernet-II
    type value.\n       For example, a protocolDirID-fragment value of:\n          0.0.0.1.0.0.8.0
    defines IP encapsulated in ether2.\n       Children of ether2 are named as 'ether2'
    followed by the type\n       field value in hexadecimal.  The above example would
    be declared\n       as:\n          ether2 0x0800\"\n    ADDRESS-FORMAT\n       \"Ethernet
    addresses are 6 octets in network order.\"\n    DECODING\n       \"Only type values
    greater than 1500 decimal indicate Ethernet-II\n       frames; lower values indicate
    802.3 encapsulation (see below).\"\n    REFERENCE\n       \"The authoritative
    list of Ether Type values is identified by the\n       URL:\n          ftp://ftp.isi.edu/in-notes/iana/assignments/ethernet-numbers\"\n
    \   ::= { 1 }\n -- LLC Encapsulation\n"
  title: ether2 PROTOCOL-IDENTIFIER
- contents:
  - "llc PROTOCOL-IDENTIFIER\n    PARAMETERS { }\n    ATTRIBUTES {\n     hasChildren(0),\n
    \    addressRecognitionCapable(1)\n    }\n    DESCRIPTION\n       \"The Logical
    Link Control (LLC) 802.2 protocol.\"\n    CHILDREN\n       \"The LLC Source Service
    Access Point (SSAP) and Destination\n       Service Access Point (DSAP) are used
    to select child protocols.\n       Each of these is one octet long, although the
    least significant\n       bit is a control bit and should be masked out in most
    situations.\n       Typically SSAP and DSAP (once masked) are the same for a given\n
    \      protocol - each end implicitly knows whether it is the server or\n       client
    in a client/server protocol.  This is only a convention,\n       however, and
    it is possible for them to be different.  The SSAP\n       is matched against
    child protocols first.  If none is found then\n       the DSAP is matched instead.
    \ The child protocol is deemed to\n       start at the first octet after the LLC
    control field(s).\n       Children of 'llc' are encoded as [ 0.0.0.2 ], the protocol\n
    \      identifier component for LLC followed by [ 0.0.0.a ] where 'a' is\n       the
    SAP value which maps to the child protocol.  For example, a\n       protocolDirID-fragment
    value of:\n          0.0.0.2.0.0.0.240\n       defines NetBios over LLC.\n       Children
    are named as 'llc' followed by the SAP value in\n       hexadecimal.  So the above
    example would have been named:\n          llc 0xf0\"\n    ADDRESS-FORMAT\n       \"The
    address consists of 6 octets of MAC address in network\n       order.  Source
    routing bits should be stripped out of the address\n       if present.\"\n    DECODING\n
    \      \"Notice that LLC has a variable length protocol header; there are\n       always
    three octets (DSAP, SSAP, control).  Depending on the\n       value of the control
    bits in the DSAP, SSAP and control fields\n       there may be an additional octet
    of control information.\n       LLC can be present on several different media.
    \ For 802.3 and\n       802.5 its presence is mandated (but see ether2 and raw
    802.3\n       encapsulations).  For 802.5 there is no other link layer\n       protocol.\n
    \      Notice also that the raw802.3 link layer protocol may take\n       precedence
    over this one in a protocol specific manner such that\n       it may not be possible
    to utilize all LSAP values if raw802.3 is\n       also present.\"\n    REFERENCE\n
    \      \"The authoritative list of LLC LSAP values is controlled by the\n       IEEE
    Registration Authority:\n       IEEE Registration Authority\n          c/o Iris
    Ringel\n          IEEE Standards Dept\n          445 Hoes Lane, P.O. Box 1331\n
    \         Piscataway, NJ 08855-1331\n          Phone +1 908 562 3813\n          Fax:
    +1 908 562 1571\"\n    ::= { 2 }\n -- SNAP over LLC (Organizationally Unique Identifier,
    OUI=000)\n -- Encapsulation\n"
  title: llc PROTOCOL-IDENTIFIER
- contents:
  - "snap PROTOCOL-IDENTIFIER\n    PARAMETERS { }\n    ATTRIBUTES {\n     hasChildren(0),\n
    \    addressRecognitionCapable(1)\n    }\n    DESCRIPTION\n       \"The Sub-Network
    Access Protocol (SNAP) is layered on top of LLC\n       protocol, allowing Ethernet-II
    protocols to be run over a media\n       restricted to LLC.\"\n    CHILDREN\n
    \      \"Children of 'snap' are identified by Ethernet-II type values;\n       the
    SNAP Protocol Identifier field (PID) is used to select the\n       appropriate
    child.  The entire SNAP protocol header is consumed;\n       the child protocol
    is assumed to start at the next octet after\n       the PID.\n       Children
    of 'snap' are encoded as [ 0.0.0.3 ], the protocol\n       identifier for 'snap',
    followed by [ 0.0.a.b ] where 'a' and 'b'\n       are the high order byte and
    low order byte of the Ethernet-II\n       type value.\n       For example, a protocolDirID-fragment
    value of:\n          0.0.0.3.0.0.8.0\n       defines the IP/SNAP protocol.\n       Children
    of this protocol are named 'snap' followed by the\n       Ethernet-II type value
    in hexadecimal.  The above example would\n       be named:\n          snap 0x0800\"\n
    \   ADDRESS-FORMAT\n         \"The address format for SNAP is the same as that
    for LLC\"\n    DECODING\n       \"SNAP is only present over LLC.  Both SSAP and
    DSAP will be 0xAA\n       and a single control octet will be present.  There are
    then three\n       octets of Organizationally Unique Identifier (OUI) and two
    octets\n       of PID.  For this encapsulation the OUI must be 0x000000 (see\n
    \      'vsnap' below for non-zero OUIs).\"\n    REFERENCE\n       \"SNAP Identifier
    values are assigned by the IEEE Standards\n       Office.  The address is:\n            IEEE
    Registration Authority\n            c/o Iris Ringel\n            IEEE Standards
    Dept\n            445 Hoes Lane, P.O. Box 1331\n            Piscataway, NJ 08855-1331\n
    \           Phone +1 908 562 3813\n            Fax: +1 908 562 1571\"\n    ::=
    { 3 }\n -- Vendor SNAP over LLC (OUI != 000) Encapsulation\n"
  title: snap PROTOCOL-IDENTIFIER
- contents:
  - "vsnap PROTOCOL-IDENTIFIER\n    PARAMETERS { }\n    ATTRIBUTES {\n     hasChildren(0),\n
    \    addressRecognitionCapable(1)\n    }\n    DESCRIPTION\n       \"This pseudo-protocol
    handles all SNAP packets which do not have\n       a zero OUI.  See 'snap' above
    for details of those that have a\n       zero OUI value.\"\n    CHILDREN\n       \"Children
    of 'vsnap' are selected by the 3 octet OUI; the PID is\n       not parsed; child
    protocols are deemed to start with the first\n       octet of the SNAP PID field,
    and continue to the end of the\n       packet.  Children of 'vsnap' are encoded
    as [ 0.0.0.4 ], the\n       protocol identifier for 'vsnap', followed by [ 0.a.b.c
    ] where\n       'a', 'b' and 'c' are the 3 octets of the OUI field in network\n
    \      byte order.\n       For example, a protocolDirID-fragment value of:\n         0.0.0.4.0.8.0.7
    defines the Apple-specific set of protocols\n       over vsnap.\n       Children
    are named as 'vsnap <OUI>', where the '<OUI>' field is\n       represented as
    3 octets in hexadecimal notation.\n       So the above example would be named:\n
    \        'vsnap 0x080007'\"\n    ADDRESS-FORMAT\n       \"The LLC address format
    is inherited by 'vsnap'.  See the 'llc'\n       protocol identifier for more details.\"\n
    \   DECODING\n       \"Same as for 'snap' except the OUI is non-zero and the SNAP\n
    \      Protocol Identifier is not parsed.\"\n    REFERENCE\n       \"SNAP Identifier
    values are assigned by the IEEE Standards\n       Office.  The address is:\n            IEEE
    Registration Authority\n            c/o Iris Ringel\n            IEEE Standards
    Dept\n            445 Hoes Lane, P.O. Box 1331\n            Piscataway, NJ 08855-1331\n
    \           Phone +1 908 562 3813\n            Fax: +1 908 562 1571\"\n    ::=
    { 4 }\n -- IANA Assigned Protocols\n"
  title: vsnap PROTOCOL-IDENTIFIER
- contents:
  - "ianaAssigned PROTOCOL-IDENTIFIER\n    PARAMETERS { }\n    ATTRIBUTES { }\n    DESCRIPTION\n
    \      \"This branch contains protocols which do not conform easily to\n       the
    hierarchical format utilized in the other link layer\n       branches.  Usually,
    such a protocol 'almost' conforms to a\n       particular 'well-known' identifier
    format, but additional\n       criteria are used (e.g. configuration-based), making
    protocol\n       identification difficult or impossible by examination of\n       appropriate
    network traffic (preventing the any 'well-known'\n       protocol-identifier macro
    from being used).\n       Sometimes well-known protocols are simply remapped to
    a different\n       port number by one or more venders (e.g. SNMP). These protocols\n
    \      can be identified with the 'limited extensibility' feature of the\n       protocolDirTable,
    and do not need special IANA assignments.\n       A centrally located list of
    these enumerated protocols must be\n       maintained by IANA to insure interoperability.
    (See section 2.3\n       for details on the document update procedure.)  Support
    for new\n       link-layers will be added explicitly, and only protocols which\n
    \      cannot possibly be represented in a better way will be considered\n       as
    'ianaAssigned' protocols.\n       IANA protocols are identified by the base-layer-selector
    value [\n       0.0.0.5 ], followed by the four octets [ 0.0.a.b ] of the integer\n
    \      value corresponding to the particular IANA protocol.\n       Do not create
    children of this protocol unless you are sure that\n       they cannot be handled
    by the more conventional link layers\n       above.\"\n    CHILDREN\n       \"Children
    of this protocol are identified by implementation-\n       specific means, described
    (as best as possible) in the 'DECODING'\n       clause within the protocol-variant-identifier
    macro for each\n       enumerated protocol.\n       Children of this protocol
    are encoded as [ 0.0.0.5 ], the\n       protocol identifier for 'ianaAssigned',
    followed by [ 0.0.a.b ]\n       where 'a', 'b' are the network byte order encodings
    of the high\n       order byte and low order byte of the enumeration value for
    the\n       particular IANA assigned protocol.\n       For example, a protocolDirID-fragment
    value of:\n          0.0.0.5.0.0.0.1\n       defines the IPX protocol encapsulated
    directly in 802.3\n       Children are named 'ianaAssigned' followed by the numeric
    value\n       of the particular IANA assigned protocol.  The above example\n       would
    be named:\n          'ianaAssigned 1' \"\n    DECODING\n       \"The 'ianaAssigned'
    base layer is a pseudo-protocol and is not\n       decoded.\"\n    REFERENCE\n
    \      \"Refer to individual PROTOCOL-IDENTIFIER macros for information\n       on
    each child of the IANA assigned protocol.\"\n    ::= { 5 }\n -- The following
    protocol-variant-identifier macro declarations are\n -- used to identify the RMONMIB
    IANA assigned protocols in a\n -- proprietary way, by simple enumeration.\n"
  title: ianaAssigned PROTOCOL-IDENTIFIER
- contents:
  - "ipxOverRaw8023 PROTOCOL-IDENTIFIER\n    VARIANT-OF  ipx\n    PARAMETERS      {
    }\n    ATTRIBUTES  { }\n    DESCRIPTION\n       \"This pseudo-protocol describes
    an encapsulation of IPX over\n       802.3, without a type field.\n       Refer
    to the macro for IPX for additional information about this\n       protocol.\"\n
    \   DECODING\n       \"Whenever the 802.3 header indicates LLC a set of protocol\n
    \      specific tests needs to be applied to determine whether this is a\n       'raw8023'
    packet or a true 802.2 packet.  The nature of these\n       tests depends on the
    active child protocols for 'raw8023' and is\n       beyond the scope of this document.\"\n
    \   ::= {\n     ianaAssigned 1,             -- [0.0.0.1]\n     802-1Q       0x05000001
    \    -- 1Q_IANA [5.0.0.1]\n    }\n"
  title: ipxOverRaw8023 PROTOCOL-IDENTIFIER
- contents:
  - "4.3.  Encapsulation Layers\n   Encapsulation layers are positioned between the
    base layer and the\n   network layer.  It is an implementation-specific matter
    whether a\n   probe exposes all such encapsulations in its RMON-2 Protocol\n   Directory.\n"
  title: 4.3.  Encapsulation Layers
- contents:
  - "4.3.1.  IEEE 802.1Q\n   RMON probes may encounter 'VLAN tagged' frames on monitored
    links.\n   The IEEE Virtual LAN (VLAN) encapsulation standards [IEEE802.1Q] and\n
    \  [IEEE802.1D-1998], define an encapsulation layer inserted after the\n   MAC
    layer and before the network layer.  This section defines a PI\n   macro which
    supports most (but not all) features of that\n   encapsulation layer.\n   Most
    notably, the RMON PI macro '802-1Q' does not expose the Token\n   Ring Encapsulation
    (TR-encaps) bit in the TCI portion of the VLAN\n   header.  It is an implementation
    specific matter whether an RMON\n   probe converts LLC-Token Ring (LLC-TR) formatted
    frames to LLC-Native\n   (LLC-N) format, for the purpose of RMON collection.\n
    \  In order to support the Ethernet and LLC-N formats in the most\n   efficient
    manner, and still maintain alignment with the RMON-2 '\n   collapsed' base layer
    approach (i.e., support for snap and vsnap),\n   the children of 802dot1Q are
    encoded a little differently than the\n   children of other base layer identifiers.\n"
  - "802-1Q   PROTOCOL-IDENTIFIER\n    PARAMETERS { }\n    ATTRIBUTES {\n     hasChildren(0)\n
    \   }\n    DESCRIPTION\n       \"IEEE 802.1Q VLAN Encapsulation header.\n       Note
    that the specific encoding of the TPID field is not\n       explicitly identified
    by this PI macro.  Ethernet-encoded vs.\n       SNAP-encoded TPID fields can be
    identified by the ifType of the\n       data source for a particular RMON collection,
    since the SNAP-\n       encoded format is used exclusively on Token Ring and FDDI
    media.\n       Also, no information held in the TCI field (including the TR-\n
    \      encap bit) is identified in protocolDirID strings utilizing this\n       PI
    macro.\"\n    CHILDREN\n       \"The first byte of the 4-byte child identifier
    is used to\n       distinguish the particular base encoding that follows the 802.1Q\n
    \      header.  The remaining three bytes are used exactly as defined by\n       the
    indicated base layer encoding.\n       In order to simplify the child encoding
    for the most common\n       cases, the 'ether2' and 'snap' base layers are combined
    into a\n       single identifier, with a value of zero.  The other base layers\n
    \      are encoded with values taken from Table 4.2.\n                     802-1Q
    Base ID Values\n                     ---------------------\n                 Base
    \            Table 4.2   Base-ID\n                 Layer            Encoding    Encoding\n
    \                -------------------------------------\n                  ether2
    \          1           0\n                  llc              2           2\n                  snap
    \            3           0\n                  vsnap            4           4\n
    \                 ianaAssigned     5           5\n       The generic child layer-identifier
    format is shown below:\n            802-1Q  Child Layer-Identifier Format\n            +--------+--------+--------+--------+\n
    \           |  Base  |                          |\n            |   ID   |   base-specific
    format   |\n            |        |                          |\n            +--------+--------+--------+--------+\n
    \           |    1   |             3            | octet count\n       Base ID
    == 0\n       ------------\n       For payloads encoded with either the Ethernet
    or LLC/SNAP headers\n       following the VLAN header, children of this protocol
    are\n       identified exactly as described for the 'ether2' or 'snap' base\n
    \      layers.\n       Children are encoded as [ 0.0.129.0 ], the protocol identifier\n
    \      for '802-1Q' followed by [ 0.0.a.b ] where 'a' and 'b' are the\n       network
    byte order encodings of the high order byte and low order\n       byte of the
    Ethernet-II type value.\n       For example, a protocolDirID-fragment value of:\n
    \         0.0.0.1.0.0.129.0.0.0.8.0\n       defines IP, VLAN-encapsulated in ether2.\n
    \      Children of this format are named as '802-1Q' followed by the\n       type
    field value in hexadecimal.\n       So the above example would be declared as:\n
    \         '802-1Q 0x0800'.\n       Base ID == 2\n       ------------\n       For
    payloads encoded with a (non-SNAP) LLC header following the\n       VLAN header,
    children of this protocol are identified exactly as\n       described for the
    'llc' base layer.\n       Children are encoded as [ 0.0.129.0 ], the protocol
    identifier\n       component for 802.1Q, followed by [ 2.0.0.a ] where 'a' is
    the\n       SAP value which maps to the child protocol.  For example, a\n       protocolDirID-fragment
    value of:\n          0.0.0.1.0.0.129.0.2.0.0.240\n       defines NetBios, VLAN-encapsulated
    over LLC.\n       Children are named as '802-1Q' followed by the SAP value in\n
    \      hexadecimal, with the leading octet set to the value 2.\n       So the
    above example would have been named:\n          '802-1Q 0x020000f0'\n       Base
    ID == 4\n       ------------\n       For payloads encoded with  LLC/SNAP (non-zero
    OUI) headers\n       following the VLAN header, children of this protocol are\n
    \      identified exactly as described for the 'vsnap' base layer.\n       Children
    are encoded as [ 0.0.129.0 ], the protocol identifier\n       for '802-1Q', followed
    by [ 4.a.b.c ] where 'a', 'b' and 'c' are\n       the 3 octets of the OUI field
    in network byte order.\n       For example, a protocolDirID-fragment value of:\n
    \        0.0.0.1.0.0.129.0.4.8.0.7 defines the Apple-specific set of\n       protocols,
    VLAN-encapsulated over vsnap.\n       Children are named as '802-1Q' followed
    by the <OUI> value, which\n       is represented as 3 octets in hexadecimal notation,
    with a\n       leading octet set to the value 4.\n       So the above example
    would be named:\n         '802-1Q 0x04080007'.\n       Base ID == 5\n       ------------\n
    \      For payloads which can only be identified as 'ianaAssigned'\n       protocols,
    children of this protocol are identified exactly as\n       described for the
    'ianaAssigned' base layer.\n       Children are encoded as [ 0.0.129.0 ], the
    protocol identifier\n       for '802-1Q', followed by [ 5.0.a.b ] where 'a' and
    'b' are the\n       network byte order encodings of the high order byte and low
    order\n       byte of the enumeration value for the particular IANA assigned\n
    \      protocol.\n       For example, a protocolDirID-fragment value of:\n          0.0.0.1.0.0.129.0.5.0.0.0.1\n
    \      defines the IPX protocol, VLAN-encapsulated directly in 802.3\n       Children
    are named '802-1Q' followed by the numeric value of the\n       particular IANA
    assigned protocol, with a leading octet set to\n       the value of 5.\n       Children
    are named '802-1Q' followed by the hexadecimal encoding\n       of the child identifier.
    \ The above example would be named:\n          '802-1Q 0x05000001'.  \"\n    DECODING\n
    \      \"VLAN headers and tagged frame structure are defined in\n       [IEEE802.1Q].\"\n
    \   REFERENCE\n       \"The 802.1Q Protocol is defined in the Draft Standard for
    Virtual\n       Bridged Local Area Networks [IEEE802.1Q].\"\n    ::= {\n        ether2
    0x8100       -- Ethernet or SNAP encoding of TPID\n        -- snap 0x8100      **
    excluded to reduce PD size & complexity\n    }\n"
  title: 4.3.1.  IEEE 802.1Q
- contents:
  - "5.  Intellectual Property\n   The IETF takes no position regarding the validity
    or scope of any\n   intellectual property or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; neither does it represent that it\n   has made any effort to
    identify any such rights.  Information on the\n   IETF's procedures with respect
    to rights in standards-track and\n   standards-related documentation can be found
    in BCP-11.  Copies of\n   claims of rights made available for publication and
    any assurances of\n   licenses to be made available, or the result of an attempt
    made to\n   obtain a general license or permission for the use of such\n   proprietary
    rights by implementors or users of this specification can\n   be obtained from
    the IETF Secretariat.\"\n   The IETF invites any interested party to bring to
    its attention any\n   copyrights, patents or patent applications, or other proprietary\n
    \  rights which may cover technology that may be required to practice\n   this
    standard.  Please address the information to the IETF Executive\n   Director.\n"
  title: 5.  Intellectual Property
- contents:
  - "6.  Acknowledgements\n   This document was produced by the IETF RMONMIB Working
    Group.\n   The authors wish to thank the following people for their\n   contributions
    to this document:\n        Anil Singhal\n        Frontier Software Development,
    Inc.\n        Jeanne Haney\n        Bay Networks\n        Dan Hansen\n        Network
    General Corp.\n   Special thanks are in order to the following people for writing
    RMON\n   PI macro compilers, and improving the specification of the PI macro\n
    \  language:\n        David Perkins\n        DeskTalk Systems, Inc.\n        Skip
    Koppenhaver\n        Technically Elite, Inc.\n"
  title: 6.  Acknowledgements
- contents:
  - "7.  References\n   [AF-LANE-0021.000]    LAN Emulation Sub-working Group, B.
    Ellington,\n                         \"LAN Emulation over ATM - Version 1.0\",
    AF-\n                         LANE-0021.000, ATM Forum, IBM, January 1995.\n   [AF-NM-TEST-0080.000]
    Network Management Sub-working Group, Test\n                         Sub-working
    Group, A. Bierman, \"Remote\n                         Monitoring MIB Extensions
    for ATM Networks\",\n                         AF- NM-TEST-0080.000, ATM Forum,
    Cisco Systems,\n                         February 1997.\n   [IEEE802.1D-1998]
    \    LAN MAN Standards Committee of the IEEE\n                         Computer
    Society, \"Information technology --\n                         Telecommunications
    and information exchange\n                         between systems -- Local and
    metropolitan area\n                         networks -- Common specification --
    Part 3:\n                         Media Access Control (MAC) Bridges\", ISO/IEC\n
    \                        Final DIS 15802-3 (IEEE P802.1D/D17) Institute\n                         of
    Electrical and Electronics Engineers, Inc.,\n                         May 1998.\n
    \  [IEEE802.1Q]          LAN MAN Standards Committee of the IEEE\n                         Computer
    Society, \"IEEE Standards for Local and\n                         Metropolitan
    Area Networks:  Virtual Bridged\n                         Local Area Networks\",
    Draft Standard\n                         P802.1Q/D11, Institute of Electrical
    and\n                         Electronics Engineers, Inc., July 1998.\n   [RFC1155]
    \            Rose, M. and K. McCloghrie, \"Structure and\n                         Identification
    of Management Information for\n                         TCP/IP-based Internets\",
    STD 16, RFC 1155, May\n                         1990.\n   [RFC1157]             Case,
    J., Fedor, M., Schoffstall, M. and J.\n                         Davin, \"Simple
    Network Management Protocol\",\n                         STD 15, RFC 1157, May
    1990.\n   [RFC1212]             Rose, M. and K. McCloghrie, \"Concise MIB\n                         Definitions\",
    STD 16, RFC 1212, March 1991.\n   [RFC1215]             Rose, M., \"A Convention
    for Defining Traps for\n                         use with the SNMP\", RFC 1215,
    March 1991.\n   [RFC1483]             Heinanen, J., \"Multiprotocol Encapsulation
    over\n                         ATM Adaptation Layer 5\", RFC 1483, July 1993.\n
    \  [RFC1700]             Reynolds, J. and J. Postel, \"Assigned Numbers\",\n                         STD
    2, RFC 1700,  October 1994.\n   [RFC1901]             Case, J., McCloghrie, K.,
    Rose, M. and S.\n                         Waldbusser, \"Introduction to Community-based\n
    \                        SNMPv2\", RFC 1901, January 1996.\n   [RFC1902]             Case,
    J., McCloghrie, K., Rose, M. and S.\n                         Waldbusser, \"Structure
    of Management\n                         Information for version 2 of the Simple
    Network\n                         Management Protocol (SNMPv2)\", RFC 1902,\n
    \                        January 1996.\n   [RFC1903]             Case, J., McCloghrie,
    K., Rose, M. and S.\n                         Waldbusser, \"Textual Conventions
    for version 2\n                         of the Simple Network Management Protocol\n
    \                        (SNMPv2)\", RFC 1903, January 1996.\n   [RFC1904]             Case,
    J., McCloghrie, K., Rose, M. and S.\n                         Waldbusser, \"Conformance
    Statements for version\n                         2 of the Simple Network Management
    Protocol\n                         (SNMPv2)\", RFC 1904, January 1996.\n   [RFC1905]
    \            Case, J., McCloghrie, K., Rose, M. and S.\n                         Waldbusser,
    \"Protocol Operations for Version 2\n                         of the Simple Network
    Management Protocol\n                         (SNMPv2)\", RFC 1905, January 1996.\n
    \  [RFC1906]             Case, J., McCloghrie, K., Rose, M. and S.\n                         Waldbusser,
    \"Transport Mappings for Version 2\n                         of the Simple Network
    Management Protocol\n                         (SNMPv2)\"\", RFC 1906, January
    1996.\n   [RFC2021]             Waldbusser, S., \"Remote Network Monitoring MIB\n
    \                        (RMON-2)\", RFC 2021, January 1997.\n   [RFC2074]             Bierman,
    A. and R. Iddon, \"Remote Network\n                         Monitoring MIB Protocol
    Identifiers\", RFC 2074,\n                         January 1997.\n   [RFC2119]
    \            Bradner, S., \"Key words for use in RFCs to\n                         Indicate
    Requirement Levels\", BCP 14, RFC 2119,\n                         March 1997.\n
    \  [RFC2233]             McCloghrie, K. and F. Kastenholz, \"The\n                         Interfaces
    Group MIB Using SMIv2\", RFC 2233,\n                         November 1997.\n
    \  [RFC2271]             Harrington, D., Presuhn, R. and B. Wijnen, \"An\n                         Architecture
    for Describing SNMP Management\n                         Frameworks\", RFC 2271,
    January 1998.\n   [RFC2272]             Case, J., Harrington D., Presuhn R. and
    B.\n                         Wijnen, \"Message Processing and Dispatching for\n
    \                        the Simple Network Management Protocol (SNMP)\",\n                         RFC
    2272, January 1998.\n   [RFC2273]             Levi, D., Meyer, P. and B. Stewart,
    \"SNMPv3\n                         Applications\", RFC 2273, January 1998.\n   [RFC2274]
    \            Blumenthal, U. and B. Wijnen, \"User-based\n                         Security
    Model (USM) for version 3 of the\n                         Simple Network Management
    Protocol (SNMPv3)\",\n                         RFC 2274, January 1998.\n   [RFC2275]
    \            Wijnen, B., Presuhn, R. and K. McCloghrie,\n                         \"View-based
    Access Control Model (VACM) for the\n                         Simple Network Management
    Protocol (SNMP)\", RFC\n                         2275, January 1998.\n   [RFC2570]
    \            Case, J., Mundy, R., Partain, D. and B.\n                         Stewart,
    \"Introduction to Version 3 of the\n                         Internet-standard
    Network Management\n                         Framework\", RFC 2570, April 1999.\n
    \  [RFC2571]             Harrington, D., Presuhn, R. and B. Wijnen, \"An\n                         Architecture
    for Describing SNMP Management\n                         Frameworks\", RFC 2571,
    April 1999.\n   [RFC2572]             Case, J., Harrington D., Presuhn R. and
    B.\n                         Wijnen, \"Message Processing and Dispatching for\n
    \                        the Simple Network Management Protocol (SNMP)\",\n                         RFC
    2572, April 1999.\n   [RFC2573]             Levi, D., Meyer, P. and B. Stewart,
    \"SNMPv3\n                         Applications\", RFC 2573, April 1999.\n   [RFC2574]
    \            Blumenthal, U. and B. Wijnen, \"User-based\n                         Security
    Model (USM) for version 3 of the\n                         Simple Network Management
    Protocol (SNMPv3)\",\n                         RFC 2574, April 1999.\n   [RFC2575]
    \            Wijnen, B., Presuhn, R. and K. McCloghrie,\n                         \"View-based
    Access Control Model (VACM) for the\n                         Simple Network Management
    Protocol (SNMP)\", RFC\n                         2575, April 1999.\n   [RFC2578]
    \            McCloghrie, K., Perkins, D., Schoenwaelder, J.,\n                         Case,
    J., Rose, M. and S. Waldbusser,\n                         \"Structure of Management
    Information Version 2\n                         (SMIv2)\", STD 58, RFC 2578, April
    1999.\n   [RFC2579]             McCloghrie, K., Perkins, D., Schoenwaelder, J.,\n
    \                        Case, J., Rose, M. and S. Waldbusser, \"Textual\n                         Conventions
    for SMIv2\", STD 58, RFC 2579, April\n                         1999.\n   [RFC2580]
    \            McCloghrie, K., Perkins, D., Schoenwaelder, J.,\n                         Case,
    J., Rose, M. and S. Waldbusser,\n                         \"Conformance Statements
    for SMIv2\", STD 58, RFC\n                         2580, April 1999.\n   [RFC2896]
    \            Bierman, A., Bucci, C. and R. Iddon, \"Remote\n                         Network
    Monitoring MIB Protocol Identifier\n                         Macros\", RFC 2896,
    August 2000.\n"
  title: 7.  References
- contents:
  - "8.  IANA Considerations\n   The protocols identified in this specification are
    almost entirely\n   defined in external documents.  In some rare cases, an arbitrary\n
    \  Protocol Identifier assignment must be made in order to support a\n   particular
    protocol in the RMON-2 protocolDirTable. Protocol\n   Identifier macros for such
    protocols will be defined under the '\n   ianaAssigned' base layer (see sections
    3. and 4.2).\n   At this time, only one protocol is defined under the ianaAssigned\n
    \  base layer, called 'ipxOverRaw8023' (see section 4.2).\n"
  title: 8.  IANA Considerations
- contents:
  - "9.  Security Considerations\n   This document discusses the syntax and semantics
    of textual\n   descriptions of networking protocols, not the definition of any\n
    \  networking behavior.  As such, no security considerations are raised\n   by
    this memo.\n"
  title: 9.  Security Considerations
- contents:
  - "10.  Authors' Addresses\n   Andy Bierman\n   Cisco Systems, Inc.\n   170 West
    Tasman Drive\n   San Jose, CA USA 95134\n   Phone: +1 408-527-3711\n   EMail:
    abierman@cisco.com\n   Chris Bucci\n   Cisco Systems, Inc.\n   170 West Tasman
    Drive\n   San Jose, CA USA 95134\n   Phone: +1 408-527-5337\n   EMail: cbucci@cisco.com\n
    \  Robin Iddon\n   c/o 3Com Inc.\n   Blackfriars House\n   40/50 Blackfrias Street\n
    \  Edinburgh, EH1 1NE, UK\n   Phone: +44 131.558.3888\n   EMail: None\n"
  title: 10.  Authors' Addresses
- contents:
  - "Appendix A: Changes since RFC 2074\n   The differences between RFC 2074 and this
    document are:\n   -  RFC 2074 has been split into a reference document\n      (this
    document) on the standards track and an informational\n      document [RFC2896],
    in order to remove most\n      protocol identifier macros out of the standards
    track document.\n   -  Administrative updates; added an author, added copyrights,\n
    \     updated SNMP framework boilerplate;\n   -  Updated overview section.\n   -
    \ Section 2.1 MUST, SHOULD text added per template\n   -  Section 2.1 added some
    new terms\n      - parent protocol\n      - child protocol\n      - protocol encapsulation
    tree\n   -  Added section 2.3 about splitting into 2 documents:\n      \"Relationship
    to the RMON Protocol Identifier Macros Document\"\n   -  Added section 2.4 \"Relationship
    to the ATM-RMON MIB\"\n   -  rewrote section 3.2 \"Protocol Identifier Macro Format\"\n
    \     But no semantic changes were made; The PI macro syntax\n      is now specified
    in greater detail using BNF notation.\n   -  Section 3.2.3.1 \"Mapping of the
    'countsFragments(0)' BIT\"\n       - this section was clarified to allow multiple\n
    \        protocolDirParameters octets in a given PI string\n         to set the
    'countsFragments' bit. The RFC version\n         says just one octet can set this
    BIT. It is a\n         useful feature to identify fragmentation at\n         multiple
    layers, and most RMON-2 agents were\n         already doing this, so the WG agreed
    to this\n         clarification.\n   -  Added section 4.3 \"Encapsualtion Layers\"\n
    \  -  This document ends after the base layer encapsulation\n      definitions
    (through RFC 2074, section 5.2)\n   -  Added Intellectual Property section\n   -
    \ Moved RFC 2074 section 5.3\n      \"L3: Children of Base Protocol Identifiers\"\n
    \     through the end of RFC 2074, to the PI Reference [RFC2896]\n      document,
    in which many new protocol identifier macros were\n      added for application
    protocols and non-IP protocol\n      stacks.\n   -  Acknowledgements section has
    been updated\n"
  title: 'Appendix A: Changes since RFC 2074'
- contents:
  - "11.  Full Copyright Statement\n   Copyright (C) The Internet Society (2000).
    \ All Rights Reserved.\n   This document and translations of it may be copied
    and furnished to\n   others, and derivative works that comment on or otherwise
    explain it\n   or assist in its implementation may be prepared, copied, published\n
    \  and distributed, in whole or in part, without restriction of any\n   kind,
    provided that the above copyright notice and this paragraph are\n   included on
    all such copies and derivative works.  However, this\n   document itself may not
    be modified in any way, such as by removing\n   the copyright notice or references
    to the Internet Society or other\n   Internet organizations, except as needed
    for the purpose of\n   developing Internet standards in which case the procedures
    for\n   copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 11.  Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
