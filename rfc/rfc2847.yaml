- title: __initial_text__
  contents:
  - '     LIPKEY - A Low Infrastructure Public Key Mechanism Using SPKM

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memorandum describes a method whereby one can use GSS-API\n\
    \   [RFC2078] to supply a secure channel between a client and server,\n   authenticating\
    \ the client with a password, and a server with a public\n   key certificate.\
    \  As such, it is analogous to the common low\n   infrastructure usage of the\
    \ Transport Layer Security (TLS) protocol\n   [RFC2246].\n   The method leverages\
    \ the existing Simple Public Key Mechanism (SPKM)\n   [RFC2025], and is specified\
    \ as a separate GSS-API mechanism (LIPKEY)\n   layered above SPKM.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . 2\n   2.  LIPKEY's Requirements of SPKM  . . . . . . . . . . . .\
    \ . . . . 4\n   2.1.  Mechanism Type . . . . . . . . . . . . . . . . . . . . .\
    \ . . 4\n   2.2.  Name Type  . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ 4\n   2.3.  Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . 5\n\
    \   2.3.1.  MANDATORY Algorithms . . . . . . . . . . . . . . . . . . . 5\n   2.3.2.\
    \  RECOMMENDED Integrity Algorithms (I-ALG) . . . . . . . . . 7\n   2.4.  Context\
    \ Establishment Tokens . . . . . . . . . . . . . . . . 8\n   2.4.1.  REQ-TOKEN\
    \ Content Requirements . . . . . . . . . . . . . . 8\n   2.4.1.1.  algId and req-integrity\
    \  . . . . . . . . . . . . . . . . 8\n   2.4.1.2.  Req-contents . . . . . . .\
    \ . . . . . . . . . . . . . . . 8\n   2.4.1.2.1.  Options  . . . . . . . . . .\
    \ . . . . . . . . . . . . . 9\n   2.4.1.2.2.  Conf-Algs  . . . . . . . . . . .\
    \ . . . . . . . . . . . 9\n   2.4.1.2.3.  Intg-Algs  . . . . . . . . . . . . .\
    \ . . . . . . . . . 9\n   2.4.2.  REP-TI-TOKEN Content Requirements  . . . . .\
    \ . . . . . . . 9\n   2.4.2.1.  algId  . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . 9\n   2.4.2.2.  rep-ti-integ . . . . . . . . . . . . . . . . . . .\
    \ . . . 9\n   2.5.  Quality of Protection (QOP)  . . . . . . . . . . . . . . .\
    \ .10\n   3.  How LIPKEY Uses SPKM . . . . . . . . . . . . . . . . . . . .  11\n\
    \   3.1.  Tokens . . . . . . . . . . . . . . . . . . . . . . . . . .  11\n   3.2.\
    \  Initiator  . . . . . . . . . . . . . . . . . . . . . . . .  11\n   3.2.1. \
    \ GSS_Import_name  . . . . . . . . . . . . . . . . . . . .  11\n   3.2.2.  GSS_Acquire_cred\
    \ . . . . . . . . . . . . . . . . . . . .  11\n   3.2.3.  GSS_Init_sec_context\
    \ . . . . . . . . . . . . . . . . . .  12\n   3.2.3.1.  LIPKEY Caller Specified\
    \ anon_req_flag as TRUE  . . . .  12\n   3.2.3.2.  LIPKEY Caller Specified anon_req_flag\
    \ as FALSE . . . .  13\n   3.2.4.  Other operations . . . . . . . . . . . . .\
    \ . . . . . . .  14\n   3.3.  Target . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  14\n   3.3.1.  GSS_Import_name  . . . . . . . . . . . . . . . . .\
    \ . . .  14\n   3.3.2.  GSS_Acquire_cred . . . . . . . . . . . . . . . . . . .\
    \ .  14\n   3.3.3.  GSS_Accept_sec_context . . . . . . . . . . . . . . . . . \
    \ 15\n   4.  LIPKEY Description . . . . . . . . . . . . . . . . . . . . .  15\n\
    \   4.1.  Mechanism Type . . . . . . . . . . . . . . . . . . . . . .  15\n   4.2.\
    \  Name Types . . . . . . . . . . . . . . . . . . . . . . . .  15\n   4.3.  Token\
    \ Formats  . . . . . . . . . . . . . . . . . . . . . .  16\n   4.3.1.  Context\
    \ Tokens . . . . . . . . . . . . . . . . . . . . .  16\n   4.3.1.1.  Context Tokens\
    \ Prior to SPKM-3 Context Establishment .  16\n   4.3.1.2.  Post-SPKM-3 Context\
    \ Establishment Tokens . . . . . . .  16\n   4.3.1.2.1.  From LIPKEY Initiator\
    \  . . . . . . . . . . . . . . .  17\n   4.3.1.2.2.  From LIPKEY Target . . .\
    \ . . . . . . . . . . . . . .  17\n   4.3.2.  Tokens from GSS_GetMIC and GSS_Wrap\
    \  . . . . . . . . . .  17\n   4.4.  Quality of Protection  . . . . . . . . .\
    \ . . . . . . . . .  18\n   5.  Security Considerations  . . . . . . . . . . .\
    \ . . . . . . .  18\n   5.1.  Password Management  . . . . . . . . . . . . . .\
    \ . . . . .  18\n   5.2.  Certification Authorities  . . . . . . . . . . . . .\
    \ . . .  18\n   5.3.  HMAC-MD5 and MD5 Weaknesses  . . . . . . . . . . . . . .\
    \ .  18\n   5.4.  Security of cast5CBC . . . . . . . . . . . . . . . . . . . \
    \ 18\n   References . . . . . . . . . . . . . . . . . . . . . . . . . . .  19\n\
    \   Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . .  21\n   Author's\
    \ Address . . . . . . . . . . . . . . . . . . . . . . . .  21\n   Full Copyright\
    \ Statement . . . . . . . . . . . . . . . . . . . .  22\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n\
    \   This memorandum describes a new security mechanism under the GSS-API\n   called\
    \ the Low Infrastructure Public Key Mechanism (LIPKEY).  GSS-API\n   provides\
    \ a way for an application protocol to implement\n   authentication, integrity,\
    \ and privacy. TLS is another way. While TLS\n   is in many ways simpler for an\
    \ application to incorporate than GSS-\n   API, there are situations where GSS-API\
    \ might be more suitable.\n   Certainly this is the case with application protocols\
    \ that run over\n   connectionless protocols. It is also the case with application\n\
    \   protocols such as ONC RPC [RFC1831] [RFC2203], which have their own\n   security\
    \ architecture, and so do not easily mesh with a protocol like\n   TLS that is\
    \ implemented as a layer that encapsulates the upper layer\n   application protocol.\
    \ GSS-API allows the application protocol to\n   encapsulate as much of the application\
    \ protocol as necessary.\n   Despite the flexibility of GSS-API, it compares unfavorably\
    \ with TLS\n   with respect to the perception of the amount of infrastructure\n\
    \   required to deploy it. The better known GSS-API mechanisms, Kerberos\n   V5\
    \ [RFC1964] and SPKM require a great deal of infrastructure to set\n   up. Compare\
    \ this to the typical TLS deployment scenario, which\n   consists of a client\
    \ with no public key certificate accessing a\n   server with a public key certificate.\
    \  The client:\n   *    obtains the server's certificate,\n   *    verifies that\
    \ it was signed by a trusted Certification Authority\n        (CA),\n   *    generates\
    \ a random session symmetric key,\n   *    encrypts the session key with the server's\
    \ public key, and\n   *    sends the encrypted session key to the server.\n  \
    \ At this point, the client and server have a secure channel.  The\n   client\
    \ can then provide a user name and password to the server to\n   authenticate\
    \ the client. For example, when TLS is being used with the\n   http protocol,\
    \ once there is a secure channel, the http server will\n   present the client\
    \ with an html page that prompts for a user name and\n   password. This information\
    \ is then encrypted with the session key and\n   sent to the server. The server\
    \ then authenticates the client.\n   Note that the client is not required to have\
    \ a certificate for itself\n   to identify and authenticate it to the server.\
    \ In addition to a TLS\n   implementation, the required security infrastructure\
    \ includes a\n   public key certificate and password database on the server, and\
    \ a\n   list of trusted CAs and their public keys on the client. Most\n   operating\
    \ systems that the http server would run on already have a\n   native password\
    \ database, so the net additional infrastructure is a\n   server certificate and\
    \ CA list. Hence the term \"low infrastructure\n   security model\" to identify\
    \ this typical TLS deployment scenario.\n   By using unilateral authentication,\
    \ and using a mechanism resembling\n   the SPKM-1 mechanism type, SPKM can offer\
    \ many aspects of the\n   previously described low infrastructure security model.\
    \ An\n   application that uses GSS-API is certainly free to use GSS-API's\n  \
    \ GSS_Wrap() routine to encrypt a user name and password and send them\n   to\
    \ the server, for it to decrypt and verify.\n   Applications often have application\
    \ protocols associated with them,\n   and there might not be any provision in\
    \ the protocol to specify a\n   password.  Layering a thin GSS-API mechanism over\
    \ a mechanism\n   resembling SPKM-1 can mitigate this problem. This can be a useful\n\
    \   approach to avoid modifying applications that have already bound to\n   GSS-API,\
    \ assuming the applications are not statically bound to\n   specific GSS-API mechanisms.\
    \  The remainder of this memorandum\n   defines the thin mechanism: the Low Infrastructure\
    \ Public Key\n   Mechanism (LIPKEY).\n"
- title: 2.  LIPKEY's Requirements of SPKM
  contents:
  - "2.  LIPKEY's Requirements of SPKM\n   SPKM-1 with unilateral authentication is\
    \ close to the desired low\n   infrastructure model described earlier. This section\
    \ describes some\n   additional changes to how SPKM-1 operates in order to realize\
    \ the low\n   infrastructure model.  These changes include some minor changes\
    \ in\n   semantics.  While it would be possible to implement these semantic\n\
    \   changes within an SPKM-1 implementation (including using the same\n   mechanism\
    \ type Object Identifier (OID) as SPKM-1), the set of changes\n   stretch the\
    \ interpretation of RFC 2025 to the point where\n   compatibility would be in\
    \ danger. A new mechanism type, called SPKM-\n   3, is warranted. LIPKEY requires\
    \ that the SPKM implementation support\n   SPKM-3.  SPKM-3 is equivalent to SPKM-1,\
    \ except as described in the\n   remainder of this section.\n"
- title: 2.1.  Mechanism Type
  contents:
  - "2.1.  Mechanism Type\n   SPKM-3 has a different mechanism type OID from SPKM-1.\n\
    \   spkm-3 OBJECT IDENTIFIER ::=\n      {iso(1)identified-organization(3)dod(6)internet(1)security(5)\n\
    \      mechanisms(5)spkm(1)spkm-3(3)}\n"
- title: 2.2.  Name Type
  contents:
  - "2.2.  Name Type\n   RFC 2025 defines no required name types of SPKM. LIPKEY requires\
    \ that\n   the SPKM-3 implementation support all the mechanism independent name\n\
    \   types in RFC 2078.\n"
- title: 2.3.  Algorithms
  contents:
  - '2.3.  Algorithms

    '
- title: 2.3.1.  MANDATORY Algorithms
  contents:
  - "2.3.1.  MANDATORY Algorithms\n   RFC 2025 defines various algorithms for integrity,\
    \ confidentiality,\n   key establishment, and subkey derivation.  Except for\n\
    \   md5WithRSAEncryption, the REQUIRED Key Establishment (K-ALG),\n   Integrity\
    \ (I-ALG) and One-Way Functions for Subkey Derivation (O-ALG)\n   algorithms listed\
    \ in RFC 2025 continue to be REQUIRED.\n   SPKM is designed to be extensible with\
    \ regard to new algorithms. In\n   order for LIPKEY to work correctly and securely,\
    \ the following\n   algorithms MUST be implemented in SPKM-3:\n   *    Integrity\
    \ algorithms (I-ALG)\n      NULL-MAC\n           Because the initiator may not\
    \ have a certificate for itself,\n           nor for the target, it is not possible\
    \ for it to calculate an\n           Integrity value in the initiator's REQ-TOKEN\
    \ that is sent to\n           the target. So we define, in ASN.1 [CCITT] syntax,\
    \ a null I-\n           ALG that returns a zero length bit string regardless of\
    \ the\n           input passed to it:\n      NULL-MAC OBJECT IDENTIFIER ::=\n\
    \         {iso(1)identified-organization(3)dod(6)internet(1)security(5)\n    \
    \     integrity(3)NULL-MAC(3)}\n      id-dsa-with-sha1\n           This is the\
    \ signature algorithm as defined in Section 7.2.2\n           of [RFC2459].  As\
    \ noted in RFC 2459, the ASN.1 OID used to\n           identify this signature\
    \ algorithm is:\n              id-dsa-with-sha1 OBJECT IDENTIFIER ::= {\n    \
    \                  iso(1) member-body(2) us(840) x9-57(10040)\n              \
    \                x9cm(4) 3\n              }\n           Note that there is a work-in-progress\
    \ [PKIX] to obsolete RFC\n           2459. However that work-in-progress does\
    \ not change the\n           definition of id-dsa-with-sha1.\n      HMAC-MD5\n\
    \           A consequence of the SPKM-3 initiator not having a\n           certificate\
    \ is that it cannot use a digital signature\n           algorithm like md5WithRSAEncryption,\
    \ id-dsa-with-sha1, or\n           sha1WithRSAEncryption once the context is established.\n\
    \           Instead, a message authentication code (MAC) algorithm is\n      \
    \     required. DES-MAC is specified as recommended in [RFC2025].\n          \
    \ Since the security of 56 bit DES has been shown to be\n           inadequate\
    \ [EFF], SPKM-3 needs a stronger MAC. Thus, SPKM-3\n           MUST support the\
    \ HMAC-MD5 algorithm [RFC2104], with this OID:\n              HMAC-MD5 OBJECT\
    \ IDENTIFIER ::= {\n                      iso(1) org(3) dod(6) internet(1) security(5)\n\
    \                              mechanisms(5) ipsec(8) isakmpOakley(1)\n      \
    \                        1\n              }\n           The reference for the\
    \ algorithm OID of HMAC-MD5 is [IANA].\n           The reference for the HMAC-MD5\
    \ algorithm is [RFC2104].\n           The HMAC-SHA1 algorithm is not a mandatory\
    \ SPKM-3 I-ALG MAC\n           because SHA-1 is about half the speed of MD5 [Young].\
    \  A MAC\n           based on an encryption algorithm like cast5CBC, DES EDE3,\
    \ or\n           RC4 is not mandatory because MD5 is 31 percent faster than\n\
    \           the fastest of the three encryption algorithms [Young].\n   *    Confidentiality\
    \ algorithm (C-ALG).\n        RFC 2025 does not have a MANDATORY confidentiality\
    \ algorithm,\n        and instead has RECOMMENDED a 56 bit DES algorithm. Since\
    \ the\n        LIPKEY initiator needs to send a password to the target, and\n\
    \        since 56 bit DES has been demonstrated as inadequate [EFF],\n       \
    \ LIPKEY needs stronger encryption. Thus, SPKM-3 MUST support this\n        algorithm:\n\
    \           cast5CBC OBJECT IDENTIFIER ::= {\n                   iso(1) memberBody(2)\
    \ usa(840) nt(113533) nsn(7)\n                           algorithms(66) 10\n \
    \          }\n           Parameters ::= SEQUENCE {\n                   iv OCTET\
    \ STRING DEFAULT 0, -- Initialization vector\n                   keyLength INTEGER\
    \          -- Key length, in bits\n           }\n        The reference for the\
    \ OID and description of the cast5CBC\n        algorithm is [RFC2144]. The keyLength\
    \ in the Parameters MUST be\n        set to 128 bits.\n        A triple DES (DES\
    \ EDE3) algorithm is not a mandatory SPKM-3 C-\n        ALG because it is much\
    \ slower than cast5CBC. One set of\n        measurements [Young] on a Pentium\
    \ Pro 200 megahertz processor\n        using the SSLeay code, showed that DES\
    \ EDE3 performed as high as\n        1,646,210 bytes per second, using 1024 byte\
    \ blocks. The same\n        test bed yielded performance of 7,147,760 bytes per\
    \ second for\n        cast5CBC, and 22,419,840 bytes per second for RC4. Most\
    \ TLS\n        sessions negotiate the RC4 cipher. Given that LIPKEY is targeted\n\
    \        at environments similar to that where TLS is deployed, selecting\n  \
    \      a cipher that is over 13 times slower (and over 13 times more\n       \
    \ CPU intensive) than RC4 would severely impede the usefulness of\n        LIPKEY.\
    \  For performance reasons, RC4 would be the preferred\n        mandatory algorithm\
    \ for SPKM-3. Due to intellectual property\n        considerations with RC4 [Schneier],\
    \ the combination of\n        cast5CBC's reasonable performance, and its royalty-free\n\
    \        licensing terms [RFC2144] make cast5CBC the optimal choice among\n  \
    \      DES EDE3, RC4, and cast5CBC.\n   *    Key Establishment Algorithm (K-ALG)\n\
    \        RFC 2025 lists dhKeyAgreement [PKCS-3] as an apparently optional\n  \
    \      algorithm.  As will be described later, the RSAEncryption key\n       \
    \ establishment algorithm is of no use for a low infrastructure\n        security\
    \ mechanism as defined by this memorandum. Hence, in\n        SPKM-3, dhKeyAgreement\
    \ is a REQUIRED key establishment\n        algorithm:\n           dhKeyAgreement\
    \ OBJECT IDENTIFIER ::= {\n                   iso(1) member-body(2) US(840) rsadsi(113549)\
    \ pkcs(1)\n                   pkcs-3(3) 1\n           }\n   *    One-Way Function\
    \ for Subkey Derivation Algorithm (O-ALG)\n        RFC 2025 lists MD5 as a mandatory\
    \ algorithm.  Since MD5 has been\n        found to have weaknesses when used as\
    \ a hash [Dobbertin], id-\n        sha1 is a MANDATORY O-ALG in SPKM-3:\n    \
    \       id-sha1 OBJECT IDENTIFIER ::= {\n                   iso(1) identified-organization(3)\
    \ oiw(14)\n                   secsig(3) algorithms(2) 26\n           }\n     \
    \   The reference for the algorithm OID of id-sha1 is [RFC2437].\n        The\
    \ reference for SHA-1 algorithm corresponding to id-sha1 is\n        [FIPS].\n"
- title: 2.3.2.  RECOMMENDED Integrity Algorithms (I-ALG)
  contents:
  - "2.3.2.  RECOMMENDED Integrity Algorithms (I-ALG)\n   md5WithRSAEncryption\n \
    \       The md5WithRSAEncryption integrity algorithm is listed in\n        [RFC2025]\
    \ as mandatory.  Due to intellectual property\n        considerations [RSA-IP],\
    \ SPKM-3 implementations cannot be\n        required to implement it. However,\
    \ given the proliferation of\n        certificates using RSA public keys, md5WithRSAEncryption\
    \ is\n        strongly RECOMMENDED. Otherwise, the opportunities for LIPKEY to\n\
    \        leverage existing public key infrastructure will be limited.\n   sha1WithRSAEncryption\n\
    \        For reasons similar to that for md5WithRSAEncryption,\n        sha1WithRSAEncryption\
    \ is a RECOMMENDED algorithm. The\n        sha1WithRSAEncryption algorithm is\
    \ listed in addition to\n        md5WithRSAEncryption due to weaknesses in the\
    \ MD5 hash algorithm\n        [Dobbertin]. The OID for sha1WithRSAEncryption is:\n\
    \           sha1WithRSAEncryption  OBJECT IDENTIFIER ::= {\n                 \
    \  iso(1) member-body(2) US(840) rsadsi(113549) pkcs(1)\n                   pkcs-1(1)\
    \ 5\n           }\n        The reference for the algorithm OID and description\
    \ of\n        sha1WithRSAEncryption is [RFC2437].\n"
- title: 2.4.  Context Establishment Tokens
  contents:
  - "2.4.  Context Establishment Tokens\n   RFC 2025 sets up a context with an initiator\
    \ first token (REQ-TOKEN),\n   a target reply (REP-TI-TOKEN), and finally an initiator\
    \ second token\n   (REP-IT-TOKEN) to reply to the target's reply. Since LIPKEY\
    \ uses\n   SPKM-3 with unilateral authentication, the REP-IT-TOKEN is not used.\n\
    \   LIPKEY has certain requirements on the contents of the REQ-TOKEN and\n   REP-TI-TOKEN,\
    \ but the syntax of the SPKM-3 tokens is not different\n   from RFC 2025's SPKM-1\
    \ tokens.\n"
- title: 2.4.1.  REQ-TOKEN Content Requirements
  contents:
  - '2.4.1.  REQ-TOKEN Content Requirements

    '
- title: 2.4.1.1.  algId and req-integrity
  contents:
  - "2.4.1.1.  algId and req-integrity\n   If the SPKM-3 initiator cannot calculate\
    \ a req-integrity field due to\n   the lack of a target certificate, it MUST use\
    \ the NULL-MAC I-ALG\n   described earlier in this memorandum. This will produce\
    \ a zero length\n   bit string in the Integrity field.\n"
- title: 2.4.1.2.  Req-contents
  contents:
  - "2.4.1.2.  Req-contents\n   Because RFC 2025 requires that the RSAEncryption K-ALG\
    \ be present,\n   SPKM-1 must be able to map the target (targ-name) to its public\
    \ key\n   certificate, and thus SPKM can use the RSAEncryption algorithm to\n\
    \   fill in the key-estb-req field.  Because LIPKEY assumes a low\n   infrastructure\
    \ deployment, SPKM-3 MUST be prepared to be unable to\n   map the targ-name field\
    \ of the Req-contents field.  This is a\n   contradiction which is resolved by\
    \ requiring SPKM-3 to support the\n   dhKeyAgreement algorithm. Note that if an\
    \ SPKM-3 implementation tries\n   to map the target to a certificate, and succeeds,\
    \ it is free to use\n   the RSAEncryption K-ALG algorithm. It is also free to\
    \ use an algID\n   other than NULL-MAC in the REQ-TOKEN type.\n"
- title: 2.4.1.2.1.  Options
  contents:
  - "2.4.1.2.1.  Options\n   SPKM-3 implementations MUST set the target-certif-data-required\
    \ bit\n   to 1 if the only K-ALG in the key-estb-set field of Req-contents is\n\
    \   dhKeyAgreement. This would normally occur if the SPKM-3\n   implementation\
    \ cannot resolve the target name to a certificate.\n"
- title: 2.4.1.2.2.  Conf-Algs
  contents:
  - "2.4.1.2.2.  Conf-Algs\n   If the SPKM-3 implementation supports an algorithm\
    \ weaker than\n   cast5CBC, cast5CBC MUST be listed before the weaker algorithm\
    \ to\n   encourage the target to negotiate the stronger algorithm.\n"
- title: 2.4.1.2.3.  Intg-Algs
  contents:
  - "2.4.1.2.3.  Intg-Algs\n   Because the initiator will be anonymous (at the SPKM-3\
    \ level) and\n   will not have a certificate for itself, the initiator cannot\
    \ use an\n   integrity algorithm that supports non-repudiation; it must use a\
    \ MAC\n   algorithm. If the SPKM-3 implementation supports an algorithm weaker\n\
    \   than HMAC-MD5, HMAC-MD5 MUST be listed before the weaker algorithm to\n  \
    \ encourage the target to negotiate the stronger algorithm.\n"
- title: 2.4.2.  REP-TI-TOKEN Content Requirements
  contents:
  - "2.4.2.  REP-TI-TOKEN Content Requirements\n   With the previously described requirements\
    \ on REQ-TOKEN, the contents\n   of SPKM-3's REP-TI-TOKEN can for the most part\
    \ be derived from the\n   specification in RFC 2025. The exceptions are the algId\
    \ and rep-ti-\n   integ fields.\n"
- title: 2.4.2.1.  algId
  contents:
  - "2.4.2.1.  algId\n   The SPKM-3 target MUST NOT use a NULL-MAC I-ALG; it MUST\
    \ use a\n   signature algorithm like id-dsa-with-sha1, md5WithRSAEncryption, or\n\
    \   sha1WithRSAEncryption.\n"
- title: 2.4.2.2.  rep-ti-integ
  contents:
  - "2.4.2.2.  rep-ti-integ\n   If the req-token has an algId of NULL-MAC, then the\
    \ target MUST\n   compute the rep-ti-integ on the concatenation of the req-contents\
    \ and\n   rep-ti-contents.\n"
- title: 2.5.  Quality of Protection (QOP)
  contents:
  - "2.5.  Quality of Protection (QOP)\n   The SPKM-3 initiator and target negotiate\
    \ the set of algorithms they\n   mutually support, using the procedure defined\
    \ in Section 5.2 of RFC\n   2025. If a QOP of zero is specified, then the initiator\
    \ and target\n   will use the first C-ALG (privacy), and I-ALG (integrity) algorithms\n\
    \   negotiated.\n   SPKM breaks the QOP into several fields, as reproduced here\
    \ from\n   Section 5.2 of RFC 2025:\n       Confidentiality                  \
    \  Integrity\n       31 (MSB)                        16 15                 (LSB)\
    \ 0\n      -------------------------------|-------------------------------\n \
    \     | TS(5) | U(3) | IA(4) | MA(4) | TS(5) | U(3) | IA(4) | MA(4) |\n      -------------------------------|-------------------------------\n\
    \   The MA subfields enumerate mechanism-defined algorithms. Since this\n   memorandum\
    \ introduces a new mechanism, SPKM-3, within the SPKM\n   family, it is appropriate\
    \ to add algorithms to the MA subfields of\n   the respective Confidentiality\
    \ and Integrity fields.\n   The complete set of Confidentiality MA algorithms\
    \ is thus:\n      0001 (1) = DES-CBC\n      0010 (2) = cast5CBC\n   Where \"0001\"\
    \ and \"0010\" are in base 2.  An SPKM peer that negotiates\n   a confidentiality\
    \ MA algorithm value of \"0010\" MUST use a 128 bit\n   key, i.e. set the keyLength\
    \ values in the cast5CBC Parameters to 128\n   bits.\n   The complete set of Integrity\
    \ MA algorithms is thus:\n      0001 (1) = md5WithRSAEncryption\n      0010 (2)\
    \ = DES-MAC\n      0011 (3) = id-dsa-with-sha1\n      0100 (4) = HMAC-MD5\n  \
    \    0101 (5) = sha1WithRSAEncryption\n   Where \"0001\" through \"0101\" are\
    \ in base 2.\n   Adding support for cast5CBC, id-dsa-with-sha1, HMAC-MD5, and\n\
    \   sha1WithRSAEncryption in the above manner to SPKM-1 and SPKM-2 does\n   not\
    \ impair SPKM-1 and SPKM-2 backward compatibility because, as noted\n   previously,\
    \ SPKM negotiates algorithms. An older SPKM-1 or SPKM-2\n   that does not recognize\
    \ MA values for cast5CBC, id-dsa-with-sha1,\n   HMAC-MD5, or sha1WithRSAEncryption\
    \ will not select them.\n"
- title: 3.  How LIPKEY Uses SPKM
  contents:
  - '3.  How LIPKEY Uses SPKM

    '
- title: 3.1.  Tokens
  contents:
  - "3.1.  Tokens\n   LIPKEY will invoke SPKM-3 to produce SPKM tokens. Since the\
    \ mechanism\n   that the application uses is LIPKEY, LIPKEY will wrap some of\
    \ the\n   SPKM-3 tokens with LIPKEY prefixes. The exact definition of the\n  \
    \ tokens is described later in this memorandum.\n"
- title: 3.2.  Initiator
  contents:
  - '3.2.  Initiator

    '
- title: 3.2.1.  GSS_Import_name
  contents:
  - "3.2.1.  GSS_Import_name\n   The initiator uses GSS_Import_name to import the\
    \ target's name,\n   typically, but not necessarily, using the GSS_C_NT_HOSTBASED_SERVICE\n\
    \   name type.  Ultimately, the output of GSS_Import_name will apply to\n   an\
    \ SPKM-3 mechanism type because a LIPKEY target is an SPKM-3 target.\n"
- title: 3.2.2.  GSS_Acquire_cred
  contents:
  - "3.2.2.  GSS_Acquire_cred\n   The initiator calls GSS_Acquire_cred. The credentials\
    \ that are\n   acquired are LIPKEY credentials, a user name and password. How\
    \ the\n   user name and password is acquired is dependent upon the operating\n\
    \   environment. A application that invokes GSS_Acquire_cred() while the\n   application's\
    \ user has a graphical user interface running might\n   trigger the appearance\
    \ of a pop up window that prompts for the\n   information. A application embedded\
    \ into the operating system, such\n   as an NFS [Sandberg] client implemented\
    \ as a native file system might\n   broadcast a message to the user's terminals\
    \ telling him to invoke a\n   command that prompts for the information.\n   Because\
    \ the credentials will not be used until GSS_Init_sec_context\n   is called, the\
    \ LIPKEY implementation will need to safeguard the\n   credentials. If this is\
    \ a problem, the implementation may instead\n   defer actual acquisition of the\
    \ user name and password until\n   GSS_init_sec_context is ready to send the user\
    \ name and password to\n   the target. In that event, the output_cred_handle argument\
    \ of\n   GSS_Acquire_cred would simply be a reference that mapped to the\n   principal\
    \ corresponding to the desired_name argument. A subsequent\n   GSS_Init_sec_context\
    \ call would consider the mapping of\n   claimant_cred_handle to principal when\
    \ it acquires the user name and\n   password. For example, the aforementioned\
    \ pop up window might fill in\n   the user name portion of the dialog with a default\
    \ value that maps to\n   the principal referred to in claimant_cred_handle.\n"
- title: 3.2.3.  GSS_Init_sec_context
  contents:
  - "3.2.3.  GSS_Init_sec_context\n   When a program invokes GSS_Init_sec_context\
    \ on the LIPKEY mechanism\n   type, if the context handle is NULL, the LIPKEY\
    \ mechanism will in\n   turn invoke GSS_Init_sec_context on an SPKM-3 mechanism\
    \ implemented\n   according to the requirements described previously. This call\
    \ to\n   SPKM-3 MUST have the following attributes:\n   *    claimant_cred_handle\
    \ is NULL\n   *    mutual_req_flag is FALSE\n   *    anon_req_flag is TRUE\n \
    \  *    input_token is NULL\n   *    mech_type is the OID of the SPKM-3 mechanism\n\
    \   Keep in mind the above attributes are in the GSS_Init_sec_context\n   call\
    \ from the LIPKEY mechanism down to the SPKM-3 mechanism. There\n   are no special\
    \ restrictions placed on the application invoking\n   LIPKEY's GSS_Init_sec_context\
    \ routine.  All other arguments are\n   derived from the LIPKEY GSS_Init_sec_context\
    \ arguments.\n   The call to the SPKM-3 GSS_Init_sec_context will create an SPKM-3\n\
    \   context handle. The remainder of the description of the LIPKEY\n   GSS_Init_sec_context\
    \ call depends on whether the caller of the LIPKEY\n   GSS_Init_sec_context sets\
    \ anon_req_flag to TRUE or FALSE.\n"
- title: 3.2.3.1.  LIPKEY Caller Specified anon_req_flag as TRUE
  contents:
  - "3.2.3.1.  LIPKEY Caller Specified anon_req_flag as TRUE\n   If the caller of\
    \ LIPKEY's GSS_Init_sec_context sets anon_req_flag to\n   TRUE, it MUST return\
    \ to the LIPKEY caller all the outputs from the\n   SPKM-3 GSS_Init_sec_context\
    \ call, including the\n   output_context_handle, output_token, and mech_type.\
    \ In this way,\n   LIPKEY now \"gets out of the way\" of GSS-API processing between\
    \ the\n   application and SPKM-3, because nothing in the returned outputs\n  \
    \ relates to LIPKEY.  This is necessary, because LIPKEY context tokens\n   do\
    \ not have provision for specifying anonymous initiators. This is\n   because\
    \ SPKM-3 is sufficient for purpose of supporting anonymous\n   initiators in a\
    \ low infrastructure environment.\n   Clearly, when the LIPKEY caller desires\
    \ anonymous authentication,\n   LIPKEY does not add any value, but it is simpler\
    \ to support the\n   feature, than to insist the caller directly use SPKM-3.\n\
    \   If all goes well, the caller of LIPKEY will be returned a\n   major_status\
    \ of GSS_S_CONTINUE_NEEDED via SPKM-3, and so the caller\n   of LIPKEY will send\
    \ the output_token to the target.  The caller of\n   LIPKEY then receives the\
    \ response token from the target, and directly\n   invokes the SPKM-3 GSS_Init_sec_context.\
    \  Upon return, the\n   major_status should be GSS_S_COMPLETE.\n"
- title: 3.2.3.2.  LIPKEY Caller Specified anon_req_flag as FALSE
  contents:
  - "3.2.3.2.  LIPKEY Caller Specified anon_req_flag as FALSE\n   The LIPKEY mechanism\
    \ will need to allocate a context handle for\n   itself, and record in the LIPKEY\
    \ context handle the SPKM-3 context\n   handle that was returned in the output_context_handle\
    \ parameter from\n   the call to the SPKM-3 GSS_Init_sec_context routine.  The\
    \ LIPKEY\n   GSS_Init_sec_context routine will return in output_context_handle\
    \ the\n   LIPKEY context handle, and in mech_type, the LIPKEY mechanism type.\n\
    \   The output_token is as defined later in this memorandum, in the\n   subsection\
    \ entitled \"Context Tokens Prior to SPKM-3 Context\n   Establishment.\"  All\
    \ the other returned outputs will be those that\n   the SPKM-3 GSS_Init_sec_context\
    \ routine returned to LIPKEY. If all\n   went well, the SPKM-3 mechanism will\
    \ have returned a major_status of\n   GSS_S_CONTINUE_NEEDED.\n   The caller of\
    \ the LIPKEY GSS_Init_sec_context routine will see a\n   major_status of GSS_S_CONTINUE_NEEDED,\
    \ and so the caller of LIPKEY\n   will send the output_token to the target. The\
    \ caller of LIPKEY then\n   receives the target's response token, and invokes\
    \ the LIPKEY\n   GSS_Init_sec_context routine for a second time. LIPKEY then invokes\n\
    \   the SPKM-3 GSS_Init_sec_context for a second time and upon return,\n   the\
    \ major_status should be GSS_S_COMPLETE.\n   While SPKM-3's context establishment\
    \ is now complete, LIPKEY's\n   context establishment is not yet complete, because\
    \ the initiator must\n   send to the target the user name and password that were\
    \ passed to it\n   via the claimant_cred_handle on the first call to the LIPKEY\n\
    \   GSS_Init_sec_context routine. LIPKEY uses the established SPKM-3\n   context\
    \ handle as the input to GSS_Wrap (with conf_req_flag set to\n   TRUE) to encrypt\
    \ what the claimant_cred_handle refers to (user name\n   and password), and returns\
    \ that as the output_token to the caller of\n   LIPKEY (provided the conf_state\
    \ output from the call to SPKM-3's\n   GSS_Wrap is TRUE), along with a major_status\
    \ of\n   GSS_S_CONTINUE_NEEDED.\n   The caller of LIPKEY sends its second context\
    \ establishment token to\n   the target, and waits for a token provided by the\
    \ target's\n   GSS_Accept_sec_context routine. The target's LIPKEY\n   GSS_Accept_sec_context\
    \ routine invokes the SPKM-3 GSS_Unwrap routine\n   on the token, and validates\
    \ the user name and password.  The target\n   then invokes SPKM-3's GSS_Wrap routine\
    \ on a boolean indicating\n   whether or not the user name and password were accepted,\
    \ and returns\n   the output_message result from GSS_Wrap as the output_token\
    \ result\n   for GSS_Accept_sec_context.\n   The caller of LIPKEY receives the\
    \ target's response token, and passes\n   this via the input_token parameter to\
    \ the LIPKEY GSS_Init_sec_context\n   routine.  LIPKEY then invokes GSS_Unwrap\
    \ to get the boolean\n   acceptance indication, and maps this to a major_status\
    \ of either\n   GSS_S_COMPLETE indicating successful (the boolean was TRUE) and\n\
    \   completed LIPKEY context establishment, or GSS_S_FAILURE, indicating\n   that\
    \ context establishment failed.  GSS_S_CONTINUE_NEEDED will not be\n   returned.\n\
    \   Note that the mutual_req_flag parameter is ignored because unilateral\n  \
    \ authentication is impossible.  The initiator must authenticate the\n   target\
    \ via SPKM-3 in order to create a secure channel to transmit the\n   user name\
    \ and password. The target must authenticate the initiator\n   when it receives\
    \ the user name and password.\n   The SPKM-3 context remains established while\
    \ the LIPKEY context is\n   established.  If the SPKM-3 context expires before\
    \ the LIPKEY context\n   is destroyed, the LIPKEY implementation should expire\
    \ the LIPKEY\n   context and return the appropriate error on the next GSS-API\n\
    \   operation.\n"
- title: 3.2.4.  Other operations
  contents:
  - "3.2.4.  Other operations\n   For other operations, the LIPKEY context acts as\
    \ a pass through to\n   the SPKM-3 context. Operations that affect or inquire\
    \ context state,\n   such as GSS_Delete_sec_context, GSS_Export_sec_context,\n\
    \   GSS_Import_sec_context, and GSS_Inquire_context will require a pass\n   through\
    \ to the SPKM-3 context and a state modification of the LIPKEY\n   context.\n"
- title: 3.3.  Target
  contents:
  - '3.3.  Target

    '
- title: 3.3.1.  GSS_Import_name
  contents:
  - "3.3.1.  GSS_Import_name\n   As with the initiator, the imported name will be\
    \ that of the target.\n"
- title: 3.3.2.  GSS_Acquire_cred
  contents:
  - "3.3.2.  GSS_Acquire_cred\n   The target calls the LIPKEY GSS_Acquire_cred routine\
    \ to get a\n   credential for an SPKM-3 target, via the SPKM-3 GSS_Acquire_cred\n\
    \   routine. The desired_name is the output_name from GSS_Import_name.\n"
- title: 3.3.3.  GSS_Accept_sec_context
  contents:
  - "3.3.3.  GSS_Accept_sec_context\n   When a program invokes GSS_Accept_sec_context\
    \ on the LIPKEY mechanism\n   type, if the context handle is NULL, the LIPKEY\
    \ mechanism will in\n   turn invoke GSS_Accept_sec_context on an SPKM-3 mechanism\
    \ implemented\n   according the requirements described previously. This call to\
    \ SPKM-3\n   is no different than what one would expect for a layered call to\n\
    \   GSS_Accept_sec_context.\n   If all goes well, the SPKM-3 GSS_Accept_sec_context\
    \ call succeeds\n   with GSS_S_COMPLETE, and the LIPKEY GSS_Accept_sec_context\
    \ call\n   returns the output_token to the caller, but with a major_status of\n\
    \   GSS_S_CONTINUE_NEEDED because the LIPKEY initiator is still expected\n   to\
    \ send the user name and password.\n   Once the SPKM-3 context is in a GSS_S_COMPLETE\
    \ state, the next token\n   the target receives will contain the user name and\
    \ password, wrapped\n   by the output of an SPKM-3 GSS_Wrap call. The target invokes\
    \ the\n   LIPKEY GSS_Accept_sec_context, which in turn invokes the SPKM-3\n  \
    \ GSS_Unwrap routine. The LIPKEY GSS_Accept_sec_context routine then\n   compares\
    \ the user name and password with its user name name and\n   password database.\
    \  If the initiator's user name and password are\n   valid, GSS_S_COMPLETE is\
    \ returned to the caller.  Otherwise\n   GSS_S_FAILURE is returned. In either\
    \ case, an output_token - equal to\n   the output_message result from an SPKM-3\
    \ GSS_Wrap call on a boolean\n   value - is returned to the caller.  The boolean\
    \ value is set to TRUE\n   if the the user name and password were valid, FALSE\
    \ otherwise. The\n   target expects no more context establishment tokens from\
    \ caller.\n"
- title: 4.  LIPKEY Description
  contents:
  - '4.  LIPKEY Description

    '
- title: 4.1.  Mechanism Type
  contents:
  - "4.1.  Mechanism Type\n   lipkey OBJECT IDENTIFIER ::=\n      {iso(1)identified-organization(3)dod(6)internet(1)security(5)\n\
    \      mechanisms(5)lipkey(9)}\n"
- title: 4.2.  Name Types
  contents:
  - "4.2.  Name Types\n   LIPKEY uses only the mechanism independent name types defined\
    \ in RFC\n   2078. All the name types defined in RFC 2078 are REQUIRED.\n"
- title: 4.3.  Token Formats
  contents:
  - '4.3.  Token Formats

    '
- title: 4.3.1.  Context Tokens
  contents:
  - "4.3.1.  Context Tokens\n   GSS-API defines the context tokens as:\n      InitialContextToken\
    \ ::=\n      -- option indication (delegation, etc.) indicated within\n      --\
    \ mechanism-specific token\n      [APPLICATION 0] IMPLICIT SEQUENCE {\n      \
    \       thisMech MechType,\n             innerContextToken ANY DEFINED BY thisMech\n\
    \                -- contents mechanism-specific\n                -- ASN.1 structure\
    \ not required\n      }\n      SubsequentContextToken ::= innerContextToken ANY\n\
    \      -- interpretation based on predecessor InitialContextToken\n      -- ASN.1\
    \ structure not required\n   The contents of the innerContextToken depend on whether\
    \ the SPKM-3\n   context is established or not.\n"
- title: 4.3.1.1.  Context Tokens Prior to SPKM-3 Context Establishment
  contents:
  - "4.3.1.1.  Context Tokens Prior to SPKM-3 Context Establishment\n   In a LIPKEY\
    \ InitialContextToken, thisMech will be the Object\n   identifier for LIPKEY.\
    \  However, as long as LIPKEY has not\n   established the SPKM-3 mechanism, the\
    \ innerContextToken for both the\n   InitialContextToken and the SubsequentContextToken\
    \ will be the output\n   of an SPKM-3 GSS_Init_sec_context or GSS_Accept_sec_context.\
    \  So the\n   LIPKEY innerContextToken would be either:\n   *    An InitialContextToken,\
    \ with thisMech set to the object\n        identifier for SPKM-3, with innerContextToken\
    \ defined to be an\n        SPKMInnerContextToken, as defined in RFC 2025.\n \
    \  *    A SubsequentContextToken, with innerContextToken defined to be\n     \
    \   SPKMInnerContextToken\n"
- title: 4.3.1.2.  Post-SPKM-3 Context Establishment Tokens
  contents:
  - "4.3.1.2.  Post-SPKM-3 Context Establishment Tokens\n   Once the SPKM-3 context\
    \ is established, there is just one token sent\n   from the initiator to the target,\
    \ and one token returned to\n   initiator.\n"
- title: 4.3.1.2.1.  From LIPKEY Initiator
  contents:
  - "4.3.1.2.1.  From LIPKEY Initiator\n   The LIPKEY initiator generates a token\
    \ that is the the result of a\n   GSS_Wrap (conf_req is set to TRUE) of a user\
    \ name and password by the\n   SPKM-3 context.  The input_message argument of\
    \ GSS_Wrap refers to an\n   instance of the UserName-Password type defined below:\n\
    \      UserName-Password ::= SEQUENCE {\n              user-name       OCTET STRING,\n\
    \                                      -- each octet is an octet of a\n      \
    \                                -- UTF-8 [RFC2279] string\n              password\
    \        OCTET STRING\n                                      -- each octet is\
    \ an octet of a\n                                      -- UTF-8 [RFC2279] string\n\
    \      }\n"
- title: 4.3.1.2.2.  From LIPKEY Target
  contents:
  - "4.3.1.2.2.  From LIPKEY Target\n   The target validates the user name and password\
    \ token from the\n   initiator, and generates a response token that is the output_message\n\
    \   result of an SPKM-3 GSS_Wrap (conf_req may or may not be set to TRUE)\n  \
    \ call on an indication of validation success. The input_message\n   argument\
    \ of GSS_Wrap refers to an instance of the Valid-UNP type\n   defined below:\n\
    \      Valid-UNP ::= BOOLEAN\n                      -- If TRUE, user name/password\
    \ pair was valid.\n"
- title: 4.3.2.  Tokens from GSS_GetMIC and GSS_Wrap
  contents:
  - "4.3.2.  Tokens from GSS_GetMIC and GSS_Wrap\n   RFC 2078 defines the token emitted\
    \ by GSS_GetMIC and GSS_Wrap as:\n             PerMsgToken ::=\n             --\
    \ as emitted by GSS_GetMIC and processed by GSS_VerifyMIC\n             -- ASN.1\
    \ structure not required\n                     innerMsgToken ANY\n           \
    \  SealedMessage ::=\n             -- as emitted by GSS_Wrap and processed by\
    \ GSS_Unwrap\n             -- includes internal, mechanism-defined indicator\n\
    \             -- of whether or not encrypted\n             -- ASN.1 structure\
    \ not required\n                     sealedUserData ANY\n   As one can see, there\
    \ are no mechanism independent prefixes in\n   PerMSGToken or SealedMessage, and\
    \ no explicit mechanism specific\n   information. Since LIPKEY does not add any\
    \ value to GSS_GetMIC and\n   GSS_Wrap other than passing the message to the SPKM-3\
    \ GSS_GetMIC and\n   GSS_Wrap, LIPKEY's PerMsgToken and SealedMessage tokens are\
    \ exactly\n   what SPKM-3's GSS_GetMIC and GSS_Wrap routines produce.\n"
- title: 4.4.  Quality of Protection
  contents:
  - "4.4.  Quality of Protection\n   LIPKEY, being a pass through for GSS_Wrap and\
    \ GSS_GetMIC to SPKM-3,\n   does not interpret or alter the QOPs passed to the\
    \ aforementioned\n   routines or received from their complements, GSS_Unwrap,\
    \ and\n   GSS_VerifyMIC. Thus, LIPKEY supports the same set of QOPs as SPKM-3.\n"
- title: 5.  Security Considerations
  contents:
  - '5.  Security Considerations

    '
- title: 5.1.  Password Management
  contents:
  - "5.1.  Password Management\n   LIPKEY sends the clear text password encrypted\
    \ by 128 bit cast5CBC so\n   the risk in this approach is in how the target manages\
    \ the password\n   after it is done with it. The approach should be safe, provided\
    \ the\n   target clears the memory (primary and secondary, such as disk)\n   buffers\
    \ that contained the password, and any hash of the password\n   immediately after\
    \ it has validated the user's password.\n"
- title: 5.2.  Certification Authorities
  contents:
  - "5.2.  Certification Authorities\n   The initiator must have a list of trusted\
    \ Certification Authorities\n   in order to verify the checksum (rep-ti-integ)\
    \ on the SPKM-3 target's\n   context reply token. If it encounters a certificate\
    \ signed by an\n   unknown and/or untrusted certificate authority, the initiator\
    \ MUST\n   NOT silently accept the certificate. If it does wish to accept the\n\
    \   certificate, it MUST get confirmation from the user running the\n   application\
    \ that is using GSS-API.\n"
- title: 5.3.  HMAC-MD5 and MD5 Weaknesses
  contents:
  - "5.3.  HMAC-MD5 and MD5 Weaknesses\n   While the MD5 hash algorithm has been found\
    \ to have weaknesses\n   [Dobbertin], the weaknesses do not impact the security\
    \ of HMAC-MD5\n   [Dobbertin].\n"
- title: 5.4.  Security of cast5CBC
  contents:
  - "5.4.  Security of cast5CBC\n   The cast5CBC encryption algorithm is relatively\
    \ new compared to\n   established algorithms like triple DES, and RC4. Nonetheless,\
    \ the\n   choice of cast5CBC as the MANDATORY C-ALG for SPKM-3 is advisable.\n\
    \   The cast5CBC algorithm is a 128 bit algorithm that the 256 bit\n   cast6CBC\
    \ [RFC2612] algorithm is based upon. The cast6CBC algorithm\n   was judged by\
    \ the U.S. National Institute of Standards and Technology\n   (NIST) to have no\
    \ known major or minor \"security gaps,\" and to have a\n   \"high security margin\"\
    \ [AES]. NIST did note some vulnerabilities\n   related to smart card implementations,\
    \ but many other algorithms NIST\n   analyzed shared the vulnerabilities, and\
    \ in any case, LIPKEY is by\n   definition not aimed at smart cards.\n"
- title: References
  contents:
  - "References\n   [AES]       Nechvatal, J., Barker, E., Dodson, D., Dworkin, M.,\
    \ Foti,\n               J., Roback, E. (Undated, but no later than 1999). \"Status\n\
    \               Report on the First Round of the Development of the\n        \
    \       Advanced Encryption Standard.\"\n               http://csrc.nist.gov/encryption/aes/round1/r1report.htm\n\
    \   [CCITT]     CCITT (1988). \"Recommendation X.208: Specification of\n     \
    \          Abstract Syntax Notation One (ASN.1).\"\n   [Dobbertin] Dobbertin,\
    \ H. (1996). \"The Status of Md5 After a Recent\n               Attack,\" RSA\
    \ Laboratories' CryptoBytes, Volume 2, Number\n               2.\n           \
    \    ftp://ftp.rsasecurity.com/pub/cryptobytes/crypto2n2.pdf\n   [EFF]       Electronic\
    \ Frontier Foundation, John Gilmore (Editor)\n               (1998). \"Cracking\
    \ Des: Secrets of Encryption Research,\n               Wiretap Politics & Chip\
    \ Design,\" O'Reilly & Associates,\n               ISBN 1565925203.\n   [FIPS]\
    \      National Institute of Standards and Technology (1995).\n              \
    \ \"Secure Hash Standard\" (SHA-1).\n               http://www.itl.nist.gov/fipspubs/fip180-1.htm\n\
    \   [IANA]      Internet Assigned Numbers Authority (1999). \"Network\n      \
    \         Management Parameters.\"  http://www.isi.edu/in-\n               notes/iana/assignments/smi-numbers\n\
    \   [PKCS-3]    RSA Laboratories (1993). \"PKCS #3: Diffie-Hellman Key-\n    \
    \           Agreement Standard, Version 1.4.\"\n               ftp://ftp.rsa.com/pub/pkcs/ascii/pkcs-3.asc\n\
    \   [PKIX]      Housley, R., Ford, W., Polk, W., Solo, D., \"Internet\n      \
    \         X.509 Public Key Infrastructure Certificate and CRL\n              \
    \ Profile\", Work in Progress.\n   [RFC1831]   Srinivasan, R., \"RPC: Remote Procedure\
    \ Call Protocol\n               Specification Version 2\", RFC 1831, August 1995.\n\
    \   [RFC1832]   Srinivasan, R., \"XDR: External Data Representation\n        \
    \       Standard\", RFC 1832, August 1995.\n   [RFC1964]   Linn, J., \"The Kerberos\
    \ Version 5 GSS-API Mechanism\", RFC\n               1964, June 1996.\n   [RFC2203]\
    \   Eisler, M., Chiu, A. and L. Ling, \"RPCSEC_GSS Protocol\n               Specification\"\
    , RFC 2203, September 1997.\n   [RFC2025]   Adams, C., \"The Simple Public-Key\
    \ GSS-API Mechanism\n               (SPKM)\", RFC 2025, October 1996.\n   [RFC2078]\
    \   Linn, J., \"Generic Security Service Application Program\n               Interface,\
    \ Version 2\", RFC 2078, January 1997.\n   [RFC2104]   Krawczyk, H, Bellare, M.\
    \ and R. Canetti, \"HMAC:  Keyed-\n               Hashing for Message Authentication\"\
    , RFC 2104, February\n               1997.\n   [RFC2119]   Bradner, S., \"Key\
    \ words for use in RFCs to Indicate\n               Requirement Levels\", BCP\
    \ 14, RFC 2119, March 1997.\n   [RFC2144]   Adams, C., \"The CAST-128 Encryption\
    \ Algorithm\", RFC 2144,\n               May 1997.\n   [RFC2246]   Dierks, T.\
    \ and C. Allen, \"The TLS Protocol Version 1.0\",\n               RFC 2246, January\
    \ 1999.\n   [RFC2279]   Yergeau, F., \"UTF-8, a transformation format of ISO\n\
    \               10646\", RFC 2279, January 1998.\n   [RFC2437]   Kaliski, B. and\
    \ J. Staddon, \"PKCS #1: RSA Cryptography\n               Specifications Version\
    \ 2.0\", RFC 2437, October 1998.\n   [RFC2459]   Housley, R., Ford, W., Polk,\
    \ W. and D. Solo, \"Internet\n               X.509 Public Key Infrastructure Certificate\
    \ and CRL\n               Profile\", RFC 2459, January 1999.\n   [RFC2612]  Adams,\
    \ C. and J. Gilchrist, \"The CAST-256 Encryption\n               Algorithm\",\
    \ RFC 2612, June 1999.\n   [RSA-IP]   All statements received by the IETF Secretariat\
    \ are places\n               on-line in http://www.ietf.org/ipr.html.  Please\
    \ check\n               this web page to see any IPR information received about\n\
    \               this and other technology.\n   [Sandberg]  Sandberg, R., Goldberg,\
    \ D., Kleiman, S., Walsh, D., Lyon,\n               B. (1985). \"Design and Implementation\
    \ of the Sun Network\n               Filesystem,\"  Proceedings of the 1985 Summer\
    \ USENIX\n               Technical Conference.\n   [Schneier]  Schneier, B. (1996).\
    \ \"Applied Cryptography,\" John Wiley &\n               Sons, Inc., ISBN 0-471-11709-9.\n\
    \   [Young]     Young, E.A. (1997). Collected timing results from the\n      \
    \         SSLeay source code distribution.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The author thanks and acknowledges:\n   *    Jack Kabat for\
    \ his patient explanation of the intricacies of\n        SPKM, excellent suggestions,\
    \ and review comments.\n   *    Denis Pinkas for his review comments.\n   *  \
    \  Carlisle Adams for his review comments.\n   *    John Linn for his review comments.\n\
    \   *    Martin Rex for his review comments.\n   *    This memorandum includes\
    \ ASN.1 definitions for GSS-API tokens\n        from RFC 2078, which was authored\
    \ by John Linn.\n   *    This memorandum includes ASN.1 definitions and other\
    \ text from\n        the SPKM definition in RFC 2025, which was authored by Carlisle\n\
    \        Adams.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Address comments related to this memorandum to:\n   ietf-cat-wg@lists.Stanford.EDU\n\
    \   Mike Eisler\n   Zambeel\n   5565 Wilson Road\n   Colorado Springs, CO 80919\n\
    \   Phone: 1-719-599-9026\n   EMail: mike@eisler.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2000).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
