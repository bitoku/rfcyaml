- title: __initial_text__
  contents:
  - "             PROTOCOL STANDARD FOR A NetBIOS SERVICE\n                     ON\
    \ A TCP/UDP TRANSPORT:\n                      CONCEPTS AND METHODS\n         \
    \                   ABSTRACT\n"
- title: This RFC defines a proposed standard protocol to support NetBIOS
  contents:
  - 'This RFC defines a proposed standard protocol to support NetBIOS

    '
- title: services in a TCP/IP environment.  Both local network and internet
  contents:
  - 'services in a TCP/IP environment.  Both local network and internet

    '
- title: operation are supported.  Various node types are defined to accommodate
  contents:
  - 'operation are supported.  Various node types are defined to accommodate

    '
- title: local and internet topologies and to allow operation with or without the
  contents:
  - 'local and internet topologies and to allow operation with or without the

    '
- title: use of IP broadcast.
  contents:
  - 'use of IP broadcast.

    '
- title: This RFC describes the NetBIOS-over-TCP protocols in a general manner,
  contents:
  - 'This RFC describes the NetBIOS-over-TCP protocols in a general manner,

    '
- title: emphasizing the underlying ideas and techniques.  Detailed
  contents:
  - 'emphasizing the underlying ideas and techniques.  Detailed

    '
- title: specifications are found in a companion RFC, "Protocol Standard For a
  contents:
  - 'specifications are found in a companion RFC, "Protocol Standard For a

    '
- title: 'NetBIOS Service on a TCP/UDP Transport: Detailed Specifications".'
  contents:
  - "NetBIOS Service on a TCP/UDP Transport: Detailed Specifications\".\n        \
    \               SUMMARY OF CONTENTS\n"
- title: 1.  STATUS OF THIS MEMO                                             6
  contents:
  - '1.  STATUS OF THIS MEMO                                             6

    '
- title: 2.  ACKNOWLEDGEMENTS                                                6
  contents:
  - '2.  ACKNOWLEDGEMENTS                                                6

    '
- title: 3.  INTRODUCTION                                                    7
  contents:
  - '3.  INTRODUCTION                                                    7

    '
- title: 4.  DESIGN PRINCIPLES                                               7
  contents:
  - '4.  DESIGN PRINCIPLES                                               7

    '
- title: 5.  OVERVIEW OF NetBIOS                                            10
  contents:
  - '5.  OVERVIEW OF NetBIOS                                            10

    '
- title: 6.  NetBIOS FACILITIES SUPPORTED BY THIS STANDARD                  15
  contents:
  - '6.  NetBIOS FACILITIES SUPPORTED BY THIS STANDARD                  15

    '
- title: 7.  REQUIRED SUPPORTING SERVICE INTERFACES AND DEFINITIONS         15
  contents:
  - '7.  REQUIRED SUPPORTING SERVICE INTERFACES AND DEFINITIONS         15

    '
- title: 8.  RELATED PROTOCOLS AND SERVICES                                 16
  contents:
  - '8.  RELATED PROTOCOLS AND SERVICES                                 16

    '
- title: 9.  NetBIOS SCOPE                                                  16
  contents:
  - '9.  NetBIOS SCOPE                                                  16

    '
- title: 10.  NetBIOS END-NODES                                             16
  contents:
  - '10.  NetBIOS END-NODES                                             16

    '
- title: 11.  NetBIOS SUPPORT SERVERS                                       18
  contents:
  - '11.  NetBIOS SUPPORT SERVERS                                       18

    '
- title: 12.  TOPOLOGIES                                                    20
  contents:
  - '12.  TOPOLOGIES                                                    20

    '
- title: 13.  GENERAL METHODS                                               23
  contents:
  - '13.  GENERAL METHODS                                               23

    '
- title: 14.  REPRESENTATION OF NETBIOS NAMES                               25
  contents:
  - '14.  REPRESENTATION OF NETBIOS NAMES                               25

    '
- title: 15.  NetBIOS NAME SERVICE                                          27
  contents:
  - '15.  NetBIOS NAME SERVICE                                          27

    '
- title: 16.  NetBIOS SESSION SERVICE                                       48
  contents:
  - '16.  NetBIOS SESSION SERVICE                                       48

    '
- title: 17.  NETBIOS DATAGRAM SERVICE                                      55
  contents:
  - '17.  NETBIOS DATAGRAM SERVICE                                      55

    '
- title: 18.  NODE CONFIGURATION PARAMETERS                                 58
  contents:
  - '18.  NODE CONFIGURATION PARAMETERS                                 58

    '
- title: 19.  MINIMAL CONFORMANCE                                           59
  contents:
  - '19.  MINIMAL CONFORMANCE                                           59

    '
- title: REFERENCES                                                         60
  contents:
  - 'REFERENCES                                                         60

    '
- title: APPENDIX A - INTEGRATION WITH INTERNET GROUP MULTICASTING          61
  contents:
  - 'APPENDIX A - INTEGRATION WITH INTERNET GROUP MULTICASTING          61

    '
- title: APPENDIX B - IMPLEMENTATION CONSIDERATIONS                         62
  contents:
  - "APPENDIX B - IMPLEMENTATION CONSIDERATIONS                         62\n     \
    \                   TABLE OF CONTENTS\n"
- title: 1.  STATUS OF THIS MEMO                                             6
  contents:
  - '1.  STATUS OF THIS MEMO                                             6

    '
- title: 2.  ACKNOWLEDGEMENTS                                                6
  contents:
  - '2.  ACKNOWLEDGEMENTS                                                6

    '
- title: 3.  INTRODUCTION                                                    7
  contents:
  - '3.  INTRODUCTION                                                    7

    '
- title: 4.  DESIGN PRINCIPLES                                               8
  contents:
  - "4.  DESIGN PRINCIPLES                                               8\n  4.1\
    \  PRESERVE NetBIOS SERVICES                                    8\n  4.2  USE\
    \ EXISTING STANDARDS                                       8\n  4.3  MINIMIZE\
    \ OPTIONS                                             8\n  4.4  TOLERATE ERRORS\
    \ AND DISRUPTIONS                              8\n  4.5  DO NOT REQUIRE CENTRAL\
    \ MANAGEMENT                            9\n  4.6  ALLOW INTERNET OPERATION   \
    \                                  9\n  4.7  MINIMIZE BROADCAST ACTIVITY     \
    \                             9\n  4.8  PERMIT IMPLEMENTATION ON EXISTING SYSTEMS\
    \                    9\n  4.9  REQUIRE ONLY THE MINIMUM NECESSARY TO OPERATE \
    \               9\n  4.10  MAXIMIZE EFFICIENCY                               \
    \         10\n  4.11  MINIMIZE NEW INVENTIONS                                \
    \    10\n"
- title: 5.  OVERVIEW OF NetBIOS                                            10
  contents:
  - "5.  OVERVIEW OF NetBIOS                                            10\n  5.1\
    \  INTERFACE TO APPLICATION PROGRAMS                           10\n  5.2  NAME\
    \ SERVICE                                                11\n  5.3  SESSION SERVICE\
    \                                             12\n  5.4  DATAGRAM SERVICE    \
    \                                        13\n  5.5  MISCELLANEOUS FUNCTIONS  \
    \                                   14\n  5.6  NON-STANDARD EXTENSIONS       \
    \                              15\n"
- title: 6.  NetBIOS FACILITIES SUPPORTED BY THIS STANDARD                  15
  contents:
  - '6.  NetBIOS FACILITIES SUPPORTED BY THIS STANDARD                  15

    '
- title: 7.  REQUIRED SUPPORTING SERVICE INTERFACES AND DEFINITIONS         15
  contents:
  - '7.  REQUIRED SUPPORTING SERVICE INTERFACES AND DEFINITIONS         15

    '
- title: 8.  RELATED PROTOCOLS AND SERVICES                                 16
  contents:
  - '8.  RELATED PROTOCOLS AND SERVICES                                 16

    '
- title: 9.  NetBIOS SCOPE                                                  16
  contents:
  - '9.  NetBIOS SCOPE                                                  16

    '
- title: 10.  NetBIOS END-NODES                                             16
  contents:
  - "10.  NetBIOS END-NODES                                             16\n  10.1\
    \  BROADCAST (B) NODES                                        16\n  10.2  POINT-TO-POINT\
    \ (P) NODES                                   16\n  10.3  MIXED MODE (M) NODES\
    \                                       16\n"
- title: 11.  NetBIOS SUPPORT SERVERS                                       18
  contents:
  - "11.  NetBIOS SUPPORT SERVERS                                       18\n  11.1\
    \  NetBIOS NAME SERVER (NBNS) NODES                           18\n     11.1.1\
    \  RELATIONSHIP OF THE NBNS TO THE DOMAIN NAME SYSTEM    19\n  11.2  NetBIOS DATAGRAM\
    \ DISTRIBUTION SERVER (NBDD) NODES          19\n  11.3  RELATIONSHIP OF NBNS AND\
    \ NBDD NODES                        20\n  11.4  RELATIONSHIP OF NetBIOS SUPPORT\
    \ SERVERS AND B NODES        20\n"
- title: 12.  TOPOLOGIES                                                    20
  contents:
  - "12.  TOPOLOGIES                                                    20\n  12.1\
    \  LOCAL                                                      20\n     12.1.1\
    \  B NODES ONLY                                          21\n     12.1.2  P NODES\
    \ ONLY                                          21\n     12.1.3  MIXED B AND P\
    \ NODES                                   21\n  12.2  INTERNET               \
    \                                    22\n     12.2.1  P NODES ONLY           \
    \                               22\n     12.2.2  MIXED M AND P NODES         \
    \                          23\n"
- title: 13.  GENERAL METHODS                                               23
  contents:
  - "13.  GENERAL METHODS                                               23\n  13.1\
    \  REQUEST/RESPONSE INTERACTION STYLE                         23\n     13.1.1\
    \  RETRANSMISSION OF REQUESTS                            24\n     13.1.2  REQUESTS\
    \ WITHOUT RESPONSES: DEMANDS                   24\n  13.2  TRANSACTIONS      \
    \                                         25\n     13.2.1  TRANSACTION ID    \
    \                                    25\n  13.3  TCP AND UDP FOUNDATIONS     \
    \                               25\n"
- title: 14.  REPRESENTATION OF NETBIOS NAMES                               25
  contents:
  - "14.  REPRESENTATION OF NETBIOS NAMES                               25\n  14.1\
    \  FIRST LEVEL ENCODING                                       26\n  14.2  SECOND\
    \ LEVEL ENCODING                                      27\n"
- title: 15.  NetBIOS NAME SERVICE                                          27
  contents:
  - "15.  NetBIOS NAME SERVICE                                          27\n  15.1\
    \  OVERVIEW OF NetBIOS NAME SERVICE                           27\n     15.1.1\
    \  NAME REGISTRATION (CLAIM)                             27\n     15.1.2  NAME\
    \ QUERY (DISCOVERY)                                28\n     15.1.3  NAME RELEASE\
    \                                          28\n       15.1.3.1  EXPLICIT RELEASE\
    \                                  28\n       15.1.3.2  NAME LIFETIME AND REFRESH\
    \                         29\n       15.1.3.3  NAME CHALLENGE                \
    \                    29\n       15.1.3.4  GROUP NAME FADE-OUT                \
    \               29\n     15.1.3.5  NAME CONFLICT                             \
    \          30\n     15.1.4  ADAPTER STATUS                                   \
    \     31\n     15.1.5  END-NODE NBNS INTERACTION                             31\n\
    \       15.1.5.1  UDP, TCP, AND TRUNCATION                          31\n     \
    \  15.1.5.2  NBNS WACK                                         32\n       15.1.5.3\
    \  NBNS REDIRECTION                                  32\n     15.1.6  SECURED\
    \ VERSUS NON-SECURED NBNS                       32\n     15.1.7  CONSISTENCY OF\
    \ THE NBNS DATA BASE                     32\n     15.1.8  NAME CACHING       \
    \                                   34\n  15.2  NAME REGISTRATION TRANSACTIONS\
    \                             34\n     15.2.1  NAME REGISTRATION BY B NODES  \
    \                        34\n     15.2.2  NAME REGISTRATION BY P NODES       \
    \                   35\n       15.2.2.1  NEW NAME, OR NEW GROUP MEMBER       \
    \              35\n       15.2.2.2  EXISTING NAME AND OWNER IS STILL ACTIVE  \
    \         36\n       15.2.2.3  EXISTING NAME AND OWNER IS INACTIVE           \
    \    37\n     15.2.3  NAME REGISTRATION BY M NODES                          38\n\
    \  15.3  NAME QUERY TRANSACTIONS                                    39\n     15.3.1\
    \  QUERY BY B NODES                                      39\n     15.3.2  QUERY\
    \ BY P NODES                                      40\n     15.3.3  QUERY BY M\
    \ NODES                                      43\n     15.3.4  ACQUIRE GROUP MEMBERSHIP\
    \ LIST                         43\n  15.4  NAME RELEASE TRANSACTIONS         \
    \                         44\n     15.4.1  RELEASE BY B NODES                \
    \                    44\n     15.4.2  RELEASE BY P NODES                     \
    \               44\n     15.4.3  RELEASE BY M NODES                          \
    \          44\n  15.5  NAME MAINTENANCE TRANSACTIONS                         \
    \     45\n     15.5.1  NAME REFRESH                                          45\n\
    \     15.5.2  NAME CHALLENGE                                        46\n     15.5.3\
    \  CLEAR NAME CONFLICT                                   47\n  15.6  ADAPTER STATUS\
    \ TRANSACTIONS                                47\n"
- title: 16.  NetBIOS SESSION SERVICE                                       48
  contents:
  - "16.  NetBIOS SESSION SERVICE                                       48\n  16.1\
    \  OVERVIEW OF NetBIOS SESSION SERVICE                        49\n     16.1.1\
    \  SESSION ESTABLISHMENT PHASE OVERVIEW                  49\n       16.1.1.1 \
    \ RETRYING AFTER BEING RETARGETTED                  50\n       16.1.1.2  SESSION\
    \ ESTABLISHMENT TO A GROUP NAME             51\n     16.1.2  STEADY STATE PHASE\
    \ OVERVIEW                           51\n     16.1.3  SESSION TERMINATION PHASE\
    \ OVERVIEW                    51\n  16.2  SESSION ESTABLISHMENT PHASE        \
    \                        52\n  16.3  SESSION DATA TRANSFER PHASE             \
    \                   54\n     16.3.1  DATA ENCAPSULATION                      \
    \              54\n     16.3.2  SESSION KEEP-ALIVES                          \
    \         54\n"
- title: 17.  NETBIOS DATAGRAM SERVICE                                      55
  contents:
  - "17.  NETBIOS DATAGRAM SERVICE                                      55\n  17.1\
    \  OVERVIEW OF NetBIOS DATAGRAM SERVICE                       55\n     17.1.1\
    \  UNICAST, MULTICAST, AND BROADCAST                     55\n     17.1.2  FRAGMENTATION\
    \ OF NetBIOS DATAGRAMS                    55\n  17.2  NetBIOS DATAGRAMS BY B NODES\
    \                               57\n  17.3  NetBIOS DATAGRAMS BY P AND M NODES\
    \                         58\n"
- title: 18.  NODE CONFIGURATION PARAMETERS                                 58
  contents:
  - '18.  NODE CONFIGURATION PARAMETERS                                 58

    '
- title: 19.  MINIMAL CONFORMANCE                                           59
  contents:
  - '19.  MINIMAL CONFORMANCE                                           59

    '
- title: REFERENCES                                                         60
  contents:
  - 'REFERENCES                                                         60

    '
- title: APPENDIX A                                                         61
  contents:
  - 'APPENDIX A                                                         61

    '
- title: INTEGRATION WITH INTERNET GROUP MULTICASTING                       61
  contents:
  - "INTEGRATION WITH INTERNET GROUP MULTICASTING                       61\n  A-1.\
    \  ADDITIONAL PROTOCOL REQUIRED IN B AND M NODES              61\n  A-2.  CONSTRAINTS\
    \                                                61\n"
- title: APPENDIX B                                                         62
  contents:
  - 'APPENDIX B                                                         62

    '
- title: IMPLEMENTATION CONSIDERATIONS                                      62
  contents:
  - "IMPLEMENTATION CONSIDERATIONS                                      62\n  B-1.\
    \  IMPLEMENTATION MODELS                                      62\n     B-1.1 \
    \ MODEL INDEPENDENT CONSIDERATIONS                       63\n     B-1.2  SERVICE\
    \ OPERATION FOR EACH MODEL                       63\n  B-2.  CASUAL AND RESTRICTED\
    \ NetBIOS APPLICATIONS                 64\n  B-3.  TCP VERSUS SESSION KEEP-ALIVES\
    \                             66\n  B-4.  RETARGET ALGORITHMS                \
    \                        67\n  B-5.  NBDD SERVICE                            \
    \                   68\n  B-6.  APPLICATION CONSIDERATIONS                   \
    \              68\n     B-6.1  USE OF NetBIOS DATAGRAMS                      \
    \         68\n             PROTOCOL STANDARD FOR A NetBIOS SERVICE\n         \
    \            ON A TCP/UDP TRANSPORT:\n                      CONCEPTS AND METHODS\n"
- title: 1.  STATUS OF THIS MEMO
  contents:
  - "1.  STATUS OF THIS MEMO\n   This RFC specifies a proposed standard for the Internet\n\
    \   community.  Since this topic is new to the Internet community,\n   discussions\
    \ and suggestions are specifically requested.\n   Please send written comments\
    \ to:\n           Karl Auerbach\n           Epilogue Technology Corporation\n\
    \           P.O. Box 5432\n           Redwood City, CA   94063\n   Please send\
    \ online comments to:\n           Avnish Aggarwal\n                   Internet:\
    \ mtxinu!excelan!avnish@ucbvax.berkeley.edu\n                   Usenet:   ucbvax!mtxinu!excelan!avnish\n\
    \   Distribution of this document is unlimited.\n"
- title: 2.  ACKNOWLEDGEMENTS
  contents:
  - "2.  ACKNOWLEDGEMENTS\n   This RFC has been developed under the auspices of the\
    \ Internet\n   Activities Board, especially the End-to-End Services Task Force.\n\
    \   The following individuals have contributed to the development of\n   this\
    \ RFC:\n   Avnish Aggarwal       Arvind Agrawal        Lorenzo Aguilar\n   Geoffrey\
    \ Arnold       Karl Auerbach         K. Ramesh Babu\n   Keith Ball           \
    \ Amatzia Ben-Artzi     Vint Cerf\n   Richard Cherry        David Crocker    \
    \     Steve Deering\n   Greg Ennis            Steve Holmgren        Jay Israel\n\
    \   David Kaufman         Lee LaBarre           James Lau\n   Dan Lynch      \
    \       Gaylord Miyata        David Stevens\n   Steve Thomas          Ishan Wu\n\
    \   The system proposed by this RFC does not reflect any existing\n   Netbios-over-TCP\
    \ implementation.  However, the design\n   incorporates considerable knowledge\
    \ obtained from prior\n   implementations.  Special thanks goes to the following\n\
    \   organizations which have provided this invaluable information:\n   CMC/Syros\
    \      Excelan        Sytek          Ungermann-Bass\n"
- title: 3.  INTRODUCTION
  contents:
  - "3.  INTRODUCTION\n   This RFC describes the ideas and general methods used to\
    \ provide\n   NetBIOS on a TCP and UDP foundation.  A companion RFC, \"Protocol\n\
    \   Standard For a NetBIOS Service on a TCP/UDP Transport: Detailed\n   Specifications\"\
    [1] contains detailed descriptions of packet\n   formats, protocols, and defined\
    \ constants and variables.\n   The NetBIOS service has become the dominant mechanism\
    \ for\n   personal computer networking.  NetBIOS provides a vendor\n   independent\
    \ interface for the IBM Personal Computer (PC) and\n   compatible systems.\n \
    \  NetBIOS defines a software interface not a protocol.  There is no\n   \"official\"\
    \ NetBIOS service standard.  In practice, however, the\n   IBM PC-Network version\
    \ is used as a reference.  That version is\n   described in the IBM document 6322916,\
    \ \"Technical Reference PC\n   Network\"[2].\n   Protocols supporting NetBIOS\
    \ services have been constructed on\n   diverse protocol and hardware foundations.\
    \  Even when the same\n   foundation is used, different implementations may not\
    \ be able to\n   interoperate unless they use a common protocol.  To allow NetBIOS\n\
    \   interoperation in the Internet, this RFC defines a standard\n   protocol to\
    \ support NetBIOS services using TCP and UDP.\n   NetBIOS has generally been confined\
    \ to personal computers to\n   date.  However, since larger computers are often\
    \ well suited to\n   run certain NetBIOS applications, such as file servers, this\n\
    \   specification has been designed to allow an implementation to be\n   built\
    \ on virtually any type of system where the TCP/IP protocol\n   suite is available.\n\
    \   This standard defines a set of protocols to support NetBIOS\n   services.\n\
    \   These protocols are more than a simple communications service\n   involving\
    \ two entities.  Rather, this note describes a\n   distributed system in which\
    \ many entities play a part even if\n   they are not involved as an end-point\
    \ of a particular NetBIOS\n   connection.\n   This standard neither constrains\
    \ nor determines how those\n   services are presented to application programs.\n\
    \   Nevertheless, it is expected that on computers operating under\n   the PC-DOS\
    \ and MS-DOS operating systems that the existing NetBIOS\n   interface will be\
    \ preserved by implementors.\n   NOTE: Various symbolic values are used in this\
    \ document.  For\n         their definitions, refer to the Detailed Specifications[1].\n"
- title: 4.  DESIGN PRINCIPLES
  contents:
  - "4.  DESIGN PRINCIPLES\n   In order to develop the specification the following\
    \ design principles\n   were adopted to guide the effort.  Most are typical to\
    \ any protocol\n   standardization effort; however, some have been assigned priorities\n\
    \   that may be considered unusual.\n"
- title: 4.1.  PRESERVE NetBIOS SERVICES
  contents:
  - "4.1.  PRESERVE NetBIOS SERVICES\n   In the absence of an \"official\" standard\
    \ for NetBIOS services, the\n   version found in the IBM PC Network Technical\
    \ Reference[2] is used.\n   NetBIOS is the foundation of a large body of existing\
    \ applications.\n   It is desirable to operate these applications on TCP networks\
    \ and to\n   extend them beyond personal computers into larger hosts.  To support\n\
    \   these applications, NetBIOS on TCP must closely conform to the\n   services\
    \ offered by existing NetBIOS systems.\n   IBM PC-Network NetBIOS contains some\
    \ implementation specific\n   characteristics.  This standard does not attempt\
    \ to completely\n   preserve these.  It is certain that some existing software\
    \ requires\n   these characteristics and will fail to operate correctly on a NetBIOS\n\
    \   service based on this RFC.\n"
- title: 4.2.  USE EXISTING STANDARDS
  contents:
  - "4.2.  USE EXISTING STANDARDS\n   Protocol development, especially with standardization,\
    \ is a demanding\n   process.  The development of new protocols must be minimized.\n\
    \   It is considered essential that an existing standard which provides\n   the\
    \ necessary functionality with reasonable performance always be\n   chosen in\
    \ preference to developing a new protocol.\n   When a standard protocol is used,\
    \ it must be unmodified.\n"
- title: 4.3.  MINIMIZE OPTIONS
  contents:
  - "4.3.  MINIMIZE OPTIONS\n   The standard for NetBIOS on TCP should contain few,\
    \ if any, options.\n   Where options are included, the options should be designed\
    \ so that\n   devices with different option selections should interoperate.\n"
- title: 4.4.  TOLERATE ERRORS AND DISRUPTIONS
  contents:
  - "4.4.  TOLERATE ERRORS AND DISRUPTIONS\n   NetBIOS networks typically operate\
    \ in an uncontrolled environment.\n   Computers come on-line at arbitrary times.\
    \  Computers usually go\n   off-line without any notice to their peers.  The software\
    \ is often\n   operated by users who are unfamiliar with networks and who may\n\
    \   randomly perturb configuration settings.\n   Despite this chaos, NetBIOS networks\
    \ work.  NetBIOS on TCP must also\n   be able to operate well in this environment.\n\
    \   Robust operation does not necessarily mean that the network is proof\n   against\
    \ all disruptions.  A typical NetBIOS network may be disrupted\n   by certain\
    \ types of behavior, whether inadvertent or malicious.\n"
- title: 4.5.  DO NOT REQUIRE CENTRAL MANAGEMENT
  contents:
  - "4.5.  DO NOT REQUIRE CENTRAL MANAGEMENT\n   NetBIOS on TCP should be able to\
    \ operate, if desired, without\n   centralized management beyond that typically\
    \ required by a TCP based\n   network.\n"
- title: 4.6.  ALLOW INTERNET OPERATION
  contents:
  - "4.6.  ALLOW INTERNET OPERATION\n   The proposed standard recognizes the need\
    \ for NetBIOS operation\n   across a set of networks interconnected by network\
    \ (IP) level relays\n   (gateways.)\n   However, the standard assumes that this\
    \ form of operation will be\n   less frequent than on the local MAC bridged-LAN.\n"
- title: 4.7.  MINIMIZE BROADCAST ACTIVITY
  contents:
  - "4.7.  MINIMIZE BROADCAST ACTIVITY\n   The standard pre-supposes that the only\
    \ broadcast services are those\n   supported by UDP.  Multicast capabilities are\
    \ not assumed to be\n   available in any form.\n   Despite the availability of\
    \ broadcast capabilities, the standard\n   recognizes that some administrations\
    \ may wish to avoid heavy\n   broadcast activity.  For example, an administration\
    \ may wish to avoid\n   isolated non-participating hosts from the burden of receiving\
    \ and\n   discarding NetBIOS broadcasts.\n"
- title: 4.8.  PERMIT IMPLEMENTATION ON EXISTING SYSTEMS
  contents:
  - "4.8.  PERMIT IMPLEMENTATION ON EXISTING SYSTEMS\n   The NetBIOS on TCP protocol\
    \ should be implementable on common\n   operating systems, such as Unix(tm) and\
    \ VAX/VMS(tm), without massive\n   effort.\n   The NetBIOS protocols should not\
    \ require services typically\n   unavailable on presently existing TCP/UDP/IP\
    \ implementations.\n"
- title: 4.9.  REQUIRE ONLY THE MINIMUM NECESSARY TO OPERATE
  contents:
  - "4.9.  REQUIRE ONLY THE MINIMUM NECESSARY TO OPERATE\n   The protocol definition\
    \ should specify only the minimal set of\n   protocols required for interoperation.\
    \  However, additional protocol\n   elements may be defined to enhance efficiency.\
    \  These latter elements\n   may be generated at the option of the sender, although\
    \ they must be\n   accepted by all receivers.\n"
- title: 4.10.  MAXIMIZE EFFICIENCY
  contents:
  - "4.10.  MAXIMIZE EFFICIENCY\n   To be useful, a protocol must conduct its business\
    \ quickly.\n"
- title: 4.11.  MINIMIZE NEW INVENTIONS
  contents:
  - "4.11.  MINIMIZE NEW INVENTIONS\n   When an existing protocol is not quite able\
    \ to support a necessary\n   function, but with a small amount of change, it could,\
    \ that protocol\n   should be used.  This is felt to be easier to achieve than\n\
    \   development of new protocols; further, it is likely to have more\n   general\
    \ utility for the Internet.\n"
- title: 5.  OVERVIEW OF NetBIOS
  contents:
  - "5.  OVERVIEW OF NetBIOS\n   This section describes the NetBIOS services.  It\
    \ is for background\n   information only.  The reader may chose to skip to the\
    \ next section.\n   NetBIOS was designed for use by groups of PCs, sharing a broadcast\n\
    \   medium.  Both connection (Session) and connectionless (Datagram)\n   services\
    \ are provided, and broadcast and multicast are supported.\n   Participants are\
    \ identified by name.  Assignment of names is\n   distributed and highly dynamic.\n\
    \   NetBIOS applications employ NetBIOS mechanisms to locate resources,\n   establish\
    \ connections, send and receive data with an application\n   peer, and terminate\
    \ connections.  For purposes of discussion, these\n   mechanisms will collectively\
    \ be called the NetBIOS Service.\n   This service can be implemented in many different\
    \ ways.  One of the\n   first implementations was for personal computers running\
    \ the PC-DOS\n   and MS-DOS operating systems.  It is possible to implement NetBIOS\n\
    \   within other operating systems, or as processes which are,\n   themselves,\
    \ simply application programs as far as the host operating\n   system is concerned.\n\
    \   The NetBIOS specification, published by IBM as \"Technical Reference\n   PC\
    \ Network\"[2] defines the interface and services available to the\n   NetBIOS\
    \ user.  The protocols outlined by that document pertain only\n   to the IBM PC\
    \ Network and are not generally applicable to other\n   networks.\n"
- title: 5.1.  INTERFACE TO APPLICATION PROGRAMS
  contents:
  - "5.1.  INTERFACE TO APPLICATION PROGRAMS\n   NetBIOS on personal computers includes\
    \ both a set of services and an\n   exact program interface to those services.\
    \  NetBIOS on other computer\n   systems may present the NetBIOS services to programs\
    \ using other\n   interfaces.  Except on personal computers, no clear standard\
    \ for a\n   NetBIOS software interface has emerged.\n"
- title: 5.2.  NAME SERVICE
  contents:
  - "5.2.  NAME SERVICE\n   NetBIOS resources are referenced by name.  Lower-level\
    \ address\n   information is not available to NetBIOS applications.  An\n   application,\
    \ representing a resource, registers one or more names\n   that it wishes to use.\n\
    \   The name space is flat and uses sixteen alphanumeric characters.\n   Names\
    \ may not start with an asterisk (*).\n   Registration is a bid for use of a name.\
    \  The bid may be for\n   exclusive (unique) or shared (group) ownership.  Each\
    \ application\n   contends with the other applications in real time.  Implicit\n\
    \   permission is granted to a station when it receives no objections.\n   That\
    \ is, a bid is made and the application waits for a period of\n   time.  If no\
    \ objections are received, the station assumes that it has\n   permission.\n \
    \  A unique name should be held by only one station at a time.  However,\n   duplicates\
    \ (\"name conflicts\") may arise due to errors.\n   All instances of a group name\
    \ are equivalent.\n   An application referencing a name generally does not know\
    \ (or care)\n   whether the name is registered as a unique or a group name.\n\
    \   An explicit name deletion function is specified, so that applications\n  \
    \ may remove a name.  Implicit name deletion occurs when a station\n   ceases\
    \ operation.  In the case of personal computers, implicit name\n   deletion is\
    \ a frequent occurrence.\n   The Name Service primitives are:\n      1)   Add\
    \ Name\n           The requesting application wants exclusive use of the name.\n\
    \      2)   Add Group Name\n           The requesting application is willing to\
    \ share use of the\n           name with other applications.\n      3)   Delete\
    \ Name\n           The application no longer requires use of the name.  It is\n\
    \           important to note that typical use of NetBIOS is among\n         \
    \  independently-operated personal computers.  A common way to\n           stop\
    \ using a PC is to turn it off; in this case, the\n           graceful give-back\
    \ mechanism, provided by the Delete Name\n           function, is not used.  Because\
    \ this occurs frequently, the\n           network service must support this behavior.\n"
- title: 5.3.  SESSION SERVICE
  contents:
  - "5.3.  SESSION SERVICE\n   A session is a reliable message exchange, conducted\
    \ between a pair of\n   NetBIOS applications.  Sessions are full-duplex, sequenced,\
    \ and\n   reliable.  Data is organized into messages.  Each message may range\n\
    \   in size from 0 to 131,071 bytes.  No expedited or urgent data\n   capabilities\
    \ are present.\n   Multiple sessions may exist between any pair of calling and\
    \ called\n   names.\n   The parties to a connection have access to the calling\
    \ and called\n   names.\n   The NetBIOS specification does not define how a connection\
    \ request to\n   a shared (group) name resolves into a session.  The usual assumption\n\
    \   is that a session may be established with any one owner of the called\n  \
    \ group name.\n   An important service provided to NetBIOS applications is the\n\
    \   detection of sessions failure.  The loss of a session is reported to\n   an\
    \ application via all of the outstanding service requests for that\n   session.\
    \  For example, if the application has only a NetBIOS receive\n   primitive pending\
    \ and the session terminates, the pending receive\n   will abort with a termination\
    \ indication.\n   Session Service primitives are:\n      1)   Call\n         \
    \  Initiate a session with a process that is listening under\n           the specified\
    \ name.  The calling entity must indicate both a\n           calling name (properly\
    \ registered to the caller) and a\n           called name.\n      2)   Listen\n\
    \           Accept a session from a caller.  The listen primitive may be\n   \
    \        constrained to accept an incoming call from a named caller.\n       \
    \    Alternatively, a call may be accepted from any caller.\n      3)   Hang Up\n\
    \           Gracefully terminate a session.  All pending data is\n           transferred\
    \ before the session is terminated.\n      4)   Send\n           Transmit one\
    \ message.  A time-out can occur.  A time-out of\n           any session send\
    \ forces the non-graceful termination of the\n           session.\n          \
    \ A \"chain send\" primitive is required by the PC NetBIOS\n           software\
    \ interface to allow a single message to be gathered\n           from pieces in\
    \ various buffers.  Chain Send is an interface\n           detail and does not\
    \ effect the protocol.\n      5)   Receive\n           Receive data.  A time-out\
    \ can occur.  A time-out on a\n           session receive only terminates the\
    \ receive, not the\n           session, although the data is lost.\n         \
    \  The receive primitive may be implemented with variants, such\n           as\
    \ \"Receive Any\", which is required by the PC NetBIOS\n           software interface.\
    \  Receive Any is an interface detail and\n           does not effect the protocol.\n\
    \      6)   Session Status\n           Obtain information about all of the requestor's\
    \ sessions,\n           under the specified name.  No network activity is involved.\n"
- title: 5.4.  DATAGRAM SERVICE
  contents:
  - "5.4.  DATAGRAM SERVICE\n   The Datagram service is an unreliable, non-sequenced,\
    \ connectionless\n   service.  Datagrams are sent under cover of a name properly\n\
    \   registered to the sender.\n   Datagrams may be sent to a specific name or\
    \ may be explicitly\n   broadcast.\n   Datagrams sent to an exclusive name are\
    \ received, if at all, by the\n   holder of that name.  Datagrams sent to a group\
    \ name are multicast to\n   all holders of that name.  The sending application\
    \ program cannot\n   distinguish between group and unique names and thus must\
    \ act as if\n   all non-broadcast datagrams are multicast.\n   As with the Session\
    \ Service, the receiver of the datagram is told the\n   sending and receiving\
    \ names.\n   Datagram Service primitives are:\n      1)   Send Datagram\n    \
    \       Send an unreliable datagram to an application that is\n           associated\
    \ with the specified name.  The name may be unique\n           or group; the sender\
    \ is not aware of the difference.  If the\n           name belongs to a group,\
    \ then each member is to receive the\n           datagram.\n      2)   Send Broadcast\
    \ Datagram\n           Send an unreliable datagram to any application with a\n\
    \           Receive Broadcast Datagram posted.\n      3)   Receive Datagram\n\
    \           Receive a datagram sent by a specified originating name to\n     \
    \      the specified name.  If the originating name is an asterisk,\n        \
    \   then the datagram may have been originated under any name.\n           Note:\
    \ An arriving datagram will be delivered to all pending\n           Receiving\
    \ Datagrams that have source and destination\n           specifications matching\
    \ those of the datagram.  In other\n           words, if a program (or group of\
    \ programs) issue a series of\n           identical Receive Datagrams, one datagram\
    \ will cause the\n           entire series to complete.\n      4)   Receive Broadcast\
    \ Datagram\n           Receive a datagram sent as a broadcast.\n           If\
    \ there are multiple pending Receive Broadcast Datagram\n           operations\
    \ pending, all will be satisfied by the same\n           received datagram.\n"
- title: 5.5.  MISCELLANEOUS FUNCTIONS
  contents:
  - "5.5.  MISCELLANEOUS FUNCTIONS\n   The following functions are present to control\
    \ the operation of the\n   hardware interface to the network.  These functions\
    \ are generally\n   implementation dependent.\n      1)   Reset\n           Initialize\
    \ the local network adapter.\n      2)   Cancel\n           Abort a pending NetBIOS\
    \ request.  The successful cancel of a\n           Send (or Chain Send) operation\
    \ will terminate the associated\n           session.\n      3)   Adapter Status\n\
    \           Obtain information about the local network adapter or of a\n     \
    \      remote adapter.\n      4)   Unlink\n           For use with Remote Program\
    \ Load (RPL).  Unlink redirects\n           the PC boot disk device back to the\
    \ local disk.  See the\n           NetBIOS specification for further details concerning\
    \ RPL and\n           the Unlink operation (see page 2-35 in [2]).\n      5) \
    \  Remote Program Load\n           Remote Program Load (RPL) is not a NetBIOS\
    \ function.  It is\n           a NetBIOS application defined by IBM in their NetBIOS\n\
    \           specification (see pages 2-80 through 2-82 in [2]).\n"
- title: 5.6.  NON-STANDARD EXTENSIONS
  contents:
  - "5.6.  NON-STANDARD EXTENSIONS\n   The IBM Token Ring implementation of NetBIOS\
    \ has added at least one\n   new user capability:\n      1)    Find Name\n   \
    \        This function determines whether a given name has been\n           registered\
    \ on the network.\n"
- title: 6.  NetBIOS FACILITIES SUPPORTED BY THIS STANDARD
  contents:
  - "6.  NetBIOS FACILITIES SUPPORTED BY THIS STANDARD\n   The protocol specified\
    \ by this standard permits an implementer to\n   provide all of the NetBIOS services\
    \ as described in the IBM\n   \"Technical Reference PC Network\"[2].\n   The following\
    \ NetBIOS facilities are outside the scope of this\n   specification.  These are\
    \ local implementation matters and do not\n   impact interoperability:\n     -\
    \  RESET\n     -  SESSION STATUS\n     -  UNLINK\n     -  RPL (Remote Program\
    \ Load)\n"
- title: 7.  REQUIRED SUPPORTING SERVICE INTERFACES AND DEFINITIONS
  contents:
  - "7.  REQUIRED SUPPORTING SERVICE INTERFACES AND DEFINITIONS\n   The protocols\
    \ described in this RFC require service interfaces to the\n   following:\n   \
    \  -  TCP[3,4]\n     -  UDP[5]\n   Byte ordering, addressing conventions (including\
    \ addresses to be\n   used for broadcasts and multicasts) are defined by the most\n\
    \   recent version of:\n     -  Assigned Numbers[6]\n   Additional definitions\
    \ and constraints are in:\n     -  IP[7]\n     -  Internet Subnets[8,9,10]\n"
- title: 8.  RELATED PROTOCOLS AND SERVICES
  contents:
  - "8.  RELATED PROTOCOLS AND SERVICES\n   The design of the protocols described\
    \ in this RFC allow for the\n   future incorporation of the following protocols\
    \ and services.\n   However, before this may occur, certain extensions may be\
    \ required to\n   the protocols defined in this RFC or to those listed below.\n\
    \     -  Domain Name Service[11,12,13,14]\n     -  Internet Group Multicast[15,16]\n"
- title: 9.  NetBIOS SCOPE
  contents:
  - "9.  NetBIOS SCOPE\n   A \"NetBIOS Scope\" is the population of computers across\
    \ which a\n   registered NetBIOS name is known.  NetBIOS broadcast and multicast\n\
    \   datagram operations must reach the entire extent of the NetBIOS\n   scope.\n\
    \   An internet may support multiple, non-intersecting NetBIOS Scopes.\n   Each\
    \ NetBIOS scope has a \"scope identifier\".  This identifier is a\n   character\
    \ string meeting the requirements of the domain name system\n   for domain names.\n\
    \   NOTE: Each implementation of NetBIOS-over-TCP must provide\n         mechanisms\
    \ to manage the scope identifier(s) to be used.\n   Control of scope identifiers\
    \ implies a requirement for additional\n   NetBIOS interface capabilities.  These\
    \ may be provided through\n   extensions of the user service interface or other\
    \ means (such as node\n   configuration parameters.)  The nature of these extensions\
    \ is not\n   part of this specification.\n"
- title: 10.  NetBIOS END-NODES
  contents:
  - "10.  NetBIOS END-NODES\n   End-nodes support NetBIOS service interfaces and contain\n\
    \   applications.\n   Three types of end-nodes are part of this standard:\n  \
    \   -  Broadcast (\"B\") nodes\n     -  Point-to-point (\"P\") nodes\n     - \
    \ Mixed mode (\"M\") nodes\n   An IP address may be associated with only one instance\
    \ of one of the\n   above types.\n   Without having preloaded name-to-address\
    \ tables, NetBIOS participants\n   are faced with the task of dynamically resolving\
    \ references to one\n   another.  This can be accomplished with broadcast or mediated\
    \ point-\n   to-point communications.\n   B nodes use local network broadcasting\
    \ to effect a rendezvous with\n   one or more recipients.  P and M nodes use the\
    \ NetBIOS Name Server\n   (NBNS) and the NetBIOS Datagram Distribution Server\
    \ (NBDD) for this\n   same purpose.\n   End-nodes may be combined in various topologies.\
    \  No matter how\n   combined, the operation of the B, P, and M nodes is not altered.\n\
    \   NOTE: It is recommended that the administration of a NetBIOS\n         scope\
    \ avoid using both M and B nodes within the same scope.\n         A NetBIOS scope\
    \ should contain only B nodes or only P and M\n         nodes.\n"
- title: 10.1.  BROADCAST (B) NODES
  contents:
  - "10.1.  BROADCAST (B) NODES\n   Broadcast (or \"B\") nodes communicate using a\
    \ mix of UDP datagrams\n   (both broadcast and directed) and TCP connections.\
    \  B nodes may\n   freely interoperate with one another within a broadcast area.\
    \  A\n   broadcast area is a single MAC-bridged \"B-LAN\".  (See Appendix A for\n\
    \   a discussion of using Internet Group Multicasting as a means to\n   extend\
    \ a broadcast area beyond a single B-LAN.)\n"
- title: 10.2.  POINT-TO-POINT (P) NODES
  contents:
  - "10.2.  POINT-TO-POINT (P) NODES\n   Point-to-point (or \"P\") nodes communicate\
    \ using only directed UDP\n   datagrams and TCP sessions.  P nodes neither generate\
    \ nor listen for\n   broadcast UDP packets.  P nodes do, however, offer NetBIOS\
    \ level\n   broadcast and multicast services using capabilities provided by the\n\
    \   NBNS and NBDD.\n   P nodes rely on NetBIOS name and datagram distribution\
    \ servers.\n   These servers may be local or remote; P nodes operate the same\
    \ in\n   either case.\n"
- title: 10.3.  MIXED MODE (M) NODES
  contents:
  - "10.3.  MIXED MODE (M) NODES\n   Mixed mode nodes (or \"M\") nodes are P nodes\
    \ which have been given\n   certain B node characteristics.  M nodes use both\
    \ broadcast and\n   unicast.  Broadcast is used to improve response time using\
    \ the\n   assumption that most resources reside on the local broadcast medium\n\
    \   rather than somewhere in an internet.\n   M nodes rely upon NBNS and NBDD\
    \ servers.  However, M nodes may\n   continue limited operation should these servers\
    \ be temporarily\n   unavailable.\n"
- title: 11.  NetBIOS SUPPORT SERVERS
  contents:
  - "11.  NetBIOS SUPPORT SERVERS\n   Two types of support servers are part of this\
    \ standard:\n     -  NetBIOS name server (\"NBNS\") nodes\n     -  Netbios datagram\
    \ distribution (\"NBDD\") nodes\n   NBNS and NBDD nodes are invisible to NetBIOS\
    \ applications and are\n   part of the underlying NetBIOS mechanism.\n   NetBIOS\
    \ name and datagram distribution servers are the focus of name\n   and datagram\
    \ activity for P and M nodes.\n   Both the name (NBNS) and datagram distribution\
    \ (NBDD) servers are\n   permitted to shift part of their operation to the P or\
    \ M end-node\n   which is requesting a service.\n   Since the assignment of responsibility\
    \ is dynamic, and since P and M\n   nodes must be prepared to operate should the\
    \ NetBIOS server delegate\n   control to the maximum extent, the system naturally\
    \ accommodates\n   improvements in NetBIOS server function.  For example, as Internet\n\
    \   Group Multicasting becomes more widespread, new NBDD implementations\n   may\
    \ elect to assume full responsibility for NetBIOS datagram\n   distribution.\n\
    \   Interoperability between different implementations is assured by\n   imposing\
    \ requirements on end-node implementations that they be able\n   to accept the\
    \ full range of legal responses from the NBNS or NBDD.\n"
- title: 11.1.  NetBIOS NAME SERVER (NBNS) NODES
  contents:
  - "11.1.  NetBIOS NAME SERVER (NBNS) NODES\n   The NBNS is designed to allow considerable\
    \ flexibility with its\n   degree of responsibility for the accuracy and management\
    \ of NetBIOS\n   names.  On one hand, the NBNS may elect not to accept full\n\
    \   responsibility, leaving the NBNS essentially a \"bulletin board\" on\n   which\
    \ name/address information is freely posted (and removed) by P\n   and M nodes\
    \ without validation by the NBNS.  Alternatively, the NBNS\n   may elect to completely\
    \ manage and validate names.  The degree of\n   responsibility that the NBNS assumes\
    \ is asserted by the NBNS each\n   time a name is claimed through a simple mechanism.\
    \  Should the NBNS\n   not assert full control, the NBNS returns enough information\
    \ to the\n   requesting node so that the node may challenge any putative holder\
    \ of\n   the name.\n   This ability to shift responsibility for NetBIOS name management\n\
    \   between the NBNS and the P and M nodes allows a network administrator\n  \
    \ (or vendor) to make a tradeoff between NBNS simplicity, security, and\n   delay\
    \ characteristics.\n   A single NBNS may be implemented as a distributed entity,\
    \ such as the\n   Domain Name Service.  However, this RFC does not attempt to\
    \ define\n   the internal communications which would be used.\n"
- title: 11.1.1.  RELATIONSHIP OF THE NBNS TO THE DOMAIN NAME SYSTEM
  contents:
  - "11.1.1.  RELATIONSHIP OF THE NBNS TO THE DOMAIN NAME SYSTEM\n   The NBNS design\
    \ attempts to align itself with the Domain Name System\n   in a number of ways.\n\
    \   First, the NetBIOS names are encoded in a form acceptable to the\n   domain\
    \ name system.\n   Second, a scope identifier is appended to each NetBIOS name.\
    \  This\n   identifier meets the restricted character set of the domain system\n\
    \   and has a leading period.  This makes the NetBIOS name, in\n   conjunction\
    \ with its scope identifier, a valid domain system name.\n   Third, the negotiated\
    \ responsibility mechanisms permit the NBNS to be\n   used as a simple bulletin\
    \ board on which are posted (name,address)\n   pairs.  This parallels the existing\
    \ domain sytem query service.\n   This RFC, however, requires the NBNS to provide\
    \ services beyond those\n   provided by the current domain name system.  An attempt\
    \ has been made\n   to coalesce all the additional services which are required\
    \ into a set\n   of transactions which follow domain name system styles of interaction\n\
    \   and packet formats.\n   Among the areas in which the domain name service must\
    \ be extended\n   before it may be used as an NBNS are:\n     -  Dynamic addition\
    \ of entries\n     -  Dynamic update of entry data\n     -  Support for multiple\
    \ instance (group) entries\n     -  Support for entry time-to-live values and\
    \ ability to accept\n        refresh messages to restart the time-to-live period\n\
    \     -  New entry attributes\n"
- title: 11.2.  NetBIOS DATAGRAM DISTRIBUTION SERVER (NBDD) NODES
  contents:
  - "11.2.  NetBIOS DATAGRAM DISTRIBUTION SERVER (NBDD) NODES\n   The internet does\
    \ not yet support broadcasting or multicasting.  The\n   NBDD extends NetBIOS\
    \ datagram distribution service to this\n   environment.\n   The NBDD may elect\
    \ to complete, partially complete, or totally refuse\n   to service a node's request\
    \ to distribute a NetBIOS datagram.  An\n   end-node may query an NBDD to determine\
    \ whether the NBDD will deliver\n   a datagram to a specific NetBIOS name.\n \
    \  The design of NetBIOS-over-TCP lends itself to the use of Internet\n   Group\
    \ Multicast.  For details see Appendix A.\n"
- title: 11.3.  RELATIONSHIP OF NBNS AND NBDD NODES
  contents:
  - "11.3.  RELATIONSHIP OF NBNS AND NBDD NODES\n   This RFC defines the NBNS and\
    \ NBDD as distinct, separate entities.\n   In the absence of NetBIOS name information,\
    \ a NetBIOS datagram\n   distribution server must send a copy to each end-node\
    \ within a\n   NetBIOS scope.\n   An implementer may elect to construct NBNS and\
    \ NBDD nodes which have\n   a private protocol for the exchange of NetBIOS name\
    \ information.\n   Alternatively, an NBNS and NBDD may be implemented within the\
    \ same\n   device.\n   NOTE: Implementations containing private NBNS-NBDD protocols\
    \ or\n         combined NBNS-NBDD functions must be clearly identified.\n"
- title: 11.4.  RELATIONSHIP OF NetBIOS SUPPORT SERVERS AND B NODES
  contents:
  - "11.4.  RELATIONSHIP OF NetBIOS SUPPORT SERVERS AND B NODES\n   As defined in\
    \ this RFC, neither NBNS nor NBDD nodes interact with B\n   nodes.  NetBIOS servers\
    \ do not listen to broadcast traffic on any\n   broadcast area to which they may\
    \ be attached.  Nor are the NetBIOS\n   support servers even aware of B node activities\
    \ or names claimed or\n   used by B nodes.\n   It may be possible to extend both\
    \ the NBNS and NBDD so that they\n   participate in B node activities and act\
    \ as a bridge to P and M\n   nodes.  However, such extensions are beyond the scope\
    \ of this\n   specification.\n"
- title: 12.  TOPOLOGIES
  contents:
  - "12.  TOPOLOGIES\n   B, P, M, NBNS, and NBDD nodes may be combined in various\
    \ ways to form\n   useful NetBIOS environments.  This section describes some of\
    \ these\n   combinations.\n   There are three classes of operation:\n     -  Class\
    \ 0:  B nodes only.\n     -  Class 1:  P nodes only.\n     -  Class 2:  P and\
    \ M nodes together.\n   In the drawings which follow, any P node may be replaced\
    \ by an M\n   node.  The effects of such replacement will be mentioned in\n  \
    \ conjunction with each example below.\n"
- title: 12.1.  LOCAL
  contents:
  - "12.1.  LOCAL\n   A NetBIOS scope is operating locally when all entities are within\
    \ the\n   same broadcast area.\n"
- title: 12.1.1.  B NODES ONLY
  contents:
  - "12.1.1.  B NODES ONLY\n   Local operation with only B nodes is the most basic\
    \ mode of\n   operation.  Name registration and discovery procedures use broadcast\n\
    \   mechanisms.  The NetBIOS scope is limited by the extent of the\n   broadcast\
    \ area.  This configuration does not require NetBIOS support\n   servers.\n  \
    \ ====+=========+=====BROADCAST AREA=====+==========+=========+====\n       |\
    \         |                        |          |         |\n       |         |\
    \                        |          |         |\n    +--+--+   +--+--+       \
    \           +--+--+    +--+--+   +--+--+\n    |  B  |   |  B  |              \
    \    |  B  |    |  B  |   |  B  |\n    +-----+   +-----+                  +-----+\
    \    +-----+   +-----+\n"
- title: 12.1.2.  P NODES ONLY
  contents:
  - "12.1.2.  P NODES ONLY\n   This configuration would typically be used when the\
    \ network\n   administrator desires to eliminate NetBIOS as a source of broadcast\n\
    \   activity.\n   ====+=========+==========+=B'CAST AREA=+==========+=========+====\n\
    \       |         |          |             |          |         |\n       |  \
    \       |          |             |          |         |\n    +--+--+   +--+--+\
    \    +--+--+       +--+--+    +--+--+   +--+--+\n    |  P  |   |  P  |    |NBNS\
    \ |       |  P  |    |NBDD |   |  P  |\n    +-----+   +-----+    +-----+     \
    \  +-----+    +-----+   +-----+\n   This configuration operates the same as if\
    \ it were in an internet and\n   is cited here only due to its convenience as\
    \ a means to reduce the\n   use of broadcast.\n   Replacement of one or more of\
    \ the P nodes with M nodes will not\n   affect the operation of the other P and\
    \ M nodes.  P and M nodes will\n   be able to interact with one another.  Because\
    \ M nodes use broadcast,\n   overall broadcast activity will increase.\n"
- title: 12.1.3.  MIXED B AND P NODES
  contents:
  - "12.1.3.  MIXED B AND P NODES\n   B and P nodes do not interact with one another.\
    \  Replacement of P\n   nodes with M nodes will allow B's and M's to interact.\n\
    \   NOTE: B nodes and M nodes may be intermixed only on a local\n         broadcast\
    \ area.  B and M nodes should not be intermixed in\n         an internet environment.\n"
- title: 12.2.  INTERNET
  contents:
  - '12.2.  INTERNET

    '
- title: 12.2.1.  P NODES ONLY
  contents:
  - "12.2.1.  P NODES ONLY\n   P nodes may be scattered at various locations in an\
    \ internetwork.\n   They require both an NBNS and an NBDD for NetBIOS name and\
    \ datagram\n   support, respectively.\n   The NetBIOS scope is determined by the\
    \ NetBIOS scope identifier\n   (domain name) used by the various P (and M) nodes.\
    \  An internet may\n   contain numerous NetBIOS scopes.\n                   +-----+\n\
    \                   |  P  |\n                   +--+--+              |    +-----+\n\
    \                      |                 |----+  P  |\n                      |\
    \                 |    +-----+\n                /-----+-----\\           |\n \
    \  +-----+      |           |  +------+ |    +-----+\n   |  P  +------+  INTERNET\
    \ +--+G'WAY |-+----+  P  |\n   +-----+      |           |  +------+ |    +-----+\n\
    \                /-----+-----/           |\n              /       |          \
    \       |    +-----+\n            /         |                 |----+  P  |\n \
    \    +-----+       +--+--+              |    +-----+\n     |NBNS +       |NBDD\
    \ |\n     +-----+       +--+--+\n   Any P node may be replaced by an M node with\
    \ no loss of function to\n   any node.  However, broadcast activity will be increased\
    \ in the\n   broadcast area to which the M node is attached.\n"
- title: 12.2.2.  MIXED M AND P NODES
  contents:
  - "12.2.2.  MIXED M AND P NODES\n   M and P nodes may be mixed.  When locating NetBIOS\
    \ names, M nodes\n   will tend to find names held by other M nodes on the same\
    \ common\n   broadcast area in preference to names held by P nodes or M nodes\n\
    \   elsewhere in the network.\n                         +-----+\n            \
    \             |  P  |\n                         +--+--+\n                    \
    \        |\n                            |\n                      /-----+-----\\\
    \n         +-----+      |           |      +-----+\n         |  P  +------+  INTERNET\
    \ +------+NBDD |\n         +-----+      |           |      +-----+\n         \
    \             /-----+-----/\n                    /       |\n                 \
    \ /         |\n           +-----+       +--+--+\n           |NBNS +       |G'WAY|\n\
    \           +-----+       +--+--+\n                            |\n           \
    \                 |\n   ====+=========+==========+=B'CAST AREA=+==========+=========+====\n\
    \       |         |          |             |          |         |\n       |  \
    \       |          |             |          |         |\n    +--+--+   +--+--+\
    \    +--+--+       +--+--+    +--+--+   +--+--+\n    |  M  |   |  P  |    |  M\
    \  |       |  P  |    |  M  |   |  P  |\n    +-----+   +-----+    +--+--+    \
    \   +-----+    +-----+   +-----+\n   NOTE: B and M nodes should not be intermixed\
    \ in an internet\n         environment.  Doing so would allow undetected NetBIOS\
    \ name\n         conflicts to arise and cause unpredictable behavior.\n"
- title: 13.  GENERAL METHODS
  contents:
  - "13.  GENERAL METHODS\n   Overlying the specific protocols, described later, are\
    \ a few general\n   methods of interaction between entities.\n"
- title: 13.1.  REQUEST/RESPONSE INTERACTION STYLE
  contents:
  - "13.1.  REQUEST/RESPONSE INTERACTION STYLE\n   Most interactions between entities\
    \ consist of a request flowing in\n   one direction and a subsequent response\
    \ flowing in the opposite\n   direction.\n   In those situations where interactions\
    \ occur on unreliable transports\n   (i.e. UDP) or when a request is broadcast,\
    \ there may not be a strict\n   interlocking or one-to-one relationship between\
    \ requests and\n   responses.\n   In no case, however, is more than one response\
    \ generated for a\n   received request.  While a response is pending the responding\
    \ entity\n   may send one or more wait acknowledgements.\n"
- title: 13.1.1.  RETRANSMISSION OF REQUESTS
  contents:
  - "13.1.1.  RETRANSMISSION OF REQUESTS\n   UDP is an unreliable delivery mechanism\
    \ where packets can be lost,\n   received out of transmit sequence, duplicated\
    \ and delivery can be\n   significantly delayed.  Since the NetBIOS protocols\
    \ make heavy use of\n   UDP, they have compensated for its unreliability with\
    \ extra\n   mechanisms.\n   Each NetBIOS packet contains all the necessary information\
    \ to process\n   it.  None of the protocols use multiple UDP packets to convey\
    \ a\n   single request or response.  If more information is required than\n  \
    \ will fit in a single UDP packet, for example, when a P-type node\n   wants all\
    \ the owners of a group name from a NetBIOS server, a TCP\n   connection is used.\
    \  Consequently, the NetBIOS protocols will not\n   fail because of out of sequence\
    \ delivery of UDP packets.\n   To overcome the loss of a request or response packet,\
    \ each request\n   operation will retransmit the request if a response is not\
    \ received\n   within a specified time limit.\n   Protocol operations sensitive\
    \ to successive response packets, such as\n   name conflict detection, are protected\
    \ from duplicated packets\n   because they ignore successive packets with the\
    \ same NetBIOS\n   information.  Since no state on the responder's node is associated\n\
    \   with a request, the responder just sends the appropriate response\n   whenever\
    \ a request packet arrives.  Consequently, duplicate or\n   delayed request packets\
    \ have no impact.\n   For all requests, if a response packet is delayed too long\
    \ another\n   request packet will be transmitted.  A second response packet being\n\
    \   sent in response to the second request packet is equivalent to a\n   duplicate\
    \ packet.  Therefore, the protocols will ignore the second\n   packet received.\
    \  If the delivery of a response is delayed until\n   after the request operation\
    \ has been completed, successfully or not,\n   the response packet is ignored.\n"
- title: '13.1.2.  REQUESTS WITHOUT RESPONSES: DEMANDS'
  contents:
  - "13.1.2.  REQUESTS WITHOUT RESPONSES: DEMANDS\n   Some request types do not have\
    \ matching responses.  These requests\n   are known as \"demands\".  In general\
    \ a \"demand\" is an imperative\n   request; the receiving node is expected to\
    \ obey.  However, because\n   demands are unconfirmed, they are used only in situations\
    \ where, at\n   most, limited damage would occur if the demand packet should be\
    \ lost.\n   Demand packets are not retransmitted.\n"
- title: 13.2.  TRANSACTIONS
  contents:
  - "13.2.  TRANSACTIONS\n   Interactions between a pair of entities are grouped into\n\
    \   \"transactions\".  These transactions comprise one or more\n   request/response\
    \ pairs.\n"
- title: 13.2.1.  TRANSACTION ID
  contents:
  - "13.2.1.  TRANSACTION ID\n   Since multiple simultaneous transactions may be in\
    \ progress between a\n   pair of entities a \"transaction id\" is used.\n   The\
    \ originator of a transaction selects an ID unique to the\n   originator.  The\
    \ transaction id is reflected back and forth in each\n   interaction within the\
    \ transaction.  The transaction partners must\n   match responses and requests\
    \ by comparison of the transaction ID and\n   the IP address of the transaction\
    \ partner.  If no matching request\n   can be found the response must be discarded.\n\
    \   A new transaction ID should be used for each transaction.  A simple\n   16\
    \ bit transaction counter ought to be an adequate id generator.  It\n   is probably\
    \ not necessary to search the space of outstanding\n   transaction ID to filter\
    \ duplicates: it is extremely unlikely that\n   any transaction will have a lifetime\
    \ that is more than a small\n   fraction of the typical counter cycle period.\
    \  Use of the IP\n   addresses in conjunction with the transaction ID further\
    \ reduces the\n   possibility of damage should transaction IDs be prematurely\
    \ re-used.\n"
- title: 13.3.  TCP AND UDP FOUNDATIONS
  contents:
  - "13.3.  TCP AND UDP FOUNDATIONS\n   This version of the NetBIOS-over-TCP protocols\
    \ uses UDP for many\n   interactions.  In the future this RFC may be extended\
    \ to permit such\n   interactions to occur over TCP connections (perhaps to increase\n\
    \   efficiency when multiple interactions occur within a short time or\n   when\
    \ NetBIOS datagram traffic reveals that an application is using\n   NetBIOS datagrams\
    \ to support connection- oriented service.)\n"
- title: 14.  REPRESENTATION OF NETBIOS NAMES
  contents:
  - "14.  REPRESENTATION OF NETBIOS NAMES\n   NetBIOS names as seen across the client\
    \ interface to NetBIOS are\n   exactly 16 bytes long.  Within the NetBIOS-over-TCP\
    \ protocols, a\n   longer representation is used.\n   There are two levels of\
    \ encoding.  The first level maps a NetBIOS\n   name into a domain system name.\
    \  The second level maps the domain\n   system name into the \"compressed\" representation\
    \ required for\n   interaction with the domain name system.\n   Except in one\
    \ packet, the second level representation is the only\n   NetBIOS name representation\
    \ used in NetBIOS-over-TCP packet formats.\n   The exception is the RDATA field\
    \ of a NODE STATUS RESPONSE packet.\n"
- title: 14.1.  FIRST LEVEL ENCODING
  contents:
  - "14.1.  FIRST LEVEL ENCODING\n   The first level representation consists of two\
    \ parts:\n     -  NetBIOS name\n     -  NetBIOS scope identifier\n   The 16 byte\
    \ NetBIOS name is mapped into a 32 byte wide field using a\n   reversible, half-ASCII,\
    \ biased encoding.  Each half-octet of the\n   NetBIOS name is encoded into one\
    \ byte of the 32 byte field.  The\n   first half octet is encoded into the first\
    \ byte, the second half-\n   octet into the second byte, etc.\n   Each 4-bit,\
    \ half-octet of the NetBIOS name is treated as an 8-bit,\n   right-adjusted, zero-filled\
    \ binary number.  This number is added to\n   value of the ASCII character 'A'\
    \ (hexidecimal 41).  The resulting 8-\n   bit number is stored in the appropriate\
    \ byte.  The following diagram\n   demonstrates this procedure:\n            \
    \             0 1 2 3 4 5 6 7\n                        +-+-+-+-+-+-+-+-+\n   \
    \                     |a b c d|w x y z|          ORIGINAL BYTE\n             \
    \           +-+-+-+-+-+-+-+-+\n                            |       |\n       \
    \            +--------+       +--------+\n                   |               \
    \          |     SPLIT THE NIBBLES\n                   v                     \
    \    v\n            0 1 2 3 4 5 6 7           0 1 2 3 4 5 6 7\n           +-+-+-+-+-+-+-+-+\
    \         +-+-+-+-+-+-+-+-+\n           |0 0 0 0 a b c d|         |0 0 0 0 w x\
    \ y z|\n           +-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+\n             \
    \      |                         |\n                   +                     \
    \    +     ADD 'A'\n                   |                         |\n         \
    \   0 1 2 3 4 5 6 7           0 1 2 3 4 5 6 7\n           +-+-+-+-+-+-+-+-+  \
    \       +-+-+-+-+-+-+-+-+\n           |0 1 0 0 0 0 0 1|         |0 1 0 0 0 0 0\
    \ 1|\n           +-+-+-+-+-+-+-+-+         +-+-+-+-+-+-+-+-+\n   This encoding\
    \ results in a NetBIOS name being represented as a\n   sequence of 32 ASCII, upper-case\
    \ characters from the set\n   {A,B,C...N,O,P}.\n   The NetBIOS scope identifier\
    \ is a valid domain name (without a\n   leading dot).\n   An ASCII dot (2E hexidecimal)\
    \ and the scope identifier are appended\n   to the encoded form of the NetBIOS\
    \ name, the result forming a valid\n   domain name.\n   For example, the NetBIOS\
    \ name \"The NetBIOS name\" in the NetBIOS scope\n   \"SCOPE.ID.COM\" would be\
    \ represented at level one by the ASCII\n   character string:\n        FEGHGFCAEOGFHEECEJEPFDCAHEGBGNGF.SCOPE.ID.COM\n"
- title: 14.2.  SECOND LEVEL ENCODING
  contents:
  - "14.2.  SECOND LEVEL ENCODING\n   The first level encoding must be reduced to\
    \ second level encoding.\n   This is performed according to the rules defined\
    \ in on page 31 of RFC\n   883[12] in the section on \"Domain name representation\
    \ and\n   compression\".  Also see the section titled \"Name Formats\" in the\n\
    \   Detailed Specifications[1].\n"
- title: 15.  NetBIOS NAME SERVICE
  contents:
  - "15.  NetBIOS NAME SERVICE\n   Before a name may be used, the name must be registered\
    \ by a node.\n   Once acquired, the name must be defended against inconsistent\n\
    \   registration by other nodes.  Before building a NetBIOS session or\n   sending\
    \ a NetBIOS datagram, the one or more holders of the name must\n   be located.\n\
    \   The NetBIOS name service is the collection of procedures through\n   which\
    \ nodes acquire, defend, and locate the holders of NetBIOS names.\n   The name\
    \ service procedures are different depending whether the end-\n   node is of type\
    \ B, P, or M.\n"
- title: 15.1.  OVERVIEW OF NetBIOS NAME SERVICE
  contents:
  - '15.1.  OVERVIEW OF NetBIOS NAME SERVICE

    '
- title: 15.1.1.  NAME REGISTRATION (CLAIM)
  contents:
  - "15.1.1.  NAME REGISTRATION (CLAIM)\n   Each NetBIOS node can own more than one\
    \ name.  Names are acquired\n   dynamically through the registration (name claim)\
    \ procedures.\n   Every node has a permanent unique name.  This name, like any\
    \ other\n   name, must be explicitly registered by all end-node types.\n   A name\
    \ can be unique (exclusive) or group (non-exclusive).  A unique\n   name may be\
    \ owned by a single node; a group name may be owned by any\n   number of nodes.\
    \  A name ceases to exist when it is not owned by at\n   least one node.  There\
    \ is no intrinsic quality of a name which\n   determines its characteristics:\
    \ these are established at the time of\n   registration.\n   Each node maintains\
    \ state information for each name it has\n   registered.  This information includes:\n\
    \     -  Whether the name is a group or unique name\n     -  Whether the name\
    \ is \"in conflict\"\n     -  Whether the name is in the process of being deleted\n\
    \   B nodes perform name registration by broadcasting claim requests,\n   soliciting\
    \ a defense from any node already holding the name.\n   P nodes perform name registration\
    \ through the agency of the NBNS.\n   M nodes register names through an initial\
    \ broadcast, like B nodes,\n   then, in the absence of an objection, by following\
    \ the same\n   procedures as a P node.  In other words, the broadcast action may\n\
    \   terminate the attempt, but is not sufficient to confirm the\n   registration.\n"
- title: 15.1.2.  NAME QUERY (DISCOVERY)
  contents:
  - "15.1.2.  NAME QUERY (DISCOVERY)\n   Name query (also known as \"resolution\"\
    \ or \"discovery\") is the\n   procedure by which the IP address(es) associated\
    \ with a NetBIOS name\n   are discovered.  Name query is required during the following\n\
    \   operations:\n   During session establishment, calling and called names must\
    \ be\n   specified.  The calling name must exist on the node that posts the\n\
    \   CALL.  The called name must exist on a node that has previously\n   posted\
    \ a LISTEN.  Either name may be a unique or group name.\n   When a directed datagram\
    \ is sent, a source and destination name must\n   be specified.  If the destination\
    \ name is a group name, a datagram is\n   sent to all the members of that group.\n\
    \   Different end-node types perform name resolution using different\n   techniques,\
    \ but using the same packet formats:\n     -  B nodes solicit name information\
    \ by broadcasting a request.\n     -  P nodes ask the NBNS.\n     -  M nodes broadcast\
    \ a request.  If that does not provide the\n        desired information, an inquiry\
    \ is sent to the NBNS.\n"
- title: 15.1.3.  NAME RELEASE
  contents:
  - "15.1.3.  NAME RELEASE\n   NetBIOS names may be released explicitly or silently\
    \ by an end- node.\n   Silent release typically occurs when an end-node fails\
    \ or is turned-\n   off.  Most of the mechanisms described below are present to\
    \ detect\n   silent name release.\n"
- title: 15.1.3.1.  EXPLICIT RELEASE
  contents:
  - "15.1.3.1.  EXPLICIT RELEASE\n   B nodes explicitly release a name by broadcasting\
    \ a notice.\n   P nodes send a notification to their NBNS.\n   M nodes both broadcast\
    \ a notice and inform their supporting NBNS.\n"
- title: 15.1.3.2.  NAME LIFETIME AND REFRESH
  contents:
  - "15.1.3.2.  NAME LIFETIME AND REFRESH\n   Names held by an NBNS are given a lifetime\
    \ during name registration.\n   The NBNS will consider a name to have been silently\
    \ released if the\n   end-node fails to send a name refresh message to the NBNS\
    \ before the\n   lifetime expires.  A refresh restarts the lifetime clock.\n \
    \  NOTE: The implementor should be aware of the tradeoff between\n         accuracy\
    \ of the database and the internet overhead that the\n         refresh mechanism\
    \ introduces.  The lifetime period should\n         be tuned accordingly.\n  \
    \ For group names, each end-node must send refresh messages.  A node\n   that\
    \ fails to do so will be considered to have silently released the\n   name and\
    \ dropped from the group.\n   The lifetime period is established through a simple\
    \ negotiation\n   mechanism during name registration:  In the name registration\n\
    \   request, the end-node proposes a lifetime value or requests an\n   infinite\
    \ lifetime.  The NBNS places an actual lifetime value into the\n   name registration\
    \ response.  The NBNS is always allowed to respond\n   with an infinite actual\
    \ period.  If the end node proposed an infinite\n   lifetime, the NBNS may respond\
    \ with any definite period.  If the end\n   node proposed a definite period, the\
    \ NBNS may respond with any\n   definite period greater than or equal to that\
    \ proposed.\n   This negotiation of refresh times gives the NBNS means to disable\
    \ or\n   enable refresh activity.  The end-nodes may set a minimum refresh\n \
    \  cycle period.\n   NBNS implementations which are completely reliable may disable\n\
    \   refresh.\n"
- title: 15.1.3.3.  NAME CHALLENGE
  contents:
  - "15.1.3.3.  NAME CHALLENGE\n   To detect whether a node has silently released\
    \ its claim to a name,\n   it is necessary on occasion to challenge that node's\
    \ current\n   ownership.  If the node defends the name then the node is allowed\
    \ to\n   continue possession.  Otherwise it is assumed that the node has\n   released\
    \ the name.\n   A name challenge may be issued by an NBNS or by a P or M node.\
    \  A\n   challenge may be directed towards any end-node type: B, P, or M.\n"
- title: 15.1.3.4.  GROUP NAME FADE-OUT
  contents:
  - "15.1.3.4.  GROUP NAME FADE-OUT\n   NetBIOS groups may contain an arbitrarily\
    \ large number of members.\n   The time to challenge all members could be quite\
    \ large.\n   To avoid long delays when names are claimed through an NBNS, an\n\
    \   optimistic heuristic has been adopted.  It is assumed that there will\n  \
    \ always be some node which will defend a group name.  Consequently, it\n   is\
    \ recommended that the NBNS will immediately reject a claim request\n   for a\
    \ unique name when there already exists a group with the same\n   name.  The NBNS\
    \ will never return an IP address (in response to a\n   NAME REGISTRATION REQUEST)\
    \ when a group name exists.\n   An NBNS will consider a group to have faded out\
    \ of existence when the\n   last remaining member fails to send a timely refresh\
    \ message or\n   explicitly releases the name.\n"
- title: 15.1.3.5.  NAME CONFLICT
  contents:
  - "15.1.3.5.  NAME CONFLICT\n   Name conflict exists when a unique name has been\
    \ claimed by more than\n   one node on a NetBIOS network.  B, M, and NBNS nodes\
    \ may detect a\n   name conflict.  The detection mechanism used by B and M nodes\
    \ is\n   active only during name discovery.  The NBNS may detect conflict at\n\
    \   any time it verifies the consistency of its name database.\n   B and M nodes\
    \ detect conflict by examining the responses received in\n   answer to a broadcast\
    \ name query request.  The first response is\n   taken as authoritative.  Any\
    \ subsequent, inconsistent responses\n   represent conflicts.\n   Subsequent responses\
    \ are inconsistent with the authoritative response\n   when:\n        The subsequent\
    \ response has the same transaction ID as the\n        NAME QUERY REQUEST.\n \
    \    AND\n        The subsequent response is not a duplicate of the\n        authoritative\
    \ response.\n     AND EITHER:\n             The group/unique characteristic of\
    \ the authoritative\n             response is \"unique\".\n          OR\n    \
    \         The group/unique characteristic of the subsequent\n             response\
    \ is \"unique\".\n   The period in which B and M nodes examine responses is limited\
    \ by a\n   conflict timer, CONFLICT_TIMER.  The accuracy or duration of this\n\
    \   timer is not crucial: the NetBIOS system will continue to operate\n   even\
    \ with persistent name conflicts.\n   Conflict conditions are signaled by sending\
    \ a NAME CONFLICT DEMAND to\n   the node owning the offending name.  Nothing is\
    \ sent to the node\n   which originated the authoritative response.\n   Any end-node\
    \ that receives NAME CONFLICT DEMAND is required to update\n   its \"local name\
    \ table\" to reflect that the name is in conflict.  (The\n   \"local name table\"\
    \ on each node contains names that have been\n   successfully registered by that\
    \ node.)\n   Notice that only those nodes that receive the name conflict message\n\
    \   place a conflict mark next to a name.\n   Logically, a marked name does not\
    \ exist on that node.  This means\n   that the node should not defend the name\
    \ (for name claim purposes),\n   should not respond to a name discovery requests\
    \ for that name, nor\n   should the node send name refresh messages for that name.\n\
    \   Furthermore, it can no longer be used by that node for any session\n   establishment\
    \ or sending or receiving datagrams.  Existing sessions\n   are not affected at\
    \ the time a name is marked as being in conflict.\n   The only valid user function\
    \ against a marked name is DELETE NAME.\n   Any other user NetBIOS function returns\
    \ immediately with an error\n   code of \"NAME CONFLICT\".\n"
- title: 15.1.4.  ADAPTER STATUS
  contents:
  - "15.1.4.  ADAPTER STATUS\n   An end-node or the NBNS may ask any other end-node\
    \ for a collection\n   of information about the NetBIOS status of that node. \
    \ This status\n   consists of, among other things, a list of the names which the\
    \ node\n   believes it owns.  The returned status is filtered to contain only\n\
    \   those names which have the same NetBIOS scope identifier as the\n   requestor's\
    \ name.\n   When requesting node status, the requestor identifies the target node\n\
    \   by NetBIOS name  A name query transaction may be necessary to acquire\n  \
    \ the IP address for the name.  Locally cached name information may be\n   used\
    \ in lieu of a query transaction.  The requesting node sends a\n   NODE STATUS\
    \ REQUEST.  In response, the receiving node sends a NODE\n   STATUS RESPONSE containing\
    \ its local name table and various\n   statistics.\n   The amount of status which\
    \ may be returned is limited by the size of\n   a UDP packet.  However, this is\
    \ sufficient for the typical NODE\n   STATUS RESPONSE packet.\n"
- title: 15.1.5.  END-NODE NBNS INTERACTION
  contents:
  - "15.1.5.  END-NODE NBNS INTERACTION\n   There are certain characteristics of end-node\
    \ to NBNS interactions\n   which are in common and are independent of any particular\
    \ transaction\n   type.\n"
- title: 15.1.5.1.  UDP, TCP, AND TRUNCATION
  contents:
  - "15.1.5.1.  UDP, TCP, AND TRUNCATION\n   For all transactions between an end-node\
    \ and an NBNS, either UDP or\n   TCP may be used as a transport.  If the NBNS\
    \ receives a UDP based\n   request, it will respond using UDP.  If the amount\
    \ of information\n   exceeds what fits into a UDP packet, the response will contain\
    \ a\n   \"truncation flag\".  In this situation, the end- node may open a TCP\n\
    \   connection to the NBNS, repeat the request, and receive a complete,\n   untruncated\
    \ response.\n"
- title: 15.1.5.2.  NBNS WACK
  contents:
  - "15.1.5.2.  NBNS WACK\n   While a name service request is in progress, the NBNS\
    \ may issue a\n   WAIT FOR ACKNOWLEDGEMENT RESPONSE (WACK) to assure the client\
    \ end-\n   node that the NBNS is still operational and is working on the\n   request.\n"
- title: 15.1.5.3.  NBNS REDIRECTION
  contents:
  - "15.1.5.3.  NBNS REDIRECTION\n   The NBNS, because it follows Domain Name system\
    \ styles of\n   interaction, is permitted to redirect a client to another NBNS.\n"
- title: 15.1.6.  SECURED VERSUS NON-SECURED NBNS
  contents:
  - "15.1.6.  SECURED VERSUS NON-SECURED NBNS\n   An NBNS may be implemented in either\
    \ of two general ways:  The NBNS\n   may monitor, and participate in, name activity\
    \ to ensure consistency.\n   This would be a \"secured\" style NBNS.  Alternatively,\
    \ an NBNS may be\n   implemented to be essentially a \"bulletin board\" on which\
    \ name\n   information is posted and responsibility for consistency is delegated\n\
    \   to the end-nodes.  This would be a \"non-secured\" style NBNS.\n"
- title: 15.1.7.  CONSISTENCY OF THE NBNS DATA BASE
  contents:
  - "15.1.7.  CONSISTENCY OF THE NBNS DATA BASE\n   Even in a properly running NetBIOS\
    \ scope the NBNS and its community\n   of end-nodes may occasionally lose synchronization\
    \ with respect to\n   the true state of name registrations.\n   This may occur\
    \ should the NBNS fail and lose all or part of its\n   database.\n   More commonly,\
    \ a P or M node may be turned-off (thus forgetting the\n   names it has registered)\
    \ and then be subsequently turned back on.\n   Finally, errors may occur or an\
    \ implementation may be incorrect.\n   Various approaches have been incorporated\
    \ into the NetBIOS-over- TCP\n   protocols to minimize the impact of these problems.\n\
    \      1.   The NBNS (or any other node) may \"challenge\" (using a NAME\n   \
    \        QUERY REQUEST) an end-node to verify that it actually owns a\n      \
    \     name.\n           Such a challenge may occur at any time.  Every end-node\
    \ must\n           be prepared to make a timely response.\n           Failure\
    \ to respond causes the NBNS to consider that the\n           end-node has released\
    \ the name in question.\n           (If UDP is being used as the underlying transport,\
    \ the\n           challenge, like all other requests, must be retransmitted\n\
    \           some number of times in the absence of a response.)\n      2.   The\
    \ NBNS (or any other node) may request (using the NODE\n           STATUS REQUEST)\
    \ that an end-node deliver its entire name\n           table.\n           This\
    \ may occur at any time.  Every end-node must be prepared\n           to make\
    \ a timely response.\n           Failure to respond permits (but does not require)\
    \ the NBNS\n           to consider that the end-node has failed and released all\n\
    \           names to which it had claims.  (Like the challenge, on a UDP\n   \
    \        transport, the request must be retransmitted in the absence\n       \
    \    of a response.)\n      3.   The NBNS may revoke a P or M node's use of a\
    \ name by sending\n           either a NAME CONFLICT DEMAND or a NAME RELEASE\
    \ REQUEST to\n           the node.\n           The receiving end-node may continue\
    \ existing sessions which\n           use that name, but must otherwise cease\
    \ using that name.  If\n           the NBNS placed the name in conflict, the name\
    \ may be re-\n           acquired only by deletion and subsequent reclamation.\
    \  If\n           the NBNS requested that the name be released, the node may\n\
    \           attempt to re-acquire the name without first performing a\n      \
    \     name release transaction.\n      4.   The NBNS may impose a \"time-to-live\"\
    \ on each name it\n           registers.  The registering node is made aware of\
    \ this time\n           value during the name registration procedure.\n      \
    \     Simple or reliable NBNS's may impose an infinite time-to-\n           live.\n\
    \      5.   If an end-node holds any names that have finite time-to-\n       \
    \    live values, then that node must periodically send a status\n           report\
    \ to the NBNS.  Each name is reported using the NAME\n           REFRESH REQUEST\
    \ packet.\n           These status reports restart the timers of both the NBNS\
    \ and\n           the reporting node.  However, the only timers which are\n  \
    \         restarted are those associated with the name found in the\n        \
    \   status report.  Timers on other names are not affected.\n           The NBNS\
    \ may consider that a node has released any name\n           which has not been\
    \ refreshed within some multiple of name's\n           time-to-live.\n       \
    \    A well-behaved NBNS, would, however, issue a challenge to-,\n           or\
    \ request a list of names from-, the non-reporting end-\n           node before\
    \ deleting its name(s).  The absence of a\n           response, or of the name\
    \ in a response, will confirm the\n           NBNS decision to delete a name.\n\
    \      6.   The absence of reports may cause the NBNS to infer that the\n    \
    \       end-node has failed.  Similarly, receipt of information\n           widely\
    \ divergent from what the NBNS believes about the node,\n           may cause\
    \ the NBNS to consider that the end-node has been\n           restarted.\n   \
    \        The NBNS may analyze the situation through challenges or\n          \
    \ requests for a list of names.\n      7.   A very cautious NBNS is free to poll\
    \ nodes (by sending NAME\n           QUERY REQUEST or NODE STATUS REQUEST packets)\
    \ to verify that\n           their name status is the same as that registered\
    \ in the\n           NBNS.\n           NOTE:  Such polling activity, if used at\
    \ all by an\n           implementation, should be kept at a very low level or\n\
    \           enabled only during periods when the NBNS has some reason to\n   \
    \        suspect that its information base is inaccurate.\n      8.   P and M\
    \ nodes can detect incorrect name information at\n           session establishment.\n\
    \           If incorrect information is found, NBNS is informed via a\n      \
    \     NAME RELEASE REQUEST originated by the end-node which\n           detects\
    \ the error.\n"
- title: 15.1.8.  NAME CACHING
  contents:
  - "15.1.8.  NAME CACHING\n   An end-node may keep a local cache of NetBIOS name-to-IP\
    \ address\n   translation entries.\n   All cache entries should be flushed on\
    \ a periodic basis.\n   In addition, a node ought to flush any cache information\
    \ associated\n   with an IP address if the node receives any information indicating\n\
    \   that there may be any possibility of trouble with the node at that IP\n  \
    \ address.  For example, if a NAME CONFLICT DEMAND is sent to a node,\n   all\
    \ cached information about that node should be cleared within the\n   sending\
    \ node.\n"
- title: 15.2.  NAME REGISTRATION TRANSACTIONS
  contents:
  - '15.2.  NAME REGISTRATION TRANSACTIONS

    '
- title: 15.2.1.  NAME REGISTRATION BY B NODES
  contents:
  - "15.2.1.  NAME REGISTRATION BY B NODES\n   A name claim transaction initiated\
    \ by a B node is broadcast\n   throughout the broadcast area.  The NAME REGISTRATION\
    \ REQUEST will be\n   heard by all B and M nodes in the area.  Each node examines\
    \ the claim\n   to see whether it it is consistent with the names it owns.  If\
    \ an\n   inconsistency exists, a NEGATIVE NAME REGISTRATION RESPONSE is\n   unicast\
    \ to the requestor.  The requesting node obtains ownership of\n   the name (or\
    \ membership in the group) if, and only if, no NEGATIVE\n   NAME REGISTRATION\
    \ RESPONSEs are received within the name claim\n   timeout, CONFLICT_TIMER.  (See\
    \ \"Defined Constants and Variables\" in\n   the Detailed Specification for the\
    \ value of this timer.)\n   A B node proclaims its new ownership by broadcasting\
    \ a NAME OVERWRITE\n   DEMAND.\n                       B-NODE REGISTRATION PROCESS\n\
    \   <-----NAME NOT ON NETWORK------>   <----NAME ALREADY EXISTS---->\n   REQ.\
    \ NODE                      NODE                     REQ.NODE\n              \
    \                   HOLDING\n                                  NAME\n   (BROADCAST)\
    \ REGISTER                        (BROADCAST) REGISTER\n   ------------------->\
    \                        <-------------------\n        REGISTER              \
    \                       REGISTER\n   ------------------->                    \
    \    <-------------------\n        REGISTER                         NEGATIVE RESPONSE\n\
    \   ------------------->             ------------------------------>\n       \
    \   OVERWRITE\n   ------------------->               (NODE DOES NOT HAVE THE NAME)\n\
    \   (NODE HAS THE NAME)\n   The NAME REGISTRATION REQUEST, like any request, must\
    \ be repeated if\n   no response is received within BCAST_REQ_RETRY_TIMEOUT. \
    \ Transmission\n   of the request is attempted BCAST_REQ_RETRY_COUNT times.\n"
- title: 15.2.2.  NAME REGISTRATION BY P NODES
  contents:
  - "15.2.2.  NAME REGISTRATION BY P NODES\n   A name registration may proceed in\
    \ various  ways depending whether\n   the name being registered is new to the\
    \ NBNS.  If the name is known\n   to the NBNS, then challenges may be sent to\
    \ the prior holder(s).\n"
- title: 15.2.2.1.  NEW NAME, OR NEW GROUP MEMBER
  contents:
  - "15.2.2.1.  NEW NAME, OR NEW GROUP MEMBER\n   The diagram, below, shows the sequence\
    \ of events when an end-node\n   registers a name which is new to the NBNS.  (The\
    \ diagram omits WACKs,\n   NBNS redirections, and retransmission of requests.)\n\
    \   This same interaction will occur if the name being registered is a\n   group\
    \ name and the group already exists.  The NBNS will add the\n   registrant to\
    \ the set of group members.\n                       P-NODE REGISTRATION PROCESS\n\
    \            (server has no previous information about the name)\n           \
    \   P-NODE                            NBNS\n                          REGISTER\n\
    \                --------------------------------->\n                        POSITIVE\
    \ RESPONSE\n                <---------------------------------\n   The interaction\
    \ is rather simple: the end-node sends a NAME\n   REGISTRATION REQUEST, the NBNS\
    \ responds with a POSITIVE NAME\n   REGISTRATION RESPONSE.\n"
- title: 15.2.2.2.  EXISTING NAME AND OWNER IS STILL ACTIVE
  contents:
  - "15.2.2.2.  EXISTING NAME AND OWNER IS STILL ACTIVE\n   The following diagram\
    \ shows interactions when an attempt is made to\n   register a unique name, the\
    \ NBNS is aware of an existing owner, and\n   that existing owner is still active.\n\
    \   There are two sides to the diagram.  The left side shows how a non-\n   secured\
    \ NBNS would handle the matter.  Secured NBNS activity is shown\n   on the right.\n\
    \                       P-NODE REGISTRATION PROCESS\n               (server HAS\
    \ a previous owner that IS active)\n   <------NON-SECURED STYLE------->  <---------SECURED\
    \ STYLE------->\n   REQ. NODE           NBNS       NODE         NBNS         REQ.NODE\n\
    \                                 HOLDING\n                                  NAME\n\
    \         REGISTER                                      REGISTER\n   ------------------->\
    \                         <-------------------\n                             \
    \          QUERY\n    END-NODE CHALLENGE              <------------\n   <-------------------\
    \                QUERY\n                                    <------------\n  \
    \           QUERY\n   ----------------------------->\n                       \
    \              POSITIVE RESP\n             QUERY                   ------------>\n\
    \   ----------------------------->                 NEGATIVE RESPONSE\n       \
    \                                           ----------------->\n         POSITIVE\
    \ RESPONSE\n   <----------------------------\n   A non-secured NBNS will answer\
    \ the NAME REGISTRATION REQUEST with a\n   END-NODE CHALLENGE REGISTRATION RESPONSE.\
    \  This response asks the\n   end-node to issue a challenge transaction against\
    \ the node indicated\n   in the response.  In this case, the prior node will defend\
    \ against\n   the challenge and the registering end-node will simply drop the\n\
    \   registration attempt without further interaction with the NBNS.\n   A secured\
    \ NBNS will refrain from answering the NAME REGISTRATION\n   REQUEST until the\
    \ NBNS has itself challenged the prior holder(s) of\n   the name.  In this case,\
    \ the NBNS finds that that the name is still\n   being defended and consequently\
    \ returns a NEGATIVE NAME REGISTRATION\n   RESPONSE to the registrant.\n   Due\
    \ to the potential time for the secured NBNS to make the\n   challenge(s), it\
    \ is likely that a WACK will be sent by the NBNS to\n   the registrant.\n   Although\
    \ not shown in the diagram, a non-secured NBNS will send a\n   NEGATIVE NAME REGISTRATION\
    \ RESPONSE to a request to register a unique\n   name when there already exists\
    \ a group of the same name.  A secured\n   NBNS may elect to poll (or challenge)\
    \ the group members to determine\n   whether any active members remain.  This\
    \ may impose a heavy load on\n   the network.  It is recommended that group names\
    \ be allowed to fade-\n   out through the name refresh mechanism.\n"
- title: 15.2.2.3.  EXISTING NAME AND OWNER IS INACTIVE
  contents:
  - "15.2.2.3.  EXISTING NAME AND OWNER IS INACTIVE\n   The following diagram shows\
    \ interactions when an attempt is made to\n   register a unique name, the NBNS\
    \ is aware of an existing owner, and\n   that existing owner is no longer active.\n\
    \   A non-secured NBNS will answer the NAME REGISTRATION REQUEST with a\n   END-NODE\
    \ CHALLENGE REGISTRATION RESPONSE.  This response asks the\n   end-node to issue\
    \ a challenge transaction against the node indicated\n   in the response.  In\
    \ this case, the prior node will not defend\n   against the challenge.  The registrant\
    \ will inform the NBNS through a\n   NAME OVERWRITE REQUEST.  The NBNS will replace\
    \ the prior name\n   information in its database with the information in the overwrite\n\
    \   request.\n   A secured NBNS will refrain from answering the NAME REGISTRATION\n\
    \   REQUEST until the NBNS has itself challenged the prior holder(s) of\n   the\
    \ name.  In this case, the NBNS finds that that the name is not\n   being defended\
    \ and consequently returns a POSITIVE NAME REGISTRATION\n   RESPONSE to the registrant.\n\
    \                       P-NODE REGISTRATION PROCESS\n             (server HAS\
    \ a previous owner that is NOT active)\n   <------NON-SECURED STYLE----->  <----------SECURED\
    \ STYLE-------->\n   REQ. NODE           NBNS     NODE           NBNS        \
    \ REQ.NODE\n                               HOLDING\n                         \
    \       NAME\n         REGISTER                                    REGISTER\n\
    \   ------------------->                         <-------------------\n      \
    \                                 QUERY\n    END-NODE CHALLENGE             <------------\n\
    \   <-------------------                QUERY\n                              \
    \     <------------\n         NAME QUERY REQUEST                        POSITIVE\
    \ RESPONSE\n   ---------------------------->                 ------------------>\n\
    \              QUERY\n   ---------------------------->\n       OVERWRITE\n   ------------------->\n\
    \    POSITIVE RESPONSE\n   <------------------\n   Due to the potential time for\
    \ the secured NBNS to make the\n   challenge(s), it is likely that a WACK will\
    \ be sent by the NBNS to\n   the registrant.\n   A secured NBNS will immediately\
    \ send a NEGATIVE NAME REGISTRATION\n   RESPONSE in answer to any NAME OVERWRITE\
    \ REQUESTS it may receive.\n"
- title: 15.2.3.  NAME REGISTRATION BY M NODES
  contents:
  - "15.2.3.  NAME REGISTRATION BY M NODES\n   An M node begin a name claim operation\
    \ as if the node were a B node:\n   it broadcasts a NAME REGISTRATION REQUEST\
    \ and listens for NEGATIVE\n   NAME REGISTRATION RESPONSEs.  Any NEGATIVE NAME\
    \ REGISTRATION RESPONSE\n   prevents the M node from obtaining the name and terminates\
    \ the claim\n   operation.\n   If, however, the M node does not receive any NEGATIVE\
    \ NAME\n   REGISTRATION RESPONSE, the M node must continue the claim procedure\n\
    \   as if the M node were a P node.\n   Only if both name claims were successful\
    \ does the M node acquire the\n   name.\n   The following diagram illustrates\
    \ M node name registration:\n                       M-NODE REGISTRATION PROCESS\n\
    \   <---NAME NOT IN BROADCAST AREA--> <--NAME IS IN BROADCAST AREA-->\n   REQ.\
    \ NODE                       NODE                     REQ.NODE\n             \
    \                     HOLDING\n                                   NAME\n   (BROADCAST)\
    \ REGISTER                         (BROADCAST) REGISTER\n   ------------------->\
    \                         <-------------------\n        REGISTER             \
    \                        REGISTER\n   ------------------->                   \
    \      <-------------------\n        REGISTER                        NEGATIVE\
    \ RESPONSE\n   ------------------->             ------------------------------->\n\
    \                 !                     (NODE DOES NOT HAVE THE NAME)\n    INITIATE\
    \     !\n    A P-NODE     !\n    REGISTRATION !\n                 V\n"
- title: 15.3.  NAME QUERY TRANSACTIONS
  contents:
  - "15.3.  NAME QUERY TRANSACTIONS\n   Name query transactions are initiated by end-nodes\
    \ to obtain the IP\n   address(es) and other attributes associated with a NetBIOS\
    \ name.\n"
- title: 15.3.1.  QUERY BY B NODES
  contents:
  - "15.3.1.  QUERY BY B NODES\n   The following diagram shows how B nodes go about\
    \ discovering who owns\n   a name.\n   The left half of the diagram illustrates\
    \ what happens if there are no\n   holders of the name.  In that case no responses\
    \ are received in\n   answer to the broadcast NAME QUERY REQUEST(s).\n   The right\
    \ half shows a POSITIVE NAME QUERY RESPONSE unicast by a name\n   holder in answer\
    \ to the broadcast request.  A name holder will make\n   this response to every\
    \ NAME QUERY REQUEST that it hears.  And each\n   holder acts this way.  Thus,\
    \ the node sending the request may receive\n   many responses, some duplicates,\
    \ and from many nodes.\n                         B-NODE DISCOVERY PROCESS\n  \
    \ <------NAME NOT ON NETWORK------>  <---NAME PRESENT ON NETWORK-->\n      REQ.\
    \ NODE                    NODE                     REQ.NODE\n                \
    \                  HOLDING\n                                   NAME\n       (BROADCAST)\
    \ QUERY                           (BROADCAST) QUERY\n   ---------------------->\
    \                    <---------------------\n      NAME QUERY REQUEST        \
    \                  NAME QUERY REQUEST\n   ---------------------->            \
    \        <---------------------\n           QUERY                        POSITIVE\
    \ RESPONSE\n   ---------------------->           ------------------------------>\n\
    \   Name query is generally, but not necessarily, a prelude to NetBIOS\n   session\
    \ establishment or NetBIOS datagram transmission.  However,\n   name query may\
    \ be used for other purposes.\n   A B node may elect to build a group membership\
    \ list for subsequent\n   use (e.g. for session establishment) by collecting and\
    \ saving the\n   responses.\n"
- title: 15.3.2.  QUERY BY P NODES
  contents:
  - "15.3.2.  QUERY BY P NODES\n   An NBNS answers queries from a P node with a list\
    \ of IP address and\n   other information for each owner of the name.  If there\
    \ are multiple\n   owners (i.e. if the name is a group name), the NBNS loads as\
    \ many\n   answers into the response as will fit into a UDP packet.  A\n   truncation\
    \ flag indicates whether any additional owner information\n   remains.  All the\
    \ information may be obtained by repeating the query\n   over a TCP connection.\n\
    \   The NBNS is not required to impose any order on its answer list.\n   The following\
    \ diagram shows what happens if the NBNS has no\n   information about the name:\n\
    \                      P-NODE DISCOVERY PROCESS\n            (server has no information\
    \ about the name)\n              P-NODE                            NBNS\n    \
    \                    NAME QUERY REQUEST\n                --------------------------------->\n\
    \                        NEGATIVE RESPONSE\n                <---------------------------------\n\
    \   The next diagram illustrates interaction between the end-node and the\n  \
    \ NBNS when the NBNS does have information about the name.  This\n   diagram shows,\
    \ in addition, the retransmission of the request by the\n   end-node in the absence\
    \ of a timely response.  Also shown are WACKs\n   (or temporary, intermediate\
    \ responses) sent by the NBNS to the end-\n   node:\n                     P-NODE\
    \ QUERY PROCESS\n           (server HAS information about the name)\n        P-NODE\
    \                                 NBNS\n                       NAME QUERY REQUEST\n\
    \        /---------------------------------------->\n       /\n       !      \
    \    (OPTIONAL)   WACK\n       !  <- - - - - - - - - - - - - - - - - - - -\n \
    \      !         !\n       !timer    !\n       !         ! (optional timer restart)\n\
    \       !         !\n        \\        V           QUERY\n         \\--------------------------------------->\n\
    \                              .\n                              .\n          \
    \                    .\n                            QUERY\n        /---------------------------------------->\n\
    \       /\n       !          (OPTIONAL)   WACK\n       !  <- - - - - - - - - -\
    \ - - - - - - - - - -\n       !         !\n       !timer    !\n       !      \
    \   ! (optional timer restart)\n       !         !\n        \\        V      \
    \     QUERY\n         \\--------------------------------------->\n           \
    \                   .\n                              .\n                    POSITIVE\
    \ RESPONSE\n         <-----------------------------------------\n   The following\
    \ diagram illustrates NBNS redirection.  Upon receipt of\n   a NAME QUERY REQUEST,\
    \ the NBNS redirects the client to another NBNS.\n   The client repeats the request\
    \ to the new NBNS and obtains a\n   response.  The diagram shows that response\
    \ as a POSITIVE NAME QUERY\n   RESPONSE.  However any legal NBNS response may\
    \ occur in actual\n   operation.\n                           NBNS REDIRECTION\n\
    \              P-NODE                            NBNS\n                      \
    \   NAME QUERY REQUEST\n                --------------------------------->\n \
    \                   REDIRECT NAME QUERY RESPONSE\n                <---------------------------------\n\
    \       (START FROM THE\n        VERY BEGINNING\n        USING THE ADDRESS\n \
    \       OF THE NEWLY\n        SUPPLIED NBNS.)\n                              \
    \                  NEW\n              P-NODE                            NBNS\n\
    \                         NAME QUERY REQUEST\n                --------------------------------->\n\
    \                   POSITIVE NAME QUERY RESPONSE\n                <---------------------------------\n\
    \   The next diagram shows how a P or M node tells the NBNS that the NBNS\n  \
    \ has provided incorrect information.  This procedure may begin after a\n   DATAGRAM\
    \ ERROR packet has been received or a session set-up attempt\n   has discovered\
    \ that the NetBIOS name does not exist at the\n   destination, the IP address\
    \ of which was obtained from the NBNS\n   during a prior name query transaction.\
    \  The NBNS, in this case a\n   secure NBNS, issues queries to verify whether\
    \ the information is, in\n   fact, incorrect.  The NBNS closes the transaction\
    \ by sending either a\n   POSITIVE or NEGATIVE NAME RELEASE RESPONSE, depending\
    \ on the results\n   of the verification.\n                 CORRECTING NBNS INFORMATION\
    \ BASE\n              P-NODE                            NBNS\n               \
    \        NAME RELEASE REQUEST\n                --------------------------------->\n\
    \                                                        QUERY\n             \
    \                                     ---------------->\n                    \
    \                                    QUERY\n                                 \
    \                 ---------------->\n                                      (NAME\
    \ TAKEN OFF THE DATABASE\n                                       IF NBNS FINDS\
    \ IT TO BE\n                                       INCORRECT)\n              \
    \      POSITIVE/NEGATIVE RESPONSE\n                <---------------------------------\n"
- title: 15.3.3.  QUERY BY M NODES
  contents:
  - "15.3.3.  QUERY BY M NODES\n   M node name query follows the B node pattern. \
    \ In the absence of\n   adequate results, the M node then continues by performing\
    \ a P node\n   type query.  This is shown in the following diagram:\n        \
    \               M-NODE DISCOVERY PROCESS\n   <---NAME NOT ON BROADCAST AREA-->\
    \  <--NAME IS ON BROADCAST AREA->\n   REQ. NODE                       NODE   \
    \                  REQ.NODE\n                                  HOLDING\n     \
    \                              NAME\n       (BROADCAST) QUERY                \
    \           (BROADCAST) QUERY\n   --------------------->                    <----------------------\n\
    \     NAME QUERY REQUEST                           NAME QUERY REQUEST\n   --------------------->\
    \                    <----------------------\n           QUERY               \
    \            POSITIVE RESPONSE\n   --------------------->           ------------------------------->\n\
    \                   !\n       INITIATE    !\n       A P-NODE    !\n       DISCOVERY\
    \   !\n       PROCESS     !\n                   V\n"
- title: 15.3.4.  ACQUIRE GROUP MEMBERSHIP LIST
  contents:
  - "15.3.4.  ACQUIRE GROUP MEMBERSHIP LIST\n   The entire membership of a group may\
    \ be acquired by sending a NAME\n   QUERY REQUEST to the NBNS.  The NBNS will\
    \ respond with a POSITIVE\n   NAME QUERY RESPONSE or a NEGATIVE NAME QUERY RESPONSE.\
    \  A negative\n   response completes the procedure and indicates that there are\
    \ no\n   members in the group.\n   If the positive response has the truncation\
    \ bit clear, then the\n   response contains the entire list of group members.\
    \  If the\n   truncation bit is set, then this entire procedure must be repeated,\n\
    \   but using TCP as a foundation rather than UDP.\n"
- title: 15.4.  NAME RELEASE TRANSACTIONS
  contents:
  - '15.4.  NAME RELEASE TRANSACTIONS

    '
- title: 15.4.1.  RELEASE BY B NODES
  contents:
  - "15.4.1.  RELEASE BY B NODES\n   A NAME RELEASE DEMAND contains the following\
    \ information:\n     -  NetBIOS name\n     -  The scope of the NetBIOS name\n\
    \     -  Name type: unique or group\n     -  IP address of the releasing node\n\
    \     -  Transaction ID\n   REQUESTING                                     OTHER\n\
    \   B-NODE                                         B-NODES\n                 \
    \    NAME RELEASE DEMAND\n              ---------------------------------->\n"
- title: 15.4.2.  RELEASE BY P NODES
  contents:
  - "15.4.2.  RELEASE BY P NODES\n   A NAME RELEASE REQUEST contains the following\
    \ information:\n     -  NetBIOS name\n     -  The scope of the NetBIOS name\n\
    \     -  Name type: unique or group\n     -  IP address of the releasing node\n\
    \     -  Transaction ID\n   A NAME RELEASE RESPONSE contains the following information:\n\
    \     -  NetBIOS name\n     -  The scope of the NetBIOS name\n     -  Name type:\
    \ unique or group\n     -  IP address of the releasing node\n     -  Transaction\
    \ ID\n     -  Result:\n          -  Yes: name was released\n          -  No: name\
    \ was not released, a reason code is provided\n   REQUESTING\n   P-NODE      \
    \                                   NBNS\n                     NAME RELEASE REQUEST\n\
    \              ---------------------------------->\n                     NAME\
    \ RELEASE RESPONSE\n              <---------------------------------\n"
- title: 15.4.3.  RELEASE BY M NODES
  contents:
  - "15.4.3.  RELEASE BY M NODES\n   The name release procedure of the M node is a\
    \ combination of the P\n   and B node name release procedures.  The M node first\
    \ performs the P\n   release procedure.  If the P procedure fails then the release\n\
    \   procedure does not continue, it fails.  If and only if the P\n   procedure\
    \ succeeds then the M node broadcasts the NAME RELEASE DEMAND\n   to the broadcast\
    \ area, the B procedure.\n   NOTE: An M node typically performs a B-style operation\
    \ and then a\n         P-style operation.  In this case, however, the P-style\n\
    \         operation comes first.\n   The following diagram illustrates the M node\
    \ name release procedure:\n   <-----P procedure fails-------> <-------P procedure\
    \ succeeds--->\n   REQUESTING               NBNS    REQUESTING             NBNS\n\
    \   M-NODE                           M-NODE\n       NAME RELEASE REQUEST     \
    \          NAME RELEASE REQUEST\n     -------------------------->       ------------------------>\n\
    \       NEGATIVE RELEASE RESPONSE        POSITIVE RELEASE RESPONSE\n     <--------------------------\
    \       <-------------------------\n                                         \
    \                  OTHER\n                                                   \
    \        M-NODES\n                                           NAME RELEASE DEMAND\n\
    \                                        ------------------------>\n"
- title: 15.5.  NAME MAINTENANCE TRANSACTIONS
  contents:
  - '15.5.  NAME MAINTENANCE TRANSACTIONS

    '
- title: 15.5.1.  NAME REFRESH
  contents:
  - "15.5.1.  NAME REFRESH\n   Name refresh transactions are used to handle the following\n\
    \   situations:\n      a)   An NBNS node needs to detect if a P or M node has\
    \ \"silently\"\n           gone down, so that names held by that node can be purged\n\
    \           from the data base.\n      b)   If the NBNS goes down, it needs to\
    \ be able to reconstruct\n           the data base when it comes back up.\n  \
    \    c)   If the network should be partitioned, the NBNS needs to be\n       \
    \    able to able to update its data base when the network\n           reconnects.\n\
    \   Each P or M node is responsible for sending periodic NAME REFRESH\n   REQUESTs\
    \ for each name that it has registered.  Each refresh packet\n   contains a single\
    \ name that has been successfully registered by that\n   node.  The interval between\
    \ such packets is negotiated between the\n   end node and the NBNS server at the\
    \ time that the name is initially\n   claimed.  At name claim time, an end node\
    \ will suggest a refresh\n   timeout value.  The NBNS node can modify this value\
    \ in the reply\n   packet.  A NBNS node can also choose to tell the end node to\
    \ not send\n   any refresh packet by using the \"infinite\" timeout value in the\n\
    \   response packet.  The timeout value returned by the NBNS is the\n   actual\
    \ refresh timeout that the end node must use.\n   When a node sends a NAME REFRESH\
    \ REQUEST, it must be prepared to\n   receive a negative response.  This would\
    \ happen, for example, if the\n   the NBNS discovers that the the name had already\
    \ been assigned to\n   some other node.  If such a response is received, the end\
    \ node should\n   mark the name as being in conflict.  Such an entry should be\
    \ treated\n   in the same way as if name conflict had been detected against the\n\
    \   name.  The following diagram illustrates name refresh:\n   <-----Successful\
    \ Refresh-----> <-----Unsuccessful Refresh---->\n   REFRESHING               NBNS\
    \   REFRESHING               NBNS\n   NODE                            NODE\n \
    \      NAME REFRESH REQUEST             NAME REFRESH REQUEST\n     ------------------------>\
    \        ----------------------->\n         POSITIVE RESPONSE                NEGATIVE\
    \ RESPONSE\n     <------------------------        <-----------------------\n \
    \                                   !\n                                    !\n\
    \                                    V\n                              MARK NAME\
    \ IN\n                                CONFLICT\n"
- title: 15.5.2.  NAME CHALLENGE
  contents:
  - "15.5.2.  NAME CHALLENGE\n   Name challenge is done by sending a NAME QUERY REQUEST\
    \ to an end node\n   of any type.  If a POSITIVE NAME QUERY RESPONSE is returned,\
    \ then\n   that node still owns the name.  If a NEGATIVE NAME QUERY RESPONSE is\n\
    \   received or if no response is received, it can be assumed that the\n   end\
    \ node no longer owns the name.\n   Name challenge can be performed either by\
    \ the NBNS node, or by an end\n   node.  When an end-node sends a name claim packet,\
    \ the NBNS node may\n   do the challenge operation.  The NBNS node can choose,\
    \ however, to\n   require the end node do the challenge.  In that case, the NBNS\
    \ will\n   send an END-NODE CHALLENGE RESPONSE packet to the end node, which\n\
    \   should then proceed to challenge the putative owner.\n   Note that the name\
    \ challenge procedure sends a normal NAME QUERY\n   REQUEST packet to the end\
    \ node.  It does not require a special\n   packet.  The only new packet introduced\
    \ is the END-NODE CHALLENGE\n   RESPONSE which is sent by an NBNS node when the\
    \ NBNS wants the end-\n   node to perform the challenge operation.\n"
- title: 15.5.3.  CLEAR NAME CONFLICT
  contents:
  - "15.5.3.  CLEAR NAME CONFLICT\n   It is possible during a refresh request from\
    \ a M or P node for a NBNS\n   to detects a name in conflict.  The response to\
    \ the NAME REFRESH\n   REQUEST must be a NEGATIVE NAME REGISTRATION RESPONSE.\
    \  Optionally,\n   in addition, the NBNS may send a NAME CONFLICT DEMAND or a\
    \ NAME\n   RELEASE REQUEST to the refreshing node.  The NAME CONFLICT DEMAND\n\
    \   forces the node to place the name in the conflict state.  The node\n   will\
    \ eventually inform it's user of the conflict.  The NAME RELEASE\n   REQUEST will\
    \ force the node to flush the name from its local name\n   table completely. \
    \ This forces the node to flush the name in\n   conflict.  This does not cause\
    \ termination of existing sessions using\n   this name.\n   The following diagram\
    \ shows an NBNS detecting and correcting a\n   conflict:\n   REFRESHING NODE \
    \                                NBNS\n                     NAME REFRESH REQUEST\n\
    \           ----------------------------------------->\n               NEGATIVE\
    \ NAME REGISTRATION RESPONSE\n           <-----------------------------------------\n\
    \                     NAME CONFLICT DEMAND\n           <-----------------------------------------\n\
    \                             OR\n                     NAME RELEASE REQUEST\n\
    \           <-----------------------------------------\n               POSITIVE/NEGATIVE\
    \ RELEASE REQUEST\n           ----------------------------------------->\n"
- title: 15.6.  ADAPTER STATUS TRANSACTIONS
  contents:
  - "15.6.  ADAPTER STATUS TRANSACTIONS\n   Adapter status is obtained from a node\
    \ as follows:\n      1.   Perform a name discovery operation to obtain the IP\n\
    \           addresses of a set of end-nodes.\n      2.   Repeat until all end-nodes\
    \ from the set have been used:\n           a.   Select one end-node from the set.\n\
    \           b.   Send a NODE STATUS REQUEST to that end-node using UDP.\n    \
    \       c.   Await a NODE STATUS RESPONSE.  (If a timely response is\n       \
    \         not forthcoming, repeat step \"b\" UCAST_REQ_RETRY_COUNT\n         \
    \       times.  After the last retry, go to step \"a\".)\n           d.   If the\
    \ truncation bit is not set in the response, the\n                response contains\
    \ the entire node status.  Return the\n                status to the user and\
    \ terminate this procedure.\n           e.   If the truncation bit is set in the\
    \ response, then not\n                all status was returned because it would\
    \ not fit into\n                the response packet.  The responder will set the\n\
    \                truncation bit if the IP datagram length would exceed\n     \
    \           MAX_DATAGRAM_LENGTH.  Return the status to the user and\n        \
    \        terminate this procedure.\n"
- title: 3.   Return error to user, no status obtained.
  contents:
  - "3.   Return error to user, no status obtained.\n   The repetition of step 2,\
    \ above, through all nodes of the set, is\n   optional.\n   Following is an example\
    \ transaction of a successful Adapter Status\n   operation:\n   REQUESTING NODE\
    \                                 NAME OWNER\n                       NAME QUERY\
    \ REQUEST\n           ----------------------------------------->\n           \
    \        POSITIVE NAME QUERY RESPONSE\n           <-----------------------------------------\n\
    \                       NODE STATUS REQUEST\n           ----------------------------------------->\n\
    \                      NODE STATUS RESPONSE\n           <-----------------------------------------\n"
- title: 16.  NetBIOS SESSION SERVICE
  contents:
  - "16.  NetBIOS SESSION SERVICE\n   The NetBIOS session service begins after one\
    \ or more IP addresses\n   have been found for the target name.  These addresses\
    \ may have been\n   acquired using the NetBIOS name query transactions or by other\
    \ means,\n   such as a local name table or cache.\n   NetBIOS session service\
    \ transactions, packets, and protocols are\n   identical for all end-node types.\
    \  They involve only directed\n   (point-to-point) communications.\n"
- title: 16.1.  OVERVIEW OF NetBIOS SESSION SERVICE
  contents:
  - "16.1.  OVERVIEW OF NetBIOS SESSION SERVICE\n   Session service has three phases:\n\
    \     Session establishment - it is during this phase that the IP\n        address\
    \ and TCP port of the called name is determined, and a\n        TCP connection\
    \ is established with the remote party.\n     Steady state - it is during this\
    \ phase that NetBIOS data\n        messages are exchanged over the session.  Keep-alive\
    \ packets\n        may also be exchanged if the participating nodes are so\n \
    \       configured.\n     Session close - a session is closed whenever either\
    \ a party (in\n        the session) closes the session or it is determined that\
    \ one\n        of the parties has gone down.\n"
- title: 16.1.1.  SESSION ESTABLISHMENT PHASE OVERVIEW
  contents:
  - "16.1.1.  SESSION ESTABLISHMENT PHASE OVERVIEW\n   An end-node begins establishment\
    \ of a session to another node by\n   somehow acquiring (perhaps using the name\
    \ query transactions or a\n   local cache) the IP address of the node or nodes\
    \ purported to own the\n   destination name.\n   Every end-node awaits incoming\
    \ NetBIOS session requests by listening\n   for TCP calls to a well-known service\
    \ port, SSN_SRVC_TCP_PORT.  Each\n   incoming TCP connection represents the start\
    \ of a separate NetBIOS\n   session initiation attempt.  The NetBIOS session server,\
    \ not the\n   ultimate application, accepts the incoming TCP connection(s).\n\
    \   Once the TCP connection is open, the calling node sends session\n   service\
    \ request packet.  This packet contains the following\n   information:\n     -\
    \  Calling IP address (see note)\n     -  Calling NetBIOS name\n     -  Called\
    \ IP address (see note)\n     -  Called NetBIOS name\n   NOTE: The IP addresses\
    \ are obtained from the TCP service\n         interface.\n   When the session\
    \ service request packet arrives at the NetBIOS\n   server, one of the the following\
    \ situations will exist:\n   -    There exists a NetBIOS LISTEN compatible with\
    \ the incoming\n        call and there are adequate resources to permit session\n\
    \        establishment to proceed.\n   -    There exists a NetBIOS LISTEN compatible\
    \ with the incoming\n        call, but there are inadequate resources to permit\n\
    \        establishment of a session.\n   -    The called name does, in fact, exist\
    \ on the called node, but\n        there is no pending NetBIOS LISTEN compatible\
    \ with the\n        incoming call.\n   -    The called name does not exist on\
    \ the called node.\n   In all but the first case, a rejection response is sent\
    \ back over the\n   TCP connection to the caller.  The TCP connection is then\
    \ closed and\n   the session phase terminates.  Any retry is the responsibility\
    \ of the\n   caller.  For retries in the case of a group name, the caller may\
    \ use\n   the next member of the group rather than immediately retrying the\n\
    \   instant address.  In the case of a unique name, the caller may\n   attempt\
    \ an immediate retry using the same target IP address unless\n   the called name\
    \ did not exist on the called node.  In that one case,\n   the NetBIOS name should\
    \ be re-resolved.\n   If a compatible LISTEN exists, and there are adequate resources,\
    \ then\n   the session server may transform the existing TCP connection into the\n\
    \   NetBIOS data session.  Alternatively, the session server may\n   redirect,\
    \ or \"retarget\" the caller to another TCP port (and IP\n   address).\n   If\
    \ the caller is redirected, the caller begins the session\n   establishment anew,\
    \ but using the new IP address and TCP port given\n   in the retarget response.\
    \  Again a TCP connection is created, and\n   again the calling and called node\
    \ exchange credentials.  The called\n   party may accept the call, reject the\
    \ call, or make a further\n   redirection.\n   This mechanism is based on the\
    \ presumption that, on hosts where it is\n   not possible to transfer open TCP\
    \ connections between processes, the\n   host will have a central session server.\
    \  Applications willing to\n   receive NetBIOS calls will obtain an ephemeral\
    \ TCP port number, post\n   a TCP unspecified passive open on that port, and then\
    \ pass that port\n   number and NetBIOS name information to the NetBIOS session\
    \ server\n   using a NetBIOS LISTEN operation.  When the call is placed, the\n\
    \   session server will \"retarget\" the caller to the application's TCP\n   socket.\
    \  The caller will then place a new call, directly to the\n   application.  The\
    \ application has the responsibility to mimic the\n   session server at least\
    \ to the extent of receiving the calling\n   credentials and then accepting or\
    \ rejecting the call.\n"
- title: 16.1.1.1.  RETRYING AFTER BEING RETARGETTED
  contents:
  - "16.1.1.1.  RETRYING AFTER BEING RETARGETTED\n   A calling node may find that\
    \ it can not establish a session with a\n   node to which it was directed by the\
    \ retargetting procedure.  Since\n   retargetting may be nested, there is an issue\
    \ whether the caller\n   should begin a retry at the initial starting point or\
    \ back-up to an\n   intermediate retargetting point.  The caller may use any method.\
    \  A\n   discussion of two such methods is in Appendix B, \"Retarget\n   Algorithms\"\
    .\n"
- title: 16.1.1.2.  SESSION ESTABLISHMENT TO A GROUP NAME
  contents:
  - "16.1.1.2.  SESSION ESTABLISHMENT TO A GROUP NAME\n   Session establishment with\
    \ a group name requires special\n   consideration.  When a NetBIOS CALL attempt\
    \ is made to a group name,\n   name discovery will result in a list (possibly\
    \ incomplete) of the\n   members of that group.  The calling node selects one\
    \ member from the\n   list and attempts to build a session.  If that fails, the\
    \ calling\n   node may select another member and make another attempt.\n   When\
    \ the session service attempts to make a connection with one of\n   the members\
    \ of the group, there is no guarantee that that member has\n   a LISTEN pending\
    \ against that group name, that the called node even\n   owns, or even that the\
    \ called node is operating.\n"
- title: 16.1.2.  STEADY STATE PHASE OVERVIEW
  contents:
  - "16.1.2.  STEADY STATE PHASE OVERVIEW\n   NetBIOS data messages are exchanged\
    \ in the steady state.  NetBIOS\n   messages are sent by prepending the user data\
    \ with a message header\n   and sending the header and the user data over the\
    \ TCP connection.\n   The receiver removes the header and passes the data to the\
    \ NetBIOS\n   user.\n   In order to detect failure of one of the nodes or of the\
    \ intervening\n   network, \"session keep alive\" packets may be periodically\
    \ sent in the\n   steady state.\n   Any failure of the underlying TCP connection,\
    \ whether a reset, a\n   timeout, or other failure, implies failure of the NetBIOS\
    \ session.\n"
- title: 16.1.3.  SESSION TERMINATION PHASE OVERVIEW
  contents:
  - "16.1.3.  SESSION TERMINATION PHASE OVERVIEW\n   A NetBIOS session is terminated\
    \ normally when the user requests the\n   session to be closed or when the session\
    \ service detects the remote\n   partner of the session has gracefully terminated\
    \ the TCP connection.\n   A NetBIOS session is abnormally terminated when the\
    \ session service\n   detects a loss of the connection.  Connection loss can be\
    \ detected\n   with the keep-alive function of the session service or TCP, or\
    \ on the\n   failure of a SESSION MESSAGE send operation.\n   When a user requests\
    \ to close a session, the service first attempts a\n   graceful in-band close\
    \ of the TCP connection.  If the connection does\n   not close within the SSN_CLOSE_TIMEOUT\
    \ the TCP connection is aborted.\n   No matter how the TCP connection is terminated,\
    \ the NetBIOS session\n   service always closes the NetBIOS session.\n   When\
    \ the session service receives an indication from TCP that a\n   connection close\
    \ request has been received, the TCP connection and\n   the NetBIOS session are\
    \ immediately closed and the user is informed\n   of the loss of the session.\
    \  All data received up to the close\n   indication should be delivered, if possible,\
    \ to the session's user.\n"
- title: 16.2.  SESSION ESTABLISHMENT PHASE
  contents:
  - "16.2.  SESSION ESTABLISHMENT PHASE\n   All the following diagrams assume a name\
    \ query operation was\n   successfully completed by the caller node for the listener's\
    \ name.\n   This first diagram shows the sequence of network events used to\n\
    \   successfully establish a session without retargetting by the\n   listener.\
    \  The TCP connection is first established with the well-\n   known NetBIOS session\
    \ service TCP port, SSN_SRVC_TCP_PORT.  The\n   caller then sends a SESSION REQUEST\
    \ packet over the TCP connection\n   requesting a session with the listener. \
    \ The SESSION REQUEST contains\n   the caller's name and the listener's name.\
    \  The listener responds\n   with a POSITIVE SESSION RESPONSE informing the caller\
    \ this TCP\n   connection is accepted as the connection for the data transfer\
    \ phase\n   of the session.\n           CALLER                          LISTENER\n\
    \                       TCP CONNECT\n           ====================================>\n\
    \                        TCP ACCEPT\n           <===================================\n\
    \                     SESSION REQUEST\n           ------------------------------------>\n\
    \                    POSITIVE RESPONSE\n           <-----------------------------------\n\
    \   The second diagram shows the sequence of network events used to\n   successfully\
    \ establish a session when the listener does retargetting.\n   The session establishment\
    \ procedure is the same as with the first\n   diagram up to the listener's response\
    \ to the SESSION REQUEST.  The\n   listener, divided into two sections, the listen\
    \ processor and the\n   actual listener, sends a SESSION RETARGET RESPONSE to\
    \ the caller.\n   This response states the call is acceptable, but the data transfer\n\
    \   TCP connection must be at the new IP address and TCP port.  The\n   caller\
    \ then re-iterates the session establishment process anew with\n   the new IP\
    \ address and TCP port after the initial TCP connection is\n   closed.  The new\
    \ listener then accepts this connection for the data\n   transfer phase with a\
    \ POSITIVE SESSION RESPONSE.\n           CALLER                  LISTEN PROCESSOR\
    \        LISTENER\n                   TCP CONNECT\n           =============================>\n\
    \                   TCP ACCEPT\n           <=============================\n  \
    \                 SESSION REQUEST\n           ----------------------------->\n\
    \              SESSION RETARGET RESPONSE\n           <-----------------------------\n\
    \                   TCP CLOSE\n           <=============================\n   \
    \                TCP CLOSE\n           =============================>\n      \
    \                 TCP CONNECT\n           ====================================================>\n\
    \                        TCP ACCEPT\n           <====================================================\n\
    \                     SESSION REQUEST\n           ---------------------------------------------------->\n\
    \                    POSITIVE RESPONSE\n           <----------------------------------------------------\n\
    \   The third diagram is the sequence of network events for a rejected\n   session\
    \ request with the listener.  This type of rejection could\n   occur with either\
    \ a non-retargetting listener or a retargetting\n   listener.  After the TCP connection\
    \ is established at\n   SSN_SRVC_TCP_PORT, the caller sends the SESSION REQUEST\
    \ over the TCP\n   connection.  The listener does not have either a listen pending\
    \ for\n   the listener's name or the pending NetBIOS listen is specific to\n \
    \  another caller's name.  Consequently, the listener sends a NEGATIVE\n   SESSION\
    \ RESPONSE and closes the TCP connection.\n           CALLER                 \
    \         LISTENER\n                        TCP CONNECT\n           ====================================>\n\
    \                        TCP ACCEPT\n           <===================================\n\
    \                     SESSION REQUEST\n           ------------------------------------>\n\
    \                    NEGATIVE RESPONSE\n           <-----------------------------------\n\
    \                        TCP CLOSE\n           <===================================\n\
    \                        TCP CLOSE\n           ====================================>\n\
    \   The fourth diagram is the sequence of network events when session\n   establishment\
    \ fails with a retargetting listener.  After being\n   redirected, and after the\
    \ initial TCP connection is closed the caller\n   tries to establish a TCP connection\
    \ with the new IP address and TCP\n   port.  The connection fails because either\
    \ the port is unavailable or\n   the target node is not active.  The port unavailable\
    \ race condition\n   occurs if another caller has already acquired the TCP connection\
    \ with\n   the listener.  For additional implementation suggestions, see\n   Appendix\
    \ B, \"Retarget Algorithms\".\n           CALLER                  LISTEN PROCESSOR\
    \        LISTENER\n                   TCP CONNECT\n           =============================>\n\
    \                   TCP ACCEPT\n           <=============================\n  \
    \                 SESSION REQUEST\n           ----------------------------->\n\
    \                   REDIRECT RESPONSE\n           <-----------------------------\n\
    \                   TCP CLOSE\n           <=============================\n   \
    \                TCP CLOSE\n           =============================>\n      \
    \                 TCP CONNECT\n           ====================================================>\n\
    \                     CONNECTION REFUSED OR TIMED OUT\n           <===================================================\n"
- title: 16.3.  SESSION DATA TRANSFER PHASE
  contents:
  - '16.3.  SESSION DATA TRANSFER PHASE

    '
- title: 16.3.1.  DATA ENCAPSULATION
  contents:
  - "16.3.1.  DATA ENCAPSULATION\n   NetBIOS messages are exchanged in the steady\
    \ state.  Messages are\n   sent by prepending user data with message header and\
    \ sending the\n   header and the user data over the TCP connection.  The receiver\n\
    \   removes the header and delivers the NetBIOS data to the user.\n"
- title: 16.3.2.  SESSION KEEP-ALIVES
  contents:
  - "16.3.2.  SESSION KEEP-ALIVES\n   In order to detect node failure or network partitioning,\
    \ \"session\n   keep alive\" packets are periodically sent in the steady state.\
    \  A\n   session keep alive packet is discarded by a peer node.\n   A session\
    \ keep alive timer is maintained for each session.  This\n   timer is reset whenever\
    \ any data is sent to, or received from, the\n   session peer.  When the timer\
    \ expires, a NetBIOS session keep-alive\n   packet is sent on the TCP connection.\
    \  Sending the keep-alive packet\n   forces data to flow on the TCP connection,\
    \ thus indirectly causing\n   TCP to detect whether the connection is still active.\n\
    \   Since many TCP implementations provide a parallel TCP \"keep- alive\"\n  \
    \ mechanism, the NetBIOS session keep-alive is made a configurable\n   option.\
    \  It is recommended that the NetBIOS keep- alive mechanism be\n   used only in\
    \ the absence of TCP keep-alive.\n   Note that unlike TCP keep alives, NetBIOS\
    \ session keep alives do not\n   require a response from the NetBIOS peer -- the\
    \ fact that it was\n   possible to send the NetBIOS session keep alive is sufficient\n\
    \   indication that the peer, and the connection to it, are still active.\n  \
    \ The only requirement for interoperability is that when a session keep\n   alive\
    \ packet is received, it should be discarded.\n"
- title: 17.  NETBIOS DATAGRAM SERVICE
  contents:
  - '17.  NETBIOS DATAGRAM SERVICE

    '
- title: 17.1.  OVERVIEW OF NetBIOS DATAGRAM SERVICE
  contents:
  - "17.1.  OVERVIEW OF NetBIOS DATAGRAM SERVICE\n   Every NetBIOS datagram has a\
    \ named destination and source.  To\n   transmit a NetBIOS datagram, the datagram\
    \ service must perform a name\n   query operation to learn the IP address and\
    \ the attributes of the\n   destination NetBIOS name.  (This information may be\
    \ cached to avoid\n   the overhead of name query on subsequent NetBIOS datagrams.)\n\
    \   NetBIOS datagrams are carried within UDP packets.  If a NetBIOS\n   datagram\
    \ is larger than a single UDP packet, it may be fragmented\n   into several UDP\
    \ packets.\n   End-nodes may receive NetBIOS datagrams addressed to names not\
    \ held\n   by the receiving node.  Such datagrams should be discarded.  If the\n\
    \   name is unique then a DATAGRAM ERROR packet is sent to the source of\n   that\
    \ NetBIOS datagram.\n"
- title: 17.1.1.  UNICAST, MULTICAST, AND BROADCAST
  contents:
  - "17.1.1.  UNICAST, MULTICAST, AND BROADCAST\n   NetBIOS datagrams may be unicast,\
    \ multicast, or broadcast.  A NetBIOS\n   datagram addressed to a unique NetBIOS\
    \ name is unicast.  A NetBIOS\n   datatgram addressed to a group NetBIOS name,\
    \ whether there are zero,\n   one, or more actual members, is multicast.  A NetBIOS\
    \ datagram sent\n   using the NetBIOS \"Send Broadcast Datagram\" primitive is\
    \ broadcast.\n"
- title: 17.1.2.  FRAGMENTATION OF NetBIOS DATAGRAMS
  contents:
  - "17.1.2.  FRAGMENTATION OF NetBIOS DATAGRAMS\n   When the header and data of a\
    \ NetBIOS datagram exceeds the maximum\n   amount of data allowed in a UDP packet,\
    \ the NetBIOS datagram must be\n   fragmented before transmission and reassembled\
    \ upon receipt.\n   A NetBIOS Datagram is composed of the following protocol elements:\n\
    \     -  IP header of 20 bytes (minimum)\n     -  UDP header of 8 bytes\n    \
    \ -  NetBIOS Datagram Header of 14 bytes\n     -  The NetBIOS Datagram data.\n\
    \   The NetBIOS Datagram data section is composed of 3 parts:\n     -  Source\
    \ NetBIOS name (255 bytes maximum)\n     -  Destination NetBIOS name (255 bytes\
    \ maximum)\n     -  The NetBIOS user's data (maximum of 512 bytes)\n   The two\
    \ name fields are in second level encoded format (see section\n   14.)\n   A maximum\
    \ size NetBIOS datagram is 1064 bytes.  The minimal maximum\n   IP datagram size\
    \ is 576 bytes.  Consequently, a NetBIOS Datagram may\n   not fit into a single\
    \ IP datagram.  This makes it necessary to permit\n   the fragmentation of NetBIOS\
    \ Datagrams.\n   On networks meeting or exceeding the minimum IP datagram length\n\
    \   requirement of 576 octets, at most two NetBIOS datagram fragments\n   will\
    \ be generated.  The protocols and packet formats accommodate\n   fragmentation\
    \ into three or more parts.\n   When a NetBIOS datagram is fragmented, the IP,\
    \ UDP and NetBIOS\n   Datagram headers are present in each fragment.  The NetBIOS\
    \ Datagram\n   data section is split among resulting UDP datagrams.  The data\n\
    \   sections of NetBIOS datagram fragments do not overlap. The only\n   fields\
    \ of the NetBIOS Datagram header that would vary are the FLAGS\n   and OFFSET\
    \ fields.\n   The FIRST bit in the FLAGS field indicate whether the fragment is\
    \ the\n   first in a sequence of fragments.  The MORE bit in the FLAGS field\n\
    \   indicates whether other fragments follow.\n   The OFFSET field is the byte\
    \ offset from the beginning of the NetBIOS\n   datagram data section to the first\
    \ byte of the data section in a\n   fragment.  It is 0 for the first fragment.\
    \  For each subsequent\n   fragment, OFFSET is the sum of the bytes in the NetBIOS\
    \ data sections\n   of all preceding fragments.\n   If the NetBIOS datagram was\
    \ not fragmented:\n     -  FIRST = TRUE\n     -  MORE = FALSE\n     -  OFFSET\
    \ = 0\n   If the NetBIOS datagram was fragmented:\n     -  First fragment:\n \
    \         -  FIRST = TRUE\n          -  MORE = TRUE\n          -  OFFSET = 0\n\
    \     -  Intermediate fragments:\n          -  FIRST = FALSE\n          -  MORE\
    \ = TRUE\n          -  OFFSET = sum(NetBIOS data in prior fragments)\n     - \
    \ Last fragment:\n          -  FIRST = FALSE\n          -  MORE = FALSE\n    \
    \      -  OFFSET = sum(NetBIOS data in prior fragments)\n   The relative position\
    \ of intermediate fragments may be ascertained\n   from OFFSET.\n   An NBDD must\
    \ remember the destination name of the first fragment in\n   order to relay the\
    \ subsequent fragments of a single NetBIOS datagram.\n   The name information\
    \ can be associated with the subsequent fragments\n   through the transaction\
    \ ID, DGM_ID, and the SOURCE_IP, fields of the\n   packet.  This information can\
    \ be purged by the NBDD after the last\n   fragment has been processed or FRAGMENT_TO\
    \ time has expired since the\n   first fragment was received.\n"
- title: 17.2.  NetBIOS DATAGRAMS BY B NODES
  contents:
  - "17.2.  NetBIOS DATAGRAMS BY B NODES\n   For NetBIOS datagrams with a named destination\
    \ (i.e. non- broadcast),\n   a B node performs a name discovery for the destination\
    \ name before\n   sending the datagram.  (Name discovery may be bypassed if information\n\
    \   from a previous discovery is held in a cache.)  If the name type\n   returned\
    \ by name discovery is UNIQUE, the datagram is unicast to the\n   sole owner of\
    \ the name.  If the name type is GROUP, the datagram is\n   broadcast to the entire\
    \ broadcast area using the destination IP\n   address BROADCAST_ADDRESS.\n   A\
    \ receiving node always filters datagrams based on the destination\n   name. \
    \ If the destination name is not owned by the node or if no\n   RECEIVE DATAGRAM\
    \ user operations are pending for the name, then the\n   datagram is discarded.\
    \  For datagrams with a UNIQUE name destination,\n   if the name is not owned\
    \ by the node then the receiving node sends a\n   DATAGRAM ERROR packet.  The\
    \ error packet originates from the\n   DGM_SRVC_UDP_PORT and is addressed to the\
    \ SOURCE_IP and SOURCE_PORT\n   from the bad datagram.  The receiving node quietly\
    \ discards datagrams\n   with a GROUP name destination if the name is not owned\
    \ by the node.\n   Since broadcast NetBIOS datagrams do not have a named destination,\n\
    \   the B node sends the DATAGRAM SERVICE packet(s) to the entire\n   broadcast\
    \ area using the destination IP address BROADCAST_ADDRESS.\n   In order for the\
    \ receiving nodes to distinguish this datagram as a\n   broadcast NetBIOS datagram,\
    \ the NetBIOS name used as the destination\n   name is '*' (hexadecimal 2A) followed\
    \ by 15 bytes of hexidecimal 00.\n   The NetBIOS scope identifier is appended\
    \ to the name before it is\n   converted into second-level encoding.  For example,\
    \ if the scope\n   identifier is \"NETBIOS.SCOPE\" then the first-level encoded\
    \ name would\n   be:\n        CKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.NETBIOS.SCOPE\n\
    \   According to [2], a user may not provide a NetBIOS name beginning\n   with\
    \ \"*\".\n   For each node in the broadcast area that receives the NetBIOS\n \
    \  broadcast datagram, if any RECEIVE BROADCAST DATAGRAM user operations\n   are\
    \ pending then the data from the NetBIOS datagram is replicated and\n   delivered\
    \ to each.  If no such operations are pending then the node\n   silently discards\
    \ the datagram.\n"
- title: 17.3.  NetBIOS DATAGRAMS BY P AND M NODES
  contents:
  - "17.3.  NetBIOS DATAGRAMS BY P AND M NODES\n   P and M nodes do not use IP broadcast\
    \ to distribute NetBIOS\n   datagrams.\n   Like B nodes, P and M nodes must perform\
    \ a name discovery or use\n   cached information to learn whether a destination\
    \ name is a group or\n   a unique name.\n   Datagrams to unique names are unicast\
    \ directly to the destination by\n   P and M nodes, exactly as they are by B nodes.\n\
    \   Datagrams to group names and NetBIOS broadcast datagrams are unicast\n   to\
    \ the NBDD.  The NBDD then relays the datagrams to each of the nodes\n   specified\
    \ by the destination name.\n   An NBDD may not be capable of sending a NetBIOS\
    \ datagram to a\n   particular NetBIOS name, including the broadcast NetBIOS name\
    \ (\"*\")\n   defined above.  A query mechanism is available to the end- node\
    \ to\n   determine if a NBDD will be able to relay a datagram to a given name.\n\
    \   Before a datagram, or its fragments, are sent to the NBDD the P or M\n   node\
    \ may send a DATAGRAM QUERY REQUEST packet to the NBDD with the\n   DESTINATION_NAME\
    \ from the DATAGRAM SERVICE packet(s).  The NBDD will\n   respond with a DATAGRAM\
    \ POSITIVE QUERY RESPONSE if it will relay\n   datagrams to the specified destination\
    \ name.  After a positive\n   response the end-node unicasts the datagram to the\
    \ NBDD.  If the NBDD\n   will not be able to relay a datagram to the destination\
    \ name\n   specified in the query, a DATAGRAM NEGATIVE QUERY RESPONSE packet is\n\
    \   returned.  If the NBDD can not distribute a datagram, the end-node\n   then\
    \ has the option of getting the name's owner list from the NBNS\n   and sending\
    \ the datagram directly to each of the owners.\n   An NBDD must be able to respond\
    \ to DATAGRAM QUERY REQUEST packets.\n   The response may always be positive.\
    \  However, the usage or\n   implementation of the query mechanism by a P or M\
    \ node is optional.\n   An implementation may always unicast the NetBIOS datagram\
    \ to the NBDD\n   without asking if it will be relayed.  Except for the datagram\
    \ query\n   facility described above, an NBDD provides no feedback to indicate\n\
    \   whether it forwarded a datagram.\n"
- title: 18.  NODE CONFIGURATION PARAMETERS
  contents:
  - "18.  NODE CONFIGURATION PARAMETERS\n     -  B NODES:\n          -  Node's permanent\
    \ unique name\n          -  Whether IGMP is in use\n          -  Broadcast IP\
    \ address to use\n          -  Whether NetBIOS session keep-alives are needed\n\
    \          -  Usable UDP data field length (to control fragmentation)\n     -\
    \  P NODES:\n          -  Node's permanent unique name\n          -  IP address\
    \ of NBNS\n          -  IP address of NBDD\n          -  Whether NetBIOS session\
    \ keep-alives are needed\n          -  Usable UDP data field length (to control\
    \ fragmentation)\n     -  M NODES:\n          -  Node's permanent unique name\n\
    \          -  Whether IGMP is in use\n          -  Broadcast IP address to use\n\
    \          -  IP address of NBNS\n          -  IP address of NBDD\n          -\
    \  Whether NetBIOS session keep-alives are needed\n          -  Usable UDP data\
    \ field length (to control fragmentation)\n"
- title: 19.  MINIMAL CONFORMANCE
  contents:
  - "19.  MINIMAL CONFORMANCE\n   To ensure multi-vendor interoperability, a minimally\
    \ conforming\n   implementation based on this specification must observe the following\n\
    \   rules:\n   a)   A node designed to work only in a broadcast area must\n  \
    \      conform to the B node specification.\n   b)   A node designed to work only\
    \ in an internet must conform to\n        the P node specification.\n"
- title: REFERENCES
  contents:
  - "REFERENCES\n      [1]  \"Protocol Standard For a NetBIOS Service on a TCP/UDP\n\
    \           Transport: Detailed Specifications\", RFC 1002, March 1987.\n    \
    \  [2]  IBM Corp., \"IBM PC Network Technical Reference Manual\", No.\n      \
    \     6322916, First Edition, September 1984.\n      [3]  J. Postel (Ed.), \"\
    Transmission Control Protocol\", RFC 793,\n           September 1981.\n      [4]\
    \  MIL-STD-1778\n      [5]  J. Postel, \"User Datagram Protocol\", RFC 768, 28\
    \ August\n           1980.\n      [6]  J. Reynolds, J. Postel, \"Assigned Numbers\"\
    , RFC 990,\n           November 1986.\n      [7]  J.  Postel, \"Internet Protocol\"\
    , RFC 791, September 1981.\n      [8]  J. Mogul, \"Internet Subnets\", RFC 950,\
    \ October 1984\n      [9]  J.  Mogul, \"Broadcasting Internet Datagrams in the\
    \ Presence\n           of Subnets\", RFC 922, October 1984.\n      [10] J.  Mogul,\
    \ \"Broadcasting Internet Datagrams\", RFC 919,\n           October 1984.\n  \
    \    [11] P. Mockapetris, \"Domain Names - Concepts and Facilities\",\n      \
    \     RFC 882, November 1983.\n      [12] P. Mockapetris, \"Domain Names - Implementation\
    \ and\n           Specification\", RFC 883, November 1983.\n      [13] P. Mockapetris,\
    \ \"Domain System Changes and Observations\",\n           RFC 973, January 1986.\n\
    \      [14] C. Partridge, \"Mail Routing and the Domain System\", RFC 974,\n \
    \          January 1986.\n      [15] S. Deering, D. Cheriton, \"Host Groups: A\
    \ Multicast Extension\n           to the Internet Protocol\", RFC 966, December\
    \ 1985.\n      [16] S. Deering, \"Host Extensions for IP Multicasting\", RFC 988,\n\
    \           July 1986.\n"
- title: APPENDIX A
  contents:
  - "APPENDIX A\n   This appendix contains supporting technical discussions.  It is\
    \ not\n   an integral part of the NetBIOS-over-TCP specification.\n   INTEGRATION\
    \ WITH INTERNET GROUP MULTICASTING\n   The Netbios-over-TCP system described in\
    \ this RFC may be easily\n   integrated with the Internet Group Multicast system\
    \ now being\n   developed for the internet.\n   In the main body of the RFC, the\
    \ notion of a broadcast area was\n   considered to be a single MAC-bridged \"\
    B-LAN\".  However, the\n   protocols defined will operate over an extended broadcast\
    \ area\n   resulting from the creation of a permanent Internet Multicast Group.\n\
    \   Each separate broadcast area would be based on a separate permanent\n   Internet\
    \ Multicast Group.  This multicast group address would be used\n   by B and M\
    \ nodes as their BROADCAST_ADDRESS.\n   In order to base the broadcast area on\
    \ a multicast group certain\n   additional procedures are required and certain\
    \ constraints must be\n   met.\n"
- title: A-1.  ADDITIONAL PROTOCOL REQUIRED IN B AND M NODES
  contents:
  - "A-1.  ADDITIONAL PROTOCOL REQUIRED IN B AND M NODES\n   All B or M nodes operating\
    \ on an IGMP based broadcast area must have\n   IGMP support in their IP layer\
    \ software.  These nodes must perform an\n   IGMP join operation to enter the\
    \ IGMP group before engaging in\n   NetBIOS activity.\n"
- title: A-2.  CONSTRAINTS
  contents:
  - "A-2.  CONSTRAINTS\n   Broadcast Areas may overlap.  For this reason, end-nodes\
    \ must be\n   careful to examine the NetBIOS scope identifiers in all received\n\
    \   broadcast packets.\n   The NetBIOS broadcast protocols were designed for a\
    \ network that\n   exhibits a low average transit time and low rate of packet\
    \ loss.  An\n   IGMP based broadcast area must exhibit these characteristics.\
    \  In\n   practice this will tend to constrain IGMP broadcast areas to a campus\n\
    \   of networks interconnected by high-speed routers and inter-router\n   links.\
    \  It is unlikely that transcontinental broadcast areas would\n   exhibit the\
    \ required characteristics.\n"
- title: APPENDIX B
  contents:
  - "APPENDIX B\n   This appendix contains supporting technical discussions.  It is\
    \ not\n   an integral part of the NetBIOS-over-TCP specification.\n"
- title: IMPLEMENTATION CONSIDERATIONS
  contents:
  - 'IMPLEMENTATION CONSIDERATIONS

    '
- title: B-1.  IMPLEMENTATION MODELS
  contents:
  - "B-1.  IMPLEMENTATION MODELS\n   On any participating system, there must be some\
    \ sort of NetBIOS\n   Service to coordinate access by NetBIOS applications on\
    \ that system.\n   To analyze the impact of the NetBIOS-over-TCP architecture,\
    \ we use\n   the following three models of how a NetBIOS service might be\n  \
    \ implemented:\n   1.   Combined Service and Application Model\n        The NetBIOS\
    \ service and application are both contained\n        within a single process.\
    \  No interprocess communication is\n        assumed within the system; all communication\
    \ is over the\n        network.  If multiple applications require concurrent access\n\
    \        to the NetBIOS service, they must be folded into this\n        monolithic\
    \ process.\n   2.   Common Kernel Element Model\n        The NetBIOS Service is\
    \ part of the operating system (perhaps\n        as a device driver or a front-end\
    \ processor).  The NetBIOS\n        applications are normal operating system application\n\
    \        processes.  The common element NetBIOS service contains all\n       \
    \ the information, such as the name and listen tables,\n        required to co-ordinate\
    \ the activities of the applications.\n   3.   Non-Kernel Common Element Model\n\
    \        The NetBIOS Service is implemented as an operating system\n        application\
    \ process.  The NetBIOS applications are other\n        operating system application\
    \ processes.  The service and the\n        applications exchange data via operating\
    \ system interprocess\n        communication.  In a multi-processor (e.g.  network)\n\
    \        operating system, each module may reside on a different cpu.\n      \
    \  The NetBIOS service process contains all the shared\n        information required\
    \ to coordinate the activities of the\n        NetBIOS applications.  The applications\
    \ may still require a\n        subroutine library to facilitate access to the\
    \ NetBIOS\n        service.\n   For any of the implementation models, the TCP/IP\
    \ service can be\n   located in the operating system or split among the NetBIOS\n\
    \   applications and the NetBIOS service processes.\n"
- title: B-1.1  MODEL INDEPENDENT CONSIDERATIONS
  contents:
  - "B-1.1  MODEL INDEPENDENT CONSIDERATIONS\n   The NetBIOS name service associates\
    \ a NetBIOS name with a host.  The\n   NetBIOS session service further binds the\
    \ name to a specific TCP port\n   for the duration of the session.\n   The name\
    \ service does not need to be informed of every Listen\n   initiation and completion.\
    \  Since the names are not bound to any TCP\n   port in the name service, the\
    \ session service may use a different tcp\n   port for each session established\
    \ with the same local name.\n   The TCP port used for the data transfer phase\
    \ of a NetBIOS session\n   can be globally well-known, locally well-known, or\
    \ ephemeral.  The\n   choice is a local implementation issue.  The RETARGET mechanism\n\
    \   allows the binding of the NetBIOS session to a TCP connection to any\n   TCP\
    \ port, even to another IP node.\n   An implementation may use the session service's\
    \ globally well- known\n   TCP port for the data transfer phase of the session\
    \ by not using the\n   RETARGET mechanism and, rather, accepting the session on\
    \ the initial\n   TCP connection.  This is permissible because the caller always\
    \ uses\n   an ephemeral TCP port.\n   The complexity of the called end RETARGET\
    \ mechanism is only required\n   if a particular implementation needs it.  For\
    \ many real system\n   environments, such as an in-kernel NetBIOS service implementation,\
    \ it\n   will not be necessary to retarget incoming calls.  Rather, all\n   NetBIOS\
    \ sessions may be multiplexed through the single, well-known,\n   NetBIOS session\
    \ service port.  These implementations will not be\n   burdened by the complexity\
    \ of the RETARGET mechanism, nor will their\n   callers be required to jump through\
    \ the retargetting hoops.\n   Nevertheless, all callers must be ready to process\
    \ all possible\n   SESSION RETARGET RESPONSEs.\n"
- title: B-1.2  SERVICE OPERATION FOR EACH MODEL
  contents:
  - "B-1.2  SERVICE OPERATION FOR EACH MODEL\n   It is possible to construct a NetBIOS\
    \ service based on this\n   specification for each of the above defined implementation\
    \ models.\n   For the common kernel element model, all the NetBIOS services, name,\n\
    \   datagram, and session, are simple.  All the information is contained\n   within\
    \ a single entity and can therefore be accessed or modified\n   easily.  A single\
    \ port or multiple ports for the NetBIOS sessions can\n   be used without adding\
    \ any significant complexity to the session\n   establishment procedure.  The\
    \ only penalty is the amount of overhead\n   incurred to get the NetBIOS messages\
    \ and operation requests/responses\n   through the user and operating system boundary.\n\
    \   The combined service and application model is very similar to the\n   common\
    \ kernel element model in terms of its requirements on the\n   NetBIOS service.\
    \  The major difficulty is the internal coordination\n   of the multiple NetBIOS\
    \ service and application processes existing in\n   a system of this type.\n \
    \  The NetBIOS name, datagram and session protocols assume that the\n   entities\
    \ at the end-points have full control of the various well-\n   known TCP and UDP\
    \ ports.  If an implementation has multiple NetBIOS\n   service entities, as would\
    \ be the case with, for example, multiple\n   applications each linked into a\
    \ NetBIOS library, then that\n   implementation must impose some internal coordination.\n\
    \   Alternatively, use of the NetBIOS ports could be periodically\n   assigned\
    \ to one application or another.\n   For the typical non-kernel common element\
    \ mode implementation, three\n   permanent system-wide NetBIOS service processes\
    \ would exist:\n     -  The name server\n     -  the datagram server\n     - \
    \ and session server\n   Each server would listen for requests from the network\
    \ on a UDP or\n   TCP well-known port.  Each application would have a small piece\
    \ of\n   the NetBIOS service built-in, possibly a library.  Each application's\n\
    \   NetBIOS support library would need to send a message to the\n   particular\
    \ server to request an operation, such as add name or send a\n   datagram or set-up\
    \ a listen.\n   The non-kernel common element model does not require a TCP connection\n\
    \   be passed between the two processes, session server and application.\n   The\
    \ RETARGET operation for an active NetBIOS Listen could be used by\n   the session\
    \ server to redirect the session to another TCP connection\n   on a port allocated\
    \ and owned by the application's NetBIOS support\n   library.  The application\
    \ with either a built-in or a kernel-based\n   TCP/IP service could then accept\
    \ the RETARGETed connection request\n   and process it independently of the session\
    \ server.\n   On Unix(tm) or POSIX(tm), the NetBIOS session server could create\n\
    \   sub-processes for incoming connections.  The open sessions would be\n   passed\
    \ through \"fork\" and \"exec\" to the child as an open file\n   descriptor. \
    \ This approach is very limited, however.  A pre- existing\n   process could not\
    \ receive an incoming call.  And all call-ed\n   processes would have to be sub-processes\
    \ of the session server.\n"
- title: B-2.  CASUAL AND RESTRICTED NetBIOS APPLICATIONS
  contents:
  - "B-2.  CASUAL AND RESTRICTED NetBIOS APPLICATIONS\n   Because NetBIOS was designed\
    \ to operate in the open system\n   environment of the typical personal computer,\
    \ it does not have the\n   concept of privileged or unprivileged applications.\
    \  In many multi-\n   user or multi-tasking operating systems applications are\
    \ assigned\n   privilege capabilities.  These capabilities limit the applications\n\
    \   ability to acquire and use system resources.  For these systems it is\n  \
    \ important to allow casual applications, those with limited system\n   privileges,\
    \ and privileged applications, those with 'super-user'\n   capabilities but access\
    \ to them and their required resources is\n   restricted, to access NetBIOS services.\
    \  It is also important to\n   allow a systems administrator to restrict certain\
    \ NetBIOS resources\n   to a particular NetBIOS application.  For example, a file\
    \ server\n   based on the NetBIOS services should be able to have names and TCP\n\
    \   ports for sessions only it can use.\n   A NetBIOS application needs at least\
    \ two local resources to\n   communicate with another NetBIOS application, a NetBIOS\
    \ name for\n   itself and, typically, a session.  A NetBIOS service cannot require\n\
    \   that NetBIOS applications directly use privileged system resources.\n   For\
    \ example, many systems require privilege to use TCP and UDP ports\n   with numbers\
    \ less than 1024.  This RFC requires reserved ports for\n   the name and session\
    \ servers of a NetBIOS service implementation.  It\n   does not require the application\
    \ to have direct access these reserved\n   ports.\n   For the name service, the\
    \ manager of the local name table must have\n   access to the NetBIOS name service's\
    \ reserved UDP port.  It needs to\n   listen for name service UDP packets to defend\
    \ and define its local\n   names to the network.  However, this manager need not\
    \ be a part of a\n   user application in a system environment which has privilege\n\
    \   restrictions on reserved ports.\n   The internal name server can require certain\
    \ privileges to add,\n   delete, or use a certain name, if an implementer wants\
    \ the\n   restriction.  This restriction is independent of the operation of the\n\
    \   NetBIOS service protocols and would not necessarily prevent the\n   interoperation\
    \ of that implementation with another implementation.\n   The session server is\
    \ required to own a reserved TCP port for session\n   establishment.  However,\
    \ the ultimate TCP connection used to transmit\n   and receive data does not have\
    \ to be through that reserved port.  The\n   RETARGET procedure the NetBIOS session\
    \ to be shifted to another TCP\n   connection, possibly through a different port\
    \ at the called end.\n   This port can be an unprivileged resource, with a value\
    \ greater than\n   1023.  This facilitates casual applications.\n   Alternately,\
    \ the RETARGET mechanism allows the TCP port used for data\n   transmission and\
    \ reception to be a reserved port.  Consequently, an\n   application wishing to\
    \ have access to its ports maintained by the\n   system administrator can use\
    \ these restricted TCP ports.  This\n   facilitates privileged applications.\n\
    \   A particular implementation may wish to require further special\n   privileges\
    \ for session establishment, these could be associated with\n   internal information.\
    \  It does not have to be based solely on TCP\n   port allocation.  For example,\
    \ a given NetBIOS name may only be used\n   for sessions by applications with\
    \ a certain system privilege level.\n   The decision to use reserved or unreserved\
    \ ports or add any\n   additional name registration and usage authorization is\
    \ a purely\n   local implementation decision.  It is not required by the NetBIOS\n\
    \   protocols specified in the RFC.\n"
- title: B-3.  TCP VERSUS SESSION KEEP-ALIVES
  contents:
  - "B-3.  TCP VERSUS SESSION KEEP-ALIVES\n   The KEEP-ALIVE is a protocol element\
    \ used to validate the existence\n   of a connection.  A packet is sent to the\
    \ remote connection partner\n   to solicit a response which shows the connection\
    \ is still\n   functioning.  TCP KEEP-ALIVES are used at the TCP level on TCP\n\
    \   connections while session KEEP-ALIVES are used on NetBIOS sessions.\n   These\
    \ protocol operations are always transparent to the connection\n   user.  The\
    \ user will only find out about a KEEP-ALIVE operation if it\n   fails, therefore,\
    \ if the connection is lost.\n   The NetBIOS specification[2] requires the NetBIOS\
    \ service to inform\n   the session user if a session is lost when it is in a\
    \ passive or\n   active state.  Therefore,if the session user is only waiting\
    \ for a\n   receive operation and the session is dropped the NetBIOS service must\n\
    \   inform the session user.  It cannot wait for a session send operation\n  \
    \ before it informs the user of the loss of the connection.\n   This requirement\
    \ stems from the management of scarce or volatile\n   resources by a NetBIOS application.\
    \  If a particular user terminates\n   a session with a server application by\
    \ destroying the client\n   application or the NetBIOS service without a NetBIOS\
    \ Hang Up, the\n   server application will want to clean-up or free allocated\
    \ resources.\n   This server application if it only receives and then sends a\
    \ response\n   requires the notification of the session abort in the passive state.\n\
    \   The standard definition of a TCP service cannot detect loss of a\n   connection\
    \ when it is in a passive state, waiting for a packet to\n   arrive.  Some TCP\
    \ implementations have added a KEEP-ALIVE operation\n   which is interoperable\
    \ with implementations without this feature.\n   These implementations send a\
    \ packet with an invalid sequence number\n   to the connection partner.  The partner,\
    \ by specification, must\n   respond with a packet showing the correct sequence\
    \ number of the\n   connection.  If no response is received from the remote partner\n\
    \   within a certain time interval then the TCP service assumes the\n   connection\
    \ is lost.\n   Since many TCP implementations do not have this KEEP-ALIVE function\n\
    \   an optional NetBIOS KEEP-ALIVE operation has been added to the\n   NetBIOS\
    \ session protocols.  The NetBIOS KEEP-ALIVE uses the\n   properties of TCP to\
    \ solicit a response from the remote connection\n   partner.  A NetBIOS session\
    \ message called KEEP-ALIVE is sent to the\n   remote partner.  Since this results\
    \ in TCP sending an IP packet to\n   the remote partner, the TCP connection is\
    \ active.  TCP will discover\n   if the TCP connection is lost if the remote TCP\
    \ partner does not\n   acknowledge the IP packet.  Therefore, the NetBIOS session\
    \ service\n   does not send a response to a session KEEP ALIVE message.  It just\n\
    \   throws it away.  The NetBIOS session service that transmits the KEEP\n   ALIVE\
    \ is informed only of the failure of the TCP connection.  It does\n   not wait\
    \ for a specific response message.\n   A particular NetBIOS implementation should\
    \ use KEEP-ALIVES if it is\n   concerned with maintaining compatibility with the\
    \ NetBIOS interface\n   specification[2].  Compatibility is especially important\
    \ if the\n   implementation wishes to support existing NetBIOS applications, which\n\
    \   typically require the session loss detection on their servers, or\n   future\
    \ applications which were developed for implementations with\n   session loss\
    \ detection.\n"
- title: B-4.  RETARGET ALGORITHMS
  contents:
  - "B-4.  RETARGET ALGORITHMS\n   This section contains 2 suggestions for RETARGET\
    \ algorithms.  They\n   are called the \"straight\" and \"stack\" methods.  The\
    \ algorithm in the\n   body of the RFC uses the straight method.  Implementation\
    \ of either\n   algorithm must take into account the Session establishment maximum\n\
    \   retry count.  The retry count is the maximum number of TCP connect\n   operations\
    \ allowed before a failure is reported.\n   The straight method forces the session\
    \ establishment procedure to\n   begin a retry after a retargetting failure with\
    \ the initial node\n   returned from the name discovery procedure.  A retargetting\
    \ failure\n   is when a TCP connection attempt fails because of a time- out or\
    \ a\n   NEGATIVE SESSION RESPONSE is received with an error code specifying\n\
    \   NOT LISTENING ON CALLED NAME.  If any other failure occurs the\n   session\
    \ establishment procedure should retry from the call to the\n   name discovery\
    \ procedure.\n   A minimum of 2 retries, either from a retargetting or a name\n\
    \   discovery failure.  This will give the session service a chance to\n   re-establish\
    \ a NetBIOS Listen or, more importantly, allow the NetBIOS\n   scope, local name\
    \ service or the NBNS, to re-learn the correct IP\n   address of a NetBIOS name.\n\
    \   The stack method operates similarly to the straight method.  However,\n  \
    \ instead of retrying at the initial node returned by the name\n   discovery procedure,\
    \ it restarts with the IP address of the last node\n   which sent a SESSION RETARGET\
    \ RESPONSE prior to the retargetting\n   failure.  To limit the stack method,\
    \ any one host can only be tried a\n   maximum of 2 times.\n"
- title: B-5.  NBDD SERVICE
  contents:
  - "B-5.  NBDD SERVICE\n   If the NBDD does not forward datagrams then don't provide\
    \ Group and\n   Broadcast NetBIOS datagram services to the NetBIOS user.  Therefore,\n\
    \   ignore the implementation of the query request and, when get a\n   negative\
    \ response, acquiring the membership list of IP addresses and\n   sending the\
    \ datagram as a unicast to each member.\n"
- title: B-6.  APPLICATION CONSIDERATIONS
  contents:
  - 'B-6.  APPLICATION CONSIDERATIONS

    '
- title: B-6.1  USE OF NetBIOS DATAGRAMS
  contents:
  - "B-6.1  USE OF NetBIOS DATAGRAMS\n   Certain existing NetBIOS applications use\
    \ NetBIOS datagrams as a\n   foundation for their own connection-oriented protocols.\
    \  This can\n   cause excessive NetBIOS name query activity and place a substantial\n\
    \   burden on the network, server nodes, and other end- nodes.  It is\n   recommended\
    \ that this practice be avoided in new applications.\n"
