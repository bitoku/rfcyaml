- title: __initial_text__
  contents:
  - "        Internationalized Domain Names for Applications (IDNA):\n           \
    \      Background, Explanation, and Rationale\n"
- title: Abstract
  contents:
  - "Abstract\n   Several years have passed since the original protocol for\n   Internationalized\
    \ Domain Names (IDNs) was completed and deployed.\n   During that time, a number\
    \ of issues have arisen, including the need\n   to update the system to deal with\
    \ newer versions of Unicode.  Some of\n   these issues require tuning of the existing\
    \ protocols and the tables\n   on which they depend.  This document provides an\
    \ overview of a\n   revised system and provides explanatory material for its components.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc5894.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n     1.1.  Context and Overview . . . . . . . . . . . . . .\
    \ . . . . .  4\n     1.2.  Terminology  . . . . . . . . . . . . . . . . . . .\
    \ . . . .  5\n       1.2.1.  DNS \"Name\" Terminology . . . . . . . . . . . .\
    \ . . . .  5\n       1.2.2.  New Terminology and Restrictions . . . . . . . .\
    \ . . .  6\n     1.3.  Objectives . . . . . . . . . . . . . . . . . . . . . .\
    \ . .  6\n     1.4.  Applicability and Function of IDNA . . . . . . . . . . .\
    \ .  7\n     1.5.  Comprehensibility of IDNA Mechanisms and Processing  . . .\
    \  8\n   2.  Processing in IDNA2008 . . . . . . . . . . . . . . . . . . . .  9\n\
    \   3.  Permitted Characters: An Inclusion List  . . . . . . . . . . .  9\n  \
    \   3.1.  A Tiered Model of Permitted Characters and Labels  . . . . 10\n    \
    \   3.1.1.  PROTOCOL-VALID . . . . . . . . . . . . . . . . . . . . 10\n      \
    \ 3.1.2.  CONTEXTUAL RULE REQUIRED . . . . . . . . . . . . . . . 11\n        \
    \ 3.1.2.1.  Contextual Restrictions  . . . . . . . . . . . . . 11\n         3.1.2.2.\
    \  Rules and Their Application  . . . . . . . . . . . 12\n       3.1.3.  DISALLOWED\
    \ . . . . . . . . . . . . . . . . . . . . . . 12\n       3.1.4.  UNASSIGNED .\
    \ . . . . . . . . . . . . . . . . . . . . . 13\n     3.2.  Registration Policy\
    \  . . . . . . . . . . . . . . . . . . . 14\n     3.3.  Layered Restrictions:\
    \ Tables, Context, Registration, and\n           Applications . . . . . . . .\
    \ . . . . . . . . . . . . . . . 15\n   4.  Application-Related Issues . . . .\
    \ . . . . . . . . . . . . . . 15\n     4.1.  Display and Network Order  . . .\
    \ . . . . . . . . . . . . . 15\n     4.2.  Entry and Display in Applications \
    \ . . . . . . . . . . . . 16\n     4.3.  Linguistic Expectations: Ligatures, Digraphs,\
    \ and\n           Alternate Character Forms  . . . . . . . . . . . . . . . . 19\n\
    \     4.4.  Case Mapping and Related Issues  . . . . . . . . . . . . . 20\n  \
    \   4.5.  Right-to-Left Text . . . . . . . . . . . . . . . . . . . . 21\n   5.\
    \  IDNs and the Robustness Principle  . . . . . . . . . . . . . . 22\n   6.  Front-end\
    \ and User Interface Processing for Lookup . . . . . . 22\n   7.  Migration from\
    \ IDNA2003 and Unicode Version Synchronization  . 25\n     7.1.  Design Criteria\
    \  . . . . . . . . . . . . . . . . . . . . . 25\n       7.1.1.  Summary and Discussion\
    \ of IDNA Validity Criteria . . . 25\n       7.1.2.  Labels in Registration .\
    \ . . . . . . . . . . . . . . . 26\n       7.1.3.  Labels in Lookup . . . . .\
    \ . . . . . . . . . . . . . . 27\n     7.2.  Changes in Character Interpretations\
    \ . . . . . . . . . . . 28\n       7.2.1.  Character Changes: Eszett and Final\
    \ Sigma  . . . . . . 28\n       7.2.2.  Character Changes: Zero Width Joiner and\
    \ Zero\n               Width Non-Joiner . . . . . . . . . . . . . . . . . . .\
    \ 29\n       7.2.3.  Character Changes and the Need for Transition  . . . . 29\n\
    \       7.2.4.  Transition Strategies  . . . . . . . . . . . . . . . . 30\n  \
    \   7.3.  Elimination of Character Mapping . . . . . . . . . . . . . 31\n    \
    \ 7.4.  The Question of Prefix Changes . . . . . . . . . . . . . . 31\n      \
    \ 7.4.1.  Conditions Requiring a Prefix Change . . . . . . . . . 31\n       7.4.2.\
    \  Conditions Not Requiring a Prefix Change . . . . . . . 32\n       7.4.3.  Implications\
    \ of Prefix Changes . . . . . . . . . . . . 32\n     7.5.  Stringprep Changes\
    \ and Compatibility . . . . . . . . . . . 33\n     7.6.  The Symbol Question \
    \ . . . . . . . . . . . . . . . . . . . 33\n     7.7.  Migration between Unicode\
    \ Versions: Unassigned Code\n           Points . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . 35\n     7.8.  Other Compatibility Issues . . . . . . .\
    \ . . . . . . . . . 36\n   8.  Name Server Considerations . . . . . . . . . .\
    \ . . . . . . . . 37\n     8.1.  Processing Non-ASCII Strings . . . . . . . .\
    \ . . . . . . . 37\n     8.2.  Root and Other DNS Server Considerations . . .\
    \ . . . . . . 37\n   9.  Internationalization Considerations  . . . . . . . .\
    \ . . . . . 38\n   10. IANA Considerations  . . . . . . . . . . . . . . . . .\
    \ . . . . 38\n     10.1. IDNA Character Registry  . . . . . . . . . . . . . .\
    \ . . . 38\n     10.2. IDNA Context Registry  . . . . . . . . . . . . . . . .\
    \ . . 39\n     10.3. IANA Repository of IDN Practices of TLDs . . . . . . . .\
    \ . 39\n   11. Security Considerations  . . . . . . . . . . . . . . . . . . .\
    \ 39\n     11.1. General Security Issues with IDNA  . . . . . . . . . . . . 39\n\
    \   12. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 39\n  \
    \ 13. Contributors . . . . . . . . . . . . . . . . . . . . . . . . . 40\n   14.\
    \ References . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n     14.1.\
    \ Normative References . . . . . . . . . . . . . . . . . . . 40\n     14.2. Informative\
    \ References . . . . . . . . . . . . . . . . . . 41\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1.  Context and Overview
  contents:
  - "1.1.  Context and Overview\n   Internationalized Domain Names in Applications\
    \ (IDNA) is a collection\n   of standards that allow client applications to convert\
    \ some mnemonic\n   strings expressed in Unicode to an ASCII-compatible encoding\
    \ form\n   (\"ACE\") that is a valid DNS label containing only LDH syntax (see\
    \ the\n   Definitions document [RFC5890]).  The specific form of ACE label used\n\
    \   by IDNA is called an \"A-label\".  A client can look up an exact\n   A-label\
    \ in the existing DNS, so A-labels do not require any\n   extensions to DNS, upgrades\
    \ of DNS servers, or updates to low-level\n   client libraries.  An A-label is\
    \ recognizable from the prefix \"xn--\"\n   before the characters produced by\
    \ the Punycode algorithm [RFC3492];\n   thus, a user application can identify\
    \ an A-label and convert it into\n   Unicode (or some local coded character set)\
    \ for display.\n   On the registry side, IDNA allows a registry to offer\n   Internationalized\
    \ Domain Names (IDNs) for registration as A-labels.\n   A registry may offer any\
    \ subset of valid IDNs, and may apply any\n   restrictions or bundling (grouping\
    \ of similar labels together in one\n   registration) appropriate for the context\
    \ of that registry.\n   Registration of labels is sometimes discussed separately\
    \ from lookup,\n   and it is subject to a few specific requirements that do not\
    \ apply to\n   lookup.\n   DNS clients and registries are subject to some differences\
    \ in\n   requirements for handling IDNs.  In particular, registries are urged\n\
    \   to register only exact, valid A-labels, while clients might do some\n   mapping\
    \ to get from otherwise-invalid user input to a valid A-label.\n   The first version\
    \ of IDNA was published in 2003 and is referred to\n   here as IDNA2003 to contrast\
    \ it with the current version, which is\n   known as IDNA2008 (after the year\
    \ in which IETF work started on it).\n   IDNA2003 consists of four documents:\
    \ the IDNA base specification\n   [RFC3490], Nameprep [RFC3491], Punycode [RFC3492],\
    \ and Stringprep\n   [RFC3454].  The current set of documents, IDNA2008, is not\
    \ dependent\n   on any of the IDNA2003 specifications other than the one for Punycode\n\
    \   encoding.  References to \"IDNA2008\", \"these specifications\", or\n   \"\
    these documents\" are to the entire IDNA2008 set listed in a separate\n   Definitions\
    \ document [RFC5890].  The characters that are valid in\n   A-labels are identified\
    \ from rules listed in the Tables document\n   [RFC5892], but validity can be\
    \ derived from the Unicode properties of\n   those characters with a very few\
    \ exceptions.\n   Traditionally, DNS labels are matched case-insensitively (as\n\
    \   described in the DNS specifications [RFC1034][RFC1035]).  That\n   convention\
    \ was preserved in IDNA2003 by a case-folding operation that\n   generally maps\
    \ capital letters into lowercase ones.  However, if case\n   rules are enforced\
    \ from one language, another language sometimes\n   loses the ability to treat\
    \ two characters separately.  Case-\n   insensitivity is treated slightly differently\
    \ in IDNA2008.\n   IDNA2003 used Unicode version 3.2 only.  In order to keep up\
    \ with new\n   characters added in new versions of Unicode, IDNA2008 decouples\
    \ its\n   rules from any particular version of Unicode.  Instead, the\n   attributes\
    \ of new characters in Unicode, supplemented by a small\n   number of exception\
    \ cases, determine how and whether the characters\n   can be used in IDNA labels.\n\
    \   This document provides informational context for IDNA2008, including\n   terminology,\
    \ background, and policy discussions.  It contains no\n   normative material;\
    \ specifications for conformance to the IDNA2008\n   protocols appears entirely\
    \ in the other documents in the series.\n"
- title: 1.2.  Terminology
  contents:
  - "1.2.  Terminology\n   Terminology for IDNA2008 appears in the Definitions document\n\
    \   [RFC5890].  That document also contains a road map to the IDNA2008\n   document\
    \ collection.  No attempt should be made to understand this\n   document without\
    \ the definitions and concepts that appear there.\n"
- title: 1.2.1.  DNS "Name" Terminology
  contents:
  - "1.2.1.  DNS \"Name\" Terminology\n   In the context of IDNs, the DNS term \"\
    name\" has introduced some\n   confusion as people speak of DNS labels in terms\
    \ of the words or\n   phrases of various natural languages.  Historically, many\
    \ of the\n   \"names\" in the DNS have been mnemonics to identify some particular\n\
    \   concept, object, or organization.  They are typically rooted in some\n   language\
    \ because most people think in language-based ways.  But,\n   because they are\
    \ mnemonics, they need not obey the orthographic\n   conventions of any language:\
    \ it is not a requirement that it be\n   possible for them to be \"words\".\n\
    \   This distinction is important because the reasonable goal of an IDN\n   effort\
    \ is not to be able to write the great Klingon (or language of\n   one's choice)\
    \ novel in DNS labels but to be able to form a usefully\n   broad range of mnemonics\
    \ in ways that are as natural as possible in a\n   very broad range of scripts.\n"
- title: 1.2.2.  New Terminology and Restrictions
  contents:
  - "1.2.2.  New Terminology and Restrictions\n   IDNA2008 introduces new terminology.\
    \  Precise definitions are\n   provided in the Definitions document for the terms\
    \ U-label, A-Label,\n   LDH label (to which all valid pre-IDNA hostnames conformed),\
    \ Reserved\n   LDH label (R-LDH label), XN-label, Fake A-label, and Non-Reserved\
    \ LDH\n   label (NR-LDH label).\n   In addition, the term \"putative label\" has\
    \ been adopted to refer to a\n   label that may appear to meet certain definitional\
    \ constraints but\n   has not yet been sufficiently tested for validity.\n   These\
    \ definitions are also illustrated in Figure 1 of the Definitions\n   document.\
    \  R-LDH labels contain \"--\" in the third and fourth\n   character positions\
    \ from the beginning of the label.  In IDNA-aware\n   applications, only a subset\
    \ of these reserved labels is permitted to\n   be used, namely the A-label subset.\
    \  A-labels are a subset of the\n   R-LDH labels that begin with the case-insensitive\
    \ string \"xn--\".\n   Labels that bear this prefix but that are not otherwise\
    \ valid fall\n   into the \"Fake A-label\" category.  The Non-Reserved labels\
    \ (NR-LDH\n   labels) are implicitly valid since they do not bear any resemblance\n\
    \   to the labels specified by IDNA.\n   The creation of the Reserved-LDH category\
    \ is required for three\n   reasons:\n   o  to prevent confusion with pre-IDNA\
    \ coding forms;\n   o  to permit future extensions that would require changing\
    \ the\n      prefix, no matter how unlikely those might be (see Section 7.4);\n\
    \      and\n   o  to reduce the opportunities for attacks via the Punycode encoding\n\
    \      algorithm itself.\n   As with other documents in the IDNA2008 set, this\
    \ document uses the\n   term \"registry\" to describe any zone in the DNS.  That\
    \ term, and the\n   terms \"zone\" or \"zone administration\", are interchangeable.\n"
- title: 1.3.  Objectives
  contents:
  - "1.3.  Objectives\n   These are the main objectives in revising IDNA.\n   o  Use\
    \ a more recent version of Unicode and allow IDNA to be\n      independent of\
    \ Unicode versions, so that IDNA2008 need not be\n      updated for implementations\
    \ to adopt code points from new Unicode\n      versions.\n   o  Fix a very small\
    \ number of code point categorizations that have\n      turned out to cause problems\
    \ in the communities that use those\n      code points.\n   o  Reduce the dependency\
    \ on mapping, in favor of valid A-labels.\n      This will result in pre-mapped\
    \ forms that are not valid IDNA\n      labels appearing less often in various\
    \ contexts.\n   o  Fix some details in the bidirectional code point handling\n\
    \      algorithms.\n"
- title: 1.4.  Applicability and Function of IDNA
  contents:
  - "1.4.  Applicability and Function of IDNA\n   The IDNA specification solves the\
    \ problem of extending the repertoire\n   of characters that can be used in domain\
    \ names to include a large\n   subset of the Unicode repertoire.\n   IDNA does\
    \ not extend DNS.  Instead, the applications (and, by\n   implication, the users)\
    \ continue to see an exact-match lookup\n   service.  Either there is a single\
    \ name that matches exactly (subject\n   to the base DNS requirement of case-insensitive\
    \ ASCII matching) or\n   there is no match.  This model has served the existing\
    \ applications\n   well, but it requires, with or without internationalized domain\n\
    \   names, that users know the exact spelling of the domain names that\n   are\
    \ to be typed into applications such as web browsers and mail user\n   agents.\
    \  The introduction of the larger repertoire of characters\n   potentially makes\
    \ the set of misspellings larger, especially given\n   that in some cases the\
    \ same appearance, for example on a business\n   card, might visually match several\
    \ Unicode code points or several\n   sequences of code points.\n   The IDNA standard\
    \ does not require any applications to conform to it,\n   nor does it retroactively\
    \ change those applications.  An application\n   can elect to use IDNA in order\
    \ to support IDNs while maintaining\n   interoperability with existing infrastructure.\
    \  For applications that\n   want to use non-ASCII characters in public DNS domain\
    \ names, IDNA is\n   the only option that is defined at the time this specification\
    \ is\n   published.  Adding IDNA support to an existing application entails\n\
    \   changes to the application only, and leaves room for flexibility in\n   front-end\
    \ processing and more specifically in the user interface (see\n   Section 6).\n\
    \   A great deal of the discussion of IDN solutions has focused on\n   transition\
    \ issues and how IDNs will work in a world where not all of\n   the components\
    \ have been updated.  Proposals that were not chosen by\n   the original IDN Working\
    \ Group would have depended on updating user\n   applications, DNS resolvers,\
    \ and DNS servers in order for a user to\n   apply an internationalized domain\
    \ name in any form or coding\n   acceptable under that method.  While processing\
    \ must be performed\n   prior to or after access to the DNS, IDNA requires no\
    \ changes to the\n   DNS protocol, any DNS servers, or the resolvers on users'\
    \ computers.\n   IDNA allows the graceful introduction of IDNs not only by avoiding\n\
    \   upgrades to existing infrastructure (such as DNS servers and mail\n   transport\
    \ agents), but also by allowing some limited use of IDNs in\n   applications by\
    \ using the ASCII-encoded representation of the labels\n   containing non-ASCII\
    \ characters.  While such names are user-\n   unfriendly to read and type, and\
    \ hence not optimal for user input,\n   they can be used as a last resort to allow\
    \ rudimentary IDN usage.\n   For example, they might be the best choice for display\
    \ if it were\n   known that relevant fonts were not available on the user's computer.\n\
    \   In order to allow user-friendly input and output of the IDNs and\n   acceptance\
    \ of some characters as equivalent to those to be processed\n   according to the\
    \ protocol, the applications need to be modified to\n   conform to this specification.\n\
    \   This version of IDNA uses the Unicode character repertoire for\n   continuity\
    \ with the original version of IDNA.\n"
- title: 1.5.  Comprehensibility of IDNA Mechanisms and Processing
  contents:
  - "1.5.  Comprehensibility of IDNA Mechanisms and Processing\n   One goal of IDNA2008,\
    \ which is aided by the main goal of reducing the\n   dependency on mapping, is\
    \ to improve the general understanding of how\n   IDNA works and what characters\
    \ are permitted and what happens to\n   them.  Comprehensibility and predictability\
    \ to users and registrants\n   are important design goals for this effort.  End-user\
    \ applications\n   have an important role to play in increasing this comprehensibility.\n\
    \   Any system that tries to handle international characters encounters\n   some\
    \ common problems.  For example, a User Interface (UI) cannot\n   display a character\
    \ if no font containing that character is\n   available.  In some cases, internationalization\
    \ enables effective\n   localization while maintaining some global uniformity\
    \ but losing some\n   universality.\n   It is difficult to even make suggestions\
    \ as to how end-user\n   applications should cope when characters and fonts are\
    \ not available.\n   Because display functions are rarely controlled by the types\
    \ of\n   applications that would call upon IDNA, such suggestions will rarely\n\
    \   be very effective.\n   Conversion between local character sets and normalized\
    \ Unicode, if\n   needed, is part of this set of user interface issues.  Those\n\
    \   conversions introduce complexity in a system that does not use\n   Unicode\
    \ as its primary (or only) internal character coding system.\n   If a label is\
    \ converted to a local character set that does not have\n   all the needed characters,\
    \ or that uses different character-coding\n   principles, the user interface program\
    \ may have to add special logic\n   to avoid or reduce loss of information.\n\
    \   The major difficulty may lie in accurately identifying the incoming\n   character\
    \ set and applying the correct conversion routine.  Even more\n   difficult, the\
    \ local character coding system could be based on\n   conceptually different assumptions\
    \ than those used by Unicode (e.g.,\n   choice of font encodings used for publications\
    \ in some Indic\n   scripts).  Those differences may not easily yield unambiguous\n\
    \   conversions or interpretations even if each coding system is\n   internally\
    \ consistent and adequate to represent the local language\n   and script.\n  \
    \ IDNA2008 shifts responsibility for character mapping and other\n   adjustments\
    \ from the protocol (where it was located in IDNA2003) to\n   pre-processing before\
    \ invoking IDNA itself.  The intent is that this\n   change will lead to greater\
    \ usage of fully-valid A-Labels or U-labels\n   in display, transit, and storage,\
    \ which should aid comprehensibility\n   and predictability.  A careful look at\
    \ pre-processing raises issues\n   about what that pre-processing should do and\
    \ at what point\n   pre-processing becomes harmful; how universally consistent\n\
    \   pre-processing algorithms can be; and how to be compatible with\n   labels\
    \ prepared in an IDNA2003 context.  Those issues are discussed\n   in Section\
    \ 6 and in the Mapping document [IDNA2008-Mapping].\n"
- title: 2.  Processing in IDNA2008
  contents:
  - "2.  Processing in IDNA2008\n   IDNA2008 separates Domain Name Registration and\
    \ Lookup in the\n   protocol specification (RFC 5891, Sections 4 and 5 [RFC5891]).\n\
    \   Although most steps in the two processes are similar, the separation\n   reflects\
    \ current practice in which per-registry (DNS zone)\n   restrictions and special\
    \ processing are applied at registration time\n   but not during lookup.  Another\
    \ significant benefit is that\n   separation facilitates incremental addition\
    \ of permitted character\n   groups to avoid freezing on one particular version\
    \ of Unicode.\n   The actual registration and lookup protocols for IDNA2008 are\n\
    \   specified in the Protocol document.\n"
- title: '3.  Permitted Characters: An Inclusion List'
  contents:
  - "3.  Permitted Characters: An Inclusion List\n   IDNA2008 adopts the inclusion\
    \ model.  A code point is assumed to be\n   invalid for IDN use unless it is included\
    \ as part of a Unicode\n   property-based rule or, in rare cases, included individually\
    \ by an\n   exception.  When an implementation moves to a new version of Unicode,\n\
    \   the rules may indicate new valid code points.\n   This section provides an\
    \ overview of the model used to establish the\n   algorithm and character lists\
    \ of the Tables document [RFC5892] and\n   describes the names and applicability\
    \ of the categories used there.\n   Note that the inclusion of a character in\
    \ the PROTOCOL-VALID category\n   group (Section 3.1.1) does not imply that it\
    \ can be used\n   indiscriminately; some characters are associated with contextual\n\
    \   rules that must be applied as well.\n   The information given in this section\
    \ is provided to make the rules,\n   tables, and protocol easier to understand.\
    \  The normative generating\n   rules that correspond to this informal discussion\
    \ appear in the\n   Tables document, and the rules that actually determine what\
    \ labels\n   can be registered or looked up are in the Protocol document.\n"
- title: 3.1.  A Tiered Model of Permitted Characters and Labels
  contents:
  - "3.1.  A Tiered Model of Permitted Characters and Labels\n   Moving to an inclusion\
    \ model involves a new specification for the\n   list of characters that are permitted\
    \ in IDNs.  In IDNA2003,\n   character validity is independent of context and\
    \ fixed forever (or\n   until the standard is replaced).  However, globally context-\n\
    \   independent rules have proved to be impractical because some\n   characters,\
    \ especially those that are called \"Join_Controls\" in\n   Unicode, are needed\
    \ to make reasonable use of some scripts but have\n   no visible effect in others.\
    \  IDNA2003 prohibited those types of\n   characters entirely by discarding them.\
    \  We now have a consensus that\n   under some conditions, these \"joiner\" characters\
    \ are legitimately\n   needed to allow useful mnemonics for some languages and\
    \ scripts.  In\n   general, context-dependent rules help deal with characters\
    \ (generally\n   characters that would otherwise be prohibited entirely) that\
    \ are used\n   differently or perceived differently across different scripts,\
    \ and\n   allow the standard to be applied more appropriately in cases where a\n\
    \   string is not universally handled the same way.\n   IDNA2008 divides all possible\
    \ Unicode code points into four\n   categories: PROTOCOL-VALID, CONTEXTUAL RULE\
    \ REQUIRED, DISALLOWED, and\n   UNASSIGNED.\n"
- title: 3.1.1.  PROTOCOL-VALID
  contents:
  - "3.1.1.  PROTOCOL-VALID\n   Characters identified as PROTOCOL-VALID (often abbreviated\
    \ PVALID)\n   are permitted in IDNs.  Their use may be restricted by rules about\n\
    \   the context in which they appear or by other rules that apply to the\n   entire\
    \ label in which they are to be embedded.  For example, any\n   label that contains\
    \ a character in this category that has a\n   \"right-to-left\" property must\
    \ be used in context with the Bidi rules\n   [RFC5893].  The term PROTOCOL-VALID\
    \ is used to stress the fact that\n   the presence of a character in this category\
    \ does not imply that a\n   given registry need accept registrations containing\
    \ any of the\n   characters in the category.  Registries are still expected to\
    \ apply\n   judgment about labels they will accept and to maintain rules\n   consistent\
    \ with those judgments (see the Protocol document [RFC5891]\n   and Section 3.3).\n\
    \   Characters that are placed in the PROTOCOL-VALID category are\n   expected\
    \ to never be removed from it or reclassified.  While\n   theoretically characters\
    \ could be removed from Unicode, such removal\n   would be inconsistent with the\
    \ Unicode stability principles (see\n   UTR 39: Unicode Security Mechanisms [Unicode52],\
    \ Appendix F) and\n   hence should never occur.\n"
- title: 3.1.2.  CONTEXTUAL RULE REQUIRED
  contents:
  - "3.1.2.  CONTEXTUAL RULE REQUIRED\n   Some characters may be unsuitable for general\
    \ use in IDNs but\n   necessary for the plausible support of some scripts.  The\
    \ two most\n   commonly cited examples are the ZERO WIDTH JOINER and ZERO WIDTH\n\
    \   NON-JOINER characters (ZWJ, U+200D and ZWNJ, U+200C), but other\n   characters\
    \ may require special treatment because they would otherwise\n   be DISALLOWED\
    \ (typically because Unicode considers them punctuation\n   or special symbols)\
    \ but need to be permitted in limited contexts.\n   Other characters are given\
    \ this special treatment because they pose\n   exceptional danger of being used\
    \ to produce misleading labels or to\n   cause unacceptable ambiguity in label\
    \ matching and interpretation.\n"
- title: 3.1.2.1.  Contextual Restrictions
  contents:
  - "3.1.2.1.  Contextual Restrictions\n   Characters with contextual restrictions\
    \ are identified as CONTEXTUAL\n   RULE REQUIRED and are associated with a rule.\
    \  The rule defines\n   whether the character is valid in a particular string,\
    \ and also\n   whether the rule itself is to be applied on lookup as well as\n\
    \   registration.\n   A distinction is made between characters that indicate or\
    \ prohibit\n   joining and ones similar to them (known as CONTEXT-JOINER or\n\
    \   CONTEXTJ) and other characters requiring contextual treatment\n   (CONTEXT-OTHER\
    \ or CONTEXTO).  Only the former require full testing at\n   lookup time.\n  \
    \ It is important to note that these contextual rules cannot prevent\n   all uses\
    \ of the relevant characters that might be confusing or\n   problematic.  What\
    \ they are expected to do is to confine\n   applicability of the characters to\
    \ scripts (and narrower contexts)\n   where zone administrators are knowledgeable\
    \ enough about the use of\n   those characters to be prepared to deal with them\
    \ appropriately.\n   For example, a registry dealing with an Indic script that\
    \ requires\n   ZWJ and/or ZWNJ as part of the writing system is expected to\n\
    \   understand where the characters have visible effect and where they do\n  \
    \ not and to make registration rules accordingly.  By contrast, a\n   registry\
    \ dealing primarily with Latin or Cyrillic script might not be\n   actively aware\
    \ that the characters exist, much less about the\n   consequences of embedding\
    \ them in labels drawn from those scripts and\n   therefore should avoid accepting\
    \ registrations containing those\n   characters, at least in labels using characters\
    \ from the Latin or\n   Cyrillic scripts.\n"
- title: 3.1.2.2.  Rules and Their Application
  contents:
  - "3.1.2.2.  Rules and Their Application\n   Rules have descriptions such as \"\
    Must follow a character from Script\n   XYZ\", \"Must occur only if the entire\
    \ label is in Script ABC\", or\n   \"Must occur only if the previous and subsequent\
    \ characters have the\n   DFG property\".  The actual rules may be DEFINED or\
    \ NULL.  If present,\n   they may have values of \"True\" (character may be used\
    \ in any position\n   in any label), \"False\" (character may not be used in any\
    \ label), or\n   may be a set of procedural rules that specify the context in\
    \ which\n   the character is permitted.\n   Because it is easier to identify these\
    \ characters than to know that\n   they are actually needed in IDNs or how to\
    \ establish exactly the\n   right rules for each one, a rule may have a null value\
    \ in a given\n   version of the tables.  Characters associated with null rules\
    \ are not\n   permitted to appear in putative labels for either registration or\n\
    \   lookup.  Of course, a later version of the tables might contain a\n   non-null\
    \ rule.\n   The actual rules and their descriptions are in Sections 2 and 3 of\n\
    \   the Tables document [RFC5892].  That document also specifies the\n   creation\
    \ of a registry for future rules.\n"
- title: 3.1.3.  DISALLOWED
  contents:
  - "3.1.3.  DISALLOWED\n   Some characters are inappropriate for use in IDNs and\
    \ are thus\n   excluded for both registration and lookup (i.e., IDNA-conforming\n\
    \   applications performing name lookup should verify that these\n   characters\
    \ are absent; if they are present, the label strings should\n   be rejected rather\
    \ than converted to A-labels and looked up.  Some of\n   these characters are\
    \ problematic for use in IDNs (such as the\n   FRACTION SLASH character, U+2044),\
    \ while some of them (such as the\n   various HEART symbols, e.g., U+2665, U+2661,\
    \ and U+2765, see\n   Section 7.6) simply fall outside the conventions for typical\n\
    \   identifiers (basically letters and numbers).\n   Of course, this category\
    \ would include code points that had been\n   removed entirely from Unicode should\
    \ such removals ever occur.\n   Characters that are placed in the DISALLOWED category\
    \ are expected to\n   never be removed from it or reclassified.  If a character\
    \ is\n   classified as DISALLOWED in error and the error is sufficiently\n   problematic,\
    \ the only recourse would be either to introduce a new\n   code point into Unicode\
    \ and classify it as PROTOCOL-VALID or for the\n   IETF to accept the considerable\
    \ costs of an incompatible change and\n   replace the relevant RFC with one containing\
    \ appropriate exceptions.\n   There is provision for exception cases but, in general,\
    \ characters\n   are placed into DISALLOWED if they fall into one or more of the\n\
    \   following groups:\n   o  The character is a compatibility equivalent for another\
    \ character.\n      In slightly more precise Unicode terms, application of\n \
    \     Normalization Form KC (NFKC) to the character yields some other\n      character.\n\
    \   o  The character is an uppercase form or some other form that is\n      mapped\
    \ to another character by Unicode case folding.\n   o  The character is a symbol\
    \ or punctuation form or, more generally,\n      something that is not a letter,\
    \ digit, or a mark that is used to\n      form a letter or digit.\n"
- title: 3.1.4.  UNASSIGNED
  contents:
  - "3.1.4.  UNASSIGNED\n   For convenience in processing and table-building, code\
    \ points that do\n   not have assigned values in a given version of Unicode are\
    \ treated as\n   belonging to a special UNASSIGNED category.  Such code points\
    \ are\n   prohibited in labels to be registered or looked up.  The category\n\
    \   differs from DISALLOWED in that code points are moved out of it by\n   the\
    \ simple expedient of being assigned in a later version of Unicode\n   (at which\
    \ point, they are classified into one of the other categories\n   as appropriate).\n\
    \   The rationale for restricting the processing of UNASSIGNED characters\n  \
    \ is simply that the properties of such code points cannot be\n   completely known\
    \ until actual characters are assigned to them.  For\n   example, assume that\
    \ an UNASSIGNED code point were included in a\n   label to be looked up.  Assume\
    \ that the code point was later assigned\n   to a character that required some\
    \ set of contextual rules.  With that\n   combination, un-updated instances of\
    \ IDNA-aware software might permit\n   lookup of labels containing the previously\
    \ unassigned characters\n   while updated versions of the software might restrict\
    \ use of the same\n   label in lookup, depending on the contextual rules.  It\
    \ should be\n   clear that under no circumstance should an UNASSIGNED character\
    \ be\n   permitted in a label to be registered as part of a domain name.\n"
- title: 3.2.  Registration Policy
  contents:
  - "3.2.  Registration Policy\n   While these recommendations cannot and should not\
    \ define registry\n   policies, registries should develop and apply additional\
    \ restrictions\n   as needed to reduce confusion and other problems.  For example,\
    \ it is\n   generally believed that labels containing characters from more than\n\
    \   one script are a bad practice although there may be some important\n   exceptions\
    \ to that principle.  Some registries may choose to restrict\n   registrations\
    \ to characters drawn from a very small number of\n   scripts.  For many scripts,\
    \ the use of variant techniques such as\n   those as described in the JET specification\
    \ for the CJK script\n   [RFC3743] and its generalization [RFC4290], and illustrated\
    \ for\n   Chinese by the tables provided by the Chinese Domain Name Consortium\n\
    \   [RFC4713] may be helpful in reducing problems that might be perceived\n  \
    \ by users.\n   In general, users will benefit if registries only permit characters\n\
    \   from scripts that are well-understood by the registry or its\n   advisers.\
    \  If a registry decides to reduce opportunities for\n   confusion by constructing\
    \ policies that disallow characters used in\n   historic writing systems or characters\
    \ whose use is restricted to\n   specialized, highly technical contexts, some\
    \ relevant information may\n   be found in Section 2.4 (Specific Character Adjustments)\
    \ of Unicode\n   Identifier and Pattern Syntax [Unicode-UAX31], especially Table\
    \ 4\n   (Candidate Characters for Exclusion from Identifiers), and Section\n \
    \  3.1 (General Security Profile for Identifiers) in Unicode Security\n   Mechanisms\
    \ [Unicode-UTS39].\n   The requirement (in Section 4.1 of the Protocol document\
    \ [RFC5891])\n   that registration procedures use only U-labels and/or A-labels\
    \ is\n   intended to ensure that registrants are fully aware of exactly what\n\
    \   is being registered as well as encouraging use of those canonical\n   forms.\
    \  That provision should not be interpreted as requiring that\n   registrants\
    \ need to provide characters in a particular code sequence.\n   Registrant input\
    \ conventions and management are part of registrant-\n   registrar interactions\
    \ and relationships between registries and\n   registrars and are outside the\
    \ scope of these standards.\n   It is worth stressing that these principles of\
    \ policy development and\n   application apply at all levels of the DNS, not only,\
    \ e.g., top level\n   domain (TLD) or second level domain (SLD) registrations.\
    \  Even a\n   trivial, \"anything is permitted that is valid under the protocol\"\
    \n   policy is helpful in that it helps users and application developers\n   know\
    \ what to expect.\n"
- title: '3.3.  Layered Restrictions: Tables, Context, Registration, and'
  contents:
  - "3.3.  Layered Restrictions: Tables, Context, Registration, and\n      Applications\n\
    \   The character rules in IDNA2008 are based on the realization that\n   there\
    \ is no single magic bullet for any of the security,\n   confusability, or other\
    \ issues associated with IDNs.  Instead, the\n   specifications define a variety\
    \ of approaches.  The character tables\n   are the first mechanism, protocol rules\
    \ about how those characters\n   are applied or restricted in context are the\
    \ second, and those two in\n   combination constitute the limits of what can be\
    \ done in the\n   protocol.  As discussed in the previous section (Section 3.2),\n\
    \   registries are expected to restrict what they permit to be\n   registered,\
    \ devising and using rules that are designed to optimize\n   the balance between\
    \ confusion and risk on the one hand and maximum\n   expressiveness in mnemonics\
    \ on the other.\n   In addition, there is an important role for user interface\
    \ programs\n   in warning against label forms that appear problematic given their\n\
    \   knowledge of local contexts and conventions.  Of course, no approach\n   based\
    \ on naming or identifiers alone can protect against all threats.\n"
- title: 4.  Application-Related Issues
  contents:
  - '4.  Application-Related Issues

    '
- title: 4.1.  Display and Network Order
  contents:
  - "4.1.  Display and Network Order\n   Domain names are always transmitted in network\
    \ order (the order in\n   which the code points are sent in protocols), but they\
    \ may have a\n   different display order (the order in which the code points are\n\
    \   displayed on a screen or paper).  When a domain name contains\n   characters\
    \ that are normally written right to left, display order may\n   be affected although\
    \ network order is not.  It gets even more\n   complicated if left-to-right and\
    \ right-to-left labels are adjacent to\n   each other within a domain name.  The\
    \ decision about the display\n   order is ultimately under the control of user\
    \ agents -- including Web\n   browsers, mail clients, hosted Web applications\
    \ and many more --\n   which may be highly localized.  Should a domain name abc.def,\
    \ in\n   which both labels are represented in scripts that are written right\n\
    \   to left, be displayed as fed.cba or cba.fed?  Applications that are\n   in\
    \ deployment today are already diverse, and one can find examples of\n   either\
    \ choice.\n   The picture changes once again when an IDN appears in an\n   Internationalized\
    \ Resource Identifier (IRI) [RFC3987].  An IRI or\n   internationalized email\
    \ address contains elements other than the\n   domain name.  For example, IRIs\
    \ contain protocol identifiers and\n   field delimiter syntax such as \"http://\"\
    \ or \"mailto:\" while email\n   addresses contain the \"@\" to separate local\
    \ parts from domain names.\n   An IRI in network order begins with \"http://\"\
    \ followed by domain\n   labels in network order, thus \"http://abc.def\".\n \
    \  User interface programs are not required to display and allow input\n   of\
    \ IRIs directly but often do so.  Implementers have to choose\n   whether the\
    \ overall direction of these strings will always be left to\n   right (or right\
    \ to left) for an IRI or email address.  The natural\n   order for a user typing\
    \ a domain name on a right-to-left system is\n   fed.cba.  Should the right-to-left\
    \ (RTL) user interface reverse the\n   entire domain name each time a domain name\
    \ is typed?  Does this\n   change if the user types \"http://\" right before typing\
    \ a domain name,\n   thus implying that the user is beginning at the beginning\
    \ of the\n   network-order IRI?  Experience in the 1980s and 1990s with mixing\n\
    \   systems in which domain name labels were read in network order (left\n   to\
    \ right) and those in which those labels were read right to left\n   would predict\
    \ a great deal of confusion.\n   If each implementation of each application makes\
    \ its own decisions on\n   these issues, users will develop heuristics that will\
    \ sometimes fail\n   when switching applications.  However, while some display\
    \ order\n   conventions, voluntarily adopted, would be desirable to reduce\n \
    \  confusion, such suggestions are beyond the scope of these\n   specifications.\n"
- title: 4.2.  Entry and Display in Applications
  contents:
  - "4.2.  Entry and Display in Applications\n   Applications can accept and display\
    \ domain names using any character\n   set or character coding system.  The IDNA\
    \ protocol does not\n   necessarily affect the interface between users and applications.\
    \  An\n   IDNA-aware application can accept and display internationalized\n  \
    \ domain names in two formats: as the internationalized character\n   set(s) supported\
    \ by the application (i.e., an appropriate local\n   representation of a U-label)\
    \ and as an A-label.  Applications may\n   allow the display of A-labels, but\
    \ are encouraged not to do so except\n   as an interface for special purposes,\
    \ possibly for debugging, or to\n   cope with display limitations.  In general,\
    \ they should allow, but\n   not encourage, user input of A-labels.  A-labels\
    \ are opaque and ugly,\n   and malicious variations on them are not easily detected\
    \ by users.\n   Where possible, they should thus only be exposed when they are\n\
    \   absolutely needed.  Because IDN labels can be rendered either as\n   A-labels\
    \ or U-labels, the application may reasonably have an option\n   for the user\
    \ to select the preferred method of display.  Rendering\n   the U-label should\
    \ normally be the default.\n   Domain names are often stored and transported in\
    \ many places.  For\n   example, they are part of documents such as mail messages\
    \ and web\n   pages.  They are transported in many parts of many protocols, such\
    \ as\n   both the control commands of SMTP and associated message body parts,\n\
    \   and in the headers and the body content in HTTP.  It is important to\n   remember\
    \ that domain names appear both in domain name slots and in\n   the content that\
    \ is passed over protocols, and it would be helpful if\n   protocols explicitly\
    \ define what their domain name slots are.\n   In protocols and document formats\
    \ that define how to handle\n   specification or negotiation of charsets, labels\
    \ can be encoded in\n   any charset allowed by the protocol or document format.\
    \  If a\n   protocol or document format only allows one charset, the labels must\n\
    \   be given in that charset.  Of course, not all charsets can properly\n   represent\
    \ all labels.  If a U-label cannot be displayed in its\n   entirety, the only\
    \ choice (without loss of information) may be to\n   display the A-label.\n  \
    \ Where a protocol or document format allows IDNs, labels should be in\n   whatever\
    \ character encoding and escape mechanism the protocol or\n   document format\
    \ uses in the local environment.  This provision is\n   intended to prevent situations\
    \ in which, e.g., UTF-8 domain names\n   appear embedded in text that is otherwise\
    \ in some other character\n   coding.\n   All protocols that use domain name slots\
    \ (see Section 2.3.2.6 in the\n   Definitions document [RFC5890]) already have\
    \ the capacity for\n   handling domain names in the ASCII charset.  Thus, A-labels\
    \ can\n   inherently be handled by those protocols.\n   IDNA2008 does not specify\
    \ required mappings between one character or\n   code point and others.  An extended\
    \ discussion of mapping issues\n   appears in Section 6 and specific recommendations\
    \ appear in the\n   Mapping document [IDNA2008-Mapping].  In general, IDNA2008\
    \ prohibits\n   characters that would be mapped to others by normalization or\
    \ other\n   rules.  As examples, while mathematical characters based on Latin\n\
    \   ones are accepted as input to IDNA2003, they are prohibited in\n   IDNA2008.\
    \  Similarly, uppercase characters, double-width characters,\n   and other variations\
    \ are prohibited as IDNA input although mapping\n   them as needed in user interfaces\
    \ is strongly encouraged.\n   Since the rules in the Tables document [RFC5892]\
    \ have the effect that\n   only strings that are not transformed by NFKC are valid,\
    \ if an\n   application chooses to perform NFKC normalization before lookup, that\n\
    \   operation is safe since this will never make the application unable\n   to\
    \ look up any valid string.  However, as discussed above, the\n   application\
    \ cannot guarantee that any other application will perform\n   that mapping, so\
    \ it should be used only with caution and for informed\n   users.\n   In many\
    \ cases, these prohibitions should have no effect on what the\n   user can type\
    \ as input to the lookup process.  It is perfectly\n   reasonable for systems\
    \ that support user interfaces to perform some\n   character mapping that is appropriate\
    \ to the local environment.  This\n   would normally be done prior to actual invocation\
    \ of IDNA.  At least\n   conceptually, the mapping would be part of the Unicode\
    \ conversions\n   discussed above and in the Protocol document [RFC5891].  However,\n\
    \   those changes will be local ones only -- local to environments in\n   which\
    \ users will clearly understand that the character forms are\n   equivalent. \
    \ For use in interchanges among systems, it appears to be\n   much more important\
    \ that U-labels and A-labels can be mapped back and\n   forth without loss of\
    \ information.\n   One specific, and very important, instance of this strategy\
    \ arises\n   with case folding.  In the ASCII-only DNS, names are looked up and\n\
    \   matched in a case-independent way, but no actual case folding occurs.\n  \
    \ Names can be placed in the DNS in either uppercase or lowercase form\n   (or\
    \ any mixture of them) and that form is preserved, returned in\n   queries, and\
    \ so on.  IDNA2003 approximated that behavior for\n   non-ASCII strings by performing\
    \ case folding at registration time\n   (resulting in only lowercase IDNs in the\
    \ DNS) and when names were\n   looked up.\n   As suggested earlier in this section,\
    \ it appears to be desirable to\n   do as little character mapping as possible\
    \ as long as Unicode works\n   correctly (e.g., Normalization Form C (NFC) mapping\
    \ to resolve\n   different codings for the same character is still necessary although\n\
    \   the specifications require that it be performed prior to invoking the\n  \
    \ protocol) in order to make the mapping between A-labels and U-labels\n   idempotent.\
    \  Case mapping is not an exception to this principle.  If\n   only lowercase\
    \ characters can be registered in the DNS (i.e., be\n   present in a U-label),\
    \ then IDNA2008 should prohibit uppercase\n   characters as input even though\
    \ user interfaces to applications\n   should probably map those characters.  Some\
    \ other considerations\n   reinforce this conclusion.  For example, in ASCII case\
    \ mapping for\n   individual characters, uppercase(character) is always equal\
    \ to\n   uppercase(lowercase(character)).  That may not be true with IDNs.  In\n\
    \   some scripts that use case distinctions, there are a few characters\n   that\
    \ do not have counterparts in one case or the other.  The\n   relationship between\
    \ uppercase and lowercase may even be language-\n   dependent, with different\
    \ languages (or even the same language in\n   different areas) expecting different\
    \ mappings.  User interface\n   programs can meet the expectations of users who\
    \ are accustomed to the\n   case-insensitive DNS environment by performing case\
    \ folding prior to\n   IDNA processing, but the IDNA procedures themselves should\
    \ neither\n   require such mapping nor expect them when they are not natural to\
    \ the\n   localized environment.\n"
- title: '4.3.  Linguistic Expectations: Ligatures, Digraphs, and Alternate'
  contents:
  - "4.3.  Linguistic Expectations: Ligatures, Digraphs, and Alternate\n      Character\
    \ Forms\n   Users have expectations about character matching or equivalence that\n\
    \   are based on their own languages and the orthography of those\n   languages.\
    \  These expectations may not always be met in a global\n   system, especially\
    \ if multiple languages are written using the same\n   script but using different\
    \ conventions.  Some examples:\n   o  A Norwegian user might expect a label with\
    \ the ae-ligature to be\n      treated as the same label as one using the Swedish\
    \ spelling with\n      a-diaeresis even though applying that mapping to English\
    \ would be\n      astonishing to users.\n   o  A German user might expect a label\
    \ with an o-umlaut and a label\n      that had \"oe\" substituted, but was otherwise\
    \ the same, to be\n      treated as equivalent even though that substitution would\
    \ be a\n      clear error in Swedish.\n   o  A Chinese user might expect automatic\
    \ matching of Simplified and\n      Traditional Chinese characters, but applying\
    \ that matching for\n      Korean or Japanese text would create considerable confusion.\n\
    \   o  An English user might expect \"theater\" and \"theatre\" to match.\n  \
    \ A number of languages use alphabetic scripts in which single phonemes\n   are\
    \ written using two characters, termed a \"digraph\", for example,\n   the \"\
    ph\" in \"pharmacy\" and \"telephone\".  (Such characters can also\n   appear\
    \ consecutively without forming a digraph, as in \"tophat\".)\n   Certain digraphs\
    \ may be indicated typographically by setting the two\n   characters closer together\
    \ than they would be if used consecutively\n   to represent different phonemes.\
    \  Some digraphs are fully joined as\n   ligatures.  For example, the word \"\
    encyclopaedia\" is sometimes set\n   with a U+00E6 LATIN SMALL LIGATURE AE.  When\
    \ ligature and digraph\n   forms have the same interpretation across all languages\
    \ that use a\n   given script, application of Unicode normalization generally\
    \ resolves\n   the differences and causes them to match.  When they have different\n\
    \   interpretations, matching must utilize other methods, presumably\n   chosen\
    \ at the registry level, or users must be educated to understand\n   that matching\
    \ will not occur.\n   The nature of the problem can be illustrated by many words\
    \ in the\n   Norwegian language, where the \"ae\" ligature is the 27th letter\
    \ of a\n   29-letter extended Latin alphabet.  It is equivalent to the 28th\n\
    \   letter of the Swedish alphabet (also containing 29 letters),\n   U+00E4 LATIN\
    \ SMALL LETTER A WITH DIAERESIS, for which an \"ae\" cannot\n   be substituted\
    \ according to current orthographic standards.  That\n   character (U+00E4) is\
    \ also part of the German alphabet where, unlike\n   in the Nordic languages,\
    \ the two-character sequence \"ae\" is usually\n   treated as a fully acceptable\
    \ alternate orthography for the \"umlauted\n   a\" character.  The inverse is\
    \ however not true, and those two\n   characters cannot necessarily be combined\
    \ into an \"umlauted a\".  This\n   also applies to another German character,\
    \ the \"umlauted o\"\n   (U+00F6 LATIN SMALL LETTER O WITH DIAERESIS) which, for\
    \ example,\n   cannot be used for writing the name of the author \"Goethe\". \
    \ It is\n   also a letter in the Swedish alphabet where, like the \"a with\n \
    \  diaeresis\", it cannot be correctly represented as \"oe\" and in the\n   Norwegian\
    \ alphabet, where it is represented, not as \"o with\n   diaeresis\", but as \"\
    slashed o\", U+00F8.\n   Some of the ligatures that have explicit code points\
    \ in Unicode were\n   given special handling in IDNA2003 and now pose additional\
    \ problems\n   in transition.  See Section 7.2.\n   Additional cases with alphabets\
    \ written right to left are described\n   in Section 4.5.\n   Matching and comparison\
    \ algorithm selection often requires\n   information about the language being\
    \ used, context, or both --\n   information that is not available to IDNA or the\
    \ DNS.  Consequently,\n   IDNA2008 makes no attempt to treat combined characters\
    \ in any special\n   way.  A registry that is aware of the language context in\
    \ which\n   labels are to be registered, and where that language sometimes (or\n\
    \   always) treats the two-character sequences as equivalent to the\n   combined\
    \ form, should give serious consideration to applying a\n   \"variant\" model\
    \ [RFC3743][RFC4290] or to prohibiting registration of\n   one of the forms entirely,\
    \ to reduce the opportunities for user\n   confusion and fraud that would result\
    \ from the related strings being\n   registered to different parties.\n"
- title: 4.4.  Case Mapping and Related Issues
  contents:
  - "4.4.  Case Mapping and Related Issues\n   In the DNS, ASCII letters are stored\
    \ with their case preserved.\n   Matching during the query process is case-independent,\
    \ but none of\n   the information that might be represented by choices of case\
    \ has been\n   lost.  That model has been accidentally helpful because, as people\n\
    \   have created DNS labels by catenating words (or parts of words) to\n   form\
    \ labels, case has often been used to distinguish among components\n   and make\
    \ the labels more memorable.\n   Since DNS servers do not get involved in parsing\
    \ IDNs, they cannot do\n   case-independent matching.  Thus, keeping the cases\
    \ separate in\n   lookup or registration, and doing matching at the server, is\
    \ not\n   feasible with IDNA or any similar approach.  Matching of characters\n\
    \   that are considered to differ only by case must be done, if desired,\n   by\
    \ programs invoking IDNA lookup even though it wasn't done by ASCII-\n   only\
    \ DNS clients.  That situation was recognized in IDNA2003 and\n   nothing in IDNA2008\
    \ fundamentally changes it or could do so.  In\n   IDNA2003, all characters are\
    \ case folded and mapped by clients in a\n   standardized step.\n   Even in scripts\
    \ that generally support case distinctions, some\n   characters do not have uppercase\
    \ forms.  For example, the Unicode\n   case-folding operation maps Greek Final\
    \ Form Sigma (U+03C2) to the\n   medial form (U+03C3) and maps Eszett (German\
    \ Sharp S, U+00DF) to\n   \"ss\".  Neither of these mappings is reversible because\
    \ the uppercase\n   of U+03C3 is the uppercase Sigma (U+03A3) and \"ss\" is an\
    \ ASCII\n   string.  IDNA2008 permits, at the risk of some incompatibility,\n\
    \   slightly more flexibility in this area by avoiding case folding and\n   treating\
    \ these characters as themselves.  Approaches to handling one-\n   way mappings\
    \ are discussed in Section 7.2.\n   Because IDNA2003 maps Final Sigma and Eszett\
    \ to other characters, and\n   the reverse mapping is never possible, neither\
    \ Final Sigma nor Eszett\n   can be represented in the ACE form of IDNA2003 IDN\
    \ nor in the native\n   character (U-label) form derived from it.  With IDNA2008,\
    \ both\n   characters can be used in an IDN and so the A-label used for lookup\n\
    \   for any U-label containing those characters is now different.  See\n   Section\
    \ 7.1 for a discussion of what kinds of changes might require\n   the IDNA prefix\
    \ to change; after extended discussions, the IDNABIS\n   Working Group came to\
    \ consensus that the change for these characters\n   did not justify a prefix\
    \ change.\n"
- title: 4.5.  Right-to-Left Text
  contents:
  - "4.5.  Right-to-Left Text\n   In order to be sure that the directionality of right-to-left\
    \ text is\n   unambiguous, IDNA2003 required that any label in which right-to-left\n\
    \   characters appear both starts and ends with them and that it does not\n  \
    \ include any characters with strong left-to-right properties (that\n   excludes\
    \ other alphabetic characters but permits European digits).\n   Any other string\
    \ that contains a right-to-left character and does not\n   meet those requirements\
    \ is rejected.  This is one of the few places\n   where the IDNA algorithms (both\
    \ in IDNA2003 and in IDNA2008) examine\n   an entire label, not just individual\
    \ characters.  The algorithmic\n   model used in IDNA2003 rejects the label when\
    \ the final character in\n   a right-to-left string requires a combining mark\
    \ in order to be\n   correctly represented.\n   That prohibition is not acceptable\
    \ for writing systems for languages\n   written with consonantal alphabets to\
    \ which diacritical vocalic\n   systems are applied, and for languages with orthographies\
    \ derived\n   from them where the combining marks may have different functionality.\n\
    \   In both cases, the combining marks can be essential components of the\n  \
    \ orthography.  Examples of this are Yiddish, written with an extended\n   Hebrew\
    \ script, and Dhivehi (the official language of Maldives), which\n   is written\
    \ in the Thaana script (which is, in turn, derived from the\n   Arabic script).\
    \  IDNA2008 removes the restriction on final combining\n   characters with a new\
    \ set of rules for right-to-left scripts and\n   their characters.  Those new\
    \ rules are specified in the Bidi document\n   [RFC5893].\n"
- title: 5.  IDNs and the Robustness Principle
  contents:
  - "5.  IDNs and the Robustness Principle\n   The \"Robustness Principle\" is often\
    \ stated as \"Be conservative about\n   what you send and liberal in what you\
    \ accept\" (see, e.g., Section\n   1.2.2 of the applications-layer Host Requirements\
    \ specification\n   [RFC1123]).  This principle applies to IDNA.  In applying\
    \ the\n   principle to registries as the source (\"sender\") of all registered\n\
    \   and useful IDNs, registries are responsible for being conservative\n   about\
    \ what they register and put out in the Internet.  For IDNs to\n   work well,\
    \ zone administrators (registries) must have and require\n   sensible policies\
    \ about what is registered -- conservative policies\n   -- and implement and enforce\
    \ them.\n   Conversely, lookup applications are expected to reject labels that\n\
    \   clearly violate global (protocol) rules (no one has ever seriously\n   claimed\
    \ that being liberal in what is accepted requires being\n   stupid).  However,\
    \ once one gets past such global rules and deals\n   with anything sensitive to\
    \ script or locale, it is necessary to\n   assume that garbage has not been placed\
    \ into the DNS, i.e., one must\n   be liberal about what one is willing to look\
    \ up in the DNS rather\n   than guessing about whether it should have been permitted\
    \ to be\n   registered.\n   If a string cannot be successfully found in the DNS\
    \ after the lookup\n   processing described here, it makes no difference whether\
    \ it simply\n   wasn't registered or was prohibited by some rule at the registry.\n\
    \   Application implementers should be aware that where DNS wildcards are\n  \
    \ used, the ability to successfully resolve a name does not guarantee\n   that\
    \ it was actually registered.\n"
- title: 6.  Front-end and User Interface Processing for Lookup
  contents:
  - "6.  Front-end and User Interface Processing for Lookup\n   Domain names may be\
    \ identified and processed in many contexts.  They\n   may be typed in by users\
    \ themselves or embedded in an identifier such\n   as an email address, URI, or\
    \ IRI.  They may occur in running text or\n   be processed by one system after\
    \ being provided in another.  Systems\n   may try to normalize URLs to determine\
    \ (or guess) whether a reference\n   is valid or if two references point to the\
    \ same object without\n   actually looking the objects up (comparison without\
    \ lookup is\n   necessary for URI types that are not intended to be resolved).\
    \  Some\n   of these goals may be more easily and reliably satisfied than others.\n\
    \   While there are strong arguments for any domain name that is placed\n   \"\
    on the wire\" -- transmitted between systems -- to be in the zero-\n   ambiguity\
    \ forms of A-labels, it is inevitable that programs that\n   process domain names\
    \ will encounter U-labels or variant forms.\n   An application that implements\
    \ the IDNA protocol [RFC5891] will\n   always take any user input and convert\
    \ it to a set of Unicode code\n   points.  That user input may be acquired by\
    \ any of several different\n   input methods, all with differing conversion processes\
    \ to be taken\n   into consideration (e.g., typed on a keyboard, written by hand\
    \ onto\n   some sort of digitizer, spoken into a microphone and interpreted by\
    \ a\n   speech-to-text engine, etc.).  The process of taking any particular\n\
    \   user input and mapping it into a Unicode code point may be a simple\n   one:\
    \ if a user strikes the \"A\" key on a US English keyboard, without\n   any modifiers\
    \ such as the \"Shift\" key held down, in order to draw a\n   Latin small letter\
    \ A (\"a\"), many (perhaps most) modern operating\n   system input methods will\
    \ produce to the calling application the code\n   point U+0061, encoded in a single\
    \ octet.\n   Sometimes the process is somewhat more complicated: a user might\n\
    \   strike a particular set of keys to represent a combining macron\n   followed\
    \ by striking the \"A\" key in order to draw a Latin small\n   letter A with a\
    \ macron above it.  Depending on the operating system,\n   the input method chosen\
    \ by the user, and even the parameters with\n   which the application communicates\
    \ with the input method, the result\n   might be the code point U+0101 (encoded\
    \ as two octets in UTF-8 or\n   UTF-16, four octets in UTF-32, etc.), the code\
    \ point U+0061 followed\n   by the code point U+0304 (again, encoded in three\
    \ or more octets,\n   depending upon the encoding used) or even the code point\
    \ U+FF41\n   followed by the code point U+0304 (and encoded in some form).  These\n\
    \   examples leave aside the issue of operating systems and input methods\n  \
    \ that do not use Unicode code points for their character set.\n   In every case,\
    \ applications (with the help of the operating systems\n   on which they run and\
    \ the input methods used) need to perform a\n   mapping from user input into Unicode\
    \ code points.\n   IDNA2003 used a model whereby input was taken from the user,\
    \ mapped\n   (via whatever input method mechanisms were used) to a set of Unicode\n\
    \   code points, and then further mapped to a set of Unicode code points\n   using\
    \ the Nameprep profile [RFC3491].  In this procedure, there are\n   two separate\
    \ mapping steps: first, a mapping done by the input method\n   (which might be\
    \ controlled by the operating system, the application,\n   or some combination)\
    \ and then a second mapping performed by the\n   Nameprep portion of the IDNA\
    \ protocol.  The mapping done in Nameprep\n   includes a particular mapping table\
    \ to re-map some characters to\n   other characters, a particular normalization,\
    \ and a set of prohibited\n   characters.\n   Note that the result of the two-step\
    \ mapping process means that the\n   mapping chosen by the operating system or\
    \ application in the first\n   step might differ significantly from the mapping\
    \ supplied by the\n   Nameprep profile in the second step.  This has advantages\
    \ and\n   disadvantages.  Of course, the second mapping regularizes what gets\n\
    \   looked up in the DNS, making for better interoperability between\n   implementations\
    \ that use the Nameprep mapping.  However, the\n   application or operating system\
    \ may choose mappings in their input\n   methods, which when passed through the\
    \ second (Nameprep) mapping\n   result in characters that are \"surprising\" to\
    \ the end user.\n   The other important feature of IDNA2003 is that, with very\
    \ few\n   exceptions, it assumes that any set of Unicode code points provided\n\
    \   to the Nameprep mapping can be mapped into a string of Unicode code\n   points\
    \ that are \"sensible\", even if that means mapping some code\n   points to nothing\
    \ (that is, removing the code points from the\n   string).  This allowed maximum\
    \ flexibility in input strings.\n   The present version of IDNA (IDNA2008) differs\
    \ significantly in\n   approach from the original version.  First and foremost,\
    \ it does not\n   provide explicit mapping instructions.  Instead, it assumes\
    \ that the\n   application (perhaps via an operating system input method) will\
    \ do\n   whatever mapping it requires to convert input into Unicode code\n   points.\
    \  This has the advantage of giving flexibility to the\n   application to choose\
    \ a mapping that is suitable for its user given\n   specific user requirements,\
    \ and avoids the two-step mapping of the\n   original protocol.  Instead of a\
    \ mapping, IDNA2008 provides a set of\n   categories that can be used to specify\
    \ the valid code points allowed\n   in a domain name.\n   In principle, an application\
    \ ought to take user input of a domain\n   name and convert it to the set of Unicode\
    \ code points that represent\n   the domain name the user intends.  As a practical\
    \ matter, of course,\n   determining user intent is a tricky business, so an application\
    \ needs\n   to choose a reasonable mapping from user input.  That may differ\n\
    \   based on the particular circumstances of a user, depending on locale,\n  \
    \ language, type of input method, etc.  It is up to the application to\n   make\
    \ a reasonable choice.\n"
- title: 7.  Migration from IDNA2003 and Unicode Version Synchronization
  contents:
  - '7.  Migration from IDNA2003 and Unicode Version Synchronization

    '
- title: 7.1.  Design Criteria
  contents:
  - "7.1.  Design Criteria\n   As mentioned above and in the IAB review and recommendations\
    \ for IDNs\n   [RFC4690], two key goals of the IDNA2008 design are:\n   o  to\
    \ enable applications to be agnostic about whether they are being\n      run in\
    \ environments supporting any Unicode version from 3.2\n      onward.\n   o  to\
    \ permit incrementally adding new characters, character groups,\n      scripts,\
    \ and other character collections as they are incorporated\n      into Unicode,\
    \ doing so without disruption and, in the long term,\n      without \"heavy\"\
    \ processes (an IETF consensus process is required\n      by the IDNA2008 specifications\
    \ and is expected to be required and\n      used until significant experience\
    \ accumulates with IDNA operations\n      and new versions of Unicode).\n"
- title: 7.1.1.  Summary and Discussion of IDNA Validity Criteria
  contents:
  - "7.1.1.  Summary and Discussion of IDNA Validity Criteria\n   The general criteria\
    \ for a label to be considered valid under IDNA\n   are (the actual rules are\
    \ rigorously defined in the Protocol\n   [RFC5891] and Tables [RFC5892] documents):\n\
    \   o  The characters are \"letters\", marks needed to form letters,\n      numerals,\
    \ or other code points used to write words in some\n      language.  Symbols,\
    \ drawing characters, and various notational\n      characters are intended to\
    \ be permanently excluded.  There is no\n      evidence that they are important\
    \ enough to Internet operations or\n      internationalization to justify expansion\
    \ of domain names beyond\n      the general principle of \"letters, digits, and\
    \ hyphen\".\n      (Additional discussion and rationale for the symbol decision\n\
    \      appears in Section 7.6.)\n   o  Other than in very exceptional cases, e.g.,\
    \ where they are needed\n      to write substantially any word of a given language,\
    \ punctuation\n      characters are excluded.  The fact that a word exists is\
    \ not proof\n      that it should be usable in a DNS label, and DNS labels are\
    \ not\n      expected to be usable for multiple-word phrases (although they are\n\
    \      certainly not prohibited if the conventions and orthography of a\n    \
    \  particular language cause that to be possible).\n   o  Characters that are\
    \ unassigned (have no character assignment at\n      all) in the version of Unicode\
    \ being used by the registry or\n      application are not permitted, even on\
    \ lookup.  The issues\n      involved in this decision are discussed in Section\
    \ 7.7.\n   o  Any character that is mapped to another character by a current\n\
    \      version of NFKC is prohibited as input to IDNA (for either\n      registration\
    \ or lookup).  With a few exceptions, this principle\n      excludes any character\
    \ mapped to another by Nameprep [RFC3491].\n   The principles above drive the\
    \ design of rules that are specified\n   exactly in the Tables document.  Those\
    \ rules identify the characters\n   that are valid under IDNA.  The rules themselves\
    \ are normative, and\n   the tables are derived from them, rather than vice versa.\n"
- title: 7.1.2.  Labels in Registration
  contents:
  - "7.1.2.  Labels in Registration\n   Any label registered in a DNS zone must be\
    \ validated -- i.e., the\n   criteria for that label must be met -- in order for\
    \ applications to\n   work as intended.  This principle is not new.  For example,\
    \ since the\n   DNS was first deployed, zone administrators have been expected\
    \ to\n   verify that names meet \"hostname\" requirements [RFC0952] where those\n\
    \   requirements are imposed by the expected applications.  Other\n   applications\
    \ contexts, such as the later addition of special service\n   location formats\
    \ [RFC2782] imposed new requirements on zone\n   administrators.  For zones that\
    \ will contain IDNs, support for\n   Unicode version-independence requires restrictions\
    \ on all strings\n   placed in the zone.  In particular, for such zones (the exact\
    \ rules\n   appear in Section 4 of the Protocol document [RFC5891]):\n   o  Any\
    \ label that appears to be an A-label, i.e., any label that\n      starts in \"\
    xn--\", must be valid under IDNA, i.e., they must be\n      valid A-labels, as\
    \ discussed in Section 2 above.\n   o  The Unicode tables (i.e., tables of code\
    \ points, character\n      classes, and properties) and IDNA tables (i.e., tables\
    \ of\n      contextual rules such as those that appear in the Tables\n      document),\
    \ must be consistent on the systems performing or\n      validating labels to\
    \ be registered.  Note that this does not\n      require that tables reflect the\
    \ latest version of Unicode, only\n      that all tables used on a given system\
    \ are consistent with each\n      other.\n   Under this model, registry tables\
    \ will need to be updated (both the\n   Unicode-associated tables and the tables\
    \ of permitted IDN characters)\n   to enable a new script or other set of new\
    \ characters.  The registry\n   will not be affected by newer versions of Unicode,\
    \ or newly\n   authorized characters, until and unless it wishes to support them.\n\
    \   The zone administrator is responsible for verifying validity for IDNA\n  \
    \ as well as its local policies -- a more extensive set of checks than\n   are\
    \ required for looking up the labels.  Systems looking up or\n   resolving DNS\
    \ labels, especially IDN DNS labels, must be able to\n   assume that applicable\
    \ registration rules were followed for names\n   entered into the DNS.\n"
- title: 7.1.3.  Labels in Lookup
  contents:
  - "7.1.3.  Labels in Lookup\n   Any application processing a label through IDNA\
    \ so it can be looked\n   up in a DNS zone is required to (the exact rules appear\
    \ in Section 5\n   of the Protocol document [RFC5891]):\n   o  Maintain IDNA and\
    \ Unicode tables that are consistent with regard\n      to versions, i.e., unless\
    \ the application actually executes the\n      classification rules in the Tables\
    \ document [RFC5892], its IDNA\n      tables must be derived from the version\
    \ of Unicode that is\n      supported more generally on the system.  As with registration,\
    \ the\n      tables need not reflect the latest version of Unicode, but they\n\
    \      must be consistent.\n   o  Validate the characters in labels to be looked\
    \ up only to the\n      extent of determining that the U-label does not contain\n\
    \      \"DISALLOWED\" code points or code points that are unassigned in its\n\
    \      version of Unicode.\n   o  Validate the label itself for conformance with\
    \ a small number of\n      whole-label rules.  In particular, it must verify that:\n\
    \      *  there are no leading combining marks,\n      *  the Bidi conditions\
    \ are met if right-to-left characters appear,\n      *  any required contextual\
    \ rules are available, and\n      *  any contextual rules that are associated\
    \ with joiner characters\n         (and CONTEXTJ characters more generally) are\
    \ tested.\n   o  Do not reject labels based on other contextual rules about\n\
    \      characters, including mixed-script label prohibitions.  Such rules\n  \
    \    may be used to influence presentation decisions in the user\n      interface,\
    \ but not to avoid looking up domain names.\n   To further clarify the rules about\
    \ handling characters that require\n   contextual rules, note that one can have\
    \ a context-required character\n   (i.e., one that requires a rule), but no rule.\
    \  In that case, the\n   character is treated the same way DISALLOWED characters\
    \ are treated,\n   until and unless a rule is supplied.  That state is more or\
    \ less\n   equivalent to \"the idea of permitting this character is accepted in\n\
    \   principle, but it won't be permitted in practice until consensus is\n   reached\
    \ on a safe way to use it\".\n   The ability to add a rule more or less exempts\
    \ these characters from\n   the prohibition against reclassifying characters from\
    \ DISALLOWED to\n   PVALID.\n   And, obviously, \"no rule\" is different from\
    \ \"have a rule, but the\n   test either succeeds or fails\".\n   Lookup applications\
    \ that follow these rules, rather than having their\n   own criteria for rejecting\
    \ lookup attempts, are not sensitive to\n   version incompatibilities with the\
    \ particular zone registry\n   associated with the domain name except for labels\
    \ containing\n   characters recently added to Unicode.\n   An application or client\
    \ that processes names according to this\n   protocol and then resolves them in\
    \ the DNS will be able to locate any\n   name that is registered, as long as those\
    \ registrations are valid\n   under IDNA and its version of the IDNA tables is\
    \ sufficiently up to\n   date to interpret all of the characters in the label.\
    \  Messages to\n   users should distinguish between \"label contains an unallocated\
    \ code\n   point\" and other types of lookup failures.  A failure on the basis\
    \ of\n   an old version of Unicode may lead the user to a desire to upgrade to\n\
    \   a newer version, but will have no other ill effects (this is\n   consistent\
    \ with behavior in the transition to the DNS when some hosts\n   could not yet\
    \ handle some forms of names or record types).\n"
- title: 7.2.  Changes in Character Interpretations
  contents:
  - "7.2.  Changes in Character Interpretations\n   As a consequence of the elimination\
    \ of mapping, the current version\n   of IDNA changes the interpretation of a\
    \ few characters relative to\n   its predecessors.  This subsection outlines the\
    \ issues and discusses\n   possible transition strategies.\n"
- title: '7.2.1.  Character Changes: Eszett and Final Sigma'
  contents:
  - "7.2.1.  Character Changes: Eszett and Final Sigma\n   In those scripts that make\
    \ case distinctions, there are a few\n   characters for which an obvious and unique\
    \ uppercase character has\n   not historically been available to match a lowercase\
    \ one, or vice\n   versa.  For those characters, the mappings used in constructing\
    \ the\n   Stringprep tables for IDNA2003, performed using the Unicode\n   toCaseFold\
    \ operation (see Section 5.18 of the Unicode Standard\n   [Unicode52]), generate\
    \ different characters or sets of characters.\n   Those operations are not reversible\
    \ and lose even more information\n   than traditional uppercase or lowercase transformations,\
    \ but are more\n   useful than those transformations for comparison purposes.\
    \  Two\n   notable characters of this type are the German character Eszett\n \
    \  (Sharp S, U+00DF) and the Greek Final Form Sigma (U+03C2).  The\n   former\
    \ is case folded to the ASCII string \"ss\", the latter to a\n   medial (lowercase)\
    \ Sigma (U+03C3).\n"
- title: '7.2.2.  Character Changes: Zero Width Joiner and Zero Width Non-Joiner'
  contents:
  - "7.2.2.  Character Changes: Zero Width Joiner and Zero Width Non-Joiner\n   IDNA2003\
    \ mapped both ZERO WIDTH JOINER (ZWJ, U+200D) and ZERO WIDTH\n   NON-JOINER (ZWNJ,\
    \ U+200C) to nothing, effectively dropping these\n   characters from any label\
    \ in which they appeared and treating strings\n   containing them as identical\
    \ to strings that did not.  As discussed\n   in Section 3.1.2 above, those characters\
    \ are essential for writing\n   many reasonable mnemonics for certain scripts.\
    \  However, treating\n   them as valid in IDNA2008, even with contextual restrictions,\
    \ raises\n   approximately the same problem as exists with Eszett and Final Sigma:\n\
    \   strings that were valid under IDNA2003 have different interpretations\n  \
    \ as labels, and different A-labels, than the same strings under this\n   newer\
    \ version.\n"
- title: 7.2.3.  Character Changes and the Need for Transition
  contents:
  - "7.2.3.  Character Changes and the Need for Transition\n   The decision to eliminate\
    \ mandatory and standardized mappings,\n   including case folding, from the IDNA2008\
    \ protocol in order to make\n   A-labels and U-labels idempotent made these characters\
    \ problematic.\n   If they were to be disallowed, important words and mnemonics\
    \ could\n   not be written in orthographically reasonable ways.  If they were\
    \ to\n   be permitted as distinct characters, there would be no information\n\
    \   loss and registries would have more flexibility, but IDNA2003 and\n   IDNA2008\
    \ lookups might result in different A-labels.\n   With the understanding that\
    \ there would be incompatibility either way\n   but a judgment that the incompatibility\
    \ was not significant enough to\n   justify a prefix change, the Working Group\
    \ concluded that Eszett and\n   Final Form Sigma should be treated as distinct\
    \ and Protocol-Valid\n   characters.\n   Since these characters are interpreted\
    \ in different ways under the\n   older and newer versions of IDNA, transition\
    \ strategies and policies\n   will be necessary.  Some actions can reasonably\
    \ be taken by\n   applications' client programs (those that perform lookup operations\n\
    \   or cause them to be performed), but because of the diversity of\n   situations\
    \ and uses of the DNS, much of the responsibility will need\n   to fall on registries.\n\
    \   Registries, especially those maintaining zones for third parties,\n   must\
    \ decide how to introduce a new service in a way that does not\n   create confusion\
    \ or significantly weaken or invalidate existing\n   identifiers.  This is not\
    \ a new problem; registries were faced with\n   similar issues when IDNs were\
    \ introduced (potentially, and especially\n   for Latin-based scripts, in conflict\
    \ with existing labels that had\n   been rendered in ASCII characters by applying\
    \ more or less\n   standardized conventions) and when other new forms of strings\
    \ have\n   been permitted as labels.\n"
- title: 7.2.4.  Transition Strategies
  contents:
  - "7.2.4.  Transition Strategies\n   There are several approaches to the introduction\
    \ of new characters or\n   changes in interpretation of existing characters from\
    \ their mapped\n   forms in the earlier version of IDNA.  The transition issue\
    \ is\n   complicated because the forms of these labels after the\n   ToUnicode(ToASCII())\
    \ translation in IDNA2003 not only remain valid\n   but do not provide strong\
    \ indications of what the registrant\n   intended: a string containing \"ss\"\
    \ could have simply been intended to\n   be that string or could have been intended\
    \ to contain an Eszett; a\n   string containing lowercase Sigma could have been\
    \ intended to contain\n   Final Sigma (one might make heuristic guesses based\
    \ on position in a\n   string, but the long tradition of forming labels by concatenating\n\
    \   words makes such heuristics unreliable), and strings that do not\n   contain\
    \ ZWJ or ZWNJ might have been intended to contain them.\n   Without any preference\
    \ or claim to completeness, some of these, all\n   of which have been used by\
    \ registries in the past for similar\n   transitions, are:\n   1.  Do not permit\
    \ use of the newly available character at the\n       registry level.  This might\
    \ cause lookup failures if a domain\n       name were to be written with the expectation\
    \ of the IDNA2003\n       mapping behavior, but would eliminate any possibility\
    \ of false\n       matches.\n   2.  Hold a \"sunrise\"-like arrangement in which\
    \ holders of labels\n       containing \"ss\" in the Eszett case, lowercase Sigma\
    \ in that case,\n       or that might have contained ZWJ or ZWNJ in context, are\
    \ given\n       priority (and perhaps other benefits) for registering the\n  \
    \     corresponding string containing Eszett, Final Sigma, or the\n       appropriate\
    \ zero-width character respectively.\n   3.  Adopt some sort of \"variant\" approach\
    \ in which registrants obtain\n       labels with both character forms.\n   4.\
    \  Adopt a different form of \"variant\" approach in which\n       registration\
    \ of additional strings that would produce the same\n       A-label if interpreted\
    \ according to IDNA2003 is either not\n       permitted at all or permitted only\
    \ by the registrant who already\n       has one of the names.\n   5.  Ignore the\
    \ issue and assume that the marketplace or other\n       mechanisms will sort\
    \ things out.\n   In any event, a registry (at any level of the DNS tree) that\
    \ chooses\n   to permit labels to be registered that contains these characters,\
    \ or\n   considers doing so, will have to address the relationship with\n   existing,\
    \ possibly conflicting, labels in some way, just as\n   registries that already\
    \ had a considerable number of labels did when\n   IDNs were first introduced.\n"
- title: 7.3.  Elimination of Character Mapping
  contents:
  - "7.3.  Elimination of Character Mapping\n   As discussed at length in Section\
    \ 6, IDNA2003, via Nameprep (see\n   Section 7.5), mapped many characters into\
    \ related ones.  Those\n   mappings no longer exist as requirements in IDNA2008.\
    \  These\n   specifications strongly prefer that only A-labels or U-labels be\
    \ used\n   in protocol contexts and as much as practical more generally.\n   IDNA2008\
    \ does anticipate situations in which some mapping at the time\n   of user input\
    \ into lookup applications is appropriate and desirable.\n   The issues are discussed\
    \ in Section 6 and specific recommendations\n   are made in the Mapping document\
    \ [IDNA2008-Mapping].\n"
- title: 7.4.  The Question of Prefix Changes
  contents:
  - "7.4.  The Question of Prefix Changes\n   The conditions that would have required\
    \ a change in the IDNA ACE\n   prefix (\"xn--\", used in IDNA2003) were of great\
    \ concern to the\n   community.  A prefix change would have clearly been necessary\
    \ if the\n   algorithms were modified in a manner that would have created serious\n\
    \   ambiguities during subsequent transition in registrations.  This\n   section\
    \ summarizes the working group's conclusions about the\n   conditions under which\
    \ a change in the prefix would have been\n   necessary and the implications of\
    \ such a change.\n"
- title: 7.4.1.  Conditions Requiring a Prefix Change
  contents:
  - "7.4.1.  Conditions Requiring a Prefix Change\n   An IDN prefix change would have\
    \ been needed if a given string would\n   be looked up or otherwise interpreted\
    \ differently depending on the\n   version of the protocol or tables being used.\
    \  This IDNA upgrade\n   would have required a prefix change if, and only if,\
    \ one of the\n   following four conditions were met:\n   1.  The conversion of\
    \ an A-label to Unicode (i.e., a U-label) would\n       have yielded one string\
    \ under IDNA2003 and a different string\n       under IDNA2008.\n   2.  In a significant\
    \ number of cases, an input string that was valid\n       under IDNA2003 and also\
    \ valid under IDNA2008 would have yielded\n       two different A-labels with\
    \ the different versions.  This\n       condition is believed to be essentially\
    \ equivalent to the one\n       above except for a very small number of edge cases\
    \ that were not\n       found to justify a prefix change (see Section 7.2).\n\
    \       Note that if the input string was valid under one version and not\n  \
    \     valid under the other, this condition would not apply.  See the\n      \
    \ first item in Section 7.4.2, below.\n   3.  A fundamental change was made to\
    \ the semantics of the string that\n       would be inserted in the DNS, e.g.,\
    \ if a decision were made to\n       try to include language or script information\
    \ in the encoding in\n       addition to the string itself.\n   4.  A sufficiently\
    \ large number of characters were added to Unicode\n       so that the Punycode\
    \ mechanism for block offsets would no longer\n       reference the higher-numbered\
    \ planes and blocks.  This condition\n       is unlikely even in the long term\
    \ and certain not to arise in the\n       next several years.\n"
- title: 7.4.2.  Conditions Not Requiring a Prefix Change
  contents:
  - "7.4.2.  Conditions Not Requiring a Prefix Change\n   As a result of the principles\
    \ described above, none of the following\n   changes required a new prefix:\n\
    \   1.  Prohibition of some characters as input to IDNA.  Such a\n       prohibition\
    \ might make names that were previously registered\n       inaccessible, but did\
    \ not change those names.\n   2.  Adjustments in IDNA tables or actions, including\
    \ normalization\n       definitions, that affected characters that were already\
    \ invalid\n       under IDNA2003.\n   3.  Changes in the style of the IDNA definition\
    \ that did not alter\n       the actions performed by IDNA.\n"
- title: 7.4.3.  Implications of Prefix Changes
  contents:
  - "7.4.3.  Implications of Prefix Changes\n   While it might have been possible\
    \ to make a prefix change, the costs\n   of such a change are considerable.  Registries\
    \ could not have\n   converted all IDNA2003 (\"xn--\") registrations to a new\
    \ form at the\n   same time and synchronize that change with applications supporting\n\
    \   lookup.  Unless all existing registrations were simply to be declared\n  \
    \ invalid (and perhaps even then), systems that needed to support both\n   labels\
    \ with old prefixes and labels with new ones would be required\n   to first process\
    \ a putative label under the IDNA2008 rules and try to\n   look it up and then,\
    \ if it were not found, would be required to\n   process the label under IDNA2003\
    \ rules and look it up again.  That\n   process would probably have significantly\
    \ slowed down all processing\n   that involved IDNs in the DNS, especially since\
    \ a fully-qualified\n   name might contain a mixture of labels that were registered\
    \ with the\n   old and new prefixes.  That would have made DNS caching very\n\
    \   difficult.  In addition, looking up the same input string as two\n   separate\
    \ A-labels would have created some potential for confusion and\n   attacks, since\
    \ the labels could map to different targets and then\n   resolve to different\
    \ entries in the DNS.\n   Consequently, a prefix change should have been, and\
    \ was, avoided if\n   at all possible, even if it means accepting some IDNA2003\
    \ decisions\n   about character distinctions as irreversible and/or giving special\n\
    \   treatment to edge cases.\n"
- title: 7.5.  Stringprep Changes and Compatibility
  contents:
  - "7.5.  Stringprep Changes and Compatibility\n   The Nameprep specification [RFC3491],\
    \ a key part of IDNA2003, is a\n   profile of Stringprep [RFC3454].  While Nameprep\
    \ is a Stringprep\n   profile specific to IDNA, Stringprep is used by a number\
    \ of other\n   protocols.  Were Stringprep to have been modified by IDNA2008,\
    \ those\n   changes to improve the handling of IDNs could cause problems for\n\
    \   non-DNS uses, most notably if they affected identification and\n   authentication\
    \ protocols.  Several elements of IDNA2008 give\n   interpretations to strings\
    \ prohibited under IDNA2003 or prohibit\n   strings that IDNA2003 permitted. \
    \ Those elements include the new\n   inclusion information in the Tables document\
    \ [RFC5892], the reduction\n   in the number of characters permitted as input\
    \ for registration or\n   lookup (Section 3), and even the changes in handling\
    \ of right-to-left\n   strings as described in the Bidi document [RFC5893].  IDNA2008\
    \ does\n   not use Nameprep or Stringprep at all, so there are no side-effect\n\
    \   changes to other protocols.\n   It is particularly important to keep IDNA\
    \ processing separate from\n   processing for various security protocols because\
    \ some of the\n   constraints that are necessary for smooth and comprehensible\
    \ use of\n   IDNs may be unwanted or undesirable in other contexts.  For example,\n\
    \   the criteria for good passwords or passphrases are very different\n   from\
    \ those for desirable IDNs: passwords should be hard to guess,\n   while domain\
    \ names should normally be easily memorable.  Similarly,\n   internationalized\
    \ Small Computer System Interface (SCSI) identifiers\n   and other protocol components\
    \ are likely to have different\n   requirements than IDNs.\n"
- title: 7.6.  The Symbol Question
  contents:
  - "7.6.  The Symbol Question\n   One of the major differences between this specification\
    \ and the\n   original version of IDNA is that IDNA2003 permitted non-letter\n\
    \   symbols of various sorts, including punctuation and line-drawing\n   symbols,\
    \ in the protocol.  They were always discouraged in practice.\n   In particular,\
    \ both the \"IESG Statement\" about IDNA and all versions\n   of the ICANN Guidelines\
    \ specify that only language characters be used\n   in labels.  This specification\
    \ disallows symbols entirely.  There are\n   several reasons for this, which include:\n\
    \   1.  As discussed elsewhere, the original IDNA specification assumed\n    \
    \   that as many Unicode characters as possible should be permitted,\n       directly\
    \ or via mapping to other characters, in IDNs.  This\n       specification operates\
    \ on an inclusion model, extrapolating from\n       the original \"hostname\"\
    \ rules (LDH, see the Definitions document\n       [RFC5890]) -- which have served\
    \ the Internet very well -- to a\n       Unicode base rather than an ASCII base.\n\
    \   2.  Symbol names are more problematic than letters because there may\n   \
    \    be no general agreement on whether a particular glyph matches a\n       symbol;\
    \ there are no uniform conventions for naming; variations\n       such as outline,\
    \ solid, and shaded forms may or may not exist;\n       and so on.  As just one\
    \ example, consider a \"heart\" symbol as it\n       might appear in a logo that\
    \ might be read as \"I love...\".  While\n       the user might read such a logo\
    \ as \"I love...\" or \"I heart...\",\n       considerable knowledge of the coding\
    \ distinctions made in Unicode\n       is needed to know that there is more than\
    \ one \"heart\" character\n       (e.g., U+2665, U+2661, and U+2765) and how to\
    \ describe it.  These\n       issues are of particular importance if strings are\
    \ expected to be\n       understood or transcribed by the listener after being\
    \ read out\n       loud.\n   3.  Design of a screen reader used by blind Internet\
    \ users who must\n       listen to renderings of IDN domain names and possibly\
    \ reproduce\n       them on the keyboard becomes considerably more complicated\
    \ when\n       the names of characters are not obvious and intuitive to anyone\n\
    \       familiar with the language in question.\n   4.  As a simplified example\
    \ of this, assume one wanted to use a\n       \"heart\" or \"star\" symbol in\
    \ a label.  This is problematic because\n       those names are ambiguous in the\
    \ Unicode system of naming (the\n       actual Unicode names require far more\
    \ qualification).  A user or\n       would-be registrant has no way to know --\
    \ absent careful study of\n       the code tables -- whether it is ambiguous (e.g.,\
    \ where there are\n       multiple \"heart\" characters) or not.  Conversely,\
    \ the user seeing\n       the hypothetical label doesn't know whether to read\
    \ it -- try to\n       transmit it to a colleague by voice -- as \"heart\", as\
    \ \"love\", as\n       \"black heart\", or as any of the other examples below.\n\
    \   5.  The actual situation is even worse than this.  There is no\n       possible\
    \ way for a normal, casual, user to tell the difference\n       between the hearts\
    \ of U+2665 and U+2765 and the stars of U+2606\n       and U+2729 without somehow\
    \ knowing to look for a distinction.  We\n       have a white heart (U+2661) and\
    \ few black hearts.  Consequently,\n       describing a label as containing a\
    \ heart is hopelessly ambiguous:\n       we can only know that it contains one\
    \ of several characters that\n       look like hearts or have \"heart\" in their\
    \ names.  In cities where\n       \"Square\" is a popular part of a location name,\
    \ one might well\n       want to use a square symbol in a label as well and there\
    \ are far\n       more squares of various flavors in Unicode than there are hearts\n\
    \       or stars.\n   The consequence of these ambiguities is that symbols are\
    \ a very poor\n   basis for reliable communication.  Consistent with this conclusion,\n\
    \   the Unicode standard recommends that strings used in identifiers not\n   contain\
    \ symbols or punctuation [Unicode-UAX31].  Of course, these\n   difficulties with\
    \ symbols do not arise with actual pictographic\n   languages and scripts which\
    \ would be treated like any other language\n   characters; the two should not\
    \ be confused.\n"
- title: '7.7.  Migration between Unicode Versions: Unassigned Code Points'
  contents:
  - "7.7.  Migration between Unicode Versions: Unassigned Code Points\n   In IDNA2003,\
    \ labels containing unassigned code points are looked up\n   on the assumption\
    \ that, if they appear in labels and can be mapped\n   and then resolved, the\
    \ relevant standards must have changed and the\n   registry has properly allocated\
    \ only assigned values.\n   In the IDNA2008 protocol, strings containing unassigned\
    \ code points\n   must not be either looked up or registered.  In summary, the\
    \ status\n   of an unassigned character with regard to the DISALLOWED,\n   PROTOCOL-VALID,\
    \ and CONTEXTUAL RULE REQUIRED categories cannot be\n   evaluated until a character\
    \ is actually assigned and known.  There\n   are several reasons for this, with\
    \ the most important ones being:\n   o  Tests involving the context of characters\
    \ (e.g., some characters\n      being permitted only adjacent to others of specific\
    \ types) and\n      integrity tests on complete labels are needed.  Unassigned\
    \ code\n      points cannot be permitted because one cannot determine whether\n\
    \      particular code points will require contextual rules (and what\n      those\
    \ rules should be) before characters are assigned to them and\n      the properties\
    \ of those characters fully understood.\n   o  It cannot be known in advance,\
    \ and with sufficient reliability,\n      whether a newly assigned code point\
    \ will be associated with a\n      character that would be disallowed by the rules\
    \ in the Tables\n      document [RFC5892] (such as a compatibility character).\
    \  In\n      IDNA2003, since there is no direct dependency on NFKC (many of the\n\
    \      entries in Stringprep's tables are based on NFKC, but IDNA2003\n      depends\
    \ only on Stringprep), allocation of a compatibility\n      character might produce\
    \ some odd situations, but it would not be a\n      problem.  In IDNA2008, where\
    \ compatibility characters are\n      DISALLOWED unless character-specific exceptions\
    \ are made,\n      permitting strings containing unassigned characters to be looked\n\
    \      up would violate the principle that characters in DISALLOWED are\n    \
    \  not looked up.\n   o  The Unicode Standard specifies that an unassigned code\
    \ point\n      normalizes (and, where relevant, case folds) to itself.  If the\n\
    \      code point is later assigned to a character, and particularly if\n    \
    \  the newly assigned code point has a combining class that\n      determines\
    \ its placement relative to other combining characters,\n      it could normalize\
    \ to some other code point or sequence.\n   It is possible to argue that the issues\
    \ above are not important and\n   that, as a consequence, it is better to retain\
    \ the principle of\n   looking up labels even if they contain unassigned characters\
    \ because\n   all of the important scripts and characters have been coded as of\n\
    \   Unicode 5.2 (or even earlier), and hence unassigned code points will\n   be\
    \ assigned only to obscure characters or archaic scripts.\n   Unfortunately, that\
    \ does not appear to be a safe assumption for at\n   least two reasons.  First,\
    \ much the same claim of completeness has\n   been made for earlier versions of\
    \ Unicode.  The reality is that a\n   script that is obscure to much of the world\
    \ may still be very\n   important to those who use it.  Cultural and linguistic\
    \ preservation\n   principles make it inappropriate to declare the script of no\n\
    \   importance in IDNs.  Second, we already have counterexamples, e.g.,\n   in\
    \ the relationships associated with new Han characters being added\n   (whether\
    \ in the BMP or in Unicode Plane 2).\n   Independent of the technical transition\
    \ issues identified above, it\n   can be observed that any addition of characters\
    \ to an existing script\n   to make it easier to use or to better accommodate\
    \ particular\n   languages may lead to transition issues.  Such additions may\
    \ change\n   the preferred form for writing a particular string, changes that\
    \ may\n   be reflected, e.g., in keyboard transition modules that would\n   necessarily\
    \ be different from those for earlier versions of Unicode\n   where the newer\
    \ characters may not exist.  This creates an inherent\n   transition problem because\
    \ attempts to access labels may use either\n   the old or the new conventions,\
    \ requiring registry action whether or\n   not the older conventions were used\
    \ in labels.  The need to consider\n   transition mechanisms is inherent to evolution\
    \ of Unicode to better\n   accommodate writing systems and is independent of how\
    \ IDNs are\n   represented in the DNS or how transitions among versions of those\n\
    \   mechanisms occur.  The requirement for transitions of this type is\n   illustrated\
    \ by the addition of Malayalam Chillu in Unicode 5.1.0.\n"
- title: 7.8.  Other Compatibility Issues
  contents:
  - "7.8.  Other Compatibility Issues\n   The 2003 IDNA model includes several odd\
    \ artifacts of the context in\n   which it was developed.  Many, if not all, of\
    \ these are potential\n   avenues for exploits, especially if the registration\
    \ process permits\n   \"source\" names (names that have not been processed through\
    \ IDNA and\n   Nameprep) to be registered.  As one example, since the character\n\
    \   Eszett, used in German, is mapped by IDNA2003 into the sequence \"ss\"\n \
    \  rather than being retained as itself or prohibited, a string\n   containing\
    \ that character, but that is otherwise in ASCII, is not\n   really an IDN (in\
    \ the U-label sense defined above).  After Nameprep\n   maps out the Eszett, the\
    \ result is an ASCII string and so it does not\n   get an xn-- prefix, but the\
    \ string that can be displayed to a user\n   appears to be an IDN.  IDNA2008 eliminates\
    \ this artifact.  A\n   character is either permitted as itself or it is prohibited;\
    \ special\n   cases that make sense only in a particular linguistic or cultural\n\
    \   context can be dealt with as localization matters where appropriate.\n"
- title: 8.  Name Server Considerations
  contents:
  - '8.  Name Server Considerations

    '
- title: 8.1.  Processing Non-ASCII Strings
  contents:
  - "8.1.  Processing Non-ASCII Strings\n   Existing DNS servers do not know the IDNA\
    \ rules for handling\n   non-ASCII forms of IDNs, and therefore need to be shielded\
    \ from them.\n   All existing channels through which names can enter a DNS server\n\
    \   database (for example, master files (as described in RFC 1034) and\n   DNS\
    \ update messages [RFC2136]) could not be IDNA-aware because they\n   predate\
    \ IDNA.  Other sections of this document provide the needed\n   shielding by ensuring\
    \ that internationalized domain names entering\n   DNS server databases through\
    \ such channels have already been\n   converted to their equivalent ASCII A-label\
    \ forms.\n   Because of the distinction made between the algorithms for\n   Registration\
    \ and Lookup in Sections 4 and 5 (respectively) of the\n   Protocol document [RFC5891]\
    \ (a domain name containing only ASCII code\n   points cannot be converted to\
    \ an A-label), there cannot be more than\n   one A-label form for any given U-label.\n\
    \   As specified in clarifications to the DNS specification [RFC2181],\n   the\
    \ DNS protocol explicitly allows domain labels to contain octets\n   beyond the\
    \ ASCII range (0000..007F), and this document does not\n   change that.  However,\
    \ although the interpretation of octets\n   0080..00FF is well-defined in the\
    \ DNS, many application protocols\n   support only ASCII labels and there is no\
    \ defined interpretation of\n   these non-ASCII octets as characters and, in particular,\
    \ no\n   interpretation of case-independent matching for them (e.g., see the\n\
    \   clarification on DNS case insensitivity [RFC4343]).  If labels\n   containing\
    \ these octets are returned to applications, unpredictable\n   behavior could\
    \ result.  The A-label form, which cannot contain those\n   characters, is the\
    \ only standard representation for internationalized\n   labels in the DNS protocol.\n"
- title: 8.2.  Root and Other DNS Server Considerations
  contents:
  - "8.2.  Root and Other DNS Server Considerations\n   IDNs in A-label form will\
    \ generally be somewhat longer than current\n   domain names, so the bandwidth\
    \ needed by the root servers is likely\n   to go up by a small amount.  Also,\
    \ queries and responses for IDNs\n   will probably be somewhat longer than typical\
    \ queries historically,\n   so Extension Mechanisms for DNS (EDNS0) [RFC2671]\
    \ support may be more\n   important (otherwise, queries and responses may be forced\
    \ to go to\n   TCP instead of UDP).\n"
- title: 9.  Internationalization Considerations
  contents:
  - "9.  Internationalization Considerations\n   DNS labels and fully-qualified domain\
    \ names provide mnemonics that\n   assist in identifying and referring to resources\
    \ on the Internet.\n   IDNs expand the range of those mnemonics to include those\
    \ based on\n   languages and character sets other than Western European and Roman-\n\
    \   derived ones.  But domain \"names\" are not, in general, words in any\n  \
    \ language.  The recommendations of the IETF policy on character sets\n   and\
    \ languages (BCP 18 [RFC2277]) are applicable to situations in\n   which language\
    \ identification is used to provide language-specific\n   contexts.  The DNS is,\
    \ by contrast, global and international and\n   ultimately has nothing to do with\
    \ languages.  Adding languages (or\n   similar context) to IDNs generally, or\
    \ to DNS matching in particular,\n   would imply context-dependent matching in\
    \ DNS, which would be a very\n   significant change to the DNS protocol itself.\
    \  It would also imply\n   that users would need to identify the language associated\
    \ with a\n   particular label in order to look that label up.  That knowledge\
    \ is\n   generally not available because many labels are not words in any\n  \
    \ language and some may be words in more than one.\n"
- title: 10.  IANA Considerations
  contents:
  - "10.  IANA Considerations\n   This section gives an overview of IANA registries\
    \ required for IDNA.\n   The actual definitions of, and specifications for, the\
    \ first two,\n   which have been newly created for IDNA2008, appear in the Tables\n\
    \   document [RFC5892].  This document describes the registries, but it\n   does\
    \ not specify any IANA actions.\n"
- title: 10.1.  IDNA Character Registry
  contents:
  - "10.1.  IDNA Character Registry\n   The distinction among the major categories\
    \ \"UNASSIGNED\",\n   \"DISALLOWED\", \"PROTOCOL-VALID\", and \"CONTEXTUAL RULE\
    \ REQUIRED\" is\n   made by special categories and rules that are integral elements\
    \ of\n   the Tables document.  While not normative, an IANA registry of\n   characters\
    \ and scripts and their categories, updated for each new\n   version of Unicode\
    \ and the characters it contains, are convenient for\n   programming and validation\
    \ purposes.  The details of this registry\n   are specified in the Tables document.\n"
- title: 10.2.  IDNA Context Registry
  contents:
  - "10.2.  IDNA Context Registry\n   IANA has created and now maintains a list of\
    \ approved contextual\n   rules for characters that are defined in the IDNA Character\
    \ Registry\n   list as requiring a Contextual Rule (i.e., the types of rules\n\
    \   described in Section 3.1.2).  The details for those rules appear in\n   the\
    \ Tables document.\n"
- title: 10.3.  IANA Repository of IDN Practices of TLDs
  contents:
  - "10.3.  IANA Repository of IDN Practices of TLDs\n   This registry, historically\
    \ described as the \"IANA Language Character\n   Set Registry\" or \"IANA Script\
    \ Registry\" (both somewhat misleading\n   terms), is maintained by IANA at the\
    \ request of ICANN.  It is used to\n   provide a central documentation repository\
    \ of the IDN policies used\n   by top level domain (TLD) registries who volunteer\
    \ to contribute to\n   it and is used in conjunction with ICANN Guidelines for\
    \ IDN use.\n   It is not an IETF-managed registry and, while the protocol changes\n\
    \   specified here may call for some revisions to the tables, IDNA2008\n   has\
    \ no direct effect on that registry and no IANA action is required\n   as a result.\n"
- title: 11.  Security Considerations
  contents:
  - '11.  Security Considerations

    '
- title: 11.1.  General Security Issues with IDNA
  contents:
  - "11.1.  General Security Issues with IDNA\n   This document is purely explanatory\
    \ and informational and\n   consequently introduces no new security issues.  It\
    \ would, of course,\n   be a poor idea for someone to try to implement from it;\
    \ such an\n   attempt would almost certainly lead to interoperability problems\
    \ and\n   might lead to security ones.  A discussion of security issues with\n\
    \   IDNA, including some relevant history, appears in the Definitions\n   document\
    \ [RFC5890].\n"
- title: 12.  Acknowledgments
  contents:
  - "12.  Acknowledgments\n   The editor and contributors would like to express their\
    \ thanks to\n   those who contributed significant early (pre-working group) review\n\
    \   comments, sometimes accompanied by text, Paul Hoffman, Simon\n   Josefsson,\
    \ and Sam Weiler.  In addition, some specific ideas were\n   incorporated from\
    \ suggestions, text, or comments about sections that\n   were unclear supplied\
    \ by Vint Cerf, Frank Ellerman, Michael Everson,\n   Asmus Freytag, Erik van der\
    \ Poel, Michel Suignard, and Ken Whistler.\n   Thanks are also due to Vint Cerf,\
    \ Lisa Dusseault, Debbie Garside, and\n   Jefsey Morfin for conversations that\
    \ led to considerable improvements\n   in the content of this document and to\
    \ several others, including Ben\n   Campbell, Martin Duerst, Subramanian Moonesamy,\
    \ Peter Saint-Andre,\n   and Dan Winship, for catching specific errors and recommending\n\
    \   corrections.\n   A meeting was held on 30 January 2008 to attempt to reconcile\n\
    \   differences in perspective and terminology about this set of\n   specifications\
    \ between the design team and members of the Unicode\n   Technical Consortium.\
    \  The discussions at and subsequent to that\n   meeting were very helpful in\
    \ focusing the issues and in refining the\n   specifications.  The active participants\
    \ at that meeting were (in\n   alphabetic order, as usual) Harald Alvestrand,\
    \ Vint Cerf, Tina Dam,\n   Mark Davis, Lisa Dusseault, Patrik Faltstrom (by telephone),\
    \ Cary\n   Karp, John Klensin, Warren Kumari, Lisa Moore, Erik van der Poel,\n\
    \   Michel Suignard, and Ken Whistler.  We express our thanks to Google\n   for\
    \ support of that meeting and to the participants for their\n   contributions.\n\
    \   Useful comments and text on the working group versions of the working\n  \
    \ draft were received from many participants in the IETF \"IDNABIS\"\n   working\
    \ group and a number of document changes resulted from mailing\n   list discussions\
    \ made by that group.  Marcos Sanz provided specific\n   analysis and suggestions\
    \ that were exceptionally helpful in refining\n   the text, as did Vint Cerf,\
    \ Martin Duerst, Andrew Sullivan, and Ken\n   Whistler.  Lisa Dusseault provided\
    \ extensive editorial suggestions\n   during the spring of 2009, most of which\
    \ were incorporated.\n"
- title: 13.  Contributors
  contents:
  - "13.  Contributors\n   While the listed editor held the pen, the core of this\
    \ document and\n   the initial working group version represents the joint work\
    \ and\n   conclusions of an ad hoc design team consisting of the editor and, in\n\
    \   alphabetic order, Harald Alvestrand, Tina Dam, Patrik Faltstrom, and\n   Cary\
    \ Karp.  Considerable material describing mapping principles has\n   been incorporated\
    \ from a draft of the Mapping document\n   [IDNA2008-Mapping] by Pete Resnick\
    \ and Paul Hoffman.  In addition,\n   there were many specific contributions and\
    \ helpful comments from\n   those listed in the Acknowledgments section and others\
    \ who have\n   contributed to the development and use of the IDNA protocols.\n"
- title: 14.  References
  contents:
  - '14.  References

    '
- title: 14.1.  Normative References
  contents:
  - "14.1.  Normative References\n   [RFC3490]    Faltstrom, P., Hoffman, P., and\
    \ A. Costello,\n                \"Internationalizing Domain Names in Applications\n\
    \                (IDNA)\", RFC 3490, March 2003.\n   [RFC3492]    Costello, A.,\
    \ \"Punycode: A Bootstring encoding of\n                Unicode for Internationalized\
    \ Domain Names in\n                Applications (IDNA)\", RFC 3492, March 2003.\n\
    \   [RFC5890]    Klensin, J., \"Internationalized Domain Names for\n         \
    \       Applications (IDNA): Definitions and Document\n                Framework\"\
    , RFC 5890, August 2010.\n   [RFC5891]    Klensin, J., \"Internationalized Domain\
    \ Names in\n                Applications (IDNA): Protocol\", RFC 5891, August\
    \ 2010.\n   [RFC5892]    Faltstrom, P., \"The Unicode Code Points and\n      \
    \          Internationalized Domain Names for Applications (IDNA)\",\n       \
    \         RFC 5892, August 2010.\n   [RFC5893]    Alvestrand, H. and C. Karp,\
    \ \"Right-to-Left Scripts for\n                Internationalized Domain Names\
    \ for Applications (IDNA)\",\n                RFC 5893, August 2010.\n   [Unicode52]\
    \  The Unicode Consortium.  The Unicode Standard, Version\n                5.2.0,\
    \ defined by: \"The Unicode Standard, Version\n                5.2.0\", (Mountain\
    \ View, CA: The Unicode Consortium,\n                2009. ISBN 978-1-936213-00-9).\n\
    \                <http://www.unicode.org/versions/Unicode5.2.0/>.\n"
- title: 14.2.  Informative References
  contents:
  - "14.2.  Informative References\n   [IDNA2008-Mapping]\n                Resnick,\
    \ P. and P. Hoffman, \"Mapping Characters in\n                Internationalized\
    \ Domain Names for Applications (IDNA)\",\n                Work in Progress, April\
    \ 2010.\n   [RFC0952]    Harrenstien, K., Stahl, M., and E. Feinler, \"DoD\n \
    \               Internet host table specification\", RFC 952,\n              \
    \  October 1985.\n   [RFC1034]    Mockapetris, P., \"Domain names - concepts and\n\
    \                facilities\", STD 13, RFC 1034, November 1987.\n   [RFC1035]\
    \    Mockapetris, P., \"Domain names - implementation and\n                specification\"\
    , STD 13, RFC 1035, November 1987.\n   [RFC1123]    Braden, R., \"Requirements\
    \ for Internet Hosts -\n                Application and Support\", STD 3, RFC\
    \ 1123, October 1989.\n   [RFC2136]    Vixie, P., Thomson, S., Rekhter, Y., and\
    \ J.  Bound,\n                \"Dynamic Updates in the Domain Name System (DNS\n\
    \                UPDATE)\", RFC 2136, April 1997.\n   [RFC2181]    Elz, R. and\
    \ R. Bush, \"Clarifications to the DNS\n                Specification\", RFC 2181,\
    \ July 1997.\n   [RFC2277]    Alvestrand, H., \"IETF Policy on Character Sets\
    \ and\n                Languages\", BCP 18, RFC 2277, January 1998.\n   [RFC2671]\
    \    Vixie, P., \"Extension Mechanisms for DNS (EDNS0)\",\n                RFC\
    \ 2671, August 1999.\n   [RFC2782]    Gulbrandsen, A., Vixie, P., and L. Esibov,\
    \ \"A DNS RR for\n                specifying the location of services (DNS SRV)\"\
    ,\n                RFC 2782, February 2000.\n   [RFC3454]    Hoffman, P. and M.\
    \ Blanchet, \"Preparation of\n                Internationalized Strings (\"stringprep\"\
    )\", RFC 3454,\n                December 2002.\n   [RFC3491]    Hoffman, P. and\
    \ M. Blanchet, \"Nameprep: A Stringprep\n                Profile for Internationalized\
    \ Domain Names (IDN)\",\n                RFC 3491, March 2003.\n   [RFC3743] \
    \   Konishi, K., Huang, K., Qian, H., and Y. Ko, \"Joint\n                Engineering\
    \ Team (JET) Guidelines for Internationalized\n                Domain Names (IDN)\
    \ Registration and Administration for\n                Chinese, Japanese, and\
    \ Korean\", RFC 3743, April 2004.\n   [RFC3987]    Duerst, M. and M. Suignard,\
    \ \"Internationalized Resource\n                Identifiers (IRIs)\", RFC 3987,\
    \ January 2005.\n   [RFC4290]    Klensin, J., \"Suggested Practices for Registration\
    \ of\n                Internationalized Domain Names (IDN)\", RFC 4290,\n    \
    \            December 2005.\n   [RFC4343]    Eastlake, D., \"Domain Name System\
    \ (DNS) Case\n                Insensitivity Clarification\", RFC 4343, January\
    \ 2006.\n   [RFC4690]    Klensin, J., Faltstrom, P., Karp, C., and IAB, \"Review\n\
    \                and Recommendations for Internationalized Domain Names\n    \
    \            (IDNs)\", RFC 4690, September 2006.\n   [RFC4713]    Lee, X., Mao,\
    \ W., Chen, E., Hsu, N., and J.  Klensin,\n                \"Registration and\
    \ Administration Recommendations for\n                Chinese Domain Names\",\
    \ RFC 4713, October 2006.\n   [Unicode-UAX31]\n                The Unicode Consortium,\
    \ \"Unicode Standard Annex #31:\n                Unicode Identifier and Pattern\
    \ Syntax, Revision 11\",\n                September 2009,\n                <http://www.unicode.org/reports/tr31/tr31-11.html>.\n\
    \   [Unicode-UTS39]\n                The Unicode Consortium, \"Unicode Technical\
    \ Standard #39:\n                Unicode Security Mechanisms, Revision 2\", August\
    \ 2006,\n                <http://www.unicode.org/reports/tr39/tr39-2.html>.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   John C Klensin\n   1770 Massachusetts Ave, Ste 322\n   Cambridge,\
    \ MA  02140\n   USA\n   Phone: +1 617 245 1457\n   EMail: john+ietf@jck.com\n"
