- title: __initial_text__
  contents:
  - "             Lightweight Directory Access Protocol (LDAP)\n                 \
    \    Client Update Protocol (LCUP)\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document defines the Lightweight Directory Access Protocol\n\
    \   (LDAP) Client Update Protocol (LCUP).  The protocol is intended to\n   allow\
    \ an LDAP client to synchronize with the content of a directory\n   information\
    \ tree (DIT) stored by an LDAP server and to be notified\n   about the changes\
    \ to that content.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Overview . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n   2.  Applicability. . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  4\n   3.  Specification of Protocol Elements . . . . . . . . . .\
    \ . . . .  5\n       3.1.  ASN.1 Considerations . . . . . . . . . . . . . . .\
    \ . . .  5\n       3.2.  Universally Unique Identifiers . . . . . . . . . . .\
    \ . .  5\n       3.3.  LCUP Scheme and LCUP Cookie. . . . . . . . . . . . . .\
    \ .  5\n       3.4.  LCUP Context . . . . . . . . . . . . . . . . . . . . . .\
    \  6\n       3.5.  Additional LDAP Result Codes defined by LCUP . . . . . .  6\n\
    \       3.6.  Sync Request Control . . . . . . . . . . . . . . . . . .  7\n  \
    \     3.7.  Sync Update Control. . . . . . . . . . . . . . . . . . .  7\n    \
    \   3.8.  Sync Done Control. . . . . . . . . . . . . . . . . . . .  8\n   4. \
    \ Protocol Usage and Flow. . . . . . . . . . . . . . . . . . . .  8\n       4.1.\
    \  LCUP Search Requests . . . . . . . . . . . . . . . . . .  8\n             4.1.1.\
    \ Initial Synchronization and Full Resync . . . . .  9\n             4.1.2. Incremental\
    \ or Update Synchronization . . . . . . 10\n             4.1.3. Persistent Only\
    \ . . . . . . . . . . . . . . . . . 10\n       4.2.  LCUP Search Responses. .\
    \ . . . . . . . . . . . . . . . . 10\n             4.2.1. Sync Update Informational\
    \ Responses . . . . . . . 11\n             4.2.2. Cookie Return Frequency . .\
    \ . . . . . . . . . . . 11\n             4.2.3. Definition of an Entry That Has\
    \ Entered the\n                    Result Set. . . . . . . . . . . . . . . . .\
    \ . . . 12\n             4.2.4. Definition of an Entry That Has Changed . . .\
    \ . . 13\n             4.2.5. Definition of an Entry That Has Left the\n     \
    \               Result Set. . . . . . . . . . . . . . . . . . . . 13\n       \
    \      4.2.6. Results For Entries Present in the Result Set . . 14\n         \
    \    4.2.7. Results For Entries That Have Left the Result\n                  \
    \  Set . . . . . . . . . . . . . . . . . . . . . . . 14\n       4.3. Responses\
    \ Requiring Special Consideration . . . . . . . . 15\n             4.3.1. Returning\
    \ Results During the Persistent Phase . . 15\n             4.3.2. No Mixing of\
    \ Sync Phase with Persist Phase. . . . 16\n             4.3.3. Returning Updated\
    \ Results During the Sync Phase . 16\n             4.3.4. Operational Attributes\
    \ and Administrative\n                    Entries . . . . . . . . . . . . . .\
    \ . . . . . . . 16\n             4.3.5. Virtual Attributes. . . . . . . . . .\
    \ . . . . . . 17\n             4.3.6. Modify DN and Delete Operations Applied\
    \ to\n                    Subtrees. . . . . . . . . . . . . . . . . . . . . 17\n\
    \             4.3.7. Convergence Guarantees. . . . . . . . . . . . . . 18\n  \
    \     4.4.  LCUP Search Termination. . . . . . . . . . . . . . . . . 18\n    \
    \         4.4.1. Server Initiated Termination. . . . . . . . . . . 18\n      \
    \       4.4.2. Client Initiated Termination. . . . . . . . . . . 19\n       4.5.\
    \  Size and Time Limits . . . . . . . . . . . . . . . . . . 19\n       4.6.  Operations\
    \ on the Same Connection. . . . . . . . . . . . 19\n       4.7.  Interactions\
    \ with Other Controls . . . . . . . . . . . . 19\n       4.8.  Replication Considerations\
    \ . . . . . . . . . . . . . . . 20\n   5.  Client Side Considerations . . . .\
    \ . . . . . . . . . . . . . . 20\n       5.1.  Using Cookies with Different Search\
    \ Criteria . . . . . . 20\n       5.2.  Renaming the Base Object . . . . . . .\
    \ . . . . . . . . . 20\n       5.3.  Use of Persistent Searches With Respect to\
    \ Resources . . 21\n       5.4.  Continuation References to Other LCUP Contexts\
    \ . . . . . 21\n       5.5.  Referral Handling. . . . . . . . . . . . . . . .\
    \ . . . . 21\n       5.6.  Multiple Copies of Same Entry During Sync Phase. .\
    \ . . . 21\n       5.7.  Handling Server Out of Resources Condition . . . . .\
    \ . . 21\n   6.  Server Implementation Considerations . . . . . . . . . . . .\
    \ . 22\n       6.1.  Server Support for UUIDs . . . . . . . . . . . . . . . .\
    \ 22\n       6.2.  Example of Using an RUV as the Cookie Value. . . . . . . 22\n\
    \       6.3.  Cookie Support Issues. . . . . . . . . . . . . . . . . . 22\n  \
    \           6.3.1. Support for Multiple Cookie Schemes . . . . . . . 22\n    \
    \         6.3.2. Information Contained in the Cookie . . . . . . . 23\n      \
    \ 6.4.  Persist Phase Response Time. . . . . . . . . . . . . . . 23\n       6.5.\
    \  Scaling Considerations . . . . . . . . . . . . . . . . . 23\n       6.6.  Alias\
    \ Dereferencing. . . . . . . . . . . . . . . . . . . 24\n   7.  Synchronizing\
    \ Heterogeneous Data Stores. . . . . . . . . . . . 24\n   8.  IANA Considerations.\
    \ . . . . . . . . . . . . . . . . . . . . . 24\n   9.  Security Considerations.\
    \ . . . . . . . . . . . . . . . . . . . 24\n   10. References . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . 25\n       10.1. Normative References .\
    \ . . . . . . . . . . . . . . . . . 25\n       10.2. Informative References .\
    \ . . . . . . . . . . . . . . . . 26\n   11. Acknowledgments. . . . . . . . .\
    \ . . . . . . . . . . . . . . . 26\n   Appendix - Features Left Out of LCUP .\
    \ . . . . . . . . . . . . . . 27\n   Authors' Addresses . . . . . . . . . . .\
    \ . . . . . . . . . . . . . 29\n   Full Copyright Statement . . . . . . . . .\
    \ . . . . . . . . . . . . 30\n"
- title: 1.  Overview
  contents:
  - "1.  Overview\n   The LCUP protocol is intended to allow LDAP clients to synchronize\n\
    \   with the content stored by LDAP servers.\n   The problem areas addressed by\
    \ the protocol include:\n   -  Mobile clients that maintain a local read-only\
    \ copy of the\n      directory data.  While off-line, the client uses the local\
    \ copy of\n      the data.  When the client connects to the network, it\n    \
    \  synchronizes with the current directory content and can optionally\n      receive\
    \ notification about the changes that occur while it is on-\n      line.  For\
    \ example, a mail client can maintain a local copy of the\n      corporate address\
    \ book that it synchronizes with the master copy\n      whenever the client is\
    \ connected to the corporate network.\n   -  Applications intending to synchronize\
    \ heterogeneous data stores.\n      A meta directory application, for instance,\
    \ would periodically\n      retrieve a list of modified entries from the directory,\
    \ construct\n      the changes and apply them to a foreign data store.\n   - \
    \ Clients that need to take certain actions when a directory entry\n      is modified.\
    \  For instance, an electronic mail repository may want\n      to perform a \"\
    create mailbox\" task when a new person entry is\n      added to an LDAP directory\
    \ and a \"delete mailbox\" task when a\n      person entry is removed.\n   The\
    \ problem areas not being considered:\n   -  Directory server to directory server\
    \ synchronization.  The IETF is\n      developing a LDAP replication protocol,\
    \ called LDUP [RFC3384],\n      which is specifically designed to address this\
    \ problem area.\n   There are currently several protocols in use for LDAP client\
    \ server\n   synchronization.  While each protocol addresses the needs of a\n\
    \   particular group of clients (e.g., on-line clients or off-line\n   clients),\
    \ none satisfies the requirements of all clients in the\n   target group.  For\
    \ instance, a mobile client that was off-line and\n   wants to become up to date\
    \ with the server and stay up to date while\n   connected can't be easily supported\
    \ by any of the existing protocols.\n   LCUP is designed such that the server\
    \ does not need to maintain state\n   information specific to individual clients.\
    \  The server may need to\n   maintain additional state information about attribute\
    \ modifications,\n   deleted entries, and moved/renamed entries.  The clients\
    \ are\n   responsible for storing the information about how up to date they are\n\
    \   with respect to the server's content.  LCUP design avoids the need\n   for\
    \ LCUP-specific update agreements to be made between client and\n   server prior\
    \ to LCUP use.  The client decides when and from where to\n   retrieve the changes.\
    \  LCUP design requires clients to initiate the\n   update session and \"pull\"\
    \ the changes from server.\n   LCUP operations are subject to administrative and\
    \ access control\n   policies enforced by the server.\n   The key words \"MUST\"\
    , \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD\
    \ NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to\
    \ be interpreted as described in BCP 14, RFC 2119\n   [RFC2119].\n"
- title: 2.  Applicability
  contents:
  - "2.  Applicability\n   LCUP will work best if the following conditions are met:\n\
    \   1) The server stores some degree of historical state or change\n      information\
    \ to reduce the amount of wire traffic required for\n      incremental synchronizations.\
    \  The optimal balance between server\n      state and wire traffic varies amongst\
    \ implementations and usage\n      scenarios, and is therefore left in the hands\
    \ of implementers.\n   2) The client cannot be assumed to understand the physical\n\
    \      information model (virtual attributes, operational attributes,\n      subentries,\
    \ etc.) implemented by the server.  Optimizations would\n      be possible if\
    \ such assumptions could be made.\n   3) Meta data changes and renames and deletions\
    \ of large subtrees are\n      very infrequent.  LCUP makes these assumptions\
    \ in order to reduce\n      client complexity required to deal with these special\
    \ operations,\n      though when they do occur they may result in a large number\
    \ of\n      incremental update messages or a full resync.\n"
- title: 3.  Specification of Protocol Elements
  contents:
  - "3.  Specification of Protocol Elements\n   The following sections define the\
    \ new elements required to use this\n   protocol.\n"
- title: 3.1.  ASN.1 Considerations
  contents:
  - "3.1.  ASN.1 Considerations\n   Protocol elements are described using ASN.1 [X.680].\
    \  The term \"BER-\n   encoded\" means the element is to be encoded using the\
    \ Basic Encoding\n   Rules [X.690] under the restrictions detailed in Section\
    \ 5.1 of\n   [RFC2251].  All ASN.1 in this document uses implicit tags.\n"
- title: 3.2.  Universally Unique Identifiers
  contents:
  - "3.2.  Universally Unique Identifiers\n   Distinguished names can change, so are\
    \ therefore unreliable as\n   identifiers.  A Universally Unique Identifier (or\
    \ UUID for short)\n   MUST be used to uniquely identify entries used with LCUP.\
    \  The UUID\n   is part of the Sync Update control value (see below) returned\
    \ with\n   each search result.  The server SHOULD provide the UUID as a single\n\
    \   valued operational attribute of the entry (e.g., \"entryUUID\").  We\n   RECOMMEND\
    \ that the server provides a way to do efficient (i.e.,\n   indexed) searches\
    \ for values of UUID, e.g., by using a search filter\n   like (entryUUID=<some\
    \ UUID value>) to quickly search for and retrieve\n   an entry based on its UUID.\
    \  Servers SHOULD use a UUID format as\n   specified in [UUID].  The UUID used\
    \ by LCUP is a value of the\n   following ASN.1 type:\n      LCUPUUID ::= OCTET\
    \ STRING\n"
- title: 3.3.  LCUP Scheme and LCUP Cookie
  contents:
  - "3.3.  LCUP Scheme and LCUP Cookie\n   The LCUP protocol uses a cookie to hold\
    \ the state of the client's\n   data with respect to the server's data.  Each\
    \ cookie format is\n   uniquely identified by its scheme.  The LCUP Scheme is\
    \ a value of the\n   following ASN.1 type:\n      LCUPScheme ::= LDAPOID\n   This\
    \ is the OID which identifies the format of the LCUP Cookie value.\n   The scheme\
    \ OID, as all object identifiers, MUST be unique for a given\n   cookie scheme.\
    \  The cookie value may be opaque or it may be exposed\n   to LCUP clients.  \
    \ For cookie schemes that expose their value, the\n   preferred form of documentation\
    \ is an RFC.  It is expected that there\n   will be one or more standards track\
    \ cookie schemes where the value\n   format is exposed and described in detail.\n\
    \   The LCUP Cookie is a value of the following ASN.1 type:\n      LCUPCookie\
    \ ::= OCTET STRING\n   This is the actual data describing the state of the client's\
    \ data.\n   This value may be opaque, or its value may have some well-known\n\
    \   format, depending on the scheme.\n   Further uses of the LCUP Cookie value\
    \ are described below.\n"
- title: 3.4.  LCUP Context
  contents:
  - "3.4.  LCUP Context\n   A part of the DIT which is enabled for LCUP is referred\
    \ to as an LCUP\n   Context.  A server may support one or more LCUP Contexts.\
    \  For\n   example, a server with two naming contexts may support LCUP in one\n\
    \   naming context but not the other, or support different LCUP cookie\n   schemes\
    \ in each naming context.  Each LCUP Context MAY use a\n   different cookie scheme.\
    \  An LCUP search will not cross an LCUP\n   Context boundary, but will instead\
    \ return a SearchResultReference\n   message, with the LDAP URL specifying the\
    \ same host and port as\n   currently being searched, and with the baseDN set\
    \ to the baseDN of\n   the new LCUP Context.  The client is then responsible for\
    \ issuing\n   another search using the new baseDN, and possibly a different cookie\n\
    \   if that LCUP Context uses a different cookie.  The client is\n   responsible\
    \ for maintaining a mapping of the LDAP URL to its\n   corresponding cookie.\n"
- title: 3.5.  Additional LDAP Result Codes defined by LCUP
  contents:
  - "3.5.  Additional LDAP Result Codes defined by LCUP\n   Implementations of this\
    \ specification SHALL recognize the following\n   additional resultCode values.\
    \  The LDAP result code names and numbers\n   defined in the following table have\
    \ been assigned by IANA per RFC\n   3383 [RFC3383].\n   lcupResourcesExhausted\
    \  (113)  the server is running out of resources\n   lcupSecurityViolation   (114)\
    \  the client is suspected of malicious\n                                  actions\n\
    \   lcupInvalidData         (115)  invalid scheme or cookie was supplied\n   \
    \                               by the client\n   lcupUnsupportedScheme   (116)\
    \  The cookie scheme is a valid OID but\n                                  is\
    \ not supported by this server\n   lcupReloadRequired      (117)  indicates that\
    \ client data needs to be\n                                  reinitialized.  This\
    \ reason is\n                                  returned if the server does not\n\
    \                                  contain sufficient information to\n       \
    \                           synchronize the client or if the\n               \
    \                   server's data was reloaded since the\n                   \
    \               last synchronization session\n   The uses of these codes are described\
    \ below.\n"
- title: 3.6.  Sync Request Control
  contents:
  - "3.6.  Sync Request Control\n   The Sync Request Control is an LDAP Control [RFC2251,\
    \ Section 4.1.2]\n   where the controlType is the object identifier 1.3.6.1.1.7.1\
    \ and the\n   controlValue, an OCTET STRING, contains a BER-encoded\n   syncRequestControlValue.\n\
    \      syncRequestControlValue ::= SEQUENCE {\n         updateType           ENUMERATED\
    \ {\n                                 syncOnly       (0),\n                  \
    \               syncAndPersist (1),\n                                 persistOnly\
    \    (2) },\n         sendCookieInterval   [0] INTEGER    OPTIONAL,\n        \
    \ scheme               [1] LCUPScheme OPTIONAL,\n         cookie             \
    \  [2] LCUPCookie OPTIONAL\n        }\n   sendCookieInterval - the server SHOULD\
    \ send the cookie back in the\n   Sync Update control value (defined below) for\
    \ every\n   sendCookieInterval number of SearchResultEntry and\n   SearchResultReference\
    \ PDUs returned to the client.  For example, if\n   the value is 5, the server\
    \ SHOULD send the cookie back in the Sync\n   Update control value for every 5\
    \ search results returned to the\n   client.  If this value is absent, zero or\
    \ less than zero, the server\n   chooses the interval.\n   The Sync Request Control\
    \ is only applicable to the searchRequest\n   message.  Use of this control is\
    \ described below.\n"
- title: 3.7.  Sync Update Control
  contents:
  - "3.7.  Sync Update Control\n   The Sync Update Control is an LDAP Control [RFC2251,\
    \ Section 4.1.2]\n   where the controlType is the object identifier 1.3.6.1.1.7.2\
    \ and the\n   controlValue, an OCTET STRING, contains a BER-encoded\n   syncUpdateControlValue.\n\
    \      syncUpdateControlValue ::= SEQUENCE {\n         stateUpdate   BOOLEAN,\n\
    \         entryUUID     [0] LCUPUUID OPTIONAL, -- REQUIRED for entries --\n  \
    \       UUIDAttribute [1] AttributeType OPTIONAL,\n         entryLeftSet  [2]\
    \ BOOLEAN,\n         persistPhase  [3] BOOLEAN,\n         scheme        [4] LCUPScheme\
    \ OPTIONAL,\n         cookie        [5] LCUPCookie OPTIONAL\n      }\n   The field\
    \ UUIDAttribute contains the name or OID of the attribute\n   that the client\
    \ should use to perform searches for entries based on\n   the UUID.  The client\
    \ should be able to use it in an equality search\n   filter, e.g., \"(<uuid attribute>=<entry\
    \ UUID value>)\" and should be\n   able to use it in the attribute list of the\
    \ search request to return\n   its value.  The UUIDAttribute field may be omitted\
    \ if the server does\n   not support searching on the UUID values.\n   The Sync\
    \ Update Control is only applicable to SearchResultEntry and\n   SearchResultReference\
    \ messages.  Although entryUUID is OPTIONAL, it\n   MUST be used with SearchResultEntry\
    \ messages.  Use of this control is\n   described below.\n"
- title: 3.8.  Sync Done Control
  contents:
  - "3.8.  Sync Done Control\n   The Sync Done Control is an LDAP Control [RFC2251,\
    \ Section 4.1.2]\n   where the controlType is the object identifier 1.3.6.1.1.7.3\
    \ and the\n   controlValue contains a BER-encoded syncDoneValue.\n      syncDoneValue\
    \ ::= SEQUENCE {\n         scheme      [0] LCUPScheme OPTIONAL,\n         cookie\
    \      [1] LCUPCookie OPTIONAL\n      }\n   The Sync Done Control is only applicable\
    \ to SearchResultDone message.\n   Use of this control is described below.\n"
- title: 4.  Protocol Usage and Flow
  contents:
  - '4.  Protocol Usage and Flow

    '
- title: 4.1.  LCUP Search Requests
  contents:
  - "4.1.  LCUP Search Requests\n   A client initiates a synchronization or persistent\
    \ search session\n   with a server by attaching a Sync Request control to an LDAP\n\
    \   searchRequest message.  The search specification determines the part\n   of\
    \ the directory information tree (DIT) the client wishes to\n   synchronize with,\
    \ the set of attributes it is interested in and the\n   amount of data the client\
    \ is willing to receive.  The Sync Request\n   control contains the client's request\
    \ specification.\n   If there is an error condition, the server MUST immediately\
    \ return a\n   SearchResultDone message with the resultCode set to an error code.\n\
    \   This table maps a condition to its corresponding behavior and\n   resultCode.\n\
    \   Condition                       Behavior or resultCode\n   Sync Request Control\
    \ is not     Server behaves as [RFC2251, Section\n   supported               \
    \        4.1.2] - specifically, if the\n                                   criticality\
    \ of the control is FALSE,\n                                   the server will\
    \ process the request\n                                   as a normal search request\n\
    \   Scheme is not supported         lcupUnsupportedScheme\n   A control value\
    \ field is        lcupInvalidData\n   invalid (e.g., illegal\n   updateType, or\
    \ the scheme is\n   not a valid OID, or the cookie\n   is invalid)\n   Server\
    \ is running out of        lcupResourcesExhausted\n   resources\n   Server suspects\
    \ client of       lcupSecurityViolation\n   malicious behavior (frequent\n   connects/disconnects,\
    \ etc.)\n   The server cannot bring the     lcupReloadRequired\n   client up to\
    \ date (server data\n   has been reloaded, or other\n   changes prevent\n   convergence)\n"
- title: 4.1.1.  Initial Synchronization and Full Resync
  contents:
  - "4.1.1.  Initial Synchronization and Full Resync\n   For an initial synchronization\
    \ or full resync, the fields of the Sync\n   Request control MUST be specified\
    \ as follows:\n   updateType         - MUST be set to syncOnly or syncAndPersist\n\
    \   sendCookieInterval - MAY be set\n   scheme             - MAY be set - if set,\
    \ the server MUST use this\n                        specified scheme or return\
    \ lcupUnsupportedScheme\n                        (see above) - if not set, the\
    \ server MAY use any\n                        scheme it supports.\n   cookie \
    \            - MUST NOT be set\n   If the request was successful, the client will\
    \ receive results as\n   described in the section \"LCUP Search Responses\" below.\n"
- title: 4.1.2.  Incremental or Update Synchronization
  contents:
  - "4.1.2.  Incremental or Update Synchronization\n   For an incremental or update\
    \ synchronization, the fields of the Sync\n   Request control MUST be specified\
    \ as follows:\n   updateType         - MUST be set to syncOnly or syncAndPersist\n\
    \   sendCookieInterval - MAY be set\n   scheme             - MUST be set\n   cookie\
    \             - MUST be set\n   The client SHOULD always use the latest cookie\
    \ it received from the\n   server.\n   If the request was successful, the client\
    \ will receive results as\n   described in the section \"LCUP Search Responses\"\
    \ below.\n"
- title: 4.1.3.  Persistent Only
  contents:
  - "4.1.3.  Persistent Only\n   For persistent only search request, the fields of\
    \ the Sync Request\n   MUST be specified as follows:\n   updateType          -\
    \ MUST be set to persistOnly\n   sendCookieInterval  - MAY be set\n   scheme \
    \             - MAY be set - if set, the server MUST use this\n              \
    \           specified scheme or return\n                         lcupUnsupportedScheme\
    \ (see above) - if not set,\n                         the server MAY use any scheme\
    \ it supports.\n   cookie              - MAY be set, but the server MUST ignore\
    \ it\n   If the request was successful, the client will receive results as\n \
    \  described in the section \"LCUP Search Responses\" below.\n"
- title: 4.2.  LCUP Search Responses
  contents:
  - "4.2.  LCUP Search Responses\n   In response to the client's LCUP request, the\
    \ server returns zero or\n   more SearchResultEntry or SearchResultReference PDUs\
    \ that fit the\n   client's specification, followed by a SearchResultDone PDU.\
    \  The\n   behavior is as specified in [RFC2251 Section 4.5].  Each\n   SearchResultEntry\
    \ or SearchResultReference PDU also contains a Sync\n   Update control that describes\
    \ the LCUP state of the returned entry.\n   The SearchResultDone PDU contains\
    \ a Sync Done control.  The following\n   sections specify behaviors in addition\
    \ to [RFC2251 Section 4.5].\n"
- title: 4.2.1 Sync Update Informational Responses
  contents:
  - "4.2.1 Sync Update Informational Responses\n   The server may use the Sync Update\
    \ control to return information not\n   related to a particular entry.  It MAY\
    \ do this at any time to return\n   a cookie to the client, or to inform the client\
    \ that the sync phase\n   of a syncAndPersist search is complete and the persist\
    \ phase has\n   begun.  It MAY do this during the persist phase even though no\
    \ entry\n   has changed that would have normally triggered a response.  In order\n\
    \   to do this, it is REQUIRED to return the following:\n   -  A SearchResultEntry\
    \ PDU with the objectName field set to the DN of\n      the baseObject of the\
    \ search request and with an empty attribute\n      list.\n   -  A Sync Update\
    \ control value with the fields set to the following:\n   stateUpdate   - MUST\
    \ be set to TRUE\n   entryUUID     - SHOULD be set to the UUID of the baseObject\
    \ of the\n                   search request\n   entryLeftSet  - MUST be set to\
    \ FALSE\n   persistPhase  - MUST be FALSE if the search is in the sync phase of\
    \ a\n                   request, and MUST be TRUE if the search is in the\n  \
    \                 persist phase\n   UUIDAttribute - SHOULD only be set if this\
    \ is either the first result\n                   returned or if the attribute\
    \ has changed\n   scheme        - MUST be set if the cookie is set and the cookie\n\
    \                   format has changed; otherwise, it MAY be omitted\n   cookie\
    \        - SHOULD be set\n   If the server merely wants to return a cookie to\
    \ the client, it\n   should return as above with the cookie field set.\n   During\
    \ a syncAndPersist request, the server MUST return (as above)\n   immediately\
    \ after the last entry of the sync phase has been sent and\n   before the first\
    \ entry of the persist phase has been sent.  In this\n   case, the persistPhase\
    \ field MUST be set to TRUE.  This allows the\n   client to know that the sync\
    \ phase is complete and the persist phase\n   is starting.\n"
- title: 4.2.2 Cookie Return Frequency
  contents:
  - "4.2.2 Cookie Return Frequency\n   The cookie field of the Sync Update control\
    \ value MAY be set in any\n   returned result, during both the sync phase and\
    \ the persist phase.\n   The server should return the cookie to the client often\
    \ enough for\n   the client to resync in a reasonable period of time in case the\n\
    \   search is disconnected or otherwise terminated.  The\n   sendCookieInterval\
    \ field in the Sync Request control is a suggestion\n   to the server of how often\
    \ to return the cookie in the Sync Update\n   control.  The server SHOULD respect\
    \ this value.\n   The scheme field of the Sync Update control value MUST be set\
    \ if the\n   cookie is set and the cookie format has changed; otherwise, it MAY\
    \ be\n   omitted.\n   Some clients may have unreliable connections, for example,\
    \ a wireless\n   device or a WAN connection.  These clients may want to insure\
    \ that\n   the cookie is returned often in the Sync Update control value, so\n\
    \   that if they have to reconnect, they do not have to process many\n   redundant\
    \ entries.  These clients should set the sendCookieInterval\n   in the Sync Request\
    \ control value to a low number, perhaps even 1.\n   Some clients may have a limited\
    \ bandwidth connection, and may not\n   want to receive the cookie very often,\
    \ or even at all (however, the\n   cookie is always sent back in the Sync Done\
    \ control value upon\n   successful completion).  These clients should set the\n\
    \   sendCookieInterval in the Sync Request control value to a high\n   number.\n\
    \   A reasonable behavior of the server is to return the cookie only when\n  \
    \ data in the LCUP context has changed, even if the client has\n   specified a\
    \ frequent sendCookieInterval.  If nothing has changed, the\n   server can probably\
    \ save some bandwidth by not returning the cookie.\n"
- title: 4.2.3.  Definition of an Entry That Has Entered the Result Set
  contents:
  - "4.2.3.  Definition of an Entry That Has Entered the Result Set\n   An entry SHALL\
    \ BE considered to have entered the client's search\n   result set if one of the\
    \ following conditions is met:\n   -  During the sync phase for an incremental\
    \ sync operation, the entry\n      is present in the search result set but was\
    \ not present before;\n      this can be due to the entry being added via an LDAP\
    \ Add\n      operation, or by the entry being moved into the result set by an\n\
    \      LDAP Modify DN operation, or by some modification to the entry\n      that\
    \ causes it to enter the result set (e.g., adding an attribute\n      value that\
    \ matches the clients search filter), or by some meta-\n      data change that\
    \ causes the entry to enter the result set (e.g.,\n      relaxing of some access\
    \ control that permits the entry to be\n      visible to the client).\n   -  During\
    \ the persist phase for a persistent search operation, the\n      entry enters\
    \ the search result set; this can be due to the entry\n      being added via an\
    \ LDAP Add operation, or by the entry being moved\n      into the result set by\
    \ an LDAP Modify DN operation, or by some\n      modification to the entry that\
    \ causes it to enter the result set\n      (e.g., adding an attribute value that\
    \ matches the clients search\n      filter), or by some meta-data change that\
    \ causes the entry to\n      enter the result set (e.g., relaxing of some access\
    \ control that\n      permits the entry to be visible to the client).\n"
- title: 4.2.4.  Definition of an Entry That Has Changed
  contents:
  - "4.2.4.  Definition of an Entry That Has Changed\n   An entry SHALL BE considered\
    \ to be changed if one or more of the\n   attributes in the attribute list in\
    \ the search request have been\n   modified.  For example, if the search request\
    \ listed the attributes\n   \"cn sn uid\", and there is an entry in the client's\
    \ search result set\n   with the \"cn\" attribute that has been modified, the\
    \ entry is\n   considered to be modified.  The modification may be due to an LDAP\n\
    \   Modify operation or by some change to the meta-data for the entry\n   (e.g.,\
    \ virtual attributes) that causes some change to the value of\n   the specified\
    \ attributes.\n   The converse of this is that an entry SHALL NOT BE considered\
    \ to be\n   changed if none of the attributes in the attribute list of the search\n\
    \   request are modified attributes of the entry.  For example, if the\n   search\
    \ request listed the attributes \"cn sn uid\", and there is an\n   entry in the\
    \ client's search result set with the \"foo\" attribute that\n   has been modified,\
    \ and none of the \"cn\" or \"sn\" or \"uid\" attributes\n   have been modified,\
    \ the entry is NOT considered to be changed.\n"
- title: 4.2.5.  Definition of an Entry That Has Left the Result Set
  contents:
  - "4.2.5.  Definition of an Entry That Has Left the Result Set\n   An entry SHALL\
    \ BE considered to have left the client's search result\n   set if one of the\
    \ following conditions is met:\n   -  During the sync phase for an incremental\
    \ sync operation, the entry\n      is not present in the search result set but\
    \ was present before;\n      this can be due to the entry being deleted via an\
    \ LDAP Delete\n      operation, or by the entry leaving the result set via an\
    \ LDAP\n      Modify DN operation, or by some modification to the entry that\n\
    \      causes it to leave the result set (e.g., changing/removing an\n      attribute\
    \ value so that it no longer matches the client's search\n      filter), or by\
    \ some meta-data change that causes the entry to\n      leave the result set (e.g.,\
    \ adding of some access control that\n      denies the entry to be visible to\
    \ the client).\n   -  During the persist phase for a persistent search operation,\
    \ the\n      entry leaves the search result set; this can be due to the entry\n\
    \      being deleted via an LDAP Delete operation, or by the entry\n      leaving\
    \ the result set via an LDAP Modify DN operation, or by some\n      modification\
    \ to the entry that causes it to leave the result set\n      (e.g., changing/removing\
    \ an attribute value so that it no longer\n      matches the client's search filter),\
    \ or by some meta-data change\n      that causes the entry to leave the result\
    \ set (e.g., adding of\n      some access control that denies the entry to be\
    \ visible to the\n      client).\n"
- title: 4.2.6.  Results For Entries Present in the Result Set
  contents:
  - "4.2.6.  Results For Entries Present in the Result Set\n   An entry SHOULD be\
    \ returned as present under the following\n   conditions:\n   -  The request is\
    \ an initial synchronization or full resync request\n      and the entry is present\
    \ in the client's search result set\n   -  The request is an incremental synchronization\
    \ and the entry has\n      changed or entered the result set since the last sync\n\
    \   -  The search is in the persist phase and the entry enters the result\n  \
    \    set or changes\n   For a SearchResultEntry return, the fields of the Sync\
    \ Update control\n   value MUST be set as follows:\n   stateUpdate   - MUST be\
    \ set to FALSE\n   entryUUID     - MUST be set to the UUID of the entry\n   entryLeftSet\
    \  - MUST be set to FALSE\n   persistPhase  - MUST be set to FALSE if during the\
    \ sync phase or TRUE\n                   if during the persist phase\n   UUIDAttribute\
    \ - SHOULD only be set if this is either the first result\n                  \
    \ returned or if the attribute has changed\n   scheme        - as above\n   cookie\
    \        - as above\n   The searchResultReference return will look the same, except\
    \ that the\n   entryUUID is not required.  If it is specified, it MUST contain\
    \ the\n   UUID of the DSE holding the reference knowledge.\n"
- title: 4.2.7.  Results For Entries That Have Left the Result Set
  contents:
  - "4.2.7.  Results For Entries That Have Left the Result Set\n   An entry SHOULD\
    \ be returned as having left the result set under the\n   following conditions:\n\
    \   -  The request is an incremental synchronization during the sync\n      phase\
    \ and the entry has left the result set\n   -  The search is in the persist phase\
    \ and the entry has left the\n      result set\n   -  The entry has left the result\
    \ set as a result of an LDAP Delete or\n      LDAP Modify DN operation against\
    \ the entry itself (i.e., not as a\n      result of an operation against its parent\
    \ or ancestor)\n   For a SearchResultEntry return where the entry has left the\
    \ result\n   set, the fields of the Sync Update control value MUST be set as\n\
    \   follows:\n   stateUpdate   - MUST be set to FALSE\n   entryUUID     - MUST\
    \ be set to the UUID of the entry that left the\n                   result set\n\
    \   entryLeftSet  - MUST be set to TRUE\n   persistPhase  - MUST be set to FALSE\
    \ if during the sync phase or TRUE\n                   if during the persist phase\n\
    \   UUIDAttribute - SHOULD only be set if this is either the first result\n  \
    \                 returned or if the attribute has changed\n   scheme        -\
    \ as above\n   cookie        - as above\n   The searchResultReference return will\
    \ look the same, except that the\n   entryUUID is not required.  If it is specified,\
    \ it MUST contain the\n   UUID of the DSE holding the reference knowledge.\n \
    \  Some server implementations keep track of deleted entries using a\n   tombstone\
    \ - a hidden entry that keeps track of the state, but not all\n   of the data,\
    \ of an entry that has been deleted.  In this case, the\n   tombstone may not\
    \ contain all of the original attributes of the\n   entry, and therefore it may\
    \ be impossible for the server to determine\n   if an entry should be removed\
    \ from the result set based on the\n   attributes in the client's search request.\
    \  Servers SHOULD keep\n   enough information about the attributes in the deleted\
    \ entries to\n   determine if an entry should be removed from the result set.\
    \  Since\n   this may not be possible, the server MAY return an entry as having\n\
    \   left the result set even if it is not or never was in the client's\n   result\
    \ set.  Clients MUST ignore these notifications.\n"
- title: 4.3.  Responses Requiring Special Consideration
  contents:
  - "4.3.  Responses Requiring Special Consideration\n   The following sections describe\
    \ special handling that may be required\n   when returning results.\n"
- title: 4.3.1.  Returning Results During the Persistent Phase
  contents:
  - "4.3.1.  Returning Results During the Persistent Phase\n   During the persistent\
    \ phase, the server SHOULD return the changed\n   entries to the client as quickly\
    \ as possible.\n"
- title: 4.3.2.  No Mixing of Sync Phase with Persist Phase
  contents:
  - "4.3.2.  No Mixing of Sync Phase with Persist Phase\n   During a sync phase, the\
    \ server MUST NOT return any entries with the\n   persistPhase flag set to TRUE,\
    \ and during the persist phase, all\n   entries returned MUST have the persistPhase\
    \ flag set to TRUE.  The\n   server MUST NOT mix and match sync phase entries\
    \ with persist phase\n   entries.  If there are any sync phase entries to return,\
    \ they MUST be\n   returned before any persist phase entries are returned.\n"
- title: 4.3.3.  Returning Updated Results During the Sync Phase
  contents:
  - "4.3.3.  Returning Updated Results During the Sync Phase\n   There may be updates\
    \ to the entries in the result set of a sync phase\n   search during the actual\
    \ search operation.  If the DSA is under a\n   heavy update load, and it attempts\
    \ to send all of those updated\n   entries to the client in addition to the other\
    \ updates it was already\n   planning to send for the sync phase, the server may\
    \ never get to the\n   end of the sync phase.  Therefore, it is left up to the\
    \ discretion of\n   the server implementation to decide when the client is \"\
    in sync\" -\n   that is, when to end a syncOnly request, or when to send the Sync\n\
    \   Update Informational Response between the sync phase and the persist\n   phase\
    \ of a syncAndPersist request.  The server MAY send the same\n   entry multiple\
    \ times during the sync phase if the entry changes\n   during the sync phase.\n\
    \   A reasonable behavior is for the server to generate a cookie based on\n  \
    \ the server state at the time the client initiated the LCUP request,\n   and\
    \ only send entries up to that point during the sync phase. Entries\n   updated\
    \ after that point will be returned only during the persist\n   phase of a syncAndPersist\
    \ request, or only upon an incremental\n   synchronization.\n"
- title: 4.3.4.  Operational Attributes and Administrative Entries
  contents:
  - "4.3.4.  Operational Attributes and Administrative Entries\n   An operational\
    \ attribute SHOULD be returned if it is specified in the\n   attributes list and\
    \ would normally be returned as subject to the\n   constraints of [RFC2251 Section\
    \ 4.5].  If the server does not support\n   syncing of operational attributes,\
    \ the server MUST return a\n   SearchResultDone message with a resultCode of unwillingToPerform.\n\
    \   LDAP Subentries [RFC3672] SHOULD be returned if they would normally\n   be\
    \ returned by the search request.  If the server does not support\n   syncing\
    \ of LDAP Subentries, and the server can determine from the\n   search request\
    \ that the client has requested LDAP Subentries to be\n   returned (e.g., search\
    \ control or search filter), the server MUST\n   return a SearchResultDone message\
    \ with a resultCode of\n   unwillingToPerform.  Otherwise, the server MAY simply\
    \ omit returning\n   LDAP Subentries.\n"
- title: 4.3.5.  Virtual Attributes
  contents:
  - "4.3.5.  Virtual Attributes\n   An entry may have attributes whose presence in\
    \ the entry, or presence\n   of values of the attribute, is generated on the fly,\
    \ possibly by some\n   mechanism outside of the entry, elsewhere in the DIT. \
    \ An example of\n   this is collective attributes [RFC3671].  These attributes\
    \ shall be\n   referred to in this document as virtual attributes.\n   LCUP treats\
    \ these attributes the same way as normal, non-virtual\n   attributes.  A virtual\
    \ attribute SHOULD be returned if it is\n   specified in the attributes list and\
    \ would normally be returned as\n   subject to the constraints of [RFC2251 Section\
    \ 4.5].  If the server\n   does not support syncing of virtual attributes, the\
    \ server MUST\n   return a SearchResultDone message with a resultCode of\n   unwillingToPerform.\n\
    \   One consequence of this is that if you change the definition of a\n   virtual\
    \ attribute such that it makes the value of that attribute\n   change in many\
    \ entries in the client's search scope, this means that\n   a server may have\
    \ to return many entries to the client as a result of\n   that one change.  It\
    \ is not anticipated that this will be a frequent\n   occurrence, and the server\
    \ has the option to simply force the client\n   to resync if necessary.\n   It\
    \ is also possible that a future LDAP control will allow the client\n   to request\
    \ only virtual or only non-virtual attributes.\n"
- title: 4.3.6.  Modify DN and Delete Operations Applied to Subtrees
  contents:
  - "4.3.6.  Modify DN and Delete Operations Applied to Subtrees\n   There is a special\
    \ case where a Modify DN or a Delete operation is\n   applied to the base entry\
    \ of a subtree, and either that base entry or\n   entries in the subtree are within\
    \ the scope of an LCUP search\n   request.  In this case, all of the entries in\
    \ the subtree are\n   implicitly renamed or removed.\n   In either of these cases,\
    \ the server MUST do one of the following:\n   -  treat all of these entries as\
    \ having been renamed or removed and\n      return each entry to the client as\
    \ such\n   -  decide that this would be prohibitively expensive, and force the\n\
    \      client to resync\n   If the search base object has been renamed, and the\
    \ client has\n   received a noSuchObject as the result of a search request, the\
    \ client\n   MAY use the entryUUID and UUIDAttribute to locate the new DN that\
    \ is\n   the result of the modify DN operation.\n"
- title: 4.3.7.  Convergence Guarantees
  contents:
  - "4.3.7.  Convergence Guarantees\n   If at any time during an LCUP search, either\
    \ during the sync phase or\n   the persist phase, the server determines that it\
    \ cannot guarantee\n   that it can bring the client's copy of the data to eventual\n\
    \   convergence, it SHOULD immediately terminate the LCUP search request\n   and\
    \ return a SearchResultDone message with a resultCode of\n   lcupReloadRequired.\
    \  This can also happen at the beginning of an\n   incremental synchronization\
    \ request, if the client presents a cookie\n   that is out of date or otherwise\
    \ unable to be processed.  The client\n   should then issue an initial synchronization\
    \ request.\n   This can happen, for example, if the data on the server is reloaded,\n\
    \   or if there has been some change to the meta-data that makes it\n   impossible\
    \ for the server to determine if a particular entry should\n   or should not be\
    \ part of the search result set, or if the meta-data\n   change makes it too resource\
    \ intensive for the server to calculate\n   the proper result set.\n   The server\
    \ can also return lcupReloadRequired if it determines that\n   it would be more\
    \ efficient for the client to perform a reload, for\n   example, if too many entries\
    \ have changed and a simple reload would\n   be much faster.\n"
- title: 4.4.  LCUP Search Termination
  contents:
  - '4.4.  LCUP Search Termination

    '
- title: 4.4.1.  Server Initiated Termination
  contents:
  - "4.4.1.  Server Initiated Termination\n   When the server has successfully finished\
    \ processing the client's\n   request, it attaches a Sync Done control to the\
    \ SearchResultDone\n   message and sends it to the client.  However, if the SearchResultDone\n\
    \   message contains a resultCode that is not success or canceled, the\n   Sync\
    \ Done control MAY be omitted.  Although the LCUP cookie is\n   OPTIONAL in the\
    \ Sync Done control value, it MUST be set if the\n   SearchResultDone resultCode\
    \ is success or canceled.  The server\n   SHOULD also set the cookie if the resultCode\
    \ is\n   lcupResourcesExhausted, timeLimitExceeded, sizeLimitExceeded, or\n  \
    \ adminLimitExceeded.  This allows the client to more easily resync\n   later.\
    \  If some error occurred, either an LDAP search error (e.g.,\n   insufficientAccessRights)\
    \ or an LCUP error (e.g.,\n   lcupUnsupportedScheme), the cookie MAY be omitted.\
    \  If the cookie is\n   set, the scheme MUST be set also if the cookie format\
    \ has changed,\n   otherwise, it MAY be omitted.\n   If server resources become\
    \ tight, the server can terminate one or\n   more search operations by sending\
    \ a SearchResultDone message to the\n   client(s) with a resultCode of lcupResourcesExhausted.\
    \  The server\n   SHOULD attach a Sync Done control with the cookie set.  A server\
    \ side\n   policy is used to decide which searches to terminate.  This can also\n\
    \   be used as a security mechanism to disconnect clients that are\n   suspected\
    \ of malicious actions, but if the server can infer that the\n   client is malicious,\
    \ the server SHOULD return lcupSecurityViolation\n   instead.\n"
- title: 4.4.2.  Client Initiated Termination
  contents:
  - "4.4.2.  Client Initiated Termination\n   If the client needs to terminate the\
    \ synchronization process and it\n   wishes to obtain the cookie that represents\
    \ the current state of its\n   data, it issues an LDAP Cancel operation [RFC3909].\
    \  The server\n   responds immediately with a LDAP Cancel response [RFC3909].\
    \  The\n   server MAY send any pending SearchResultEntry or\n   SearchResultReference\
    \ PDUs if the server cannot easily abort or\n   remove those search results from\
    \ its outgoing queue.  The server\n   SHOULD send as few of these remaining messages\
    \ as possible.  Finally,\n   the server sends the message SearchResultDone with\
    \ the Sync Done\n   control attached.  If the search was successful up to that\
    \ point, the\n   resultCode field of the SearchResultDone message MUST be canceled\n\
    \   [RFC3909], and the cookie MUST be set in the Sync Done control.  If\n   there\
    \ is an error condition, the server MAY return as described in\n   section 4.4.1\
    \ above, or MAY return as described in [RFC3909].\n   If the client is not interested\
    \ in the state information, it can\n   simply abandon the search operation or\
    \ disconnect from the server.\n"
- title: 4.5.  Size and Time Limits
  contents:
  - "4.5.  Size and Time Limits\n   The server SHALL support size and time limits\
    \ as specified in\n   [RFC2251, Section 5].  The server SHOULD ensure that if\
    \ the operation\n   is terminated due to these conditions, the cookie is sent\
    \ back to the\n   client.\n"
- title: 4.6.  Operations on the Same Connection
  contents:
  - "4.6.  Operations on the Same Connection\n   It is permissible for the client\
    \ to issue other LDAP operations on\n   the connection used by the protocol. \
    \ Since each LDAP\n   request/response carries a message id there will be no ambiguity\n\
    \   about which PDU belongs to which operation.  By sharing the\n   connection\
    \ among multiple operations, the server will be able to\n   conserve its resources.\n"
- title: 4.7.  Interactions with Other Controls
  contents:
  - "4.7.  Interactions with Other Controls\n   LCUP defines neither restrictions\
    \ nor guarantees about the ability to\n   use the controls defined in this document\
    \ in conjunction with other\n   LDAP controls, except for the following: A server\
    \ MAY ignore non-\n   critical controls supplied with the LCUP control.  A server\
    \ MAY\n   ignore an LCUP defined control if it is non-critical and it is\n   supplied\
    \ with other critical controls.  If a server receives a\n   critical LCUP control\
    \ with another critical control, and the server\n   does not support both controls\
    \ at the same time, the server SHOULD\n   return unavailableCriticalExtension.\n\
    \   It is up to the server implementation to determine if the server\n   supports\
    \ controls such as the Sort or VLV or similar controls that\n   change the order\
    \ of the entries sent to the client.  But note that it\n   may be difficult or\
    \ impossible for a server to perform an incremental\n   synchronization in the\
    \ presence of such controls, since the cookie\n   will typically be based off\
    \ a change number, or Change Sequence\n   Number (CSN), or timestamp, or some\
    \ criteria other than an\n   alphabetical order.\n"
- title: 4.8.  Replication Considerations
  contents:
  - "4.8.  Replication Considerations\n   Use of an LCUP cookie with multiple DSAs\
    \ in a replicated environment\n   is not defined by LCUP.   An implementation\
    \ of LCUP may support\n   continuation of an LCUP session with another DSA holding\
    \ a replica of\n   the LCUP context.  Clients MAY submit cookies returned by one\
    \ DSA to\n   a different DSA; it is up to the server to determine if a cookie\
    \ is\n   one they recognize or not and to return an appropriate result code if\n\
    \   not.\n"
- title: 5.  Client Side Considerations
  contents:
  - '5.  Client Side Considerations

    '
- title: 5.1.  Using Cookies with Different Search Criteria
  contents:
  - "5.1.  Using Cookies with Different Search Criteria\n   The cookie received from\
    \ the server after a synchronization session\n   SHOULD only be used with the\
    \ same search specification as the search\n   that generated the cookie.  Some\
    \ servers MAY allow the cookie to be\n   used with a more restrictive search specification\
    \ than the search\n   that generated the cookie.  If the server does not support\
    \ the\n   cookie, it MUST return lcupInvalidCookie.  This is because the client\n\
    \   can end up with an incomplete data store otherwise.  A more\n   restrictive\
    \ search specification is one that would generate a subset\n   of the data produced\
    \ by the original search specification.\n"
- title: 5.2.  Renaming the Base Object
  contents:
  - "5.2.  Renaming the Base Object\n   Because an LCUP client specifies the area\
    \ of the tree with which it\n   wishes to synchronize through the standard LDAP\
    \ search specification,\n   the client can be returned noSuchObject error if the\
    \ root of the\n   synchronization area was renamed between the synchronization\
    \ sessions\n   or during a synchronization session.  If this condition occurs,\
    \ the\n   client can attempt to locate the root by using the root's UUID saved\n\
    \   in client's local data store.  It then can repeat the synchronization\n  \
    \ request using the new search base.  In general, a client can detect\n   that\
    \ an entry was renamed and apply the changes received to the right\n   entry by\
    \ using the UUID rather than DN based addressing.\n"
- title: 5.3.  Use of Persistent Searches With Respect to Resources
  contents:
  - "5.3.  Use of Persistent Searches With Respect to Resources\n   Each active persistent\
    \ operation requires that an open TCP connection\n   be maintained between an\
    \ LDAP client and an LDAP server that might\n   not otherwise be kept open.  Therefore,\
    \ client implementors are\n   encouraged to avoid using persistent operations\
    \ for non-essential\n   tasks and to close idle LDAP connections as soon as practical.\
    \  The\n   server may close connections if server resources become tight.\n"
- title: 5.4.  Continuation References to Other LCUP Contexts
  contents:
  - "5.4.  Continuation References to Other LCUP Contexts\n   The client MAY receive\
    \ a continuation reference\n   (SearchResultReference [RFC2251 SECTION 4.5.3])\
    \ if the search request\n   spans multiple parts of the DIT, some of which may\
    \ require a\n   different LCUP cookie, some of which may not even be managed by\
    \ LCUP.\n   The client SHOULD maintain a cache of the LDAP URLs returned in the\n\
    \   continuation references and the cookies associated with them.  The\n   client\
    \ is responsible for performing another LCUP search to follow\n   the references,\
    \ and SHOULD use the cookie corresponding to the LDAP\n   URL for that reference\
    \ (if it has a cookie).\n"
- title: 5.5.  Referral Handling
  contents:
  - "5.5.  Referral Handling\n   The client may receive a referral (Referral [RFC2251\
    \ SECTION 4.1.11])\n   when the search base is a subordinate reference, and this\
    \ will end\n   the operation.\n"
- title: 5.6.  Multiple Copies of Same Entry During Sync Phase
  contents:
  - "5.6.  Multiple Copies of Same Entry During Sync Phase\n   The server MAY send\
    \ the same entry multiple times during a sync phase\n   if the entry changes during\
    \ the sync phase.  The client SHOULD use\n   the last sent copy of the entry as\
    \ the current one.\n"
- title: 5.7.  Handling Server Out of Resources Condition
  contents:
  - "5.7.  Handling Server Out of Resources Condition\n   If the client receives an\
    \ lcupResourcesExhausted or\n   lcupSecurityViolation resultCode, the client SHOULD\
    \ wait at least 5\n   seconds before attempting another operation.  It is RECOMMENDED\
    \ that\n   the client use an exponential backoff strategy, but different clients\n\
    \   may want to use different backoff strategies.\n"
- title: 6.  Server Implementation Considerations
  contents:
  - '6.  Server Implementation Considerations

    '
- title: 6.1.  Server Support for UUIDs
  contents:
  - "6.1.  Server Support for UUIDs\n   Servers MUST support UUIDs.  UUIDs are required\
    \ in the Sync Update\n   control.  Additionally, server implementers SHOULD make\
    \ the UUID\n   values for the entries available as an attribute of the entry,\
    \ and\n   provide indexing or other mechanisms to allow clients to search for\n\
    \   an entry using the UUID attribute in the search filter.  The\n   syncUpdate\
    \ control provides a field UUIDAttribute to allow the server\n   to let the client\
    \ know the name or OID of the attribute to use to\n   search for an entry by UUID.\n"
- title: 6.2.  Example of Using an RUV as the Cookie Value
  contents:
  - "6.2.  Example of Using an RUV as the Cookie Value\n   By design, the protocol\
    \ supports multiple cookie schemes.  This is to\n   allow different implementations\
    \ the flexibility of storing any\n   information applicable to their environment.\
    \  A reasonable\n   implementation for an LDUP compliant server would be to use\
    \ the\n   Replica Update Vector (RUV).  For each master, RUV contains the\n  \
    \ largest CSN seen from this master.  In addition, RUV implemented by\n   some\
    \ directory servers (not yet in LDUP) contains replica generation\n   - an opaque\
    \ string that identifies the replica's data store.  The\n   replica generation\
    \ value changes whenever the replica's data is\n   reloaded.  Replica generation\
    \ is intended to signal the\n   replication/synchronization peers that the replica's\
    \ data was\n   reloaded and that all other replicas need to be reinitialized.\
    \  RUV\n   satisfies the three most important properties of the cookie: (1) it\n\
    \   uniquely identifies the state of client's data, (2) it can be used to\n  \
    \ synchronize with multiple servers, and (3) it can be used to detect\n   that\
    \ the server's data was reloaded.  If RUV is used as the cookie,\n   entries last\
    \ modified by a particular master must be sent to the\n   client in the order\
    \ of their last modified CSN.  This ordering\n   guarantees that the RUV can be\
    \ updated after each entry is sent.\n"
- title: 6.3. Cookie Support Issues
  contents:
  - '6.3. Cookie Support Issues

    '
- title: 6.3.1.  Support for Multiple Cookie Schemes
  contents:
  - "6.3.1.  Support for Multiple Cookie Schemes\n   A server may support one or more\
    \ LCUP cookie schemes.  It is expected\n   that schemes will be published along\
    \ with their OIDs as RFCs.  The\n   server's DIT may be partitioned into different\
    \ sections which may\n   have different cookies associated with them.  For example,\
    \ some\n   servers may use some sort of replication mechanism to support LCUP.\n\
    \   If so, the DIT may be partitioned into multiple replicas.  A client\n   may\
    \ send an LCUP search request that spans multiple replicas.  Some\n   parts of\
    \ the DIT spanned by the search request scope may support LCUP\n   and some may\
    \ not.  The server MUST send a SearchResultReference\n   [RFC2251, SECTION 4.5.3]\
    \ when the LCUP Context for a returned entry\n   changes.  The server SHOULD send\
    \ all references to other LCUP\n   Contexts in the search scope first, in order\
    \ to allow the clients to\n   process these searches in parallel.  The LDAP URL(s)\
    \ returned MUST\n   contain the DN(s) of the base of another section of the DIT\
    \ (however\n   the server implementation has partitioned the DIT).  The client\
    \ will\n   then issue another LCUP search using the LDAP URL returned.  Each\n\
    \   section of the DIT MAY require a different cookie value, so the\n   client\
    \ SHOULD maintain a cache, mapping the different LDAP URL values\n   to different\
    \ cookies.  If the cookie changes, the scheme may change\n   as well, but the\
    \ cookie scheme MUST be the same within a given LCUP\n   Context.\n"
- title: 6.3.2.  Information Contained in the Cookie
  contents:
  - "6.3.2.  Information Contained in the Cookie\n   The cookie must contain enough\
    \ information to allow the server to\n   determine whether the cookie can be safely\
    \ used with the search\n   specification it is attached to.  As discussed earlier\
    \ in the\n   document, the cookie SHOULD only be used with the search\n   specification\
    \ that is equal to the one for which the cookie was\n   generated, but some servers\
    \ MAY support using a cookie with a search\n   specification that is more restrictive\
    \ than the one used to generate\n   the cookie.\n"
- title: 6.4.  Persist Phase Response Time
  contents:
  - "6.4.  Persist Phase Response Time\n   The specification makes no guarantees about\
    \ how soon a server should\n   send notification of a changed entry to the client\
    \ during the persist\n   phase.  This is intentional as any specific maximum delay\
    \ would be\n   impossible to meet in a distributed directory service implementation.\n\
    \   Server implementers are encouraged to minimize the delay before\n   sending\
    \ notifications to ensure that clients' needs for timeliness of\n   change notification\
    \ are met.\n"
- title: 6.5.  Scaling Considerations
  contents:
  - "6.5.  Scaling Considerations\n   Implementers of servers that support the mechanism\
    \ described in this\n   document should ensure that their implementation scales\
    \ well as the\n   number of active persistent operations and the number of changes\
    \ made\n   in the directory increases.  Server implementers are also encouraged\n\
    \   to support a large number of client connections if they need to\n   support\
    \ large numbers of persistent operations.\n"
- title: 6.6.  Alias Dereferencing
  contents:
  - "6.6.  Alias Dereferencing\n   LCUP design does not consider issues associated\
    \ with alias\n   dereferencing in search.  Clients MUST specify derefAliases as\
    \ either\n   neverDerefAliases or derefFindingBaseObj.  Servers are to return\n\
    \   protocolError if the client specifies either derefInSearching or\n   derefAlways.\n"
- title: 7.  Synchronizing Heterogeneous Data Stores
  contents:
  - "7.  Synchronizing Heterogeneous Data Stores\n   Clients, like a meta directory\
    \ join engine, synchronizing multiple\n   writable data stores, will only work\
    \ correctly if each piece of\n   information comes from a single authoritative\
    \ data source.  In a\n   replicated environment, an LCUP Context should employ\
    \ the same\n   conflict resolution scheme across all its replicas.  This is because\n\
    \   different systems have different notions of time and different update\n  \
    \ resolution procedures.  As a result, a change applied on one system\n   can\
    \ be discarded by the other, thus preventing the data stores from\n   converging.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   This document lists several values that have been\
    \ registered by the\n   IANA.  The following LDAP result codes have been assigned\
    \ by IANA as\n   described in section 3.6 of [RFC3383]:\n      lcupResourcesExhausted\
    \    113\n      lcupSecurityViolation     114\n      lcupInvalidData         \
    \  115\n      lcupUnsupportedScheme     116\n      lcupReloadRequired        117\n\
    \   The three controls defined in this document have been registered as\n   LDAP\
    \ Protocol Mechanisms as described in section 3.2 of [RFC3383].\n   One OID, 1.3.6.1.1.7,\
    \ has been assigned by IANA as described in\n   section 3.1 of [RFC3383].  The\
    \ OIDs for the controls defined in this\n   document are derived as follows from\
    \ the one assigned by IANA:\n      LCUP Sync Request Control    1.3.6.1.1.7.1\n\
    \      LCUP Sync Update Control     1.3.6.1.1.7.2\n      LCUP Sync Done Control\
    \       1.3.6.1.1.7.3\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   In some situations, it may be important to prevent\
    \ general exposure\n   of information about changes that occur in an LDAP server.\
    \ Therefore,\n   servers that implement the mechanism described in this document\n\
    \   SHOULD provide a means to enforce access control on the entries\n   returned\
    \ and MAY also provide specific access control mechanisms to\n   control the use\
    \ of the controls and extended operations defined in\n   this document.\n   As\
    \ with normal LDAP search requests, a malicious client can initiate\n   a large\
    \ number of persistent search requests in an attempt to consume\n   all available\
    \ server resources and deny service to legitimate\n   clients.  The protocol provides\
    \ the means to stop malicious clients\n   by disconnecting them from the server.\
    \  The servers that implement\n   the mechanism SHOULD provide the means to detect\
    \ the malicious\n   clients. In addition, the servers SHOULD provide the means\
    \ to limit\n   the number of resources that can be consumed by a single client.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC2119]    Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n                Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC2251]    Wahl, M., Howes, T., and S. Kille, \"Lightweight\n\
    \                Directory Access Protocol (v3)\", RFC 2251, December\n      \
    \          1997.\n   [RFC3383]    Zeilenga, K., \"Internet Assigned Numbers Authority\n\
    \                (IANA) Considerations for Lightweight Directory Access\n    \
    \            Protocol (LDAP)\", BCP 64, RFC 3383, September 2002.\n   [RFC3909]\
    \    Zeilenga, K., \"Lightweight Directory Access Protocol\n                (LDAP)\
    \ Cancel Operation\", RFC 3909, October 2004.\n   [X.680]      ITU-T, \"Abstract\
    \ Syntax Notation One (ASN.1) -\n                Specification of Basic Notation\"\
    , X.680, 1994.\n   [X.690]      ITU-T, \"Specification of ASN.1 encoding rules:\
    \  Basic,\n                Canonical, and Distinguished Encoding Rules\", X.690,\n\
    \                1994.\n   [UUID]       International Organization for Standardization\
    \ (ISO),\n                \"Information technology - Open Systems Interconnection\
    \ -\n                Remote Procedure Call\", ISO/IEC 11578:1996.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [RFC3384]    Stokes, E., Weiser, R., Moats,\
    \ R., and R. Huber,\n                \"Lightweight Directory Access Protocol (version\
    \ 3)\n                Replication Requirements\", RFC 3384, October 2002.\n  \
    \ [RFC3671]    Zeilenga, K., \"Collective Attributes in the Lightweight\n    \
    \            Directory Access Protocol (LDAP)\", RFC 3671, December\n        \
    \        2003.\n   [RFC3672]    Zeilenga, K. and S. Legg, \"Subentries in the\
    \ Lightweight\n                Directory Access Protocol (LDAP)\", RFC 3672, December\n\
    \                2003.\n"
- title: 11.  Acknowledgments
  contents:
  - "11.  Acknowledgments\n   The LCUP protocol is based in part on the Persistent\
    \ Search Change\n   Notification Mechanism defined by Mark Smith, Gordon Good,\
    \ Tim Howes,\n   and Rob Weltman, the LDAPv3 Triggered Search Control defined\
    \ by Mark\n   Wahl, and the LDAP Control for Directory Synchronization defined\
    \ by\n   Michael Armijo.  The members of the IETF LDUP working group made\n  \
    \ significant contributions to this document.\n"
- title: Appendix - Features Left Out of LCUP
  contents:
  - "Appendix - Features Left Out of LCUP\n   There are several features present in\
    \ other protocols or considered\n   useful by clients that are currently not included\
    \ in the protocol\n   primarily because they are difficult to implement on the\
    \ server.\n   These features are briefly discussed in this section.\n"
- title: Triggered Search Change Type
  contents:
  - "Triggered Search Change Type\n   This feature is present in the Triggered Search\
    \ specification.  A\n   flag is attached to each entry returned to the client\
    \ indicating the\n   reason why this entry is returned.  The possible reasons\
    \ from the\n   document are:\n   -  notChange: the entry existed in the directory\
    \ and matched the\n      search at the time the operation is being performed,\n\
    \   -  enteredSet: the entry entered the result,\n   -  leftSet: the entry left\
    \ the result,\n   -  modified: the entry was part of the result set, was modified\
    \ or\n      renamed, and still is in the result set.\n   The leftSet feature is\
    \ particularly useful because it indicates to\n   the client that an entry is\
    \ no longer within the client's search\n   specification and the client can remove\
    \ the associated data from its\n   data store.  Ironically, this feature is the\
    \ hardest to implement on\n   the server because the server does not keep track\
    \ of the client's\n   state and has no easy way of telling which entries moved\
    \ out of scope\n   between synchronization sessions with the client.  A compromise\
    \ could\n   be reached by only providing this feature for the operations that\n\
    \   occur while the client is connected to the server.  This is easier to\n  \
    \ accomplish because the decision about the change type can be made\n   based\
    \ only on the change without need for any historical information.\n   This, however,\
    \ would add complexity to the protocol.\n"
- title: Persistent Search Change Type
  contents:
  - "Persistent Search Change Type\n   This feature is present in the Persistent Search\
    \ specification.\n   Persistent search has the notion of changeTypes.  The client\n\
    \   specifies which type of updates will cause entries to be returned,\n   and\
    \ optionally whether the server tags each returned entry with the\n   type of\
    \ change that caused that entry to be returned.\n   For LCUP, the intention is\
    \ full synchronization, not partial.  Each\n   entry returned by an LCUP search\
    \ will have some change associated\n   with it that may concern the client.  The\
    \ client may have to have a\n   local index of entries by DN or UUID to determine\
    \ if the entry has\n   been added or just modified.  It is easy for clients to\
    \ determine if\n   the entry has been deleted because the entryLeftSet value of\
    \ the Sync\n   Update control will be TRUE.\n"
- title: Sending Changes
  contents:
  - "Sending Changes\n   Some earlier synchronization protocols sent the client(s)\
    \ only the\n   modified attributes of the entry rather than the entire entry.\
    \  While\n   this approach can significantly reduce the amount of data returned\
    \ to\n   the client, it has several disadvantages.  First, unless a separate\n\
    \   mechanism (like the change type described above) is used to notify\n   the\
    \ client about entries moving into the search scope, sending only\n   the changes\
    \ can result in the client having an incomplete version of\n   the data.  Let's\
    \ consider an example.  An attribute of an entry is\n   modified.  As a result\
    \ of the change, the entry enters the scope of\n   the client's search.  If only\
    \ the changes are sent, the client would\n   never see the initial data of the\
    \ entry.  Second, this feature is\n   hard to implement since the server might\
    \ not contain sufficient\n   information to construct the changes based solely\
    \ on the server's\n   state and the client's cookie.  On the other hand, this\
    \ feature can\n   be easily implemented by the client assuming that the client\
    \ has the\n   previous version of the data and can perform value by value\n  \
    \ comparisons.\n"
- title: Data Size Limits
  contents:
  - "Data Size Limits\n   Some earlier synchronization protocols allowed clients to\
    \ control the\n   amount of data sent to them in the search response.  This feature\
    \ was\n   intended to allow clients with limited resources to process\n   synchronization\
    \ data in batches.  However, an LDAP search operation\n   already provides the\
    \ means for the client to specify the size limit\n   by setting the sizeLimit\
    \ field in the SearchRequest to the maximum\n   number of entries the client is\
    \ willing to receive.  While the\n   granularity is not the same, the assumption\
    \ is that regular LDAP\n   clients that can deal with the limitations of the LDAP\
    \ protocol will\n   implement LCUP.\n"
- title: Data Ordering
  contents:
  - "Data Ordering\n   Some earlier synchronization protocols allowed a client to\
    \ specify\n   that parent entries should be sent before the children for add\n\
    \   operations and children entries sent before their parents during\n   delete\
    \ operations.  This ordering helps clients to maintain a\n   hierarchical view\
    \ of the data in their data store.  While possibly\n   useful, this feature is\
    \ relatively hard to implement and is expensive\n   to perform.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Rich Megginson\n   Netscape Communications Corp., an America\
    \ Online company.\n   360 W. Caribbean Drive\n   Sunnyvale, CA 94089\n   USA\n\
    \   Phone: +1 505 797-7762\n   EMail: rmegginson0224@aol.com\n   Olga Natkovich\n\
    \   Yahoo, Inc.\n   701 First Ave.\n   Sunnyvale, CA 94089\n   USA\n   Phone:\
    \ +1 408 349-6153\n   EMail: olgan@yahoo-inc.com\n   Mark Smith\n   Pearl Crescent,\
    \ LLC\n   447 Marlpool Drive\n   Saline, MI 48176\n   USA\n   Phone: +1 734 944-2856\n\
    \   EMail: mcs@pearlcrescent.com\n   Jeff Parham\n   Microsoft Corporation\n \
    \  One Microsoft Way\n   Redmond, WA 98052-6399\n   USA\n   Phone: +1 425 882-8080\n\
    \   EMail: jeffparh@microsoft.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2004).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and at www.rfc-editor.org, and except as set\n   forth therein, the\
    \ authors retain all their rights.\n   This document and the information contained\
    \ herein are provided on an\n   \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION\
    \ HE/SHE REPRESENTS\n   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND\
    \ THE INTERNET\n   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR\
    \ IMPLIED,\n   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE\n\
    \   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES\
    \ OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ ISOC's procedures with respect to rights in ISOC Documents can\n   be found\
    \ in BCP 78 and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat\
    \ and any\n   assurances of licenses to be made available, or the result of an\n\
    \   attempt made to obtain a general license or permission for the use of\n  \
    \ such proprietary rights by implementers or users of this\n   specification can\
    \ be obtained from the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n\
    \   The IETF invites any interested party to bring to its attention any\n   copyrights,\
    \ patents or patent applications, or other proprietary\n   rights that may cover\
    \ technology that may be required to implement\n   this standard.  Please address\
    \ the information to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
