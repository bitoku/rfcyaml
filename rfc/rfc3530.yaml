- title: __initial_text__
  contents:
  - '              Network File System (NFS) version 4 Protocol

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Network File System (NFS) version 4 is a distributed filesystem\n\
    \   protocol which owes heritage to NFS protocol version 2, RFC 1094, and\n  \
    \ version 3, RFC 1813.  Unlike earlier versions, the NFS version 4\n   protocol\
    \ supports traditional file access while integrating support\n   for file locking\
    \ and the mount protocol.  In addition, support for\n   strong security (and its\
    \ negotiation), compound operations, client\n   caching, and internationalization\
    \ have been added.  Of course,\n   attention has been applied to making NFS version\
    \ 4 operate well in an\n   Internet environment.\n   This document replaces RFC\
    \ 3010 as the definition of the NFS version\n   4 protocol.\n"
- title: Key Words
  contents:
  - "Key Words\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",\
    \ \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.   Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . .    8\n        1.1.  Changes since RFC 3010 . . . . . . . . . . . . .\
    \ . .    8\n        1.2.  NFS version 4 Goals. . . . . . . . . . . . . . . . .\
    \    9\n        1.3.  Inconsistencies of this Document with Section 18 . .   \
    \ 9\n        1.4.  Overview of NFS version 4 Features . . . . . . . . .   10\n\
    \              1.4.1.  RPC and Security . . . . . . . . . . . . . .   10\n   \
    \           1.4.2.  Procedure and Operation Structure. . . . . .   10\n      \
    \        1.4.3.  Filesystem Mode. . . . . . . . . . . . . . .   11\n         \
    \             1.4.3.1.  Filehandle Types . . . . . . . . .   11\n            \
    \          1.4.3.2.  Attribute Types. . . . . . . . . .   12\n               \
    \       1.4.3.3.  Filesystem Replication and\n                               \
    \ Migration. . . . . . . . . . . . .   13\n              1.4.4.  OPEN and CLOSE\
    \ . . . . . . . . . . . . . . .   13\n              1.4.5.  File locking . . .\
    \ . . . . . . . . . . . . .   13\n              1.4.6.  Client Caching and Delegation.\
    \ . . . . . . .   13\n        1.5.  General Definitions. . . . . . . . . . . .\
    \ . . . . .   14\n   2.   Protocol Data Types. . . . . . . . . . . . . . . . .\
    \ . . .   16\n        2.1.  Basic Data Types . . . . . . . . . . . . . . . . .\
    \ .   16\n        2.2.  Structured Data Types. . . . . . . . . . . . . . . . \
    \  18\n   3.   RPC and Security Flavor. . . . . . . . . . . . . . . . . .   23\n\
    \        3.1.  Ports and Transports . . . . . . . . . . . . . . . .   23\n   \
    \           3.1.1.  Client Retransmission Behavior . . . . . . .   24\n      \
    \  3.2.  Security Flavors . . . . . . . . . . . . . . . . . .   25\n         \
    \     3.2.1.  Security mechanisms for NFS version 4. . . .   25\n            \
    \          3.2.1.1.  Kerberos V5 as a security triple .   25\n               \
    \       3.2.1.2.  LIPKEY as a security triple. . . .   26\n                  \
    \    3.2.1.3.  SPKM-3 as a security triple. . . .   27\n        3.3.  Security\
    \ Negotiation . . . . . . . . . . . . . . . .   27\n              3.3.1.  SECINFO.\
    \ . . . . . . . . . . . . . . . . . .   28\n              3.3.2.  Security Error\
    \ . . . . . . . . . . . . . . .   28\n        3.4.  Callback RPC Authentication.\
    \ . . . . . . . . . . . .   28\n   4.  Filehandles . . . . . . . . . . . . . .\
    \ . . . . . . . . . .   30\n        4.1.  Obtaining the First Filehandle . . .\
    \ . . . . . . . .   30\n              4.1.1.  Root Filehandle. . . . . . . . .\
    \ . . . . . .   31\n              4.1.2.  Public Filehandle. . . . . . . . . .\
    \ . . . .   31\n        4.2.  Filehandle Types . . . . . . . . . . . . . . . .\
    \ . .   31\n              4.2.1.  General Properties of a Filehandle . . . . .\
    \   32\n              4.2.2.  Persistent Filehandle. . . . . . . . . . . .   32\n\
    \              4.2.3.  Volatile Filehandle. . . . . . . . . . . . .   33\n   \
    \           4.2.4.  One Method of Constructing a\n                      Volatile\
    \ Filehandle. . . . . . . . . . . . .   34\n        4.3.  Client Recovery from\
    \ Filehandle Expiration . . . . .   35\n   5.   File Attributes. . . . . . . .\
    \ . . . . . . . . . . . . . .   35\n        5.1.  Mandatory Attributes . . . .\
    \ . . . . . . . . . . . .   37\n        5.2.  Recommended Attributes . . . . .\
    \ . . . . . . . . . .   37\n        5.3.  Named Attributes . . . . . . . . . .\
    \ . . . . . . . .   37\n        5.4.  Classification of Attributes . . . . . .\
    \ . . . . . .   38\n        5.5.  Mandatory Attributes - Definitions . . . . .\
    \ . . . .   39\n        5.6.  Recommended Attributes - Definitions . . . . . .\
    \ . .   41\n        5.7.  Time Access. . . . . . . . . . . . . . . . . . . . .\
    \   46\n        5.8.  Interpreting owner and owner_group . . . . . . . . .   47\n\
    \        5.9.  Character Case Attributes. . . . . . . . . . . . . .   49\n   \
    \     5.10. Quota Attributes . . . . . . . . . . . . . . . . . .   49\n      \
    \  5.11. Access Control Lists . . . . . . . . . . . . . . . .   50\n         \
    \      5.11.1.  ACE type . . . . . . . . . . . . . . . . .   51\n            \
    \   5.11.2.  ACE Access Mask. . . . . . . . . . . . . .   52\n               5.11.3.\
    \  ACE flag . . . . . . . . . . . . . . . . .   54\n               5.11.4.  ACE\
    \ who  . . . . . . . . . . . . . . . . .   55\n               5.11.5.  Mode Attribute\
    \ . . . . . . . . . . . . . .   56\n               5.11.6.  Mode and ACL Attribute\
    \ . . . . . . . . . .   57\n               5.11.7.  mounted_on_fileid. . . . .\
    \ . . . . . . . .   57\n   6.  Filesystem Migration and Replication  . . . . .\
    \ . . . . . .   58\n        6.1.  Replication. . . . . . . . . . . . . . . . .\
    \ . . . .   58\n        6.2.  Migration. . . . . . . . . . . . . . . . . . . .\
    \ . .   59\n        6.3.  Interpretation of the fs_locations Attribute . . . .\
    \   60\n        6.4.  Filehandle Recovery for Migration or Replication . .   61\n\
    \   7.  NFS Server Name Space . . . . . . . . . . . . . . . . . . .   61\n   \
    \     7.1.  Server Exports . . . . . . . . . . . . . . . . . . .   61\n      \
    \  7.2.  Browsing Exports . . . . . . . . . . . . . . . . . .   62\n        7.3.\
    \  Server Pseudo Filesystem . . . . . . . . . . . . . .   62\n        7.4.  Multiple\
    \ Roots . . . . . . . . . . . . . . . . . . .   63\n        7.5.  Filehandle Volatility.\
    \ . . . . . . . . . . . . . . .   63\n        7.6.  Exported Root. . . . . . .\
    \ . . . . . . . . . . . . .   63\n        7.7.  Mount Point Crossing . . . . .\
    \ . . . . . . . . . . .   63\n        7.8.  Security Policy and Name Space Presentation.\
    \ . . . .   64\n   8.   File Locking and Share Reservations. . . . . . . . . .\
    \ . .   65\n        8.1.  Locking. . . . . . . . . . . . . . . . . . . . . . .\
    \   65\n              8.1.1.    Client ID. . . . . . . . . . . . . . . . .   66\n\
    \              8.1.2.    Server Release of Clientid . . . . . . . .   69\n   \
    \           8.1.3.    lock_owner and stateid Definition. . . . .   69\n      \
    \        8.1.4.    Use of the stateid and Locking . . . . . .   71\n         \
    \     8.1.5.    Sequencing of Lock Requests. . . . . . . .   73\n            \
    \  8.1.6.    Recovery from Replayed Requests. . . . . .   74\n              8.1.7.\
    \    Releasing lock_owner State . . . . . . . .   74\n              8.1.8.   \
    \ Use of Open Confirmation . . . . . . . . .   75\n        8.2.  Lock Ranges.\
    \ . . . . . . . . . . . . . . . . . . . .   76\n        8.3.  Upgrading and Downgrading\
    \ Locks. . . . . . . . . . .   76\n        8.4.  Blocking Locks . . . . . . .\
    \ . . . . . . . . . . . .   77\n        8.5.  Lease Renewal. . . . . . . . . .\
    \ . . . . . . . . . .   77\n        8.6.  Crash Recovery . . . . . . . . . . .\
    \ . . . . . . . .   78\n               8.6.1.   Client Failure and Recovery. .\
    \ . . . . . .   79\n               8.6.2.   Server Failure and Recovery. . . .\
    \ . . . .   79\n               8.6.3.   Network Partitions and Recovery. . . .\
    \ . .   81\n        8.7.   Recovery from a Lock Request Timeout or Abort . . .\
    \   85\n        8.8.   Server Revocation of Locks. . . . . . . . . . . . .   85\n\
    \        8.9.   Share Reservations. . . . . . . . . . . . . . . . .   86\n   \
    \     8.10.  OPEN/CLOSE Operations . . . . . . . . . . . . . . .   87\n      \
    \         8.10.1.  Close and Retention of State\n                        Information.\
    \ . . . . . . . . . . . . . . .   88\n        8.11.  Open Upgrade and Downgrade.\
    \ . . . . . . . . . . . .   88\n        8.12.  Short and Long Leases . . . . .\
    \ . . . . . . . . . .   89\n        8.13.  Clocks, Propagation Delay, and Calculating\
    \ Lease\n               Expiration. . . . . . . . . . . . . . . . . . . . .  \
    \ 89\n        8.14.  Migration, Replication and State. . . . . . . . . .   90\n\
    \               8.14.1.  Migration and State. . . . . . . . . . . .   90\n   \
    \            8.14.2.  Replication and State. . . . . . . . . . .   91\n      \
    \         8.14.3.  Notification of Migrated Lease . . . . . .   92\n         \
    \      8.14.4.  Migration and the Lease_time Attribute . .   92\n   9.  Client-Side\
    \ Caching . . . . . . . . . . . . . . . . . . . .   93\n        9.1.   Performance\
    \ Challenges for Client-Side Caching. . .   93\n        9.2.   Delegation and\
    \ Callbacks. . . . . . . . . . . . . .   94\n               9.2.1.  Delegation\
    \ Recovery . . . . . . . . . . . .   96\n        9.3.   Data Caching. . . . .\
    \ . . . . . . . . . . . . . . .   98\n               9.3.1.   Data Caching and\
    \ OPENs . . . . . . . . . .   98\n               9.3.2.   Data Caching and File\
    \ Locking. . . . . . .   99\n               9.3.3.   Data Caching and Mandatory\
    \ File Locking. .  101\n               9.3.4.   Data Caching and File Identity\
    \ . . . . . .  101\n        9.4.   Open Delegation . . . . . . . . . . . . . .\
    \ . . . .  102\n               9.4.1.   Open Delegation and Data Caching . . .\
    \ . .  104\n               9.4.2.   Open Delegation and File Locks . . . . . .\
    \  106\n               9.4.3.   Handling of CB_GETATTR . . . . . . . . . .  106\n\
    \               9.4.4.   Recall of Open Delegation. . . . . . . . .  109\n   \
    \            9.4.5.   Clients that Fail to Honor\n                        Delegation\
    \ Recalls . . . . . . . . . . . .  111\n               9.4.6.   Delegation Revocation.\
    \ . . . . . . . . . .  112\n        9.5.   Data Caching and Revocation . . . .\
    \ . . . . . . . .  112\n               9.5.1.   Revocation Recovery for Write\
    \ Open\n                        Delegation . . . . . . . . . . . . . . . .  113\n\
    \        9.6.   Attribute Caching . . . . . . . . . . . . . . . . .  113\n   \
    \     9.7.   Data and Metadata Caching and Memory Mapped Files .  115\n      \
    \  9.8.   Name Caching  . . . . . . . . . . . . . . . . . . .  118\n        9.9.\
    \   Directory Caching . . . . . . . . . . . . . . . . .  119\n   10.  Minor Versioning\
    \ . . . . . . . . . . . . . . . . . . . . .  120\n   11.  Internationalization\
    \ . . . . . . . . . . . . . . . . . . .  122\n        11.1.  Stringprep profile\
    \ for the utf8str_cs type. . . . .  123\n               11.1.1.  Intended applicability\
    \ of the\n                        nfs4_cs_prep profile . . . . . . . . . . . \
    \ 123\n               11.1.2.  Character repertoire of nfs4_cs_prep . . .  124\n\
    \               11.1.3.  Mapping used by nfs4_cs_prep . . . . . . .  124\n   \
    \            11.1.4.  Normalization used by nfs4_cs_prep . . . .  124\n      \
    \         11.1.5.  Prohibited output for nfs4_cs_prep . . . .  125\n         \
    \      11.1.6.  Bidirectional output for nfs4_cs_prep. . .  125\n        11.2.\
    \  Stringprep profile for the utf8str_cis type . . . .  125\n               11.2.1.\
    \  Intended applicability of the\n                        nfs4_cis_prep profile.\
    \ . . . . . . . . . .  125\n               11.2.2.  Character repertoire of nfs4_cis_prep\
    \  . .  125\n               11.2.3.  Mapping used by nfs4_cis_prep  . . . . .\
    \ .  125\n               11.2.4.  Normalization used by nfs4_cis_prep  . . . \
    \ 125\n               11.2.5.  Prohibited output for nfs4_cis_prep  . . .  126\n\
    \               11.2.6.  Bidirectional output for nfs4_cis_prep . .  126\n   \
    \     11.3.  Stringprep profile for the utf8str_mixed type . . .  126\n      \
    \         11.3.1.  Intended applicability of the\n                        nfs4_mixed_prep\
    \ profile. . . . . . . . . .  126\n               11.3.2.  Character repertoire\
    \ of nfs4_mixed_prep  .  126\n               11.3.3.  Mapping used by nfs4_cis_prep\
    \  . . . . . .  126\n               11.3.4.  Normalization used by nfs4_mixed_prep\
    \  . .  127\n               11.3.5.  Prohibited output for nfs4_mixed_prep  .\
    \ .  127\n               11.3.6.  Bidirectional output for nfs4_mixed_prep . \
    \ 127\n        11.4.  UTF-8 Related Errors. . . . . . . . . . . . . . . .  127\n\
    \   12.  Error Definitions  . . . . . . . . . . . . . . . . . . . .  128\n   13.\
    \  NFS version 4 Requests . . . . . . . . . . . . . . . . . .  134\n        13.1.\
    \  Compound Procedure. . . . . . . . . . . . . . . . .  134\n        13.2.  Evaluation\
    \ of a Compound Request. . . . . . . . . .  135\n        13.3.  Synchronous Modifying\
    \ Operations. . . . . . . . . .  136\n        13.4.  Operation Values. . . . .\
    \ . . . . . . . . . . . . .  136\n   14.  NFS version 4 Procedures . . . . . .\
    \ . . . . . . . . . . .  136\n        14.1.  Procedure 0: NULL - No Operation.\
    \ . . . . . . . . .  136\n        14.2.  Procedure 1: COMPOUND - Compound Operations\
    \ . . . .  137\n               14.2.1.   Operation 3: ACCESS - Check Access\n\
    \                         Rights. . . . . . . . . . . . . . . . . .  140\n   \
    \            14.2.2.   Operation 4: CLOSE - Close File . . . . .  142\n      \
    \         14.2.3.   Operation 5: COMMIT - Commit\n                         Cached\
    \ Data . . . . . . . . . . . . . . .  144\n               14.2.4.   Operation\
    \ 6: CREATE - Create a\n                         Non-Regular File Object . . .\
    \ . . . . . .  147\n               14.2.5.   Operation 7: DELEGPURGE -\n     \
    \                    Purge Delegations Awaiting Recovery . . .  150\n        \
    \       14.2.6.   Operation 8: DELEGRETURN - Return\n                        \
    \ Delegation. . . . . . . . . . . . . . . .  151\n               14.2.7.   Operation\
    \ 9: GETATTR - Get Attributes . .  152\n               14.2.8.   Operation 10:\
    \ GETFH - Get Current\n                         Filehandle. . . . . . . . . .\
    \ . . . . . .  153\n               14.2.9.   Operation 11: LINK - Create Link\
    \ to a\n                         File. . . . . . . . . . . . . . . . . . .  154\n\
    \               14.2.10.  Operation 12: LOCK - Create Lock  . . . .  156\n   \
    \            14.2.11.  Operation 13: LOCKT - Test For Lock . . .  160\n      \
    \         14.2.12.  Operation 14: LOCKU - Unlock File . . . .  162\n         \
    \      14.2.13.  Operation 15: LOOKUP - Lookup Filename. .  163\n            \
    \   14.2.14.  Operation 16: LOOKUPP - Lookup\n                         Parent\
    \ Directory. . . . . . . . . . . . .  165\n               14.2.15.  Operation\
    \ 17: NVERIFY - Verify\n                         Difference in Attributes  . .\
    \ . . . . . .  166\n               14.2.16.  Operation 18: OPEN - Open a Regular\n\
    \                         File. . . . . . . . . . . . . . . . . . .  168\n   \
    \            14.2.17.  Operation 19: OPENATTR - Open Named\n                 \
    \        Attribute Directory . . . . . . . . . . .  178\n               14.2.18.\
    \  Operation 20: OPEN_CONFIRM -\n                         Confirm Open . . . .\
    \ . . . . . . . . . .   180\n               14.2.19.  Operation 21: OPEN_DOWNGRADE\
    \ -\n                         Reduce Open File Access . . . . . . . . .  182\n\
    \               14.2.20.  Operation 22: PUTFH - Set\n                        \
    \ Current Filehandle. . . . . . . . . . . .  184\n               14.2.21.  Operation\
    \ 23: PUTPUBFH -\n                         Set Public Filehandle . . . . . . .\
    \ . . .  185\n               14.2.22.  Operation 24: PUTROOTFH -\n           \
    \              Set Root Filehandle . . . . . . . . . . .  186\n              \
    \ 14.2.23.  Operation 25: READ - Read from File . . .  187\n               14.2.24.\
    \  Operation 26: READDIR -\n                         Read Directory. . . . . .\
    \ . . . . . . . .  190\n               14.2.25.  Operation 27: READLINK -\n  \
    \                       Read Symbolic Link. . . . . . . . . . . .  193\n     \
    \          14.2.26.  Operation 28: REMOVE -\n                         Remove Filesystem\
    \ Object. . . . . . . . .  195\n               14.2.27.  Operation 29: RENAME\
    \ -\n                         Rename Directory Entry. . . . . . . . . .  197\n\
    \               14.2.28.  Operation 30: RENEW - Renew a Lease . . .  200\n   \
    \            14.2.29.  Operation 31: RESTOREFH -\n                         Restore\
    \ Saved Filehandle. . . . . . . . .  201\n               14.2.30.  Operation 32:\
    \ SAVEFH - Save\n                         Current Filehandle. . . . . . . . .\
    \ . . .  202\n               14.2.31.  Operation 33: SECINFO - Obtain\n      \
    \                   Available Security. . . . . . . . . . . .  203\n         \
    \      14.2.32.  Operation 34: SETATTR - Set Attributes. .  206\n            \
    \   14.2.33.  Operation 35: SETCLIENTID -\n                         Negotiate\
    \ Clientid. . . . . . . . . . . .  209\n               14.2.34.  Operation 36:\
    \ SETCLIENTID_CONFIRM -\n                         Confirm Clientid. . . . . .\
    \ . . . . . . .  213\n               14.2.35.  Operation 37: VERIFY -\n      \
    \                   Verify Same Attributes. . . . . . . . . .  217\n         \
    \      14.2.36.  Operation 38: WRITE - Write to File . . .  218\n            \
    \   14.2.37.  Operation 39: RELEASE_LOCKOWNER -\n                         Release\
    \ Lockowner State . . . . . . . . .  223\n               14.2.38.  Operation 10044:\
    \ ILLEGAL -\n                         Illegal operation . . . . . . . . . . .\
    \ .  224\n   15.  NFS version 4 Callback Procedures  . . . . . . . . . . . . \
    \ 225\n        15.1.  Procedure 0: CB_NULL - No Operation . . . . . . . .  225\n\
    \        15.2.  Procedure 1: CB_COMPOUND - Compound\n               Operations.\
    \ . . . . . . . . . . . . . . . . . . . .  226\n               15.2.1.  Operation\
    \ 3: CB_GETATTR - Get\n                        Attributes . . . . . . . . . .\
    \ . . . . . .  228\n               15.2.2.  Operation 4: CB_RECALL -\n       \
    \                 Recall an Open Delegation. . . . . . . . .  229\n          \
    \     15.2.3.  Operation 10044: CB_ILLEGAL -\n                        Illegal\
    \ Callback Operation . . . . . . . .  230\n   16.  Security Considerations  .\
    \ . . . . . . . . . . . . . . . .  231\n   17.  IANA Considerations  . . . . .\
    \ . . . . . . . . . . . . . .  232\n        17.1.  Named Attribute Definition.\
    \ . . . . . . . . . . . .  232\n        17.2.  ONC RPC Network Identifiers (netids).\
    \ . . . . . . .  232\n   18.  RPC definition file  . . . . . . . . . . . . . .\
    \ . . . . .  234\n   19.  Acknowledgements . . . . . . . . . . . . . . . . . .\
    \ . . .  268\n   20.  Normative References . . . . . . . . . . . . . . . . . .\
    \ .  268\n   21.  Informative References . . . . . . . . . . . . . . . . . . \
    \ 270\n   22.  Authors' Information . . . . . . . . . . . . . . . . . . .  273\n\
    \        22.1.  Editor's Address. . . . . . . . . . . . . . . . . .  273\n   \
    \     22.2.  Authors' Addresses. . . . . . . . . . . . . . . . .  274\n   23.\
    \  Full Copyright Statement . . . . . . . . . . . . . . . . .  275\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1.  Changes since RFC 3010
  contents:
  - "1.1.  Changes since RFC 3010\n   This definition of the NFS version 4 protocol\
    \ replaces or obsoletes\n   the definition present in [RFC3010].  While portions\
    \ of the two\n   documents have remained the same, there have been substantive\
    \ changes\n   in others.  The changes made between [RFC3010] and this document\n\
    \   represent implementation experience and further review of the\n   protocol.\
    \  While some modifications were made for ease of\n   implementation or clarification,\
    \ most updates represent errors or\n   situations where the [RFC3010] definition\
    \ were untenable.\n   The following list is not all inclusive of all changes but\
    \ presents\n   some of the most notable changes or additions made:\n   o  The\
    \ state model has added an open_owner4 identifier.  This was\n      done to accommodate\
    \ Posix based clients and the model they use for\n      file locking.  For Posix\
    \ clients, an open_owner4 would correspond\n      to a file descriptor potentially\
    \ shared amongst a set of processes\n      and the lock_owner4 identifier would\
    \ correspond to a process that\n      is locking a file.\n   o  Clarifications\
    \ and error conditions were added for the handling of\n      the owner and group\
    \ attributes.  Since these attributes are string\n      based (as opposed to the\
    \ numeric uid/gid of previous versions of\n      NFS), translations may not be\
    \ available and hence the changes\n      made.\n   o  Clarifications for the ACL\
    \ and mode attributes to address\n      evaluation and partial support.\n   o\
    \  For identifiers that are defined as XDR opaque, limits were set on\n      their\
    \ size.\n   o  Added the mounted_on_filed attribute to allow Posix clients to\n\
    \      correctly construct local mounts.\n   o  Modified the SETCLIENTID/SETCLIENTID_CONFIRM\
    \ operations to deal\n      correctly with confirmation details along with adding\
    \ the ability\n      to specify new client callback information.  Also added\n\
    \      clarification of the callback information itself.\n   o  Added a new operation\
    \ LOCKOWNER_RELEASE to enable notifying the\n      server that a lock_owner4 will\
    \ no longer be used by the client.\n   o  RENEW operation changes to identify\
    \ the client correctly and allow\n      for additional error returns.\n   o  Verify\
    \ error return possibilities for all operations.\n   o  Remove use of the pathname4\
    \ data type from LOOKUP and OPEN in\n      favor of having the client construct\
    \ a sequence of LOOKUP\n      operations to achieive the same effect.\n   o  Clarification\
    \ of the internationalization issues and adoption of\n      the new stringprep\
    \ profile framework.\n"
- title: 1.2.  NFS Version 4 Goals
  contents:
  - "1.2.  NFS Version 4 Goals\n   The NFS version 4 protocol is a further revision\
    \ of the NFS protocol\n   defined already by versions 2 [RFC1094] and 3 [RFC1813].\
    \  It retains\n   the essential characteristics of previous versions: design for\
    \ easy\n   recovery, independent of transport protocols, operating systems and\n\
    \   filesystems, simplicity, and good performance.  The NFS version 4\n   revision\
    \ has the following goals:\n   o  Improved access and good performance on the\
    \ Internet.\n      The protocol is designed to transit firewalls easily, perform\
    \ well\n      where latency is high and bandwidth is low, and scale to very\n\
    \      large numbers of clients per server.\n   o  Strong security with negotiation\
    \ built into the protocol.\n      The protocol builds on the work of the ONCRPC\
    \ working group in\n      supporting the RPCSEC_GSS protocol.  Additionally, the\
    \ NFS version\n      4 protocol provides a mechanism to allow clients and servers\
    \ the\n      ability to negotiate security and require clients and servers to\n\
    \      support a minimal set of security schemes.\n   o  Good cross-platform interoperability.\n\
    \      The protocol features a filesystem model that provides a useful,\n    \
    \  common set of features that does not unduly favor one filesystem\n      or\
    \ operating system over another.\n   o  Designed for protocol extensions.\n  \
    \    The protocol is designed to accept standard extensions that do not\n    \
    \  compromise backward compatibility.\n"
- title: 1.3.  Inconsistencies of this Document with Section 18
  contents:
  - "1.3.  Inconsistencies of this Document with Section 18\n   Section 18, RPC Definition\
    \ File, contains the definitions in XDR\n   description language of the constructs\
    \ used by the protocol.  Prior\n   to Section 18, several of the constructs are\
    \ reproduced for purposes\n   of explanation.  The reader is warned of the possibility\
    \ of errors in\n   the reproduced constructs outside of Section 18.  For any part\
    \ of the\n   document that is inconsistent with Section 18, Section 18 is to be\n\
    \   considered authoritative.\n"
- title: 1.4.  Overview of NFS version 4 Features
  contents:
  - "1.4.  Overview of NFS version 4 Features\n   To provide a reasonable context\
    \ for the reader, the major features of\n   NFS version 4 protocol will be reviewed\
    \ in brief.  This will be done\n   to provide an appropriate context for both\
    \ the reader who is familiar\n   with the previous versions of the NFS protocol\
    \ and the reader that is\n   new to the NFS protocols.  For the reader new to\
    \ the NFS protocols,\n   there is still a fundamental knowledge that is expected.\
    \  The reader\n   should be familiar with the XDR and RPC protocols as described\
    \ in\n   [RFC1831] and [RFC1832].  A basic knowledge of filesystems and\n   distributed\
    \ filesystems is expected as well.\n"
- title: 1.4.1.  RPC and Security
  contents:
  - "1.4.1.  RPC and Security\n   As with previous versions of NFS, the External Data\
    \ Representation\n   (XDR) and Remote Procedure Call (RPC) mechanisms used for\
    \ the NFS\n   version 4 protocol are those defined in [RFC1831] and [RFC1832].\
    \  To\n   meet end to end security requirements, the RPCSEC_GSS framework\n  \
    \ [RFC2203] will be used to extend the basic RPC security.  With the\n   use of\
    \ RPCSEC_GSS, various mechanisms can be provided to offer\n   authentication,\
    \ integrity, and privacy to the NFS version 4 protocol.\n   Kerberos V5 will be\
    \ used as described in [RFC1964] to provide one\n   security framework.  The LIPKEY\
    \ GSS-API mechanism described in\n   [RFC2847] will be used to provide for the\
    \ use of user password and\n   server public key by the NFS version 4 protocol.\
    \  With the use of\n   RPCSEC_GSS, other mechanisms may also be specified and\
    \ used for NFS\n   version 4 security.\n   To enable in-band security negotiation,\
    \ the NFS version 4 protocol\n   has added a new operation which provides the\
    \ client a method of\n   querying the server about its policies regarding which\
    \ security\n   mechanisms must be used for access to the server's filesystem\n\
    \   resources.  With this, the client can securely match the security\n   mechanism\
    \ that meets the policies specified at both the client and\n   server.\n"
- title: 1.4.2.  Procedure and Operation Structure
  contents:
  - "1.4.2.  Procedure and Operation Structure\n   A significant departure from the\
    \ previous versions of the NFS\n   protocol is the introduction of the COMPOUND\
    \ procedure.  For the NFS\n   version 4 protocol, there are two RPC procedures,\
    \ NULL and COMPOUND.\n   The COMPOUND procedure is defined in terms of operations\
    \ and these\n   operations correspond more closely to the traditional NFS procedures.\n\
    \   With the use of the COMPOUND procedure, the client is able to build\n   simple\
    \ or complex requests.  These COMPOUND requests allow for a\n   reduction in the\
    \ number of RPCs needed for logical filesystem\n   operations.  For example, without\
    \ previous contact with a server a\n   client will be able to read data from a\
    \ file in one request by\n   combining LOOKUP, OPEN, and READ operations in a\
    \ single COMPOUND RPC.\n   With previous versions of the NFS protocol, this type\
    \ of single\n   request was not possible.\n   The model used for COMPOUND is very\
    \ simple.  There is no logical OR\n   or ANDing of operations.  The operations\
    \ combined within a COMPOUND\n   request are evaluated in order by the server.\
    \  Once an operation\n   returns a failing result, the evaluation ends and the\
    \ results of all\n   evaluated operations are returned to the client.\n   The\
    \ NFS version 4 protocol continues to have the client refer to a\n   file or directory\
    \ at the server by a \"filehandle\".  The COMPOUND\n   procedure has a method\
    \ of passing a filehandle from one operation to\n   another within the sequence\
    \ of operations.  There is a concept of a\n   \"current filehandle\" and \"saved\
    \ filehandle\".  Most operations use the\n   \"current filehandle\" as the filesystem\
    \ object to operate upon.  The\n   \"saved filehandle\" is used as temporary filehandle\
    \ storage within a\n   COMPOUND procedure as well as an additional operand for\
    \ certain\n   operations.\n"
- title: 1.4.3.  Filesystem Model
  contents:
  - "1.4.3.  Filesystem Model\n   The general filesystem model used for the NFS version\
    \ 4 protocol is\n   the same as previous versions.  The server filesystem is hierarchical\n\
    \   with the regular files contained within being treated as opaque byte\n   streams.\
    \  In a slight departure, file and directory names are encoded\n   with UTF-8\
    \ to deal with the basics of internationalization.\n   The NFS version 4 protocol\
    \ does not require a separate protocol to\n   provide for the initial mapping\
    \ between path name and filehandle.\n   Instead of using the older MOUNT protocol\
    \ for this mapping, the\n   server provides a ROOT filehandle that represents\
    \ the logical root or\n   top of the filesystem tree provided by the server. \
    \ The server\n   provides multiple filesystems by gluing them together with pseudo\n\
    \   filesystems.  These pseudo filesystems provide for potential gaps in\n   the\
    \ path names between real filesystems.\n"
- title: 1.4.3.1.  Filehandle Types
  contents:
  - "1.4.3.1.  Filehandle Types\n   In previous versions of the NFS protocol, the\
    \ filehandle provided by\n   the server was guaranteed to be valid or persistent\
    \ for the lifetime\n   of the filesystem object to which it referred.  For some\
    \ server\n   implementations, this persistence requirement has been difficult\
    \ to\n   meet.  For the NFS version 4 protocol, this requirement has been\n  \
    \ relaxed by introducing another type of filehandle, volatile.  With\n   persistent\
    \ and volatile filehandle types, the server implementation\n   can match the abilities\
    \ of the filesystem at the server along with\n   the operating environment.  The\
    \ client will have knowledge of the\n   type of filehandle being provided by the\
    \ server and can be prepared\n   to deal with the semantics of each.\n"
- title: 1.4.3.2.  Attribute Types
  contents:
  - "1.4.3.2.  Attribute Types\n   The NFS version 4 protocol introduces three classes\
    \ of filesystem or\n   file attributes.  Like the additional filehandle type,\
    \ the\n   classification of file attributes has been done to ease server\n   implementations\
    \ along with extending the overall functionality of the\n   NFS protocol.  This\
    \ attribute model is structured to be extensible\n   such that new attributes\
    \ can be introduced in minor revisions of the\n   protocol without requiring significant\
    \ rework.\n   The three classifications are: mandatory, recommended and named\n\
    \   attributes.  This is a significant departure from the previous\n   attribute\
    \ model used in the NFS protocol.  Previously, the attributes\n   for the filesystem\
    \ and file objects were a fixed set of mainly UNIX\n   attributes.  If the server\
    \ or client did not support a particular\n   attribute, it would have to simulate\
    \ the attribute the best it could.\n   Mandatory attributes are the minimal set\
    \ of file or filesystem\n   attributes that must be provided by the server and\
    \ must be properly\n   represented by the server.  Recommended attributes represent\n\
    \   different filesystem types and operating environments.  The\n   recommended\
    \ attributes will allow for better interoperability and the\n   inclusion of more\
    \ operating environments.  The mandatory and\n   recommended attribute sets are\
    \ traditional file or filesystem\n   attributes.  The third type of attribute\
    \ is the named attribute.  A\n   named attribute is an opaque byte stream that\
    \ is associated with a\n   directory or file and referred to by a string name.\
    \  Named attributes\n   are meant to be used by client applications as a method\
    \ to associate\n   application specific data with a regular file or directory.\n\
    \   One significant addition to the recommended set of file attributes is\n  \
    \ the Access Control List (ACL) attribute.  This attribute provides for\n   directory\
    \ and file access control beyond the model used in previous\n   versions of the\
    \ NFS protocol.  The ACL definition allows for\n   specification of user and group\
    \ level access control.\n"
- title: 1.4.3.3.  Filesystem Replication and Migration
  contents:
  - "1.4.3.3.  Filesystem Replication and Migration\n   With the use of a special\
    \ file attribute, the ability to migrate or\n   replicate server filesystems is\
    \ enabled within the protocol.  The\n   filesystem locations attribute provides\
    \ a method for the client to\n   probe the server about the location of a filesystem.\
    \  In the event of\n   a migration of a filesystem, the client will receive an\
    \ error when\n   operating on the filesystem and it can then query as to the new\
    \ file\n   system location.  Similar steps are used for replication, the client\n\
    \   is able to query the server for the multiple available locations of a\n  \
    \ particular filesystem.  From this information, the client can use its\n   own\
    \ policies to access the appropriate filesystem location.\n"
- title: 1.4.4.  OPEN and CLOSE
  contents:
  - "1.4.4.  OPEN and CLOSE\n   The NFS version 4 protocol introduces OPEN and CLOSE\
    \ operations.  The\n   OPEN operation provides a single point where file lookup,\
    \ creation,\n   and share semantics can be combined.  The CLOSE operation also\n\
    \   provides for the release of state accumulated by OPEN.\n"
- title: 1.4.5.  File locking
  contents:
  - "1.4.5.  File locking\n   With the NFS version 4 protocol, the support for byte\
    \ range file\n   locking is part of the NFS protocol.  The file locking support\
    \ is\n   structured so that an RPC callback mechanism is not required.  This\n\
    \   is a departure from the previous versions of the NFS file locking\n   protocol,\
    \ Network Lock Manager (NLM).  The state associated with file\n   locks is maintained\
    \ at the server under a lease-based model.  The\n   server defines a single lease\
    \ period for all state held by a NFS\n   client.  If the client does not renew\
    \ its lease within the defined\n   period, all state associated with the client's\
    \ lease may be released\n   by the server.  The client may renew its lease with\
    \ use of the RENEW\n   operation or implicitly by use of other operations (primarily\
    \ READ).\n"
- title: 1.4.6.  Client Caching and Delegation
  contents:
  - "1.4.6.  Client Caching and Delegation\n   The file, attribute, and directory\
    \ caching for the NFS version 4\n   protocol is similar to previous versions.\
    \  Attributes and directory\n   information are cached for a duration determined\
    \ by the client.  At\n   the end of a predefined timeout, the client will query\
    \ the server to\n   see if the related filesystem object has been updated.\n \
    \  For file data, the client checks its cache validity when the file is\n   opened.\
    \  A query is sent to the server to determine if the file has\n   been changed.\
    \  Based on this information, the client determines if\n   the data cache for\
    \ the file should kept or released.  Also, when the\n   file is closed, any modified\
    \ data is written to the server.\n   If an application wants to serialize access\
    \ to file data, file\n   locking of the file data ranges in question should be\
    \ used.\n   The major addition to NFS version 4 in the area of caching is the\n\
    \   ability of the server to delegate certain responsibilities to the\n   client.\
    \  When the server grants a delegation for a file to a client,\n   the client\
    \ is guaranteed certain semantics with respect to the\n   sharing of that file\
    \ with other clients.  At OPEN, the server may\n   provide the client either a\
    \ read or write delegation for the file.\n   If the client is granted a read delegation,\
    \ it is assured that no\n   other client has the ability to write to the file\
    \ for the duration of\n   the delegation.  If the client is granted a write delegation,\
    \ the\n   client is assured that no other client has read or write access to\n\
    \   the file.\n   Delegations can be recalled by the server.  If another client\n\
    \   requests access to the file in such a way that the access conflicts\n   with\
    \ the granted delegation, the server is able to notify the initial\n   client\
    \ and recall the delegation.  This requires that a callback path\n   exist between\
    \ the server and client.  If this callback path does not\n   exist, then delegations\
    \ can not be granted.  The essence of a\n   delegation is that it allows the client\
    \ to locally service operations\n   such as OPEN, CLOSE, LOCK, LOCKU, READ, WRITE\
    \ without immediate\n   interaction with the server.\n"
- title: 1.5.  General Definitions
  contents:
  - "1.5.  General Definitions\n   The following definitions are provided for the\
    \ purpose of providing\n   an appropriate context for the reader.\n   Client \
    \   The \"client\" is the entity that accesses the NFS server's\n            \
    \ resources.  The client may be an application which contains\n             the\
    \ logic to access the NFS server directly.  The client\n             may also\
    \ be the traditional operating system client remote\n             filesystem services\
    \ for a set of applications.\n             In the case of file locking the client\
    \ is the entity that\n             maintains a set of locks on behalf of one or\
    \ more\n             applications.  This client is responsible for crash or\n\
    \             failure recovery for those locks it manages.\n             Note\
    \ that multiple clients may share the same transport and\n             multiple\
    \ clients may exist on the same network node.\n   Clientid  A 64-bit quantity\
    \ used as a unique, short-hand reference to\n             a client supplied Verifier\
    \ and ID.  The server is\n             responsible for supplying the Clientid.\n\
    \   Lease     An interval of time defined by the server for which the\n      \
    \       client is irrevocably granted a lock.  At the end of a\n             lease\
    \ period the lock may be revoked if the lease has not\n             been extended.\
    \  The lock must be revoked if a conflicting\n             lock has been granted\
    \ after the lease interval.\n             All leases granted by a server have\
    \ the same fixed\n             interval.  Note that the fixed interval was chosen\
    \ to\n             alleviate the expense a server would have in maintaining\n\
    \             state about variable length leases across server failures.\n   Lock\
    \      The term \"lock\" is used to refer to both record (byte-\n            \
    \ range) locks as well as share reservations unless\n             specifically\
    \ stated otherwise.\n   Server    The \"Server\" is the entity responsible for\
    \ coordinating\n             client access to a set of filesystems.\n   Stable\
    \ Storage\n             NFS version 4 servers must be able to recover without\
    \ data\n             loss from multiple power failures (including cascading\n\
    \             power failures, that is, several power failures in quick\n     \
    \        succession), operating system failures, and hardware\n             failure\
    \ of components other than the storage medium itself\n             (for example,\
    \ disk, nonvolatile RAM).\n             Some examples of stable storage that are\
    \ allowable for an\n             NFS server include:\n             1. Media commit\
    \ of data, that is, the modified data has\n                been successfully written\
    \ to the disk media, for\n                example, the disk platter.\n       \
    \      2. An immediate reply disk drive with battery-backed on-\n            \
    \    drive intermediate storage or uninterruptible power\n                system\
    \ (UPS).\n             3. Server commit of data with battery-backed intermediate\n\
    \                storage and recovery software.\n             4. Cache commit\
    \ with uninterruptible power system (UPS) and\n                recovery software.\n\
    \   Stateid   A 128-bit quantity returned by a server that uniquely\n        \
    \     defines the open and locking state provided by the server\n            \
    \ for a specific open or lock owner for a specific file.\n             Stateids\
    \ composed of all bits 0 or all bits 1 have special\n             meaning and\
    \ are reserved values.\n   Verifier  A 64-bit quantity generated by the client\
    \ that the server\n             can use to determine if the client has restarted\
    \ and lost\n             all previous lock state.\n"
- title: 2.  Protocol Data Types
  contents:
  - "2.  Protocol Data Types\n   The syntax and semantics to describe the data types\
    \ of the NFS\n   version 4 protocol are defined in the XDR [RFC1832] and RPC [RFC1831]\n\
    \   documents.  The next sections build upon the XDR data types to define\n  \
    \ types and structures specific to this protocol.\n"
- title: 2.1.  Basic Data Types
  contents:
  - "2.1.  Basic Data Types\n   Data Type       Definition\n   ____________________________________________________________________\n\
    \   int32_t         typedef int             int32_t;\n   uint32_t        typedef\
    \ unsigned int    uint32_t;\n   int64_t         typedef hyper           int64_t;\n\
    \   uint64_t        typedef unsigned hyper  uint64_t;\n   attrlist4       typedef\
    \ opaque        attrlist4<>;\n                   Used for file/directory attributes\n\
    \   bitmap4         typedef uint32_t        bitmap4<>;\n                   Used\
    \ in attribute array encoding.\n   changeid4       typedef       uint64_t    \
    \    changeid4;\n                   Used in definition of change_info\n   clientid4\
    \       typedef uint64_t        clientid4;\n                   Shorthand reference\
    \ to client identification\n   component4      typedef utf8str_cs      component4;\n\
    \                   Represents path name components\n   count4          typedef\
    \ uint32_t        count4;\n                   Various count parameters (READ,\
    \ WRITE, COMMIT)\n   length4         typedef uint64_t        length4;\n      \
    \             Describes LOCK lengths\n   linktext4       typedef utf8str_cs  \
    \    linktext4;\n                   Symbolic link contents\n   mode4         \
    \  typedef uint32_t        mode4;\n                   Mode attribute data type\n\
    \   nfs_cookie4     typedef uint64_t        nfs_cookie4;\n                   Opaque\
    \ cookie value for READDIR\n   nfs_fh4         typedef opaque          nfs_fh4<NFS4_FHSIZE>;\n\
    \                   Filehandle definition; NFS4_FHSIZE is defined as 128\n   nfs_ftype4\
    \      enum nfs_ftype4;\n                   Various defined file types\n   nfsstat4\
    \        enum nfsstat4;\n                   Return value for operations\n   offset4\
    \         typedef uint64_t        offset4;\n                   Various offset\
    \ designations (READ, WRITE,\n                   LOCK, COMMIT)\n   pathname4 \
    \      typedef component4      pathname4<>;\n                   Represents path\
    \ name for LOOKUP, OPEN and others\n   qop4            typedef uint32_t      \
    \  qop4;\n                   Quality of protection designation in SECINFO\n  \
    \ sec_oid4        typedef opaque          sec_oid4<>;\n                   Security\
    \ Object Identifier\n                   The sec_oid4 data type is not really opaque.\n\
    \                   Instead contains an ASN.1 OBJECT IDENTIFIER as used\n    \
    \               by GSS-API in the mech_type argument to\n                   GSS_Init_sec_context.\
    \  See [RFC2743] for details.\n   seqid4          typedef uint32_t        seqid4;\n\
    \                   Sequence identifier used for file locking\n   utf8string \
    \     typedef opaque          utf8string<>;\n                   UTF-8 encoding\
    \ for strings\n   utf8str_cis     typedef opaque          utf8str_cis;\n     \
    \              Case-insensitive UTF-8 string\n   utf8str_cs      typedef opaque\
    \          utf8str_cs;\n                   Case-sensitive UTF-8 string\n   utf8str_mixed\
    \   typedef opaque          utf8str_mixed;\n                   UTF-8 strings with\
    \ a case sensitive prefix and\n                   a case insensitive suffix.\n\
    \   verifier4       typedef opaque        verifier4[NFS4_VERIFIER_SIZE];\n   \
    \                Verifier used for various operations (COMMIT,\n             \
    \      CREATE, OPEN, READDIR, SETCLIENTID,\n                   SETCLIENTID_CONFIRM,\
    \ WRITE) NFS4_VERIFIER_SIZE is\n                   defined as 8.\n"
- title: 2.2.  Structured Data Types
  contents:
  - "2.2.  Structured Data Types\n   nfstime4\n                  struct nfstime4 {\n\
    \                          int64_t seconds;\n                          uint32_t\
    \ nseconds;\n                  }\n   The nfstime4 structure gives the number of\
    \ seconds and nanoseconds\n   since midnight or 0 hour January 1, 1970 Coordinated\
    \ Universal Time\n   (UTC).  Values greater than zero for the seconds field denote\
    \ dates\n   after the 0 hour January 1, 1970.  Values less than zero for the\n\
    \   seconds field denote dates before the 0 hour January 1, 1970.  In\n   both\
    \ cases, the nseconds field is to be added to the seconds field\n   for the final\
    \ time representation.  For example, if the time to be\n   represented is one-half\
    \ second before 0 hour January 1, 1970, the\n   seconds field would have a value\
    \ of negative one (-1) and the\n   nseconds fields would have a value of one-half\
    \ second (500000000).\n   Values greater than 999,999,999 for nseconds are considered\
    \ invalid.\n   This data type is used to pass time and date information.  A server\n\
    \   converts to and from its local representation of time when processing\n  \
    \ time values, preserving as much accuracy as possible.  If the\n   precision\
    \ of timestamps stored for a filesystem object is less than\n   defined, loss\
    \ of precision can occur.  An adjunct time maintenance\n   protocol is recommended\
    \ to reduce client and server time skew.\n   time_how4\n                  enum\
    \ time_how4 {\n                          SET_TO_SERVER_TIME4 = 0,\n          \
    \                SET_TO_CLIENT_TIME4 = 1\n                  };\n   settime4\n\
    \                  union settime4 switch (time_how4 set_it) {\n              \
    \     case SET_TO_CLIENT_TIME4:\n                           nfstime4       time;\n\
    \                   default:\n                           void;\n             \
    \     };\n   The above definitions are used as the attribute definitions to set\n\
    \   time values.  If set_it is SET_TO_SERVER_TIME4, then the server uses\n   its\
    \ local representation of time for the time value.\n   specdata4\n           \
    \       struct specdata4 {\n                          uint32_t specdata1; /* major\
    \ device number */\n                          uint32_t specdata2; /* minor device\
    \ number */\n                  };\n   This data type represents additional information\
    \ for the device file\n   types NF4CHR and NF4BLK.\n   fsid4\n               \
    \   struct fsid4 {\n                    uint64_t        major;\n             \
    \       uint64_t        minor;\n                  };\n   This type is the filesystem\
    \ identifier that is used as a mandatory\n   attribute.\n   fs_location4\n   \
    \               struct fs_location4 {\n                          utf8str_cis \
    \   server<>;\n                          pathname4     rootpath;\n           \
    \       };\n   fs_locations4\n                  struct fs_locations4 {\n     \
    \                     pathname4     fs_root;\n                          fs_location4\
    \  locations<>;\n                  };\n   The fs_location4 and fs_locations4 data\
    \ types are used for the\n   fs_locations recommended attribute which is used\
    \ for migration and\n   replication support.\n   fattr4\n                  struct\
    \ fattr4 {\n                          bitmap4       attrmask;\n              \
    \            attrlist4     attr_vals;\n                  };\n   The fattr4 structure\
    \ is used to represent file and directory\n   attributes.\n   The bitmap is a\
    \ counted array of 32 bit integers used to contain bit\n   values.  The position\
    \ of the integer in the array that contains bit n\n   can be computed from the\
    \ expression (n / 32) and its bit within that\n   integer is (n mod 32).\n   \
    \                        0            1\n         +-----------+-----------+-----------+--\n\
    \         |  count    | 31  ..  0 | 63  .. 32 |\n         +-----------+-----------+-----------+--\n\
    \   change_info4\n                  struct change_info4 {\n                  \
    \        bool          atomic;\n                          changeid4     before;\n\
    \                          changeid4     after;\n                  };\n   This\
    \ structure is used with the CREATE, LINK, REMOVE, RENAME\n   operations to let\
    \ the client know the value of the change attribute\n   for the directory in which\
    \ the target filesystem object resides.\n   clientaddr4\n                  struct\
    \ clientaddr4 {\n                          /* see struct rpcb in RFC 1833 */\n\
    \                          string r_netid<>;    /* network id */\n           \
    \               string r_addr<>;     /* universal address */\n               \
    \   };\n   The clientaddr4 structure is used as part of the SETCLIENTID\n   operation\
    \ to either specify the address of the client that is using a\n   clientid or\
    \ as part of the callback registration.  The\n   r_netid and r_addr fields are\
    \ specified in [RFC1833], but they are\n   underspecified in [RFC1833] as far\
    \ as what they should look like for\n   specific protocols.\n   For TCP over IPv4\
    \ and for UDP over IPv4, the format of r_addr is the\n   US-ASCII string:\n  \
    \    h1.h2.h3.h4.p1.p2\n   The prefix, \"h1.h2.h3.h4\", is the standard textual\
    \ form for\n   representing an IPv4 address, which is always four octets long.\n\
    \   Assuming big-endian ordering, h1, h2, h3, and h4, are respectively,\n   the\
    \ first through fourth octets each converted to ASCII-decimal.\n   Assuming big-endian\
    \ ordering, p1 and p2 are, respectively, the first\n   and second octets each\
    \ converted to ASCII-decimal.  For example, if a\n   host, in big-endian order,\
    \ has an address of 0x0A010307 and there is\n   a service listening on, in big\
    \ endian order, port 0x020F (decimal\n   527), then the complete universal address\
    \ is \"10.1.3.7.2.15\".\n   For TCP over IPv4 the value of r_netid is the string\
    \ \"tcp\".  For UDP\n   over IPv4 the value of r_netid is the string \"udp\".\n\
    \   For TCP over IPv6 and for UDP over IPv6, the format of r_addr is the\n   US-ASCII\
    \ string:\n         x1:x2:x3:x4:x5:x6:x7:x8.p1.p2\n   The suffix \"p1.p2\" is\
    \ the service port, and is computed the same way\n   as with universal addresses\
    \ for TCP and UDP over IPv4.  The prefix,\n   \"x1:x2:x3:x4:x5:x6:x7:x8\", is\
    \ the standard textual form for\n   representing an IPv6 address as defined in\
    \ Section 2.2 of [RFC2373].\n   Additionally, the two alternative forms specified\
    \ in Section 2.2 of\n   [RFC2373] are also acceptable.\n   For TCP over IPv6 the\
    \ value of r_netid is the string \"tcp6\".  For UDP\n   over IPv6 the value of\
    \ r_netid is the string \"udp6\".\n   cb_client4\n                  struct cb_client4\
    \ {\n                          unsigned int  cb_program;\n                   \
    \       clientaddr4   cb_location;\n                  };\n   This structure is\
    \ used by the client to inform the server of its call\n   back address; includes\
    \ the program number and client address.\n   nfs_client_id4\n                \
    \  struct nfs_client_id4 {\n                          verifier4     verifier;\n\
    \                          opaque        id<NFS4_OPAQUE_LIMIT>;\n            \
    \      };\n   This structure is part of the arguments to the SETCLIENTID operation.\n\
    \   NFS4_OPAQUE_LIMIT is defined as 1024.\n   open_owner4\n                  struct\
    \ open_owner4 {\n                          clientid4     clientid;\n         \
    \                 opaque        owner<NFS4_OPAQUE_LIMIT>;\n                  };\n\
    \   This structure is used to identify the owner of open state.\n   NFS4_OPAQUE_LIMIT\
    \ is defined as 1024.\n   lock_owner4\n                  struct lock_owner4 {\n\
    \                          clientid4     clientid;\n                         \
    \ opaque        owner<NFS4_OPAQUE_LIMIT>;\n                  };\n   This structure\
    \ is used to identify the owner of file locking state.\n   NFS4_OPAQUE_LIMIT is\
    \ defined as 1024.\n   open_to_lock_owner4\n                  struct open_to_lock_owner4\
    \ {\n                          seqid4          open_seqid;\n                 \
    \         stateid4        open_stateid;\n                          seqid4    \
    \      lock_seqid;\n                          lock_owner4     lock_owner;\n  \
    \                };\n   This structure is used for the first LOCK operation done\
    \ for an\n   open_owner4.  It provides both the open_stateid and lock_owner such\n\
    \   that the transition is made from a valid open_stateid sequence to\n   that\
    \ of the new lock_stateid sequence.  Using this mechanism avoids\n   the confirmation\
    \ of the lock_owner/lock_seqid pair since it is tied\n   to established state\
    \ in the form of the open_stateid/open_seqid.\n   stateid4\n                 \
    \ struct stateid4 {\n                    uint32_t        seqid;\n            \
    \        opaque          other[12];\n                  };\n   This structure is\
    \ used for the various state sharing mechanisms\n   between the client and server.\
    \  For the client, this data structure\n   is read-only.  The starting value of\
    \ the seqid field is undefined.\n   The server is required to increment the seqid\
    \ field monotonically at\n   each transition of the stateid.  This is important\
    \ since the client\n   will inspect the seqid in OPEN stateids to determine the\
    \ order of\n   OPEN processing done by the server.\n"
- title: 3.  RPC and Security Flavor
  contents:
  - "3.  RPC and Security Flavor\n   The NFS version 4 protocol is a Remote Procedure\
    \ Call (RPC)\n   application that uses RPC version 2 and the corresponding eXternal\n\
    \   Data Representation (XDR) as defined in [RFC1831] and [RFC1832].  The\n  \
    \ RPCSEC_GSS security flavor as defined in [RFC2203] MUST be used as\n   the mechanism\
    \ to deliver stronger security for the NFS version 4\n   protocol.\n"
- title: 3.1.  Ports and Transports
  contents:
  - "3.1.  Ports and Transports\n   Historically, NFS version 2 and version 3 servers\
    \ have resided on\n   port 2049.  The registered port 2049 [RFC3232] for the NFS\
    \ protocol\n   should be the default configuration.  Using the registered port\
    \ for\n   NFS services means the NFS client will not need to use the RPC\n   binding\
    \ protocols as described in [RFC1833]; this will allow NFS to\n   transit firewalls.\n\
    \   Where an NFS version 4 implementation supports operation over the IP\n   network\
    \ protocol, the supported transports between NFS and IP MUST be\n   among the\
    \ IETF-approved congestion control transport protocols, which\n   include TCP\
    \ and SCTP.  To enhance the possibilities for\n   interoperability, an NFS version\
    \ 4 implementation MUST support\n   operation over the TCP transport protocol,\
    \ at least until such time\n   as a standards track RFC revises this requirement\
    \ to use a different\n   IETF-approved congestion control transport protocol.\n\
    \   If TCP is used as the transport, the client and server SHOULD use\n   persistent\
    \ connections.  This will prevent the weakening of TCP's\n   congestion control\
    \ via short lived connections and will improve\n   performance for the WAN environment\
    \ by eliminating the need for SYN\n   handshakes.\n   As noted in the Security\
    \ Considerations section, the authentication\n   model for NFS version 4 has moved\
    \ from machine-based to principal-\n   based.  However, this modification of the\
    \ authentication model does\n   not imply a technical requirement to move the\
    \ TCP connection\n   management model from whole machine-based to one based on\
    \ a per user\n   model.  In particular, NFS over TCP client implementations have\n\
    \   traditionally multiplexed traffic for multiple users over a common\n   TCP\
    \ connection between an NFS client and server.  This has been true,\n   regardless\
    \ whether the NFS client is using AUTH_SYS, AUTH_DH,\n   RPCSEC_GSS or any other\
    \ flavor.  Similarly, NFS over TCP server\n   implementations have assumed such\
    \ a model and thus scale the\n   implementation of TCP connection management in\
    \ proportion to the\n   number of expected client machines.  It is intended that\
    \ NFS version\n   4 will not modify this connection management model.  NFS version\
    \ 4\n   clients that violate this assumption can expect scaling issues on the\n\
    \   server and hence reduced service.\n   Note that for various timers, the client\
    \ and server should avoid\n   inadvertent synchronization of those timers.  For\
    \ further discussion\n   of the general issue refer to [Floyd].\n"
- title: 3.1.1.  Client Retransmission Behavior
  contents:
  - "3.1.1.  Client Retransmission Behavior\n   When processing a request received\
    \ over a reliable transport such as\n   TCP, the NFS version 4 server MUST NOT\
    \ silently drop the request,\n   except if the transport connection has been broken.\
    \  Given such a\n   contract between NFS version 4 clients and servers, clients\
    \ MUST NOT\n   retry a request unless one or both of the following are true:\n\
    \   o  The transport connection has been broken\n   o  The procedure being retried\
    \ is the NULL procedure\n   Since reliable transports, such as TCP, do not always\
    \ synchronously\n   inform a peer when the other peer has broken the connection\
    \ (for\n   example, when an NFS server reboots), the NFS version 4 client may\n\
    \   want to actively \"probe\" the connection to see if has been broken.\n   Use\
    \ of the NULL procedure is one recommended way to do so.  So, when\n   a client\
    \ experiences a remote procedure call timeout (of some\n   arbitrary implementation\
    \ specific amount), rather than retrying the\n   remote procedure call, it could\
    \ instead issue a NULL procedure call\n   to the server.  If the server has died,\
    \ the transport connection\n   break will eventually be indicated to the NFS version\
    \ 4 client.  The\n   client can then reconnect, and then retry the original request.\
    \  If\n   the NULL procedure call gets a response, the connection has not\n  \
    \ broken.  The client can decide to wait longer for the original\n   request's\
    \ response, or it can break the transport connection and\n   reconnect before\
    \ re-sending the original request.\n   For callbacks from the server to the client,\
    \ the same rules apply,\n   but the server doing the callback becomes the client,\
    \ and the client\n   receiving the callback becomes the server.\n"
- title: 3.2.  Security Flavors
  contents:
  - "3.2.  Security Flavors\n   Traditional RPC implementations have included AUTH_NONE,\
    \ AUTH_SYS,\n   AUTH_DH, and AUTH_KRB4 as security flavors.  With [RFC2203] an\n\
    \   additional security flavor of RPCSEC_GSS has been introduced which\n   uses\
    \ the functionality of GSS-API [RFC2743].  This allows for the use\n   of various\
    \ security mechanisms by the RPC layer without the\n   additional implementation\
    \ overhead of adding RPC security flavors.\n   For NFS version 4, the RPCSEC_GSS\
    \ security flavor MUST be used to\n   enable the mandatory security mechanism.\
    \  Other flavors, such as,\n   AUTH_NONE, AUTH_SYS, and AUTH_DH MAY be implemented\
    \ as well.\n"
- title: 3.2.1.  Security mechanisms for NFS version 4
  contents:
  - "3.2.1.  Security mechanisms for NFS version 4\n   The use of RPCSEC_GSS requires\
    \ selection of: mechanism, quality of\n   protection, and service (authentication,\
    \ integrity, privacy).  The\n   remainder of this document will refer to these\
    \ three parameters of\n   the RPCSEC_GSS security as the security triple.\n"
- title: 3.2.1.1.  Kerberos V5 as a security triple
  contents:
  - "3.2.1.1.  Kerberos V5 as a security triple\n   The Kerberos V5 GSS-API mechanism\
    \ as described in [RFC1964] MUST be\n   implemented and provide the following\
    \ security triples.\n   column descriptions:\n   1 == number of pseudo flavor\n\
    \   2 == name of pseudo flavor\n   3 == mechanism's OID\n   4 == mechanism's algorithm(s)\n\
    \   5 == RPCSEC_GSS service\n   1      2     3                    4          \
    \   5\n   --------------------------------------------------------------------\n\
    \   390003 krb5  1.2.840.113554.1.2.2 DES MAC MD5   rpc_gss_svc_none\n   390004\
    \ krb5i 1.2.840.113554.1.2.2 DES MAC MD5   rpc_gss_svc_integrity\n   390005 krb5p\
    \ 1.2.840.113554.1.2.2 DES MAC MD5   rpc_gss_svc_privacy\n                   \
    \                  for integrity,\n                                     and 56\
    \ bit DES\n                                     for privacy.\n   Note that the\
    \ pseudo flavor is presented here as a mapping aid to the\n   implementor.  Because\
    \ this NFS protocol includes a method to\n   negotiate security and it understands\
    \ the GSS-API mechanism, the\n   pseudo flavor is not needed.  The pseudo flavor\
    \ is needed for NFS\n   version 3 since the security negotiation is done via the\
    \ MOUNT\n   protocol.\n   For a discussion of NFS' use of RPCSEC_GSS and Kerberos\
    \ V5, please\n   see [RFC2623].\n   Users and implementors are warned that 56\
    \ bit DES is no longer\n   considered state of the art in terms of resistance\
    \ to brute force\n   attacks.  Once a revision to [RFC1964] is available that\
    \ adds support\n   for AES, implementors are urged to incorporate AES into their\
    \ NFSv4\n   over Kerberos V5 protocol stacks, and users are similarly urged to\n\
    \   migrate to the use of AES.\n"
- title: 3.2.1.2.  LIPKEY as a security triple
  contents:
  - "3.2.1.2.  LIPKEY as a security triple\n   The LIPKEY GSS-API mechanism as described\
    \ in [RFC2847] MUST be\n   implemented and provide the following security triples.\
    \  The\n   definition of the columns matches the previous subsection \"Kerberos\n\
    \   V5 as security triple\"\n   1      2        3                   4        \
    \      5\n   --------------------------------------------------------------------\n\
    \   390006 lipkey   1.3.6.1.5.5.9       negotiated  rpc_gss_svc_none\n   390007\
    \ lipkey-i 1.3.6.1.5.5.9       negotiated  rpc_gss_svc_integrity\n   390008 lipkey-p\
    \ 1.3.6.1.5.5.9       negotiated  rpc_gss_svc_privacy\n   The mechanism algorithm\
    \ is listed as \"negotiated\".  This is because\n   LIPKEY is layered on SPKM-3\
    \ and in SPKM-3 [RFC2847] the\n   confidentiality and integrity algorithms are\
    \ negotiated.  Since\n   SPKM-3 specifies HMAC-MD5 for integrity as MANDATORY,\
    \ 128 bit\n   cast5CBC for confidentiality for privacy as MANDATORY, and further\n\
    \   specifies that HMAC-MD5 and cast5CBC MUST be listed first before\n   weaker\
    \ algorithms, specifying \"negotiated\" in column 4 does not\n   impair interoperability.\
    \  In the event an SPKM-3 peer does not\n   support the mandatory algorithms,\
    \ the other peer is free to accept or\n   reject the GSS-API context creation.\n\
    \   Because SPKM-3 negotiates the algorithms, subsequent calls to\n   LIPKEY's\
    \ GSS_Wrap() and GSS_GetMIC() by RPCSEC_GSS will use a quality\n   of protection\
    \ value of 0 (zero).  See section 5.2 of [RFC2025] for an\n   explanation.\n \
    \  LIPKEY uses SPKM-3 to create a secure channel in which to pass a user\n   name\
    \ and password from the client to the server.  Once the user name\n   and password\
    \ have been accepted by the server, calls to the LIPKEY\n   context are redirected\
    \ to the SPKM-3 context.  See [RFC2847] for more\n   details.\n"
- title: 3.2.1.3.  SPKM-3 as a security triple
  contents:
  - "3.2.1.3.  SPKM-3 as a security triple\n   The SPKM-3 GSS-API mechanism as described\
    \ in [RFC2847] MUST be\n   implemented and provide the following security triples.\
    \  The\n   definition of the columns matches the previous subsection \"Kerberos\n\
    \   V5 as security triple\".\n   1      2        3                   4       \
    \       5\n   --------------------------------------------------------------------\n\
    \   390009 spkm3    1.3.6.1.5.5.1.3     negotiated  rpc_gss_svc_none\n   390010\
    \ spkm3i   1.3.6.1.5.5.1.3     negotiated  rpc_gss_svc_integrity\n   390011 spkm3p\
    \   1.3.6.1.5.5.1.3     negotiated  rpc_gss_svc_privacy\n   For a discussion as\
    \ to why the mechanism algorithm is listed as\n   \"negotiated\", see the previous\
    \ section \"LIPKEY as a security triple.\"\n   Because SPKM-3 negotiates the algorithms,\
    \ subsequent calls to SPKM-\n   3's GSS_Wrap() and GSS_GetMIC() by RPCSEC_GSS\
    \ will use a quality of\n   protection value of 0 (zero).  See section 5.2 of\
    \ [RFC2025] for an\n   explanation.\n   Even though LIPKEY is layered over SPKM-3,\
    \ SPKM-3 is specified as a\n   mandatory set of triples to handle the situations\
    \ where the initiator\n   (the client) is anonymous or where the initiator has\
    \ its own\n   certificate.  If the initiator is anonymous, there will not be a\
    \ user\n   name and password to send to the target (the server).  If the\n   initiator\
    \ has its own certificate, then using passwords is\n   superfluous.\n"
- title: 3.3.  Security Negotiation
  contents:
  - "3.3.  Security Negotiation\n   With the NFS version 4 server potentially offering\
    \ multiple security\n   mechanisms, the client needs a method to determine or\
    \ negotiate which\n   mechanism is to be used for its communication with the server.\
    \  The\n   NFS server may have multiple points within its filesystem name space\n\
    \   that are available for use by NFS clients.  In turn the NFS server\n   may\
    \ be configured such that each of these entry points may have\n   different or\
    \ multiple security mechanisms in use.\n   The security negotiation between client\
    \ and server must be done with\n   a secure channel to eliminate the possibility\
    \ of a third party\n   intercepting the negotiation sequence and forcing the client\
    \ and\n   server to choose a lower level of security than required or desired.\n\
    \   See the section \"Security Considerations\" for further discussion.\n"
- title: 3.3.1.  SECINFO
  contents:
  - "3.3.1.  SECINFO\n   The new SECINFO operation will allow the client to determine,\
    \ on a\n   per filehandle basis, what security triple is to be used for server\n\
    \   access.  In general, the client will not have to use the SECINFO\n   operation\
    \ except during initial communication with the server or when\n   the client crosses\
    \ policy boundaries at the server.  It is possible\n   that the server's policies\
    \ change during the client's interaction\n   therefore forcing the client to negotiate\
    \ a new security triple.\n"
- title: 3.3.2.  Security Error
  contents:
  - "3.3.2.  Security Error\n   Based on the assumption that each NFS version 4 client\
    \ and server\n   must support a minimum set of security (i.e., LIPKEY, SPKM-3,\
    \ and\n   Kerberos-V5 all under RPCSEC_GSS), the NFS client will start its\n \
    \  communication with the server with one of the minimal security\n   triples.\
    \  During communication with the server, the client may\n   receive an NFS error\
    \ of NFS4ERR_WRONGSEC.  This error allows the\n   server to notify the client\
    \ that the security triple currently being\n   used is not appropriate for access\
    \ to the server's filesystem\n   resources.  The client is then responsible for\
    \ determining what\n   security triples are available at the server and choose\
    \ one which is\n   appropriate for the client.  See the section for the \"SECINFO\"\
    \n   operation for further discussion of how the client will respond to\n   the\
    \ NFS4ERR_WRONGSEC error and use SECINFO.\n"
- title: 3.4.  Callback RPC Authentication
  contents:
  - "3.4.  Callback RPC Authentication\n   Except as noted elsewhere in this section,\
    \ the callback RPC\n   (described later) MUST mutually authenticate the NFS server\
    \ to the\n   principal that acquired the clientid (also described later), using\n\
    \   the security flavor the original SETCLIENTID operation used.\n   For AUTH_NONE,\
    \ there are no principals, so this is a non-issue.\n   AUTH_SYS has no notions\
    \ of mutual authentication or a server\n   principal, so the callback from the\
    \ server simply uses the AUTH_SYS\n   credential that the user used when he set\
    \ up the delegation.\n   For AUTH_DH, one commonly used convention is that the\
    \ server uses the\n   credential corresponding to this AUTH_DH principal:\n  \
    \       unix.host@domain\n   where host and domain are variables corresponding\
    \ to the name of\n   server host and directory services domain in which it lives\
    \ such as a\n   Network Information System domain or a DNS domain.\n   Because\
    \ LIPKEY is layered over SPKM-3, it is permissible for the\n   server to use SPKM-3\
    \ and not LIPKEY for the callback even if the\n   client used LIPKEY for SETCLIENTID.\n\
    \   Regardless of what security mechanism under RPCSEC_GSS is being used,\n  \
    \ the NFS server, MUST identify itself in GSS-API via a\n   GSS_C_NT_HOSTBASED_SERVICE\
    \ name type.  GSS_C_NT_HOSTBASED_SERVICE\n   names are of the form:\n        \
    \ service@hostname\n   For NFS, the \"service\" element is\n         nfs\n   Implementations\
    \ of security mechanisms will convert nfs@hostname to\n   various different forms.\
    \  For Kerberos V5 and LIPKEY, the following\n   form is RECOMMENDED:\n      \
    \   nfs/hostname\n   For Kerberos V5, nfs/hostname would be a server principal\
    \ in the\n   Kerberos Key Distribution Center database.  This is the same\n  \
    \ principal the client acquired a GSS-API context for when it issued\n   the SETCLIENTID\
    \ operation, therefore, the realm name for the server\n   principal must be the\
    \ same for the callback as it was for the\n   SETCLIENTID.\n   For LIPKEY, this\
    \ would be the username passed to the target (the NFS\n   version 4 client that\
    \ receives the callback).\n   It should be noted that LIPKEY may not work for\
    \ callbacks, since the\n   LIPKEY client uses a user id/password.  If the NFS\
    \ client receiving\n   the callback can authenticate the NFS server's user name/password\n\
    \   pair, and if the user that the NFS server is authenticating to has a\n   public\
    \ key certificate, then it works.\n   In situations where the NFS client uses\
    \ LIPKEY and uses a per-host\n   principal for the SETCLIENTID operation, instead\
    \ of using LIPKEY for\n   SETCLIENTID, it is RECOMMENDED that SPKM-3 with mutual\
    \ authentication\n   be used.  This effectively means that the client will use\
    \ a\n   certificate to authenticate and identify the initiator to the target\n\
    \   on the NFS server.  Using SPKM-3 and not LIPKEY has the following\n   advantages:\n\
    \   o  When the server does a callback, it must authenticate to the\n      principal\
    \ used in the SETCLIENTID.  Even if LIPKEY is used,\n      because LIPKEY is layered\
    \ over SPKM-3, the NFS client will need to\n      have a certificate that corresponds\
    \ to the principal used in the\n      SETCLIENTID operation.  From an administrative\
    \ perspective, having\n      a user name, password, and certificate for both the\
    \ client and\n      server is redundant.\n   o  LIPKEY was intended to minimize\
    \ additional infrastructure\n      requirements beyond a certificate for the target,\
    \ and the\n      expectation is that existing password infrastructure can be\n\
    \      leveraged for the initiator.  In some environments, a per-host\n      password\
    \ does not exist yet.  If certificates are used for any\n      per-host principals,\
    \ then additional password infrastructure is\n      not needed.\n   o  In cases\
    \ when a host is both an NFS client and server, it can\n      share the same per-host\
    \ certificate.\n"
- title: 4.  Filehandles
  contents:
  - "4.  Filehandles\n   The filehandle in the NFS protocol is a per server unique\
    \ identifier\n   for a filesystem object.  The contents of the filehandle are\
    \ opaque\n   to the client.  Therefore, the server is responsible for translating\n\
    \   the filehandle to an internal representation of the filesystem\n   object.\n"
- title: 4.1.  Obtaining the First Filehandle
  contents:
  - "4.1.  Obtaining the First Filehandle\n   The operations of the NFS protocol are\
    \ defined in terms of one or\n   more filehandles.  Therefore, the client needs\
    \ a filehandle to\n   initiate communication with the server.  With the NFS version\
    \ 2\n   protocol [RFC1094] and the NFS version 3 protocol [RFC1813], there\n \
    \  exists an ancillary protocol to obtain this first filehandle.  The\n   MOUNT\
    \ protocol, RPC program number 100005, provides the mechanism of\n   translating\
    \ a string based filesystem path name to a filehandle which\n   can then be used\
    \ by the NFS protocols.\n   The MOUNT protocol has deficiencies in the area of\
    \ security and use\n   via firewalls.  This is one reason that the use of the\
    \ public\n   filehandle was introduced in [RFC2054] and [RFC2055].  With the use\n\
    \   of the public filehandle in combination with the LOOKUP operation in\n   the\
    \ NFS version 2 and 3 protocols, it has been demonstrated that the\n   MOUNT protocol\
    \ is unnecessary for viable interaction between NFS\n   client and server.\n \
    \  Therefore, the NFS version 4 protocol will not use an ancillary\n   protocol\
    \ for translation from string based path names to a\n   filehandle.  Two special\
    \ filehandles will be used as starting points\n   for the NFS client.\n"
- title: 4.1.1.  Root Filehandle
  contents:
  - "4.1.1.  Root Filehandle\n   The first of the special filehandles is the ROOT\
    \ filehandle.  The\n   ROOT filehandle is the \"conceptual\" root of the filesystem\
    \ name space\n   at the NFS server.  The client uses or starts with the ROOT\n\
    \   filehandle by employing the PUTROOTFH operation.  The PUTROOTFH\n   operation\
    \ instructs the server to set the \"current\" filehandle to the\n   ROOT of the\
    \ server's file tree.  Once this PUTROOTFH operation is\n   used, the client can\
    \ then traverse the entirety of the server's file\n   tree with the LOOKUP operation.\
    \  A complete discussion of the server\n   name space is in the section \"NFS\
    \ Server Name Space\".\n"
- title: 4.1.2.  Public Filehandle
  contents:
  - "4.1.2.  Public Filehandle\n   The second special filehandle is the PUBLIC filehandle.\
    \  Unlike the\n   ROOT filehandle, the PUBLIC filehandle may be bound or represent\
    \ an\n   arbitrary filesystem object at the server.  The server is responsible\n\
    \   for this binding.  It may be that the PUBLIC filehandle and the ROOT\n   filehandle\
    \ refer to the same filesystem object.  However, it is up to\n   the administrative\
    \ software at the server and the policies of the\n   server administrator to define\
    \ the binding of the PUBLIC filehandle\n   and server filesystem object.  The\
    \ client may not make any\n   assumptions about this binding.  The client uses\
    \ the PUBLIC\n   filehandle via the PUTPUBFH operation.\n"
- title: 4.2.  Filehandle Types
  contents:
  - "4.2.  Filehandle Types\n   In the NFS version 2 and 3 protocols, there was one\
    \ type of\n   filehandle with a single set of semantics.  This type of filehandle\n\
    \   is termed \"persistent\" in NFS Version 4.  The semantics of a\n   persistent\
    \ filehandle remain the same as before.  A new type of\n   filehandle introduced\
    \ in NFS Version 4 is the \"volatile\" filehandle,\n   which attempts to accommodate\
    \ certain server environments.\n   The volatile filehandle type was introduced\
    \ to address server\n   functionality or implementation issues which make correct\n\
    \   implementation of a persistent filehandle infeasible.  Some server\n   environments\
    \ do not provide a filesystem level invariant that can be\n   used to construct\
    \ a persistent filehandle.  The underlying server\n   filesystem may not provide\
    \ the invariant or the server's filesystem\n   programming interfaces may not\
    \ provide access to the needed\n   invariant.  Volatile filehandles may ease the\
    \ implementation of\n   server functionality such as hierarchical storage management\
    \ or\n   filesystem reorganization or migration.  However, the volatile\n   filehandle\
    \ increases the implementation burden for the client.\n   Since the client will\
    \ need to handle persistent and volatile\n   filehandles differently, a file attribute\
    \ is defined which may be\n   used by the client to determine the filehandle types\
    \ being returned\n   by the server.\n"
- title: 4.2.1.  General Properties of a Filehandle
  contents:
  - "4.2.1.  General Properties of a Filehandle\n   The filehandle contains all the\
    \ information the server needs to\n   distinguish an individual file.  To the\
    \ client, the filehandle is\n   opaque.  The client stores filehandles for use\
    \ in a later request and\n   can compare two filehandles from the same server\
    \ for equality by\n   doing a byte-by-byte comparison.  However, the client MUST\
    \ NOT\n   otherwise interpret the contents of filehandles.  If two filehandles\n\
    \   from the same server are equal, they MUST refer to the same file.\n   Servers\
    \ SHOULD try to maintain a one-to-one correspondence between\n   filehandles and\
    \ files but this is not required.  Clients MUST use\n   filehandle comparisons\
    \ only to improve performance, not for correct\n   behavior.  All clients need\
    \ to be prepared for situations in which it\n   cannot be determined whether two\
    \ filehandles denote the same object\n   and in such cases, avoid making invalid\
    \ assumptions which might cause\n   incorrect behavior.  Further discussion of\
    \ filehandle and attribute\n   comparison in the context of data caching is presented\
    \ in the section\n   \"Data Caching and File Identity\".\n   As an example, in\
    \ the case that two different path names when\n   traversed at the server terminate\
    \ at the same filesystem object, the\n   server SHOULD return the same filehandle\
    \ for each path.  This can\n   occur if a hard link is used to create two file\
    \ names which refer to\n   the same underlying file object and associated data.\
    \  For example, if\n   paths /a/b/c and /a/d/c refer to the same file, the server\
    \ SHOULD\n   return the same filehandle for both path names traversals.\n"
- title: 4.2.2.  Persistent Filehandle
  contents:
  - "4.2.2.  Persistent Filehandle\n   A persistent filehandle is defined as having\
    \ a fixed value for the\n   lifetime of the filesystem object to which it refers.\
    \  Once the\n   server creates the filehandle for a filesystem object, the server\n\
    \   MUST accept the same filehandle for the object for the lifetime of\n   the\
    \ object.  If the server restarts or reboots the NFS server must\n   honor the\
    \ same filehandle value as it did in the server's previous\n   instantiation.\
    \  Similarly, if the filesystem is migrated, the new NFS\n   server must honor\
    \ the same filehandle as the old NFS server.\n   The persistent filehandle will\
    \ be become stale or invalid when the\n   filesystem object is removed.  When\
    \ the server is presented with a\n   persistent filehandle that refers to a deleted\
    \ object, it MUST return\n   an error of NFS4ERR_STALE.  A filehandle may become\
    \ stale when the\n   filesystem containing the object is no longer available.\
    \  The file\n   system may become unavailable if it exists on removable media\
    \ and the\n   media is no longer available at the server or the filesystem in\
    \ whole\n   has been destroyed or the filesystem has simply been removed from\
    \ the\n   server's name space (i.e., unmounted in a UNIX environment).\n"
- title: 4.2.3.  Volatile Filehandle
  contents:
  - "4.2.3.  Volatile Filehandle\n   A volatile filehandle does not share the same\
    \ longevity\n   characteristics of a persistent filehandle.  The server may determine\n\
    \   that a volatile filehandle is no longer valid at many different\n   points\
    \ in time.  If the server can definitively determine that a\n   volatile filehandle\
    \ refers to an object that has been removed, the\n   server should return NFS4ERR_STALE\
    \ to the client (as is the case for\n   persistent filehandles).  In all other\
    \ cases where the server\n   determines that a volatile filehandle can no longer\
    \ be used, it\n   should return an error of NFS4ERR_FHEXPIRED.\n   The mandatory\
    \ attribute \"fh_expire_type\" is used by the client to\n   determine what type\
    \ of filehandle the server is providing for a\n   particular filesystem.  This\
    \ attribute is a bitmask with the\n   following values:\n   FH4_PERSISTENT\n \
    \            The value of FH4_PERSISTENT is used to indicate a\n             persistent\
    \ filehandle, which is valid until the object is\n             removed from the\
    \ filesystem.  The server will not return\n             NFS4ERR_FHEXPIRED for\
    \ this filehandle.  FH4_PERSISTENT is\n             defined as a value in which\
    \ none of the bits specified\n             below are set.\n   FH4_VOLATILE_ANY\n\
    \             The filehandle may expire at any time, except as\n             specifically\
    \ excluded (i.e., FH4_NO_EXPIRE_WITH_OPEN).\n   FH4_NOEXPIRE_WITH_OPEN\n     \
    \        May only be set when FH4_VOLATILE_ANY is set.  If this bit\n        \
    \     is set, then the meaning of FH4_VOLATILE_ANY is qualified\n            \
    \ to exclude any expiration of the filehandle when it is\n             open.\n\
    \   FH4_VOL_MIGRATION\n             The filehandle will expire as a result of\
    \ migration.  If\n             FH4_VOL_ANY is set, FH4_VOL_MIGRATION is redundant.\n\
    \   FH4_VOL_RENAME\n             The filehandle will expire during rename.  This\
    \ includes a\n             rename by the requesting client or a rename by any\
    \ other\n             client.  If FH4_VOL_ANY is set, FH4_VOL_RENAME is\n    \
    \         redundant.\n   Servers which provide volatile filehandles that may expire\
    \ while open\n   (i.e., if FH4_VOL_MIGRATION or FH4_VOL_RENAME is set or if\n\
    \   FH4_VOLATILE_ANY is set and FH4_NOEXPIRE_WITH_OPEN not set), should\n   deny\
    \ a RENAME or REMOVE that would affect an OPEN file of any of the\n   components\
    \ leading to the OPEN file.  In addition, the server should\n   deny all RENAME\
    \ or REMOVE requests during the grace period upon\n   server restart.\n   Note\
    \ that the bits FH4_VOL_MIGRATION and FH4_VOL_RENAME allow the\n   client to determine\
    \ that expiration has occurred whenever a specific\n   event occurs, without an\
    \ explicit filehandle expiration error from\n   the server.  FH4_VOL_ANY does\
    \ not provide this form of information.\n   In situations where the server will\
    \ expire many, but not all\n   filehandles upon migration (e.g., all but those\
    \ that are open),\n   FH4_VOLATILE_ANY (in this case with FH4_NOEXPIRE_WITH_OPEN)\
    \ is a\n   better choice since the client may not assume that all filehandles\n\
    \   will expire when migration occurs, and it is likely that additional\n   expirations\
    \ will occur (as a result of file CLOSE) that are separated\n   in time from the\
    \ migration event itself.\n"
- title: 4.2.4.  One Method of Constructing a Volatile Filehandle
  contents:
  - "4.2.4.  One Method of Constructing a Volatile Filehandle\n   A volatile filehandle,\
    \ while opaque to the client could contain:\n   [volatile bit = 1 | server boot\
    \ time | slot | generation number]\n   o  slot is an index in the server volatile\
    \ filehandle table\n   o  generation number is the generation number for the table\n\
    \      entry/slot\n   When the client presents a volatile filehandle, the server\
    \ makes the\n   following checks, which assume that the check for the volatile\
    \ bit\n   has passed.  If the server boot time is less than the current server\n\
    \   boot time, return NFS4ERR_FHEXPIRED.  If slot is out of range, return\n  \
    \ NFS4ERR_BADHANDLE.  If the generation number does not match, return\n   NFS4ERR_FHEXPIRED.\n\
    \   When the server reboots, the table is gone (it is volatile).\n   If volatile\
    \ bit is 0, then it is a persistent filehandle with a\n   different structure\
    \ following it.\n"
- title: 4.3.  Client Recovery from Filehandle Expiration
  contents:
  - "4.3.  Client Recovery from Filehandle Expiration\n   If possible, the client\
    \ SHOULD recover from the receipt of an\n   NFS4ERR_FHEXPIRED error.  The client\
    \ must take on additional\n   responsibility so that it may prepare itself to\
    \ recover from the\n   expiration of a volatile filehandle.  If the server returns\n\
    \   persistent filehandles, the client does not need these additional\n   steps.\n\
    \   For volatile filehandles, most commonly the client will need to store\n  \
    \ the component names leading up to and including the filesystem object\n   in\
    \ question.  With these names, the client should be able to recover\n   by finding\
    \ a filehandle in the name space that is still available or\n   by starting at\
    \ the root of the server's filesystem name space.\n   If the expired filehandle\
    \ refers to an object that has been removed\n   from the filesystem, obviously\
    \ the client will not be able to recover\n   from the expired filehandle.\n  \
    \ It is also possible that the expired filehandle refers to a file that\n   has\
    \ been renamed.  If the file was renamed by another client, again\n   it is possible\
    \ that the original client will not be able to recover.\n   However, in the case\
    \ that the client itself is renaming the file and\n   the file is open, it is\
    \ possible that the client may be able to\n   recover.  The client can determine\
    \ the new path name based on the\n   processing of the rename request.  The client\
    \ can then regenerate the\n   new filehandle based on the new path name.  The\
    \ client could also use\n   the compound operation mechanism to construct a set\
    \ of operations\n   like:\n           RENAME A B\n           LOOKUP B\n      \
    \     GETFH\n   Note that the COMPOUND procedure does not provide atomicity. \
    \ This\n   example only reduces the overhead of recovering from an expired\n \
    \  filehandle.\n"
- title: 5.  File Attributes
  contents:
  - "5.  File Attributes\n   To meet the requirements of extensibility and increased\n\
    \   interoperability with non-UNIX platforms, attributes must be handled\n   in\
    \ a flexible manner.  The NFS version 3 fattr3 structure contains a\n   fixed\
    \ list of attributes that not all clients and servers are able to\n   support\
    \ or care about.  The fattr3 structure can not be extended as\n   new needs arise\
    \ and it provides no way to indicate non-support.  With\n   the NFS version 4\
    \ protocol, the client is able query what attributes\n   the server supports and\
    \ construct requests with only those supported\n   attributes (or a subset thereof).\n\
    \   To this end, attributes are divided into three groups: mandatory,\n   recommended,\
    \ and named.  Both mandatory and recommended attributes\n   are supported in the\
    \ NFS version 4 protocol by a specific and well-\n   defined encoding and are\
    \ identified by number.  They are requested by\n   setting a bit in the bit vector\
    \ sent in the GETATTR request; the\n   server response includes a bit vector to\
    \ list what attributes were\n   returned in the response.  New mandatory or recommended\
    \ attributes\n   may be added to the NFS protocol between major revisions by\n\
    \   publishing a standards-track RFC which allocates a new attribute\n   number\
    \ value and defines the encoding for the attribute.  See the\n   section \"Minor\
    \ Versioning\" for further discussion.\n   Named attributes are accessed by the\
    \ new OPENATTR operation, which\n   accesses a hidden directory of attributes\
    \ associated with a file\n   system object.  OPENATTR takes a filehandle for the\
    \ object and\n   returns the filehandle for the attribute hierarchy.  The filehandle\n\
    \   for the named attributes is a directory object accessible by LOOKUP\n   or\
    \ READDIR and contains files whose names represent the named\n   attributes and\
    \ whose data bytes are the value of the attribute.  For\n   example:\n      LOOKUP\
    \     \"foo\"       ; look up file\n      GETATTR    attrbits\n      OPENATTR\
    \               ; access foo's named attributes\n      LOOKUP     \"x11icon\"\
    \   ; look up specific attribute\n      READ       0,4096      ; read stream of\
    \ bytes\n   Named attributes are intended for data needed by applications rather\n\
    \   than by an NFS client implementation.  NFS implementors are strongly\n   encouraged\
    \ to define their new attributes as recommended attributes\n   by bringing them\
    \ to the IETF standards-track process.\n   The set of attributes which are classified\
    \ as mandatory is\n   deliberately small since servers must do whatever it takes\
    \ to support\n   them.  A server should support as many of the recommended attributes\n\
    \   as possible but by their definition, the server is not required to\n   support\
    \ all of them.  Attributes are deemed mandatory if the data is\n   both needed\
    \ by a large number of clients and is not otherwise\n   reasonably computable\
    \ by the client when support is not provided on\n   the server.\n   Note that\
    \ the hidden directory returned by OPENATTR is a convenience\n   for protocol\
    \ processing.  The client should not make any assumptions\n   about the server's\
    \ implementation of named attributes and whether the\n   underlying filesystem\
    \ at the server has a named attribute directory\n   or not.  Therefore, operations\
    \ such as SETATTR and GETATTR on the\n   named attribute directory are undefined.\n"
- title: 5.1.  Mandatory Attributes
  contents:
  - "5.1.  Mandatory Attributes\n   These MUST be supported by every NFS version 4\
    \ client and server in\n   order to ensure a minimum level of interoperability.\
    \  The server must\n   store and return these attributes and the client must be\
    \ able to\n   function with an attribute set limited to these attributes.  With\n\
    \   just the mandatory attributes some client functionality may be\n   impaired\
    \ or limited in some ways.  A client may ask for any of these\n   attributes to\
    \ be returned by setting a bit in the GETATTR request and\n   the server must\
    \ return their value.\n"
- title: 5.2.  Recommended Attributes
  contents:
  - "5.2.  Recommended Attributes\n   These attributes are understood well enough\
    \ to warrant support in the\n   NFS version 4 protocol.  However, they may not\
    \ be supported on all\n   clients and servers.  A client may ask for any of these\
    \ attributes to\n   be returned by setting a bit in the GETATTR request but must\
    \ handle\n   the case where the server does not return them.  A client may ask\
    \ for\n   the set of attributes the server supports and should not request\n \
    \  attributes the server does not support.  A server should be tolerant\n   of\
    \ requests for unsupported attributes and simply not return them\n   rather than\
    \ considering the request an error.  It is expected that\n   servers will support\
    \ all attributes they comfortably can and only\n   fail to support attributes\
    \ which are difficult to support in their\n   operating environments.  A server\
    \ should provide attributes whenever\n   they don't have to \"tell lies\" to the\
    \ client.  For example, a file\n   modification time should be either an accurate\
    \ time or should not be\n   supported by the server.  This will not always be\
    \ comfortable to\n   clients but the client is better positioned decide whether\
    \ and how to\n   fabricate or construct an attribute or whether to do without\
    \ the\n   attribute.\n"
- title: 5.3.  Named Attributes
  contents:
  - "5.3.  Named Attributes\n   These attributes are not supported by direct encoding\
    \ in the NFS\n   Version 4 protocol but are accessed by string names rather than\n\
    \   numbers and correspond to an uninterpreted stream of bytes which are\n   stored\
    \ with the filesystem object.  The name space for these\n   attributes may be\
    \ accessed by using the OPENATTR operation.  The\n   OPENATTR operation returns\
    \ a filehandle for a virtual \"attribute\n   directory\" and further perusal of\
    \ the name space may be done using\n   READDIR and LOOKUP operations on this filehandle.\
    \  Named attributes\n   may then be examined or changed by normal READ and WRITE\
    \ and CREATE\n   operations on the filehandles returned from READDIR and LOOKUP.\n\
    \   Named attributes may have attributes.\n   It is recommended that servers support\
    \ arbitrary named attributes.  A\n   client should not depend on the ability to\
    \ store any named attributes\n   in the server's filesystem.  If a server does\
    \ support named\n   attributes, a client which is also able to handle them should\
    \ be able\n   to copy a file's data and meta-data with complete transparency from\n\
    \   one location to another; this would imply that names allowed for\n   regular\
    \ directory entries are valid for named attribute names as\n   well.\n   Names\
    \ of attributes will not be controlled by this document or other\n   IETF standards\
    \ track documents.  See the section \"IANA\n   Considerations\" for further discussion.\n"
- title: 5.4.  Classification of Attributes
  contents:
  - "5.4.  Classification of Attributes\n   Each of the Mandatory and Recommended\
    \ attributes can be classified in\n   one of three categories: per server, per\
    \ filesystem, or per\n   filesystem object.  Note that it is possible that some\
    \ per filesystem\n   attributes may vary within the filesystem.  See the \"homogeneous\"\
    \n   attribute for its definition.  Note that the attributes\n   time_access_set\
    \ and time_modify_set are not listed in this section\n   because they are write-only\
    \ attributes corresponding to time_access\n   and time_modify, and are used in\
    \ a special instance of SETATTR.\n   o  The per server attribute is:\n       \
    \  lease_time\n   o  The per filesystem attributes are:\n      supp_attr, fh_expire_type,\
    \ link_support, symlink_support,\n      unique_handles, aclsupport, cansettime,\
    \ case_insensitive,\n      case_preserving, chown_restricted, files_avail, files_free,\n\
    \      files_total, fs_locations, homogeneous, maxfilesize, maxname,\n      maxread,\
    \ maxwrite, no_trunc, space_avail, space_free, space_total,\n      time_delta\n\
    \   o  The per filesystem object attributes are:\n      type, change, size, named_attr,\
    \ fsid, rdattr_error, filehandle,\n      ACL, archive, fileid, hidden, maxlink,\
    \ mimetype, mode, numlinks,\n      owner, owner_group, rawdev, space_used, system,\
    \ time_access,\n      time_backup, time_create, time_metadata, time_modify,\n\
    \      mounted_on_fileid\n   For quota_avail_hard, quota_avail_soft, and quota_used\
    \ see their\n   definitions below for the appropriate classification.\n"
- title: 5.5.  Mandatory Attributes - Definitions
  contents:
  - "5.5.  Mandatory Attributes - Definitions\n   Name              #    DataType\
    \     Access   Description\n   ___________________________________________________________________\n\
    \   supp_attr         0    bitmap       READ     The bit vector which\n      \
    \                                          would retrieve all\n              \
    \                                  mandatory and\n                           \
    \                     recommended attributes\n                               \
    \                 that are supported for\n                                   \
    \             this object.  The\n                                            \
    \    scope of this\n                                                attribute\
    \ applies to\n                                                all objects with\
    \ a\n                                                matching fsid.\n   type \
    \             1    nfs4_ftype   READ     The type of the object\n            \
    \                                    (file, directory,\n                     \
    \                           symlink, etc.)\n   fh_expire_type    2    uint32 \
    \      READ     Server uses this to\n                                        \
    \        specify filehandle\n                                                expiration\
    \ behavior to\n                                                the client.  See\
    \ the\n                                                section \"Filehandles\"\
    \n                                                for additional\n           \
    \                                     description.\n   change            3   \
    \ uint64       READ     A value created by the\n                             \
    \                   server that the client\n                                 \
    \               can use to determine\n                                       \
    \         if file data,\n                                                directory\
    \ contents or\n                                                attributes of the\n\
    \                                                object have been\n          \
    \                                      modified.  The server\n               \
    \                                 may return the\n                           \
    \                     object's time_metadata\n                               \
    \                 attribute for this\n                                       \
    \         attribute's value but\n                                            \
    \    only if the filesystem\n                                                object\
    \ can not be\n                                                updated more\n \
    \                                               frequently than the\n        \
    \                                        resolution of\n                     \
    \                           time_metadata.\n   size              4    uint64 \
    \      R/W      The size of the object\n                                     \
    \           in bytes.\n   link_support      5    bool         READ     True, if\
    \ the object's\n                                                filesystem supports\n\
    \                                                hard links.\n   symlink_support\
    \   6    bool         READ     True, if the object's\n                       \
    \                         filesystem supports\n                              \
    \                  symbolic links.\n   named_attr        7    bool         READ\
    \     True, if this object\n                                                has\
    \ named attributes.\n                                                In other\
    \ words, object\n                                                has a non-empty\
    \ named\n                                                attribute directory.\n\
    \   fsid              8    fsid4        READ     Unique filesystem\n         \
    \                                       identifier for the\n                 \
    \                               filesystem holding\n                         \
    \                       this object.  fsid\n                                 \
    \               contains major and\n                                         \
    \       minor components each\n                                              \
    \  of which are uint64.\n   unique_handles    9    bool         READ     True,\
    \ if two distinct\n                                                filehandles\
    \ guaranteed\n                                                to refer to two\n\
    \                                                different filesystem\n      \
    \                                          objects.\n   lease_time        10 \
    \  nfs_lease4   READ     Duration of leases at\n                             \
    \                   server in seconds.\n   rdattr_error      11   enum       \
    \  READ     Error returned from\n                                            \
    \    getattr during\n                                                readdir.\n\
    \   filehandle        19   nfs_fh4      READ     The filehandle of this\n    \
    \                                            object (primarily for\n         \
    \                                       readdir requests).\n"
- title: 5.6.  Recommended Attributes - Definitions
  contents:
  - "5.6.  Recommended Attributes - Definitions\n   Name                #    Data\
    \ Type      Access   Description\n   _____________________________________________________________________\n\
    \   ACL                 12   nfsace4<>      R/W      The access control\n    \
    \                                                list for the object.\n   aclsupport\
    \          13   uint32         READ     Indicates what types\n               \
    \                                     of ACLs are\n                          \
    \                          supported on the\n                                \
    \                    current filesystem.\n   archive             14   bool   \
    \        R/W      True, if this file\n                                       \
    \             has been archived\n                                            \
    \        since the time of\n                                                 \
    \   last modification\n                                                    (deprecated\
    \ in favor\n                                                    of time_backup).\n\
    \   cansettime          15   bool           READ     True, if the server\n   \
    \                                                 is able to change\n        \
    \                                            the times for a\n               \
    \                                     filesystem object as\n                 \
    \                                   specified in a\n                         \
    \                           SETATTR operation.\n   case_insensitive    16   bool\
    \           READ     True, if filename\n                                     \
    \               comparisons on this\n                                        \
    \            filesystem are case\n                                           \
    \         insensitive.\n   case_preserving     17   bool           READ     True,\
    \ if filename\n                                                    case on this\n\
    \                                                    filesystem are\n        \
    \                                            preserved.\n   chown_restricted \
    \   18   bool           READ     If TRUE, the server\n                       \
    \                             will reject any\n                              \
    \                      request to change\n                                   \
    \                 either the owner or\n                                      \
    \              the group associated\n                                        \
    \            with a file if the\n                                            \
    \        caller is not a\n                                                   \
    \ privileged user (for\n                                                    example,\
    \ \"root\" in\n                                                    UNIX operating\n\
    \                                                    environments or in\n    \
    \                                                Windows 2000 the\n          \
    \                                          \"Take Ownership\"\n              \
    \                                      privilege).\n   fileid              20\
    \   uint64         READ     A number uniquely\n                              \
    \                      identifying the file\n                                \
    \                    within the\n                                            \
    \        filesystem.\n   files_avail         21   uint64         READ     File\
    \ slots available\n                                                    to this\
    \ user on the\n                                                    filesystem\n\
    \                                                    containing this\n       \
    \                                             object - this should\n         \
    \                                           be the smallest\n                \
    \                                    relevant limit.\n   files_free          22\
    \   uint64         READ     Free file slots on\n                             \
    \                       the filesystem\n                                     \
    \               containing this\n                                            \
    \        object - this should\n                                              \
    \      be the smallest\n                                                    relevant\
    \ limit.\n   files_total         23   uint64         READ     Total file slots\
    \ on\n                                                    the filesystem\n   \
    \                                                 containing this\n          \
    \                                          object.\n   fs_locations        24\
    \   fs_locations   READ     Locations where this\n                           \
    \                         filesystem may be\n                                \
    \                    found.  If the\n                                        \
    \            server returns\n                                                \
    \    NFS4ERR_MOVED\n                                                    as an\
    \ error, this\n                                                    attribute MUST\
    \ be\n                                                    supported.\n   hidden\
    \              25   bool           R/W      True, if the file is\n           \
    \                                         considered hidden\n                \
    \                                    with respect to the\n                   \
    \                                 Windows API.\n   homogeneous         26   bool\
    \           READ     True, if this\n                                         \
    \           object's filesystem\n                                            \
    \        is homogeneous,\n                                                   \
    \ i.e., are per\n                                                    filesystem\n\
    \                                                    attributes the same\n   \
    \                                                 for all filesystem's\n     \
    \                                               objects?\n   maxfilesize     \
    \    27   uint64         READ     Maximum supported\n                        \
    \                            file size for the\n                             \
    \                       filesystem of this\n                                 \
    \                   object.\n   maxlink             28   uint32         READ \
    \    Maximum number of\n                                                    links\
    \ for this\n                                                    object.\n   maxname\
    \             29   uint32         READ     Maximum filename\n                \
    \                                    size supported for\n                    \
    \                                this object.\n   maxread             30   uint64\
    \         READ     Maximum read size\n                                       \
    \             supported for this\n                                           \
    \         object.\n   maxwrite            31   uint64         READ     Maximum\
    \ write size\n                                                    supported for\
    \ this\n                                                    object.  This\n  \
    \                                                  attribute SHOULD be\n     \
    \                                               supported if the\n           \
    \                                         file is writable.\n                \
    \                                    Lack of this\n                          \
    \                          attribute can\n                                   \
    \                 lead to the client\n                                       \
    \             either wasting\n                                               \
    \     bandwidth or not\n                                                    receiving\
    \ the best\n                                                    performance.\n\
    \   mimetype            32   utf8<>         R/W      MIME body\n             \
    \                                       type/subtype of this\n               \
    \                                     object.\n   mode                33   mode4\
    \          R/W      UNIX-style mode and\n                                    \
    \                permission bits for\n                                       \
    \             this object.\n   no_trunc            34   bool           READ  \
    \   True, if a name\n                                                    longer\
    \ than name_max\n                                                    is used,\
    \ an error be\n                                                    returned and\
    \ name is\n                                                    not truncated.\n\
    \   numlinks            35   uint32         READ     Number of hard links\n  \
    \                                                  to this object.\n   owner \
    \              36   utf8<>         R/W      The string name of\n             \
    \                                       the owner of this\n                  \
    \                                  object.\n   owner_group         37   utf8<>\
    \         R/W      The string name of\n                                      \
    \              the group ownership\n                                         \
    \           of this object.\n   quota_avail_hard    38   uint64         READ \
    \    For definition see\n                                                    \"\
    Quota Attributes\"\n                                                    section\
    \ below.\n   quota_avail_soft    39   uint64         READ     For definition see\n\
    \                                                    \"Quota Attributes\"\n  \
    \                                                  section below.\n   quota_used\
    \          40   uint64         READ     For definition see\n                 \
    \                                   \"Quota Attributes\"\n                   \
    \                                 section below.\n   rawdev              41  \
    \ specdata4      READ     Raw device\n                                       \
    \             identifier.  UNIX\n                                            \
    \        device major/minor\n                                                \
    \    node information.\n                                                    If\
    \ the value of\n                                                    type is not\n\
    \                                                    NF4BLK or NF4CHR,\n     \
    \                                               the value return\n           \
    \                                         SHOULD NOT be\n                    \
    \                                considered useful.\n   space_avail         42\
    \   uint64         READ     Disk space in bytes\n                            \
    \                        available to this\n                                 \
    \                   user on the\n                                            \
    \        filesystem\n                                                    containing\
    \ this\n                                                    object - this should\n\
    \                                                    be the smallest\n       \
    \                                             relevant limit.\n   space_free \
    \         43   uint64         READ     Free disk space in\n                  \
    \                                  bytes on the\n                            \
    \                        filesystem\n                                        \
    \            containing this\n                                               \
    \     object - this should\n                                                 \
    \   be the smallest\n                                                    relevant\
    \ limit.\n   space_total         44   uint64         READ     Total disk space\
    \ in\n                                                    bytes on the\n     \
    \                                               filesystem\n                 \
    \                                   containing this\n                        \
    \                            object.\n   space_used          45   uint64     \
    \    READ     Number of filesystem\n                                         \
    \           bytes allocated to\n                                             \
    \       this object.\n   system              46   bool           R/W      True,\
    \ if this file\n                                                    is a \"system\"\
    \ file\n                                                    with respect to the\n\
    \                                                    Windows API.\n   time_access\
    \         47   nfstime4       READ     The time of last\n                    \
    \                                access to the object\n                      \
    \                              by a read that was\n                          \
    \                          satisfied by the\n                                \
    \                    server.\n   time_access_set     48   settime4       WRITE\
    \    Set the time of last\n                                                  \
    \  access to the\n                                                    object.\
    \  SETATTR\n                                                    use only.\n  \
    \ time_backup         49   nfstime4       R/W      The time of last\n        \
    \                                            backup of the\n                 \
    \                                   object.\n   time_create         50   nfstime4\
    \       R/W      The time of creation\n                                      \
    \              of the object.  This\n                                        \
    \            attribute does not\n                                            \
    \        have any relation to\n                                              \
    \      the traditional UNIX\n                                                \
    \    file attribute\n                                                    \"ctime\"\
    \ or \"change\n                                                    time\".\n \
    \  time_delta          51   nfstime4       READ     Smallest useful\n        \
    \                                            server time\n                   \
    \                                 granularity.\n   time_metadata       52   nfstime4\
    \       READ     The time of last\n                                          \
    \          meta-data\n                                                    modification\
    \ of the\n                                                    object.\n   time_modify\
    \         53   nfstime4       READ     The time of last\n                    \
    \                                modification to the\n                       \
    \                             object.\n   time_modify_set     54   settime4  \
    \     WRITE    Set the time of last\n                                        \
    \            modification to the\n                                           \
    \         object.  SETATTR use\n                                             \
    \       only.\n   mounted_on_fileid   55   uint64         READ     Like fileid,\
    \ but if\n                                                    the target\n   \
    \                                                 filehandle is the\n        \
    \                                            root of a filesystem\n          \
    \                                          return the fileid of\n            \
    \                                        the underlying\n                    \
    \                                directory.\n"
- title: 5.7.  Time Access
  contents:
  - "5.7.  Time Access\n   As defined above, the time_access attribute represents\
    \ the time of\n   last access to the object by a read that was satisfied by the\
    \ server.\n   The notion of what is an \"access\" depends on server's operating\n\
    \   environment and/or the server's filesystem semantics.  For example,\n   for\
    \ servers obeying POSIX semantics, time_access would be updated\n   only by the\
    \ READLINK, READ, and READDIR operations and not any of the\n   operations that\
    \ modify the content of the object.  Of course, setting\n   the corresponding\
    \ time_access_set attribute is another way to modify\n   the time_access attribute.\n\
    \   Whenever the file object resides on a writable filesystem, the server\n  \
    \ should make best efforts to record time_access into stable storage.\n   However,\
    \ to mitigate the performance effects of doing so, and most\n   especially whenever\
    \ the server is satisfying the read of the object's\n   content from its cache,\
    \ the server MAY cache access time updates and\n   lazily write them to stable\
    \ storage.  It is also acceptable to give\n   administrators of the server the\
    \ option to disable time_access\n   updates.\n"
- title: 5.8.  Interpreting owner and owner_group
  contents:
  - "5.8.  Interpreting owner and owner_group\n   The recommended attributes \"owner\"\
    \ and \"owner_group\" (and also users\n   and groups within the \"acl\" attribute)\
    \ are represented in terms of a\n   UTF-8 string.  To avoid a representation that\
    \ is tied to a particular\n   underlying implementation at the client or server,\
    \ the use of the\n   UTF-8 string has been chosen.  Note that section 6.1 of [RFC2624]\n\
    \   provides additional rationale.  It is expected that the client and\n   server\
    \ will have their own local representation of owner and\n   owner_group that is\
    \ used for local storage or presentation to the end\n   user.  Therefore, it is\
    \ expected that when these attributes are\n   transferred between the client and\
    \ server that the local\n   representation is translated to a syntax of the form\n\
    \   \"user@dns_domain\".  This will allow for a client and server that do\n  \
    \ not use the same local representation the ability to translate to a\n   common\
    \ syntax that can be interpreted by both.\n   Similarly, security principals may\
    \ be represented in different ways\n   by different security mechanisms.  Servers\
    \ normally translate these\n   representations into a common format, generally\
    \ that used by local\n   storage, to serve as a means of identifying the users\
    \ corresponding\n   to these security principals.  When these local identifiers\
    \ are\n   translated to the form of the owner attribute, associated with files\n\
    \   created by such principals they identify, in a common format, the\n   users\
    \ associated with each corresponding set of security principals.\n   The translation\
    \ used to interpret owner and group strings is not\n   specified as part of the\
    \ protocol.  This allows various solutions to\n   be employed.  For example, a\
    \ local translation table may be consulted\n   that maps between a numeric id\
    \ to the user@dns_domain syntax.  A name\n   service may also be used to accomplish\
    \ the translation.  A server may\n   provide a more general service, not limited\
    \ by any particular\n   translation (which would only translate a limited set\
    \ of possible\n   strings) by storing the owner and owner_group attributes in\
    \ local\n   storage without any translation or it may augment a translation\n\
    \   method by storing the entire string for attributes for which no\n   translation\
    \ is available while using the local representation for\n   those cases in which\
    \ a translation is available.\n   Servers that do not provide support for all\
    \ possible values of the\n   owner and owner_group attributes, should return an\
    \ error\n   (NFS4ERR_BADOWNER) when a string is presented that has no\n   translation,\
    \ as the value to be set for a SETATTR of the owner,\n   owner_group, or acl attributes.\
    \  When a server does accept an owner\n   or owner_group value as valid on a SETATTR\
    \ (and similarly for the\n   owner and group strings in an acl), it is promising\
    \ to return that\n   same string when a corresponding GETATTR is done.  Configuration\n\
    \   changes and ill-constructed name translations (those that contain\n   aliasing)\
    \ may make that promise impossible to honor.  Servers should\n   make appropriate\
    \ efforts to avoid a situation in which these\n   attributes have their values\
    \ changed when no real change to ownership\n   has occurred.\n   The \"dns_domain\"\
    \ portion of the owner string is meant to be a DNS\n   domain name.  For example,\
    \ user@ietf.org.  Servers should accept as\n   valid a set of users for at least\
    \ one domain.  A server may treat\n   other domains as having no valid translations.\
    \  A more general\n   service is provided when a server is capable of accepting\
    \ users for\n   multiple domains, or for all domains, subject to security\n  \
    \ constraints.\n   In the case where there is no translation available to the\
    \ client or\n   server, the attribute value must be constructed without the \"\
    @\".\n   Therefore, the absence of the @ from the owner or owner_group\n   attribute\
    \ signifies that no translation was available at the sender\n   and that the receiver\
    \ of the attribute should not use that string as\n   a basis for translation into\
    \ its own internal format.  Even though\n   the attribute value can not be translated,\
    \ it may still be useful.\n   In the case of a client, the attribute string may\
    \ be used for local\n   display of ownership.\n   To provide a greater degree\
    \ of compatibility with previous versions\n   of NFS (i.e., v2 and v3), which\
    \ identified users and groups by 32-bit\n   unsigned uid's and gid's, owner and\
    \ group strings that consist of\n   decimal numeric values with no leading zeros\
    \ can be given a special\n   interpretation by clients and servers which choose\
    \ to provide such\n   support.  The receiver may treat such a user or group string\
    \ as\n   representing the same user as would be represented by a v2/v3 uid or\n\
    \   gid having the corresponding numeric value.  A server is not\n   obligated\
    \ to accept such a string, but may return an NFS4ERR_BADOWNER\n   instead.  To\
    \ avoid this mechanism being used to subvert user and\n   group translation, so\
    \ that a client might pass all of the owners and\n   groups in numeric form, a\
    \ server SHOULD return an NFS4ERR_BADOWNER\n   error when there is a valid translation\
    \ for the user or owner\n   designated in this way.  In that case, the client\
    \ must use the\n   appropriate name@domain string and not the special form for\n\
    \   compatibility.\n   The owner string \"nobody\" may be used to designate an\
    \ anonymous user,\n   which will be associated with a file created by a security\
    \ principal\n   that cannot be mapped through normal means to the owner attribute.\n"
- title: 5.9.  Character Case Attributes
  contents:
  - "5.9.  Character Case Attributes\n   With respect to the case_insensitive and\
    \ case_preserving attributes,\n   each UCS-4 character (which UTF-8 encodes) has\
    \ a \"long descriptive\n   name\" [RFC1345] which may or may not included the\
    \ word \"CAPITAL\" or\n   \"SMALL\".  The presence of SMALL or CAPITAL allows\
    \ an NFS server to\n   implement unambiguous and efficient table driven mappings\
    \ for case\n   insensitive comparisons, and non-case-preserving storage.  For\n\
    \   general character handling and internationalization issues, see the\n   section\
    \ \"Internationalization\".\n"
- title: 5.10.  Quota Attributes
  contents:
  - "5.10.  Quota Attributes\n   For the attributes related to filesystem quotas,\
    \ the following\n   definitions apply:\n   quota_avail_soft\n         The value\
    \ in bytes which represents the amount of additional\n         disk space that\
    \ can be allocated to this file or directory\n         before the user may reasonably\
    \ be warned.  It is understood\n         that this space may be consumed by allocations\
    \ to other files\n         or directories though there is a rule as to which other\
    \ files\n         or directories.\n   quota_avail_hard\n         The value in\
    \ bytes which represent the amount of additional\n         disk space beyond the\
    \ current allocation that can be allocated\n         to this file or directory\
    \ before further allocations will be\n         refused.  It is understood that\
    \ this space may be consumed by\n         allocations to other files or directories.\n\
    \   quota_used\n         The value in bytes which represent the amount of disc\
    \ space\n         used by this file or directory and possibly a number of other\n\
    \         similar files or directories, where the set of \"similar\" meets\n \
    \        at least the criterion that allocating space to any file or\n       \
    \  directory in the set will reduce the \"quota_avail_hard\" of\n         every\
    \ other file or directory in the set.\n         Note that there may be a number\
    \ of distinct but overlapping\n         sets of files or directories for which\
    \ a quota_used value is\n         maintained (e.g., \"all files with a given owner\"\
    , \"all files\n         with a given group owner\", etc.).\n         The server\
    \ is at liberty to choose any of those sets but should\n         do so in a repeatable\
    \ way.  The rule may be configured per-\n         filesystem or may be \"choose\
    \ the set with the smallest quota\".\n"
- title: 5.11.  Access Control Lists
  contents:
  - "5.11.  Access Control Lists\n   The NFS version 4 ACL attribute is an array of\
    \ access control entries\n   (ACE).  Although, the client can read and write the\
    \ ACL attribute,\n   the NFSv4 model is the server does all access control based\
    \ on the\n   server's interpretation of the ACL.  If at any point the client wants\n\
    \   to check access without issuing an operation that modifies or reads\n   data\
    \ or metadata, the client can use the OPEN and ACCESS operations\n   to do so.\
    \  There are various access control entry types, as defined\n   in the Section\
    \ \"ACE type\".  The server is able to communicate which\n   ACE types are supported\
    \ by returning the appropriate value within the\n   aclsupport attribute.  Each\
    \ ACE covers one or more operations on a\n   file or directory as described in\
    \ the Section \"ACE Access Mask\".  It\n   may also contain one or more flags\
    \ that modify the semantics of the\n   ACE as defined in the Section \"ACE flag\"\
    .\n   The NFS ACE attribute is defined as follows:\n         typedef uint32_t\
    \        acetype4;\n         typedef uint32_t        aceflag4;\n         typedef\
    \ uint32_t        acemask4;\n         struct nfsace4 {\n                 acetype4\
    \        type;\n                 aceflag4        flag;\n                 acemask4\
    \        access_mask;\n                 utf8str_mixed   who;\n         };\n  \
    \ To determine if a request succeeds, each nfsace4 entry is processed\n   in order\
    \ by the server.  Only ACEs which have a \"who\" that matches\n   the requester\
    \ are considered.  Each ACE is processed until all of the\n   bits of the requester's\
    \ access have been ALLOWED.  Once a bit (see\n   below) has been ALLOWED by an\
    \ ACCESS_ALLOWED_ACE, it is no longer\n   considered in the processing of later\
    \ ACEs.  If an ACCESS_DENIED_ACE\n   is encountered where the requester's access\
    \ still has unALLOWED bits\n   in common with the \"access_mask\" of the ACE,\
    \ the request is denied.\n   However, unlike the ALLOWED and DENIED ACE types,\
    \ the ALARM and AUDIT\n   ACE types do not affect a requester's access, and instead\
    \ are for\n   triggering events as a result of a requester's access attempt.\n\
    \   Therefore, all AUDIT and ALARM ACEs are processed until end of the\n   ACL.\
    \  When the ACL is fully processed, if there are bits in\n   requester's mask\
    \ that have not been considered whether the server\n   allows or denies the access\
    \ is undefined.  If there is a mode\n   attribute on the file, then this cannot\
    \ happen, since the mode's\n   MODE4_*OTH bits will map to EVERYONE@ ACEs that\
    \ unambiguously specify\n   the requester's access.\n   The NFS version 4 ACL\
    \ model is quite rich.  Some server platforms may\n   provide access control functionality\
    \ that goes beyond the UNIX-style\n   mode attribute, but which is not as rich\
    \ as the NFS ACL model.  So\n   that users can take advantage of this more limited\
    \ functionality, the\n   server may indicate that it supports ACLs as long as\
    \ it follows the\n   guidelines for mapping between its ACL model and the NFS\
    \ version 4\n   ACL model.\n   The situation is complicated by the fact that a\
    \ server may have\n   multiple modules that enforce ACLs.  For example, the enforcement\
    \ for\n   NFS version 4 access may be different from the enforcement for local\n\
    \   access, and both may be different from the enforcement for access\n   through\
    \ other protocols such as SMB.  So it may be useful for a\n   server to accept\
    \ an ACL even if not all of its modules are able to\n   support it.\n   The guiding\
    \ principle in all cases is that the server must not accept\n   ACLs that appear\
    \ to make the file more secure than it really is.\n"
- title: 5.11.1.  ACE type
  contents:
  - "5.11.1.  ACE type\n   Type         Description\n   _____________________________________________________\n\
    \   ALLOW        Explicitly grants the access defined in\n                acemask4\
    \ to the file or directory.\n   DENY         Explicitly denies the access defined\
    \ in\n                acemask4 to the file or directory.\n   AUDIT        LOG\
    \ (system dependent) any access\n                attempt to a file or directory\
    \ which\n                uses any of the access methods specified\n          \
    \      in acemask4.\n   ALARM        Generate a system ALARM (system\n       \
    \         dependent) when any access attempt is\n                made to a file\
    \ or directory for the\n                access methods specified in acemask4.\n\
    \   A server need not support all of the above ACE types.  The bitmask\n   constants\
    \ used to represent the above definitions within the\n   aclsupport attribute\
    \ are as follows:\n      const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;\n     \
    \ const ACL4_SUPPORT_DENY_ACL     = 0x00000002;\n      const ACL4_SUPPORT_AUDIT_ACL\
    \    = 0x00000004;\n      const ACL4_SUPPORT_ALARM_ACL    = 0x00000008;\n   The\
    \ semantics of the \"type\" field follow the descriptions provided\n   above.\n\
    \   The constants used for the type field (acetype4) are as follows:\n      const\
    \ ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;\n      const ACE4_ACCESS_DENIED_ACE_TYPE\
    \       = 0x00000001;\n      const ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;\n\
    \      const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;\n   Clients should\
    \ not attempt to set an ACE unless the server claims\n   support for that ACE\
    \ type.  If the server receives a request to set\n   an ACE that it cannot store,\
    \ it MUST reject the request with\n   NFS4ERR_ATTRNOTSUPP.  If the server receives\
    \ a request to set an ACE\n   that it can store but cannot enforce, the server\
    \ SHOULD reject the\n   request with NFS4ERR_ATTRNOTSUPP.\n   Example: suppose\
    \ a server can enforce NFS ACLs for NFS access but\n   cannot enforce ACLs for\
    \ local access.  If arbitrary processes can run\n   on the server, then the server\
    \ SHOULD NOT indicate ACL support.  On\n   the other hand, if only trusted administrative\
    \ programs run locally,\n   then the server may indicate ACL support.\n"
- title: 5.11.2.  ACE Access Mask
  contents:
  - "5.11.2.  ACE Access Mask\n   The access_mask field contains values based on the\
    \ following:\n   Access                 Description\n   _______________________________________________________________\n\
    \   READ_DATA              Permission to read the data of the file\n   LIST_DIRECTORY\
    \         Permission to list the contents of a\n                          directory\n\
    \   WRITE_DATA             Permission to modify the file's data\n   ADD_FILE \
    \              Permission to add a new file to a\n                          directory\n\
    \   APPEND_DATA            Permission to append data to a file\n   ADD_SUBDIRECTORY\
    \       Permission to create a subdirectory to a\n                          directory\n\
    \   READ_NAMED_ATTRS       Permission to read the named attributes\n         \
    \                 of a file\n   WRITE_NAMED_ATTRS      Permission to write the\
    \ named attributes\n                          of a file\n   EXECUTE          \
    \      Permission to execute a file\n   DELETE_CHILD           Permission to delete\
    \ a file or directory\n                          within a directory\n   READ_ATTRIBUTES\
    \        The ability to read basic attributes\n                          (non-acls)\
    \ of a file\n   WRITE_ATTRIBUTES       Permission to change basic attributes\n\
    \                          (non-acls) of a file\n   DELETE                 Permission\
    \ to Delete the file\n   READ_ACL               Permission to Read the ACL\n \
    \  WRITE_ACL              Permission to Write the ACL\n   WRITE_OWNER        \
    \    Permission to change the owner\n   SYNCHRONIZE            Permission to access\
    \ file locally at the\n                          server with synchronous reads\
    \ and writes\n   The bitmask constants used for the access mask field are as follows:\n\
    \   const ACE4_READ_DATA            = 0x00000001;\n   const ACE4_LIST_DIRECTORY\
    \       = 0x00000001;\n   const ACE4_WRITE_DATA           = 0x00000002;\n   const\
    \ ACE4_ADD_FILE             = 0x00000002;\n   const ACE4_APPEND_DATA         \
    \ = 0x00000004;\n   const ACE4_ADD_SUBDIRECTORY     = 0x00000004;\n   const ACE4_READ_NAMED_ATTRS\
    \     = 0x00000008;\n   const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;\n   const\
    \ ACE4_EXECUTE              = 0x00000020;\n   const ACE4_DELETE_CHILD        \
    \ = 0x00000040;\n   const ACE4_READ_ATTRIBUTES      = 0x00000080;\n   const ACE4_WRITE_ATTRIBUTES\
    \     = 0x00000100;\n   const ACE4_DELETE               = 0x00010000;\n   const\
    \ ACE4_READ_ACL             = 0x00020000;\n   const ACE4_WRITE_ACL           \
    \ = 0x00040000;\n   const ACE4_WRITE_OWNER          = 0x00080000;\n   const ACE4_SYNCHRONIZE\
    \          = 0x00100000;\n   Server implementations need not provide the granularity\
    \ of control\n   that is implied by this list of masks.  For example, POSIX-based\n\
    \   systems might not distinguish APPEND_DATA (the ability to append to a\n  \
    \ file) from WRITE_DATA (the ability to modify existing contents); both\n   masks\
    \ would be tied to a single \"write\" permission.  When such a\n   server returns\
    \ attributes to the client, it would show both\n   APPEND_DATA and WRITE_DATA\
    \ if and only if the write permission is\n   enabled.\n   If a server receives\
    \ a SETATTR request that it cannot accurately\n   implement, it should error in\
    \ the direction of more restricted\n   access.  For example, suppose a server\
    \ cannot distinguish overwriting\n   data from appending new data, as described\
    \ in the previous paragraph.\n   If a client submits an ACE where APPEND_DATA\
    \ is set but WRITE_DATA is\n   not (or vice versa), the server should reject the\
    \ request with\n   NFS4ERR_ATTRNOTSUPP.  Nonetheless, if the ACE has type DENY,\
    \ the\n   server may silently turn on the other bit, so that both APPEND_DATA\n\
    \   and WRITE_DATA are denied.\n"
- title: 5.11.3.  ACE flag
  contents:
  - "5.11.3.  ACE flag\n   The \"flag\" field contains values based on the following\
    \ descriptions.\n   ACE4_FILE_INHERIT_ACE\n      Can be placed on a directory\
    \ and indicates that this ACE should be\n      added to each new non-directory\
    \ file created.\n   ACE4_DIRECTORY_INHERIT_ACE\n      Can be placed on a directory\
    \ and indicates that this ACE should be\n      added to each new directory created.\n\
    \   ACE4_INHERIT_ONLY_ACE\n      Can be placed on a directory but does not apply\
    \ to the directory,\n      only to newly created files/directories as specified\
    \ by the above\n      two flags.\n   ACE4_NO_PROPAGATE_INHERIT_ACE\n      Can\
    \ be placed on a directory.  Normally when a new directory is\n      created and\
    \ an ACE exists on the parent directory which is marked\n      ACL4_DIRECTORY_INHERIT_ACE,\
    \ two ACEs are placed on the new\n      directory.  One for the directory itself\
    \ and one which is an\n      inheritable ACE for newly created directories.  This\
    \ flag tells\n      the server to not place an ACE on the newly created directory\n\
    \      which is inheritable by subdirectories of the created directory.\n   ACE4_SUCCESSFUL_ACCESS_ACE_FLAG\n\
    \   ACL4_FAILED_ACCESS_ACE_FLAG\n      The ACE4_SUCCESSFUL_ACCESS_ACE_FLAG (SUCCESS)\
    \ and\n      ACE4_FAILED_ACCESS_ACE_FLAG (FAILED) flag bits relate only to\n \
    \     ACE4_SYSTEM_AUDIT_ACE_TYPE (AUDIT) and ACE4_SYSTEM_ALARM_ACE_TYPE\n    \
    \  (ALARM) ACE types.  If during the processing of the file's ACL,\n      the\
    \ server encounters an AUDIT or ALARM ACE that matches the\n      principal attempting\
    \ the OPEN, the server notes that fact, and the\n      presence, if any, of the\
    \ SUCCESS and FAILED flags encountered in\n      the AUDIT or ALARM ACE.  Once\
    \ the server completes the ACL\n      processing, and the share reservation processing,\
    \ and the OPEN\n      call, it then notes if the OPEN succeeded or failed.  If\
    \ the OPEN\n      succeeded, and if the SUCCESS flag was set for a matching AUDIT\
    \ or\n      ALARM, then the appropriate AUDIT or ALARM event occurs.  If the\n\
    \      OPEN failed, and if the FAILED flag was set for the matching AUDIT\n  \
    \    or ALARM, then the appropriate AUDIT or ALARM event occurs.\n      Clearly\
    \ either or both of the SUCCESS or FAILED can be set, but if\n      neither is\
    \ set, the AUDIT or ALARM ACE is not useful.\n      The previously described processing\
    \ applies to that of the ACCESS\n      operation as well.  The difference being\
    \ that \"success\" or\n      \"failure\" does not mean whether ACCESS returns\
    \ NFS4_OK or not.\n      Success means whether ACCESS returns all requested and\
    \ supported\n      bits.  Failure means whether ACCESS failed to return a bit\
    \ that\n      was requested and supported.\n   ACE4_IDENTIFIER_GROUP\n      Indicates\
    \ that the \"who\" refers to a GROUP as defined under UNIX.\n   The bitmask constants\
    \ used for the flag field are as follows:\n   const ACE4_FILE_INHERIT_ACE    \
    \         = 0x00000001;\n   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;\n\
    \   const ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;\n   const ACE4_INHERIT_ONLY_ACE\
    \             = 0x00000008;\n   const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;\n\
    \   const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;\n   const ACE4_IDENTIFIER_GROUP\
    \             = 0x00000040;\n   A server need not support any of these flags.\
    \  If the server supports\n   flags that are similar to, but not exactly the same\
    \ as, these flags,\n   the implementation may define a mapping between the protocol-defined\n\
    \   flags and the implementation-defined flags.  Again, the guiding\n   principle\
    \ is that the file not appear to be more secure than it\n   really is.\n   For\
    \ example, suppose a client tries to set an ACE with\n   ACE4_FILE_INHERIT_ACE\
    \ set but not ACE4_DIRECTORY_INHERIT_ACE.  If the\n   server does not support\
    \ any form of ACL inheritance, the server\n   should reject the request with NFS4ERR_ATTRNOTSUPP.\
    \  If the server\n   supports a single \"inherit ACE\" flag that applies to both\
    \ files and\n   directories, the server may reject the request (i.e., requiring\
    \ the\n   client to set both the file and directory inheritance flags).  The\n\
    \   server may also accept the request and silently turn on the\n   ACE4_DIRECTORY_INHERIT_ACE\
    \ flag.\n"
- title: 5.11.4.  ACE who
  contents:
  - "5.11.4.  ACE who\n   There are several special identifiers (\"who\") which need\
    \ to be\n   understood universally, rather than in the context of a particular\n\
    \   DNS domain.  Some of these identifiers cannot be understood when an\n   NFS\
    \ client accesses the server, but have meaning when a local process\n   accesses\
    \ the file.  The ability to display and modify these\n   permissions is permitted\
    \ over NFS, even if none of the access methods\n   on the server understands the\
    \ identifiers.\n   Who                    Description\n   _______________________________________________________________\n\
    \   \"OWNER\"                The owner of the file.\n   \"GROUP\"            \
    \    The group associated with the file.\n   \"EVERYONE\"             The world.\n\
    \   \"INTERACTIVE\"          Accessed from an interactive terminal.\n   \"NETWORK\"\
    \              Accessed via the network.\n   \"DIALUP\"               Accessed\
    \ as a dialup user to the server.\n   \"BATCH\"                Accessed from a\
    \ batch job.\n   \"ANONYMOUS\"            Accessed without any authentication.\n\
    \   \"AUTHENTICATED\"        Any authenticated user (opposite of\n           \
    \               ANONYMOUS)\n   \"SERVICE\"              Access from a system service.\n\
    \   To avoid conflict, these special identifiers are distinguish by an\n   appended\
    \ \"@\" and should appear in the form \"xxxx@\" (note: no domain\n   name after\
    \ the \"@\").  For example: ANONYMOUS@.\n"
- title: 5.11.5.  Mode Attribute
  contents:
  - "5.11.5.  Mode Attribute\n   The NFS version 4 mode attribute is based on the\
    \ UNIX mode bits.  The\n   following bits are defined:\n      const MODE4_SUID\
    \ = 0x800;  /* set user id on execution */\n      const MODE4_SGID = 0x400;  /*\
    \ set group id on execution */\n      const MODE4_SVTX = 0x200;  /* save text\
    \ even after use */\n      const MODE4_RUSR = 0x100;  /* read permission: owner\
    \ */\n      const MODE4_WUSR = 0x080;  /* write permission: owner */\n      const\
    \ MODE4_XUSR = 0x040;  /* execute permission: owner */\n      const MODE4_RGRP\
    \ = 0x020;  /* read permission: group */\n      const MODE4_WGRP = 0x010;  /*\
    \ write permission: group */\n      const MODE4_XGRP = 0x008;  /* execute permission:\
    \ group */\n      const MODE4_ROTH = 0x004;  /* read permission: other */\n  \
    \    const MODE4_WOTH = 0x002;  /* write permission: other */\n      const MODE4_XOTH\
    \ = 0x001;  /* execute permission: other */\n   Bits MODE4_RUSR, MODE4_WUSR, and\
    \ MODE4_XUSR apply to the principal\n   identified in the owner attribute.  Bits\
    \ MODE4_RGRP, MODE4_WGRP, and\n   MODE4_XGRP apply to the principals identified\
    \ in the owner_group\n   attribute.  Bits MODE4_ROTH, MODE4_WOTH, MODE4_XOTH apply\
    \ to any\n   principal that does not match that in the owner group, and does not\n\
    \   have a group matching that of the owner_group attribute.\n   The remaining\
    \ bits are not defined by this protocol and MUST NOT be\n   used.  The minor version\
    \ mechanism must be used to define further bit\n   usage.\n   Note that in UNIX,\
    \ if a file has the MODE4_SGID bit set and no\n   MODE4_XGRP bit set, then READ\
    \ and WRITE must use mandatory file\n   locking.\n"
- title: 5.11.6.  Mode and ACL Attribute
  contents:
  - "5.11.6.  Mode and ACL Attribute\n   The server that supports both mode and ACL\
    \ must take care to\n   synchronize the MODE4_*USR, MODE4_*GRP, and MODE4_*OTH\
    \ bits with the\n   ACEs which have respective who fields of \"OWNER@\", \"GROUP@\"\
    , and\n   \"EVERYONE@\" so that the client can see semantically equivalent access\n\
    \   permissions exist whether the client asks for owner, owner_group and\n   mode\
    \ attributes, or for just the ACL.\n   Because the mode attribute includes bits\
    \ (e.g., MODE4_SVTX) that have\n   nothing to do with ACL semantics, it is permitted\
    \ for clients to\n   specify both the ACL attribute and mode in the same SETATTR\n\
    \   operation.  However, because there is no prescribed order for\n   processing\
    \ the attributes in a SETATTR, the client must ensure that\n   ACL attribute,\
    \ if specified without mode, would produce the desired\n   mode bits, and conversely,\
    \ the mode attribute if specified without\n   ACL, would produce the desired \"\
    OWNER@\", \"GROUP@\", and \"EVERYONE@\"\n   ACEs.\n"
- title: 5.11.7.  mounted_on_fileid
  contents:
  - "5.11.7.  mounted_on_fileid\n   UNIX-based operating environments connect a filesystem\
    \ into the\n   namespace by connecting (mounting) the filesystem onto the existing\n\
    \   file object (the mount point, usually a directory) of an existing\n   filesystem.\
    \  When the mount point's parent directory is read via an\n   API like readdir(),\
    \ the return results are directory entries, each\n   with a component name and\
    \ a fileid.  The fileid of the mount point's\n   directory entry will be different\
    \ from the fileid that the stat()\n   system call returns.  The stat() system\
    \ call is returning the fileid\n   of the root of the mounted filesystem, whereas\
    \ readdir() is returning\n   the fileid stat() would have returned before any\
    \ filesystems were\n   mounted on the mount point.\n   Unlike NFS version 3, NFS\
    \ version 4 allows a client's LOOKUP request\n   to cross other filesystems. \
    \ The client detects the filesystem\n   crossing whenever the filehandle argument\
    \ of LOOKUP has an fsid\n   attribute different from that of the filehandle returned\
    \ by LOOKUP.\n   A UNIX-based client will consider this a \"mount point crossing\"\
    .\n   UNIX has a legacy scheme for allowing a process to determine its\n   current\
    \ working directory.  This relies on readdir() of a mount\n   point's parent and\
    \ stat() of the mount point returning fileids as\n   previously described.  The\
    \ mounted_on_fileid attribute corresponds to\n   the fileid that readdir() would\
    \ have returned as described\n   previously.\n   While the NFS version 4 client\
    \ could simply fabricate a fileid\n   corresponding to what mounted_on_fileid\
    \ provides (and if the server\n   does not support mounted_on_fileid, the client\
    \ has no choice), there\n   is a risk that the client will generate a fileid that\
    \ conflicts with\n   one that is already assigned to another object in the filesystem.\n\
    \   Instead, if the server can provide the mounted_on_fileid, the\n   potential\
    \ for client operational problems in this area is eliminated.\n   If the server\
    \ detects that there is no mounted point at the target\n   file object, then the\
    \ value for mounted_on_fileid that it returns is\n   the same as that of the fileid\
    \ attribute.\n   The mounted_on_fileid attribute is RECOMMENDED, so the server\
    \ SHOULD\n   provide it if possible, and for a UNIX-based server, this is\n  \
    \ straightforward.  Usually, mounted_on_fileid will be requested during\n   a\
    \ READDIR operation, in which case it is trivial (at least for UNIX-\n   based\
    \ servers) to return mounted_on_fileid since it is equal to the\n   fileid of\
    \ a directory entry returned by readdir().  If\n   mounted_on_fileid is requested\
    \ in a GETATTR operation, the server\n   should obey an invariant that has it\
    \ returning a value that is equal\n   to the file object's entry in the object's\
    \ parent directory, i.e.,\n   what readdir() would have returned.  Some operating\
    \ environments\n   allow a series of two or more filesystems to be mounted onto\
    \ a single\n   mount point.  In this case, for the server to obey the aforementioned\n\
    \   invariant, it will need to find the base mount point, and not the\n   intermediate\
    \ mount points.\n"
- title: 6.  Filesystem Migration and Replication
  contents:
  - "6.  Filesystem Migration and Replication\n   With the use of the recommended\
    \ attribute \"fs_locations\", the NFS\n   version 4 server has a method of providing\
    \ filesystem migration or\n   replication services.  For the purposes of migration\
    \ and replication,\n   a filesystem will be defined as all files that share a\
    \ given fsid\n   (both major and minor values are the same).\n   The fs_locations\
    \ attribute provides a list of filesystem locations.\n   These locations are specified\
    \ by providing the server name (either\n   DNS domain or IP address) and the path\
    \ name representing the root of\n   the filesystem.  Depending on the type of\
    \ service being provided, the\n   list will provide a new location or a set of\
    \ alternate locations for\n   the filesystem.  The client will use this information\
    \ to redirect its\n   requests to the new server.\n"
- title: 6.1.  Replication
  contents:
  - "6.1.  Replication\n   It is expected that filesystem replication will be used\
    \ in the case\n   of read-only data.  Typically, the filesystem will be replicated\
    \ on\n   two or more servers.  The fs_locations attribute will provide the\n \
    \  list of these locations to the client.  On first access of the\n   filesystem,\
    \ the client should obtain the value of the fs_locations\n   attribute.  If, in\
    \ the future, the client finds the server\n   unresponsive, the client may attempt\
    \ to use another server specified\n   by fs_locations.\n   If applicable, the\
    \ client must take the appropriate steps to recover\n   valid filehandles from\
    \ the new server.  This is described in more\n   detail in the following sections.\n"
- title: 6.2.  Migration
  contents:
  - "6.2.  Migration\n   Filesystem migration is used to move a filesystem from one\
    \ server to\n   another.  Migration is typically used for a filesystem that is\n\
    \   writable and has a single copy.  The expected use of migration is for\n  \
    \ load balancing or general resource reallocation.  The protocol does\n   not\
    \ specify how the filesystem will be moved between servers.  This\n   server-to-server\
    \ transfer mechanism is left to the server\n   implementor.  However, the method\
    \ used to communicate the migration\n   event between client and server is specified\
    \ here.\n   Once the servers participating in the migration have completed the\n\
    \   move of the filesystem, the error NFS4ERR_MOVED will be returned for\n   subsequent\
    \ requests received by the original server.  The\n   NFS4ERR_MOVED error is returned\
    \ for all operations except PUTFH and\n   GETATTR.  Upon receiving the NFS4ERR_MOVED\
    \ error, the client will\n   obtain the value of the fs_locations attribute. \
    \ The client will then\n   use the contents of the attribute to redirect its requests\
    \ to the\n   specified server.  To facilitate the use of GETATTR, operations such\n\
    \   as PUTFH must also be accepted by the server for the migrated file\n   system's\
    \ filehandles.  Note that if the server returns NFS4ERR_MOVED,\n   the server\
    \ MUST support the fs_locations attribute.\n   If the client requests more attributes\
    \ than just fs_locations, the\n   server may return fs_locations only.  This is\
    \ to be expected since\n   the server has migrated the filesystem and may not\
    \ have a method of\n   obtaining additional attribute data.\n   The server implementor\
    \ needs to be careful in developing a migration\n   solution.  The server must\
    \ consider all of the state information\n   clients may have outstanding at the\
    \ server.  This includes but is not\n   limited to locking/share state, delegation\
    \ state, and asynchronous\n   file writes which are represented by WRITE and COMMIT\
    \ verifiers.  The\n   server should strive to minimize the impact on its clients\
    \ during and\n   after the migration process.\n"
- title: 6.3.  Interpretation of the fs_locations Attribute
  contents:
  - "6.3.  Interpretation of the fs_locations Attribute\n   The fs_location attribute\
    \ is structured in the following way:\n   struct fs_location {\n           utf8str_cis\
    \     server<>;\n           pathname4       rootpath;\n   };\n   struct fs_locations\
    \ {\n           pathname4       fs_root;\n           fs_location     locations<>;\n\
    \   };\n   The fs_location struct is used to represent the location of a\n   filesystem\
    \ by providing a server name and the path to the root of the\n   filesystem. \
    \ For a multi-homed server or a set of servers that use\n   the same rootpath,\
    \ an array of server names may be provided.  An\n   entry in the server array\
    \ is an UTF8 string and represents one of a\n   traditional DNS host name, IPv4\
    \ address, or IPv6 address.  It is not\n   a requirement that all servers that\
    \ share the same rootpath be listed\n   in one fs_location struct.  The array\
    \ of server names is provided for\n   convenience.  Servers that share the same\
    \ rootpath may also be listed\n   in separate fs_location entries in the fs_locations\
    \ attribute.\n   The fs_locations struct and attribute then contains an array\
    \ of\n   locations.  Since the name space of each server may be constructed\n\
    \   differently, the \"fs_root\" field is provided.  The path represented\n  \
    \ by fs_root represents the location of the filesystem in the server's\n   name\
    \ space.  Therefore, the fs_root path is only associated with the\n   server from\
    \ which the fs_locations attribute was obtained.  The\n   fs_root path is meant\
    \ to aid the client in locating the filesystem at\n   the various servers listed.\n\
    \   As an example, there is a replicated filesystem located at two\n   servers\
    \ (servA and servB).  At servA the filesystem is located at\n   path \"/a/b/c\"\
    .  At servB the filesystem is located at path \"/x/y/z\".\n   In this example\
    \ the client accesses the filesystem first at servA\n   with a multi-component\
    \ lookup path of \"/a/b/c/d\".  Since the client\n   used a multi-component lookup\
    \ to obtain the filehandle at \"/a/b/c/d\",\n   it is unaware that the filesystem's\
    \ root is located in servA's name\n   space at \"/a/b/c\".  When the client switches\
    \ to servB, it will need\n   to determine that the directory it first referenced\
    \ at servA is now\n   represented by the path \"/x/y/z/d\" on servB.  To facilitate\
    \ this, the\n   fs_locations attribute provided by servA would have a fs_root\
    \ value\n   of \"/a/b/c\" and two entries in fs_location.  One entry in fs_location\n\
    \   will be for itself (servA) and the other will be for servB with a\n   path\
    \ of \"/x/y/z\".  With this information, the client is able to\n   substitute\
    \ \"/x/y/z\" for the \"/a/b/c\" at the beginning of its access\n   path and construct\
    \ \"/x/y/z/d\" to use for the new server.\n   See the section \"Security Considerations\"\
    \ for a discussion on the\n   recommendations for the security flavor to be used\
    \ by any GETATTR\n   operation that requests the \"fs_locations\" attribute.\n"
- title: 6.4.  Filehandle Recovery for Migration or Replication
  contents:
  - "6.4.  Filehandle Recovery for Migration or Replication\n   Filehandles for filesystems\
    \ that are replicated or migrated generally\n   have the same semantics as for\
    \ filesystems that are not replicated or\n   migrated.  For example, if a filesystem\
    \ has persistent filehandles\n   and it is migrated to another server, the filehandle\
    \ values for the\n   filesystem will be valid at the new server.\n   For volatile\
    \ filehandles, the servers involved likely do not have a\n   mechanism to transfer\
    \ filehandle format and content between\n   themselves.  Therefore, a server may\
    \ have difficulty in determining\n   if a volatile filehandle from an old server\
    \ should return an error of\n   NFS4ERR_FHEXPIRED.  Therefore, the client is informed,\
    \ with the use\n   of the fh_expire_type attribute, whether volatile filehandles\
    \ will\n   expire at the migration or replication event.  If the bit\n   FH4_VOL_MIGRATION\
    \ is set in the fh_expire_type attribute, the client\n   must treat the volatile\
    \ filehandle as if the server had returned the\n   NFS4ERR_FHEXPIRED error.  At\
    \ the migration or replication event in\n   the presence of the FH4_VOL_MIGRATION\
    \ bit, the client will not\n   present the original or old volatile filehandle\
    \ to the new server.\n   The client will start its communication with the new\
    \ server by\n   recovering its filehandles using the saved file names.\n"
- title: 7.  NFS Server Name Space
  contents:
  - '7.  NFS Server Name Space

    '
- title: 7.1.  Server Exports
  contents:
  - "7.1.  Server Exports\n   On a UNIX server the name space describes all the files\
    \ reachable by\n   pathnames under the root directory or \"/\".  On a Windows\
    \ NT server\n   the name space constitutes all the files on disks named by mapped\n\
    \   disk letters.  NFS server administrators rarely make the entire\n   server's\
    \ filesystem name space available to NFS clients.  More often\n   portions of\
    \ the name space are made available via an \"export\"\n   feature.  In previous\
    \ versions of the NFS protocol, the root\n   filehandle for each export is obtained\
    \ through the MOUNT protocol;\n   the client sends a string that identifies the\
    \ export of name space\n   and the server returns the root filehandle for it.\
    \  The MOUNT\n   protocol supports an EXPORTS procedure that will enumerate the\n\
    \   server's exports.\n"
- title: 7.2.  Browsing Exports
  contents:
  - "7.2.  Browsing Exports\n   The NFS version 4 protocol provides a root filehandle\
    \ that clients\n   can use to obtain filehandles for these exports via a multi-component\n\
    \   LOOKUP.  A common user experience is to use a graphical user\n   interface\
    \ (perhaps a file \"Open\" dialog window) to find a file via\n   progressive browsing\
    \ through a directory tree.  The client must be\n   able to move from one export\
    \ to another export via single-component,\n   progressive LOOKUP operations.\n\
    \   This style of browsing is not well supported by the NFS version 2 and\n  \
    \ 3 protocols.  The client expects all LOOKUP operations to remain\n   within\
    \ a single server filesystem.  For example, the device attribute\n   will not\
    \ change.  This prevents a client from taking name space paths\n   that span exports.\n\
    \   An automounter on the client can obtain a snapshot of the server's\n   name\
    \ space using the EXPORTS procedure of the MOUNT protocol.  If it\n   understands\
    \ the server's pathname syntax, it can create an image of\n   the server's name\
    \ space on the client.  The parts of the name space\n   that are not exported\
    \ by the server are filled in with a \"pseudo\n   filesystem\" that allows the\
    \ user to browse from one mounted\n   filesystem to another.  There is a drawback\
    \ to this representation of\n   the server's name space on the client: it is static.\
    \  If the server\n   administrator adds a new export the client will be unaware\
    \ of it.\n"
- title: 7.3.  Server Pseudo Filesystem
  contents:
  - "7.3.  Server Pseudo Filesystem\n   NFS version 4 servers avoid this name space\
    \ inconsistency by\n   presenting all the exports within the framework of a single\
    \ server\n   name space.  An NFS version 4 client uses LOOKUP and READDIR\n  \
    \ operations to browse seamlessly from one export to another.  Portions\n   of\
    \ the server name space that are not exported are bridged via a\n   \"pseudo filesystem\"\
    \ that provides a view of exported directories\n   only.  A pseudo filesystem\
    \ has a unique fsid and behaves like a\n   normal, read only filesystem.\n   Based\
    \ on the construction of the server's name space, it is possible\n   that multiple\
    \ pseudo filesystems may exist.  For example,\n   /a         pseudo filesystem\n\
    \   /a/b       real filesystem\n   /a/b/c     pseudo filesystem\n   /a/b/c/d \
    \  real filesystem\n   Each of the pseudo filesystems are considered separate\
    \ entities and\n   therefore will have a unique fsid.\n"
- title: 7.4.  Multiple Roots
  contents:
  - "7.4.  Multiple Roots\n   The DOS and Windows operating environments are sometimes\
    \ described as\n   having \"multiple roots\".  Filesystems are commonly represented\
    \ as\n   disk letters.  MacOS represents filesystems as top level names.  NFS\n\
    \   version 4 servers for these platforms can construct a pseudo file\n   system\
    \ above these root names so that disk letters or volume names\n   are simply directory\
    \ names in the pseudo root.\n"
- title: 7.5.  Filehandle Volatility
  contents:
  - "7.5.  Filehandle Volatility\n   The nature of the server's pseudo filesystem\
    \ is that it is a logical\n   representation of filesystem(s) available from the\
    \ server.\n   Therefore, the pseudo filesystem is most likely constructed\n  \
    \ dynamically when the server is first instantiated.  It is expected\n   that\
    \ the pseudo filesystem may not have an on disk counterpart from\n   which persistent\
    \ filehandles could be constructed.  Even though it is\n   preferable that the\
    \ server provide persistent filehandles for the\n   pseudo filesystem, the NFS\
    \ client should expect that pseudo file\n   system filehandles are volatile. \
    \ This can be confirmed by checking\n   the associated \"fh_expire_type\" attribute\
    \ for those filehandles in\n   question.  If the filehandles are volatile, the\
    \ NFS client must be\n   prepared to recover a filehandle value (e.g., with a\
    \ multi-component\n   LOOKUP) when receiving an error of NFS4ERR_FHEXPIRED.\n"
- title: 7.6.  Exported Root
  contents:
  - "7.6.  Exported Root\n   If the server's root filesystem is exported, one might\
    \ conclude that\n   a pseudo-filesystem is not needed.  This would be wrong. \
    \ Assume the\n   following filesystems on a server:\n         /       disk1  (exported)\n\
    \         /a      disk2  (not exported)\n         /a/b    disk3  (exported)\n\
    \   Because disk2 is not exported, disk3 cannot be reached with simple\n   LOOKUPs.\
    \  The server must bridge the gap with a pseudo-filesystem.\n"
- title: 7.7.  Mount Point Crossing
  contents:
  - "7.7.  Mount Point Crossing\n   The server filesystem environment may be constructed\
    \ in such a way\n   that one filesystem contains a directory which is 'covered'\
    \ or\n   mounted upon by a second filesystem.  For example:\n         /a/b   \
    \         (filesystem 1)\n         /a/b/c/d        (filesystem 2)\n   The pseudo\
    \ filesystem for this server may be constructed to look\n   like:\n         /\
    \               (place holder/not exported)\n         /a/b            (filesystem\
    \ 1)\n         /a/b/c/d        (filesystem 2)\n   It is the server's responsibility\
    \ to present the pseudo filesystem\n   that is complete to the client.  If the\
    \ client sends a lookup request\n   for the path \"/a/b/c/d\", the server's response\
    \ is the filehandle of\n   the filesystem \"/a/b/c/d\".  In previous versions\
    \ of the NFS protocol,\n   the server would respond with the filehandle of directory\
    \ \"/a/b/c/d\"\n   within the filesystem \"/a/b\".\n   The NFS client will be\
    \ able to determine if it crosses a server mount\n   point by a change in the\
    \ value of the \"fsid\" attribute.\n"
- title: 7.8.  Security Policy and Name Space Presentation
  contents:
  - "7.8.  Security Policy and Name Space Presentation\n   The application of the\
    \ server's security policy needs to be carefully\n   considered by the implementor.\
    \  One may choose to limit the\n   viewability of portions of the pseudo filesystem\
    \ based on the\n   server's perception of the client's ability to authenticate\
    \ itself\n   properly.  However, with the support of multiple security mechanisms\n\
    \   and the ability to negotiate the appropriate use of these mechanisms,\n  \
    \ the server is unable to properly determine if a client will be able\n   to authenticate\
    \ itself.  If, based on its policies, the server\n   chooses to limit the contents\
    \ of the pseudo filesystem, the server\n   may effectively hide filesystems from\
    \ a client that may otherwise\n   have legitimate access.\n   As suggested practice,\
    \ the server should apply the security policy of\n   a shared resource in the\
    \ server's namespace to the components of the\n   resource's ancestors.  For example:\n\
    \         /\n         /a/b\n         /a/b/c\n   The /a/b/c directory is a real\
    \ filesystem and is the shared resource.\n   The security policy for /a/b/c is\
    \ Kerberos with integrity.  The\n   server should apply the same security policy\
    \ to /, /a, and /a/b.\n   This allows for the extension of the protection of the\
    \ server's\n   namespace to the ancestors of the real shared resource.\n   For\
    \ the case of the use of multiple, disjoint security mechanisms in\n   the server's\
    \ resources, the security for a particular object in the\n   server's namespace\
    \ should be the union of all security mechanisms of\n   all direct descendants.\n"
- title: 8.  File Locking and Share Reservations
  contents:
  - "8.  File Locking and Share Reservations\n   Integrating locking into the NFS\
    \ protocol necessarily causes it to be\n   stateful.  With the inclusion of share\
    \ reservations the protocol\n   becomes substantially more dependent on state\
    \ than the traditional\n   combination of NFS and NLM [XNFS].  There are three\
    \ components to\n   making this state manageable:\n   o  Clear division between\
    \ client and server\n   o  Ability to reliably detect inconsistency in state between\
    \ client\n      and server\n   o  Simple and robust recovery mechanisms\n   In\
    \ this model, the server owns the state information.  The client\n   communicates\
    \ its view of this state to the server as needed.  The\n   client is also able\
    \ to detect inconsistent state before modifying a\n   file.\n   To support Win32\
    \ share reservations it is necessary to atomically\n   OPEN or CREATE files. \
    \ Having a separate share/unshare operation\n   would not allow correct implementation\
    \ of the Win32 OpenFile API.  In\n   order to correctly implement share semantics,\
    \ the previous NFS\n   protocol mechanisms used when a file is opened or created\
    \ (LOOKUP,\n   CREATE, ACCESS) need to be replaced.  The NFS version 4 protocol\
    \ has\n   an OPEN operation that subsumes the NFS version 3 methodology of\n \
    \  LOOKUP, CREATE, and ACCESS.  However, because many operations require\n   a\
    \ filehandle, the traditional LOOKUP is preserved to map a file name\n   to filehandle\
    \ without establishing state on the server.  The policy\n   of granting access\
    \ or modifying files is managed by the server based\n   on the client's state.\
    \  These mechanisms can implement policy ranging\n   from advisory only locking\
    \ to full mandatory locking.\n"
- title: 8.1.  Locking
  contents:
  - "8.1.  Locking\n   It is assumed that manipulating a lock is rare when compared\
    \ to READ\n   and WRITE operations.  It is also assumed that crashes and network\n\
    \   partitions are relatively rare.  Therefore it is important that the\n   READ\
    \ and WRITE operations have a lightweight mechanism to indicate if\n   they possess\
    \ a held lock.  A lock request contains the heavyweight\n   information required\
    \ to establish a lock and uniquely define the lock\n   owner.\n   The following\
    \ sections describe the transition from the heavy weight\n   information to the\
    \ eventual stateid used for most client and server\n   locking and lease interactions.\n"
- title: 8.1.1.  Client ID
  contents:
  - "8.1.1.  Client ID\n   For each LOCK request, the client must identify itself\
    \ to the server.\n   This is done in such a way as to allow for correct lock\n\
    \   identification and crash recovery.  A sequence of a SETCLIENTID\n   operation\
    \ followed by a SETCLIENTID_CONFIRM operation is required to\n   establish the\
    \ identification onto the server.  Establishment of\n   identification by a new\
    \ incarnation of the client also has the effect\n   of immediately breaking any\
    \ leased state that a previous incarnation\n   of the client might have had on\
    \ the server, as opposed to forcing the\n   new client incarnation to wait for\
    \ the leases to expire.  Breaking\n   the lease state amounts to the server removing\
    \ all lock, share\n   reservation, and, where the server is not supporting the\n\
    \   CLAIM_DELEGATE_PREV claim type, all delegation state associated with\n   same\
    \ client with the same identity.  For discussion of delegation\n   state recovery,\
    \ see the section \"Delegation Recovery\".\n   Client identification is encapsulated\
    \ in the following structure:\n         struct nfs_client_id4 {\n            \
    \     verifier4     verifier;\n                 opaque        id<NFS4_OPAQUE_LIMIT>;\n\
    \         };\n   The first field, verifier is a client incarnation verifier that\
    \ is\n   used to detect client reboots.  Only if the verifier is different\n \
    \  from that which the server has previously recorded the client (as\n   identified\
    \ by the second field of the structure, id) does the server\n   start the process\
    \ of canceling the client's leased state.\n   The second field, id is a variable\
    \ length string that uniquely\n   defines the client.\n   There are several considerations\
    \ for how the client generates the id\n   string:\n   o  The string should be\
    \ unique so that multiple clients do not\n      present the same string.  The\
    \ consequences of two clients\n      presenting the same string range from one\
    \ client getting an error\n      to one client having its leased state abruptly\
    \ and unexpectedly\n      canceled.\n   o  The string should be selected so the\
    \ subsequent incarnations\n      (e.g., reboots) of the same client cause the\
    \ client to present the\n      same string.  The implementor is cautioned against\
    \ an approach\n      that requires the string to be recorded in a local file because\n\
    \      this precludes the use of the implementation in an environment\n      where\
    \ there is no local disk and all file access is from an NFS\n      version 4 server.\n\
    \   o  The string should be different for each server network address\n      that\
    \ the client accesses, rather than common to all server network\n      addresses.\
    \  The reason is that it may not be possible for the\n      client to tell if\
    \ the same server is listening on multiple network\n      addresses.  If the client\
    \ issues SETCLIENTID with the same id\n      string to each network address of\
    \ such a server, the server will\n      think it is the same client, and each\
    \ successive SETCLIENTID will\n      cause the server to begin the process of\
    \ removing the client's\n      previous leased state.\n   o  The algorithm for\
    \ generating the string should not assume that the\n      client's network address\
    \ won't change.  This includes changes\n      between client incarnations and\
    \ even changes while the client is\n      stilling running in its current incarnation.\
    \  This means that if\n      the client includes just the client's and server's\
    \ network address\n      in the id string, there is a real risk, after the client\
    \ gives up\n      the network address, that another client, using a similar\n\
    \      algorithm for generating the id string, will generate a\n      conflicting\
    \ id string.\n   Given the above considerations, an example of a well generated\
    \ id\n   string is one that includes:\n   o  The server's network address.\n \
    \  o  The client's network address.\n   o  For a user level NFS version 4 client,\
    \ it should contain\n      additional information to distinguish the client from\
    \ other user\n      level clients running on the same host, such as a process\
    \ id or\n      other unique sequence.\n   o  Additional information that tends\
    \ to be unique, such as one or\n      more of:\n      -  The client machine's\
    \ serial number (for privacy reasons, it is\n         best to perform some one\
    \ way function on the serial number).\n      -  A MAC address.\n      -  The timestamp\
    \ of when the NFS version 4 software was first\n         installed on the client\
    \ (though this is subject to the\n         previously mentioned caution about\
    \ using information that is\n         stored in a file, because the file might\
    \ only be accessible\n         over NFS version 4).\n      -  A true random number.\
    \  However since this number ought to be\n         the same between client incarnations,\
    \ this shares the same\n         problem as that of the using the timestamp of\
    \ the software\n         installation.\n   As a security measure, the server MUST\
    \ NOT cancel a client's leased\n   state if the principal established the state\
    \ for a given id string is\n   not the same as the principal issuing the SETCLIENTID.\n\
    \   Note that SETCLIENTID and SETCLIENTID_CONFIRM has a secondary purpose\n  \
    \ of establishing the information the server needs to make callbacks to\n   the\
    \ client for purpose of supporting delegations.  It is permitted to\n   change\
    \ this information via SETCLIENTID and SETCLIENTID_CONFIRM\n   within the same\
    \ incarnation of the client without removing the\n   client's leased state.\n\
    \   Once a SETCLIENTID and SETCLIENTID_CONFIRM sequence has successfully\n   completed,\
    \ the client uses the shorthand client identifier, of type\n   clientid4, instead\
    \ of the longer and less compact nfs_client_id4\n   structure.  This shorthand\
    \ client identifier (a clientid) is assigned\n   by the server and should be chosen\
    \ so that it will not conflict with\n   a clientid previously assigned by the\
    \ server.  This applies across\n   server restarts or reboots.  When a clientid\
    \ is presented to a server\n   and that clientid is not recognized, as would happen\
    \ after a server\n   reboot, the server will reject the request with the error\n\
    \   NFS4ERR_STALE_CLIENTID.  When this happens, the client must obtain a\n   new\
    \ clientid by use of the SETCLIENTID operation and then proceed to\n   any other\
    \ necessary recovery for the server reboot case (See the\n   section \"Server\
    \ Failure and Recovery\").\n   The client must also employ the SETCLIENTID operation\
    \ when it\n   receives a NFS4ERR_STALE_STATEID error using a stateid derived from\n\
    \   its current clientid, since this also indicates a server reboot which\n  \
    \ has invalidated the existing clientid (see the next section\n   \"lock_owner\
    \ and stateid Definition\" for details).\n   See the detailed descriptions of\
    \ SETCLIENTID and SETCLIENTID_CONFIRM\n   for a complete specification of the\
    \ operations.\n"
- title: 8.1.2.  Server Release of Clientid
  contents:
  - "8.1.2.  Server Release of Clientid\n   If the server determines that the client\
    \ holds no associated state\n   for its clientid, the server may choose to release\
    \ the clientid.  The\n   server may make this choice for an inactive client so\
    \ that resources\n   are not consumed by those intermittently active clients.\
    \  If the\n   client contacts the server after this release, the server must ensure\n\
    \   the client receives the appropriate error so that it will use the\n   SETCLIENTID/SETCLIENTID_CONFIRM\
    \ sequence to establish a new identity.\n   It should be clear that the server\
    \ must be very hesitant to release a\n   clientid since the resulting work on\
    \ the client to recover from such\n   an event will be the same burden as if the\
    \ server had failed and\n   restarted.  Typically a server would not release a\
    \ clientid unless\n   there had been no activity from that client for many minutes.\n\
    \   Note that if the id string in a SETCLIENTID request is properly\n   constructed,\
    \ and if the client takes care to use the same principal\n   for each successive\
    \ use of SETCLIENTID, then, barring an active\n   denial of service attack, NFS4ERR_CLID_INUSE\
    \ should never be\n   returned.\n   However, client bugs, server bugs, or perhaps\
    \ a deliberate change of\n   the principal owner of the id string (such as the\
    \ case of a client\n   that changes security flavors, and under the new flavor,\
    \ there is no\n   mapping to the previous owner) will in rare cases result in\n\
    \   NFS4ERR_CLID_INUSE.\n   In that event, when the server gets a SETCLIENTID\
    \ for a client id\n   that currently has no state, or it has state, but the lease\
    \ has\n   expired, rather than returning NFS4ERR_CLID_INUSE, the server MUST\n\
    \   allow the SETCLIENTID, and confirm the new clientid if followed by\n   the\
    \ appropriate SETCLIENTID_CONFIRM.\n"
- title: 8.1.3.  lock_owner and stateid Definition
  contents:
  - "8.1.3.  lock_owner and stateid Definition\n   When requesting a lock, the client\
    \ must present to the server the\n   clientid and an identifier for the owner\
    \ of the requested lock.\n   These two fields are referred to as the lock_owner\
    \ and the definition\n   of those fields are:\n   o  A clientid returned by the\
    \ server as part of the client's use of\n      the SETCLIENTID operation.\n  \
    \ o  A variable length opaque array used to uniquely define the owner\n      of\
    \ a lock managed by the client.\n      This may be a thread id, process id, or\
    \ other unique value.\n   When the server grants the lock, it responds with a\
    \ unique stateid.\n   The stateid is used as a shorthand reference to the lock_owner,\
    \ since\n   the server will be maintaining the correspondence between them.\n\
    \   The server is free to form the stateid in any manner that it chooses\n   as\
    \ long as it is able to recognize invalid and out-of-date stateids.\n   This requirement\
    \ includes those stateids generated by earlier\n   instances of the server.  From\
    \ this, the client can be properly\n   notified of a server restart.  This notification\
    \ will occur when the\n   client presents a stateid to the server from a previous\n\
    \   instantiation.\n   The server must be able to distinguish the following situations\
    \ and\n   return the error as specified:\n   o  The stateid was generated by an\
    \ earlier server instance (i.e.,\n      before a server reboot).  The error NFS4ERR_STALE_STATEID\
    \ should\n      be returned.\n   o  The stateid was generated by the current server\
    \ instance but the\n      stateid no longer designates the current locking state\
    \ for the\n      lockowner-file pair in question (i.e., one or more locking\n\
    \      operations has occurred).  The error NFS4ERR_OLD_STATEID should be\n  \
    \    returned.\n      This error condition will only occur when the client issues\
    \ a\n      locking request which changes a stateid while an I/O request that\n\
    \      uses that stateid is outstanding.\n   o  The stateid was generated by the\
    \ current server instance but the\n      stateid does not designate a locking\
    \ state for any active\n      lockowner-file pair.  The error NFS4ERR_BAD_STATEID\
    \ should be\n      returned.\n      This error condition will occur when there\
    \ has been a logic error\n      on the part of the client or server.  This should\
    \ not happen.\n   One mechanism that may be used to satisfy these requirements\
    \ is for\n   the server to,\n   o  divide the \"other\" field of each stateid\
    \ into two fields:\n      -  A server verifier which uniquely designates a particular\
    \ server\n         instantiation.\n      -  An index into a table of locking-state\
    \ structures.\n   o  utilize the \"seqid\" field of each stateid, such that seqid\
    \ is\n      monotonically incremented for each stateid that is associated with\n\
    \      the same index into the locking-state table.\n   By matching the incoming\
    \ stateid and its field values with the state\n   held at the server, the server\
    \ is able to easily determine if a\n   stateid is valid for its current instantiation\
    \ and state.  If the\n   stateid is not valid, the appropriate error can be supplied\
    \ to the\n   client.\n"
- title: 8.1.4.  Use of the stateid and Locking
  contents:
  - "8.1.4.  Use of the stateid and Locking\n   All READ, WRITE and SETATTR operations\
    \ contain a stateid.  For the\n   purposes of this section, SETATTR operations\
    \ which change the size\n   attribute of a file are treated as if they are writing\
    \ the area\n   between the old and new size (i.e., the range truncated or added\
    \ to\n   the file by means of the SETATTR), even where SETATTR is not\n   explicitly\
    \ mentioned in the text.\n   If the lock_owner performs a READ or WRITE in a situation\
    \ in which it\n   has established a lock or share reservation on the server (any\
    \ OPEN\n   constitutes a share reservation) the stateid (previously returned by\n\
    \   the server) must be used to indicate what locks, including both\n   record\
    \ locks and share reservations, are held by the lockowner.  If\n   no state is\
    \ established by the client, either record lock or share\n   reservation, a stateid\
    \ of all bits 0 is used.  Regardless whether a\n   stateid of all bits 0, or a\
    \ stateid returned by the server is used,\n   if there is a conflicting share\
    \ reservation or mandatory record lock\n   held on the file, the server MUST refuse\
    \ to service the READ or WRITE\n   operation.\n   Share reservations are established\
    \ by OPEN operations and by their\n   nature are mandatory in that when the OPEN\
    \ denies READ or WRITE\n   operations, that denial results in such operations\
    \ being rejected\n   with error NFS4ERR_LOCKED.  Record locks may be implemented\
    \ by the\n   server as either mandatory or advisory, or the choice of mandatory\
    \ or\n   advisory behavior may be determined by the server on the basis of the\n\
    \   file being accessed (for example, some UNIX-based servers support a\n   \"\
    mandatory lock bit\" on the mode attribute such that if set, record\n   locks\
    \ are required on the file before I/O is possible).  When record\n   locks are\
    \ advisory, they only prevent the granting of conflicting\n   lock requests and\
    \ have no effect on READs or WRITEs.  Mandatory\n   record locks, however, prevent\
    \ conflicting I/O operations.  When they\n   are attempted, they are rejected\
    \ with NFS4ERR_LOCKED.  When the\n   client gets NFS4ERR_LOCKED on a file it knows\
    \ it has the proper share\n   reservation for, it will need to issue a LOCK request\
    \ on the region\n   of the file that includes the region the I/O was to be performed\
    \ on,\n   with an appropriate locktype (i.e., READ*_LT for a READ operation,\n\
    \   WRITE*_LT for a WRITE operation).\n   With NFS version 3, there was no notion\
    \ of a stateid so there was no\n   way to tell if the application process of the\
    \ client sending the READ\n   or WRITE operation had also acquired the appropriate\
    \ record lock on\n   the file.  Thus there was no way to implement mandatory locking.\n\
    \   With the stateid construct, this barrier has been removed.\n   Note that for\
    \ UNIX environments that support mandatory file locking,\n   the distinction between\
    \ advisory and mandatory locking is subtle.  In\n   fact, advisory and mandatory\
    \ record locks are exactly the same in so\n   far as the APIs and requirements\
    \ on implementation.  If the mandatory\n   lock attribute is set on the file,\
    \ the server checks to see if the\n   lockowner has an appropriate shared (read)\
    \ or exclusive (write)\n   record lock on the region it wishes to read or write\
    \ to.  If there is\n   no appropriate lock, the server checks if there is a conflicting\
    \ lock\n   (which can be done by attempting to acquire the conflicting lock on\n\
    \   the behalf of the lockowner, and if successful, release the lock\n   after\
    \ the READ or WRITE is done), and if there is, the server returns\n   NFS4ERR_LOCKED.\n\
    \   For Windows environments, there are no advisory record locks, so the\n   server\
    \ always checks for record locks during I/O requests.\n   Thus, the NFS version\
    \ 4 LOCK operation does not need to distinguish\n   between advisory and mandatory\
    \ record locks.  It is the NFS version 4\n   server's processing of the READ and\
    \ WRITE operations that introduces\n   the distinction.\n   Every stateid other\
    \ than the special stateid values noted in this\n   section, whether returned\
    \ by an OPEN-type operation (i.e., OPEN,\n   OPEN_DOWNGRADE), or by a LOCK-type\
    \ operation (i.e., LOCK or LOCKU),\n   defines an access mode for the file (i.e.,\
    \ READ, WRITE, or READ-\n   WRITE) as established by the original OPEN which began\
    \ the stateid\n   sequence, and as modified by subsequent OPENs and OPEN_DOWNGRADEs\n\
    \   within that stateid sequence.  When a READ, WRITE, or SETATTR which\n   specifies\
    \ the size attribute, is done, the operation is subject to\n   checking against\
    \ the access mode to verify that the operation is\n   appropriate given the OPEN\
    \ with which the operation is associated.\n   In the case of WRITE-type operations\
    \ (i.e., WRITEs and SETATTRs which\n   set size), the server must verify that\
    \ the access mode allows writing\n   and return an NFS4ERR_OPENMODE error if it\
    \ does not.  In the case, of\n   READ, the server may perform the corresponding\
    \ check on the access\n   mode, or it may choose to allow READ on opens for WRITE\
    \ only, to\n   accommodate clients whose write implementation may unavoidably\
    \ do\n   reads (e.g., due to buffer cache constraints).  However, even if\n  \
    \ READs are allowed in these circumstances, the server MUST still check\n   for\
    \ locks that conflict with the READ (e.g., another open specify\n   denial of\
    \ READs).  Note that a server which does enforce the access\n   mode check on\
    \ READs need not explicitly check for conflicting share\n   reservations since\
    \ the existence of OPEN for read access guarantees\n   that no conflicting share\
    \ reservation can exist.\n   A stateid of all bits 1 (one) MAY allow READ operations\
    \ to bypass\n   locking checks at the server.  However, WRITE operations with\
    \ a\n   stateid with bits all 1 (one) MUST NOT bypass locking checks and are\n\
    \   treated exactly the same as if a stateid of all bits 0 were used.\n   A lock\
    \ may not be granted while a READ or WRITE operation using one\n   of the special\
    \ stateids is being performed and the range of the lock\n   request conflicts\
    \ with the range of the READ or WRITE operation.  For\n   the purposes of this\
    \ paragraph, a conflict occurs when a shared lock\n   is requested and a WRITE\
    \ operation is being performed, or an\n   exclusive lock is requested and either\
    \ a READ or a WRITE operation is\n   being performed.  A SETATTR that sets size\
    \ is treated similarly to a\n   WRITE as discussed above.\n"
- title: 8.1.5.  Sequencing of Lock Requests
  contents:
  - "8.1.5.  Sequencing of Lock Requests\n   Locking is different than most NFS operations\
    \ as it requires \"at-\n   most-one\" semantics that are not provided by ONCRPC.\
    \  ONCRPC over a\n   reliable transport is not sufficient because a sequence of\
    \ locking\n   requests may span multiple TCP connections.  In the face of\n  \
    \ retransmission or reordering, lock or unlock requests must have a\n   well defined\
    \ and consistent behavior.  To accomplish this, each lock\n   request contains\
    \ a sequence number that is a consecutively increasing\n   integer.  Different\
    \ lock_owners have different sequences.  The server\n   maintains the last sequence\
    \ number (L) received and the response that\n   was returned.  The first request\
    \ issued for any given lock_owner is\n   issued with a sequence number of zero.\n\
    \   Note that for requests that contain a sequence number, for each\n   lock_owner,\
    \ there should be no more than one outstanding request.\n   If a request (r) with\
    \ a previous sequence number (r < L) is received,\n   it is rejected with the\
    \ return of error NFS4ERR_BAD_SEQID.  Given a\n   properly-functioning client,\
    \ the response to (r) must have been\n   received before the last request (L)\
    \ was sent.  If a duplicate of\n   last request (r == L) is received, the stored\
    \ response is returned.\n   If a request beyond the next sequence (r == L + 2)\
    \ is received, it is\n   rejected with the return of error NFS4ERR_BAD_SEQID.\
    \  Sequence\n   history is reinitialized whenever the SETCLIENTID/SETCLIENTID_CONFIRM\n\
    \   sequence changes the client verifier.\n   Since the sequence number is represented\
    \ with an unsigned 32-bit\n   integer, the arithmetic involved with the sequence\
    \ number is mod\n   2^32.  For an example of modulo arithmetic involving sequence\
    \ numbers\n   see [RFC793].\n   It is critical the server maintain the last response\
    \ sent to the\n   client to provide a more reliable cache of duplicate non-idempotent\n\
    \   requests than that of the traditional cache described in [Juszczak].\n   The\
    \ traditional duplicate request cache uses a least recently used\n   algorithm\
    \ for removing unneeded requests.  However, the last lock\n   request and response\
    \ on a given lock_owner must be cached as long as\n   the lock state exists on\
    \ the server.\n   The client MUST monotonically increment the sequence number\
    \ for the\n   CLOSE, LOCK, LOCKU, OPEN, OPEN_CONFIRM, and OPEN_DOWNGRADE\n   operations.\
    \  This is true even in the event that the previous\n   operation that used the\
    \ sequence number received an error.  The only\n   exception to this rule is if\
    \ the previous operation received one of\n   the following errors: NFS4ERR_STALE_CLIENTID,\
    \ NFS4ERR_STALE_STATEID,\n   NFS4ERR_BAD_STATEID, NFS4ERR_BAD_SEQID, NFS4ERR_BADXDR,\n\
    \   NFS4ERR_RESOURCE, NFS4ERR_NOFILEHANDLE.\n"
- title: 8.1.6.  Recovery from Replayed Requests
  contents:
  - "8.1.6.  Recovery from Replayed Requests\n   As described above, the sequence\
    \ number is per lock_owner.  As long\n   as the server maintains the last sequence\
    \ number received and follows\n   the methods described above, there are no risks\
    \ of a Byzantine router\n   re-sending old requests.  The server need only maintain\
    \ the\n   (lock_owner, sequence number) state as long as there are open files\n\
    \   or closed files with locks outstanding.\n   LOCK, LOCKU, OPEN, OPEN_DOWNGRADE,\
    \ and CLOSE each contain a sequence\n   number and therefore the risk of the replay\
    \ of these operations\n   resulting in undesired effects is non-existent while\
    \ the server\n   maintains the lock_owner state.\n"
- title: 8.1.7.  Releasing lock_owner State
  contents:
  - "8.1.7.  Releasing lock_owner State\n   When a particular lock_owner no longer\
    \ holds open or file locking\n   state at the server, the server may choose to\
    \ release the sequence\n   number state associated with the lock_owner.  The server\
    \ may make\n   this choice based on lease expiration, for the reclamation of server\n\
    \   memory, or other implementation specific details.  In any event, the\n   server\
    \ is able to do this safely only when the lock_owner no longer\n   is being utilized\
    \ by the client.  The server may choose to hold the\n   lock_owner state in the\
    \ event that retransmitted requests are\n   received.  However, the period to\
    \ hold this state is implementation\n   specific.\n   In the case that a LOCK,\
    \ LOCKU, OPEN_DOWNGRADE, or CLOSE is\n   retransmitted after the server has previously\
    \ released the lock_owner\n   state, the server will find that the lock_owner\
    \ has no files open and\n   an error will be returned to the client.  If the lock_owner\
    \ does have\n   a file open, the stateid will not match and again an error is\n\
    \   returned to the client.\n"
- title: 8.1.8.  Use of Open Confirmation
  contents:
  - "8.1.8.  Use of Open Confirmation\n   In the case that an OPEN is retransmitted\
    \ and the lock_owner is being\n   used for the first time or the lock_owner state\
    \ has been previously\n   released by the server, the use of the OPEN_CONFIRM\
    \ operation will\n   prevent incorrect behavior.  When the server observes the\
    \ use of the\n   lock_owner for the first time, it will direct the client to perform\n\
    \   the OPEN_CONFIRM for the corresponding OPEN.  This sequence\n   establishes\
    \ the use of an lock_owner and associated sequence number.\n   Since the OPEN_CONFIRM\
    \ sequence connects a new open_owner on the\n   server with an existing open_owner\
    \ on a client, the sequence number\n   may have any value.  The OPEN_CONFIRM step\
    \ assures the server that\n   the value received is the correct one.  See the\
    \ section \"OPEN_CONFIRM\n   - Confirm Open\" for further details.\n   There are\
    \ a number of situations in which the requirement to confirm\n   an OPEN would\
    \ pose difficulties for the client and server, in that\n   they would be prevented\
    \ from acting in a timely fashion on\n   information received, because that information\
    \ would be provisional,\n   subject to deletion upon non-confirmation.  Fortunately,\
    \ these are\n   situations in which the server can avoid the need for confirmation\n\
    \   when responding to open requests.  The two constraints are:\n   o  The server\
    \ must not bestow a delegation for any open which would\n      require confirmation.\n\
    \   o  The server MUST NOT require confirmation on a reclaim-type open\n     \
    \ (i.e., one specifying claim type CLAIM_PREVIOUS or\n      CLAIM_DELEGATE_PREV).\n\
    \   These constraints are related in that reclaim-type opens are the only\n  \
    \ ones in which the server may be required to send a delegation.  For\n   CLAIM_NULL,\
    \ sending the delegation is optional while for\n   CLAIM_DELEGATE_CUR, no delegation\
    \ is sent.\n   Delegations being sent with an open requiring confirmation are\n\
    \   troublesome because recovering from non-confirmation adds undue\n   complexity\
    \ to the protocol while requiring confirmation on reclaim-\n   type opens poses\
    \ difficulties in that the inability to resolve\n   the status of the reclaim\
    \ until lease expiration may make it\n   difficult to have timely determination\
    \ of the set of locks being\n   reclaimed (since the grace period may expire).\n\
    \   Requiring open confirmation on reclaim-type opens is avoidable\n   because\
    \ of the nature of the environments in which such opens are\n   done.  For CLAIM_PREVIOUS\
    \ opens, this is immediately after server\n   reboot, so there should be no time\
    \ for lockowners to be created,\n   found to be unused, and recycled.  For CLAIM_DELEGATE_PREV\
    \ opens, we\n   are dealing with a client reboot situation.  A server which supports\n\
    \   delegation can be sure that no lockowners for that client have been\n   recycled\
    \ since client initialization and thus can ensure that\n   confirmation will not\
    \ be required.\n"
- title: 8.2.  Lock Ranges
  contents:
  - "8.2.  Lock Ranges\n   The protocol allows a lock owner to request a lock with\
    \ a byte range\n   and then either upgrade or unlock a sub-range of the initial\
    \ lock.\n   It is expected that this will be an uncommon type of request.  In\
    \ any\n   case, servers or server filesystems may not be able to support sub-\n\
    \   range lock semantics.  In the event that a server receives a locking\n   request\
    \ that represents a sub-range of current locking state for the\n   lock owner,\
    \ the server is allowed to return the error\n   NFS4ERR_LOCK_RANGE to signify\
    \ that it does not support sub-range lock\n   operations.  Therefore, the client\
    \ should be prepared to receive this\n   error and, if appropriate, report the\
    \ error to the requesting\n   application.\n   The client is discouraged from\
    \ combining multiple independent locking\n   ranges that happen to be adjacent\
    \ into a single request since the\n   server may not support sub-range requests\
    \ and for reasons related to\n   the recovery of file locking state in the event\
    \ of server failure.\n   As discussed in the section \"Server Failure and Recovery\"\
    \ below, the\n   server may employ certain optimizations during recovery that\
    \ work\n   effectively only when the client's behavior during lock recovery is\n\
    \   similar to the client's locking behavior prior to server failure.\n"
- title: 8.3.  Upgrading and Downgrading Locks
  contents:
  - "8.3.  Upgrading and Downgrading Locks\n   If a client has a write lock on a record,\
    \ it can request an atomic\n   downgrade of the lock to a read lock via the LOCK\
    \ request, by setting\n   the type to READ_LT.  If the server supports atomic\
    \ downgrade, the\n   request will succeed.  If not, it will return NFS4ERR_LOCK_NOTSUPP.\n\
    \   The client should be prepared to receive this error, and if\n   appropriate,\
    \ report the error to the requesting application.\n   If a client has a read lock\
    \ on a record, it can request an atomic\n   upgrade of the lock to a write lock\
    \ via the LOCK request by setting\n   the type to WRITE_LT or WRITEW_LT.  If the\
    \ server does not support\n   atomic upgrade, it will return NFS4ERR_LOCK_NOTSUPP.\
    \  If the upgrade\n   can be achieved without an existing conflict, the request\
    \ will\n   succeed.  Otherwise, the server will return either NFS4ERR_DENIED or\n\
    \   NFS4ERR_DEADLOCK.  The error NFS4ERR_DEADLOCK is returned if the\n   client\
    \ issued the LOCK request with the type set to WRITEW_LT and the\n   server has\
    \ detected a deadlock.  The client should be prepared to\n   receive such errors\
    \ and if appropriate, report the error to the\n   requesting application.\n"
- title: 8.4.  Blocking Locks
  contents:
  - "8.4.  Blocking Locks\n   Some clients require the support of blocking locks.\
    \  The NFS version\n   4 protocol must not rely on a callback mechanism and therefore\
    \ is\n   unable to notify a client when a previously denied lock has been\n  \
    \ granted.  Clients have no choice but to continually poll for the\n   lock. \
    \ This presents a fairness problem.  Two new lock types are\n   added, READW and\
    \ WRITEW, and are used to indicate to the server that\n   the client is requesting\
    \ a blocking lock.  The server should maintain\n   an ordered list of pending\
    \ blocking locks.  When the conflicting lock\n   is released, the server may wait\
    \ the lease period for the first\n   waiting client to re-request the lock.  After\
    \ the lease period\n   expires the next waiting client request is allowed the\
    \ lock.  Clients\n   are required to poll at an interval sufficiently small that\
    \ it is\n   likely to acquire the lock in a timely manner.  The server is not\n\
    \   required to maintain a list of pending blocked locks as it is used to\n  \
    \ increase fairness and not correct operation.  Because of the\n   unordered nature\
    \ of crash recovery, storing of lock state to stable\n   storage would be required\
    \ to guarantee ordered granting of blocking\n   locks.\n   Servers may also note\
    \ the lock types and delay returning denial of\n   the request to allow extra\
    \ time for a conflicting lock to be\n   released, allowing a successful return.\
    \  In this way, clients can\n   avoid the burden of needlessly frequent polling\
    \ for blocking locks.\n   The server should take care in the length of delay in\
    \ the event the\n   client retransmits the request.\n"
- title: 8.5.  Lease Renewal
  contents:
  - "8.5.  Lease Renewal\n   The purpose of a lease is to allow a server to remove\
    \ stale locks\n   that are held by a client that has crashed or is otherwise\n\
    \   unreachable.  It is not a mechanism for cache consistency and lease\n   renewals\
    \ may not be denied if the lease interval has not expired.\n   The following events\
    \ cause implicit renewal of all of the leases for\n   a given client (i.e., all\
    \ those sharing a given clientid).  Each of\n   these is a positive indication\
    \ that the client is still active and\n   that the associated state held at the\
    \ server, for the client, is\n   still valid.\n   o  An OPEN with a valid clientid.\n\
    \   o  Any operation made with a valid stateid (CLOSE, DELEGPURGE,\n      DELEGRETURN,\
    \ LOCK, LOCKU, OPEN, OPEN_CONFIRM, OPEN_DOWNGRADE,\n      READ, RENEW, SETATTR,\
    \ WRITE).  This does not include the special\n      stateids of all bits 0 or\
    \ all bits 1.\n      Note that if the client had restarted or rebooted, the client\n\
    \      would not be making these requests without issuing the\n      SETCLIENTID/SETCLIENTID_CONFIRM\
    \ sequence.  The use of the\n      SETCLIENTID/SETCLIENTID_CONFIRM sequence (one\
    \ that changes the\n      client verifier) notifies the server to drop the locking\
    \ state\n      associated with the client.  SETCLIENTID/SETCLIENTID_CONFIRM never\n\
    \      renews a lease.\n      If the server has rebooted, the stateids (NFS4ERR_STALE_STATEID\n\
    \      error) or the clientid (NFS4ERR_STALE_CLIENTID error) will not be\n   \
    \   valid hence preventing spurious renewals.\n   This approach allows for low\
    \ overhead lease renewal which scales\n   well.  In the typical case no extra\
    \ RPC calls are required for lease\n   renewal and in the worst case one RPC is\
    \ required every lease period\n   (i.e., a RENEW operation).  The number of locks\
    \ held by the client is\n   not a factor since all state for the client is involved\
    \ with the\n   lease renewal action.\n   Since all operations that create a new\
    \ lease also renew existing\n   leases, the server must maintain a common lease\
    \ expiration time for\n   all valid leases for a given client.  This lease time\
    \ can then be\n   easily updated upon implicit lease renewal actions.\n"
- title: 8.6.  Crash Recovery
  contents:
  - "8.6.  Crash Recovery\n   The important requirement in crash recovery is that\
    \ both the client\n   and the server know when the other has failed.  Additionally,\
    \ it is\n   required that a client sees a consistent view of data across server\n\
    \   restarts or reboots.  All READ and WRITE operations that may have\n   been\
    \ queued within the client or network buffers must wait until the\n   client has\
    \ successfully recovered the locks protecting the READ and\n   WRITE operations.\n"
- title: 8.6.1.  Client Failure and Recovery
  contents:
  - "8.6.1.  Client Failure and Recovery\n   In the event that a client fails, the\
    \ server may recover the client's\n   locks when the associated leases have expired.\
    \  Conflicting locks\n   from another client may only be granted after this lease\
    \ expiration.\n   If the client is able to restart or reinitialize within the\
    \ lease\n   period the client may be forced to wait the remainder of the lease\n\
    \   period before obtaining new locks.\n   To minimize client delay upon restart,\
    \ lock requests are associated\n   with an instance of the client by a client\
    \ supplied verifier.  This\n   verifier is part of the initial SETCLIENTID call\
    \ made by the client.\n   The server returns a clientid as a result of the SETCLIENTID\n\
    \   operation.  The client then confirms the use of the clientid with\n   SETCLIENTID_CONFIRM.\
    \  The clientid in combination with an opaque\n   owner field is then used by\
    \ the client to identify the lock owner for\n   OPEN.  This chain of associations\
    \ is then used to identify all locks\n   for a particular client.\n   Since the\
    \ verifier will be changed by the client upon each\n   initialization, the server\
    \ can compare a new verifier to the verifier\n   associated with currently held\
    \ locks and determine that they do not\n   match.  This signifies the client's\
    \ new instantiation and subsequent\n   loss of locking state.  As a result, the\
    \ server is free to release\n   all locks held which are associated with the old\
    \ clientid which was\n   derived from the old verifier.\n   Note that the verifier\
    \ must have the same uniqueness properties of\n   the verifier for the COMMIT\
    \ operation.\n"
- title: 8.6.2.  Server Failure and Recovery
  contents:
  - "8.6.2.  Server Failure and Recovery\n   If the server loses locking state (usually\
    \ as a result of a restart\n   or reboot), it must allow clients time to discover\
    \ this fact and re-\n   establish the lost locking state.  The client must be\
    \ able to re-\n   establish the locking state without having the server deny valid\n\
    \   requests because the server has granted conflicting access to another\n  \
    \ client.  Likewise, if there is the possibility that clients have not\n   yet\
    \ re-established their locking state for a file, the server must\n   disallow\
    \ READ and WRITE operations for that file.  The duration of\n   this recovery\
    \ period is equal to the duration of the lease period.\n   A client can determine\
    \ that server failure (and thus loss of locking\n   state) has occurred, when\
    \ it receives one of two errors.  The\n   NFS4ERR_STALE_STATEID error indicates\
    \ a stateid invalidated by a\n   reboot or restart.  The NFS4ERR_STALE_CLIENTID\
    \ error indicates a\n   clientid invalidated by reboot or restart.  When either\
    \ of these are\n   received, the client must establish a new clientid (See the\
    \ section\n   \"Client ID\") and re-establish the locking state as discussed below.\n\
    \   The period of special handling of locking and READs and WRITEs, equal\n  \
    \ in duration to the lease period, is referred to as the \"grace\n   period\"\
    .  During the grace period, clients recover locks and the\n   associated state\
    \ by reclaim-type locking requests (i.e., LOCK\n   requests with reclaim set to\
    \ true and OPEN operations with a claim\n   type of CLAIM_PREVIOUS).  During the\
    \ grace period, the server must\n   reject READ and WRITE operations and non-reclaim\
    \ locking requests\n   (i.e., other LOCK and OPEN operations) with an error of\n\
    \   NFS4ERR_GRACE.\n   If the server can reliably determine that granting a non-reclaim\n\
    \   request will not conflict with reclamation of locks by other clients,\n  \
    \ the NFS4ERR_GRACE error does not have to be returned and the non-\n   reclaim\
    \ client request can be serviced.  For the server to be able to\n   service READ\
    \ and WRITE operations during the grace period, it must\n   again be able to guarantee\
    \ that no possible conflict could arise\n   between an impending reclaim locking\
    \ request and the READ or WRITE\n   operation.  If the server is unable to offer\
    \ that guarantee, the\n   NFS4ERR_GRACE error must be returned to the client.\n\
    \   For a server to provide simple, valid handling during the grace\n   period,\
    \ the easiest method is to simply reject all non-reclaim\n   locking requests\
    \ and READ and WRITE operations by returning the\n   NFS4ERR_GRACE error.  However,\
    \ a server may keep information about\n   granted locks in stable storage.  With\
    \ this information, the server\n   could determine if a regular lock or READ or\
    \ WRITE operation can be\n   safely processed.\n   For example, if a count of\
    \ locks on a given file is available in\n   stable storage, the server can track\
    \ reclaimed locks for the file and\n   when all reclaims have been processed,\
    \ non-reclaim locking requests\n   may be processed.  This way the server can\
    \ ensure that non-reclaim\n   locking requests will not conflict with potential\
    \ reclaim requests.\n   With respect to I/O requests, if the server is able to\
    \ determine that\n   there are no outstanding reclaim requests for a file by information\n\
    \   from stable storage or another similar mechanism, the processing of\n   I/O\
    \ requests could proceed normally for the file.\n   To reiterate, for a server\
    \ that allows non-reclaim lock and I/O\n   requests to be processed during the\
    \ grace period, it MUST determine\n   that no lock subsequently reclaimed will\
    \ be rejected and that no lock\n   subsequently reclaimed would have prevented\
    \ any I/O operation\n   processed during the grace period.\n   Clients should\
    \ be prepared for the return of NFS4ERR_GRACE errors for\n   non-reclaim lock\
    \ and I/O requests.  In this case the client should\n   employ a retry mechanism\
    \ for the request.  A delay (on the order of\n   several seconds) between retries\
    \ should be used to avoid overwhelming\n   the server.  Further discussion of\
    \ the general issue is included in\n   [Floyd].  The client must account for the\
    \ server that is able to\n   perform I/O and non-reclaim locking requests within\
    \ the grace period\n   as well as those that can not do so.\n   A reclaim-type\
    \ locking request outside the server's grace period can\n   only succeed if the\
    \ server can guarantee that no conflicting lock or\n   I/O request has been granted\
    \ since reboot or restart.\n   A server may, upon restart, establish a new value\
    \ for the lease\n   period.  Therefore, clients should, once a new clientid is\n\
    \   established, refetch the lease_time attribute and use it as the basis\n  \
    \ for lease renewal for the lease associated with that server.\n   However, the\
    \ server must establish, for this restart event, a grace\n   period at least as\
    \ long as the lease period for the previous server\n   instantiation.  This allows\
    \ the client state obtained during the\n   previous server instance to be reliably\
    \ re-established.\n"
- title: 8.6.3.  Network Partitions and Recovery
  contents:
  - "8.6.3.  Network Partitions and Recovery\n   If the duration of a network partition\
    \ is greater than the lease\n   period provided by the server, the server will\
    \ have not received a\n   lease renewal from the client.  If this occurs, the\
    \ server may free\n   all locks held for the client.  As a result, all stateids\
    \ held by the\n   client will become invalid or stale.  Once the client is able\
    \ to\n   reach the server after such a network partition, all I/O submitted by\n\
    \   the client with the now invalid stateids will fail with the server\n   returning\
    \ the error NFS4ERR_EXPIRED.  Once this error is received,\n   the client will\
    \ suitably notify the application that held the lock.\n   As a courtesy to the\
    \ client or as an optimization, the server may\n   continue to hold locks on behalf\
    \ of a client for which recent\n   communication has extended beyond the lease\
    \ period.  If the server\n   receives a lock or I/O request that conflicts with\
    \ one of these\n   courtesy locks, the server must free the courtesy lock and\
    \ grant the\n   new request.\n   When a network partition is combined with a server\
    \ reboot, there are\n   edge conditions that place requirements on the server\
    \ in order to\n   avoid silent data corruption following the server reboot.  Two\
    \ of\n   these edge conditions are known, and are discussed below.\n   The first\
    \ edge condition has the following scenario:\n      1. Client A acquires a lock.\n\
    \      2. Client A and server experience mutual network partition, such\n    \
    \     that client A is unable to renew its lease.\n      3. Client A's lease expires,\
    \ so server releases lock.\n      4. Client B acquires a lock that would have\
    \ conflicted with that\n         of Client A.\n      5. Client B releases the\
    \ lock\n      6. Server reboots\n      7. Network partition between client A and\
    \ server heals.\n      8. Client A issues a RENEW operation, and gets back a\n\
    \         NFS4ERR_STALE_CLIENTID.\n      9. Client A reclaims its lock within\
    \ the server's grace period.\n   Thus, at the final step, the server has erroneously\
    \ granted client\n   A's lock reclaim.  If client B modified the object the lock\
    \ was\n   protecting, client A will experience object corruption.\n   The second\
    \ known edge condition follows:\n      1. Client A acquires a lock.\n      2.\
    \ Server reboots.\n      3. Client A and server experience mutual network partition,\
    \ such\n         that client A is unable to reclaim its lock within the grace\n\
    \         period.\n      4. Server's reclaim grace period ends.  Client A has\
    \ no locks\n         recorded on server.\n      5. Client B acquires a lock that\
    \ would have conflicted with that\n         of Client A.\n      6. Client B releases\
    \ the lock.\n      7. Server reboots a second time.\n      8. Network partition\
    \ between client A and server heals.\n      9. Client A issues a RENEW operation,\
    \ and gets back a\n         NFS4ERR_STALE_CLIENTID.\n     10. Client A reclaims\
    \ its lock within the server's grace period.\n   As with the first edge condition,\
    \ the final step of the scenario of\n   the second edge condition has the server\
    \ erroneously granting client\n   A's lock reclaim.\n   Solving the first and\
    \ second edge conditions requires that the server\n   either assume after it reboots\
    \ that edge condition occurs, and thus\n   return NFS4ERR_NO_GRACE for all reclaim\
    \ attempts, or that the server\n   record some information stable storage.  The\
    \ amount of information\n   the server records in stable storage is in inverse\
    \ proportion to how\n   harsh the server wants to be whenever the edge conditions\
    \ occur.  The\n   server that is completely tolerant of all edge conditions will\
    \ record\n   in stable storage every lock that is acquired, removing the lock\n\
    \   record from stable storage only when the lock is unlocked by the\n   client\
    \ and the lock's lockowner advances the sequence number such\n   that the lock\
    \ release is not the last stateful event for the\n   lockowner's sequence.  For\
    \ the two aforementioned edge conditions,\n   the harshest a server can be, and\
    \ still support a grace period for\n   reclaims, requires that the server record\
    \ in stable storage\n   information some minimal information.  For example, a\
    \ server\n   implementation could, for each client, save in stable storage a\n\
    \   record containing:\n   o  the client's id string\n   o  a boolean that indicates\
    \ if the client's lease expired or if there\n      was administrative intervention\
    \ (see the section, Server\n      Revocation of Locks) to revoke a record lock,\
    \ share reservation,\n      or delegation\n   o  a timestamp that is updated the\
    \ first time after a server boot or\n      reboot the client acquires record locking,\
    \ share reservation, or\n      delegation state on the server.  The timestamp\
    \ need not be updated\n      on subsequent lock requests until the server reboots.\n\
    \   The server implementation would also record in the stable storage the\n  \
    \ timestamps from the two most recent server reboots.\n   Assuming the above record\
    \ keeping, for the first edge condition,\n   after the server reboots, the record\
    \ that client A's lease expired\n   means that another client could have acquired\
    \ a conflicting record\n   lock, share reservation, or delegation.  Hence the\
    \ server must reject\n   a reclaim from client A with the error NFS4ERR_NO_GRACE.\n\
    \   For the second edge condition, after the server reboots for a second\n   time,\
    \ the record that the client had an unexpired record lock, share\n   reservation,\
    \ or delegation established before the server's previous\n   incarnation means\
    \ that the server must reject a reclaim from client A\n   with the error NFS4ERR_NO_GRACE.\n\
    \   Regardless of the level and approach to record keeping, the server\n   MUST\
    \ implement one of the following strategies (which apply to\n   reclaims of share\
    \ reservations, record locks, and delegations):\n      1. Reject all reclaims\
    \ with NFS4ERR_NO_GRACE.  This is superharsh,\n         but necessary if the server\
    \ does not want to record lock state\n         in stable storage.\n      2. Record\
    \ sufficient state in stable storage such that all known\n         edge conditions\
    \ involving server reboot, including the two\n         noted in this section,\
    \ are detected.  False positives are\n         acceptable.  Note that at this\
    \ time, it is not known if there\n         are other edge conditions.\n      \
    \   In the event, after a server reboot, the server determines that\n        \
    \ there is unrecoverable damage or corruption to the the stable\n         storage,\
    \ then for all clients and/or locks affected, the server\n         MUST return\
    \ NFS4ERR_NO_GRACE.\n   A mandate for the client's handling of the NFS4ERR_NO_GRACE\
    \ error is\n   outside the scope of this specification, since the strategies for\n\
    \   such handling are very dependent on the client's operating\n   environment.\
    \  However, one potential approach is described below.\n   When the client receives\
    \ NFS4ERR_NO_GRACE, it could examine the\n   change attribute of the objects the\
    \ client is trying to reclaim state\n   for, and use that to determine whether\
    \ to re-establish the state via\n   normal OPEN or LOCK requests.  This is acceptable\
    \ provided the\n   client's operating environment allows it.  In otherwords, the\
    \ client\n   implementor is advised to document for his users the behavior.  The\n\
    \   client could also inform the application that its record lock or\n   share\
    \ reservations (whether they were delegated or not) have been\n   lost, such as\
    \ via a UNIX signal, a GUI pop-up window, etc.  See the\n   section, \"Data Caching\
    \ and Revocation\" for a discussion of what the\n   client should do for dealing\
    \ with unreclaimed delegations on client\n   state.\n   For further discussion\
    \ of revocation of locks see the section \"Server\n   Revocation of Locks\".\n"
- title: 8.7.  Recovery from a Lock Request Timeout or Abort
  contents:
  - "8.7.  Recovery from a Lock Request Timeout or Abort\n   In the event a lock request\
    \ times out, a client may decide to not\n   retry the request.  The client may\
    \ also abort the request when the\n   process for which it was issued is terminated\
    \ (e.g., in UNIX due to a\n   signal).  It is possible though that the server\
    \ received the request\n   and acted upon it.  This would change the state on\
    \ the server without\n   the client being aware of the change.  It is paramount\
    \ that the\n   client re-synchronize state with server before it attempts any\
    \ other\n   operation that takes a seqid and/or a stateid with the same\n   lock_owner.\
    \  This is straightforward to do without a special re-\n   synchronize operation.\n\
    \   Since the server maintains the last lock request and response\n   received\
    \ on the lock_owner, for each lock_owner, the client should\n   cache the last\
    \ lock request it sent such that the lock request did\n   not receive a response.\
    \  From this, the next time the client does a\n   lock operation for the lock_owner,\
    \ it can send the cached request, if\n   there is one, and if the request was\
    \ one that established state\n   (e.g., a LOCK or OPEN operation), the server\
    \ will return the cached\n   result or if never saw the request, perform it. \
    \ The client can\n   follow up with a request to remove the state (e.g., a LOCKU\
    \ or CLOSE\n   operation).  With this approach, the sequencing and stateid\n \
    \  information on the client and server for the given lock_owner will\n   re-synchronize\
    \ and in turn the lock state will re-synchronize.\n"
- title: 8.8.  Server Revocation of Locks
  contents:
  - "8.8.  Server Revocation of Locks\n   At any point, the server can revoke locks\
    \ held by a client and the\n   client must be prepared for this event.  When the\
    \ client detects that\n   its locks have been or may have been revoked, the client\
    \ is\n   responsible for validating the state information between itself and\n\
    \   the server.  Validating locking state for the client means that it\n   must\
    \ verify or reclaim state for each lock currently held.\n   The first instance\
    \ of lock revocation is upon server reboot or re-\n   initialization.  In this\
    \ instance the client will receive an error\n   (NFS4ERR_STALE_STATEID or NFS4ERR_STALE_CLIENTID)\
    \ and the client will\n   proceed with normal crash recovery as described in the\
    \ previous\n   section.\n   The second lock revocation event is the inability\
    \ to renew the lease\n   before expiration.  While this is considered a rare or\
    \ unusual event,\n   the client must be prepared to recover.  Both the server\
    \ and client\n   will be able to detect the failure to renew the lease and are\
    \ capable\n   of recovering without data corruption.  For the server, it tracks\
    \ the\n   last renewal event serviced for the client and knows when the lease\n\
    \   will expire.  Similarly, the client must track operations which will\n   renew\
    \ the lease period.  Using the time that each such request was\n   sent and the\
    \ time that the corresponding reply was received, the\n   client should bound\
    \ the time that the corresponding renewal could\n   have occurred on the server\
    \ and thus determine if it is possible that\n   a lease period expiration could\
    \ have occurred.\n   The third lock revocation event can occur as a result of\n\
    \   administrative intervention within the lease period.  While this is\n   considered\
    \ a rare event, it is possible that the server's\n   administrator has decided\
    \ to release or revoke a particular lock held\n   by the client.  As a result\
    \ of revocation, the client will receive an\n   error of NFS4ERR_ADMIN_REVOKED.\
    \  In this instance the client may\n   assume that only the lock_owner's locks\
    \ have been lost.  The client\n   notifies the lock holder appropriately.  The\
    \ client may not assume\n   the lease period has been renewed as a result of failed\
    \ operation.\n   When the client determines the lease period may have expired,\
    \ the\n   client must mark all locks held for the associated lease as\n   \"unvalidated\"\
    .  This means the client has been unable to re-establish\n   or confirm the appropriate\
    \ lock state with the server.  As described\n   in the previous section on crash\
    \ recovery, there are scenarios in\n   which the server may grant conflicting\
    \ locks after the lease period\n   has expired for a client.  When it is possible\
    \ that the lease period\n   has expired, the client must validate each lock currently\
    \ held to\n   ensure that a conflicting lock has not been granted.  The client\
    \ may\n   accomplish this task by issuing an I/O request, either a pending I/O\n\
    \   or a zero-length read, specifying the stateid associated with the\n   lock\
    \ in question.  If the response to the request is success, the\n   client has\
    \ validated all of the locks governed by that stateid and\n   re-established the\
    \ appropriate state between itself and the server.\n   If the I/O request is not\
    \ successful, then one or more of the locks\n   associated with the stateid was\
    \ revoked by the server and the client\n   must notify the owner.\n"
- title: 8.9.  Share Reservations
  contents:
  - "8.9.  Share Reservations\n   A share reservation is a mechanism to control access\
    \ to a file.  It\n   is a separate and independent mechanism from record locking.\
    \  When a\n   client opens a file, it issues an OPEN operation to the server\n\
    \   specifying the type of access required (READ, WRITE, or BOTH) and the\n  \
    \ type of access to deny others (deny NONE, READ, WRITE, or BOTH).  If\n   the\
    \ OPEN fails the client will fail the application's open request.\n   Pseudo-code\
    \ definition of the semantics:\n   if (request.access == 0)\n      return (NFS4ERR_INVAL)\n\
    \   else\n      if ((request.access & file_state.deny)) ||\n            (request.deny\
    \ & file_state.access))\n                    return (NFS4ERR_DENIED)\n   This\
    \ checking of share reservations on OPEN is done with no exception\n   for an\
    \ existing OPEN for the same open_owner.\n   The constants used for the OPEN and\
    \ OPEN_DOWNGRADE operations for the\n   access and deny fields are as follows:\n\
    \   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;\n   const OPEN4_SHARE_ACCESS_WRITE\
    \  = 0x00000002;\n   const OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;\n   const OPEN4_SHARE_DENY_NONE\
    \     = 0x00000000;\n   const OPEN4_SHARE_DENY_READ     = 0x00000001;\n   const\
    \ OPEN4_SHARE_DENY_WRITE    = 0x00000002;\n   const OPEN4_SHARE_DENY_BOTH    \
    \ = 0x00000003;\n"
- title: 8.10.  OPEN/CLOSE Operations
  contents:
  - "8.10.  OPEN/CLOSE Operations\n   To provide correct share semantics, a client\
    \ MUST use the OPEN\n   operation to obtain the initial filehandle and indicate\
    \ the desired\n   access and what if any access to deny.  Even if the client intends\
    \ to\n   use a stateid of all 0's or all 1's, it must still obtain the\n   filehandle\
    \ for the regular file with the OPEN operation so the\n   appropriate share semantics\
    \ can be applied.  For clients that do not\n   have a deny mode built into their\
    \ open programming interfaces, deny\n   equal to NONE should be used.\n   The\
    \ OPEN operation with the CREATE flag, also subsumes the CREATE\n   operation\
    \ for regular files as used in previous versions of the NFS\n   protocol.  This\
    \ allows a create with a share to be done atomically.\n   The CLOSE operation\
    \ removes all share reservations held by the\n   lock_owner on that file.  If\
    \ record locks are held, the client SHOULD\n   release all locks before issuing\
    \ a CLOSE.  The server MAY free all\n   outstanding locks on CLOSE but some servers\
    \ may not support the CLOSE\n   of a file that still has record locks held.  The\
    \ server MUST return\n   failure, NFS4ERR_LOCKS_HELD, if any locks would exist\
    \ after the\n   CLOSE.\n   The LOOKUP operation will return a filehandle without\
    \ establishing\n   any lock state on the server.  Without a valid stateid, the\
    \ server\n   will assume the client has the least access.  For example, a file\n\
    \   opened with deny READ/WRITE cannot be accessed using a filehandle\n   obtained\
    \ through LOOKUP because it would not have a valid stateid\n   (i.e., using a\
    \ stateid of all bits 0 or all bits 1).\n"
- title: 8.10.1.  Close and Retention of State Information
  contents:
  - "8.10.1.  Close and Retention of State Information\n   Since a CLOSE operation\
    \ requests deallocation of a stateid, dealing\n   with retransmission of the CLOSE,\
    \ may pose special difficulties,\n   since the state information, which normally\
    \ would be used to\n   determine the state of the open file being designated,\
    \ might be\n   deallocated, resulting in an NFS4ERR_BAD_STATEID error.\n   Servers\
    \ may deal with this problem in a number of ways.  To provide\n   the greatest\
    \ degree assurance that the protocol is being used\n   properly, a server should,\
    \ rather than deallocate the stateid, mark\n   it as close-pending, and retain\
    \ the stateid with this status, until\n   later deallocation.  In this way, a\
    \ retransmitted CLOSE can be\n   recognized since the stateid points to state\
    \ information with this\n   distinctive status, so that it can be handled without\
    \ error.\n   When adopting this strategy, a server should retain the state\n \
    \  information until the earliest of:\n   o  Another validly sequenced request\
    \ for the same lockowner, that is\n      not a retransmission.\n   o  The time\
    \ that a lockowner is freed by the server due to period\n      with no activity.\n\
    \   o  All locks for the client are freed as a result of a SETCLIENTID.\n   Servers\
    \ may avoid this complexity, at the cost of less complete\n   protocol error checking,\
    \ by simply responding NFS4_OK in the event of\n   a CLOSE for a deallocated stateid,\
    \ on the assumption that this case\n   must be caused by a retransmitted close.\
    \  When adopting this\n   approach, it is desirable to at least log an error when\
    \ returning a\n   no-error indication in this situation.  If the server maintains\
    \ a\n   reply-cache mechanism, it can verify the CLOSE is indeed a\n   retransmission\
    \ and avoid error logging in most cases.\n"
- title: 8.11.  Open Upgrade and Downgrade
  contents:
  - "8.11.  Open Upgrade and Downgrade\n   When an OPEN is done for a file and the\
    \ lockowner for which the open\n   is being done already has the file open, the\
    \ result is to upgrade the\n   open file status maintained on the server to include\
    \ the access and\n   deny bits specified by the new OPEN as well as those for\
    \ the existing\n   OPEN.  The result is that there is one open file, as far as\
    \ the\n   protocol is concerned, and it includes the union of the access and\n\
    \   deny bits for all of the OPEN requests completed.  Only a single\n   CLOSE\
    \ will be done to reset the effects of both OPENs.  Note that the\n   client,\
    \ when issuing the OPEN, may not know that the same file is in\n   fact being\
    \ opened.  The above only applies if both OPENs result in\n   the OPENed object\
    \ being designated by the same filehandle.\n   When the server chooses to export\
    \ multiple filehandles corresponding\n   to the same file object and returns different\
    \ filehandles on two\n   different OPENs of the same file object, the server MUST\
    \ NOT \"OR\"\n   together the access and deny bits and coalesce the two open files.\n\
    \   Instead the server must maintain separate OPENs with separate\n   stateids\
    \ and will require separate CLOSEs to free them.\n   When multiple open files\
    \ on the client are merged into a single open\n   file object on the server, the\
    \ close of one of the open files (on the\n   client) may necessitate change of\
    \ the access and deny status of the\n   open file on the server.  This is because\
    \ the union of the access and\n   deny bits for the remaining opens may be smaller\
    \ (i.e., a proper\n   subset) than previously.  The OPEN_DOWNGRADE operation is\
    \ used to\n   make the necessary change and the client should use it to update\
    \ the\n   server so that share reservation requests by other clients are\n   handled\
    \ properly.\n"
- title: 8.12.  Short and Long Leases
  contents:
  - "8.12.  Short and Long Leases\n   When determining the time period for the server\
    \ lease, the usual\n   lease tradeoffs apply.  Short leases are good for fast\
    \ server\n   recovery at a cost of increased RENEW or READ (with zero length)\n\
    \   requests.  Longer leases are certainly kinder and gentler to servers\n   trying\
    \ to handle very large numbers of clients.  The number of RENEW\n   requests drop\
    \ in proportion to the lease time.  The disadvantages of\n   long leases are slower\
    \ recovery after server failure (the server must\n   wait for the leases to expire\
    \ and the grace period to elapse before\n   granting new lock requests) and increased\
    \ file contention (if client\n   fails to transmit an unlock request then server\
    \ must wait for lease\n   expiration before granting new locks).\n   Long leases\
    \ are usable if the server is able to store lease state in\n   non-volatile memory.\
    \  Upon recovery, the server can reconstruct the\n   lease state from its non-volatile\
    \ memory and continue operation with\n   its clients and therefore long leases\
    \ would not be an issue.\n"
- title: 8.13.  Clocks, Propagation Delay, and Calculating Lease Expiration
  contents:
  - "8.13.  Clocks, Propagation Delay, and Calculating Lease Expiration\n   To avoid\
    \ the need for synchronized clocks, lease times are granted by\n   the server\
    \ as a time delta.  However, there is a requirement that the\n   client and server\
    \ clocks do not drift excessively over the duration\n   of the lock.  There is\
    \ also the issue of propagation delay across the\n   network which could easily\
    \ be several hundred milliseconds as well as\n   the possibility that requests\
    \ will be lost and need to be\n   retransmitted.\n   To take propagation delay\
    \ into account, the client should subtract it\n   from lease times (e.g., if the\
    \ client estimates the one-way\n   propagation delay as 200 msec, then it can\
    \ assume that the lease is\n   already 200 msec old when it gets it).  In addition,\
    \ it will take\n   another 200 msec to get a response back to the server.  So\
    \ the client\n   must send a lock renewal or write data back to the server 400\
    \ msec\n   before the lease would expire.\n   The server's lease period configuration\
    \ should take into account the\n   network distance of the clients that will be\
    \ accessing the server's\n   resources.  It is expected that the lease period\
    \ will take into\n   account the network propagation delays and other network\
    \ delay\n   factors for the client population.  Since the protocol does not allow\n\
    \   for an automatic method to determine an appropriate lease period, the\n  \
    \ server's administrator may have to tune the lease period.\n"
- title: 8.14.  Migration, Replication and State
  contents:
  - "8.14.  Migration, Replication and State\n   When responsibility for handling\
    \ a given file system is transferred\n   to a new server (migration) or the client\
    \ chooses to use an alternate\n   server (e.g., in response to server unresponsiveness)\
    \ in the context\n   of file system replication, the appropriate handling of state\
    \ shared\n   between the client and server (i.e., locks, leases, stateids, and\n\
    \   clientids) is as described below.  The handling differs between\n   migration\
    \ and replication.  For related discussion of file server\n   state and recover\
    \ of such see the sections under \"File Locking and\n   Share Reservations\".\n\
    \   If server replica or a server immigrating a filesystem agrees to, or\n   is\
    \ expected to, accept opaque values from the client that originated\n   from another\
    \ server, then it is a wise implementation practice for\n   the servers to encode\
    \ the \"opaque\" values in network byte order.\n   This way, servers acting as\
    \ replicas or immigrating filesystems will\n   be able to parse values like stateids,\
    \ directory cookies,\n   filehandles, etc. even if their native byte order is\
    \ different from\n   other servers cooperating in the replication and migration\
    \ of the\n   filesystem.\n"
- title: 8.14.1.  Migration and State
  contents:
  - "8.14.1.  Migration and State\n   In the case of migration, the servers involved\
    \ in the migration of a\n   filesystem SHOULD transfer all server state from the\
    \ original to the\n   new server.  This must be done in a way that is transparent\
    \ to the\n   client.  This state transfer will ease the client's transition when\
    \ a\n   filesystem migration occurs.  If the servers are successful in\n   transferring\
    \ all state, the client will continue to use stateids\n   assigned by the original\
    \ server.  Therefore the new server must\n   recognize these stateids as valid.\
    \  This holds true for the clientid\n   as well.  Since responsibility for an\
    \ entire filesystem is\n   transferred with a migration event, there is no possibility\
    \ that\n   conflicts will arise on the new server as a result of the transfer\
    \ of\n   locks.\n   As part of the transfer of information between servers, leases\
    \ would\n   be transferred as well.  The leases being transferred to the new\n\
    \   server will typically have a different expiration time from those for\n  \
    \ the same client, previously on the old server.  To maintain the\n   property\
    \ that all leases on a given server for a given client expire\n   at the same\
    \ time, the server should advance the expiration time to\n   the later of the\
    \ leases being transferred or the leases already\n   present.  This allows the\
    \ client to maintain lease renewal of both\n   classes without special effort.\n\
    \   The servers may choose not to transfer the state information upon\n   migration.\
    \  However, this choice is discouraged.  In this case, when\n   the client presents\
    \ state information from the original server, the\n   client must be prepared\
    \ to receive either NFS4ERR_STALE_CLIENTID or\n   NFS4ERR_STALE_STATEID from the\
    \ new server.  The client should then\n   recover its state information as it\
    \ normally would in response to a\n   server failure.  The new server must take\
    \ care to allow for the\n   recovery of state information as it would in the event\
    \ of server\n   restart.\n"
- title: 8.14.2.  Replication and State
  contents:
  - "8.14.2.  Replication and State\n   Since client switch-over in the case of replication\
    \ is not under\n   server control, the handling of state is different.  In this\
    \ case,\n   leases, stateids and clientids do not have validity across a\n   transition\
    \ from one server to another.  The client must re-establish\n   its locks on the\
    \ new server.  This can be compared to the re-\n   establishment of locks by means\
    \ of reclaim-type requests after a\n   server reboot.  The difference is that\
    \ the server has no provision to\n   distinguish requests reclaiming locks from\
    \ those obtaining new locks\n   or to defer the latter.  Thus, a client re-establishing\
    \ a lock on the\n   new server (by means of a LOCK or OPEN request), may have\
    \ the\n   requests denied due to a conflicting lock.  Since replication is\n \
    \  intended for read-only use of filesystems, such denial of locks\n   should\
    \ not pose large difficulties in practice.  When an attempt to\n   re-establish\
    \ a lock on a new server is denied, the client should\n   treat the situation\
    \ as if his original lock had been revoked.\n"
- title: 8.14.3.  Notification of Migrated Lease
  contents:
  - "8.14.3.  Notification of Migrated Lease\n   In the case of lease renewal, the\
    \ client may not be submitting\n   requests for a filesystem that has been migrated\
    \ to another server.\n   This can occur because of the implicit lease renewal\
    \ mechanism.  The\n   client renews leases for all filesystems when submitting\
    \ a request to\n   any one filesystem at the server.\n   In order for the client\
    \ to schedule renewal of leases that may have\n   been relocated to the new server,\
    \ the client must find out about\n   lease relocation before those leases expire.\
    \  To accomplish this, all\n   operations which implicitly renew leases for a\
    \ client (i.e., OPEN,\n   CLOSE, READ, WRITE, RENEW, LOCK, LOCKT, LOCKU), will\
    \ return the error\n   NFS4ERR_LEASE_MOVED if responsibility for any of the leases\
    \ to be\n   renewed has been transferred to a new server.  This condition will\n\
    \   continue until the client receives an NFS4ERR_MOVED error and the\n   server\
    \ receives the subsequent GETATTR(fs_locations) for an access to\n   each filesystem\
    \ for which a lease has been moved to a new server.\n   When a client receives\
    \ an NFS4ERR_LEASE_MOVED error, it should\n   perform an operation on each filesystem\
    \ associated with the server in\n   question.  When the client receives an NFS4ERR_MOVED\
    \ error, the\n   client can follow the normal process to obtain the new server\n\
    \   information (through the fs_locations attribute) and perform renewal\n   of\
    \ those leases on the new server.  If the server has not had state\n   transferred\
    \ to it transparently, the client will receive either\n   NFS4ERR_STALE_CLIENTID\
    \ or NFS4ERR_STALE_STATEID from the new server,\n   as described above, and the\
    \ client can then recover state information\n   as it does in the event of server\
    \ failure.\n"
- title: 8.14.4.  Migration and the Lease_time Attribute
  contents:
  - "8.14.4.  Migration and the Lease_time Attribute\n   In order that the client\
    \ may appropriately manage its leases in the\n   case of migration, the destination\
    \ server must establish proper\n   values for the lease_time attribute.\n   When\
    \ state is transferred transparently, that state should include\n   the correct\
    \ value of the lease_time attribute.  The lease_time\n   attribute on the destination\
    \ server must never be less than that on\n   the source since this would result\
    \ in premature expiration of leases\n   granted by the source server.  Upon migration\
    \ in which state is\n   transferred transparently, the client is under no obligation\
    \ to re-\n   fetch the lease_time attribute and may continue to use the value\n\
    \   previously fetched (on the source server).\n   If state has not been transferred\
    \ transparently (i.e., the client\n   sees a real or simulated server reboot),\
    \ the client should fetch the\n   value of lease_time on the new (i.e., destination)\
    \ server, and use it\n   for subsequent locking requests.  However the server\
    \ must respect a\n   grace period at least as long as the lease_time on the source\
    \ server,\n   in order to ensure that clients have ample time to reclaim their\n\
    \   locks before potentially conflicting non-reclaimed locks are granted.\n  \
    \ The means by which the new server obtains the value of lease_time on\n   the\
    \ old server is left to the server implementations.  It is not\n   specified by\
    \ the NFS version 4 protocol.\n"
- title: 9.  Client-Side Caching
  contents:
  - "9.  Client-Side Caching\n   Client-side caching of data, of file attributes,\
    \ and of file names is\n   essential to providing good performance with the NFS\
    \ protocol.\n   Providing distributed cache coherence is a difficult problem and\n\
    \   previous versions of the NFS protocol have not attempted it.\n   Instead,\
    \ several NFS client implementation techniques have been used\n   to reduce the\
    \ problems that a lack of coherence poses for users.\n   These techniques have\
    \ not been clearly defined by earlier protocol\n   specifications and it is often\
    \ unclear what is valid or invalid\n   client behavior.\n   The NFS version 4\
    \ protocol uses many techniques similar to those that\n   have been used in previous\
    \ protocol versions.  The NFS version 4\n   protocol does not provide distributed\
    \ cache coherence.  However, it\n   defines a more limited set of caching guarantees\
    \ to allow locks and\n   share reservations to be used without destructive interference\
    \ from\n   client side caching.\n   In addition, the NFS version 4 protocol introduces\
    \ a delegation\n   mechanism which allows many decisions normally made by the\
    \ server to\n   be made locally by clients.  This mechanism provides efficient\n\
    \   support of the common cases where sharing is infrequent or where\n   sharing\
    \ is read-only.\n"
- title: 9.1.  Performance Challenges for Client-Side Caching
  contents:
  - "9.1.  Performance Challenges for Client-Side Caching\n   Caching techniques used\
    \ in previous versions of the NFS protocol have\n   been successful in providing\
    \ good performance.  However, several\n   scalability challenges can arise when\
    \ those techniques are used with\n   very large numbers of clients.  This is particularly\
    \ true when\n   clients are geographically distributed which classically increases\n\
    \   the latency for cache revalidation requests.\n   The previous versions of\
    \ the NFS protocol repeat their file data\n   cache validation requests at the\
    \ time the file is opened.  This\n   behavior can have serious performance drawbacks.\
    \  A common case is\n   one in which a file is only accessed by a single client.\
    \  Therefore,\n   sharing is infrequent.\n   In this case, repeated reference\
    \ to the server to find that no\n   conflicts exist is expensive.  A better option\
    \ with regards to\n   performance is to allow a client that repeatedly opens a\
    \ file to do\n   so without reference to the server.  This is done until potentially\n\
    \   conflicting operations from another client actually occur.\n   A similar situation\
    \ arises in connection with file locking.  Sending\n   file lock and unlock requests\
    \ to the server as well as the read and\n   write requests necessary to make data\
    \ caching consistent with the\n   locking semantics (see the section \"Data Caching\
    \ and File Locking\")\n   can severely limit performance.  When locking is used\
    \ to provide\n   protection against infrequent conflicts, a large penalty is incurred.\n\
    \   This penalty may discourage the use of file locking by applications.\n   The\
    \ NFS version 4 protocol provides more aggressive caching\n   strategies with\
    \ the following design goals:\n   o  Compatibility with a large range of server\
    \ semantics.\n   o  Provide the same caching benefits as previous versions of\
    \ the NFS\n      protocol when unable to provide the more aggressive model.\n\
    \   o  Requirements for aggressive caching are organized so that a large\n   \
    \   portion of the benefit can be obtained even when not all of the\n      requirements\
    \ can be met.\n   The appropriate requirements for the server are discussed in\
    \ later\n   sections in which specific forms of caching are covered.  (see the\n\
    \   section \"Open Delegation\").\n"
- title: 9.2.  Delegation and Callbacks
  contents:
  - "9.2.  Delegation and Callbacks\n   Recallable delegation of server responsibilities\
    \ for a file to a\n   client improves performance by avoiding repeated requests\
    \ to the\n   server in the absence of inter-client conflict.  With the use of\
    \ a\n   \"callback\" RPC from server to client, a server recalls delegated\n \
    \  responsibilities when another client engages in sharing of a\n   delegated\
    \ file.\n   A delegation is passed from the server to the client, specifying the\n\
    \   object of the delegation and the type of delegation.  There are\n   different\
    \ types of delegations but each type contains a stateid to be\n   used to represent\
    \ the delegation when performing operations that\n   depend on the delegation.\
    \  This stateid is similar to those\n   associated with locks and share reservations\
    \ but differs in that the\n   stateid for a delegation is associated with a clientid\
    \ and may be\n   used on behalf of all the open_owners for the given client. \
    \ A\n   delegation is made to the client as a whole and not to any specific\n\
    \   process or thread of control within it.\n   Because callback RPCs may not\
    \ work in all environments (due to\n   firewalls, for example), correct protocol\
    \ operation does not depend\n   on them.  Preliminary testing of callback functionality\
    \ by means of a\n   CB_NULL procedure determines whether callbacks can be supported.\
    \  The\n   CB_NULL procedure checks the continuity of the callback path.  A\n\
    \   server makes a preliminary assessment of callback availability to a\n   given\
    \ client and avoids delegating responsibilities until it has\n   determined that\
    \ callbacks are supported.  Because the granting of a\n   delegation is always\
    \ conditional upon the absence of conflicting\n   access, clients must not assume\
    \ that a delegation will be granted and\n   they must always be prepared for OPENs\
    \ to be processed without any\n   delegations being granted.\n   Once granted,\
    \ a delegation behaves in most ways like a lock.  There\n   is an associated lease\
    \ that is subject to renewal together with all\n   of the other leases held by\
    \ that client.\n   Unlike locks, an operation by a second client to a delegated\
    \ file\n   will cause the server to recall a delegation through a callback.\n\
    \   On recall, the client holding the delegation must flush modified\n   state\
    \ (such as modified data) to the server and return the\n   delegation.  The conflicting\
    \ request will not receive a response\n   until the recall is complete.  The recall\
    \ is considered complete when\n   the client returns the delegation or the server\
    \ times out on the\n   recall and revokes the delegation as a result of the timeout.\n\
    \   Following the resolution of the recall, the server has the\n   information\
    \ necessary to grant or deny the second client's request.\n   At the time the\
    \ client receives a delegation recall, it may have\n   substantial state that\
    \ needs to be flushed to the server.  Therefore,\n   the server should allow sufficient\
    \ time for the delegation to be\n   returned since it may involve numerous RPCs\
    \ to the server.  If the\n   server is able to determine that the client is diligently\
    \ flushing\n   state to the server as a result of the recall, the server may extend\n\
    \   the usual time allowed for a recall.  However, the time allowed for\n   recall\
    \ completion should not be unbounded.\n   An example of this is when responsibility\
    \ to mediate opens on a given\n   file is delegated to a client (see the section\
    \ \"Open Delegation\").\n   The server will not know what opens are in effect\
    \ on the client.\n   Without this knowledge the server will be unable to determine\
    \ if the\n   access and deny state for the file allows any particular open until\n\
    \   the delegation for the file has been returned.\n   A client failure or a network\
    \ partition can result in failure to\n   respond to a recall callback.  In this\
    \ case, the server will revoke\n   the delegation which in turn will render useless\
    \ any modified state\n   still on the client.\n"
- title: 9.2.1.  Delegation Recovery
  contents:
  - "9.2.1.  Delegation Recovery\n   There are three situations that delegation recovery\
    \ must deal with:\n   o   Client reboot or restart\n   o   Server reboot or restart\n\
    \   o   Network partition (full or callback-only)\n   In the event the client\
    \ reboots or restarts, the failure to renew\n   leases will result in the revocation\
    \ of record locks and share\n   reservations.  Delegations, however, may be treated\
    \ a bit\n   differently.\n   There will be situations in which delegations will\
    \ need to be\n   reestablished after a client reboots or restarts.  The reason\
    \ for\n   this is the client may have file data stored locally and this data\n\
    \   was associated with the previously held delegations.  The client will\n  \
    \ need to reestablish the appropriate file state on the server.\n   To allow for\
    \ this type of client recovery, the server MAY extend the\n   period for delegation\
    \ recovery beyond the typical lease expiration\n   period.  This implies that\
    \ requests from other clients that conflict\n   with these delegations will need\
    \ to wait.  Because the normal recall\n   process may require significant time\
    \ for the client to flush changed\n   state to the server, other clients need\
    \ be prepared for delays that\n   occur because of a conflicting delegation. \
    \ This longer interval\n   would increase the window for clients to reboot and\
    \ consult stable\n   storage so that the delegations can be reclaimed.  For open\n\
    \   delegations, such delegations are reclaimed using OPEN with a claim\n   type\
    \ of CLAIM_DELEGATE_PREV.  (See the sections on \"Data Caching and\n   Revocation\"\
    \ and \"Operation 18: OPEN\" for discussion of open\n   delegation and the details\
    \ of OPEN respectively).\n   A server MAY support a claim type of CLAIM_DELEGATE_PREV,\
    \ but if it\n   does, it MUST NOT remove delegations upon SETCLIENTID_CONFIRM,\
    \ and\n   instead MUST, for a period of time no less than that of the value of\n\
    \   the lease_time attribute, maintain the client's delegations to allow\n   time\
    \ for the client to issue CLAIM_DELEGATE_PREV requests.  The\n   server that supports\
    \ CLAIM_DELEGATE_PREV MUST support the DELEGPURGE\n   operation.\n   When the\
    \ server reboots or restarts, delegations are reclaimed (using\n   the OPEN operation\
    \ with CLAIM_PREVIOUS) in a similar fashion to\n   record locks and share reservations.\
    \  However, there is a slight\n   semantic difference.  In the normal case if\
    \ the server decides that a\n   delegation should not be granted, it performs\
    \ the requested action\n   (e.g., OPEN) without granting any delegation.  For\
    \ reclaim, the\n   server grants the delegation but a special designation is applied\
    \ so\n   that the client treats the delegation as having been granted but\n  \
    \ recalled by the server.  Because of this, the client has the duty to\n   write\
    \ all modified state to the server and then return the\n   delegation.  This process\
    \ of handling delegation reclaim reconciles\n   three principles of the NFS version\
    \ 4 protocol:\n   o  Upon reclaim, a client reporting resources assigned to it\
    \ by an\n      earlier server instance must be granted those resources.\n   o\
    \  The server has unquestionable authority to determine whether\n      delegations\
    \ are to be granted and, once granted, whether they are\n      to be continued.\n\
    \   o  The use of callbacks is not to be depended upon until the client\n    \
    \  has proven its ability to receive them.\n   When a network partition occurs,\
    \ delegations are subject to freeing\n   by the server when the lease renewal\
    \ period expires.  This is similar\n   to the behavior for locks and share reservations.\
    \  For delegations,\n   however, the server may extend the period in which conflicting\n\
    \   requests are held off.  Eventually the occurrence of a conflicting\n   request\
    \ from another client will cause revocation of the delegation.\n   A loss of the\
    \ callback path (e.g., by later network configuration\n   change) will have the\
    \ same effect.  A recall request will fail and\n   revocation of the delegation\
    \ will result.\n   A client normally finds out about revocation of a delegation\
    \ when it\n   uses a stateid associated with a delegation and receives the error\n\
    \   NFS4ERR_EXPIRED.  It also may find out about delegation revocation\n   after\
    \ a client reboot when it attempts to reclaim a delegation and\n   receives that\
    \ same error.  Note that in the case of a revoked write\n   open delegation, there\
    \ are issues because data may have been modified\n   by the client whose delegation\
    \ is revoked and separately by other\n   clients.  See the section \"Revocation\
    \ Recovery for Write Open\n   Delegation\" for a discussion of such issues.  Note\
    \ also that when\n   delegations are revoked, information about the revoked delegation\n\
    \   will be written by the server to stable storage (as described in the\n   section\
    \ \"Crash Recovery\").  This is done to deal with the case in\n   which a server\
    \ reboots after revoking a delegation but before the\n   client holding the revoked\
    \ delegation is notified about the\n   revocation.\n"
- title: 9.3.  Data Caching
  contents:
  - "9.3.  Data Caching\n   When applications share access to a set of files, they\
    \ need to be\n   implemented so as to take account of the possibility of conflicting\n\
    \   access by another application.  This is true whether the applications\n  \
    \ in question execute on different clients or reside on the same\n   client.\n\
    \   Share reservations and record locks are the facilities the NFS\n   version\
    \ 4 protocol provides to allow applications to coordinate\n   access by providing\
    \ mutual exclusion facilities.  The NFS version 4\n   protocol's data caching\
    \ must be implemented such that it does not\n   invalidate the assumptions that\
    \ those using these facilities depend\n   upon.\n"
- title: 9.3.1.  Data Caching and OPENs
  contents:
  - "9.3.1.  Data Caching and OPENs\n   In order to avoid invalidating the sharing\
    \ assumptions that\n   applications rely on, NFS version 4 clients should not\
    \ provide cached\n   data to applications or modify it on behalf of an application\
    \ when it\n   would not be valid to obtain or modify that same data via a READ\
    \ or\n   WRITE operation.\n   Furthermore, in the absence of open delegation (see\
    \ the section \"Open\n   Delegation\") two additional rules apply.  Note that\
    \ these rules are\n   obeyed in practice by many NFS version 2 and version 3 clients.\n\
    \   o  First, cached data present on a client must be revalidated after\n    \
    \  doing an OPEN.  Revalidating means that the client fetches the\n      change\
    \ attribute from the server, compares it with the cached\n      change attribute,\
    \ and if different, declares the cached data (as\n      well as the cached attributes)\
    \ as invalid.  This is to ensure that\n      the data for the OPENed file is still\
    \ correctly reflected in the\n      client's cache.  This validation must be done\
    \ at least when the\n      client's OPEN operation includes DENY=WRITE or BOTH\
    \ thus\n      terminating a period in which other clients may have had the\n \
    \     opportunity to open the file with WRITE access.  Clients may\n      choose\
    \ to do the revalidation more often (i.e., at OPENs\n      specifying DENY=NONE)\
    \ to parallel the NFS version 3 protocol's\n      practice for the benefit of\
    \ users assuming this degree of cache\n      revalidation.\n      Since the change\
    \ attribute is updated for data and metadata\n      modifications, some client\
    \ implementors may be tempted to use the\n      time_modify attribute and not\
    \ change to validate cached data, so\n      that metadata changes do not spuriously\
    \ invalidate clean data.\n      The implementor is cautioned in this approach.\
    \  The change\n      attribute is guaranteed to change for each update to the\
    \ file,\n      whereas time_modify is guaranteed to change only at the\n     \
    \ granularity of the time_delta attribute.  Use by the client's data\n      cache\
    \ validation logic of time_modify and not change runs the risk\n      of the client\
    \ incorrectly marking stale data as valid.\n   o  Second, modified data must be\
    \ flushed to the server before closing\n      a file OPENed for write.  This is\
    \ complementary to the first rule.\n      If the data is not flushed at CLOSE,\
    \ the revalidation done after\n      client OPENs as file is unable to achieve\
    \ its purpose.  The other\n      aspect to flushing the data before close is that\
    \ the data must be\n      committed to stable storage, at the server, before the\
    \ CLOSE\n      operation is requested by the client.  In the case of a server\n\
    \      reboot or restart and a CLOSEd file, it may not be possible to\n      retransmit\
    \ the data to be written to the file.  Hence, this\n      requirement.\n"
- title: 9.3.2.  Data Caching and File Locking
  contents:
  - "9.3.2.  Data Caching and File Locking\n   For those applications that choose\
    \ to use file locking instead of\n   share reservations to exclude inconsistent\
    \ file access, there is an\n   analogous set of constraints that apply to client\
    \ side data caching.\n   These rules are effective only if the file locking is\
    \ used in a way\n   that matches in an equivalent way the actual READ and WRITE\n\
    \   operations executed.  This is as opposed to file locking that is\n   based\
    \ on pure convention.  For example, it is possible to manipulate\n   a two-megabyte\
    \ file by dividing the file into two one-megabyte\n   regions and protecting access\
    \ to the two regions by file locks on\n   bytes zero and one.  A lock for write\
    \ on byte zero of the file would\n   represent the right to do READ and WRITE\
    \ operations on the first\n   region.  A lock for write on byte one of the file\
    \ would represent the\n   right to do READ and WRITE operations on the second\
    \ region.  As long\n   as all applications manipulating the file obey this convention,\
    \ they\n   will work on a local filesystem.  However, they may not work with the\n\
    \   NFS version 4 protocol unless clients refrain from data caching.\n   The rules\
    \ for data caching in the file locking environment are:\n   o  First, when a client\
    \ obtains a file lock for a particular region,\n      the data cache corresponding\
    \ to that region (if any cached data\n      exists) must be revalidated.  If the\
    \ change attribute indicates\n      that the file may have been updated since\
    \ the cached data was\n      obtained, the client must flush or invalidate the\
    \ cached data for\n      the newly locked region.  A client might choose to invalidate\
    \ all\n      of non-modified cached data that it has for the file but the only\n\
    \      requirement for correct operation is to invalidate all of the data\n  \
    \    in the newly locked region.\n   o  Second, before releasing a write lock\
    \ for a region, all modified\n      data for that region must be flushed to the\
    \ server.  The modified\n      data must also be written to stable storage.\n\
    \   Note that flushing data to the server and the invalidation of cached\n   data\
    \ must reflect the actual byte ranges locked or unlocked.\n   Rounding these up\
    \ or down to reflect client cache block boundaries\n   will cause problems if\
    \ not carefully done.  For example, writing a\n   modified block when only half\
    \ of that block is within an area being\n   unlocked may cause invalid modification\
    \ to the region outside the\n   unlocked area.  This, in turn, may be part of\
    \ a region locked by\n   another client.  Clients can avoid this situation by\
    \ synchronously\n   performing portions of write operations that overlap that\
    \ portion\n   (initial or final) that is not a full block.  Similarly, invalidating\n\
    \   a locked area which is not an integral number of full buffer blocks\n   would\
    \ require the client to read one or two partial blocks from the\n   server if\
    \ the revalidation procedure shows that the data which the\n   client possesses\
    \ may not be valid.\n   The data that is written to the server as a prerequisite\
    \ to the\n   unlocking of a region must be written, at the server, to stable\n\
    \   storage.  The client may accomplish this either with synchronous\n   writes\
    \ or by following asynchronous writes with a COMMIT operation.\n   This is required\
    \ because retransmission of the modified data after a\n   server reboot might\
    \ conflict with a lock held by another client.\n   A client implementation may\
    \ choose to accommodate applications which\n   use record locking in non-standard\
    \ ways (e.g., using a record lock as\n   a global semaphore) by flushing to the\
    \ server more data upon an LOCKU\n   than is covered by the locked range.  This\
    \ may include modified data\n   within files other than the one for which the\
    \ unlocks are being done.\n   In such cases, the client must not interfere with\
    \ applications whose\n   READs and WRITEs are being done only within the bounds\
    \ of record\n   locks which the application holds.  For example, an application\
    \ locks\n   a single byte of a file and proceeds to write that single byte.  A\n\
    \   client that chose to handle a LOCKU by flushing all modified data to\n   the\
    \ server could validly write that single byte in response to an\n   unrelated\
    \ unlock.  However, it would not be valid to write the entire\n   block in which\
    \ that single written byte was located since it includes\n   an area that is not\
    \ locked and might be locked by another client.\n   Client implementations can\
    \ avoid this problem by dividing files with\n   modified data into those for which\
    \ all modifications are done to\n   areas covered by an appropriate record lock\
    \ and those for which there\n   are modifications not covered by a record lock.\
    \  Any writes done for\n   the former class of files must not include areas not\
    \ locked and thus\n   not modified on the client.\n"
- title: 9.3.3.  Data Caching and Mandatory File Locking
  contents:
  - "9.3.3.  Data Caching and Mandatory File Locking\n   Client side data caching\
    \ needs to respect mandatory file locking when\n   it is in effect.  The presence\
    \ of mandatory file locking for a given\n   file is indicated when the client\
    \ gets back NFS4ERR_LOCKED from a\n   READ or WRITE on a file it has an appropriate\
    \ share reservation for.\n   When mandatory locking is in effect for a file, the\
    \ client must check\n   for an appropriate file lock for data being read or written.\
    \  If a\n   lock exists for the range being read or written, the client may\n\
    \   satisfy the request using the client's validated cache.  If an\n   appropriate\
    \ file lock is not held for the range of the read or write,\n   the read or write\
    \ request must not be satisfied by the client's cache\n   and the request must\
    \ be sent to the server for processing.  When a\n   read or write request partially\
    \ overlaps a locked region, the request\n   should be subdivided into multiple\
    \ pieces with each region (locked or\n   not) treated appropriately.\n"
- title: 9.3.4.  Data Caching and File Identity
  contents:
  - "9.3.4.  Data Caching and File Identity\n   When clients cache data, the file\
    \ data needs to be organized\n   according to the filesystem object to which the\
    \ data belongs.  For\n   NFS version 3 clients, the typical practice has been\
    \ to assume for\n   the purpose of caching that distinct filehandles represent\
    \ distinct\n   filesystem objects.  The client then has the choice to organize\
    \ and\n   maintain the data cache on this basis.\n   In the NFS version 4 protocol,\
    \ there is now the possibility to have\n   significant deviations from a \"one\
    \ filehandle per object\" model\n   because a filehandle may be constructed on\
    \ the basis of the object's\n   pathname.  Therefore, clients need a reliable\
    \ method to determine if\n   two filehandles designate the same filesystem object.\
    \  If clients\n   were simply to assume that all distinct filehandles denote distinct\n\
    \   objects and proceed to do data caching on this basis, caching\n   inconsistencies\
    \ would arise between the distinct client side objects\n   which mapped to the\
    \ same server side object.\n   By providing a method to differentiate filehandles,\
    \ the NFS version 4\n   protocol alleviates a potential functional regression\
    \ in comparison\n   with the NFS version 3 protocol.  Without this method, caching\n\
    \   inconsistencies within the same client could occur and this has not\n   been\
    \ present in previous versions of the NFS protocol.  Note that it\n   is possible\
    \ to have such inconsistencies with applications executing\n   on multiple clients\
    \ but that is not the issue being addressed here.\n   For the purposes of data\
    \ caching, the following steps allow an NFS\n   version 4 client to determine\
    \ whether two distinct filehandles denote\n   the same server side object:\n \
    \  o  If GETATTR directed to two filehandles returns different values of\n   \
    \   the fsid attribute, then the filehandles represent distinct\n      objects.\n\
    \   o  If GETATTR for any file with an fsid that matches the fsid of the\n   \
    \   two filehandles in question returns a unique_handles attribute\n      with\
    \ a value of TRUE, then the two objects are distinct.\n   o  If GETATTR directed\
    \ to the two filehandles does not return the\n      fileid attribute for both\
    \ of the handles, then it cannot be\n      determined whether the two objects\
    \ are the same.  Therefore,\n      operations which depend on that knowledge (e.g.,\
    \ client side data\n      caching) cannot be done reliably.\n   o  If GETATTR\
    \ directed to the two filehandles returns different\n      values for the fileid\
    \ attribute, then they are distinct objects.\n   o  Otherwise they are the same\
    \ object.\n"
- title: 9.4.  Open Delegation
  contents:
  - "9.4.  Open Delegation\n   When a file is being OPENed, the server may delegate\
    \ further handling\n   of opens and closes for that file to the opening client.\
    \  Any such\n   delegation is recallable, since the circumstances that allowed\
    \ for\n   the delegation are subject to change.  In particular, the server may\n\
    \   receive a conflicting OPEN from another client, the server must\n   recall\
    \ the delegation before deciding whether the OPEN from the other\n   client may\
    \ be granted.  Making a delegation is up to the server and\n   clients should\
    \ not assume that any particular OPEN either will or\n   will not result in an\
    \ open delegation.  The following is a typical\n   set of conditions that servers\
    \ might use in deciding whether OPEN\n   should be delegated:\n   o  The client\
    \ must be able to respond to the server's callback\n      requests.  The server\
    \ will use the CB_NULL procedure for a test of\n      callback ability.\n   o\
    \  The client must have responded properly to previous recalls.\n   o  There must\
    \ be no current open conflicting with the requested\n      delegation.\n   o \
    \ There should be no current delegation that conflicts with the\n      delegation\
    \ being requested.\n   o  The probability of future conflicting open requests\
    \ should be low\n      based on the recent history of the file.\n   o  The existence\
    \ of any server-specific semantics of OPEN/CLOSE that\n      would make the required\
    \ handling incompatible with the prescribed\n      handling that the delegated\
    \ client would apply (see below).\n   There are two types of open delegations,\
    \ read and write.  A read open\n   delegation allows a client to handle, on its\
    \ own, requests to open a\n   file for reading that do not deny read access to\
    \ others.  Multiple\n   read open delegations may be outstanding simultaneously\
    \ and do not\n   conflict.  A write open delegation allows the client to handle,\
    \ on\n   its own, all opens.  Only one write open delegation may exist for a\n\
    \   given file at a given time and it is inconsistent with any read open\n   delegations.\n\
    \   When a client has a read open delegation, it may not make any changes\n  \
    \ to the contents or attributes of the file but it is assured that no\n   other\
    \ client may do so.  When a client has a write open delegation,\n   it may modify\
    \ the file data since no other client will be accessing\n   the file's data. \
    \ The client holding a write delegation may only\n   affect file attributes which\
    \ are intimately connected with the file\n   data:  size, time_modify, change.\n\
    \   When a client has an open delegation, it does not send OPENs or\n   CLOSEs\
    \ to the server but updates the appropriate status internally.\n   For a read\
    \ open delegation, opens that cannot be handled locally\n   (opens for write or\
    \ that deny read access) must be sent to the\n   server.\n   When an open delegation\
    \ is made, the response to the OPEN contains an\n   open delegation structure\
    \ which specifies the following:\n   o  the type of delegation (read or write)\n\
    \   o  space limitation information to control flushing of data on close\n   \
    \   (write open delegation only, see the section \"Open Delegation and\n     \
    \ Data Caching\")\n   o  an nfsace4 specifying read and write permissions\n  \
    \ o  a stateid to represent the delegation for READ and WRITE\n   The delegation\
    \ stateid is separate and distinct from the stateid for\n   the OPEN proper. \
    \ The standard stateid, unlike the delegation\n   stateid, is associated with\
    \ a particular lock_owner and will continue\n   to be valid after the delegation\
    \ is recalled and the file remains\n   open.\n   When a request internal to the\
    \ client is made to open a file and open\n   delegation is in effect, it will\
    \ be accepted or rejected solely on\n   the basis of the following conditions.\
    \  Any requirement for other\n   checks to be made by the delegate should result\
    \ in open delegation\n   being denied so that the checks can be made by the server\
    \ itself.\n   o  The access and deny bits for the request and the file as described\n\
    \      in the section \"Share Reservations\".\n   o  The read and write permissions\
    \ as determined below.\n   The nfsace4 passed with delegation can be used to avoid\
    \ frequent\n   ACCESS calls.  The permission check should be as follows:\n   o\
    \  If the nfsace4 indicates that the open may be done, then it should\n      be\
    \ granted without reference to the server.\n   o  If the nfsace4 indicates that\
    \ the open may not be done, then an\n      ACCESS request must be sent to the\
    \ server to obtain the definitive\n      answer.\n   The server may return an\
    \ nfsace4 that is more restrictive than the\n   actual ACL of the file.  This\
    \ includes an nfsace4 that specifies\n   denial of all access.  Note that some\
    \ common practices such as\n   mapping the traditional user \"root\" to the user\
    \ \"nobody\" may make it\n   incorrect to return the actual ACL of the file in\
    \ the delegation\n   response.\n   The use of delegation together with various\
    \ other forms of caching\n   creates the possibility that no server authentication\
    \ will ever be\n   performed for a given user since all of the user's requests\
    \ might be\n   satisfied locally.  Where the client is depending on the server\
    \ for\n   authentication, the client should be sure authentication occurs for\n\
    \   each user by use of the ACCESS operation.  This should be the case\n   even\
    \ if an ACCESS operation would not be required otherwise.  As\n   mentioned before,\
    \ the server may enforce frequent authentication by\n   returning an nfsace4 denying\
    \ all access with every open delegation.\n"
- title: 9.4.1.  Open Delegation and Data Caching
  contents:
  - "9.4.1.  Open Delegation and Data Caching\n   OPEN delegation allows much of the\
    \ message overhead associated with\n   the opening and closing files to be eliminated.\
    \  An open when an open\n   delegation is in effect does not require that a validation\
    \ message be\n   sent to the server.  The continued endurance of the \"read open\n\
    \   delegation\" provides a guarantee that no OPEN for write and thus no\n   write\
    \ has occurred.  Similarly, when closing a file opened for write\n   and if write\
    \ open delegation is in effect, the data written does not\n   have to be flushed\
    \ to the server until the open delegation is\n   recalled.  The continued endurance\
    \ of the open delegation provides a\n   guarantee that no open and thus no read\
    \ or write has been done by\n   another client.\n   For the purposes of open delegation,\
    \ READs and WRITEs done without an\n   OPEN are treated as the functional equivalents\
    \ of a corresponding\n   type of OPEN.  This refers to the READs and WRITEs that\
    \ use the\n   special stateids consisting of all zero bits or all one bits.\n\
    \   Therefore, READs or WRITEs with a special stateid done by another\n   client\
    \ will force the server to recall a write open delegation.  A\n   WRITE with a\
    \ special stateid done by another client will force a\n   recall of read open\
    \ delegations.\n   With delegations, a client is able to avoid writing data to\
    \ the\n   server when the CLOSE of a file is serviced.  The file close system\n\
    \   call is the usual point at which the client is notified of a lack of\n   stable\
    \ storage for the modified file data generated by the\n   application.  At the\
    \ close, file data is written to the server and\n   through normal accounting\
    \ the server is able to determine if the\n   available filesystem space for the\
    \ data has been exceeded (i.e.,\n   server returns NFS4ERR_NOSPC or NFS4ERR_DQUOT).\
    \  This accounting\n   includes quotas.  The introduction of delegations requires\
    \ that a\n   alternative method be in place for the same type of communication\
    \ to\n   occur between client and server.\n   In the delegation response, the\
    \ server provides either the limit of\n   the size of the file or the number of\
    \ modified blocks and associated\n   block size.  The server must ensure that\
    \ the client will be able to\n   flush data to the server of a size equal to that\
    \ provided in the\n   original delegation.  The server must make this assurance\
    \ for all\n   outstanding delegations.  Therefore, the server must be careful\
    \ in\n   its management of available space for new or modified data taking\n \
    \  into account available filesystem space and any applicable quotas.\n   The\
    \ server can recall delegations as a result of managing the\n   available filesystem\
    \ space.  The client should abide by the server's\n   state space limits for delegations.\
    \  If the client exceeds the stated\n   limits for the delegation, the server's\
    \ behavior is undefined.\n   Based on server conditions, quotas or available filesystem\
    \ space, the\n   server may grant write open delegations with very restrictive\
    \ space\n   limitations.  The limitations may be defined in a way that will\n\
    \   always force modified data to be flushed to the server on close.\n   With\
    \ respect to authentication, flushing modified data to the server\n   after a\
    \ CLOSE has occurred may be problematic.  For example, the user\n   of the application\
    \ may have logged off the client and unexpired\n   authentication credentials\
    \ may not be present.  In this case, the\n   client may need to take special care\
    \ to ensure that local unexpired\n   credentials will in fact be available.  This\
    \ may be accomplished by\n   tracking the expiration time of credentials and flushing\
    \ data well in\n   advance of their expiration or by making private copies of\n\
    \   credentials to assure their availability when needed.\n"
- title: 9.4.2.  Open Delegation and File Locks
  contents:
  - "9.4.2.  Open Delegation and File Locks\n   When a client holds a write open delegation,\
    \ lock operations may be\n   performed locally.  This includes those required\
    \ for mandatory file\n   locking.  This can be done since the delegation implies\
    \ that there\n   can be no conflicting locks.  Similarly, all of the revalidations\n\
    \   that would normally be associated with obtaining locks and the\n   flushing\
    \ of data associated with the releasing of locks need not be\n   done.\n   When\
    \ a client holds a read open delegation, lock operations are not\n   performed\
    \ locally.  All lock operations, including those requesting\n   non-exclusive\
    \ locks, are sent to the server for resolution.\n"
- title: 9.4.3.  Handling of CB_GETATTR
  contents:
  - "9.4.3.  Handling of CB_GETATTR\n   The server needs to employ special handling\
    \ for a GETATTR where the\n   target is a file that has a write open delegation\
    \ in effect.  The\n   reason for this is that the client holding the write delegation\
    \ may\n   have modified the data and the server needs to reflect this change to\n\
    \   the second client that submitted the GETATTR.  Therefore, the client\n   holding\
    \ the write delegation needs to be interrogated.  The server\n   will use the\
    \ CB_GETATTR operation.  The only attributes that the\n   server can reliably\
    \ query via CB_GETATTR are size and change.\n   Since CB_GETATTR is being used\
    \ to satisfy another client's GETATTR\n   request, the server only needs to know\
    \ if the client holding the\n   delegation has a modified version of the file.\
    \  If the client's copy\n   of the delegated file is not modified (data or size),\
    \ the server can\n   satisfy the second client's GETATTR request from the attributes\n\
    \   stored locally at the server.  If the file is modified, the server\n   only\
    \ needs to know about this modified state.  If the server\n   determines that\
    \ the file is currently modified, it will respond to\n   the second client's GETATTR\
    \ as if the file had been modified locally\n   at the server.\n   Since the form\
    \ of the change attribute is determined by the server\n   and is opaque to the\
    \ client, the client and server need to agree on a\n   method of communicating\
    \ the modified state of the file.  For the size\n   attribute, the client will\
    \ report its current view of the file size.\n   For the change attribute, the\
    \ handling is more involved.\n   For the client, the following steps will be taken\
    \ when receiving a\n   write delegation:\n   o  The value of the change attribute\
    \ will be obtained from the server\n      and cached.  Let this value be represented\
    \ by c.\n   o  The client will create a value greater than c that will be used\n\
    \      for communicating modified data is held at the client.  Let this\n    \
    \  value be represented by d.\n   o  When the client is queried via CB_GETATTR\
    \ for the change\n      attribute, it checks to see if it holds modified data.\
    \  If the\n      file is modified, the value d is returned for the change attribute\n\
    \      value.  If this file is not currently modified, the client returns\n  \
    \    the value c for the change attribute.\n   For simplicity of implementation,\
    \ the client MAY for each CB_GETATTR\n   return the same value d.  This is true\
    \ even if, between successive\n   CB_GETATTR operations, the client again modifies\
    \ in the file's data\n   or metadata in its cache.  The client can return the\
    \ same value\n   because the only requirement is that the client be able to indicate\n\
    \   to the server that the client holds modified data.  Therefore, the\n   value\
    \ of d may always be c + 1.\n   While the change attribute is opaque to the client\
    \ in the sense that\n   it has no idea what units of time, if any, the server\
    \ is counting\n   change with, it is not opaque in that the client has to treat\
    \ it as\n   an unsigned integer, and the server has to be able to see the results\n\
    \   of the client's changes to that integer.  Therefore, the server MUST\n   encode\
    \ the change attribute in network order when sending it to the\n   client.  The\
    \ client MUST decode it from network order to its native\n   order when receiving\
    \ it and the client MUST encode it network order\n   when sending it to the server.\
    \  For this reason, change is defined as\n   an unsigned integer rather than an\
    \ opaque array of octets.\n   For the server, the following steps will be taken\
    \ when providing a\n   write delegation:\n   o  Upon providing a write delegation,\
    \ the server will cache a copy of\n      the change attribute in the data structure\
    \ it uses to record the\n      delegation.  Let this value be represented by sc.\n\
    \   o  When a second client sends a GETATTR operation on the same file to\n  \
    \    the server, the server obtains the change attribute from the first\n    \
    \  client.  Let this value be cc.\n   o  If the value cc is equal to sc, the file\
    \ is not modified and the\n      server returns the current values for change,\
    \ time_metadata, and\n      time_modify (for example) to the second client.\n\
    \   o  If the value cc is NOT equal to sc, the file is currently modified\n  \
    \    at the first client and most likely will be modified at the server\n    \
    \  at a future time.  The server then uses its current time to\n      construct\
    \ attribute values for time_metadata and time_modify.  A\n      new value of sc,\
    \ which we will call nsc, is computed by the\n      server, such that nsc >= sc\
    \ + 1.  The server then returns the\n      constructed time_metadata, time_modify,\
    \ and nsc values to the\n      requester.  The server replaces sc in the delegation\
    \ record with\n      nsc.  To prevent the possibility of time_modify, time_metadata,\n\
    \      and change from appearing to go backward (which would happen if\n     \
    \ the client holding the delegation fails to write its modified data\n      to\
    \ the server before the delegation is revoked or returned), the\n      server\
    \ SHOULD update the file's metadata record with the\n      constructed attribute\
    \ values.  For reasons of reasonable\n      performance, committing the constructed\
    \ attribute values to stable\n      storage is OPTIONAL.\n      As discussed earlier\
    \ in this section, the client MAY return the\n      same cc value on subsequent\
    \ CB_GETATTR calls, even if the file was\n      modified in the client's cache\
    \ yet again between successive\n      CB_GETATTR calls.  Therefore, the server\
    \ must assume that the file\n      has been modified yet again, and MUST take\
    \ care to ensure that the\n      new nsc it constructs and returns is greater\
    \ than the previous nsc\n      it returned.  An example implementation's delegation\
    \ record would\n      satisfy this mandate by including a boolean field (let us\
    \ call it\n      \"modified\") that is set to false when the delegation is granted,\n\
    \      and an sc value set at the time of grant to the change attribute\n    \
    \  value.  The modified field would be set to true the first time cc\n      !=\
    \ sc, and would stay true until the delegation is returned or\n      revoked.\
    \  The processing for constructing nsc, time_modify, and\n      time_metadata\
    \ would use this pseudo code:\n      if (!modified) {\n          do CB_GETATTR\
    \ for change and size;\n             if (cc != sc)\n                 modified\
    \ = TRUE;\n         } else {\n                 do CB_GETATTR for size;\n     \
    \    }\n         if (modified) {\n             sc = sc + 1;\n          time_modify\
    \ = time_metadata = current_time;\n          update sc, time_modify, time_metadata\
    \ into file's metadata;\n      }\n      return to client (that sent GETATTR) the\
    \ attributes\n         it requested, but make sure size comes from what\n    \
    \     CB_GETATTR returned.  Do not update the file's metadata\n         with the\
    \ client's modified size.\n   o  In the case that the file attribute size is different\
    \ than the\n      server's current value, the server treats this as a modification\n\
    \      regardless of the value of the change attribute retrieved via\n      CB_GETATTR\
    \ and responds to the second client as in the last step.\n   This methodology\
    \ resolves issues of clock differences between client\n   and server and other\
    \ scenarios where the use of CB_GETATTR break\n   down.\n   It should be noted\
    \ that the server is under no obligation to use\n   CB_GETATTR and therefore the\
    \ server MAY simply recall the delegation\n   to avoid its use.\n"
- title: 9.4.4.  Recall of Open Delegation
  contents:
  - "9.4.4.  Recall of Open Delegation\n   The following events necessitate recall\
    \ of an open delegation:\n   o  Potentially conflicting OPEN request (or READ/WRITE\
    \ done with\n      \"special\" stateid)\n   o  SETATTR issued by another client\n\
    \   o  REMOVE request for the file\n   o  RENAME request for the file as either\
    \ source or target of the\n      RENAME\n   Whether a RENAME of a directory in\
    \ the path leading to the file\n   results in recall of an open delegation depends\
    \ on the semantics of\n   the server filesystem.  If that filesystem denies such\
    \ RENAMEs when a\n   file is open, the recall must be performed to determine whether\
    \ the\n   file in question is, in fact, open.\n   In addition to the situations\
    \ above, the server may choose to recall\n   open delegations at any time if resource\
    \ constraints make it\n   advisable to do so.  Clients should always be prepared\
    \ for the\n   possibility of recall.\n   When a client receives a recall for an\
    \ open delegation, it needs to\n   update state on the server before returning\
    \ the delegation.  These\n   same updates must be done whenever a client chooses\
    \ to return a\n   delegation voluntarily.  The following items of state need to\
    \ be\n   dealt with:\n   o  If the file associated with the delegation is no longer\
    \ open and\n      no previous CLOSE operation has been sent to the server, a CLOSE\n\
    \      operation must be sent to the server.\n   o  If a file has other open references\
    \ at the client, then OPEN\n      operations must be sent to the server.  The\
    \ appropriate stateids\n      will be provided by the server for subsequent use\
    \ by the client\n      since the delegation stateid will not longer be valid.\
    \  These OPEN\n      requests are done with the claim type of CLAIM_DELEGATE_CUR.\
    \  This\n      will allow the presentation of the delegation stateid so that the\n\
    \      client can establish the appropriate rights to perform the OPEN.\n    \
    \  (see the section \"Operation 18: OPEN\" for details.)\n   o  If there are granted\
    \ file locks, the corresponding LOCK operations\n      need to be performed. \
    \ This applies to the write open delegation\n      case only.\n   o  For a write\
    \ open delegation, if at the time of recall the file is\n      not open for write,\
    \ all modified data for the file must be flushed\n      to the server.  If the\
    \ delegation had not existed, the client\n      would have done this data flush\
    \ before the CLOSE operation.\n   o  For a write open delegation when a file is\
    \ still open at the time\n      of recall, any modified data for the file needs\
    \ to be flushed to\n      the server.\n   o  With the write open delegation in\
    \ place, it is possible that the\n      file was truncated during the duration\
    \ of the delegation.  For\n      example, the truncation could have occurred as\
    \ a result of an OPEN\n      UNCHECKED with a size attribute value of zero.  Therefore,\
    \ if a\n      truncation of the file has occurred and this operation has not\n\
    \      been propagated to the server, the truncation must occur before\n     \
    \ any modified data is written to the server.\n   In the case of write open delegation,\
    \ file locking imposes some\n   additional requirements.  To precisely maintain\
    \ the associated\n   invariant, it is required to flush any modified data in any\
    \ region\n   for which a write lock was released while the write delegation was\
    \ in\n   effect.  However, because the write open delegation implies no other\n\
    \   locking by other clients, a simpler implementation is to flush all\n   modified\
    \ data for the file (as described just above) if any write\n   lock has been released\
    \ while the write open delegation was in effect.\n   An implementation need not\
    \ wait until delegation recall (or deciding\n   to voluntarily return a delegation)\
    \ to perform any of the above\n   actions, if implementation considerations (e.g.,\
    \ resource\n   availability constraints) make that desirable.  Generally, however,\n\
    \   the fact that the actual open state of the file may continue to\n   change\
    \ makes it not worthwhile to send information about opens and\n   closes to the\
    \ server, except as part of delegation return.  Only in\n   the case of closing\
    \ the open that resulted in obtaining the\n   delegation would clients be likely\
    \ to do this early, since, in that\n   case, the close once done will not be undone.\
    \  Regardless of the\n   client's choices on scheduling these actions, all must\
    \ be performed\n   before the delegation is returned, including (when applicable)\
    \ the\n   close that corresponds to the open that resulted in the delegation.\n\
    \   These actions can be performed either in previous requests or in\n   previous\
    \ operations in the same COMPOUND request.\n"
- title: 9.4.5.  Clients that Fail to Honor Delegation Recalls
  contents:
  - "9.4.5.  Clients that Fail to Honor Delegation Recalls\n   A client may fail to\
    \ respond to a recall for various reasons, such as\n   a failure of the callback\
    \ path from server to the client.  The client\n   may be unaware of a failure\
    \ in the callback path.  This lack of\n   awareness could result in the client\
    \ finding out long after the\n   failure that its delegation has been revoked,\
    \ and another client has\n   modified the data for which the client had a delegation.\
    \  This is\n   especially a problem for the client that held a write delegation.\n\
    \   The server also has a dilemma in that the client that fails to\n   respond\
    \ to the recall might also be sending other NFS requests,\n   including those\
    \ that renew the lease before the lease expires.\n   Without returning an error\
    \ for those lease renewing operations, the\n   server leads the client to believe\
    \ that the delegation it has is in\n   force.\n   This difficulty is solved by\
    \ the following rules:\n   o  When the callback path is down, the server MUST\
    \ NOT revoke the\n      delegation if one of the following occurs:\n      -  The\
    \ client has issued a RENEW operation and the server has\n         returned an\
    \ NFS4ERR_CB_PATH_DOWN error.  The server MUST renew\n         the lease for any\
    \ record locks and share reservations the\n         client has that the server\
    \ has known about (as opposed to those\n         locks and share reservations\
    \ the client has established but not\n         yet sent to the server, due to\
    \ the delegation).  The server\n         SHOULD give the client a reasonable time\
    \ to return its\n         delegations to the server before revoking the client's\n\
    \         delegations.\n      -  The client has not issued a RENEW operation for\
    \ some period of\n         time after the server attempted to recall the delegation.\
    \  This\n         period of time MUST NOT be less than the value of the\n    \
    \     lease_time attribute.\n   o  When the client holds a delegation, it can\
    \ not rely on operations,\n      except for RENEW, that take a stateid, to renew\
    \ delegation leases\n      across callback path failures.  The client that wants\
    \ to keep\n      delegations in force across callback path failures must use RENEW\n\
    \      to do so.\n"
- title: 9.4.6.  Delegation Revocation
  contents:
  - "9.4.6.  Delegation Revocation\n   At the point a delegation is revoked, if there\
    \ are associated opens\n   on the client, the applications holding these opens\
    \ need to be\n   notified.  This notification usually occurs by returning errors\
    \ for\n   READ/WRITE operations or when a close is attempted for the open file.\n\
    \   If no opens exist for the file at the point the delegation is\n   revoked,\
    \ then notification of the revocation is unnecessary.\n   However, if there is\
    \ modified data present at the client for the\n   file, the user of the application\
    \ should be notified.  Unfortunately,\n   it may not be possible to notify the\
    \ user since active applications\n   may not be present at the client.  See the\
    \ section \"Revocation\n   Recovery for Write Open Delegation\" for additional\
    \ details.\n"
- title: 9.5.  Data Caching and Revocation
  contents:
  - "9.5.  Data Caching and Revocation\n   When locks and delegations are revoked,\
    \ the assumptions upon which\n   successful caching depend are no longer guaranteed.\
    \  For any locks or\n   share reservations that have been revoked, the corresponding\
    \ owner\n   needs to be notified.  This notification includes applications with\
    \ a\n   file open that has a corresponding delegation which has been revoked.\n\
    \   Cached data associated with the revocation must be removed from the\n   client.\
    \  In the case of modified data existing in the client's cache,\n   that data\
    \ must be removed from the client without it being written to\n   the server.\
    \  As mentioned, the assumptions made by the client are no\n   longer valid at\
    \ the point when a lock or delegation has been revoked.\n   For example, another\
    \ client may have been granted a conflicting lock\n   after the revocation of\
    \ the lock at the first client.  Therefore, the\n   data within the lock range\
    \ may have been modified by the other\n   client.  Obviously, the first client\
    \ is unable to guarantee to the\n   application what has occurred to the file\
    \ in the case of revocation.\n   Notification to a lock owner will in many cases\
    \ consist of simply\n   returning an error on the next and all subsequent READs/WRITEs\
    \ to the\n   open file or on the close.  Where the methods available to a client\n\
    \   make such notification impossible because errors for certain\n   operations\
    \ may not be returned, more drastic action such as signals\n   or process termination\
    \ may be appropriate.  The justification for\n   this is that an invariant for\
    \ which an application depends on may be\n   violated.  Depending on how errors\
    \ are typically treated for the\n   client operating environment, further levels\
    \ of notification\n   including logging, console messages, and GUI pop-ups may\
    \ be\n   appropriate.\n"
- title: 9.5.1.  Revocation Recovery for Write Open Delegation
  contents:
  - "9.5.1.  Revocation Recovery for Write Open Delegation\n   Revocation recovery\
    \ for a write open delegation poses the special\n   issue of modified data in\
    \ the client cache while the file is not\n   open.  In this situation, any client\
    \ which does not flush modified\n   data to the server on each close must ensure\
    \ that the user receives\n   appropriate notification of the failure as a result\
    \ of the\n   revocation.  Since such situations may require human action to\n\
    \   correct problems, notification schemes in which the appropriate user\n   or\
    \ administrator is notified may be necessary.  Logging and console\n   messages\
    \ are typical examples.\n   If there is modified data on the client, it must not\
    \ be flushed\n   normally to the server.  A client may attempt to provide a copy\
    \ of\n   the file data as modified during the delegation under a different\n \
    \  name in the filesystem name space to ease recovery.  Note that when\n   the\
    \ client can determine that the file has not been modified by any\n   other client,\
    \ or when the client has a complete cached copy of file\n   in question, such\
    \ a saved copy of the client's view of the file may\n   be of particular value\
    \ for recovery.  In other case, recovery using a\n   copy of the file based partially\
    \ on the client's cached data and\n   partially on the server copy as modified\
    \ by other clients, will be\n   anything but straightforward, so clients may avoid\
    \ saving file\n   contents in these situations or mark the results specially to\
    \ warn\n   users of possible problems.\n   Saving of such modified data in delegation\
    \ revocation situations may\n   be limited to files of a certain size or might\
    \ be used only when\n   sufficient disk space is available within the target filesystem.\n\
    \   Such saving may also be restricted to situations when the client has\n   sufficient\
    \ buffering resources to keep the cached copy available\n   until it is properly\
    \ stored to the target filesystem.\n"
- title: 9.6.  Attribute Caching
  contents:
  - "9.6.  Attribute Caching\n   The attributes discussed in this section do not include\
    \ named\n   attributes.  Individual named attributes are analogous to files and\n\
    \   caching of the data for these needs to be handled just as data\n   caching\
    \ is for ordinary files.  Similarly, LOOKUP results from an\n   OPENATTR directory\
    \ are to be cached on the same basis as any other\n   pathnames and similarly\
    \ for directory contents.\n   Clients may cache file attributes obtained from\
    \ the server and use\n   them to avoid subsequent GETATTR requests.  Such caching\
    \ is write\n   through in that modification to file attributes is always done\
    \ by\n   means of requests to the server and should not be done locally and\n\
    \   cached.  The exception to this are modifications to attributes that\n   are\
    \ intimately connected with data caching.  Therefore, extending a\n   file by\
    \ writing data to the local data cache is reflected immediately\n   in the size\
    \ as seen on the client without this change being\n   immediately reflected on\
    \ the server.  Normally such changes are not\n   propagated directly to the server\
    \ but when the modified data is\n   flushed to the server, analogous attribute\
    \ changes are made on the\n   server.  When open delegation is in effect, the\
    \ modified attributes\n   may be returned to the server in the response to a CB_RECALL\
    \ call.\n   The result of local caching of attributes is that the attribute\n\
    \   caches maintained on individual clients will not be coherent.\n   Changes\
    \ made in one order on the server may be seen in a different\n   order on one\
    \ client and in a third order on a different client.\n   The typical filesystem\
    \ application programming interfaces do not\n   provide means to atomically modify\
    \ or interrogate attributes for\n   multiple files at the same time.  The following\
    \ rules provide an\n   environment where the potential incoherences mentioned\
    \ above can be\n   reasonably managed.  These rules are derived from the practice\
    \ of\n   previous NFS protocols.\n   o  All attributes for a given file (per-fsid\
    \ attributes excepted) are\n      cached as a unit at the client so that no non-serializability\
    \ can\n      arise within the context of a single file.\n   o  An upper time boundary\
    \ is maintained on how long a client cache\n      entry can be kept without being\
    \ refreshed from the server.\n   o  When operations are performed that change\
    \ attributes at the\n      server, the updated attribute set is requested as part\
    \ of the\n      containing RPC.  This includes directory operations that update\n\
    \      attributes indirectly.  This is accomplished by following the\n      modifying\
    \ operation with a GETATTR operation and then using the\n      results of the\
    \ GETATTR to update the client's cached attributes.\n   Note that if the full\
    \ set of attributes to be cached is requested by\n   READDIR, the results can\
    \ be cached by the client on the same basis as\n   attributes obtained via GETATTR.\n\
    \   A client may validate its cached version of attributes for a file by\n   fetching\
    \ just both the change and time_access attributes and assuming\n   that if the\
    \ change attribute has the same value as it did when the\n   attributes were cached,\
    \ then no attributes other than time_access\n   have changed.  The reason why\
    \ time_access is also fetched is because\n   many servers operate in environments\
    \ where the operation that updates\n   change does not update time_access.  For\
    \ example, POSIX file\n   semantics do not update access time when a file is modified\
    \ by the\n   write system call.  Therefore, the client that wants a current\n\
    \   time_access value should fetch it with change during the attribute\n   cache\
    \ validation processing and update its cached time_access.\n   The client may\
    \ maintain a cache of modified attributes for those\n   attributes intimately\
    \ connected with data of modified regular files\n   (size, time_modify, and change).\
    \  Other than those three attributes,\n   the client MUST NOT maintain a cache\
    \ of modified attributes.\n   Instead, attribute changes are immediately sent\
    \ to the server.\n   In some operating environments, the equivalent to time_access\
    \ is\n   expected to be implicitly updated by each read of the content of the\n\
    \   file object.  If an NFS client is caching the content of a file\n   object,\
    \ whether it is a regular file, directory, or symbolic link,\n   the client SHOULD\
    \ NOT update the time_access attribute (via SETATTR\n   or a small READ or READDIR\
    \ request) on the server with each read that\n   is satisfied from cache.  The\
    \ reason is that this can defeat the\n   performance benefits of caching content,\
    \ especially since an explicit\n   SETATTR of time_access may alter the change\
    \ attribute on the server.\n   If the change attribute changes, clients that are\
    \ caching the content\n   will think the content has changed, and will re-read\
    \ unmodified data\n   from the server.  Nor is the client encouraged to maintain\
    \ a modified\n   version of time_access in its cache, since this would mean that\
    \ the\n   client will either eventually have to write the access time to the\n\
    \   server with bad performance effects, or it would never update the\n   server's\
    \ time_access, thereby resulting in a situation where an\n   application that\
    \ caches access time between a close and open of the\n   same file observes the\
    \ access time oscillating between the past and\n   present.  The time_access attribute\
    \ always means the time of last\n   access to a file by a read that was satisfied\
    \ by the server.  This\n   way clients will tend to see only time_access changes\
    \ that go forward\n   in time.\n"
- title: 9.7.  Data and Metadata Caching and Memory Mapped Files
  contents:
  - "9.7.  Data and Metadata Caching and Memory Mapped Files\n   Some operating environments\
    \ include the capability for an application\n   to map a file's content into the\
    \ application's address space.  Each\n   time the application accesses a memory\
    \ location that corresponds to a\n   block that has not been loaded into the address\
    \ space, a page fault\n   occurs and the file is read (or if the block does not\
    \ exist in the\n   file, the block is allocated and then instantiated in the\n\
    \   application's address space).\n   As long as each memory mapped access to\
    \ the file requires a page\n   fault, the relevant attributes of the file that\
    \ are used to detect\n   access and modification (time_access, time_metadata,\
    \ time_modify, and\n   change) will be updated.  However, in many operating environments,\n\
    \   when page faults are not required these attributes will not be\n   updated\
    \ on reads or updates to the file via memory access (regardless\n   whether the\
    \ file is local file or is being access remotely).  A\n   client or server MAY\
    \ fail to update attributes of a file that is\n   being accessed via memory mapped\
    \ I/O.  This has several implications:\n   o  If there is an application on the\
    \ server that has memory mapped a\n      file that a client is also accessing,\
    \ the client may not be able\n      to get a consistent value of the change attribute\
    \ to determine\n      whether its cache is stale or not.  A server that knows\
    \ that the\n      file is memory mapped could always pessimistically return updated\n\
    \      values for change so as to force the application to always get the\n  \
    \    most up to date data and metadata for the file.  However, due to\n      the\
    \ negative performance implications of this, such behavior is\n      OPTIONAL.\n\
    \   o  If the memory mapped file is not being modified on the server, and\n  \
    \    instead is just being read by an application via the memory mapped\n    \
    \  interface, the client will not see an updated time_access\n      attribute.\
    \  However, in many operating environments, neither will\n      any process running\
    \ on the server.  Thus NFS clients are at no\n      disadvantage with respect\
    \ to local processes.\n   o  If there is another client that is memory mapping\
    \ the file, and if\n      that client is holding a write delegation, the same\
    \ set of issues\n      as discussed in the previous two bullet items apply.  So,\
    \ when a\n      server does a CB_GETATTR to a file that the client has modified\
    \ in\n      its cache, the response from CB_GETATTR will not necessarily be\n\
    \      accurate.  As discussed earlier, the client's obligation is to\n      report\
    \ that the file has been modified since the delegation was\n      granted, not\
    \ whether it has been modified again between successive\n      CB_GETATTR calls,\
    \ and the server MUST assume that any file the\n      client has modified in cache\
    \ has been modified again between\n      successive CB_GETATTR calls.  Depending\
    \ on the nature of the\n      client's memory management system, this weak obligation\
    \ may not be\n      possible.  A client MAY return stale information in CB_GETATTR\n\
    \      whenever the file is memory mapped.\n   o  The mixture of memory mapping\
    \ and file locking on the same file is\n      problematic.  Consider the following\
    \ scenario, where the page size\n      on each client is 8192 bytes.\n      -\
    \  Client A memory maps first page (8192 bytes) of file X\n      -  Client B memory\
    \ maps first page (8192 bytes) of file X\n      -  Client A write locks first\
    \ 4096 bytes\n      -  Client B write locks second 4096 bytes\n      -  Client\
    \ A, via a STORE instruction modifies part of its locked\n         region.\n \
    \     -  Simultaneous to client A, client B issues a STORE on part of\n      \
    \   its locked region.\n   Here the challenge is for each client to resynchronize\
    \ to get a\n   correct view of the first page.  In many operating environments,\
    \ the\n   virtual memory management systems on each client only know a page is\n\
    \   modified, not that a subset of the page corresponding to the\n   respective\
    \ lock regions has been modified.  So it is not possible for\n   each client to\
    \ do the right thing, which is to only write to the\n   server that portion of\
    \ the page that is locked. For example, if\n   client A simply writes out the\
    \ page, and then client B writes out the\n   page, client A's data is lost.\n\
    \   Moreover, if mandatory locking is enabled on the file, then we have a\n  \
    \ different problem.  When clients A and B issue the STORE\n   instructions, the\
    \ resulting page faults require a record lock on the\n   entire page.  Each client\
    \ then tries to extend their locked range to\n   the entire page, which results\
    \ in a deadlock.\n   Communicating the NFS4ERR_DEADLOCK error to a STORE instruction\
    \ is\n   difficult at best.\n   If a client is locking the entire memory mapped\
    \ file, there is no\n   problem with advisory or mandatory record locking, at\
    \ least until the\n   client unlocks a region in the middle of the file.\n   Given\
    \ the above issues the following are permitted:\n   -  Clients and servers MAY\
    \ deny memory mapping a file they know there\n      are record locks for.\n  \
    \ -  Clients and servers MAY deny a record lock on a file they know is\n     \
    \ memory mapped.\n   -  A client MAY deny memory mapping a file that it knows\
    \ requires\n      mandatory locking for I/O.  If mandatory locking is enabled\
    \ after\n      the file is opened and mapped, the client MAY deny the application\n\
    \      further access to its mapped file.\n"
- title: 9.8.  Name Caching
  contents:
  - "9.8.  Name Caching\n   The results of LOOKUP and READDIR operations may be cached\
    \ to avoid\n   the cost of subsequent LOOKUP operations.  Just as in the case\
    \ of\n   attribute caching, inconsistencies may arise among the various client\n\
    \   caches.  To mitigate the effects of these inconsistencies and given\n   the\
    \ context of typical filesystem APIs, an upper time boundary is\n   maintained\
    \ on how long a client name cache entry can be kept without\n   verifying that\
    \ the entry has not been made invalid by a directory\n   change operation performed\
    \ by another client.\n   When a client is not making changes to a directory for\
    \ which there\n   exist name cache entries, the client needs to periodically fetch\n\
    \   attributes for that directory to ensure that it is not being\n   modified.\
    \  After determining that no modification has occurred, the\n   expiration time\
    \ for the associated name cache entries may be updated\n   to be the current time\
    \ plus the name cache staleness bound.\n   When a client is making changes to\
    \ a given directory, it needs to\n   determine whether there have been changes\
    \ made to the directory by\n   other clients.  It does this by using the change\
    \ attribute as\n   reported before and after the directory operation in the associated\n\
    \   change_info4 value returned for the operation.  The server is able to\n  \
    \ communicate to the client whether the change_info4 data is provided\n   atomically\
    \ with respect to the directory operation.  If the change\n   values are provided\
    \ atomically, the client is then able to compare\n   the pre-operation change\
    \ value with the change value in the client's\n   name cache.  If the comparison\
    \ indicates that the directory was\n   updated by another client, the name cache\
    \ associated with the\n   modified directory is purged from the client.  If the\
    \ comparison\n   indicates no modification, the name cache can be updated on the\n\
    \   client to reflect the directory operation and the associated timeout\n   extended.\
    \  The post-operation change value needs to be saved as the\n   basis for future\
    \ change_info4 comparisons.\n   As demonstrated by the scenario above, name caching\
    \ requires that the\n   client revalidate name cache data by inspecting the change\
    \ attribute\n   of a directory at the point when the name cache item was cached.\n\
    \   This requires that the server update the change attribute for\n   directories\
    \ when the contents of the corresponding directory is\n   modified.  For a client\
    \ to use the change_info4 information\n   appropriately and correctly, the server\
    \ must report the pre and post\n   operation change attribute values atomically.\
    \  When the server is\n   unable to report the before and after values atomically\
    \ with respect\n   to the directory operation, the server must indicate that fact\
    \ in the\n   change_info4 return value.  When the information is not atomically\n\
    \   reported, the client should not assume that other clients have not\n   changed\
    \ the directory.\n"
- title: 9.9.  Directory Caching
  contents:
  - "9.9.  Directory Caching\n   The results of READDIR operations may be used to\
    \ avoid subsequent\n   READDIR operations.  Just as in the cases of attribute\
    \ and name\n   caching, inconsistencies may arise among the various client caches.\n\
    \   To mitigate the effects of these inconsistencies, and given the\n   context\
    \ of typical filesystem APIs, the following rules should be\n   followed:\n  \
    \ o  Cached READDIR information for a directory which is not obtained\n      in\
    \ a single READDIR operation must always be a consistent snapshot\n      of directory\
    \ contents.  This is determined by using a GETATTR\n      before the first READDIR\
    \ and after the last of READDIR that\n      contributes to the cache.\n   o  An\
    \ upper time boundary is maintained to indicate the length of\n      time a directory\
    \ cache entry is considered valid before the client\n      must revalidate the\
    \ cached information.\n   The revalidation technique parallels that discussed\
    \ in the case of\n   name caching.  When the client is not changing the directory\
    \ in\n   question, checking the change attribute of the directory with GETATTR\n\
    \   is adequate.  The lifetime of the cache entry can be extended at\n   these\
    \ checkpoints.  When a client is modifying the directory, the\n   client needs\
    \ to use the change_info4 data to determine whether there\n   are other clients\
    \ modifying the directory.  If it is determined that\n   no other client modifications\
    \ are occurring, the client may update\n   its directory cache to reflect its\
    \ own changes.\n   As demonstrated previously, directory caching requires that\
    \ the\n   client revalidate directory cache data by inspecting the change\n  \
    \ attribute of a directory at the point when the directory was cached.\n   This\
    \ requires that the server update the change attribute for\n   directories when\
    \ the contents of the corresponding directory is\n   modified.  For a client to\
    \ use the change_info4 information\n   appropriately and correctly, the server\
    \ must report the pre and post\n   operation change attribute values atomically.\
    \  When the server is\n   unable to report the before and after values atomically\
    \ with respect\n   to the directory operation, the server must indicate that fact\
    \ in the\n   change_info4 return value.  When the information is not atomically\n\
    \   reported, the client should not assume that other clients have not\n   changed\
    \ the directory.\n"
- title: 10.  Minor Versioning
  contents:
  - "10.  Minor Versioning\n   To address the requirement of an NFS protocol that\
    \ can evolve as the\n   need arises, the NFS version 4 protocol contains the rules\
    \ and\n   framework to allow for future minor changes or versioning.\n   The base\
    \ assumption with respect to minor versioning is that any\n   future accepted\
    \ minor version must follow the IETF process and be\n   documented in a standards\
    \ track RFC.  Therefore, each minor version\n   number will correspond to an RFC.\
    \  Minor version zero of the NFS\n   version 4 protocol is represented by this\
    \ RFC.  The COMPOUND\n   procedure will support the encoding of the minor version\
    \ being\n   requested by the client.\n   The following items represent the basic\
    \ rules for the development of\n   minor versions.  Note that a future minor version\
    \ may decide to\n   modify or add to the following rules as part of the minor\
    \ version\n   definition.\n    1.  Procedures are not added or deleted\n     \
    \   To maintain the general RPC model, NFS version 4 minor versions\n        will\
    \ not add to or delete procedures from the NFS program.\n    2.  Minor versions\
    \ may add operations to the COMPOUND and\n        CB_COMPOUND procedures.\n  \
    \      The addition of operations to the COMPOUND and CB_COMPOUND\n        procedures\
    \ does not affect the RPC model.\n    2.1 Minor versions may append attributes\
    \ to GETATTR4args, bitmap4,\n        and GETATTR4res.\n        This allows for\
    \ the expansion of the attribute model to allow\n        for future growth or\
    \ adaptation.\n    2.2 Minor version X must append any new attributes after the\
    \ last\n        documented attribute.\n        Since attribute results are specified\
    \ as an opaque array of\n        per-attribute XDR encoded results, the complexity\
    \ of adding new\n        attributes in the midst of the current definitions will\
    \ be too\n        burdensome.\n    3.  Minor versions must not modify the structure\
    \ of an existing\n        operation's arguments or results.\n        Again the\
    \ complexity of handling multiple structure definitions\n        for a single\
    \ operation is too burdensome.  New operations should\n        be added instead\
    \ of modifying existing structures for a minor\n        version.\n        This\
    \ rule does not preclude the following adaptations in a minor\n        version.\n\
    \      o  adding bits to flag fields such as new attributes to GETATTR's\n   \
    \      bitmap4 data type\n      o  adding bits to existing attributes like ACLs\
    \ that have flag\n         words\n      o  extending enumerated types (including\
    \ NFS4ERR_*) with new\n         values\n    4.  Minor versions may not modify\
    \ the structure of existing\n        attributes.\n    5.  Minor versions may not\
    \ delete operations.\n        This prevents the potential reuse of a particular\
    \ operation\n        \"slot\" in a future minor version.\n    6.  Minor versions\
    \ may not delete attributes.\n    7.  Minor versions may not delete flag bits\
    \ or enumeration values.\n    8.  Minor versions may declare an operation as mandatory\
    \ to NOT\n        implement.\n        Specifying an operation as \"mandatory to\
    \ not implement\" is\n        equivalent to obsoleting an operation.  For the\
    \ client, it means\n        that the operation should not be sent to the server.\
    \  For the\n        server, an NFS error can be returned as opposed to \"dropping\"\
    \n        the request as an XDR decode error.  This approach allows for\n    \
    \    the obsolescence of an operation while maintaining its structure\n      \
    \  so that a future minor version can reintroduce the operation.\n    8.1 Minor\
    \ versions may declare attributes mandatory to NOT\n        implement.\n    8.2\
    \ Minor versions may declare flag bits or enumeration values as\n        mandatory\
    \ to NOT implement.\n    9.  Minor versions may downgrade features from mandatory\
    \ to\n        recommended, or recommended to optional.\n    10. Minor versions\
    \ may upgrade features from optional to recommended\n        or recommended to\
    \ mandatory.\n    11. A client and server that support minor version X must support\n\
    \        minor versions 0 (zero) through X-1 as well.\n    12. No new features\
    \ may be introduced as mandatory in a minor\n        version.\n        This rule\
    \ allows for the introduction of new functionality and\n        forces the use\
    \ of implementation experience before designating a\n        feature as mandatory.\n\
    \    13. A client MUST NOT attempt to use a stateid, filehandle, or\n        similar\
    \ returned object from the COMPOUND procedure with minor\n        version X for\
    \ another COMPOUND procedure with minor version Y,\n        where X != Y.\n"
- title: 11.  Internationalization
  contents:
  - "11.  Internationalization\n   The primary issue in which NFS version 4 needs\
    \ to deal with\n   internationalization, or I18N, is with respect to file names\
    \ and\n   other strings as used within the protocol.  The choice of string\n \
    \  representation must allow reasonable name/string access to clients\n   which\
    \ use various languages.  The UTF-8 encoding of the UCS as\n   defined by [ISO10646]\
    \ allows for this type of access and follows the\n   policy described in \"IETF\
    \ Policy on Character Sets and Languages\",\n   [RFC2277].\n   [RFC3454], otherwise\
    \ know as \"stringprep\", documents a framework for\n   using Unicode/UTF-8 in\
    \ networking protocols, so as \"to increase the\n   likelihood that string input\
    \ and string comparison work in ways that\n   make sense for typical users throughout\
    \ the world.\"  A protocol must\n   define a profile of stringprep \"in order\
    \ to fully specify the\n   processing options.\"  The remainder of this Internationalization\n\
    \   section defines the NFS version 4 stringprep profiles.  Much of\n   terminology\
    \ used for the remainder of this section comes from\n   stringprep.\n   There\
    \ are three UTF-8 string types defined for NFS version 4:\n   utf8str_cs, utf8str_cis,\
    \ and utf8str_mixed.  Separate profiles are\n   defined for each. Each profile\
    \ defines the following, as required by\n   stringprep:\n   o  The intended applicability\
    \ of the profile\n   o  The character repertoire that is the input and output\
    \ to\n      stringprep (which is Unicode 3.2 for referenced version of\n     \
    \ stringprep)\n   o  The mapping tables from stringprep used (as described in\
    \ section 3\n      of stringprep)\n   o  Any additional mapping tables specific\
    \ to the profile\n   o  The Unicode normalization used, if any (as described in\
    \ section 4\n      of stringprep)\n   o  The tables from stringprep listing of\
    \ characters that are\n      prohibited as output (as described in section 5 of\
    \ stringprep)\n   o  The bidirectional string testing used, if any (as described\
    \ in\n      section 6 of stringprep)\n   o  Any additional characters that are\
    \ prohibited as output specific\n      to the profile\n   Stringprep discusses\
    \ Unicode characters, whereas NFS version 4\n   renders UTF-8 characters.  Since\
    \ there is a one to one mapping from\n   UTF-8 to Unicode, where ever the remainder\
    \ of this document refers to\n   to Unicode, the reader should assume UTF-8.\n\
    \   Much of the text for the profiles comes from [RFC3454].\n"
- title: 11.1.  Stringprep profile for the utf8str_cs type
  contents:
  - "11.1.  Stringprep profile for the utf8str_cs type\n   Every use of the utf8str_cs\
    \ type definition in the NFS version 4\n   protocol specification follows the\
    \ profile named nfs4_cs_prep.\n"
- title: 11.1.1.  Intended applicability of the nfs4_cs_prep profile
  contents:
  - "11.1.1.  Intended applicability of the nfs4_cs_prep profile\n   The utf8str_cs\
    \ type is a case sensitive string of UTF-8 characters.\n   Its primary use in\
    \ NFS Version 4 is for naming components and\n   pathnames.  Components and pathnames\
    \ are stored on the server's\n   filesystem.  Two valid distinct UTF-8 strings\
    \ might be the same after\n   processing via the utf8str_cs profile.  If the strings\
    \ are two names\n   inside a directory, the NFS version 4 server will need to\
    \ either:\n   o  disallow the creation of a second name if it's post processed\
    \ form\n      collides with that of an existing name, or\n   o  allow the creation\
    \ of the second name, but arrange so that after\n      post processing, the second\
    \ name is different than the post\n      processed form of the first name.\n"
- title: 11.1.2.  Character repertoire of nfs4_cs_prep
  contents:
  - "11.1.2.  Character repertoire of nfs4_cs_prep\n   The nfs4_cs_prep profile uses\
    \ Unicode 3.2, as defined in stringprep's\n   Appendix A.1\n"
- title: 11.1.3.  Mapping used by nfs4_cs_prep
  contents:
  - "11.1.3.  Mapping used by nfs4_cs_prep\n   The nfs4_cs_prep profile specifies\
    \ mapping using the following tables\n   from stringprep:\n      Table B.1\n \
    \  Table B.2 is normally not part of the nfs4_cs_prep profile as it is\n   primarily\
    \ for dealing with case-insensitive comparisons.  However, if\n   the NFS version\
    \ 4 file server supports the case_insensitive\n   filesystem attribute, and if\
    \ case_insensitive is true, the NFS\n   version 4 server MUST use Table B.2 (in\
    \ addition to Table B1) when\n   processing utf8str_cs strings, and the NFS version\
    \ 4 client MUST\n   assume Table B.2 (in addition to Table B.1) are being used.\n\
    \   If the case_preserving attribute is present and set to false, then\n   the\
    \ NFS version 4 server MUST use table B.2 to map case when\n   processing utf8str_cs\
    \ strings.  Whether the server maps from lower to\n   upper case or the upper\
    \ to lower case is an implementation\n   dependency.\n"
- title: 11.1.4.  Normalization used by nfs4_cs_prep
  contents:
  - "11.1.4.  Normalization used by nfs4_cs_prep\n   The nfs4_cs_prep profile does\
    \ not specify a normalization form.  A\n   later revision of this specification\
    \ may specify a particular\n   normalization form.  Therefore, the server and\
    \ client can expect that\n   they may receive unnormalized characters within protocol\
    \ requests and\n   responses.  If the operating environment requires normalization,\
    \ then\n   the implementation must normalize utf8str_cs strings within the\n \
    \  protocol before presenting the information to an application (at the\n   client)\
    \ or local filesystem (at the server).\n"
- title: 11.1.5.  Prohibited output for nfs4_cs_prep
  contents:
  - "11.1.5.  Prohibited output for nfs4_cs_prep\n   The nfs4_cs_prep profile specifies\
    \ prohibiting using the following\n   tables from stringprep:\n      Table C.3\n\
    \      Table C.4\n      Table C.5\n      Table C.6\n      Table C.7\n      Table\
    \ C.8\n      Table C.9\n"
- title: 11.1.6.  Bidirectional output for nfs4_cs_prep
  contents:
  - "11.1.6.  Bidirectional output for nfs4_cs_prep\n   The nfs4_cs_prep profile does\
    \ not specify any checking of\n   bidirectional strings.\n"
- title: 11.2.  Stringprep profile for the utf8str_cis type
  contents:
  - "11.2.  Stringprep profile for the utf8str_cis type\n   Every use of the utf8str_cis\
    \ type definition in the NFS version 4\n   protocol specification follows the\
    \ profile named nfs4_cis_prep.\n"
- title: 11.2.1.  Intended applicability of the nfs4_cis_prep profile
  contents:
  - "11.2.1.  Intended applicability of the nfs4_cis_prep profile\n   The utf8str_cis\
    \ type is a case insensitive string of UTF-8\n   characters.  Its primary use\
    \ in NFS Version 4 is for naming NFS\n   servers.\n"
- title: 11.2.2.  Character repertoire of nfs4_cis_prep
  contents:
  - "11.2.2.  Character repertoire of nfs4_cis_prep\n   The nfs4_cis_prep profile\
    \ uses Unicode 3.2, as defined in\n   stringprep's Appendix A.1\n"
- title: 11.2.3.  Mapping used by nfs4_cis_prep
  contents:
  - "11.2.3.  Mapping used by nfs4_cis_prep\n   The nfs4_cis_prep profile specifies\
    \ mapping using the following\n   tables from stringprep:\n      Table B.1\n \
    \     Table B.2\n"
- title: 11.2.4.  Normalization used by nfs4_cis_prep
  contents:
  - "11.2.4.  Normalization used by nfs4_cis_prep\n   The nfs4_cis_prep profile specifies\
    \ using Unicode normalization form\n   KC, as described in stringprep.\n"
- title: 11.2.5.  Prohibited output for nfs4_cis_prep
  contents:
  - "11.2.5.  Prohibited output for nfs4_cis_prep\n   The nfs4_cis_prep profile specifies\
    \ prohibiting using the following\n   tables from stringprep:\n      Table C.1.2\n\
    \      Table C.2.2\n      Table C.3\n      Table C.4\n      Table C.5\n      Table\
    \ C.6\n      Table C.7\n      Table C.8\n      Table C.9\n"
- title: 11.2.6.  Bidirectional output for nfs4_cis_prep
  contents:
  - "11.2.6.  Bidirectional output for nfs4_cis_prep\n   The nfs4_cis_prep profile\
    \ specifies checking bidirectional strings as\n   described in stringprep's section\
    \ 6.\n"
- title: 11.3.  Stringprep profile for the utf8str_mixed type
  contents:
  - "11.3.  Stringprep profile for the utf8str_mixed type\n   Every use of the utf8str_mixed\
    \ type definition in the NFS version 4\n   protocol specification follows the\
    \ profile named nfs4_mixed_prep.\n"
- title: 11.3.1.  Intended applicability of the nfs4_mixed_prep profile
  contents:
  - "11.3.1.  Intended applicability of the nfs4_mixed_prep profile\n   The utf8str_mixed\
    \ type is a string of UTF-8 characters, with a prefix\n   that is case sensitive,\
    \ a separator equal to '@', and a suffix that\n   is fully qualified domain name.\
    \  Its primary use in NFS Version 4 is\n   for naming principals identified in\
    \ an Access Control Entry.\n"
- title: 11.3.2.  Character repertoire of nfs4_mixed_prep
  contents:
  - "11.3.2.  Character repertoire of nfs4_mixed_prep\n   The nfs4_mixed_prep profile\
    \ uses Unicode 3.2, as defined in\n   stringprep's Appendix A.1\n"
- title: 11.3.3.  Mapping used by nfs4_cis_prep
  contents:
  - "11.3.3.  Mapping used by nfs4_cis_prep\n   For the prefix and the separator of\
    \ a utf8str_mixed string, the\n   nfs4_mixed_prep profile specifies mapping using\
    \ the following table\n   from stringprep:\n      Table B.1\n   For the suffix\
    \ of a utf8str_mixed string, the nfs4_mixed_prep profile\n   specifies mapping\
    \ using the following tables from stringprep:\n      Table B.1\n      Table B.2\n"
- title: 11.3.4.  Normalization used by nfs4_mixed_prep
  contents:
  - "11.3.4.  Normalization used by nfs4_mixed_prep\n   The nfs4_mixed_prep profile\
    \ specifies using Unicode normalization\n   form KC, as described in stringprep.\n"
- title: 11.3.5.  Prohibited output for nfs4_mixed_prep
  contents:
  - "11.3.5.  Prohibited output for nfs4_mixed_prep\n   The nfs4_mixed_prep profile\
    \ specifies prohibiting using the following\n   tables from stringprep:\n    \
    \  Table C.1.2\n      Table C.2.2\n      Table C.3\n      Table C.4\n      Table\
    \ C.5\n      Table C.6\n      Table C.7\n      Table C.8\n      Table C.9\n"
- title: 11.3.6.  Bidirectional output for nfs4_mixed_prep
  contents:
  - "11.3.6.  Bidirectional output for nfs4_mixed_prep\n   The nfs4_mixed_prep profile\
    \ specifies checking bidirectional strings\n   as described in stringprep's section\
    \ 6.\n"
- title: 11.4.  UTF-8 Related Errors
  contents:
  - "11.4.  UTF-8 Related Errors\n   Where the client sends an invalid UTF-8 string,\
    \ the server should\n   return an NFS4ERR_INVAL error.  This includes cases in\
    \ which\n   inappropriate prefixes are detected and where the count includes\n\
    \   trailing bytes that do not constitute a full UCS character.\n   Where the\
    \ client supplied string is valid UTF-8 but contains\n   characters that are not\
    \ supported by the server as a value for that\n   string (e.g., names containing\
    \ characters that have more than two\n   octets on a filesystem that supports\
    \ Unicode characters only), the\n   server should return an NFS4ERR_BADCHAR error.\n\
    \   Where a UTF-8 string is used as a file name, and the filesystem,\n   while\
    \ supporting all of the characters within the name, does not\n   allow that particular\
    \ name to be used, the server should return the\n   error NFS4ERR_BADNAME.  This\
    \ includes situations in which the server\n   filesystem imposes a normalization\
    \ constraint on name strings, but\n   will also include such situations as filesystem\
    \ prohibitions of \".\"\n   and \"..\" as file names for certain operations, and\
    \ other such\n   constraints.\n"
- title: 12.  Error Definitions
  contents:
  - "12.  Error Definitions\n   NFS error numbers are assigned to failed operations\
    \ within a compound\n   request.  A compound request contains a number of NFS\
    \ operations that\n   have their results encoded in sequence in a compound reply.\
    \  The\n   results of successful operations will consist of an NFS4_OK status\n\
    \   followed by the encoded results of the operation.  If an NFS\n   operation\
    \ fails, an error status will be entered in the reply and the\n   compound request\
    \ will be terminated.\n   A description of each defined error follows:\n   NFS4_OK\
    \               Indicates the operation completed successfully.\n   NFS4ERR_ACCESS\
    \        Permission denied. The caller does not have the\n                   \
    \      correct permission to perform the requested\n                         operation.\
    \ Contrast this with NFS4ERR_PERM,\n                         which restricts itself\
    \ to owner or privileged\n                         user permission failures.\n\
    \   NFS4ERR_ATTRNOTSUPP   An attribute specified is not supported by the\n   \
    \                      server.  Does not apply to the GETATTR\n              \
    \           operation.\n   NFS4ERR_ADMIN_REVOKED Due to administrator intervention,\
    \ the\n                         lockowner's record locks, share reservations,\n\
    \                         and delegations have been revoked by the\n         \
    \                server.\n   NFS4ERR_BADCHAR       A UTF-8 string contains a character\
    \ which is\n                         not supported by the server in the context\
    \ in\n                         which it being used.\n   NFS4ERR_BAD_COOKIE   \
    \ READDIR cookie is stale.\n   NFS4ERR_BADHANDLE     Illegal NFS filehandle. The\
    \ filehandle failed\n                         internal consistency checks.\n \
    \  NFS4ERR_BADNAME       A name string in a request consists of valid\n      \
    \                   UTF-8 characters supported by the server but\n           \
    \              the name is not supported by the server as a\n                \
    \         valid name for current operation.\n   NFS4ERR_BADOWNER      An owner,\
    \ owner_group, or ACL attribute value\n                         can not be translated\
    \ to local representation.\n   NFS4ERR_BADTYPE       An attempt was made to create\
    \ an object of a\n                         type not supported by the server.\n\
    \   NFS4ERR_BAD_RANGE     The range for a LOCK, LOCKT, or LOCKU operation\n  \
    \                       is not appropriate to the allowable range of\n       \
    \                  offsets for the server.\n   NFS4ERR_BAD_SEQID     The sequence\
    \ number in a locking request is\n                         neither the next expected\
    \ number or the last\n                         number processed.\n   NFS4ERR_BAD_STATEID\
    \   A stateid generated by the current server\n                         instance,\
    \ but which does not designate any\n                         locking state (either\
    \ current or superseded)\n                         for a current lockowner-file\
    \ pair, was used.\n   NFS4ERR_BADXDR        The server encountered an XDR decoding\
    \ error\n                         while processing an operation.\n   NFS4ERR_CLID_INUSE\
    \    The SETCLIENTID operation has found that a\n                         client\
    \ id is already in use by another client.\n   NFS4ERR_DEADLOCK      The server\
    \ has been able to determine a file\n                         locking deadlock\
    \ condition for a blocking lock\n                         request.\n   NFS4ERR_DELAY\
    \         The server initiated the request, but was not\n                    \
    \     able to complete it in a timely fashion. The\n                         client\
    \ should wait and then try the request\n                         with a new RPC\
    \ transaction ID.  For example,\n                         this error should be\
    \ returned from a server\n                         that supports hierarchical\
    \ storage and receives\n                         a request to process a file that\
    \ has been\n                         migrated. In this case, the server should\
    \ start\n                         the immigration process and respond to client\n\
    \                         with this error.  This error may also occur\n      \
    \                   when a necessary delegation recall makes\n               \
    \          processing a request in a timely fashion\n                        \
    \ impossible.\n   NFS4ERR_DENIED        An attempt to lock a file is denied. \
    \ Since\n                         this may be a temporary condition, the client\n\
    \                         is encouraged to retry the lock request until\n    \
    \                     the lock is accepted.\n   NFS4ERR_DQUOT         Resource\
    \ (quota) hard limit exceeded. The\n                         user's resource limit\
    \ on the server has been\n                         exceeded.\n   NFS4ERR_EXIST\
    \         File exists. The file specified already exists.\n   NFS4ERR_EXPIRED\
    \       A lease has expired that is being used in the\n                      \
    \   current operation.\n   NFS4ERR_FBIG          File too large. The operation\
    \ would have caused\n                         a file to grow beyond the server's\
    \ limit.\n   NFS4ERR_FHEXPIRED     The filehandle provided is volatile and has\n\
    \                         expired at the server.\n   NFS4ERR_FILE_OPEN     The\
    \ operation can not be successfully processed\n                         because\
    \ a file involved in the operation is\n                         currently open.\n\
    \   NFS4ERR_GRACE         The server is in its recovery or grace period\n    \
    \                     which should match the lease period of the\n           \
    \              server.\n   NFS4ERR_INVAL         Invalid argument or unsupported\
    \ argument for an\n                         operation. Two examples are attempting\
    \ a\n                         READLINK on an object other than a symbolic\n  \
    \                       link or specifying a value for an enum field\n       \
    \                  that is not defined in the protocol (e.g.,\n              \
    \           nfs_ftype4).\n   NFS4ERR_IO            I/O error. A hard error (for\
    \ example, a disk\n                         error) occurred while processing the\
    \ requested\n                         operation.\n   NFS4ERR_ISDIR         Is\
    \ a directory. The caller specified a\n                         directory in a\
    \ non-directory operation.\n   NFS4ERR_LEASE_MOVED   A lease being renewed is\
    \ associated with a\n                         filesystem that has been migrated\
    \ to a new\n                         server.\n   NFS4ERR_LOCKED        A read\
    \ or write operation was attempted on a\n                         locked file.\n\
    \   NFS4ERR_LOCK_NOTSUPP  Server does not support atomic upgrade or\n        \
    \                 downgrade of locks.\n   NFS4ERR_LOCK_RANGE    A lock request\
    \ is operating on a sub-range of a\n                         current lock for\
    \ the lock owner and the server\n                         does not support this\
    \ type of request.\n   NFS4ERR_LOCKS_HELD    A CLOSE was attempted and file locks\
    \ would\n                         exist after the CLOSE.\n   NFS4ERR_MINOR_VERS_MISMATCH\n\
    \                         The server has received a request that\n           \
    \              specifies an unsupported minor version.  The\n                \
    \         server must return a COMPOUND4res with a zero\n                    \
    \     length operations result array.\n   NFS4ERR_MLINK         Too many hard\
    \ links.\n   NFS4ERR_MOVED         The filesystem which contains the current\n\
    \                         filehandle object has been relocated or\n          \
    \               migrated to another server.  The client may\n                \
    \         obtain the new filesystem location by obtaining\n                  \
    \       the \"fs_locations\" attribute for the current\n                     \
    \    filehandle.  For further discussion, refer to\n                         the\
    \ section \"Filesystem Migration or\n                         Relocation\".\n\
    \   NFS4ERR_NAMETOOLONG   The filename in an operation was too long.\n   NFS4ERR_NOENT\
    \         No such file or directory. The file or\n                         directory\
    \ name specified does not exist.\n   NFS4ERR_NOFILEHANDLE  The logical current\
    \ filehandle value (or, in\n                         the case of RESTOREFH, the\
    \ saved filehandle\n                         value) has not been set properly.\
    \  This may be\n                         a result of a malformed COMPOUND operation\n\
    \                         (i.e., no PUTFH or PUTROOTFH before an\n           \
    \              operation that requires the current filehandle\n              \
    \           be set).\n   NFS4ERR_NO_GRACE      A reclaim of client state has fallen\
    \ outside of\n                         the grace period of the server.  As a result,\n\
    \                         the server can not guarantee that conflicting\n    \
    \                     state has not been provided to another client.\n   NFS4ERR_NOSPC\
    \         No space left on device. The operation would\n                     \
    \    have caused the server's filesystem to exceed\n                         its\
    \ limit.\n   NFS4ERR_NOTDIR        Not a directory. The caller specified a non-\n\
    \                         directory in a directory operation.\n   NFS4ERR_NOTEMPTY\
    \      An attempt was made to remove a directory that\n                      \
    \   was not empty.\n   NFS4ERR_NOTSUPP       Operation is not supported.\n   NFS4ERR_NOT_SAME\
    \      This error is returned by the VERIFY operation\n                      \
    \   to signify that the attributes compared were\n                         not\
    \ the same as provided in the client's\n                         request.\n  \
    \ NFS4ERR_NXIO          I/O error. No such device or address.\n   NFS4ERR_OLD_STATEID\
    \   A stateid which designates the locking state\n                         for\
    \ a lockowner-file at an earlier time was\n                         used.\n  \
    \ NFS4ERR_OPENMODE      The client attempted a READ, WRITE, LOCK or\n        \
    \                 SETATTR operation not sanctioned by the stateid\n          \
    \               passed (e.g., writing to a file opened only for\n            \
    \             read).\n   NFS4ERR_OP_ILLEGAL    An illegal operation value has\
    \ been specified\n                         in the argop field of a COMPOUND or\
    \ CB_COMPOUND\n                         procedure.\n   NFS4ERR_PERM          Not\
    \ owner. The operation was not allowed\n                         because the caller\
    \ is either not a privileged\n                         user (root) or not the\
    \ owner of the target of\n                         the operation.\n   NFS4ERR_RECLAIM_BAD\
    \   The reclaim provided by the client does not\n                         match\
    \ any of the server's state consistency\n                         checks and is\
    \ bad.\n   NFS4ERR_RECLAIM_CONFLICT\n                         The reclaim provided\
    \ by the client has\n                         encountered a conflict and can not\
    \ be provided.\n                         Potentially indicates a misbehaving client.\n\
    \   NFS4ERR_RESOURCE      For the processing of the COMPOUND procedure,\n    \
    \                     the server may exhaust available resources and\n       \
    \                  can not continue processing operations within\n           \
    \              the COMPOUND procedure.  This error will be\n                 \
    \        returned from the server in those instances of\n                    \
    \     resource exhaustion related to the processing\n                        \
    \ of the COMPOUND procedure.\n   NFS4ERR_RESTOREFH     The RESTOREFH operation\
    \ does not have a saved\n                         filehandle (identified by SAVEFH)\
    \ to operate\n                         upon.\n   NFS4ERR_ROFS          Read-only\
    \ filesystem. A modifying operation was\n                         attempted on\
    \ a read-only filesystem.\n   NFS4ERR_SAME          This error is returned by\
    \ the NVERIFY operation\n                         to signify that the attributes\
    \ compared were\n                         the same as provided in the client's\
    \ request.\n   NFS4ERR_SERVERFAULT   An error occurred on the server which does\
    \ not\n                         map to any of the legal NFS version 4 protocol\n\
    \                         error values.  The client should translate this\n  \
    \                       into an appropriate error.  UNIX clients may\n       \
    \                  choose to translate this to EIO.\n   NFS4ERR_SHARE_DENIED \
    \ An attempt to OPEN a file with a share\n                         reservation\
    \ has failed because of a share\n                         conflict.\n   NFS4ERR_STALE\
    \         Invalid filehandle. The filehandle given in the\n                  \
    \       arguments was invalid. The file referred to by\n                     \
    \    that filehandle no longer exists or access to\n                         it\
    \ has been revoked.\n   NFS4ERR_STALE_CLIENTID A clientid not recognized by the\
    \ server was\n                          used in a locking or SETCLIENTID_CONFIRM\n\
    \                          request.\n   NFS4ERR_STALE_STATEID A stateid generated\
    \ by an earlier server\n                         instance was used.\n   NFS4ERR_SYMLINK\
    \       The current filehandle provided for a LOOKUP is\n                    \
    \     not a directory but a symbolic link.  Also used\n                      \
    \   if the final component of the OPEN path is a\n                         symbolic\
    \ link.\n   NFS4ERR_TOOSMALL      The encoded response to a READDIR request\n\
    \                         exceeds the size limit set by the initial\n        \
    \                 request.\n   NFS4ERR_WRONGSEC      The security mechanism being\
    \ used by the client\n                         for the operation does not match\
    \ the server's\n                         security policy.  The client should change\
    \ the\n                         security mechanism being used and retry the\n\
    \                         operation.\n   NFS4ERR_XDEV          Attempt to do an\
    \ operation between different\n                         fsids.\n"
- title: 13.  NFS version 4 Requests
  contents:
  - "13.  NFS version 4 Requests\n   For the NFS version 4 RPC program, there are\
    \ two traditional RPC\n   procedures: NULL and COMPOUND.  All other functionality\
    \ is defined as\n   a set of operations and these operations are defined in normal\n\
    \   XDR/RPC syntax and semantics.  However, these operations are\n   encapsulated\
    \ within the COMPOUND procedure.  This requires that the\n   client combine one\
    \ or more of the NFS version 4 operations into a\n   single request.\n   The NFS4_CALLBACK\
    \ program is used to provide server to client\n   signaling and is constructed\
    \ in a similar fashion as the NFS version\n   4 program.  The procedures CB_NULL\
    \ and CB_COMPOUND are defined in the\n   same way as NULL and COMPOUND are within\
    \ the NFS program.  The\n   CB_COMPOUND request also encapsulates the remaining\
    \ operations of the\n   NFS4_CALLBACK program.  There is no predefined RPC program\
    \ number for\n   the NFS4_CALLBACK program.  It is up to the client to specify\
    \ a\n   program number in the \"transient\" program range.  The program and\n\
    \   port number of the NFS4_CALLBACK program are provided by the client\n   as\
    \ part of the SETCLIENTID/SETCLIENTID_CONFIRM sequence. The program\n   and port\
    \ can be changed by another SETCLIENTID/SETCLIENTID_CONFIRM\n   sequence, and\
    \ it is possible to use the sequence to change them\n   within a client incarnation\
    \ without removing relevant leased client\n   state.\n"
- title: 13.1.  Compound Procedure
  contents:
  - "13.1.  Compound Procedure\n   The COMPOUND procedure provides the opportunity\
    \ for better\n   performance within high latency networks.  The client can avoid\n\
    \   cumulative latency of multiple RPCs by combining multiple dependent\n   operations\
    \ into a single COMPOUND procedure.  A compound operation\n   may provide for\
    \ protocol simplification by allowing the client to\n   combine basic procedures\
    \ into a single request that is customized for\n   the client's environment.\n\
    \   The CB_COMPOUND procedure precisely parallels the features of\n   COMPOUND\
    \ as described above.\n   The basic structure of the COMPOUND procedure is:\n\
    \   +-----+--------------+--------+-----------+-----------+-----------+--\n  \
    \ | tag | minorversion | numops | op + args | op + args | op + args |\n   +-----+--------------+--------+-----------+-----------+-----------+--\n\
    \   and the reply's structure is:\n      +------------+-----+--------+-----------------------+--\n\
    \      |last status | tag | numres | status + op + results |\n      +------------+-----+--------+-----------------------+--\n\
    \   The numops and numres fields, used in the depiction above, represent\n   the\
    \ count for the counted array encoding use to signify the number of\n   arguments\
    \ or results encoded in the request and response.  As per the\n   XDR encoding,\
    \ these counts must match exactly the number of operation\n   arguments or results\
    \ encoded.\n"
- title: 13.2.  Evaluation of a Compound Request
  contents:
  - "13.2.  Evaluation of a Compound Request\n   The server will process the COMPOUND\
    \ procedure by evaluating each of\n   the operations within the COMPOUND procedure\
    \ in order.  Each\n   component operation consists of a 32 bit operation code,\
    \ followed by\n   the argument of length determined by the type of operation.\
    \ The\n   results of each operation are encoded in sequence into a reply\n   buffer.\
    \  The results of each operation are preceded by the opcode and\n   a status code\
    \ (normally zero).  If an operation results in a non-zero\n   status code, the\
    \ status will be encoded and evaluation of the\n   compound sequence will halt\
    \ and the reply will be returned.  Note\n   that evaluation stops even in the\
    \ event of \"non error\" conditions\n   such as NFS4ERR_SAME.\n   There are no\
    \ atomicity requirements for the operations contained\n   within the COMPOUND\
    \ procedure.  The operations being evaluated as\n   part of a COMPOUND request\
    \ may be evaluated simultaneously with other\n   COMPOUND requests that the server\
    \ receives.\n   It is the client's responsibility for recovering from any partially\n\
    \   completed COMPOUND procedure.  Partially completed COMPOUND\n   procedures\
    \ may occur at any point due to errors such as\n   NFS4ERR_RESOURCE and NFS4ERR_DELAY.\
    \  This may occur even given an\n   otherwise valid operation string.  Further,\
    \ a server reboot which\n   occurs in the middle of processing a COMPOUND procedure\
    \ may leave the\n   client with the difficult task of determining how far COMPOUND\n\
    \   processing has proceeded.  Therefore, the client should avoid overly\n   complex\
    \ COMPOUND procedures in the event of the failure of an\n   operation within the\
    \ procedure.\n   Each operation assumes a \"current\" and \"saved\" filehandle\
    \ that is\n   available as part of the execution context of the compound request.\n\
    \   Operations may set, change, or return the current filehandle.  The\n   \"\
    saved\" filehandle is used for temporary storage of a filehandle\n   value and\
    \ as operands for the RENAME and LINK operations.\n"
- title: 13.3.  Synchronous Modifying Operations
  contents:
  - "13.3.  Synchronous Modifying Operations\n   NFS version 4 operations that modify\
    \ the filesystem are synchronous.\n   When an operation is successfully completed\
    \ at the server, the client\n   can depend that any data associated with the request\
    \ is now on stable\n   storage (the one exception is in the case of the file data\
    \ in a WRITE\n   operation with the UNSTABLE option specified).\n   This implies\
    \ that any previous operations within the same compound\n   request are also reflected\
    \ in stable storage.  This behavior enables\n   the client's ability to recover\
    \ from a partially executed compound\n   request which may resulted from the failure\
    \ of the server.  For\n   example, if a compound request contains operations A\
    \ and B and the\n   server is unable to send a response to the client, depending\
    \ on the\n   progress the server made in servicing the request the result of both\n\
    \   operations may be reflected in stable storage or just operation A may\n  \
    \ be reflected.  The server must not have just the results of operation\n   B\
    \ in stable storage.\n"
- title: 13.4.  Operation Values
  contents:
  - "13.4.  Operation Values\n   The operations encoded in the COMPOUND procedure\
    \ are identified by\n   operation values.  To avoid overlap with the RPC procedure\
    \ numbers,\n   operations 0 (zero) and 1 are not defined.  Operation 2 is not\n\
    \   defined but reserved for future use with minor versioning.\n"
- title: 14.  NFS version 4 Procedures
  contents:
  - '14.  NFS version 4 Procedures

    '
- title: '14.1.  Procedure 0: NULL - No Operation'
  contents:
  - "14.1.  Procedure 0: NULL - No Operation\n   SYNOPSIS\n      <null>\n   ARGUMENT\n\
    \      void;\n   RESULT\n      void;\n   DESCRIPTION\n      Standard NULL procedure.\
    \  Void argument, void response.  This\n      procedure has no functionality associated\
    \ with it.  Because of\n      this it is sometimes used to measure the overhead\
    \ of processing a\n      service request.  Therefore, the server should ensure\
    \ that no\n      unnecessary work is done in servicing this procedure.\n   ERRORS\n\
    \      None.\n"
- title: '14.2.  Procedure 1: COMPOUND - Compound Operations'
  contents:
  - "14.2.  Procedure 1: COMPOUND - Compound Operations\n   SYNOPSIS\n     compoundargs\
    \ -> compoundres\n   ARGUMENT\n     union nfs_argop4 switch (nfs_opnum4 argop)\
    \ {\n             case <OPCODE>: <argument>;\n             ...\n     };\n    \
    \ struct COMPOUND4args {\n             utf8str_cs      tag;\n             uint32_t\
    \        minorversion;\n             nfs_argop4      argarray<>;\n     };\n  \
    \ RESULT\n     union nfs_resop4 switch (nfs_opnum4 resop){\n             case\
    \ <OPCODE>: <result>;\n             ...\n     };\n     struct COMPOUND4res {\n\
    \             nfsstat4        status;\n             utf8str_cs      tag;\n   \
    \          nfs_resop4      resarray<>;\n     };\n   DESCRIPTION\n   The COMPOUND\
    \ procedure is used to combine one or more of the NFS\n   operations into a single\
    \ RPC request.  The main NFS RPC program has\n   two main procedures: NULL and\
    \ COMPOUND.  All other operations use the\n   COMPOUND procedure as a wrapper.\n\
    \   The COMPOUND procedure is used to combine individual operations into\n   a\
    \ single RPC request.  The server interprets each of the operations\n   in turn.\
    \  If an operation is executed by the server and the status of\n   that operation\
    \ is NFS4_OK, then the next operation in the COMPOUND\n   procedure is executed.\
    \  The server continues this process until there\n   are no more operations to\
    \ be executed or one of the operations has a\n   status value other than NFS4_OK.\n\
    \   In the processing of the COMPOUND procedure, the server may find that\n  \
    \ it does not have the available resources to execute any or all of the\n   operations\
    \ within the COMPOUND sequence.  In this case, the error\n   NFS4ERR_RESOURCE\
    \ will be returned for the particular operation within\n   the COMPOUND procedure\
    \ where the resource exhaustion occurred.  This\n   assumes that all previous\
    \ operations within the COMPOUND sequence\n   have been evaluated successfully.\
    \  The results for all of the\n   evaluated operations must be returned to the\
    \ client.\n   The server will generally choose between two methods of decoding\
    \ the\n   client's request.  The first would be the traditional one-pass XDR\n\
    \   decode, in which decoding of the entire COMPOUND precedes execution\n   of\
    \ any operation within it.  If there is an XDR decoding error in\n   this case,\
    \ an RPC XDR decode error would be returned.  The second\n   method would be to\
    \ make an initial pass to decode the basic COMPOUND\n   request and then to XDR\
    \ decode each of the individual operations, as\n   the server is ready to execute\
    \ it.  In this case, the server may\n   encounter an XDR decode error during such\
    \ an operation decode, after\n   previous operations within the COMPOUND have\
    \ been executed.  In this\n   case, the server would return the error NFS4ERR_BADXDR\
    \ to signify the\n   decode error.\n   The COMPOUND arguments contain a \"minorversion\"\
    \ field.  The initial\n   and default value for this field is 0 (zero).  This\
    \ field will be\n   used by future minor versions such that the client can communicate\
    \ to\n   the server what minor version is being requested.  If the server\n  \
    \ receives a COMPOUND procedure with a minorversion field value that it\n   does\
    \ not support, the server MUST return an error of\n   NFS4ERR_MINOR_VERS_MISMATCH\
    \ and a zero length resultdata array.\n   Contained within the COMPOUND results\
    \ is a \"status\" field.  If the\n   results array length is non-zero, this status\
    \ must be equivalent to\n   the status of the last operation that was executed\
    \ within the\n   COMPOUND procedure.  Therefore, if an operation incurred an error\n\
    \   then the \"status\" value will be the same error value as is being\n   returned\
    \ for the operation that failed.\n   Note that operations, 0 (zero) and 1 (one)\
    \ are not defined for the\n   COMPOUND procedure.  Operation 2 is not defined\
    \ but reserved for\n   future definition and use with minor versioning.  If the\
    \ server\n   receives a operation array that contains operation 2 and the\n  \
    \ minorversion field has a value of 0 (zero), an error of\n   NFS4ERR_OP_ILLEGAL,\
    \ as described in the next paragraph, is returned\n   to the client.  If an operation\
    \ array contains an operation 2 and the\n   minorversion field is non-zero and\
    \ the server does not support the\n   minor version, the server returns an error\
    \ of\n   NFS4ERR_MINOR_VERS_MISMATCH.  Therefore, the\n   NFS4ERR_MINOR_VERS_MISMATCH\
    \ error takes precedence over all other\n   errors.\n   It is possible that the\
    \ server receives a request that contains an\n   operation that is less than the\
    \ first legal operation (OP_ACCESS) or\n   greater than the last legal operation\
    \ (OP_RELEASE_LOCKOWNER).\n   In this case, the server's response will encode\
    \ the opcode OP_ILLEGAL\n   rather than the illegal opcode of the request. The\
    \ status field in\n   the ILLEGAL return results will set to NFS4ERR_OP_ILLEGAL.\
    \  The\n   COMPOUND procedure's return results will also be NFS4ERR_OP_ILLEGAL.\n\
    \   The definition of the \"tag\" in the request is left to the\n   implementor.\
    \  It may be used to summarize the content of the compound\n   request for the\
    \ benefit of packet sniffers and engineers debugging\n   implementations.  However,\
    \ the value of \"tag\" in the response SHOULD\n   be the same value as provided\
    \ in the request.  This applies to the\n   tag field of the CB_COMPOUND procedure\
    \ as well.\n   IMPLEMENTATION\n   Since an error of any type may occur after only\
    \ a portion of the\n   operations have been evaluated, the client must be prepared\
    \ to\n   recover from any failure.  If the source of an NFS4ERR_RESOURCE error\n\
    \   was a complex or lengthy set of operations, it is likely that if the\n   number\
    \ of operations were reduced the server would be able to\n   evaluate them successfully.\
    \  Therefore, the client is responsible for\n   dealing with this type of complexity\
    \ in recovery.\n   ERRORS\n   All errors defined in the protocol\n"
- title: '14.2.1.  Operation 3: ACCESS - Check Access Rights'
  contents:
  - "14.2.1.  Operation 3: ACCESS - Check Access Rights\n   SYNOPSIS\n     (cfh),\
    \ accessreq -> supported, accessrights\n   ARGUMENT\n     const ACCESS4_READ \
    \     = 0x00000001;\n     const ACCESS4_LOOKUP    = 0x00000002;\n     const ACCESS4_MODIFY\
    \    = 0x00000004;\n     const ACCESS4_EXTEND    = 0x00000008;\n     const ACCESS4_DELETE\
    \    = 0x00000010;\n     const ACCESS4_EXECUTE   = 0x00000020;\n     struct ACCESS4args\
    \ {\n             /* CURRENT_FH: object */\n             uint32_t        access;\n\
    \     };\n   RESULT\n     struct ACCESS4resok {\n             uint32_t       \
    \ supported;\n             uint32_t        access;\n     };\n     union ACCESS4res\
    \ switch (nfsstat4 status) {\n      case NFS4_OK:\n              ACCESS4resok\
    \   resok4;\n      default:\n              void;\n     };\n   DESCRIPTION\n  \
    \ ACCESS determines the access rights that a user, as identified by the\n   credentials\
    \ in the RPC request, has with respect to the file system\n   object specified\
    \ by the current filehandle.  The client encodes the\n   set of access rights\
    \ that are to be checked in the bit mask \"access\".\n   The server checks the\
    \ permissions encoded in the bit mask.  If a\n   status of NFS4_OK is returned,\
    \ two bit masks are included in the\n   response.  The first, \"supported\", represents\
    \ the access rights for\n   which the server can verify reliably.  The second,\
    \ \"access\",\n   represents the access rights available to the user for the filehandle\n\
    \   provided.  On success, the current filehandle retains its value.\n   Note\
    \ that the supported field will contain only as many values as\n   were originally\
    \ sent in the arguments.  For example, if the client\n   sends an ACCESS operation\
    \ with only the ACCESS4_READ value set and\n   the server supports this value,\
    \ the server will return only\n   ACCESS4_READ even if it could have reliably\
    \ checked other values.\n   The results of this operation are necessarily advisory\
    \ in nature.  A\n   return status of NFS4_OK and the appropriate bit set in the\
    \ bit mask\n   does not imply that such access will be allowed to the file system\n\
    \   object in the future. This is because access rights can be revoked by\n  \
    \ the server at any time.\n   The following access permissions may be requested:\n\
    \   ACCESS4_READ    Read data from file or read a directory.\n   ACCESS4_LOOKUP\
    \  Look up a name in a directory (no meaning for non-\n                   directory\
    \ objects).\n   ACCESS4_MODIFY  Rewrite existing file data or modify existing\n\
    \                   directory entries.\n   ACCESS4_EXTEND  Write new data or add\
    \ directory entries.\n   ACCESS4_DELETE  Delete an existing directory entry.\n\
    \   ACCESS4_EXECUTE Execute file (no meaning for a directory).\n   On success,\
    \ the current filehandle retains its value.\n   IMPLEMENTATION\n   In general,\
    \ it is not sufficient for the client to attempt to deduce\n   access permissions\
    \ by inspecting the uid, gid, and mode fields in the\n   file attributes or by\
    \ attempting to interpret the contents of the ACL\n   attribute.  This is because\
    \ the server may perform uid or gid mapping\n   or enforce additional access control\
    \ restrictions.  It is also\n   possible that the server may not be in the same\
    \ ID space as the\n   client.  In these cases (and perhaps others), the client\
    \ can not\n   reliably perform an access check with only current file attributes.\n\
    \   In the NFS version 2 protocol, the only reliable way to determine\n   whether\
    \ an operation was allowed was to try it and see if it\n   succeeded or failed.\
    \  Using the ACCESS operation in the NFS version 4\n   protocol, the client can\
    \ ask the server to indicate whether or not\n   one or more classes of operations\
    \ are permitted.  The ACCESS\n   operation is provided to allow clients to check\
    \ before doing a series\n   of operations which will result in an access failure.\
    \  The OPEN\n   operation provides a point where the server can verify access\
    \ to the\n   file object and method to return that information to the client.\
    \  The\n   ACCESS operation is still useful for directory operations or for use\n\
    \   in the case the UNIX API \"access\" is used on the client.\n   The information\
    \ returned by the server in response to an ACCESS call\n   is not permanent. \
    \ It was correct at the exact time that the server\n   performed the checks, but\
    \ not necessarily afterwards.  The server can\n   revoke access permission at\
    \ any time.\n   The client should use the effective credentials of the user to\
    \ build\n   the authentication information in the ACCESS request used to\n   determine\
    \ access rights.  It is the effective user and group\n   credentials that are\
    \ used in subsequent read and write operations.\n   Many implementations do not\
    \ directly support the ACCESS4_DELETE\n   permission.  Operating systems like\
    \ UNIX will ignore the\n   ACCESS4_DELETE bit if set on an access request on a\
    \ non-directory\n   object.  In these systems, delete permission on a file is\
    \ determined\n   by the access permissions on the directory in which the file\
    \ resides,\n   instead of being determined by the permissions of the file itself.\n\
    \   Therefore, the mask returned enumerating which access rights can be\n   determined\
    \ will have the ACCESS4_DELETE value set to 0.  This\n   indicates to the client\
    \ that the server was unable to check that\n   particular access right.  The ACCESS4_DELETE\
    \ bit in the access mask\n   returned will then be ignored by the client.\n  \
    \ ERRORS\n      NFS4ERR_ACCESS\n      NFS4ERR_BADHANDLE\n      NFS4ERR_BADXDR\n\
    \      NFS4ERR_DELAY\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n      NFS4ERR_IO\n\
    \      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_RESOURCE\n   \
    \   NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n"
- title: '14.2.2.  Operation 4: CLOSE - Close File'
  contents:
  - "14.2.2.  Operation 4: CLOSE - Close File\n   SYNOPSIS\n     (cfh), seqid, open_stateid\
    \ -> open_stateid\n   ARGUMENT\n     struct CLOSE4args {\n             /* CURRENT_FH:\
    \ object */\n             seqid4          seqid\n             stateid4       \
    \ open_stateid;\n     };\n   RESULT\n     union CLOSE4res switch (nfsstat4 status)\
    \ {\n      case NFS4_OK:\n              stateid4       open_stateid;\n      default:\n\
    \              void;\n     };\n   DESCRIPTION\n   The CLOSE operation releases\
    \ share reservations for the regular or\n   named attribute file as specified\
    \ by the current filehandle.  The\n   share reservations and other state information\
    \ released at the server\n   as a result of this CLOSE is only associated with\
    \ the supplied\n   stateid.  The sequence id provides for the correct ordering.\
    \ State\n   associated with other OPENs is not affected.\n   If record locks are\
    \ held, the client SHOULD release all locks before\n   issuing a CLOSE.  The server\
    \ MAY free all outstanding locks on CLOSE\n   but some servers may not support\
    \ the CLOSE of a file that still has\n   record locks held.  The server MUST return\
    \ failure if any locks would\n   exist after the CLOSE.\n   On success, the current\
    \ filehandle retains its value.\n   IMPLEMENTATION\n   Even though CLOSE returns\
    \ a stateid, this stateid is not useful to\n   the client and should be treated\
    \ as deprecated.  CLOSE \"shuts down\"\n   the state associated with all OPENs\
    \ for the file by a single\n   open_owner.  As noted above, CLOSE will either\
    \ release all file\n   locking state or return an error.  Therefore, the stateid\
    \ returned by\n   CLOSE is not useful for operations that follow.\n   ERRORS\n\
    \      NFS4ERR_ADMIN_REVOKED\n      NFS4ERR_BADHANDLE\n      NFS4ERR_BAD_SEQID\n\
    \      NFS4ERR_BAD_STATEID\n      NFS4ERR_BADXDR\n      NFS4ERR_DELAY\n      NFS4ERR_EXPIRED\n\
    \      NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n      NFS4ERR_ISDIR\n      NFS4ERR_LEASE_MOVED\n\
    \      NFS4ERR_LOCKS_HELD\n      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n \
    \     NFS4ERR_OLD_STATEID\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n\
    \      NFS4ERR_STALE\n      NFS4ERR_STALE_STATEID\n"
- title: '14.2.3.  Operation 5: COMMIT - Commit Cached Data'
  contents:
  - "14.2.3.  Operation 5: COMMIT - Commit Cached Data\n   SYNOPSIS\n     (cfh), offset,\
    \ count -> verifier\n   ARGUMENT\n     struct COMMIT4args {\n             /* CURRENT_FH:\
    \ file */\n             offset4         offset;\n             count4         \
    \ count;\n     };\n   RESULT\n     struct COMMIT4resok {\n             verifier4\
    \       writeverf;\n     };\n     union COMMIT4res switch (nfsstat4 status) {\n\
    \      case NFS4_OK:\n              COMMIT4resok   resok4;\n      default:\n \
    \             void;\n     };\n   DESCRIPTION\n   The COMMIT operation forces or\
    \ flushes data to stable storage for the\n   file specified by the current filehandle.\
    \  The flushed data is that\n   which was previously written with a WRITE operation\
    \ which had the\n   stable field set to UNSTABLE4.\n   The offset specifies the\
    \ position within the file where the flush is\n   to begin.  An offset value of\
    \ 0 (zero) means to flush data starting\n   at the beginning of the file.  The\
    \ count specifies the number of\n   bytes of data to flush.  If count is 0 (zero),\
    \ a flush from offset to\n   the end of the file is done.\n   The server returns\
    \ a write verifier upon successful completion of the\n   COMMIT.  The write verifier\
    \ is used by the client to determine if the\n   server has restarted or rebooted\
    \ between the initial WRITE(s) and the\n   COMMIT.  The client does this by comparing\
    \ the write verifier\n   returned from the initial writes and the verifier returned\
    \ by the\n   COMMIT operation.  The server must vary the value of the write\n\
    \   verifier at each server event or instantiation that may lead to a\n   loss\
    \ of uncommitted data.  Most commonly this occurs when the server\n   is rebooted;\
    \ however, other events at the server may result in\n   uncommitted data loss\
    \ as well.\n   On success, the current filehandle retains its value.\n   IMPLEMENTATION\n\
    \   The COMMIT operation is similar in operation and semantics to the\n   POSIX\
    \ fsync(2) system call that synchronizes a file's state with the\n   disk (file\
    \ data and metadata is flushed to disk or stable storage).\n   COMMIT performs\
    \ the same operation for a client, flushing any\n   unsynchronized data and metadata\
    \ on the server to the server's disk\n   or stable storage for the specified file.\
    \  Like fsync(2), it may be\n   that there is some modified data or no modified\
    \ data to synchronize.\n   The data may have been synchronized by the server's\
    \ normal periodic\n   buffer synchronization activity.  COMMIT should return NFS4_OK,\n\
    \   unless there has been an unexpected error.\n   COMMIT differs from fsync(2)\
    \ in that it is possible for the client to\n   flush a range of the file (most\
    \ likely triggered by a buffer-\n   reclamation scheme on the client before file\
    \ has been completely\n   written).\n   The server implementation of COMMIT is\
    \ reasonably simple.  If the\n   server receives a full file COMMIT request, that\
    \ is starting at\n   offset 0 and count 0, it should do the equivalent of fsync()'ing\
    \ the\n   file.  Otherwise, it should arrange to have the cached data in the\n\
    \   range specified by offset and count to be flushed to stable storage.\n   In\
    \ both cases, any metadata associated with the file must be flushed\n   to stable\
    \ storage before returning.  It is not an error for there to\n   be nothing to\
    \ flush on the server.  This means that the data and\n   metadata that needed\
    \ to be flushed have already been flushed or lost\n   during the last server failure.\n\
    \   The client implementation of COMMIT is a little more complex.  There\n   are\
    \ two reasons for wanting to commit a client buffer to stable\n   storage.  The\
    \ first is that the client wants to reuse a buffer.  In\n   this case, the offset\
    \ and count of the buffer are sent to the server\n   in the COMMIT request.  The\
    \ server then flushes any cached data based\n   on the offset and count, and flushes\
    \ any metadata associated with the\n   file.  It then returns the status of the\
    \ flush and the write\n   verifier.  The other reason for the client to generate\
    \ a COMMIT is\n   for a full file flush, such as may be done at close.  In this\
    \ case,\n   the client would gather all of the buffers for this file that contain\n\
    \   uncommitted data, do the COMMIT operation with an offset of 0 and\n   count\
    \ of 0, and then free all of those buffers.  Any other dirty\n   buffers would\
    \ be sent to the server in the normal fashion.\n   After a buffer is written by\
    \ the client with the stable parameter set\n   to UNSTABLE4, the buffer must be\
    \ considered as modified by the client\n   until the buffer has either been flushed\
    \ via a COMMIT operation or\n   written via a WRITE operation with stable parameter\
    \ set to FILE_SYNC4\n   or DATA_SYNC4. This is done to prevent the buffer from\
    \ being freed\n   and reused before the data can be flushed to stable storage\
    \ on the\n   server.\n   When a response is returned from either a WRITE or a\
    \ COMMIT operation\n   and it contains a write verifier that is different than\
    \ previously\n   returned by the server, the client will need to retransmit all\
    \ of the\n   buffers containing uncommitted cached data to the server.  How this\n\
    \   is to be done is up to the implementor.  If there is only one buffer\n   of\
    \ interest, then it should probably be sent back over in a WRITE\n   request with\
    \ the appropriate stable parameter.  If there is more than\n   one buffer, it\
    \ might be worthwhile retransmitting all of the buffers\n   in WRITE requests\
    \ with the stable parameter set to UNSTABLE4 and then\n   retransmitting the COMMIT\
    \ operation to flush all of the data on the\n   server to stable storage.  The\
    \ timing of these retransmissions is\n   left to the implementor.\n   The above\
    \ description applies to page-cache-based systems as well as\n   buffer-cache-based\
    \ systems.  In those systems, the virtual memory\n   system will need to be modified\
    \ instead of the buffer cache.\n   ERRORS\n      NFS4ERR_ACCESS\n      NFS4ERR_BADHANDLE\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n      NFS4ERR_IO\n\
    \      NFS4ERR_ISDIR\n      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_RESOURCE\n\
    \      NFS4ERR_ROFS\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n"
- title: '14.2.4.  Operation 6: CREATE - Create a Non-Regular File Object'
  contents:
  - "14.2.4.  Operation 6: CREATE - Create a Non-Regular File Object\n   SYNOPSIS\n\
    \     (cfh), name, type, attrs -> (cfh), change_info, attrs_set\n   ARGUMENT\n\
    \     union createtype4 switch (nfs_ftype4 type) {\n      case NF4LNK:\n     \
    \         linktext4      linkdata;\n      case NF4BLK:\n      case NF4CHR:\n \
    \             specdata4      devdata;\n      case NF4SOCK:\n      case NF4FIFO:\n\
    \      case NF4DIR:\n              void;\n     };\n     struct CREATE4args {\n\
    \             /* CURRENT_FH: directory for creation */\n             createtype4\
    \     objtype;\n             component4      objname;\n             fattr4   \
    \       createattrs;\n     };\n   RESULT\n     struct CREATE4resok {\n       \
    \      change_info4    cinfo;\n             bitmap4         attrset;        /*\
    \ attributes set */\n     };\n     union CREATE4res switch (nfsstat4 status) {\n\
    \      case NFS4_OK:\n              CREATE4resok resok4;\n      default:\n   \
    \           void;\n     };\n   DESCRIPTION\n   The CREATE operation creates a\
    \ non-regular file object in a directory\n   with a given name.  The OPEN operation\
    \ MUST be used to create a\n   regular file.\n   The objname specifies the name\
    \ for the new object.  The objtype\n   determines the type of object to be created:\
    \ directory, symlink, etc.\n   If an object of the same name already exists in\
    \ the directory, the\n   server will return the error NFS4ERR_EXIST.\n   For the\
    \ directory where the new file object was created, the server\n   returns change_info4\
    \ information in cinfo.  With the atomic field of\n   the change_info4 struct,\
    \ the server will indicate if the before and\n   after change attributes were\
    \ obtained atomically with respect to the\n   file object creation.\n   If the\
    \ objname has a length of 0 (zero), or if objname does not obey\n   the UTF-8\
    \ definition, the error NFS4ERR_INVAL will be returned.\n   The current filehandle\
    \ is replaced by that of the new object.\n   The createattrs specifies the initial\
    \ set of attributes for the\n   object.  The set of attributes may include any\
    \ writable attribute\n   valid for the object type. When the operation is successful,\
    \ the\n   server will return to the client an attribute mask signifying which\n\
    \   attributes were successfully set for the object.\n   If createattrs includes\
    \ neither the owner attribute nor an ACL with\n   an ACE for the owner, and if\
    \ the server's filesystem both supports\n   and requires an owner attribute (or\
    \ an owner ACE) then the server\n   MUST derive the owner (or the owner ACE).\
    \ This would typically be\n   from the principal indicated in the RPC credentials\
    \ of the call, but\n   the server's operating environment or filesystem semantics\
    \ may\n   dictate other methods of derivation. Similarly, if createattrs\n   includes\
    \ neither the group attribute nor a group ACE, and if the\n   server's filesystem\
    \ both supports and requires the notion of a group\n   attribute (or group ACE),\
    \ the server MUST derive the group attribute\n   (or the corresponding owner ACE)\
    \ for the file. This could be from the\n   RPC call's credentials, such as the\
    \ group principal if the\n   credentials include it (such as with AUTH_SYS), from\
    \ the group\n   identifier associated with the principal in the credentials (for\n\
    \   e.g., POSIX systems have a passwd database that has the group\n   identifier\
    \ for every user identifier), inherited from directory the\n   object is created\
    \ in, or whatever else the server's operating\n   environment or filesystem semantics\
    \ dictate. This applies to the OPEN\n   operation too.\n   Conversely, it is possible\
    \ the client will specify in createattrs an\n   owner attribute or group attribute\
    \ or ACL that the principal\n   indicated the RPC call's credentials does not\
    \ have permissions to\n   create files for. The error to be returned in this instance\
    \ is\n   NFS4ERR_PERM. This applies to the OPEN operation too.\n   IMPLEMENTATION\n\
    \   If the client desires to set attribute values after the create, a\n   SETATTR\
    \ operation can be added to the COMPOUND request so that the\n   appropriate attributes\
    \ will be set.\n   ERRORS\n      NFS4ERR_ACCESS\n      NFS4ERR_ATTRNOTSUPP\n \
    \     NFS4ERR_BADCHAR\n      NFS4ERR_BADHANDLE\n      NFS4ERR_BADNAME\n      NFS4ERR_BADOWNER\n\
    \      NFS4ERR_BADTYPE\n      NFS4ERR_BADXDR\n      NFS4ERR_DELAY\n      NFS4ERR_DQUOT\n\
    \      NFS4ERR_EXIST\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n      NFS4ERR_IO\n\
    \      NFS4ERR_MOVED\n      NFS4ERR_NAMETOOLONG\n      NFS4ERR_NOFILEHANDLE\n\
    \      NFS4ERR_NOSPC\n      NFS4ERR_NOTDIR\n      NFS4ERR_PERM\n      NFS4ERR_RESOURCE\n\
    \      NFS4ERR_ROFS\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n"
- title: '14.2.5.  Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery'
  contents:
  - "14.2.5.  Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery\n   SYNOPSIS\n\
    \     clientid ->\n   ARGUMENT\n     struct DELEGPURGE4args {\n             clientid4\
    \       clientid;\n     };\n   RESULT\n     struct DELEGPURGE4res {\n        \
    \     nfsstat4        status;\n     };\n   DESCRIPTION\n   Purges all of the delegations\
    \ awaiting recovery for a given client.\n   This is useful for clients which do\
    \ not commit delegation information\n   to stable storage to indicate that conflicting\
    \ requests need not be\n   delayed by the server awaiting recovery of delegation\
    \ information.\n   This operation should be used by clients that record delegation\n\
    \   information on stable storage on the client.  In this case,\n   DELEGPURGE\
    \ should be issued immediately after doing delegation\n   recovery on all delegations\
    \ known to the client.  Doing so will\n   notify the server that no additional\
    \ delegations for the client will\n   be recovered allowing it to free resources,\
    \ and avoid delaying other\n   clients who make requests that conflict with the\
    \ unrecovered\n   delegations.  The set of delegations known to the server and\
    \ the\n   client may be different.  The reason for this is that a client may\n\
    \   fail after making a request which resulted in delegation but before\n   it\
    \ received the results and committed them to the client's stable\n   storage.\n\
    \   The server MAY support DELEGPURGE, but if it does not, it MUST NOT\n   support\
    \ CLAIM_DELEGATE_PREV.\n   ERRORS\n      NFS4ERR_BADXDR\n      NFS4ERR_NOTSUPP\n\
    \      NFS4ERR_LEASE_MOVED\n      NFS4ERR_MOVED\n      NFS4ERR_RESOURCE\n    \
    \  NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE_CLIENTID\n"
- title: '14.2.6.  Operation 8: DELEGRETURN - Return Delegation'
  contents:
  - "14.2.6.  Operation 8: DELEGRETURN - Return Delegation\n   SYNOPSIS\n     (cfh),\
    \ stateid ->\n   ARGUMENT\n     struct DELEGRETURN4args {\n             /* CURRENT_FH:\
    \ delegated file */\n             stateid4        stateid;\n     };\n   RESULT\n\
    \     struct DELEGRETURN4res {\n             nfsstat4        status;\n     };\n\
    \   DESCRIPTION\n   Returns the delegation represented by the current filehandle\
    \ and\n   stateid.\n   Delegations may be returned when recalled or voluntarily\
    \ (i.e.,\n   before the server has recalled them).  In either case the client\
    \ must\n   properly propagate state changed under the context of the delegation\n\
    \   to the server before returning the delegation.\n   ERRORS\n      NFS4ERR_ADMIN_REVOKED\n\
    \      NFS4ERR_BAD_STATEID\n      NFS4ERR_BADXDR\n      NFS4ERR_EXPIRED\n    \
    \  NFS4ERR_INVAL\n      NFS4ERR_LEASE_MOVED\n      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n\
    \      NFS4ERR_NOTSUPP\n      NFS4ERR_OLD_STATEID\n      NFS4ERR_RESOURCE\n  \
    \    NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_STALE_STATEID\n"
- title: '14.2.7.  Operation 9: GETATTR - Get Attributes'
  contents:
  - "14.2.7.  Operation 9: GETATTR - Get Attributes\n   SYNOPSIS\n     (cfh), attrbits\
    \ -> attrbits, attrvals\n   ARGUMENT\n     struct GETATTR4args {\n           \
    \  /* CURRENT_FH: directory or file */\n             bitmap4         attr_request;\n\
    \     };\n   RESULT\n     struct GETATTR4resok {\n             fattr4        \
    \  obj_attributes;\n     };\n     union GETATTR4res switch (nfsstat4 status) {\n\
    \      case NFS4_OK:\n              GETATTR4resok  resok4;\n      default:\n \
    \             void;\n     };\n   DESCRIPTION\n   The GETATTR operation will obtain\
    \ attributes for the filesystem\n   object specified by the current filehandle.\
    \  The client sets a bit in\n   the bitmap argument for each attribute value that\
    \ it would like the\n   server to return.  The server returns an attribute bitmap\
    \ that\n   indicates the attribute values for which it was able to return,\n \
    \  followed by the attribute values ordered lowest attribute number\n   first.\n\
    \   The server must return a value for each attribute that the client\n   requests\
    \ if the attribute is supported by the server.  If the server\n   does not support\
    \ an attribute or cannot approximate a useful value\n   then it must not return\
    \ the attribute value and must not set the\n   attribute bit in the result bitmap.\
    \  The server must return an error\n   if it supports an attribute but cannot\
    \ obtain its value.  In that\n   case no attribute values will be returned.\n\
    \   All servers must support the mandatory attributes as specified in the\n  \
    \ section \"File Attributes\".\n   On success, the current filehandle retains\
    \ its value.\n   IMPLEMENTATION\n   ERRORS\n      NFS4ERR_ACCESS\n      NFS4ERR_BADHANDLE\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_DELAY\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n\
    \      NFS4ERR_IO\n      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_RESOURCE\n\
    \      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n"
- title: '14.2.8.  Operation 10: GETFH - Get Current Filehandle'
  contents:
  - "14.2.8.  Operation 10: GETFH - Get Current Filehandle\n   SYNOPSIS\n     (cfh)\
    \ -> filehandle\n   ARGUMENT\n     /* CURRENT_FH: */\n     void;\n   RESULT\n\
    \     struct GETFH4resok {\n             nfs_fh4         object;\n     };\n  \
    \   union GETFH4res switch (nfsstat4 status) {\n      case NFS4_OK:\n        \
    \     GETFH4resok     resok4;\n      default:\n             void;\n     };\n \
    \  DESCRIPTION\n   This operation returns the current filehandle value.\n   On\
    \ success, the current filehandle retains its value.\n   IMPLEMENTATION\n   Operations\
    \ that change the current filehandle like LOOKUP or CREATE\n   do not automatically\
    \ return the new filehandle as a result.  For\n   instance, if a client needs\
    \ to lookup a directory entry and obtain\n   its filehandle then the following\
    \ request is needed.\n      PUTFH  (directory filehandle)\n      LOOKUP (entry\
    \ name)\n      GETFH\n   ERRORS\n      NFS4ERR_BADHANDLE\n      NFS4ERR_FHEXPIRED\n\
    \      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_RESOURCE\n   \
    \   NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n"
- title: '14.2.9.  Operation 11: LINK - Create Link to a File'
  contents:
  - "14.2.9.  Operation 11: LINK - Create Link to a File\n   SYNOPSIS\n     (sfh),\
    \ (cfh), newname -> (cfh), change_info\n   ARGUMENT\n     struct LINK4args {\n\
    \             /* SAVED_FH: source object */\n             /* CURRENT_FH: target\
    \ directory */\n             component4      newname;\n     };\n   RESULT\n  \
    \   struct LINK4resok {\n             change_info4    cinfo;\n     };\n     union\
    \ LINK4res switch (nfsstat4 status) {\n      case NFS4_OK:\n              LINK4resok\
    \ resok4;\n      default:\n              void;\n     };\n   DESCRIPTION\n   The\
    \ LINK operation creates an additional newname for the file\n   represented by\
    \ the saved filehandle, as set by the SAVEFH operation,\n   in the directory represented\
    \ by the current filehandle.  The existing\n   file and the target directory must\
    \ reside within the same filesystem\n   on the server.  On success, the current\
    \ filehandle will continue to\n   be the target directory.  If an object exists\
    \ in the target directory\n   with the same name as newname, the server must return\
    \ NFS4ERR_EXIST.\n   For the target directory, the server returns change_info4\
    \ information\n   in cinfo.  With the atomic field of the change_info4 struct,\
    \ the\n   server will indicate if the before and after change attributes were\n\
    \   obtained atomically with respect to the link creation.\n   If the newname\
    \ has a length of 0 (zero), or if newname does not obey\n   the UTF-8 definition,\
    \ the error NFS4ERR_INVAL will be returned.\n   IMPLEMENTATION\n   Changes to\
    \ any property of the \"hard\" linked files are reflected in\n   all of the linked\
    \ files.  When a link is made to a file, the\n   attributes for the file should\
    \ have a value for numlinks that is one\n   greater than the value before the\
    \ LINK operation.\n   The statement \"file and the target directory must reside\
    \ within the\n   same filesystem on the server\" means that the fsid fields in\
    \ the\n   attributes for the objects are the same. If they reside on different\n\
    \   filesystems, the error, NFS4ERR_XDEV, is returned.  On some servers,\n   the\
    \ filenames, \".\" and \"..\", are illegal as newname.\n   In the case that newname\
    \ is already linked to the file represented by\n   the saved filehandle, the server\
    \ will return NFS4ERR_EXIST.\n   Note that symbolic links are created with the\
    \ CREATE operation.\n   ERRORS\n      NFS4ERR_ACCESS\n      NFS4ERR_BADCHAR\n\
    \      NFS4ERR_BADHANDLE\n      NFS4ERR_BADNAME\n      NFS4ERR_BADXDR\n      NFS4ERR_DELAY\n\
    \      NFS4ERR_DQUOT\n      NFS4ERR_EXIST\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_FILE_OPEN\n\
    \      NFS4ERR_INVAL\n      NFS4ERR_IO\n      NFS4ERR_ISDIR\n      NFS4ERR_MLINK\n\
    \      NFS4ERR_MOVED\n      NFS4ERR_NAMETOOLONG\n      NFS4ERR_NOENT\n      NFS4ERR_NOFILEHANDLE\n\
    \      NFS4ERR_NOSPC\n      NFS4ERR_NOTDIR\n      NFS4ERR_NOTSUPP\n      NFS4ERR_RESOURCE\n\
    \      NFS4ERR_ROFS\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_WRONGSEC\n\
    \      NFS4ERR_XDEV\n"
- title: '14.2.10.  Operation 12: LOCK - Create Lock'
  contents:
  - "14.2.10.  Operation 12: LOCK - Create Lock\n   SYNOPSIS\n     (cfh) locktype,\
    \ reclaim, offset, length, locker -> stateid\n   ARGUMENT\n     struct open_to_lock_owner4\
    \ {\n             seqid4          open_seqid;\n             stateid4        open_stateid;\n\
    \             seqid4          lock_seqid;\n             lock_owner4     lock_owner;\n\
    \     };\n     struct exist_lock_owner4 {\n             stateid4        lock_stateid;\n\
    \             seqid4          lock_seqid;\n     };\n     union locker4 switch\
    \ (bool new_lock_owner) {\n      case TRUE:\n             open_to_lock_owner4\
    \     open_owner;\n      case FALSE:\n             exist_lock_owner4       lock_owner;\n\
    \     };\n     enum nfs_lock_type4 {\n             READ_LT         = 1,\n    \
    \         WRITE_LT        = 2,\n             READW_LT        = 3,    /* blocking\
    \ read */\n             WRITEW_LT       = 4     /* blocking write */\n     };\n\
    \     struct LOCK4args {\n             /* CURRENT_FH: file */\n             nfs_lock_type4\
    \  locktype;\n             bool            reclaim;\n             offset4    \
    \     offset;\n             length4         length;\n             locker4    \
    \     locker;\n     };\n   RESULT\n     struct LOCK4denied {\n             offset4\
    \         offset;\n             length4         length;\n             nfs_lock_type4\
    \  locktype;\n             lock_owner4     owner;\n     };\n     struct LOCK4resok\
    \ {\n             stateid4        lock_stateid;\n     };\n     union LOCK4res\
    \ switch (nfsstat4 status) {\n      case NFS4_OK:\n              LOCK4resok  \
    \   resok4;\n      case NFS4ERR_DENIED:\n              LOCK4denied    denied;\n\
    \      default:\n              void;\n     };\n   DESCRIPTION\n   The LOCK operation\
    \ requests a record lock for the byte range\n   specified by the offset and length\
    \ parameters.  The lock type is also\n   specified to be one of the nfs_lock_type4s.\
    \  If this is a reclaim\n   request, the reclaim parameter will be TRUE;\n   Bytes\
    \ in a file may be locked even if those bytes are not currently\n   allocated\
    \ to the file.  To lock the file from a specific offset\n   through the end-of-file\
    \ (no matter how long the file actually is) use\n   a length field with all bits\
    \ set to 1 (one).  If the length is zero,\n   or if a length which is not all\
    \ bits set to one is specified, and\n   length when added to the offset exceeds\
    \ the maximum 64-bit unsigned\n   integer value, the error NFS4ERR_INVAL will\
    \ result.\n   Some servers may only support locking for byte offsets that fit\n\
    \   within 32 bits.  If the client specifies a range that includes a byte\n  \
    \ beyond the last byte offset of the 32-bit range, but does not include\n   the\
    \ last byte offset of the 32-bit and all of the byte offsets beyond\n   it, up\
    \ to the end of the valid 64-bit range, such a 32-bit server\n   MUST return the\
    \ error NFS4ERR_BAD_RANGE.\n   In the case that the lock is denied, the owner,\
    \ offset, and length of\n   a conflicting lock are returned.\n   On success, the\
    \ current filehandle retains its value.\n   IMPLEMENTATION\n   If the server is\
    \ unable to determine the exact offset and length of\n   the conflicting lock,\
    \ the same offset and length that were provided\n   in the arguments should be\
    \ returned in the denied results.  The File\n   Locking section contains a full\
    \ description of this and the other\n   file locking operations.\n   LOCK operations\
    \ are subject to permission checks and to checks\n   against the access type of\
    \ the associated file.  However, the\n   specific right and modes required for\
    \ various type of locks, reflect\n   the semantics of the server-exported filesystem,\
    \ and are not\n   specified by the protocol.  For example, Windows 2000 allows\
    \ a write\n   lock of a file open for READ, while a POSIX-compliant system does\n\
    \   not.\n   When the client makes a lock request that corresponds to a range\
    \ that\n   the lockowner has locked already (with the same or different lock\n\
    \   type), or to a sub-region of such a range, or to a region which\n   includes\
    \ multiple locks already granted to that lockowner, in whole\n   or in part, and\
    \ the server does not support such locking operations\n   (i.e., does not support\
    \ POSIX locking semantics), the server will\n   return the error NFS4ERR_LOCK_RANGE.\
    \  In that case, the client may\n   return an error, or it may emulate the required\
    \ operations, using\n   only LOCK for ranges that do not include any bytes already\
    \ locked by\n   that lock_owner and LOCKU of locks held by that lock_owner\n \
    \  (specifying an exactly-matching range and type).  Similarly, when the\n   client\
    \ makes a lock request that amounts to upgrading (changing from\n   a read lock\
    \ to a write lock) or downgrading (changing from write lock\n   to a read lock)\
    \ an existing record lock, and the server does not\n   support such a lock, the\
    \ server will return NFS4ERR_LOCK_NOTSUPP.\n   Such operations may not perfectly\
    \ reflect the required semantics in\n   the face of conflicting lock requests\
    \ from other clients.\n   The locker argument specifies the lock_owner that is\
    \ associated with\n   the LOCK request.  The locker4 structure is a switched union\
    \ that\n   indicates whether the lock_owner is known to the server or if the\n\
    \   lock_owner is new to the server.  In the case that the lock_owner is\n   known\
    \ to the server and has an established lock_seqid, the argument\n   is just the\
    \ lock_owner and lock_seqid.  In the case that the\n   lock_owner is not known\
    \ to the server, the argument contains not only\n   the lock_owner and lock_seqid\
    \ but also the open_stateid and\n   open_seqid.  The new lock_owner case covers\
    \ the very first lock done\n   by the lock_owner and offers a method to use the\
    \ established state of\n   the open_stateid to transition to the use of the lock_owner.\n\
    \   ERRORS\n      NFS4ERR_ACCESS\n      NFS4ERR_ADMIN_REVOKED\n      NFS4ERR_BADHANDLE\n\
    \      NFS4ERR_BAD_RANGE\n      NFS4ERR_BAD_SEQID\n      NFS4ERR_BAD_STATEID\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_DEADLOCK\n      NFS4ERR_DELAY\n      NFS4ERR_DENIED\n\
    \      NFS4ERR_EXPIRED\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_GRACE\n      NFS4ERR_INVAL\n\
    \      NFS4ERR_ISDIR\n      NFS4ERR_LEASE_MOVED\n      NFS4ERR_LOCK_NOTSUPP\n\
    \      NFS4ERR_LOCK_RANGE\n      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n \
    \     NFS4ERR_NO_GRACE\n      NFS4ERR_OLD_STATEID\n      NFS4ERR_OPENMODE\n  \
    \    NFS4ERR_RECLAIM_BAD\n      NFS4ERR_RECLAIM_CONFLICT\n      NFS4ERR_RESOURCE\n\
    \      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_STALE_CLIENTID\n\
    \      NFS4ERR_STALE_STATEID\n"
- title: '14.2.11.  Operation 13: LOCKT - Test For Lock'
  contents:
  - "14.2.11.  Operation 13: LOCKT - Test For Lock\n   SYNOPSIS\n     (cfh) locktype,\
    \ offset, length owner -> {void, NFS4ERR_DENIED ->\n     owner}\n   ARGUMENT\n\
    \     struct LOCKT4args {\n             /* CURRENT_FH: file */\n             nfs_lock_type4\
    \  locktype;\n             offset4         offset;\n             length4     \
    \    length;\n             lock_owner4     owner;\n     };\n   RESULT\n     struct\
    \ LOCK4denied {\n             offset4         offset;\n             length4  \
    \       length;\n             nfs_lock_type4  locktype;\n             lock_owner4\
    \     owner;\n     };\n     union LOCKT4res switch (nfsstat4 status) {\n     \
    \ case NFS4ERR_DENIED:\n              LOCK4denied    denied;\n      case NFS4_OK:\n\
    \              void;\n      default:\n              void;\n     };\n   DESCRIPTION\n\
    \   The LOCKT operation tests the lock as specified in the arguments.  If\n  \
    \ a conflicting lock exists, the owner, offset, length, and type of the\n   conflicting\
    \ lock are returned; if no lock is held, nothing other than\n   NFS4_OK is returned.\
    \  Lock types READ_LT and READW_LT are processed\n   in the same way in that a\
    \ conflicting lock test is done without\n   regard to blocking or non-blocking.\
    \  The same is true for WRITE_LT\n   and WRITEW_LT.\n   The ranges are specified\
    \ as for LOCK.  The NFS4ERR_INVAL and\n   NFS4ERR_BAD_RANGE errors are returned\
    \ under the same circumstances as\n   for LOCK.\n   On success, the current filehandle\
    \ retains its value.\n   IMPLEMENTATION\n   If the server is unable to determine\
    \ the exact offset and length of\n   the conflicting lock, the same offset and\
    \ length that were provided\n   in the arguments should be returned in the denied\
    \ results.  The File\n   Locking section contains further discussion of the file\
    \ locking\n   mechanisms.\n   LOCKT uses a lock_owner4 rather a stateid4, as is\
    \ used in LOCK to\n   identify the owner.  This is because the client does not\
    \ have to open\n   the file to test for the existence of a lock, so a stateid\
    \ may not be\n   available.\n   The test for conflicting locks should exclude\
    \ locks for the current\n   lockowner.  Note that since such locks are not examined\
    \ the possible\n   existence of overlapping ranges may not affect the results\
    \ of LOCKT.\n   If the server does examine locks that match the lockowner for\
    \ the\n   purpose of range checking, NFS4ERR_LOCK_RANGE may be returned..  In\n\
    \   the event that it returns NFS4_OK, clients may do a LOCK and receive\n   NFS4ERR_LOCK_RANGE\
    \ on the LOCK request because of the flexibility\n   provided to the server.\n\
    \   ERRORS\n      NFS4ERR_ACCESS\n      NFS4ERR_BADHANDLE\n      NFS4ERR_BAD_RANGE\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_DELAY\n      NFS4ERR_DENIED\n      NFS4ERR_FHEXPIRED\n\
    \      NFS4ERR_GRACE\n      NFS4ERR_INVAL\n      NFS4ERR_ISDIR\n      NFS4ERR_LEASE_MOVED\n\
    \      NFS4ERR_LOCK_RANGE\n      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n \
    \     NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n     \
    \ NFS4ERR_STALE_CLIENTID\n"
- title: '14.2.12.  Operation 14: LOCKU - Unlock File'
  contents:
  - "14.2.12.  Operation 14: LOCKU - Unlock File\n   SYNOPSIS\n     (cfh) type, seqid,\
    \ stateid, offset, length -> stateid\n   ARGUMENT\n     struct LOCKU4args {\n\
    \             /* CURRENT_FH: file */\n             nfs_lock_type4  locktype;\n\
    \             seqid4          seqid;\n             stateid4        stateid;\n\
    \             offset4         offset;\n             length4         length;\n\
    \     };\n   RESULT\n     union LOCKU4res switch (nfsstat4 status) {\n      case\
    \   NFS4_OK:\n              stateid4       stateid;\n      default:\n        \
    \      void;\n     };\n   DESCRIPTION\n   The LOCKU operation unlocks the record\
    \ lock specified by the\n   parameters. The client may set the locktype field\
    \ to any value that\n   is legal for the nfs_lock_type4 enumerated type, and the\
    \ server MUST\n   accept any legal value for locktype. Any legal value for locktype\
    \ has\n   no effect on the success or failure of the LOCKU operation.\n   The\
    \ ranges are specified as for LOCK.  The NFS4ERR_INVAL and\n   NFS4ERR_BAD_RANGE\
    \ errors are returned under the same circumstances as\n   for LOCK.\n   On success,\
    \ the current filehandle retains its value.\n   IMPLEMENTATION\n   If the area\
    \ to be unlocked does not correspond exactly to a lock\n   actually held by the\
    \ lockowner the server may return the error\n   NFS4ERR_LOCK_RANGE.  This includes\
    \ the case in which the area is not\n   locked, where the area is a sub-range\
    \ of the area locked, where it\n   overlaps the area locked without matching exactly\
    \ or the area\n   specified includes multiple locks held by the lockowner.  In\
    \ all of\n   these cases, allowed by POSIX locking semantics, a client receiving\n\
    \   this error, should if it desires support for such operations,\n   simulate\
    \ the operation using LOCKU on ranges corresponding to locks\n   it actually holds,\
    \ possibly followed by LOCK requests for the sub-\n   ranges not being unlocked.\n\
    \   ERRORS\n      NFS4ERR_ACCESS\n      NFS4ERR_ADMIN_REVOKED\n      NFS4ERR_BADHANDLE\n\
    \      NFS4ERR_BAD_RANGE\n      NFS4ERR_BAD_SEQID\n      NFS4ERR_BAD_STATEID\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_EXPIRED\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_GRACE\n\
    \      NFS4ERR_INVAL\n      NFS4ERR_ISDIR\n      NFS4ERR_LEASE_MOVED\n      NFS4ERR_LOCK_RANGE\n\
    \      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_OLD_STATEID\n\
    \      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n    \
    \  NFS4ERR_STALE_STATEID\n"
- title: '14.2.13.  Operation 15: LOOKUP - Lookup Filename'
  contents:
  - "14.2.13.  Operation 15: LOOKUP - Lookup Filename\n   SYNOPSIS\n     (cfh), component\
    \ -> (cfh)\n   ARGUMENT\n     struct LOOKUP4args {\n             /* CURRENT_FH:\
    \ directory */\n             component4      objname;\n     };\n   RESULT\n  \
    \   struct LOOKUP4res {\n             /* CURRENT_FH: object */\n             nfsstat4\
    \        status;\n     };\n   DESCRIPTION\n   This operation LOOKUPs or finds\
    \ a filesystem object using the\n   directory specified by the current filehandle.\
    \  LOOKUP evaluates the\n   component and if the object exists the current filehandle\
    \ is replaced\n   with the component's filehandle.\n   If the component cannot\
    \ be evaluated either because it does not exist\n   or because the client does\
    \ not have permission to evaluate the\n   component, then an error will be returned\
    \ and the current filehandle\n   will be unchanged.\n   If the component is a\
    \ zero length string or if any component does not\n   obey the UTF-8 definition,\
    \ the error NFS4ERR_INVAL will be returned.\n   IMPLEMENTATION\n   If the client\
    \ wants to achieve the effect of a multi-component\n   lookup, it may construct\
    \ a COMPOUND request such as (and obtain each\n   filehandle):\n      PUTFH  (directory\
    \ filehandle)\n      LOOKUP \"pub\"\n      GETFH\n      LOOKUP \"foo\"\n     \
    \ GETFH\n      LOOKUP \"bar\"\n      GETFH\n   NFS version 4 servers depart from\
    \ the semantics of previous NFS\n   versions in allowing LOOKUP requests to cross\
    \ mountpoints on the\n   server.  The client can detect a mountpoint crossing\
    \ by comparing the\n   fsid attribute of the directory with the fsid attribute\
    \ of the\n   directory looked up.  If the fsids are different then the new\n \
    \  directory is a server mountpoint.  UNIX clients that detect a\n   mountpoint\
    \ crossing will need to mount the server's filesystem.  This\n   needs to be done\
    \ to maintain the file object identity checking\n   mechanisms common to UNIX\
    \ clients.\n   Servers that limit NFS access to \"shares\" or \"exported\" filesystems\n\
    \   should provide a pseudo-filesystem into which the exported\n   filesystems\
    \ can be integrated, so that clients can browse the\n   server's name space. \
    \ The clients' view of a pseudo filesystem will\n   be limited to paths that lead\
    \ to exported filesystems.\n   Note: previous versions of the protocol assigned\
    \ special semantics to\n   the names \".\" and \"..\".  NFS version 4 assigns\
    \ no special semantics\n   to these names.  The LOOKUPP operator must be used\
    \ to lookup a parent\n   directory.\n   Note that this operation does not follow\
    \ symbolic links.  The client\n   is responsible for all parsing of filenames\
    \ including filenames that\n   are modified by symbolic links encountered during\
    \ the lookup process.\n   If the current filehandle supplied is not a directory\
    \ but a symbolic\n   link, the error NFS4ERR_SYMLINK is returned as the error.\
    \  For all\n   other non-directory file types, the error NFS4ERR_NOTDIR is returned.\n\
    \   ERRORS\n      NFS4ERR_ACCESS\n      NFS4ERR_BADCHAR\n      NFS4ERR_BADHANDLE\n\
    \      NFS4ERR_BADNAME\n      NFS4ERR_BADXDR\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n\
    \      NFS4ERR_IO\n      NFS4ERR_MOVED\n      NFS4ERR_NAMETOOLONG\n      NFS4ERR_NOENT\n\
    \      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOTDIR\n      NFS4ERR_RESOURCE\n  \
    \    NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_SYMLINK\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.14.  Operation 16: LOOKUPP - Lookup Parent Directory'
  contents:
  - "14.2.14.  Operation 16: LOOKUPP - Lookup Parent Directory\n   SYNOPSIS\n    \
    \ (cfh) -> (cfh)\n   ARGUMENT\n     /* CURRENT_FH: object */\n     void;\n   RESULT\n\
    \     struct LOOKUPP4res {\n             /* CURRENT_FH: directory */\n       \
    \      nfsstat4        status;\n     };\n   DESCRIPTION\n   The current filehandle\
    \ is assumed to refer to a regular directory\n   or a named attribute directory.\
    \  LOOKUPP assigns the filehandle for\n   its parent directory to be the current\
    \ filehandle.  If there is no\n   parent directory an NFS4ERR_NOENT error must\
    \ be returned.\n   Therefore, NFS4ERR_NOENT will be returned by the server when\
    \ the\n   current filehandle is at the root or top of the server's file tree.\n\
    \   IMPLEMENTATION\n   As for LOOKUP, LOOKUPP will also cross mountpoints.\n \
    \  If the current filehandle is not a directory or named attribute\n   directory,\
    \ the error NFS4ERR_NOTDIR is returned.\n   ERRORS\n      NFS4ERR_ACCESS\n   \
    \   NFS4ERR_BADHANDLE\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_IO\n      NFS4ERR_MOVED\n\
    \      NFS4ERR_NOENT\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOTDIR\n     \
    \ NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n"
- title: '14.2.15.  Operation 17: NVERIFY - Verify Difference in Attributes'
  contents:
  - "14.2.15.  Operation 17: NVERIFY - Verify Difference in Attributes\n   SYNOPSIS\n\
    \     (cfh), fattr -> -\n   ARGUMENT\n     struct NVERIFY4args {\n           \
    \  /* CURRENT_FH: object */\n             fattr4          obj_attributes;\n  \
    \   };\n   RESULT\n     struct NVERIFY4res {\n             nfsstat4        status;\n\
    \     };\n   DESCRIPTION\n   This operation is used to prefix a sequence of operations\
    \ to be\n   performed if one or more attributes have changed on some filesystem\n\
    \   object.  If all the attributes match then the error NFS4ERR_SAME must\n  \
    \ be returned.\n   On success, the current filehandle retains its value.\n   IMPLEMENTATION\n\
    \   This operation is useful as a cache validation operator.  If the\n   object\
    \ to which the attributes belong has changed then the following\n   operations\
    \ may obtain new data associated with that object.  For\n   instance, to check\
    \ if a file has been changed and obtain new data if\n   it has:\n      PUTFH \
    \ (public)\n      LOOKUP \"foobar\"\n      NVERIFY attrbits attrs\n      READ\
    \ 0 32767\n   In the case that a recommended attribute is specified in the NVERIFY\n\
    \   operation and the server does not support that attribute for the\n   filesystem\
    \ object, the error NFS4ERR_ATTRNOTSUPP is returned to the\n   client.\n   When\
    \ the attribute rdattr_error or any write-only attribute (e.g.,\n   time_modify_set)\
    \ is specified, the error NFS4ERR_INVAL is returned to\n   the client.\n   ERRORS\n\
    \      NFS4ERR_ACCESS\n      NFS4ERR_ATTRNOTSUPP\n      NFS4ERR_BADCHAR\n    \
    \  NFS4ERR_BADHANDLE\n      NFS4ERR_BADXDR\n      NFS4ERR_DELAY\n      NFS4ERR_FHEXPIRED\n\
    \      NFS4ERR_INVAL\n      NFS4ERR_IO\n      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n\
    \      NFS4ERR_RESOURCE\n      NFS4ERR_SAME\n      NFS4ERR_SERVERFAULT\n     \
    \ NFS4ERR_STALE\n"
- title: '14.2.16.  Operation 18: OPEN - Open a Regular File'
  contents:
  - "14.2.16.  Operation 18: OPEN - Open a Regular File\n   SYNOPSIS\n     (cfh),\
    \ seqid, share_access, share_deny, owner, openhow, claim ->\n     (cfh), stateid,\
    \ cinfo, rflags, open_confirm, attrset delegation\n   ARGUMENT\n     struct OPEN4args\
    \ {\n             seqid4          seqid;\n             uint32_t        share_access;\n\
    \             uint32_t        share_deny;\n             open_owner4     owner;\n\
    \             openflag4       openhow;\n             open_claim4     claim;\n\
    \     };\n     enum createmode4 {\n             UNCHECKED4      = 0,\n       \
    \      GUARDED4        = 1,\n             EXCLUSIVE4      = 2\n     };\n     union\
    \ createhow4 switch (createmode4 mode) {\n      case UNCHECKED4:\n      case GUARDED4:\n\
    \              fattr4         createattrs;\n      case EXCLUSIVE4:\n         \
    \     verifier4      createverf;\n     };\n     enum opentype4 {\n           \
    \  OPEN4_NOCREATE  = 0,\n             OPEN4_CREATE    = 1\n     };\n     union\
    \ openflag4 switch (opentype4 opentype) {\n      case OPEN4_CREATE:\n        \
    \      createhow4     how;\n      default:\n              void;\n     };\n   \
    \  /* Next definitions used for OPEN delegation */\n     enum limit_by4 {\n  \
    \           NFS_LIMIT_SIZE          = 1,\n             NFS_LIMIT_BLOCKS      \
    \  = 2\n             /* others as needed */\n     };\n     struct nfs_modified_limit4\
    \ {\n             uint32_t        num_blocks;\n             uint32_t        bytes_per_block;\n\
    \     };\n     union nfs_space_limit4 switch (limit_by4 limitby) {\n      /* limit\
    \ specified as file size */\n      case NFS_LIMIT_SIZE:\n              uint64_t\
    \               filesize;\n      /* limit specified by number of blocks */\n \
    \     case NFS_LIMIT_BLOCKS:\n              nfs_modified_limit4    mod_blocks;\n\
    \     } ;\n     enum open_delegation_type4 {\n             OPEN_DELEGATE_NONE\
    \      = 0,\n             OPEN_DELEGATE_READ      = 1,\n             OPEN_DELEGATE_WRITE\
    \     = 2\n     };\n     enum open_claim_type4 {\n             CLAIM_NULL    \
    \          = 0,\n             CLAIM_PREVIOUS          = 1,\n             CLAIM_DELEGATE_CUR\
    \      = 2,\n             CLAIM_DELEGATE_PREV     = 3\n     };\n     struct open_claim_delegate_cur4\
    \ {\n             stateid4        delegate_stateid;\n             component4 \
    \     file;\n     };\n     union open_claim4 switch (open_claim_type4 claim) {\n\
    \      /*\n       * No special rights to file. Ordinary OPEN of the specified\
    \ file.\n       */\n      case CLAIM_NULL:\n              /* CURRENT_FH: directory\
    \ */\n              component4     file;\n      /*\n       * Right to the file\
    \ established by an open previous to server\n       * reboot.  File identified\
    \ by filehandle obtained at that time\n       * rather than by name.\n       */\n\
    \      case CLAIM_PREVIOUS:\n              /* CURRENT_FH: file being reclaimed\
    \ */\n              open_delegation_type4   delegate_type;\n      /*\n       *\
    \ Right to file based on a delegation granted by the server.\n       * File is\
    \ specified by name.\n       */\n      case CLAIM_DELEGATE_CUR:\n            \
    \  /* CURRENT_FH: directory */\n              open_claim_delegate_cur4       delegate_cur_info;\n\
    \      /* Right to file based on a delegation granted to a previous boot\n   \
    \    * instance of the client.  File is specified by name.\n       */\n      case\
    \ CLAIM_DELEGATE_PREV:\n              /* CURRENT_FH: directory */\n          \
    \    component4     file_delegate_prev;\n     };\n   RESULT\n   struct open_read_delegation4\
    \ {\n           stateid4        stateid;        /* Stateid for delegation*/\n\
    \           bool            recall;         /* Pre-recalled flag for\n       \
    \                                       delegations obtained\n               \
    \                               by reclaim\n                                 \
    \             (CLAIM_PREVIOUS) */\n           nfsace4         permissions;   \
    \ /* Defines users who don't\n                                              need\
    \ an ACCESS call to\n                                              open for read\
    \ */\n   };\n   struct open_write_delegation4 {\n           stateid4        stateid;\
    \        /* Stateid for delegation*/\n           bool            recall;     \
    \    /* Pre-recalled flag for\n                                              delegations\
    \ obtained\n                                              by reclaim\n       \
    \                                       (CLAIM_PREVIOUS) */\n           nfs_space_limit4\
    \ space_limit;   /* Defines condition that\n                                 \
    \             the client must check to\n                                     \
    \         determine whether the\n                                            \
    \  file needs to be flushed\n                                              to\
    \ the server on close.\n                                              */\n   \
    \        nfsace4         permissions;    /* Defines users who don't\n        \
    \                                      need an ACCESS call as\n              \
    \                                part of a delegated\n                       \
    \                       open. */\n   };\n   union open_delegation4\n   switch\
    \ (open_delegation_type4 delegation_type) {\n           case OPEN_DELEGATE_NONE:\n\
    \                   void;\n           case OPEN_DELEGATE_READ:\n             \
    \      open_read_delegation4 read;\n           case OPEN_DELEGATE_WRITE:\n   \
    \                open_write_delegation4 write;\n   };\n   const OPEN4_RESULT_CONFIRM\
    \      = 0x00000002;\n   const OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004;\n   struct\
    \ OPEN4resok {\n           stateid4        stateid;        /* Stateid for open\
    \ */\n           change_info4    cinfo;          /* Directory Change Info */\n\
    \           uint32_t        rflags;         /* Result flags */\n           bitmap4\
    \         attrset;        /* attributes on create */\n           open_delegation4\
    \ delegation;    /* Info on any open\n                                       \
    \       delegation */\n   };\n   union OPEN4res switch (nfsstat4 status) {\n \
    \   case NFS4_OK:\n           /* CURRENT_FH: opened file */\n           OPEN4resok\
    \      resok4;\n    default:\n           void;\n   };\n   WARNING TO CLIENT IMPLEMENTORS\n\
    \   OPEN resembles LOOKUP in that it generates a filehandle for the\n   client\
    \ to use.  Unlike LOOKUP though, OPEN creates server state on\n   the filehandle.\
    \  In normal circumstances, the client can only release\n   this state with a\
    \ CLOSE operation.  CLOSE uses the current filehandle\n   to determine which file\
    \ to close.  Therefore the client MUST follow\n   every OPEN operation with a\
    \ GETFH operation in the same COMPOUND\n   procedure.  This will supply the client\
    \ with the filehandle such that\n   CLOSE can be used appropriately.\n   Simply\
    \ waiting for the lease on the file to expire is insufficient\n   because the\
    \ server may maintain the state indefinitely as long as\n   another client does\
    \ not attempt to make a conflicting access to the\n   same file.\n   DESCRIPTION\n\
    \   The OPEN operation creates and/or opens a regular file in a directory\n  \
    \ with the provided name.  If the file does not exist at the server and\n   creation\
    \ is desired, specification of the method of creation is\n   provided by the openhow\
    \ parameter.  The client has the choice of\n   three creation methods: UNCHECKED,\
    \ GUARDED, or EXCLUSIVE.\n   If the current filehandle is a named attribute directory,\
    \ OPEN will\n   then create or open a named attribute file.  Note that exclusive\n\
    \   create of a named attribute is not supported.  If the createmode is\n   EXCLUSIVE4\
    \ and the current filehandle is a named attribute directory,\n   the server will\
    \ return EINVAL.\n   UNCHECKED means that the file should be created if a file\
    \ of that\n   name does not exist and encountering an existing regular file of\
    \ that\n   name is not an error.  For this type of create, createattrs specifies\n\
    \   the initial set of attributes for the file.  The set of attributes\n   may\
    \ include any writable attribute valid for regular files.  When an\n   UNCHECKED\
    \ create encounters an existing file, the attributes\n   specified by createattrs\
    \ are not used, except that when an size of\n   zero is specified, the existing\
    \ file is truncated.  If GUARDED is\n   specified, the server checks for the presence\
    \ of a duplicate object\n   by name before performing the create.  If a duplicate\
    \ exists, an\n   error of NFS4ERR_EXIST is returned as the status.  If the object\
    \ does\n   not exist, the request is performed as described for UNCHECKED.  For\n\
    \   each of these cases (UNCHECKED and GUARDED) where the operation is\n   successful,\
    \ the server will return to the client an attribute mask\n   signifying which\
    \ attributes were successfully set for the object.\n   EXCLUSIVE specifies that\
    \ the server is to follow exclusive creation\n   semantics, using the verifier\
    \ to ensure exclusive creation of the\n   target.  The server should check for\
    \ the presence of a duplicate\n   object by name.  If the object does not exist,\
    \ the server creates the\n   object and stores the verifier with the object. \
    \ If the object does\n   exist and the stored verifier matches the client provided\
    \ verifier,\n   the server uses the existing object as the newly created object.\
    \  If\n   the stored verifier does not match, then an error of NFS4ERR_EXIST is\n\
    \   returned.  No attributes may be provided in this case, since the\n   server\
    \ may use an attribute of the target object to store the\n   verifier.  If the\
    \ server uses an attribute to store the exclusive\n   create verifier, it will\
    \ signify which attribute by setting the\n   appropriate bit in the attribute\
    \ mask that is returned in the\n   results.\n   For the target directory, the\
    \ server returns change_info4 information\n   in cinfo.  With the atomic field\
    \ of the change_info4 struct, the\n   server will indicate if the before and after\
    \ change attributes were\n   obtained atomically with respect to the link creation.\n\
    \   Upon successful creation, the current filehandle is replaced by that\n   of\
    \ the new object.\n   The OPEN operation provides for Windows share reservation\
    \ capability\n   with the use of the share_access and share_deny fields of the\
    \ OPEN\n   arguments.  The client specifies at OPEN the required share_access\n\
    \   and share_deny modes.  For clients that do not directly support\n   SHAREs\
    \ (i.e., UNIX), the expected deny value is DENY_NONE.  In the\n   case that there\
    \ is a existing SHARE reservation that conflicts with\n   the OPEN request, the\
    \ server returns the error NFS4ERR_SHARE_DENIED.\n   For a complete SHARE request,\
    \ the client must provide values for the\n   owner and seqid fields for the OPEN\
    \ argument.  For additional\n   discussion of SHARE semantics see the section\
    \ on 'Share\n   Reservations'.\n   In the case that the client is recovering state\
    \ from a server\n   failure, the claim field of the OPEN argument is used to signify\
    \ that\n   the request is meant to reclaim state previously held.\n   The \"claim\"\
    \ field of the OPEN argument is used to specify the file to\n   be opened and\
    \ the state information which the client claims to\n   possess.  There are four\
    \ basic claim types which cover the various\n   situations for an OPEN.  They\
    \ are as follows:\n   CLAIM_NULL\n                         For the client, this\
    \ is a new OPEN\n                         request and there is no previous state\n\
    \                         associate with the file for the client.\n   CLAIM_PREVIOUS\n\
    \                         The client is claiming basic OPEN state\n          \
    \               for a file that was held previous to a\n                     \
    \    server reboot.  Generally used when a\n                         server is\
    \ returning persistent\n                         filehandles; the client may not\
    \ have the\n                         file name to reclaim the OPEN.\n   CLAIM_DELEGATE_CUR\n\
    \                         The client is claiming a delegation for\n          \
    \               OPEN as granted by the server.\n                         Generally\
    \ this is done as part of\n                         recalling a delegation.\n\
    \   CLAIM_DELEGATE_PREV\n                         The client is claiming a delegation\n\
    \                         granted to a previous client instance;\n           \
    \              used after the client reboots. The\n                         server\
    \ MAY support CLAIM_DELEGATE_PREV.\n                         If it does support\
    \ CLAIM_DELEGATE_PREV,\n                         SETCLIENTID_CONFIRM MUST NOT\
    \ remove the\n                         client's delegation state, and the\n  \
    \                       server MUST support the DELEGPURGE\n                 \
    \        operation.\n   For OPEN requests whose claim type is other than CLAIM_PREVIOUS\n\
    \   (i.e., requests other than those devoted to reclaiming opens after a\n   server\
    \ reboot) that reach the server during its grace or lease\n   expiration period,\
    \ the server returns an error of NFS4ERR_GRACE.\n   For any OPEN request, the\
    \ server may return an open delegation, which\n   allows further opens and closes\
    \ to be handled locally on the client\n   as described in the section Open Delegation.\
    \  Note that delegation is\n   up to the server to decide.  The client should\
    \ never assume that\n   delegation will or will not be granted in a particular\
    \ instance.  It\n   should always be prepared for either case.  A partial exception\
    \ is\n   the reclaim (CLAIM_PREVIOUS) case, in which a delegation type is\n  \
    \ claimed.  In this case, delegation will always be granted, although\n   the\
    \ server may specify an immediate recall in the delegation\n   structure.\n  \
    \ The rflags returned by a successful OPEN allow the server to return\n   information\
    \ governing how the open file is to be handled.\n   OPEN4_RESULT_CONFIRM indicates\
    \ that the client MUST execute an\n   OPEN_CONFIRM operation before using the\
    \ open file.\n   OPEN4_RESULT_LOCKTYPE_POSIX indicates the server's file locking\n\
    \   behavior supports the complete set of Posix locking techniques.  From\n  \
    \ this the client can choose to manage file locking state in a way to\n   handle\
    \ a mis-match of file locking management.\n   If the component is of zero length,\
    \ NFS4ERR_INVAL will be returned.\n   The component is also subject to the normal\
    \ UTF-8, character support,\n   and name checks.  See the section \"UTF-8 Related\
    \ Errors\" for further\n   discussion.\n   When an OPEN is done and the specified\
    \ lockowner already has the\n   resulting filehandle open, the result is to \"\
    OR\" together the new\n   share and deny status together with the existing status.\
    \  In this\n   case, only a single CLOSE need be done, even though multiple OPENs\n\
    \   were completed.  When such an OPEN is done, checking of share\n   reservations\
    \ for the new OPEN proceeds normally, with no exception\n   for the existing OPEN\
    \ held by the same lockowner.\n   If the underlying filesystem at the server is\
    \ only accessible in a\n   read-only mode and the OPEN request has specified ACCESS_WRITE\
    \ or\n   ACCESS_BOTH, the server will return NFS4ERR_ROFS to indicate a read-\n\
    \   only filesystem.\n   As with the CREATE operation, the server MUST derive\
    \ the owner, owner\n   ACE, group, or group ACE if any of the four attributes\
    \ are required\n   and supported by the server's filesystem.  For an OPEN with\
    \ the\n   EXCLUSIVE4 createmode, the server has no choice, since such OPEN\n \
    \  calls do not include the createattrs field.  Conversely, if\n   createattrs\
    \ is specified, and includes owner or group (or\n   corresponding ACEs) that the\
    \ principal in the RPC call's credentials\n   does not have authorization to create\
    \ files for, then the server may\n   return NFS4ERR_PERM.\n   In the case of a\
    \ OPEN which specifies a size of zero (e.g.,\n   truncation) and the file has\
    \ named attributes, the named attributes\n   are left as is.  They are not removed.\n\
    \   IMPLEMENTATION\n   The OPEN operation contains support for EXCLUSIVE create.\
    \  The\n   mechanism is similar to the support in NFS version 3 [RFC1813].  As\n\
    \   in NFS version 3, this mechanism provides reliable exclusive\n   creation.\
    \  Exclusive create is invoked when the how parameter is\n   EXCLUSIVE.  In this\
    \ case, the client provides a verifier that can\n   reasonably be expected to\
    \ be unique.  A combination of a client\n   identifier, perhaps the client network\
    \ address, and a unique number\n   generated by the client, perhaps the RPC transaction\
    \ identifier, may\n   be appropriate.\n   If the object does not exist, the server\
    \ creates the object and\n   stores the verifier in stable storage. For filesystems\
    \ that do not\n   provide a mechanism for the storage of arbitrary file attributes,\
    \ the\n   server may use one or more elements of the object meta-data to store\n\
    \   the verifier. The verifier must be stored in stable storage to\n   prevent\
    \ erroneous failure on retransmission of the request. It is\n   assumed that an\
    \ exclusive create is being performed because exclusive\n   semantics are critical\
    \ to the application. Because of the expected\n   usage, exclusive CREATE does\
    \ not rely solely on the normally volatile\n   duplicate request cache for storage\
    \ of the verifier. The duplicate\n   request cache in volatile storage does not\
    \ survive a crash and may\n   actually flush on a long network partition, opening\
    \ failure windows.\n   In the UNIX local filesystem environment, the expected\
    \ storage\n   location for the verifier on creation is the meta-data (time stamps)\n\
    \   of the object. For this reason, an exclusive object create may not\n   include\
    \ initial attributes because the server would have nowhere to\n   store the verifier.\n\
    \   If the server can not support these exclusive create semantics,\n   possibly\
    \ because of the requirement to commit the verifier to stable\n   storage, it\
    \ should fail the OPEN request with the error,\n   NFS4ERR_NOTSUPP.\n   During\
    \ an exclusive CREATE request, if the object already exists, the\n   server reconstructs\
    \ the object's verifier and compares it with the\n   verifier in the request.\
    \ If they match, the server treats the request\n   as a success. The request is\
    \ presumed to be a duplicate of an\n   earlier, successful request for which the\
    \ reply was lost and that the\n   server duplicate request cache mechanism did\
    \ not detect.  If the\n   verifiers do not match, the request is rejected with\
    \ the status,\n   NFS4ERR_EXIST.\n   Once the client has performed a successful\
    \ exclusive create, it must\n   issue a SETATTR to set the correct object attributes.\
    \  Until it does\n   so, it should not rely upon any of the object attributes,\
    \ since the\n   server implementation may need to overload object meta-data to\
    \ store\n   the verifier.  The subsequent SETATTR must not occur in the same\n\
    \   COMPOUND request as the OPEN.  This separation will guarantee that\n   the\
    \ exclusive create mechanism will continue to function properly in\n   the face\
    \ of retransmission of the request.\n   Use of the GUARDED attribute does not\
    \ provide exactly-once semantics.\n   In particular, if a reply is lost and the\
    \ server does not detect the\n   retransmission of the request, the operation\
    \ can fail with\n   NFS4ERR_EXIST, even though the create was performed successfully.\n\
    \   The client would use this behavior in the case that the application\n   has\
    \ not requested an exclusive create but has asked to have the file\n   truncated\
    \ when the file is opened.  In the case of the client timing\n   out and retransmitting\
    \ the create request, the client can use GUARDED\n   to prevent against a sequence\
    \ like: create, write, create\n   (retransmitted) from occurring.\n   For SHARE\
    \ reservations, the client must specify a value for\n   share_access that is one\
    \ of READ, WRITE, or BOTH.  For share_deny,\n   the client must specify one of\
    \ NONE, READ, WRITE, or BOTH.  If the\n   client fails to do this, the server\
    \ must return NFS4ERR_INVAL.\n   Based on the share_access value (READ, WRITE,\
    \ or BOTH) the client\n   should check that the requester has the proper access\
    \ rights to\n   perform the specified operation.  This would generally be the\
    \ results\n   of applying the ACL access rules to the file for the current\n \
    \  requester.  However, just as with the ACCESS operation, the client\n   should\
    \ not attempt to second-guess the server's decisions, as access\n   rights may\
    \ change and may be subject to server administrative\n   controls outside the\
    \ ACL framework.  If the requester is not\n   authorized to READ or WRITE (depending\
    \ on the share_access value),\n   the server must return NFS4ERR_ACCESS.  Note\
    \ that since the NFS\n   version 4 protocol does not impose any requirement that\
    \ READs and\n   WRITEs issued for an open file have the same credentials as the\
    \ OPEN\n   itself, the server still must do appropriate access checking on the\n\
    \   READs and WRITEs themselves.\n   If the component provided to OPEN is a symbolic\
    \ link, the error\n   NFS4ERR_SYMLINK will be returned to the client.  If the\
    \ current\n   filehandle is not a directory, the error NFS4ERR_NOTDIR will be\n\
    \   returned.\n   ERRORS\n      NFS4ERR_ACCESS\n      NFS4ERR_ADMIN_REVOKED\n\
    \      NFS4ERR_ATTRNOTSUPP\n      NFS4ERR_BADCHAR\n      NFS4ERR_BADHANDLE\n \
    \     NFS4ERR_BADNAME\n      NFS4ERR_BADOWNER\n      NFS4ERR_BAD_SEQID\n     \
    \ NFS4ERR_BADXDR\n      NFS4ERR_DELAY\n      NFS4ERR_DQUOT\n      NFS4ERR_EXIST\n\
    \      NFS4ERR_EXPIRED\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_GRACE\n      NFS4ERR_IO\n\
    \      NFS4ERR_INVAL\n      NFS4ERR_ISDIR\n      NFS4ERR_LEASE_MOVED\n      NFS4ERR_MOVED\n\
    \      NFS4ERR_NAMETOOLONG\n      NFS4ERR_NOENT\n      NFS4ERR_NOFILEHANDLE\n\
    \      NFS4ERR_NOSPC\n      NFS4ERR_NOTDIR\n      NFS4ERR_NOTSUPP\n      NFS4ERR_NO_GRACE\n\
    \      NFS4ERR_PERM\n      NFS4ERR_RECLAIM_BAD\n      NFS4ERR_RECLAIM_CONFLICT\n\
    \      NFS4ERR_RESOURCE\n      NFS4ERR_ROFS\n      NFS4ERR_SERVERFAULT\n     \
    \ NFS4ERR_SHARE_DENIED\n      NFS4ERR_STALE\n      NFS4ERR_STALE_CLIENTID\n  \
    \    NFS4ERR_SYMLINK\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.17.  Operation 19: OPENATTR - Open Named Attribute Directory'
  contents:
  - "14.2.17.  Operation 19: OPENATTR - Open Named Attribute Directory\n   SYNOPSIS\n\
    \     (cfh) createdir -> (cfh)\n   ARGUMENT\n     struct OPENATTR4args {\n   \
    \          /* CURRENT_FH: object */\n             bool    createdir;\n     };\n\
    \   RESULT\n     struct OPENATTR4res {\n             /* CURRENT_FH: named attr\
    \ directory*/\n             nfsstat4        status;\n     };\n   DESCRIPTION\n\
    \   The OPENATTR operation is used to obtain the filehandle of the named\n   attribute\
    \ directory associated with the current filehandle.  The\n   result of the OPENATTR\
    \ will be a filehandle to an object of type\n   NF4ATTRDIR.  From this filehandle,\
    \ READDIR and LOOKUP operations can\n   be used to obtain filehandles for the\
    \ various named attributes\n   associated with the original filesystem object.\
    \  Filehandles returned\n   within the named attribute directory will have a type\
    \ of\n   NF4NAMEDATTR.\n   The createdir argument allows the client to signify\
    \ if a named\n   attribute directory should be created as a result of the OPENATTR\n\
    \   operation.  Some clients may use the OPENATTR operation with a value\n   of\
    \ FALSE for createdir to determine if any named attributes exist for\n   the object.\
    \  If none exist, then NFS4ERR_NOENT will be returned.  If\n   createdir has a\
    \ value of TRUE and no named attribute directory\n   exists, one is created. \
    \ The creation of a named attribute directory\n   assumes that the server has\
    \ implemented named attribute support in\n   this fashion and is not required\
    \ to do so by this definition.\n   IMPLEMENTATION\n   If the server does not support\
    \ named attributes for the current\n   filehandle, an error of NFS4ERR_NOTSUPP\
    \ will be returned to the\n   client.\n   ERRORS\n      NFS4ERR_ACCESS\n     \
    \ NFS4ERR_BADHANDLE\n      NFS4ERR_BADXDR\n      NFS4ERR_DELAY\n      NFS4ERR_DQUOT\n\
    \      NFS4ERR_FHEXPIRED\n      NFS4ERR_IO\n      NFS4ERR_MOVED\n      NFS4ERR_NOENT\n\
    \      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOSPC\n      NFS4ERR_NOTSUPP\n    \
    \  NFS4ERR_RESOURCE\n      NFS4ERR_ROFS\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n"
- title: '14.2.18.  Operation 20: OPEN_CONFIRM - Confirm Open'
  contents:
  - "14.2.18.  Operation 20: OPEN_CONFIRM - Confirm Open\n   SYNOPSIS\n     (cfh),\
    \ seqid, stateid-> stateid\n   ARGUMENT\n     struct OPEN_CONFIRM4args {\n   \
    \          /* CURRENT_FH: opened file */\n             stateid4        open_stateid;\n\
    \             seqid4          seqid;\n     };\n   RESULT\n     struct OPEN_CONFIRM4resok\
    \ {\n             stateid4        open_stateid;\n     };\n     union OPEN_CONFIRM4res\
    \ switch (nfsstat4 status) {\n      case NFS4_OK:\n              OPEN_CONFIRM4resok\
    \     resok4;\n      default:\n              void;\n     };\n   DESCRIPTION\n\
    \   This operation is used to confirm the sequence id usage for the first\n  \
    \ time that a open_owner is used by a client.  The stateid returned\n   from the\
    \ OPEN operation is used as the argument for this operation\n   along with the\
    \ next sequence id for the open_owner.  The sequence id\n   passed to the OPEN_CONFIRM\
    \ must be 1 (one) greater than the seqid\n   passed to the OPEN operation from\
    \ which the open_confirm value was\n   obtained.  If the server receives an unexpected\
    \ sequence id with\n   respect to the original open, then the server assumes that\
    \ the client\n   will not confirm the original OPEN and all state associated with\
    \ the\n   original OPEN is released by the server.\n   On success, the current\
    \ filehandle retains its value.\n   IMPLEMENTATION\n   A given client might generate\
    \ many open_owner4 data structures for a\n   given clientid.  The client will\
    \ periodically either dispose of its\n   open_owner4s or stop using them for indefinite\
    \ periods of time.  The\n   latter situation is why the NFS version 4 protocol\
    \ does not have an\n   explicit operation to exit an open_owner4: such an operation\
    \ is of no\n   use in that situation.  Instead, to avoid unbounded memory use,\
    \ the\n   server needs to implement a strategy for disposing of open_owner4s\n\
    \   that have no current lock, open, or delegation state for any files\n   and\
    \ have not been used recently.  The time period used to determine\n   when to\
    \ dispose of open_owner4s is an implementation choice.  The\n   time period should\
    \ certainly be no less than the lease time plus any\n   grace period the server\
    \ wishes to implement beyond a lease time.  The\n   OPEN_CONFIRM operation allows\
    \ the server to safely dispose of unused\n   open_owner4 data structures.\n  \
    \ In the case that a client issues an OPEN operation and the server no\n   longer\
    \ has a record of the open_owner4, the server needs to ensure\n   that this is\
    \ a new OPEN and not a replay or retransmission.\n   Servers must not require\
    \ confirmation on OPENs that grant delegations\n   or are doing reclaim operations.\
    \  See section \"Use of Open\n   Confirmation\" for details.  The server can easily\
    \ avoid this by\n   noting whether it has disposed of one open_owner4 for the\
    \ given\n   clientid.  If the server does not support delegation, it might simply\n\
    \   maintain a single bit that notes whether any open_owner4 (for any\n   client)\
    \ has been disposed of.\n   The server must hold unconfirmed OPEN state until\
    \ one of three events\n   occur.  First, the client sends an OPEN_CONFIRM request\
    \ with the\n   appropriate sequence id and stateid within the lease period.  In\
    \ this\n   case, the OPEN state on the server goes to confirmed, and the\n   open_owner4\
    \ on the server is fully established.\n   Second, the client sends another OPEN\
    \ request with a sequence id that\n   is incorrect for the open_owner4 (out of\
    \ sequence).  In this case,\n   the server assumes the second OPEN request is\
    \ valid and the first one\n   is a replay.  The server cancels the OPEN state\
    \ of the first OPEN\n   request, establishes an unconfirmed OPEN state for the\
    \ second OPEN\n   request, and responds to the second OPEN request with an indication\n\
    \   that an OPEN_CONFIRM is needed.  The process then repeats itself.\n   While\
    \ there is a potential for a denial of service attack on the\n   client, it is\
    \ mitigated if the client and server require the use of a\n   security flavor\
    \ based on Kerberos V5, LIPKEY, or some other flavor\n   that uses cryptography.\n\
    \   What if the server is in the unconfirmed OPEN state for a given\n   open_owner4,\
    \ and it receives an operation on the open_owner4 that has\n   a stateid but the\
    \ operation is not OPEN, or it is OPEN_CONFIRM but\n   with the wrong stateid?\
    \  Then, even if the seqid is correct, the\n   server returns NFS4ERR_BAD_STATEID,\
    \ because the server assumes the\n   operation is a replay: if the server has\
    \ no established OPEN state,\n   then there is no way, for example, a LOCK operation\
    \ could be valid.\n   Third, neither of the two aforementioned events occur for\
    \ the\n   open_owner4 within the lease period.  In this case, the OPEN state is\n\
    \   canceled and disposal of the open_owner4 can occur.\n   ERRORS\n      NFS4ERR_ADMIN_REVOKED\n\
    \      NFS4ERR_BADHANDLE\n      NFS4ERR_BAD_SEQID\n      NFS4ERR_BAD_STATEID\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_EXPIRED\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n\
    \      NFS4ERR_ISDIR\n      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_OLD_STATEID\n\
    \      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n    \
    \  NFS4ERR_STALE_STATEID\n"
- title: '14.2.19.  Operation 21: OPEN_DOWNGRADE - Reduce Open File Access'
  contents:
  - "14.2.19.  Operation 21: OPEN_DOWNGRADE - Reduce Open File Access\n   SYNOPSIS\n\
    \     (cfh), stateid, seqid, access, deny -> stateid\n   ARGUMENT\n     struct\
    \ OPEN_DOWNGRADE4args {\n             /* CURRENT_FH: opened file */\n        \
    \     stateid4        open_stateid;\n             seqid4          seqid;\n   \
    \          uint32_t        share_access;\n             uint32_t        share_deny;\n\
    \     };\n   RESULT\n     struct OPEN_DOWNGRADE4resok {\n             stateid4\
    \        open_stateid;\n     };\n     union OPEN_DOWNGRADE4res switch(nfsstat4\
    \ status) {\n      case NFS4_OK:\n             OPEN_DOWNGRADE4resok    resok4;\n\
    \      default:\n             void;\n     };\n   DESCRIPTION\n   This operation\
    \ is used to adjust the share_access and share_deny bits\n   for a given open.\
    \  This is necessary when a given openowner opens the\n   same file multiple times\
    \ with different share_access and share_deny\n   flags.  In this situation, a\
    \ close of one of the opens may change the\n   appropriate share_access and share_deny\
    \ flags to remove bits\n   associated with opens no longer in effect.\n   The\
    \ share_access and share_deny bits specified in this operation\n   replace the\
    \ current ones for the specified open file.  The\n   share_access and share_deny\
    \ bits specified must be exactly equal to\n   the union of the share_access and\
    \ share_deny bits specified for some\n   subset of the OPENs in effect for current\
    \ openowner on the current\n   file.  If that constraint is not respected, the\
    \ error NFS4ERR_INVAL\n   should be returned.  Since share_access and share_deny\
    \ bits are\n   subsets of those already granted, it is not possible for this request\n\
    \   to be denied because of conflicting share reservations.\n   On success, the\
    \ current filehandle retains its value.\n   ERRORS\n      NFS4ERR_ADMIN_REVOKED\n\
    \      NFS4ERR_BADHANDLE\n      NFS4ERR_BAD_SEQID\n      NFS4ERR_BAD_STATEID\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_EXPIRED\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n\
    \      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_OLD_STATEID\n\
    \      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n    \
    \  NFS4ERR_STALE_STATEID\n"
- title: '14.2.20.  Operation 22: PUTFH - Set Current Filehandle'
  contents:
  - "14.2.20.  Operation 22: PUTFH - Set Current Filehandle\n   SYNOPSIS\n     filehandle\
    \ -> (cfh)\n   ARGUMENT\n     struct PUTFH4args {\n             nfs_fh4      \
    \   object;\n     };\n   RESULT\n     struct PUTFH4res {\n             /* CURRENT_FH:\
    \ */\n             nfsstat4        status;\n     };\n   DESCRIPTION\n   Replaces\
    \ the current filehandle with the filehandle provided as an\n   argument.\n  \
    \ If the security mechanism used by the requester does not meet the\n   requirements\
    \ of the filehandle provided to this operation, the server\n   MUST return NFS4ERR_WRONGSEC.\n\
    \   IMPLEMENTATION\n   Commonly used as the first operator in an NFS request to\
    \ set the\n   context for following operations.\n   ERRORS\n      NFS4ERR_BADHANDLE\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_MOVED\n      NFS4ERR_RESOURCE\n\
    \      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.21.  Operation 23: PUTPUBFH - Set Public Filehandle'
  contents:
  - "14.2.21.  Operation 23: PUTPUBFH - Set Public Filehandle\n   SYNOPSIS\n     -\
    \ -> (cfh)\n   ARGUMENT\n     void;\n   RESULT\n     struct PUTPUBFH4res {\n \
    \            /* CURRENT_FH: public fh */\n             nfsstat4        status;\n\
    \     };\n   DESCRIPTION\n   Replaces the current filehandle with the filehandle\
    \ that represents\n   the public filehandle of the server's name space.  This\
    \ filehandle\n   may be different from the \"root\" filehandle which may be associated\n\
    \   with some other directory on the server.\n   The public filehandle represents\
    \ the concepts embodied in [RFC2054],\n   [RFC2055], [RFC2224].  The intent for\
    \ NFS version 4 is that the\n   public filehandle (represented by the PUTPUBFH\
    \ operation) be used as\n   a method of providing WebNFS server compatibility\
    \ with NFS versions 2\n   and 3.\n   The public filehandle and the root filehandle\
    \ (represented by the\n   PUTROOTFH operation) should be equivalent.  If the public\
    \ and root\n   filehandles are not equivalent, then the public filehandle MUST\
    \ be a\n   descendant of the root filehandle.\n   IMPLEMENTATION\n   Used as the\
    \ first operator in an NFS request to set the context for\n   following operations.\n\
    \   With the NFS version 2 and 3 public filehandle, the client is able to\n  \
    \ specify whether the path name provided in the LOOKUP should be\n   evaluated\
    \ as either an absolute path relative to the server's root or\n   relative to\
    \ the public filehandle.  [RFC2224] contains further\n   discussion of the functionality.\
    \  With NFS version 4, that type of\n   specification is not directly available\
    \ in the LOOKUP operation.  The\n   reason for this is because the component separators\
    \ needed to specify\n   absolute vs. relative are not allowed in NFS version 4.\
    \  Therefore,\n   the client is responsible for constructing its request such\
    \ that the\n   use of either PUTROOTFH or PUTPUBFH are used to signify absolute\
    \ or\n   relative evaluation of an NFS URL respectively.\n   Note that there are\
    \ warnings mentioned in [RFC2224] with respect to\n   the use of absolute evaluation\
    \ and the restrictions the server may\n   place on that evaluation with respect\
    \ to how much of its namespace\n   has been made available.  These same warnings\
    \ apply to NFS version 4.\n   It is likely, therefore that because of server implementation\n\
    \   details, an NFS version 3 absolute public filehandle lookup may\n   behave\
    \ differently than an NFS version 4 absolute resolution.\n   There is a form of\
    \ security negotiation as described in [RFC2755]\n   that uses the public filehandle\
    \ a method of employing SNEGO.  This\n   method is not available with NFS version\
    \ 4 as filehandles are not\n   overloaded with special meaning and therefore do\
    \ not provide the same\n   framework as NFS versions 2 and 3.  Clients should\
    \ therefore use the\n   security negotiation mechanisms described in this RFC.\n\
    \   ERRORS\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.22.  Operation 24: PUTROOTFH - Set Root Filehandle'
  contents:
  - "14.2.22.  Operation 24: PUTROOTFH - Set Root Filehandle\n   SYNOPSIS\n     -\
    \ -> (cfh)\n   ARGUMENT\n     void;\n   RESULT\n     struct PUTROOTFH4res {\n\
    \             /* CURRENT_FH: root fh */\n             nfsstat4        status;\n\
    \     };\n   DESCRIPTION\n   Replaces the current filehandle with the filehandle\
    \ that represents\n   the root of the server's name space.  From this filehandle\
    \ a LOOKUP\n   operation can locate any other filehandle on the server. This\n\
    \   filehandle may be different from the \"public\" filehandle which may be\n\
    \   associated with some other directory on the server.\n   IMPLEMENTATION\n \
    \  Commonly used as the first operator in an NFS request to set the\n   context\
    \ for following operations.\n   ERRORS\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n\
    \      NFS4ERR_WRONGSEC\n"
- title: '14.2.23.  Operation 25: READ - Read from File'
  contents:
  - "14.2.23.  Operation 25: READ - Read from File\n   SYNOPSIS\n     (cfh), stateid,\
    \ offset, count -> eof, data\n   ARGUMENT\n     struct READ4args {\n         \
    \    /* CURRENT_FH: file */\n             stateid4        stateid;\n         \
    \    offset4         offset;\n             count4          count;\n     };\n \
    \  RESULT\n     struct READ4resok {\n             bool            eof;\n     \
    \        opaque          data<>;\n     };\n     union READ4res switch (nfsstat4\
    \ status) {\n      case NFS4_OK:\n              READ4resok     resok4;\n     \
    \ default:\n              void;\n     };\n   DESCRIPTION\n   The READ operation\
    \ reads data from the regular file identified by the\n   current filehandle.\n\
    \   The client provides an offset of where the READ is to start and a\n   count\
    \ of how many bytes are to be read.  An offset of 0 (zero) means\n   to read data\
    \ starting at the beginning of the file.  If offset is\n   greater than or equal\
    \ to the size of the file, the status, NFS4_OK,\n   is returned with a data length\
    \ set to 0 (zero) and eof is set to\n   TRUE.  The READ is subject to access permissions\
    \ checking.\n   If the client specifies a count value of 0 (zero), the READ succeeds\n\
    \   and returns 0 (zero) bytes of data again subject to access\n   permissions\
    \ checking.  The server may choose to return fewer bytes\n   than specified by\
    \ the client.  The client needs to check for this\n   condition and handle the\
    \ condition appropriately.\n   The stateid value for a READ request represents\
    \ a value returned from\n   a previous record lock or share reservation request.\
    \  The stateid is\n   used by the server to verify that the associated share reservation\n\
    \   and any record locks are still valid and to update lease timeouts for\n  \
    \ the client.\n   If the read ended at the end-of-file (formally, in a correctly\
    \ formed\n   READ request, if offset + count is equal to the size of the file),\
    \ or\n   the read request extends beyond the size of the file (if offset +\n \
    \  count is greater than the size of the file), eof is returned as TRUE;\n   otherwise\
    \ it is FALSE.  A successful READ of an empty file will\n   always return eof\
    \ as TRUE.\n   If the current filehandle is not a regular file, an error will\
    \ be\n   returned to the client.  In the case the current filehandle\n   represents\
    \ a directory, NFS4ERR_ISDIR is return; otherwise,\n   NFS4ERR_INVAL is returned.\n\
    \   For a READ with a stateid value of all bits 0, the server MAY allow\n   the\
    \ READ to be serviced subject to mandatory file locks or the\n   current share\
    \ deny modes for the file.  For a READ with a stateid\n   value of all bits 1,\
    \ the server MAY allow READ operations to bypass\n   locking checks at the server.\n\
    \   On success, the current filehandle retains its value.\n   IMPLEMENTATION\n\
    \   It is possible for the server to return fewer than count bytes of\n   data.\
    \  If the server returns less than the count requested and eof is\n   set to FALSE,\
    \ the client should issue another READ to get the\n   remaining data.  A server\
    \ may return less data than requested under\n   several circumstances.  The file\
    \ may have been truncated by another\n   client or perhaps on the server itself,\
    \ changing the file size from\n   what the requesting client believes to be the\
    \ case.  This would\n   reduce the actual amount of data available to the client.\
    \  It is\n   possible that the server may back off the transfer size and reduce\n\
    \   the read request return.  Server resource exhaustion may also occur\n   necessitating\
    \ a smaller read return.\n   If mandatory file locking is on for the file, and\
    \ if the region\n   corresponding to the data to be read from file is write locked\
    \ by an\n   owner not associated the stateid, the server will return the\n   NFS4ERR_LOCKED\
    \ error.  The client should try to get the appropriate\n   read record lock via\
    \ the LOCK operation before re-attempting the\n   READ.  When the READ completes,\
    \ the client should release the record\n   lock via LOCKU.\n   ERRORS\n      NFS4ERR_ACCESS\n\
    \      NFS4ERR_ADMIN_REVOKED\n      NFS4ERR_BADHANDLE\n      NFS4ERR_BAD_STATEID\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_DELAY\n      NFS4ERR_EXPIRED\n      NFS4ERR_FHEXPIRED\n\
    \      NFS4ERR_GRACE\n      NFS4ERR_IO\n      NFS4ERR_INVAL\n      NFS4ERR_ISDIR\n\
    \      NFS4ERR_LEASE_MOVED\n      NFS4ERR_LOCKED\n      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n\
    \      NFS4ERR_NXIO\n      NFS4ERR_OLD_STATEID\n      NFS4ERR_OPENMODE\n     \
    \ NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_STALE_STATEID\n"
- title: '14.2.24.  Operation 26: READDIR - Read Directory'
  contents:
  - "14.2.24.  Operation 26: READDIR - Read Directory\n   SYNOPSIS\n      (cfh), cookie,\
    \ cookieverf, dircount, maxcount, attr_request ->\n      cookieverf { cookie,\
    \ name, attrs }\n   ARGUMENT\n     struct READDIR4args {\n             /* CURRENT_FH:\
    \ directory */\n             nfs_cookie4     cookie;\n             verifier4 \
    \      cookieverf;\n             count4          dircount;\n             count4\
    \          maxcount;\n             bitmap4         attr_request;\n     };\n  \
    \ RESULT\n     struct entry4 {\n             nfs_cookie4     cookie;\n       \
    \      component4      name;\n             fattr4          attrs;\n          \
    \   entry4          *nextentry;\n     };\n     struct dirlist4 {\n           \
    \  entry4          *entries;\n             bool            eof;\n     };\n   \
    \  struct READDIR4resok {\n             verifier4       cookieverf;\n        \
    \     dirlist4        reply;\n     };\n     union READDIR4res switch (nfsstat4\
    \ status) {\n      case NFS4_OK:\n              READDIR4resok  resok4;\n     \
    \ default:\n              void;\n     };\n   DESCRIPTION\n   The READDIR operation\
    \ retrieves a variable number of entries from a\n   filesystem directory and returns\
    \ client requested attributes for each\n   entry along with information to allow\
    \ the client to request\n   additional directory entries in a subsequent READDIR.\n\
    \   The arguments contain a cookie value that represents where the\n   READDIR\
    \ should start within the directory.  A value of 0 (zero) for\n   the cookie is\
    \ used to start reading at the beginning of the\n   directory.  For subsequent\
    \ READDIR requests, the client specifies a\n   cookie value that is provided by\
    \ the server on a previous READDIR\n   request.\n   The cookieverf value should\
    \ be set to 0 (zero) when the cookie value\n   is 0 (zero) (first directory read).\
    \  On subsequent requests, it\n   should be a cookieverf as returned by the server.\
    \  The cookieverf\n   must match that returned by the READDIR in which the cookie\
    \ was\n   acquired.  If the server determines that the cookieverf is no longer\n\
    \   valid for the directory, the error NFS4ERR_NOT_SAME must be returned.\n  \
    \ The dircount portion of the argument is a hint of the maximum number\n   of\
    \ bytes of directory information that should be returned.  This\n   value represents\
    \ the length of the names of the directory entries and\n   the cookie value for\
    \ these entries.  This length represents the XDR\n   encoding of the data (names\
    \ and cookies) and not the length in the\n   native format of the server.\n  \
    \ The maxcount value of the argument is the maximum number of bytes for\n   the\
    \ result.  This maximum size represents all of the data being\n   returned within\
    \ the READDIR4resok structure and includes the XDR\n   overhead.  The server may\
    \ return less data.  If the server is unable\n   to return a single directory\
    \ entry within the maxcount limit, the\n   error NFS4ERR_TOOSMALL will be returned\
    \ to the client.\n   Finally, attr_request represents the list of attributes to\
    \ be\n   returned for each directory entry supplied by the server.\n   On successful\
    \ return, the server's response will provide a list of\n   directory entries.\
    \  Each of these entries contains the name of the\n   directory entry, a cookie\
    \ value for that entry, and the associated\n   attributes as requested.  The \"\
    eof\" flag has a value of TRUE if there\n   are no more entries in the directory.\n\
    \   The cookie value is only meaningful to the server and is used as a\n   \"\
    bookmark\" for the directory entry.  As mentioned, this cookie is\n   used by\
    \ the client for subsequent READDIR operations so that it may\n   continue reading\
    \ a directory.  The cookie is similar in concept to a\n   READ offset but should\
    \ not be interpreted as such by the client.\n   Ideally, the cookie value should\
    \ not change if the directory is\n   modified since the client may be caching\
    \ these values.\n   In some cases, the server may encounter an error while obtaining\
    \ the\n   attributes for a directory entry.  Instead of returning an error for\n\
    \   the entire READDIR operation, the server can instead return the\n   attribute\
    \ 'fattr4_rdattr_error'.  With this, the server is able to\n   communicate the\
    \ failure to the client and not fail the entire\n   operation in the instance\
    \ of what might be a transient failure.\n   Obviously, the client must request\
    \ the fattr4_rdattr_error attribute\n   for this method to work properly.  If\
    \ the client does not request the\n   attribute, the server has no choice but\
    \ to return failure for the\n   entire READDIR operation.\n   For some filesystem\
    \ environments, the directory entries \".\" and \"..\"\n   have special meaning\
    \ and in other environments, they may not.  If the\n   server supports these special\
    \ entries within a directory, they should\n   not be returned to the client as\
    \ part of the READDIR response.  To\n   enable some client environments, the cookie\
    \ values of 0, 1, and 2 are\n   to be considered reserved.  Note that the UNIX\
    \ client will use these\n   values when combining the server's response and local\
    \ representations\n   to enable a fully formed UNIX directory presentation to\
    \ the\n   application.\n   For READDIR arguments, cookie values of 1 and 2 should\
    \ not be used\n   and for READDIR results cookie values of 0, 1, and 2 should\
    \ not be\n   returned.\n   On success, the current filehandle retains its value.\n\
    \   IMPLEMENTATION\n   The server's filesystem directory representations can differ\
    \ greatly.\n   A client's programming interfaces may also be bound to the local\n\
    \   operating environment in a way that does not translate well into the\n   NFS\
    \ protocol.  Therefore the use of the dircount and maxcount fields\n   are provided\
    \ to allow the client the ability to provide guidelines to\n   the server.  If\
    \ the client is aggressive about attribute collection\n   during a READDIR, the\
    \ server has an idea of how to limit the encoded\n   response.  The dircount field\
    \ provides a hint on the number of\n   entries based solely on the names of the\
    \ directory entries.  Since it\n   is a hint, it may be possible that a dircount\
    \ value is zero.  In this\n   case, the server is free to ignore the dircount\
    \ value and return\n   directory information based on the specified maxcount value.\n\
    \   The cookieverf may be used by the server to help manage cookie values\n  \
    \ that may become stale.  It should be a rare occurrence that a server\n   is\
    \ unable to continue properly reading a directory with the provided\n   cookie/cookieverf\
    \ pair.  The server should make every effort to avoid\n   this condition since\
    \ the application at the client may not be able to\n   properly handle this type\
    \ of failure.\n   The use of the cookieverf will also protect the client from\
    \ using\n   READDIR cookie values that may be stale.  For example, if the file\n\
    \   system has been migrated, the server may or may not be able to use\n   the\
    \ same cookie values to service READDIR as the previous server\n   used.  With\
    \ the client providing the cookieverf, the server is able\n   to provide the appropriate\
    \ response to the client.  This prevents the\n   case where the server may accept\
    \ a cookie value but the underlying\n   directory has changed and the response\
    \ is invalid from the client's\n   context of its previous READDIR.\n   Since\
    \ some servers will not be returning \".\" and \"..\" entries as has\n   been\
    \ done with previous versions of the NFS protocol, the client that\n   requires\
    \ these entries be present in READDIR responses must fabricate\n   them.\n   ERRORS\n\
    \      NFS4ERR_ACCESS\n      NFS4ERR_BADHANDLE\n      NFS4ERR_BAD_COOKIE\n   \
    \   NFS4ERR_BADXDR\n      NFS4ERR_DELAY\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n\
    \      NFS4ERR_IO\n      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOTDIR\n\
    \      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n    \
    \  NFS4ERR_TOOSMALL\n"
- title: '14.2.25.  Operation 27: READLINK - Read Symbolic Link'
  contents:
  - "14.2.25.  Operation 27: READLINK - Read Symbolic Link\n   SYNOPSIS\n     (cfh)\
    \ -> linktext\n   ARGUMENT\n     /* CURRENT_FH: symlink */\n     void;\n   RESULT\n\
    \     struct READLINK4resok {\n             linktext4       link;\n     };\n \
    \    union READLINK4res switch (nfsstat4 status) {\n      case NFS4_OK:\n    \
    \          READLINK4resok resok4;\n      default:\n              void;\n     };\n\
    \   DESCRIPTION\n   READLINK reads the data associated with a symbolic link. \
    \ The data is\n   a UTF-8 string that is opaque to the server.  That is, whether\n\
    \   created by an NFS client or created locally on the server, the data\n   in\
    \ a symbolic link is not interpreted when created, but is simply\n   stored.\n\
    \   On success, the current filehandle retains its value.\n   IMPLEMENTATION\n\
    \   A symbolic link is nominally a pointer to another file.  The data is\n   not\
    \ necessarily interpreted by the server, just stored in the file.\n   It is possible\
    \ for a client implementation to store a path name that\n   is not meaningful\
    \ to the server operating system in a symbolic link.\n   A READLINK operation\
    \ returns the data to the client for\n   interpretation. If different implementations\
    \ want to share access to\n   symbolic links, then they must agree on the interpretation\
    \ of the\n   data in the symbolic link.\n   The READLINK operation is only allowed\
    \ on objects of type NF4LNK.\n   The server should return the error, NFS4ERR_INVAL,\
    \ if the object is\n   not of type, NF4LNK.\n   ERRORS\n      NFS4ERR_ACCESS\n\
    \      NFS4ERR_BADHANDLE\n      NFS4ERR_DELAY\n      NFS4ERR_FHEXPIRED\n     \
    \ NFS4ERR_INVAL\n      NFS4ERR_IO\n      NFS4ERR_ISDIR\n      NFS4ERR_MOVED\n\
    \      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOTSUPP\n      NFS4ERR_RESOURCE\n \
    \     NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n"
- title: '14.2.26.  Operation 28: REMOVE - Remove Filesystem Object'
  contents:
  - "14.2.26.  Operation 28: REMOVE - Remove Filesystem Object\n   SYNOPSIS\n    \
    \ (cfh), filename -> change_info\n   ARGUMENT\n     struct REMOVE4args {\n   \
    \          /* CURRENT_FH: directory */\n             component4       target;\n\
    \     };\n   RESULT\n     struct REMOVE4resok {\n             change_info4   \
    \ cinfo;\n     }\n     union REMOVE4res switch (nfsstat4 status) {\n      case\
    \ NFS4_OK:\n              REMOVE4resok   resok4;\n      default:\n           \
    \   void;\n     }\n   DESCRIPTION\n   The REMOVE operation removes (deletes) a\
    \ directory entry named by\n   filename from the directory corresponding to the\
    \ current filehandle.\n   If the entry in the directory was the last reference\
    \ to the\n   corresponding filesystem object, the object may be destroyed.\n \
    \  For the directory where the filename was removed, the server returns\n   change_info4\
    \ information in cinfo.  With the atomic field of the\n   change_info4 struct,\
    \ the server will indicate if the before and after\n   change attributes were\
    \ obtained atomically with respect to the\n   removal.\n   If the target has a\
    \ length of 0 (zero), or if target does not obey\n   the UTF-8 definition, the\
    \ error NFS4ERR_INVAL will be returned.\n   On success, the current filehandle\
    \ retains its value.\n   IMPLEMENTATION\n   NFS versions 2 and 3 required a different\
    \ operator RMDIR for\n   directory removal and REMOVE for non-directory removal.\
    \ This allowed\n   clients to skip checking the file type when being passed a\
    \ non-\n   directory delete system call (e.g., unlink() in POSIX) to remove a\n\
    \   directory, as well as the converse (e.g., a rmdir() on a non-\n   directory)\
    \ because they knew the server would check the file type.\n   NFS version 4 REMOVE\
    \ can be used to delete any directory entry\n   independent of its file type.\
    \ The implementor of an NFS version 4\n   client's entry points from the unlink()\
    \ and rmdir() system calls\n   should first check the file type against the types\
    \ the system call is\n   allowed to remove before issuing a REMOVE. Alternatively,\
    \ the\n   implementor can produce a COMPOUND call that includes a LOOKUP/VERIFY\n\
    \   sequence to verify the file type before a REMOVE operation in the\n   same\
    \ COMPOUND call.\n   The concept of last reference is server specific.  However,\
    \ if the\n   numlinks field in the previous attributes of the object had the value\n\
    \   1, the client should not rely on referring to the object via a\n   filehandle.\
    \  Likewise, the client should not rely on the resources\n   (disk space, directory\
    \ entry, and so on) formerly associated with the\n   object becoming immediately\
    \ available.  Thus, if a client needs to be\n   able to continue to access a file\
    \ after using REMOVE to remove it,\n   the client should take steps to make sure\
    \ that the file will still be\n   accessible.  The usual mechanism used is to\
    \ RENAME the file from its\n   old name to a new hidden name.\n   If the server\
    \ finds that the file is still open when the REMOVE\n   arrives:\n   o  The server\
    \ SHOULD NOT delete the file's directory entry if the\n      file was opened with\
    \ OPEN4_SHARE_DENY_WRITE or\n      OPEN4_SHARE_DENY_BOTH.\n   o  If the file was\
    \ not opened with OPEN4_SHARE_DENY_WRITE or\n      OPEN4_SHARE_DENY_BOTH, the\
    \ server SHOULD delete the file's\n      directory entry.  However, until last\
    \ CLOSE of the file, the\n      server MAY continue to allow access to the file\
    \ via its\n      filehandle.\n   ERRORS\n      NFS4ERR_ACCESS\n      NFS4ERR_BADCHAR\n\
    \      NFS4ERR_BADHANDLE\n      NFS4ERR_BADNAME\n      NFS4ERR_BADXDR\n      NFS4ERR_DELAY\n\
    \      NFS4ERR_FHEXPIRED\n      NFS4ERR_FILE_OPEN\n      NFS4ERR_INVAL\n     \
    \ NFS4ERR_IO\n      NFS4ERR_MOVED\n      NFS4ERR_NAMETOOLONG\n      NFS4ERR_NOENT\n\
    \      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOTDIR\n      NFS4ERR_NOTEMPTY\n  \
    \    NFS4ERR_RESOURCE\n      NFS4ERR_ROFS\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n"
- title: '14.2.27.  Operation 29: RENAME - Rename Directory Entry'
  contents:
  - "14.2.27.  Operation 29: RENAME - Rename Directory Entry\n   SYNOPSIS\n     (sfh),\
    \ oldname, (cfh), newname -> source_change_info,\n     target_change_info\n  \
    \ ARGUMENT\n     struct RENAME4args {\n             /* SAVED_FH: source directory\
    \ */\n             component4      oldname;\n             /* CURRENT_FH: target\
    \ directory */\n             component4      newname;\n     };\n   RESULT\n  \
    \   struct RENAME4resok {\n             change_info4    source_cinfo;\n      \
    \       change_info4    target_cinfo;\n     };\n     union RENAME4res switch (nfsstat4\
    \ status) {\n      case NFS4_OK:\n              RENAME4resok   resok4;\n     \
    \ default:\n              void;\n     };\n   DESCRIPTION\n   The RENAME operation\
    \ renames the object identified by oldname in the\n   source directory corresponding\
    \ to the saved filehandle, as set by the\n   SAVEFH operation, to newname in the\
    \ target directory corresponding to\n   the current filehandle.  The operation\
    \ is required to be atomic to\n   the client.  Source and target directories must\
    \ reside on the same\n   filesystem on the server.  On success, the current filehandle\
    \ will\n   continue to be the target directory.\n   If the target directory already\
    \ contains an entry with the name,\n   newname, the source object must be compatible\
    \ with the target:\n   either both are non-directories or both are directories\
    \ and the\n   target must be empty.  If compatible, the existing target is removed\n\
    \   before the rename occurs (See the IMPLEMENTATION subsection of the\n   section\
    \ \"Operation 28: REMOVE - Remove Filesystem Object\" for client\n   and server\
    \ actions whenever a target is removed).  If they are not\n   compatible or if\
    \ the target is a directory but not empty, the server\n   will return the error,\
    \ NFS4ERR_EXIST.\n   If oldname and newname both refer to the same file (they\
    \ might be\n   hard links of each other), then RENAME should perform no action\
    \ and\n   return success.\n   For both directories involved in the RENAME, the\
    \ server returns\n   change_info4 information.  With the atomic field of the change_info4\n\
    \   struct, the server will indicate if the before and after change\n   attributes\
    \ were obtained atomically with respect to the rename.\n   If the oldname refers\
    \ to a named attribute and the saved and current\n   filehandles refer to different\
    \ filesystem objects, the server will\n   return NFS4ERR_XDEV just as if the saved\
    \ and current filehandles\n   represented directories on different filesystems.\n\
    \   If the oldname or newname has a length of 0 (zero), or if oldname or\n   newname\
    \ does not obey the UTF-8 definition, the error NFS4ERR_INVAL\n   will be returned.\n\
    \   IMPLEMENTATION\n   The RENAME operation must be atomic to the client.  The\
    \ statement\n   \"source and target directories must reside on the same filesystem\
    \ on\n   the server\" means that the fsid fields in the attributes for the\n \
    \  directories are the same. If they reside on different filesystems,\n   the\
    \ error, NFS4ERR_XDEV, is returned.\n   Based on the value of the fh_expire_type\
    \ attribute for the object,\n   the filehandle may or may not expire on a RENAME.\
    \  However, server\n   implementors are strongly encouraged to attempt to keep\
    \ filehandles\n   from expiring in this fashion.\n   On some servers, the file\
    \ names \".\" and \"..\" are illegal as either\n   oldname or newname, and will\
    \ result in the error NFS4ERR_BADNAME.  In\n   addition, on many servers the case\
    \ of oldname or newname being an\n   alias for the source directory will be checked\
    \ for.  Such servers\n   will return the error NFS4ERR_INVAL in these cases.\n\
    \   If either of the source or target filehandles are not directories,\n   the\
    \ server will return NFS4ERR_NOTDIR.\n   ERRORS\n      NFS4ERR_ACCESS\n      NFS4ERR_BADCHAR\n\
    \      NFS4ERR_BADHANDLE\n      NFS4ERR_BADNAME\n      NFS4ERR_BADXDR\n      NFS4ERR_DELAY\n\
    \      NFS4ERR_DQUOT\n      NFS4ERR_EXIST\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_FILE_OPEN\n\
    \      NFS4ERR_INVAL\n      NFS4ERR_IO\n      NFS4ERR_MOVED\n      NFS4ERR_NAMETOOLONG\n\
    \      NFS4ERR_NOENT\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOSPC\n      NFS4ERR_NOTDIR\n\
    \      NFS4ERR_NOTEMPTY\n      NFS4ERR_RESOURCE\n      NFS4ERR_ROFS\n      NFS4ERR_SERVERFAULT\n\
    \      NFS4ERR_STALE\n      NFS4ERR_WRONGSEC\n      NFS4ERR_XDEV\n"
- title: '14.2.28.  Operation 30: RENEW - Renew a Lease'
  contents:
  - "14.2.28.  Operation 30: RENEW - Renew a Lease\n   SYNOPSIS\n     clientid ->\
    \ ()\n   ARGUMENT\n     struct RENEW4args {\n             clientid4       clientid;\n\
    \     };\n   RESULT\n     struct RENEW4res {\n             nfsstat4        status;\n\
    \     };\n   DESCRIPTION\n   The RENEW operation is used by the client to renew\
    \ leases which it\n   currently holds at a server.  In processing the RENEW request,\
    \ the\n   server renews all leases associated with the client.  The associated\n\
    \   leases are determined by the clientid provided via the SETCLIENTID\n   operation.\n\
    \   IMPLEMENTATION\n   When the client holds delegations, it needs to use RENEW\
    \ to detect\n   when the server has determined that the callback path is down.\
    \  When\n   the server has made such a determination, only the RENEW operation\n\
    \   will renew the lease on delegations.  If the server determines the\n   callback\
    \ path is down, it returns NFS4ERR_CB_PATH_DOWN.  Even though\n   it returns NFS4ERR_CB_PATH_DOWN,\
    \ the server MUST renew the lease on\n   the record locks and share reservations\
    \ that the client has\n   established on the server.  If for some reason the lock\
    \ and share\n   reservation lease cannot be renewed, then the server MUST return\
    \ an\n   error other than NFS4ERR_CB_PATH_DOWN, even if the callback path is\n\
    \   also down.\n   The client that issues RENEW MUST choose the principal, RPC\
    \ security\n   flavor, and if applicable, GSS-API mechanism and service via one\
    \ of\n   the following algorithms:\n   o  The client uses the same principal,\
    \ RPC security flavor -- and if\n      the flavor was RPCSEC_GSS -- the same mechanism\
    \ and service that\n      was used when the client id was established via\n  \
    \    SETCLIENTID_CONFIRM.\n   o  The client uses any principal, RPC security flavor\
    \ mechanism and\n      service combination that currently has an OPEN file on\
    \ the server.\n      I.e.,  the same principal had a successful OPEN operation,\
    \ the\n      file is still open by that principal, and the flavor, mechanism,\n\
    \      and service of RENEW match that of the previous OPEN.\n   The server MUST\
    \ reject a RENEW that does not use one the\n   aforementioned algorithms, with\
    \ the error NFS4ERR_ACCESS.\n   ERRORS\n      NFS4ERR_ACCESS\n      NFS4ERR_ADMIN_REVOKED\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_CB_PATH_DOWN\n      NFS4ERR_EXPIRED\n   \
    \   NFS4ERR_LEASE_MOVED\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n \
    \     NFS4ERR_STALE_CLIENTID\n"
- title: '14.2.29.  Operation 31: RESTOREFH - Restore Saved Filehandle'
  contents:
  - "14.2.29.  Operation 31: RESTOREFH - Restore Saved Filehandle\n   SYNOPSIS\n \
    \    (sfh) -> (cfh)\n   ARGUMENT\n     /* SAVED_FH: */\n     void;\n   RESULT\n\
    \     struct RESTOREFH4res {\n             /* CURRENT_FH: value of saved fh */\n\
    \             nfsstat4        status;\n     };\n   DESCRIPTION\n   Set the current\
    \ filehandle to the value in the saved filehandle.  If\n   there is no saved filehandle\
    \ then return the error NFS4ERR_RESTOREFH.\n   IMPLEMENTATION\n   Operations like\
    \ OPEN and LOOKUP use the current filehandle to\n   represent a directory and\
    \ replace it with a new filehandle.  Assuming\n   the previous filehandle was\
    \ saved with a SAVEFH operator, the\n   previous filehandle can be restored as\
    \ the current filehandle.  This\n   is commonly used to obtain post-operation\
    \ attributes for the\n   directory, e.g.,\n         PUTFH (directory filehandle)\n\
    \         SAVEFH\n         GETATTR attrbits     (pre-op dir attrs)\n         CREATE\
    \ optbits \"foo\" attrs\n         GETATTR attrbits     (file attributes)\n   \
    \      RESTOREFH\n         GETATTR attrbits     (post-op dir attrs)\n   ERRORS\n\
    \      NFS4ERR_BADHANDLE\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_MOVED\n     \
    \ NFS4ERR_RESOURCE\n      NFS4ERR_RESTOREFH\n      NFS4ERR_SERVERFAULT\n     \
    \ NFS4ERR_STALE\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.30.  Operation 32: SAVEFH - Save Current Filehandle'
  contents:
  - "14.2.30.  Operation 32: SAVEFH - Save Current Filehandle\n   SYNOPSIS\n     (cfh)\
    \ -> (sfh)\n   ARGUMENT\n     /* CURRENT_FH: */\n     void;\n   RESULT\n     struct\
    \ SAVEFH4res {\n             /* SAVED_FH: value of current fh */\n           \
    \  nfsstat4        status;\n     };\n   DESCRIPTION\n   Save the current filehandle.\
    \  If a previous filehandle was saved then\n   it is no longer accessible.  The\
    \ saved filehandle can be restored as\n   the current filehandle with the RESTOREFH\
    \ operator.\n   On success, the current filehandle retains its value.\n   IMPLEMENTATION\n\
    \   ERRORS\n      NFS4ERR_BADHANDLE\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_MOVED\n\
    \      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n\
    \      NFS4ERR_STALE\n"
- title: '14.2.31.  Operation 33: SECINFO - Obtain Available Security'
  contents:
  - "14.2.31.  Operation 33: SECINFO - Obtain Available Security\n   SYNOPSIS\n  \
    \   (cfh), name -> { secinfo }\n   ARGUMENT\n     struct SECINFO4args {\n    \
    \         /* CURRENT_FH: directory */\n             component4     name;\n   \
    \  };\n   RESULT\n     enum rpc_gss_svc_t {/* From RFC 2203 */\n             RPC_GSS_SVC_NONE\
    \        = 1,\n             RPC_GSS_SVC_INTEGRITY   = 2,\n             RPC_GSS_SVC_PRIVACY\
    \     = 3\n     };\n     struct rpcsec_gss_info {\n             sec_oid4     \
    \   oid;\n             qop4            qop;\n             rpc_gss_svc_t   service;\n\
    \     };\n     union secinfo4 switch (uint32_t flavor) {\n      case RPCSEC_GSS:\n\
    \              rpcsec_gss_info        flavor_info;\n      default:\n         \
    \     void;\n     };\n     typedef secinfo4 SECINFO4resok<>;\n     union SECINFO4res\
    \ switch (nfsstat4 status) {\n      case NFS4_OK:\n              SECINFO4resok\
    \ resok4;\n      default:\n              void;\n     };\n   DESCRIPTION\n   The\
    \ SECINFO operation is used by the client to obtain a list of valid\n   RPC authentication\
    \ flavors for a specific directory filehandle, file\n   name pair.  SECINFO should\
    \ apply the same access methodology used for\n   LOOKUP when evaluating the name.\
    \  Therefore, if the requester does\n   not have the appropriate access to LOOKUP\
    \ the name then SECINFO must\n   behave the same way and return NFS4ERR_ACCESS.\n\
    \   The result will contain an array which represents the security\n   mechanisms\
    \ available, with an order corresponding to server's\n   preferences, the most\
    \ preferred being first in the array. The client\n   is free to pick whatever\
    \ security mechanism it both desires and\n   supports, or to pick in the server's\
    \ preference order the first one\n   it supports.  The array entries are represented\
    \ by the secinfo4\n   structure.  The field 'flavor' will contain a value of AUTH_NONE,\n\
    \   AUTH_SYS (as defined in [RFC1831]), or RPCSEC_GSS (as defined in\n   [RFC2203]).\n\
    \   For the flavors AUTH_NONE and AUTH_SYS, no additional security\n   information\
    \ is returned.  For a return value of RPCSEC_GSS, a\n   security triple is returned\
    \ that contains the mechanism object id (as\n   defined in [RFC2743]), the quality\
    \ of protection (as defined in\n   [RFC2743]) and the service type (as defined\
    \ in [RFC2203]).  It is\n   possible for SECINFO to return multiple entries with\
    \ flavor equal to\n   RPCSEC_GSS with different security triple values.\n   On\
    \ success, the current filehandle retains its value.\n   If the name has a length\
    \ of 0 (zero), or if name does not obey the\n   UTF-8 definition, the error NFS4ERR_INVAL\
    \ will be returned.\n   IMPLEMENTATION\n   The SECINFO operation is expected to\
    \ be used by the NFS client when\n   the error value of NFS4ERR_WRONGSEC is returned\
    \ from another NFS\n   operation.  This signifies to the client that the server's\
    \ security\n   policy is different from what the client is currently using.  At\
    \ this\n   point, the client is expected to obtain a list of possible security\n\
    \   flavors and choose what best suits its policies.\n   As mentioned, the server's\
    \ security policies will determine when a\n   client request receives NFS4ERR_WRONGSEC.\
    \  The operations which may\n   receive this error are: LINK, LOOKUP, OPEN, PUTFH,\
    \ PUTPUBFH,\n   PUTROOTFH, RESTOREFH, RENAME, and indirectly READDIR.  LINK and\n\
    \   RENAME will only receive this error if the security used for the\n   operation\
    \ is inappropriate for saved filehandle.  With the exception\n   of READDIR, these\
    \ operations represent the point at which the client\n   can instantiate a filehandle\
    \ into the \"current filehandle\" at the\n   server.  The filehandle is either\
    \ provided by the client (PUTFH,\n   PUTPUBFH, PUTROOTFH) or generated as a result\
    \ of a name to filehandle\n   translation (LOOKUP and OPEN).  RESTOREFH is different\
    \ because the\n   filehandle is a result of a previous SAVEFH.  Even though the\n\
    \   filehandle, for RESTOREFH, might have previously passed the server's\n   inspection\
    \ for a security match, the server will check it again on\n   RESTOREFH to ensure\
    \ that the security policy has not changed.\n   If the client wants to resolve\
    \ an error return of NFS4ERR_WRONGSEC,\n   the following will occur:\n   o  For\
    \ LOOKUP and OPEN, the client will use SECINFO with the same\n      current filehandle\
    \ and name as provided in the original LOOKUP or\n      OPEN to enumerate the\
    \ available security triples.\n   o  For LINK, PUTFH, RENAME, and RESTOREFH, the\
    \ client will use\n      SECINFO and provide the parent directory filehandle and\
    \ object\n      name which corresponds to the filehandle originally provided by\n\
    \      the PUTFH RESTOREFH, or for LINK and RENAME, the SAVEFH.\n   o  For PUTROOTFH\
    \ and PUTPUBFH, the client will be unable to use the\n      SECINFO operation\
    \ since SECINFO requires a current filehandle and\n      none exist for these\
    \ two operations.  Therefore, the client must\n      iterate through the security\
    \ triples available at the client and\n      reattempt the PUTROOTFH or PUTPUBFH\
    \ operation. In the unfortunate\n      event none of the MANDATORY security triples\
    \ are supported by the\n      client and server, the client SHOULD try using others\
    \ that support\n      integrity. Failing that, the client can try using AUTH_NONE,\
    \ but\n      because such forms lack integrity checks, this puts the client at\n\
    \      risk.  Nonetheless, the server SHOULD allow the client to use\n      whatever\
    \ security form the client requests and the server\n      supports, since the\
    \ risks of doing so are on the client.\n   The READDIR operation will not directly\
    \ return the NFS4ERR_WRONGSEC\n   error.  However, if the READDIR request included\
    \ a request for\n   attributes, it is possible that the READDIR request's security\
    \ triple\n   does not match that of a directory entry.  If this is the case and\n\
    \   the client has requested the rdattr_error attribute, the server will\n   return\
    \ the NFS4ERR_WRONGSEC error in rdattr_error for the entry.\n   See the section\
    \ \"Security Considerations\" for a discussion on the\n   recommendations for\
    \ security flavor used by SECINFO.\n   ERRORS\n      NFS4ERR_ACCESS\n      NFS4ERR_BADCHAR\n\
    \      NFS4ERR_BADHANDLE\n      NFS4ERR_BADNAME\n      NFS4ERR_BADXDR\n      NFS4ERR_FHEXPIRED\n\
    \      NFS4ERR_INVAL\n      NFS4ERR_MOVED\n      NFS4ERR_NAMETOOLONG\n      NFS4ERR_NOENT\n\
    \      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOTDIR\n      NFS4ERR_RESOURCE\n  \
    \    NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n"
- title: '14.2.32.  Operation 34: SETATTR - Set Attributes'
  contents:
  - "14.2.32.  Operation 34: SETATTR - Set Attributes\n   SYNOPSIS\n     (cfh), stateid,\
    \ attrmask, attr_vals -> attrsset\n   ARGUMENT\n     struct SETATTR4args {\n \
    \            /* CURRENT_FH: target object */\n             stateid4        stateid;\n\
    \             fattr4          obj_attributes;\n     };\n   RESULT\n     struct\
    \ SETATTR4res {\n             nfsstat4        status;\n             bitmap4  \
    \       attrsset;\n     };\n   DESCRIPTION\n   The SETATTR operation changes one\
    \ or more of the attributes of a\n   filesystem object.  The new attributes are\
    \ specified with a bitmap\n   and the attributes that follow the bitmap in bit\
    \ order.\n   The stateid argument for SETATTR is used to provide file locking\n\
    \   context that is necessary for SETATTR requests that set the size\n   attribute.\
    \  Since setting the size attribute modifies the file's\n   data, it has the same\
    \ locking requirements as a corresponding WRITE.\n   Any SETATTR that sets the\
    \ size attribute is incompatible with a share\n   reservation that specifies DENY_WRITE.\
    \  The area between the old\n   end-of-file and the new end-of-file is considered\
    \ to be modified just\n   as would have been the case had the area in question\
    \ been specified\n   as the target of WRITE, for the purpose of checking conflicts\
    \ with\n   record locks, for those cases in which a server is implementing\n \
    \  mandatory record locking behavior.  A valid stateid should always be\n   specified.\
    \  When the file size attribute is not set, the special\n   stateid consisting\
    \ of all bits zero should be passed.\n   On either success or failure of the operation,\
    \ the server will return\n   the attrsset bitmask to represent what (if any) attributes\
    \ were\n   successfully set.  The attrsset in the response is a subset of the\n\
    \   bitmap4 that is part of the obj_attributes in the argument.\n   On success,\
    \ the current filehandle retains its value.\n   IMPLEMENTATION\n   If the request\
    \ specifies the owner attribute to be set, the server\n   should allow the operation\
    \ to succeed if the current owner of the\n   object matches the value specified\
    \ in the request.  Some servers may\n   be implemented in a way as to prohibit\
    \ the setting of the owner\n   attribute unless the requester has privilege to\
    \ do so.  If the server\n   is lenient in this one case of matching owner values,\
    \ the client\n   implementation may be simplified in cases of creation of an object\n\
    \   followed by a SETATTR.\n   The file size attribute is used to request changes\
    \ to the size of a\n   file. A value of 0 (zero) causes the file to be truncated,\
    \ a value\n   less than the current size of the file causes data from new size\
    \ to\n   the end of the file to be discarded, and a size greater than the\n  \
    \ current size of the file causes logically zeroed data bytes to be\n   added\
    \ to the end of the file.  Servers are free to implement this\n   using holes\
    \ or actual zero data bytes. Clients should not make any\n   assumptions regarding\
    \ a server's implementation of this feature,\n   beyond that the bytes returned\
    \ will be zeroed.  Servers must support\n   extending the file size via SETATTR.\n\
    \   SETATTR is not guaranteed atomic.  A failed SETATTR may partially\n   change\
    \ a file's attributes.\n   Changing the size of a file with SETATTR indirectly\
    \ changes the\n   time_modify.  A client must account for this as size changes\
    \ can\n   result in data deletion.\n   The attributes time_access_set and time_modify_set\
    \ are write-only\n   attributes constructed as a switched union so the client\
    \ can direct\n   the server in setting the time values.  If the switched union\n\
    \   specifies SET_TO_CLIENT_TIME4, the client has provided an nfstime4 to\n  \
    \ be used for the operation.  If the switch union does not specify\n   SET_TO_CLIENT_TIME4,\
    \ the server is to use its current time for the\n   SETATTR operation.\n   If\
    \ server and client times differ, programs that compare client time\n   to file\
    \ times can break. A time maintenance protocol should be used\n   to limit client/server\
    \ time skew.\n   Use of a COMPOUND containing a VERIFY operation specifying only\
    \ the\n   change attribute, immediately followed by a SETATTR, provides a means\n\
    \   whereby a client may specify a request that emulates the\n   functionality\
    \ of the SETATTR guard mechanism of NFS version 3.  Since\n   the function of\
    \ the guard mechanism is to avoid changes to the file\n   attributes based on\
    \ stale information, delays between checking of the\n   guard condition and the\
    \ setting of the attributes have the potential\n   to compromise this function,\
    \ as would the corresponding delay in the\n   NFS version 4 emulation.  Therefore,\
    \ NFS version 4 servers should\n   take care to avoid such delays, to the degree\
    \ possible, when\n   executing such a request.\n   If the server does not support\
    \ an attribute as requested by the\n   client, the server should return NFS4ERR_ATTRNOTSUPP.\n\
    \   A mask of the attributes actually set is returned by SETATTR in all\n   cases.\
    \  That mask must not include attributes bits not requested to\n   be set by the\
    \ client, and must be equal to the mask of attributes\n   requested to be set\
    \ only if the SETATTR completes without error.\n   ERRORS\n      NFS4ERR_ACCESS\n\
    \      NFS4ERR_ADMIN_REVOKED\n      NFS4ERR_ATTRNOTSUPP\n      NFS4ERR_BADCHAR\n\
    \      NFS4ERR_BADHANDLE\n      NFS4ERR_BADOWNER\n      NFS4ERR_BAD_STATEID\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_DELAY\n      NFS4ERR_DQUOT\n      NFS4ERR_EXPIRED\n\
    \      NFS4ERR_FBIG\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_GRACE\n      NFS4ERR_INVAL\n\
    \      NFS4ERR_IO\n      NFS4ERR_ISDIR\n      NFS4ERR_LOCKED\n      NFS4ERR_MOVED\n\
    \      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOSPC\n      NFS4ERR_OLD_STATEID\n\
    \      NFS4ERR_OPENMODE\n      NFS4ERR_PERM\n      NFS4ERR_RESOURCE\n      NFS4ERR_ROFS\n\
    \      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_STALE_STATEID\n"
- title: '14.2.33.  Operation 35: SETCLIENTID - Negotiate Clientid'
  contents:
  - "14.2.33.  Operation 35: SETCLIENTID - Negotiate Clientid\n   SYNOPSIS\n     client,\
    \ callback, callback_ident -> clientid, setclientid_confirm\n   ARGUMENT\n   \
    \  struct SETCLIENTID4args {\n             nfs_client_id4  client;\n         \
    \    cb_client4      callback;\n             uint32_t        callback_ident;\n\
    \     };\n   RESULT\n     struct SETCLIENTID4resok {\n             clientid4 \
    \      clientid;\n             verifier4       setclientid_confirm;\n     };\n\
    \     union SETCLIENTID4res switch (nfsstat4 status) {\n      case NFS4_OK:\n\
    \              SETCLIENTID4resok      resok4;\n      case NFS4ERR_CLID_INUSE:\n\
    \              clientaddr4    client_using;\n      default:\n              void;\n\
    \     };\n   DESCRIPTION\n   The client uses the SETCLIENTID operation to notify\
    \ the server of its\n   intention to use a particular client identifier, callback,\
    \ and\n   callback_ident for subsequent requests that entail creating lock,\n\
    \   share reservation, and delegation state on the server.  Upon\n   successful\
    \ completion the server will return a shorthand clientid\n   which, if confirmed\
    \ via a separate step, will be used in subsequent\n   file locking and file open\
    \ requests. Confirmation of the clientid\n   must be done via the SETCLIENTID_CONFIRM\
    \ operation to return the\n   clientid and setclientid_confirm values, as verifiers,\
    \ to the server.\n   The reason why two verifiers are necessary is that it is\
    \ possible to\n   use SETCLIENTID and SETCLIENTID_CONFIRM to modify the callback\
    \ and\n   callback_ident information but not the shorthand clientid.  In that\n\
    \   event, the setclientid_confirm value is effectively the only\n   verifier.\n\
    \   The callback information provided in this operation will be used if\n   the\
    \ client is provided an open delegation at a future point.\n   Therefore, the\
    \ client must correctly reflect the program and port\n   numbers for the callback\
    \ program at the time SETCLIENTID is used.\n   The callback_ident value is used\
    \ by the server on the callback.  The\n   client can leverage the callback_ident\
    \ to eliminate the need for more\n   than one callback RPC program number, while\
    \ still being able to\n   determine which server is initiating the callback.\n\
    \   IMPLEMENTATION\n   To understand how to implement SETCLIENTID, make the following\n\
    \   notations. Let:\n   x be the value of the client.id subfield of the SETCLIENTID4args\n\
    \     structure.\n   v be the value of the client.verifier subfield of the\n \
    \    SETCLIENTID4args structure.\n   c be the value of the clientid field returned\
    \ in the\n     SETCLIENTID4resok structure.\n   k represent the value combination\
    \ of the fields callback and\n     callback_ident fields of the SETCLIENTID4args\
    \ structure.\n   s be the setclientid_confirm value returned in the\n     SETCLIENTID4resok\
    \ structure.\n   { v, x, c, k, s }\n     be a quintuple for a client record. A\
    \ client record is\n     confirmed if there has been a SETCLIENTID_CONFIRM operation\
    \ to\n     confirm it.  Otherwise it is unconfirmed. An unconfirmed\n     record\
    \ is established by a SETCLIENTID call.\n   Since SETCLIENTID is a non-idempotent\
    \ operation, let us assume that\n   the server is implementing the duplicate request\
    \ cache (DRC).\n   When the server gets a SETCLIENTID { v, x, k } request, it\
    \ processes\n   it in the following manner.\n   o  It first looks up the request\
    \ in the DRC. If there is a hit, it\n      returns the result cached in the DRC.\
    \  The server does NOT remove\n      client state (locks, shares, delegations)\
    \ nor does it modify any\n      recorded callback and callback_ident information\
    \ for client { x }.\n      For any DRC miss, the server takes the client id string\
    \ x, and\n      searches for client records for x that the server may have\n \
    \     recorded from previous SETCLIENTID calls. For any confirmed record\n   \
    \   with the same id string x, if the recorded principal does not\n      match\
    \ that of SETCLIENTID call, then the server returns a\n      NFS4ERR_CLID_INUSE\
    \ error.\n      For brevity of discussion, the remaining description of the\n\
    \      processing assumes that there was a DRC miss, and that where the\n    \
    \  server has previously recorded a confirmed record for client x,\n      the\
    \ aforementioned principal check has successfully passed.\n   o  The server checks\
    \ if it has recorded a confirmed record for { v,\n      x, c, l, s }, where l\
    \ may or may not equal k. If so, and since the\n      id verifier v of the request\
    \ matches that which is confirmed and\n      recorded, the server treats this\
    \ as a probable callback\n      information update and records an unconfirmed\
    \ { v, x, c, k, t }\n      and leaves the confirmed { v, x, c, l, s } in place,\
    \ such that t\n      != s. It does not matter if k equals l or not.  Any pre-existing\n\
    \      unconfirmed { v, x, c, *, * } is removed.\n      The server returns { c,\
    \ t }. It is indeed returning the old\n      clientid4 value c, because the client\
    \ apparently only wants to\n      update callback value k to value l.  It's possible\
    \ this request is\n      one from the Byzantine router that has stale callback\
    \ information,\n      but this is not a problem.  The callback information update\
    \ is\n      only confirmed if followed up by a SETCLIENTID_CONFIRM { c, t }.\n\
    \      The server awaits confirmation of k via\n      SETCLIENTID_CONFIRM { c,\
    \ t }.\n      The server does NOT remove client (lock/share/delegation) state\n\
    \      for x.\n   o  The server has previously recorded a confirmed { u, x, c,\
    \ l, s }\n      record such that v != u, l may or may not equal k, and has not\n\
    \      recorded any unconfirmed { *, x, *, *, * } record for x.  The\n      server\
    \ records an unconfirmed { v, x, d, k, t } (d != c, t != s).\n      The server\
    \ returns { d, t }.\n      The server awaits confirmation of { d, k } via SETCLIENTID_CONFIRM\n\
    \      { d, t }.\n      The server does NOT remove client (lock/share/delegation)\
    \ state\n      for x.\n   o  The server has previously recorded a confirmed {\
    \ u, x, c, l, s }\n      record such that v != u, l may or may not equal k, and\
    \ recorded an\n      unconfirmed { w, x, d, m, t } record such that c != d, t\
    \ != s, m\n      may or may not equal k, m may or may not equal l, and k may or\
    \ may\n      not equal l. Whether w == v or w != v makes no difference.  The\n\
    \      server simply removes the unconfirmed { w, x, d, m, t } record and\n  \
    \    replaces it with an unconfirmed { v, x, e, k, r } record, such\n      that\
    \ e != d, e != c, r != t, r != s.\n      The server returns { e, r }.\n      The\
    \ server awaits confirmation of { e, k } via\n      SETCLIENTID_CONFIRM { e, r\
    \ }.\n      The server does NOT remove client (lock/share/delegation) state\n\
    \      for x.\n   o  The server has no confirmed { *, x, *, *, * } for x. It may\
    \ or may\n      not have recorded an unconfirmed { u, x, c, l, s }, where l may\
    \ or\n      may not equal k, and u may or may not equal v.  Any unconfirmed\n\
    \      record { u, x, c, l, * }, regardless whether u == v or l == k, is\n   \
    \   replaced with an unconfirmed record { v, x, d, k, t } where d !=\n      c,\
    \ t != s.\n      The server returns { d, t }.\n      The server awaits confirmation\
    \ of { d, k } via SETCLIENTID_CONFIRM\n      { d, t }.  The server does NOT remove\
    \ client\n      (lock/share/delegation) state for x.\n   The server generates\
    \ the clientid and setclientid_confirm values and\n   must take care to ensure\
    \ that these values are extremely unlikely to\n   ever be regenerated.\n   ERRORS\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_CLID_INUSE\n      NFS4ERR_INVAL\n      NFS4ERR_RESOURCE\n\
    \      NFS4ERR_SERVERFAULT\n"
- title: '14.2.34.  Operation 36: SETCLIENTID_CONFIRM - Confirm Clientid'
  contents:
  - "14.2.34.  Operation 36: SETCLIENTID_CONFIRM - Confirm Clientid\n   SYNOPSIS\n\
    \     clientid, verifier -> -\n   ARGUMENT\n     struct SETCLIENTID_CONFIRM4args\
    \ {\n             clientid4       clientid;\n             verifier4       setclientid_confirm;\n\
    \     };\n   RESULT\n     struct SETCLIENTID_CONFIRM4res {\n             nfsstat4\
    \        status;\n     };\n   DESCRIPTION\n   This operation is used by the client\
    \ to confirm the results from a\n   previous call to SETCLIENTID.  The client\
    \ provides the server\n   supplied (from a SETCLIENTID response) clientid.  The\
    \ server responds\n   with a simple status of success or failure.\n   IMPLEMENTATION\n\
    \   The client must use the SETCLIENTID_CONFIRM operation to confirm the\n   following\
    \ two distinct cases:\n   o  The client's use of a new shorthand client identifier\
    \ (as returned\n      from the server in the response to SETCLIENTID), a new callback\n\
    \      value (as specified in the arguments to SETCLIENTID) and a new\n      callback_ident\
    \ (as specified in the arguments to SETCLIENTID)\n      value.  The client's use\
    \ of SETCLIENTID_CONFIRM in this case also\n      confirms the removal of any\
    \ of the client's previous relevant\n      leased state. Relevant leased client\
    \ state includes record locks,\n      share reservations, and where the server\
    \ does not support the\n      CLAIM_DELEGATE_PREV claim type, delegations.  If\
    \ the server\n      supports CLAIM_DELEGATE_PREV, then SETCLIENTID_CONFIRM MUST\
    \ NOT\n      remove delegations for this client; relevant leased client state\n\
    \      would then just include record locks and share reservations.\n   o  The\
    \ client's re-use of an old, previously confirmed, shorthand\n      client identifier,\
    \ a new callback value, and a new callback_ident\n      value.  The client's use\
    \ of SETCLIENTID_CONFIRM in this case MUST\n      NOT result in the removal of\
    \ any previous leased state (locks,\n      share reservations, and delegations)\n\
    \   We use the same notation and definitions for v, x, c, k, s, and\n   unconfirmed\
    \ and confirmed client records as introduced in the\n   description of the SETCLIENTID\
    \ operation. The arguments to\n   SETCLIENTID_CONFIRM are indicated by the notation\
    \ { c, s }, where c\n   is a value of type clientid4, and s is a value of type\
    \ verifier4\n   corresponding to the setclientid_confirm field.\n   As with SETCLIENTID,\
    \ SETCLIENTID_CONFIRM is a non-idempotent\n   operation, and we assume that the\
    \ server is implementing the\n   duplicate request cache (DRC).\n   When the server\
    \ gets a SETCLIENTID_CONFIRM { c, s } request, it\n   processes it in the following\
    \ manner.\n   o  It first looks up the request in the DRC. If there is a hit,\
    \ it\n      returns the result cached in the DRC.  The server does not remove\n\
    \      any relevant leased client state nor does it modify any recorded\n    \
    \  callback and callback_ident information for client { x } as\n      represented\
    \ by the shorthand value c.\n   For a DRC miss, the server checks for client records\
    \ that match the\n   shorthand value c.  The processing cases are as follows:\n\
    \   o  The server has recorded an unconfirmed { v, x, c, k, s } record\n     \
    \ and a confirmed { v, x, c, l, t } record, such that s != t.  If\n      the principals\
    \ of the records do not match that of the\n      SETCLIENTID_CONFIRM, the server\
    \ returns NFS4ERR_CLID_INUSE, and no\n      relevant leased client state is removed\
    \ and no recorded callback\n      and callback_ident information for client {\
    \ x } is changed.\n      Otherwise, the confirmed { v, x, c, l, t } record is\
    \ removed and\n      the unconfirmed { v, x, c, k, s } is marked as confirmed,\
    \ thereby\n      modifying recorded and confirmed callback and callback_ident\n\
    \      information for client { x }.\n      The server does not remove any relevant\
    \ leased client state.\n      The server returns NFS4_OK.\n   o  The server has\
    \ not recorded an unconfirmed { v, x, c, *, * } and\n      has recorded a confirmed\
    \ { v, x, c, *, s }. If the principals of\n      the record and of SETCLIENTID_CONFIRM\
    \ do not match, the server\n      returns NFS4ERR_CLID_INUSE without removing\
    \ any relevant leased\n      client state and without changing recorded callback\
    \ and\n      callback_ident values for client { x }.\n      If the principals\
    \ match, then what has likely happened is that the\n      client never got the\
    \ response from the SETCLIENTID_CONFIRM, and\n      the DRC entry has been purged.\
    \ Whatever the scenario, since the\n      principals match, as well as { c, s\
    \ } matching a confirmed record,\n      the server leaves client x's relevant\
    \ leased client state intact,\n      leaves its callback and callback_ident values\
    \ unmodified, and\n      returns NFS4_OK.\n   o  The server has not recorded a\
    \ confirmed { *, *, c, *, * }, and has\n      recorded an unconfirmed { *, x,\
    \ c, k, s }.  Even if this is a\n      retry from client, nonetheless the client's\
    \ first\n      SETCLIENTID_CONFIRM attempt was not received by the server.  Retry\n\
    \      or not, the server doesn't know, but it processes it as if were a\n   \
    \   first try.  If the principal of the unconfirmed { *, x, c, k, s }\n      record\
    \ mismatches that of the SETCLIENTID_CONFIRM request the\n      server returns\
    \ NFS4ERR_CLID_INUSE without removing any relevant\n      leased client state.\n\
    \      Otherwise, the server records a confirmed { *, x, c, k, s }. If\n     \
    \ there is also a confirmed { *, x, d, *, t }, the server MUST\n      remove the\
    \ client x's relevant leased client state, and overwrite\n      the callback state\
    \ with k. The confirmed record { *, x, d, *, t }\n      is removed.\n      Server\
    \ returns NFS4_OK.\n   o  The server has no record of a confirmed or unconfirmed\
    \ { *, *, c,\n      *, s }.  The server returns NFS4ERR_STALE_CLIENTID.  The server\n\
    \      does not remove any relevant leased client state, nor does it\n      modify\
    \ any recorded callback and callback_ident information for\n      any client.\n\
    \   The server needs to cache unconfirmed { v, x, c, k, s } client\n   records\
    \ and await for some time their confirmation.  As should be\n   clear from the\
    \ record processing discussions for SETCLIENTID and\n   SETCLIENTID_CONFIRM, there\
    \ are cases where the server does not\n   deterministically remove unconfirmed\
    \ client records.  To avoid\n   running out of resources, the server is not required\
    \ to hold\n   unconfirmed records indefinitely.  One strategy the server might\
    \ use\n   is to set a limit on how many unconfirmed client records it will\n \
    \  maintain, and then when the limit would be exceeded, remove the\n   oldest\
    \ record. Another strategy might be to remove an unconfirmed\n   record when some\
    \ amount of time has elapsed. The choice of the amount\n   of time is fairly arbitrary\
    \ but it is surely no higher than the\n   server's lease time period. Consider\
    \ that leases need to be renewed\n   before the lease time expires via an operation\
    \ from the client.  If\n   the client cannot issue a SETCLIENTID_CONFIRM after\
    \ a SETCLIENTID\n   before a period of time equal to that of a lease expires,\
    \ then the\n   client is unlikely to be able maintain state on the server during\n\
    \   steady state operation.\n   If the client does send a SETCLIENTID_CONFIRM\
    \ for an unconfirmed\n   record that the server has already deleted, the client\
    \ will get\n   NFS4ERR_STALE_CLIENTID back.  If so, the client should then start\n\
    \   over, and send SETCLIENTID to reestablish an unconfirmed client\n   record\
    \ and get back an unconfirmed clientid and setclientid_confirm\n   verifier. \
    \ The client should then send the SETCLIENTID_CONFIRM to\n   confirm the clientid.\n\
    \   SETCLIENTID_CONFIRM does not establish or renew a lease.  However, if\n  \
    \ SETCLIENTID_CONFIRM removes relevant leased client state, and that\n   state\
    \ does not include existing delegations, the server MUST allow\n   the client\
    \ a period of time no less than the value of lease_time\n   attribute, to reclaim,\
    \ (via the CLAIM_DELEGATE_PREV claim type of the\n   OPEN operation) its delegations\
    \ before removing unreclaimed\n   delegations.\n   ERRORS\n      NFS4ERR_BADXDR\n\
    \      NFS4ERR_CLID_INUSE\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n\
    \      NFS4ERR_STALE_CLIENTID\n"
- title: '14.2.35.  Operation 37: VERIFY - Verify Same Attributes'
  contents:
  - "14.2.35.  Operation 37: VERIFY - Verify Same Attributes\n   SYNOPSIS\n     (cfh),\
    \ fattr -> -\n   ARGUMENT\n     struct VERIFY4args {\n             /* CURRENT_FH:\
    \ object */\n             fattr4          obj_attributes;\n     };\n   RESULT\n\
    \     struct VERIFY4res {\n             nfsstat4        status;\n     };\n   DESCRIPTION\n\
    \   The VERIFY operation is used to verify that attributes have a value\n   assumed\
    \ by the client before proceeding with following operations in\n   the compound\
    \ request.  If any of the attributes do not match then the\n   error NFS4ERR_NOT_SAME\
    \ must be returned.  The current filehandle\n   retains its value after successful\
    \ completion of the operation.\n   IMPLEMENTATION\n   One possible use of the\
    \ VERIFY operation is the following compound\n   sequence.  With this the client\
    \ is attempting to verify that the file\n   being removed will match what the\
    \ client expects to be removed.  This\n   sequence can help prevent the unintended\
    \ deletion of a file.\n         PUTFH (directory filehandle)\n         LOOKUP\
    \ (file name)\n         VERIFY (filehandle == fh)\n         PUTFH (directory filehandle)\n\
    \         REMOVE (file name)\n   This sequence does not prevent a second client\
    \ from removing and\n   creating a new file in the middle of this sequence but\
    \ it does help\n   avoid the unintended result.\n   In the case that a recommended\
    \ attribute is specified in the VERIFY\n   operation and the server does not support\
    \ that attribute for the\n   filesystem object, the error NFS4ERR_ATTRNOTSUPP\
    \ is returned to the\n   client.\n   When the attribute rdattr_error or any write-only\
    \ attribute (e.g.,\n   time_modify_set) is specified, the error NFS4ERR_INVAL\
    \ is returned to\n   the client.\n   ERRORS\n      NFS4ERR_ACCESS\n      NFS4ERR_ATTRNOTSUPP\n\
    \      NFS4ERR_BADCHAR\n      NFS4ERR_BADHANDLE\n      NFS4ERR_BADXDR\n      NFS4ERR_DELAY\n\
    \      NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n\
    \      NFS4ERR_NOT_SAME\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n \
    \     NFS4ERR_STALE\n"
- title: '14.2.36.  Operation 38: WRITE - Write to File'
  contents:
  - "14.2.36.  Operation 38: WRITE - Write to File\n   SYNOPSIS\n     (cfh), stateid,\
    \ offset, stable, data -> count, committed, writeverf\n   ARGUMENT\n     enum\
    \ stable_how4 {\n             UNSTABLE4       = 0,\n             DATA_SYNC4  \
    \    = 1,\n             FILE_SYNC4      = 2\n     };\n     struct WRITE4args {\n\
    \             /* CURRENT_FH: file */\n             stateid4        stateid;\n\
    \             offset4         offset;\n             stable_how4     stable;\n\
    \             opaque          data<>;\n     };\n   RESULT\n     struct WRITE4resok\
    \ {\n             count4          count;\n             stable_how4     committed;\n\
    \             verifier4       writeverf;\n     };\n     union WRITE4res switch\
    \ (nfsstat4 status) {\n      case NFS4_OK:\n              WRITE4resok    resok4;\n\
    \      default:\n              void;\n     };\n   DESCRIPTION\n   The WRITE operation\
    \ is used to write data to a regular file.  The\n   target file is specified by\
    \ the current filehandle.  The offset\n   specifies the offset where the data\
    \ should be written.  An offset of\n   0 (zero) specifies that the write should\
    \ start at the beginning of\n   the file.  The count, as encoded as part of the\
    \ opaque data\n   parameter, represents the number of bytes of data that are to\
    \ be\n   written.  If the count is 0 (zero), the WRITE will succeed and return\n\
    \   a count of 0 (zero) subject to permissions checking.  The server may\n   choose\
    \ to write fewer bytes than requested by the client.\n   Part of the write request\
    \ is a specification of how the write is to\n   be performed.  The client specifies\
    \ with the stable parameter the\n   method of how the data is to be processed\
    \ by the server.  If stable\n   is FILE_SYNC4, the server must commit the data\
    \ written plus all\n   filesystem metadata to stable storage before returning\
    \ results.  This\n   corresponds to the NFS version 2 protocol semantics.  Any\
    \ other\n   behavior constitutes a protocol violation.  If stable is DATA_SYNC4,\n\
    \   then the server must commit all of the data to stable storage and\n   enough\
    \ of the metadata to retrieve the data before returning.  The\n   server implementor\
    \ is free to implement DATA_SYNC4 in the same\n   fashion as FILE_SYNC4, but with\
    \ a possible performance drop.  If\n   stable is UNSTABLE4, the server is free\
    \ to commit any part of the\n   data and the metadata to stable storage, including\
    \ all or none,\n   before returning a reply to the client. There is no guarantee\
    \ whether\n   or when any uncommitted data will subsequently be committed to stable\n\
    \   storage. The only guarantees made by the server are that it will not\n   destroy\
    \ any data without changing the value of verf and that it will\n   not commit\
    \ the data and metadata at a level less than that requested\n   by the client.\n\
    \   The stateid value for a WRITE request represents a value returned\n   from\
    \ a previous record lock or share reservation request.  The\n   stateid is used\
    \ by the server to verify that the associated share\n   reservation and any record\
    \ locks are still valid and to update lease\n   timeouts for the client.\n   Upon\
    \ successful completion, the following results are returned.  The\n   count result\
    \ is the number of bytes of data written to the file. The\n   server may write\
    \ fewer bytes than requested. If so, the actual number\n   of bytes written starting\
    \ at location, offset, is returned.\n   The server also returns an indication\
    \ of the level of commitment of\n   the data and metadata via committed. If the\
    \ server committed all data\n   and metadata to stable storage, committed should\
    \ be set to\n   FILE_SYNC4. If the level of commitment was at least as strong\
    \ as\n   DATA_SYNC4, then committed should be set to DATA_SYNC4.  Otherwise,\n\
    \   committed must be returned as UNSTABLE4. If stable was FILE4_SYNC,\n   then\
    \ committed must also be FILE_SYNC4: anything else constitutes a\n   protocol\
    \ violation. If stable was DATA_SYNC4, then committed may be\n   FILE_SYNC4 or\
    \ DATA_SYNC4: anything else constitutes a protocol\n   violation. If stable was\
    \ UNSTABLE4, then committed may be either\n   FILE_SYNC4, DATA_SYNC4, or UNSTABLE4.\n\
    \   The final portion of the result is the write verifier.  The write\n   verifier\
    \ is a cookie that the client can use to determine whether the\n   server has\
    \ changed instance (boot) state between a call to WRITE and\n   a subsequent call\
    \ to either WRITE or COMMIT.  This cookie must be\n   consistent during a single\
    \ instance of the NFS version 4 protocol\n   service and must be unique between\
    \ instances of the NFS version 4\n   protocol server, where uncommitted data may\
    \ be lost.\n   If a client writes data to the server with the stable argument\
    \ set to\n   UNSTABLE4 and the reply yields a committed response of DATA_SYNC4\
    \ or\n   UNSTABLE4, the client will follow up some time in the future with a\n\
    \   COMMIT operation to synchronize outstanding asynchronous data and\n   metadata\
    \ with the server's stable storage, barring client error. It\n   is possible that\
    \ due to client crash or other error that a subsequent\n   COMMIT will not be\
    \ received by the server.\n   For a WRITE with a stateid value of all bits 0,\
    \ the server MAY allow\n   the WRITE to be serviced subject to mandatory file\
    \ locks or the\n   current share deny modes for the file.  For a WRITE with a\
    \ stateid\n   value of all bits 1, the server MUST NOT allow the WRITE operation\
    \ to\n   bypass locking checks at the server and are treated exactly the same\n\
    \   as if a stateid of all bits 0 were used.\n   On success, the current filehandle\
    \ retains its value.\n   IMPLEMENTATION\n   It is possible for the server to write\
    \ fewer bytes of data than\n   requested by the client.  In this case, the server\
    \ should not return\n   an error unless no data was written at all.  If the server\
    \ writes\n   less than the number of bytes specified, the client should issue\n\
    \   another WRITE to write the remaining data.\n   It is assumed that the act\
    \ of writing data to a file will cause the\n   time_modified of the file to be\
    \ updated.  However, the time_modified\n   of the file should not be changed unless\
    \ the contents of the file are\n   changed.  Thus, a WRITE request with count\
    \ set to 0 should not cause\n   the time_modified of the file to be updated.\n\
    \   The definition of stable storage has been historically a point of\n   contention.\
    \  The following expected properties of stable storage may\n   help in resolving\
    \ design issues in the implementation. Stable storage\n   is persistent storage\
    \ that survives:\n      1. Repeated power failures.\n      2. Hardware failures\
    \ (of any board, power supply, etc.).\n      3. Repeated software crashes, including\
    \ reboot cycle.\n   This definition does not address failure of the stable storage\
    \ module\n   itself.\n   The verifier is defined to allow a client to detect different\n\
    \   instances of an NFS version 4 protocol server over which cached,\n   uncommitted\
    \ data may be lost. In the most likely case, the verifier\n   allows the client\
    \ to detect server reboots.  This information is\n   required so that the client\
    \ can safely determine whether the server\n   could have lost cached data.  If\
    \ the server fails unexpectedly and\n   the client has uncommitted data from previous\
    \ WRITE requests (done\n   with the stable argument set to UNSTABLE4 and in which\
    \ the result\n   committed was returned as UNSTABLE4 as well) it may not have\
    \ flushed\n   cached data to stable storage. The burden of recovery is on the\n\
    \   client and the client will need to retransmit the data to the server.\n  \
    \ A suggested verifier would be to use the time that the server was\n   booted\
    \ or the time the server was last started (if restarting the\n   server without\
    \ a reboot results in lost buffers).\n   The committed field in the results allows\
    \ the client to do more\n   effective caching.  If the server is committing all\
    \ WRITE requests to\n   stable storage, then it should return with committed set\
    \ to\n   FILE_SYNC4, regardless of the value of the stable field in the\n   arguments.\
    \ A server that uses an NVRAM accelerator may choose to\n   implement this policy.\
    \  The client can use this to increase the\n   effectiveness of the cache by discarding\
    \ cached data that has already\n   been committed on the server.\n   Some implementations\
    \ may return NFS4ERR_NOSPC instead of\n   NFS4ERR_DQUOT when a user's quota is\
    \ exceeded.  In the case that the\n   current filehandle is a directory, the server\
    \ will return\n   NFS4ERR_ISDIR.  If the current filehandle is not a regular file\
    \ or a\n   directory, the server will return NFS4ERR_INVAL.\n   If mandatory file\
    \ locking is on for the file, and corresponding\n   record of the data to be written\
    \ file is read or write locked by an\n   owner that is not associated with the\
    \ stateid, the server will return\n   NFS4ERR_LOCKED. If so, the client must check\
    \ if the owner\n   corresponding to the stateid used with the WRITE operation\
    \ has a\n   conflicting read lock that overlaps with the region that was to be\n\
    \   written. If the stateid's owner has no conflicting read lock, then\n   the\
    \ client should try to get the appropriate write record lock via\n   the LOCK\
    \ operation before re-attempting the WRITE. When the WRITE\n   completes, the\
    \ client should release the record lock via LOCKU.\n   If the stateid's owner\
    \ had a conflicting read lock, then the client\n   has no choice but to return\
    \ an error to the application that\n   attempted the WRITE. The reason is that\
    \ since the stateid's owner had\n   a read lock, the server either attempted to\
    \ temporarily effectively\n   upgrade this read lock to a write lock, or the server\
    \ has no upgrade\n   capability. If the server attempted to upgrade the read lock\
    \ and\n   failed, it is pointless for the client to re-attempt the upgrade via\n\
    \   the LOCK operation, because there might be another client also trying\n  \
    \ to upgrade.  If two clients are blocked trying upgrade the same lock,\n   the\
    \ clients deadlock.  If the server has no upgrade capability, then\n   it is pointless\
    \ to try a LOCK operation to upgrade.\n   ERRORS\n      NFS4ERR_ACCESS\n     \
    \ NFS4ERR_ADMIN_REVOKED\n      NFS4ERR_BADHANDLE\n      NFS4ERR_BAD_STATEID\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_DELAY\n      NFS4ERR_DQUOT\n      NFS4ERR_EXPIRED\n\
    \      NFS4ERR_FBIG\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_GRACE\n      NFS4ERR_INVAL\n\
    \      NFS4ERR_IO\n      NFS4ERR_ISDIR\n      NFS4ERR_LEASE_MOVED\n      NFS4ERR_LOCKED\n\
    \      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOSPC\n      NFS4ERR_NXIO\n\
    \      NFS4ERR_OLD_STATEID\n      NFS4ERR_OPENMODE\n      NFS4ERR_RESOURCE\n \
    \     NFS4ERR_ROFS\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_STALE_STATEID\n"
- title: '14.2.37.  Operation 39: RELEASE_LOCKOWNER - Release Lockowner State'
  contents:
  - "14.2.37.  Operation 39: RELEASE_LOCKOWNER - Release Lockowner State\n   SYNOPSIS\n\
    \     lockowner -> ()\n   ARGUMENT\n     struct RELEASE_LOCKOWNER4args {\n   \
    \          lock_owner4     lock_owner;\n     };\n   RESULT\n     struct RELEASE_LOCKOWNER4res\
    \ {\n             nfsstat4        status;\n     };\n   DESCRIPTION\n   This operation\
    \ is used to notify the server that the lock_owner is no\n   longer in use by\
    \ the client.  This allows the server to release\n   cached state related to the\
    \ specified lock_owner.  If file locks,\n   associated with the lock_owner, are\
    \ held at the server, the error\n   NFS4ERR_LOCKS_HELD will be returned and no\
    \ further action will be\n   taken.\n   IMPLEMENTATION\n   The client may choose\
    \ to use this operation to ease the amount of\n   server state that is held. \
    \ Depending on behavior of applications at\n   the client, it may be important\
    \ for the client to use this operation\n   since the server has certain obligations\
    \ with respect to holding a\n   reference to a lock_owner as long as the associated\
    \ file is open.\n   Therefore, if the client knows for certain that the lock_owner\
    \ will\n   no longer be used under the context of the associated open_owner4,\
    \ it\n   should use RELEASE_LOCKOWNER.\n   ERRORS\n      NFS4ERR_ADMIN_REVOKED\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_EXPIRED\n      NFS4ERR_LEASE_MOVED\n    \
    \  NFS4ERR_LOCKS_HELD\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n   \
    \   NFS4ERR_STALE_CLIENTID\n"
- title: '14.2.38.  Operation 10044: ILLEGAL - Illegal operation'
  contents:
  - "14.2.38.  Operation 10044: ILLEGAL - Illegal operation\n   SYNOPSIS\n     <null>\
    \ -> ()\n   ARGUMENT\n             void;\n   RESULT\n             struct ILLEGAL4res\
    \ {\n                     nfsstat4        status;\n             };\n   DESCRIPTION\n\
    \   This operation is a placeholder for encoding a result to handle the\n   case\
    \ of the client sending an operation code within COMPOUND that is\n   not supported.\
    \ See the COMPOUND procedure description for more\n   details.\n   The status\
    \ field of ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.\n   IMPLEMENTATION\n\
    \   A client will probably not send an operation with code OP_ILLEGAL but\n  \
    \ if it does, the response will be ILLEGAL4res just as it would be with\n   any\
    \ other invalid operation code. Note that if the server gets an\n   illegal operation\
    \ code that is not OP_ILLEGAL, and if the server\n   checks for legal operation\
    \ codes during the XDR decode phase, then\n   the ILLEGAL4res would not be returned.\n\
    \   ERRORS\n   NFS4ERR_OP_ILLEGAL\n"
- title: 15.  NFS version 4 Callback Procedures
  contents:
  - "15.  NFS version 4 Callback Procedures\n   The procedures used for callbacks\
    \ are defined in the following\n   sections.  In the interest of clarity, the\
    \ terms \"client\" and\n   \"server\" refer to NFS clients and servers, despite\
    \ the fact that for\n   an individual callback RPC, the sense of these terms would\
    \ be\n   precisely the opposite.\n"
- title: '15.1.  Procedure 0: CB_NULL - No Operation'
  contents:
  - "15.1.  Procedure 0: CB_NULL - No Operation\n   SYNOPSIS\n     <null>\n   ARGUMENT\n\
    \     void;\n   RESULT\n     void;\n   DESCRIPTION\n   Standard NULL procedure.\
    \  Void argument, void response.  Even though\n   there is no direct functionality\
    \ associated with this procedure, the\n   server will use CB_NULL to confirm the\
    \ existence of a path for RPCs\n   from server to client.\n   ERRORS\n   None.\n"
- title: '15.2.  Procedure 1: CB_COMPOUND - Compound Operations'
  contents:
  - "15.2.  Procedure 1: CB_COMPOUND - Compound Operations\n   SYNOPSIS\n     compoundargs\
    \ -> compoundres\n   ARGUMENT\n     enum nfs_cb_opnum4 {\n             OP_CB_GETATTR\
    \           = 3,\n             OP_CB_RECALL            = 4,\n             OP_CB_ILLEGAL\
    \           = 10044\n     };\n     union nfs_cb_argop4 switch (unsigned argop)\
    \ {\n      case OP_CB_GETATTR:    CB_GETATTR4args opcbgetattr;\n      case OP_CB_RECALL:\
    \     CB_RECALL4args  opcbrecall;\n      case OP_CB_ILLEGAL:    void         \
    \   opcbillegal;\n     };\n     struct CB_COMPOUND4args {\n             utf8str_cs\
    \      tag;\n             uint32_t        minorversion;\n             uint32_t\
    \        callback_ident;\n             nfs_cb_argop4   argarray<>;\n     };\n\
    \   RESULT\n     union nfs_cb_resop4 switch (unsigned resop){\n      case OP_CB_GETATTR:\
    \    CB_GETATTR4res  opcbgetattr;\n      case OP_CB_RECALL:     CB_RECALL4res\
    \   opcbrecall;\n     };\n     struct CB_COMPOUND4res {\n             nfsstat4\
    \ status;\n             utf8str_cs      tag;\n             nfs_cb_resop4   resarray<>;\n\
    \     };\n   DESCRIPTION\n   The CB_COMPOUND procedure is used to combine one\
    \ or more of the\n   callback procedures into a single RPC request.  The main\
    \ callback RPC\n   program has two main procedures: CB_NULL and CB_COMPOUND. \
    \ All other\n   operations use the CB_COMPOUND procedure as a wrapper.\n   In\
    \ the processing of the CB_COMPOUND procedure, the client may find\n   that it\
    \ does not have the available resources to execute any or all\n   of the operations\
    \ within the CB_COMPOUND sequence.  In this case, the\n   error NFS4ERR_RESOURCE\
    \ will be returned for the particular operation\n   within the CB_COMPOUND procedure\
    \ where the resource exhaustion\n   occurred.  This assumes that all previous\
    \ operations within the\n   CB_COMPOUND sequence have been evaluated successfully.\n\
    \   Contained within the CB_COMPOUND results is a 'status' field.  This\n   status\
    \ must be equivalent to the status of the last operation that\n   was executed\
    \ within the CB_COMPOUND procedure.  Therefore, if an\n   operation incurred an\
    \ error then the 'status' value will be the same\n   error value as is being returned\
    \ for the operation that failed.\n   For the definition of the \"tag\" field,\
    \ see the section \"Procedure 1:\n   COMPOUND - Compound Operations\".\n   The\
    \ value of callback_ident is supplied by the client during\n   SETCLIENTID.  The\
    \ server must use the client supplied callback_ident\n   during the CB_COMPOUND\
    \ to allow the client to properly identify the\n   server.\n   Illegal operation\
    \ codes are handled in the same way as they are\n   handled for the COMPOUND procedure.\n\
    \   IMPLEMENTATION\n   The CB_COMPOUND procedure is used to combine individual\
    \ operations\n   into a single RPC request.  The client interprets each of the\n\
    \   operations in turn.  If an operation is executed by the client and\n   the\
    \ status of that operation is NFS4_OK, then the next operation in\n   the CB_COMPOUND\
    \ procedure is executed.  The client continues this\n   process until there are\
    \ no more operations to be executed or one of\n   the operations has a status\
    \ value other than NFS4_OK.\n   ERRORS\n      NFS4ERR_BADHANDLE\n      NFS4ERR_BAD_STATEID\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_OP_ILLEGAL\n      NFS4ERR_RESOURCE\n    \
    \  NFS4ERR_SERVERFAULT\n"
- title: '15.2.1.  Operation 3: CB_GETATTR - Get Attributes'
  contents:
  - "15.2.1.  Operation 3: CB_GETATTR - Get Attributes\n   SYNOPSIS\n     fh, attr_request\
    \ -> attrmask, attr_vals\n   ARGUMENT\n     struct CB_GETATTR4args {\n       \
    \      nfs_fh4 fh;\n             bitmap4 attr_request;\n     };\n   RESULT\n \
    \    struct CB_GETATTR4resok {\n             fattr4  obj_attributes;\n     };\n\
    \     union CB_GETATTR4res switch (nfsstat4 status) {\n      case NFS4_OK:\n \
    \             CB_GETATTR4resok       resok4;\n      default:\n              void;\n\
    \     };\n"
- title: DESCRIPTION
  contents:
  - "DESCRIPTION\n   The CB_GETATTR operation is used by the server to obtain the\n\
    \   current modified state of a file that has been write delegated.\n   The attributes\
    \ size and change are the only ones guaranteed to be\n   serviced by the client.\
    \  See the section \"Handling of CB_GETATTR\"\n   for a full description of how\
    \ the client and server are to interact\n   with the use of CB_GETATTR.\n   If\
    \ the filehandle specified is not one for which the client holds a\n   write open\
    \ delegation, an NFS4ERR_BADHANDLE error is returned.\n   IMPLEMENTATION\n   The\
    \ client returns attrmask bits and the associated attribute\n   values only for\
    \ the change attribute, and attributes that it may\n   change (time_modify, and\
    \ size).\n   ERRORS\n      NFS4ERR_BADHANDLE\n      NFS4ERR_BADXDR\n      NFS4ERR_RESOURCE\n\
    \      NFS4ERR_SERVERFAULT\n"
- title: '15.2.2.  Operation 4: CB_RECALL - Recall an Open Delegation'
  contents:
  - "15.2.2.  Operation 4: CB_RECALL - Recall an Open Delegation\n   SYNOPSIS\n  \
    \   stateid, truncate, fh -> ()\n   ARGUMENT\n     struct CB_RECALL4args {\n \
    \            stateid4        stateid;\n             bool            truncate;\n\
    \             nfs_fh4         fh;\n     };\n   RESULT\n     struct CB_RECALL4res\
    \ {\n             nfsstat4        status;\n     };\n   DESCRIPTION\n   The CB_RECALL\
    \ operation is used to begin the process of recalling an\n   open delegation and\
    \ returning it to the server.\n   The truncate flag is used to optimize recall\
    \ for a file which is\n   about to be truncated to zero.  When it is set, the\
    \ client is freed\n   of obligation to propagate modified data for the file to\
    \ the server,\n   since this data is irrelevant.\n   If the handle specified is\
    \ not one for which the client holds an open\n   delegation, an NFS4ERR_BADHANDLE\
    \ error is returned.\n   If the stateid specified is not one corresponding to\
    \ an open\n   delegation for the file specified by the filehandle, an\n   NFS4ERR_BAD_STATEID\
    \ is returned.\n   IMPLEMENTATION\n   The client should reply to the callback\
    \ immediately.  Replying does\n   not complete the recall except when an error\
    \ was returned.  The\n   recall is not complete until the delegation is returned\
    \ using a\n   DELEGRETURN.\n   ERRORS\n      NFS4ERR_BADHANDLE\n      NFS4ERR_BAD_STATEID\n\
    \      NFS4ERR_BADXDR\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n"
- title: '15.2.3.  Operation 10044: CB_ILLEGAL - Illegal Callback Operation'
  contents:
  - "15.2.3.  Operation 10044: CB_ILLEGAL - Illegal Callback Operation\n   SYNOPSIS\n\
    \     <null> -> ()\n   ARGUMENT\n       void;\n   RESULT\n             struct\
    \ CB_ILLEGAL4res {\n                     nfsstat4        status;\n           \
    \  };\n   DESCRIPTION\n   This operation is a placeholder for encoding a result\
    \ to handle the\n   case of the client sending an operation code within COMPOUND\
    \ that is\n   not supported. See the COMPOUND procedure description for more\n\
    \   details.\n   The status field of CB_ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.\n\
    \   IMPLEMENTATION\n   A server will probably not send an operation with code\
    \ OP_CB_ILLEGAL\n   but if it does, the response will be CB_ILLEGAL4res just as\
    \ it would\n   be with any other invalid operation code. Note that if the client\n\
    \   gets an illegal operation code that is not OP_ILLEGAL, and if the\n   client\
    \ checks for legal operation codes during the XDR decode phase,\n   then the CB_ILLEGAL4res\
    \ would not be returned.\n   ERRORS\n   NFS4ERR_OP_ILLEGAL\n"
- title: 16.  Security Considerations
  contents:
  - "16.  Security Considerations\n   NFS has historically used a model where, from\
    \ an authentication\n   perspective, the client was the entire machine, or at\
    \ least the\n   source IP address of the machine.  The NFS server relied on the\
    \ NFS\n   client to make the proper authentication of the end-user.  The NFS\n\
    \   server in turn shared its files only to specific clients, as\n   identified\
    \ by the client's source IP address.  Given this model, the\n   AUTH_SYS RPC security\
    \ flavor simply identified the end-user using the\n   client to the NFS server.\
    \  When processing NFS responses, the client\n   ensured that the responses came\
    \ from the same IP address and port\n   number that the request was sent to. \
    \ While such a model is easy to\n   implement and simple to deploy and use, it\
    \ is certainly not a safe\n   model.  Thus, NFSv4 mandates that implementations\
    \ support a security\n   model that uses end to end authentication, where an end-user\
    \ on a\n   client mutually authenticates (via cryptographic schemes that do not\n\
    \   expose passwords or keys in the clear on the network) to a principal\n   on\
    \ an NFS server.  Consideration should also be given to the\n   integrity and\
    \ privacy of NFS requests and responses.  The issues of\n   end to end mutual\
    \ authentication, integrity, and privacy are\n   discussed as part of the section\
    \ on \"RPC and Security Flavor\".\n   Note that while NFSv4 mandates an end to\
    \ end mutual authentication\n   model, the \"classic\" model of machine authentication\
    \ via IP address\n   checking and AUTH_SYS identification can still be supported\
    \ with the\n   caveat that the AUTH_SYS flavor is neither MANDATORY nor RECOMMENDED\n\
    \   by this specification, and so interoperability via AUTH_SYS is not\n   assured.\n\
    \   For reasons of reduced administration overhead, better performance\n   and/or\
    \ reduction of CPU utilization, users of NFS version 4\n   implementations may\
    \ choose to not use security mechanisms that enable\n   integrity protection on\
    \ each remote procedure call and response. The\n   use of mechanisms without integrity\
    \ leaves the customer vulnerable to\n   an attacker in between the NFS client\
    \ and server that modifies the\n   RPC request and/or the response. While implementations\
    \ are free to\n   provide the option to use weaker security mechanisms, there\
    \ are two\n   operations in particular that warrant the implementation overriding\n\
    \   user choices.\n   The first such operation is SECINFO.  It is recommended\
    \ that the\n   client issue the SECINFO call such that it is protected with a\n\
    \   security flavor that has integrity protection, such as RPCSEC_GSS\n   with\
    \ a security triple that uses either rpc_gss_svc_integrity or\n   rpc_gss_svc_privacy\
    \ (rpc_gss_svc_privacy includes integrity\n   protection) service. Without integrity\
    \ protection encapsulating\n   SECINFO and therefore its results, an attacker\
    \ in the middle could\n   modify results such that the client might select a weaker\
    \ algorithm\n   in the set allowed by server, making the client and/or server\n\
    \   vulnerable to further attacks.\n   The second operation that should definitely\
    \ use integrity protection\n   is any GETATTR for the fs_locations attribute.\
    \ The attack has two\n   steps.  First the attacker modifies the unprotected results\
    \ of some\n   operation to return NFS4ERR_MOVED. Second, when the client follows\
    \ up\n   with a GETATTR for the fs_locations attribute, the attacker modifies\n\
    \   the results to cause the client migrate its traffic to a server\n   controlled\
    \ by the attacker.\n   Because the operations SETCLIENTID/SETCLIENTID_CONFIRM\
    \ are\n   responsible for the release of client state, it is imperative that\n\
    \   the principal used for these operations is checked against and match\n   the\
    \ previous use of these operations.  See the section \"Client ID\"\n   for further\
    \ discussion.\n"
- title: 17.  IANA Considerations
  contents:
  - '17.  IANA Considerations

    '
- title: 17.1.  Named Attribute Definition
  contents:
  - "17.1.  Named Attribute Definition\n   The NFS version 4 protocol provides for\
    \ the association of named\n   attributes to files.  The name space identifiers\
    \ for these attributes\n   are defined as string names.  The protocol does not\
    \ define the\n   specific assignment of the name space for these file attributes.\n\
    \   Even though the name space is not specifically controlled to prevent\n   collisions,\
    \ an IANA registry has been created for the registration of\n   NFS version 4\
    \ named attributes.  Registration will be achieved\n   through the publication\
    \ of an Informational RFC and will require not\n   only the name of the attribute\
    \ but the syntax and semantics of the\n   named attribute contents; the intent\
    \ is to promote interoperability\n   where common interests exist.  While application\
    \ developers are\n   allowed to define and use attributes as needed, they are\
    \ encouraged\n   to register the attributes with IANA.\n"
- title: 17.2.  ONC RPC Network Identifiers (netids)
  contents:
  - "17.2.  ONC RPC Network Identifiers (netids)\n   The section \"Structured Data\
    \ Types\" discussed the r_netid field and\n   the corresponding r_addr field of\
    \ a clientaddr4 structure.  The NFS\n   version 4 protocol depends on the syntax\
    \ and semantics of these\n   fields to effectively communicate callback information\
    \ between client\n   and server.  Therefore, an IANA registry has been created\
    \ to include\n   the values defined in this document and to allow for future expansion\n\
    \   based on transport usage/availability.  Additions to this ONC RPC\n   Network\
    \ Identifier registry must be done with the publication of an\n   RFC.\n   The\
    \ initial values for this registry are as follows (some of this\n   text is replicated\
    \ from section 2.2 for clarity):\n   The Network Identifier (or r_netid for short)\
    \ is used to specify a\n   transport protocol and associated universal address\
    \ (or r_addr for\n   short).  The syntax of the Network Identifier is a US-ASCII\
    \ string.\n   The initial definitions for r_netid are:\n      \"tcp\"   - TCP\
    \ over IP version 4\n      \"udp\"   - UDP over IP version 4\n      \"tcp6\" \
    \ - TCP over IP version 6\n      \"udp6\"  - UDP over IP version 6\n   Note: the\
    \ '\"' marks are used for delimiting the strings for this\n   document and are\
    \ not part of the Network Identifier string.\n   For the \"tcp\" and \"udp\" Network\
    \ Identifiers the Universal Address or\n   r_addr (for IPv4) is a US-ASCII string\
    \ and is of the form:\n   h1.h2.h3.h4.p1.p2\n   The prefix, \"h1.h2.h3.h4\", is\
    \ the standard textual form for\n   representing an IPv4 address, which is always\
    \ four octets long.\n   Assuming big-endian ordering, h1, h2, h3, and h4, are\
    \ respectively,\n   the first through fourth octets each converted to ASCII-decimal.\n\
    \   Assuming big-endian ordering, p1 and p2 are, respectively, the first\n   and\
    \ second octets each converted to ASCII-decimal.  For example, if a\n   host,\
    \ in big-endian order, has an address of 0x0A010307 and there is\n   a service\
    \ listening on, in big endian order, port 0x020F (decimal\n   527), then complete\
    \ universal address is \"10.1.3.7.2.15\".\n   For the \"tcp6\" and \"udp6\" Network\
    \ Identifiers the Universal Address\n   or r_addr (for IPv6) is a US-ASCII string\
    \ and is of the form:\n      x1:x2:x3:x4:x5:x6:x7:x8.p1.p2\n   The suffix \"p1.p2\"\
    \ is the service port, and is computed the same way\n   as with universal addresses\
    \ for \"tcp\" and \"udp\".  The prefix,\n   \"x1:x2:x3:x4:x5:x6:x7:x8\", is the\
    \ standard textual form for\n   representing an IPv6 address as defined in Section\
    \ 2.2 of [RFC2373].\n   Additionally, the two alternative forms specified in Section\
    \ 2.2 of\n   [RFC2373] are also acceptable.\n   As mentioned, the registration\
    \ of new Network Identifiers will\n   require the publication of an Information\
    \ RFC with similar detail as\n   listed above for the Network Identifier itself\
    \ and corresponding\n   Universal Address.\n"
- title: 18.  RPC definition file
  contents:
  - "18.  RPC definition file\n   /*\n    *  Copyright (C) The Internet Society (1998,1999,2000,2001,2002).\n\
    \    *  All Rights Reserved.\n    */\n   /*\n    *      nfs4_prot.x\n    *\n \
    \   */\n   %#pragma ident  \"%W%\"\n   /*\n    * Basic typedefs for RFC 1832 data\
    \ type definitions\n    */\n   typedef int             int32_t;\n   typedef unsigned\
    \ int    uint32_t;\n   typedef hyper           int64_t;\n   typedef unsigned hyper\
    \  uint64_t;\n   /*\n    * Sizes\n    */\n   const NFS4_FHSIZE               =\
    \ 128;\n   const NFS4_VERIFIER_SIZE        = 8;\n   const NFS4_OPAQUE_LIMIT  \
    \       = 1024;\n   /*\n    * File types\n    */\n   enum nfs_ftype4 {\n     \
    \      NF4REG          = 1,    /* Regular File */\n           NF4DIR         \
    \ = 2,    /* Directory */\n           NF4BLK          = 3,    /* Special File\
    \ - block device */\n           NF4CHR          = 4,    /* Special File - character\
    \ device */\n           NF4LNK          = 5,    /* Symbolic Link */\n        \
    \   NF4SOCK         = 6,    /* Special File - socket */\n           NF4FIFO  \
    \       = 7,    /* Special File - fifo */\n           NF4ATTRDIR      = 8,   \
    \ /* Attribute Directory */\n           NF4NAMEDATTR    = 9     /* Named Attribute\
    \ */\n   };\n   /*\n    * Error status\n    */\n   enum nfsstat4 {\n         \
    \  NFS4_OK                 = 0,    /* everything is okay      */\n           NFS4ERR_PERM\
    \            = 1,    /* caller not privileged   */\n           NFS4ERR_NOENT \
    \          = 2,    /* no such file/directory  */\n           NFS4ERR_IO      \
    \        = 5,    /* hard I/O error          */\n           NFS4ERR_NXIO      \
    \      = 6,    /* no such device          */\n           NFS4ERR_ACCESS      \
    \    = 13,   /* access denied           */\n           NFS4ERR_EXIST         \
    \  = 17,   /* file already exists     */\n           NFS4ERR_XDEV            =\
    \ 18,   /* different filesystems   */\n           /* Unused/reserved        19\
    \ */\n           NFS4ERR_NOTDIR          = 20,   /* should be a directory   */\n\
    \           NFS4ERR_ISDIR           = 21,   /* should not be directory */\n  \
    \         NFS4ERR_INVAL           = 22,   /* invalid argument        */\n    \
    \       NFS4ERR_FBIG            = 27,   /* file exceeds server max */\n      \
    \     NFS4ERR_NOSPC           = 28,   /* no space on filesystem  */\n        \
    \   NFS4ERR_ROFS            = 30,   /* read-only filesystem    */\n          \
    \ NFS4ERR_MLINK           = 31,   /* too many hard links     */\n           NFS4ERR_NAMETOOLONG\
    \     = 63,   /* name exceeds server max */\n           NFS4ERR_NOTEMPTY     \
    \   = 66,   /* directory not empty     */\n           NFS4ERR_DQUOT          \
    \ = 69,   /* hard quota limit reached*/\n           NFS4ERR_STALE           =\
    \ 70,   /* file no longer exists   */\n           NFS4ERR_BADHANDLE       = 10001,/*\
    \ Illegal filehandle      */\n           NFS4ERR_BAD_COOKIE      = 10003,/* READDIR\
    \ cookie is stale */\n           NFS4ERR_NOTSUPP         = 10004,/* operation\
    \ not supported */\n           NFS4ERR_TOOSMALL        = 10005,/* response limit\
    \ exceeded */\n           NFS4ERR_SERVERFAULT     = 10006,/* undefined server\
    \ error  */\n           NFS4ERR_BADTYPE         = 10007,/* type invalid for CREATE\
    \ */\n           NFS4ERR_DELAY           = 10008,/* file \"busy\" - retry    \
    \ */\n           NFS4ERR_SAME            = 10009,/* nverify says attrs same */\n\
    \           NFS4ERR_DENIED          = 10010,/* lock unavailable        */\n  \
    \         NFS4ERR_EXPIRED         = 10011,/* lock lease expired      */\n    \
    \       NFS4ERR_LOCKED          = 10012,/* I/O failed due to lock  */\n      \
    \     NFS4ERR_GRACE           = 10013,/* in grace period         */\n        \
    \   NFS4ERR_FHEXPIRED       = 10014,/* filehandle expired      */\n          \
    \ NFS4ERR_SHARE_DENIED    = 10015,/* share reserve denied    */\n           NFS4ERR_WRONGSEC\
    \        = 10016,/* wrong security flavor   */\n           NFS4ERR_CLID_INUSE\
    \      = 10017,/* clientid in use         */\n           NFS4ERR_RESOURCE    \
    \    = 10018,/* resource exhaustion     */\n           NFS4ERR_MOVED         \
    \  = 10019,/* filesystem relocated    */\n           NFS4ERR_NOFILEHANDLE    =\
    \ 10020,/* current FH is not set   */\n           NFS4ERR_MINOR_VERS_MISMATCH\
    \ = 10021,/* minor vers not supp */\n           NFS4ERR_STALE_CLIENTID  = 10022,/*\
    \ server has rebooted     */\n           NFS4ERR_STALE_STATEID   = 10023,/* server\
    \ has rebooted     */\n           NFS4ERR_OLD_STATEID     = 10024,/* state is\
    \ out of sync    */\n           NFS4ERR_BAD_STATEID     = 10025,/* incorrect stateid\
    \       */\n           NFS4ERR_BAD_SEQID       = 10026,/* request is out of seq.\
    \  */\n           NFS4ERR_NOT_SAME        = 10027,/* verify - attrs not same */\n\
    \           NFS4ERR_LOCK_RANGE      = 10028,/* lock range not supported*/\n  \
    \         NFS4ERR_SYMLINK         = 10029,/* should be file/directory*/\n    \
    \       NFS4ERR_RESTOREFH       = 10030,/* no saved filehandle     */\n      \
    \     NFS4ERR_LEASE_MOVED     = 10031,/* some filesystem moved   */\n        \
    \   NFS4ERR_ATTRNOTSUPP     = 10032,/* recommended attr not sup*/\n          \
    \ NFS4ERR_NO_GRACE        = 10033,/* reclaim outside of grace*/\n           NFS4ERR_RECLAIM_BAD\
    \     = 10034,/* reclaim error at server */\n           NFS4ERR_RECLAIM_CONFLICT\
    \ = 10035,/* conflict on reclaim    */\n           NFS4ERR_BADXDR          = 10036,/*\
    \ XDR decode failed       */\n           NFS4ERR_LOCKS_HELD      = 10037,/* file\
    \ locks held at CLOSE*/\n           NFS4ERR_OPENMODE        = 10038,/* conflict\
    \ in OPEN and I/O*/\n           NFS4ERR_BADOWNER        = 10039,/* owner translation\
    \ bad   */\n           NFS4ERR_BADCHAR         = 10040,/* utf-8 char not supported*/\n\
    \           NFS4ERR_BADNAME         = 10041,/* name not supported      */\n  \
    \         NFS4ERR_BAD_RANGE       = 10042,/* lock range not supported*/\n    \
    \       NFS4ERR_LOCK_NOTSUPP    = 10043,/* no atomic up/downgrade  */\n      \
    \     NFS4ERR_OP_ILLEGAL      = 10044,/* undefined operation     */\n        \
    \   NFS4ERR_DEADLOCK        = 10045,/* file locking deadlock   */\n          \
    \ NFS4ERR_FILE_OPEN       = 10046,/* open file blocks op.    */\n           NFS4ERR_ADMIN_REVOKED\
    \   = 10047,/* lockowner state revoked */\n           NFS4ERR_CB_PATH_DOWN   \
    \ = 10048 /* callback path down      */\n   };\n   /*\n    * Basic data types\n\
    \    */\n   typedef uint32_t        bitmap4<>;\n   typedef uint64_t        offset4;\n\
    \   typedef uint32_t        count4;\n   typedef uint64_t        length4;\n   typedef\
    \ uint64_t        clientid4;\n   typedef uint32_t        seqid4;\n   typedef opaque\
    \          utf8string<>;\n   typedef utf8string      utf8str_cis;\n   typedef\
    \ utf8string      utf8str_cs;\n   typedef utf8string      utf8str_mixed;\n   typedef\
    \ utf8str_cs      component4;\n   typedef component4      pathname4<>;\n   typedef\
    \ uint64_t        nfs_lockid4;\n   typedef uint64_t        nfs_cookie4;\n   typedef\
    \ utf8str_cs      linktext4;\n   typedef opaque          sec_oid4<>;\n   typedef\
    \ uint32_t        qop4;\n   typedef uint32_t        mode4;\n   typedef uint64_t\
    \        changeid4;\n   typedef opaque          verifier4[NFS4_VERIFIER_SIZE];\n\
    \   /*\n    * Timeval\n    */\n   struct nfstime4 {\n           int64_t      \
    \   seconds;\n           uint32_t        nseconds;\n   };\n   enum time_how4 {\n\
    \           SET_TO_SERVER_TIME4 = 0,\n           SET_TO_CLIENT_TIME4 = 1\n   };\n\
    \   union settime4 switch (time_how4 set_it) {\n    case SET_TO_CLIENT_TIME4:\n\
    \            nfstime4       time;\n    default:\n            void;\n   };\n  \
    \ /*\n    * File access handle\n    */\n   typedef opaque  nfs_fh4<NFS4_FHSIZE>;\n\
    \   /*\n    * File attribute definitions\n    */\n   /*\n    * FSID structure\
    \ for major/minor\n    */\n   struct fsid4 {\n           uint64_t        major;\n\
    \           uint64_t        minor;\n   };\n   /*\n    * Filesystem locations attribute\
    \ for relocation/migration\n    */\n   struct fs_location4 {\n           utf8str_cis\
    \     server<>;\n           pathname4       rootpath;\n   };\n   struct fs_locations4\
    \ {\n           pathname4       fs_root;\n           fs_location4    locations<>;\n\
    \   };\n   /*\n    * Various Access Control Entry definitions\n    */\n   /*\n\
    \    * Mask that indicates which Access Control Entries are supported.\n    *\
    \ Values for the fattr4_aclsupport attribute.\n    */\n   const ACL4_SUPPORT_ALLOW_ACL\
    \    = 0x00000001;\n   const ACL4_SUPPORT_DENY_ACL     = 0x00000002;\n   const\
    \ ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;\n   const ACL4_SUPPORT_ALARM_ACL   \
    \ = 0x00000008;\n   typedef uint32_t        acetype4;\n   /*\n    * acetype4 values,\
    \ others can be added as needed.\n    */\n   const ACE4_ACCESS_ALLOWED_ACE_TYPE\
    \      = 0x00000000;\n   const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;\n\
    \   const ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;\n   const ACE4_SYSTEM_ALARM_ACE_TYPE\
    \        = 0x00000003;\n   /*\n    * ACE flag\n    */\n   typedef uint32_t aceflag4;\n\
    \   /*\n    * ACE flag values\n    */\n   const ACE4_FILE_INHERIT_ACE        \
    \     = 0x00000001;\n   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;\n\
    \   const ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;\n   const ACE4_INHERIT_ONLY_ACE\
    \             = 0x00000008;\n   const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;\n\
    \   const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;\n   const ACE4_IDENTIFIER_GROUP\
    \             = 0x00000040;\n   /*\n    * ACE mask\n    */\n   typedef uint32_t\
    \        acemask4;\n   /*\n    * ACE mask values\n    */\n   const ACE4_READ_DATA\
    \            = 0x00000001;\n   const ACE4_LIST_DIRECTORY       = 0x00000001;\n\
    \   const ACE4_WRITE_DATA           = 0x00000002;\n   const ACE4_ADD_FILE    \
    \         = 0x00000002;\n   const ACE4_APPEND_DATA          = 0x00000004;\n  \
    \ const ACE4_ADD_SUBDIRECTORY     = 0x00000004;\n   const ACE4_READ_NAMED_ATTRS\
    \     = 0x00000008;\n   const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;\n   const\
    \ ACE4_EXECUTE              = 0x00000020;\n   const ACE4_DELETE_CHILD        \
    \ = 0x00000040;\n   const ACE4_READ_ATTRIBUTES      = 0x00000080;\n   const ACE4_WRITE_ATTRIBUTES\
    \     = 0x00000100;\n   const ACE4_DELETE               = 0x00010000;\n   const\
    \ ACE4_READ_ACL             = 0x00020000;\n   const ACE4_WRITE_ACL           \
    \ = 0x00040000;\n   const ACE4_WRITE_OWNER          = 0x00080000;\n   const ACE4_SYNCHRONIZE\
    \          = 0x00100000;\n   /*\n    * ACE4_GENERIC_READ -- defined as combination\
    \ of\n    *      ACE4_READ_ACL |\n    *      ACE4_READ_DATA |\n    *      ACE4_READ_ATTRIBUTES\
    \ |\n    *      ACE4_SYNCHRONIZE\n    */\n   const ACE4_GENERIC_READ = 0x00120081;\n\
    \   /*\n    * ACE4_GENERIC_WRITE -- defined as combination of\n    *      ACE4_READ_ACL\
    \ |\n    *      ACE4_WRITE_DATA |\n    *      ACE4_WRITE_ATTRIBUTES |\n    * \
    \     ACE4_WRITE_ACL |\n    *      ACE4_APPEND_DATA |\n    *      ACE4_SYNCHRONIZE\n\
    \    */\n   const ACE4_GENERIC_WRITE = 0x00160106;\n   /*\n    * ACE4_GENERIC_EXECUTE\
    \ -- defined as combination of\n    *      ACE4_READ_ACL\n    *      ACE4_READ_ATTRIBUTES\n\
    \    *      ACE4_EXECUTE\n    *      ACE4_SYNCHRONIZE\n    */\n   const ACE4_GENERIC_EXECUTE\
    \ = 0x001200A0;\n   /*\n    * Access Control Entry definition\n    */\n   struct\
    \ nfsace4 {\n           acetype4        type;\n           aceflag4        flag;\n\
    \           acemask4        access_mask;\n           utf8str_mixed   who;\n  \
    \ };\n   /*\n    * Field definitions for the fattr4_mode attribute\n    */\n \
    \  const MODE4_SUID = 0x800;  /* set user id on execution */\n   const MODE4_SGID\
    \ = 0x400;  /* set group id on execution */\n   const MODE4_SVTX = 0x200;  /*\
    \ save text even after use */\n   const MODE4_RUSR = 0x100;  /* read permission:\
    \ owner */\n   const MODE4_WUSR = 0x080;  /* write permission: owner */\n   const\
    \ MODE4_XUSR = 0x040;  /* execute permission: owner */\n   const MODE4_RGRP =\
    \ 0x020;  /* read permission: group */\n   const MODE4_WGRP = 0x010;  /* write\
    \ permission: group */\n   const MODE4_XGRP = 0x008;  /* execute permission: group\
    \ */\n   const MODE4_ROTH = 0x004;  /* read permission: other */\n   const MODE4_WOTH\
    \ = 0x002;  /* write permission: other */\n   const MODE4_XOTH = 0x001;  /* execute\
    \ permission: other */\n   /*\n    * Special data/attribute associated with\n\
    \    * file types NF4BLK and NF4CHR.\n    */\n   struct specdata4 {\n        \
    \   uint32_t        specdata1;      /* major device number */\n           uint32_t\
    \        specdata2;      /* minor device number */\n   };\n   /*\n    * Values\
    \ for fattr4_fh_expire_type\n    */\n   const   FH4_PERSISTENT          = 0x00000000;\n\
    \   const   FH4_NOEXPIRE_WITH_OPEN  = 0x00000001;\n   const   FH4_VOLATILE_ANY\
    \        = 0x00000002;\n   const   FH4_VOL_MIGRATION       = 0x00000004;\n   const\
    \   FH4_VOL_RENAME          = 0x00000008;\n   typedef bitmap4         fattr4_supported_attrs;\n\
    \   typedef nfs_ftype4      fattr4_type;\n   typedef uint32_t        fattr4_fh_expire_type;\n\
    \   typedef changeid4       fattr4_change;\n   typedef uint64_t        fattr4_size;\n\
    \   typedef bool            fattr4_link_support;\n   typedef bool            fattr4_symlink_support;\n\
    \   typedef bool            fattr4_named_attr;\n   typedef fsid4           fattr4_fsid;\n\
    \   typedef bool            fattr4_unique_handles;\n   typedef uint32_t      \
    \  fattr4_lease_time;\n   typedef nfsstat4        fattr4_rdattr_error;\n   typedef\
    \ nfsace4         fattr4_acl<>;\n   typedef uint32_t        fattr4_aclsupport;\n\
    \   typedef bool            fattr4_archive;\n   typedef bool            fattr4_cansettime;\n\
    \   typedef bool            fattr4_case_insensitive;\n   typedef bool        \
    \    fattr4_case_preserving;\n   typedef bool            fattr4_chown_restricted;\n\
    \   typedef uint64_t        fattr4_fileid;\n   typedef uint64_t        fattr4_files_avail;\n\
    \   typedef nfs_fh4         fattr4_filehandle;\n   typedef uint64_t        fattr4_files_free;\n\
    \   typedef uint64_t        fattr4_files_total;\n   typedef fs_locations4   fattr4_fs_locations;\n\
    \   typedef bool            fattr4_hidden;\n   typedef bool            fattr4_homogeneous;\n\
    \   typedef uint64_t        fattr4_maxfilesize;\n   typedef uint32_t        fattr4_maxlink;\n\
    \   typedef uint32_t        fattr4_maxname;\n   typedef uint64_t        fattr4_maxread;\n\
    \   typedef uint64_t        fattr4_maxwrite;\n   typedef utf8str_cs      fattr4_mimetype;\n\
    \   typedef mode4           fattr4_mode;\n   typedef uint64_t        fattr4_mounted_on_fileid;\n\
    \   typedef bool            fattr4_no_trunc;\n   typedef uint32_t        fattr4_numlinks;\n\
    \   typedef utf8str_mixed   fattr4_owner;\n   typedef utf8str_mixed   fattr4_owner_group;\n\
    \   typedef uint64_t        fattr4_quota_avail_hard;\n   typedef uint64_t    \
    \    fattr4_quota_avail_soft;\n   typedef uint64_t        fattr4_quota_used;\n\
    \   typedef specdata4       fattr4_rawdev;\n   typedef uint64_t        fattr4_space_avail;\n\
    \   typedef uint64_t        fattr4_space_free;\n   typedef uint64_t        fattr4_space_total;\n\
    \   typedef uint64_t        fattr4_space_used;\n   typedef bool            fattr4_system;\n\
    \   typedef nfstime4        fattr4_time_access;\n   typedef settime4        fattr4_time_access_set;\n\
    \   typedef nfstime4        fattr4_time_backup;\n   typedef nfstime4        fattr4_time_create;\n\
    \   typedef nfstime4        fattr4_time_delta;\n   typedef nfstime4        fattr4_time_metadata;\n\
    \   typedef nfstime4        fattr4_time_modify;\n   typedef settime4        fattr4_time_modify_set;\n\
    \   /*\n    * Mandatory Attributes\n    */\n   const FATTR4_SUPPORTED_ATTRS  \
    \  = 0;\n   const FATTR4_TYPE               = 1;\n   const FATTR4_FH_EXPIRE_TYPE\
    \     = 2;\n   const FATTR4_CHANGE             = 3;\n   const FATTR4_SIZE    \
    \           = 4;\n   const FATTR4_LINK_SUPPORT       = 5;\n   const FATTR4_SYMLINK_SUPPORT\
    \    = 6;\n   const FATTR4_NAMED_ATTR         = 7;\n   const FATTR4_FSID     \
    \          = 8;\n   const FATTR4_UNIQUE_HANDLES     = 9;\n   const FATTR4_LEASE_TIME\
    \         = 10;\n   const FATTR4_RDATTR_ERROR       = 11;\n   const FATTR4_FILEHANDLE\
    \         = 19;\n   /*\n    * Recommended Attributes\n    */\n   const FATTR4_ACL\
    \                = 12;\n   const FATTR4_ACLSUPPORT         = 13;\n   const FATTR4_ARCHIVE\
    \            = 14;\n   const FATTR4_CANSETTIME         = 15;\n   const FATTR4_CASE_INSENSITIVE\
    \   = 16;\n   const FATTR4_CASE_PRESERVING    = 17;\n   const FATTR4_CHOWN_RESTRICTED\
    \   = 18;\n   const FATTR4_FILEID             = 20;\n   const FATTR4_FILES_AVAIL\
    \        = 21;\n   const FATTR4_FILES_FREE         = 22;\n   const FATTR4_FILES_TOTAL\
    \        = 23;\n   const FATTR4_FS_LOCATIONS       = 24;\n   const FATTR4_HIDDEN\
    \             = 25;\n   const FATTR4_HOMOGENEOUS        = 26;\n   const FATTR4_MAXFILESIZE\
    \        = 27;\n   const FATTR4_MAXLINK            = 28;\n   const FATTR4_MAXNAME\
    \            = 29;\n   const FATTR4_MAXREAD            = 30;\n   const FATTR4_MAXWRITE\
    \           = 31;\n   const FATTR4_MIMETYPE           = 32;\n   const FATTR4_MODE\
    \               = 33;\n   const FATTR4_NO_TRUNC           = 34;\n   const FATTR4_NUMLINKS\
    \           = 35;\n   const FATTR4_OWNER              = 36;\n   const FATTR4_OWNER_GROUP\
    \        = 37;\n   const FATTR4_QUOTA_AVAIL_HARD   = 38;\n   const FATTR4_QUOTA_AVAIL_SOFT\
    \   = 39;\n   const FATTR4_QUOTA_USED         = 40;\n   const FATTR4_RAWDEV  \
    \           = 41;\n   const FATTR4_SPACE_AVAIL        = 42;\n   const FATTR4_SPACE_FREE\
    \         = 43;\n   const FATTR4_SPACE_TOTAL        = 44;\n   const FATTR4_SPACE_USED\
    \         = 45;\n   const FATTR4_SYSTEM             = 46;\n   const FATTR4_TIME_ACCESS\
    \        = 47;\n   const FATTR4_TIME_ACCESS_SET    = 48;\n   const FATTR4_TIME_BACKUP\
    \        = 49;\n   const FATTR4_TIME_CREATE        = 50;\n   const FATTR4_TIME_DELTA\
    \         = 51;\n   const FATTR4_TIME_METADATA      = 52;\n   const FATTR4_TIME_MODIFY\
    \        = 53;\n   const FATTR4_TIME_MODIFY_SET    = 54;\n   const FATTR4_MOUNTED_ON_FILEID\
    \  = 55;\n   typedef opaque  attrlist4<>;\n   /*\n    * File attribute container\n\
    \    */\n   struct fattr4 {\n           bitmap4         attrmask;\n          \
    \ attrlist4       attr_vals;\n   };\n   /*\n    * Change info for the client\n\
    \    */\n   struct change_info4 {\n           bool            atomic;\n      \
    \     changeid4       before;\n           changeid4       after;\n   };\n   struct\
    \ clientaddr4 {\n           /* see struct rpcb in RFC 1833 */\n           string\
    \ r_netid<>;               /* network id */\n           string r_addr<>;     \
    \           /* universal address */\n   };\n   /*\n    * Callback program info\
    \ as provided by the client\n    */\n   struct cb_client4 {\n           uint32_t\
    \        cb_program;\n           clientaddr4     cb_location;\n   };\n   /*\n\
    \    * Stateid\n    */\n   struct stateid4 {\n           uint32_t        seqid;\n\
    \           opaque          other[12];\n   };\n   /*\n    * Client ID\n    */\n\
    \   struct nfs_client_id4 {\n           verifier4       verifier;\n          \
    \ opaque          id<NFS4_OPAQUE_LIMIT>;\n   };\n   struct open_owner4 {\n   \
    \        clientid4       clientid;\n           opaque          owner<NFS4_OPAQUE_LIMIT>;\n\
    \   };\n   struct lock_owner4 {\n           clientid4       clientid;\n      \
    \     opaque          owner<NFS4_OPAQUE_LIMIT>;\n   };\n   enum nfs_lock_type4\
    \ {\n           READ_LT         = 1,\n           WRITE_LT        = 2,\n      \
    \     READW_LT        = 3,    /* blocking read */\n           WRITEW_LT      \
    \ = 4     /* blocking write */\n   };\n   /*\n    * ACCESS: Check access permission\n\
    \    */\n   const ACCESS4_READ      = 0x00000001;\n   const ACCESS4_LOOKUP   \
    \ = 0x00000002;\n   const ACCESS4_MODIFY    = 0x00000004;\n   const ACCESS4_EXTEND\
    \    = 0x00000008;\n   const ACCESS4_DELETE    = 0x00000010;\n   const ACCESS4_EXECUTE\
    \   = 0x00000020;\n   struct ACCESS4args {\n           /* CURRENT_FH: object */\n\
    \           uint32_t        access;\n   };\n   struct ACCESS4resok {\n       \
    \    uint32_t        supported;\n           uint32_t        access;\n   };\n \
    \  union ACCESS4res switch (nfsstat4 status) {\n    case NFS4_OK:\n          \
    \  ACCESS4resok   resok4;\n    default:\n            void;\n   };\n   /*\n   \
    \ * CLOSE: Close a file and release share reservations\n    */\n   struct CLOSE4args\
    \ {\n           /* CURRENT_FH: object */\n           seqid4          seqid;\n\
    \           stateid4        open_stateid;\n   };\n   union CLOSE4res switch (nfsstat4\
    \ status) {\n    case NFS4_OK:\n            stateid4       open_stateid;\n   \
    \ default:\n            void;\n   };\n   /*\n    * COMMIT: Commit cached data\
    \ on server to stable storage\n    */\n   struct COMMIT4args {\n           /*\
    \ CURRENT_FH: file */\n           offset4         offset;\n           count4 \
    \         count;\n   };\n   struct COMMIT4resok {\n           verifier4      \
    \ writeverf;\n   };\n   union COMMIT4res switch (nfsstat4 status) {\n    case\
    \ NFS4_OK:\n            COMMIT4resok   resok4;\n    default:\n            void;\n\
    \   };\n   /*\n    * CREATE: Create a non-regular file\n    */\n   union createtype4\
    \ switch (nfs_ftype4 type) {\n    case NF4LNK:\n            linktext4      linkdata;\n\
    \    case NF4BLK:\n    case NF4CHR:\n            specdata4      devdata;\n   \
    \ case NF4SOCK:\n    case NF4FIFO:\n    case NF4DIR:\n            void;\n    default:\n\
    \            void;          /* server should return NFS4ERR_BADTYPE */\n   };\n\
    \   struct CREATE4args {\n           /* CURRENT_FH: directory for creation */\n\
    \           createtype4     objtype;\n           component4      objname;\n  \
    \         fattr4          createattrs;\n   };\n   struct CREATE4resok {\n    \
    \       change_info4    cinfo;\n           bitmap4         attrset;        /*\
    \ attributes set */\n   };\n   union CREATE4res switch (nfsstat4 status) {\n \
    \   case NFS4_OK:\n            CREATE4resok resok4;\n    default:\n          \
    \  void;\n   };\n   /*\n    * DELEGPURGE: Purge Delegations Awaiting Recovery\n\
    \    */\n   struct DELEGPURGE4args {\n           clientid4       clientid;\n \
    \  };\n   struct DELEGPURGE4res {\n           nfsstat4        status;\n   };\n\
    \   /*\n    * DELEGRETURN: Return a delegation\n    */\n   struct DELEGRETURN4args\
    \ {\n           /* CURRENT_FH: delegated file */\n           stateid4        deleg_stateid;\n\
    \   };\n   struct DELEGRETURN4res {\n           nfsstat4        status;\n   };\n\
    \   /*\n    * GETATTR: Get file attributes\n    */\n   struct GETATTR4args {\n\
    \           /* CURRENT_FH: directory or file */\n           bitmap4         attr_request;\n\
    \   };\n   struct GETATTR4resok {\n           fattr4          obj_attributes;\n\
    \   };\n   union GETATTR4res switch (nfsstat4 status) {\n    case NFS4_OK:\n \
    \           GETATTR4resok  resok4;\n    default:\n            void;\n   };\n \
    \  /*\n    * GETFH: Get current filehandle\n    */\n   struct GETFH4resok {\n\
    \           nfs_fh4         object;\n   };\n   union GETFH4res switch (nfsstat4\
    \ status) {\n    case NFS4_OK:\n           GETFH4resok     resok4;\n    default:\n\
    \           void;\n   };\n   /*\n    * LINK: Create link to an object\n    */\n\
    \   struct LINK4args {\n           /* SAVED_FH: source object */\n           /*\
    \ CURRENT_FH: target directory */\n           component4      newname;\n   };\n\
    \   struct LINK4resok {\n           change_info4    cinfo;\n   };\n   union LINK4res\
    \ switch (nfsstat4 status) {\n    case NFS4_OK:\n            LINK4resok resok4;\n\
    \    default:\n            void;\n   };\n   /*\n    * For LOCK, transition from\
    \ open_owner to new lock_owner\n    */\n   struct open_to_lock_owner4 {\n    \
    \       seqid4          open_seqid;\n           stateid4        open_stateid;\n\
    \           seqid4          lock_seqid;\n           lock_owner4     lock_owner;\n\
    \   };\n   /*\n    * For LOCK, existing lock_owner continues to request file locks\n\
    \    */\n   struct exist_lock_owner4 {\n           stateid4        lock_stateid;\n\
    \           seqid4          lock_seqid;\n   };\n   union locker4 switch (bool\
    \ new_lock_owner) {\n    case TRUE:\n           open_to_lock_owner4     open_owner;\n\
    \    case FALSE:\n           exist_lock_owner4       lock_owner;\n   };\n   /*\n\
    \    * LOCK/LOCKT/LOCKU: Record lock management\n    */\n   struct LOCK4args {\n\
    \           /* CURRENT_FH: file */\n           nfs_lock_type4  locktype;\n   \
    \        bool            reclaim;\n           offset4         offset;\n      \
    \     length4         length;\n           locker4         locker;\n   };\n   struct\
    \ LOCK4denied {\n           offset4         offset;\n           length4      \
    \   length;\n           nfs_lock_type4  locktype;\n           lock_owner4    \
    \ owner;\n   };\n   struct LOCK4resok {\n           stateid4        lock_stateid;\n\
    \   };\n   union LOCK4res switch (nfsstat4 status) {\n    case NFS4_OK:\n    \
    \        LOCK4resok     resok4;\n    case NFS4ERR_DENIED:\n            LOCK4denied\
    \    denied;\n    default:\n            void;\n   };\n   struct LOCKT4args {\n\
    \           /* CURRENT_FH: file */\n           nfs_lock_type4  locktype;\n   \
    \        offset4         offset;\n           length4         length;\n       \
    \    lock_owner4     owner;\n   };\n   union LOCKT4res switch (nfsstat4 status)\
    \ {\n    case NFS4ERR_DENIED:\n            LOCK4denied    denied;\n    case NFS4_OK:\n\
    \            void;\n    default:\n            void;\n   };\n   struct LOCKU4args\
    \ {\n           /* CURRENT_FH: file */\n           nfs_lock_type4  locktype;\n\
    \           seqid4          seqid;\n           stateid4        lock_stateid;\n\
    \           offset4         offset;\n           length4         length;\n   };\n\
    \   union LOCKU4res switch (nfsstat4 status) {\n    case   NFS4_OK:\n        \
    \    stateid4       lock_stateid;\n    default:\n            void;\n   };\n  \
    \ /*\n    * LOOKUP: Lookup filename\n    */\n   struct LOOKUP4args {\n       \
    \    /* CURRENT_FH: directory */\n           component4      objname;\n   };\n\
    \   struct LOOKUP4res {\n           /* CURRENT_FH: object */\n           nfsstat4\
    \        status;\n   };\n   /*\n    * LOOKUPP: Lookup parent directory\n    */\n\
    \   struct LOOKUPP4res {\n           /* CURRENT_FH: directory */\n           nfsstat4\
    \        status;\n   };\n   /*\n    * NVERIFY: Verify attributes different\n \
    \   */\n   struct NVERIFY4args {\n           /* CURRENT_FH: object */\n      \
    \     fattr4          obj_attributes;\n   };\n   struct NVERIFY4res {\n      \
    \     nfsstat4        status;\n   };\n   /*\n    * Various definitions for OPEN\n\
    \    */\n   enum createmode4 {\n           UNCHECKED4      = 0,\n           GUARDED4\
    \        = 1,\n           EXCLUSIVE4      = 2\n   };\n   union createhow4 switch\
    \ (createmode4 mode) {\n    case UNCHECKED4:\n    case GUARDED4:\n           \
    \ fattr4         createattrs;\n    case EXCLUSIVE4:\n            verifier4   \
    \   createverf;\n   };\n   enum opentype4 {\n           OPEN4_NOCREATE  = 0,\n\
    \           OPEN4_CREATE    = 1\n   };\n   union openflag4 switch (opentype4 opentype)\
    \ {\n    case OPEN4_CREATE:\n            createhow4     how;\n    default:\n \
    \           void;\n   };\n   /* Next definitions used for OPEN delegation */\n\
    \   enum limit_by4 {\n           NFS_LIMIT_SIZE          = 1,\n           NFS_LIMIT_BLOCKS\
    \        = 2\n           /* others as needed */\n   };\n   struct nfs_modified_limit4\
    \ {\n           uint32_t        num_blocks;\n           uint32_t        bytes_per_block;\n\
    \   };\n   union nfs_space_limit4 switch (limit_by4 limitby) {\n    /* limit specified\
    \ as file size */\n    case NFS_LIMIT_SIZE:\n            uint64_t            \
    \   filesize;\n    /* limit specified by number of blocks */\n    case NFS_LIMIT_BLOCKS:\n\
    \            nfs_modified_limit4    mod_blocks;\n   } ;\n   /*\n    * Share Access\
    \ and Deny constants for open argument\n    */\n   const OPEN4_SHARE_ACCESS_READ\
    \   = 0x00000001;\n   const OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;\n   const\
    \ OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;\n   const OPEN4_SHARE_DENY_NONE    \
    \ = 0x00000000;\n   const OPEN4_SHARE_DENY_READ     = 0x00000001;\n   const OPEN4_SHARE_DENY_WRITE\
    \    = 0x00000002;\n   const OPEN4_SHARE_DENY_BOTH     = 0x00000003;\n   enum\
    \ open_delegation_type4 {\n           OPEN_DELEGATE_NONE      = 0,\n         \
    \  OPEN_DELEGATE_READ      = 1,\n           OPEN_DELEGATE_WRITE     = 2\n   };\n\
    \   enum open_claim_type4 {\n           CLAIM_NULL              = 0,\n       \
    \    CLAIM_PREVIOUS          = 1,\n           CLAIM_DELEGATE_CUR      = 2,\n \
    \          CLAIM_DELEGATE_PREV     = 3\n   };\n   struct open_claim_delegate_cur4\
    \ {\n           stateid4        delegate_stateid;\n           component4     \
    \ file;\n   };\n   union open_claim4 switch (open_claim_type4 claim) {\n    /*\n\
    \     * No special rights to file. Ordinary OPEN of the specified file.\n    \
    \ */\n    case CLAIM_NULL:\n           /* CURRENT_FH: directory */\n         \
    \  component4      file;\n    /*\n     * Right to the file established by an open\
    \ previous to server\n     * reboot.  File identified by filehandle obtained at\
    \ that time\n     * rather than by name.\n     */\n    case CLAIM_PREVIOUS:\n\
    \           /* CURRENT_FH: file being reclaimed */\n           open_delegation_type4\
    \   delegate_type;\n    /*\n     * Right to file based on a delegation granted\
    \ by the server.\n     * File is specified by name.\n     */\n    case CLAIM_DELEGATE_CUR:\n\
    \           /* CURRENT_FH: directory */\n           open_claim_delegate_cur4 \
    \       delegate_cur_info;\n    /* Right to file based on a delegation granted\
    \ to a previous boot\n     * instance of the client.  File is specified by name.\n\
    \     */\n    case CLAIM_DELEGATE_PREV:\n            /* CURRENT_FH: directory\
    \ */\n           component4      file_delegate_prev;\n   };\n   /*\n    * OPEN:\
    \ Open a file, potentially receiving an open delegation\n    */\n   struct OPEN4args\
    \ {\n           seqid4          seqid;\n           uint32_t        share_access;\n\
    \           uint32_t        share_deny;\n           open_owner4     owner;\n \
    \          openflag4       openhow;\n           open_claim4     claim;\n   };\n\
    \   struct open_read_delegation4 {\n           stateid4        stateid;      \
    \  /* Stateid for delegation*/\n           bool            recall;         /*\
    \ Pre-recalled flag for\n                                              delegations\
    \ obtained\n                                              by reclaim\n       \
    \                                       (CLAIM_PREVIOUS) */\n           nfsace4\
    \         permissions;    /* Defines users who don't\n                       \
    \                       need an ACCESS call to\n                             \
    \                 open for read */\n   };\n   struct open_write_delegation4 {\n\
    \           stateid4        stateid;        /* Stateid for delegation */\n   \
    \        bool            recall;         /* Pre-recalled flag for\n          \
    \                                    delegations obtained\n                  \
    \                            by reclaim\n                                    \
    \          (CLAIM_PREVIOUS) */\n           nfs_space_limit4 space_limit;   /*\
    \ Defines condition that\n                                              the client\
    \ must check to\n                                              determine whether\
    \ the\n                                              file needs to be flushed\n\
    \                                              to the server on close.\n     \
    \                                         */\n           nfsace4         permissions;\
    \    /* Defines users who don't\n                                            \
    \  need an ACCESS call as\n                                              part\
    \ of a delegated\n                                              open. */\n   };\n\
    \   union open_delegation4\n   switch (open_delegation_type4 delegation_type)\
    \ {\n           case OPEN_DELEGATE_NONE:\n                   void;\n         \
    \  case OPEN_DELEGATE_READ:\n                   open_read_delegation4 read;\n\
    \           case OPEN_DELEGATE_WRITE:\n                   open_write_delegation4\
    \ write;\n   };\n   /*\n    * Result flags\n    */\n   /* Client must confirm\
    \ open */\n   const OPEN4_RESULT_CONFIRM      = 0x00000002;\n   /* Type of file\
    \ locking behavior at the server */\n   const OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004;\n\
    \   struct OPEN4resok {\n           stateid4        stateid;        /* Stateid\
    \ for open */\n           change_info4    cinfo;          /* Directory Change\
    \ Info */\n           uint32_t        rflags;         /* Result flags */\n   \
    \        bitmap4         attrset;        /* attribute set for create*/\n     \
    \      open_delegation4 delegation;    /* Info on any open\n                 \
    \                             delegation */\n   };\n   union OPEN4res switch (nfsstat4\
    \ status) {\n    case NFS4_OK:\n           /* CURRENT_FH: opened file */\n   \
    \        OPEN4resok      resok4;\n    default:\n           void;\n   };\n   /*\n\
    \    * OPENATTR: open named attributes directory\n    */\n   struct OPENATTR4args\
    \ {\n           /* CURRENT_FH: object */\n           bool    createdir;\n   };\n\
    \   struct OPENATTR4res {\n           /* CURRENT_FH: named attr directory */\n\
    \           nfsstat4        status;\n   };\n   /*\n    * OPEN_CONFIRM: confirm\
    \ the open\n    */\n   struct OPEN_CONFIRM4args {\n           /* CURRENT_FH: opened\
    \ file */\n           stateid4        open_stateid;\n           seqid4       \
    \   seqid;\n   };\n   struct OPEN_CONFIRM4resok {\n           stateid4       \
    \ open_stateid;\n   };\n   union OPEN_CONFIRM4res switch (nfsstat4 status) {\n\
    \       case NFS4_OK:\n               OPEN_CONFIRM4resok     resok4;\n    default:\n\
    \            void;\n   };\n   /*\n    * OPEN_DOWNGRADE: downgrade the access/deny\
    \ for a file\n    */\n   struct OPEN_DOWNGRADE4args {\n           /* CURRENT_FH:\
    \ opened file */\n           stateid4        open_stateid;\n           seqid4\
    \          seqid;\n           uint32_t        share_access;\n           uint32_t\
    \        share_deny;\n   };\n   struct OPEN_DOWNGRADE4resok {\n           stateid4\
    \        open_stateid;\n   };\n   union OPEN_DOWNGRADE4res switch(nfsstat4 status)\
    \ {\n    case NFS4_OK:\n           OPEN_DOWNGRADE4resok    resok4;\n    default:\n\
    \            void;\n   };\n   /*\n    * PUTFH: Set current filehandle\n    */\n\
    \   struct PUTFH4args {\n           nfs_fh4         object;\n   };\n   struct\
    \ PUTFH4res {\n           /* CURRENT_FH: */\n           nfsstat4        status;\n\
    \   };\n   /*\n    * PUTPUBFH: Set public filehandle\n    */\n   struct PUTPUBFH4res\
    \ {\n           /* CURRENT_FH: public fh */\n           nfsstat4        status;\n\
    \   };\n   /*\n    * PUTROOTFH: Set root filehandle\n    */\n   struct PUTROOTFH4res\
    \ {\n           /* CURRENT_FH: root fh */\n           nfsstat4        status;\n\
    \   };\n   /*\n    * READ: Read from file\n    */\n   struct READ4args {\n   \
    \        /* CURRENT_FH: file */\n           stateid4        stateid;\n       \
    \    offset4         offset;\n           count4          count;\n   };\n   struct\
    \ READ4resok {\n           bool            eof;\n           opaque          data<>;\n\
    \   };\n   union READ4res switch (nfsstat4 status) {\n    case NFS4_OK:\n    \
    \        READ4resok     resok4;\n    default:\n            void;\n   };\n   /*\n\
    \    * READDIR: Read directory\n    */\n   struct READDIR4args {\n           /*\
    \ CURRENT_FH: directory */\n           nfs_cookie4     cookie;\n           verifier4\
    \       cookieverf;\n           count4          dircount;\n           count4 \
    \         maxcount;\n           bitmap4         attr_request;\n   };\n   struct\
    \ entry4 {\n           nfs_cookie4     cookie;\n           component4      name;\n\
    \           fattr4          attrs;\n           entry4          *nextentry;\n \
    \  };\n   struct dirlist4 {\n           entry4          *entries;\n          \
    \ bool            eof;\n   };\n   struct READDIR4resok {\n           verifier4\
    \       cookieverf;\n           dirlist4        reply;\n   };\n   union READDIR4res\
    \ switch (nfsstat4 status) {\n    case NFS4_OK:\n            READDIR4resok  resok4;\n\
    \    default:\n            void;\n   };\n   /*\n    * READLINK: Read symbolic\
    \ link\n    */\n   struct READLINK4resok {\n           linktext4       link;\n\
    \   };\n   union READLINK4res switch (nfsstat4 status) {\n    case NFS4_OK:\n\
    \            READLINK4resok resok4;\n    default:\n            void;\n   };\n\
    \   /*\n    * REMOVE: Remove filesystem object\n    */\n   struct REMOVE4args\
    \ {\n           /* CURRENT_FH: directory */\n           component4      target;\n\
    \   };\n   struct REMOVE4resok {\n           change_info4    cinfo;\n   };\n \
    \  union REMOVE4res switch (nfsstat4 status) {\n    case NFS4_OK:\n          \
    \  REMOVE4resok   resok4;\n    default:\n            void;\n   };\n   /*\n   \
    \ * RENAME: Rename directory entry\n    */\n   struct RENAME4args {\n        \
    \   /* SAVED_FH: source directory */\n           component4      oldname;\n  \
    \         /* CURRENT_FH: target directory */\n           component4      newname;\n\
    \   };\n   struct RENAME4resok {\n           change_info4    source_cinfo;\n \
    \          change_info4    target_cinfo;\n   };\n   union RENAME4res switch (nfsstat4\
    \ status) {\n    case NFS4_OK:\n           RENAME4resok    resok4;\n    default:\n\
    \           void;\n   };\n   /*\n    * RENEW: Renew a Lease\n    */\n   struct\
    \ RENEW4args {\n           clientid4       clientid;\n   };\n   struct RENEW4res\
    \ {\n           nfsstat4        status;\n   };\n   /*\n    * RESTOREFH: Restore\
    \ saved filehandle\n    */\n   struct RESTOREFH4res {\n           /* CURRENT_FH:\
    \ value of saved fh */\n           nfsstat4        status;\n   };\n   /*\n   \
    \ * SAVEFH: Save current filehandle\n    */\n   struct SAVEFH4res {\n        \
    \   /* SAVED_FH: value of current fh */\n           nfsstat4        status;\n\
    \   };\n   /*\n    * SECINFO: Obtain Available Security Mechanisms\n    */\n \
    \  struct SECINFO4args {\n           /* CURRENT_FH: directory */\n           component4\
    \      name;\n   };\n   /*\n    * From RFC 2203\n    */\n   enum rpc_gss_svc_t\
    \ {\n           RPC_GSS_SVC_NONE        = 1,\n           RPC_GSS_SVC_INTEGRITY\
    \   = 2,\n           RPC_GSS_SVC_PRIVACY     = 3\n   };\n   struct rpcsec_gss_info\
    \ {\n           sec_oid4        oid;\n           qop4            qop;\n      \
    \     rpc_gss_svc_t   service;\n   };\n   /* RPCSEC_GSS has a value of '6' - See\
    \ RFC 2203 */\n   union secinfo4 switch (uint32_t flavor) {\n    case RPCSEC_GSS:\n\
    \            rpcsec_gss_info        flavor_info;\n    default:\n            void;\n\
    \   };\n   typedef secinfo4 SECINFO4resok<>;\n   union SECINFO4res switch (nfsstat4\
    \ status) {\n    case NFS4_OK:\n            SECINFO4resok resok4;\n    default:\n\
    \            void;\n   };\n   /*\n    * SETATTR: Set attributes\n    */\n   struct\
    \ SETATTR4args {\n           /* CURRENT_FH: target object */\n           stateid4\
    \        stateid;\n           fattr4          obj_attributes;\n   };\n   struct\
    \ SETATTR4res {\n           nfsstat4        status;\n           bitmap4      \
    \   attrsset;\n   };\n   /*\n    * SETCLIENTID\n    */\n   struct SETCLIENTID4args\
    \ {\n           nfs_client_id4  client;\n           cb_client4      callback;\n\
    \           uint32_t        callback_ident;\n   };\n   struct SETCLIENTID4resok\
    \ {\n           clientid4       clientid;\n           verifier4       setclientid_confirm;\n\
    \   };\n   union SETCLIENTID4res switch (nfsstat4 status) {\n    case NFS4_OK:\n\
    \            SETCLIENTID4resok      resok4;\n    case NFS4ERR_CLID_INUSE:\n  \
    \          clientaddr4    client_using;\n    default:\n            void;\n   };\n\
    \   struct SETCLIENTID_CONFIRM4args {\n           clientid4       clientid;\n\
    \           verifier4       setclientid_confirm;\n   };\n   struct SETCLIENTID_CONFIRM4res\
    \ {\n           nfsstat4        status;\n   };\n   /*\n    * VERIFY: Verify attributes\
    \ same\n    */\n   struct VERIFY4args {\n           /* CURRENT_FH: object */\n\
    \           fattr4          obj_attributes;\n   };\n   struct VERIFY4res {\n \
    \          nfsstat4        status;\n   };\n   /*\n    * WRITE: Write to file\n\
    \    */\n   enum stable_how4 {\n           UNSTABLE4       = 0,\n           DATA_SYNC4\
    \      = 1,\n           FILE_SYNC4      = 2\n   };\n   struct WRITE4args {\n \
    \          /* CURRENT_FH: file */\n           stateid4        stateid;\n     \
    \      offset4         offset;\n           stable_how4     stable;\n         \
    \  opaque          data<>;\n   };\n   struct WRITE4resok {\n           count4\
    \          count;\n           stable_how4     committed;\n           verifier4\
    \       writeverf;\n   };\n   union WRITE4res switch (nfsstat4 status) {\n   \
    \ case NFS4_OK:\n            WRITE4resok    resok4;\n    default:\n          \
    \  void;\n   };\n   /*\n    * RELEASE_LOCKOWNER: Notify server to release lockowner\n\
    \    */\n   struct RELEASE_LOCKOWNER4args {\n           lock_owner4     lock_owner;\n\
    \   };\n   struct RELEASE_LOCKOWNER4res {\n           nfsstat4        status;\n\
    \   };\n   /*\n    * ILLEGAL: Response for illegal operation numbers\n    */\n\
    \   struct ILLEGAL4res {\n           nfsstat4        status;\n   };\n   /*\n \
    \   * Operation arrays\n    */\n   enum nfs_opnum4 {\n           OP_ACCESS   \
    \            = 3,\n           OP_CLOSE                = 4,\n           OP_COMMIT\
    \               = 5,\n           OP_CREATE               = 6,\n           OP_DELEGPURGE\
    \           = 7,\n           OP_DELEGRETURN          = 8,\n           OP_GETATTR\
    \              = 9,\n           OP_GETFH                = 10,\n           OP_LINK\
    \                 = 11,\n           OP_LOCK                 = 12,\n          \
    \ OP_LOCKT                = 13,\n           OP_LOCKU                = 14,\n  \
    \         OP_LOOKUP               = 15,\n           OP_LOOKUPP              =\
    \ 16,\n           OP_NVERIFY              = 17,\n           OP_OPEN          \
    \       = 18,\n           OP_OPENATTR             = 19,\n           OP_OPEN_CONFIRM\
    \         = 20,\n           OP_OPEN_DOWNGRADE       = 21,\n           OP_PUTFH\
    \                = 22,\n           OP_PUTPUBFH             = 23,\n           OP_PUTROOTFH\
    \            = 24,\n           OP_READ                 = 25,\n           OP_READDIR\
    \              = 26,\n           OP_READLINK             = 27,\n           OP_REMOVE\
    \               = 28,\n           OP_RENAME               = 29,\n           OP_RENEW\
    \                = 30,\n           OP_RESTOREFH            = 31,\n           OP_SAVEFH\
    \               = 32,\n           OP_SECINFO              = 33,\n           OP_SETATTR\
    \              = 34,\n           OP_SETCLIENTID          = 35,\n           OP_SETCLIENTID_CONFIRM\
    \  = 36,\n           OP_VERIFY               = 37,\n           OP_WRITE      \
    \          = 38,\n           OP_RELEASE_LOCKOWNER    = 39,\n           OP_ILLEGAL\
    \              = 10044\n   };\n   union nfs_argop4 switch (nfs_opnum4 argop) {\n\
    \    case OP_ACCESS:        ACCESS4args opaccess;\n    case OP_CLOSE:        \
    \ CLOSE4args opclose;\n    case OP_COMMIT:        COMMIT4args opcommit;\n    case\
    \ OP_CREATE:        CREATE4args opcreate;\n    case OP_DELEGPURGE:    DELEGPURGE4args\
    \ opdelegpurge;\n    case OP_DELEGRETURN:   DELEGRETURN4args opdelegreturn;\n\
    \    case OP_GETATTR:       GETATTR4args opgetattr;\n    case OP_GETFH:      \
    \   void;\n    case OP_LINK:          LINK4args oplink;\n    case OP_LOCK:   \
    \       LOCK4args oplock;\n    case OP_LOCKT:         LOCKT4args oplockt;\n  \
    \  case OP_LOCKU:         LOCKU4args oplocku;\n    case OP_LOOKUP:        LOOKUP4args\
    \ oplookup;\n    case OP_LOOKUPP:       void;\n    case OP_NVERIFY:       NVERIFY4args\
    \ opnverify;\n    case OP_OPEN:          OPEN4args opopen;\n    case OP_OPENATTR:\
    \      OPENATTR4args opopenattr;\n    case OP_OPEN_CONFIRM:  OPEN_CONFIRM4args\
    \ opopen_confirm;\n    case OP_OPEN_DOWNGRADE:        OPEN_DOWNGRADE4args opopen_downgrade;\n\
    \    case OP_PUTFH:         PUTFH4args opputfh;\n    case OP_PUTPUBFH:      void;\n\
    \    case OP_PUTROOTFH:     void;\n    case OP_READ:          READ4args opread;\n\
    \    case OP_READDIR:       READDIR4args opreaddir;\n    case OP_READLINK:   \
    \   void;\n    case OP_REMOVE:        REMOVE4args opremove;\n    case OP_RENAME:\
    \        RENAME4args oprename;\n    case OP_RENEW:         RENEW4args oprenew;\n\
    \    case OP_RESTOREFH:     void;\n    case OP_SAVEFH:        void;\n    case\
    \ OP_SECINFO:       SECINFO4args opsecinfo;\n    case OP_SETATTR:       SETATTR4args\
    \ opsetattr;\n    case OP_SETCLIENTID:   SETCLIENTID4args opsetclientid;\n   \
    \ case OP_SETCLIENTID_CONFIRM:   SETCLIENTID_CONFIRM4args\n                  \
    \                         opsetclientid_confirm;\n    case OP_VERIFY:        VERIFY4args\
    \ opverify;\n    case OP_WRITE:         WRITE4args opwrite;\n    case OP_RELEASE_LOCKOWNER:\
    \     RELEASE_LOCKOWNER4args\n                                       oprelease_lockowner;\n\
    \    case OP_ILLEGAL:       void;\n   };\n   union nfs_resop4 switch (nfs_opnum4\
    \ resop){\n    case OP_ACCESS:        ACCESS4res opaccess;\n    case OP_CLOSE:\
    \         CLOSE4res opclose;\n    case OP_COMMIT:        COMMIT4res opcommit;\n\
    \    case OP_CREATE:        CREATE4res opcreate;\n    case OP_DELEGPURGE:    DELEGPURGE4res\
    \ opdelegpurge;\n    case OP_DELEGRETURN:   DELEGRETURN4res opdelegreturn;\n \
    \   case OP_GETATTR:       GETATTR4res opgetattr;\n    case OP_GETFH:        \
    \ GETFH4res opgetfh;\n    case OP_LINK:          LINK4res oplink;\n    case OP_LOCK:\
    \          LOCK4res oplock;\n    case OP_LOCKT:         LOCKT4res oplockt;\n \
    \   case OP_LOCKU:         LOCKU4res oplocku;\n    case OP_LOOKUP:        LOOKUP4res\
    \ oplookup;\n    case OP_LOOKUPP:       LOOKUPP4res oplookupp;\n    case OP_NVERIFY:\
    \       NVERIFY4res opnverify;\n    case OP_OPEN:          OPEN4res opopen;\n\
    \    case OP_OPENATTR:      OPENATTR4res opopenattr;\n    case OP_OPEN_CONFIRM:\
    \  OPEN_CONFIRM4res opopen_confirm;\n    case OP_OPEN_DOWNGRADE:        OPEN_DOWNGRADE4res\
    \ opopen_downgrade;\n    case OP_PUTFH:         PUTFH4res opputfh;\n    case OP_PUTPUBFH:\
    \      PUTPUBFH4res opputpubfh;\n    case OP_PUTROOTFH:     PUTROOTFH4res opputrootfh;\n\
    \    case OP_READ:          READ4res opread;\n    case OP_READDIR:       READDIR4res\
    \ opreaddir;\n    case OP_READLINK:      READLINK4res opreadlink;\n    case OP_REMOVE:\
    \        REMOVE4res opremove;\n    case OP_RENAME:        RENAME4res oprename;\n\
    \    case OP_RENEW:         RENEW4res oprenew;\n    case OP_RESTOREFH:     RESTOREFH4res\
    \ oprestorefh;\n    case OP_SAVEFH:        SAVEFH4res opsavefh;\n    case OP_SECINFO:\
    \       SECINFO4res opsecinfo;\n    case OP_SETATTR:       SETATTR4res opsetattr;\n\
    \    case OP_SETCLIENTID:   SETCLIENTID4res opsetclientid;\n    case OP_SETCLIENTID_CONFIRM:\
    \   SETCLIENTID_CONFIRM4res\n                                           opsetclientid_confirm;\n\
    \    case OP_VERIFY:        VERIFY4res opverify;\n    case OP_WRITE:         WRITE4res\
    \ opwrite;\n    case OP_RELEASE_LOCKOWNER:     RELEASE_LOCKOWNER4res\n       \
    \                                oprelease_lockowner;\n    case OP_ILLEGAL:  \
    \     ILLEGAL4res opillegal;\n   };\n   struct COMPOUND4args {\n           utf8str_cs\
    \      tag;\n           uint32_t        minorversion;\n           nfs_argop4 \
    \     argarray<>;\n   };\n   struct COMPOUND4res {\n           nfsstat4 status;\n\
    \           utf8str_cs      tag;\n           nfs_resop4      resarray<>;\n   };\n\
    \   /*\n    * Remote file service routines\n    */\n   program NFS4_PROGRAM {\n\
    \           version NFS_V4 {\n                   void\n                      \
    \     NFSPROC4_NULL(void) = 0;\n                   COMPOUND4res\n            \
    \               NFSPROC4_COMPOUND(COMPOUND4args) = 1;\n           } = 4;\n   }\
    \ = 100003;\n   /*\n    * NFS4 Callback Procedure Definitions and Program\n  \
    \  */\n   /*\n    * CB_GETATTR: Get Current Attributes\n    */\n   struct CB_GETATTR4args\
    \ {\n           nfs_fh4 fh;\n           bitmap4 attr_request;\n   };\n   struct\
    \ CB_GETATTR4resok {\n           fattr4  obj_attributes;\n   };\n   union CB_GETATTR4res\
    \ switch (nfsstat4 status) {\n    case NFS4_OK:\n            CB_GETATTR4resok\
    \       resok4;\n    default:\n            void;\n   };\n   /*\n    * CB_RECALL:\
    \ Recall an Open Delegation\n    */\n   struct CB_RECALL4args {\n           stateid4\
    \        stateid;\n           bool            truncate;\n           nfs_fh4  \
    \       fh;\n   };\n   struct CB_RECALL4res {\n           nfsstat4        status;\n\
    \   };\n   /*\n    * CB_ILLEGAL: Response for illegal operation numbers\n    */\n\
    \   struct CB_ILLEGAL4res {\n           nfsstat4        status;\n   };\n   /*\n\
    \    * Various definitions for CB_COMPOUND\n    */\n   enum nfs_cb_opnum4 {\n\
    \           OP_CB_GETATTR           = 3,\n           OP_CB_RECALL            =\
    \ 4,\n           OP_CB_ILLEGAL           = 10044\n   };\n   union nfs_cb_argop4\
    \ switch (unsigned argop) {\n    case OP_CB_GETATTR:    CB_GETATTR4args opcbgetattr;\n\
    \    case OP_CB_RECALL:     CB_RECALL4args  opcbrecall;\n    case OP_CB_ILLEGAL:\
    \    void;\n   };\n   union nfs_cb_resop4 switch (unsigned resop){\n    case OP_CB_GETATTR:\
    \    CB_GETATTR4res  opcbgetattr;\n    case OP_CB_RECALL:     CB_RECALL4res  \
    \ opcbrecall;\n    case OP_CB_ILLEGAL:    CB_ILLEGAL4res  opcbillegal;\n   };\n\
    \   struct CB_COMPOUND4args {\n           utf8str_cs      tag;\n           uint32_t\
    \        minorversion;\n           uint32_t        callback_ident;\n         \
    \  nfs_cb_argop4   argarray<>;\n   };\n   struct CB_COMPOUND4res {\n         \
    \  nfsstat4 status;\n           utf8str_cs      tag;\n           nfs_cb_resop4\
    \   resarray<>;\n   };\n   /*\n    * Program number is in the transient range\
    \ since the client\n    * will assign the exact transient program number and provide\n\
    \    * that to the server via the SETCLIENTID operation.\n    */\n   program NFS4_CALLBACK\
    \ {\n           version NFS_CB {\n                   void\n                  \
    \         CB_NULL(void) = 0;\n                   CB_COMPOUND4res\n           \
    \                CB_COMPOUND(CB_COMPOUND4args) = 1;\n           } = 1;\n   } =\
    \ 0x40000000;\n"
- title: 19.  Acknowledgements
  contents:
  - "19.  Acknowledgements\n   The authors thank and acknowledge:\n   Neil Brown for\
    \ his extensive review and comments of various\n   documents. Rick Macklem at\
    \ the University of Guelph, Mike Frisch,\n   Sergey Klyushin, and Dan Trufasiu\
    \ of Hummingbird Ltd., and Andy\n   Adamson, Bruce Fields, Jim Rees, and Kendrick\
    \ Smith from the CITI\n   organization at the University of Michigan, for their\
    \ implementation\n   efforts and feedback on the protocol specification. Mike\
    \ Kupfer for\n   his review of the file locking and ACL mechanisms.  Alan Yoder\
    \ for\n   his input to ACL mechanisms. Peter Astrand for his close review of\n\
    \   the protocol specification. Ran Atkinson for his constant reminder\n   that\
    \ users do matter.\n"
- title: 20.  Normative References
  contents:
  - "20.  Normative References\n   [ISO10646]                \"ISO/IEC 10646-1:1993.\
    \ International\n                             Standard -- Information technology\
    \ --\n                             Universal Multiple-Octet Coded Character\n\
    \                             Set (UCS) -- Part 1: Architecture and Basic\n  \
    \                           Multilingual Plane.\"\n   [RFC793]               \
    \   Postel, J., \"Transmission Control\n                             Protocol\"\
    , STD 7, RFC 793, September 1981.\n   [RFC1831]                 Srinivasan, R.,\
    \ \"RPC: Remote Procedure Call\n                             Protocol Specification\
    \ Version 2\", RFC\n                             1831, August 1995.\n   [RFC1832]\
    \                 Srinivasan, R., \"XDR: External Data\n                     \
    \        Representation Standard\", RFC 1832, August\n                       \
    \      1995.\n   [RFC2373]                 Hinden, R. and S. Deering, \"IP Version\
    \ 6\n                             Addressing Architecture\", RFC 2373, July\n\
    \                             1998.\n   [RFC1964]                 Linn, J., \"\
    The Kerberos Version 5 GSS-API\n                             Mechanism\", RFC\
    \ 1964, June 1996.\n   [RFC2025]                 Adams, C., \"The Simple Public-Key\
    \ GSS-API\n                             Mechanism (SPKM)\", RFC 2025, October\
    \ 1996.\n   [RFC2119]                 Bradner, S., \"Key words for use in RFCs\
    \ to\n                             Indicate Requirement Levels\", BCP 14, RFC\n\
    \                             2119, March 1997.\n   [RFC2203]                \
    \ Eisler, M., Chiu, A. and L. Ling,\n                             \"RPCSEC_GSS\
    \ Protocol Specification\", RFC\n                             2203, September\
    \ 1997.\n   [RFC2277]                 Alvestrand, H., \"IETF Policy on Character\n\
    \                             Sets and Languages\", BCP 19, RFC 2277,\n      \
    \                       January 1998.\n   [RFC2279]                 Yergeau, F.,\
    \ \"UTF-8, a transformation\n                             format of ISO 10646\"\
    , RFC 2279, January\n                             1998.\n   [RFC2623]        \
    \         Eisler, M., \"NFS Version 2 and Version 3\n                        \
    \     Security Issues and the NFS Protocol's Use\n                           \
    \  of RPCSEC_GSS and Kerberos V5\", RFC 2623,\n                             June\
    \ 1999.\n   [RFC2743]                 Linn, J., \"Generic Security Service\n \
    \                            Application Program Interface, Version 2,\n     \
    \                        Update 1\", RFC 2743, January 2000.\n   [RFC2847]   \
    \              Eisler, M., \"LIPKEY - A Low Infrastructure\n                 \
    \            Public Key Mechanism Using SPKM\", RFC 2847,\n                  \
    \           June 2000.\n   [RFC3010]                 Shepler, S., Callaghan, B.,\
    \ Robinson, D.,\n                             Thurlow, R., Beame, C., Eisler,\
    \ M. and D.\n                             Noveck, \"NFS version 4 Protocol\",\
    \ RFC 3010,\n                             December 2000.\n   [RFC3454]       \
    \          Hoffman, P. and P. Blanchet, \"Preparation\n                      \
    \       of Internationalized Strings\n                             (\"stringprep\"\
    )\", RFC 3454, December 2002.\n   [Unicode1]                The Unicode Consortium,\
    \ \"The Unicode\n                             Standard, Version 3.0\", Addison-Wesley\n\
    \                             Developers Press, Reading, MA, 2000. ISBN\n    \
    \                         0-201-61633-5.\n                             More information\
    \ available at:\n                             http://www.unicode.org/\n   [Unicode2]\
    \                \"Unsupported Scripts\" Unicode, Inc., The\n                \
    \             Unicode Consortium, P.O. Box 700519, San\n                     \
    \        Jose, CA 95710-0519 USA, September 1999.\n                          \
    \   http://www.unicode.org/unicode/standard/\n                             unsupported.html\n"
- title: 21.  Informative References
  contents:
  - "21.  Informative References\n   [Floyd]                   S. Floyd, V. Jacobson,\
    \ \"The Synchronization\n                             of Periodic Routing Messages,\"\
    \ IEEE/ACM\n                             Transactions on Networking, 2(2), pp.\
    \ 122-\n                             136, April 1994.\n   [Gray]             \
    \       C. Gray, D. Cheriton, \"Leases: An Efficient\n                       \
    \      Fault-Tolerant Mechanism for Distributed\n                            \
    \ File Cache Consistency,\" Proceedings of the\n                             Twelfth\
    \ Symposium on Operating Systems\n                             Principles, p.\
    \ 202-210, December 1989.\n   [Juszczak]                Juszczak, Chet, \"Improving\
    \ the Performance\n                             and Correctness of an NFS Server,\"\
    \ USENIX\n                             Conference Proceedings, USENIX Association,\n\
    \                             Berkeley, CA, June 1990, pages 53-63.\n        \
    \                     Describes reply cache implementation that\n            \
    \                 avoids work in the server by handling\n                    \
    \         duplicate requests. More important, though\n                       \
    \      listed as a side-effect, the reply cache\n                            \
    \ aids in the avoidance of destructive non-\n                             idempotent\
    \ operation re-application --\n                             improving correctness.\n\
    \   [Kazar]                   Kazar, Michael Leon, \"Synchronization and\n   \
    \                          Caching Issues in the Andrew File System,\"\n     \
    \                        USENIX Conference Proceedings, USENIX\n             \
    \                Association, Berkeley, CA, Dallas Winter\n                  \
    \           1988, pages 27-36.  A description of the\n                       \
    \      cache consistency scheme in AFS.\n                             Contrasted\
    \ with other distributed file\n                             systems.\n   [Macklem]\
    \                 Macklem, Rick, \"Lessons Learned Tuning the\n              \
    \               4.3BSD Reno Implementation of the NFS\n                      \
    \       Protocol,\" Winter USENIX Conference\n                             Proceedings,\
    \ USENIX Association, Berkeley,\n                             CA, January 1991.\
    \  Describes performance\n                             work in tuning the 4.3BSD\
    \ Reno NFS\n                             implementation. Describes performance\n\
    \                             improvement (reduced CPU loading) through\n    \
    \                         elimination of data copies.\n   [Mogul]            \
    \       Mogul, Jeffrey C., \"A Recovery Protocol for\n                       \
    \      Spritely NFS,\" USENIX File System Workshop\n                         \
    \    Proceedings, Ann Arbor, MI, USENIX\n                             Association,\
    \ Berkeley, CA, May 1992.\n                             Second paper on Spritely\
    \ NFS proposes a\n                             lease-based scheme for recovering\
    \ state of\n                             consistency protocol.\n   [Nowicki] \
    \                Nowicki, Bill, \"Transport Issues in the\n                  \
    \           Network File System,\" ACM SIGCOMM\n                             newsletter\
    \ Computer Communication Review,\n                             April 1989.  A\
    \ brief description of the\n                             basis for the dynamic\
    \ retransmission work.\n   [Pawlowski]               Pawlowski, Brian, Ron Hixon,\
    \ Mark Stein,\n                             Joseph Tumminaro, \"Network Computing\
    \ in the\n                             UNIX and IBM Mainframe Environment,\"\n\
    \                             Uniforum `89 Conf.  Proc., (1989)\n            \
    \                 Description of an NFS server implementation\n              \
    \               for IBM's MVS operating system.\n   [RFC1094]                \
    \ Sun Microsystems, Inc., \"NFS: Network File\n                             System\
    \ Protocol Specification\", RFC 1094,\n                             March 1989.\n\
    \   [RFC1345]                 Simonsen, K., \"Character Mnemonics &\n        \
    \                     Character Sets\", RFC 1345, June 1992.\n   [RFC1813]   \
    \              Callaghan, B., Pawlowski, B. and P.\n                         \
    \    Staubach, \"NFS Version 3 Protocol\n                             Specification\"\
    , RFC 1813, June 1995.\n   [RFC3232]                 Reynolds, J., Editor, \"\
    Assigned Numbers:\n                             RFC 1700 is Replaced by an On-line\n\
    \                             Database\", RFC 3232, January 2002.\n   [RFC1833]\
    \                 Srinivasan, R., \"Binding Protocols for ONC\n              \
    \               RPC Version 2\", RFC 1833, August 1995.\n   [RFC2054]        \
    \         Callaghan, B., \"WebNFS Client\n                             Specification\"\
    , RFC 2054, October 1996.\n   [RFC2055]                 Callaghan, B., \"WebNFS\
    \ Server\n                             Specification\", RFC 2055,  October 1996.\n\
    \   [RFC2152]                 Goldsmith, D. and M. Davis, \"UTF-7 A Mail-\n  \
    \                           Safe Transformation Format of Unicode\", RFC\n   \
    \                          2152, May 1997.\n   [RFC2224]                 Callaghan,\
    \ B., \"NFS URL Scheme\", RFC 2224,\n                             October 1997.\n\
    \   [RFC2624]                 Shepler, S., \"NFS Version 4 Design\n          \
    \                   Considerations\", RFC 2624, June 1999.\n   [RFC2755]     \
    \            Chiu, A., Eisler, M. and B. Callaghan,\n                        \
    \     \"Security Negotiation for WebNFS\" , RFC\n                            \
    \ 2755, June 2000.\n   [Sandberg]                Sandberg, R., D. Goldberg, S.\
    \ Kleiman, D.\n                             Walsh, B.  Lyon, \"Design and Implementation\n\
    \                             of the Sun Network Filesystem,\" USENIX\n      \
    \                       Conference Proceedings, USENIX Association,\n        \
    \                     Berkeley, CA, Summer 1985.  The basic paper\n          \
    \                   describing the SunOS implementation of the\n             \
    \                NFS version 2 protocol, and discusses the\n                 \
    \            goals, protocol specification and trade-\n                      \
    \       offs.\n   [Srinivasan]              Srinivasan, V., Jeffrey C. Mogul,\
    \ \"Spritely\n                             NFS: Implementation and Performance\
    \ of\n                             Cache Consistency Protocols\", WRL Research\n\
    \                             Report 89/5, Digital Equipment Corporation\n   \
    \                          Western Research Laboratory, 100 Hamilton\n       \
    \                      Ave., Palo Alto, CA, 94301, May 1989.  This\n         \
    \                    paper analyzes the effect of applying a\n               \
    \              Sprite-like consistency protocol applied to\n                 \
    \            standard NFS. The issues of recovery in a\n                     \
    \        stateful environment are covered in\n                             [Mogul].\n\
    \   [XNFS]                    The Open Group, Protocols for Interworking:\n  \
    \                           XNFS, Version 3W, The Open Group, 1010 El\n      \
    \                       Camino Real Suite 380, Menlo Park, CA\n              \
    \               94025, ISBN 1-85912-184-5, February 1998.\n                  \
    \           HTML version available:\n                             http://www.opengroup.org\n"
- title: 22.  Authors' Information
  contents:
  - '22.  Authors'' Information

    '
- title: 22.1.  Editor's Address
  contents:
  - "22.1.  Editor's Address\n   Spencer Shepler\n   Sun Microsystems, Inc.\n   7808\
    \ Moonflower Drive\n   Austin, Texas  78750\n   Phone: +1 512-349-9376\n   EMail:\
    \ spencer.shepler@sun.com\n"
- title: 22.2.  Authors' Addresses
  contents:
  - "22.2.  Authors' Addresses\n   Carl Beame\n   Hummingbird Ltd.\n   EMail: beame@bws.com\n\
    \   Brent Callaghan\n   Sun Microsystems, Inc.\n   17 Network Circle\n   Menlo\
    \ Park, CA  94025\n   Phone: +1 650-786-5067\n   EMail: brent.callaghan@sun.com\n\
    \   Mike Eisler\n   5765 Chase Point Circle\n   Colorado Springs, CO  80919\n\
    \   Phone: +1 719-599-9026\n   EMail: mike@eisler.com\n   David Noveck\n   Network\
    \ Appliance\n   375 Totten Pond Road\n   Waltham, MA  02451\n   Phone: +1 781-768-5347\n\
    \   EMail: dnoveck@netapp.com\n   David Robinson\n   Sun Microsystems, Inc.\n\
    \   5300 Riata Park Court\n   Austin, TX  78727\n   Phone: +1 650-786-5088\n \
    \  EMail: david.robinson@sun.com\n   Robert Thurlow\n   Sun Microsystems, Inc.\n\
    \   500 Eldorado Blvd.\n   Broomfield, CO  80021\n   Phone: +1 650-786-5096\n\
    \   EMail: robert.thurlow@sun.com\n"
- title: 23.  Full Copyright Statement
  contents:
  - "23.  Full Copyright Statement\n   Copyright (C) The Internet Society (2003).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
