- title: __initial_text__
  contents:
  - "                         Sockets API Extensions\n          for the Stream Control\
    \ Transmission Protocol (SCTP)\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a mapping of the Stream Control Transmission\n\
    \   Protocol (SCTP) into a sockets API.  The benefits of this mapping\n   include\
    \ compatibility for TCP applications, access to new SCTP\n   features, and a consolidated\
    \ error and event notification scheme.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6458.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................6\n\
    \   2. Data Types ......................................................8\n  \
    \ 3. One-to-Many Style Interface .....................................8\n    \
    \  3.1. Basic Operation ............................................8\n      \
    \     3.1.1. socket() ............................................9\n        \
    \   3.1.2. bind() .............................................10\n          \
    \ 3.1.3. listen() ...........................................11\n           3.1.4.\
    \ sendmsg() and recvmsg() ............................12\n           3.1.5. close()\
    \ ............................................14\n           3.1.6. connect()\
    \ ..........................................14\n      3.2. Non-Blocking Mode .........................................15\n\
    \      3.3. Special Considerations ....................................16\n  \
    \ 4. One-to-One Style Interface .....................................18\n    \
    \  4.1. Basic Operation ...........................................18\n      \
    \     4.1.1. socket() ...........................................19\n        \
    \   4.1.2. bind() .............................................19\n          \
    \ 4.1.3. listen() ...........................................21\n           4.1.4.\
    \ accept() ...........................................21\n           4.1.5. connect()\
    \ ..........................................22\n           4.1.6. close() ............................................23\n\
    \           4.1.7. shutdown() .........................................23\n  \
    \         4.1.8. sendmsg() and recvmsg() ............................24\n    \
    \       4.1.9. getpeername() ......................................24\n   5. Data\
    \ Structures ................................................25\n      5.1. The\
    \ msghdr and cmsghdr Structures .........................25\n      5.2. Ancillary\
    \ Data Considerations and Semantics ...............26\n           5.2.1. Multiple\
    \ Items and Ordering ........................27\n           5.2.2. Accessing and\
    \ Manipulating Ancillary Data ..........27\n           5.2.3. Control Message\
    \ Buffer Sizing ......................28\n      5.3. SCTP msg_control Structures\
    \ ...............................28\n           5.3.1. SCTP Initiation Structure\
    \ (SCTP_INIT) ..............29\n           5.3.2. SCTP Header Information Structure\n\
    \                  (SCTP_SNDRCV) - DEPRECATED .........................30\n  \
    \         5.3.3. Extended SCTP Header Information Structure\n                \
    \  (SCTP_EXTRCV) - DEPRECATED .........................33\n           5.3.4. SCTP\
    \ Send Information Structure (SCTP_SNDINFO) .....35\n           5.3.5. SCTP Receive\
    \ Information Structure (SCTP_RCVINFO) ..37\n           5.3.6. SCTP Next Receive\
    \ Information Structure\n                  (SCTP_NXTINFO) .....................................38\n\
    \           5.3.7. SCTP PR-SCTP Information Structure (SCTP_PRINFO) ...39\n  \
    \         5.3.8. SCTP AUTH Information Structure (SCTP_AUTHINFO) ....40\n    \
    \       5.3.9. SCTP Destination IPv4 Address Structure\n                  (SCTP_DSTADDRV4)\
    \ ...................................41\n           5.3.10. SCTP Destination IPv6\
    \ Address Structure\n                   (SCTP_DSTADDRV6) ..................................41\n\
    \   6. SCTP Events and Notifications ..................................41\n  \
    \    6.1. SCTP Notification Structure ...............................42\n    \
    \       6.1.1. SCTP_ASSOC_CHANGE ..................................43\n      \
    \     6.1.2. SCTP_PEER_ADDR_CHANGE ..............................45\n        \
    \   6.1.3. SCTP_REMOTE_ERROR ..................................46\n          \
    \ 6.1.4. SCTP_SEND_FAILED - DEPRECATED ......................47\n           6.1.5.\
    \ SCTP_SHUTDOWN_EVENT ................................48\n           6.1.6. SCTP_ADAPTATION_INDICATION\
    \ .........................49\n           6.1.7. SCTP_PARTIAL_DELIVERY_EVENT ........................49\n\
    \           6.1.8. SCTP_AUTHENTICATION_EVENT ..........................50\n  \
    \         6.1.9. SCTP_SENDER_DRY_EVENT ..............................51\n    \
    \       6.1.10. SCTP_NOTIFICATIONS_STOPPED_EVENT ..................52\n      \
    \     6.1.11. SCTP_SEND_FAILED_EVENT ............................52\n      6.2.\
    \ Notification Interest Options .............................54\n           6.2.1.\
    \ SCTP_EVENTS Option - DEPRECATED ....................54\n           6.2.2. SCTP_EVENT\
    \ Option ..................................56\n   7. Common Operations for Both\
    \ Styles ..............................57\n      7.1. send(), recv(), sendto(),\
    \ and recvfrom() ..................57\n      7.2. setsockopt() and getsockopt()\
    \ .............................59\n      7.3. read() and write() ........................................60\n\
    \      7.4. getsockname() .............................................60\n  \
    \    7.5. Implicit Association Setup ................................61\n   8.\
    \ Socket Options .................................................61\n      8.1.\
    \ Read/Write Options ........................................63\n           8.1.1.\
    \ Retransmission Timeout Parameters (SCTP_RTOINFO) ...63\n           8.1.2. Association\
    \ Parameters (SCTP_ASSOCINFO) ............64\n           8.1.3. Initialization\
    \ Parameters (SCTP_INITMSG) ...........66\n           8.1.4. SO_LINGER ..........................................66\n\
    \           8.1.5. SCTP_NODELAY .......................................66\n  \
    \         8.1.6. SO_RCVBUF ..........................................67\n    \
    \       8.1.7. SO_SNDBUF ..........................................67\n      \
    \     8.1.8. Automatic Close of Associations (SCTP_AUTOCLOSE) ...67\n        \
    \   8.1.9. Set Primary Address (SCTP_PRIMARY_ADDR) ............68\n          \
    \ 8.1.10. Set Adaptation Layer Indicator\n                   (SCTP_ADAPTATION_LAYER)\
    \ ...........................68\n           8.1.11. Enable/Disable Message Fragmentation\n\
    \                   (SCTP_DISABLE_FRAGMENTS) ..........................68\n  \
    \         8.1.12. Peer Address Parameters (SCTP_PEER_ADDR_PARAMS) ...69\n    \
    \       8.1.13. Set Default Send Parameters\n                   (SCTP_DEFAULT_SEND_PARAM)\
    \ - DEPRECATED ............71\n           8.1.14. Set Notification and Ancillary\
    \ Events\n                   (SCTP_EVENTS) - DEPRECATED ........................72\n\
    \           8.1.15. Set/Clear IPv4 Mapped Addresses\n                   (SCTP_I_WANT_MAPPED_V4_ADDR)\
    \ ......................72\n           8.1.16. Get or Set the Maximum Fragmentation\
    \ Size\n                   (SCTP_MAXSEG) .....................................72\n\
    \           8.1.17. Get or Set the List of Supported HMAC\n                  \
    \ Identifiers (SCTP_HMAC_IDENT) .....................73\n           8.1.18. Get\
    \ or Set the Active Shared Key\n                   (SCTP_AUTH_ACTIVE_KEY) ............................74\n\
    \           8.1.19. Get or Set Delayed SACK Timer\n                   (SCTP_DELAYED_SACK)\
    \ ...............................74\n           8.1.20. Get or Set Fragmented\
    \ Interleave\n                   (SCTP_FRAGMENT_INTERLEAVE) ........................75\n\
    \           8.1.21. Set or Get the SCTP Partial Delivery Point\n             \
    \      (SCTP_PARTIAL_DELIVERY_POINT) .....................77\n           8.1.22.\
    \ Set or Get the Use of Extended Receive Info\n                   (SCTP_USE_EXT_RCVINFO)\
    \ - DEPRECATED ...............77\n           8.1.23. Set or Get the Auto ASCONF\
    \ Flag\n                   (SCTP_AUTO_ASCONF) ................................77\n\
    \           8.1.24. Set or Get the Maximum Burst (SCTP_MAX_BURST) .....78\n  \
    \         8.1.25. Set or Get the Default Context (SCTP_CONTEXT) .....78\n    \
    \       8.1.26. Enable or Disable Explicit EOR Marking\n                   (SCTP_EXPLICIT_EOR)\
    \ ...............................79\n           8.1.27. Enable SCTP Port Reusage\
    \ (SCTP_REUSE_PORT) ........79\n           8.1.28. Set Notification Event (SCTP_EVENT)\
    \ ...............79\n           8.1.29. Enable or Disable the Delivery of SCTP_RCVINFO\n\
    \                   as Ancillary Data (SCTP_RECVRCVINFO) ..............79\n  \
    \         8.1.30. Enable or Disable the Delivery of SCTP_NXTINFO\n           \
    \        as Ancillary Data (SCTP_RECVNXTINFO) ..............80\n           8.1.31.\
    \ Set Default Send Parameters\n                   (SCTP_DEFAULT_SNDINFO) ............................80\n\
    \           8.1.32. Set Default PR-SCTP Parameters\n                   (SCTP_DEFAULT_PRINFO)\
    \ .............................80\n      8.2. Read-Only Options .........................................81\n\
    \           8.2.1. Association Status (SCTP_STATUS) ...................81\n  \
    \         8.2.2. Peer Address Information\n                  (SCTP_GET_PEER_ADDR_INFO)\
    \ ..........................82\n           8.2.3. Get the List of Chunks the Peer\
    \ Requires to\n                  Be Authenticated (SCTP_PEER_AUTH_CHUNKS) ...........84\n\
    \           8.2.4. Get the List of Chunks the Local Endpoint Requires\n      \
    \            to Be Authenticated (SCTP_LOCAL_AUTH_CHUNKS) .......84\n        \
    \   8.2.5. Get the Current Number of Associations\n                  (SCTP_GET_ASSOC_NUMBER)\
    \ ............................85\n           8.2.6. Get the Current Identifiers\
    \ of Associations\n                  (SCTP_GET_ASSOC_ID_LIST) ...........................85\n\
    \      8.3. Write-Only Options ........................................85\n  \
    \         8.3.1. Set Peer Primary Address\n                  (SCTP_SET_PEER_PRIMARY_ADDR)\
    \ .......................86\n           8.3.2. Add a Chunk That Must Be Authenticated\n\
    \                  (SCTP_AUTH_CHUNK) ..................................86\n  \
    \         8.3.3. Set a Shared Key (SCTP_AUTH_KEY) ...................86\n    \
    \       8.3.4. Deactivate a Shared Key\n                  (SCTP_AUTH_DEACTIVATE_KEY)\
    \ .........................87\n           8.3.5. Delete a Shared Key (SCTP_AUTH_DELETE_KEY)\
    \ .........88\n   9. New Functions ..................................................88\n\
    \      9.1. sctp_bindx() ..............................................88\n  \
    \    9.2. sctp_peeloff() ............................................90\n    \
    \  9.3. sctp_getpaddrs() ..........................................91\n      9.4.\
    \ sctp_freepaddrs() .........................................92\n      9.5. sctp_getladdrs()\
    \ ..........................................92\n      9.6. sctp_freeladdrs() .........................................93\n\
    \      9.7. sctp_sendmsg() - DEPRECATED ...............................93\n  \
    \    9.8. sctp_recvmsg() - DEPRECATED ...............................94\n    \
    \  9.9. sctp_connectx() ...........................................95\n      9.10.\
    \ sctp_send() - DEPRECATED .................................96\n      9.11. sctp_sendx()\
    \ - DEPRECATED ................................97\n      9.12. sctp_sendv() .............................................98\n\
    \      9.13. sctp_recvv() ............................................101\n  \
    \ 10. Security Considerations ......................................103\n   11.\
    \ Acknowledgments ..............................................103\n   12. References\
    \ ...................................................104\n      12.1. Normative\
    \ References ....................................104\n      12.2. Informative\
    \ References ..................................104\n   Appendix A. Example Using\
    \ One-to-One Style Sockets ...............106\n   Appendix B. Example Using One-to-Many\
    \ Style Sockets ..............109\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The sockets API has provided a standard mapping of the Internet\n\
    \   Protocol suite to many operating systems.  Both TCP [RFC0793] and UDP\n  \
    \ [RFC0768] have benefited from this standard representation and access\n   method\
    \ across many diverse platforms.  SCTP is a new protocol that\n   provides many\
    \ of the characteristics of TCP but also incorporates\n   semantics more akin\
    \ to UDP.  This document defines a method to map\n   the existing sockets API\
    \ for use with SCTP, providing both a base for\n   access to new features and\
    \ compatibility so that most existing TCP\n   applications can be migrated to\
    \ SCTP with few (if any) changes.\n   There are three basic design objectives:\n\
    \   1.  Maintain consistency with existing sockets APIs: We define a\n       sockets\
    \ mapping for SCTP that is consistent with other sockets\n       API protocol\
    \ mappings (for instance UDP, TCP, IPv4, and IPv6).\n   2.  Support a one-to-many\
    \ style interface: This set of semantics is\n       similar to that defined for\
    \ connectionless protocols, such as\n       UDP.  A one-to-many style SCTP socket\
    \ should be able to control\n       multiple SCTP associations.  This is similar\
    \ to a UDP socket,\n       which can communicate with many peer endpoints.  Each\
    \ of these\n       associations is assigned an association identifier so that\
    \ an\n       application can use the ID to differentiate them.  Note that SCTP\n\
    \       is connection-oriented in nature, and it does not support\n       broadcast\
    \ or multicast communications, as UDP does.\n   3.  Support a one-to-one style\
    \ interface: This interface supports a\n       similar semantics as sockets for\
    \ connection-oriented protocols,\n       such as TCP.  A one-to-one style SCTP\
    \ socket should only control\n       one SCTP association.  One purpose of defining\
    \ this interface is\n       to allow existing applications built on other connection-oriented\n\
    \       protocols to be ported to use SCTP with very little effort.\n       Developers\
    \ familiar with these semantics can easily adapt to\n       SCTP.  Another purpose\
    \ is to make sure that existing mechanisms\n       in most operating systems that\
    \ support sockets, such as select(),\n       should continue to work with this\
    \ style of socket.  Extensions\n       are added to this mapping to provide mechanisms\
    \ to exploit new\n       features of SCTP.\n   Goals 2 and 3 are not compatible,\
    \ so this document defines two modes\n   of mapping, namely the one-to-many style\
    \ mapping and the one-to-one\n   style mapping.  These two modes share some common\
    \ data structures and\n   operations, but will require the use of two different\
    \ application\n   programming styles.  Note that all new SCTP features can be\
    \ used with\n   both styles of socket.  The decision on which one to use depends\n\
    \   mainly on the nature of the applications.\n   A mechanism is defined to extract\
    \ an SCTP association from a one-to-\n   many style socket into a one-to-one style\
    \ socket.\n   Some of the SCTP mechanisms cannot be adequately mapped to an\n\
    \   existing socket interface.  In some cases, it is more desirable to\n   have\
    \ a new interface instead of using existing socket calls.\n   Section 9 of this\
    \ document describes these new interfaces.\n   Please note that some elements\
    \ of the SCTP sockets API are declared\n   as deprecated.  During the evolution\
    \ of this document, elements of\n   the API were introduced, implemented, and\
    \ later on replaced by other\n   elements.  These replaced elements are declared\
    \ as deprecated, since\n   they are still available in some implementations and\
    \ the replacement\n   functions are not.  This applies especially to older versions\
    \ of\n   operating systems supporting SCTP.  New SCTP socket implementations\n\
    \   must implement at least the non-deprecated elements.  Implementations\n  \
    \ intending interoperability with older versions of the API should also\n   include\
    \ the deprecated functions.\n"
- title: 2.  Data Types
  contents:
  - "2.  Data Types\n   Whenever possible, Portable Operating System Interface (POSIX)\
    \ data\n   types defined in [IEEE-1003.1-2008] are used: uintN_t means an\n  \
    \ unsigned integer of exactly N bits (e.g., uint16_t).  This document\n   also\
    \ assumes the argument data types from POSIX when possible (e.g.,\n   the final\
    \ argument to setsockopt() is a socklen_t value).  Whenever\n   buffer sizes are\
    \ specified, the POSIX size_t data type is used.\n"
- title: 3.  One-to-Many Style Interface
  contents:
  - "3.  One-to-Many Style Interface\n   In the one-to-many style interface, there\
    \ is a one-to-many\n   relationship between sockets and associations.\n"
- title: 3.1.  Basic Operation
  contents:
  - "3.1.  Basic Operation\n   A typical server in this style uses the following socket\
    \ calls in\n   sequence to prepare an endpoint for servicing requests:\n   o \
    \ socket()\n   o  bind()\n   o  listen()\n   o  recvmsg()\n   o  sendmsg()\n \
    \  o  close()\n   A typical client uses the following calls in sequence to set\
    \ up an\n   association with a server to request services:\n   o  socket()\n \
    \  o  sendmsg()\n   o  recvmsg()\n   o  close()\n   In this style, by default,\
    \ all of the associations connected to the\n   endpoint are represented with a\
    \ single socket.  Each association is\n   assigned an association identifier (the\
    \ type is sctp_assoc_t) so that\n   an application can use it to differentiate\
    \ among them.  In some\n   implementations, the peer endpoints' addresses can\
    \ also be used for\n   this purpose.  But this is not required for performance\
    \ reasons.  If\n   an implementation does not support using addresses to differentiate\n\
    \   between different associations, the sendto() call can only be used to\n  \
    \ set up an association implicitly.  It cannot be used to send data to\n   an\
    \ established association, as the association identifier cannot be\n   specified.\n\
    \   Once an association identifier is assigned to an SCTP association,\n   that\
    \ identifier will not be reused until the application explicitly\n   terminates\
    \ the use of the association.  The resources belonging to\n   that association\
    \ will not be freed until that happens.  This is\n   similar to the close() operation\
    \ on a normal socket.  The only\n   exception is when the SCTP_AUTOCLOSE option\
    \ (Section 8.1.8) is set.\n   In this case, after the association is terminated\
    \ gracefully and\n   automatically, the association identifier assigned to it\
    \ can be\n   reused.  All applications using this option should be aware of this\n\
    \   to avoid the possible problem of sending data to an incorrect peer\n   endpoint.\n\
    \   If the server or client wishes to branch an existing association off\n   to\
    \ a separate socket, it is required to call sctp_peeloff() and to\n   specify\
    \ the association identifier.  The sctp_peeloff() call will\n   return a new one-to-one\
    \ style socket that can then be used with\n   recv() and send() functions for\
    \ message passing.  See Section 9.2 for\n   more on branched-off associations.\n\
    \   Once an association is branched off to a separate socket, it becomes\n   completely\
    \ separated from the original socket.  All subsequent\n   control and data operations\
    \ to that association must be done through\n   the new socket.  For example, the\
    \ close() operation on the original\n   socket will not terminate any associations\
    \ that have been branched\n   off to a different socket.\n   One-to-many style\
    \ socket calls are discussed in more detail in the\n   following subsections.\n"
- title: 3.1.1.  socket()
  contents:
  - "3.1.1.  socket()\n   Applications use socket() to create a socket descriptor\
    \ to represent\n   an SCTP endpoint.\n   The function prototype is\n   int socket(int\
    \ domain,\n              int type,\n              int protocol);\n   and one uses\
    \ PF_INET or PF_INET6 as the domain, SOCK_SEQPACKET as the\n   type, and IPPROTO_SCTP\
    \ as the protocol.\n   Here, SOCK_SEQPACKET indicates the creation of a one-to-many\
    \ style\n   socket.\n   The function returns a socket descriptor, or -1 in case\
    \ of an error.\n   Using the PF_INET domain indicates the creation of an endpoint\
    \ that\n   can use only IPv4 addresses, while PF_INET6 creates an endpoint that\n\
    \   can use both IPv6 and IPv4 addresses.\n"
- title: 3.1.2.  bind()
  contents:
  - "3.1.2.  bind()\n   Applications use bind() to specify with which local address\
    \ and port\n   the SCTP endpoint should associate itself.\n   An SCTP endpoint\
    \ can be associated with multiple addresses.  To do\n   this, sctp_bindx() is\
    \ introduced in Section 9.1 to help applications\n   do the job of associating\
    \ multiple addresses.  But note that an\n   endpoint can only be associated with\
    \ one local port.\n   These addresses associated with a socket are the eligible\
    \ transport\n   addresses for the endpoint to send and receive data.  The endpoint\n\
    \   will also present these addresses to its peers during the association\n  \
    \ initialization process; see [RFC4960].\n   After calling bind(), if the endpoint\
    \ wishes to accept new\n   associations on the socket, it must call listen() (see\n\
    \   Section 3.1.3).\n   The function prototype of bind() is\n   int bind(int sd,\n\
    \            struct sockaddr *addr,\n            socklen_t addrlen);\n   and the\
    \ arguments are\n   sd:  The socket descriptor returned by socket().\n   addr:\
    \  The address structure (struct sockaddr_in for an IPv4 address\n      or struct\
    \ sockaddr_in6 for an IPv6 address; see [RFC3493]).\n   addrlen:  The size of\
    \ the address structure.\n   bind() returns 0 on success and -1 in case of an\
    \ error.\n   If sd is an IPv4 socket, the address passed must be an IPv4 address.\n\
    \   If the sd is an IPv6 socket, the address passed can either be an IPv4\n  \
    \ or an IPv6 address.\n   Applications cannot call bind() multiple times to associate\
    \ multiple\n   addresses to an endpoint.  After the first call to bind(), all\n\
    \   subsequent calls will return an error.\n   If the IP address part of addr\
    \ is specified as a wildcard (INADDR_ANY\n   for an IPv4 address, or as IN6ADDR_ANY_INIT\
    \ or in6addr_any for an\n   IPv6 address), the operating system will associate\
    \ the endpoint with\n   an optimal address set of the available interfaces.  If\
    \ the IPv4\n   sin_port or IPv6 sin6_port is set to 0, the operating system will\n\
    \   choose an ephemeral port for the endpoint.\n   If bind() is not called prior\
    \ to a sendmsg() call that initiates a\n   new association, the system picks an\
    \ ephemeral port and will choose\n   an address set equivalent to binding with\
    \ a wildcard address.  One of\n   those addresses will be the primary address\
    \ for the association.\n   This automatically enables the multi-homing capability\
    \ of SCTP.\n   The completion of this bind() process does not allow the SCTP\n\
    \   endpoint to accept inbound SCTP association requests.  Until a\n   listen()\
    \ system call, described below, is performed on the socket,\n   the SCTP endpoint\
    \ will promptly reject an inbound SCTP INIT request\n   with an SCTP ABORT.\n"
- title: 3.1.3.  listen()
  contents:
  - "3.1.3.  listen()\n   By default, a one-to-many style socket does not accept new\n\
    \   association requests.  An application uses listen() to mark a socket\n   as\
    \ being able to accept new associations.\n   The function prototype is\n   int\
    \ listen(int sd,\n              int backlog);\n   and the arguments are\n   sd:\
    \  The socket descriptor of the endpoint.\n   backlog:  If backlog is non-zero,\
    \ enable listening, else disable\n      listening.\n   listen() returns 0 on success\
    \ and -1 in case of an error.\n   Note that one-to-many style socket consumers\
    \ do not need to call\n   accept() to retrieve new associations.  Calling accept()\
    \ on a one-to-\n   many style socket should return EOPNOTSUPP.  Rather, new associations\n\
    \   are accepted automatically, and notifications of the new associations\n  \
    \ are delivered via recvmsg() with the SCTP_ASSOC_CHANGE event (if\n   these notifications\
    \ are enabled).  Clients will typically not call\n   listen(), so that they can\
    \ be assured that only actively initiated\n   associations are possible on the\
    \ socket.  Server or peer-to-peer\n   sockets, on the other hand, will always\
    \ accept new associations, so a\n   well-written application using server one-to-many\
    \ style sockets must\n   be prepared to handle new associations from unwanted\
    \ peers.\n   Also note that the SCTP_ASSOC_CHANGE event provides the association\n\
    \   identifier for a new association, so if applications wish to use the\n   association\
    \ identifier as a parameter to other socket calls, they\n   should ensure that\
    \ the SCTP_ASSOC_CHANGE event is enabled.\n"
- title: 3.1.4.  sendmsg() and recvmsg()
  contents:
  - "3.1.4.  sendmsg() and recvmsg()\n   An application uses the sendmsg() and recvmsg()\
    \ calls to transmit\n   data to and receive data from its peer.\n   The function\
    \ prototypes are\n   ssize_t sendmsg(int sd,\n                   const struct\
    \ msghdr *message,\n                   int flags);\n   and\n   ssize_t recvmsg(int\
    \ sd,\n                   struct msghdr *message,\n                   int flags);\n\
    \   using the following arguments:\n   sd:  The socket descriptor of the endpoint.\n\
    \   message:  Pointer to the msghdr structure that contains a single user\n  \
    \    message and possibly some ancillary data.  See Section 5 for a\n      complete\
    \ description of the data structures.\n   flags:  No new flags are defined for\
    \ SCTP at this level.  See\n      Section 5 for SCTP-specific flags used in the\
    \ msghdr structure.\n   sendmsg() returns the number of bytes accepted by the\
    \ kernel or -1 in\n   case of an error.  recvmsg() returns the number of bytes\
    \ received or\n   -1 in case of an error.\n   As described in Section 5, different\
    \ types of ancillary data can be\n   sent and received along with user data. \
    \ When sending, the ancillary\n   data is used to specify the sent behavior, such\
    \ as the SCTP stream\n   number to use.  When receiving, the ancillary data is\
    \ used to\n   describe the received data, such as the SCTP stream sequence number\n\
    \   of the message.\n   When sending user data with sendmsg(), the msg_name field\
    \ in the\n   msghdr structure will be filled with one of the transport addresses\n\
    \   of the intended receiver.  If there is no existing association\n   between\
    \ the sender and the intended receiver, the sender's SCTP stack\n   will set up\
    \ a new association and then send the user data (see\n   Section 7.5 for more\
    \ on implicit association setup).  If sendmsg() is\n   called with no data and\
    \ there is no existing association, a new one\n   will be established.  The SCTP_INIT\
    \ type ancillary data can be used\n   to change some of the parameters used to\
    \ set up a new association.\n   If sendmsg() is called with NULL data, and there\
    \ is no existing\n   association but the SCTP_ABORT or SCTP_EOF flags are set\
    \ as described\n   in Section 5.3.4, then -1 is returned and errno is set to EINVAL.\n\
    \   Sending a message using sendmsg() is atomic unless explicit end of\n   record\
    \ (EOR) marking is enabled on the socket specified by sd (see\n   Section 8.1.26).\n\
    \   If a peer sends a SHUTDOWN, an SCTP_SHUTDOWN_EVENT notification will\n   be\
    \ delivered if that notification has been enabled, and no more data\n   can be\
    \ sent to that association.  Any attempt to send more data will\n   cause sendmsg()\
    \ to return with an ESHUTDOWN error.  Note that the\n   socket is still open for\
    \ reading at this point, so it is possible to\n   retrieve notifications.\n  \
    \ When receiving a user message with recvmsg(), the msg_name field in\n   the\
    \ msghdr structure will be populated with the source transport\n   address of\
    \ the user data.  The caller of recvmsg() can use this\n   address information\
    \ to determine to which association the received\n   user message belongs.  Note\
    \ that if SCTP_ASSOC_CHANGE events are\n   disabled, applications must use the\
    \ peer transport address provided\n   in the msg_name field by recvmsg() to perform\
    \ correlation to an\n   association, since they will not have the association\
    \ identifier.\n   If all data in a single message has been delivered, MSG_EOR\
    \ will be\n   set in the msg_flags field of the msghdr structure (see Section\
    \ 5.1).\n   If the application does not provide enough buffer space to completely\n\
    \   receive a data message, MSG_EOR will not be set in msg_flags.\n   Successive\
    \ reads will consume more of the same message until the\n   entire message has\
    \ been delivered, and MSG_EOR will be set.\n   If the SCTP stack is running low\
    \ on buffers, it may partially deliver\n   a message.  In this case, MSG_EOR will\
    \ not be set, and more calls to\n   recvmsg() will be necessary to completely\
    \ consume the message.  Only\n   one message at a time can be partially delivered\
    \ in any stream.  The\n   socket option SCTP_FRAGMENT_INTERLEAVE controls various\
    \ aspects of\n   what interlacing of messages occurs for both the one-to-one and\
    \ the\n   one-to-many style sockets.  Please consult Section 8.1.20 for further\n\
    \   details on message delivery options.\n"
- title: 3.1.5.  close()
  contents:
  - "3.1.5.  close()\n   Applications use close() to perform graceful shutdown (as\
    \ described\n   in Section 10.1 of [RFC4960]) on all of the associations currently\n\
    \   represented by a one-to-many style socket.\n   The function prototype is\n\
    \   int close(int sd);\n   and the argument is\n   sd:  The socket descriptor\
    \ of the associations to be closed.\n   0 is returned on success and -1 in case\
    \ of an error.\n   To gracefully shut down a specific association represented\
    \ by the\n   one-to-many style socket, an application should use the sendmsg()\n\
    \   call and include the SCTP_EOF flag.  A user may optionally terminate\n   an\
    \ association non-gracefully by using sendmsg() with the SCTP_ABORT\n   flag set\
    \ and possibly passing a user-specified abort code in the data\n   field.  Both\
    \ flags SCTP_EOF and SCTP_ABORT are passed with ancillary\n   data (see Section\
    \ 5.3.4) in the sendmsg() call.\n   If sd in the close() call is a branched-off\
    \ socket representing only\n   one association, the shutdown is performed on that\
    \ association only.\n"
- title: 3.1.6.  connect()
  contents:
  - "3.1.6.  connect()\n   An application may use the connect() call in the one-to-many\
    \ style to\n   initiate an association without sending data.\n   The function\
    \ prototype is\n   int connect(int sd,\n               const struct sockaddr *nam,\n\
    \               socklen_t len);\n   and the arguments are\n   sd:  The socket\
    \ descriptor to which a new association is added.\n   nam:  The address structure\
    \ (struct sockaddr_in for an IPv4 address\n      or struct sockaddr_in6 for an\
    \ IPv6 address; see [RFC3493]).\n   len:  The size of the address.\n   0 is returned\
    \ on success and -1 in case of an error.\n   Multiple connect() calls can be made\
    \ on the same socket to create\n   multiple associations.  This is different from\
    \ the semantics of\n   connect() on a UDP socket.\n   Note that SCTP allows data\
    \ exchange, similar to T/TCP [RFC1644] (made\n   Historic by [RFC6247]), during\
    \ the association setup phase.  If an\n   application wants to do this, it cannot\
    \ use the connect() call.\n   Instead, it should use sendto() or sendmsg() to\
    \ initiate an\n   association.  If it uses sendto() and it wants to change the\n\
    \   initialization behavior, it needs to use the SCTP_INITMSG socket\n   option\
    \ before calling sendto().  Or it can use sendmsg() with\n   SCTP_INIT type ancillary\
    \ data to initiate an association without\n   calling setsockopt().  Note that\
    \ the implicit setup is supported for\n   the one-to-many style sockets.\n   SCTP\
    \ does not support half close semantics.  This means that unlike\n   T/TCP, MSG_EOF\
    \ should not be set in the flags parameter when calling\n   sendto() or sendmsg()\
    \ when the call is used to initiate a connection.\n   MSG_EOF is not an acceptable\
    \ flag with an SCTP socket.\n"
- title: 3.2.  Non-Blocking Mode
  contents:
  - "3.2.  Non-Blocking Mode\n   Some SCTP applications may wish to avoid being blocked\
    \ when calling a\n   socket interface function.\n   Once a bind() call and/or\
    \ subsequent sctp_bindx() calls are complete\n   on a one-to-many style socket,\
    \ an application may set the\n   non-blocking option via a fcntl() (such as O_NONBLOCK).\
    \  After\n   setting the socket to non-blocking mode, the sendmsg() function\n\
    \   returns immediately.  The success or failure of sending the data\n   message\
    \ (with possible SCTP_INITMSG ancillary data) will be signaled\n   by the SCTP_ASSOC_CHANGE\
    \ event with SCTP_COMM_UP or\n   SCTP_CANT_START_ASSOC.  If user data could not\
    \ be sent (due to an\n   SCTP_CANT_START_ASSOC), the sender will also receive\
    \ an\n   SCTP_SEND_FAILED_EVENT event.  Events can be received by the user\n \
    \  calling recvmsg().  A server (having called listen()) is also\n   notified\
    \ of an association-up event via the reception of an\n   SCTP_ASSOC_CHANGE with\
    \ SCTP_COMM_UP via the calling of recvmsg() and\n   possibly the reception of\
    \ the first data message.\n   To shut down the association gracefully, the user\
    \ must call sendmsg()\n   with no data and with the SCTP_EOF flag set as described\
    \ in\n   Section 5.3.4.  The function returns immediately, and completion of\n\
    \   the graceful shutdown is indicated by an SCTP_ASSOC_CHANGE\n   notification\
    \ of type SCTP_SHUTDOWN_COMP (see Section 6.1.1).  Note\n   that this can also\
    \ be done using the sctp_sendv() call described in\n   Section 9.12.\n   It is\
    \ recommended that an application use caution when using select()\n   (or poll())\
    \ for writing on a one-to-many style socket, because the\n   interpretation of\
    \ select() on write is implementation specific.\n   Generally, a positive return\
    \ on a select() on write would only\n   indicate that one of the associations\
    \ represented by the one-to-many\n   style socket is writable.  An application\
    \ that writes after the\n   select() returns may still block, since the association\
    \ that was\n   writable is not the destination association of the write call.\n\
    \   Likewise, select() (or poll()) for reading from a one-to-many style\n   socket\
    \ will only return an indication that one of the associations\n   represented\
    \ by the socket has data to be read.\n   An application that wishes to know that\
    \ a particular association is\n   ready for reading or writing should either use\
    \ the one-to-one style\n   or use the sctp_peeloff() function (see Section 9.2)\
    \ to separate the\n   association of interest from the one-to-many style socket.\n\
    \   Note that some implementations may have an extended select call, such\n  \
    \ as epoll or kqueue, that may escape this limitation and allow a\n   select on\
    \ a specific association of a one-to-many style socket, but\n   this is an implementation-specific\
    \ detail that a portable application\n   cannot depend on.\n"
- title: 3.3.  Special Considerations
  contents:
  - "3.3.  Special Considerations\n   The fact that a one-to-many style socket can\
    \ provide access to many\n   SCTP associations through a single socket descriptor\
    \ has important\n   implications for both application programmers and system programmers\n\
    \   implementing this API.  A key issue is how buffer space inside the\n   sockets\
    \ layer is managed.  Because this implementation detail\n   directly affects how\
    \ application programmers must write their code to\n   ensure correct operation\
    \ and portability, this section provides some\n   guidance to both implementers\
    \ and application programmers.\n   An important feature that SCTP shares with\
    \ TCP is flow control.\n   Specifically, a sender may not send data faster than\
    \ the receiver can\n   consume it.\n   For TCP, flow control is typically provided\
    \ for in the sockets API as\n   follows.  If the reader stops reading, the sender\
    \ queues messages in\n   the socket layer until the send socket buffer is completely\
    \ filled.\n   This results in a \"stalled connection\".  Further attempts to write\
    \ to\n   the socket will block or return the error EAGAIN or EWOULDBLOCK for a\n\
    \   non-blocking socket.  At some point, either the connection is closed,\n  \
    \ or the receiver begins to read, again freeing space in the output\n   queue.\n\
    \   For one-to-one style SCTP sockets (this includes sockets descriptors\n   that\
    \ were separated from a one-to-many style socket with\n   sctp_peeloff()), the\
    \ behavior is identical.  For one-to-many style\n   SCTP sockets, there are multiple\
    \ associations for a single socket,\n   which makes the situation more complicated.\
    \  If the implementation\n   uses a single buffer space allocation shared by all\
    \ associations, a\n   single stalled association can prevent the further sending\
    \ of data on\n   all associations active on a particular one-to-many style socket.\n\
    \   For a blocking socket, it should be clear that a single stalled\n   association\
    \ can block the entire socket.  For this reason,\n   application programmers may\
    \ want to use non-blocking one-to-many\n   style sockets.  The application should\
    \ at least be able to send\n   messages to the non-stalled associations.\n   But\
    \ a non-blocking socket is not sufficient if the API implementer\n   has chosen\
    \ a single shared buffer allocation for the socket.  A\n   single stalled association\
    \ would eventually cause the shared\n   allocation to fill, and it would become\
    \ impossible to send even to\n   non-stalled associations.\n   The API implementer\
    \ can solve this problem by providing each\n   association with its own allocation\
    \ of outbound buffer space.  Each\n   association should conceptually have as\
    \ much buffer space as it would\n   have if it had its own socket.  As a bonus,\
    \ this simplifies the\n   implementation of sctp_peeloff().\n   To ensure that\
    \ a given stalled association will not prevent other\n   non-stalled associations\
    \ from being writable, application programmers\n   should either\n   o  demand\
    \ that the underlying implementation dedicates independent\n      buffer space\
    \ reservation to each association (as suggested\n      above), or\n   o  verify\
    \ that their application-layer protocol does not permit large\n      amounts of\
    \ unread data at the receiver (this is true of some\n      request-response protocols,\
    \ for example), or\n   o  use one-to-one style sockets for association, which\
    \ may\n      potentially stall (either from the beginning, or by using\n     \
    \ sctp_peeloff() before sending large amounts of data that may cause\n      a\
    \ stalled condition).\n"
- title: 4.  One-to-One Style Interface
  contents:
  - "4.  One-to-One Style Interface\n   The goal of this style is to follow as closely\
    \ as possible the\n   current practice of using the sockets interface for a connection-\n\
    \   oriented protocol such as TCP.  This style enables existing\n   applications\
    \ using connection-oriented protocols to be ported to SCTP\n   with very little\
    \ effort.\n   One-to-one style sockets can be connected (explicitly or implicitly)\n\
    \   at most once, similar to TCP sockets.\n   Note that some new SCTP features\
    \ and some new SCTP socket options can\n   only be utilized through the use of\
    \ sendmsg() and recvmsg() calls;\n   see Section 4.1.8.\n"
- title: 4.1.  Basic Operation
  contents:
  - "4.1.  Basic Operation\n   A typical one-to-one style server uses the following\
    \ system call\n   sequence to prepare an SCTP endpoint for servicing requests:\n\
    \   o  socket()\n   o  bind()\n   o  listen()\n   o  accept()\n   The accept()\
    \ call blocks until a new association is set up.  It\n   returns with a new socket\
    \ descriptor.  The server then uses the new\n   socket descriptor to communicate\
    \ with the client, using recv() and\n   send() calls to get requests and send\
    \ back responses.\n   Then it calls\n   o  close()\n   to terminate the association.\n\
    \   A typical client uses the following system call sequence to set up an\n  \
    \ association with a server to request services:\n   o  socket()\n   o  connect()\n\
    \   After returning from the connect() call, the client uses send()/\n   sendmsg()\
    \ and recv()/recvmsg() calls to send out requests and receive\n   responses from\
    \ the server.\n   The client calls\n   o  close()\n   to terminate this association\
    \ when done.\n"
- title: 4.1.1.  socket()
  contents:
  - "4.1.1.  socket()\n   Applications call socket() to create a socket descriptor\
    \ to represent\n   an SCTP endpoint.\n   The function prototype is\n   int socket(int\
    \ domain,\n              int type,\n              int protocol);\n   and one uses\
    \ PF_INET or PF_INET6 as the domain, SOCK_STREAM as the\n   type, and IPPROTO_SCTP\
    \ as the protocol.\n   Here, SOCK_STREAM indicates the creation of a one-to-one\
    \ style\n   socket.\n   Using the PF_INET domain indicates the creation of an\
    \ endpoint that\n   can use only IPv4 addresses, while PF_INET6 creates an endpoint\
    \ that\n   can use both IPv6 and IPv4 addresses.\n"
- title: 4.1.2.  bind()
  contents:
  - "4.1.2.  bind()\n   Applications use bind() to specify with which local address\
    \ and port\n   the SCTP endpoint should associate itself.\n   An SCTP endpoint\
    \ can be associated with multiple addresses.  To do\n   this, sctp_bindx() is\
    \ introduced in Section 9.1 to help applications\n   do the job of associating\
    \ multiple addresses.  But note that an\n   endpoint can only be associated with\
    \ one local port.\n   These addresses associated with a socket are the eligible\
    \ transport\n   addresses for the endpoint to send and receive data.  The endpoint\n\
    \   will also present these addresses to its peers during the association\n  \
    \ initialization process; see [RFC4960].\n   The function prototype of bind()\
    \ is\n   int bind(int sd,\n            struct sockaddr *addr,\n            socklen_t\
    \ addrlen);\n   and the arguments are\n   sd:  The socket descriptor returned\
    \ by socket().\n   addr:  The address structure (struct sockaddr_in for an IPv4\
    \ address\n      or struct sockaddr_in6 for an IPv6 address; see [RFC3493]).\n\
    \   addrlen:  The size of the address structure.\n   If sd is an IPv4 socket,\
    \ the address passed must be an IPv4 address.\n   If sd is an IPv6 socket, the\
    \ address passed can either be an IPv4 or\n   an IPv6 address.\n   Applications\
    \ cannot call bind() multiple times to associate multiple\n   addresses to the\
    \ endpoint.  After the first call to bind(), all\n   subsequent calls will return\
    \ an error.\n   If the IP address part of addr is specified as a wildcard (INADDR_ANY\n\
    \   for an IPv4 address, or as IN6ADDR_ANY_INIT or in6addr_any for an\n   IPv6\
    \ address), the operating system will associate the endpoint with\n   an optimal\
    \ address set of the available interfaces.  If the IPv4\n   sin_port or IPv6 sin6_port\
    \ is set to 0, the operating system will\n   choose an ephemeral port for the\
    \ endpoint.\n   If bind() is not called prior to the connect() call, the system\
    \ picks\n   an ephemeral port and will choose an address set equivalent to\n \
    \  binding with a wildcard address.  One of these addresses will be the\n   primary\
    \ address for the association.  This automatically enables the\n   multi-homing\
    \ capability of SCTP.\n   The completion of this bind() process does not allow\
    \ the SCTP\n   endpoint to accept inbound SCTP association requests.  Until a\n\
    \   listen() system call, described below, is performed on the socket,\n   the\
    \ SCTP endpoint will promptly reject an inbound SCTP INIT request\n   with an\
    \ SCTP ABORT.\n"
- title: 4.1.3.  listen()
  contents:
  - "4.1.3.  listen()\n   Applications use listen() to allow the SCTP endpoint to\
    \ accept\n   inbound associations.\n   The function prototype is\n   int listen(int\
    \ sd,\n              int backlog);\n   and the arguments are\n   sd:  The socket\
    \ descriptor of the SCTP endpoint.\n   backlog:  Specifies the max number of outstanding\
    \ associations\n      allowed in the socket's accept queue.  These are the associations\n\
    \      that have finished the four-way initiation handshake (see\n      Section\
    \ 5 of [RFC4960]) and are in the ESTABLISHED state.  Note\n      that a backlog\
    \ of '0' indicates that the caller no longer wishes\n      to receive new associations.\n\
    \   listen() returns 0 on success and -1 in case of an error.\n"
- title: 4.1.4.  accept()
  contents:
  - "4.1.4.  accept()\n   Applications use the accept() call to remove an established\
    \ SCTP\n   association from the accept queue of the endpoint.  A new socket\n\
    \   descriptor will be returned from accept() to represent the newly\n   formed\
    \ association.\n   The function prototype is\n   int accept(int sd,\n        \
    \      struct sockaddr *addr,\n              socklen_t *addrlen);\n   and the\
    \ arguments are\n   sd:  The listening socket descriptor.\n   addr:  On return,\
    \ addr (struct sockaddr_in for an IPv4 address or\n      struct sockaddr_in6 for\
    \ an IPv6 address; see [RFC3493]) will\n      contain the primary address of the\
    \ peer endpoint.\n   addrlen:  On return, addrlen will contain the size of addr.\n\
    \   The function returns the socket descriptor for the newly formed\n   association\
    \ on success and -1 in case of an error.\n"
- title: 4.1.5.  connect()
  contents:
  - "4.1.5.  connect()\n   Applications use connect() to initiate an association to\
    \ a peer.\n   The function prototype is\n   int connect(int sd,\n            \
    \   const struct sockaddr *addr,\n               socklen_t addrlen);\n   and the\
    \ arguments are\n   sd:  The socket descriptor of the endpoint.\n   addr:  The\
    \ peer's (struct sockaddr_in for an IPv4 address or struct\n      sockaddr_in6\
    \ for an IPv6 address; see [RFC3493]) address.\n   addrlen:  The size of the address.\n\
    \   connect() returns 0 on success and -1 on error.\n   This operation corresponds\
    \ to the ASSOCIATE primitive described in\n   Section 10.1 of [RFC4960].\n   The\
    \ number of outbound streams the new association has is stack\n   dependent. \
    \ Before connecting, applications can use the SCTP_INITMSG\n   option described\
    \ in Section 8.1.3 to change the number of outbound\n   streams.\n   If bind()\
    \ is not called prior to the connect() call, the system picks\n   an ephemeral\
    \ port and will choose an address set equivalent to\n   binding with INADDR_ANY\
    \ and IN6ADDR_ANY_INIT for IPv4 and IPv6\n   sockets, respectively.  One of the\
    \ addresses will be the primary\n   address for the association.  This automatically\
    \ enables the\n   multi-homing capability of SCTP.\n   Note that SCTP allows data\
    \ exchange, similar to T/TCP [RFC1644] (made\n   Historic by [RFC6247]), during\
    \ the association setup phase.  If an\n   application wants to do this, it cannot\
    \ use the connect() call.\n   Instead, it should use sendto() or sendmsg() to\
    \ initiate an\n   association.  If it uses sendto() and it wants to change the\n\
    \   initialization behavior, it needs to use the SCTP_INITMSG socket\n   option\
    \ before calling sendto().  Or it can use sendmsg() with\n   SCTP_INIT type ancillary\
    \ data to initiate an association without\n   calling setsockopt().  Note that\
    \ the implicit setup is supported for\n   the one-to-one style sockets.\n   SCTP\
    \ does not support half close semantics.  This means that unlike\n   T/TCP, MSG_EOF\
    \ should not be set in the flags parameter when calling\n   sendto() or sendmsg()\
    \ when the call is used to initiate a connection.\n   MSG_EOF is not an acceptable\
    \ flag with an SCTP socket.\n"
- title: 4.1.6.  close()
  contents:
  - "4.1.6.  close()\n   Applications use close() to gracefully close down an association.\n\
    \   The function prototype is\n   int close(int sd);\n   and the argument is\n\
    \   sd:  The socket descriptor of the association to be closed.\n   close() returns\
    \ 0 on success and -1 in case of an error.\n   After an application calls close()\
    \ on a socket descriptor, no further\n   socket operations will succeed on that\
    \ descriptor.\n"
- title: 4.1.7.  shutdown()
  contents:
  - "4.1.7.  shutdown()\n   SCTP differs from TCP in that it does not have half close\
    \ semantics.\n   Hence, the shutdown() call for SCTP is an approximation of the\
    \ TCP\n   shutdown() call, and solves some different problems.  Full TCP\n   compatibility\
    \ is not provided, so developers porting TCP applications\n   to SCTP may need\
    \ to recode sections that use shutdown().  (Note that\n   it is possible to achieve\
    \ the same results as half close in SCTP\n   using SCTP streams.)\n   The function\
    \ prototype is\n   int shutdown(int sd,\n                int how);\n   and the\
    \ arguments are\n   sd:  The socket descriptor of the association to be closed.\n\
    \   how:  Specifies the type of shutdown.  The values are as follows:\n      SHUT_RD:\
    \  Disables further receive operations.  No SCTP protocol\n         action is\
    \ taken.\n      SHUT_WR:  Disables further send operations, and initiates the\
    \ SCTP\n         shutdown sequence.\n      SHUT_RDWR:  Disables further send and\
    \ receive operations, and\n         initiates the SCTP shutdown sequence.\n  \
    \ shutdown() returns 0 on success and -1 in case of an error.\n   The major difference\
    \ between SCTP and TCP shutdown() is that SCTP\n   SHUT_WR initiates immediate\
    \ and full protocol shutdown, whereas TCP\n   SHUT_WR causes TCP to go into the\
    \ half close state.  SHUT_RD behaves\n   the same for SCTP as for TCP.  The purpose\
    \ of SCTP SHUT_WR is to\n   close the SCTP association while still leaving the\
    \ socket descriptor\n   open.  This allows the caller to receive back any data\
    \ that SCTP is\n   unable to deliver (see Section 6.1.4 for more information)\
    \ and\n   receive event notifications.\n   To perform the ABORT operation described\
    \ in Section 10.1 of\n   [RFC4960], an application can use the socket option SO_LINGER.\n\
    \   SO_LINGER is described in Section 8.1.4.\n"
- title: 4.1.8.  sendmsg() and recvmsg()
  contents:
  - "4.1.8.  sendmsg() and recvmsg()\n   With a one-to-one style socket, the application\
    \ can also use\n   sendmsg() and recvmsg() to transmit data to and receive data\
    \ from its\n   peer.  The semantics is similar to those used in the one-to-many\n\
    \   style (see Section 3.1.4), with the following differences:\n   1.  When sending,\
    \ the msg_name field in the msghdr is not used to\n       specify the intended\
    \ receiver; rather, it is used to indicate a\n       preferred peer address if\
    \ the sender wishes to discourage the\n       stack from sending the message to\
    \ the primary address of the\n       receiver.  If the socket is connected and\
    \ the transport address\n       given is not part of the current association,\
    \ the data will not\n       be sent, and an SCTP_SEND_FAILED_EVENT event will\
    \ be delivered to\n       the application if send failure events are enabled.\n\
    \   2.  Using sendmsg() on a non-connected one-to-one style socket for\n     \
    \  implicit connection setup may or may not work, depending on the\n       SCTP\
    \ implementation.\n"
- title: 4.1.9.  getpeername()
  contents:
  - "4.1.9.  getpeername()\n   Applications use getpeername() to retrieve the primary\
    \ socket address\n   of the peer.  This call is for TCP compatibility and is not\n\
    \   multi-homed.  It may not work with one-to-many style sockets,\n   depending\
    \ on the implementation.  See Section 9.3 for a multi-homed\n   style version\
    \ of the call.\n   The function prototype is\n   int getpeername(int sd,\n   \
    \                struct sockaddr *address,\n                   socklen_t *len);\n\
    \   and the arguments are\n   sd:  The socket descriptor to be queried.\n   address:\
    \  On return, the peer primary address is stored in this\n      buffer.  If the\
    \ socket is an IPv4 socket, the address will be\n      IPv4.  If the socket is\
    \ an IPv6 socket, the address will be either\n      an IPv6 or IPv4 address.\n\
    \   len:  The caller should set the length of address here.  On return,\n    \
    \  this is set to the length of the returned address.\n   getpeername() returns\
    \ 0 on success and -1 in case of an error.\n   If the actual length of the address\
    \ is greater than the length of the\n   supplied sockaddr structure, the stored\
    \ address will be truncated.\n"
- title: 5.  Data Structures
  contents:
  - "5.  Data Structures\n   This section discusses important data structures that\
    \ are specific to\n   SCTP and are used with sendmsg() and recvmsg() calls to\
    \ control SCTP\n   endpoint operations and to access ancillary information and\n\
    \   notifications.\n"
- title: 5.1.  The msghdr and cmsghdr Structures
  contents:
  - "5.1.  The msghdr and cmsghdr Structures\n   The msghdr structure used in the\
    \ sendmsg() and recvmsg() calls, as\n   well as the ancillary data carried in\
    \ the structure, is the key for\n   the application to set and get various control\
    \ information from the\n   SCTP endpoint.\n   The msghdr and the related cmsghdr\
    \ structures are defined and\n   discussed in detail in [RFC3542].  They are defined\
    \ as\n   struct msghdr {\n     void *msg_name;           /* ptr to socket address\
    \ structure */\n     socklen_t msg_namelen;    /* size of socket address structure\
    \ */\n     struct iovec *msg_iov;    /* scatter/gather array */\n     int msg_iovlen;\
    \           /* # elements in msg_iov */\n     void *msg_control;        /* ancillary\
    \ data */\n     socklen_t msg_controllen; /* ancillary data buffer length */\n\
    \     int msg_flags;            /* flags on received message */\n   };\n   struct\
    \ cmsghdr {\n     socklen_t cmsg_len; /* # bytes, including this header */\n \
    \    int cmsg_level;     /* originating protocol */\n     int cmsg_type;     \
    \ /* protocol-specific type */\n                         /* followed by unsigned\
    \ char cmsg_data[]; */\n   };\n   In the msghdr structure, the usage of msg_name\
    \ has been discussed in\n   previous sections (see Sections 3.1.4 and 4.1.8).\n\
    \   The scatter/gather buffers, or I/O vectors (pointed to by the msg_iov\n  \
    \ field) are treated by SCTP as a single user message for both\n   sendmsg() and\
    \ recvmsg().\n   The SCTP stack uses the ancillary data (msg_control field) to\n\
    \   communicate the attributes, such as SCTP_RCVINFO, of the message\n   stored\
    \ in msg_iov to the socket endpoint.  The different ancillary\n   data types are\
    \ described in Section 5.3.\n   The msg_flags are not used when sending a message\
    \ with sendmsg().\n   If a notification has arrived, recvmsg() will return the\
    \ notification\n   in the msg_iov field and set the MSG_NOTIFICATION flag in msg_flags.\n\
    \   If the MSG_NOTIFICATION flag is not set, recvmsg() will return data.\n   See\
    \ Section 6 for more information about notifications.\n   If all portions of a\
    \ data frame or notification have been read,\n   recvmsg() will return with MSG_EOR\
    \ set in msg_flags.\n"
- title: 5.2.  Ancillary Data Considerations and Semantics
  contents:
  - "5.2.  Ancillary Data Considerations and Semantics\n   Programming with ancillary\
    \ socket data (msg_control) contains some\n   subtleties and pitfalls, which are\
    \ discussed below.\n"
- title: 5.2.1.  Multiple Items and Ordering
  contents:
  - "5.2.1.  Multiple Items and Ordering\n   Multiple ancillary data items may be\
    \ included in any call to\n   sendmsg() or recvmsg(); these may include multiple\
    \ SCTP items,\n   non-SCTP items (such as IP-level items), or both.\n   The ordering\
    \ of ancillary data items (either by SCTP or another\n   protocol) is not significant\
    \ and is implementation dependent, so\n   applications must not depend on any\
    \ ordering.\n   SCTP_SNDRCV/SCTP_SNDINFO/SCTP_RCVINFO type ancillary data always\n\
    \   corresponds to the data in the msghdr's msg_iov member.  There can be\n  \
    \ only one such type of ancillary data for each sendmsg() or recvmsg()\n   call.\n"
- title: 5.2.2.  Accessing and Manipulating Ancillary Data
  contents:
  - "5.2.2.  Accessing and Manipulating Ancillary Data\n   Applications can infer\
    \ the presence of data or ancillary data by\n   examining the msg_iovlen and msg_controllen\
    \ msghdr members,\n   respectively.\n   Implementations may have different padding\
    \ requirements for ancillary\n   data, so portable applications should make use\
    \ of the macros\n   CMSG_FIRSTHDR, CMSG_NXTHDR, CMSG_DATA, CMSG_SPACE, and CMSG_LEN.\
    \  See\n   [RFC3542] and the SCTP implementation's documentation for more\n  \
    \ information.  The following is an example, from [RFC3542],\n   demonstrating\
    \ the use of these macros to access ancillary data:\n   struct msghdr msg;\n \
    \  struct cmsghdr *cmsgptr;\n   /* fill in msg */\n   /* call recvmsg() */\n \
    \  for (cmsgptr = CMSG_FIRSTHDR(&msg); cmsgptr != NULL;\n        cmsgptr = CMSG_NXTHDR(&msg,\
    \ cmsgptr)) {\n     if (cmsgptr->cmsg_len == 0) {\n        /* Error handling */\n\
    \        break;\n     }\n     if (cmsgptr->cmsg_level == ... && cmsgptr->cmsg_type\
    \ == ... ) {\n       u_char  *ptr;\n       ptr = CMSG_DATA(cmsgptr);\n       /*\
    \ process data pointed to by ptr */\n     }\n   }\n"
- title: 5.2.3.  Control Message Buffer Sizing
  contents:
  - "5.2.3.  Control Message Buffer Sizing\n   The information conveyed via SCTP_SNDRCV/SCTP_SNDINFO/SCTP_RCVINFO\n\
    \   ancillary data will often be fundamental to the correct and sane\n   operation\
    \ of the sockets application.  This is particularly true for\n   one-to-many style\
    \ sockets, but also for one-to-one style sockets.\n   For example, if an application\
    \ needs to send and receive data on\n   different SCTP streams, SCTP_SNDRCV/SCTP_SNDINFO/SCTP_RCVINFO\n\
    \   ancillary data is indispensable.\n   Given that some ancillary data is critical,\
    \ and that multiple\n   ancillary data items may appear in any order, applications\
    \ should be\n   carefully written to always provide a large enough buffer to contain\n\
    \   all possible ancillary data that can be presented by recvmsg().  If\n   the\
    \ buffer is too small, and crucial data is truncated, it may pose a\n   fatal\
    \ error condition.\n   Thus, it is essential that applications be able to deterministically\n\
    \   calculate the maximum required buffer size to pass to recvmsg().  One\n  \
    \ constraint imposed on this specification that makes this possible is\n   that\
    \ all ancillary data definitions are of a fixed length.  One way\n   to calculate\
    \ the maximum required buffer size might be to take the\n   sum of the sizes of\
    \ all enabled ancillary data item structures, as\n   calculated by CMSG_SPACE.\
    \  For example, if we enabled\n   SCTP_SNDRCV_INFO and IPV6_RECVPKTINFO [RFC3542],\
    \ we would calculate\n   and allocate the buffer size as follows:\n   size_t total;\n\
    \   void *buf;\n   total = CMSG_SPACE(sizeof(struct sctp_sndrcvinfo)) +\n    \
    \       CMSG_SPACE(sizeof(struct in6_pktinfo));\n   buf = malloc(total);\n   We\
    \ could then use this buffer (buf) for msg_control on each call to\n   recvmsg()\
    \ and be assured that we would not lose any ancillary data to\n   truncation.\n"
- title: 5.3.  SCTP msg_control Structures
  contents:
  - "5.3.  SCTP msg_control Structures\n   A key element of all SCTP-specific socket\
    \ extensions is the use of\n   ancillary data to specify and access SCTP-specific\
    \ data via the\n   msghdr structure's msg_control member used in sendmsg() and\n\
    \   recvmsg().  Fine-grained control over initialization and sending\n   parameters\
    \ are handled with ancillary data.\n   Each ancillary data item is preceded by\
    \ a struct cmsghdr (see\n   Section 5.1), which defines the function and purpose\
    \ of the data\n   contained in the cmsg_data[] member.\n   By default, on either\
    \ style of socket, SCTP will pass no ancillary\n   data.  Specific ancillary data\
    \ items can be enabled with socket\n   options defined for SCTP; see Section 6.2.\n\
    \   Note that all ancillary types are of fixed length; see Section 5.2\n   for\
    \ further discussion on this.  These data structures use struct\n   sockaddr_storage\
    \ (defined in [RFC3493]) as a portable, fixed-length\n   address format.\n   Other\
    \ protocols may also provide ancillary data to the socket layer\n   consumer.\
    \  These ancillary data items from other protocols may\n   intermingle with SCTP\
    \ data.  For example, the IPv6 sockets API\n   definitions ([RFC3542] and [RFC3493])\
    \ define a number of ancillary\n   data items.  If a sockets API consumer enables\
    \ delivery of both SCTP\n   and IPv6 ancillary data, they both may appear in the\
    \ same msg_control\n   buffer in any order.  An application may thus need to handle\
    \ other\n   types of ancillary data besides those passed by SCTP.\n   The sockets\
    \ application must provide a buffer large enough to\n   accommodate all ancillary\
    \ data provided via recvmsg().  If the buffer\n   is not large enough, the ancillary\
    \ data will be truncated and the\n   msghdr's msg_flags will include MSG_CTRUNC.\n"
- title: 5.3.1.  SCTP Initiation Structure (SCTP_INIT)
  contents:
  - "5.3.1.  SCTP Initiation Structure (SCTP_INIT)\n   This cmsghdr structure provides\
    \ information for initializing new SCTP\n   associations with sendmsg().  The\
    \ SCTP_INITMSG socket option uses\n   this same data structure.  This structure\
    \ is not used for recvmsg().\n            +--------------+-----------+---------------------+\n\
    \            | cmsg_level   | cmsg_type | cmsg_data[]         |\n            +--------------+-----------+---------------------+\n\
    \            | IPPROTO_SCTP | SCTP_INIT | struct sctp_initmsg |\n            +--------------+-----------+---------------------+\n\
    \   The sctp_initmsg structure is defined below:\n   struct sctp_initmsg {\n \
    \    uint16_t sinit_num_ostreams;\n     uint16_t sinit_max_instreams;\n     uint16_t\
    \ sinit_max_attempts;\n     uint16_t sinit_max_init_timeo;\n   };\n   sinit_num_ostreams:\
    \  This is an integer representing the number of\n      streams to which the application\
    \ wishes to be able to send.  This\n      number is confirmed in the SCTP_COMM_UP\
    \ notification and must be\n      verified, since it is a negotiated number with\
    \ the remote\n      endpoint.  The default value of 0 indicates the use of the\n\
    \      endpoint's default value.\n   sinit_max_instreams:  This value represents\
    \ the maximum number of\n      inbound streams the application is prepared to\
    \ support.  This\n      value is bounded by the actual implementation.  In other\
    \ words,\n      the user may be able to support more streams than the operating\n\
    \      system.  In such a case, the operating-system limit overrides the\n   \
    \   value requested by the user.  The default value of 0 indicates the\n     \
    \ use of the endpoint's default value.\n   sinit_max_attempts:  This integer specifies\
    \ how many attempts the\n      SCTP endpoint should make at resending the INIT.\
    \  This value\n      overrides the system SCTP 'Max.Init.Retransmits' value. \
    \ The\n      default value of 0 indicates the use of the endpoint's default\n\
    \      value.  This is normally set to the system's default\n      'Max.Init.Retransmit'\
    \ value.\n   sinit_max_init_timeo:  This value represents the largest timeout\
    \ or\n      retransmission timeout (RTO) value (in milliseconds) to use in\n \
    \     attempting an INIT.  Normally, the 'RTO.Max' is used to limit the\n    \
    \  doubling of the RTO upon timeout.  For the INIT message, this\n      value\
    \ may override 'RTO.Max'.  This value must not influence\n      'RTO.Max' during\
    \ data transmission and is only used to bound the\n      initial setup time. \
    \ A default value of 0 indicates the use of the\n      endpoint's default value.\
    \  This is normally set to the system's\n      'RTO.Max' value (60 seconds).\n"
- title: 5.3.2.  SCTP Header Information Structure (SCTP_SNDRCV) - DEPRECATED
  contents:
  - "5.3.2.  SCTP Header Information Structure (SCTP_SNDRCV) - DEPRECATED\n   This\
    \ cmsghdr structure specifies SCTP options for sendmsg() and\n   describes SCTP\
    \ header information about a received message through\n   recvmsg().  This structure\
    \ mixes the send and receive path.\n   SCTP_SNDINFO (described in Section 5.3.4)\
    \ and SCTP_RCVINFO (described\n   in Section 5.3.5) split this information.  These\
    \ structures should be\n   used, when possible, since SCTP_SNDRCV is deprecated.\n\
    \          +--------------+-------------+------------------------+\n         \
    \ | cmsg_level   | cmsg_type   | cmsg_data[]            |\n          +--------------+-------------+------------------------+\n\
    \          | IPPROTO_SCTP | SCTP_SNDRCV | struct sctp_sndrcvinfo |\n         \
    \ +--------------+-------------+------------------------+\n   The sctp_sndrcvinfo\
    \ structure is defined below:\n   struct sctp_sndrcvinfo {\n     uint16_t sinfo_stream;\n\
    \     uint16_t sinfo_ssn;\n     uint16_t sinfo_flags;\n     uint32_t sinfo_ppid;\n\
    \     uint32_t sinfo_context;\n     uint32_t sinfo_timetolive;\n     uint32_t\
    \ sinfo_tsn;\n     uint32_t sinfo_cumtsn;\n     sctp_assoc_t sinfo_assoc_id;\n\
    \   };\n   sinfo_stream:  For recvmsg(), the SCTP stack places the message's\n\
    \      stream number in this value.  For sendmsg(), this value holds the\n   \
    \   stream number to which the application wishes to send this\n      message.\
    \  If a sender specifies an invalid stream number, an error\n      indication\
    \ is returned and the call fails.\n   sinfo_ssn:  For recvmsg(), this value contains\
    \ the stream sequence\n      number that the remote endpoint placed in the DATA\
    \ chunk.  For\n      fragmented messages, this is the same number for all deliveries\
    \ of\n      the message (if more than one recvmsg() is needed to read the\n  \
    \    message).  The sendmsg() call will ignore this parameter.\n   sinfo_flags:\
    \  This field may contain any of the following flags and\n      is composed of\
    \ a bitwise OR of these values.\n      recvmsg() flags:\n         SCTP_UNORDERED:\
    \  This flag is present when the message was sent\n            unordered.\n  \
    \    sendmsg() flags:\n         SCTP_UNORDERED:  This flag requests the unordered\
    \ delivery of\n            the message.  If this flag is clear, the datagram is\n\
    \            considered an ordered send.\n         SCTP_ADDR_OVER:  This flag,\
    \ for a one-to-many style socket,\n            requests that the SCTP stack override\
    \ the primary\n            destination address with the address found with the\
    \ sendto/\n            sendmsg call.\n         SCTP_ABORT:  Setting this flag\
    \ causes the specified association\n            to abort by sending an ABORT message\
    \ to the peer.  The ABORT\n            chunk will contain an error cause of 'User\
    \ Initiated Abort'\n            with cause code 12.  The cause-specific information\
    \ of this\n            error cause is provided in msg_iov.\n         SCTP_EOF:\
    \  Setting this flag invokes the SCTP graceful shutdown\n            procedure\
    \ on the specified association.  Graceful shutdown\n            assures that all\
    \ data queued by both endpoints is\n            successfully transmitted before\
    \ closing the association.\n         SCTP_SENDALL:  This flag, if set, will cause\
    \ a one-to-many\n            style socket to send the message to all associations\
    \ that\n            are currently established on this socket.  For the one-to-\n\
    \            one style socket, this flag has no effect.\n   sinfo_ppid:  This\
    \ value in sendmsg() is an unsigned integer that is\n      passed to the remote\
    \ end in each user message.  In recvmsg(), this\n      value is the same information\
    \ that was passed by the upper layer\n      in the peer application.  Please note\
    \ that the SCTP stack performs\n      no byte order modification of this field.\
    \  For example, if the\n      DATA chunk has to contain a given value in network\
    \ byte order, the\n      SCTP user has to perform the htonl() computation.\n \
    \  sinfo_context:  This value is an opaque 32-bit context datum that is\n    \
    \  used in the sendmsg() function.  This value is passed back to the\n      upper\
    \ layer if an error occurs on the send of a message and is\n      retrieved with\
    \ each undelivered message.\n   sinfo_timetolive:  For the sending side, this\
    \ field contains the\n      message's time to live, in milliseconds.  The sending\
    \ side will\n      expire the message within the specified time period if the\
    \ message\n      has not been sent to the peer within this time period.  This\
    \ value\n      will override any default value set using any socket option.  Also\n\
    \      note that the value of 0 is special in that it indicates no\n      timeout\
    \ should occur on this message.\n   sinfo_tsn:  For the receiving side, this field\
    \ holds a Transmission\n      Sequence Number (TSN) that was assigned to one of\
    \ the SCTP DATA\n      chunks.  For the sending side, it is ignored.\n   sinfo_cumtsn:\
    \  This field will hold the current cumulative TSN as\n      known by the underlying\
    \ SCTP layer.  Note that this field is\n      ignored when sending.\n   sinfo_assoc_id:\
    \  The association handle field, sinfo_assoc_id, holds\n      the identifier for\
    \ the association announced in the SCTP_COMM_UP\n      notification.  All notifications\
    \ for a given association have the\n      same identifier.  This field is ignored\
    \ for one-to-one style\n      sockets.\n   An sctp_sndrcvinfo item always corresponds\
    \ to the data in msg_iov.\n"
- title: 5.3.3.  Extended SCTP Header Information Structure (SCTP_EXTRCV) -
  contents:
  - "5.3.3.  Extended SCTP Header Information Structure (SCTP_EXTRCV) -\n        DEPRECATED\n\
    \   This cmsghdr structure specifies SCTP options for SCTP header\n   information\
    \ about a received message via recvmsg().  Note that this\n   structure is an\
    \ extended version of SCTP_SNDRCV (see Section 5.3.2)\n   and will only be received\
    \ if the user has set the socket option\n   SCTP_USE_EXT_RCVINFO (see Section\
    \ 8.1.22) to true in addition to any\n   event subscription needed to receive\
    \ ancillary data.  Note that data\n   in the next message is not valid unless\
    \ the current message is\n   completely read, i.e., unless the MSG_EOR is set;\
    \ in other words, if\n   the application has more data to read from the current\
    \ message, then\n   no next-message information will be available.\n   SCTP_NXTINFO\
    \ (described in Section 5.3.6) should be used when\n   possible, since SCTP_EXTRCV\
    \ is considered deprecated.\n          +--------------+-------------+------------------------+\n\
    \          | cmsg_level   | cmsg_type   | cmsg_data[]            |\n         \
    \ +--------------+-------------+------------------------+\n          | IPPROTO_SCTP\
    \ | SCTP_EXTRCV | struct sctp_extrcvinfo |\n          +--------------+-------------+------------------------+\n\
    \   The sctp_extrcvinfo structure is defined below:\n   struct sctp_extrcvinfo\
    \ {\n     uint16_t sinfo_stream;\n     uint16_t sinfo_ssn;\n     uint16_t sinfo_flags;\n\
    \     uint32_t sinfo_ppid;\n     uint32_t sinfo_context;\n     uint32_t sinfo_pr_value;\n\
    \     uint32_t sinfo_tsn;\n     uint32_t sinfo_cumtsn;\n     uint16_t serinfo_next_flags;\n\
    \     uint16_t serinfo_next_stream;\n     uint32_t serinfo_next_aid;\n     uint32_t\
    \ serinfo_next_length;\n     uint32_t serinfo_next_ppid;\n     sctp_assoc_t sinfo_assoc_id;\n\
    \   };\n   sinfo_*:  Please see Section 5.3.2 for details for these fields.\n\
    \   serinfo_next_flags:  This bitmask will hold one or more of the\n      following\
    \ values:\n      SCTP_NEXT_MSG_AVAIL:  This bit, when set to 1, indicates that\n\
    \         next-message information is available; i.e., next_stream,\n        \
    \ next_aid, next_length, and next_ppid fields all have valid\n         values.\
    \  If this bit is set to 0, then these fields are not\n         valid and should\
    \ be ignored.\n      SCTP_NEXT_MSG_ISCOMPLETE:  This bit, when set, indicates\
    \ that the\n         next message is completely in the receive buffer.  The\n\
    \         next_length field thus contains the entire message size.  If\n     \
    \    this flag is set to 0, then the next_length field only contains\n       \
    \  part of the message size, since the message is still being\n         received\
    \ (it is being partially delivered).\n      SCTP_NEXT_MSG_IS_UNORDERED:  This\
    \ bit, when set, indicates that\n         the next message to be received was\
    \ sent by the peer as\n         unordered.  If this bit is not set (i.e., the\
    \ bit is 0) the\n         next message to be read is an ordered message in the\
    \ stream\n         specified.\n      SCTP_NEXT_MSG_IS_NOTIFICATION:  This bit,\
    \ when set, indicates that\n         the next message to be received is not a\
    \ message from the peer,\n         but instead is a MSG_NOTIFICATION from the\
    \ local SCTP stack.\n   serinfo_next_stream:  This value, when valid (see\n  \
    \    serinfo_next_flags), contains the next stream number that will be\n     \
    \ received on a subsequent call to one of the receive message\n      functions.\n\
    \   serinfo_next_aid:  This value, when valid (see serinfo_next_flags),\n    \
    \  contains the next association identifier that will be received on\n      a\
    \ subsequent call to one of the receive message functions.\n   serinfo_next_length:\
    \  This value, when valid (see\n      serinfo_next_flags), contains the length\
    \ of the next message that\n      will be received on a subsequent call to one\
    \ of the receive\n      message functions.  Note that this length may be a partial\
    \ length,\n      depending on the settings of next_flags.\n   serinfo_next_ppid:\
    \  This value, when valid (see serinfo_next_flags),\n      contains the ppid of\
    \ the next message that will be received on a\n      subsequent call to one of\
    \ the receive message functions.\n"
- title: 5.3.4.  SCTP Send Information Structure (SCTP_SNDINFO)
  contents:
  - "5.3.4.  SCTP Send Information Structure (SCTP_SNDINFO)\n   This cmsghdr structure\
    \ specifies SCTP options for sendmsg().\n           +--------------+--------------+---------------------+\n\
    \           | cmsg_level   | cmsg_type    | cmsg_data[]         |\n          \
    \ +--------------+--------------+---------------------+\n           | IPPROTO_SCTP\
    \ | SCTP_SNDINFO | struct sctp_sndinfo |\n           +--------------+--------------+---------------------+\n\
    \   The sctp_sndinfo structure is defined below:\n   struct sctp_sndinfo {\n \
    \    uint16_t snd_sid;\n     uint16_t snd_flags;\n     uint32_t snd_ppid;\n  \
    \   uint32_t snd_context;\n     sctp_assoc_t snd_assoc_id;\n   };\n   snd_sid:\
    \  This value holds the stream number to which the application\n      wishes to\
    \ send this message.  If a sender specifies an invalid\n      stream number, an\
    \ error indication is returned and the call fails.\n   snd_flags:  This field\
    \ may contain any of the following flags and is\n      composed of a bitwise OR\
    \ of these values.\n      SCTP_UNORDERED:  This flag requests the unordered delivery\
    \ of the\n         message.  If this flag is clear, the datagram is considered\
    \ an\n         ordered send.\n      SCTP_ADDR_OVER:  This flag, for a one-to-many\
    \ style socket,\n         requests that the SCTP stack override the primary destination\n\
    \         address with the address found with the sendto()/sendmsg call.\n   \
    \   SCTP_ABORT:  Setting this flag causes the specified association to\n     \
    \    abort by sending an ABORT message to the peer.  The ABORT chunk\n       \
    \  will contain an error cause of 'User Initiated Abort' with\n         cause\
    \ code 12.  The cause-specific information of this error\n         cause is provided\
    \ in msg_iov.\n      SCTP_EOF:  Setting this flag invokes the SCTP graceful shutdown\n\
    \         procedures on the specified association.  Graceful shutdown\n      \
    \   assures that all data queued by both endpoints is successfully\n         transmitted\
    \ before closing the association.\n      SCTP_SENDALL:  This flag, if set, will\
    \ cause a one-to-many style\n         socket to send the message to all associations\
    \ that are\n         currently established on this socket.  For the one-to-one\
    \ style\n         socket, this flag has no effect.\n   snd_ppid:  This value in\
    \ sendmsg() is an unsigned integer that is\n      passed to the remote end in\
    \ each user message.  Please note that\n      the SCTP stack performs no byte\
    \ order modification of this field.\n      For example, if the DATA chunk has\
    \ to contain a given value in\n      network byte order, the SCTP user has to\
    \ perform the htonl()\n      computation.\n   snd_context:  This value is an opaque\
    \ 32-bit context datum that is\n      used in the sendmsg() function.  This value\
    \ is passed back to the\n      upper layer if an error occurs on the send of a\
    \ message and is\n      retrieved with each undelivered message.\n   snd_assoc_id:\
    \  The association handle field, sinfo_assoc_id, holds\n      the identifier for\
    \ the association announced in the SCTP_COMM_UP\n      notification.  All notifications\
    \ for a given association have the\n      same identifier.  This field is ignored\
    \ for one-to-one style\n      sockets.\n   An sctp_sndinfo item always corresponds\
    \ to the data in msg_iov.\n"
- title: 5.3.5.  SCTP Receive Information Structure (SCTP_RCVINFO)
  contents:
  - "5.3.5.  SCTP Receive Information Structure (SCTP_RCVINFO)\n   This cmsghdr structure\
    \ describes SCTP receive information about a\n   received message through recvmsg().\n\
    \   To enable the delivery of this information, an application must use\n   the\
    \ SCTP_RECVRCVINFO socket option (see Section 8.1.29).\n           +--------------+--------------+---------------------+\n\
    \           | cmsg_level   | cmsg_type    | cmsg_data[]         |\n          \
    \ +--------------+--------------+---------------------+\n           | IPPROTO_SCTP\
    \ | SCTP_RCVINFO | struct sctp_rcvinfo |\n           +--------------+--------------+---------------------+\n\
    \   The sctp_rcvinfo structure is defined below:\n   struct sctp_rcvinfo {\n \
    \    uint16_t rcv_sid;\n     uint16_t rcv_ssn;\n     uint16_t rcv_flags;\n   \
    \  uint32_t rcv_ppid;\n     uint32_t rcv_tsn;\n     uint32_t rcv_cumtsn;\n   \
    \  uint32_t rcv_context;\n     sctp_assoc_t rcv_assoc_id;\n   };\n   rcv_sid:\
    \  The SCTP stack places the message's stream number in this\n      value.\n \
    \  rcv_ssn:  This value contains the stream sequence number that the\n      remote\
    \ endpoint placed in the DATA chunk.  For fragmented\n      messages, this is\
    \ the same number for all deliveries of the\n      message (if more than one recvmsg()\
    \ is needed to read the\n      message).\n   rcv_flags:  This field may contain\
    \ any of the following flags and is\n      composed of a bitwise OR of these values.\n\
    \      SCTP_UNORDERED:  This flag is present when the message was sent\n     \
    \    unordered.\n   rcv_ppid:  This value is the same information that was passed\
    \ by the\n      upper layer in the peer application.  Please note that the SCTP\n\
    \      stack performs no byte order modification of this field.  For\n      example,\
    \ if the DATA chunk has to contain a given value in network\n      byte order,\
    \ the SCTP user has to perform the ntohl() computation.\n   rcv_tsn:  This field\
    \ holds a TSN that was assigned to one of the SCTP\n      DATA chunks.\n   rcv_cumtsn:\
    \  This field will hold the current cumulative TSN as known\n      by the underlying\
    \ SCTP layer.\n   rcv_context:  This value is an opaque 32-bit context datum that\
    \ was\n      set by the user with the SCTP_CONTEXT socket option.  This value\n\
    \      is passed back to the upper layer if an error occurs on the send\n    \
    \  of a message and is retrieved with each undelivered message.\n   rcv_assoc_id:\
    \  The association handle field, sinfo_assoc_id, holds\n      the identifier for\
    \ the association announced in the SCTP_COMM_UP\n      notification.  All notifications\
    \ for a given association have the\n      same identifier.  This field is ignored\
    \ for one-to-one style\n      sockets.\n   An sctp_rcvinfo item always corresponds\
    \ to the data in msg_iov.\n"
- title: 5.3.6.  SCTP Next Receive Information Structure (SCTP_NXTINFO)
  contents:
  - "5.3.6.  SCTP Next Receive Information Structure (SCTP_NXTINFO)\n   This cmsghdr\
    \ structure describes SCTP receive information of the next\n   message that will\
    \ be delivered through recvmsg() if this information\n   is already available\
    \ when delivering the current message.\n   To enable the delivery of this information,\
    \ an application must use\n   the SCTP_RECVNXTINFO socket option (see Section\
    \ 8.1.30).\n           +--------------+--------------+---------------------+\n\
    \           | cmsg_level   | cmsg_type    | cmsg_data[]         |\n          \
    \ +--------------+--------------+---------------------+\n           | IPPROTO_SCTP\
    \ | SCTP_NXTINFO | struct sctp_nxtinfo |\n           +--------------+--------------+---------------------+\n\
    \   The sctp_nxtinfo structure is defined below:\n   struct sctp_nxtinfo {\n \
    \    uint16_t nxt_sid;\n     uint16_t nxt_flags;\n     uint32_t nxt_ppid;\n  \
    \   uint32_t nxt_length;\n     sctp_assoc_t nxt_assoc_id;\n   };\n   nxt_sid:\
    \  The SCTP stack places the next message's stream number in\n      this value.\n\
    \   nxt_flags:  This field may contain any of the following flags and is\n   \
    \   composed of a bitwise OR of these values.\n      SCTP_UNORDERED:  This flag\
    \ is present when the next message was\n         sent unordered.\n      SCTP_COMPLETE:\
    \  This flag indicates that the entire message has\n         been received and\
    \ is in the socket buffer.  Note that this has\n         special implications\
    \ with respect to the nxt_length field; see\n         the description for nxt_length\
    \ below.\n      SCTP_NOTIFICATION:  This flag is present when the next message\
    \ is\n         not a user message but instead is a notification.\n   nxt_ppid:\
    \  This value is the same information that was passed by the\n      upper layer\
    \ in the peer application for the next message.  Please\n      note that the SCTP\
    \ stack performs no byte order modification of\n      this field.  For example,\
    \ if the DATA chunk has to contain a given\n      value in network byte order,\
    \ the SCTP user has to perform the\n      ntohl() computation.\n   nxt_length:\
    \  This value is the length of the message currently within\n      the socket\
    \ buffer.  This might NOT be the entire length of the\n      message, since a\
    \ partial delivery may be in progress.  Only if the\n      flag SCTP_COMPLETE\
    \ is set in the nxt_flags field does this field\n      represent the size of the\
    \ entire next message.\n   nxt_assoc_id:  The association handle field of the\
    \ next message,\n      nxt_assoc_id, holds the identifier for the association\
    \ announced\n      in the SCTP_COMM_UP notification.  All notifications for a\
    \ given\n      association have the same identifier.  This field is ignored for\n\
    \      one-to-one style sockets.\n"
- title: 5.3.7.  SCTP PR-SCTP Information Structure (SCTP_PRINFO)
  contents:
  - "5.3.7.  SCTP PR-SCTP Information Structure (SCTP_PRINFO)\n   This cmsghdr structure\
    \ specifies SCTP options for sendmsg().\n            +--------------+-------------+--------------------+\n\
    \            | cmsg_level   | cmsg_type   | cmsg_data[]        |\n           \
    \ +--------------+-------------+--------------------+\n            | IPPROTO_SCTP\
    \ | SCTP_PRINFO | struct sctp_prinfo |\n            +--------------+-------------+--------------------+\n\
    \   The sctp_prinfo structure is defined below:\n   struct sctp_prinfo {\n   \
    \  uint16_t pr_policy;\n     uint32_t pr_value;\n   };\n   pr_policy:  This specifies\
    \ which Partially Reliable SCTP (PR-SCTP)\n      policy is used.  Using SCTP_PR_SCTP_NONE\
    \ results in a reliable\n      transmission.  When SCTP_PR_SCTP_TTL is used, the\
    \ PR-SCTP policy\n      \"timed reliability\" defined in [RFC3758] is used.  In\
    \ this case,\n      the lifetime is provided in pr_value.\n   pr_value:  The meaning\
    \ of this field depends on the PR-SCTP policy\n      specified by the pr_policy\
    \ field.  It is ignored when\n      SCTP_PR_SCTP_NONE is specified.  In the case\
    \ of SCTP_PR_SCTP_TTL,\n      the lifetime in milliseconds is specified.\n   An\
    \ sctp_prinfo item always corresponds to the data in msg_iov.\n"
- title: 5.3.8.  SCTP AUTH Information Structure (SCTP_AUTHINFO)
  contents:
  - "5.3.8.  SCTP AUTH Information Structure (SCTP_AUTHINFO)\n   This cmsghdr structure\
    \ specifies SCTP options for sendmsg().\n          +--------------+---------------+----------------------+\n\
    \          | cmsg_level   | cmsg_type     | cmsg_data[]          |\n         \
    \ +--------------+---------------+----------------------+\n          | IPPROTO_SCTP\
    \ | SCTP_AUTHINFO | struct sctp_authinfo |\n          +--------------+---------------+----------------------+\n\
    \   The sctp_authinfo structure is defined below:\n   struct sctp_authinfo {\n\
    \     uint16_t auth_keynumber;\n   };\n   auth_keynumber:  This specifies the\
    \ shared key identifier used for\n      sending the user message.\n   An sctp_authinfo\
    \ item always corresponds to the data in msg_iov.\n   Please note that the SCTP\
    \ implementation must not bundle user\n   messages that need to be authenticated\
    \ using different shared key\n   identifiers.\n"
- title: 5.3.9.  SCTP Destination IPv4 Address Structure (SCTP_DSTADDRV4)
  contents:
  - "5.3.9.  SCTP Destination IPv4 Address Structure (SCTP_DSTADDRV4)\n   This cmsghdr\
    \ structure specifies SCTP options for sendmsg().\n            +--------------+----------------+----------------+\n\
    \            | cmsg_level   | cmsg_type      | cmsg_data[]    |\n            +--------------+----------------+----------------+\n\
    \            | IPPROTO_SCTP | SCTP_DSTADDRV4 | struct in_addr |\n            +--------------+----------------+----------------+\n\
    \   This ancillary data can be used to provide more than one destination\n   address\
    \ to sendmsg().  It can be used to implement sctp_sendv() using\n   sendmsg().\n"
- title: 5.3.10.  SCTP Destination IPv6 Address Structure (SCTP_DSTADDRV6)
  contents:
  - "5.3.10.  SCTP Destination IPv6 Address Structure (SCTP_DSTADDRV6)\n   This cmsghdr\
    \ structure specifies SCTP options for sendmsg().\n            +--------------+----------------+-----------------+\n\
    \            | cmsg_level   | cmsg_type      | cmsg_data[]     |\n           \
    \ +--------------+----------------+-----------------+\n            | IPPROTO_SCTP\
    \ | SCTP_DSTADDRV6 | struct in6_addr |\n            +--------------+----------------+-----------------+\n\
    \   This ancillary data can be used to provide more than one destination\n   address\
    \ to sendmsg().  It can be used to implement sctp_sendv() using\n   sendmsg().\n"
- title: 6.  SCTP Events and Notifications
  contents:
  - "6.  SCTP Events and Notifications\n   An SCTP application may need to understand\
    \ and process events and\n   errors that happen on the SCTP stack.  These events\
    \ include network\n   status changes, association startups, remote operational\
    \ errors, and\n   undeliverable messages.  All of these can be essential for the\n\
    \   application.\n   When an SCTP application layer does a recvmsg(), the message\
    \ read is\n   normally a data message from a peer endpoint.  If the application\n\
    \   wishes to have the SCTP stack deliver notifications of non-data\n   events,\
    \ it sets the appropriate socket option for the notifications\n   it wants.  See\
    \ Section 6.2 for these socket options.  When a\n   notification arrives, recvmsg()\
    \ returns the notification in the\n   application-supplied data buffer via msg_iov,\
    \ and sets\n   MSG_NOTIFICATION in msg_flags.\n   This section details the notification\
    \ structures.  Every notification\n   structure carries some common fields that\
    \ provide general\n   information.\n   A recvmsg() call will return only one notification\
    \ at a time.  Just\n   as when reading normal data, it may return part of a notification\
    \ if\n   the msg_iov buffer is not large enough.  If a single read is not\n  \
    \ sufficient, msg_flags will have MSG_EOR clear.  The user must finish\n   reading\
    \ the notification before subsequent data can arrive.\n"
- title: 6.1.  SCTP Notification Structure
  contents:
  - "6.1.  SCTP Notification Structure\n   The notification structure is defined as\
    \ the union of all\n   notification types.\n   union sctp_notification {\n   \
    \  struct sctp_tlv {\n       uint16_t sn_type; /* Notification type. */\n    \
    \   uint16_t sn_flags;\n       uint32_t sn_length;\n     } sn_header;\n     struct\
    \ sctp_assoc_change sn_assoc_change;\n     struct sctp_paddr_change sn_paddr_change;\n\
    \     struct sctp_remote_error sn_remote_error;\n     struct sctp_send_failed\
    \ sn_send_failed;\n     struct sctp_shutdown_event sn_shutdown_event;\n     struct\
    \ sctp_adaptation_event sn_adaptation_event;\n     struct sctp_pdapi_event sn_pdapi_event;\n\
    \     struct sctp_authkey_event sn_auth_event;\n     struct sctp_sender_dry_event\
    \ sn_sender_dry_event;\n     struct sctp_send_failed_event sn_send_failed_event;\n\
    \   };\n   sn_type:  The following list describes the SCTP notification and\n\
    \      event types for the field sn_type.\n      SCTP_ASSOC_CHANGE:  This tag\
    \ indicates that an association has\n         either been opened or closed.  Refer\
    \ to Section 6.1.1 for\n         details.\n      SCTP_PEER_ADDR_CHANGE:  This\
    \ tag indicates that an address that is\n         part of an existing association\
    \ has experienced a change of\n         state (e.g., a failure or return to service\
    \ of the reachability\n         of an endpoint via a specific transport address).\
    \  Please see\n         Section 6.1.2 for data structure details.\n      SCTP_REMOTE_ERROR:\
    \  The attached error message is an Operation\n         Error message received\
    \ from the remote peer.  It includes the\n         complete TLV sent by the remote\
    \ endpoint.  See Section 6.1.3\n         for the detailed format.\n      SCTP_SEND_FAILED_EVENT:\
    \  The attached datagram could not be sent\n         to the remote endpoint. \
    \ This structure includes the original\n         SCTP_SNDINFO that was used in\
    \ sending this message; i.e., this\n         structure uses the sctp_sndinfo per\
    \ Section 6.1.11.\n      SCTP_SHUTDOWN_EVENT:  The peer has sent a SHUTDOWN. \
    \ No further\n         data should be sent on this socket.\n      SCTP_ADAPTATION_INDICATION:\
    \  This notification holds the peer's\n         indicated adaptation layer.  Please\
    \ see Section 6.1.6.\n      SCTP_PARTIAL_DELIVERY_EVENT:  This notification is\
    \ used to tell a\n         receiver that the partial delivery has been aborted.\
    \  This may\n         indicate that the association is about to be aborted.  Please\n\
    \         see Section 6.1.7.\n      SCTP_AUTHENTICATION_EVENT:  This notification\
    \ is used to tell a\n         receiver that either an error occurred on authentication,\
    \ or a\n         new key was made active.  See Section 6.1.8.\n      SCTP_SENDER_DRY_EVENT:\
    \  This notification is used to inform the\n         application that the sender\
    \ has no more user data queued for\n         transmission or retransmission. \
    \ See Section 6.1.9.\n   sn_flags:  These are notification-specific flags.\n \
    \  sn_length:  This is the length of the whole sctp_notification\n      structure,\
    \ including the sn_type, sn_flags, and sn_length fields.\n"
- title: 6.1.1.  SCTP_ASSOC_CHANGE
  contents:
  - "6.1.1.  SCTP_ASSOC_CHANGE\n   Communication notifications inform the application\
    \ that an SCTP\n   association has either begun or ended.  The identifier for\
    \ a new\n   association is provided by this notification.  The notification\n\
    \   information has the following format:\n   struct sctp_assoc_change {\n   \
    \  uint16_t sac_type;\n     uint16_t sac_flags;\n     uint32_t sac_length;\n \
    \    uint16_t sac_state;\n     uint16_t sac_error;\n     uint16_t sac_outbound_streams;\n\
    \     uint16_t sac_inbound_streams;\n     sctp_assoc_t sac_assoc_id;\n     uint8_t\
    \  sac_info[];\n   };\n   sac_type:  This field should be set to SCTP_ASSOC_CHANGE.\n\
    \   sac_flags:  This field is currently unused.\n   sac_length:  This field is\
    \ the total length of the notification data,\n      including the notification\
    \ header.\n   sac_state:  This field holds one of a number of values that\n  \
    \    communicate the event that happened to the association.  These\n      values\
    \ include\n      SCTP_COMM_UP:  A new association is now ready, and data may be\n\
    \         exchanged with this peer.  When an association has been\n         established\
    \ successfully, this notification should be the\n         first one.\n      SCTP_COMM_LOST:\
    \  The association has failed.  The association is\n         now in the closed\
    \ state.  If SEND_FAILED notifications are\n         turned on, an SCTP_COMM_LOST\
    \ is accompanied by a series of\n         SCTP_SEND_FAILED_EVENT events, one for\
    \ each outstanding\n         message.\n      SCTP_RESTART:  SCTP has detected\
    \ that the peer has restarted.\n      SCTP_SHUTDOWN_COMP:  The association has\
    \ gracefully closed.\n      SCTP_CANT_STR_ASSOC:  The association setup failed.\
    \  If\n         non-blocking mode is set and data was sent (on a one-to-many\n\
    \         style socket), an SCTP_CANT_STR_ASSOC is accompanied by a\n        \
    \ series of SCTP_SEND_FAILED_EVENT events, one for each\n         outstanding\
    \ message.\n   sac_error:  If the state was reached due to an error condition\
    \ (e.g.,\n      SCTP_COMM_LOST), any relevant error information is available in\n\
    \      this field.  This corresponds to the protocol error codes defined\n   \
    \   in [RFC4960].\n   sac_outbound_streams and sac_inbound_streams:  The maximum\
    \ number of\n      streams allowed in each direction is available in\n      sac_outbound_streams\
    \ and sac_inbound streams.\n   sac_assoc_id:  The sac_assoc_id field holds the\
    \ identifier for the\n      association.  All notifications for a given association\
    \ have the\n      same association identifier.  For a one-to-one style socket,\
    \ this\n      field is ignored.\n   sac_info:  If sac_state is SCTP_COMM_LOST\
    \ and an ABORT chunk was\n      received for this association, sac_info[] contains\
    \ the complete\n      ABORT chunk as defined in Section 3.3.7 of the SCTP specification\n\
    \      [RFC4960].  If sac_state is SCTP_COMM_UP or SCTP_RESTART, sac_info\n  \
    \    may contain an array of uint8_t describing the features that the\n      current\
    \ association supports.  Features may include\n      SCTP_ASSOC_SUPPORTS_PR: \
    \ Both endpoints support the protocol\n         extension described in [RFC3758].\n\
    \      SCTP_ASSOC_SUPPORTS_AUTH:  Both endpoints support the protocol\n      \
    \   extension described in [RFC4895].\n      SCTP_ASSOC_SUPPORTS_ASCONF:  Both\
    \ endpoints support the protocol\n         extension described in [RFC5061].\n\
    \      SCTP_ASSOC_SUPPORTS_MULTIBUF:  For a one-to-many style socket, the\n  \
    \       local endpoints use separate send and/or receive buffers for\n       \
    \  each SCTP association.\n"
- title: 6.1.2.  SCTP_PEER_ADDR_CHANGE
  contents:
  - "6.1.2.  SCTP_PEER_ADDR_CHANGE\n   When a destination address of a multi-homed\
    \ peer encounters a state\n   change, a peer address change event is sent.  The\
    \ notification has\n   the following format:\n   struct sctp_paddr_change {\n\
    \     uint16_t spc_type;\n     uint16_t spc_flags;\n     uint32_t spc_length;\n\
    \     struct sockaddr_storage spc_aaddr;\n     uint32_t spc_state;\n     uint32_t\
    \ spc_error;\n     sctp_assoc_t spc_assoc_id;\n   }\n   spc_type:  This field\
    \ should be set to SCTP_PEER_ADDR_CHANGE.\n   spc_flags:  This field is currently\
    \ unused.\n   spc_length:  This field is the total length of the notification\
    \ data,\n      including the notification header.\n   spc_aaddr:  The affected\
    \ address field holds the remote peer's\n      address that is encountering the\
    \ change of state.\n   spc_state:  This field holds one of a number of values\
    \ that\n      communicate the event that happened to the address.  They include\n\
    \      SCTP_ADDR_AVAILABLE:  This address is now reachable.  This\n         notification\
    \ is provided whenever an address becomes reachable.\n      SCTP_ADDR_UNREACHABLE:\
    \  The address specified can no longer be\n         reached.  Any data sent to\
    \ this address is rerouted to an\n         alternate until this address becomes\
    \ reachable.  This\n         notification is provided whenever an address becomes\n\
    \         unreachable.\n      SCTP_ADDR_REMOVED:  The address is no longer part\
    \ of the\n         association.\n      SCTP_ADDR_ADDED:  The address is now part\
    \ of the association.\n      SCTP_ADDR_MADE_PRIM:  This address has now been made\
    \ the primary\n         destination address.  This notification is provided whenever\
    \ an\n         address is made primary.\n   spc_error:  If the state was reached\
    \ due to any error condition\n      (e.g., SCTP_ADDR_UNREACHABLE), any relevant\
    \ error information is\n      available in this field.\n   spc_assoc_id:  The\
    \ spc_assoc_id field holds the identifier for the\n      association.  All notifications\
    \ for a given association have the\n      same association identifier.  For a\
    \ one-to-one style socket, this\n      field is ignored.\n"
- title: 6.1.3.  SCTP_REMOTE_ERROR
  contents:
  - "6.1.3.  SCTP_REMOTE_ERROR\n   A remote peer may send an Operation Error message\
    \ to its peer.  This\n   message indicates a variety of error conditions on an\
    \ association.\n   The entire ERROR chunk as it appears on the wire is included\
    \ in an\n   SCTP_REMOTE_ERROR event.  Please refer to the SCTP specification\n\
    \   [RFC4960] and any extensions for a list of possible error formats.\n   An\
    \ SCTP error notification has the following format:\n   struct sctp_remote_error\
    \ {\n     uint16_t sre_type;\n     uint16_t sre_flags;\n     uint32_t sre_length;\n\
    \     uint16_t sre_error;\n     sctp_assoc_t sre_assoc_id;\n     uint8_t  sre_data[];\n\
    \   };\n   sre_type:  This field should be set to SCTP_REMOTE_ERROR.\n   sre_flags:\
    \  This field is currently unused.\n   sre_length:  This field is the total length\
    \ of the notification data,\n      including the notification header and the contents\
    \ of sre_data.\n   sre_error:  This value represents one of the Operation Error\
    \ causes\n      defined in the SCTP specification [RFC4960], in network byte\n\
    \      order.\n   sre_assoc_id:  The sre_assoc_id field holds the identifier for\
    \ the\n      association.  All notifications for a given association have the\n\
    \      same association identifier.  For a one-to-one style socket, this\n   \
    \   field is ignored.\n   sre_data:  This contains the ERROR chunk as defined\
    \ in Section 3.3.10\n      of the SCTP specification [RFC4960].\n"
- title: 6.1.4.  SCTP_SEND_FAILED - DEPRECATED
  contents:
  - "6.1.4.  SCTP_SEND_FAILED - DEPRECATED\n   Please note that this notification\
    \ is deprecated.  Use\n   SCTP_SEND_FAILED_EVENT instead.\n   If SCTP cannot deliver\
    \ a message, it can return back the message as a\n   notification if the SCTP_SEND_FAILED\
    \ event is enabled.  The\n   notification has the following format:\n   struct\
    \ sctp_send_failed {\n     uint16_t ssf_type;\n     uint16_t ssf_flags;\n    \
    \ uint32_t ssf_length;\n     uint32_t ssf_error;\n     struct sctp_sndrcvinfo\
    \ ssf_info;\n     sctp_assoc_t ssf_assoc_id;\n     uint8_t  ssf_data[];\n   };\n\
    \   ssf_type:  This field should be set to SCTP_SEND_FAILED.\n   ssf_flags:  The\
    \ flag value will take one of the following values:\n      SCTP_DATA_UNSENT: \
    \ This value indicates that the data was never\n         put on the wire.\n  \
    \    SCTP_DATA_SENT:  This value indicates that the data was put on the\n    \
    \     wire.  Note that this does not necessarily mean that the data\n        \
    \ was (or was not) successfully delivered.\n   ssf_length:  This field is the\
    \ total length of the notification data,\n      including the notification header\
    \ and the payload in ssf_data.\n   ssf_error:  This value represents the reason\
    \ why the send failed, and\n      if set, will be an SCTP protocol error code\
    \ as defined in\n      Section 3.3.10 of [RFC4960].\n   ssf_info:  This field\
    \ includes the ancillary data (struct\n      sctp_sndrcvinfo) used to send the\
    \ undelivered message.  Regardless\n      of whether ancillary data is used or\
    \ not, the ssf_info.sinfo_flags\n      field indicates whether the complete message\
    \ or only part of the\n      message is returned in ssf_data.  If only part of\
    \ the message is\n      returned, it means that the part that is not present has\
    \ been sent\n      successfully to the peer.\n      If the complete message cannot\
    \ be sent, the SCTP_DATA_NOT_FRAG\n      flag is set in ssf_info.sinfo_flags.\
    \  If the first part of the\n      message is sent successfully, SCTP_DATA_LAST_FRAG\
    \ is set.  This\n      means that the tail end of the message is returned in ssf_data.\n\
    \   ssf_assoc_id:  The ssf_assoc_id field, ssf_assoc_id, holds the\n      identifier\
    \ for the association.  All notifications for a given\n      association have\
    \ the same association identifier.  For a one-to-\n      one style socket, this\
    \ field is ignored.\n   ssf_data:  The undelivered message or part of the undelivered\
    \ message\n      will be present in the ssf_data field.  Note that the\n     \
    \ ssf_info.sinfo_flags field as noted above should be used to\n      determine\
    \ whether a complete message or just a piece of the\n      message is present.\
    \  Note that only user data is present in this\n      field; any chunk headers\
    \ or SCTP common headers must be removed by\n      the SCTP stack.\n"
- title: 6.1.5.  SCTP_SHUTDOWN_EVENT
  contents:
  - "6.1.5.  SCTP_SHUTDOWN_EVENT\n   When a peer sends a SHUTDOWN, SCTP delivers this\
    \ notification to\n   inform the application that it should cease sending data.\n\
    \       struct sctp_shutdown_event {\n           uint16_t sse_type;\n        \
    \   uint16_t sse_flags;\n           uint32_t sse_length;\n           sctp_assoc_t\
    \ sse_assoc_id;\n       };\n   sse_type:  This field should be set to SCTP_SHUTDOWN_EVENT.\n\
    \   sse_flags:  This field is currently unused.\n   sse_length:  This field is\
    \ the total length of the notification data,\n      including the notification\
    \ header.  It will generally be\n      sizeof(struct sctp_shutdown_event).\n \
    \  sse_assoc_id:  The sse_assoc_id field holds the identifier for the\n      association.\
    \  All notifications for a given association have the\n      same association\
    \ identifier.  For a one-to-one style socket, this\n      field is ignored.\n"
- title: 6.1.6.  SCTP_ADAPTATION_INDICATION
  contents:
  - "6.1.6.  SCTP_ADAPTATION_INDICATION\n   When a peer sends an Adaptation Layer\
    \ Indication parameter as\n   described in [RFC5061], SCTP delivers this notification\
    \ to inform the\n   application about the peer's adaptation layer indication.\n\
    \   struct sctp_adaptation_event {\n     uint16_t sai_type;\n     uint16_t sai_flags;\n\
    \     uint32_t sai_length;\n     uint32_t sai_adaptation_ind;\n     sctp_assoc_t\
    \ sai_assoc_id;\n   };\n   sai_type:  This field should be set to SCTP_ADAPTATION_INDICATION.\n\
    \   sai_flags:  This field is currently unused.\n   sai_length:  This field is\
    \ the total length of the notification data,\n      including the notification\
    \ header.  It will generally be\n      sizeof(struct sctp_adaptation_event).\n\
    \   sai_adaptation_ind:  This field holds the bit array sent by the peer\n   \
    \   in the Adaptation Layer Indication parameter.\n   sai_assoc_id:  The sai_assoc_id\
    \ field holds the identifier for the\n      association.  All notifications for\
    \ a given association have the\n      same association identifier.  For a one-to-one\
    \ style socket, this\n      field is ignored.\n"
- title: 6.1.7.  SCTP_PARTIAL_DELIVERY_EVENT
  contents:
  - "6.1.7.  SCTP_PARTIAL_DELIVERY_EVENT\n   When a receiver is engaged in a partial\
    \ delivery of a message, this\n   notification will be used to indicate various\
    \ events.\n   struct sctp_pdapi_event {\n     uint16_t pdapi_type;\n     uint16_t\
    \ pdapi_flags;\n     uint32_t pdapi_length;\n     uint32_t pdapi_indication;\n\
    \     uint32_t pdapi_stream;\n     uint32_t pdapi_seq;\n     sctp_assoc_t pdapi_assoc_id;\n\
    \   };\n   pdapi_type:  This field should be set to SCTP_PARTIAL_DELIVERY_EVENT.\n\
    \   pdapi_flags:  This field is currently unused.\n   pdapi_length:  This field\
    \ is the total length of the notification\n      data, including the notification\
    \ header.  It will generally be\n      sizeof(struct sctp_pdapi_event).\n   pdapi_indication:\
    \  This field holds the indication being sent to the\n      application.  Currently,\
    \ there is only one defined value:\n      SCTP_PARTIAL_DELIVERY_ABORTED:  This\
    \ indicates that the partial\n         delivery of a user message has been aborted.\
    \  This happens, for\n         example, if an association is aborted while a partial\
    \ delivery\n         is going on or the user message gets abandoned using PR-SCTP\n\
    \         while the partial delivery of this message is going on.\n   pdapi_stream:\
    \  This field holds the stream on which the partial\n      delivery event happened.\n\
    \   pdapi_seq:  This field holds the stream sequence number that was\n      being\
    \ partially delivered.\n   pdapi_assoc_id:  The pdapi_assoc_id field holds the\
    \ identifier for\n      the association.  All notifications for a given association\
    \ have\n      the same association identifier.  For a one-to-one style socket,\n\
    \      this field is ignored.\n"
- title: 6.1.8.  SCTP_AUTHENTICATION_EVENT
  contents:
  - "6.1.8.  SCTP_AUTHENTICATION_EVENT\n   [RFC4895] defines an extension to authenticate\
    \ SCTP messages.  The\n   following notification is used to report different events\
    \ relating to\n   the use of this extension.\n   struct sctp_authkey_event {\n\
    \     uint16_t auth_type;\n     uint16_t auth_flags;\n     uint32_t auth_length;\n\
    \     uint16_t auth_keynumber;\n     uint32_t auth_indication;\n     sctp_assoc_t\
    \ auth_assoc_id;\n   };\n   auth_type:  This field should be set to SCTP_AUTHENTICATION_EVENT.\n\
    \   auth_flags:  This field is currently unused.\n   auth_length:  This field\
    \ is the total length of the notification\n      data, including the notification\
    \ header.  It will generally be\n      sizeof(struct sctp_authkey_event).\n  \
    \ auth_keynumber:  This field holds the key number for the affected key\n    \
    \  indicated in the event (depends on auth_indication).\n   auth_indication: \
    \ This field holds the error or indication being\n      reported.  The following\
    \ values are currently defined:\n      SCTP_AUTH_NEW_KEY:  This report indicates\
    \ that a new key has been\n         made active (used for the first time by the\
    \ peer) and is now\n         the active key.  The auth_keynumber field holds the\
    \ user-\n         specified key number.\n      SCTP_AUTH_NO_AUTH:  This report\
    \ indicates that the peer does not\n         support SCTP authentication as defined\
    \ in [RFC4895].\n      SCTP_AUTH_FREE_KEY:  This report indicates that the SCTP\n\
    \         implementation will no longer use the key identifier specified\n   \
    \      in auth_keynumber.\n   auth_assoc_id:  The auth_assoc_id field holds the\
    \ identifier for the\n      association.  All notifications for a given association\
    \ have the\n      same association identifier.  For a one-to-one style socket,\
    \ this\n      field is ignored.\n"
- title: 6.1.9.  SCTP_SENDER_DRY_EVENT
  contents:
  - "6.1.9.  SCTP_SENDER_DRY_EVENT\n   When the SCTP stack has no more user data to\
    \ send or retransmit, this\n   notification is given to the user.  Also, at the\
    \ time when a user app\n   subscribes to this event, if there is no data to be\
    \ sent or\n   retransmit, the stack will immediately send up this notification.\n\
    \   struct sctp_sender_dry_event {\n     uint16_t sender_dry_type;\n     uint16_t\
    \ sender_dry_flags;\n     uint32_t sender_dry_length;\n     sctp_assoc_t sender_dry_assoc_id;\n\
    \   };\n   sender_dry_type:  This field should be set to SCTP_SENDER_DRY_EVENT.\n\
    \   sender_dry_flags:  This field is currently unused.\n   sender_dry_length:\
    \  This field is the total length of the\n      notification data, including the\
    \ notification header.  It will\n      generally be sizeof(struct sctp_sender_dry_event).\n\
    \   sender_dry_assoc_id:  The sender_dry_assoc_id field holds the\n      identifier\
    \ for the association.  All notifications for a given\n      association have\
    \ the same association identifier.  For a one-to-\n      one style socket, this\
    \ field is ignored.\n"
- title: 6.1.10.  SCTP_NOTIFICATIONS_STOPPED_EVENT
  contents:
  - "6.1.10.  SCTP_NOTIFICATIONS_STOPPED_EVENT\n   SCTP notifications, when subscribed\
    \ to, are reliable.  They are\n   always delivered as long as there is space in\
    \ the socket receive\n   buffer.  However, if an implementation experiences a\
    \ notification\n   storm, it may run out of socket buffer space.  When this occurs,\
    \ it\n   may wish to disable notifications.  If the implementation chooses to\n\
    \   do this, it will append a final notification\n   SCTP_NOTIFICATIONS_STOPPED_EVENT.\
    \  This notification is a union\n   sctp_notification, where only the sctp_tlv\
    \ structure (see the union\n   above) is used.  It only contains this type in\
    \ the sn_type field, the\n   sn_length field set to the size of an sctp_tlv structure,\
    \ and the\n   sn_flags set to 0.  If an application receives this notification,\
    \ it\n   will need to re-subscribe to any notifications of interest to it,\n \
    \  except for the sctp_data_io_event (note that SCTP_EVENTS is\n   deprecated).\n\
    \   An endpoint is automatically subscribed to this event as soon as it\n   is\
    \ subscribed to any event other than data io events.\n"
- title: 6.1.11.  SCTP_SEND_FAILED_EVENT
  contents:
  - "6.1.11.  SCTP_SEND_FAILED_EVENT\n   If SCTP cannot deliver a message, it can\
    \ return back the message as a\n   notification if the SCTP_SEND_FAILED_EVENT\
    \ event is enabled.  The\n   notification has the following format:\n   struct\
    \ sctp_send_failed_event {\n     uint16_t ssfe_type;\n     uint16_t ssfe_flags;\n\
    \     uint32_t ssfe_length;\n     uint32_t ssfe_error;\n     struct sctp_sndinfo\
    \ ssfe_info;\n     sctp_assoc_t ssfe_assoc_id;\n     uint8_t  ssfe_data[];\n \
    \  };\n   ssfe_type:  This field should be set to SCTP_SEND_FAILED_EVENT.\n  \
    \ ssfe_flags:  The flag value will take one of the following values:\n      SCTP_DATA_UNSENT:\
    \  This value indicates that the data was never\n         put on the wire.\n \
    \     SCTP_DATA_SENT:  This value indicates that the data was put on the\n   \
    \      wire.  Note that this does not necessarily mean that the data\n       \
    \  was (or was not) successfully delivered.\n   ssfe_length:  This field is the\
    \ total length of the notification\n      data, including the notification header\
    \ and the payload in\n      ssf_data.\n   ssfe_error:  This value represents the\
    \ reason why the send failed,\n      and if set, will be an SCTP protocol error\
    \ code as defined in\n      Section 3.3.10 of [RFC4960].\n   ssfe_info:  This\
    \ field includes the ancillary data (struct\n      sctp_sndinfo) used to send\
    \ the undelivered message.  Regardless of\n      whether ancillary data is used\
    \ or not, the ssfe_info.sinfo_flags\n      field indicates whether the complete\
    \ message or only part of the\n      message is returned in ssf_data.  If only\
    \ part of the message is\n      returned, it means that the part that is not present\
    \ has been sent\n      successfully to the peer.\n      If the complete message\
    \ cannot be sent, the SCTP_DATA_NOT_FRAG\n      flag is set in ssfe_info.sinfo_flags.\
    \  If the first part of the\n      message is sent successfully, SCTP_DATA_LAST_FRAG\
    \ is set.  This\n      means that the tail end of the message is returned in ssf_data.\n\
    \   ssfe_assoc_id:  The ssfe_assoc_id field, ssf_assoc_id, holds the\n      identifier\
    \ for the association.  All notifications for a given\n      association have\
    \ the same association identifier.  For a one-to-\n      one style socket, this\
    \ field is ignored.\n   ssfe_data:  The undelivered message or part of the undelivered\n\
    \      message will be present in the ssf_data field.  Note that the\n      ssf_info.sinfo_flags\
    \ field as noted above should be used to\n      determine whether a complete message\
    \ or just a piece of the\n      message is present.  Note that only user data\
    \ is present in this\n      field; any chunk headers or SCTP common headers must\
    \ be removed by\n      the SCTP stack.\n"
- title: 6.2.  Notification Interest Options
  contents:
  - '6.2.  Notification Interest Options

    '
- title: 6.2.1.  SCTP_EVENTS Option - DEPRECATED
  contents:
  - "6.2.1.  SCTP_EVENTS Option - DEPRECATED\n   Please note that this option is deprecated.\
    \  Use the SCTP_EVENT\n   option described in Section 6.2.2 instead.\n   To receive\
    \ SCTP event notifications, an application registers its\n   interest by setting\
    \ the SCTP_EVENTS socket option.  The application\n   then uses recvmsg() to retrieve\
    \ notifications.  A notification is\n   stored in the data part (msg_iov) of the\
    \ msghdr structure.  The\n   socket option uses the following structure:\n   struct\
    \ sctp_event_subscribe {\n     uint8_t sctp_data_io_event;\n     uint8_t sctp_association_event;\n\
    \     uint8_t sctp_address_event;\n     uint8_t sctp_send_failure_event;\n   \
    \  uint8_t sctp_peer_error_event;\n     uint8_t sctp_shutdown_event;\n     uint8_t\
    \ sctp_partial_delivery_event;\n     uint8_t sctp_adaptation_layer_event;\n  \
    \   uint8_t sctp_authentication_event;\n     uint8_t sctp_sender_dry_event;\n\
    \   };\n   sctp_data_io_event:  Setting this flag to 1 will cause the reception\n\
    \      of SCTP_SNDRCV information on a per-message basis.  The\n      application\
    \ will need to use the recvmsg() interface so that it\n      can receive the event\
    \ information contained in the msg_control\n      field.  Setting the flag to\
    \ 0 will disable the reception of the\n      message control information.  Note\
    \ that this flag is not really a\n      notification and is stored in the ancillary\
    \ data (msg_control),\n      not in the data part (msg_iov).\n   sctp_association_event:\
    \  Setting this flag to 1 will enable the\n      reception of association event\
    \ notifications.  Setting the flag to\n      0 will disable association event\
    \ notifications.\n   sctp_address_event:  Setting this flag to 1 will enable the\
    \ reception\n      of address event notifications.  Setting the flag to 0 will\n\
    \      disable address event notifications.\n   sctp_send_failure_event:  Setting\
    \ this flag to 1 will enable the\n      reception of send failure event notifications.\
    \  Setting the flag\n      to 0 will disable send failure event notifications.\n\
    \   sctp_peer_error_event:  Setting this flag to 1 will enable the\n      reception\
    \ of peer error event notifications.  Setting the flag to\n      0 will disable\
    \ peer error event notifications.\n   sctp_shutdown_event:  Setting this flag\
    \ to 1 will enable the\n      reception of shutdown event notifications.  Setting\
    \ the flag to 0\n      will disable shutdown event notifications.\n   sctp_partial_delivery_event:\
    \  Setting this flag to 1 will enable the\n      reception of partial delivery\
    \ event notifications.  Setting the\n      flag to 0 will disable partial delivery\
    \ event notifications.\n   sctp_adaptation_layer_event:  Setting this flag to\
    \ 1 will enable the\n      reception of adaptation layer event notifications.\
    \  Setting the\n      flag to 0 will disable adaptation layer event notifications.\n\
    \   sctp_authentication_event:  Setting this flag to 1 will enable the\n     \
    \ reception of authentication layer event notifications.  Setting\n      the flag\
    \ to 0 will disable authentication layer event\n      notifications.\n   sctp_sender_dry_event:\
    \  Setting this flag to 1 will enable the\n      reception of sender dry event\
    \ notifications.  Setting the flag to\n      0 will disable sender dry event notifications.\n\
    \   An example where an application would like to receive data_io_events\n   and\
    \ association_events but no others would be as follows:\n   {\n     struct sctp_event_subscribe\
    \ events;\n     memset(&events, 0, sizeof(events));\n     events.sctp_data_io_event\
    \ = 1;\n     events.sctp_association_event = 1;\n     setsockopt(sd, IPPROTO_SCTP,\
    \ SCTP_EVENTS, &events, sizeof(events));\n   }\n   Note that for one-to-many style\
    \ SCTP sockets, the caller of recvmsg()\n   receives ancillary data and notifications\
    \ for all associations bound\n   to the file descriptor.  For one-to-one style\
    \ SCTP sockets, the\n   caller receives ancillary data and notifications only\
    \ for the single\n   association bound to the file descriptor.\n   By default,\
    \ both the one-to-one style and the one-to-many style\n   socket do not subscribe\
    \ to any notification.\n"
- title: 6.2.2.  SCTP_EVENT Option
  contents:
  - "6.2.2.  SCTP_EVENT Option\n   The SCTP_EVENTS socket option has one issue for\
    \ future compatibility.\n   As new features are added, the structure (sctp_event_subscribe)\
    \ must\n   be expanded.  This can cause an application binary interface (ABI)\n\
    \   issue unless an implementation has added padding at the end of the\n   structure.\
    \  To avoid this problem, SCTP_EVENTS has been deprecated\n   and a new socket\
    \ option SCTP_EVENT has taken its place.  The option\n   is used with the following\
    \ structure:\n   struct sctp_event {\n           sctp_assoc_t se_assoc_id;\n \
    \          uint16_t     se_type;\n           uint8_t      se_on;\n   };\n   se_assoc_id:\
    \  The se_assoc_id field is ignored for one-to-one style\n      sockets.  For\
    \ one-to-many style sockets, this field can be a\n      particular association\
    \ identifier or SCTP_{FUTURE|CURRENT|\n      ALL}_ASSOC.\n   se_type:  The se_type\
    \ field can be filled with any value that would\n      show up in the respective\
    \ sn_type field (in the sctp_tlv structure\n      of the notification).\n   se_on:\
    \  The se_on field is set to 1 to turn on an event and set to 0\n      to turn\
    \ off an event.\n   To use this option, the user fills in this structure and then\
    \ calls\n   setsockopt() to turn on or off an individual event.  The following\
    \ is\n   an example use of this option:\n   {\n     struct sctp_event event;\n\
    \     memset(&event, 0, sizeof(event));\n     event.se_assoc_id = SCTP_FUTURE_ASSOC;\n\
    \     event.se_type = SCTP_SENDER_DRY_EVENT;\n     event.se_on = 1;\n     setsockopt(sd,\
    \ IPPROTO_SCTP, SCTP_EVENT, &event, sizeof(event));\n   }\n   By default, both\
    \ the one-to-one style and the one-to-many style\n   socket do not subscribe to\
    \ any notification.\n"
- title: 7.  Common Operations for Both Styles
  contents:
  - '7.  Common Operations for Both Styles

    '
- title: 7.1.  send(), recv(), sendto(), and recvfrom()
  contents:
  - "7.1.  send(), recv(), sendto(), and recvfrom()\n   Applications can use send()\
    \ and sendto() to transmit data to the peer\n   of an SCTP endpoint.  recv() and\
    \ recvfrom() can be used to receive\n   data from the peer.\n   The function prototypes\
    \ are\n   ssize_t send(int sd,\n                const void *msg,\n           \
    \     size_t len,\n                int flags);\n   ssize_t sendto(int sd,\n  \
    \                const void *msg,\n                  size_t len,\n           \
    \       int flags,\n                  const struct sockaddr *to,\n           \
    \       socklen_t tolen);\n   ssize_t recv(int sd,\n                void *buf,\n\
    \                size_t len,\n                int flags);\n   ssize_t recvfrom(int\
    \ sd,\n                    void *buf,\n                    size_t len,\n     \
    \               int flags,\n                    struct sockaddr *from,\n     \
    \               socklen_t *fromlen);\n   and the arguments are\n   sd:  The socket\
    \ descriptor of an SCTP endpoint.\n   msg:  The message to be sent.\n   len: \
    \ The size of the message or the size of the buffer.\n   to:  One of the peer\
    \ addresses of the association to be used to send\n      the message.\n   tolen:\
    \  The size of the address.\n   buf:  The buffer to store a received message.\n\
    \   from:  The buffer to store the peer address used to send the received\n  \
    \    message.\n   fromlen:  The size of the from address.\n   flags:  (described\
    \ below).\n   These calls give access to only basic SCTP protocol features.  If\n\
    \   either peer in the association uses multiple streams, or sends\n   unordered\
    \ data, these calls will usually be inadequate and may\n   deliver the data in\
    \ unpredictable ways.\n   SCTP has the concept of multiple streams in one association.\
    \  The\n   above calls do not allow the caller to specify on which stream a\n\
    \   message should be sent.  The system uses stream 0 as the default\n   stream\
    \ for send() and sendto().  recv() and recvfrom() return data\n   from any stream,\
    \ but the caller cannot distinguish the different\n   streams.  This may result\
    \ in data seeming to arrive out of order.\n   Similarly, if a DATA chunk is sent\
    \ unordered, recv() and recvfrom()\n   provide no indication.\n   SCTP is message\
    \ based.  The msg buffer above in send() and sendto()\n   is considered to be\
    \ a single message.  This means that if the caller\n   wants to send a message\
    \ that is composed by several buffers, the\n   caller needs to combine them before\
    \ calling send() or sendto().\n   Alternately, the caller can use sendmsg() to\
    \ do that without\n   combining them.  Sending a message using send() or sendto()\
    \ is atomic\n   unless explicit EOR marking is enabled on the socket specified\
    \ by sd.\n   Using sendto() on a non-connected one-to-one style socket for\n \
    \  implicit connection setup may or may not work, depending on the SCTP\n   implementation.\
    \  recv() and recvfrom() cannot distinguish message\n   boundaries (i.e., there\
    \ is no way to observe the MSG_EOR flag to\n   detect partial delivery).\n   When\
    \ receiving, if the buffer supplied is not large enough to hold a\n   complete\
    \ message, the receive call acts like a stream socket and\n   returns as much\
    \ data as will fit in the buffer.\n   Note that the send() and recv() calls may\
    \ not be used for a one-to-\n   many style socket.\n   Note that if an application\
    \ calls a send() or sendto() function with\n   no user data, the SCTP implementation\
    \ should reject the request with\n   an appropriate error message.  An implementation\
    \ is not allowed to\n   send a DATA chunk with no user data [RFC4960].\n"
- title: 7.2.  setsockopt() and getsockopt()
  contents:
  - "7.2.  setsockopt() and getsockopt()\n   Applications use setsockopt() and getsockopt()\
    \ to set or retrieve\n   socket options.  Socket options are used to change the\
    \ default\n   behavior of socket calls.  They are described in Section 8.\n  \
    \ The function prototypes are\n   int getsockopt(int sd,\n                  int\
    \ level,\n                  int optname,\n                  void *optval,\n  \
    \                socklen_t *optlen);\n   and\n   int setsockopt(int sd,\n    \
    \              int level,\n                  int optname,\n                  const\
    \ void *optval,\n                  socklen_t optlen);\n   and the arguments are\n\
    \   sd:  The socket descriptor.\n   level:  Set to IPPROTO_SCTP for all SCTP options.\n\
    \   optname:  The option name.\n   optval:  The buffer to store the value of the\
    \ option.\n   optlen:  The size of the buffer (or the length of the option\n \
    \     returned).\n   These functions return 0 on success and -1 in case of an\
    \ error.\n   All socket options set on a one-to-one style listening socket also\n\
    \   apply to all future accepted sockets.  For one-to-many style sockets,\n  \
    \ often a socket option will pass a structure that includes an assoc_id\n   field.\
    \  This field can be filled with the association identifier of a\n   particular\
    \ association and unless otherwise specified can be filled\n   with one of the\
    \ following constants:\n   SCTP_FUTURE_ASSOC:  Specifies that only future associations\
    \ created\n      after this socket option will be affected by this call.\n   SCTP_CURRENT_ASSOC:\
    \  Specifies that only currently existing\n      associations will be affected\
    \ by this call, and future\n      associations will still receive the previous\
    \ default value.\n   SCTP_ALL_ASSOC:  Specifies that all current and future associations\n\
    \      will be affected by this call.\n"
- title: 7.3.  read() and write()
  contents:
  - "7.3.  read() and write()\n   Applications can use read() and write() to receive\
    \ and send data from\n   and to a peer.  They have the same semantics as recv()\
    \ and send(),\n   except that the flags parameter cannot be used.\n"
- title: 7.4.  getsockname()
  contents:
  - "7.4.  getsockname()\n   Applications use getsockname() to retrieve the locally\
    \ bound socket\n   address of the specified socket.  This is especially useful\
    \ if the\n   caller let SCTP choose a local port.  This call is for single-homed\n\
    \   endpoints.  It does not work well with multi-homed endpoints.  See\n   Section\
    \ 9.5 for a multi-homed version of the call.\n   The function prototype is\n \
    \  int getsockname(int sd,\n                   struct sockaddr *address,\n   \
    \                socklen_t *len);\n   and the arguments are\n   sd:  The socket\
    \ descriptor to be queried.\n   address:  On return, one locally bound address\
    \ (chosen by the SCTP\n      stack) is stored in this buffer.  If the socket is\
    \ an IPv4 socket,\n      the address will be IPv4.  If the socket is an IPv6 socket,\
    \ the\n      address will be either an IPv6 or IPv4 address.\n   len:  The caller\
    \ should set the length of the address here.  On\n      return, this is set to\
    \ the length of the returned address.\n   getsockname() returns 0 on success and\
    \ -1 in case of an error.\n   If the actual length of the address is greater than\
    \ the length of the\n   supplied sockaddr structure, the stored address will be\
    \ truncated.\n   If the socket has not been bound to a local name, the value stored\
    \ in\n   the object pointed to by address is unspecified.\n"
- title: 7.5.  Implicit Association Setup
  contents:
  - "7.5.  Implicit Association Setup\n   The application can begin sending and receiving\
    \ data using the\n   sendmsg()/recvmsg() or sendto()/recvfrom() calls, without\
    \ going\n   through any explicit association setup procedures (i.e., no connect()\n\
    \   calls required).\n   Whenever sendmsg() or sendto() is called and the SCTP\
    \ stack at the\n   sender finds that no association exists between the sender\
    \ and the\n   intended receiver (identified by the address passed either in the\n\
    \   msg_name field of the msghdr structure in the sendmsg() call or the\n   dest_addr\
    \ field in the sendto() call), the SCTP stack will\n   automatically set up an\
    \ association to the intended receiver.\n   Upon successful association setup,\
    \ an SCTP_COMM_UP notification will\n   be dispatched to the socket at both the\
    \ sender and receiver side.\n   This notification can be read by the recvmsg()\
    \ system call (see\n   Section 3.1.4).\n   Note that if the SCTP stack at the\
    \ sender side supports bundling, the\n   first user message may be bundled with\
    \ the COOKIE ECHO message\n   [RFC4960].\n   When the SCTP stack sets up a new\
    \ association implicitly, the\n   SCTP_INIT type ancillary data may also be passed\
    \ along (see\n   Section 5.3.1 for details of the data structures) to change some\n\
    \   parameters used in setting up a new association.\n   If this information is\
    \ not present in the sendmsg() call, or if the\n   implicit association setup\
    \ is triggered by a sendto() call, the\n   default association initialization\
    \ parameters will be used.  These\n   default association parameters may be set\
    \ with respective\n   setsockopt() calls or be left to the system defaults.\n\
    \   Implicit association setup cannot be initiated by send() calls.\n"
- title: 8.  Socket Options
  contents:
  - "8.  Socket Options\n   The following subsection describes various SCTP-level\
    \ socket options\n   that are common to both styles.  SCTP associations can be\n\
    \   multi-homed.  Therefore, certain option parameters include a\n   sockaddr_storage\
    \ structure to select to which peer address the option\n   should be applied.\n\
    \   For the one-to-many style sockets, an sctp_assoc_t (association\n   identifier)\
    \ parameter is used to identify the association instance\n   that the operation\
    \ affects.  So it must be set when using this style.\n   For the one-to-one style\
    \ sockets and branched-off one-to-many style\n   sockets (see Section 9.2), this\
    \ association ID parameter is ignored.\n   Note that socket- or IP-level options\
    \ are set or retrieved per\n   socket.  This means that for one-to-many style\
    \ sockets, the options\n   will be applied to all associations (similar to using\
    \ SCTP_ALL_ASSOC\n   as the association identifier) belonging to the socket. \
    \ For the one-\n   to-one style, these options will be applied to all peer addresses\
    \ of\n   the association controlled by the socket.  Applications should be\n \
    \  careful in setting those options.\n   For some IP stacks, getsockopt() is read-only,\
    \ so a new interface\n   will be needed when information must be passed both into\
    \ and out of\n   the SCTP stack.  The syntax for sctp_opt_info() is\n   int sctp_opt_info(int\
    \ sd,\n                     sctp_assoc_t id,\n                     int opt,\n\
    \                     void *arg,\n                     socklen_t *size);\n   The\
    \ sctp_opt_info() call is a replacement for getsockopt() only and\n   will not\
    \ set any options associated with the specified socket.  A\n   setsockopt() call\
    \ must be used to set any writable option.\n   For one-to-many style sockets,\
    \ id specifies the association to query.\n   For one-to-one style sockets, id\
    \ is ignored.  For one-to-many style\n   sockets, any association identifier in\
    \ the structure provided as arg\n   is ignored, and id takes precedence.\n   Note\
    \ that SCTP_CURRENT_ASSOC and SCTP_ALL_ASSOC cannot be used with\n   sctp_opt_info()\
    \ or in getsockopt() calls.  Using them will result in\n   an error (returning\
    \ -1 and errno set to EINVAL).  SCTP_FUTURE_ASSOC\n   can be used to query information\
    \ for future associations.\n   The field opt specifies which SCTP socket option\
    \ to get.  It can get\n   any socket option currently supported that requests\
    \ information\n   (either read/write options or read-only) such as\n   SCTP_RTOINFO\n\
    \   SCTP_ASSOCINFO\n   SCTP_PRIMARY_ADDR\n   SCTP_PEER_ADDR_PARAMS\n   SCTP_DEFAULT_SEND_PARAM\n\
    \   SCTP_MAX_SEG\n   SCTP_AUTH_ACTIVE_KEY\n   SCTP_DELAYED_SACK\n   SCTP_MAX_BURST\n\
    \   SCTP_CONTEXT\n   SCTP_EVENT\n   SCTP_DEFAULT_SNDINFO\n   SCTP_DEFAULT_PRINFO\n\
    \   SCTP_STATUS\n   SCTP_GET_PEER_ADDR_INFO\n   SCTP_PEER_AUTH_CHUNKS\n   SCTP_LOCAL_AUTH_CHUNKS\n\
    \   The arg field is an option-specific structure buffer provided by the\n   caller.\
    \  See the rest of this section for more information on these\n   options and\
    \ option-specific structures.\n   sctp_opt_info() returns 0 on success, or on\
    \ failure returns -1 and\n   sets errno to the appropriate error code.\n"
- title: 8.1.  Read/Write Options
  contents:
  - '8.1.  Read/Write Options

    '
- title: 8.1.1.  Retransmission Timeout Parameters (SCTP_RTOINFO)
  contents:
  - "8.1.1.  Retransmission Timeout Parameters (SCTP_RTOINFO)\n   The protocol parameters\
    \ used to initialize and limit the\n   retransmission timeout (RTO) are tunable.\
    \  See [RFC4960] for more\n   information on how these parameters are used in\
    \ RTO calculation.\n   The following structure is used to access and modify these\n\
    \   parameters:\n   struct sctp_rtoinfo {\n     sctp_assoc_t srto_assoc_id;\n\
    \     uint32_t srto_initial;\n     uint32_t srto_max;\n     uint32_t srto_min;\n\
    \   };\n   srto_assoc_id:  This parameter is ignored for one-to-one style\n  \
    \    sockets.  For one-to-many style sockets, the application may fill\n     \
    \ in an association identifier or SCTP_FUTURE_ASSOC.  It is an error\n      to\
    \ use SCTP_{CURRENT|ALL}_ASSOC in srto_assoc_id.\n   srto_initial:  This parameter\
    \ contains the initial RTO value.\n   srto_max and srto_min:  These parameters\
    \ contain the maximum and\n      minimum bounds for all RTOs.\n   All times are\
    \ given in milliseconds.  A value of 0, when modifying\n   the parameters, indicates\
    \ that the current value should not be\n   changed.\n   To access or modify these\
    \ parameters, the application should call\n   getsockopt() or setsockopt(), respectively,\
    \ with the option name\n   SCTP_RTOINFO.\n"
- title: 8.1.2.  Association Parameters (SCTP_ASSOCINFO)
  contents:
  - "8.1.2.  Association Parameters (SCTP_ASSOCINFO)\n   This option is used to both\
    \ examine and set various association and\n   endpoint parameters.  See [RFC4960]\
    \ for more information on how these\n   parameters are used.\n   The following\
    \ structure is used to access and modify these\n   parameters:\n   struct sctp_assocparams\
    \ {\n     sctp_assoc_t sasoc_assoc_id;\n     uint16_t sasoc_asocmaxrxt;\n    \
    \ uint16_t sasoc_number_peer_destinations;\n     uint32_t sasoc_peer_rwnd;\n \
    \    uint32_t sasoc_local_rwnd;\n     uint32_t sasoc_cookie_life;\n   };\n   sasoc_assoc_id:\
    \  This parameter is ignored for one-to-one style\n      sockets.  For one-to-many\
    \ style sockets, the application may fill\n      in an association identifier\
    \ or SCTP_FUTURE_ASSOC.  It is an error\n      to use SCTP_{CURRENT|ALL}_ASSOC\
    \ in sasoc_assoc_id.\n   sasoc_asocmaxrxt:  This parameter contains the maximum\
    \ retransmission\n      attempts to make for the association.\n   sasoc_number_peer_destinations:\
    \  This parameter is the number of\n      destination addresses that the peer\
    \ has.\n   sasoc_peer_rwnd:  This parameter holds the current value of the\n \
    \     peer's rwnd (reported in the last selective acknowledgment (SACK))\n   \
    \   minus any outstanding data (i.e., data in flight).\n   sasoc_local_rwnd: \
    \ This parameter holds the last reported rwnd that\n      was sent to the peer.\n\
    \   sasoc_cookie_life:  This parameter is the association's cookie life\n    \
    \  value used when issuing cookies.\n   The value of sasoc_peer_rwnd is meaningless\
    \ when examining endpoint\n   information (i.e., it is only valid when examining\
    \ information on a\n   specific association).\n   All time values are given in\
    \ milliseconds.  A value of 0, when\n   modifying the parameters, indicates that\
    \ the current value should not\n   be changed.\n   The values of sasoc_asocmaxrxt\
    \ and sasoc_cookie_life may be set on\n   either an endpoint or association basis.\
    \  The rwnd and destination\n   counts (sasoc_number_peer_destinations, sasoc_peer_rwnd,\n\
    \   sasoc_local_rwnd) are not settable, and any value placed in these is\n   ignored.\n\
    \   To access or modify these parameters, the application should call\n   getsockopt()\
    \ or setsockopt(), respectively, with the option name\n   SCTP_ASSOCINFO.\n  \
    \ The maximum number of retransmissions before an address is considered\n   unreachable\
    \ is also tunable, but is address-specific, so it is\n   covered in a separate\
    \ option.  If an application attempts to set the\n   value of the association's\
    \ maximum retransmission parameter to more\n   than the sum of all maximum retransmission\
    \ parameters, setsockopt()\n   may return an error.  The reason for this, from\
    \ Section 8.2 of\n   [RFC4960], is as follows:\n      Note: When configuring the\
    \ SCTP endpoint, the user should avoid\n      having the value of 'Association.Max.Retrans'\
    \ (sasoc_maxrxt in\n      this option) larger than the summation of the 'Path.Max.Retrans'\n\
    \      (see spp_pathmaxrxt in Section 8.1.12) of all of the destination\n    \
    \  addresses for the remote endpoint.  Otherwise, all of the\n      destination\
    \ addresses may become inactive while the endpoint still\n      considers the\
    \ peer endpoint reachable.\n"
- title: 8.1.3.  Initialization Parameters (SCTP_INITMSG)
  contents:
  - "8.1.3.  Initialization Parameters (SCTP_INITMSG)\n   Applications can specify\
    \ protocol parameters for the default\n   association initialization.  The structure\
    \ used to access and modify\n   these parameters is defined in Section 5.3.1.\
    \  The option name\n   argument to setsockopt() and getsockopt() is SCTP_INITMSG.\n\
    \   Setting initialization parameters is effective only on an unconnected\n  \
    \ socket (for one-to-many style sockets, only future associations are\n   affected\
    \ by the change).\n"
- title: 8.1.4.  SO_LINGER
  contents:
  - "8.1.4.  SO_LINGER\n   An application can use this option to perform the SCTP\
    \ ABORT\n   primitive.  This option affects all associations related to the\n\
    \   socket.\n   The linger option structure is\n   struct linger {\n     int l_onoff;\
    \  /* option on/off */\n     int l_linger; /* linger time   */\n   };\n   To enable\
    \ the option, set l_onoff to 1.  If the l_linger value is set\n   to 0, calling\
    \ close() is the same as the ABORT primitive.  If the\n   value is set to a negative\
    \ value, the setsockopt() call will return\n   an error.  If the value is set\
    \ to a positive value linger_time, the\n   close() can be blocked for at most\
    \ linger_time.  Please note that the\n   time unit is in seconds, according to\
    \ POSIX, but might be different\n   on specific platforms.  If the graceful shutdown\
    \ phase does not\n   finish during this period, close() will return, but the graceful\n\
    \   shutdown phase will continue in the system.\n   Note that this is a socket-level\
    \ option, not an SCTP-level option.\n   When using this option, an application\
    \ must specify a level of\n   SOL_SOCKET in the call.\n"
- title: 8.1.5.  SCTP_NODELAY
  contents:
  - "8.1.5.  SCTP_NODELAY\n   This option turns on/off any Nagle-like algorithm. \
    \ This means that\n   packets are generally sent as soon as possible, and no unnecessary\n\
    \   delays are introduced, at the cost of more packets in the network.\n   In\
    \ particular, not using any Nagle-like algorithm might reduce the\n   bundling\
    \ of small user messages in cases where this would require an\n   additional delay.\n\
    \   Turning this option on disables any Nagle-like algorithm.\n   This option\
    \ expects an integer boolean flag, where a non-zero value\n   turns on the option,\
    \ and a zero value turns off the option.\n"
- title: 8.1.6.  SO_RCVBUF
  contents:
  - "8.1.6.  SO_RCVBUF\n   This option sets the receive buffer size in octets.  For\
    \ SCTP one-to-\n   one style sockets, this option controls the receiver window\
    \ size.\n   For one-to-many style sockets, the meaning is implementation\n   dependent.\
    \  It might control the receive buffer for each association\n   bound to the socket\
    \ descriptor, or it might control the receive\n   buffer for the whole socket.\
    \  This option expects an integer.\n   Note that this is a socket-level option,\
    \ not an SCTP-level option.\n   When using this option, an application must specify\
    \ a level of\n   SOL_SOCKET in the call.\n"
- title: 8.1.7.  SO_SNDBUF
  contents:
  - "8.1.7.  SO_SNDBUF\n   This option sets the send buffer size.  For SCTP one-to-one\
    \ style\n   sockets, this option controls the amount of data SCTP may have\n \
    \  waiting in internal buffers to be sent.  This option therefore bounds\n   the\
    \ maximum size of data that can be sent in a single send call.  For\n   one-to-many\
    \ style sockets, the effect is the same, except that it\n   applies to one or\
    \ all associations (see Section 3.3) bound to the\n   socket descriptor used in\
    \ the setsockopt() or getsockopt() call.  The\n   option applies to each association's\
    \ window size separately.  This\n   option expects an integer.\n   Note that this\
    \ is a socket-level option, not an SCTP-level option.\n   When using this option,\
    \ an application must specify a level of\n   SOL_SOCKET in the call.\n"
- title: 8.1.8.  Automatic Close of Associations (SCTP_AUTOCLOSE)
  contents:
  - "8.1.8.  Automatic Close of Associations (SCTP_AUTOCLOSE)\n   This socket option\
    \ is applicable to the one-to-many style socket\n   only.  When set, it will cause\
    \ associations that are idle for more\n   than the specified number of seconds\
    \ to automatically close using the\n   graceful shutdown procedure.  An idle association\
    \ is defined as an\n   association that has not sent or received user data.  The\
    \ special\n   value of '0' indicates that no automatic close of any association\n\
    \   should be performed; this is the default value.  This option expects\n   an\
    \ integer defining the number of seconds of idle time before an\n   association\
    \ is closed.\n   An application using this option should enable the ability to\
    \ receive\n   the association change notification.  This is the only mechanism\
    \ by\n   which an application is informed about the closing of an association.\n\
    \   After an association is closed, the association identifier assigned\n   to\
    \ it can be reused.  An application should be aware of this to avoid\n   the possible\
    \ problem of sending data to an incorrect peer endpoint.\n"
- title: 8.1.9.  Set Primary Address (SCTP_PRIMARY_ADDR)
  contents:
  - "8.1.9.  Set Primary Address (SCTP_PRIMARY_ADDR)\n   This option requests that\
    \ the local SCTP stack uses the enclosed peer\n   address as the association's\
    \ primary.  The enclosed address must be\n   one of the association peer's addresses.\n\
    \   The following structure is used to make a set peer primary request:\n   struct\
    \ sctp_setprim {\n     sctp_assoc_t ssp_assoc_id;\n     struct sockaddr_storage\
    \ ssp_addr;\n   };\n   ssp_assoc_id:  This parameter is ignored for one-to-one\
    \ style\n      sockets.  For one-to-many style sockets, it identifies the\n  \
    \    association for this request.  Note that the special sctp_assoc_t\n     \
    \ SCTP_{FUTURE|ALL|CURRENT}_ASSOC are not allowed.\n   ssp_addr:  This parameter\
    \ is the address to set as primary.  No\n      wildcard address is allowed.\n"
- title: 8.1.10.  Set Adaptation Layer Indicator (SCTP_ADAPTATION_LAYER)
  contents:
  - "8.1.10.  Set Adaptation Layer Indicator (SCTP_ADAPTATION_LAYER)\n   This option\
    \ requests that the local endpoint set the specified\n   Adaptation Layer Indication\
    \ parameter for all future INIT and\n   INIT-ACK exchanges.\n   The following\
    \ structure is used to access and modify this parameter:\n   struct sctp_setadaptation\
    \ {\n     uint32_t   ssb_adaptation_ind;\n   };\n   ssb_adaptation_ind:  The adaptation\
    \ layer indicator that will be\n      included in any outgoing Adaptation Layer\
    \ Indication parameter.\n"
- title: 8.1.11.  Enable/Disable Message Fragmentation (SCTP_DISABLE_FRAGMENTS)
  contents:
  - "8.1.11.  Enable/Disable Message Fragmentation (SCTP_DISABLE_FRAGMENTS)\n   This\
    \ option is an on/off flag and is passed as an integer, where a\n   non-zero is\
    \ on and a zero is off.  If enabled, no SCTP message\n   fragmentation will be\
    \ performed.  The effect of enabling this option\n   is that if a message being\
    \ sent exceeds the current Path MTU (PMTU)\n   size, the message will not be sent\
    \ and instead an error will be\n   indicated to the user.  If this option is disabled\
    \ (the default),\n   then a message exceeding the size of the PMTU will be fragmented\
    \ and\n   reassembled by the peer.\n"
- title: 8.1.12.  Peer Address Parameters (SCTP_PEER_ADDR_PARAMS)
  contents:
  - "8.1.12.  Peer Address Parameters (SCTP_PEER_ADDR_PARAMS)\n   Applications can\
    \ enable or disable heartbeats for any peer address of\n   an association, modify\
    \ an address's heartbeat interval, force a\n   heartbeat to be sent immediately,\
    \ and adjust the address's maximum\n   number of retransmissions sent before an\
    \ address is considered\n   unreachable.\n   The following structure is used to\
    \ access and modify an address's\n   parameters:\n   struct sctp_paddrparams {\n\
    \     sctp_assoc_t spp_assoc_id;\n     struct sockaddr_storage spp_address;\n\
    \     uint32_t spp_hbinterval;\n     uint16_t spp_pathmaxrxt;\n     uint32_t spp_pathmtu;\n\
    \     uint32_t spp_flags;\n     uint32_t spp_ipv6_flowlabel;\n     uint8_t  spp_dscp;\n\
    \   };\n   spp_assoc_id:  This parameter is ignored for one-to-one style\n   \
    \   sockets.  For one-to-many style sockets, the application may fill\n      in\
    \ an association identifier or SCTP_FUTURE_ASSOC for this query.\n      It is\
    \ an error to use SCTP_{CURRENT|ALL}_ASSOC in spp_assoc_id.\n   spp_address: \
    \ This specifies which address is of interest.  If a\n      wildcard address is\
    \ provided, it applies to all current and future\n      paths.\n   spp_hbinterval:\
    \  This contains the value of the heartbeat interval,\n      in milliseconds (HB.Interval\
    \ in [RFC4960]).  Note that unless the\n      spp_flags field is set to SPP_HB_ENABLE,\
    \ the value of this field\n      is ignored.  Note also that a value of zero indicates\
    \ that the\n      current setting should be left unchanged.  To set an actual\
    \ value\n      of zero, the SPP_HB_TIME_IS_ZERO flag should be used.  Even when\n\
    \      it is set to 0, it does not mean that SCTP will continuously send\n   \
    \   out heartbeats, since the actual interval also includes the\n      current\
    \ RTO and jitter (see Section 8.3 of [RFC4960]).\n   spp_pathmaxrxt:  This contains\
    \ the maximum number of retransmissions\n      before this address shall be considered\
    \ unreachable.  Note that a\n      value of zero indicates that the current setting\
    \ should be left\n      unchanged.\n   spp_pathmtu:  This field contains the current\
    \ Path MTU of the peer\n      address.  It is the number of bytes available in\
    \ an SCTP packet\n      for chunks.  Providing a value of 0 does not change the\
    \ current\n      setting.  If a positive value is provided and SPP_PMTUD_DISABLE\
    \ is\n      set in the spp_flags field, the given value is used as the Path\n\
    \      MTU.  If SPP_PMTUD_ENABLE is set in the spp_flags field, the\n      spp_pathmtu\
    \ field is ignored.\n   spp_flags:  These flags are used to control various features\
    \ on an\n      association.  The flag field is a bitmask that may contain zero\
    \ or\n      more of the following options:\n      SPP_HB_ENABLE:  This field enables\
    \ heartbeats on the specified\n         address.\n      SPP_HB_DISABLE:  This\
    \ field disables heartbeats on the specified\n         address.  Note that SPP_HB_ENABLE\
    \ and SPP_HB_DISABLE are\n         mutually exclusive; only one of these two should\
    \ be specified.\n         Enabling both fields will yield undetermined results.\n\
    \      SPP_HB_DEMAND:  This field requests that a user-initiated\n         heartbeat\
    \ be made immediately.  This must not be used in\n         conjunction with a\
    \ wildcard address.\n      SPP_HB_TIME_IS_ZERO:  This field specifies that the\
    \ time for\n         heartbeat delay is to be set to 0 milliseconds.\n      SPP_PMTUD_ENABLE:\
    \  This field will enable PMTU discovery on the\n         specified address.\n\
    \      SPP_PMTUD_DISABLE:  This field will disable PMTU discovery on the\n   \
    \      specified address.  Note that if the address field is empty,\n        \
    \ then all addresses on the association are affected.  Note also\n         that\
    \ SPP_PMTUD_ENABLE and SPP_PMTUD_DISABLE are mutually\n         exclusive.  Enabling\
    \ both fields will yield undetermined\n         results.\n      SPP_IPV6_FLOWLABEL:\
    \  Setting this flag enables the setting of the\n         IPV6 flow label value.\
    \  The value is contained in the\n         spp_ipv6_flowlabel field.\n       \
    \  Upon retrieval, this flag will be set to indicate that the\n         spp_ipv6_flowlabel\
    \ field has a valid value returned.  If a\n         specific destination address\
    \ is set (in the spp_address field),\n         then the value returned is that\
    \ of the address.  If just an\n         association is specified (and no address),\
    \ then the\n         association's default flow label is returned.  If neither\
    \ an\n         association nor a destination is specified, then the socket's\n\
    \         default flow label is returned.  For non-IPv6 sockets, this\n      \
    \   flag will be left cleared.\n      SPP_DSCP:  Setting this flag enables the\
    \ setting of the\n         Differentiated Services Code Point (DSCP) value associated\
    \ with\n         either the association or a specific address.  The value is\n\
    \         obtained in the spp_dscp field.\n         Upon retrieval, this flag\
    \ will be set to indicate that the\n         spp_dscp field has a valid value\
    \ returned.  If a specific\n         destination address is set when called (in\
    \ the spp_address\n         field), then that specific destination address's DSCP\
    \ value is\n         returned.  If just an association is specified, then the\n\
    \         association's default DSCP is returned.  If neither an\n         association\
    \ nor a destination is specified, then the socket's\n         default DSCP is\
    \ returned.\n   spp_ipv6_flowlabel:  This field is used in conjunction with the\n\
    \      SPP_IPV6_FLOWLABEL flag and contains the IPv6 flow label.  The 20\n   \
    \   least significant bits are used for the flow label.  This setting\n      has\
    \ precedence over any IPv6-layer setting.\n   spp_dscp:  This field is used in\
    \ conjunction with the SPP_DSCP flag\n      and contains the DSCP.  The 6 most\
    \ significant bits are used for\n      the DSCP.  This setting has precedence\
    \ over any IPv4- or IPv6-\n      layer setting.\n   Please note that changing\
    \ the flow label or DSCP value will affect\n   all packets sent by the SCTP stack\
    \ after setting these parameters.\n   The flow label might also be set via the\
    \ sin6_flowinfo field of the\n   sockaddr_in6 structure.\n"
- title: 8.1.13.  Set Default Send Parameters (SCTP_DEFAULT_SEND_PARAM) -
  contents:
  - "8.1.13.  Set Default Send Parameters (SCTP_DEFAULT_SEND_PARAM) -\n         DEPRECATED\n\
    \   Please note that this option is deprecated.  SCTP_DEFAULT_SNDINFO\n   (Section\
    \ 8.1.31) should be used instead.\n   Applications that wish to use the sendto()\
    \ system call may wish to\n   specify a default set of parameters that would normally\
    \ be supplied\n   through the inclusion of ancillary data.  This socket option\
    \ allows\n   such an application to set the default sctp_sndrcvinfo structure.\n\
    \   The application that wishes to use this socket option simply passes\n   the\
    \ sctp_sndrcvinfo structure (defined in Section 5.3.2) to this\n   call.  The\
    \ input parameters accepted by this call include\n   sinfo_stream, sinfo_flags,\
    \ sinfo_ppid, sinfo_context, and\n   sinfo_timetolive.  The sinfo_flags field\
    \ is composed of a bitwise OR\n   of SCTP_UNORDERED, SCTP_EOF, and SCTP_SENDALL.\
    \  The sinfo_assoc_id\n   field specifies the association to which to apply the\
    \ parameters.\n   For a one-to-many style socket, any of the predefined constants\
    \ are\n   also allowed in this field.  The field is ignored for one-to-one\n \
    \  style sockets.\n"
- title: 8.1.14.  Set Notification and Ancillary Events (SCTP_EVENTS) -
  contents:
  - "8.1.14.  Set Notification and Ancillary Events (SCTP_EVENTS) -\n         DEPRECATED\n\
    \   This socket option is used to specify various notifications and\n   ancillary\
    \ data the user wishes to receive.  Please see Section 6.2.1\n   for a full description\
    \ of this option and its usage.  Note that this\n   option is considered deprecated\
    \ and is present for backward\n   compatibility.  New applications should use\
    \ the SCTP_EVENT option.\n   See Section 6.2.2 for a full description of that\
    \ option as well.\n"
- title: 8.1.15.  Set/Clear IPv4 Mapped Addresses (SCTP_I_WANT_MAPPED_V4_ADDR)
  contents:
  - "8.1.15.  Set/Clear IPv4 Mapped Addresses (SCTP_I_WANT_MAPPED_V4_ADDR)\n   This\
    \ socket option is a boolean flag that turns on or off the mapping\n   of IPv4\
    \ addresses.  If this option is turned on, then IPv4 addresses\n   will be mapped\
    \ to IPv6 representation.  If this option is turned off,\n   then no mapping will\
    \ be done of IPv4 addresses, and a user will\n   receive both PF_INET6 and PF_INET\
    \ type addresses on the socket.  See\n   [RFC3542] for more details on mapped\
    \ IPv6 addresses.\n   If this socket option is used on a socket of type PF_INET,\
    \ an error\n   is returned.\n   By default, this option is turned off and expects\
    \ an integer to be\n   passed where a non-zero value turns on the option and a\
    \ zero value\n   turns off the option.\n"
- title: 8.1.16.  Get or Set the Maximum Fragmentation Size (SCTP_MAXSEG)
  contents:
  - "8.1.16.  Get or Set the Maximum Fragmentation Size (SCTP_MAXSEG)\n   This option\
    \ will get or set the maximum size to put in any outgoing\n   SCTP DATA chunk.\
    \  If a message is larger than this maximum size, it\n   will be fragmented by\
    \ SCTP into the specified size.  Note that the\n   underlying SCTP implementation\
    \ may fragment into smaller sized chunks\n   when the PMTU of the underlying association\
    \ is smaller than the value\n   set by the user.  The default value for this option\
    \ is '0', which\n   indicates that the user is not limiting fragmentation and\
    \ only the\n   PMTU will affect SCTP's choice of DATA chunk size.  Note also that\n\
    \   values set larger than the maximum size of an IP datagram will\n   effectively\
    \ let SCTP control fragmentation (i.e., the same as setting\n   this option to\
    \ 0).\n   The following structure is used to access and modify this parameter:\n\
    \   struct sctp_assoc_value {\n     sctp_assoc_t assoc_id;\n     uint32_t assoc_value;\n\
    \   };\n   assoc_id:  This parameter is ignored for one-to-one style sockets.\n\
    \      For one-to-many style sockets, this parameter indicates upon which\n  \
    \    association the user is performing an action.  It is an error to\n      use\
    \ SCTP_{CURRENT|ALL}_ASSOC in assoc_id.\n   assoc_value:  This parameter specifies\
    \ the maximum size in bytes.\n"
- title: 8.1.17.  Get or Set the List of Supported HMAC Identifiers
  contents:
  - "8.1.17.  Get or Set the List of Supported HMAC Identifiers\n         (SCTP_HMAC_IDENT)\n\
    \   This option gets or sets the list of Hashed Message Authentication\n   Code\
    \ (HMAC) algorithms that the local endpoint requires the peer\n   to use.\n  \
    \ The following structure is used to get or set these identifiers:\n   struct\
    \ sctp_hmacalgo {\n     uint32_t shmac_number_of_idents;\n     uint16_t shmac_idents[];\n\
    \   };\n   shmac_number_of_idents:  This field gives the number of elements\n\
    \      present in the array shmac_idents.\n   shmac_idents:  This parameter contains\
    \ an array of HMAC identifiers\n      that the local endpoint is requesting the\
    \ peer to use, in priority\n      order.  The following identifiers are valid:\n\
    \      *  SCTP_AUTH_HMAC_ID_SHA1\n      *  SCTP_AUTH_HMAC_ID_SHA256\n   Note that\
    \ the list supplied must include SCTP_AUTH_HMAC_ID_SHA1 and\n   may include any\
    \ of the other values in its preferred order (lowest\n   list position has the\
    \ highest preference in algorithm selection).\n   Note also that the lack of SCTP_AUTH_HMAC_ID_SHA1,\
    \ or the inclusion\n   of an unknown HMAC identifier (including optional identifiers\
    \ unknown\n   to the implementation), will cause the set option to fail and return\n\
    \   an error.\n"
- title: 8.1.18.  Get or Set the Active Shared Key (SCTP_AUTH_ACTIVE_KEY)
  contents:
  - "8.1.18.  Get or Set the Active Shared Key (SCTP_AUTH_ACTIVE_KEY)\n   This option\
    \ will get or set the active shared key to be used to build\n   the association\
    \ shared key.\n   The following structure is used to access and modify these\n\
    \   parameters:\n   struct sctp_authkeyid {\n     sctp_assoc_t scact_assoc_id;\n\
    \     uint16_t scact_keynumber;\n   };\n   scact_assoc_id:  This parameter sets\
    \ the active key of the specified\n      association.  The special SCTP_{FUTURE|CURRENT|ALL}_ASSOC\
    \ can be\n      used.  For one-to-one style sockets, this parameter is ignored.\n\
    \      Note, however, that this option will set the active key on the\n      association\
    \ if the socket is connected; otherwise, this option\n      will set the default\
    \ active key for the endpoint.\n   scact_keynumber:  This parameter is the shared\
    \ key identifier that\n      the application is requesting to become the active\
    \ shared key to\n      be used for sending authenticated chunks.  The key identifier\
    \ must\n      correspond to an existing shared key.  Note that shared key\n  \
    \    identifier '0' defaults to a null key.\n   When used with setsockopt(), the\
    \ SCTP implementation must use the\n   indicated shared key identifier for all\
    \ messages being given to an\n   SCTP implementation via a send call after the\
    \ setsockopt() call,\n   until changed again.  Therefore, the SCTP implementation\
    \ must not\n   bundle user messages that should be authenticated using different\n\
    \   shared key identifiers.\n   Initially, the key with key identifier 0 is the\
    \ active key.\n"
- title: 8.1.19.  Get or Set Delayed SACK Timer (SCTP_DELAYED_SACK)
  contents:
  - "8.1.19.  Get or Set Delayed SACK Timer (SCTP_DELAYED_SACK)\n   This option will\
    \ affect the way delayed SACKs are performed.  This\n   option allows the application\
    \ to get or set the delayed SACK time, in\n   milliseconds.  It also allows changing\
    \ the delayed SACK frequency.\n   Changing the frequency to 1 disables the delayed\
    \ SACK algorithm.\n   Note that if sack_delay or sack_freq is 0 when setting this\
    \ option,\n   the current values will remain unchanged.\n   The following structure\
    \ is used to access and modify these\n   parameters:\n   struct sctp_sack_info\
    \ {\n     sctp_assoc_t sack_assoc_id;\n     uint32_t sack_delay;\n     uint32_t\
    \ sack_freq;\n   };\n   sack_assoc_id:  This parameter is ignored for one-to-one\
    \ style\n      sockets.  For one-to-many style sockets, this parameter indicates\n\
    \      upon which association the user is performing an action.  The\n      special\
    \ SCTP_{FUTURE|CURRENT|ALL}_ASSOC can also be used.\n   sack_delay:  This parameter\
    \ contains the number of milliseconds the\n      user is requesting that the delayed\
    \ SACK timer be set to.  Note\n      that this value is defined in [RFC4960] to\
    \ be between 200 and 500\n      milliseconds.\n   sack_freq:  This parameter contains\
    \ the number of packets that must\n      be received before a SACK is sent without\
    \ waiting for the delay\n      timer to expire.  The default value is 2; setting\
    \ this value to 1\n      will disable the delayed SACK algorithm.\n"
- title: 8.1.20.  Get or Set Fragmented Interleave (SCTP_FRAGMENT_INTERLEAVE)
  contents:
  - "8.1.20.  Get or Set Fragmented Interleave (SCTP_FRAGMENT_INTERLEAVE)\n   Fragmented\
    \ interleave controls how the presentation of messages\n   occurs for the message\
    \ receiver.  There are three levels of fragment\n   interleave defined.  Two of\
    \ the levels affect one-to-one style\n   sockets, while one-to-many style sockets\
    \ are affected by all three\n   levels.\n   This option takes an integer value.\
    \  It can be set to a value of 0,\n   1, or 2.  Attempting to set this level to\
    \ other values will return an\n   error.\n   Setting the three levels provides\
    \ the following receiver\n   interactions:\n   level 0:  Prevents the interleaving\
    \ of any messages.  This means that\n      when a partial delivery begins, no\
    \ other messages will be received\n      except the message being partially delivered.\
    \  If another message\n      arrives on a different stream (or association) that\
    \ could be\n      delivered, it will be blocked waiting for the user to read all\
    \ of\n      the partially delivered message.\n   level 1:  Allows interleaving\
    \ of messages that are from different\n      associations.  For one-to-one style\
    \ sockets, level 0 and level 1\n      thus have the same meaning, since a one-to-one\
    \ style socket always\n      receives messages from the same association.  Note\
    \ that setting a\n      one-to-many style socket to this level may cause multiple\
    \ partial\n      deliveries from different associations, but for any given\n \
    \     association, only one message will be delivered until all parts of\n   \
    \   a message have been delivered.  This means that one large message,\n     \
    \ being read with an association identifier of \"X\", will block other\n     \
    \ messages from association \"X\" from being delivered.\n   level 2:  Allows complete\
    \ interleaving of messages.  This level\n      requires that the sender not only\
    \ carefully observe the peer\n      association identifier (or address) but also\
    \ pay careful attention\n      to the stream number.  With this option enabled,\
    \ a partially\n      delivered message may begin being delivered for association\
    \ \"X\"\n      stream \"Y\", and the next subsequent receive may return a message\n\
    \      from association \"X\" stream \"Z\".  Note that no other messages\n   \
    \   would be delivered for association \"X\" stream \"Y\" until all of\n     \
    \ stream \"Y\"'s partially delivered message was read.  Note that this\n     \
    \ option also affects one-to-one style sockets.  Also note that for\n      one-to-many\
    \ style sockets, not only another stream's message from\n      the same association\
    \ may be delivered upon the next receive, but\n      some other association's\
    \ message may also be delivered upon the\n      next receive.\n   An implementation\
    \ should default one-to-many style sockets to level\n   1, because otherwise,\
    \ it is possible that a peer could begin sending\n   a partial message and thus\
    \ block all other peers from sending data.\n   However, a setting of level 2 requires\
    \ that the application not only\n   be aware of the association (via the association\
    \ identifier or peer's\n   address) but also the stream number.  The stream number\
    \ is not\n   present unless the user has subscribed to the sctp_data_io_event\
    \ (see\n   Section 6.2), which is deprecated, or has enabled the\n   SCTP_RECVRCVINFO\
    \ socket option (see Section 8.1.29).  This is also\n   why we recommend that\
    \ one-to-one style sockets be defaulted to level\n   0 (level 1 for one-to-one\
    \ style sockets has no effect).  Note that an\n   implementation should return\
    \ an error if an application attempts to\n   set the level to 2 and has not subscribed\
    \ to the sctp_data_io_event\n   event, which is deprecated, or has enabled the\
    \ SCTP_RECVRCVINFO\n   socket option.\n   For applications that have subscribed\
    \ to events, those events appear\n   in the normal socket buffer data stream.\
    \  This means that unless the\n   user has set the fragmentation interleave level\
    \ to 0, notifications\n   may also be interleaved with partially delivered messages.\n"
- title: 8.1.21.  Set or Get the SCTP Partial Delivery Point
  contents:
  - "8.1.21.  Set or Get the SCTP Partial Delivery Point\n         (SCTP_PARTIAL_DELIVERY_POINT)\n\
    \   This option will set or get the SCTP partial delivery point.  This\n   point\
    \ is the size of a message where the partial delivery API will be\n   invoked\
    \ to help free up rwnd space for the peer.  Setting this to a\n   lower value\
    \ will cause partial deliveries to happen more often.  This\n   option expects\
    \ an integer that sets or gets the partial delivery\n   point in bytes.  Note\
    \ also that the call will fail if the user\n   attempts to set this value larger\
    \ than the socket receive buffer\n   size.\n   Note that any single message having\
    \ a length smaller than or equal to\n   the SCTP partial delivery point will be\
    \ delivered in a single read\n   call as long as the user-provided buffer is large\
    \ enough to hold the\n   message.\n"
- title: 8.1.22.  Set or Get the Use of Extended Receive Info
  contents:
  - "8.1.22.  Set or Get the Use of Extended Receive Info\n         (SCTP_USE_EXT_RCVINFO)\
    \ - DEPRECATED\n   This option will enable or disable the use of the extended\
    \ version of\n   the sctp_sndrcvinfo structure.  If this option is disabled, then\
    \ the\n   normal sctp_sndrcvinfo structure is returned in all receive message\n\
    \   calls.  If this option is enabled, then the sctp_extrcvinfo structure\n  \
    \ is returned in all receive message calls.  The default is off.\n   Note that\
    \ the sctp_extrcvinfo structure is never used in any send\n   call.\n   This option\
    \ is present for compatibility with older applications and\n   is deprecated.\
    \  Future applications should use SCTP_NXTINFO to\n   retrieve this same information\
    \ via ancillary data.\n"
- title: 8.1.23.  Set or Get the Auto ASCONF Flag (SCTP_AUTO_ASCONF)
  contents:
  - "8.1.23.  Set or Get the Auto ASCONF Flag (SCTP_AUTO_ASCONF)\n   This option will\
    \ enable or disable the use of the automatic\n   generation of ASCONF chunks to\
    \ add and delete addresses to an\n   existing association.  Note that this option\
    \ has two caveats, namely\n   a) it only affects sockets that are bound to all\
    \ addresses available\n   to the SCTP stack, and b) the system administrator may\
    \ have an\n   overriding control that turns the ASCONF feature off no matter what\n\
    \   setting the socket option may have.\n   This option expects an integer boolean\
    \ flag, where a non-zero value\n   turns on the option, and a zero value turns\
    \ off the option.\n"
- title: 8.1.24.  Set or Get the Maximum Burst (SCTP_MAX_BURST)
  contents:
  - "8.1.24.  Set or Get the Maximum Burst (SCTP_MAX_BURST)\n   This option will allow\
    \ a user to change the maximum burst of packets\n   that can be emitted by this\
    \ association.  Note that the default value\n   is 4, and some implementations\
    \ may restrict this setting so that it\n   can only be lowered to positive values.\n\
    \   To set or get this option, the user fills in the following structure:\n  \
    \ struct sctp_assoc_value {\n     sctp_assoc_t assoc_id;\n     uint32_t assoc_value;\n\
    \   };\n   assoc_id:  This parameter is ignored for one-to-one style sockets.\n\
    \      For one-to-many style sockets, this parameter indicates upon which\n  \
    \    association the user is performing an action.  The special\n      SCTP_{FUTURE|CURRENT|ALL}_ASSOC\
    \ can also be used.\n   assoc_value:  This parameter contains the maximum burst.\
    \  Setting the\n      value to 0 disables burst mitigation.\n"
- title: 8.1.25.  Set or Get the Default Context (SCTP_CONTEXT)
  contents:
  - "8.1.25.  Set or Get the Default Context (SCTP_CONTEXT)\n   The context field\
    \ in the sctp_sndrcvinfo structure is normally only\n   used when a failed message\
    \ is retrieved holding the value that was\n   sent down on the actual send call.\
    \  This option allows the setting,\n   on an association basis, of a default context\
    \ that will be received\n   on reading messages from the peer.  This is especially\
    \ helpful for an\n   application when using one-to-many style sockets to keep\
    \ some\n   reference to an internal state machine that is processing messages\
    \ on\n   the association.  Note that the setting of this value only affects\n\
    \   received messages from the peer and does not affect the value that is\n  \
    \ saved with outbound messages.\n   To set or get this option, the user fills\
    \ in the following structure:\n   struct sctp_assoc_value {\n     sctp_assoc_t\
    \ assoc_id;\n     uint32_t assoc_value;\n   };\n   assoc_id:  This parameter is\
    \ ignored for one-to-one style sockets.\n      For one-to-many style sockets,\
    \ this parameter indicates upon which\n      association the user is performing\
    \ an action.  The special\n      SCTP_{FUTURE|CURRENT|ALL}_ASSOC can also be used.\n\
    \   assoc_value:  This parameter contains the context.\n"
- title: 8.1.26.  Enable or Disable Explicit EOR Marking (SCTP_EXPLICIT_EOR)
  contents:
  - "8.1.26.  Enable or Disable Explicit EOR Marking (SCTP_EXPLICIT_EOR)\n   This\
    \ boolean flag is used to enable or disable explicit end of record\n   (EOR) marking.\
    \  When this option is enabled, a user may make multiple\n   send system calls\
    \ to send a record and must indicate that they are\n   finished sending a particular\
    \ record by including the SCTP_EOR flag.\n   If this boolean flag is disabled,\
    \ then each individual send system\n   call is considered to have an SCTP_EOR\
    \ indicator set on it implicitly\n   without the user having to explicitly add\
    \ this flag.  The default\n   is off.\n   This option expects an integer boolean\
    \ flag, where a non-zero value\n   turns on the option, and a zero value turns\
    \ off the option.\n"
- title: 8.1.27.  Enable SCTP Port Reusage (SCTP_REUSE_PORT)
  contents:
  - "8.1.27.  Enable SCTP Port Reusage (SCTP_REUSE_PORT)\n   This option only supports\
    \ one-to-one style SCTP sockets.  If used on\n   a one-to-many style SCTP socket,\
    \ an error is indicated.\n   This option expects an integer boolean flag, where\
    \ a non-zero value\n   turns on the option, and a zero value turns off the option.\n\
    \   This socket option must not be used after calling bind() or\n   sctp_bindx()\
    \ for a one-to-one style SCTP socket.  If using bind() or\n   sctp_bindx() on\
    \ a socket with the SCTP_REUSE_PORT option, all other\n   SCTP sockets bound to\
    \ the same port must have set the SCTP_REUSE_PORT\n   option.  Calling bind()\
    \ or sctp_bindx() for a socket without having\n   set the SCTP_REUSE_PORT option\
    \ will fail if there are other sockets\n   bound to the same port.  At most one\
    \ socket being bound to the same\n   port may be listening.\n   It should be noted\
    \ that the behavior of the socket-level socket\n   option to reuse ports and/or\
    \ addresses for SCTP sockets is\n   unspecified.\n"
- title: 8.1.28.  Set Notification Event (SCTP_EVENT)
  contents:
  - "8.1.28.  Set Notification Event (SCTP_EVENT)\n   This socket option is used to\
    \ set a specific notification option.\n   Please see Section 6.2.2 for a full\
    \ description of this option and\n   its usage.\n"
- title: 8.1.29.  Enable or Disable the Delivery of SCTP_RCVINFO as Ancillary
  contents:
  - "8.1.29.  Enable or Disable the Delivery of SCTP_RCVINFO as Ancillary\n      \
    \   Data (SCTP_RECVRCVINFO)\n   Setting this option specifies that SCTP_RCVINFO\
    \ (defined in\n   Section 5.3.5) is returned as ancillary data by recvmsg().\n\
    \   This option expects an integer boolean flag, where a non-zero value\n   turns\
    \ on the option, and a zero value turns off the option.\n"
- title: 8.1.30.  Enable or Disable the Delivery of SCTP_NXTINFO as Ancillary
  contents:
  - "8.1.30.  Enable or Disable the Delivery of SCTP_NXTINFO as Ancillary\n      \
    \   Data (SCTP_RECVNXTINFO)\n   Setting this option specifies that SCTP_NXTINFO\
    \ (defined in\n   Section 5.3.6) is returned as ancillary data by recvmsg().\n\
    \   This option expects an integer boolean flag, where a non-zero value\n   turns\
    \ on the option, and a zero value turns off the option.\n"
- title: 8.1.31.  Set Default Send Parameters (SCTP_DEFAULT_SNDINFO)
  contents:
  - "8.1.31.  Set Default Send Parameters (SCTP_DEFAULT_SNDINFO)\n   Applications\
    \ that wish to use the sendto() system call may wish to\n   specify a default\
    \ set of parameters that would normally be supplied\n   through the inclusion\
    \ of ancillary data.  This socket option allows\n   such an application to set\
    \ the default sctp_sndinfo structure.  The\n   application that wishes to use\
    \ this socket option simply passes the\n   sctp_sndinfo structure (defined in\
    \ Section 5.3.4) to this call.  The\n   input parameters accepted by this call\
    \ include snd_sid, snd_flags,\n   snd_ppid, and snd_context.  The snd_flags parameter\
    \ is composed of a\n   bitwise OR of SCTP_UNORDERED, SCTP_EOF, and SCTP_SENDALL.\
    \  The\n   snd_assoc_id field specifies the association to which to apply the\n\
    \   parameters.  For a one-to-many style socket, any of the predefined\n   constants\
    \ are also allowed in this field.  The field is ignored for\n   one-to-one style\
    \ sockets.\n"
- title: 8.1.32.  Set Default PR-SCTP Parameters (SCTP_DEFAULT_PRINFO)
  contents:
  - "8.1.32.  Set Default PR-SCTP Parameters (SCTP_DEFAULT_PRINFO)\n   This option\
    \ sets and gets the default parameters for PR-SCTP.  They\n   can be overwritten\
    \ by specific information provided in send calls.\n   The following structure\
    \ is used to access and modify these\n   parameters:\n   struct sctp_default_prinfo\
    \ {\n     uint16_t pr_policy;\n     uint32_t pr_value;\n     sctp_assoc_t pr_assoc_id;\n\
    \   };\n   pr_policy:  This field is the same as that described in\n      Section\
    \ 5.3.7.\n   pr_value:  This field is the same as that described in Section 5.3.7.\n\
    \   pr_assoc_id:  This field is ignored for one-to-one style sockets.\n      For\
    \ one-to-many style sockets, pr_assoc_id can be a particular\n      association\
    \ identifier or SCTP_{FUTURE|CURRENT|ALL}_ASSOC.\n"
- title: 8.2.  Read-Only Options
  contents:
  - "8.2.  Read-Only Options\n   The options defined in this subsection are read-only.\
    \  Using this\n   option in a setsockopt() call will result in an error indicating\n\
    \   EOPNOTSUPP.\n"
- title: 8.2.1.  Association Status (SCTP_STATUS)
  contents:
  - "8.2.1.  Association Status (SCTP_STATUS)\n   Applications can retrieve current\
    \ status information about an\n   association, including association state, peer\
    \ receiver window size,\n   number of unacknowledged DATA chunks, and number of\
    \ DATA chunks\n   pending receipt.  This information is read-only.\n   The following\
    \ structure is used to access this information:\n   struct sctp_status {\n   \
    \  sctp_assoc_t sstat_assoc_id;\n     int32_t  sstat_state;\n     uint32_t sstat_rwnd;\n\
    \     uint16_t sstat_unackdata;\n     uint16_t sstat_penddata;\n     uint16_t\
    \ sstat_instrms;\n     uint16_t sstat_outstrms;\n     uint32_t sstat_fragmentation_point;\n\
    \     struct sctp_paddrinfo sstat_primary;\n   };\n   sstat_assoc_id:  This parameter\
    \ is ignored for one-to-one style\n      sockets.  For one-to-many style sockets,\
    \ it holds the identifier\n      for the association.  All notifications for a\
    \ given association\n      have the same association identifier.  The special\
    \ SCTP_{FUTURE|\n      CURRENT|ALL}_ASSOC cannot be used.\n   sstat_state:  This\
    \ contains the association's current state, i.e.,\n      one of the following\
    \ values:\n      *  SCTP_CLOSED\n      *  SCTP_BOUND\n      *  SCTP_LISTEN\n \
    \     *  SCTP_COOKIE_WAIT\n      *  SCTP_COOKIE_ECHOED\n      *  SCTP_ESTABLISHED\n\
    \      *  SCTP_SHUTDOWN_PENDING\n      *  SCTP_SHUTDOWN_SENT\n      *  SCTP_SHUTDOWN_RECEIVED\n\
    \      *  SCTP_SHUTDOWN_ACK_SENT\n   sstat_rwnd:  This contains the association\
    \ peer's current receiver\n      window size.\n   sstat_unackdata:  This is the\
    \ number of unacknowledged DATA chunks.\n   sstat_penddata:  This is the number\
    \ of DATA chunks pending receipt.\n   sstat_instrms:  This is the number of streams\
    \ that the peer will be\n      using outbound.\n   sstat_outstrms:  This is the\
    \ number of outbound streams that the\n      endpoint is allowed to use.\n   sstat_fragmentation_point:\
    \  This is the size at which SCTP\n      fragmentation will occur.\n   sstat_primary:\
    \  This is information on the current primary peer\n      address.\n   To access\
    \ these status values, the application calls getsockopt()\n   with the option\
    \ name SCTP_STATUS.\n"
- title: 8.2.2.  Peer Address Information (SCTP_GET_PEER_ADDR_INFO)
  contents:
  - "8.2.2.  Peer Address Information (SCTP_GET_PEER_ADDR_INFO)\n   Applications can\
    \ retrieve information about a specific peer address\n   of an association, including\
    \ its reachability state, congestion\n   window, and retransmission timer values.\
    \  This information is\n   read-only.\n   The following structure is used to access\
    \ this information:\n   struct sctp_paddrinfo {\n     sctp_assoc_t spinfo_assoc_id;\n\
    \     struct sockaddr_storage spinfo_address;\n     int32_t  spinfo_state;\n \
    \    uint32_t spinfo_cwnd;\n     uint32_t spinfo_srtt;\n     uint32_t spinfo_rto;\n\
    \     uint32_t spinfo_mtu;\n   };\n   spinfo_assoc_id:  This parameter is ignored\
    \ for one-to-one style\n      sockets.\n      For one-to-many style sockets, this\
    \ field may be filled by the\n      application, and if so, this field will have\
    \ priority in looking\n      up the association instead of using the address specified\
    \ in\n      spinfo_address.  Note that if the address does not belong to the\n\
    \      association specified, then this call will fail.  If the\n      application\
    \ does not fill in the spinfo_assoc_id, then the address\n      will be used to\
    \ look up the association, and on return, this field\n      will have the valid\
    \ association identifier.  In other words, this\n      call can be used to translate\
    \ an address into an association\n      identifier.  Note that the predefined\
    \ constants are not allowed\n      for this option.\n   spinfo_address:  This\
    \ is filled by the application and contains the\n      peer address of interest.\n\
    \   spinfo_state:  This contains the peer address's state:\n      SCTP_UNCONFIRMED:\
    \  This is the initial state of a peer address.\n      SCTP_ACTIVE:  This state\
    \ is entered the first time after path\n         verification.  It can also be\
    \ entered if the state is\n         SCTP_INACTIVE and the path supervision detects\
    \ that the peer\n         address is reachable again.\n      SCTP_INACTIVE:  This\
    \ state is entered whenever a path failure is\n         detected.\n   spinfo_cwnd:\
    \  This contains the peer address's current congestion\n      window.\n   spinfo_srtt:\
    \  This contains the peer address's current smoothed\n      round-trip time calculation\
    \ in milliseconds.\n   spinfo_rto:  This contains the peer address's current retransmission\n\
    \      timeout value in milliseconds.\n   spinfo_mtu:  This is the current Path\
    \ MTU of the peer address.  It is\n      the number of bytes available in an SCTP\
    \ packet for chunks.\n"
- title: 8.2.3.  Get the List of Chunks the Peer Requires to Be Authenticated
  contents:
  - "8.2.3.  Get the List of Chunks the Peer Requires to Be Authenticated\n      \
    \  (SCTP_PEER_AUTH_CHUNKS)\n   This option gets a list of chunk types (see [RFC4960])\
    \ for a\n   specified association that the peer requires to be received\n   authenticated\
    \ only.\n   The following structure is used to access these parameters:\n   struct\
    \ sctp_authchunks {\n     sctp_assoc_t gauth_assoc_id;\n     uint32_t gauth_number_of_chunks\n\
    \     uint8_t  gauth_chunks[];\n   };\n   gauth_assoc_id:  This parameter indicates\
    \ for which association the\n      user is requesting the list of peer-authenticated\
    \ chunks.  For\n      one-to-one style sockets, this parameter is ignored.  Note\
    \ that\n      the predefined constants are not allowed with this option.\n   gauth_number_of_chunks:\
    \  This parameter gives the number of elements\n      in the array gauth_chunks.\n\
    \   gauth_chunks:  This parameter contains an array of chunk types that\n    \
    \  the peer is requesting to be authenticated.  If the passed-in\n      buffer\
    \ size is not large enough to hold the list of chunk types,\n      ENOBUFS is\
    \ returned.\n"
- title: 8.2.4.  Get the List of Chunks the Local Endpoint Requires to Be
  contents:
  - "8.2.4.  Get the List of Chunks the Local Endpoint Requires to Be\n        Authenticated\
    \ (SCTP_LOCAL_AUTH_CHUNKS)\n   This option gets a list of chunk types (see [RFC4960])\
    \ for a\n   specified association that the local endpoint requires to be received\n\
    \   authenticated only.\n   The following structure is used to access these parameters:\n\
    \   struct sctp_authchunks {\n     sctp_assoc_t gauth_assoc_id;\n     uint32_t\
    \ gauth_number_of_chunks;\n     uint8_t  gauth_chunks[];\n   };\n   gauth_assoc_id:\
    \  This parameter is ignored for one-to-one style\n      sockets.  For one-to-many\
    \ style sockets, the application may fill\n      in an association identifier\
    \ or SCTP_FUTURE_ASSOC.  It is an error\n      to use SCTP_{CURRENT|ALL}_ASSOC\
    \ in gauth_assoc_id.\n   gauth_number_of_chunks:  This parameter gives the number\
    \ of elements\n      in the array gauth_chunks.\n   gauth_chunks:  This parameter\
    \ contains an array of chunk types that\n      the local endpoint is requesting\
    \ to be authenticated.  If the\n      passed-in buffer is not large enough to\
    \ hold the list of chunk\n      types, ENOBUFS is returned.\n"
- title: 8.2.5.  Get the Current Number of Associations (SCTP_GET_ASSOC_NUMBER)
  contents:
  - "8.2.5.  Get the Current Number of Associations (SCTP_GET_ASSOC_NUMBER)\n   This\
    \ option gets the current number of associations that are attached\n   to a one-to-many\
    \ style socket.  The option value is an uint32_t.\n   Note that this number is\
    \ only a snapshot.  This means that the number\n   of associations may have changed\
    \ when the caller gets back the option\n   result.\n   For a one-to-one style\
    \ socket, this socket option results in an\n   error.\n"
- title: 8.2.6.  Get the Current Identifiers of Associations
  contents:
  - "8.2.6.  Get the Current Identifiers of Associations\n        (SCTP_GET_ASSOC_ID_LIST)\n\
    \   This option gets the current list of SCTP association identifiers of\n   the\
    \ SCTP associations handled by a one-to-many style socket.\n   The option value\
    \ has the structure\n   struct sctp_assoc_ids {\n     uint32_t gaids_number_of_ids;\n\
    \     sctp_assoc_t gaids_assoc_id[];\n   };\n   The caller must provide a large\
    \ enough buffer to hold all association\n   identifiers.  If the buffer is too\
    \ small, an error must be returned.\n   The user can use the SCTP_GET_ASSOC_NUMBER\
    \ socket option to get an\n   idea of how large the buffer has to be.  gaids_number_of_ids\
    \ gives\n   the number of elements in the array gaids_assoc_id.  Note also that\n\
    \   some or all of sctp_assoc_t returned in the array may become invalid\n   by\
    \ the time the caller gets back the result.\n   For a one-to-one style socket,\
    \ this socket option results in an\n   error.\n"
- title: 8.3.  Write-Only Options
  contents:
  - "8.3.  Write-Only Options\n   The options defined in this subsection are write-only.\
    \  Using this\n   option in a getsockopt() or sctp_opt_info() call will result\
    \ in an\n   error indicating EOPNOTSUPP.\n"
- title: 8.3.1.  Set Peer Primary Address (SCTP_SET_PEER_PRIMARY_ADDR)
  contents:
  - "8.3.1.  Set Peer Primary Address (SCTP_SET_PEER_PRIMARY_ADDR)\n   This call requests\
    \ that the peer mark the enclosed address as the\n   association primary (see\
    \ [RFC5061]).  The enclosed address must be\n   one of the association's locally\
    \ bound addresses.\n   The following structure is used to make a set peer primary\
    \ request:\n   struct sctp_setpeerprim {\n     sctp_assoc_t sspp_assoc_id;\n \
    \    struct sockaddr_storage sspp_addr;\n   };\n   sspp_assoc_id:  This parameter\
    \ is ignored for one-to-one style\n      sockets.  For one-to-many style sockets,\
    \ it identifies the\n      association for this request.  Note that the predefined\
    \ constants\n      are not allowed for this option.\n   sspp_addr:  The address\
    \ to set as primary.\n"
- title: 8.3.2.  Add a Chunk That Must Be Authenticated (SCTP_AUTH_CHUNK)
  contents:
  - "8.3.2.  Add a Chunk That Must Be Authenticated (SCTP_AUTH_CHUNK)\n   This set\
    \ option adds a chunk type that the user is requesting to be\n   received only\
    \ in an authenticated way.  Changes to the list of chunks\n   will only affect\
    \ future associations on the socket.\n   The following structure is used to add\
    \ a chunk:\n   struct sctp_authchunk {\n     uint8_t sauth_chunk;\n   };\n   sauth_chunk:\
    \  This parameter contains a chunk type that the user is\n      requesting to\
    \ be authenticated.\n   The chunk types for INIT, INIT-ACK, SHUTDOWN-COMPLETE,\
    \ and AUTH\n   chunks must not be used.  If they are used, an error must be\n\
    \   returned.  The usage of this option enables SCTP AUTH in cases where\n   it\
    \ is not required by other means (for example, the use of dynamic\n   address\
    \ reconfiguration).\n"
- title: 8.3.3.  Set a Shared Key (SCTP_AUTH_KEY)
  contents:
  - "8.3.3.  Set a Shared Key (SCTP_AUTH_KEY)\n   This option will set a shared secret\
    \ key that is used to build an\n   association shared key.\n   The following structure\
    \ is used to access and modify these\n   parameters:\n   struct sctp_authkey {\n\
    \     sctp_assoc_t sca_assoc_id;\n     uint16_t sca_keynumber;\n     uint16_t\
    \ sca_keylength;\n     uint8_t  sca_key[];\n   };\n   sca_assoc_id:  This parameter\
    \ indicates on what association the\n      shared key is being set.  The special\
    \ SCTP_{FUTURE|CURRENT|\n      ALL}_ASSOC can be used.  For one-to-one style sockets,\
    \ this\n      parameter is ignored.  Note, however, that on one-to-one style\n\
    \      sockets, this option will set a key on the association if the\n      socket\
    \ is connected; otherwise, this option will set a key on the\n      endpoint.\n\
    \   sca_keynumber:  This parameter is the shared key identifier by which\n   \
    \   the application will refer to this shared key.  If a key of the\n      specified\
    \ index already exists, then this new key will replace the\n      old existing\
    \ key.  Note that shared key identifier '0' defaults to\n      a null key.\n \
    \  sca_keylength:  This parameter is the length of the array sca_key.\n   sca_key:\
    \  This parameter contains an array of bytes that is to be\n      used by the\
    \ endpoint (or association) as the shared secret key.\n      Note that if the\
    \ length of this field is zero, a null key is set.\n"
- title: 8.3.4.  Deactivate a Shared Key (SCTP_AUTH_DEACTIVATE_KEY)
  contents:
  - "8.3.4.  Deactivate a Shared Key (SCTP_AUTH_DEACTIVATE_KEY)\n   This set option\
    \ indicates that the application will no longer send\n   user messages using the\
    \ indicated key identifier.\n   struct sctp_authkeyid {\n     sctp_assoc_t scact_assoc_id;\n\
    \     uint16_t scact_keynumber;\n   };\n   scact_assoc_id:  This parameter indicates\
    \ from which association the\n      shared key identifier is being deleted.  The\
    \ special SCTP_{FUTURE|\n      CURRENT|ALL}_ASSOC can be used.  For one-to-one\
    \ style sockets,\n      this parameter is ignored.  Note, however, that this option\
    \ will\n      deactivate the key from the association if the socket is\n     \
    \ connected; otherwise, this option will deactivate the key from the\n      endpoint.\n\
    \   scact_keynumber:  This parameter is the shared key identifier that\n     \
    \ the application is requesting to be deactivated.  The key\n      identifier\
    \ must correspond to an existing shared key.  Note that\n      if this parameter\
    \ is zero, use of the null key identifier '0' is\n      deactivated on the endpoint\
    \ and/or association.\n   The currently active key cannot be deactivated.\n"
- title: 8.3.5.  Delete a Shared Key (SCTP_AUTH_DELETE_KEY)
  contents:
  - "8.3.5.  Delete a Shared Key (SCTP_AUTH_DELETE_KEY)\n   This set option will delete\
    \ an SCTP association's shared secret key\n   that has been deactivated.\n   struct\
    \ sctp_authkeyid {\n     sctp_assoc_t scact_assoc_id;\n     uint16_t scact_keynumber;\n\
    \   };\n   scact_assoc_id:  This parameter indicates from which association the\n\
    \      shared key identifier is being deleted.  The special SCTP_{FUTURE|\n  \
    \    CURRENT|ALL}_ASSOC can be used.  For one-to-one style sockets,\n      this\
    \ parameter is ignored.  Note, however, that this option will\n      delete the\
    \ key from the association if the socket is connected;\n      otherwise, this\
    \ option will delete the key from the endpoint.\n   scact_keynumber:  This parameter\
    \ is the shared key identifier that\n      the application is requesting to be\
    \ deleted.  The key identifier\n      must correspond to an existing shared key\
    \ and must not be in use\n      for any packet being sent by the SCTP implementation.\
    \  This means,\n      in particular, that it must be deactivated first.  Note\
    \ that if\n      this parameter is zero, use of the null key identifier '0' is\n\
    \      deleted from the endpoint and/or association.\n   Only deactivated keys\
    \ that are no longer used by an association can\n   be deleted.\n"
- title: 9.  New Functions
  contents:
  - "9.  New Functions\n   Depending on the system, the following interface can be\
    \ implemented\n   as a system call or library function.\n"
- title: 9.1.  sctp_bindx()
  contents:
  - "9.1.  sctp_bindx()\n   This function allows the user to bind a specific subset\
    \ of addresses\n   or, if the SCTP extension described in [RFC5061] is supported,\
    \ add or\n   delete specific addresses.\n   The function prototype is\n   int\
    \ sctp_bindx(int sd,\n                  struct sockaddr *addrs,\n            \
    \      int addrcnt,\n                  int flags);\n   If sd is an IPv4 socket,\
    \ the addresses passed must be IPv4 addresses.\n   If the sd is an IPv6 socket,\
    \ the addresses passed can either be IPv4\n   or IPv6 addresses.\n   A single\
    \ address may be specified as INADDR_ANY for an IPv4 address,\n   or as IN6ADDR_ANY_INIT\
    \ or in6addr_any for an IPv6 address; see\n   Section 3.1.2 for this usage.\n\
    \   addrs is a pointer to an array of one or more socket addresses.  Each\n  \
    \ address is contained in its appropriate structure.  For an IPv6\n   socket,\
    \ an array of sockaddr_in6 is used.  For an IPv4 socket, an\n   array of sockaddr_in\
    \ is used.  The caller specifies the number of\n   addresses in the array with\
    \ addrcnt.  Note that the wildcard\n   addresses cannot be used in combination\
    \ with non-wildcard addresses\n   on a socket with this function; doing so will\
    \ result in an error.\n   On success, sctp_bindx() returns 0.  On failure, sctp_bindx()\
    \ returns\n   -1 and sets errno to the appropriate error code.\n   For SCTP, the\
    \ port given in each socket address must be the same, or\n   sctp_bindx() will\
    \ fail, setting errno to EINVAL.\n   The flags parameter is formed from the bitwise\
    \ OR of zero or more of\n   the following currently defined flags:\n   o  SCTP_BINDX_ADD_ADDR\n\
    \   o  SCTP_BINDX_REM_ADDR\n   SCTP_BINDX_ADD_ADDR directs SCTP to add the given\
    \ addresses to the\n   socket (i.e., endpoint), and SCTP_BINDX_REM_ADDR directs\
    \ SCTP to\n   remove the given addresses from the socket.  The two flags are\n\
    \   mutually exclusive; if both are given, sctp_bindx() will fail with\n   EINVAL.\
    \  A caller may not remove all addresses from a socket;\n   sctp_bindx() will\
    \ reject such an attempt with EINVAL.\n   An application can use sctp_bindx(SCTP_BINDX_ADD_ADDR)\
    \ to associate\n   additional addresses with an endpoint after calling bind().\
    \  Or, an\n   application can use sctp_bindx(SCTP_BINDX_REM_ADDR) to remove some\n\
    \   addresses with which a listening socket is associated, so that no new\n  \
    \ association accepted will be associated with these addresses.  If the\n   endpoint\
    \ supports dynamic address reconfiguration, an\n   SCTP_BINDX_REM_ADDR or SCTP_BINDX_ADD_ADDR\
    \ may cause an endpoint to\n   send the appropriate message to its peers to change\
    \ the peers'\n   address lists.\n   Adding and removing addresses from established\
    \ associations is an\n   optional functionality.  Implementations that do not\
    \ support this\n   functionality should return -1 and set errno to EOPNOTSUPP.\n\
    \   sctp_bindx() can be called on an already bound socket or on an\n   unbound\
    \ socket.  If the socket is unbound and the first port number\n   in the addrs\
    \ parameter is zero, the kernel will choose a port number.\n   All port numbers\
    \ after the first one being 0 must also be zero.  If\n   the first port number\
    \ is not zero, the following port numbers must be\n   zero or have the same value\
    \ as the first one.  For an already bound\n   socket, all port numbers provided\
    \ must be the bound one or 0.\n   sctp_bindx() is an atomic operation.  Therefore,\
    \ the binding will\n   either succeed on all addresses or fail on all addresses.\
    \  If\n   multiple addresses are provided and the sctp_bindx() call fails,\n \
    \  there is no indication of which address is responsible for the\n   failure.\
    \  The only way to identify the specific error indication is\n   to call sctp_bindx()\
    \ sequentially with only one address per call.\n"
- title: 9.2.  sctp_peeloff()
  contents:
  - "9.2.  sctp_peeloff()\n   After an association is established on a one-to-many\
    \ style socket,\n   the application may wish to branch off the association into\
    \ a\n   separate socket/file descriptor.\n   This is particularly desirable when,\
    \ for instance, the application\n   wishes to have a number of sporadic message\
    \ senders/receivers remain\n   under the original one-to-many style socket but\
    \ branch off these\n   associations carrying high-volume data traffic into their\
    \ own\n   separate socket descriptors.\n   The application uses the sctp_peeloff()\
    \ call to branch off an\n   association into a separate socket.  (Note that the\
    \ semantics are\n   somewhat changed from the traditional one-to-one style accept()\n\
    \   call.)  Note also that the new socket is a one-to-one style socket.\n   Thus,\
    \ it will be confined to operations allowed for a one-to-one\n   style socket.\n\
    \   The function prototype is\n   int sctp_peeloff(int sd,\n                 \
    \   sctp_assoc_t assoc_id);\n   and the arguments are\n   sd:  The original one-to-many\
    \ style socket descriptor returned from\n      the socket() system call (see Section\
    \ 3.1.1).\n   assoc_id:  The specified identifier of the association that is to\
    \ be\n      branched off to a separate file descriptor.  (Note that in a\n   \
    \   traditional one-to-one style accept() call, this would be an out\n      parameter,\
    \ but for the one-to-many style call, this is an in\n      parameter.)\n   The\
    \ function returns a non-negative file descriptor representing the\n   branched-off\
    \ association, or -1 if an error occurred.  The variable\n   errno is then set\
    \ appropriately.\n"
- title: 9.3.  sctp_getpaddrs()
  contents:
  - "9.3.  sctp_getpaddrs()\n   sctp_getpaddrs() returns all peer addresses in an\
    \ association.\n   The function prototype is\n   int sctp_getpaddrs(int sd,\n\
    \                      sctp_assoc_t id,\n                      struct sockaddr\
    \ **addrs);\n   On return, addrs will point to a dynamically allocated array of\n\
    \   sockaddr structures of the appropriate type for the socket type.  The\n  \
    \ caller should use sctp_freepaddrs() to free the memory.  Note that\n   the in/out\
    \ parameter addrs must not be NULL.\n   If sd is an IPv4 socket, the addresses\
    \ returned will be all IPv4\n   addresses.  If sd is an IPv6 socket, the addresses\
    \ returned can be a\n   mix of IPv4 or IPv6 addresses, with IPv4 addresses returned\
    \ according\n   to the SCTP_I_WANT_MAPPED_V4_ADDR option setting.\n   For one-to-many\
    \ style sockets, id specifies the association to query.\n   For one-to-one style\
    \ sockets, id is ignored.\n   On success, sctp_getpaddrs() returns the number\
    \ of peer addresses in\n   the association.  If there is no association on this\
    \ socket,\n   sctp_getpaddrs() returns 0, and the value of *addrs is undefined.\
    \  If\n   an error occurs, sctp_getpaddrs() returns -1, and the value of *addrs\n\
    \   is undefined.\n"
- title: 9.4.  sctp_freepaddrs()
  contents:
  - "9.4.  sctp_freepaddrs()\n   sctp_freepaddrs() frees all resources allocated by\
    \ sctp_getpaddrs().\n   The function prototype is\n   void sctp_freepaddrs(struct\
    \ sockaddr *addrs);\n   and addrs is the array of peer addresses returned by\n\
    \   sctp_getpaddrs().\n"
- title: 9.5.  sctp_getladdrs()
  contents:
  - "9.5.  sctp_getladdrs()\n   sctp_getladdrs() returns all locally bound addresses\
    \ on a socket.\n   The function prototype is\n   int sctp_getladdrs(int sd,\n\
    \                      sctp_assoc_t id,\n                      struct sockaddr\
    \ **addrs);\n   On return, addrs will point to a dynamically allocated array of\n\
    \   sockaddr structures of the appropriate type for the socket type.  The\n  \
    \ caller should use sctp_freeladdrs() to free the memory.  Note that\n   the in/out\
    \ parameter addrs must not be NULL.\n   If sd is an IPv4 socket, the addresses\
    \ returned will be all IPv4\n   addresses.  If sd is an IPv6 socket, the addresses\
    \ returned can be a\n   mix of IPv4 or IPv6 addresses, with IPv4 addresses returned\
    \ according\n   to the SCTP_I_WANT_MAPPED_V4_ADDR option setting.\n   For one-to-many\
    \ style sockets, id specifies the association to query.\n   For one-to-one style\
    \ sockets, id is ignored.\n   If the id field is set to the value '0', then the\
    \ locally bound\n   addresses are returned without regard to any particular association.\n\
    \   On success, sctp_getladdrs() returns the number of local addresses\n   bound\
    \ to the socket.  If the socket is unbound, sctp_getladdrs()\n   returns 0, and\
    \ the value of *addrs is undefined.  If an error occurs,\n   sctp_getladdrs()\
    \ returns -1, and the value of *addrs is undefined.\n"
- title: 9.6.  sctp_freeladdrs()
  contents:
  - "9.6.  sctp_freeladdrs()\n   sctp_freeladdrs() frees all resources allocated by\
    \ sctp_getladdrs().\n   The function prototype is\n   void sctp_freeladdrs(struct\
    \ sockaddr *addrs);\n   and addrs is the array of local addresses returned by\n\
    \   sctp_getladdrs().\n"
- title: 9.7.  sctp_sendmsg() - DEPRECATED
  contents:
  - "9.7.  sctp_sendmsg() - DEPRECATED\n   This function is deprecated; sctp_sendv()\
    \ (see Section 9.12) should\n   be used instead.\n   An implementation may provide\
    \ a library function (or possibly system\n   call) to assist the user with the\
    \ advanced features of SCTP.\n   The function prototype is\n   ssize_t sctp_sendmsg(int\
    \ sd,\n                        const void *msg,\n                        size_t\
    \ len,\n                        const struct sockaddr *to,\n                 \
    \       socklen_t tolen,\n                        uint32_t ppid,\n           \
    \             uint32_t flags,\n                        uint16_t stream_no,\n \
    \                       uint32_t timetolive,\n                        uint32_t\
    \ context);\n   and the arguments are\n   sd:  The socket descriptor.\n   msg:\
    \  The message to be sent.\n   len:  The length of the message.\n   to:  The destination\
    \ address of the message.\n   tolen:  The length of the destination address.\n\
    \   ppid:  The same as sinfo_ppid (see Section 5.3.2).\n   flags:  The same as\
    \ sinfo_flags (see Section 5.3.2).\n   stream_no:  The same as sinfo_stream (see\
    \ Section 5.3.2).\n   timetolive:  The same as sinfo_timetolive (see Section 5.3.2).\n\
    \   context:  The same as sinfo_context (see Section 5.3.2).\n   The call returns\
    \ the number of characters sent, or -1 if an error\n   occurred.  The variable\
    \ errno is then set appropriately.\n   Sending a message using sctp_sendmsg()\
    \ is atomic (unless explicit EOR\n   marking is enabled on the socket specified\
    \ by sd).\n   Using sctp_sendmsg() on a non-connected one-to-one style socket\
    \ for\n   implicit connection setup may or may not work, depending on the SCTP\n\
    \   implementation.\n"
- title: 9.8.  sctp_recvmsg() - DEPRECATED
  contents:
  - "9.8.  sctp_recvmsg() - DEPRECATED\n   This function is deprecated; sctp_recvv()\
    \ (see Section 9.13) should\n   be used instead.\n   An implementation may provide\
    \ a library function (or possibly system\n   call) to assist the user with the\
    \ advanced features of SCTP.  Note\n   that in order for the sctp_sndrcvinfo structure\
    \ to be filled in by\n   sctp_recvmsg(), the caller must enable the sctp_data_io_event\
    \ with\n   the SCTP_EVENTS option.  Note that the setting of the\n   SCTP_USE_EXT_RCVINFO\
    \ will affect this function as well, causing the\n   sctp_sndrcvinfo information\
    \ to be extended.\n   The function prototype is\n   ssize_t sctp_recvmsg(int sd,\n\
    \                        void *msg,\n                        size_t len,\n   \
    \                     struct sockaddr *from,\n                        socklen_t\
    \ *fromlen\n                        struct sctp_sndrcvinfo *sinfo\n          \
    \              int *msg_flags);\n   and the arguments are\n   sd:  The socket\
    \ descriptor.\n   msg:  The message buffer to be filled.\n   len:  The length\
    \ of the message buffer.\n   from:  A pointer to an address to be filled with\
    \ the address of the\n      sender of this message.\n   fromlen:  An in/out parameter\
    \ describing the from length.\n   sinfo:  A pointer to an sctp_sndrcvinfo structure\
    \ to be filled upon\n      receipt of the message.\n   msg_flags:  A pointer to\
    \ an integer to be filled with any message\n      flags (e.g., MSG_NOTIFICATION).\
    \  Note that this field is an in-out\n      field.  Options for the receive may\
    \ also be passed into the value\n      (e.g., MSG_PEEK).  On return from the call,\
    \ the msg_flags value\n      will be different than what was sent in to the call.\
    \  If\n      implemented via a recvmsg() call, the msg_flags parameter should\n\
    \      only contain the value of the flags from the recvmsg() call.\n   The call\
    \ returns the number of bytes received, or -1 if an error\n   occurred.  The variable\
    \ errno is then set appropriately.\n"
- title: 9.9.  sctp_connectx()
  contents:
  - "9.9.  sctp_connectx()\n   An implementation may provide a library function (or\
    \ possibly system\n   call) to assist the user with associating to an endpoint\
    \ that is\n   multi-homed.  Much like sctp_bindx(), this call allows a caller\
    \ to\n   specify multiple addresses at which a peer can be reached.  The way\n\
    \   the SCTP stack uses the list of addresses to set up the association\n   is\
    \ implementation dependent.  This function only specifies that the\n   stack will\
    \ try to make use of all of the addresses in the list when\n   needed.\n   Note\
    \ that the list of addresses passed in is only used for setting up\n   the association.\
    \  It does not necessarily equal the set of addresses\n   the peer uses for the\
    \ resulting association.  If the caller wants to\n   find out the set of peer\
    \ addresses, it must use sctp_getpaddrs() to\n   retrieve them after the association\
    \ has been set up.\n   The function prototype is\n   int sctp_connectx(int sd,\n\
    \                     struct sockaddr *addrs,\n                     int addrcnt,\n\
    \                     sctp_assoc_t *id);\n   and the arguments are\n   sd:  The\
    \ socket descriptor.\n   addrs:  An array of addresses.\n   addrcnt:  The number\
    \ of addresses in the array.\n   id:  An output parameter that, if passed in as\
    \ non-NULL, will return\n      the association identifier for the newly created\
    \ association (if\n      successful).\n   The call returns 0 on success or -1\
    \ if an error occurred.  The\n   variable errno is then set appropriately.\n"
- title: 9.10.  sctp_send() - DEPRECATED
  contents:
  - "9.10.  sctp_send() - DEPRECATED\n   This function is deprecated; sctp_sendv()\
    \ should be used instead.\n   An implementation may provide another alternative\
    \ function or system\n   call to assist an application with the sending of data\
    \ without the\n   use of the cmsghdr structures.\n   The function prototype is\n\
    \   ssize_t sctp_send(int sd,\n                     const void *msg,\n       \
    \              size_t len,\n                     const struct sctp_sndrcvinfo\
    \ *sinfo,\n                     int flags);\n   and the arguments are\n   sd:\
    \  The socket descriptor.\n   msg:  The message to be sent.\n   len:  The length\
    \ of the message.\n   sinfo:  A pointer to an sctp_sndrcvinfo structure used as\
    \ described\n      in Section 5.3.2 for a sendmsg() call.\n   flags:  The same\
    \ flags as used by the sendmsg() call flags (e.g.,\n      MSG_DONTROUTE).\n  \
    \ The call returns the number of bytes sent, or -1 if an error\n   occurred. \
    \ The variable errno is then set appropriately.\n   This function call may also\
    \ be used to terminate an association using\n   an association identifier by setting\
    \ the sinfo.sinfo_flags to\n   SCTP_EOF and the sinfo.sinfo_assoc_id to the association\
    \ that needs\n   to be terminated.  In such a case, len can be zero.\n   Using\
    \ sctp_send() on a non-connected one-to-one style socket for\n   implicit connection\
    \ setup may or may not work, depending on the SCTP\n   implementation.\n   Sending\
    \ a message using sctp_send() is atomic unless explicit EOR\n   marking is enabled\
    \ on the socket specified by sd.\n"
- title: 9.11.  sctp_sendx() - DEPRECATED
  contents:
  - "9.11.  sctp_sendx() - DEPRECATED\n   This function is deprecated; sctp_sendv()\
    \ should be used instead.\n   An implementation may provide another alternative\
    \ function or system\n   call to assist an application with the sending of data\
    \ without the\n   use of the cmsghdr structure, and to provide a list of addresses.\n\
    \   The list of addresses is provided for implicit association setup.  In\n  \
    \ such a case, the list of addresses serves the same purpose as the\n   addresses\
    \ given in sctp_connectx() (see Section 9.9).\n   The function prototype is\n\
    \   ssize_t sctp_sendx(int sd,\n                      const void *msg,\n     \
    \                 size_t len,\n                      struct sockaddr *addrs,\n\
    \                      int addrcnt,\n                      struct sctp_sndrcvinfo\
    \ *sinfo,\n                      int flags);\n   and the arguments are\n   sd:\
    \  The socket descriptor.\n   msg:  The message to be sent.\n   len:  The length\
    \ of the message.\n   addrs:  An array of addresses.\n   addrcnt:  The number\
    \ of addresses in the array.\n   sinfo:  A pointer to an sctp_sndrcvinfo structure\
    \ used as described\n      in Section 5.3.2 for a sendmsg() call.\n   flags: \
    \ The same flags as used by the sendmsg() call flags (e.g.,\n      MSG_DONTROUTE).\n\
    \   The call returns the number of bytes sent, or -1 if an error\n   occurred.\
    \  The variable errno is then set appropriately.\n   Note that in the case of\
    \ implicit connection setup, on return from\n   this call, the sinfo_assoc_id\
    \ field of the sinfo structure will\n   contain the new association identifier.\n\
    \   This function call may also be used to terminate an association using\n  \
    \ an association identifier by setting the sinfo.sinfo_flags to\n   SCTP_EOF and\
    \ the sinfo.sinfo_assoc_id to the association that needs\n   to be terminated.\
    \  In such a case, len would be zero.\n   Sending a message using sctp_sendx()\
    \ is atomic unless explicit EOR\n   marking is enabled on the socket specified\
    \ by sd.\n   Using sctp_sendx() on a non-connected one-to-one style socket for\n\
    \   implicit connection setup may or may not work, depending on the SCTP\n   implementation.\n"
- title: 9.12.  sctp_sendv()
  contents:
  - "9.12.  sctp_sendv()\n   The function prototype is\n   ssize_t sctp_sendv(int\
    \ sd,\n                      const struct iovec *iov,\n                      int\
    \ iovcnt,\n                      struct sockaddr *addrs,\n                   \
    \   int addrcnt,\n                      void *info,\n                      socklen_t\
    \ infolen,\n                      unsigned int infotype,\n                   \
    \   int flags);\n   The function sctp_sendv() provides an extensible way for an\n\
    \   application to communicate different send attributes to the SCTP\n   stack\
    \ when sending a message.  An implementation may provide\n   sctp_sendv() as a\
    \ library function or a system call.\n   This document defines three types of\
    \ attributes that can be used to\n   describe a message to be sent.  They are\
    \ struct sctp_sndinfo\n   (Section 5.3.4), struct sctp_prinfo (Section 5.3.7),\
    \ and struct\n   sctp_authinfo (Section 5.3.8).  The following structure,\n  \
    \ sctp_sendv_spa, is defined to be used when more than one of the above\n   attributes\
    \ are needed to describe a message to be sent.\n   struct sctp_sendv_spa {\n \
    \    uint32_t sendv_flags;\n     struct sctp_sndinfo sendv_sndinfo;\n     struct\
    \ sctp_prinfo sendv_prinfo;\n     struct sctp_authinfo sendv_authinfo;\n   };\n\
    \   The sendv_flags field holds a bitwise OR of SCTP_SEND_SNDINFO_VALID,\n   SCTP_SEND_PRINFO_VALID,\
    \ and SCTP_SEND_AUTHINFO_VALID indicating if\n   the sendv_sndinfo/sendv_prinfo/sendv_authinfo\
    \ fields contain valid\n   information.\n   In future, when new send attributes\
    \ are needed, new structures can be\n   defined.  But those new structures do\
    \ not need to be based on any of\n   the above defined structures.\n   The function\
    \ takes the following arguments:\n   sd:  The socket descriptor.\n   iov:  The\
    \ gather buffer.  The data in the buffer is treated as a\n      single user message.\n\
    \   iovcnt:  The number of elements in iov.\n   addrs:  An array of addresses\
    \ to be used to set up an association or\n      a single address to be used to\
    \ send the message.  NULL is passed\n      in if the caller neither wants to set\
    \ up an association nor wants\n      to send the message to a specific address.\n\
    \   addrcnt:  The number of addresses in the addrs array.\n   info:  A pointer\
    \ to the buffer containing the attribute associated\n      with the message to\
    \ be sent.  The type is indicated by the\n      info_type parameter.\n   infolen:\
    \  The length of info, in bytes.\n   infotype:  Identifies the type of the information\
    \ provided in info.\n      The current defined values are as follows:\n      SCTP_SENDV_NOINFO:\
    \  No information is provided.  The parameter\n         info is a NULL pointer,\
    \ and infolen is 0.\n      SCTP_SENDV_SNDINFO:  The parameter info is pointing\
    \ to a struct\n         sctp_sndinfo.\n      SCTP_SENDV_PRINFO:  The parameter\
    \ info is pointing to a struct\n         sctp_prinfo.\n      SCTP_SENDV_AUTHINFO:\
    \  The parameter info is pointing to a struct\n         sctp_authinfo.\n     \
    \ SCTP_SENDV_SPA:  The parameter info is pointing to a struct\n         sctp_sendv_spa.\n\
    \   flags:  The same flags as used by the sendmsg() call flags (e.g.,\n      MSG_DONTROUTE).\n\
    \   The call returns the number of bytes sent, or -1 if an error\n   occurred.\
    \  The variable errno is then set appropriately.\n   A note on the one-to-many\
    \ style socket: The struct sctp_sndinfo\n   attribute must always be used in order\
    \ to specify the association on\n   which the message is to be sent.  The only\
    \ case where it is not\n   needed is when this call is used to set up a new association.\n\
    \   The caller provides a list of addresses in the addrs parameter to set\n  \
    \ up an association.  This function will behave like calling\n   sctp_connectx()\
    \ (see Section 9.9), first using the list of addresses\n   and then calling sendmsg()\
    \ with the given message and attributes.\n   For a one-to-many style socket, if\
    \ the struct sctp_sndinfo attribute\n   is provided, the snd_assoc_id field must\
    \ be 0.  When this function\n   returns, the snd_assoc_id field will contain the\
    \ association\n   identifier of the newly established association.  Note that\
    \ the\n   struct sctp_sndinfo attribute is not required to set up an\n   association\
    \ for a one-to-many style socket.  If this attribute is not\n   provided, the\
    \ caller can enable the SCTP_ASSOC_CHANGE notification\n   and use the SCTP_COMM_UP\
    \ message to find out the association\n   identifier.\n   If the caller wants\
    \ to send the message to a specific peer address\n   (hence overriding the primary\
    \ address), it can provide the specific\n   address in the addrs parameter and\
    \ provide a struct sctp_sndinfo\n   attribute with the field snd_flags set to\
    \ SCTP_ADDR_OVER.\n   This function call may also be used to terminate an association.\
    \  The\n   caller provides an sctp_sndinfo attribute with the snd_flags set to\n\
    \   SCTP_EOF.  In this case, len would be zero.\n   Sending a message using sctp_sendv()\
    \ is atomic unless explicit EOR\n   marking is enabled on the socket specified\
    \ by sd.\n"
- title: 9.13.  sctp_recvv()
  contents:
  - "9.13.  sctp_recvv()\n   The function prototype is\n   ssize_t sctp_recvv(int\
    \ sd,\n                      const struct iovec *iov,\n                      int\
    \ iovlen,\n                      struct sockaddr *from,\n                    \
    \  socklen_t *fromlen,\n                      void *info,\n                  \
    \    socklen_t *infolen,\n                      unsigned int *infotype,\n    \
    \                  int *flags);\n   The function sctp_recvv() provides an extensible\
    \ way for the SCTP\n   stack to pass up different SCTP attributes associated with\
    \ a received\n   message to an application.  An implementation may provide\n \
    \  sctp_recvv() as a library function or as a system call.\n   This document defines\
    \ two types of attributes that can be returned by\n   this call: the attribute\
    \ of the received message and the attribute of\n   the next message in the receive\
    \ buffer.  The caller enables the\n   SCTP_RECVRCVINFO and SCTP_RECVNXTINFO socket\
    \ options, respectively,\n   to receive these attributes.  Attributes of the received\
    \ message are\n   returned in struct sctp_rcvinfo (Section 5.3.5), and attributes\
    \ of\n   the next message are returned in struct sctp_nxtinfo (Section 5.3.6).\n\
    \   If both options are enabled, both attributes are returned using the\n   following\
    \ structure.\n   struct sctp_recvv_rn {\n     struct sctp_rcvinfo recvv_rcvinfo;\n\
    \     struct sctp_nxtinfo recvv_nxtinfo;\n   };\n   In future, new structures\
    \ can be defined to hold new types of\n   attributes.  The new structures do not\
    \ need to be based on struct\n   sctp_recvv_rn or struct sctp_rcvinfo.\n   This\
    \ function takes the following arguments:\n   sd:  The socket descriptor.\n  \
    \ iov:  The scatter buffer.  Only one user message is returned in this\n     \
    \ buffer.\n   iovlen:  The number of elements in iov.\n   from:  A pointer to\
    \ an address to be filled with the sender of the\n      received message's address.\n\
    \   fromlen:  An in/out parameter describing the from length.\n   info:  A pointer\
    \ to the buffer to hold the attributes of the received\n      message.  The structure\
    \ type of info is determined by the\n      info_type parameter.\n   infolen: \
    \ An in/out parameter describing the size of the info buffer.\n   infotype:  On\
    \ return, *info_type is set to the type of the info\n      buffer.  The current\
    \ defined values are as follows:\n      SCTP_RECVV_NOINFO:  If both SCTP_RECVRCVINFO\
    \ and SCTP_RECVNXTINFO\n         options are not enabled, no attribute will be\
    \ returned.  If\n         only the SCTP_RECVNXTINFO option is enabled but there\
    \ is no\n         next message in the buffer, no attribute will be returned. \
    \ In\n         these cases, *info_type will be set to SCTP_RECVV_NOINFO.\n   \
    \   SCTP_RECVV_RCVINFO:  The type of info is struct sctp_rcvinfo, and\n      \
    \   the attribute relates to the received message.\n      SCTP_RECVV_NXTINFO:\
    \  The type of info is struct sctp_nxtinfo, and\n         the attribute relates\
    \ to the next message in the receive\n         buffer.  This is the case when\
    \ only the SCTP_RECVNXTINFO option\n         is enabled and there is a next message\
    \ in the buffer.\n      SCTP_RECVV_RN:  The type of info is struct sctp_recvv_rn.\
    \  The\n         recvv_rcvinfo field is the attribute of the received message,\n\
    \         and the recvv_nxtinfo field is the attribute of the next\n         message\
    \ in the buffer.  This is the case when both\n         SCTP_RECVRCVINFO and SCTP_RECVNXTINFO\
    \ options are enabled and\n         there is a next message in the receive buffer.\n\
    \   flags:  A pointer to an integer to be filled with any message flags\n    \
    \  (e.g., MSG_NOTIFICATION).  Note that this field is an in/out\n      parameter.\
    \  Options for the receive may also be passed into the\n      value (e.g., MSG_PEEK).\
    \  On return from the call, the flags value\n      will be different than what\
    \ was sent in to the call.  If\n      implemented via a recvmsg() call, the flags\
    \ should only contain\n      the value of the flags from the recvmsg() call when\
    \ calling\n      sctp_recvv(), and on return it has the value from msg_flags.\n\
    \   The call returns the number of bytes received, or -1 if an error\n   occurred.\
    \  The variable errno is then set appropriately.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   Many TCP and UDP implementations reserve port\
    \ numbers below 1024 for\n   privileged users.  If the target platform supports\
    \ privileged users,\n   the SCTP implementation should restrict the ability to\
    \ call bind() or\n   sctp_bindx() on these port numbers to privileged users.\n\
    \   Similarly, unprivileged users should not be able to set protocol\n   parameters\
    \ that could result in the congestion control algorithm\n   being more aggressive\
    \ than permitted on the public Internet.  These\n   parameters are as follows:\n\
    \   o  struct sctp_rtoinfo\n   If an unprivileged user inherits a one-to-many\
    \ style socket with open\n   associations on a privileged port, accepting new\
    \ associations might\n   be permitted, but opening new associations should not\
    \ be permitted.\n   This could be relevant for the r* family (rsh, rlogin, rwho,\
    \ ...) of\n   protocols.\n   Applications using the one-to-many style sockets\
    \ and using the\n   interleave level (if 0) are subject to denial-of-service attacks,\
    \ as\n   described in Section 8.1.20.\n   Applications needing transport layer\
    \ security can use Datagram\n   Transport Layer Security/SCTP (DTLS/SCTP) as specified\
    \ in [RFC6083].\n   This can be implemented using the sockets API described in\
    \ this\n   document.\n"
- title: 11.  Acknowledgments
  contents:
  - "11.  Acknowledgments\n   Special acknowledgment is given to Ken Fujita, Jonathan\
    \ Woods,\n   Qiaobing Xie, and La Monte Yarroll, who helped extensively in the\n\
    \   early formation of this document.\n   The authors also wish to thank Kavitha\
    \ Baratakke, Mike Bartlett,\n   Martin Becke, Jon Berger, Mark Butler, Thomas\
    \ Dreibholz, Andreas\n   Fink, Scott Kimble, Jonathan Leighton, Renee Revis, Irene\
    \ Ruengeler,\n   Dan Wing, and many others on the TSVWG mailing list for contributing\n\
    \   valuable comments.\n   A special thanks to Phillip Conrad, for his suggested\
    \ text, quick and\n   constructive insights, and most of all his persistent fighting\
    \ to\n   keep the interface to SCTP usable for the application programmer.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [IEEE-1003.1-2008]\n              Institute of\
    \ Electrical and Electronics Engineers,\n              \"Information Technology\
    \ - Portable Operating System\n              Interface (POSIX)\", IEEE Standard\
    \ 1003.1, 2008.\n   [RFC3493]  Gilligan, R., Thomson, S., Bound, J., McCann, J.,\
    \ and W.\n              Stevens, \"Basic Socket Interface Extensions for IPv6\"\
    ,\n              RFC 3493, February 2003.\n   [RFC3542]  Stevens, W., Thomas,\
    \ M., Nordmark, E., and T. Jinmei,\n              \"Advanced Sockets Application\
    \ Program Interface (API) for\n              IPv6\", RFC 3542, May 2003.\n   [RFC3758]\
    \  Stewart, R., Ramalho, M., Xie, Q., Tuexen, M., and P.\n              Conrad,\
    \ \"Stream Control Transmission Protocol (SCTP)\n              Partial Reliability\
    \ Extension\", RFC 3758, May 2004.\n   [RFC4895]  Tuexen, M., Stewart, R., Lei,\
    \ P., and E. Rescorla,\n              \"Authenticated Chunks for the Stream Control\
    \ Transmission\n              Protocol (SCTP)\", RFC 4895, August 2007.\n   [RFC4960]\
    \  Stewart, R., Ed., \"Stream Control Transmission Protocol\",\n             \
    \ RFC 4960, September 2007.\n   [RFC5061]  Stewart, R., Xie, Q., Tuexen, M., Maruyama,\
    \ S., and M.\n              Kozuka, \"Stream Control Transmission Protocol (SCTP)\n\
    \              Dynamic Address Reconfiguration\", RFC 5061,\n              September\
    \ 2007.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [RFC0768]  Postel, J., \"User Datagram Protocol\"\
    , STD 6, RFC 768,\n              August 1980.\n   [RFC0793]  Postel, J., \"Transmission\
    \ Control Protocol\", STD 7,\n              RFC 793, September 1981.\n   [RFC1644]\
    \  Braden, R., \"T/TCP -- TCP Extensions for Transactions\n              Functional\
    \ Specification\", RFC 1644, July 1994.\n   [RFC6083]  Tuexen, M., Seggelmann,\
    \ R., and E. Rescorla, \"Datagram\n              Transport Layer Security (DTLS)\
    \ for Stream Control\n              Transmission Protocol (SCTP)\", RFC 6083,\
    \ January 2011.\n   [RFC6247]  Eggert, L., \"Moving the Undeployed TCP Extensions\
    \ RFC\n              1072, RFC 1106, RFC 1110, RFC 1145, RFC 1146, RFC 1379,\n\
    \              RFC 1644, and RFC 1693 to Historic Status\", RFC 6247,\n      \
    \        May 2011.\n"
- title: Appendix A.  Example Using One-to-One Style Sockets
  contents:
  - "Appendix A.  Example Using One-to-One Style Sockets\n   The following code is\
    \ an implementation of a simple client that sends\n   a number of messages marked\
    \ for unordered delivery to an echo server\n   making use of all outgoing streams.\
    \  The example shows how to use\n   some features of one-to-one style IPv4 SCTP\
    \ sockets, including\n   o  Creating and connecting an SCTP socket.\n   o  Making\
    \ a request to negotiate a number of outgoing streams.\n   o  Determining the\
    \ negotiated number of outgoing streams.\n   o  Setting an adaptation layer indication.\n\
    \   o  Sending messages with a given payload protocol identifier on a\n      particular\
    \ stream using sctp_sendv().\n   <CODE BEGINS>\n   /*\n      Copyright (c) 2011\
    \ IETF Trust and the persons identified\n      as authors of the code.  All rights\
    \ reserved.\n      Redistribution and use in source and binary forms, with\n \
    \     or without modification, is permitted pursuant to, and subject\n      to\
    \ the license terms contained in, the Simplified BSD License\n      set forth\
    \ in Section 4.c of the IETF Trust's Legal Provisions\n      Relating to IETF\
    \ Documents (http://trustee.ietf.org/license-info).\n   */\n   #include <sys/types.h>\n\
    \   #include <sys/socket.h>\n   #include <netinet/in.h>\n   #include <netinet/sctp.h>\n\
    \   #include <arpa/inet.h>\n   #include <string.h>\n   #include <stdio.h>\n  \
    \ #include <unistd.h>\n   #include <stdlib.h>\n   #define PORT 9\n   #define ADDR\
    \ \"127.0.0.1\"\n   #define SIZE_OF_MESSAGE 1000\n   #define NUMBER_OF_MESSAGES\
    \ 10\n   #define PPID 1234\n   int\n   main(void) {\n     unsigned int i;\n  \
    \   int sd;\n     struct sockaddr_in addr;\n     char buffer[SIZE_OF_MESSAGE];\n\
    \     struct iovec iov;\n     struct sctp_status status;\n     struct sctp_initmsg\
    \ init;\n     struct sctp_sndinfo info;\n     struct sctp_setadaptation ind;\n\
    \     socklen_t opt_len;\n     /* Create a one-to-one style SCTP socket. */\n\
    \     if ((sd = socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP)) < 0) {\n       perror(\"\
    socket\");\n       exit(1);\n     }\n     /* Prepare for requesting 2048 outgoing\
    \ streams. */\n     memset(&init, 0, sizeof(init));\n     init.sinit_num_ostreams\
    \ = 2048;\n     if (setsockopt(sd, IPPROTO_SCTP, SCTP_INITMSG,\n             \
    \       &init, (socklen_t)sizeof(init)) < 0) {\n       perror(\"setsockopt\");\n\
    \       exit(1);\n     }\n     ind.ssb_adaptation_ind  = 0x01020304;\n     if\
    \ (setsockopt(sd, IPPROTO_SCTP, SCTP_ADAPTATION_LAYER,\n                    &ind,\
    \ (socklen_t)sizeof(ind)) < 0) {\n       perror(\"setsockopt\");\n       exit(1);\n\
    \     }\n     /* Connect to the discard server. */\n     memset(&addr, 0, sizeof(addr));\n\
    \   #ifdef HAVE_SIN_LEN\n     addr.sin_len         = sizeof(struct sockaddr_in);\n\
    \   #endif\n     addr.sin_family      = AF_INET;\n     addr.sin_port        =\
    \ htons(PORT);\n     addr.sin_addr.s_addr = inet_addr(ADDR);\n     if (connect(sd,\n\
    \                 (const struct sockaddr *)&addr,\n                 sizeof(struct\
    \ sockaddr_in)) < 0) {\n       perror(\"connect\");\n       exit(1);\n     }\n\
    \     /* Get the actual number of outgoing streams. */\n     memset(&status, 0,\
    \ sizeof(status));\n     opt_len = (socklen_t)sizeof(status);\n     if (getsockopt(sd,\
    \ IPPROTO_SCTP, SCTP_STATUS,\n                    &status, &opt_len) < 0) {\n\
    \       perror(\"getsockopt\");\n       exit(1);\n     }\n     memset(&info, 0,\
    \ sizeof(info));\n     info.snd_ppid = htonl(PPID);\n     info.snd_flags = SCTP_UNORDERED;\n\
    \     memset(buffer, 'A', SIZE_OF_MESSAGE);\n     iov.iov_base = buffer;\n   \
    \  iov.iov_len = SIZE_OF_MESSAGE;\n     for (i = 0; i <  NUMBER_OF_MESSAGES; i++)\
    \ {\n       info.snd_sid = i % status.sstat_outstrms;\n       if (sctp_sendv(sd,\n\
    \                      (const struct iovec *)&iov, 1,\n                      NULL,\
    \ 0,\n                      &info, sizeof(info), SCTP_SENDV_SNDINFO,\n       \
    \               0) < 0) {\n         perror(\"sctp_sendv\");\n         exit(1);\n\
    \       }\n     }\n     if (close(sd) < 0) {\n       perror(\"close\");\n    \
    \   exit(1);\n     }\n     return(0);\n   }\n   <CODE ENDS>\n"
- title: Appendix B.  Example Using One-to-Many Style Sockets
  contents:
  - "Appendix B.  Example Using One-to-Many Style Sockets\n   The following code is\
    \ a simple implementation of a discard server\n   over SCTP.  The example shows\
    \ how to use some features of one-to-many\n   style IPv6 SCTP sockets, including\n\
    \   o  Opening and binding of a socket.\n   o  Enabling notifications.\n   o \
    \ Handling notifications.\n   o  Configuring the auto-close timer.\n   o  Using\
    \ sctp_recvv() to receive messages.\n   Please note that this server can be used\
    \ in combination with the\n   client described in Appendix A.\n   <CODE BEGINS>\n\
    \   /*\n      Copyright (c) 2011 IETF Trust and the persons identified\n     \
    \ as authors of the code.  All rights reserved.\n      Redistribution and use\
    \ in source and binary forms, with\n      or without modification, is permitted\
    \ pursuant to, and subject\n      to the license terms contained in, the Simplified\
    \ BSD License\n      set forth in Section 4.c of the IETF Trust's Legal Provisions\n\
    \      Relating to IETF Documents (http://trustee.ietf.org/license-info).\n  \
    \ */\n   #include <sys/types.h>\n   #include <sys/socket.h>\n   #include <netinet/in.h>\n\
    \   #include <netinet/sctp.h>\n   #include <arpa/inet.h>\n   #include <string.h>\n\
    \   #include <stdio.h>\n   #include <stdlib.h>\n   #include <unistd.h>\n   #define\
    \ BUFFER_SIZE (1<<16)\n   #define PORT 9\n   #define ADDR \"0.0.0.0\"\n   #define\
    \ TIMEOUT 5\n   static void\n   print_notification(void *buf)\n   {\n     struct\
    \ sctp_assoc_change *sac;\n     struct sctp_paddr_change *spc;\n     struct sctp_adaptation_event\
    \ *sad;\n     union sctp_notification *snp;\n     char addrbuf[INET6_ADDRSTRLEN];\n\
    \     const char *ap;\n     struct sockaddr_in *sin;\n     struct sockaddr_in6\
    \ *sin6;\n     snp = buf;\n     switch (snp->sn_header.sn_type) {\n     case SCTP_ASSOC_CHANGE:\n\
    \       sac = &snp->sn_assoc_change;\n       printf(\"^^^ Association change:\
    \ \");\n       switch (sac->sac_state) {\n       case SCTP_COMM_UP:\n        \
    \ printf(\"Communication up (streams (in/out)=(%u/%u)).\\n\",\n              \
    \  sac->sac_inbound_streams, sac->sac_outbound_streams);\n         break;\n  \
    \     case SCTP_COMM_LOST:\n         printf(\"Communication lost (error=%d).\\\
    n\", sac->sac_error);\n         break;\n       case SCTP_RESTART:\n         printf(\"\
    Communication restarted (streams (in/out)=(%u/%u).\\n\",\n                sac->sac_inbound_streams,\
    \ sac->sac_outbound_streams);\n         break;\n       case SCTP_SHUTDOWN_COMP:\n\
    \         printf(\"Communication completed.\\n\");\n         break;\n       case\
    \ SCTP_CANT_STR_ASSOC:\n         printf(\"Communication couldn't be started.\\\
    n\");\n         break;\n       default:\n         printf(\"Unknown state: %d.\\\
    n\", sac->sac_state);\n         break;\n       }\n       break;\n     case SCTP_PEER_ADDR_CHANGE:\n\
    \       spc = &snp->sn_paddr_change;\n       if (spc->spc_aaddr.ss_family == AF_INET)\
    \ {\n         sin = (struct sockaddr_in *)&spc->spc_aaddr;\n         ap = inet_ntop(AF_INET,\
    \ &sin->sin_addr,\n                        addrbuf, INET6_ADDRSTRLEN);\n     \
    \  } else {\n         sin6 = (struct sockaddr_in6 *)&spc->spc_aaddr;\n       \
    \  ap = inet_ntop(AF_INET6, &sin6->sin6_addr,\n                        addrbuf,\
    \ INET6_ADDRSTRLEN);\n       }\n       printf(\"^^^ Peer Address change: %s \"\
    , ap);\n       switch (spc->spc_state) {\n       case SCTP_ADDR_AVAILABLE:\n \
    \        printf(\"is available.\\n\");\n         break;\n       case SCTP_ADDR_UNREACHABLE:\n\
    \         printf(\"is not available (error=%d).\\n\", spc->spc_error);\n     \
    \    break;\n       case SCTP_ADDR_REMOVED:\n         printf(\"was removed.\\\
    n\");\n         break;\n       case SCTP_ADDR_ADDED:\n         printf(\"was added.\\\
    n\");\n         break;\n       case SCTP_ADDR_MADE_PRIM:\n         printf(\"is\
    \ primary.\\n\");\n         break;\n       default:\n         printf(\"unknown\
    \ state (%d).\\n\", spc->spc_state);\n         break;\n       }\n       break;\n\
    \     case SCTP_SHUTDOWN_EVENT:\n       printf(\"^^^ Shutdown received.\\n\");\n\
    \       break;\n     case SCTP_ADAPTATION_INDICATION:\n       sad = &snp->sn_adaptation_event;\n\
    \       printf(\"^^^ Adaptation indication 0x%08x received.\\n\",\n          \
    \    sad->sai_adaptation_ind);\n       break;\n     default:\n       printf(\"\
    ^^^ Unknown event of type: %u.\\n\",\n              snp->sn_header.sn_type);\n\
    \       break;\n     };\n   }\n   int\n   main(void) {\n     int sd, flags, timeout,\
    \ on;\n     ssize_t n;\n     unsigned int i;\n     union {\n       struct sockaddr\
    \ sa;\n       struct sockaddr_in sin;\n       struct sockaddr_in6 sin6;\n    \
    \ } addr;\n     socklen_t fromlen, infolen;\n     struct sctp_rcvinfo info;\n\
    \     unsigned int infotype;\n     struct iovec iov;\n     char buffer[BUFFER_SIZE];\n\
    \     struct sctp_event event;\n     uint16_t event_types[] = {SCTP_ASSOC_CHANGE,\n\
    \                               SCTP_PEER_ADDR_CHANGE,\n                     \
    \          SCTP_SHUTDOWN_EVENT,\n                               SCTP_ADAPTATION_INDICATION};\n\
    \     /* Create a one-to-many style SCTP socket. */\n     if ((sd = socket(AF_INET6,\
    \ SOCK_SEQPACKET, IPPROTO_SCTP)) < 0) {\n       perror(\"socket\");\n       exit(1);\n\
    \     }\n     /* Enable the events of interest. */\n     memset(&event, 0, sizeof(event));\n\
    \     event.se_assoc_id = SCTP_FUTURE_ASSOC;\n     event.se_on = 1;\n     for\
    \ (i = 0; i < sizeof(event_types)/sizeof(uint16_t); i++) {\n       event.se_type\
    \ = event_types[i];\n       if (setsockopt(sd, IPPROTO_SCTP, SCTP_EVENT,\n   \
    \                   &event, sizeof(event)) < 0) {\n         perror(\"setsockopt\"\
    );\n         exit(1);\n       }\n     }\n     /* Configure auto-close timer. */\n\
    \     timeout = TIMEOUT;\n     if (setsockopt(sd, IPPROTO_SCTP, SCTP_AUTOCLOSE,\n\
    \                    &timeout, sizeof(timeout)) < 0) {\n       perror(\"setsockopt\
    \ SCTP_AUTOCLOSE\");\n       exit(1);\n     }\n     /* Enable delivery of SCTP_RCVINFO.\
    \ */\n     on = 1;\n     if (setsockopt(sd, IPPROTO_SCTP, SCTP_RECVRCVINFO,\n\
    \                    &on, sizeof(on)) < 0) {\n       perror(\"setsockopt SCTP_RECVRCVINFO\"\
    );\n       exit(1);\n     }\n     /* Bind the socket to all local addresses. */\n\
    \     memset(&addr, 0, sizeof(addr));\n   #ifdef HAVE_SIN6_LEN\n     addr.sin6.sin6_len\
    \         = sizeof(addr.sin6);\n   #endif\n     addr.sin6.sin6_family      = AF_INET6;\n\
    \     addr.sin6.sin6_port        = htons(PORT);\n     addr.sin6.sin6_addr    \
    \    = in6addr_any;\n     if (bind(sd, &addr.sa, sizeof(addr.sin6)) < 0) {\n \
    \      perror(\"bind\");\n       exit(1);\n     }\n     /* Enable accepting associations.\
    \ */\n     if (listen(sd, 1) < 0) {\n       perror(\"listen\");\n       exit(1);\n\
    \     }\n     for (;;) {\n       flags = 0;\n       memset(&addr, 0, sizeof(addr));\n\
    \       fromlen = (socklen_t)sizeof(addr);\n       memset(&info, 0, sizeof(info));\n\
    \       infolen = (socklen_t)sizeof(info);\n       infotype = 0;\n       iov.iov_base\
    \ = buffer;\n       iov.iov_len = BUFFER_SIZE;\n       n = sctp_recvv(sd, &iov,\
    \ 1,\n                      &addr.sa, &fromlen,\n                      &info,\
    \ &infolen, &infotype,\n                      &flags);\n       if (flags & MSG_NOTIFICATION)\
    \ {\n         print_notification(iov.iov_base);\n       } else {\n         char\
    \ addrbuf[INET6_ADDRSTRLEN];\n         const char *ap;\n         in_port_t port;\n\
    \         if (addr.sa.sa_family == AF_INET) {\n                ap = inet_ntop(AF_INET,\
    \ &addr.sin.sin_addr,\n                               addrbuf, INET6_ADDRSTRLEN);\n\
    \                port = ntohs(addr.sin.sin_port);\n         } else {\n       \
    \         ap = inet_ntop(AF_INET6, &addr.sin6.sin6_addr,\n                   \
    \            addrbuf, INET6_ADDRSTRLEN);\n                port = ntohs(addr.sin6.sin6_port);\n\
    \         }\n         printf(\"Message received from %s:%u: len=%d\",\n      \
    \          ap, port, (int)n);\n         switch (infotype) {\n         case SCTP_RECVV_RCVINFO:\n\
    \           printf(\", sid=%u\", info.rcv_sid);\n           if (info.rcv_flags\
    \ & SCTP_UNORDERED) {\n             printf(\", unordered\");\n           } else\
    \ {\n             printf(\", ssn=%u\", info.rcv_ssn);\n           }\n        \
    \   printf(\", tsn=%u\", info.rcv_tsn);\n           printf(\", ppid=%u.\\n\",\
    \ ntohl(info.rcv_ppid));\n           break;\n         case SCTP_RECVV_NOINFO:\n\
    \         case SCTP_RECVV_NXTINFO:\n         case SCTP_RECVV_RN:\n           printf(\"\
    .\\n\");\n           break;\n         default:\n           printf(\" unknown infotype.\\\
    n\");\n         }\n       }\n     }\n     if (close(sd) < 0) {\n       perror(\"\
    close\");\n       exit(1);\n     }\n     return (0);\n   }\n   <CODE ENDS>\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Randall R. Stewart\n   Adara Networks\n   Chapin, SC \
    \ 29036\n   USA\n   EMail: randall@lakerest.net\n   Michael Tuexen\n   Muenster\
    \ University of Applied Sciences\n   Stegerwaldstr. 39\n   48565 Steinfurt\n \
    \  Germany\n   EMail: tuexen@fh-muenster.de\n   Kacheong Poon\n   Oracle Corporation\n\
    \   EMail: ka-cheong.poon@oracle.com\n   Peter Lei\n   Cisco Systems, Inc.\n \
    \  9501 Technology Blvd.\n   West Office Center\n   Rosemont, IL  60018\n   USA\n\
    \   EMail: peterlei@cisco.com\n   Vladislav Yasevich\n   HP\n   110 Spitrook Rd.\n\
    \   Nashua, NH  03062\n   USA\n   EMail: vladislav.yasevich@hp.com\n"
