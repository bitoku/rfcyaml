- title: __initial_text__
  contents:
  - '                   On Queuing, Marking, and Dropping

    '
- title: Abstract
  contents:
  - "Abstract\n   This note discusses queuing and marking/dropping algorithms.  While\n\
    \   these algorithms may be implemented in a coupled manner, this note\n   argues\
    \ that specifications, measurements, and comparisons should\n   decouple the different\
    \ algorithms and their contributions to system\n   behavior.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7806.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   2\n   2.  Fair Queuing: Algorithms and History  . . . . . . . .\
    \ . . . .   3\n     2.1.  Generalized Processor Sharing . . . . . . . . . . .\
    \ . . .   3\n       2.1.1.  GPS Comparisons: Transmission Quanta  . . . . . .\
    \ . .   4\n       2.1.2.  GPS Comparisons: Flow Definition  . . . . . . . . .\
    \ .   4\n       2.1.3.  GPS Comparisons: Unit of Measurement  . . . . . . . .\
    \   5\n     2.2.  GPS Approximations  . . . . . . . . . . . . . . . . . . .  \
    \ 5\n       2.2.1.  Definition of a Queuing Algorithm . . . . . . . . . .   5\n\
    \       2.2.2.  Round-Robin Models  . . . . . . . . . . . . . . . . .   6\n  \
    \     2.2.3.  Calendar Queue Models . . . . . . . . . . . . . . . .   7\n    \
    \   2.2.4.  Work-Conserving Models and Stochastic Fairness\n               Queuing\
    \ . . . . . . . . . . . . . . . . . . . . . . .   9\n       2.2.5.  Non-Work-Conserving\
    \ Models and Virtual Clock  . . . .   9\n   3.  Queuing, Marking, and Dropping\
    \  . . . . . . . . . . . . . . .  10\n     3.1.  Queuing with Tail Mark/Drop .\
    \ . . . . . . . . . . . . . .  11\n     3.2.  Queuing with CoDel Mark/Drop  .\
    \ . . . . . . . . . . . . .  11\n     3.3.  Queuing with RED or PIE Mark/Drop\
    \ . . . . . . . . . . . .  11\n   4.  Conclusion  . . . . . . . . . . . . . .\
    \ . . . . . . . . . . .  12\n   5.  Security Considerations . . . . . . . . .\
    \ . . . . . . . . . .  13\n   6.  References  . . . . . . . . . . . . . . . .\
    \ . . . . . . . . .  13\n     6.1.  Normative References  . . . . . . . . . .\
    \ . . . . . . . .  13\n     6.2.  Informative References  . . . . . . . . . .\
    \ . . . . . . .  13\n   Acknowledgements  . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  15\n   Authors' Addresses  . . . . . . . . . . . . . . . . . .\
    \ . . . . .  16\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   In the discussion of Active Queue Management (AQM), there\
    \ has been\n   discussion of the coupling of queue management algorithms such\
    \ as\n   Stochastic Fairness Queuing [SFQ], Virtual Clock [VirtualClock], or\n\
    \   Deficit Round Robin [DRR] with mark/drop algorithms such as\n   Controlled\
    \ Delay (CoDel) [DELAY-AQM] or Proportional Integral\n   controller Enhanced (PIE)\
    \ [AQM-PIE].  In the interest of clarifying\n   the discussion, we document possible\
    \ implementation approaches to\n   that and analyze the possible effects and side\
    \ effects.  The language\n   and model derive from the Architecture for Differentiated\
    \ Services\n   [RFC2475].\n   This note is informational and is intended to describe\
    \ reasonable\n   possibilities without constraining outcomes.  This is not so\
    \ much\n   about \"right\" or \"wrong\" as it is \"what might be reasonable\"\
    \ and\n   discusses several possible implementation strategies.  Also, while\n\
    \   queuing might be implemented in almost any layer, the note\n   specifically\
    \ addresses queues that might be used in the\n   Differentiated Services Architecture\
    \ and are therefore at or below\n   the IP layer.\n"
- title: '2.  Fair Queuing: Algorithms and History'
  contents:
  - "2.  Fair Queuing: Algorithms and History\n   There is extensive history in the\
    \ set of algorithms collectively\n   referred to as \"fair queuing\".  The model\
    \ was initially discussed in\n   [RFC970], which proposed it hypothetically as\
    \ a solution to the TCP\n   Silly Window Syndrome issue in BSD 4.1.  The problem\
    \ was that, due to\n   a TCP implementation bug, some senders would settle into\
    \ sending a\n   long stream of very short segments, which unnecessarily consumed\n\
    \   bandwidth on TCP and IP headers and occupied short packet buffers,\n   thereby\
    \ disrupting competing sessions.  Nagle suggested that if\n   packet streams were\
    \ sorted by their source address and the sources\n   treated in a round-robin\
    \ fashion, a sender's effect on end-to-end\n   latency and increased loss rate\
    \ would primarily affect only itself.\n   This touched off perhaps a decade of\
    \ work by various researchers on\n   what was and is termed \"fair queuing\",\
    \ philosophical discussions of\n   the meaning of the word \"fair\", operational\
    \ reasons that one might\n   want a \"weighted\" or \"predictably unfair\" queuing\
    \ algorithm, and so\n   on.\n"
- title: 2.1.  Generalized Processor Sharing
  contents:
  - "2.1.  Generalized Processor Sharing\n   Conceptually, any fair queuing algorithm\
    \ attempts to implement some\n   approximation to the Generalized Processor Sharing\
    \ [GPS] model.\n   The GPS model, in its essence, presumes that a set of identified\
    \ data\n   streams, called \"flows\", pass through an interface.  Each flow has\
    \ a\n   rate when measured over a period of time; a voice session might, for\n\
    \   example, require 64 kbit/s plus whatever overhead is necessary to\n   deliver\
    \ it, and a TCP session might have variable throughput\n   depending on where\
    \ it is in its evolution.  The premise of\n   Generalized Processor Sharing is\
    \ that on all time scales, the flow\n   occupies a predictable bit rate so that\
    \ if there is enough bandwidth\n   for the flow in the long term, it also lacks\
    \ nothing in the short\n   term.  \"All time scales\" is obviously untenable in\
    \ a packet network\n   -- and even in a traditional Time-Division Multiplexer\
    \ (TDM) circuit\n   switch network -- because a timescale shorter than the duration\
    \ of a\n   packet will only see one packet at a time.  However, it provides an\n\
    \   ideal for other models to be compared against.\n   There are a number of attributes\
    \ of approximations to the GPS model\n   that bear operational consideration,\
    \ including at least the\n   transmission quanta, the definition of a \"flow\"\
    , and the unit of\n   measurement.  Implementation approaches have different practical\n\
    \   impacts as well.\n"
- title: '2.1.1.  GPS Comparisons: Transmission Quanta'
  contents:
  - "2.1.1.  GPS Comparisons: Transmission Quanta\n   The most obvious comparison\
    \ between the GPS model and common\n   approximations to it is that real world\
    \ data is not delivered\n   uniformly, but in some quantum.  The smallest quantum\
    \ in a packet\n   network is a packet.  But quanta can be larger; for example,\
    \ in video\n   applications, it is common to describe data flow in frames per\n\
    \   second, where a frame describes a picture on a screen or the changes\n   made\
    \ from a previous one.  A single video frame is commonly on the\n   order of tens\
    \ of packets.  If a codec is delivering thirty frames per\n   second, it is conceivable\
    \ that the packets comprising a frame might\n   be sent as thirty bursts per second,\
    \ with each burst sent at the\n   interface rate of the camera or other sender.\
    \  Similarly, TCP\n   exchanges have an initial window (common values of which\
    \ include 1,\n   2, 3, 4 [RFC3390], and 10 [RFC6928]), and there are also reports\
    \ of\n   bursts of 64 KB at the relevant Maximum Segment Size (MSS), which is\n\
    \   to say about 45 packets in one burst, presumably coming from TCP\n   Segment\
    \ Offload ((TSO) also called TCP Offload Engine (TOE)) engines\n   (at least one\
    \ implementation is known to be able to send a burst of\n   256 KB).  After that\
    \ initial burst, TCP senders commonly send pairs\n   of packets but may send either\
    \ smaller or larger bursts [RFC5690].\n"
- title: '2.1.2.  GPS Comparisons: Flow Definition'
  contents:
  - "2.1.2.  GPS Comparisons: Flow Definition\n   An important engineering trade-off\
    \ relevant to GPS is the definition\n   of a \"flow\".  A flow is, by definition,\
    \ a defined data stream.\n   Common definitions include:\n   o  packets in a single\
    \ transport layer session (\"microflow\"),\n      identified by a five-tuple [RFC2990];\n\
    \   o  packets between a single pair of addresses, identified by a source\n  \
    \    and destination address or prefix;\n   o  packets from a single source address\
    \ or prefix [RFC970];\n   o  packets to a single destination address or prefix;\
    \ and\n   o  packets to or from a single subscriber, customer, or peer\n     \
    \ [RFC6057].  In Service Provider operations, this might be a\n      neighboring\
    \ Autonomous System; in broadband, this might be a\n      residential customer.\n\
    \   The difference should be apparent.  Consider a comparison between\n   sorting\
    \ by source address or destination address, to pick two\n   examples, in the case\
    \ that a given router interface has N application\n   sessions going through it\
    \ between N/2 local destinations and N remote\n   sources.  Sorting by source,\
    \ or in this case by source/destination\n   pair, would give each remote peer\
    \ an upper-bound guarantee of 1/N of\n   the available capacity, which might be\
    \ distributed very unevenly\n   among the local destinations.  Sorting by destination\
    \ would give each\n   local destination an upper-bound guarantee of 2/N of the\
    \ available\n   capacity, which might be distributed very unevenly among the remote\n\
    \   systems and correlated sessions.  Who is one fair to?  In both cases,\n  \
    \ they deliver equal service by their definition, but that might not be\n   someone\
    \ else's definition.\n   Flow fairness, and the implications of TCP's congestion\
    \ avoidance\n   algorithms, is discussed extensively in [NoFair].\n"
- title: '2.1.3.  GPS Comparisons: Unit of Measurement'
  contents:
  - "2.1.3.  GPS Comparisons: Unit of Measurement\n   And finally, there is the question\
    \ of what is measured for rate.  If\n   the only objective is to force packet\
    \ streams to not dominate each\n   other, it is sufficient to count packets. \
    \ However, if the issue is\n   the bit rate of a Service Level Agreement (SLA),\
    \ one must consider\n   the sizes of the packets (the aggregate throughput of\
    \ a flow measured\n   in bits or bytes).  If predictable unfairness is a consideration,\
    \ the\n   value must be weighted accordingly.\n   [RFC7141] discusses measurement.\n"
- title: 2.2.  GPS Approximations
  contents:
  - "2.2.  GPS Approximations\n   Carrying the matter further, a queuing algorithm\
    \ may also be termed\n   \"work conserving\" or \"non work conserving\".  A queue\
    \ in a work-\n   conserving algorithm, by definition, is either empty, in which\
    \ case\n   no attempt is being made to dequeue data from it, or contains\n   something,\
    \ in which case the algorithm continuously tries to empty\n   the queue.  A work-conserving\
    \ queue that contains queued data at an\n   interface with a given rate will deliver\
    \ data at that rate until it\n   empties.  A non-work-conserving queue might stop\
    \ delivering even\n   though it still contains data.  A common reason for doing\
    \ this is to\n   impose an artificial upper bound on a class of traffic that is\
    \ lower\n   than the rate of the underlying physical interface.\n"
- title: 2.2.1.  Definition of a Queuing Algorithm
  contents:
  - "2.2.1.  Definition of a Queuing Algorithm\n   In the discussion following, we\
    \ assume a basic definition of a\n   queuing algorithm.  A queuing algorithm has,\
    \ at minimum:\n   o  some form of internal storage for the elements kept in the\
    \ queue;\n   o  if it has multiple internal classifications, then it has\n   \
    \   *  a method for classifying elements and\n      *  additional storage for\
    \ the classifier and implied classes;\n   o  potentially, a method for creating\
    \ the queue;\n   o  potentially, a method for destroying the queue;\n   o  an\
    \ enqueuing method for placing packets into the queue or queuing\n      system;\
    \ and\n   o  a dequeuing method for removing packets from the queue or queuing\n\
    \      system.\n   There may also be other information or methods, such as the\
    \ ability\n   to inspect the queue.  It also often has inspectable external\n\
    \   attributes, such as the total volume of packets or bytes in queue,\n   and\
    \ may have limit thresholds, such as a maximum number of packets or\n   bytes\
    \ the queue might hold.\n   For example, a simple FIFO queue has a linear data\
    \ structure,\n   enqueues packets at the tail, and dequeues packets from the head.\
    \  It\n   might have a maximum queue depth and a current queue depth maintained\n\
    \   in packets or bytes.\n"
- title: 2.2.2.  Round-Robin Models
  contents:
  - "2.2.2.  Round-Robin Models\n   One class of implementation approaches, generically\
    \ referred to as\n   \"Weighted Round Robin\" (WRR), implements the structure\
    \ of the queue\n   as an array or ring of subqueues associated with flows for\
    \ whatever\n   definition of a flow is important.\n   The arriving packet must,\
    \ of course, first be classified.  If a hash\n   is used as a classifier, the\
    \ hash result might be used as an array\n   index, selecting the subqueue that\
    \ the packet will go into.  One can\n   imagine other classifiers, such as using\
    \ a Differentiated Services\n   Code Point (DSCP) value as an index into an array\
    \ containing the\n   queue number for a flow, or more complex access list implementations.\n\
    \   In any event, a subqueue contains the traffic for a flow, and data is\n  \
    \ sent from each subqueue in succession.\n   Upon entering the queue, the enqueue\
    \ method places a classified\n   packet into a simple FIFO subqueue.\n   On dequeue,\
    \ the subqueues are searched in round-robin order, and when\n   a subqueue is\
    \ identified that contains data, the dequeue method\n   removes a specified quantum\
    \ of data from it.  That quantum is at\n   minimum a packet, but it may be more.\
    \  If the system is intended to\n   maintain a byte rate, there will be memory\
    \ between searches of the\n   excess previously dequeued.\n                  \
    \          +-+\n                          +>|1|\n                          | +-+\n\
    \                          |  |\n                          | +-+             \
    \  +-+\n                          | |1|             +>|3|\n                  \
    \        | +-+             | +-+\n                          |  |             \
    \ |  |\n                          | +-+      +-+    | +-+\n                  \
    \        | |1|    +>|2|    | |3|\n                          | +-+    | +-+   \
    \ | +-+\n                          |  A     |  A     |  A\n                  \
    \        |  |     |  |     |  |\n                         ++--++   ++--++   ++--++\n\
    \                      +->| Q  |-->| Q  |-->| Q  |--+\n                      |\
    \  +----+   +----+   +----+  |\n                      +----------------------------+\n\
    \                       Figure 1: Round-Robin Queues\n"
- title: 2.2.3.  Calendar Queue Models
  contents:
  - "2.2.3.  Calendar Queue Models\n   Another class of implementation approaches,\
    \ generically referred to\n   as Calendar Queue Implementations [CalendarQueue],\
    \ implements the\n   structure of the queue as an array or ring of subqueues (often\
    \ called\n   \"buckets\") associated with time or sequence; each bucket contains\
    \ the\n   set of packets, which may be null, intended to be sent at a certain\n\
    \   time or following the emptying of the previous bucket.  The queue\n   structure\
    \ includes a look-aside table that indicates the current\n   depth (which is to\
    \ say, the next bucket) of any given class of\n   traffic, which might similarly\
    \ be identified using a hash, a DSCP, an\n   access list, or any other classifier.\
    \  Conceptually, the queues each\n   contain zero or more packets from each class\
    \ of traffic.  One is the\n   queue being emptied \"now\"; the rest are associated\
    \ with some time or\n   sequence in the future.  The characteristics under \"\
    load\" have been\n   investigated in [Deadline].\n   Upon entering the queue,\
    \ the enqueue method, considering a classified\n   packet, determines the current\
    \ depth of that class with a view to\n   scheduling it for transmission at some\
    \ time or sequence in the\n   future.  If the unit of scheduling is a packet and\
    \ the queuing\n   quantum is one packet per subqueue, a burst of packets arrives\
    \ in a\n   given flow, and if at the start the flow has no queued data, the\n\
    \   first packet goes into the \"next\" queue, the second into its\n   successor,\
    \ and so on.  If there was some data in the class, the first\n   packet in the\
    \ burst would go into the bucket pointed to by the look-\n   aside table.  If\
    \ the unit of scheduling is time, the explanation in\n   Section 2.2.5 might be\
    \ simplest to follow, but the bucket selected\n   will be the bucket corresponding\
    \ to a given transmission time in the\n   future.  A necessary side effect, memory\
    \ being finite, is that there\n   exist a finite number of \"future\" buckets.\
    \  If enough traffic arrives\n   to cause a class to wrap, one is forced to drop\
    \ something (tail\n   drop).\n   On dequeue, the buckets are searched at their\
    \ stated times or in\n   their stated sequence, and when a bucket is identified\
    \ that contains\n   data, the dequeue method removes a specified quantum of data\
    \ from it\n   and, by extension, from the associated traffic classes.  A single\n\
    \   bucket might contain data from a number of classes simultaneously.\n     \
    \                        +-+\n                           +>|1|\n             \
    \              | +-+\n                           |  |\n                      \
    \     | +-+      +-+\n                           | |2|    +>|2|\n            \
    \               | +-+    | +-+\n                           |  |     |  |\n   \
    \                        | +-+    | +-+      +-+\n                           |\
    \ |3|    | |1|    +>|1|\n                           | +-+    | +-+    | +-+\n\
    \                           |  A     |  A     |  A\n                         \
    \  |  |     |  |     |  |\n                          ++--++   ++--++   ++--++\n\
    \                  \"now\"+->| Q  |-->| Q  |-->| Q  |-->...\n                \
    \          +----+   +----+   +----+\n                             A       A  \
    \       A\n                             |3      |2        |1\n               \
    \           +++++++++++++++++++++++\n                          ||||     Flow \
    \     ||||\n                          +++++++++++++++++++++++\n              \
    \           Figure 2: Calendar Queue\n   In any event, a subqueue contains the\
    \ traffic for a point in time or\n   a point in sequence, and data is sent from\
    \ each subqueue in\n   succession.  If subqueues are associated with time, an\
    \ interesting\n   end case develops: if the system is draining a given subqueue\
    \ and the\n   time of the next subqueue arrives, what should the system do?  One\n\
    \   potentially valid line of reasoning would have it continue delivering\n  \
    \ the data in the present queue on the assumption that it will likely\n   trade\
    \ off for time in the next.  Another potentially valid line of\n   reasoning would\
    \ have it discard any waiting data in the present queue\n   and move to the next.\n"
- title: 2.2.4.  Work-Conserving Models and Stochastic Fairness Queuing
  contents:
  - "2.2.4.  Work-Conserving Models and Stochastic Fairness Queuing\n   Stochastic\
    \ Fairness Queuing [SFQ] is an example of a work-conserving\n   algorithm.  This\
    \ algorithm measures packets and considers a \"flow\" to\n   be an equivalence\
    \ class of traffic defined by a hashing algorithm\n   over the source and destination\
    \ IPv4 addresses.  As packets arrive,\n   the enqueue method performs the indicated\
    \ hash and places the packet\n   into the indicated subqueue.  The dequeue method\
    \ operates as\n   described in Section 2.2.2; subqueues are inspected in round-robin\n\
    \   sequence and a packet is removed if they contain one or more packets.\n  \
    \ The Deficit Round Robin [DRR] model modifies the quanta to bytes and\n   deals\
    \ with variable length packets.  A subqueue descriptor contains a\n   waiting\
    \ quantum (the amount intended to be dequeued on the previous\n   dequeue attempt\
    \ that was not satisfied), a per-round quantum (the\n   subqueue is intended to\
    \ dequeue a certain number of bytes each\n   round), and a maximum to permit (some\
    \ multiple of the MTU).  In each\n   dequeue attempt, the dequeue method sets\
    \ the waiting quantum to the\n   smaller of the maximum quantum and the sum of\
    \ the waiting and\n   incremental quantum.  It then dequeues up to the waiting\
    \ quantum (in\n   bytes) of packets in the queue and reduces the waiting quantum\
    \ by the\n   number of bytes dequeued.  Since packets will not normally be exactly\n\
    \   the size of the quantum, some dequeue attempts will dequeue more than\n  \
    \ others, but they will over time average the incremental quantum per\n   round\
    \ if there is data present.\n   [SFQ] and [DRR] could be implemented as described\
    \ in Section 2.2.3.\n   The weakness of a classical WRR approach is the search\
    \ time expended\n   inspecting and not choosing sub-queues that contain no data\
    \ or not\n   enough to trigger a transmission from them.\n"
- title: 2.2.5.  Non-Work-Conserving Models and Virtual Clock
  contents:
  - "2.2.5.  Non-Work-Conserving Models and Virtual Clock\n   Virtual Clock [VirtualClock]\
    \ is an example of a non-work-conserving\n   algorithm.  It is trivially implemented\
    \ as described in\n   Section 2.2.3.  It associates buckets with intervals in\
    \ time that\n   have durations on the order of microseconds to tens of milliseconds.\n\
    \   Each flow is assigned a rate in bytes per interval.  The flow entry\n   maintains\
    \ a point in time the \"next\" packet in the flow should be\n   scheduled.\n \
    \  On enqueue, the method determines whether the \"next schedule\" time is\n \
    \  \"in the past\"; if so, the packet is scheduled \"now\", and if not, the\n\
    \   packet is scheduled at that time.  It then calculates the new \"next\n   schedule\"\
    \ time as the current \"next schedule\" time plus the length of\n   the packet\
    \ divided by the rate.  If the resulting time is also in the\n   past, the \"\
    next schedule\" time is set to \"now\"; otherwise, it is set\n   to the calculated\
    \ time.  As noted in Section 2.2.3, there is an\n   interesting point regarding\
    \ \"too much time in the future\"; if a\n   packet is scheduled too far into the\
    \ future, it may be marked or\n   dropped in the AQM procedure, and if it runs\
    \ beyond the end of the\n   queuing system, may be defensively tail dropped.\n\
    \   On dequeue, the bucket associated with the time \"now\" is inspected.\n  \
    \ If it contains a packet, the packet is dequeued and transmitted.  If\n   the\
    \ bucket is empty and the time for the next bucket has not arrived,\n   the system\
    \ waits, even if there is a packet in the next bucket.  As\n   noted in Section\
    \ 2.2.3, there is an interesting point regarding the\n   queue associated with\
    \ \"now\".  If a subsequent bucket, even if it is\n   actually empty, would be\
    \ delayed by the transmission of a packet, one\n   could imagine marking the packet\
    \ Explicit Congestion Notification -\n   Congestion Experienced (ECN-CE) [RFC3168]\
    \ [RFC6679] or dropping the\n   packet.\n"
- title: 3.  Queuing, Marking, and Dropping
  contents:
  - "3.  Queuing, Marking, and Dropping\n   Queuing, marking, and dropping are integrated\
    \ in any system that has\n   a queue.  If nothing else, as memory is finite, a\
    \ system has to drop\n   as discussed in Sections 2.2.3 and 2.2.5 in order to\
    \ protect itself.\n   However, host transports interpret drops as signals, so\
    \ AQM\n   algorithms use that as a mechanism to signal.\n   It is useful to think\
    \ of the effects of queuing as a signal as well.\n   The receiver sends acknowledgements\
    \ as data is received, so the\n   arrival of acknowledgements at the sender paces\
    \ the sender at\n   approximately the average rate it is able to achieve through\
    \ the\n   network.  This is true even if the sender keeps an arbitrarily large\n\
    \   amount of data stored in network queues and is the basis for delay-\n   based\
    \ congestion control algorithms.  So, delaying a packet\n   momentarily in order\
    \ to permit another session to improve its\n   operation has the effect of signaling\
    \ a slightly lower capacity to\n   the sender.\n"
- title: 3.1.  Queuing with Tail Mark/Drop
  contents:
  - "3.1.  Queuing with Tail Mark/Drop\n   In the default case in which a FIFO queue\
    \ is used with defensive tail\n   drop only, the effect is to signal to the sender\
    \ in two ways:\n   o  Ack clocking, which involves pacing the sender to send at\n\
    \      approximately the rate it can deliver data to the receiver; and\n   o \
    \ Defensive loss, which is when a sender sends faster than available\n      capacity\
    \ (such as by probing network capacity when fully utilizing\n      that capacity)\
    \ and overburdens a queue.\n"
- title: 3.2.  Queuing with CoDel Mark/Drop
  contents:
  - "3.2.  Queuing with CoDel Mark/Drop\n   In any case wherein a queuing algorithm\
    \ is used along with CoDel\n   [DELAY-AQM], the sequence of events is that a packet\
    \ is time stamped,\n   enqueued, dequeued, compared to a subsequent reading of\
    \ the clock,\n   and then acted on, whether by dropping it, marking and forwarding\
    \ it,\n   or simply forwarding it.  This is to say that the only drop algorithm\n\
    \   inherent in queuing is the defensive drop when the queue's resources\n   are\
    \ overrun.  However, the intention of marking or dropping is to\n   signal to\
    \ the sender much earlier when a certain amount of delay has\n   been observed.\
    \  In a FIFO+CoDel, Virtual Clock+CoDel, or FlowQueue-\n   Codel [FQ-CODEL] implementation,\
    \ the queuing algorithm is completely\n   separate from the AQM algorithm.  Using\
    \ them in series results in\n   four signals to the sender:\n   o  Ack clocking,\
    \ which involves pacing the sender to send at\n      approximately the rate it\
    \ can deliver data to the receiver through\n      a queue;\n   o  Lossless signaling\
    \ that a certain delay threshold has been\n      reached, if ECN [RFC3168] [RFC6679]\
    \ is in use;\n   o  Intentional signaling via loss that a certain delay threshold\
    \ has\n      been reached, if ECN is not in use; and\n   o  Defensive loss, which\
    \ is when a sender sends faster than available\n      capacity (such as by probing\
    \ network capacity when fully utilizing\n      that capacity) and overburdens\
    \ a queue.\n"
- title: 3.3.  Queuing with RED or PIE Mark/Drop
  contents:
  - "3.3.  Queuing with RED or PIE Mark/Drop\n   In any case wherein a queuing algorithm\
    \ is used along with PIE\n   [AQM-PIE], Random Early Detection (RED) [RFC7567],\
    \ or other such\n   algorithms, the sequence of events is that a queue is inspected,\
    \ a\n   packet is dropped, marked, or left unchanged, enqueued, dequeued,\n  \
    \ compared to a subsequent reading of the clock, and then forwarded on.\n   This\
    \ is to say that the AQM Mark/Drop Algorithm precedes enqueue; if\n   it has not\
    \ been effective and as a result the queue is out of\n   resources anyway, the\
    \ defensive drop algorithm steps in, and failing\n   that, the queue operates\
    \ in whatever way it does.  Hence, in a\n   FIFO+PIE, SFQ+PIE, or Virtual Clock+PIE\
    \ implementation, the queuing\n   algorithm is again completely separate from\
    \ the AQM algorithm.  Using\n   them in series results in four signals to the\
    \ sender:\n   o  Ack clocking, which involves pacing the sender to send at\n \
    \     approximately the rate it can deliver data to the receiver through\n   \
    \   a queue;\n   o  Lossless signaling that a queue depth that corresponds to\
    \ a\n      certain delay threshold has been reached, if ECN is in use;\n   o \
    \ Intentional signaling via loss that a queue depth that corresponds\n      to\
    \ a certain delay threshold has been reached, if ECN is not in\n      use; and\n\
    \   o  Defensive loss, which is when a sender sends faster than available\n  \
    \    capacity (such as by probing network capacity when fully utilizing\n    \
    \  that capacity) and overburdens a queue.\n"
- title: 4.  Conclusion
  contents:
  - "4.  Conclusion\n   To summarize, in Section 2, implementation approaches for\
    \ several\n   classes of queuing algorithms were explored.  Queuing algorithms\
    \ such\n   as SFQ, Virtual Clock, and FlowQueue-Codel [FQ-CODEL] have value in\n\
    \   the network in that they delay packets to enforce a rate upper bound\n   or\
    \ to permit competing flows to compete more effectively.  ECN\n   marking and\
    \ loss are also useful signals if used in a manner that\n   enhances TCP / Steam\
    \ Control Transmission Protocol (SCTP) operation\n   or restrains unmanaged UDP\
    \ data flows.\n   Conceptually, queuing algorithms and mark/drop algorithms operate\
    \ in\n   series (as discussed in Section 3), not as a single algorithm.  The\n\
    \   observed effects differ: defensive loss protects the intermediate\n   system\
    \ and provides a signal, AQM mark/drop works to reduce mean\n   latency, and the\
    \ scheduling of flows works to modify flow interleave\n   and acknowledgement\
    \ pacing.  Certain features like flow isolation are\n   provided by fair-queuing-related\
    \ designs but are not the effect of\n   the mark/drop algorithm.\n   There is\
    \ value in implementing and coupling the operation of both\n   queuing algorithms\
    \ and queue management algorithms, and there is\n   definitely interesting research\
    \ in this area, but specifications,\n   measurements, and comparisons should decouple\
    \ the different\n   algorithms and their contributions to system behavior.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   This memo adds no new security issues; it observes\
    \ implementation\n   strategies for Diffserv implementation.\n"
- title: 6.  References
  contents:
  - '6.  References

    '
- title: 6.1.  Normative References
  contents:
  - "6.1.  Normative References\n   [RFC2475]   Blake, S., Black, D., Carlson, M.,\
    \ Davies, E., Wang, Z.,\n               and W. Weiss, \"An Architecture for Differentiated\n\
    \               Services\", RFC 2475, DOI 10.17487/RFC2475, December 1998,\n \
    \              <http://www.rfc-editor.org/info/rfc2475>.\n"
- title: 6.2.  Informative References
  contents:
  - "6.2.  Informative References\n   [AQM-PIE]   Pan, R., Natarajan, P., and F. Baker,\
    \ \"PIE: A Lightweight\n               Control Scheme To Address the Bufferbloat\
    \ Problem\", Work\n               in Progress, draft-ietf-aqm-pie-06, April 2016.\n\
    \   [CalendarQueue]\n               Brown, R., \"Calendar queues: a fast 0(1)\
    \ priority queue\n               implementation for the simulation event set problem\"\
    ,\n               Communications of the ACM Volume 21, Issue 10, pp.\n       \
    \        1220-1227, DOI 10.1145/63039.63045, October 1988,\n               <http://dl.acm.org/citation.cfm?id=63045>.\n\
    \   [Deadline]  Kruk, L., Lohoczky, J., Ramanan, K., and S. Shreve,\n        \
    \       \"Heavy Traffic Analysis For EDF Queues With Reneging\",\n           \
    \    The Annals of Applied Probability Volume 21, Issue No. 2,\n             \
    \  pp. 484-545, DOI 10.1214/10-AAP681, 2011,\n               <http://www.math.cmu.edu/users/shreve/Reneging.pdf>.\n\
    \   [DELAY-AQM] Nichols, K., Jacobson, V., McGregor, A., and J. Iyengar,\n   \
    \            \"Controlled Delay Active Queue Management\", Work in\n         \
    \      Progress, draft-ietf-aqm-codel-03, March 2016.\n   [DRR]       Shreedhar,\
    \ M. and G. Varghese, \"Efficient fair queuing\n               using deficit round-robin\"\
    , IEEE/ACM Transactions on\n               Networking Volume 4, Issue 3, pp. 375-385,\n\
    \               DOI 10.1109/90.502236, June 1996,\n               <http://ieeexplore.ieee.org/stamp/\n\
    \               stamp.jsp?tp=&arnumber=502236>.\n   [FQ-CODEL]  Hoeiland-Joergensen,\
    \ T., McKenney, P., Taht, D., Gettys,\n               J., and E. Dumazet, \"The\
    \ FlowQueue-CoDel Packet Scheduler\n               and Active Queue Management\
    \ Algorithm\", Work in Progress,\n               draft-ietf-aqm-fq-codel-06, March\
    \ 2016.\n   [GPS]       Demers, A., University of California, Berkeley, and Xerox\n\
    \               PARC, \"Analysis and Simulation of a Fair Queueing\n         \
    \      Algorithm\", ACM SIGCOMM Computer Communication\n               Review,\
    \ Volume 19, Issue 4, pp. 1-12,\n               DOI 10.1145/75247.75248, September\
    \ 1989,\n               <http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/\n\
    \               data/89/fq.pdf>.\n   [NoFair]    Briscoe, B., \"Flow rate fairness:\
    \ dismantling a\n               religion\", ACM SIGCOMM Computer Communication\n\
    \               Review, Volume 37, Issue 2, pp. 63-74,\n               DOI 10.1145/1232919.1232926,\
    \ April 2007,\n               <http://dl.acm.org/citation.cfm?id=1232926>.\n \
    \  [RFC970]    Nagle, J., \"On Packet Switches With Infinite Storage\",\n    \
    \           RFC 970, DOI 10.17487/RFC0970, December 1985,\n               <http://www.rfc-editor.org/info/rfc970>.\n\
    \   [RFC2990]   Huston, G., \"Next Steps for the IP QoS Architecture\",\n    \
    \           RFC 2990, DOI 10.17487/RFC2990, November 2000,\n               <http://www.rfc-editor.org/info/rfc2990>.\n\
    \   [RFC3168]   Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition\n  \
    \             of Explicit Congestion Notification (ECN) to IP\",\n           \
    \    RFC 3168, DOI 10.17487/RFC3168, September 2001,\n               <http://www.rfc-editor.org/info/rfc3168>.\n\
    \   [RFC3390]   Allman, M., Floyd, S., and C. Partridge, \"Increasing\n      \
    \         TCP's Initial Window\", RFC 3390, DOI 10.17487/RFC3390,\n          \
    \     October 2002, <http://www.rfc-editor.org/info/rfc3390>.\n   [RFC5690]  \
    \ Floyd, S., Arcia, A., Ros, D., and J. Iyengar, \"Adding\n               Acknowledgement\
    \ Congestion Control to TCP\", RFC 5690,\n               DOI 10.17487/RFC5690,\
    \ February 2010,\n               <http://www.rfc-editor.org/info/rfc5690>.\n \
    \  [RFC6057]   Bastian, C., Klieber, T., Livingood, J., Mills, J., and\n     \
    \          R.  Woundy, \"Comcast's Protocol-Agnostic Congestion\n            \
    \   Management System\", RFC 6057, DOI 10.17487/RFC6057,\n               December\
    \ 2010, <http://www.rfc-editor.org/info/rfc6057>.\n   [RFC6679]   Westerlund,\
    \ M., Johansson, I., Perkins, C., O'Hanlon, P.,\n               and K. Carlberg,\
    \ \"Explicit Congestion Notification (ECN)\n               for RTP over UDP\"\
    , RFC 6679, DOI 10.17487/RFC6679, August\n               2012, <http://www.rfc-editor.org/info/rfc6679>.\n\
    \   [RFC6928]   Chu, J., Dukkipati, N., Cheng, Y., and M. Mathis,\n          \
    \     \"Increasing TCP's Initial Window\", RFC 6928,\n               DOI 10.17487/RFC6928,\
    \ April 2013,\n               <http://www.rfc-editor.org/info/rfc6928>.\n   [RFC7141]\
    \   Briscoe, B. and J. Manner, \"Byte and Packet Congestion\n               Notification\"\
    , BCP 41, RFC 7141, DOI 10.17487/RFC7141,\n               February 2014, <http://www.rfc-editor.org/info/rfc7141>.\n\
    \   [RFC7567]   Baker, F., Ed. and G. Fairhurst, Ed., \"IETF\n               Recommendations\
    \ Regarding Active Queue Management\",\n               BCP 197, RFC 7567, DOI\
    \ 10.17487/RFC7567, July 2015,\n               <http://www.rfc-editor.org/info/rfc7567>.\n\
    \   [SFQ]       Mckenney, P., \"Stochastic Fairness Queuing\", Proceedings\n \
    \              of IEEE INFOCOM '90, Volume 2, pp. 733-740,\n               DOI\
    \ 10.1109/INFCOM.1990.91316, June 1990,\n               <http://www2.rdrop.com/~paulmck/scalability/paper/\n\
    \               sfq.2002.06.04.pdf>.\n   [VirtualClock]\n               Zhang,\
    \ L., \"VirtualClock: A New Traffic Control Algorithm\n               for Packet\
    \ Switching Networks\", Proceedings of the ACM\n               Symposium on Communications\
    \ Architectures and\n               Protocols, Volume 20, DOI 10.1145/99508.99525,\
    \ September\n               1990, <http://dl.acm.org/citation.cfm?id=99508.99525>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   This note grew out of, and is in response to, mailing list\n\
    \   discussions in AQM, in which some have pushed an algorithm to compare\n  \
    \ to AQM marking and dropping algorithms, but which includes flow\n   queuing.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Fred Baker\n   Cisco Systems\n   Santa Barbara, California\
    \  93117\n   United States\n   Email: fred@cisco.com\n   Rong Pan\n   Cisco Systems\n\
    \   Milpitas, California  95035\n   United States\n   Email: ropan@cisco.com\n"
