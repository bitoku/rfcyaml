- contents:
  - '                       JSON Web Encryption (JWE)

    '
  title: __initial_text__
- contents:
  - "Abstract\n   JSON Web Encryption (JWE) represents encrypted content using\n   JSON-based
    data structures.  Cryptographic algorithms and identifiers\n   for use with this
    specification are described in the separate JSON\n   Web Algorithms (JWA) specification
    and IANA registries defined by\n   that specification.  Related digital signature
    and Message\n   Authentication Code (MAC) capabilities are described in the separate\n
    \  JSON Web Signature (JWS) specification.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7516.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   4\n     1.1.  Notational Conventions  . . . . . . . . . . . . . .
    . . .   4\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . .
    .   5\n   3.  JSON Web Encryption (JWE) Overview  . . . . . . . . . . . . .   8\n
    \    3.1.  JWE Compact Serialization Overview  . . . . . . . . . . .   8\n     3.2.
    \ JWE JSON Serialization Overview . . . . . . . . . . . . .   9\n     3.3.  Example
    JWE . . . . . . . . . . . . . . . . . . . . . . .  10\n   4.  JOSE Header . .
    . . . . . . . . . . . . . . . . . . . . . . .  11\n     4.1.  Registered Header
    Parameter Names . . . . . . . . . . . .  11\n       4.1.1.  \"alg\" (Algorithm)
    Header Parameter  . . . . . . . . .  12\n       4.1.2.  \"enc\" (Encryption Algorithm)
    Header Parameter . . . .  12\n       4.1.3.  \"zip\" (Compression Algorithm) Header
    Parameter  . . .  12\n       4.1.4.  \"jku\" (JWK Set URL) Header Parameter  .
    . . . . . . .  13\n       4.1.5.  \"jwk\" (JSON Web Key) Header Parameter . .
    . . . . . .  13\n       4.1.6.  \"kid\" (Key ID) Header Parameter . . . . . .
    . . . . .  13\n       4.1.7.  \"x5u\" (X.509 URL) Header Parameter  . . . . .
    . . . .  13\n       4.1.8.  \"x5c\" (X.509 Certificate Chain) Header Parameter
    \ . .  13\n       4.1.9.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header\n
    \              Parameter . . . . . . . . . . . . . . . . . . . . . .  14\n       4.1.10.
    \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint)\n               Header Parameter
    \ . . . . . . . . . . . . . . . . . .  14\n       4.1.11. \"typ\" (Type) Header
    Parameter . . . . . . . . . . . .  14\n       4.1.12. \"cty\" (Content Type) Header
    Parameter . . . . . . . .  14\n       4.1.13. \"crit\" (Critical) Header Parameter
    \ . . . . . . . . .  14\n     4.2.  Public Header Parameter Names . . . . . .
    . . . . . . . .  14\n     4.3.  Private Header Parameter Names  . . . . . . .
    . . . . . .  15\n   5.  Producing and Consuming JWEs  . . . . . . . . . . . .
    . . . .  15\n     5.1.  Message Encryption  . . . . . . . . . . . . . . . . .
    . .  15\n     5.2.  Message Decryption  . . . . . . . . . . . . . . . . . . .
    \ 17\n     5.3.  String Comparison Rules . . . . . . . . . . . . . . . . .  20\n
    \  6.  Key Identification  . . . . . . . . . . . . . . . . . . . . .  20\n   7.
    \ Serializations  . . . . . . . . . . . . . . . . . . . . . . .  20\n     7.1.
    \ JWE Compact Serialization . . . . . . . . . . . . . . . .  20\n     7.2.  JWE
    JSON Serialization  . . . . . . . . . . . . . . . . .  20\n       7.2.1.  General
    JWE JSON Serialization Syntax . . . . . . . .  21\n       7.2.2.  Flattened JWE
    JSON Serialization Syntax . . . . . . .  23\n   8.  TLS Requirements  . . . .
    . . . . . . . . . . . . . . . . . .  24\n   9.  Distinguishing between JWS and
    JWE Objects  . . . . . . . . .  24\n   10. IANA Considerations . . . . . . . .
    . . . . . . . . . . . . .  25\n     10.1.  JSON Web Signature and Encryption Header
    Parameters\n            Registration . . . . . . . . . . . . . . . . . . . . .
    .  25\n       10.1.1.  Registry Contents  . . . . . . . . . . . . . . . . .  25\n
    \  11. Security Considerations . . . . . . . . . . . . . . . . . . .  27\n     11.1.
    \ Key Entropy and Random Values  . . . . . . . . . . . . .  27\n     11.2.  Key
    Protection . . . . . . . . . . . . . . . . . . . . .  27\n     11.3.  Using Matching
    Algorithm Strengths . . . . . . . . . . .  28\n     11.4.  Adaptive Chosen-Ciphertext
    Attacks . . . . . . . . . . .  28\n     11.5.  Timing Attacks . . . . . . . .
    . . . . . . . . . . . . .  28\n   12. References  . . . . . . . . . . . . . .
    . . . . . . . . . . .  29\n     12.1.  Normative References . . . . . . . . .
    . . . . . . . . .  29\n     12.2.  Informative References . . . . . . . . . .
    . . . . . . .  30\n   Appendix A.  JWE Examples . . . . . . . . . . . . . . .
    . . . . .  32\n     A.1.  Example JWE using RSAES-OAEP and AES GCM  . . . . .
    . . .  32\n       A.1.1.  JOSE Header . . . . . . . . . . . . . . . . . . . .
    .  32\n       A.1.2.  Content Encryption Key (CEK)  . . . . . . . . . . . .  32\n
    \      A.1.3.  Key Encryption  . . . . . . . . . . . . . . . . . . .  33\n       A.1.4.
    \ Initialization Vector . . . . . . . . . . . . . . . .  34\n       A.1.5.  Additional
    Authenticated Data . . . . . . . . . . . .  35\n       A.1.6.  Content Encryption
    \ . . . . . . . . . . . . . . . . .  35\n       A.1.7.  Complete Representation
    . . . . . . . . . . . . . . .  36\n       A.1.8.  Validation  . . . . . . . .
    . . . . . . . . . . . . .  36\n     A.2.  Example JWE using RSAES-PKCS1-v1_5 and\n
    \          AES_128_CBC_HMAC_SHA_256  . . . . . . . . . . . . . . . .  36\n       A.2.1.
    \ JOSE Header . . . . . . . . . . . . . . . . . . . . .  37\n       A.2.2.  Content
    Encryption Key (CEK)  . . . . . . . . . . . .  37\n       A.2.3.  Key Encryption
    \ . . . . . . . . . . . . . . . . . . .  38\n       A.2.4.  Initialization Vector
    . . . . . . . . . . . . . . . .  39\n       A.2.5.  Additional Authenticated Data
    . . . . . . . . . . . .  40\n       A.2.6.  Content Encryption  . . . . . . .
    . . . . . . . . . .  40\n       A.2.7.  Complete Representation . . . . . . .
    . . . . . . . .  40\n       A.2.8.  Validation  . . . . . . . . . . . . . . .
    . . . . . .  41\n     A.3.  Example JWE Using AES Key Wrap and\n           AES_128_CBC_HMAC_SHA_256
    \ . . . . . . . . . . . . . . . .  41\n       A.3.1.  JOSE Header . . . . . .
    . . . . . . . . . . . . . . .  41\n       A.3.2.  Content Encryption Key (CEK)
    \ . . . . . . . . . . . .  42\n       A.3.3.  Key Encryption  . . . . . . . .
    . . . . . . . . . . .  42\n       A.3.4.  Initialization Vector . . . . . . .
    . . . . . . . . .  42\n       A.3.5.  Additional Authenticated Data . . . . .
    . . . . . . .  43\n       A.3.6.  Content Encryption  . . . . . . . . . . . .
    . . . . .  43\n       A.3.7.  Complete Representation . . . . . . . . . . . .
    . . .  43\n       A.3.8.  Validation  . . . . . . . . . . . . . . . . . . . .
    .  44\n     A.4.  Example JWE Using General JWE JSON Serialization  . . . .  44\n
    \      A.4.1.  JWE Per-Recipient Unprotected Headers . . . . . . . .  45\n       A.4.2.
    \ JWE Protected Header  . . . . . . . . . . . . . . . .  45\n       A.4.3.  JWE
    Shared Unprotected Header . . . . . . . . . . . .  45\n       A.4.4.  Complete
    JOSE Header Values . . . . . . . . . . . . .  45\n       A.4.5.  Additional Authenticated
    Data . . . . . . . . . . . .  46\n       A.4.6.  Content Encryption  . . . . .
    . . . . . . . . . . . .  46\n       A.4.7.  Complete JWE JSON Serialization Representation
    \ . . .  47\n     A.5.  Example JWE Using Flattened JWE JSON Serialization  .
    . .  47\n   Appendix B.  Example AES_128_CBC_HMAC_SHA_256 Computation . . . .
    \ 48\n     B.1.  Extract MAC_KEY and ENC_KEY from Key  . . . . . . . . . .  48\n
    \    B.2.  Encrypt Plaintext to Create Ciphertext  . . . . . . . . .  49\n     B.3.
    \ 64-Bit Big-Endian Representation of AAD Length  . . . . .  49\n     B.4.  Initialization
    Vector Value . . . . . . . . . . . . . . .  49\n     B.5.  Create Input to HMAC
    Computation  . . . . . . . . . . . .  50\n     B.6.  Compute HMAC Value  . . .
    . . . . . . . . . . . . . . . .  50\n     B.7.  Truncate HMAC Value to Create
    Authentication Tag  . . . .  50\n   Acknowledgements  . . . . . . . . . . . .
    . . . . . . . . . . . .  50\n   Authors' Addresses  . . . . . . . . . . . . .
    . . . . . . . . . .  51\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   JSON Web Encryption (JWE) represents encrypted content using
    JSON-\n   based data structures [RFC7159].  The JWE cryptographic mechanisms\n
    \  encrypt and provide integrity protection for an arbitrary sequence of\n   octets.\n
    \  Two closely related serializations for JWEs are defined.  The JWE\n   Compact
    Serialization is a compact, URL-safe representation intended\n   for space constrained
    environments such as HTTP Authorization headers\n   and URI query parameters.
    \ The JWE JSON Serialization represents JWEs\n   as JSON objects and enables the
    same content to be encrypted to\n   multiple parties.  Both share the same cryptographic
    underpinnings.\n   Cryptographic algorithms and identifiers for use with this\n
    \  specification are described in the separate JSON Web Algorithms (JWA)\n   [JWA]
    specification and IANA registries defined by that\n   specification.  Related
    digital signature and MAC capabilities are\n   described in the separate JSON
    Web Signature (JWS) [JWS]\n   specification.\n   Names defined by this specification
    are short because a core goal is\n   for the resulting representations to be compact.\n"
  - contents:
    - "1.1.  Notational Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
      RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
      as described in\n   \"Key words for use in RFCs to Indicate Requirement Levels\"
      [RFC2119].\n   The interpretation should only be applied when the terms appear
      in\n   all capital letters.\n   BASE64URL(OCTETS) denotes the base64url encoding
      of OCTETS, per\n   Section 2 of [JWS].\n   UTF8(STRING) denotes the octets of
      the UTF-8 [RFC3629] representation\n   of STRING, where STRING is a sequence
      of zero or more Unicode\n   [UNICODE] characters.\n   ASCII(STRING) denotes
      the octets of the ASCII [RFC20] representation\n   of STRING, where STRING is
      a sequence of zero or more ASCII\n   characters.\n   The concatenation of two
      values A and B is denoted as A || B.\n"
    title: 1.1.  Notational Conventions
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The terms \"JSON Web Signature (JWS)\", \"Base64url Encoding\",\n
    \  \"Collision-Resistant Name\", \"Header Parameter\", \"JOSE Header\", and\n
    \  \"StringOrURI\" are defined by the JWS specification [JWS].\n   The terms \"Ciphertext\",
    \"Digital Signature\", \"Initialization Vector\n   (IV)\", \"Message Authentication
    Code (MAC)\", and \"Plaintext\" are\n   defined by the \"Internet Security Glossary,
    Version 2\" [RFC4949].\n   These terms are defined by this specification:\n   JSON
    Web Encryption (JWE)\n      A data structure representing an encrypted and integrity-protected\n
    \     message.\n   Authenticated Encryption with Associated Data (AEAD)\n      An
    AEAD algorithm is one that encrypts the plaintext, allows\n      Additional Authenticated
    Data to be specified, and provides an\n      integrated content integrity check
    over the ciphertext and\n      Additional Authenticated Data.  AEAD algorithms
    accept two inputs,\n      the plaintext and the Additional Authenticated Data
    value, and\n      produce two outputs, the ciphertext and the Authentication Tag\n
    \     value.  AES Galois/Counter Mode (GCM) is one such algorithm.\n   Additional
    Authenticated Data (AAD)\n      An input to an AEAD operation that is integrity
    protected but not\n      encrypted.\n   Authentication Tag\n      An output of
    an AEAD operation that ensures the integrity of the\n      ciphertext and the
    Additional Authenticated Data.  Note that some\n      algorithms may not use an
    Authentication Tag, in which case this\n      value is the empty octet sequence.\n
    \  Content Encryption Key (CEK)\n      A symmetric key for the AEAD algorithm
    used to encrypt the\n      plaintext to produce the ciphertext and the Authentication
    Tag.\n   JWE Encrypted Key\n      Encrypted Content Encryption Key value.  Note
    that for some\n      algorithms, the JWE Encrypted Key value is specified as being
    the\n      empty octet sequence.\n   JWE Initialization Vector\n      Initialization
    Vector value used when encrypting the plaintext.\n      Note that some algorithms
    may not use an Initialization Vector, in\n      which case this value is the empty
    octet sequence.\n   JWE AAD\n      Additional value to be integrity protected
    by the authenticated\n      encryption operation.  This can only be present when
    using the JWE\n      JSON Serialization.  (Note that this can also be achieved
    when\n      using either the JWE Compact Serialization or the JWE JSON\n      Serialization
    by including the AAD value as an integrity-protected\n      Header Parameter value,
    but at the cost of the value being double\n      base64url encoded.)\n   JWE Ciphertext\n
    \     Ciphertext value resulting from authenticated encryption of the\n      plaintext
    with Additional Authenticated Data.\n   JWE Authentication Tag\n      Authentication
    Tag value resulting from authenticated encryption\n      of the plaintext with
    Additional Authenticated Data.\n   JWE Protected Header\n      JSON object that
    contains the Header Parameters that are integrity\n      protected by the authenticated
    encryption operation.  These\n      parameters apply to all recipients of the
    JWE.  For the JWE\n      Compact Serialization, this comprises the entire JOSE
    Header.  For\n      the JWE JSON Serialization, this is one component of the JOSE\n
    \     Header.\n   JWE Shared Unprotected Header\n      JSON object that contains
    the Header Parameters that apply to all\n      recipients of the JWE that are
    not integrity protected.  This can\n      only be present when using the JWE JSON
    Serialization.\n   JWE Per-Recipient Unprotected Header\n      JSON object that
    contains Header Parameters that apply to a single\n      recipient of the JWE.
    \ These Header Parameter values are not\n      integrity protected.  This can
    only be present when using the JWE\n      JSON Serialization.\n   JWE Compact
    Serialization\n      A representation of the JWE as a compact, URL-safe string.\n
    \  JWE JSON Serialization\n      A representation of the JWE as a JSON object.
    \ The JWE JSON\n      Serialization enables the same content to be encrypted to
    multiple\n      parties.  This representation is neither optimized for compactness\n
    \     nor URL safe.\n   Key Management Mode\n      A method of determining the
    Content Encryption Key value to use.\n      Each algorithm used for determining
    the CEK value uses a specific\n      Key Management Mode.  Key Management Modes
    employed by this\n      specification are Key Encryption, Key Wrapping, Direct
    Key\n      Agreement, Key Agreement with Key Wrapping, and Direct Encryption.\n
    \  Key Encryption\n      A Key Management Mode in which the CEK value is encrypted
    to the\n      intended recipient using an asymmetric encryption algorithm.\n   Key
    Wrapping\n      A Key Management Mode in which the CEK value is encrypted to the\n
    \     intended recipient using a symmetric key wrapping algorithm.\n   Direct
    Key Agreement\n      A Key Management Mode in which a key agreement algorithm
    is used\n      to agree upon the CEK value.\n   Key Agreement with Key Wrapping\n
    \     A Key Management Mode in which a key agreement algorithm is used\n      to
    agree upon a symmetric key used to encrypt the CEK value to the\n      intended
    recipient using a symmetric key wrapping algorithm.\n   Direct Encryption\n      A
    Key Management Mode in which the CEK value used is the secret\n      symmetric
    key value shared between the parties.\n"
  title: 2.  Terminology
- contents:
  - "3.  JSON Web Encryption (JWE) Overview\n   JWE represents encrypted content using
    JSON data structures and\n   base64url encoding.  These JSON data structures MAY
    contain\n   whitespace and/or line breaks before or after any JSON values or\n
    \  structural characters, in accordance with Section 2 of RFC 7159\n   [RFC7159].
    \ A JWE represents these logical values (each of which is\n   defined in Section
    2):\n   o  JOSE Header\n   o  JWE Encrypted Key\n   o  JWE Initialization Vector\n
    \  o  JWE AAD\n   o  JWE Ciphertext\n   o  JWE Authentication Tag\n   For a JWE,
    the JOSE Header members are the union of the members of\n   these values (each
    of which is defined in Section 2):\n   o  JWE Protected Header\n   o  JWE Shared
    Unprotected Header\n   o  JWE Per-Recipient Unprotected Header\n   JWE utilizes
    authenticated encryption to ensure the confidentiality\n   and integrity of the
    plaintext and the integrity of the JWE Protected\n   Header and the JWE AAD.\n
    \  This document defines two serializations for JWEs: a compact, URL-\n   safe
    serialization called the JWE Compact Serialization and a JSON\n   serialization
    called the JWE JSON Serialization.  In both\n   serializations, the JWE Protected
    Header, JWE Encrypted Key, JWE\n   Initialization Vector, JWE Ciphertext, and
    JWE Authentication Tag are\n   base64url encoded, since JSON lacks a way to directly
    represent\n   arbitrary octet sequences.  When present, the JWE AAD is also\n
    \  base64url encoded.\n"
  - contents:
    - "3.1.  JWE Compact Serialization Overview\n   In the JWE Compact Serialization,
      no JWE Shared Unprotected Header or\n   JWE Per-Recipient Unprotected Header
      are used.  In this case, the\n   JOSE Header and the JWE Protected Header are
      the same.\n   In the JWE Compact Serialization, a JWE is represented as the\n
      \  concatenation:\n      BASE64URL(UTF8(JWE Protected Header)) || '.' ||\n      BASE64URL(JWE
      Encrypted Key) || '.' ||\n      BASE64URL(JWE Initialization Vector) || '.'
      ||\n      BASE64URL(JWE Ciphertext) || '.' ||\n      BASE64URL(JWE Authentication
      Tag)\n   See Section 7.1 for more information about the JWE Compact\n   Serialization.\n"
    title: 3.1.  JWE Compact Serialization Overview
  - contents:
    - "3.2.  JWE JSON Serialization Overview\n   In the JWE JSON Serialization, one
      or more of the JWE Protected\n   Header, JWE Shared Unprotected Header, and
      JWE Per-Recipient\n   Unprotected Header MUST be present.  In this case, the
      members of the\n   JOSE Header are the union of the members of the JWE Protected
      Header,\n   JWE Shared Unprotected Header, and JWE Per-Recipient Unprotected\n
      \  Header values that are present.\n   In the JWE JSON Serialization, a JWE
      is represented as a JSON object\n   containing some or all of these eight members:\n
      \     \"protected\", with the value BASE64URL(UTF8(JWE Protected Header))\n
      \     \"unprotected\", with the value JWE Shared Unprotected Header\n      \"header\",
      with the value JWE Per-Recipient Unprotected Header\n      \"encrypted_key\",
      with the value BASE64URL(JWE Encrypted Key)\n      \"iv\", with the value BASE64URL(JWE
      Initialization Vector)\n      \"ciphertext\", with the value BASE64URL(JWE Ciphertext)\n
      \     \"tag\", with the value BASE64URL(JWE Authentication Tag)\n      \"aad\",
      with the value BASE64URL(JWE AAD)\n   The six base64url-encoded result strings
      and the two unprotected JSON\n   object values are represented as members within
      a JSON object.  The\n   inclusion of some of these values is OPTIONAL.  The
      JWE JSON\n   Serialization can also encrypt the plaintext to multiple recipients.\n
      \  See Section 7.2 for more information about the JWE JSON\n   Serialization.\n"
    title: 3.2.  JWE JSON Serialization Overview
  - contents:
    - "3.3.  Example JWE\n   This example encrypts the plaintext \"The true sign of
      intelligence is\n   not knowledge but imagination.\" to the recipient.\n   The
      following example JWE Protected Header declares that:\n   o  The Content Encryption
      Key is encrypted to the recipient using the\n      RSAES-OAEP [RFC3447] algorithm
      to produce the JWE Encrypted Key.\n   o  Authenticated encryption is performed
      on the plaintext using the\n      AES GCM [AES] [NIST.800-38D] algorithm with
      a 256-bit key to\n      produce the ciphertext and the Authentication Tag.\n
      \    {\"alg\":\"RSA-OAEP\",\"enc\":\"A256GCM\"}\n   Encoding this JWE Protected
      Header as BASE64URL(UTF8(JWE Protected\n   Header)) gives this value:\n     eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ\n
      \  The remaining steps to finish creating this JWE are:\n   o  Generate a random
      Content Encryption Key (CEK).\n   o  Encrypt the CEK with the recipient's public
      key using the RSAES-\n      OAEP algorithm to produce the JWE Encrypted Key.\n
      \  o  Base64url-encode the JWE Encrypted Key.\n   o  Generate a random JWE Initialization
      Vector.\n   o  Base64url-encode the JWE Initialization Vector.\n   o  Let the
      Additional Authenticated Data encryption parameter be\n      ASCII(BASE64URL(UTF8(JWE
      Protected Header))).\n   o  Perform authenticated encryption on the plaintext
      with the AES GCM\n      algorithm using the CEK as the encryption key, the JWE\n
      \     Initialization Vector, and the Additional Authenticated Data\n      value,
      requesting a 128-bit Authentication Tag output.\n   o  Base64url-encode the
      ciphertext.\n   o  Base64url-encode the Authentication Tag.\n   o  Assemble
      the final representation: The Compact Serialization of\n      this result is
      the string BASE64URL(UTF8(JWE Protected Header)) ||\n      '.' || BASE64URL(JWE
      Encrypted Key) || '.' || BASE64URL(JWE\n      Initialization Vector) || '.'
      || BASE64URL(JWE Ciphertext) || '.'\n      || BASE64URL(JWE Authentication Tag).\n
      \  The final result in this example (with line breaks for display\n   purposes
      only) is:\n     eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\n     OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe\n
      \    ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb\n     Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV\n
      \    mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8\n     1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi\n
      \    6UklfCpIMfIjf7iGdXKHzg.\n     48V1_ALb6US04U3b.\n     5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji\n
      \    SdiwkIr3ajwQzaBtQD_A.\n     XFBoMYUZodetZdvTiFvSkQ\n   See Appendix A.1
      for the complete details of computing this JWE.  See\n   Appendix A for additional
      examples, including examples using the JWE\n   JSON Serialization in Sections
      A.4 and A.5.\n"
    title: 3.3.  Example JWE
  title: 3.  JSON Web Encryption (JWE) Overview
- contents:
  - "4.  JOSE Header\n   For a JWE, the members of the JSON object(s) representing
    the JOSE\n   Header describe the encryption applied to the plaintext and\n   optionally
    additional properties of the JWE.  The Header Parameter\n   names within the JOSE
    Header MUST be unique, just as described in\n   Section 4 of [JWS].  The rules
    about handling Header Parameters that\n   are not understood by the implementation
    are also the same.  The\n   classes of Header Parameter names are likewise the
    same.\n"
  - contents:
    - "4.1.  Registered Header Parameter Names\n   The following Header Parameter
      names for use in JWEs are registered\n   in the IANA \"JSON Web Signature and
      Encryption Header Parameters\"\n   registry established by [JWS], with meanings
      as defined below.\n   As indicated by the common registry, JWSs and JWEs share
      a common\n   Header Parameter space; when a parameter is used by both\n   specifications,
      its usage must be compatible between the\n   specifications.\n"
    - contents:
      - "4.1.1.  \"alg\" (Algorithm) Header Parameter\n   This parameter has the same
        meaning, syntax, and processing rules as\n   the \"alg\" Header Parameter
        defined in Section 4.1.1 of [JWS], except\n   that the Header Parameter identifies
        the cryptographic algorithm used\n   to encrypt or determine the value of
        the CEK.  The encrypted content\n   is not usable if the \"alg\" value does
        not represent a supported\n   algorithm, or if the recipient does not have
        a key that can be used\n   with that algorithm.\n   A list of defined \"alg\"
        values for this use can be found in the IANA\n   \"JSON Web Signature and
        Encryption Algorithms\" registry established\n   by [JWA]; the initial contents
        of this registry are the values\n   defined in Section 4.1 of [JWA].\n"
      title: 4.1.1.  "alg" (Algorithm) Header Parameter
    - contents:
      - "4.1.2.  \"enc\" (Encryption Algorithm) Header Parameter\n   The \"enc\" (encryption
        algorithm) Header Parameter identifies the\n   content encryption algorithm
        used to perform authenticated encryption\n   on the plaintext to produce the
        ciphertext and the Authentication\n   Tag.  This algorithm MUST be an AEAD
        algorithm with a specified key\n   length.  The encrypted content is not usable
        if the \"enc\" value does\n   not represent a supported algorithm.  \"enc\"
        values should either be\n   registered in the IANA \"JSON Web Signature and
        Encryption Algorithms\"\n   registry established by [JWA] or be a value that
        contains a\n   Collision-Resistant Name.  The \"enc\" value is a case-sensitive
        ASCII\n   string containing a StringOrURI value.  This Header Parameter MUST
        be\n   present and MUST be understood and processed by implementations.\n
        \  A list of defined \"enc\" values for this use can be found in the IANA\n
        \  \"JSON Web Signature and Encryption Algorithms\" registry established\n
        \  by [JWA]; the initial contents of this registry are the values\n   defined
        in Section 5.1 of [JWA].\n"
      title: 4.1.2.  "enc" (Encryption Algorithm) Header Parameter
    - contents:
      - "4.1.3.  \"zip\" (Compression Algorithm) Header Parameter\n   The \"zip\"
        (compression algorithm) applied to the plaintext before\n   encryption, if
        any.  The \"zip\" value defined by this specification\n   is:\n   o  \"DEF\"
        - Compression with the DEFLATE [RFC1951] algorithm\n   Other values MAY be
        used.  Compression algorithm values can be\n   registered in the IANA \"JSON
        Web Encryption Compression Algorithms\"\n   registry established by [JWA].
        \ The \"zip\" value is a case-sensitive\n   string.  If no \"zip\" parameter
        is present, no compression is applied\n   to the plaintext before encryption.
        \ When used, this Header Parameter\n   MUST be integrity protected; therefore,
        it MUST occur only within the\n   JWE Protected Header.  Use of this Header
        Parameter is OPTIONAL.\n   This Header Parameter MUST be understood and processed
        by\n   implementations.\n"
      title: 4.1.3.  "zip" (Compression Algorithm) Header Parameter
    - contents:
      - "4.1.4.  \"jku\" (JWK Set URL) Header Parameter\n   This parameter has the
        same meaning, syntax, and processing rules as\n   the \"jku\" Header Parameter
        defined in Section 4.1.2 of [JWS], except\n   that the JWK Set resource contains
        the public key to which the JWE\n   was encrypted; this can be used to determine
        the private key needed\n   to decrypt the JWE.\n"
      title: 4.1.4.  "jku" (JWK Set URL) Header Parameter
    - contents:
      - "4.1.5.  \"jwk\" (JSON Web Key) Header Parameter\n   This parameter has the
        same meaning, syntax, and processing rules as\n   the \"jwk\" Header Parameter
        defined in Section 4.1.3 of [JWS], except\n   that the key is the public key
        to which the JWE was encrypted; this\n   can be used to determine the private
        key needed to decrypt the JWE.\n"
      title: 4.1.5.  "jwk" (JSON Web Key) Header Parameter
    - contents:
      - "4.1.6.  \"kid\" (Key ID) Header Parameter\n   This parameter has the same
        meaning, syntax, and processing rules as\n   the \"kid\" Header Parameter
        defined in Section 4.1.4 of [JWS], except\n   that the key hint references
        the public key to which the JWE was\n   encrypted; this can be used to determine
        the private key needed to\n   decrypt the JWE.  This parameter allows originators
        to explicitly\n   signal a change of key to JWE recipients.\n"
      title: 4.1.6.  "kid" (Key ID) Header Parameter
    - contents:
      - "4.1.7.  \"x5u\" (X.509 URL) Header Parameter\n   This parameter has the same
        meaning, syntax, and processing rules as\n   the \"x5u\" Header Parameter
        defined in Section 4.1.5 of [JWS], except\n   that the X.509 public key certificate
        or certificate chain [RFC5280]\n   contains the public key to which the JWE
        was encrypted; this can be\n   used to determine the private key needed to
        decrypt the JWE.\n"
      title: 4.1.7.  "x5u" (X.509 URL) Header Parameter
    - contents:
      - "4.1.8.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n   This parameter
        has the same meaning, syntax, and processing rules as\n   the \"x5c\" Header
        Parameter defined in Section 4.1.6 of [JWS], except\n   that the X.509 public
        key certificate or certificate chain [RFC5280]\n   contains the public key
        to which the JWE was encrypted; this can be\n   used to determine the private
        key needed to decrypt the JWE.\n   See Appendix B of [JWS] for an example
        \"x5c\" value.\n"
      title: 4.1.8.  "x5c" (X.509 Certificate Chain) Header Parameter
    - contents:
      - "4.1.9.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n   This
        parameter has the same meaning, syntax, and processing rules as\n   the \"x5t\"
        Header Parameter defined in Section 4.1.7 of [JWS], except\n   that the certificate
        referenced by the thumbprint contains the public\n   key to which the JWE
        was encrypted; this can be used to determine the\n   private key needed to
        decrypt the JWE.  Note that certificate\n   thumbprints are also sometimes
        known as certificate fingerprints.\n"
      title: 4.1.9.  "x5t" (X.509 Certificate SHA-1 Thumbprint) Header Parameter
    - contents:
      - "4.1.10.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n         Parameter\n
        \  This parameter has the same meaning, syntax, and processing rules as\n
        \  the \"x5t#S256\" Header Parameter defined in Section 4.1.8 of [JWS],\n
        \  except that the certificate referenced by the thumbprint contains the\n
        \  public key to which the JWE was encrypted; this can be used to\n   determine
        the private key needed to decrypt the JWE.  Note that\n   certificate thumbprints
        are also sometimes known as certificate\n   fingerprints.\n"
      title: 4.1.10.  "x5t#S256" (X.509 Certificate SHA-256 Thumbprint) Header
    - contents:
      - "4.1.11.  \"typ\" (Type) Header Parameter\n   This parameter has the same
        meaning, syntax, and processing rules as\n   the \"typ\" Header Parameter
        defined in Section 4.1.9 of [JWS], except\n   that the type is that of this
        complete JWE.\n"
      title: 4.1.11.  "typ" (Type) Header Parameter
    - contents:
      - "4.1.12.  \"cty\" (Content Type) Header Parameter\n   This parameter has the
        same meaning, syntax, and processing rules as\n   the \"cty\" Header Parameter
        defined in Section 4.1.10 of [JWS], except\n   that the type is that of the
        secured content (the plaintext).\n"
      title: 4.1.12.  "cty" (Content Type) Header Parameter
    - contents:
      - "4.1.13.  \"crit\" (Critical) Header Parameter\n   This parameter has the
        same meaning, syntax, and processing rules as\n   the \"crit\" Header Parameter
        defined in Section 4.1.11 of [JWS],\n   except that Header Parameters for
        a JWE are being referred to, rather\n   than Header Parameters for a JWS.\n"
      title: 4.1.13.  "crit" (Critical) Header Parameter
    title: 4.1.  Registered Header Parameter Names
  - contents:
    - "4.2.  Public Header Parameter Names\n   Additional Header Parameter names can
      be defined by those using JWEs.\n   However, in order to prevent collisions,
      any new Header Parameter\n   name should either be registered in the IANA \"JSON
      Web Signature and\n   Encryption Header Parameters\" registry established by
      [JWS] or be a\n   Public Name: a value that contains a Collision-Resistant Name.
      \ In\n   each case, the definer of the name or value needs to take reasonable\n
      \  precautions to make sure they are in control of the part of the\n   namespace
      they use to define the Header Parameter name.\n   New Header Parameters should
      be introduced sparingly, as they can\n   result in non-interoperable JWEs.\n"
    title: 4.2.  Public Header Parameter Names
  - contents:
    - "4.3.  Private Header Parameter Names\n   A producer and consumer of a JWE may
      agree to use Header Parameter\n   names that are Private Names: names that are
      not Registered Header\n   Parameter names (Section 4.1) or Public Header Parameter
      names\n   (Section 4.2).  Unlike Public Header Parameter names, Private Header\n
      \  Parameter names are subject to collision and should be used with\n   caution.\n"
    title: 4.3.  Private Header Parameter Names
  title: 4.  JOSE Header
- contents:
  - '5.  Producing and Consuming JWEs

    '
  - contents:
    - "5.1.  Message Encryption\n   The message encryption process is as follows.
      \ The order of the steps\n   is not significant in cases where there are no
      dependencies between\n   the inputs and outputs of the steps.\n   1.   Determine
      the Key Management Mode employed by the algorithm used\n        to determine
      the Content Encryption Key value.  (This is the\n        algorithm recorded
      in the \"alg\" (algorithm) Header Parameter of\n        the resulting JWE.)\n
      \  2.   When Key Wrapping, Key Encryption, or Key Agreement with Key\n        Wrapping
      are employed, generate a random CEK value.  See RFC\n        4086 [RFC4086]
      for considerations on generating random values.\n        The CEK MUST have a
      length equal to that required for the\n        content encryption algorithm.\n
      \  3.   When Direct Key Agreement or Key Agreement with Key Wrapping are\n        employed,
      use the key agreement algorithm to compute the value\n        of the agreed
      upon key.  When Direct Key Agreement is employed,\n        let the CEK be the
      agreed upon key.  When Key Agreement with Key\n        Wrapping is employed,
      the agreed upon key will be used to wrap\n        the CEK.\n   4.   When Key
      Wrapping, Key Encryption, or Key Agreement with Key\n        Wrapping are employed,
      encrypt the CEK to the recipient and let\n        the result be the JWE Encrypted
      Key.\n   5.   When Direct Key Agreement or Direct Encryption are employed, let\n
      \       the JWE Encrypted Key be the empty octet sequence.\n   6.   When Direct
      Encryption is employed, let the CEK be the shared\n        symmetric key.\n
      \  7.   Compute the encoded key value BASE64URL(JWE Encrypted Key).\n   8.   If
      the JWE JSON Serialization is being used, repeat this process\n        (steps
      1-7) for each recipient.\n   9.   Generate a random JWE Initialization Vector
      of the correct size\n        for the content encryption algorithm (if required
      for the\n        algorithm); otherwise, let the JWE Initialization Vector be
      the\n        empty octet sequence.\n   10.  Compute the encoded Initialization
      Vector value BASE64URL(JWE\n        Initialization Vector).\n   11.  If a \"zip\"
      parameter was included, compress the plaintext using\n        the specified
      compression algorithm and let M be the octet\n        sequence representing
      the compressed plaintext; otherwise, let M\n        be the octet sequence representing
      the plaintext.\n   12.  Create the JSON object(s) containing the desired set
      of Header\n        Parameters, which together comprise the JOSE Header: one
      or more\n        of the JWE Protected Header, the JWE Shared Unprotected Header,\n
      \       and the JWE Per-Recipient Unprotected Header.\n   13.  Compute the Encoded
      Protected Header value BASE64URL(UTF8(JWE\n        Protected Header)).  If the
      JWE Protected Header is not present\n        (which can only happen when using
      the JWE JSON Serialization and\n        no \"protected\" member is present),
      let this value be the empty\n        string.\n   14.  Let the Additional Authenticated
      Data encryption parameter be\n        ASCII(Encoded Protected Header).  However,
      if a JWE AAD value is\n        present (which can only be the case when using
      the JWE JSON\n        Serialization), instead let the Additional Authenticated
      Data\n        encryption parameter be ASCII(Encoded Protected Header || '.'
      ||\n        BASE64URL(JWE AAD)).\n   15.  Encrypt M using the CEK, the JWE Initialization
      Vector, and the\n        Additional Authenticated Data value using the specified
      content\n        encryption algorithm to create the JWE Ciphertext value and
      the\n        JWE Authentication Tag (which is the Authentication Tag output\n
      \       from the encryption operation).\n   16.  Compute the encoded ciphertext
      value BASE64URL(JWE Ciphertext).\n   17.  Compute the encoded Authentication
      Tag value BASE64URL(JWE\n        Authentication Tag).\n   18.  If a JWE AAD
      value is present, compute the encoded AAD value\n        BASE64URL(JWE AAD).\n
      \  19.  Create the desired serialized output.  The Compact Serialization\n        of
      this result is the string BASE64URL(UTF8(JWE Protected\n        Header)) ||
      '.' || BASE64URL(JWE Encrypted Key) || '.' ||\n        BASE64URL(JWE Initialization
      Vector) || '.' || BASE64URL(JWE\n        Ciphertext) || '.' || BASE64URL(JWE
      Authentication Tag).  The\n        JWE JSON Serialization is described in Section
      7.2.\n"
    title: 5.1.  Message Encryption
  - contents:
    - "5.2.  Message Decryption\n   The message decryption process is the reverse
      of the encryption\n   process.  The order of the steps is not significant in
      cases where\n   there are no dependencies between the inputs and outputs of
      the\n   steps.  If any of these steps fail, the encrypted content cannot be\n
      \  validated.\n   When there are multiple recipients, it is an application decision\n
      \  which of the recipients' encrypted content must successfully validate\n   for
      the JWE to be accepted.  In some cases, encrypted content for all\n   recipients
      must successfully validate or the JWE will be considered\n   invalid.  In other
      cases, only the encrypted content for a single\n   recipient needs to be successfully
      validated.  However, in all cases,\n   the encrypted content for at least one
      recipient MUST successfully\n   validate or the JWE MUST be considered invalid.\n
      \  1.   Parse the JWE representation to extract the serialized values\n        for
      the components of the JWE.  When using the JWE Compact\n        Serialization,
      these components are the base64url-encoded\n        representations of the JWE
      Protected Header, the JWE Encrypted\n        Key, the JWE Initialization Vector,
      the JWE Ciphertext, and the\n        JWE Authentication Tag, and when using
      the JWE JSON\n        Serialization, these components also include the base64url-\n
      \       encoded representation of the JWE AAD and the unencoded JWE\n        Shared
      Unprotected Header and JWE Per-Recipient Unprotected\n        Header values.
      \ When using the JWE Compact Serialization, the\n        JWE Protected Header,
      the JWE Encrypted Key, the JWE\n        Initialization Vector, the JWE Ciphertext,
      and the JWE\n        Authentication Tag are represented as base64url-encoded
      values\n        in that order, with each value being separated from the next
      by\n        a single period ('.') character, resulting in exactly four\n        delimiting
      period characters being used.  The JWE JSON\n        Serialization is described
      in Section 7.2.\n   2.   Base64url decode the encoded representations of the
      JWE\n        Protected Header, the JWE Encrypted Key, the JWE Initialization\n
      \       Vector, the JWE Ciphertext, the JWE Authentication Tag, and the\n        JWE
      AAD, following the restriction that no line breaks,\n        whitespace, or
      other additional characters have been used.\n   3.   Verify that the octet sequence
      resulting from decoding the\n        encoded JWE Protected Header is a UTF-8-encoded
      representation\n        of a completely valid JSON object conforming to RFC
      7159\n        [RFC7159]; let the JWE Protected Header be this JSON object.\n
      \  4.   If using the JWE Compact Serialization, let the JOSE Header be\n        the
      JWE Protected Header.  Otherwise, when using the JWE JSON\n        Serialization,
      let the JOSE Header be the union of the members\n        of the JWE Protected
      Header, the JWE Shared Unprotected Header\n        and the corresponding JWE
      Per-Recipient Unprotected Header, all\n        of which must be completely valid
      JSON objects.  During this\n        step, verify that the resulting JOSE Header
      does not contain\n        duplicate Header Parameter names.  When using the
      JWE JSON\n        Serialization, this restriction includes that the same Header\n
      \       Parameter name also MUST NOT occur in distinct JSON object\n        values
      that together comprise the JOSE Header.\n   5.   Verify that the implementation
      understands and can process all\n        fields that it is required to support,
      whether required by this\n        specification, by the algorithms being used,
      or by the \"crit\"\n        Header Parameter value, and that the values of those
      parameters\n        are also understood and supported.\n   6.   Determine the
      Key Management Mode employed by the algorithm\n        specified by the \"alg\"
      (algorithm) Header Parameter.\n   7.   Verify that the JWE uses a key known
      to the recipient.\n   8.   When Direct Key Agreement or Key Agreement with Key
      Wrapping are\n        employed, use the key agreement algorithm to compute the
      value\n        of the agreed upon key.  When Direct Key Agreement is employed,\n
      \       let the CEK be the agreed upon key.  When Key Agreement with Key\n        Wrapping
      is employed, the agreed upon key will be used to\n        decrypt the JWE Encrypted
      Key.\n   9.   When Key Wrapping, Key Encryption, or Key Agreement with Key\n
      \       Wrapping are employed, decrypt the JWE Encrypted Key to produce\n        the
      CEK.  The CEK MUST have a length equal to that required for\n        the content
      encryption algorithm.  Note that when there are\n        multiple recipients,
      each recipient will only be able to decrypt\n        JWE Encrypted Key values
      that were encrypted to a key in that\n        recipient's possession.  It is
      therefore normal to only be able\n        to decrypt one of the per-recipient
      JWE Encrypted Key values to\n        obtain the CEK value.  Also, see Section
      11.5 for security\n        considerations on mitigating timing attacks.\n   10.
      \ When Direct Key Agreement or Direct Encryption are employed,\n        verify
      that the JWE Encrypted Key value is an empty octet\n        sequence.\n   11.
      \ When Direct Encryption is employed, let the CEK be the shared\n        symmetric
      key.\n   12.  Record whether the CEK could be successfully determined for this\n
      \       recipient or not.\n   13.  If the JWE JSON Serialization is being used,
      repeat this process\n        (steps 4-12) for each recipient contained in the
      representation.\n   14.  Compute the Encoded Protected Header value BASE64URL(UTF8(JWE\n
      \       Protected Header)).  If the JWE Protected Header is not present\n        (which
      can only happen when using the JWE JSON Serialization and\n        no \"protected\"
      member is present), let this value be the empty\n        string.\n   15.  Let
      the Additional Authenticated Data encryption parameter be\n        ASCII(Encoded
      Protected Header).  However, if a JWE AAD value is\n        present (which can
      only be the case when using the JWE JSON\n        Serialization), instead let
      the Additional Authenticated Data\n        encryption parameter be ASCII(Encoded
      Protected Header || '.' ||\n        BASE64URL(JWE AAD)).\n   16.  Decrypt the
      JWE Ciphertext using the CEK, the JWE Initialization\n        Vector, the Additional
      Authenticated Data value, and the JWE\n        Authentication Tag (which is
      the Authentication Tag input to the\n        calculation) using the specified
      content encryption algorithm,\n        returning the decrypted plaintext and
      validating the JWE\n        Authentication Tag in the manner specified for the
      algorithm,\n        rejecting the input without emitting any decrypted output
      if the\n        JWE Authentication Tag is incorrect.\n   17.  If a \"zip\" parameter
      was included, uncompress the decrypted\n        plaintext using the specified
      compression algorithm.\n   18.  If there was no recipient for which all of the
      decryption steps\n        succeeded, then the JWE MUST be considered invalid.
      \ Otherwise,\n        output the plaintext.  In the JWE JSON Serialization case,
      also\n        return a result to the application indicating for which of the\n
      \       recipients the decryption succeeded and failed.\n   Finally, note that
      it is an application decision which algorithms may\n   be used in a given context.
      \ Even if a JWE can be successfully\n   decrypted, unless the algorithms used
      in the JWE are acceptable to\n   the application, it SHOULD consider the JWE
      to be invalid.\n"
    title: 5.2.  Message Decryption
  - contents:
    - "5.3.  String Comparison Rules\n   The string comparison rules for this specification
      are the same as\n   those defined in Section 5.3 of [JWS].\n"
    title: 5.3.  String Comparison Rules
  title: 5.  Producing and Consuming JWEs
- contents:
  - "6.  Key Identification\n   The key identification methods for this specification
    are the same as\n   those defined in Section 6 of [JWS], except that the key being\n
    \  identified is the public key to which the JWE was encrypted.\n"
  title: 6.  Key Identification
- contents:
  - "7.  Serializations\n   JWEs use one of two serializations: the JWE Compact Serialization
    or\n   the JWE JSON Serialization.  Applications using this specification\n   need
    to specify what serialization and serialization features are\n   used for that
    application.  For instance, applications might specify\n   that only the JWE JSON
    Serialization is used, that only JWE JSON\n   Serialization support for a single
    recipient is used, or that support\n   for multiple recipients is used.  JWE implementations
    only need to\n   implement the features needed for the applications they are designed\n
    \  to support.\n"
  - contents:
    - "7.1.  JWE Compact Serialization\n   The JWE Compact Serialization represents
      encrypted content as a\n   compact, URL-safe string.  This string is:\n      BASE64URL(UTF8(JWE
      Protected Header)) || '.' ||\n      BASE64URL(JWE Encrypted Key) || '.' ||\n
      \     BASE64URL(JWE Initialization Vector) || '.' ||\n      BASE64URL(JWE Ciphertext)
      || '.' ||\n      BASE64URL(JWE Authentication Tag)\n   Only one recipient is
      supported by the JWE Compact Serialization and\n   it provides no syntax to
      represent JWE Shared Unprotected Header, JWE\n   Per-Recipient Unprotected Header,
      or JWE AAD values.\n"
    title: 7.1.  JWE Compact Serialization
  - contents:
    - "7.2.  JWE JSON Serialization\n   The JWE JSON Serialization represents encrypted
      content as a JSON\n   object.  This representation is neither optimized for
      compactness nor\n   URL safe.\n   Two closely related syntaxes are defined for
      the JWE JSON\n   Serialization: a fully general syntax, with which content can
      be\n   encrypted to more than one recipient, and a flattened syntax, which\n
      \  is optimized for the single-recipient case.\n"
    - contents:
      - "7.2.1.  General JWE JSON Serialization Syntax\n   The following members are
        defined for use in top-level JSON objects\n   used for the fully general JWE
        JSON Serialization syntax:\n   protected\n      The \"protected\" member MUST
        be present and contain the value\n      BASE64URL(UTF8(JWE Protected Header))
        when the JWE Protected\n      Header value is non-empty; otherwise, it MUST
        be absent.  These\n      Header Parameter values are integrity protected.\n
        \  unprotected\n      The \"unprotected\" member MUST be present and contain
        the value JWE\n      Shared Unprotected Header when the JWE Shared Unprotected
        Header\n      value is non-empty; otherwise, it MUST be absent.  This value
        is\n      represented as an unencoded JSON object, rather than as a string.\n
        \     These Header Parameter values are not integrity protected.\n   iv\n
        \     The \"iv\" member MUST be present and contain the value\n      BASE64URL(JWE
        Initialization Vector) when the JWE Initialization\n      Vector value is
        non-empty; otherwise, it MUST be absent.\n   aad\n      The \"aad\" member
        MUST be present and contain the value\n      BASE64URL(JWE AAD)) when the
        JWE AAD value is non-empty;\n      otherwise, it MUST be absent.  A JWE AAD
        value can be included to\n      supply a base64url-encoded value to be integrity
        protected but not\n      encrypted.\n   ciphertext\n      The \"ciphertext\"
        member MUST be present and contain the value\n      BASE64URL(JWE Ciphertext).\n
        \  tag\n      The \"tag\" member MUST be present and contain the value\n      BASE64URL(JWE
        Authentication Tag) when the JWE Authentication Tag\n      value is non-empty;
        otherwise, it MUST be absent.\n   recipients\n      The \"recipients\" member
        value MUST be an array of JSON objects.\n      Each object contains information
        specific to a single recipient.\n      This member MUST be present with exactly
        one array element per\n      recipient, even if some or all of the array element
        values are the\n      empty JSON object \"{}\" (which can happen when all
        Header Parameter\n      values are shared between all recipients and when
        no encrypted key\n      is used, such as when doing Direct Encryption).\n
        \  The following members are defined for use in the JSON objects that\n   are
        elements of the \"recipients\" array:\n   header\n      The \"header\" member
        MUST be present and contain the value JWE Per-\n      Recipient Unprotected
        Header when the JWE Per-Recipient\n      Unprotected Header value is non-empty;
        otherwise, it MUST be\n      absent.  This value is represented as an unencoded
        JSON object,\n      rather than as a string.  These Header Parameter values
        are not\n      integrity protected.\n   encrypted_key\n      The \"encrypted_key\"
        member MUST be present and contain the value\n      BASE64URL(JWE Encrypted
        Key) when the JWE Encrypted Key value is\n      non-empty; otherwise, it MUST
        be absent.\n   At least one of the \"header\", \"protected\", and \"unprotected\"
        members\n   MUST be present so that \"alg\" and \"enc\" Header Parameter values
        are\n   conveyed for each recipient computation.\n   Additional members can
        be present in both the JSON objects defined\n   above; if not understood by
        implementations encountering them, they\n   MUST be ignored.\n   Some Header
        Parameters, including the \"alg\" parameter, can be shared\n   among all recipient
        computations.  Header Parameters in the JWE\n   Protected Header and JWE Shared
        Unprotected Header values are shared\n   among all recipients.\n   The Header
        Parameter values used when creating or validating per-\n   recipient ciphertext
        and Authentication Tag values are the union of\n   the three sets of Header
        Parameter values that may be present: (1)\n   the JWE Protected Header represented
        in the \"protected\" member, (2)\n   the JWE Shared Unprotected Header represented
        in the \"unprotected\"\n   member, and (3) the JWE Per-Recipient Unprotected
        Header represented\n   in the \"header\" member of the recipient's array element.
        \ The union\n   of these sets of Header Parameters comprises the JOSE Header.
        \ The\n   Header Parameter names in the three locations MUST be disjoint.\n
        \  Each JWE Encrypted Key value is computed using the parameters of the\n
        \  corresponding JOSE Header value in the same manner as for the JWE\n   Compact
        Serialization.  This has the desirable property that each JWE\n   Encrypted
        Key value in the \"recipients\" array is identical to the\n   value that would
        have been computed for the same parameter in the JWE\n   Compact Serialization.
        \ Likewise, the JWE Ciphertext and JWE\n   Authentication Tag values match
        those produced for the JWE Compact\n   Serialization, provided that the JWE
        Protected Header value (which\n   represents the integrity-protected Header
        Parameter values) matches\n   that used in the JWE Compact Serialization.\n
        \  All recipients use the same JWE Protected Header, JWE Initialization\n
        \  Vector, JWE Ciphertext, and JWE Authentication Tag values, when\n   present,
        resulting in potentially significant space savings if the\n   message is large.
        \ Therefore, all Header Parameters that specify the\n   treatment of the plaintext
        value MUST be the same for all recipients.\n   This primarily means that the
        \"enc\" (encryption algorithm) Header\n   Parameter value in the JOSE Header
        for each recipient and any\n   parameters of that algorithm MUST be the same.\n
        \  In summary, the syntax of a JWE using the general JWE JSON\n   Serialization
        is as follows:\n     {\n      \"protected\":\"<integrity-protected shared
        header contents>\",\n      \"unprotected\":<non-integrity-protected shared
        header contents>,\n      \"recipients\":[\n       {\"header\":<per-recipient
        unprotected header 1 contents>,\n        \"encrypted_key\":\"<encrypted key
        1 contents>\"},\n       ...\n       {\"header\":<per-recipient unprotected
        header N contents>,\n        \"encrypted_key\":\"<encrypted key N contents>\"}],\n
        \     \"aad\":\"<additional authenticated data contents>\",\n      \"iv\":\"<initialization
        vector contents>\",\n      \"ciphertext\":\"<ciphertext contents>\",\n      \"tag\":\"<authentication
        tag contents>\"\n     }\n   See Appendix A.4 for an example JWE using the
        general JWE JSON\n   Serialization syntax.\n"
      title: 7.2.1.  General JWE JSON Serialization Syntax
    - contents:
      - "7.2.2.  Flattened JWE JSON Serialization Syntax\n   The flattened JWE JSON
        Serialization syntax is based upon the general\n   syntax, but flattens it,
        optimizing it for the single-recipient case.\n   It flattens it by removing
        the \"recipients\" member and instead\n   placing those members defined for
        use in the \"recipients\" array (the\n   \"header\" and \"encrypted_key\"
        members) in the top-level JSON object\n   (at the same level as the \"ciphertext\"
        member).\n   The \"recipients\" member MUST NOT be present when using this
        syntax.\n   Other than this syntax difference, JWE JSON Serialization objects\n
        \  using the flattened syntax are processed identically to those using\n   the
        general syntax.\n   In summary, the syntax of a JWE using the flattened JWE
        JSON\n   Serialization is as follows:\n     {\n      \"protected\":\"<integrity-protected
        header contents>\",\n      \"unprotected\":<non-integrity-protected header
        contents>,\n      \"header\":<more non-integrity-protected header contents>,\n
        \     \"encrypted_key\":\"<encrypted key contents>\",\n      \"aad\":\"<additional
        authenticated data contents>\",\n      \"iv\":\"<initialization vector contents>\",\n
        \     \"ciphertext\":\"<ciphertext contents>\",\n      \"tag\":\"<authentication
        tag contents>\"\n     }\n   Note that when using the flattened syntax, just
        as when using the\n   general syntax, any unprotected Header Parameter values
        can reside in\n   either the \"unprotected\" member or the \"header\" member,
        or in both.\n   See Appendix A.5 for an example JWE using the flattened JWE
        JSON\n   Serialization syntax.\n"
      title: 7.2.2.  Flattened JWE JSON Serialization Syntax
    title: 7.2.  JWE JSON Serialization
  title: 7.  Serializations
- contents:
  - "8.  TLS Requirements\n   The Transport Layer Security (TLS) requirements for
    this\n   specification are the same as those defined in Section 8 of [JWS].\n"
  title: 8.  TLS Requirements
- contents:
  - "9.  Distinguishing between JWS and JWE Objects\n   There are several ways of
    distinguishing whether an object is a JWS\n   or JWE.  All these methods will
    yield the same result for all legal\n   input values; they may yield different
    results for malformed inputs.\n   o  If the object is using the JWS Compact Serialization
    or the JWE\n      Compact Serialization, the number of base64url-encoded segments\n
    \     separated by period ('.') characters differs for JWSs and JWEs.\n      JWSs
    have three segments separated by two period ('.') characters.\n      JWEs have
    five segments separated by four period ('.') characters.\n   o  If the object
    is using the JWS JSON Serialization or the JWE JSON\n      Serialization, the
    members used will be different.  JWSs have a\n      \"payload\" member and JWEs
    do not.  JWEs have a \"ciphertext\" member\n      and JWSs do not.\n   o  The
    JOSE Header for a JWS can be distinguished from the JOSE\n      Header for a JWE
    by examining the \"alg\" (algorithm) Header\n      Parameter value.  If the value
    represents a digital signature or\n      MAC algorithm, or is the value \"none\",
    it is for a JWS; if it\n      represents a Key Encryption, Key Wrapping, Direct
    Key Agreement,\n      Key Agreement with Key Wrapping, or Direct Encryption algorithm,\n
    \     it is for a JWE.  (Extracting the \"alg\" value to examine is\n      straightforward
    when using the JWS Compact Serialization or the\n      JWE Compact Serialization
    and may be more difficult when using the\n      JWS JSON Serialization or the
    JWE JSON Serialization.)\n   o  The JOSE Header for a JWS can also be distinguished
    from the JOSE\n      Header for a JWE by determining whether an \"enc\" (encryption\n
    \     algorithm) member exists.  If the \"enc\" member exists, it is a\n      JWE;
    otherwise, it is a JWS.\n"
  title: 9.  Distinguishing between JWS and JWE Objects
- contents:
  - '10.  IANA Considerations

    '
  - contents:
    - "10.1.  JSON Web Signature and Encryption Header Parameters Registration\n   This
      section registers the Header Parameter names defined in\n   Section 4.1 in the
      IANA \"JSON Web Signature and Encryption Header\n   Parameters\" registry established
      by [JWS].\n"
    - contents:
      - "10.1.1.  Registry Contents\n   o  Header Parameter Name: \"alg\"\n   o  Header
        Parameter Description: Algorithm\n   o  Header Parameter Usage Location(s):
        JWE\n   o  Change Controller: IESG\n   o  Specification Document(s): Section
        4.1.1 of RFC 7516\n   o  Header Parameter Name: \"enc\"\n   o  Header Parameter
        Description: Encryption Algorithm\n   o  Header Parameter Usage Location(s):
        JWE\n   o  Change Controller: IESG\n   o  Specification Document(s): Section
        4.1.2 of RFC 7516\n   o  Header Parameter Name: \"zip\"\n   o  Header Parameter
        Description: Compression Algorithm\n   o  Header Parameter Usage Location(s):
        JWE\n   o  Change Controller: IESG\n   o  Specification Document(s): Section
        4.1.3 of RFC 7516\n   o  Header Parameter Name: \"jku\"\n   o  Header Parameter
        Description: JWK Set URL\n   o  Header Parameter Usage Location(s): JWE\n
        \  o  Change Controller: IESG\n   o  Specification Document(s): Section 4.1.4
        of RFC 7516\n   o  Header Parameter Name: \"jwk\"\n   o  Header Parameter
        Description: JSON Web Key\n   o  Header Parameter Usage Location(s): JWE\n
        \  o  Change Controller: IESG\n   o  Specification Document(s): Section 4.1.5
        of RFC 7516\n   o  Header Parameter Name: \"kid\"\n   o  Header Parameter
        Description: Key ID\n   o  Header Parameter Usage Location(s): JWE\n   o  Change
        Controller: IESG\n   o  Specification Document(s): Section 4.1.6 of RFC 7516\n
        \  o  Header Parameter Name: \"x5u\"\n   o  Header Parameter Description:
        X.509 URL\n   o  Header Parameter Usage Location(s): JWE\n   o  Change Controller:
        IESG\n   o  Specification Document(s): Section 4.1.7 of RFC 7516\n   o  Header
        Parameter Name: \"x5c\"\n   o  Header Parameter Description: X.509 Certificate
        Chain\n   o  Header Parameter Usage Location(s): JWE\n   o  Change Controller:
        IESG\n   o  Specification Document(s): Section 4.1.8 of RFC 7516\n   o  Header
        Parameter Name: \"x5t\"\n   o  Header Parameter Description: X.509 Certificate
        SHA-1 Thumbprint\n   o  Header Parameter Usage Location(s): JWE\n   o  Change
        Controller: IESG\n   o  Specification Document(s): Section 4.1.9 of RFC 7516\n
        \  o  Header Parameter Name: \"x5t#S256\"\n   o  Header Parameter Description:
        X.509 Certificate SHA-256 Thumbprint\n   o  Header Parameter Usage Location(s):
        JWE\n   o  Change Controller: IESG\n   o  Specification Document(s): Section
        4.1.10 of RFC 7516\n   o  Header Parameter Name: \"typ\"\n   o  Header Parameter
        Description: Type\n   o  Header Parameter Usage Location(s): JWE\n   o  Change
        Controller: IESG\n   o  Specification Document(s): Section 4.1.11 of RFC 7516\n
        \  o  Header Parameter Name: \"cty\"\n   o  Header Parameter Description:
        Content Type\n   o  Header Parameter Usage Location(s): JWE\n   o  Change
        Controller: IESG\n   o  Specification Document(s): Section 4.1.12 of RFC 7516\n
        \  o  Header Parameter Name: \"crit\"\n   o  Header Parameter Description:
        Critical\n   o  Header Parameter Usage Location(s): JWE\n   o  Change Controller:
        IESG\n   o  Specification Document(s): Section 4.1.13 of RFC 7516\n"
      title: 10.1.1.  Registry Contents
    title: 10.1.  JSON Web Signature and Encryption Header Parameters Registration
  title: 10.  IANA Considerations
- contents:
  - "11.  Security Considerations\n   All of the security issues that are pertinent
    to any cryptographic\n   application must be addressed by JWS/JWE/JWK agents.
    \ Among these\n   issues are protecting the user's asymmetric private and symmetric\n
    \  secret keys and employing countermeasures to various attacks.\n   All the security
    considerations in the JWS specification also apply\n   to this specification.
    \ Likewise, all the security considerations in\n   XML Encryption 1.1 [W3C.REC-xmlenc-core1-20130411]
    also apply, other\n   than those that are XML specific.\n"
  - contents:
    - "11.1.  Key Entropy and Random Values\n   See Section 10.1 of [JWS] for security
      considerations on key entropy\n   and random values.  In addition to the uses
      of random values listed\n   there, note that random values are also used for
      Content Encryption\n   Keys (CEKs) and Initialization Vectors (IVs) when performing\n
      \  encryption.\n"
    title: 11.1.  Key Entropy and Random Values
  - contents:
    - "11.2.  Key Protection\n   See Section 10.2 of [JWS] for security considerations
      on key\n   protection.  In addition to the keys listed there that must be\n
      \  protected, implementations performing encryption must protect the key\n   encryption
      key and the Content Encryption Key.  Compromise of the key\n   encryption key
      may result in the disclosure of all contents protected\n   with that key.  Similarly,
      compromise of the Content Encryption Key\n   may result in disclosure of the
      associated encrypted content.\n"
    title: 11.2.  Key Protection
  - contents:
    - "11.3.  Using Matching Algorithm Strengths\n   Algorithms of matching strengths
      should be used together whenever\n   possible.  For instance, when AES Key Wrap
      is used with a given key\n   size, using the same key size is recommended when
      AES GCM is also\n   used.  If the key encryption and content encryption algorithms
      are\n   different, the effective security is determined by the weaker of the\n
      \  two algorithms.\n   Also, see RFC 3766 [RFC3766] for information on determining
      strengths\n   for public keys used for exchanging symmetric keys.\n"
    title: 11.3.  Using Matching Algorithm Strengths
  - contents:
    - "11.4.  Adaptive Chosen-Ciphertext Attacks\n   When decrypting, particular care
      must be taken not to allow the JWE\n   recipient to be used as an oracle for
      decrypting messages.  RFC 3218\n   [RFC3218] should be consulted for specific
      countermeasures to attacks\n   on RSAES-PKCS1-v1_5.  An attacker might modify
      the contents of the\n   \"alg\" Header Parameter from \"RSA-OAEP\" to \"RSA1_5\"
      in order to\n   generate a formatting error that can be detected and used to
      recover\n   the CEK even if RSAES-OAEP was used to encrypt the CEK.  It is\n
      \  therefore particularly important to report all formatting errors to\n   the
      CEK, Additional Authenticated Data, or ciphertext as a single\n   error when
      the encrypted content is rejected.\n   Additionally, this type of attack can
      be prevented by restricting the\n   use of a key to a limited set of algorithms
      -- usually one.  This\n   means, for instance, that if the key is marked as
      being for\n   \"RSA-OAEP\" only, any attempt to decrypt a message using the
      \"RSA1_5\"\n   algorithm with that key should fail immediately due to invalid
      use of\n   the key.\n"
    title: 11.4.  Adaptive Chosen-Ciphertext Attacks
  - contents:
    - "11.5.  Timing Attacks\n   To mitigate the attacks described in RFC 3218 [RFC3218],
      the\n   recipient MUST NOT distinguish between format, padding, and length\n
      \  errors of encrypted keys.  It is strongly recommended, in the event\n   of
      receiving an improperly formatted key, that the recipient\n   substitute a randomly
      generated CEK and proceed to the next step, to\n   mitigate timing attacks.\n"
    title: 11.5.  Timing Attacks
  title: 11.  Security Considerations
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [JWA]      Jones, M., \"JSON Web Algorithms
      (JWA)\", RFC 7518,\n              DOI 10.17487/RFC7518, May 2015,\n              <http://www.rfc-editor.org/info/rfc7518>.\n
      \  [JWK]      Jones, M., \"JSON Web Key (JWK)\", RFC 7517,\n              DOI
      10.17487/RFC7517, May 2015,\n              <http://www.rfc-editor.org/info/rfc7517>.\n
      \  [JWS]      Jones, M., Bradley, J., and N. Sakimura, \"JSON Web\n              Signature
      (JWS)\", RFC 7515, DOI 10.17487/RFC7515, May\n              2015, <http://www.rfc-editor.org/info/rfc7515>.\n
      \  [RFC1951]  Deutsch, P., \"DEFLATE Compressed Data Format Specification\n
      \             version 1.3\", RFC 1951, DOI 10.17487/RFC1951, May 1996,\n              <http://www.rfc-editor.org/info/rfc1951>.\n
      \  [RFC20]    Cerf, V., \"ASCII format for Network Interchange\", STD 80,\n
      \             RFC 20, DOI 10.17487/RFC0020, October 1969,\n              <http://www.rfc-editor.org/info/rfc20>.\n
      \  [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n
      \             <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC3629]  Yergeau,
      F., \"UTF-8, a transformation format of ISO\n              10646\", STD 63,
      RFC 3629, DOI 10.17487/RFC3629, November\n              2003, <http://www.rfc-editor.org/info/rfc3629>.\n
      \  [RFC4949]  Shirey, R., \"Internet Security Glossary, Version 2\",\n              FYI
      36, RFC 4949, DOI 10.17487/RFC4949, August 2007,\n              <http://www.rfc-editor.org/info/rfc4949>.\n
      \  [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n              Housley,
      R., and W. Polk, \"Internet X.509 Public Key\n              Infrastructure Certificate
      and Certificate Revocation List\n              (CRL) Profile\", RFC 5280, DOI
      10.17487/RFC5280, May 2008,\n              <http://www.rfc-editor.org/info/rfc5280>.\n
      \  [RFC7159]  Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data\n
      \             Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March\n
      \             2014, <http://www.rfc-editor.org/info/rfc7159>.\n   [UNICODE]
      \ The Unicode Consortium, \"The Unicode Standard\",\n              <http://www.unicode.org/versions/latest/>.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [AES]      National Institute of Standards
      and Technology (NIST),\n              \"Advanced Encryption Standard (AES)\",
      FIPS PUB 197,\n              November 2001, <http://csrc.nist.gov/publications/\n
      \             fips/fips197/fips-197.pdf>.\n   [JSE]      Bradley, J. and N.
      Sakimura (editor), \"JSON Simple\n              Encryption\", September 2010,\n
      \             <http://jsonenc.info/enc/1.0/>.\n   [JSMS]     Rescorla, E. and
      J. Hildebrand, \"JavaScript Message\n              Security Format\", Work in
      Progress,\n              draft-rescorla-jsms-00, March 2011.\n   [NIST.800-38D]\n
      \             National Institute of Standards and Technology (NIST),\n              \"Recommendation
      for Block Cipher Modes of Operation:\n              Galois/Counter Mode (GCM)
      and GMAC\", NIST PUB 800-38D,\n              November 2007, <http://csrc.nist.gov/publications/\n
      \             nistpubs/800-38D/SP-800-38D.pdf>.\n   [RFC3218]  Rescorla, E.,
      \"Preventing the Million Message Attack on\n              Cryptographic Message
      Syntax\", RFC 3218,\n              DOI 10.17487/RFC3218, January 2002,\n              <http://www.rfc-editor.org/info/rfc3218>.\n
      \  [RFC3447]  Jonsson, J. and B. Kaliski, \"Public-Key Cryptography\n              Standards
      (PKCS) #1: RSA Cryptography Specifications\n              Version 2.1\", RFC
      3447, DOI 10.17487/RFC3447, February\n              2003, <http://www.rfc-editor.org/info/rfc3447>.\n
      \  [RFC3766]  Orman, H. and P. Hoffman, \"Determining Strengths For\n              Public
      Keys Used For Exchanging Symmetric Keys\", BCP 86,\n              RFC 3766,
      DOI 10.17487/RFC3766, April 2004,\n              <http://www.rfc-editor.org/info/rfc3766>.\n
      \  [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,\n              \"Randomness
      Requirements for Security\", BCP 106, RFC 4086,\n              DOI 10.17487/RFC4086,
      June 2005,\n              <http://www.rfc-editor.org/info/rfc4086>.\n   [RFC5652]
      \ Housley, R., \"Cryptographic Message Syntax (CMS)\", STD 70,\n              RFC
      5652, DOI 10.17487/RFC5652, September 2009,\n              <http://www.rfc-editor.org/info/rfc5652>.\n
      \  [W3C.REC-xmlenc-core1-20130411]\n              Eastlake, D., Reagle, J.,
      Hirsch, F., and T. Roessler,\n              \"XML Encryption Syntax and Processing
      Version 1.1\", World\n              Wide Web Consortium Recommendation\n              REC-xmlenc-core1-20130411,
      April 2013,\n              <http://www.w3.org/TR/2013/REC-xmlenc-core1-20130411/>.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Appendix A.  JWE Examples\n   This section provides examples of JWE computations.\n"
  - contents:
    - "A.1.  Example JWE using RSAES-OAEP and AES GCM\n   This example encrypts the
      plaintext \"The true sign of intelligence is\n   not knowledge but imagination.\"
      to the recipient using RSAES-OAEP for\n   key encryption and AES GCM for content
      encryption.  The\n   representation of this plaintext (using JSON array notation)
      is:\n   [84, 104, 101, 32, 116, 114, 117, 101, 32, 115, 105, 103, 110, 32,\n
      \  111, 102, 32, 105, 110, 116, 101, 108, 108, 105, 103, 101, 110, 99,\n   101,
      32, 105, 115, 32, 110, 111, 116, 32, 107, 110, 111, 119, 108,\n   101, 100,
      103, 101, 32, 98, 117, 116, 32, 105, 109, 97, 103, 105,\n   110, 97, 116, 105,
      111, 110, 46]\n"
    - contents:
      - "A.1.1.  JOSE Header\n   The following example JWE Protected Header declares
        that:\n   o  The Content Encryption Key is encrypted to the recipient using
        the\n      RSAES-OAEP algorithm to produce the JWE Encrypted Key.\n   o  Authenticated
        encryption is performed on the plaintext using the\n      AES GCM algorithm
        with a 256-bit key to produce the ciphertext and\n      the Authentication
        Tag.\n     {\"alg\":\"RSA-OAEP\",\"enc\":\"A256GCM\"}\n   Encoding this JWE
        Protected Header as BASE64URL(UTF8(JWE Protected\n   Header)) gives this value:\n
        \    eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ\n"
      title: A.1.1.  JOSE Header
    - contents:
      - "A.1.2.  Content Encryption Key (CEK)\n   Generate a 256-bit random CEK.  In
        this example, the value (using\n   JSON array notation) is:\n   [177, 161,
        244, 128, 84, 143, 225, 115, 63, 180, 3, 255, 107, 154,\n   212, 246, 138,
        7, 110, 91, 112, 46, 34, 105, 47, 130, 203, 46, 122,\n   234, 64, 252]\n"
      title: A.1.2.  Content Encryption Key (CEK)
    - contents:
      - "A.1.3.  Key Encryption\n   Encrypt the CEK with the recipient's public key
        using the RSAES-OAEP\n   algorithm to produce the JWE Encrypted Key.  This
        example uses the\n   RSA key represented in JSON Web Key [JWK] format below
        (with line\n   breaks within values for display purposes only):\n     {\"kty\":\"RSA\",\n
        \     \"n\":\"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUW\n
        \          cJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3S\n           psk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2a\n
        \          sbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMS\n           tPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2dj\n
        \          YgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw\",\n      \"e\":\"AQAB\",\n
        \     \"d\":\"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5N\n
        \          WV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD9\n           3Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghk\n
        \          qDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vl\n           t3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSnd\n
        \          VTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ\",\n      \"p\":\"1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-\n
        \          SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lf\n           fNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0\",\n
        \     \"q\":\"wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBm\n
        \          UDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aX\n           IWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc\",\n
        \     \"dp\":\"ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KL\n
        \          hMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827\n           rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE\",\n
        \     \"dq\":\"Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCj\n
        \          ywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDB\n           UfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis\",\n
        \     \"qi\":\"VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7\n
        \          AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3\n           eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY\"\n
        \    }\n   The resulting JWE Encrypted Key value is:\n   [56, 163, 154, 192,
        58, 53, 222, 4, 105, 218, 136, 218, 29, 94, 203,\n   22, 150, 92, 129, 94,
        211, 232, 53, 89, 41, 60, 138, 56, 196, 216,\n   82, 98, 168, 76, 37, 73,
        70, 7, 36, 8, 191, 100, 136, 196, 244, 220,\n   145, 158, 138, 155, 4, 117,
        141, 230, 199, 247, 173, 45, 182, 214,\n   74, 177, 107, 211, 153, 11, 205,
        196, 171, 226, 162, 128, 171, 182,\n   13, 237, 239, 99, 193, 4, 91, 219,
        121, 223, 107, 167, 61, 119, 228,\n   173, 156, 137, 134, 200, 80, 219, 74,
        253, 56, 185, 91, 177, 34, 158,\n   89, 154, 205, 96, 55, 18, 138, 43, 96,
        218, 215, 128, 124, 75, 138,\n   243, 85, 25, 109, 117, 140, 26, 155, 249,
        67, 167, 149, 231, 100, 6,\n   41, 65, 214, 251, 232, 87, 72, 40, 182, 149,
        154, 168, 31, 193, 126,\n   215, 89, 28, 111, 219, 125, 182, 139, 235, 195,
        197, 23, 234, 55, 58,\n   63, 180, 68, 202, 206, 149, 75, 205, 248, 176, 67,
        39, 178, 60, 98,\n   193, 32, 238, 122, 96, 158, 222, 57, 183, 111, 210, 55,
        188, 215,\n   206, 180, 166, 150, 166, 106, 250, 55, 229, 72, 40, 69, 214,
        216,\n   104, 23, 40, 135, 212, 28, 127, 41, 80, 175, 174, 168, 115, 171,
        197,\n   89, 116, 92, 103, 246, 83, 216, 182, 176, 84, 37, 147, 35, 45, 219,\n
        \  172, 99, 226, 233, 73, 37, 124, 42, 72, 49, 242, 35, 127, 184, 134,\n   117,
        114, 135, 206]\n   Encoding this JWE Encrypted Key as BASE64URL(JWE Encrypted
        Key) gives\n   this value (with line breaks for display purposes only):\n
        \    OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe\n     ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb\n
        \    Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV\n     mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8\n
        \    1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi\n     6UklfCpIMfIjf7iGdXKHzg\n"
      title: A.1.3.  Key Encryption
    - contents:
      - "A.1.4.  Initialization Vector\n   Generate a random 96-bit JWE Initialization
        Vector.  In this example,\n   the value is:\n   [227, 197, 117, 252, 2, 219,
        233, 68, 180, 225, 77, 219]\n   Encoding this JWE Initialization Vector as
        BASE64URL(JWE\n   Initialization Vector) gives this value:\n     48V1_ALb6US04U3b\n"
      title: A.1.4.  Initialization Vector
    - contents:
      - "A.1.5.  Additional Authenticated Data\n   Let the Additional Authenticated
        Data encryption parameter be\n   ASCII(BASE64URL(UTF8(JWE Protected Header))).
        \ This value is:\n   [101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83,
        85, 48, 69,\n   116, 84, 48, 70, 70, 85, 67, 73, 115, 73, 109, 86, 117, 89,
        121, 73,\n   54, 73, 107, 69, 121, 78, 84, 90, 72, 81, 48, 48, 105, 102, 81]\n"
      title: A.1.5.  Additional Authenticated Data
    - contents:
      - "A.1.6.  Content Encryption\n   Perform authenticated encryption on the plaintext
        with the AES GCM\n   algorithm using the CEK as the encryption key, the JWE
        Initialization\n   Vector, and the Additional Authenticated Data value above,
        requesting\n   a 128-bit Authentication Tag output.  The resulting ciphertext
        is:\n   [229, 236, 166, 241, 53, 191, 115, 196, 174, 43, 73, 109, 39, 122,\n
        \  233, 96, 140, 206, 120, 52, 51, 237, 48, 11, 190, 219, 186, 80, 111,\n
        \  104, 50, 142, 47, 167, 59, 61, 181, 127, 196, 21, 40, 82, 242, 32,\n   123,
        143, 168, 226, 73, 216, 176, 144, 138, 247, 106, 60, 16, 205,\n   160, 109,
        64, 63, 192]\n   The resulting Authentication Tag value is:\n   [92, 80, 104,
        49, 133, 25, 161, 215, 173, 101, 219, 211, 136, 91,\n   210, 145]\n   Encoding
        this JWE Ciphertext as BASE64URL(JWE Ciphertext) gives this\n   value (with
        line breaks for display purposes only):\n     5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji\n
        \    SdiwkIr3ajwQzaBtQD_A\n   Encoding this JWE Authentication Tag as BASE64URL(JWE
        Authentication\n   Tag) gives this value:\n     XFBoMYUZodetZdvTiFvSkQ\n"
      title: A.1.6.  Content Encryption
    - contents:
      - "A.1.7.  Complete Representation\n   Assemble the final representation: The
        Compact Serialization of this\n   result is the string BASE64URL(UTF8(JWE
        Protected Header)) || '.' ||\n   BASE64URL(JWE Encrypted Key) || '.' || BASE64URL(JWE
        Initialization\n   Vector) || '.' || BASE64URL(JWE Ciphertext) || '.' || BASE64URL(JWE\n
        \  Authentication Tag).\n   The final result in this example (with line breaks
        for display\n   purposes only) is:\n     eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\n
        \    OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe\n     ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb\n
        \    Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV\n     mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8\n
        \    1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi\n     6UklfCpIMfIjf7iGdXKHzg.\n
        \    48V1_ALb6US04U3b.\n     5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji\n
        \    SdiwkIr3ajwQzaBtQD_A.\n     XFBoMYUZodetZdvTiFvSkQ\n"
      title: A.1.7.  Complete Representation
    - contents:
      - "A.1.8.  Validation\n   This example illustrates the process of creating a
        JWE with\n   RSAES-OAEP for key encryption and AES GCM for content encryption.\n
        \  These results can be used to validate JWE decryption implementations\n
        \  for these algorithms.  Note that since the RSAES-OAEP computation\n   includes
        random values, the encryption results above will not be\n   completely reproducible.
        \ However, since the AES GCM computation is\n   deterministic, the JWE Encrypted
        Ciphertext values will be the same\n   for all encryptions performed using
        these inputs.\n"
      title: A.1.8.  Validation
    title: A.1.  Example JWE using RSAES-OAEP and AES GCM
  - contents:
    - "A.2.  Example JWE using RSAES-PKCS1-v1_5 and AES_128_CBC_HMAC_SHA_256\n   This
      example encrypts the plaintext \"Live long and prosper.\" to the\n   recipient
      using RSAES-PKCS1-v1_5 for key encryption and\n   AES_128_CBC_HMAC_SHA_256 for
      content encryption.  The representation\n   of this plaintext (using JSON array
      notation) is:\n   [76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100,
      32,\n   112, 114, 111, 115, 112, 101, 114, 46]\n"
    - contents:
      - "A.2.1.  JOSE Header\n   The following example JWE Protected Header declares
        that:\n   o  The Content Encryption Key is encrypted to the recipient using
        the\n      RSAES-PKCS1-v1_5 algorithm to produce the JWE Encrypted Key.\n
        \  o  Authenticated encryption is performed on the plaintext using the\n      AES_128_CBC_HMAC_SHA_256
        algorithm to produce the ciphertext and\n      the Authentication Tag.\n     {\"alg\":\"RSA1_5\",\"enc\":\"A128CBC-HS256\"}\n
        \  Encoding this JWE Protected Header as BASE64URL(UTF8(JWE Protected\n   Header))
        gives this value:\n     eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0\n"
      title: A.2.1.  JOSE Header
    - contents:
      - "A.2.2.  Content Encryption Key (CEK)\n   Generate a 256-bit random CEK.  In
        this example, the key value is:\n   [4, 211, 31, 197, 84, 157, 252, 254, 11,
        100, 157, 250, 63, 170, 106,\n   206, 107, 124, 212, 45, 111, 107, 9, 219,
        200, 177, 0, 240, 143, 156,\n   44, 207]\n"
      title: A.2.2.  Content Encryption Key (CEK)
    - contents:
      - "A.2.3.  Key Encryption\n   Encrypt the CEK with the recipient's public key
        using the\n   RSAES-PKCS1-v1_5 algorithm to produce the JWE Encrypted Key.
        \ This\n   example uses the RSA key represented in JSON Web Key [JWK] format\n
        \  below (with line breaks within values for display purposes only):\n     {\"kty\":\"RSA\",\n
        \     \"n\":\"sXchDaQebHnPiGvyDOAT4saGEUetSyo9MKLOoWFsueri23bOdgWp4Dy1Wl\n
        \          UzewbgBHod5pcM9H95GQRV3JDXboIRROSBigeC5yjU1hGzHHyXss8UDpre\n           cbAYxknTcQkhslANGRUZmdTOQ5qTRsLAt6BTYuyvVRdhS8exSZEy_c4gs_\n
        \          7svlJJQ4H9_NxsiIoLwAEk7-Q3UXERGYw_75IDrGA84-lA_-Ct4eTlXHBI\n           Y2EaV7t7LjJaynVJCpkv4LKjTTAumiGUIuQhrNhZLuF_RJLqHpM2kgWFLU\n
        \          7-VTdL1VbC2tejvcI2BlMkEpk1BzBZI0KQB0GaDWFLN-aEAw3vRw\",\n      \"e\":\"AQAB\",\n
        \     \"d\":\"VFCWOqXr8nvZNyaaJLXdnNPXZKRaWCjkU5Q2egQQpTBMwhprMzWzpR8Sxq\n
        \          1OPThh_J6MUD8Z35wky9b8eEO0pwNS8xlh1lOFRRBoNqDIKVOku0aZb-ry\n           nq8cxjDTLZQ6Fz7jSjR1Klop-YKaUHc9GsEofQqYruPhzSA-QgajZGPbE_\n
        \          0ZaVDJHfyd7UUBUKunFMScbflYAAOYJqVIVwaYR5zWEEceUjNnTNo_CVSj\n           -VvXLO5VZfCUAVLgW4dpf1SrtZjSt34YLsRarSb127reG_DUwg9Ch-Kyvj\n
        \          T1SkHgUWRVGcyly7uvVGRSDwsXypdrNinPA4jlhoNdizK2zF2CWQ\",\n      \"p\":\"9gY2w6I6S6L0juEKsbeDAwpd9WMfgqFoeA9vEyEUuk4kLwBKcoe1x4HG68\n
        \          ik918hdDSE9vDQSccA3xXHOAFOPJ8R9EeIAbTi1VwBYnbTp87X-xcPWlEP\n           krdoUKW60tgs1aNd_Nnc9LEVVPMS390zbFxt8TN_biaBgelNgbC95sM\",\n
        \     \"q\":\"uKlCKvKv_ZJMVcdIs5vVSU_6cPtYI1ljWytExV_skstvRSNi9r66jdd9-y\n
        \          BhVfuG4shsp2j7rGnIio901RBeHo6TPKWVVykPu1iYhQXw1jIABfw-MVsN\n           -3bQ76WLdt2SDxsHs7q7zPyUyHXmps7ycZ5c72wGkUwNOjYelmkiNS0\",\n
        \     \"dp\":\"w0kZbV63cVRvVX6yk3C8cMxo2qCM4Y8nsq1lmMSYhG4EcL6FWbX5h9yuv\n
        \          ngs4iLEFk6eALoUS4vIWEwcL4txw9LsWH_zKI-hwoReoP77cOdSL4AVcra\n           Hawlkpyd2TWjE5evgbhWtOxnZee3cXJBkAi64Ik6jZxbvk-RR3pEhnCs\",\n
        \     \"dq\":\"o_8V14SezckO6CNLKs_btPdFiO9_kC1DsuUTd2LAfIIVeMZ7jn1Gus_Ff\n
        \          7B7IVx3p5KuBGOVF8L-qifLb6nQnLysgHDh132NDioZkhH7mI7hPG-PYE_\n           odApKdnqECHWw0J-F0JWnUd6D2B_1TvF9mXA2Qx-iGYn8OVV1Bsmp6qU\",\n
        \     \"qi\":\"eNho5yRBEBxhGBtQRww9QirZsB66TrfFReG_CcteI1aCneT0ELGhYlRlC\n
        \          tUkTRclIfuEPmNsNDPbLoLqqCVznFbvdB7x-Tl-m0l_eFTj2KiqwGqE9PZ\n           B9nNTwMVvH3VRRSLWACvPnSiwP8N5Usy-WRXS-V7TbpxIhvepTfE0NNo\"\n
        \    }\n   The resulting JWE Encrypted Key value is:\n   [80, 104, 72, 58,
        11, 130, 236, 139, 132, 189, 255, 205, 61, 86, 151,\n   176, 99, 40, 44, 233,
        176, 189, 205, 70, 202, 169, 72, 40, 226, 181,\n   156, 223, 120, 156, 115,
        232, 150, 209, 145, 133, 104, 112, 237, 156,\n   116, 250, 65, 102, 212, 210,
        103, 240, 177, 61, 93, 40, 71, 231, 223,\n   226, 240, 157, 15, 31, 150, 89,
        200, 215, 198, 203, 108, 70, 117, 66,\n   212, 238, 193, 205, 23, 161, 169,
        218, 243, 203, 128, 214, 127, 253,\n   215, 139, 43, 17, 135, 103, 179, 220,
        28, 2, 212, 206, 131, 158, 128,\n   66, 62, 240, 78, 186, 141, 125, 132, 227,
        60, 137, 43, 31, 152, 199,\n   54, 72, 34, 212, 115, 11, 152, 101, 70, 42,
        219, 233, 142, 66, 151,\n   250, 126, 146, 141, 216, 190, 73, 50, 177, 146,
        5, 52, 247, 28, 197,\n   21, 59, 170, 247, 181, 89, 131, 241, 169, 182, 246,
        99, 15, 36, 102,\n   166, 182, 172, 197, 136, 230, 120, 60, 58, 219, 243,
        149, 94, 222,\n   150, 154, 194, 110, 227, 225, 112, 39, 89, 233, 112, 207,
        211, 241,\n   124, 174, 69, 221, 179, 107, 196, 225, 127, 167, 112, 226, 12,
        242,\n   16, 24, 28, 120, 182, 244, 213, 244, 153, 194, 162, 69, 160, 244,\n
        \  248, 63, 165, 141, 4, 207, 249, 193, 79, 131, 0, 169, 233, 127, 167,\n
        \  101, 151, 125, 56, 112, 111, 248, 29, 232, 90, 29, 147, 110, 169,\n   146,
        114, 165, 204, 71, 136, 41, 252]\n   Encoding this JWE Encrypted Key as BASE64URL(JWE
        Encrypted Key) gives\n   this value (with line breaks for display purposes
        only):\n     UGhIOguC7IuEvf_NPVaXsGMoLOmwvc1GyqlIKOK1nN94nHPoltGRhWhw7Zx0-kFm\n
        \    1NJn8LE9XShH59_i8J0PH5ZZyNfGy2xGdULU7sHNF6Gp2vPLgNZ__deLKxGHZ7Pc\n     HALUzoOegEI-8E66jX2E4zyJKx-YxzZIItRzC5hlRirb6Y5Cl_p-ko3YvkkysZIF\n
        \    NPccxRU7qve1WYPxqbb2Yw8kZqa2rMWI5ng8OtvzlV7elprCbuPhcCdZ6XDP0_F8\n     rkXds2vE4X-ncOIM8hAYHHi29NX0mcKiRaD0-D-ljQTP-cFPgwCp6X-nZZd9OHBv\n
        \    -B3oWh2TbqmScqXMR4gp_A\n"
      title: A.2.3.  Key Encryption
    - contents:
      - "A.2.4.  Initialization Vector\n   Generate a random 128-bit JWE Initialization
        Vector.  In this\n   example, the value is:\n   [3, 22, 60, 12, 43, 67, 104,
        105, 108, 108, 105, 99, 111, 116, 104,\n   101]\n   Encoding this JWE Initialization
        Vector as BASE64URL(JWE\n   Initialization Vector) gives this value:\n     AxY8DCtDaGlsbGljb3RoZQ\n"
      title: A.2.4.  Initialization Vector
    - contents:
      - "A.2.5.  Additional Authenticated Data\n   Let the Additional Authenticated
        Data encryption parameter be\n   ASCII(BASE64URL(UTF8(JWE Protected Header))).
        \ This value is:\n   [101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83,
        85, 48, 69,\n   120, 88, 122, 85, 105, 76, 67, 74, 108, 98, 109, 77, 105,
        79, 105,\n   74, 66, 77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77,
        106, 85,\n   50, 73, 110, 48]\n"
      title: A.2.5.  Additional Authenticated Data
    - contents:
      - "A.2.6.  Content Encryption\n   Perform authenticated encryption on the plaintext
        with the\n   AES_128_CBC_HMAC_SHA_256 algorithm using the CEK as the encryption\n
        \  key, the JWE Initialization Vector, and the Additional Authenticated\n
        \  Data value above.  The steps for doing this using the values from\n   Appendix
        A.3 are detailed in Appendix B.  The resulting ciphertext\n   is:\n   [40,
        57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6,\n   75, 129,
        223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143,\n   112, 56, 102]\n
        \  The resulting Authentication Tag value is:\n   [246, 17, 244, 190, 4, 95,
        98, 3, 231, 0, 115, 157, 242, 203, 100,\n   191]\n   Encoding this JWE Ciphertext
        as BASE64URL(JWE Ciphertext) gives this\n   value:\n     KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY\n
        \  Encoding this JWE Authentication Tag as BASE64URL(JWE Authentication\n
        \  Tag) gives this value:\n     9hH0vgRfYgPnAHOd8stkvw\n"
      title: A.2.6.  Content Encryption
    - contents:
      - "A.2.7.  Complete Representation\n   Assemble the final representation: The
        Compact Serialization of this\n   result is the string BASE64URL(UTF8(JWE
        Protected Header)) || '.' ||\n   BASE64URL(JWE Encrypted Key) || '.' || BASE64URL(JWE
        Initialization\n   Vector) || '.' || BASE64URL(JWE Ciphertext) || '.' || BASE64URL(JWE\n
        \  Authentication Tag).\n   The final result in this example (with line breaks
        for display\n   purposes only) is:\n     eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.\n
        \    UGhIOguC7IuEvf_NPVaXsGMoLOmwvc1GyqlIKOK1nN94nHPoltGRhWhw7Zx0-kFm\n     1NJn8LE9XShH59_i8J0PH5ZZyNfGy2xGdULU7sHNF6Gp2vPLgNZ__deLKxGHZ7Pc\n
        \    HALUzoOegEI-8E66jX2E4zyJKx-YxzZIItRzC5hlRirb6Y5Cl_p-ko3YvkkysZIF\n     NPccxRU7qve1WYPxqbb2Yw8kZqa2rMWI5ng8OtvzlV7elprCbuPhcCdZ6XDP0_F8\n
        \    rkXds2vE4X-ncOIM8hAYHHi29NX0mcKiRaD0-D-ljQTP-cFPgwCp6X-nZZd9OHBv\n     -B3oWh2TbqmScqXMR4gp_A.\n
        \    AxY8DCtDaGlsbGljb3RoZQ.\n     KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.\n
        \    9hH0vgRfYgPnAHOd8stkvw\n"
      title: A.2.7.  Complete Representation
    - contents:
      - "A.2.8.  Validation\n   This example illustrates the process of creating a
        JWE with\n   RSAES-PKCS1-v1_5 for key encryption and AES_CBC_HMAC_SHA2 for
        content\n   encryption.  These results can be used to validate JWE decryption\n
        \  implementations for these algorithms.  Note that since the\n   RSAES-PKCS1-v1_5
        computation includes random values, the encryption\n   results above will
        not be completely reproducible.  However, since\n   the AES-CBC computation
        is deterministic, the JWE Encrypted\n   Ciphertext values will be the same
        for all encryptions performed\n   using these inputs.\n"
      title: A.2.8.  Validation
    title: A.2.  Example JWE using RSAES-PKCS1-v1_5 and AES_128_CBC_HMAC_SHA_256
  - contents:
    - "A.3.  Example JWE Using AES Key Wrap and AES_128_CBC_HMAC_SHA_256\n   This
      example encrypts the plaintext \"Live long and prosper.\" to the\n   recipient
      using AES Key Wrap for key encryption and\n   AES_128_CBC_HMAC_SHA_256 for content
      encryption.  The representation\n   of this plaintext (using JSON array notation)
      is:\n   [76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97, 110, 100, 32,\n
      \  112, 114, 111, 115, 112, 101, 114, 46]\n"
    - contents:
      - "A.3.1.  JOSE Header\n   The following example JWE Protected Header declares
        that:\n   o  The Content Encryption Key is encrypted to the recipient using
        the\n      AES Key Wrap algorithm with a 128-bit key to produce the JWE\n
        \     Encrypted Key.\n   o  Authenticated encryption is performed on the plaintext
        using the\n      AES_128_CBC_HMAC_SHA_256 algorithm to produce the ciphertext
        and\n      the Authentication Tag.\n     {\"alg\":\"A128KW\",\"enc\":\"A128CBC-HS256\"}\n
        \  Encoding this JWE Protected Header as BASE64URL(UTF8(JWE Protected\n   Header))
        gives this value:\n     eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0\n"
      title: A.3.1.  JOSE Header
    - contents:
      - "A.3.2.  Content Encryption Key (CEK)\n   Generate a 256-bit random CEK.  In
        this example, the value is:\n   [4, 211, 31, 197, 84, 157, 252, 254, 11, 100,
        157, 250, 63, 170, 106,\n   206, 107, 124, 212, 45, 111, 107, 9, 219, 200,
        177, 0, 240, 143, 156,\n   44, 207]\n"
      title: A.3.2.  Content Encryption Key (CEK)
    - contents:
      - "A.3.3.  Key Encryption\n   Encrypt the CEK with the shared symmetric key
        using the AES Key Wrap\n   algorithm to produce the JWE Encrypted Key.  This
        example uses the\n   symmetric key represented in JSON Web Key [JWK] format
        below:\n     {\"kty\":\"oct\",\n      \"k\":\"GawgguFyGrWKav7AX4VKUg\"\n     }\n
        \  The resulting JWE Encrypted Key value is:\n   [232, 160, 123, 211, 183,
        76, 245, 132, 200, 128, 123, 75, 190, 216,\n   22, 67, 201, 138, 193, 186,
        9, 91, 122, 31, 246, 90, 28, 139, 57, 3,\n   76, 124, 193, 11, 98, 37, 173,
        61, 104, 57]\n   Encoding this JWE Encrypted Key as BASE64URL(JWE Encrypted
        Key) gives\n   this value:\n     6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ\n"
      title: A.3.3.  Key Encryption
    - contents:
      - "A.3.4.  Initialization Vector\n   Generate a random 128-bit JWE Initialization
        Vector.  In this\n   example, the value is:\n   [3, 22, 60, 12, 43, 67, 104,
        105, 108, 108, 105, 99, 111, 116, 104,\n   101]\n   Encoding this JWE Initialization
        Vector as BASE64URL(JWE\n   Initialization Vector) gives this value:\n     AxY8DCtDaGlsbGljb3RoZQ\n"
      title: A.3.4.  Initialization Vector
    - contents:
      - "A.3.5.  Additional Authenticated Data\n   Let the Additional Authenticated
        Data encryption parameter be\n   ASCII(BASE64URL(UTF8(JWE Protected Header))).
        \ This value is:\n   [101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 66,
        77, 84, 73, 52,\n   83, 49, 99, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79,
        105, 74, 66,\n   77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106,
        85, 50, 73,\n   110, 48]\n"
      title: A.3.5.  Additional Authenticated Data
    - contents:
      - "A.3.6.  Content Encryption\n   Perform authenticated encryption on the plaintext
        with the\n   AES_128_CBC_HMAC_SHA_256 algorithm using the CEK as the encryption\n
        \  key, the JWE Initialization Vector, and the Additional Authenticated\n
        \  Data value above.  The steps for doing this using the values from\n   this
        example are detailed in Appendix B.  The resulting ciphertext\n   is:\n   [40,
        57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6,\n   75, 129,
        223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143,\n   112, 56, 102]\n
        \  The resulting Authentication Tag value is:\n   [83, 73, 191, 98, 104, 205,
        211, 128, 201, 189, 199, 133, 32, 38,\n   194, 85]\n   Encoding this JWE Ciphertext
        as BASE64URL(JWE Ciphertext) gives this\n   value:\n     KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY\n
        \  Encoding this JWE Authentication Tag as BASE64URL(JWE Authentication\n
        \  Tag) gives this value:\n     U0m_YmjN04DJvceFICbCVQ\n"
      title: A.3.6.  Content Encryption
    - contents:
      - "A.3.7.  Complete Representation\n   Assemble the final representation: The
        Compact Serialization of this\n   result is the string BASE64URL(UTF8(JWE
        Protected Header)) || '.' ||\n   BASE64URL(JWE Encrypted Key) || '.' || BASE64URL(JWE
        Initialization\n   Vector) || '.' || BASE64URL(JWE Ciphertext) || '.' || BASE64URL(JWE\n
        \  Authentication Tag).\n   The final result in this example (with line breaks
        for display\n   purposes only) is:\n     eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.\n
        \    6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.\n     AxY8DCtDaGlsbGljb3RoZQ.\n
        \    KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.\n     U0m_YmjN04DJvceFICbCVQ\n"
      title: A.3.7.  Complete Representation
    - contents:
      - "A.3.8.  Validation\n   This example illustrates the process of creating a
        JWE with AES Key\n   Wrap for key encryption and AES GCM for content encryption.
        \ These\n   results can be used to validate JWE decryption implementations
        for\n   these algorithms.  Also, since both the AES Key Wrap and AES GCM\n
        \  computations are deterministic, the resulting JWE value will be the\n   same
        for all encryptions performed using these inputs.  Since the\n   computation
        is reproducible, these results can also be used to\n   validate JWE encryption
        implementations for these algorithms.\n"
      title: A.3.8.  Validation
    title: A.3.  Example JWE Using AES Key Wrap and AES_128_CBC_HMAC_SHA_256
  - contents:
    - "A.4.  Example JWE Using General JWE JSON Serialization\n   This section contains
      an example using the general JWE JSON\n   Serialization syntax.  This example
      demonstrates the capability for\n   encrypting the same plaintext to multiple
      recipients.\n   Two recipients are present in this example.  The algorithm and
      key\n   used for the first recipient are the same as that used in\n   Appendix
      A.2.  The algorithm and key used for the second recipient\n   are the same as
      that used in Appendix A.3.  The resulting JWE\n   Encrypted Key values are therefore
      the same; those computations are\n   not repeated here.\n   The plaintext, the
      CEK, JWE Initialization Vector, and JWE Protected\n   Header are shared by all
      recipients (which must be the case, since\n   the ciphertext and Authentication
      Tag are also shared).\n"
    - contents:
      - "A.4.1.  JWE Per-Recipient Unprotected Headers\n   The first recipient uses
        the RSAES-PKCS1-v1_5 algorithm to encrypt\n   the CEK.  The second uses AES
        Key Wrap to encrypt the CEK.  Key ID\n   values are supplied for both keys.
        \ The two JWE Per-Recipient\n   Unprotected Header values used to represent
        these algorithms and key\n   IDs are:\n     {\"alg\":\"RSA1_5\",\"kid\":\"2011-04-29\"}\n
        \  and\n     {\"alg\":\"A128KW\",\"kid\":\"7\"}\n"
      title: A.4.1.  JWE Per-Recipient Unprotected Headers
    - contents:
      - "A.4.2.  JWE Protected Header\n   Authenticated encryption is performed on
        the plaintext using the\n   AES_128_CBC_HMAC_SHA_256 algorithm to produce
        the common JWE\n   Ciphertext and JWE Authentication Tag values.  The JWE
        Protected\n   Header value representing this is:\n     {\"enc\":\"A128CBC-HS256\"}\n
        \  Encoding this JWE Protected Header as BASE64URL(UTF8(JWE Protected\n   Header))
        gives this value:\n     eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0\n"
      title: A.4.2.  JWE Protected Header
    - contents:
      - "A.4.3.  JWE Shared Unprotected Header\n   This JWE uses the \"jku\" Header
        Parameter to reference a JWK Set.\n   This is represented in the following
        JWE Shared Unprotected Header\n   value as:\n     {\"jku\":\"https://server.example.com/keys.jwks\"}\n"
      title: A.4.3.  JWE Shared Unprotected Header
    - contents:
      - "A.4.4.  Complete JOSE Header Values\n   Combining the JWE Per-Recipient Unprotected
        Header, JWE Protected\n   Header, and JWE Shared Unprotected Header values
        supplied, the JOSE\n   Header values used for the first and second recipient,
        respectively,\n   are:\n     {\"alg\":\"RSA1_5\",\n      \"kid\":\"2011-04-29\",\n
        \     \"enc\":\"A128CBC-HS256\",\n      \"jku\":\"https://server.example.com/keys.jwks\"}\n
        \  and\n     {\"alg\":\"A128KW\",\n      \"kid\":\"7\",\n      \"enc\":\"A128CBC-HS256\",\n
        \     \"jku\":\"https://server.example.com/keys.jwks\"}\n"
      title: A.4.4.  Complete JOSE Header Values
    - contents:
      - "A.4.5.  Additional Authenticated Data\n   Let the Additional Authenticated
        Data encryption parameter be\n   ASCII(BASE64URL(UTF8(JWE Protected Header))).
        \ This value is:\n   [101, 121, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66,
        77, 84, 73,\n   52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50, 73,
        110, 48]\n"
      title: A.4.5.  Additional Authenticated Data
    - contents:
      - "A.4.6.  Content Encryption\n   Perform authenticated encryption on the plaintext
        with the\n   AES_128_CBC_HMAC_SHA_256 algorithm using the CEK as the encryption\n
        \  key, the JWE Initialization Vector, and the Additional Authenticated\n
        \  Data value above.  The steps for doing this using the values from\n   Appendix
        A.3 are detailed in Appendix B.  The resulting ciphertext\n   is:\n   [40,
        57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6,\n   75, 129,
        223, 127, 19, 210, 82, 183, 230, 168, 33, 215, 104, 143,\n   112, 56, 102]\n
        \  The resulting Authentication Tag value is:\n   [51, 63, 149, 60, 252, 148,
        225, 25, 92, 185, 139, 245, 35, 2, 47,\n   207]\n   Encoding this JWE Ciphertext
        as BASE64URL(JWE Ciphertext) gives this\n   value:\n     KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY\n
        \  Encoding this JWE Authentication Tag as BASE64URL(JWE Authentication\n
        \  Tag) gives this value:\n     Mz-VPPyU4RlcuYv1IwIvzw\n"
      title: A.4.6.  Content Encryption
    - contents:
      - "A.4.7.  Complete JWE JSON Serialization Representation\n   The complete JWE
        JSON Serialization for these values is as follows\n   (with line breaks within
        values for display purposes only):\n     {\n      \"protected\":\n       \"eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0\",\n
        \     \"unprotected\":\n       {\"jku\":\"https://server.example.com/keys.jwks\"},\n
        \     \"recipients\":[\n       {\"header\":\n         {\"alg\":\"RSA1_5\",\"kid\":\"2011-04-29\"},\n
        \       \"encrypted_key\":\n         \"UGhIOguC7IuEvf_NPVaXsGMoLOmwvc1GyqlIKOK1nN94nHPoltGRhWhw7Zx0-\n
        \         kFm1NJn8LE9XShH59_i8J0PH5ZZyNfGy2xGdULU7sHNF6Gp2vPLgNZ__deLKx\n
        \         GHZ7PcHALUzoOegEI-8E66jX2E4zyJKx-YxzZIItRzC5hlRirb6Y5Cl_p-ko3\n
        \         YvkkysZIFNPccxRU7qve1WYPxqbb2Yw8kZqa2rMWI5ng8OtvzlV7elprCbuPh\n
        \         cCdZ6XDP0_F8rkXds2vE4X-ncOIM8hAYHHi29NX0mcKiRaD0-D-ljQTP-cFPg\n
        \         wCp6X-nZZd9OHBv-B3oWh2TbqmScqXMR4gp_A\"},\n       {\"header\":\n
        \        {\"alg\":\"A128KW\",\"kid\":\"7\"},\n        \"encrypted_key\":\n
        \        \"6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ\"}],\n      \"iv\":\n
        \      \"AxY8DCtDaGlsbGljb3RoZQ\",\n      \"ciphertext\":\n       \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY\",\n
        \     \"tag\":\n       \"Mz-VPPyU4RlcuYv1IwIvzw\"\n     }\n"
      title: A.4.7.  Complete JWE JSON Serialization Representation
    title: A.4.  Example JWE Using General JWE JSON Serialization
  - contents:
    - "A.5.  Example JWE Using Flattened JWE JSON Serialization\n   This section contains
      an example using the flattened JWE JSON\n   Serialization syntax.  This example
      demonstrates the capability for\n   encrypting the plaintext to a single recipient
      in a flattened JSON\n   structure.\n   The values in this example are the same
      as those for the second\n   recipient of the previous example in Appendix A.4.\n
      \  The complete JWE JSON Serialization for these values is as follows\n   (with
      line breaks within values for display purposes only):\n     {\n      \"protected\":\n
      \      \"eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0\",\n      \"unprotected\":\n       {\"jku\":\"https://server.example.com/keys.jwks\"},\n
      \     \"header\":\n       {\"alg\":\"A128KW\",\"kid\":\"7\"},\n      \"encrypted_key\":\n
      \      \"6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ\",\n      \"iv\":\n
      \      \"AxY8DCtDaGlsbGljb3RoZQ\",\n      \"ciphertext\":\n       \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY\",\n
      \     \"tag\":\n       \"Mz-VPPyU4RlcuYv1IwIvzw\"\n     }\n"
    title: A.5.  Example JWE Using Flattened JWE JSON Serialization
  title: Appendix A.  JWE Examples
- contents:
  - "Appendix B.  Example AES_128_CBC_HMAC_SHA_256 Computation\n   This example shows
    the steps in the AES_128_CBC_HMAC_SHA_256\n   authenticated encryption computation
    using the values from the\n   example in Appendix A.3.  As described where this
    algorithm is\n   defined in Sections 5.2 and 5.2.3 of JWA, the AES_CBC_HMAC_SHA2\n
    \  family of algorithms are implemented using Advanced Encryption\n   Standard
    (AES) in Cipher Block Chaining (CBC) mode with Public-Key\n   Cryptography Standards
    (PKCS) #7 padding to perform the encryption\n   and an HMAC SHA-2 function to
    perform the integrity calculation -- in\n   this case, HMAC SHA-256.\n"
  - contents:
    - "B.1.  Extract MAC_KEY and ENC_KEY from Key\n   The 256 bit AES_128_CBC_HMAC_SHA_256
      key K used in this example\n   (using JSON array notation) is:\n   [4, 211,
      31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106,\n   206, 107, 124,
      212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156,\n   44, 207]\n   Use
      the first 128 bits of this key as the HMAC SHA-256 key MAC_KEY,\n   which is:\n
      \  [4, 211, 31, 197, 84, 157, 252, 254, 11, 100, 157, 250, 63, 170, 106,\n   206]\n
      \  Use the last 128 bits of this key as the AES-CBC key ENC_KEY, which\n   is:\n
      \  [107, 124, 212, 45, 111, 107, 9, 219, 200, 177, 0, 240, 143, 156, 44,\n   207]\n
      \  Note that the MAC key comes before the encryption key in the input\n   key
      K; this is in the opposite order of the algorithm names in the\n   identifiers
      \"AES_128_CBC_HMAC_SHA_256\" and \"A128CBC-HS256\".\n"
    title: B.1.  Extract MAC_KEY and ENC_KEY from Key
  - contents:
    - "B.2.  Encrypt Plaintext to Create Ciphertext\n   Encrypt the plaintext with
      AES in CBC mode using PKCS #7 padding\n   using the ENC_KEY above.  The plaintext
      in this example is:\n   [76, 105, 118, 101, 32, 108, 111, 110, 103, 32, 97,
      110, 100, 32,\n   112, 114, 111, 115, 112, 101, 114, 46]\n   The encryption
      result is as follows, which is the ciphertext output:\n   [40, 57, 83, 181,
      119, 33, 133, 148, 198, 185, 243, 24, 152, 230, 6,\n   75, 129, 223, 127, 19,
      210, 82, 183, 230, 168, 33, 215, 104, 143,\n   112, 56, 102]\n"
    title: B.2.  Encrypt Plaintext to Create Ciphertext
  - contents:
    - "B.3.  64-Bit Big-Endian Representation of AAD Length\n   The Additional Authenticated
      Data (AAD) in this example is:\n   [101, 121, 74, 104, 98, 71, 99, 105, 79,
      105, 74, 66, 77, 84, 73, 52,\n   83, 49, 99, 105, 76, 67, 74, 108, 98, 109,
      77, 105, 79, 105, 74, 66,\n   77, 84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84,
      77, 106, 85, 50, 73,\n   110, 48]\n   This AAD is 51-bytes long, which is 408-bits
      long.  The octet string\n   AL, which is the number of bits in AAD expressed
      as a big-endian\n   64-bit unsigned integer is:\n   [0, 0, 0, 0, 0, 0, 1, 152]\n"
    title: B.3.  64-Bit Big-Endian Representation of AAD Length
  - contents:
    - "B.4.  Initialization Vector Value\n   The Initialization Vector value used
      in this example is:\n   [3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99,
      111, 116, 104,\n   101]\n"
    title: B.4.  Initialization Vector Value
  - contents:
    - "B.5.  Create Input to HMAC Computation\n   Concatenate the AAD, the Initialization
      Vector, the ciphertext, and\n   the AL value.  The result of this concatenation
      is:\n   [101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 66, 77, 84, 73, 52,\n
      \  83, 49, 99, 105, 76, 67, 74, 108, 98, 109, 77, 105, 79, 105, 74, 66,\n   77,
      84, 73, 52, 81, 48, 74, 68, 76, 85, 104, 84, 77, 106, 85, 50, 73,\n   110, 48,
      3, 22, 60, 12, 43, 67, 104, 105, 108, 108, 105, 99, 111,\n   116, 104, 101,
      40, 57, 83, 181, 119, 33, 133, 148, 198, 185, 243, 24,\n   152, 230, 6, 75,
      129, 223, 127, 19, 210, 82, 183, 230, 168, 33, 215,\n   104, 143, 112, 56, 102,
      0, 0, 0, 0, 0, 0, 1, 152]\n"
    title: B.5.  Create Input to HMAC Computation
  - contents:
    - "B.6.  Compute HMAC Value\n   Compute the HMAC SHA-256 of the concatenated value
      above.  This\n   result M is:\n   [83, 73, 191, 98, 104, 205, 211, 128, 201,
      189, 199, 133, 32, 38,\n   194, 85, 9, 84, 229, 201, 219, 135, 44, 252, 145,
      102, 179, 140, 105,\n   86, 229, 116]\n"
    title: B.6.  Compute HMAC Value
  - contents:
    - "B.7.  Truncate HMAC Value to Create Authentication Tag\n   Use the first half
      (128 bits) of the HMAC output M as the\n   Authentication Tag output T.  This
      truncated value is:\n   [83, 73, 191, 98, 104, 205, 211, 128, 201, 189, 199,
      133, 32, 38,\n   194, 85]\n"
    title: B.7.  Truncate HMAC Value to Create Authentication Tag
  title: Appendix B.  Example AES_128_CBC_HMAC_SHA_256 Computation
- contents:
  - "Acknowledgements\n   Solutions for encrypting JSON content were also explored
    by \"JSON\n   Simple Encryption\" [JSE] and \"JavaScript Message Security Format\"\n
    \  [JSMS], both of which significantly influenced this document.  This\n   document
    attempts to explicitly reuse as many of the relevant\n   concepts from XML Encryption
    1.1 [W3C.REC-xmlenc-core1-20130411] and\n   RFC 5652 [RFC5652] as possible, while
    utilizing simple, compact JSON-\n   based data structures.\n   Special thanks
    are due to John Bradley, Eric Rescorla, and Nat\n   Sakimura for the discussions
    that helped inform the content of this\n   specification; to Eric Rescorla and
    Joe Hildebrand for allowing the\n   reuse of text from [JSMS] in this document;
    and to Eric Rescorla for\n   co-authoring many drafts of this specification.\n
    \  Thanks to Axel Nennker, Emmanuel Raviart, Brian Campbell, and Edmund\n   Jay
    for validating the examples in this specification.\n   This specification is the
    work of the JOSE working group, which\n   includes dozens of active and dedicated
    participants.  In particular,\n   the following individuals contributed ideas,
    feedback, and wording\n   that influenced this specification:\n   Richard Barnes,
    John Bradley, Brian Campbell, Alissa Cooper, Breno de\n   Medeiros, Stephen Farrell,
    Dick Hardt, Jeff Hodges, Russ Housley,\n   Edmund Jay, Scott Kelly, Stephen Kent,
    Barry Leiba, James Manger,\n   Matt Miller, Kathleen Moriarty, Tony Nadalin, Hideki
    Nara, Axel\n   Nennker, Ray Polk, Emmanuel Raviart, Eric Rescorla, Pete Resnick,
    Nat\n   Sakimura, Jim Schaad, Hannes Tschofenig, and Sean Turner.\n   Jim Schaad
    and Karen O'Donoghue chaired the JOSE working group and\n   Sean Turner, Stephen
    Farrell, and Kathleen Moriarty served as\n   Security Area Directors during the
    creation of this specification.\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   Michael B. Jones\n   Microsoft\n   EMail: mbj@microsoft.com\n
    \  URI:   http://self-issued.info/\n   Joe Hildebrand\n   Cisco Systems, Inc.\n
    \  EMail: jhildebr@cisco.com\n"
  title: Authors' Addresses
