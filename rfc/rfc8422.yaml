- contents:
  - "            Elliptic Curve Cryptography (ECC) Cipher Suites\n      for Transport
    Layer Security (TLS) Versions 1.2 and Earlier\n"
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes key exchange algorithms based on Elliptic\n
    \  Curve Cryptography (ECC) for the Transport Layer Security (TLS)\n   protocol.
    \ In particular, it specifies the use of Ephemeral Elliptic\n   Curve Diffie-Hellman
    (ECDHE) key agreement in a TLS handshake and the\n   use of the Elliptic Curve
    Digital Signature Algorithm (ECDSA) and\n   Edwards-curve Digital Signature Algorithm
    (EdDSA) as authentication\n   mechanisms.\n   This document obsoletes RFC 4492.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8422.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   4\n     1.1.  Conventions Used in This Document . . . . . . . . .
    . . .   4\n   2.  Key Exchange Algorithm  . . . . . . . . . . . . . . . . . .
    .   4\n     2.1.  ECDHE_ECDSA . . . . . . . . . . . . . . . . . . . . . . .   6\n
    \    2.2.  ECDHE_RSA . . . . . . . . . . . . . . . . . . . . . . . .   7\n     2.3.
    \ ECDH_anon . . . . . . . . . . . . . . . . . . . . . . . .   7\n     2.4.  Algorithms
    in Certificate Chains  . . . . . . . . . . . .   7\n   3.  Client Authentication
    . . . . . . . . . . . . . . . . . . . .   8\n     3.1.  ECDSA_sign  . . . . .
    . . . . . . . . . . . . . . . . . .   8\n   4.  TLS Extensions for ECC  . . .
    . . . . . . . . . . . . . . . .   9\n   5.  Data Structures and Computations  .
    . . . . . . . . . . . . .  10\n     5.1.  Client Hello Extensions . . . . . .
    . . . . . . . . . . .  10\n       5.1.1.  Supported Elliptic Curves Extension
    . . . . . . . . .  11\n       5.1.2.  Supported Point Formats Extension . . .
    . . . . . . .  13\n       5.1.3.  The signature_algorithms Extension and EdDSA
    \ . . . .  13\n     5.2.  Server Hello Extension  . . . . . . . . . . . . . .
    . . .  14\n     5.3.  Server Certificate  . . . . . . . . . . . . . . . . . .
    .  15\n     5.4.  Server Key Exchange . . . . . . . . . . . . . . . . . . .  16\n
    \      5.4.1.  Uncompressed Point Format for NIST Curves . . . . . .  19\n     5.5.
    \ Certificate Request . . . . . . . . . . . . . . . . . . .  20\n     5.6.  Client
    Certificate  . . . . . . . . . . . . . . . . . . .  21\n     5.7.  Client Key
    Exchange . . . . . . . . . . . . . . . . . . .  22\n     5.8.  Certificate Verify
    \ . . . . . . . . . . . . . . . . . . .  23\n     5.9.  Elliptic Curve Certificates
    . . . . . . . . . . . . . . .  24\n     5.10. ECDH, ECDSA, and RSA Computations
    . . . . . . . . . . . .  24\n     5.11. Public Key Validation . . . . . . . .
    . . . . . . . . . .  26\n   6.  Cipher Suites . . . . . . . . . . . . . . . .
    . . . . . . . .  26\n   7.  Implementation Status . . . . . . . . . . . . . .
    . . . . . .  27\n   8.  Security Considerations . . . . . . . . . . . . . . .
    . . . .  27\n   9.  IANA Considerations . . . . . . . . . . . . . . . . . . .
    . .  28\n   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .
    \ 29\n     10.1.  Normative References . . . . . . . . . . . . . . . . . .  29\n
    \    10.2.  Informative References . . . . . . . . . . . . . . . . .  31\n   Appendix
    A.  Equivalent Curves (Informative)  . . . . . . . . . .  32\n   Appendix B.  Differences
    from RFC 4492  . . . . . . . . . . . . .  33\n   Acknowledgements  . . . . . .
    . . . . . . . . . . . . . . . . . .  34\n   Authors' Addresses  . . . . . . .
    . . . . . . . . . . . . . . . .  34\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document describes additions to TLS to support ECC
    that are\n   applicable to TLS versions 1.0 [RFC2246], 1.1 [RFC4346], and 1.2\n
    \  [RFC5246].  The use of ECC in TLS 1.3 is defined in [TLS1.3] and is\n   explicitly
    out of scope for this document.  In particular, this\n   document defines:\n   o
    \ the use of the ECDHE key agreement scheme with ephemeral keys to\n      establish
    the TLS premaster secret, and\n   o  the use of ECDSA and EdDSA signatures for
    authentication of TLS\n      peers.\n   The remainder of this document is organized
    as follows.  Section 2\n   provides an overview of ECC-based key exchange algorithms
    for TLS.\n   Section 3 describes the use of ECC certificates for client\n   authentication.
    \ TLS extensions that allow a client to negotiate the\n   use of specific curves
    and point formats are presented in Section 4.\n   Section 5 specifies various
    data structures needed for an ECC-based\n   handshake, their encoding in TLS messages,
    and the processing of\n   those messages.  Section 6 defines ECC-based cipher
    suites and\n   identifies a small subset of these as recommended for all\n   implementations
    of this specification.  Section 8 discusses security\n   considerations.  Section
    9 describes IANA considerations for the name\n   spaces created by this document's
    predecessor.  Appendix B provides\n   differences from [RFC4492], the document
    that this one replaces.\n   Implementation of this specification requires familiarity
    with TLS,\n   TLS extensions [RFC4366], and ECC.\n"
  - contents:
    - "1.1.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST
      NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\",
      \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this
      document are to be interpreted as described in\n   BCP 14 [RFC2119] [RFC8174]
      when, and only when, they appear in all\n   capitals, as shown here.\n"
    title: 1.1.  Conventions Used in This Document
  title: 1.  Introduction
- contents:
  - "2.  Key Exchange Algorithm\n   This document defines three new ECC-based key
    exchange algorithms for\n   TLS.  All of them use Ephemeral ECDH (ECDHE) to compute
    the TLS\n   premaster secret, and they differ only in the mechanism (if any) used\n
    \  to authenticate them.  The derivation of the TLS master secret from\n   the
    premaster secret and the subsequent generation of bulk\n   encryption/MAC keys
    and initialization vectors is independent of the\n   key exchange algorithm and
    not impacted by the introduction of ECC.\n   Table 1 summarizes the new key exchange
    algorithms.  All of these key\n   exchange algorithms provide forward secrecy
    if and only if fresh\n   ephemeral keys are generated and used, and also destroyed
    after use.\n     +-------------+------------------------------------------------+\n
    \    | Algorithm   | Description                                    |\n     +-------------+------------------------------------------------+\n
    \    | ECDHE_ECDSA | Ephemeral ECDH with ECDSA or EdDSA signatures. |\n     |
    ECDHE_RSA   | Ephemeral ECDH with RSA signatures.            |\n     | ECDH_anon
    \  | Anonymous ephemeral ECDH, no signatures.       |\n     +-------------+------------------------------------------------+\n
    \                  Table 1: ECC Key Exchange Algorithms\n   These key exchanges
    are analogous to DHE_DSS, DHE_RSA, and DH_anon,\n   respectively.\n   With ECDHE_RSA,
    a server can reuse its existing RSA certificate and\n   easily comply with a constrained
    client's elliptic curve preferences\n   (see Section 4).  However, the computational
    cost incurred by a\n   server is higher for ECDHE_RSA than for the traditional
    RSA key\n   exchange, which does not provide forward secrecy.\n   The anonymous
    key exchange algorithm does not provide authentication\n   of the server or the
    client.  Like other anonymous TLS key exchanges,\n   it is subject to man-in-the-middle
    attacks.  Applications using TLS\n   with this algorithm SHOULD provide authentication
    by other means.\n          Client                                        Server\n
    \         ------                                        ------\n          ClientHello
    \         -------->\n                                                   ServerHello\n
    \                                                 Certificate*\n                                            ServerKeyExchange*\n
    \                                         CertificateRequest*+\n                               <--------
    \      ServerHelloDone\n          Certificate*+\n          ClientKeyExchange\n
    \         CertificateVerify*+\n          [ChangeCipherSpec]\n          Finished
    \            -------->\n                                            [ChangeCipherSpec]\n
    \                              <--------              Finished\n          Application
    Data     <------->      Application Data\n               * message is not sent
    under some conditions\n               + message is not sent unless client authentication\n
    \                is desired\n            Figure 1: Message Flow in a Full TLS
    1.2 Handshake\n   Figure 1 shows all messages involved in the TLS key establishment\n
    \  protocol (aka full handshake).  The addition of ECC has direct impact\n   only
    on the ClientHello, the ServerHello, the server's Certificate\n   message, the
    ServerKeyExchange, the ClientKeyExchange, the\n   CertificateRequest, the client's
    Certificate message, and the\n   CertificateVerify.  Next, we describe the ECC
    key exchange algorithm\n   in greater detail in terms of the content and processing
    of these\n   messages.  For ease of exposition, we defer discussion of client\n
    \  authentication and associated messages (identified with a '+' in\n   Figure
    1) until Section 3 and of the optional ECC-specific extensions\n   (which impact
    the Hello messages) until Section 4.\n"
  - contents:
    - "2.1.  ECDHE_ECDSA\n   In ECDHE_ECDSA, the server's certificate MUST contain
      an ECDSA- or\n   EdDSA-capable public key.\n   The server sends its ephemeral
      ECDH public key and a specification of\n   the corresponding curve in the ServerKeyExchange
      message.  These\n   parameters MUST be signed with ECDSA or EdDSA using the
      private key\n   corresponding to the public key in the server's Certificate.\n
      \  The client generates an ECDH key pair on the same curve as the\n   server's
      ephemeral ECDH key and sends its public key in the\n   ClientKeyExchange message.\n
      \  Both client and server perform an ECDH operation (see Section 5.10)\n   and
      use the resultant shared secret as the premaster secret.\n"
    title: 2.1.  ECDHE_ECDSA
  - contents:
    - "2.2.  ECDHE_RSA\n   This key exchange algorithm is the same as ECDHE_ECDSA
      except that\n   the server's certificate MUST contain an RSA public key authorized\n
      \  for signing and the signature in the ServerKeyExchange message must\n   be
      computed with the corresponding RSA private key.\n"
    title: 2.2.  ECDHE_RSA
  - contents:
    - "2.3.  ECDH_anon\n   NOTE: Despite the name beginning with \"ECDH_\" (no E),
      the key used in\n   ECDH_anon is ephemeral just like the key in ECDHE_RSA and\n
      \  ECDHE_ECDSA.  The naming follows the example of DH_anon, where the\n   key
      is also ephemeral but the name does not reflect it.\n   In ECDH_anon, the server's
      Certificate, the CertificateRequest, the\n   client's Certificate, and the CertificateVerify
      messages MUST NOT be\n   sent.\n   The server MUST send an ephemeral ECDH public
      key and a specification\n   of the corresponding curve in the ServerKeyExchange
      message.  These\n   parameters MUST NOT be signed.\n   The client generates
      an ECDH key pair on the same curve as the\n   server's ephemeral ECDH key and
      sends its public key in the\n   ClientKeyExchange message.\n   Both client and
      server perform an ECDH operation and use the\n   resultant shared secret as
      the premaster secret.  All ECDH\n   calculations are performed as specified
      in Section 5.10.\n"
    title: 2.3.  ECDH_anon
  - contents:
    - "2.4.  Algorithms in Certificate Chains\n   This specification does not impose
      restrictions on signature schemes\n   used anywhere in the certificate chain.
      \ The previous version of this\n   document required the signatures to match,
      but this restriction,\n   originating in previous TLS versions, is lifted here
      as it had been\n   in RFC 5246.\n"
    title: 2.4.  Algorithms in Certificate Chains
  title: 2.  Key Exchange Algorithm
- contents:
  - "3.  Client Authentication\n   This document defines a client authentication mechanism
    named after\n   the type of client certificate involved: ECDSA_sign.  The ECDSA_sign\n
    \  mechanism is usable with any of the non-anonymous ECC key exchange\n   algorithms
    described in Section 2 as well as other non-anonymous\n   (non-ECC) key exchange
    algorithms defined in TLS.\n   Note that client certificates with EdDSA public
    keys also use this\n   mechanism.\n   The server can request ECC-based client
    authentication by including\n   this certificate type in its CertificateRequest
    message.  The client\n   must check if it possesses a certificate appropriate
    for the method\n   suggested by the server and is willing to use it for authentication.\n
    \  If these conditions are not met, the client SHOULD send a client\n   Certificate
    message containing no certificates.  In this case, the\n   ClientKeyExchange MUST
    be sent as described in Section 2, and the\n   CertificateVerify MUST NOT be sent.
    \ If the server requires client\n   authentication, it may respond with a fatal
    handshake failure alert.\n   If the client has an appropriate certificate and
    is willing to use it\n   for authentication, it must send that certificate in
    the client's\n   Certificate message (as per Section 5.6) and prove possession
    of the\n   private key corresponding to the certified key.  The process of\n   determining
    an appropriate certificate and proving possession is\n   different for each authentication
    mechanism and is described below.\n   NOTE: It is permissible for a server to
    request (and the client to\n   send) a client certificate of a different type
    than the server\n   certificate.\n"
  - contents:
    - "3.1.  ECDSA_sign\n   To use this authentication mechanism, the client MUST
      possess a\n   certificate containing an ECDSA- or EdDSA-capable public key.\n
      \  The client proves possession of the private key corresponding to the\n   certified
      key by including a signature in the CertificateVerify\n   message as described
      in Section 5.8.\n"
    title: 3.1.  ECDSA_sign
  title: 3.  Client Authentication
- contents:
  - "4.  TLS Extensions for ECC\n   Two TLS extensions are defined in this specification:
    (i) the\n   Supported Elliptic Curves Extension and (ii) the Supported Point\n
    \  Formats Extension.  These allow negotiating the use of specific\n   curves
    and point formats (e.g., compressed vs. uncompressed,\n   respectively) during
    a handshake starting a new session.  These\n   extensions are especially relevant
    for constrained clients that may\n   only support a limited number of curves or
    point formats.  They\n   follow the general approach outlined in [RFC4366]; message
    details\n   are specified in Section 5.  The client enumerates the curves it\n
    \  supports and the point formats it can parse by including the\n   appropriate
    extensions in its ClientHello message.  The server\n   similarly enumerates the
    point formats it can parse by including an\n   extension in its ServerHello message.\n
    \  A TLS client that proposes ECC cipher suites in its ClientHello\n   message
    SHOULD include these extensions.  Servers implementing ECC\n   cipher suites MUST
    support these extensions, and when a client uses\n   these extensions, servers
    MUST NOT negotiate the use of an ECC cipher\n   suite unless they can complete
    the handshake while respecting the\n   choice of curves specified by the client.
    \ This eliminates the\n   possibility that a negotiated ECC handshake will be
    subsequently\n   aborted due to a client's inability to deal with the server's
    EC key.\n   The client MUST NOT include these extensions in the ClientHello\n
    \  message if it does not propose any ECC cipher suites.  A client that\n   proposes
    ECC cipher suites may choose not to include these\n   extensions.  In this case,
    the server is free to choose any one of\n   the elliptic curves or point formats
    listed in Section 5.  That\n   section also describes the structure and processing
    of these\n   extensions in greater detail.\n   In the case of session resumption,
    the server simply ignores the\n   Supported Elliptic Curves Extension and the
    Supported Point Formats\n   Extension appearing in the current ClientHello message.
    \ These\n   extensions only play a role during handshakes negotiating a new\n
    \  session.\n"
  title: 4.  TLS Extensions for ECC
- contents:
  - "5.  Data Structures and Computations\n   This section specifies the data structures
    and computations used by\n   ECC-based key mechanisms specified in the previous
    three sections.\n   The presentation language used here is the same as that used
    in TLS.\n   Since this specification extends TLS, these descriptions should be\n
    \  merged with those in the TLS specification and any others that extend\n   TLS.
    \ This means that enum types may not specify all possible values,\n   and structures
    with multiple formats chosen with a select() clause\n   may not indicate all possible
    cases.\n"
  - contents:
    - "5.1.  Client Hello Extensions\n   This section specifies two TLS extensions
      that can be included with\n   the ClientHello message as described in [RFC4366]:
      the Supported\n   Elliptic Curves Extension and the Supported Point Formats
      Extension.\n   When these extensions are sent:\n   The extensions SHOULD be
      sent along with any ClientHello message that\n   proposes ECC cipher suites.\n
      \  Meaning of these extensions:\n   These extensions allow a client to enumerate
      the elliptic curves it\n   supports and/or the point formats it can parse.\n
      \  Structure of these extensions:\n   The general structure of TLS extensions
      is described in [RFC4366],\n   and this specification adds two types to ExtensionType.\n
      \     enum {\n          elliptic_curves(10),\n          ec_point_formats(11)\n
      \     } ExtensionType;\n   o  elliptic_curves (Supported Elliptic Curves Extension):
      Indicates\n      the set of elliptic curves supported by the client.  For this\n
      \     extension, the opaque extension_data field contains\n      NamedCurveList.
      \ See Section 5.1.1 for details.\n   o  ec_point_formats (Supported Point Formats
      Extension): Indicates\n      the set of point formats that the client can parse.
      \ For this\n      extension, the opaque extension_data field contains\n      ECPointFormatList.
      \ See Section 5.1.2 for details.\n   Actions of the sender:\n   A client that
      proposes ECC cipher suites in its ClientHello message\n   appends these extensions
      (along with any others), enumerating the\n   curves it supports and the point
      formats it can parse.  Clients\n   SHOULD send both the Supported Elliptic Curves
      Extension and the\n   Supported Point Formats Extension.  If the Supported Point
      Formats\n   Extension is indeed sent, it MUST contain the value 0 (uncompressed)\n
      \  as one of the items in the list of point formats.\n   Actions of the receiver:\n
      \  A server that receives a ClientHello containing one or both of these\n   extensions
      MUST use the client's enumerated capabilities to guide its\n   selection of
      an appropriate cipher suite.  One of the proposed ECC\n   cipher suites must
      be negotiated only if the server can successfully\n   complete the handshake
      while using the curves and point formats\n   supported by the client (cf. Sections
      5.3 and 5.4).\n   NOTE: A server participating in an ECDHE_ECDSA key exchange
      may use\n   different curves for the ECDSA or EdDSA key in its certificate and\n
      \  for the ephemeral ECDH key in the ServerKeyExchange message.  The\n   server
      MUST consider the extensions in both cases.\n   If a server does not understand
      the Supported Elliptic Curves\n   Extension, does not understand the Supported
      Point Formats Extension,\n   or is unable to complete the ECC handshake while
      restricting itself\n   to the enumerated curves and point formats, it MUST NOT
      negotiate the\n   use of an ECC cipher suite.  Depending on what other cipher
      suites\n   are proposed by the client and supported by the server, this may\n
      \  result in a fatal handshake failure alert due to the lack of common\n   cipher
      suites.\n"
    - contents:
      - "5.1.1.  Supported Elliptic Curves Extension\n   RFC 4492 defined 25 different
        curves in the NamedCurve registry (now\n   renamed the \"TLS Supported Groups\"
        registry, although the enumeration\n   below is still named NamedCurve) for
        use in TLS.  Only three have\n   seen much use.  This specification is deprecating
        the rest (with\n   numbers 1-22).  This specification also deprecates the
        explicit\n   curves with identifiers 0xFF01 and 0xFF02.  It also adds the
        new\n   curves defined in [RFC7748].  The end result is as follows:\n           enum
        {\n               deprecated(1..22),\n               secp256r1 (23), secp384r1
        (24), secp521r1 (25),\n               x25519(29), x448(30),\n               reserved
        (0xFE00..0xFEFF),\n               deprecated(0xFF01..0xFF02),\n               (0xFFFF)\n
        \          } NamedCurve;\n   Note that other specifications have since added
        other values to this\n   enumeration.  Some of those values are not curves
        at all, but finite\n   field groups.  See [RFC7919].\n   secp256r1, etc: Indicates
        support of the corresponding named curve or\n   groups.  The named curves
        secp256r1, secp384r1, and secp521r1 are\n   specified in SEC 2 [SECG-SEC2].
        \ These curves are also recommended in\n   ANSI X9.62 [ANSI.X9-62.2005] and
        FIPS 186-4 [FIPS.186-4].  The rest\n   of this document refers to these three
        curves as the \"NIST curves\"\n   because they were originally standardized
        by the National Institute\n   of Standards and Technology.  The curves x25519
        and x448 are defined\n   in [RFC7748].  Values 0xFE00 through 0xFEFF are reserved
        for private\n   use.\n   The predecessor of this document also supported explicitly
        defined\n   prime and char2 curves, but these are deprecated by this\n   specification.\n
        \  The NamedCurve name space (now titled \"TLS Supported Groups\") is\n   maintained
        by IANA.  See Section 9 for information on how new value\n   assignments are
        added.\n           struct {\n               NamedCurve named_curve_list<2..2^16-1>\n
        \          } NamedCurveList;\n   Items in named_curve_list are ordered according
        to the client's\n   preferences (favorite choice first).\n   As an example,
        a client that only supports secp256r1 (aka NIST P-256;\n   value 23 = 0x0017)
        and secp384r1 (aka NIST P-384; value 24 = 0x0018)\n   and prefers to use secp256r1
        would include a TLS extension consisting\n   of the following octets.  Note
        that the first two octets indicate the\n   extension type (Supported Elliptic
        Curves Extension):\n           00 0A 00 06 00 04 00 17 00 18\n"
      title: 5.1.1.  Supported Elliptic Curves Extension
    - contents:
      - "5.1.2.  Supported Point Formats Extension\n           enum {\n               uncompressed
        (0),\n               deprecated (1..2),\n               reserved (248..255)\n
        \          } ECPointFormat;\n           struct {\n               ECPointFormat
        ec_point_format_list<1..2^8-1>\n           } ECPointFormatList;\n   Three
        point formats were included in the definition of ECPointFormat\n   above.
        \ This specification deprecates all but the uncompressed point\n   format.
        \ Implementations of this document MUST support the\n   uncompressed format
        for all of their supported curves and MUST NOT\n   support other formats for
        curves defined in this specification.  For\n   backwards compatibility purposes,
        the point format list extension MAY\n   still be included and contain exactly
        one value: the uncompressed\n   point format (0).  RFC 4492 specified that
        if this extension is\n   missing, it means that only the uncompressed point
        format is\n   supported, so interoperability with implementations that support
        the\n   uncompressed format should work with or without the extension.\n   If
        the client sends the extension and the extension does not contain\n   the
        uncompressed point format, and the client has used the Supported\n   Groups
        extension to indicate support for any of the curves defined in\n   this specification,
        then the server MUST abort the handshake and\n   return an illegal_parameter
        alert.\n   The ECPointFormat name space (now titled \"TLS EC Point Formats\")
        is\n   maintained by IANA.  See Section 9 for information on how new value\n
        \  assignments are added.\n   A client compliant with this specification that
        supports no other\n   curves MUST send the following octets; note that the
        first two octets\n   indicate the extension type (Supported Point Formats
        Extension):\n           00 0B 00 02 01 00\n"
      title: 5.1.2.  Supported Point Formats Extension
    - contents:
      - "5.1.3.  The signature_algorithms Extension and EdDSA\n   The signature_algorithms
        extension, defined in Section 7.4.1.4.1 of\n   [RFC5246], advertises the combinations
        of signature algorithm and\n   hash function that the client supports.  The
        pure (non-prehashed)\n   forms of EdDSA do not hash the data before signing
        it.  For this\n   reason, it does not make sense to combine them with a hash
        function\n   in the extension.\n   For bits-on-the-wire compatibility with
        TLS 1.3, we define a new\n   dummy value in the \"TLS HashAlgorithm\" registry
        that we call\n   \"Intrinsic\" (value 8), meaning that hashing is intrinsic
        to the\n   signature algorithm.\n   To represent ed25519 and ed448 in the
        signature_algorithms extension,\n   the value shall be (8,7) and (8,8), respectively.\n"
      title: 5.1.3.  The signature_algorithms Extension and EdDSA
    title: 5.1.  Client Hello Extensions
  - contents:
    - "5.2.  Server Hello Extension\n   This section specifies a TLS extension that
      can be included with the\n   ServerHello message as described in [RFC4366],
      the Supported Point\n   Formats Extension.\n   When this extension is sent:\n
      \  The Supported Point Formats Extension is included in a ServerHello\n   message
      in response to a ClientHello message containing the Supported\n   Point Formats
      Extension when negotiating an ECC cipher suite.\n   Meaning of this extension:\n
      \  This extension allows a server to enumerate the point formats it can\n   parse
      (for the curve that will appear in its ServerKeyExchange\n   message when using
      the ECDHE_ECDSA, ECDHE_RSA, or ECDH_anon key\n   exchange algorithm.\n   Structure
      of this extension:\n   The server's Supported Point Formats Extension has the
      same structure\n   as the client's Supported Point Formats Extension (see\n
      \  Section 5.1.2).  Items in ec_point_format_list here are ordered\n   according
      to the server's preference (favorite choice first).  Note\n   that the server
      MAY include items that were not found in the client's\n   list.  However, without
      extensions, this specification allows exactly\n   one point format, so there
      is not really any opportunity for\n   mismatches.\n   Actions of the sender:\n
      \  A server that selects an ECC cipher suite in response to a\n   ClientHello
      message including a Supported Point Formats Extension\n   appends this extension
      (along with others) to its ServerHello\n   message, enumerating the point formats
      it can parse.  The Supported\n   Point Formats Extension, when used, MUST contain
      the value 0\n   (uncompressed) as one of the items in the list of point formats.\n
      \  Actions of the receiver:\n   A client that receives a ServerHello message
      containing a Supported\n   Point Formats Extension MUST respect the server's
      choice of point\n   formats during the handshake (cf.  Sections 5.6 and 5.7).
      \ If no\n   Supported Point Formats Extension is received with the ServerHello,\n
      \  this is equivalent to an extension allowing only the uncompressed\n   point
      format.\n"
    title: 5.2.  Server Hello Extension
  - contents:
    - "5.3.  Server Certificate\n   When this message is sent:\n   This message is
      sent in all non-anonymous, ECC-based key exchange\n   algorithms.\n   Meaning
      of this message:\n   This message is used to authentically convey the server's
      static\n   public key to the client.  The following table shows the server\n
      \  certificate type appropriate for each key exchange algorithm.  ECC\n   public
      keys MUST be encoded in certificates as described in\n   Section 5.9.\n   NOTE:
      The server's Certificate message is capable of carrying a chain\n   of certificates.
      \ The restrictions mentioned in Table 2 apply only to\n   the server's certificate
      (first in the chain).\n   +-------------+-----------------------------------------------------+\n
      \  | Algorithm   | Server Certificate Type                             |\n   +-------------+-----------------------------------------------------+\n
      \  | ECDHE_ECDSA | Certificate MUST contain an ECDSA- or EdDSA-capable |\n   |
      \            | public key.                                         |\n   | ECDHE_RSA
      \  | Certificate MUST contain an RSA public key.         |\n   +-------------+-----------------------------------------------------+\n
      \                    Table 2: Server Certificate Types\n   Structure of this
      message:\n   Identical to the TLS Certificate format.\n   Actions of the sender:\n
      \  The server constructs an appropriate certificate chain and conveys it\n   to
      the client in the Certificate message.  If the client has used a\n   Supported
      Elliptic Curves Extension, the public key in the server's\n   certificate MUST
      respect the client's choice of elliptic curves.  A\n   server that cannot satisfy
      this requirement MUST NOT choose an ECC\n   cipher suite in its ServerHello
      message.)\n   Actions of the receiver:\n   The client validates the certificate
      chain, extracts the server's\n   public key, and checks that the key type is
      appropriate for the\n   negotiated key exchange algorithm.  (A possible reason
      for a fatal\n   handshake failure is that the client's capabilities for handling\n
      \  elliptic curves and point formats are exceeded; cf. Section 5.1.)\n"
    title: 5.3.  Server Certificate
  - contents:
    - "5.4.  Server Key Exchange\n   When this message is sent:\n   This message is
      sent when using the ECDHE_ECDSA, ECDHE_RSA, and\n   ECDH_anon key exchange algorithms.\n
      \  Meaning of this message:\n   This message is used to convey the server's
      ephemeral ECDH public key\n   (and the corresponding elliptic curve domain parameters)
      to the\n   client.\n   The ECCurveType enum used to have values for explicit
      prime and for\n   explicit char2 curves.  Those values are now deprecated, so
      only one\n   value remains:\n   Structure of this message:\n           enum
      {\n               deprecated (1..2),\n               named_curve (3),\n               reserved(248..255)\n
      \          } ECCurveType;\n   The value named_curve indicates that a named curve
      is used.  This\n   option is now the only remaining format.\n   Values 248 through
      255 are reserved for private use.\n   The ECCurveType name space (now titled
      \"TLS EC Curve Types\") is\n   maintained by IANA.  See Section 9 for information
      on how new value\n   assignments are added.\n   RFC 4492 had a specification
      for an ECCurve structure and an\n   ECBasisType structure.  Both of these are
      omitted now because they\n   were only used with the now deprecated explicit
      curves.\n           struct {\n               opaque point <1..2^8-1>;\n           }
      ECPoint;\n   point: This is the byte string representation of an elliptic curve\n
      \  point following the conversion routine in Section 4.3.6 of\n   [ANSI.X9-62.2005].
      \ This byte string may represent an elliptic curve\n   point in uncompressed,
      compressed, or hybrid format, but this\n   specification deprecates all but
      the uncompressed format.  For the\n   NIST curves, the format is repeated in
      Section 5.4.1 for convenience.\n   For the X25519 and X448 curves, the only
      valid representation is the\n   one specified in [RFC7748], a 32- or 56-octet
      representation of the u\n   value of the point.  This structure MUST NOT be
      used with Ed25519 and\n   Ed448 public keys.\n           struct {\n               ECCurveType
      \   curve_type;\n               select (curve_type) {\n                   case
      named_curve:\n                       NamedCurve namedcurve;\n               };\n
      \          } ECParameters;\n   curve_type: This identifies the type of the elliptic
      curve domain\n   parameters.\n   namedCurve: Specifies a recommended set of
      elliptic curve domain\n   parameters.  All those values of NamedCurve are allowed
      that refer to\n   a curve capable of Diffie-Hellman.  With the deprecation of
      the\n   explicit curves, this now includes all of the NamedCurve values.\n           struct
      {\n               ECParameters    curve_params;\n               ECPoint         public;\n
      \          } ServerECDHParams;\n   curve_params: Specifies the elliptic curve
      domain parameters\n   associated with the ECDH public key.\n   public: The ephemeral
      ECDH public key.\n   The ServerKeyExchange message is extended as follows.\n
      \          enum {\n               ec_diffie_hellman\n           } KeyExchangeAlgorithm;\n
      \  o  ec_diffie_hellman: Indicates the ServerKeyExchange message\n      contains
      an ECDH public key.\n      select (KeyExchangeAlgorithm) {\n          case ec_diffie_hellman:\n
      \             ServerECDHParams    params;\n              Signature           signed_params;\n
      \     } ServerKeyExchange;\n   o  params: Specifies the ECDH public key and
      associated domain\n      parameters.\n   o  signed_params: A hash of the params,
      with the signature\n      appropriate to that hash applied.  The private key
      corresponding\n      to the certified public key in the server's Certificate
      message is\n      used for signing.\n        enum {\n            ecdsa(3),\n
      \           ed25519(7)\n            ed448(8)\n        } SignatureAlgorithm;\n
      \       select (SignatureAlgorithm) {\n           case ecdsa:\n                digitally-signed
      struct {\n                    opaque sha_hash[sha_size];\n                };\n
      \          case ed25519,ed448:\n                digitally-signed struct {\n
      \                   opaque rawdata[rawdata_size];\n                };\n        }
      Signature;\n      ServerKeyExchange.signed_params.sha_hash\n          SHA(ClientHello.random
      + ServerHello.random +\n                                 ServerKeyExchange.params);\n
      \     ServerKeyExchange.signed_params.rawdata\n          ClientHello.random
      + ServerHello.random +\n                                 ServerKeyExchange.params;\n
      \  NOTE: SignatureAlgorithm is \"rsa\" for the ECDHE_RSA key exchange\n   algorithm
      and \"anonymous\" for ECDH_anon.  These cases are defined in\n   TLS.  SignatureAlgorithm
      is \"ecdsa\" or \"eddsa\" for ECDHE_ECDSA.\n   ECDSA signatures are generated
      and verified as described in\n   Section 5.10.  SHA, in the above template for
      sha_hash, may denote a\n   hash algorithm other than SHA-1.  As per ANSI X9.62,
      an ECDSA\n   signature consists of a pair of integers, r and s.  The digitally-\n
      \  signed element is encoded as an opaque vector <0..2^16-1>, the\n   contents
      of which are the DER encoding corresponding to the following\n   ASN.1 notation.\n
      \             Ecdsa-Sig-Value ::= SEQUENCE {\n                  r       INTEGER,\n
      \                 s       INTEGER\n              }\n   EdDSA signatures in both
      the protocol and in certificates that\n   conform to [RFC8410] are generated
      and verified according to\n   [RFC8032].  The digitally-signed element is encoded
      as an opaque\n   vector <0..2^16-1>, the contents of which include the octet
      string\n   output of the EdDSA signing algorithm.\n   Actions of the sender:\n
      \  The server selects elliptic curve domain parameters and an ephemeral\n   ECDH
      public key corresponding to these parameters according to the\n   ECKAS-DH1
      scheme from IEEE 1363 [IEEE.P1363].  It conveys this\n   information to the
      client in the ServerKeyExchange message using the\n   format defined above.\n
      \  Actions of the receiver:\n   The client verifies the signature (when present)
      and retrieves the\n   server's elliptic curve domain parameters and ephemeral
      ECDH public\n   key from the ServerKeyExchange message.  (A possible reason
      for a\n   fatal handshake failure is that the client's capabilities for\n   handling
      elliptic curves and point formats are exceeded; cf.\n   Section 5.1.)\n"
    - contents:
      - "5.4.1.  Uncompressed Point Format for NIST Curves\n   The following represents
        the wire format for representing ECPoint in\n   ServerKeyExchange records.
        \ The first octet of the representation\n   indicates the form, which may
        be compressed, uncompressed, or hybrid.\n   This specification supports only
        the uncompressed format for these\n   curves.  This is followed by the binary
        representation of the X value\n   in \"big-endian\" or \"network\" format,
        followed by the binary\n   representation of the Y value in \"big-endian\"
        or \"network\" format.\n   There are no internal length markers, so each number
        representation\n   occupies as many octets as implied by the curve parameters.
        \ For\n   P-256 this means that each of X and Y use 32 octets, padded on the\n
        \  left by zeros if necessary.  For P-384, they take 48 octets each, and\n
        \  for P-521, they take 66 octets each.\n   Here's a more formal representation:\n
        \            enum {\n                 uncompressed(4),\n                 (255)\n
        \              } PointConversionForm;\n             struct {\n                 PointConversionForm
        \ form;\n                 opaque               X[coordinate_length];\n                 opaque
        \              Y[coordinate_length];\n             } UncompressedPointRepresentation;\n"
      title: 5.4.1.  Uncompressed Point Format for NIST Curves
    title: 5.4.  Server Key Exchange
  - contents:
    - "5.5.  Certificate Request\n   When this message is sent:\n   This message is
      sent when requesting client authentication.\n   Meaning of this message:\n   The
      server uses this message to suggest acceptable client\n   authentication methods.\n
      \  Structure of this message:\n   The TLS CertificateRequest message is extended
      as follows.\n           enum {\n               ecdsa_sign(64),\n               deprecated1(65),
      \ /* was rsa_fixed_ecdh */\n               deprecated2(66),  /* was ecdsa_fixed_ecdh
      */\n               (255)\n           } ClientCertificateType;\n   o  ecdsa_sign:
      Indicates that the server would like to use the\n      corresponding client
      authentication method specified in Section 3.\n   Note that RFC 4492 also defined
      RSA and ECDSA certificates that\n   included a fixed ECDH public key.  These
      mechanisms saw very little\n   implementation, so this specification is deprecating
      them.\n   Actions of the sender:\n   The server decides which client authentication
      methods it would like\n   to use and conveys this information to the client
      using the format\n   defined above.\n   Actions of the receiver:\n   The client
      determines whether it has a suitable certificate for use\n   with any of the
      requested methods and whether to proceed with client\n   authentication.\n"
    title: 5.5.  Certificate Request
  - contents:
    - "5.6.  Client Certificate\n   When this message is sent:\n   This message is
      sent in response to a CertificateRequest when a\n   client has a suitable certificate
      and has decided to proceed with\n   client authentication.  (Note that if the
      server has used a Supported\n   Point Formats Extension, a certificate can only
      be considered\n   suitable for use with the ECDSA_sign authentication method
      if the\n   public key point specified in it is uncompressed, as that is the
      only\n   point format still supported.\n   Meaning of this message:\n   This
      message is used to authentically convey the client's static\n   public key to
      the server.  ECC public keys must be encoded in\n   certificates as described
      in Section 5.9.  The certificate MUST\n   contain an ECDSA- or EdDSA-capable
      public key.\n   NOTE: The client's Certificate message is capable of carrying
      a chain\n   of certificates.  The restrictions mentioned above apply only to
      the\n   client's certificate (first in the chain).\n   Structure of this message:\n
      \  Identical to the TLS client Certificate format.\n   Actions of the sender:\n
      \  The client constructs an appropriate certificate chain and conveys it\n   to
      the server in the Certificate message.\n   Actions of the receiver:\n   The
      TLS server validates the certificate chain, extracts the client's\n   public
      key, and checks that the key type is appropriate for the\n   client authentication
      method.\n"
    title: 5.6.  Client Certificate
  - contents:
    - "5.7.  Client Key Exchange\n   When this message is sent:\n   This message is
      sent in all key exchange algorithms.  It contains the\n   client's ephemeral
      ECDH public key.\n   Meaning of the message:\n   This message is used to convey
      ephemeral data relating to the key\n   exchange belonging to the client (such
      as its ephemeral ECDH public\n   key).\n   Structure of this message:\n   The
      TLS ClientKeyExchange message is extended as follows.\n           enum {\n               implicit,\n
      \              explicit\n           } PublicValueEncoding;\n   o  implicit,
      explicit: For ECC cipher suites, this indicates whether\n      the client's
      ECDH public key is in the client's certificate\n      (\"implicit\") or is provided,
      as an ephemeral ECDH public key, in\n      the ClientKeyExchange message (\"explicit\").
      \ The implicit encoding\n      is deprecated and is retained here for backward
      compatibility\n      only.\n           struct {\n               ECPoint ecdh_Yc;\n
      \          } ClientECDiffieHellmanPublic;\n   ecdh_Yc: Contains the client's
      ephemeral ECDH public key as a byte\n   string ECPoint.point, which may represent
      an elliptic curve point in\n   uncompressed format.\n           struct {\n               select
      (KeyExchangeAlgorithm) {\n                   case ec_diffie_hellman: ClientECDiffieHellmanPublic;\n
      \              } exchange_keys;\n           } ClientKeyExchange;\n   Actions
      of the sender:\n   The client selects an ephemeral ECDH public key corresponding
      to the\n   parameters it received from the server.  The format is the same as
      in\n   Section 5.4.\n   Actions of the receiver:\n   The server retrieves the
      client's ephemeral ECDH public key from the\n   ClientKeyExchange message and
      checks that it is on the same elliptic\n   curve as the server's ECDH key.\n"
    title: 5.7.  Client Key Exchange
  - contents:
    - "5.8.  Certificate Verify\n   When this message is sent:\n   This message is
      sent when the client sends a client certificate\n   containing a public key
      usable for digital signatures.\n   Meaning of the message:\n   This message
      contains a signature that proves possession of the\n   private key corresponding
      to the public key in the client's\n   Certificate message.\n   Structure of
      this message:\n   The TLS CertificateVerify message and the underlying signature
      type\n   are defined in the TLS base specifications, and the latter is\n   extended
      here in Section 5.4.  For the \"ecdsa\" and \"eddsa\" cases, the\n   signature
      field in the CertificateVerify message contains an ECDSA or\n   EdDSA (respectively)
      signature computed over handshake messages\n   exchanged so far, exactly similar
      to CertificateVerify with other\n   signing algorithms:\n           CertificateVerify.signature.sha_hash\n
      \              SHA(handshake_messages);\n           CertificateVerify.signature.rawdata\n
      \              handshake_messages;\n   ECDSA signatures are computed as described
      in Section 5.10, and SHA\n   in the above template for sha_hash accordingly
      may denote a hash\n   algorithm other than SHA-1.  As per ANSI X9.62, an ECDSA
      signature\n   consists of a pair of integers, r and s.  The digitally-signed\n
      \  element is encoded as an opaque vector <0..2^16-1>, the contents of\n   which
      are the DER encoding [X.690] corresponding to the following\n   ASN.1 notation
      [X.680].\n           Ecdsa-Sig-Value ::= SEQUENCE {\n               r       INTEGER,\n
      \              s       INTEGER\n           }\n   EdDSA signatures are generated
      and verified according to [RFC8032].\n   The digitally-signed element is encoded
      as an opaque vector\n   <0..2^16-1>, the contents of which include the octet
      string output of\n   the EdDSA signing algorithm.\n   Actions of the sender:\n
      \  The client computes its signature over all handshake messages sent or\n   received
      starting at client hello and up to but not including this\n   message.  It uses
      the private key corresponding to its certified\n   public key to compute the
      signature, which is conveyed in the format\n   defined above.\n   Actions of
      the receiver:\n   The server extracts the client's signature from the CertificateVerify\n
      \  message and verifies the signature using the public key it received\n   in
      the client's Certificate message.\n"
    title: 5.8.  Certificate Verify
  - contents:
    - "5.9.  Elliptic Curve Certificates\n   X.509 certificates containing ECC public
      keys or signed using ECDSA\n   MUST comply with [RFC3279] or another RFC that
      replaces or extends\n   it.  X.509 certificates containing ECC public keys or
      signed using\n   EdDSA MUST comply with [RFC8410].  Clients SHOULD use the elliptic\n
      \  curve domain parameters recommended in ANSI X9.62, FIPS 186-4, and\n   SEC
      2 [SECG-SEC2], or in [RFC8032].\n   EdDSA keys using the Ed25519 algorithm MUST
      use the ed25519 signature\n   algorithm, and Ed448 keys MUST use the ed448 signature
      algorithm.\n   This document does not define use of Ed25519ph and Ed448ph keys
      with\n   TLS.  Ed25519, Ed25519ph, Ed448, and Ed448ph keys MUST NOT be used\n
      \  with ECDSA.\n"
    title: 5.9.  Elliptic Curve Certificates
  - contents:
    - "5.10.  ECDH, ECDSA, and RSA Computations\n   All ECDH calculations for the
      NIST curves (including parameter and\n   key generation as well as the shared
      secret calculation) are\n   performed according to [IEEE.P1363] using the ECKAS-DH1
      scheme with\n   the identity map as the Key Derivation Function (KDF) so that
      the\n   premaster secret is the x-coordinate of the ECDH shared secret\n   elliptic
      curve point represented as an octet string.  Note that this\n   octet string
      (Z in IEEE 1363 terminology), as output by FE2OSP (Field\n   Element to Octet
      String Conversion Primitive), has constant length\n   for any given field; leading
      zeros found in this octet string MUST\n   NOT be truncated.\n   (Note that this
      use of the identity KDF is a technicality.  The\n   complete picture is that
      ECDH is employed with a non-trivial KDF\n   because TLS does not directly use
      the premaster secret for anything\n   other than for computing the master secret.
      \ In TLS 1.0 and 1.1, this\n   means that the MD5- and SHA-1-based TLS Pseudorandom
      Function (PRF)\n   serves as a KDF; in TLS 1.2, the KDF is determined by ciphersuite,\n
      \  and it is conceivable that future TLS versions or new TLS extensions\n   introduced
      in the future may vary this computation.)\n   An ECDHE key exchange using X25519
      (curve x25519) goes as follows:\n   (1) each party picks a secret key d uniformly
      at random and computes\n   the corresponding public key x = X25519(d, G); (2)
      parties exchange\n   their public keys and compute a shared secret as x_S =
      X25519(d,\n   x_peer); and (3), if either party obtains all-zeroes x_S, it MUST\n
      \  abort the handshake (as required by definition of X25519 and X448).\n   ECDHE
      for X448 works similarly, replacing X25519 with X448 and x25519\n   with x448.
      \ The derived shared secret is used directly as the\n   premaster secret, which
      is always exactly 32 bytes when ECDHE with\n   X25519 is used and 56 bytes when
      ECDHE with X448 is used.\n   All ECDSA computations MUST be performed according
      to ANSI X9.62 or\n   its successors.  Data to be signed/verified is hashed,
      and the result\n   runs directly through the ECDSA algorithm with no additional
      hashing.\n   A secure hash function such as SHA-256, SHA-384, or SHA-512 from\n
      \  [FIPS.180-4] MUST be used.\n   All EdDSA computations MUST be performed according
      to [RFC8032] or\n   its successors.  Data to be signed/verified is run through
      the EdDSA\n   algorithm with no hashing (EdDSA will internally run the data
      through\n   the \"prehash\" function PH).  The context parameter for Ed448 MUST
      be\n   set to the empty string.\n   RFC 4492 anticipated the standardization
      of a mechanism for\n   specifying the required hash function in the certificate,
      perhaps in\n   the parameters field of the subjectPublicKeyInfo.  Such\n   standardization
      never took place, and as a result, SHA-1 is used in\n   TLS 1.1 and earlier
      (except for EdDSA, which uses identity function).\n   TLS 1.2 added a SignatureAndHashAlgorithm
      parameter to the\n   DigitallySigned struct, thus allowing agility in choosing
      the\n   signature hash.  EdDSA signatures MUST have HashAlgorithm of 8\n   (Intrinsic).\n
      \  All RSA signatures must be generated and verified according to\n   Section
      7.2 of [RFC8017].\n"
    title: 5.10.  ECDH, ECDSA, and RSA Computations
  - contents:
    - "5.11.  Public Key Validation\n   With the NIST curves, each party MUST validate
      the public key sent by\n   its peer in the ClientKeyExchange and ServerKeyExchange
      messages.  A\n   receiving party MUST check that the x and y parameters from
      the\n   peer's public value satisfy the curve equation, y^2 = x^3 + ax + b\n
      \  mod p.  See Section 2.3 of [Menezes] for details.  Failing to do so\n   allows
      attackers to gain information about the private key to the\n   point that they
      may recover the entire private key in a few requests\n   if that key is not
      really ephemeral.\n   With X25519 and X448, a receiving party MUST check whether
      the\n   computed premaster secret is the all-zero value and abort the\n   handshake
      if so, as described in Section 6 of [RFC7748].\n   Ed25519 and Ed448 internally
      do public key validation as part of\n   signature verification.\n"
    title: 5.11.  Public Key Validation
  title: 5.  Data Structures and Computations
- contents:
  - "6.  Cipher Suites\n   The table below defines ECC cipher suites that use the
    key exchange\n   algorithms specified in Section 2.\n       +-----------------------------------------+----------------+\n
    \      | CipherSuite                             | Identifier     |\n       +-----------------------------------------+----------------+\n
    \      | TLS_ECDHE_ECDSA_WITH_NULL_SHA           | { 0xC0, 0x06 } |\n       |
    TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA   | { 0xC0, 0x08 } |\n       | TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
    \   | { 0xC0, 0x09 } |\n       | TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    | { 0xC0,
    0x0A } |\n       | TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 | { 0xC0, 0x2B } |\n
    \      | TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 | { 0xC0, 0x2C } |\n       |
    \                                        |                |\n       | TLS_ECDHE_RSA_WITH_NULL_SHA
    \            | { 0xC0, 0x10 } |\n       | TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
    \    | { 0xC0, 0x12 } |\n       | TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      | {
    0xC0, 0x13 } |\n       | TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      | { 0xC0, 0x14
    } |\n       | TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   | { 0xC0, 0x2F } |\n       |
    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   | { 0xC0, 0x30 } |\n       |                                         |
    \               |\n       | TLS_ECDH_anon_WITH_NULL_SHA             | { 0xC0,
    0x15 } |\n       | TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA     | { 0xC0, 0x17 } |\n
    \      | TLS_ECDH_anon_WITH_AES_128_CBC_SHA      | { 0xC0, 0x18 } |\n       |
    TLS_ECDH_anon_WITH_AES_256_CBC_SHA      | { 0xC0, 0x19 } |\n       +-----------------------------------------+----------------+\n
    \                     Table 3: TLS ECC Cipher Suites\n   The key exchange method,
    cipher, and hash algorithm for each of these\n   cipher suites are easily determined
    by examining the name.  Ciphers\n   (other than AES ciphers) and hash algorithms
    are defined in [RFC2246]\n   and [RFC4346].  AES ciphers are defined in [RFC5246],
    and AES-GCM\n   ciphersuites are in [RFC5289].\n   Server implementations SHOULD
    support all of the following cipher\n   suites, and client implementations SHOULD
    support at least one of\n   them:\n   o  TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n
    \  o  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\n   o  TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\n
    \  o  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\n"
  title: 6.  Cipher Suites
- contents:
  - "7.  Implementation Status\n   Both ECDHE and ECDSA with the NIST curves are widely
    implemented and\n   supported in all major browsers and all widely used TLS libraries.\n
    \  ECDHE with Curve25519 is by now implemented in several browsers and\n   several
    TLS libraries including OpenSSL.  Curve448 and EdDSA have\n   working interoperable
    implementations, but they are not yet as widely\n   deployed.\n"
  title: 7.  Implementation Status
- contents:
  - "8.  Security Considerations\n   Security issues are discussed throughout this
    memo.\n   For TLS handshakes using ECC cipher suites, the security\n   considerations
    in Appendix D of each of the three TLS base documents\n   apply accordingly.\n
    \  Security discussions specific to ECC can be found in [IEEE.P1363] and\n   [ANSI.X9-62.2005].
    \ One important issue that implementers and users\n   must consider is elliptic
    curve selection.  Guidance on selecting an\n   appropriate elliptic curve size
    is given in Table 1.  Security\n   considerations specific to X25519 and X448
    are discussed in Section 7\n   of [RFC7748].\n   Beyond elliptic curve size, the
    main issue is elliptic curve\n   structure.  As a general principle, it is more
    conservative to use\n   elliptic curves with as little algebraic structure as
    possible.\n   Thus, random curves are more conservative than special curves such
    as\n   Koblitz curves, and curves over F_p with p random are more\n   conservative
    than curves over F_p with p of a special form, and\n   curves over F_p with p
    random are considered more conservative than\n   curves over F_2^m as there is
    no choice between multiple fields of\n   similar size for characteristic 2.\n
    \  Another issue is the potential for catastrophic failures when a\n   single
    elliptic curve is widely used.  In this case, an attack on the\n   elliptic curve
    might result in the compromise of a large number of\n   keys.  Again, this concern
    may need to be balanced against efficiency\n   and interoperability improvements
    associated with widely used curves.\n   Substantial additional information on
    elliptic curve choice can be\n   found in [IEEE.P1363], [ANSI.X9-62.2005], and
    [FIPS.186-4].\n   The Introduction of [RFC8032] lists the security, performance,
    and\n   operational advantages of EdDSA signatures over ECDSA signatures\n   using
    the NIST curves.\n   All of the key exchange algorithms defined in this document
    provide\n   forward secrecy.  Some of the deprecated key exchange algorithms do\n
    \  not.\n"
  title: 8.  Security Considerations
- contents:
  - "9.  IANA Considerations\n   [RFC4492], the predecessor of this document, defined
    the IANA\n   registries for the following:\n   o  Supported Groups (Section 5.1)\n
    \  o  EC Point Format (Section 5.1)\n   o  EC Curve Type (Section 5.4)\n   IANA
    has prepended \"TLS\" to the names of these three registries.\n   For each name
    space, this document defines the initial value\n   assignments and defines a range
    of 256 values (NamedCurve) or eight\n   values (ECPointFormat and ECCurveType)
    reserved for Private Use.  The\n   policy for any additional assignments is \"Specification
    Required\".\n   (RFC 4492 required IETF review.)\n   All existing entries in the
    \"ExtensionType Values\", \"TLS\n   ClientCertificateType Identifiers\", \"TLS
    Cipher Suites\", \"TLS\n   Supported Groups\", \"TLS EC Point Format\", and \"TLS
    EC Curve Type\"\n   registries that referred to RFC 4492 have been updated to
    refer to\n   this document.\n   IANA has assigned the value 29 to x25519 and the
    value 30 to x448 in\n   the \"TLS Supported Groups\" registry.\n   IANA has assigned
    two values in the \"TLS SignatureAlgorithm\" registry\n   for ed25519 (7) and
    ed448 (8) with this document as reference.  This\n   keeps compatibility with
    TLS 1.3.\n   IANA has assigned one value from the \"TLS HashAlgorithm\" registry
    for\n   Intrinsic (8) with DTLS-OK set to true (Y) and this document as\n   reference.
    \ This keeps compatibility with TLS 1.3.\n"
  title: 9.  IANA Considerations
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [ANSI.X9-62.2005]\n              American National
      Standards Institute, \"Public Key\n              Cryptography for the Financial
      Services Industry: The\n              Elliptic Curve Digital Signature Algorithm
      (ECDSA)\",\n              ANSI X9.62, November 2005.\n   [FIPS.186-4]\n              National
      Institute of Standards and Technology, \"Digital\n              Signature Standard
      (DSS)\", FIPS PUB 186-4,\n              DOI 10.6028/NIST.FIPS.186-4, July 2013,\n
      \             <http://nvlpubs.nist.gov/nistpubs/FIPS/\n              NIST.FIPS.186-4.pdf>.\n
      \  [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n
      \             <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC2246]  Dierks,
      T. and C. Allen, \"The TLS Protocol Version 1.0\",\n              RFC 2246,
      DOI 10.17487/RFC2246, January 1999,\n              <https://www.rfc-editor.org/info/rfc2246>.\n
      \  [RFC3279]  Bassham, L., Polk, W., and R. Housley, \"Algorithms and\n              Identifiers
      for the Internet X.509 Public Key\n              Infrastructure Certificate
      and Certificate Revocation List\n              (CRL) Profile\", RFC 3279, DOI
      10.17487/RFC3279, April\n              2002, <https://www.rfc-editor.org/info/rfc3279>.\n
      \  [RFC4346]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.1\", RFC 4346,\n              DOI 10.17487/RFC4346, April
      2006,\n              <https://www.rfc-editor.org/info/rfc4346>.\n   [RFC4366]
      \ Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,\n              and
      T. Wright, \"Transport Layer Security (TLS)\n              Extensions\", RFC
      4366, DOI 10.17487/RFC4366, April 2006,\n              <https://www.rfc-editor.org/info/rfc4366>.\n
      \  [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August
      2008,\n              <https://www.rfc-editor.org/info/rfc5246>.\n   [RFC5289]
      \ Rescorla, E., \"TLS Elliptic Curve Cipher Suites with SHA-\n              256/384
      and AES Galois Counter Mode (GCM)\", RFC 5289,\n              DOI 10.17487/RFC5289,
      August 2008,\n              <https://www.rfc-editor.org/info/rfc5289>.\n   [RFC7748]
      \ Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves\n              for
      Security\", RFC 7748, DOI 10.17487/RFC7748, January\n              2016, <https://www.rfc-editor.org/info/rfc7748>.\n
      \  [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,\n              \"PKCS
      #1: RSA Cryptography Specifications Version 2.2\",\n              RFC 8017,
      DOI 10.17487/RFC8017, November 2016,\n              <https://www.rfc-editor.org/info/rfc8017>.\n
      \  [RFC8032]  Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital\n              Signature
      Algorithm (EdDSA)\", RFC 8032,\n              DOI 10.17487/RFC8032, January
      2017,\n              <https://www.rfc-editor.org/info/rfc8032>.\n   [RFC8174]
      \ Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8410]  Josefsson, S. and
      J. Schaad, \"Algorithm Identifiers for\n              Ed25519, Ed448, X25519
      and X448 for Use in the Internet\n              X.509 Public Key Infrastructure\",
      RFC 8410,\n              DOI 10.17487/RFC8410, August 2018,\n              <https://www.rfc-editor.org/info/rfc8410>.\n
      \  [SECG-SEC2]\n              Certicom Research, \"SEC 2: Recommended Elliptic
      Curve\n              Domain Parameters\", Standards for Efficient Cryptography
      2\n              (SEC 2), Version 2.0, January 2010,\n              <http://www.secg.org/sec2-v2.pdf>.\n
      \  [X.680]    ITU-T, \"Abstract Syntax Notation One (ASN.1):\n              Specification
      of basic notation\", ITU-T Recommendation\n              X.680, ISO/IEC 8824-1,
      August 2015.\n   [X.690]    ITU-T, \"Information technology-ASN.1 encoding rules:\n
      \             Specification of Basic Encoding Rules (BER), Canonical\n              Encoding
      Rules (CER) and Distinguished Encoding Rules\n              (DER)\", ITU-T Recommendation
      X.690, ISO/IEC 8825-1, August\n              2015.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [FIPS.180-4]\n              National Institute
      of Standards and Technology, \"Secure\n              Hash Standard (SHS)\",
      FIPS PUB 180-4, DOI\n              10.6028/NIST.FIPS.180-4, August 2015,\n              <http://nvlpubs.nist.gov/nistpubs/FIPS/\n
      \             NIST.FIPS.180-4.pdf>.\n   [IEEE.P1363]\n              IEEE, \"Standard
      Specifications for Public Key\n              Cryptography\", IEEE Std P1363,\n
      \             <http://ieeexplore.ieee.org/document/891000/>.\n   [Menezes]  Menezes,
      A. and B. Ustaoglu, \"On reusing ephemeral keys in\n              Diffie-Hellman
      key agreement protocols\", International\n              Journal of Applied Cryptography,
      Vol. 2, Issue 2,\n              DOI 10.1504/IJACT.2010.038308, January 2010.\n
      \  [RFC4492]  Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.\n              Moeller,
      \"Elliptic Curve Cryptography (ECC) Cipher Suites\n              for Transport
      Layer Security (TLS)\", RFC 4492,\n              DOI 10.17487/RFC4492, May 2006,\n
      \             <https://www.rfc-editor.org/info/rfc4492>.\n   [RFC7919]  Gillmor,
      D., \"Negotiated Finite Field Diffie-Hellman\n              Ephemeral Parameters
      for Transport Layer Security (TLS)\",\n              RFC 7919, DOI 10.17487/RFC7919,
      August 2016,\n              <https://www.rfc-editor.org/info/rfc7919>.\n   [TLS1.3]
      \  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n              Version
      1.3\", Work in Progress, draft-ietf-tls-tls13-28,\n              March 2018.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  Equivalent Curves (Informative)\n   All of the NIST curves [FIPS.186-4]
    and several of the ANSI curves\n   [ANSI.X9-62.2005] are equivalent to curves
    listed in Section 5.1.1.\n   The following table displays the curve names chosen
    by different\n   standards organizations; multiple names in one row represent
    aliases\n   for the same curve.\n                  +-----------+------------+------------+\n
    \                 | SECG      | ANSI X9.62 | NIST       |\n                  +-----------+------------+------------+\n
    \                 | sect163k1 |            | NIST K-163 |\n                  |
    sect163r1 |            |            |\n                  | sect163r2 |            |
    NIST B-163 |\n                  | sect193r1 |            |            |\n                  |
    sect193r2 |            |            |\n                  | sect233k1 |            |
    NIST K-233 |\n                  | sect233r1 |            | NIST B-233 |\n                  |
    sect239k1 |            |            |\n                  | sect283k1 |            |
    NIST K-283 |\n                  | sect283r1 |            | NIST B-283 |\n                  |
    sect409k1 |            | NIST K-409 |\n                  | sect409r1 |            |
    NIST B-409 |\n                  | sect571k1 |            | NIST K-571 |\n                  |
    sect571r1 |            | NIST B-571 |\n                  | secp160k1 |            |
    \           |\n                  | secp160r1 |            |            |\n                  |
    secp160r2 |            |            |\n                  | secp192k1 |            |
    \           |\n                  | secp192r1 | prime192v1 | NIST P-192 |\n                  |
    secp224k1 |            |            |\n                  | secp224r1 |            |
    NIST P-224 |\n                  | secp256k1 |            |            |\n                  |
    secp256r1 | prime256v1 | NIST P-256 |\n                  | secp384r1 |            |
    NIST P-384 |\n                  | secp521r1 |            | NIST P-521 |\n                  +-----------+------------+------------+\n
    \       Table 4: Equivalent Curves Defined by SECG, ANSI, and NIST\n"
  title: Appendix A.  Equivalent Curves (Informative)
- contents:
  - "Appendix B.  Differences from RFC 4492\n   o  Renamed EllipticCurveList to NamedCurveList.\n
    \  o  Added TLS 1.2.\n   o  Merged errata.\n   o  Removed the ECDH key exchange
    algorithms: ECDH_RSA and ECDH_ECDSA\n   o  Deprecated a bunch of ciphersuites:\n
    \        TLS_ECDH_ECDSA_WITH_NULL_SHA\n         TLS_ECDH_ECDSA_WITH_RC4_128_SHA\n
    \        TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA\n         TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA\n
    \        TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA\n         TLS_ECDH_RSA_WITH_NULL_SHA\n
    \        TLS_ECDH_RSA_WITH_RC4_128_SHA\n         TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA\n
    \        TLS_ECDH_RSA_WITH_AES_128_CBC_SHA\n         TLS_ECDH_RSA_WITH_AES_256_CBC_SHA\n
    \        All the other RC4 ciphersuites\n   o  Removed unused curves and all but
    the uncompressed point format.\n   o  Added X25519 and X448.\n   o  Deprecated
    explicit curves.\n   o  Removed restriction on signature algorithm in certificate.\n"
  title: Appendix B.  Differences from RFC 4492
- contents:
  - "Acknowledgements\n   Most of the text in this document is taken from [RFC4492],
    the\n   predecessor of this document.  The authors of that document were:\n   o
    \ Simon Blake-Wilson\n   o  Nelson Bolyard\n   o  Vipul Gupta\n   o  Chris Hawk\n
    \  o  Bodo Moeller\n   In the predecessor document, the authors acknowledged the\n
    \  contributions of Bill Anderson and Tim Dierks.\n   The authors would like to
    thank Nikos Mavrogiannopoulos, Martin\n   Thomson, and Tanja Lange for contributions
    to this document.\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   Yoav Nir\n   Check Point Software Technologies Ltd.\n
    \  5 Hasolelim st.\n   Tel Aviv  6789735\n   Israel\n   Email: ynir.ietf@gmail.com\n
    \  Simon Josefsson\n   SJD AB\n   Email: simon@josefsson.org\n   Manuel Pegourie-Gonnard\n
    \  ARM\n   Email: mpg@elzevir.fr\n"
  title: Authors' Addresses
