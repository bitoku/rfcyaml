- contents:
  - '                    Media Control Channel Framework

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes a framework and protocol for application\n
    \  deployment where the application programming logic and media\n   processing
    are distributed.  This implies that application\n   programming logic can seamlessly
    gain access to appropriate resources\n   that are not co-located on the same physical
    network entity.  The\n   framework uses the Session Initiation Protocol (SIP)
    to establish an\n   application-level control mechanism between application servers
    and\n   associated external servers such as media servers.\n   The motivation
    for the creation of this framework is to provide an\n   interface suitable to
    meet the requirements of a centralized\n   conference system, where the conference
    system can be distributed, as\n   defined by the XCON working group in the IETF.
    \ It is not, however,\n   limited to this scope.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6230.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  4\n   2.  Conventions and Terminology  . . . . . . . . . . . . .
    . . . .  4\n   3.  Overview . . . . . . . . . . . . . . . . . . . . . . . . .
    . .  6\n   4.  Control Channel Setup  . . . . . . . . . . . . . . . . . . . .
    10\n     4.1.  Control Client SIP UAC Behavior  . . . . . . . . . . . . . 10\n
    \    4.2.  Control Server SIP UAS Behavior  . . . . . . . . . . . . . 13\n   5.
    \ Establishing Media Streams - Control Client SIP UAC\n       Behavior . . . .
    . . . . . . . . . . . . . . . . . . . . . . . 14\n   6.  Control Framework Interactions
    . . . . . . . . . . . . . . . . 15\n     6.1.  General Behavior for Constructing
    Requests . . . . . . . . 17\n     6.2.  General Behavior for Constructing Responses
    \ . . . . . . . 17\n     6.3.  Transaction Processing . . . . . . . . . . . .
    . . . . . . 18\n       6.3.1.  CONTROL Transactions . . . . . . . . . . . . .
    . . . . 18\n       6.3.2.  REPORT Transactions  . . . . . . . . . . . . . . .
    . . 19\n       6.3.3.  K-ALIVE Transactions . . . . . . . . . . . . . . . . .
    21\n       6.3.4.  SYNC Transactions  . . . . . . . . . . . . . . . . . . 22\n
    \  7.  Response Code Descriptions . . . . . . . . . . . . . . . . . . 24\n     7.1.
    \ 200 Response Code  . . . . . . . . . . . . . . . . . . . . 25\n     7.2.  202
    Response Code  . . . . . . . . . . . . . . . . . . . . 25\n     7.3.  400 Response
    Code  . . . . . . . . . . . . . . . . . . . . 25\n     7.4.  403 Response Code
    \ . . . . . . . . . . . . . . . . . . . . 25\n     7.5.  405 Response Code  .
    . . . . . . . . . . . . . . . . . . . 25\n     7.6.  406 Response Code  . . .
    . . . . . . . . . . . . . . . . . 25\n     7.7.  420 Response Code  . . . . .
    . . . . . . . . . . . . . . . 25\n     7.8.  421 Response Code  . . . . . . .
    . . . . . . . . . . . . . 25\n     7.9.  422 Response Code  . . . . . . . . .
    . . . . . . . . . . . 25\n     7.10. 423 Response Code  . . . . . . . . . . .
    . . . . . . . . . 25\n     7.11. 481 Response Code  . . . . . . . . . . . . .
    . . . . . . . 26\n     7.12. 500 Response Code  . . . . . . . . . . . . . . .
    . . . . . 26\n   8.  Control Packages . . . . . . . . . . . . . . . . . . . .
    . . . 26\n     8.1.  Control Package Name . . . . . . . . . . . . . . . . . .
    . 26\n     8.2.  Framework Message Usage  . . . . . . . . . . . . . . . . . 26\n
    \    8.3.  Common XML Support . . . . . . . . . . . . . . . . . . . . 27\n     8.4.
    \ CONTROL Message Bodies . . . . . . . . . . . . . . . . . . 27\n     8.5.  REPORT
    Message Bodies  . . . . . . . . . . . . . . . . . . 27\n     8.6.  Audit  . .
    . . . . . . . . . . . . . . . . . . . . . . . . 27\n     8.7.  Examples . . .
    . . . . . . . . . . . . . . . . . . . . . . 28\n   9.  Formal Syntax  . . . .
    . . . . . . . . . . . . . . . . . . . . 28\n     9.1.  Control Framework Formal
    Syntax  . . . . . . . . . . . . . 28\n     9.2.  Control Framework Dialog Identifier
    SDP Attribute  . . . . 31\n   10. Examples . . . . . . . . . . . . . . . . . .
    . . . . . . . . . 31\n   11. Extensibility  . . . . . . . . . . . . . . . . .
    . . . . . . . 35\n   12. Security Considerations  . . . . . . . . . . . . . .
    . . . . . 36\n     12.1. Session Establishment  . . . . . . . . . . . . . . .
    . . . 36\n     12.2. Transport-Level Protection . . . . . . . . . . . . . . .
    . 36\n     12.3. Control Channel Policy Management  . . . . . . . . . . . . 37\n
    \  13. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 38\n     13.1.
    Control Packages Registration Information  . . . . . . . . 38\n       13.1.1.
    Control Package Registration Template  . . . . . . . . 39\n     13.2. Control
    Framework Method Names . . . . . . . . . . . . . . 39\n     13.3. Control Framework
    Status Codes . . . . . . . . . . . . . . 39\n     13.4. Control Framework Header
    Fields  . . . . . . . . . . . . . 40\n     13.5. Control Framework Port . . .
    . . . . . . . . . . . . . . . 40\n     13.6. Media Type Registrations . . . .
    . . . . . . . . . . . . . 40\n       13.6.1. Registration of MIME Media Type application/cfw
    \ . . . 41\n       13.6.2. Registration of MIME Media Type\n               application/framework-attributes+xml
    . . . . . . . . . 42\n     13.7. 'cfw-id' SDP Attribute . . . . . . . . . . .
    . . . . . . . 42\n     13.8. URN Sub-Namespace for\n           urn:ietf:params:xml:ns:control:framework-attributes
    \ . . . 43\n     13.9. XML Schema Registration  . . . . . . . . . . . . . . .
    . . 43\n   14. Contributors . . . . . . . . . . . . . . . . . . . . . . . . .
    44\n   15. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 44\n
    \  16. References . . . . . . . . . . . . . . . . . . . . . . . . . . 44\n     16.1.
    Normative References . . . . . . . . . . . . . . . . . . . 44\n     16.2. Informative
    References . . . . . . . . . . . . . . . . . . 46\n   Appendix A.  Common Package
    Components . . . . . . . . . . . . . . 47\n     A.1.  Common Dialog/Multiparty
    Reference Schema  . . . . . . . . 47\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Real-time media applications are often developed using an\n
    \  architecture where the application logic and media processing\n   activities
    are distributed.  Commonly, the application logic runs on\n   \"application servers\",
    but the processing runs on external servers,\n   such as \"media servers\".  This
    document focuses on the framework and\n   protocol between the application server
    and external processing\n   server.  The motivation for this framework comes from
    a set of\n   requirements for Media Server Control, which can be found in \"Media\n
    \  Server Control Protocol Requirements\" [RFC5167].  While the Framework\n   is
    not specific to media server control, it is the primary driver and\n   use case
    for this work.  It is intended that the framework contained\n   in this document
    be able to be used for a variety of device control\n   scenarios (for example,
    conference control).\n   This document does not define a particular SIP extension
    for the\n   direct control of external components.  Rather, other documents,\n
    \  known as \"Control Packages\", extend the Control Framework described\n   by
    this document.  Section 8 provides a comprehensive set of\n   guidelines for creating
    such Control Packages.\n   Current IETF device control protocols, such as Megaco
    [RFC5125],\n   while excellent for controlling media gateways that bridge separate\n
    \  networks, are troublesome for supporting media-rich applications in\n   SIP
    networks.  This is because Megaco duplicates many of the\n   functions inherent
    in SIP.  Rather than using a single protocol for\n   session establishment and
    application media processing, application\n   developers need to translate between
    two separate mechanisms.\n   Moreover, the model provided by the framework presented
    here, using\n   SIP, better matches the application programming model than does\n
    \  Megaco.\n   SIP [RFC3261] provides the ideal rendezvous mechanism for\n   establishing
    and maintaining control connections to external server\n   components.  The control
    connections can then be used to exchange\n   explicit command/response interactions
    that allow for media control\n   and associated command response results.\n"
  title: 1.  Introduction
- contents:
  - "2.  Conventions and Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
    and \"OPTIONAL\" in this\n   document are to be interpreted as described in BCP
    14, [RFC2119], as\n   scoped to those conformance targets.\n   The following additional
    terms are defined for use in this document:\n   User Agent Client (UAC):  As specified
    in [RFC3261].\n   User Agent Server (UAS):  As specified in [RFC3261].\n   B2BUA:
    \ A B2BUA is a Back-to-Back SIP User Agent.\n   Control Server:  A Control Server
    is an entity that performs a\n      service, such as media processing, on behalf
    of a Control Client.\n      For example, a media server offers mixing, announcement,
    tone\n      detection and generation, and play and record services.  The\n      Control
    Server has a direct Real-Time Transport Protocol (RTP)\n      [RFC3550] relationship
    with the source or sink of the media flow.\n      In this document, we often refer
    to the Control Server simply as\n      \"the Server\".\n   Control Client:  A
    Control Client is an entity that requests\n      processing from a Control Server.
    \ Note that the Control Client\n      might not have any processing capabilities
    whatsoever.  For\n      example, the Control Client may be an application server
    (B2BUA)\n      or other endpoint requesting manipulation of a third party's media\n
    \     stream that terminates on a media server acting in the role of a\n      Control
    Server.  In this document, we often refer to the Control\n      Client simply
    as \"the Client\".\n   Control Channel:  A Control Channel is a reliable connection
    between\n      a Client and Server that is used to exchange Framework messages.\n
    \     The term \"Connection\" is used synonymously within this document.\n   Framework
    Message:  A Framework message is a message on a Control\n      Channel that has
    a type corresponding to one of the Methods\n      defined in this document.  A
    Framework message is often referred\n      to by its method, such as a \"CONTROL
    message\".\n   Method:  A Method is the type of a Framework message.  Four Methods\n
    \     are defined in this document: SYNC, CONTROL, REPORT, and K-ALIVE.\n   Control
    Command:  A Control Command is an application-level request\n      from a Client
    to a Server.  Control Commands are carried in the\n      body of CONTROL messages.
    \ Control Commands are defined in\n      separate specifications known as \"Control
    Packages\".\n   Framework Transaction:  A Framework Transaction is defined as
    a\n      sequence composed of a Control Framework message originated by\n      either
    a Control Client or Control Server and responded to with a\n      Control Framework
    response code message.  Note that the Control\n      Framework has no \"provisional\"
    responses.  A Control Framework\n      transaction is referenced throughout the
    document as a\n      'Transaction-Timeout'.\n   Transaction-Timeout:  The maximum
    allowed time between a Control\n      Client or Server issuing a Framework message
    and it arriving at\n      the destination.  The value for 'Transaction-Timeout'
    is 10\n      seconds.\n"
  title: 2.  Conventions and Terminology
- contents:
  - "3.  Overview\n   This document details mechanisms for establishing, using, and\n
    \  terminating a reliable transport connection channel using SIP and the\n   Session
    Description Protocol offer/answer [RFC3264] exchange.  The\n   established connection
    is then used for controlling an external\n   server.  The following text provides
    a non-normative overview of the\n   mechanisms used.  Detailed, normative guidelines
    are provided later\n   in the document.\n   Control Channels are negotiated using
    standard SIP mechanisms that\n   would be used in a similar manner to creating
    a SIP multimedia\n   session.  Figure 1 illustrates a simplified view of the mechanism.\n
    \  It highlights a separation of the SIP signaling traffic and the\n   associated
    Control Channel that is established as a result of the SIP\n   interactions.\n
    \  Initial analysis into the Control Framework, as documented in\n   [MSCL-THOUGHTS],
    established the following.  One might ask, \"If all\n   we are doing is establishing
    a TCP connection to control the media\n   server, why do we need SIP?\"  This
    is a reasonable question.  The key\n   is that we use SIP for media session establishment.
    \ If we are using\n   SIP for media session establishment, then we need to ensure
    the URI\n   used for session establishment resolves to the same node as the node\n
    \  for session control.  Using the SIP routing mechanism, and having the\n   server
    initiate the TCP connection back, ensures this works.  For\n   example, the URI
    sip:myserver.example.com may resolve to sip:\n   server21.farm12.northeast.example.net,
    whereas the URI\n   http://myserver.example.com may resolve to\n   http://server41.httpfarm.central.example.net.
    \ That is, the host part\n   is not necessarily unambiguous.\n   The use of SIP
    to negotiate the Control Channel provides many\n   inherent capabilities, which
    include:\n   o  Service location - Use SIP Proxies and Back-to-Back User Agents\n
    \     for locating Control Servers.\n   o  Security mechanisms - Leverage established
    security mechanisms\n      such as Transport Layer Security (TLS) and Client Authentication.\n
    \  o  Connection maintenance - The ability to re-negotiate a connection,\n      ensure
    it is active, and so forth.\n   o  Application agnostic - Generic protocol allows
    for easy extension.\n   As mentioned in the previous list, one of the main benefits
    of using\n   SIP as the session control protocol is the \"Service Location\"\n
    \  facilities provided.  This applies both at a routing level, where\n   [RFC3263]
    provides the physical location of devices, and at the\n   service level, using
    Caller Preferences [RFC3840] and Callee\n   Capabilities [RFC3841].  The ability
    to select a Control Server based\n   on service-level capabilities is extremely
    powerful when considering\n   a distributed, clustered architecture containing
    varying services\n   (for example, voice, video, IM).  More detail on locating
    Control\n   Server resources using these techniques is outlined in Section 4.1
    of\n   this document.\n           +--------------SIP Traffic--------------+\n
    \         |                                       |\n          v                                       v\n
    \      +-----+                                 +--+--+\n       | SIP |                                 |
    SIP |\n       |Stack|                                 |Stack|\n   +---+-----+---+
    \                        +---+-----+---+\n   |   Control   |                         |
    \  Control   |\n   |   Client    |<----Control Channel---->|   Server    |\n   +-------------+
    \                        +-------------+\n                       Figure 1: Basic
    Architecture\n   The example from Figure 1 conveys a 1:1 connection between the\n
    \  Control Client and the Control Server.  It is possible, if required,\n   for
    the client to request multiple Control Channels using separate\n   SIP INVITE
    dialogs between the Control Client and the Control Server\n   entities.  Any of
    the connections created between the two entities\n   can then be used for Server
    control interactions.  The control\n   connections are orthogonal to any given
    media session.  Specific\n   media session information is incorporated in control
    interaction\n   commands, which themselves are defined in external packages, using\n
    \  the XML schema defined in Appendix A.  The ability to have multiple\n   Control
    Channels allows for stronger redundancy and the ability to\n   manage high volumes
    of traffic in busy systems.\n   Consider the following simple example for session
    establishment\n   between a Client and a Server.  (Note: Some lines in the examples
    are\n   removed for clarity and brevity.)  Note that the roles discussed are\n
    \  logical and can change during a session, if the Control Package\n   allows.\n
    \  The Client constructs and sends a standard SIP INVITE request, as\n   defined
    in [RFC3261], to the external Server.  The Session\n   Description Protocol (SDP)
    payload includes the required information\n   for Control Channel negotiation
    and is the primary mechanism for\n   conveying support for this specification.
    \ The application/cfw MIME\n   type is defined in this document to convey the
    appropriate SDP format\n   for compliance to this specification.  The Connection-Oriented
    Media\n   (COMEDIA) [RFC4145] specification for setting up and maintaining\n   reliable
    connections is used as part of the negotiation mechanism\n   (more detail available
    in later sections).  The Client also includes\n   the 'cfw-id' SDP attribute,
    as defined in this specification, which\n   is a unique identifier used to correlate
    the underlying Media Control\n   Channel with the offer/answer exchange.\n   Client
    Sends to External Server:\n   INVITE sip:External-Server@example.com SIP/2.0\n
    \  To: <sip:External-Server@example.com>\n   From: <sip:Client@example.com>;tag=64823746\n
    \  Via: SIP/2.0/UDP client.example.com;branch=z9hG4bK72d\n   Call-ID: 7823987HJHG6\n
    \  Max-Forwards: 70\n   CSeq: 1 INVITE\n   Contact: <sip:Client@clientmachine.example.com>\n
    \  Content-Type: application/sdp\n   Content-Length: [..]\n   v=0\n   o=originator
    2890844526 2890842808 IN IP4 controller.example.com\n   s=-\n   c=IN IP4 controller.example.com\n
    \  m=application 49153 TCP cfw\n   a=setup:active\n   a=connection:new\n   a=cfw-id:H839quwhjdhegvdga\n
    \  On receiving the INVITE request, an external Server supporting this\n   mechanism
    generates a 200 OK response containing appropriate SDP and\n   formatted using
    the application/cfw MIME type specified in this\n   document.  The Server inserts
    its own unique 'cfw-id' SDP attribute,\n   which differs from the one received
    in the INVITE (offer).\n   External Server Sends to Client:\n"
  - 'SIP/2.0 200 OK

    '
  - 'To: <sip:External-Server@example.com>;tag=28943879

    '
  - 'From: <sip:Client@example.com>;tag=64823746

    '
  - 'Via: SIP/2.0/UDP client.example.com;branch=z9hG4bK72d;received=192.0.2.4

    '
  - 'Call-ID: 7823987HJHG6

    '
  - 'CSeq: 1 INVITE

    '
  - 'Contact: <sip:External-Server@servermachine.example.com>

    '
  - 'Content-Type: application/sdp

    '
  - 'Content-Length: [..]

    '
  - 'v=0

    '
  - 'o=responder 2890844526 2890842808 IN IP4 server.example.com

    '
  - 's=-

    '
  - 'c=IN IP4 mserver.example.com

    '
  - 'm=application 7563 TCP cfw

    '
  - 'a=setup:passive

    '
  - 'a=connection:new

    '
  - "a=cfw-id:U8dh7UHDushsdu32uha\n   The Control Client receives the SIP 200 OK response
    and extracts the\n   relevant information (also sending a SIP ACK).  It creates
    an\n   outgoing (as specified by the SDP 'setup' attribute of 'active') TCP\n
    \  connection to the Control Server.  The connection address (taken from\n   'c=')
    and port (taken from 'm=') are used to identify the remote port\n   in the new
    connection.\n   Once established, the newly created connection can be used to\n
    \  exchange requests and responses as defined in this document.  If\n   required,
    after the Control Channel has been set up, media sessions\n   can be established
    using standard SIP Third Party Call Control (3PCC)\n   [RFC3725].\n   Figure 2
    provides a simplified example where the framework is used to\n   control a User
    Agent's RTP session.\n                         +--------Control SIP Dialog(1)---------+\n
    \                        |                                      |\n                         v
    \                                     v\n                      +-----+                                +--+--+\n
    \    +------(2)------>| SIP |---------------(2)------------->| SIP |\n     |                |Stack|
    \                               |Stack|\n     |            +---+-----+---+                        +---+-----+---+\n
    \    |            |             |                        |             |\n     |
    \           |   Control   |<--Control Channel(1)-->|             |\n     |            |
    \  Client    |                        |   Control   |\n     |            +-------------+
    \                       |   Server    |\n  +--+--+                                                |
    \            |\n  |User |                                                |             |\n
    \ |Agent|<=====================RTP(2)===================>|             |\n  +-----+
    \                                               +-------------+\n                    Figure
    2: Participant Architecture\n   The link (1) represents the SIP INVITE dialog
    usage and dedicated\n   Control Channel previously described in this overview
    section.  The\n   link (2) from Figure 2 represents the User Agent SIP INVITE
    dialog\n   usage interactions and associated media flow.  A User Agent creates
    a\n   SIP INVITE dialog usage with the Control Client entity.  The Control\n   Client
    entity then creates a SIP INVITE dialog usage to the Control\n   Server, using
    B2BUA type functionality.  Using the interaction\n   illustrated by (2), the Control
    Client negotiates media capabilities\n   with the Control Server, on behalf of
    the User Agent, using SIP 3PCC.\n   [RFC3725].\n"
  title: 3.  Overview
- contents:
  - "4.  Control Channel Setup\n   This section describes the setup, using SIP, of
    the dedicated Control\n   Channel.  Once the Control Channel has been established,
    commands can\n   be exchanged (as discussed in Section 6).\n"
  - contents:
    - "4.1.  Control Client SIP UAC Behavior\n   When a UAC wishes to establish a
      Control Channel, it MUST construct\n   and transmit a new SIP INVITE request
      for Control Channel setup.  The\n   UAC MUST construct the INVITE request as
      defined in [RFC3261].\n   If a reliable response is received (as defined in
      [RFC3261] and\n   [RFC3262]), the mechanisms defined in this document are applicable
      to\n   the newly created SIP INVITE dialog usage.\n   The UAC SHOULD include
      a valid session description (an 'offer' as\n   defined in [RFC3264]) in an INVITE
      request using the Session\n   Description Protocol defined in [RFC4566] but
      MAY choose an offer-\n   less INVITE as per [RFC3261].  The SDP SHOULD be formatted
      in\n   accordance with the steps below and using the MIME type application/\n
      \  cfw, which is registered in Section 13.  The following information\n   defines
      the composition of specific elements of the SDP payload the\n   offerer MUST
      adhere to when used in a SIP-based offer/answer exchange\n   using SDP and the
      application/cfw MIME type.  The SDP being\n   constructed MUST contain only
      a single occurrence of a Control\n   Channel definition outlined in this specification
      but can contain\n   other media lines if required.\n   The Connection Data line
      in the SDP payload is constructed as\n   specified in [RFC4566]:\n   c=<nettype>
      <addrtype> <connection-address>\n   The first sub-field, <nettype>, MUST equal
      the value \"IN\".  The\n   second sub-field, <addrtype>, MUST equal either \"IP4\"
      or \"IP6\".  The\n   third sub-field for Connection Data is <connection-address>.
      \ This\n   supplies a representation of the SDP originator's address, for\n
      \  example, DNS/IP representation.  The address is the address used for\n   connections.\n
      \  Example:\n   c=IN IP4 controller.example.com\n   The SDP MUST contain a corresponding
      Media Description entry:\n   m=<media> <port> <proto> <fmt>\n   The first \"sub-field\",
      <media>, MUST equal the value \"application\".\n   The second sub-field, <port>,
      MUST represent a port on which the\n   constructing client can receive an incoming
      connection if required.\n   The port is used in combination with the address
      specified in the\n   Connection Data line defined previously to supply connection
      details.\n   If the entity constructing the SDP can't receive incoming\n   connections,
      it must still enter a valid port entry.  The use of the\n   port value '0' has
      the same meaning as defined in a SIP offer/answer\n   exchange [RFC3264].  The
      Control Framework has a default port defined\n   in Section 13.5.  This value
      is default, although a client is free to\n   choose explicit port numbers.  However,
      SDP SHOULD use the default\n   port number, unless local policy prohibits its
      use.  Using the\n   default port number allows network administrators to manage
      firewall\n   policy for Control Framework interactions.  The third sub-field,\n
      \  <proto>, compliant to this specification, MUST support the values\n   \"TCP\"
      and \"TCP/TLS\".  Implementations MUST support TLS as a\n   transport-level
      security mechanism for the Control Channel, although\n   use of TLS in specific
      deployments is optional.  Control Framework\n   implementations MUST support
      TCP as a transport protocol.  When an\n   entity identifies a transport value
      but is not willing to establish\n   the session, it MUST respond using the appropriate
      SIP mechanism.\n   The <fmt> sub-field MUST contain the value \"cfw\".\n   The
      SDP MUST also contain a number of SDP media attributes (a=) that\n   are specifically
      defined in the COMEDIA [RFC4145] specification.  The\n   attributes provide
      connection negotiation and maintenance parameters.\n   It is RECOMMENDED that
      a Controlling UAC initiate a connection to an\n   external Server but that an
      external Server MAY negotiate and\n   initiate a connection using COMEDIA, if
      network topology prohibits\n   initiating connections in a certain direction.
      \ An example of the\n   COMEDIA attributes is:\n                           a=setup:active\n
      \                          a=connection:new\n   This example demonstrates a
      new connection that will be initiated\n   from the owner of the SDP payload.
      \ The connection details are\n   contained in the SDP answer received from the
      UAS.  A full example of\n   an SDP payload compliant to this specification can
      be viewed in\n   Section 3.  Once the SDP has been constructed along with the\n
      \  remainder of the SIP INVITE request (as defined in [RFC3261]), it can\n   be
      sent to the appropriate location.  The SIP INVITE dialog usage and\n   appropriate
      control connection is then established.\n   A SIP UAC constructing an offer
      MUST include the 'cfw-id' SDP\n   attribute as defined in Section 9.2.  The
      'cfw-id' attribute\n   indicates an identifier that can be used within the Control
      Channel\n   to correlate the Control Channel with this SIP INVITE dialog usage.\n
      \  The 'cfw-id' attribute MUST be unique in the context of the\n   interaction
      between the UAC and UAS and MUST NOT clash with instances\n   of the 'cfw-id'
      used in other SIP offer/answer exchanges.  The value\n   chosen for the 'cfw-id'
      attribute MUST be used for the entire\n   duration of the associated SIP INVITE
      dialog usage and not be changed\n   during updates to the offer/answer exchange.
      \ This applies\n   specifically to the 'connection' attribute as defined in
      [RFC4145].\n   If a SIP UAC wants to change some other parts of the SDP but
      reuse\n   the already established connection, it uses the value of 'existing'\n
      \  in the 'connection' attribute (for example, a=connection:existing).\n   If
      it has noted that a connection has failed and wants to re-\n   establish the
      connection, it uses the value of 'new' in the\n   'connection' attribute (for
      example, a=connection:new).  Throughout\n   this, the connection identifier
      specified in the 'cfw-id' SDP\n   parameter MUST NOT change.  One is simply
      negotiating the underlying\n   TCP connection between endpoints but always using
      the same Control\n   Framework session, which is 1:1 for the lifetime of the
      SIP INVITE\n   dialog usage.\n   A non-2xx-class final SIP response (3xx, 4xx,
      5xx, and 6xx) received\n   for the INVITE request indicates that no SIP INVITE
      dialog usage has\n   been created and is treated as specified by SIP [RFC3261].\n
      \  Specifically, support of this specification is negotiated through the\n   presence
      of the media type defined in this specification.  The\n   receipt of a SIP error
      response such as \"488\" indicates that the\n   offer contained in a request
      is not acceptable.  The inclusion of the\n   media line associated with this
      specification in such a rejected\n   offer indicates to the client generating
      the offer that this could be\n   due to the receiving client not supporting
      this specification.  The\n   client generating the offer MUST act as it would
      normally on\n   receiving this response, as per [RFC3261].  Media streams can
      also be\n   rejected by setting the port to \"0\" in the \"m=\" line of the
      session\n   description, as defined in [RFC3264].  A client using this\n   specification
      MUST be prepared to receive an answer where the \"m=\"\n   line it inserted
      for using the Control Framework has been set to \"0\".\n   In this situation,
      the client will act as it would for any other\n   media type with a port set
      to \"0\".\n"
    title: 4.1.  Control Client SIP UAC Behavior
  - contents:
    - "4.2.  Control Server SIP UAS Behavior\n   On receiving a SIP INVITE request,
      an external Server (SIP UAS)\n   inspects the message for indications of support
      for the mechanisms\n   defined in this specification.  This is achieved through
      inspection\n   of the session description of the offer message and identifying\n
      \  support for the application/cfw MIME type in the SDP.  If the SIP UAS\n   wishes
      to construct a reliable response that conveys support for the\n   extension,
      it MUST follow the mechanisms defined in [RFC3261].  If\n   support is conveyed
      in a reliable SIP provisional response, the\n   mechanisms in [RFC3262] MUST
      also be used.  It should be noted that\n   the SDP offer is not restricted to
      the initial INVITE request and MAY\n   appear in any series of messages that
      are compliant to [RFC3261],\n   [RFC3262], [RFC3311], and [RFC3264].\n   When
      constructing an answer, the SDP payload MUST be constructed\n   using the semantic
      (connection, media, and attribute) defined in\n   Section 4.1 using valid local
      settings and also with full compliance\n   to the COMEDIA [RFC4145] specification.
      \ For example, the SDP\n   attributes included in the answer constructed for
      the example offer\n   provided in Section 4.1 would look as follows:\n                           a=setup:passive\n
      \                          a=connection:new\n   A client constructing an answer
      MUST include the 'cfw-id' SDP\n   attribute as defined in Section 9.2.  This
      attribute MUST be unique\n   in the context of the interaction between the UAC
      and UAS and MUST\n   NOT clash with instances of the 'cfw-id' used in other
      SIP offer/\n   answer exchanges.  The 'cfw-id' MUST be different from the 'cfw-id'\n
      \  value received in the offer as it is used to uniquely identify and\n   distinguish
      between multiple endpoints that generate SDP answers.\n   The value chosen for
      the 'cfw-id' attribute MUST be used for the\n   entire duration of the associated
      SIP INVITE dialog usage and not be\n   changed during updates to the offer/answer
      exchange.\n   Once the SDP answer has been constructed, it is sent using standard\n
      \  SIP mechanisms.  Depending on the contents of the SDP payloads that\n   were
      negotiated using the offer/answer exchange, a reliable\n   connection will be
      established between the Controlling UAC and\n   External Server UAS entities.
      \ The newly established connection is\n   now available to exchange Control
      Command primitives.  The state of\n   the SIP INVITE dialog usage and the associated
      Control Channel are\n   now implicitly linked.  If either party wishes to terminate
      a Control\n   Channel, it simply issues a SIP termination request (for example,
      a\n   SIP BYE request or appropriate response in an early SIP INVITE dialog\n
      \  usage).  The Control Channel therefore lives for the duration of the\n   SIP
      INVITE dialog usage.\n   A UAS receiving a SIP OPTIONS request MUST respond
      appropriately as\n   defined in [RFC3261].  The UAS MUST include the media types
      supported\n   in the SIP 200 OK response in a SIP 'Accept' header to indicate
      the\n   valid media types.\n"
    title: 4.2.  Control Server SIP UAS Behavior
  title: 4.  Control Channel Setup
- contents:
  - "5.  Establishing Media Streams - Control Client SIP UAC Behavior\n   It is intended
    that the Control Framework will be used within a\n   variety of architectures
    for a wide range of functions.  One of the\n   primary functions will be the use
    of the Control Channel to apply\n   multiple specific Control Package commands
    to media sessions\n   established by SIP INVITE dialogs (media dialogs) with a
    given remote\n   server.  For example, the Control Server might send a command
    to\n   generate audio media (such as an announcement) on an RTP stream\n   between
    a User Agent and a media server.\n   SIP INVITE dialogs used to establish media
    sessions (see Figure 2) on\n   behalf of User Agents MAY contain more than one
    Media Description (as\n   defined by \"m=\" in the SDP).  The Control Client MUST
    include a media\n   label attribute, as defined in [RFC4574], for each \"m=\"
    definition\n   received that is to be directed to an entity using the Control\n
    \  Framework.  This allows the Control Client to later explicitly direct\n   commands
    on the Control Channel at a specific media line (m=).\n   This framework identifies
    the referencing of such associated media\n   dialogs as extremely important.  A
    connection reference attribute has\n   been specified that can optionally be imported
    into any Control\n   Package.  It is intended that this will reduce the repetitive\n
    \  specifying of dialog reference language.  The schema can be found in\n   Appendix
    A.1.\n   Similarly, the ability to identify and apply commands to a group of\n
    \  associated media dialogs (multiparty) is also identified as a common\n   structure
    that could be defined and reused, for example, playing a\n   prompt to all participants
    in a Conference.  The schema for such\n   operations can also be found in Appendix
    A.1.\n   Support for both the common attributes described here is specified as\n
    \  part of each Control Package definition, as detailed in Section 8.\n"
  title: 5.  Establishing Media Streams - Control Client SIP UAC Behavior
- contents:
  - "6.  Control Framework Interactions\n   In this document, the use of the COMEDIA
    specification allows for a\n   Control Channel to be set up in either direction
    as a result of a SIP\n   INVITE transaction.  SIP provides a flexible negotiation
    mechanism to\n   establish the Control Channel, but there needs to be a mechanism\n
    \  within the Control Channel to correlate it with the SIP INVITE dialog\n   usage
    implemented for its establishment.  A Control Client receiving\n   an incoming
    connection (whether it be acting in the role of UAC or\n   UAS) has no way of
    identifying the associated SIP INVITE dialog usage\n   as it could be simply listening
    for all incoming connections on a\n   specific port.  The following steps, which
    implementations MUST\n   support, allow a connecting UA (that is, the UA with
    the active role\n   in COMEDIA) to identify the associated SIP INVITE dialog usage
    that\n   triggered the connection.  Unless there is an alternative dialog\n   association
    mechanism used, the UAs MUST carry out these steps before\n   any other signaling
    on the newly created Control Channel.\n   o  Once the connection has been established,
    the UA acting in the\n      active role (active UA) to initiate the connection
    MUST send a\n      Control Framework SYNC request.  The SYNC request MUST be\n
    \     constructed as defined in Section 9.1 and MUST contain the\n      'Dialog-ID'
    message header.\n   o  The 'Dialog-ID' message header is populated with the value
    of the\n      local 'cfw-id' media-level attribute that was inserted by the same\n
    \     client in the SDP offer/answer exchange to establish the Control\n      Channel.
    \ This allows for a correlation between the Control\n      Channel and its associated
    SIP INVITE dialog usage.\n   o  On creating the SYNC request, the active UA MUST
    follow the\n      procedures outlined in Section 6.3.3.  This provides details
    of\n      connection keep-alive messages.\n   o  On creating the SYNC request,
    the active UA MUST also follow the\n      procedures outlined in Section 6.3.4.2.
    \ This provides details of\n      the negotiation mechanism used to determine
    the Protocol Data\n      Units (PDUs) that can be exchanged on the established
    Control\n      Channel connection.\n   o  The UA in the active role for the connection
    creation MUST then\n      send the SYNC request.  If the UA in the active role
    for the\n      connection creation is a SIP UAS and has generated its SDP\n      response
    in a 2xx-class SIP response, it MUST wait for an incoming\n      SIP ACK message
    before issuing the SYNC.  If the UA in the active\n      role for the connection
    creation is a SIP UAS and has generated\n      its SDP response in a reliable
    1XX class SIP response, it MUST\n      wait for an incoming SIP PRACK message
    before issuing the SYNC.\n      If the UA in the active role for the connection
    creation is a SIP\n      UAC, it MUST send the SYNC message immediately on establishment
    of\n      the Control Channel.  It MUST then wait for a period of at least\n      2*'Transaction-Timeout'
    to receive a response.  It MAY choose a\n      longer time to wait, but it MUST
    NOT be shorter than 'Transaction-\n      Timeout'.  In general, a Control Framework
    transaction MUST\n      complete within 20 (2*'Transaction-Timeout') seconds and
    is\n      referenced throughout the document as 'Transaction-Timeout'.\n   o  If
    no response is received for the SYNC message, a timeout occurs\n      and the
    Control Channel is terminated along with the associated\n      SIP INVITE dialog
    usage.  The active UA MUST issue a BYE request\n      to terminate the SIP INVITE
    dialog usage.\n   o  If the active UA receives a 481 response from the passive
    UA, this\n      means the SYNC request was received, but the associated SIP INVITE\n
    \     dialog usage specified in the SYNC message does not exist.  The\n      active
    client MUST terminate the Control Channel.  The active UA\n      MUST issue a
    SIP BYE request to terminate the SIP INVITE dialog\n      usage.\n   o  All other
    error responses received for the SYNC request are\n      treated as detailed in
    this specification and also result in the\n      termination of the Control Channel
    and the associated SIP INVITE\n      dialog usage.  The active UA MUST issue a
    BYE request to terminate\n      the SIP INVITE dialog usage.\n   o  The receipt
    of a 200 response to a SYNC message implies that the\n      SIP INVITE dialog
    usage and control connection have been\n      successfully correlated.  The Control
    Channel can now be used for\n      further interactions.\n   SYNC messages can
    be sent at any point while the Control Channel is\n   open from either side, once
    the initial exchange is complete.  If\n   present, the contents of the 'Keep-Alive'
    and 'Dialog-ID' headers\n   MUST NOT change.  New values of the 'Keep-Alive' and
    'Dialog-ID'\n   headers have no relevance as they are negotiated for the lifetime
    of\n   the Media Control Channel Framework session.\n   Once a successful Control
    Channel has been established, as defined in\n   Sections 4.1 and 4.2, and the
    connection has been correlated, as\n   described in previous paragraphs, the two
    entities are now in a\n   position to exchange Control Framework messages.  The
    following sub-\n   sections specify the general behavior for constructing Control\n
    \  Framework requests and responses.  Section 6.3 specifies the core\n   Control
    Framework methods and their transaction processing.\n"
  - contents:
    - "6.1.  General Behavior for Constructing Requests\n   An entity acting as a
      Control Client that constructs and sends\n   requests on a Control Channel MUST
      adhere to the syntax defined in\n   Section 9.  Note that either entity can
      act as a Control Client\n   depending on individual package requirements.  Control
      Commands MUST\n   also adhere to the syntax defined by the Control Packages
      negotiated\n   in Sections 4.1 and 4.2 of this document.  A Control Client MUST\n
      \  create a unique transaction and associated identifier for insertion\n   in
      the request.  The transaction identifier is then included in the\n   first line
      of a Control Framework message along with the method type,\n   as defined in
      the ABNF in Section 9.  The first line starts with the\n   \"CFW\" token for
      the purpose of easily extracting the transaction\n   identifier.  The transaction
      identifier MUST be unique in the context\n   of the interaction between the
      Control Client and Control Server.\n   This unique property helps avoid clashes
      when multiple client\n   entities could be creating transactions to be carried
      out on a single\n   receiving server.  All required, mandatory, and optional
      Control\n   Framework headers are then inserted into the request with appropriate\n
      \  values (see relevant individual header information for explicit\n   detail).
      \ A 'Control-Package' header MUST also be inserted with the\n   value indicating
      the Control Package to which this specific request\n   applies.  Multiple packages
      can be negotiated per Control Channel\n   using the SYNC message discussed in
      Section 6.3.4.2.\n   Any Framework message that contains an associated payload
      MUST also\n   include the 'Content-Type' and 'Content-Length' message headers,\n
      \  which indicate the MIME type of the payload specified by the\n   individual
      Control Framework packages and the size of the message\n   body represented
      as a whole decimal number of octets, respectively.\n   If no associated payload
      is to be added to the message, the 'Content-\n   Length' header MUST have a
      value of '0'.\n   A Server receiving a Framework message request MUST respond
      with an\n   appropriate response (as defined in Section 6.2).  Control Clients\n
      \  MUST wait for a minimum of 2*'Transaction-Timeout' for a response\n   before
      considering the transaction a failure and tidying state\n   appropriately depending
      on the extension package being used.\n"
    title: 6.1.  General Behavior for Constructing Requests
  - contents:
    - "6.2.  General Behavior for Constructing Responses\n   An entity acting as a
      Control Server, on receiving a request, MUST\n   generate a response within
      the 'Transaction-Timeout', as measured\n   from the Control Client.  The response
      MUST conform to the ABNF\n   defined in Section 9.  The first line of the response
      MUST contain\n   the transaction identifier used in the first line of the request,
      as\n   defined in Section 6.1.  Responses MUST NOT include the 'Status' or\n
      \  'Timeout' message headers, and these MUST be ignored if received by a\n   Client
      in a response.\n   A Control Server MUST include a status code in the first
      line of the\n   response.  If there is no error, the Server responds with a
      200\n   Control Framework status code, as defined in Section 7.1.  The 200\n
      \  response MAY include message bodies.  If the response contains a\n   payload,
      the message MUST include the 'Content-Length' and 'Content-\n   Type' headers.
      \ When the Control Client receives a 2xx-class\n   response, the Control Command
      transaction is complete.\n   If the Control Server receives a request, like
      CONTROL, that the\n   Server understands, but the Server knows processing the
      command will\n   exceed the 'Transaction-Timeout', then the Server MUST respond
      with a\n   202 status code in the first line of the response.  Following the\n
      \  initial response, the server will send one or more REPORT messages as\n   described
      in Section 6.3.2.  A Control Package MUST explicitly define\n   the circumstances
      under which the server sends 200 and 202 messages.\n   If a Control Server encounters
      problems with a Control Framework\n   request (like REPORT or CONTROL), an appropriate
      error code MUST be\n   used in the response, as listed in Section 7.  The generation
      of a\n   non-2xx-class response code to a Control Framework request (like\n
      \  CONTROL or REPORT) will indicate failure of the transaction, and all\n   associated
      transaction state and resources MUST be terminated.  The\n   response code may
      provide an explicit indication of why the\n   transaction failed, which might
      result in a re-submission of the\n   request depending on the extension package
      being used.\n"
    title: 6.2.  General Behavior for Constructing Responses
  - contents:
    - "6.3.  Transaction Processing\n   The Control Framework defines four types of
      requests (methods):\n   CONTROL, REPORT, K-ALIVE, and SYNC.  Implementations
      MUST support\n   sending and receiving these four methods.\n   The following
      sub-sections specify each Control Framework method and\n   its associated transaction
      processing.\n"
    - contents:
      - "6.3.1.  CONTROL Transactions\n   A CONTROL message is used by the Control
        Client to pass control-\n   related information to a Control Server.  It is
        also used as the\n   event-reporting mechanism in the Control Framework.  Reporting
        events\n   is simply another usage of the CONTROL message, which is permitted
        to\n   be sent in either direction between two participants in a session,\n
        \  carrying the appropriate payload for an event.  The message is\n   constructed
        in the same way as any standard Control Framework\n   message, as discussed
        in Section 6.1 and defined in Section 9.  A\n   CONTROL message MAY contain
        a message body.  The explicit Control\n   Command(s) of the message payload
        contained in a CONTROL message are\n   specified in separate Control Package
        specifications.  Separate\n   Control Package specifications MUST conform
        to the format defined in\n   Section 8.4.  A CONTROL message containing a
        payload MUST include a\n   'Content-Type' header.  The payload MUST be one
        of the payload types\n   defined by the Control Package.  Individual packages
        MAY allow a\n   CONTROL message that does not contain a payload.  This could
        in fact\n   be a valid message exchange within a specific package; if it's
        not,\n   an appropriate package-level error message MUST be generated.\n"
      title: 6.3.1.  CONTROL Transactions
    - contents:
      - "6.3.2.  REPORT Transactions\n   A 'REPORT' message is used by a Control Server
        when processing of a\n   CONTROL command extends beyond the 'Transaction-Timeout',
        as measured\n   from the Client.  In this case, the Server returns a 202 response.\n
        \  The Server returns status updates and the final results of the\n   command
        in subsequent REPORT messages.\n   All REPORT messages MUST contain the same
        transaction ID in the\n   request start line that was present in the original
        CONTROL\n   transaction.  This correlates extended transactions with the original\n
        \  CONTROL transaction.  A REPORT message containing a payload MUST\n   include
        the 'Content-Type' and 'Content-Length' headers indicating\n   the payload
        MIME type [RFC2045] defined by the Control Package and\n   the length of the
        payload, respectively.\n"
      - contents:
        - "6.3.2.1.  Reporting the Status of Extended Transactions\n   On receiving
          a CONTROL message, a Control Server MUST respond within\n   'Transaction-Timeout'
          with a status code for the request, as\n   specified in Section 6.2.  If
          the processing of the command completes\n   within that time, a 200 response
          code MUST be sent.  If the command\n   does not complete within that time,
          the response code 202 MUST be\n   sent indicating that the requested command
          is still being processed\n   and the CONTROL transaction is being extended.
          \ The REPORT method is\n   then used to update and terminate the status
          of the extended\n   transaction.  The Control Server should not wait until
          the last\n   possible opportunity to make the decision of issuing a 202
          response\n   code and should ensure that it has plenty of time for the response
          to\n   arrive at the Control Client.  If it does not have time, transactions\n
          \  will be terminated (timed out) at the Control Client before\n   completion.\n
          \  A Control Server issuing a 202 response MUST ensure the message\n   contains
          a 'Timeout' message header.  This header MUST have a value\n   in seconds
          that is the amount of time the recipient of the 202\n   message MUST wait
          before assuming that there has been a problem and\n   terminating the extended
          transaction and associated state.\n   The initial REPORT message MUST contain
          a 'Seq' (Sequence) message\n   header with a value equal to '1'.  Note:
          the 'Seq' numbers at both\n   Control Client and Control Server for Framework
          messages are\n   independent.\n   All REPORT messages for an extended CONTROL
          transaction MUST contain\n   a 'Timeout' message header.  This header will
          contain a value in\n   seconds that is the amount of time the recipient
          of the REPORT\n   message MUST wait before assuming that there has been
          a problem and\n   terminating the extended transaction and associated state.
          \ On\n   receiving a REPORT message with a 'Status' header of 'update',
          the\n   Control Client MUST reset the timer for the associated extended\n
          \  CONTROL transaction to the indicated timeout period.  If the timeout\n
          \  period approaches and no intended REPORT messages have been\n   generated,
          the entity acting as a Control Framework UAS for the\n   interaction MUST
          generate a REPORT message containing, as defined in\n   this paragraph,
          a 'Status' header of 'update' with no associated\n   payload.  Such a message
          acts as a timeout refresh and in no way\n   impacts the extended transaction
          because no message body or semantics\n   are permitted.  It is RECOMMENDED
          that a minimum value of 10 and a\n   maximum value of 15 seconds be used
          for the value of the 'Timeout'\n   message header.  It is also RECOMMENDED
          that a Control Server refresh\n   the timeout period of the CONTROL transaction
          at an interval that is\n   not too close to the expiry time.  A value of
          80% of the timeout\n   period could be used.  For example, if the timeout
          period is 10\n   seconds, the Server would refresh the transaction after
          8 seconds.\n   Subsequent REPORT messages that provide additional information\n
          \  relating to the extended CONTROL transaction MUST also include and\n
          \  increment by 1 the 'Seq' header value.  A REPORT message received\n   that
          has not been incremented by 1 MUST be responded to with a 406\n   response
          and the extended transaction MUST be considered terminated.\n   On receiving
          a 406 response, the extended transaction MUST be\n   terminated.  REPORT
          messages MUST also include a 'Status' header with\n   a value of 'update'.
          \ These REPORT messages sent to update the\n   extended CONTROL transaction
          status MAY contain a message body, as\n   defined by individual Control
          Packages and specified in Section 8.5.\n   A REPORT message sent updating
          the extended transaction also acts as\n   a timeout refresh, as described
          earlier in this section.  This will\n   result in a transaction timeout
          period at the initiator of the\n   original CONTROL request being reset
          to the interval contained in the\n   'Timeout' message header.\n   When
          all processing for an extended CONTROL transaction has taken\n   place,
          the entity acting as a Control Server MUST send a terminating\n   REPORT
          message.  The terminating REPORT message MUST increment the\n   value in
          the 'Seq' message header by the value of '1' from the\n   previous REPORT
          message.  It MUST also include a 'Status' header with\n   a value of 'terminate'
          and MAY contain a message body.  It MUST also\n   contain a 'Timeout' message
          header with a valid value.  The inclusion\n   of the 'Timeout' header is
          for consistency, and its value is ignored.\n   A Control Framework UAC can
          then clean up any pending state\n   associated with the original CONTROL
          transaction.\n"
        title: 6.3.2.1.  Reporting the Status of Extended Transactions
      title: 6.3.2.  REPORT Transactions
    - contents:
      - "6.3.3.  K-ALIVE Transactions\n   The protocol defined in this document may
        be used in various network\n   architectures.  This includes a wide range
        of deployments where the\n   clients could be co-located in a secured, private
        domain, or spread\n   across disparate domains that require traversal of devices
        such as\n   Network Address Translators (NATs) and firewalls.  A keep-alive\n
        \  mechanism enables the Control Channel to be kept active during times\n
        \  of inactivity.  This is because many firewalls have a timeout period\n
        \  after which connections are closed.  This mechanism also provides the\n
        \  ability for application-level failure detection.  It should be noted\n
        \  that the following procedures apply only to the Control Channel being\n
        \  created.  For details relating to the SIP keep-alive mechanism,\n   implementers
        should seek guidance from SIP Outbound [RFC5626].\n   The following keep-alive
        procedures MUST be implemented.  Specific\n   deployments MAY choose not to
        use the keep-alive mechanism if both\n   entities are in a co-located domain.
        \ Note that choosing not to use\n   the keep-alive mechanism defined in this
        section, even when in a co-\n   located architecture, will reduce the ability
        to detect application-\n   level errors, especially during long periods of
        inactivity.\n   Once the SIP INVITE dialog usage has been established and
        the\n   underlying Control Channel has been set up, including the initial\n
        \  correlation handshake using SYNC as discussed in Section 6, both\n   entities
        acting in the active and passive roles, as defined in\n   COMEDIA [RFC4145],
        MUST start a keep-alive timer equal to the value\n   negotiated during the
        Control Channel SYNC request/response exchange.\n   This is the value from
        the 'Keep-Alive' header in seconds.\n"
      - contents:
        - "6.3.3.1.  Behavior for an Entity in an Active Role\n   When in an active
          role, a K-ALIVE message MUST be generated before\n   the local keep-alive
          timer fires.  An active entity is free to send\n   the K-ALIVE message whenever
          it chooses.  It is RECOMMENDED for the\n   entity to issue a K-ALIVE message
          after 80% of the local keep-alive\n   timer.  On receiving a 200 OK Control
          Framework message for the\n   K-ALIVE request, the active entity MUST reset
          the local keep-alive\n   timer.  If no 200 OK response is received to the
          K-ALIVE message, or\n   a transport-level problem is detected by some other
          means, before the\n   local keep-alive timer fires, the active entity MAY
          use COMEDIA re-\n   negotiation procedures to recover the connection.  Otherwise,
          the\n   active entity MUST tear down the SIP INVITE dialog and recover the\n
          \  associated Control Channel resources.\n"
        title: 6.3.3.1.  Behavior for an Entity in an Active Role
      - contents:
        - "6.3.3.2.  Behavior for an Entity in a Passive Role\n   When acting as a
          passive entity, a K-ALIVE message must be received\n   before the local
          keep-alive timer fires.  When a K-ALIVE request is\n   received, the passive
          entity MUST generate a 200 OK Control Framework\n   response and reset the
          local keep-alive timer.  No other Control\n   Framework response is valid.
          \ If no K-ALIVE message is received (or a\n   transport level problem is
          detected by some other means) before the\n   local keep-alive timer fires,
          the passive entity MUST tear down the\n   SIP INVITE dialog and recover
          the associated Control Channel\n   resources.\n"
        title: 6.3.3.2.  Behavior for an Entity in a Passive Role
      title: 6.3.3.  K-ALIVE Transactions
    - contents:
      - "6.3.4.  SYNC Transactions\n   The initial SYNC request on a Control Channel
        is used to negotiate\n   the timeout period for the Control Channel keep-alive
        mechanism and\n   to allow clients and servers to learn the Control Packages
        that each\n   supports.  Subsequent SYNC requests MAY be used to change the
        set of\n   Control Packages that can be used on the Control Channel.\n"
      - contents:
        - "6.3.4.1.  Timeout Negotiation for the Initial SYNC Transaction\n   The
          initial SYNC request allows the timeout period for the Control\n   Channel
          keep-alive mechanism to be negotiated.  The following rules\n   MUST be
          followed for the initial SYNC request:\n   o  If the Client initiating the
          SDP offer has a COMEDIA 'setup'\n      attribute equal to active, the 'Keep-Alive'
          header MUST be\n      included in the SYNC message generated by the offerer.
          \ The value\n      of the 'Keep-Alive' header SHOULD be in the range of
          95 to 120\n      seconds (this is consistent with SIP Outbound [RFC5626]).
          \ The\n      value of the 'Keep-Alive' header MUST NOT exceed 600 seconds.
          \ The\n      client that generated the SDP \"Answer\" (the passive client)
          MUST\n      copy the 'Keep-Alive' header into the 200 response to the SYNC\n
          \     message with the same value.\n   o  If the Client initiating the SDP
          offer has a COMEDIA 'setup'\n      attribute equal to passive, the 'Keep-Alive'
          header parameter MUST\n      be included in the SYNC message generated by
          the answerer.  The\n      value of the 'Keep-Alive' header SHOULD be in
          the range of 95 to\n      120 seconds.  The client that generated the SDP
          offer (the passive\n      client) MUST copy the 'Keep-Alive' header into
          the 200 response to\n      the SYNC message with the same value.\n   o  If
          the Client initiating the SDP offer has a COMEDIA 'setup'\n      attribute
          equal to 'actpass', the 'Keep-Alive' header parameter\n      MUST be included
          in the SYNC message of the entity who is the\n      active participant in
          the SDP session.  If the client generating\n      the subsequent SDP answer
          places a value of 'active' in the\n      COMEDIA SDP 'setup' attribute,
          it will generate the SYNC request\n      and include the 'Keep-Alive' header.
          \ The value SHOULD be in the\n      range 95 to 120 seconds.  If the client
          generating the subsequent\n      SDP answer places a value of 'passive'
          in the COMEDIA 'setup'\n      attribute, the original UA making the SDP
          will generate the SYNC\n      request and include the 'Keep-Alive' header.
          \ The value SHOULD be\n      in the range 95 to 120 seconds.\n   o  If the
          initial negotiated offer/answer results in a COMEDIA\n      'setup' attribute
          equal to 'holdconn', the initial SYNC mechanism\n      will occur when the
          offer/answer exchange is updated and the\n      active/passive roles are
          resolved using COMEDIA.\n   The previous steps ensure that the entity initiating
          the Control\n   Channel connection is always the one specifying the keep-alive\n
          \  timeout period.  It will always be the initiator of the connection\n
          \  who generates the K-ALIVE messages.\n   Once negotiated, the keep-alive
          timeout applies for the remainder of\n   the Control Framework session.
          \ Any subsequent SYNC messages\n   generated in the Control Channel do not
          impact the negotiated keep-\n   alive property of the session.  The 'Keep-Alive'
          header MUST NOT be\n   included in subsequent SYNC messages, and if it is
          received, it MUST\n   be ignored.\n"
        title: 6.3.4.1.  Timeout Negotiation for the Initial SYNC Transaction
      - contents:
        - "6.3.4.2.  Package Negotiation\n   As part of the SYNC message exchange,
          a client generating the request\n   MUST include a 'Packages' header, as
          defined in Section 9.  The\n   'Packages' header contains a list of all
          Control Framework packages\n   that can be supported within this control
          session, from the\n   perspective of the client creating the SYNC message.
          \ All Channel\n   Framework package names MUST be tokens that adhere to
          the rules set\n   out in Section 8.  The 'Packages' header of the initial
          SYNC message\n   MUST contain at least one value.\n   A server receiving
          the initial SYNC request MUST examine the contents\n   of the 'Packages'
          header.  If the server supports at least one of the\n   packages listed
          in the request, it MUST respond with a 200 response\n   code.  The response
          MUST contain a 'Packages' header that lists the\n   supported packages that
          are in common with those from the 'Packages'\n   header of the request (either
          all or a subset).  This list forms a\n   common set of Control Packages
          that are supported by both parties.\n   Any Control Packages supported by
          the server that are not listed in\n   the 'Packages' header of the SYNC
          request MAY be placed in the\n   'Supported' header of the response.  This
          provides a hint to the\n   client that generated the SYNC request about
          additional packages\n   supported by the server.\n   If no common packages
          are supported by the server receiving the SYNC\n   message, it MUST respond
          with a 422 error response code.  The error\n   response MUST contain a 'Supported'
          header indicating the packages\n   that are supported.  The initiating client
          can then choose to either\n   re-submit a new SYNC message based on the
          422 response or consider\n   the interaction a failure.  This would lead
          to termination of the\n   associated SIP INVITE dialog by sending a SIP
          BYE request, as per\n   [RFC3261].\n   Once the initial SYNC transaction
          is completed, either client MAY\n   choose to send a subsequent new SYNC
          message to re-negotiate the\n   packages that are supported within the Control
          Channel.  A new SYNC\n   message whose 'Packages' header has different values
          from the\n   previous SYNC message can effectively add and delete the packages\n
          \  used in the Control Channel.  If a client receiving a subsequent SYNC\n
          \  message does not wish to change the set of packages, it MUST respond\n
          \  with a 421 Control Framework response code.  Subsequent SYNC messages\n
          \  MUST NOT change the value of the 'Dialog-ID' and 'Keep-Alive' Control\n
          \  Framework headers that appeared in the original SYNC negotiation.\n   An
          entity MAY honor Control Framework commands relating to a Control\n   Package
          it no longer supports after package re-negotiation.  When the\n   entity
          does not wish to honor such commands, it MUST respond to the\n   request
          with a 420 response.\n"
        title: 6.3.4.2.  Package Negotiation
      title: 6.3.4.  SYNC Transactions
    title: 6.3.  Transaction Processing
  title: 6.  Control Framework Interactions
- contents:
  - "7.  Response Code Descriptions\n   The following response codes are defined for
    transaction responses to\n   methods defined in Section 6.1.  All response codes
    in this section\n   MUST be supported and can be used in response to both CONTROL
    and\n   REPORT messages except that a 202 MUST NOT be generated in response\n
    \  to a REPORT message.\n   Note that these response codes apply to Framework
    Transactions only.\n   Success or error indications for Control Commands MUST
    be treated as\n   the result of a Control Command and returned in either a 200
    response\n   or REPORT message.\n"
  - contents:
    - "7.1.  200 Response Code\n   The framework protocol transaction completed successfully.\n"
    title: 7.1.  200 Response Code
  - contents:
    - "7.2.  202 Response Code\n   The framework protocol transaction completed successfully
      and\n   additional information will be provided at a later time through the\n
      \  REPORT mechanism defined in Section 6.3.2.\n"
    title: 7.2.  202 Response Code
  - contents:
    - "7.3.  400 Response Code\n   The request was syntactically incorrect.\n"
    title: 7.3.  400 Response Code
  - contents:
    - "7.4.  403 Response Code\n   The server understood the request, but is refusing
      to fulfill it.\n   The client SHOULD NOT repeat the request.\n"
    title: 7.4.  403 Response Code
  - contents:
    - "7.5.  405 Response Code\n   Method not allowed.  The primitive is not supported.\n"
    title: 7.5.  405 Response Code
  - contents:
    - "7.6.  406 Response Code\n   Message out of sequence.\n"
    title: 7.6.  406 Response Code
  - contents:
    - "7.7.  420 Response Code\n   Intended target of the request is for a Control
      Package that is not\n   valid for the current session.\n"
    title: 7.7.  420 Response Code
  - contents:
    - "7.8.  421 Response Code\n   Recipient does not wish to re-negotiate Control
      Packages at this\n   moment in time.\n"
    title: 7.8.  421 Response Code
  - contents:
    - "7.9.  422 Response Code\n   Recipient does not support any Control Packages
      listed in the SYNC\n   message.\n"
    title: 7.9.  422 Response Code
  - contents:
    - "7.10.  423 Response Code\n   Recipient has an existing transaction with the
      same transaction ID.\n"
    title: 7.10.  423 Response Code
  - contents:
    - "7.11.  481 Response Code\n   The transaction of the request does not exist.
      \ In response to a SYNC\n   request, the 481 response code indicates that the
      corresponding SIP\n   INVITE dialog usage does not exist.\n"
    title: 7.11.  481 Response Code
  - contents:
    - "7.12.  500 Response Code\n   The recipient does not understand the request.\n"
    title: 7.12.  500 Response Code
  title: 7.  Response Code Descriptions
- contents:
  - "8.  Control Packages\n   Control Packages specify behavior that extends the capability
    defined\n   in this document.  Control Packages MUST NOT weaken statements of\n
    \  \"MUST\" and \"SHOULD\" strength in this document.  A Control Package MAY\n
    \  strengthen \"SHOULD\", \"RECOMMENDED\", and \"MAY\" to \"MUST\" if justified\n
    \  by the specific usage of the framework.\n   In addition to the usual sections
    expected in Standards-Track RFCs\n   and SIP extension documents, authors of Control
    Packages need to\n   address each of the issues detailed in the following sub-sections.\n
    \  The following sections MUST be used as a template and included\n   appropriately
    in all Control-Package specifications.  To reiterate,\n   the following sections
    do not solely form the basis of all Control-\n   Package specifications but are
    included as a minimum to provide\n   essential package-level information.  A Control-Package
    specification\n   can take any valid form it wishes as long as it includes at
    least the\n   following information listed in this section.\n"
  - contents:
    - "8.1.  Control Package Name\n   This section MUST be present in all extensions
      to this document and\n   provides a token name for the Control Package.  The
      section MUST\n   include information that appears in the IANA registration of
      the\n   token.  Information on registering Control Package tokens is\n   contained
      in Section 13.\n"
    title: 8.1.  Control Package Name
  - contents:
    - "8.2.  Framework Message Usage\n   The Control Framework defines a number of
      message primitives that can\n   be used to exchange commands and information.
      \ There are no\n   limitations restricting the directionality of messages passed
      down a\n   Control Channel.  This section of a Control Package document MUST\n
      \  explicitly detail the types of Framework messages (Methods) that can\n   be
      used as well as provide an indication of directionality between\n   entities.
      \ This will include which role type is allowed to initiate a\n   request type.\n"
    title: 8.2.  Framework Message Usage
  - contents:
    - "8.3.  Common XML Support\n   This optional section is only included in a Control
      Package if the\n   attributes for media dialog or conference reference are required,
      as\n   defined and discussed in Appendix A.1.  The Control Package will make\n
      \  strong statements (using language from RFC 2119 [RFC2119]) if the XML\n   schema
      defined in Appendix A.1 is to be supported.  If only part of\n   the schema
      is required (for example, just 'connectionid' or\n   'conferenceid'), the Control
      Package will make equally strong\n   statements (using language from RFC 2119
      [RFC2119]).\n"
    title: 8.3.  Common XML Support
  - contents:
    - "8.4.  CONTROL Message Bodies\n   This mandatory section of a Control Package
      defines the control body\n   that can be contained within a CONTROL command
      request, as defined in\n   Section 6, or that no Control Package body is required.
      \ This section\n   MUST indicate the location of detailed syntax definitions
      and\n   semantics for the appropriate MIME [RFC2045] body type that apply to\n
      \  a CONTROL command request and, optionally, the associated 200\n   response.
      \ For Control Packages that do not have a Control Package\n   body, making such
      a statement satisfies the \"MUST\" strength of this\n   section in the Control
      Package document.\n"
    title: 8.4.  CONTROL Message Bodies
  - contents:
    - "8.5.  REPORT Message Bodies\n   This mandatory section of a Control Package
      defines the REPORT body\n   that can be contained within a REPORT command request,
      as defined in\n   Section 6, or that no report package body is required.  This
      section\n   MUST indicate the location of detailed syntax definitions and\n
      \  semantics for the appropriate MIME [RFC2045] body type.  It should be\n   noted
      that the Control Framework specification does allow for\n   payloads to exist
      in 200 responses to CONTROL messages (as defined in\n   this document).  An
      entity that is prepared to receive a payload type\n   in a REPORT message MUST
      also be prepared to receive the same payload\n   in a 200 response to a CONTROL
      message.  For Control Packages that do\n   not have a Control Package body,
      stating such satisfies the \"MUST\"\n   strength of this section in the Control
      Package document.\n"
    title: 8.5.  REPORT Message Bodies
  - contents:
    - "8.6.  Audit\n   Auditing of various Control Package properties such as capabilities\n
      \  and resources (package-level meta-information) is extremely useful.\n   Such
      meta-data usually has no direct impact on Control Framework\n   interactions
      but allows for contextual information to be learnt.\n   Control Packages are
      encouraged to make use of Control Framework\n   interactions to provide relevant
      package audit information.\n   This section SHOULD include the following information:\n
      \  o  If an auditing capability is available in this package.\n   o  How auditing
      information is triggered (for example, using a\n      Control Framework CONTROL
      message) and delivered (for example, in\n      a Control Framework 200 response).\n
      \  o  The location of the audit query and response format for the\n      payload
      (for example, it could be a separate XML schema OR part of\n      a larger XML
      schema).\n"
    title: 8.6.  Audit
  - contents:
    - "8.7.  Examples\n   It is strongly RECOMMENDED that Control Packages provide
      a range of\n   message flows that represent common flows using the package and
      this\n   framework document.\n"
    title: 8.7.  Examples
  title: 8.  Control Packages
- contents:
  - '9.  Formal Syntax

    '
  - contents:
    - "9.1.  Control Framework Formal Syntax\n   The Control Framework interactions
      use the UTF-8 transformation\n   format as defined in [RFC3629].  The syntax
      in this section uses the\n   Augmented Backus-Naur Form (ABNF) as defined in
      [RFC5234] including\n   types 'DIGIT', 'CRLF', and 'ALPHA'.\n   Unless otherwise
      stated in the definition of a particular header\n   field, field values, parameter
      names, and parameter values are not\n   case-sensitive.\n  control-req-or-resp
      = control-request / control-response\n  control-request = control-req-start
      *headers CRLF [control-content]\n  control-response = control-resp-start *headers
      CRLF [control-content]\n  control-req-start  = pCFW SP trans-id SP method CRLF\n
      \ control-resp-start = pCFW SP trans-id SP status-code CRLF\n  pCFW = %x43.46.57;
      CFW in caps\n  trans-id = alpha-num-token\n  method = mCONTROL / mREPORT / mSYNC
      / mK-ALIVE / other-method\n  mCONTROL = %x43.4F.4E.54.52.4F.4C ; CONTROL in
      caps\n  mREPORT = %x52.45.50.4F.52.54     ; REPORT in caps\n  mSYNC = %x53.59.4E.43
      \            ; SYNC in caps\n  mK-ALIVE = %x4B.2D.41.4C.49.56.45 ; K-ALIVE in
      caps\n  other-method = 1*UPALPHA\n  status-code = 3*DIGIT ; any code defined
      in this and other documents\n  headers = header-name CRLF\n  header-name = (Content-Length\n
      \  /Content-Type\n   /Control-Package\n   /Status\n   /Seq\n   /Timeout\n   /Dialog-ID\n
      \  /Packages\n   /Supported\n   /Keep-alive\n   /ext-header)\n  Content-Length
      = \"Content-Length:\" SP 1*DIGIT\n  Control-Package = \"Control-Package:\" SP
      1*alpha-num-token\n  Status = \"Status:\" SP (\"update\" / \"terminate\" )\n
      \ Timeout = \"Timeout:\" SP 1*DIGIT\n  Seq = \"Seq:\" SP 1*DIGIT\n  Dialog-ID
      = \"Dialog-ID:\" SP dialog-id-string\n  Packages = \"Packages:\" SP package-name
      *(COMMA package-name)\n  Supported = \"Supported:\" SP supprtd-alphanum *(COMMA
      supprtd-alphanum)\n  Keep-alive = \"Keep-Alive:\" SP kalive-seconds\n  dialog-id-string
      = alpha-num-token\n  package-name = alpha-num-token\n  supprtd-alphanum = alpha-num-token\n
      \ kalive-seconds = 1*DIGIT\n  alpha-num-token = ALPHANUM  3*31alpha-num-tokent-char\n
      \ alpha-num-tokent-char = ALPHANUM / \".\" / \"-\" / \"+\" / \"%\" / \"=\" /
      \"/\"\n  control-content = *OCTET\n  Content-Type = \"Content-Type:\" SP media-type\n
      \ media-type = type \"/\" subtype *(SP \";\" gen-param )\n  type = token    ;
      Section 4.2 of RFC 4288\n  subtype = token ; Section 4.2 of RFC 4288\n  gen-param
      = pname [ \"=\" pval ]\n  pname = token\n  pval  = token / quoted-string\n  token
      = 1*(%x21 / %x23-27 / %x2A-2B / %x2D-2E\n             / %x30-39 / %x41-5A /
      %x5E-7E)\n  quoted-string = DQUOTE *(qdtext / qd-esc) DQUOTE\n  qdtext = SP
      / HTAB / %x21 / %x23-5B / %x5D-7E\n              / UTF8-NONASCII\n  qd-esc =
      (BACKSLASH BACKSLASH) / (BACKSLASH DQUOTE)\n  BACKSLASH = \"\\\"\n  UPALPHA
      \ = %x41-5A\n  ALPHANUM = ALPHA / DIGIT\n  ext-header = hname \":\" SP hval
      CRLF\n  hname = ALPHA *token\n  hval = utf8text\n  utf8text = *(HTAB / %x20-7E
      / UTF8-NONASCII)\n  UTF8-NONASCII = UTF8-2 / UTF8-3 / UTF8-4 ; From RFC 3629\n
      \  The following table details a summary of the headers that can be\n   contained
      in Control Framework interactions.\n         Header field        Where    CONTROL
      REPORT SYNC  K-ALIVE\n         ___________________________________________________________\n
      \        Content-Length                  o      o      -      -\n         Control-Package
      \      R         m      -      -      -\n         Seq                             -
      \     m      -      -\n         Status                R         -      m      -
      \     -\n         Timeout               R         -      m      -      -\n         Timeout
      \             202        -      m      -      -\n         Dialog-ID             R
      \        -      -      m      -\n         Packages                        -
      \     -      m      -\n         Supported             r         -      -      o
      \     -\n         Keep-Alive            R         -      -      o      -\n         Content-Type
      \                   o      o      -      -\n       Table 1: Summary of Headers
      in Control Framework Interactions\n   The notation used in Table 1 is as follows:\n
      R: header field may only appear in requests.\n r: header field may only appear
      in responses.\n 2xx, 4xx, etc.: response codes with which the header field can
      be used.\n [blank]: header field may appear in either requests or responses.\n
      m: header field is mandatory.\n o: header field is optional.\n -: header field
      is not applicable (ignored if present).\n"
    title: 9.1.  Control Framework Formal Syntax
  - contents:
    - "9.2.  Control Framework Dialog Identifier SDP Attribute\n   This specification
      defines a new media-level value attribute:\n   'cfw-id'.  Its formatting in
      SDP is described by the following ABNF\n   [RFC5234].\n            cfw-dialog-id
      = \"a=cfw-id:\" 1*(SP cfw-id-name) CRLF\n            cfw-id-name   = token\n
      \           token         = 1*(token-char)\n            token-char    = %x21
      / %x23-27 / %x2A-2B / %x2D-2E / %x30-39\n                            / %x41-5A
      / %x5E-7E\n   The token-char and token elements are defined in [RFC4566] but\n
      \  included here to provide support for the implementer of this SDP\n   feature.\n"
    title: 9.2.  Control Framework Dialog Identifier SDP Attribute
  title: 9.  Formal Syntax
- contents:
  - "10.  Examples\n   The following examples provide an abstracted flow of Control
    Channel\n   establishment and Control Framework message exchange.  The SIP\n   signaling
    is prefixed with the token 'SIP'.  All other messages are\n   Control Framework
    interactions defined in this document.\n   In this example, the Control Client
    establishes a Control Channel,\n   SYNCs with the Control Server, and issues a
    CONTROL request that\n   can't be completed within the 'Transaction-Timeout',
    so the Control\n   Server returns a 202 response code to extend the transaction.
    \ The\n   Control Server then follows with REPORTs until the requested action\n
    \  has been completed.  The SIP INVITE dialog is then terminated.\n            Control
    Client                                Control Server\n                   |                                             |\n
    \                  |       (1) SIP INVITE                        |\n                   |
    \ ---------------------------------------->  |\n                   |                                             |\n
    \                  |       (2) SIP 200                           |\n                   |
    \ <---------------------------------------   |\n                   |                                             |\n
    \                  |       (3) SIP ACK                           |\n                   |
    \ ---------------------------------------->  |\n                   |                                             |\n
    \                  |==>=======================================>==|\n                   |
    \        Control Channel Established         |\n                   |==>=======================================>==|\n
    \                  |                                             |\n                   |
    \      (4) SYNC                              |\n                   |  ---------------------------------------->
    \ |\n                   |                                             |\n                   |
    \      (5) 200                               |\n                   |  <---------------------------------------
    \  |\n                   |                                             |\n                   |
    \      (6) CONTROL                           |\n                   |  ---------------------------------------->
    \ |\n                   |                                             |\n   (1)
    \  Control Client-->Control Server (SIP): INVITE\n         sip:control-server@example.com\n
    \  INVITE sip:control-server@example.com SIP/2.0\n   To: <sip:control-server@example.com>\n
    \  From: <sip:control-client@example.com>;tag=8937498\n   Via: SIP/2.0/UDP client.example.com;branch=z9hG4bK123\n
    \  CSeq: 1 INVITE\n   Max-Forwards: 70\n   Call-ID: 893jhoeihjr8392@example.com\n
    \  Contact: <sip:control-client@pc1.example.com>\n   Content-Type: application/sdp\n
    \  Content-Length: 206\n   v=0\n   o=originator 2890844526 2890842808 IN IP4 controller.example.com\n
    \  s=-\n   c=IN IP4 control-client.example.com\n   m=application 49153 TCP cfw\n
    \  a=setup:active\n   a=connection:new\n   a=cfw-id:fndskuhHKsd783hjdla\n   (2)
    \  Control Server-->Control Client (SIP): 200 OK\n"
  - 'SIP/2.0 200 OK

    '
  - 'To: <sip:control-server@example.com>;tag=023983774

    '
  - 'From: <sip:control-client@example.com>;tag=8937498

    '
  - 'Via: SIP/2.0/UDP client.example.com;branch=z9hG4bK123;received=192.0.2.5

    '
  - 'CSeq: 1 INVITE

    '
  - 'Call-ID: 893jhoeihjr8392@example.com

    '
  - 'Contact: <sip:control-server@pc2.example.com>

    '
  - 'Content-Type: application/sdp

    '
  - 'Content-Length: 203

    '
  - 'v=0

    '
  - 'o=responder 2890844600 2890842900 IN IP4 controller.example.com

    '
  - 's=-

    '
  - 'c=IN IP4 control-server.example.com

    '
  - 'm=application 49153 TCP cfw

    '
  - 'a=setup:passive

    '
  - 'a=connection:new

    '
  - "a=cfw-id:7JeDi23i7eiysi32\n   (3)   Control Client-->Control Server (SIP): ACK\n
    \  (4)   Control Client opens a TCP connection to the Control Server.\n         The
    connection can now be used to exchange Control Framework\n         messages.  Control
    Client-->Control Server (Control Framework\n         message): SYNC.\n   CFW 8djae7khauj
    SYNC\n   Dialog-ID: fndskuhHKsd783hjdla\n   Keep-Alive: 100\n   Packages: msc-ivr-basic/1.0\n
    \  (5)   Control Server-->Control Client (Control Framework message):\n         200.\n
    \  CFW 8djae7khauj 200\n   Keep-Alive: 100\n   Packages: msc-ivr-basic/1.0\n   Supported:
    msc-ivr-vxml/1.0,msc-conf-audio/1.0\n   (6)   Once the SYNC process has completed,
    the connection can now be\n         used to exchange Control Framework messages.
    \ Control\n         Client-->Control Server (Control Framework message): CONTROL.\n
    \  CFW i387yeiqyiq CONTROL\n   Control-Package: <package-name>\n   Content-Type:
    example_content/example_content\n   Content-Length: 11\n   <XML BLOB/>\n   (7)
    \  Control Server-->Control Client (Control Framework message):\n         202.\n
    \  CFW i387yeiqyiq 202\n   Timeout: 10\n   (8)   Control Server-->Control Client
    (Control Framework message):\n         REPORT.\n   CFW i387yeiqyiq REPORT\n   Seq:
    1\n   Status: update\n   Timeout: 10\n   (9)   Control Client-->Control Server
    (Control Framework message):\n         200.\n   CFW i387yeiqyiq 200\n   Seq: 1\n
    \  (10)  Control Server-->Control Client (Control Framework message):\n         REPORT.\n
    \  CFW i387yeiqyiq REPORT\n   Seq: 2\n   Status: update\n   Timeout: 10\n   Content-Type:
    example_content/example_content\n   Content-Length: 11\n   <XML BLOB/>\n   (11)
    \ Control Client-->Control Server (Control Framework message):\n         200.\n
    \  CFW i387yeiqyiq 200\n   Seq: 2\n   (12)  Control Server-->Control Client (Control
    Framework message):\n         REPORT.\n   CFW i387yeiqyiq REPORT\n   Seq: 3\n
    \  Status: terminate\n   Timeout: 10\n   Content-Type: example_content/example_content\n
    \  Content-Length: 11\n   <XML BLOB/>\n   (13)  Control Client-->Control Server
    (Control Framework message):\n         200.\n   CFW i387yeiqyiq 200\n   Seq: 3\n
    \  (14)  Control Client-->Control Server (SIP): BYE\n   BYE sip:control-server@pc2.example.com
    SIP/2.0\n   To: <sip:control-server@example.com>;tag=023983774\n   From: <sip:client@example.com>;tag=8937498\n
    \  Via: SIP/2.0/UDP client.example.com;branch=z9hG4bK234\n   CSeq: 2 BYE\n   Max-Forwards:
    70\n   Call-ID: 893jhoeihjr8392@example.com\n   Contact: <sip:control-client@pc1.example.com>\n
    \  Content-Length: 0\n   (15)  Control Server-->Control Client (SIP): 200 OK\n"
  - 'SIP/2.0 200 OK

    '
  - 'To: <sip:control-server@example.com>;tag=023983774

    '
  - 'From: <sip:client@example.com>;tag=8937498

    '
  - 'Via: SIP/2.0/UDP client.example.com;branch=z9hG4bK234;received=192.0.2.5

    '
  - 'CSeq: 2 BYE

    '
  - 'Call-ID: 893jhoeihjr8392@example.com

    '
  - 'Contact: <sip:control-server@pc1.example.com>

    '
  - 'Content-Length: 0

    '
  title: 10.  Examples
- contents:
  - "11.  Extensibility\n   The Media Control Channel Framework was designed to be
    only minimally\n   extensible.  New methods, header fields, and status codes can
    be\n   defined in Standards-Track RFCs.  The Media Control Channel Framework\n
    \  does not contain a version number or any negotiation mechanism to\n   require
    or discover new features.  If an extension is specified in\n   the future that
    requires negotiation, the specification will need to\n   describe how the extension
    is to be negotiated in the encapsulating\n   signaling protocol.  If a non-interoperable
    update or extension\n   occurs in the future, it will be treated as a new protocol,
    and it\n   MUST describe how its use will be signaled.\n   In order to allow extension
    header fields without breaking\n   interoperability, if a Media Control Channel
    device receives a\n   request or response containing a header field that it does
    not\n   understand, it MUST ignore the header field and process the request\n
    \  or response as if the header field was not present.  If a Media\n   Control
    Channel device receives a request with an unknown method, it\n   MUST return a
    500 response.\n"
  title: 11.  Extensibility
- contents:
  - "12.  Security Considerations\n   The Channel Framework provides confidentiality
    and integrity for the\n   messages it transfers.  It also provides assurances
    that the\n   connected host is the host that it meant to connect to and that the\n
    \  connection has not been hijacked, as discussed in the remainder of\n   this
    section.\n   In design, the Channel Framework complies with the security-related\n
    \  requirements documented in \"Media Server Control Protocol\n   Requirements\"
    [RFC5167] -- more specifically, REQ-MCP-11, REQ-MCP-12,\n   REQ-MCP-13, and REQ-MCP-14.
    \ Specific security measures employed by\n   the Channel Framework are summarized
    in the following sub-sections.\n"
  - contents:
    - "12.1.  Session Establishment\n   Channel Framework sessions are established
      as media sessions\n   described by SDP within the context of a SIP INVITE dialog.
      \ In order\n   to ensure secure rendezvous between Control Framework clients
      and\n   servers, the Media Channel Control Framework should make full use of\n
      \  mechanisms provided by SIP.  The use of the 'cfw-id' SDP attribute\n   results
      in important session information being carried across the SIP\n   network.  For
      this reason, SIP clients using this specification MUST\n   use appropriate security
      mechanisms, such as TLS [RFC5246] and SMIME\n   [RFC5751], when deployed in
      open networks.\n"
    title: 12.1.  Session Establishment
  - contents:
    - "12.2.  Transport-Level Protection\n   When using only TCP connections, the
      Channel Framework security is\n   weak.  Although the Channel Framework requires
      the ability to protect\n   this exchange, there is no guarantee that the protection
      will be used\n   all the time.  If such protection is not used, anyone can see
      data\n   exchanges.\n   Sensitive data, such as private and financial data,
      is carried over\n   the Control Framework channel.  Clients and servers must
      be properly\n   authenticated/authorized and the Control Channel must permit
      the use\n   of confidentiality, replay protection, and integrity protection
      for\n   the data.  To ensure Control Channel protection, Control Framework\n
      \  clients and servers MUST support TLS and SHOULD use it by default\n   unless
      alternative Control Channel protection is used or a protected\n   environment
      is guaranteed by the administrator of the network.\n   Alternative Control Channel
      protection MAY be used if desired (e.g.,\n   IPsec [RFC5246]).\n   TLS is used
      to authenticate devices and to provide integrity, replay\n   protection, and
      confidentiality for the header fields being\n   transported on the Control Channel.
      \ Channel Framework elements MUST\n   implement TLS and MUST also implement
      the TLS ClientExtendedHello\n   extended hello information for server name indication
      as described in\n   [RFC5246].  A TLS cipher-suite of TLS_RSA_WITH_AES_128_CBC_SHA\n
      \  [RFC3261] MUST be supported.  Other cipher-suites MAY also be\n   supported.\n
      \  When a TLS client establishes a connection with a server, it is\n   presented
      with the server's X.509 certificate.  Authentication\n   proceeds as described
      in Section 7.3 (\"Client Behavior\") of RFC 5922\n   [RFC5922].\n   A TLS server
      conformant to this specification MUST ask for a client\n   certificate; if the
      client possesses a certificate, it will be\n   presented to the server for mutual
      authentication, and authentication\n   proceeds as described in Section 7.4
      (\"Server Behavior\") of RFC 5922\n   [RFC5922].\n"
    title: 12.2.  Transport-Level Protection
  - contents:
    - "12.3.  Control Channel Policy Management\n   This specification permits the
      establishment of a dedicated Control\n   Channel using SIP.  It is also permitted
      for entities to create\n   multiple channels for the purpose of failover and
      redundancy.  As a\n   general solution, the ability for multiple entities to
      create\n   connections and have access to resources could be the cause of\n
      \  potential conflict in shared environments.  It should be noted that\n   this
      document does not carry any specific mechanism to overcome such\n   conflicts
      but will provide a summary of how to do so.\n   It can be determined that access
      to resources and use of Control\n   Channels relate to policy.  It can be considered
      implementation and\n   deployment detail that dictates the level of policy that
      is adopted.\n   The authorization and associated policy of a Control Channel
      can be\n   linked to the authentication mechanisms described in this section.\n
      \  For example, strictly authenticating a Control Channel using TLS\n   authentication
      allows entities to protect resources and ensure the\n   required level of granularity.
      \ Such policy can be applied at the\n   package level or even as low as a structure
      like a conference\n   instance (Control Channel X is not permitted to issue
      commands for\n   Control Package y OR Control Channel A is not permitted to
      issue\n   commands for conference instance B).  Systems should ensure that,
      if\n   required, an appropriate policy framework is adopted to satisfy the\n
      \  requirements for implemented packages.  The most robust form of\n   policy
      can be achieved using a strong authentication mechanism such\n   as mutual TLS
      authentication on the Control Channel.  This\n   specification provides a Control
      Channel response code (403) to\n   indicate to the issuer of a command that
      it is not permitted.  The\n   403 response MUST be issued to Control Framework
      requests that are\n   not permitted under the implemented policy.  If a 403
      response is\n   received, a Control Framework client MAY choose to re-submit
      the\n   request with differing requirements or to abandon the request.  The\n
      \  403 response does not provide any additional information on the\n   policy
      failure due to the generic nature of this specification.\n   Individual Control
      Packages can supply additional information if\n   required.  The mechanism for
      providing such additional information is\n   not mandated in this specification.
      \ It should be noted that\n   additional policy requirements to those covered
      in this section might\n   be defined and applied in individual packages that
      specify a finer\n   granularity for access to resources, etc.\n"
    title: 12.3.  Control Channel Policy Management
  title: 12.  Security Considerations
- contents:
  - "13.  IANA Considerations\n   IANA has created a new registry for SIP Control
    Framework parameters.\n   The \"Media Control Channel Framework Parameters\" registry
    is a\n   container for sub-registries.  This section further introduces sub-\n
    \  registries for control packages, method names, status codes, header\n   field
    names, and port and transport protocol.\n   Additionally, Section 13.6 registers
    a new MIME type for use with\n   SDP.\n   For all registries and sub-registries
    created by this document, the\n   policy applied when creating a new registration
    is also applied when\n   changing an existing registration.\n"
  - contents:
    - "13.1.  Control Packages Registration Information\n   This specification establishes
      the Control Packages sub-registry\n   under Media Control Channel Framework
      Packages.  New parameters in\n   this sub-registry must be published in an RFC
      (either in the IETF\n   stream or Independent Submission stream), using the
      IANA policy\n   [RFC5226] \"RFC Required\".\n   As this document specifies no
      package or template-package names, the\n   initial IANA registration for Control
      Packages will be empty.  The\n   remainder of the text in this section gives
      an example of the type of\n   information to be maintained by the IANA.\n   The
      table below lists the Control Packages defined in the \"Media\n   Control Channel
      Framework\".\n    Package Name      Reference\n    ------------      ---------\n
      \   example1          [RFCXXXX]\n"
    - contents:
      - "13.1.1.  Control Package Registration Template\n      Package Name:\n          (Package
        names must conform to the syntax described in\n          Section 8.1.)\n      Published
        Specification(s):\n          (Control Packages require an RFC.)\n      Person
        & email address to contact for further information:\n"
      title: 13.1.1.  Control Package Registration Template
    title: 13.1.  Control Packages Registration Information
  - contents:
    - "13.2.  Control Framework Method Names\n   This specification establishes the
      Method Names sub-registry under\n   Media Control Channel Framework Parameters
      and initiates its\n   population as follows.  New parameters in this sub-registry
      must be\n   published in an RFC (either in the IETF stream or Independent\n
      \  Submission stream).\n    CONTROL - [RFC6230]\n    REPORT  - [RFC6230]\n    SYNC
      \   - [RFC6230]\n    K-ALIVE - [RFC6230]\n   The following information MUST
      be provided in an RFC in order to\n   register a new Control Framework method:\n
      \  o  The method name.\n   o  The RFC number in which the method is registered.\n"
    title: 13.2.  Control Framework Method Names
  - contents:
    - "13.3.  Control Framework Status Codes\n   This specification establishes the
      Status Code sub-registry under\n   Media Control Channel Framework Parameters.
      \ New parameters in this\n   sub-registry must be published in an RFC (either
      in the IETF stream\n   or Independent Submission stream).  Its initial population
      is defined\n   in Section 9.  It takes the following format:\n    Code Description
      Reference\n   The following information MUST be provided in an RFC in order
      to\n   register a new Control Framework status code:\n   o  The status code
      number.\n   o  The RFC number in which the method is registered.\n   o  A brief
      description of the status code.\n"
    title: 13.3.  Control Framework Status Codes
  - contents:
    - "13.4.  Control Framework Header Fields\n   This specification establishes the
      Header Field sub-registry under\n   Media Control Channel Framework Parameters.
      \ New parameters in this\n   sub-registry must be published in an RFC (either
      in the IETF stream\n   or Independent Submission stream).  Its initial population
      is defined\n   as follows:\n      Control-Package - [RFC6230]\n      Status
      - [RFC6230]\n      Seq - [RFC6230]\n      Timeout - [RFC6230]\n      Dialog-ID
      - [RFC6230]\n      Packages - [RFC6230]\n      Supported - [RFC6230]\n      Keep-Alive
      - [RFC6230]\n      Content-Type - [RFC6230]\n      Content-Length - [RFC6230]\n
      \  The following information MUST be provided in an RFC in order to\n   register
      a new Channel Framework header field:\n   o  The header field name.\n   o  The
      RFC number in which the method is registered.\n"
    title: 13.4.  Control Framework Header Fields
  - contents:
    - "13.5.  Control Framework Port\n   The Control Framework uses TCP port 7563,
      from the \"registered\" port\n   range.  Usage of this value is described in
      Section 4.1.\n"
    title: 13.5.  Control Framework Port
  - contents:
    - "13.6.  Media Type Registrations\n   This section describes the media types
      and names associated with\n   payload formats used by the Control Framework.
      \ The registration uses\n   the templates defined in [RFC4288].  It follows
      [RFC4855].\n"
    - contents:
      - "13.6.1.  Registration of MIME Media Type application/cfw\n    Type name:
        application\n    Subtype name: cfw\n    Required parameters: None\n    Optional
        parameters: None\n    Encoding considerations: Binary and see Section 4 of
        RFC 6230\n    Security considerations: See Section 12 of RFC 6230\n    Interoperability
        considerations:\n       Endpoints compliant to this specification must\n       use
        this MIME type.  Receivers who cannot support\n       this specification will
        reject using appropriate\n       protocol mechanism.\n    Published specification:
        RFC 6230\n    Applications that use this media type:\n       Applications
        compliant with Media Control Channels.\n     Additional Information:\n       Magic
        number(s): (none)\n       File extension(s): (none)\n       Macintosh file
        type code(s): (none)\n    Person & email address to contact for further information:\n
        \      Chris Boulton <chris@ns-technologies.com>\n    Intended usage: COMMON\n
        \   Restrictions on usage:\n       Should be used only in conjunction with
        this specification,\n       RFC 6230.\n    Author: Chris Boulton\n    Change
        controller:\n       IETF MEDIACTRL working group, delegated from the IESG.\n"
      title: 13.6.1.  Registration of MIME Media Type application/cfw
    - contents:
      - "13.6.2.  Registration of MIME Media Type application/\n         framework-attributes+xml\n
        \   Type name:  application\n    Subtype name:  framework-attributes+xml\n
        \   Required parameters:  (none)\n    Optional parameters: Same as charset
        parameter of application/xml as\n       specified in RFC 3023 [RFC3023].\n
        \   Encoding considerations:  Same as encoding considerations of\n       application/xml
        as specified in RFC 3023 [RFC3023].\n    Security considerations:  No known
        security considerations outside\n       of those provided by core Media Control
        Channel Framework.\n    Interoperability considerations:  This content type
        provides common\n       constructs for related Media Control Channel packages.\n
        \   Published specification:  RFC 6230\n    Applications that use this media
        type:  Implementations of\n       appropriate Media Control Channel packages.\n
        \   Additional information:\n       Magic number(s): (none)\n       File extension(s):
        (none)\n       Macintosh file type code(s): (none)\n    Person & email address
        to contact for further information:\n       Chris Boulton <chris@ns-technologies.com>\n
        \   Intended usage:  LIMITED USE\n    Author/Change controller:  The IETF\n
        \   Other information:  None.\n"
      title: 13.6.2.  Registration of MIME Media Type application/
    title: 13.6.  Media Type Registrations
  - contents:
    - "13.7.  'cfw-id' SDP Attribute\n   Contact name:          Chris Boulton <chris@ns-technologies.com>\n
      \  Attribute name:        \"cfw-id\".\n   Type of attribute      Media level.\n
      \  Subject to charset:    Not.\n   Purpose of attribute:  The 'cfw-id' attribute
      indicates an\n      identifier that can be used to correlate the Control Channel
      with\n      the SIP INVITE dialog used to negotiate it, when the attribute\n
      \     value is used within the Control Channel.\n   Allowed attribute values:
      \ A token.\n"
    title: 13.7.  'cfw-id' SDP Attribute
  - contents:
    - "13.8.  URN Sub-Namespace for\n       urn:ietf:params:xml:ns:control:framework-attributes\n
      \  IANA has registered a new XML namespace,\n   \"urn:ietf:params:xml:ns:control:framework-attributes\",
      per the\n   guidelines in RFC 3688 [RFC3688].\n  URI: urn:ietf:params:xml:ns:control:framework-attributes\n
      \ Registrant Contact: IETF MEDIACTRL working group <mediactrl@ietf.org>,\n     Chris
      Boulton <chris@ns-technologies.com>.\n  XML:\n     BEGIN\n     <?xml version=\"1.0\"?>\n
      \    <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n         \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n
      \     <html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n       <head>\n
      \       <title>Media Control Channel attributes</title>\n       </head>\n       <body>\n
      \       <h1>Namespace for Media Control Channel attributes</h1>\n        <h2>urn:ietf:params:xml:ns:control:framework-attributes</h2>\n
      \         <p>See <a href=\"http://www.rfc-editor.org/rfc/rfc6230.txt\">\n             RFC
      6230</a>.</p>\n       </body>\n      </html>\n     END\n"
    title: 13.8.  URN Sub-Namespace for
  - contents:
    - "13.9.  XML Schema Registration\n   This section registers an XML schema as
      per the guidelines in RFC\n   3688 [RFC3688].\n  URI:  urn:ietf:params:xml:ns:control:framework-attributes\n
      \ Registrant Contact: IETF MEDIACTRL working group <mediactrl@ietf.org>,\n     Chris
      Boulton <chris@ns-technologies.com>.\n  Schema:  The XML for this schema can
      be found in Appendix A.1 of this\n     document.\n"
    title: 13.9.  XML Schema Registration
  title: 13.  IANA Considerations
- contents:
  - "14.  Contributors\n   Asher Shiratzky from Radvision provided valuable support
    and\n   contributions to the early versions of this document.\n"
  title: 14.  Contributors
- contents:
  - "15.  Acknowledgments\n   The authors would like to thank Ian Evans of Avaya,
    Michael\n   Bardzinski and John Dally of NS-Technologies, Adnan Saleem of\n   Radisys,
    and Dave Morgan for useful review and input to this work.\n   Eric Burger contributed
    to the early phases of this work.\n   Expert review was also provided by Spencer
    Dawkins, Krishna Prasad\n   Kalluri, Lorenzo Miniero, and Roni Even.  Hadriel
    Kaplan provided\n   expert guidance on the dialog association mechanism.  Lorenzo
    Miniero\n   has constantly provided excellent feedback based on his work.\n   Ben
    Campbell carried out the RAI expert review on this document and\n   provided a
    great deal of invaluable input.  Brian Weis carried out a\n   thorough security
    review.  Jonathan Lennox carried out a thorough SDP\n   review that provided some
    excellent modifications.  Text from Eric\n   Burger was used in the introduction
    in the explanation for using SIP.\n"
  title: 15.  Acknowledgments
- contents:
  - '16.  References

    '
  - contents:
    - "16.1.  Normative References\n   [RFC2045]  Freed, N. and N. Borenstein, \"Multipurpose
      Internet Mail\n              Extensions (MIME) Part One: Format of Internet
      Message\n              Bodies\", RFC 2045, November 1996.\n   [RFC2119]  Bradner,
      S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\",
      BCP 14, RFC 2119, March 1997.\n   [RFC3261]  Rosenberg, J., Schulzrinne, H.,
      Camarillo, G., Johnston,\n              A., Peterson, J., Sparks, R., Handley,
      M., and E.\n              Schooler, \"SIP: Session Initiation Protocol\", RFC
      3261,\n              June 2002.\n   [RFC3262]  Rosenberg, J. and H. Schulzrinne,
      \"Reliability of\n              Provisional Responses in Session Initiation
      Protocol\n              (SIP)\", RFC 3262, June 2002.\n   [RFC3263]  Rosenberg,
      J. and H. Schulzrinne, \"Session Initiation\n              Protocol (SIP): Locating
      SIP Servers\", RFC 3263,\n              June 2002.\n   [RFC3264]  Rosenberg,
      J. and H. Schulzrinne, \"An Offer/Answer Model\n              with Session Description
      Protocol (SDP)\", RFC 3264,\n              June 2002.\n   [RFC3311]  Rosenberg,
      J., \"The Session Initiation Protocol (SIP)\n              UPDATE Method\",
      RFC 3311, October 2002.\n   [RFC3629]  Yergeau, F., \"UTF-8, a transformation
      format of ISO\n              10646\", STD 63, RFC 3629, November 2003.\n   [RFC3688]
      \ Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688,\n              January
      2004.\n   [RFC4145]  Yon, D. and G. Camarillo, \"TCP-Based Media Transport in\n
      \             the Session Description Protocol (SDP)\", RFC 4145,\n              September
      2005.\n   [RFC4288]  Freed, N. and J. Klensin, \"Media Type Specifications and\n
      \             Registration Procedures\", BCP 13, RFC 4288, December 2005.\n
      \  [RFC4566]  Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session\n              Description
      Protocol\", RFC 4566, July 2006.\n   [RFC4574]  Levin, O. and G. Camarillo,
      \"The Session Description\n              Protocol (SDP) Label Attribute\", RFC
      4574, August 2006.\n   [RFC4855]  Casner, S., \"Media Type Registration of RTP
      Payload\n              Formats\", RFC 4855, February 2007.\n   [RFC5226]  Narten,
      T. and H. Alvestrand, \"Guidelines for Writing an\n              IANA Considerations
      Section in RFCs\", BCP 26, RFC 5226,\n              May 2008.\n   [RFC5234]
      \ Crocker, D. and P. Overell, \"Augmented BNF for Syntax\n              Specifications:
      ABNF\", STD 68, RFC 5234, January 2008.\n   [RFC5246]  Dierks, T. and E. Rescorla,
      \"The Transport Layer Security\n              (TLS) Protocol Version 1.2\",
      RFC 5246, August 2008.\n   [RFC5751]  Ramsdell, B. and S. Turner, \"Secure/Multipurpose
      Internet\n              Mail Extensions (S/MIME) Version 3.2 Message\n              Specification\",
      RFC 5751, January 2010.\n   [RFC5922]  Gurbani, V., Lawrence, S., and A. Jeffrey,
      \"Domain\n              Certificates in the Session Initiation Protocol (SIP)\",\n
      \             RFC 5922, June 2010.\n"
    title: 16.1.  Normative References
  - contents:
    - "16.2.  Informative References\n   [MSCL-THOUGHTS]\n              Burger, E.,
      \"Media Server Control Language and Protocol\n              Thoughts\", Work
      in Progress, June 2006.\n   [RFC3023]  Murata, M., St. Laurent, S., and D. Kohn,
      \"XML Media\n              Types\", RFC 3023, January 2001.\n   [RFC3550]  Schulzrinne,
      H., Casner, S., Frederick, R., and V.\n              Jacobson, \"RTP: A Transport
      Protocol for Real-Time\n              Applications\", STD 64, RFC 3550, July
      2003.\n   [RFC3725]  Rosenberg, J., Peterson, J., Schulzrinne, H., and G.\n
      \             Camarillo, \"Best Current Practices for Third Party Call\n              Control
      (3pcc) in the Session Initiation Protocol (SIP)\",\n              BCP 85, RFC
      3725, April 2004.\n   [RFC3840]  Rosenberg, J., Schulzrinne, H., and P. Kyzivat,\n
      \             \"Indicating User Agent Capabilities in the Session\n              Initiation
      Protocol (SIP)\", RFC 3840, August 2004.\n   [RFC3841]  Rosenberg, J., Schulzrinne,
      H., and P. Kyzivat, \"Caller\n              Preferences for the Session Initiation
      Protocol (SIP)\",\n              RFC 3841, August 2004.\n   [RFC5125]  Taylor,
      T., \"Reclassification of RFC 3525 to Historic\",\n              RFC 5125, February
      2008.\n   [RFC5167]  Dolly, M. and R. Even, \"Media Server Control Protocol\n
      \             Requirements\", RFC 5167, March 2008.\n   [RFC5626]  Jennings,
      C., Mahy, R., and F. Audet, \"Managing Client-\n              Initiated Connections
      in the Session Initiation Protocol\n              (SIP)\", RFC 5626, October
      2009.\n"
    title: 16.2.  Informative References
  title: 16.  References
- contents:
  - "Appendix A.  Common Package Components\n   During the creation of the Control
    Framework, it has become clear\n   that there are a number of components that
    are common across multiple\n   packages.  It has become apparent that it would
    be useful to collect\n   such reusable components in a central location.  In the
    short term,\n   this appendix provides the placeholder for the utilities, and
    it is\n   the intention that this section will eventually form the basis of an\n
    \  initial 'Utilities Document' that can be used by Control Packages.\n"
  - contents:
    - "A.1.  Common Dialog/Multiparty Reference Schema\n   The following schema provides
      some common attributes for allowing\n   Control Packages to apply specific commands
      to a particular SIP media\n   dialog (also referred to as \"Connection\") or
      conference.  If used\n   within a Control Package, the Connection and multiparty
      attributes\n   will be imported and used appropriately to specifically identify\n
      \  either a SIP dialog or a conference instance.  If used within a\n   package,
      the value contained in the 'connectionid' attribute MUST be\n   constructed
      by concatenating the 'Local' and 'Remote' SIP dialog\n   identifier tags as
      defined in [RFC3261].  They MUST then be separated\n   using the ':' character.
      \ So the format would be:\n               'Local Dialog tag' + ':' + 'Remote
      Dialog tag'\n   As an example, for an entity that has a SIP Local dialog identifier\n
      \  of '7HDY839' and a Remote dialog identifier of 'HJKSkyHS', the\n   'connectionid'
      attribute for a Control Framework command would be:\n                 7HDY839:HJKSkyHS\n
      \  It should be noted that Control Framework requests initiated in\n   conjunction
      with a SIP dialog will produce a different 'connectionid'\n   value depending
      on the directionality of the request; for example,\n   Local and Remote tags
      are locally identifiable.\n   As with the Connection attribute previously defined,
      it is useful to\n   have the ability to apply specific Control Framework commands
      to a\n   number of related dialogs, such as a multiparty call.  This typically\n
      \  consists of a number of media dialogs that are logically bound by a\n   single
      identifier.  The following schema allows for Control Framework\n   commands
      to explicitly reference such a grouping through a\n   'conferenceid' XML container.
      \ If used by a Control Package, any\n   control XML referenced by the attribute
      applies to all related media\n   dialogs.  Unlike the dialog attribute, the
      'conferenceid' attribute\n   does not need to be constructed based on the overlying
      SIP dialog.\n   The 'conferenceid' attribute value is system specific and should
      be\n   selected with relevant context and uniqueness.\n   It should be noted
      that the values contained in both the\n   'connectionid' and 'conferenceid'
      identifiers MUST be compared in a\n   case-sensitive manner.\n   The full schema
      follows:\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <xsd:schema\n   targetNamespace=\"urn:ietf:params:xml:ns:control:framework-attributes\"\n
      \  xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n   xmlns=\"urn:ietf:params:xml:ns::control:framework-attributes\"\n
      \  elementFormDefault=\"qualified\" attributeFormDefault=\"unqualified\">\n
      \       <xsd:attributeGroup name=\"framework-attributes\">\n          <xsd:annotation>\n
      \           <xsd:documentation>\n              SIP Connection and Conf Identifiers\n
      \           </xsd:documentation>\n          </xsd:annotation>\n          <xsd:attribute
      name=\"connectionid\" type=\"xsd:string\"/>\n          <xsd:attribute name=\"conferenceid\"
      type=\"xsd:string\"/>\n        </xsd:attributeGroup>\n </xsd:schema>\n"
    title: A.1.  Common Dialog/Multiparty Reference Schema
  title: Appendix A.  Common Package Components
- contents:
  - "Authors' Addresses\n   Chris Boulton\n   NS-Technologies\n   EMail: chris@ns-technologies.com\n
    \  Tim Melanchuk\n   Rainwillow\n   EMail: timm@rainwillow.com\n   Scott McGlashan\n
    \  Hewlett-Packard\n   Gustav III:s boulevard 36\n   SE-16985 Stockholm, Sweden\n
    \  EMail: smcg.stds01@mcglashan.org\n"
  title: Authors' Addresses
