- title: __initial_text__
  contents:
  - '         Network Time Protocol Version 4: Autokey Specification

    '
- title: Abstract
  contents:
  - "Abstract\n   This memo describes the Autokey security model for authenticating\n\
    \   servers to clients using the Network Time Protocol (NTP) and public\n   key\
    \ cryptography.  Its design is based on the premise that IPsec\n   schemes cannot\
    \ be adopted intact, since that would preclude stateless\n   servers and severely\
    \ compromise timekeeping accuracy.  In addition,\n   Public Key Infrastructure\
    \ (PKI) schemes presume authenticated time\n   values are always available to\
    \ enforce certificate lifetimes;\n   however, cryptographically verified timestamps\
    \ require interaction\n   between the timekeeping and authentication functions.\n\
    \   This memo includes the Autokey requirements analysis, design\n   principles,\
    \ and protocol specification.  A detailed description of\n   the protocol states,\
    \ events, and transition functions is included.  A\n   prototype of the Autokey\
    \ design based on this memo has been\n   implemented, tested, and documented in\
    \ the NTP version 4 (NTPv4)\n   software distribution for the Unix, Windows, and\
    \ Virtual Memory\n   System (VMS) operating systems at http://www.ntp.org.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc5906.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \   2. NTP Security Model ..............................................4\n  \
    \ 3. Approach ........................................................7\n   4.\
    \ Autokey Cryptography ............................................8\n   5. Autokey\
    \ Protocol Overview ......................................12\n   6. NTP Secure\
    \ Groups ..............................................14\n   7. Identity Schemes\
    \ ...............................................19\n   8. Timestamps and Filestamps\
    \ ......................................20\n   9. Autokey Operations .............................................22\n\
    \   10. Autokey Protocol Messages .....................................23\n  \
    \    10.1. No-Operation .............................................26\n    \
    \  10.2. Association Message (ASSOC) ..............................26\n      10.3.\
    \ Certificate Message (CERT) ...............................26\n      10.4. Cookie\
    \ Message (COOKIE) ..................................27\n      10.5. Autokey Message\
    \ (AUTO) ...................................27\n      10.6. Leapseconds Values\
    \ Message (LEAP) ........................27\n      10.7. Sign Message (SIGN) ......................................27\n\
    \      10.8. Identity Messages (IFF, GQ, MV) ..........................27\n  \
    \ 11. Autokey State Machine .........................................28\n    \
    \  11.1. Status Word ..............................................28\n      11.2.\
    \ Host State Variables .....................................30\n      11.3. Client\
    \ State Variables (all modes) .......................33\n      11.4. Protocol\
    \ State Transitions ...............................34\n           11.4.1. Server\
    \ Dance ......................................34\n           11.4.2. Broadcast\
    \ Dance ...................................35\n           11.4.3. Symmetric Dance\
    \ ...................................36\n      11.5. Error Recovery ...........................................37\n\
    \   12. Security Considerations .......................................39\n  \
    \    12.1. Protocol Vulnerability ...................................39\n    \
    \  12.2. Clogging Vulnerability ...................................40\n   13.\
    \ IANA Considerations ...........................................42\n   13. References\
    \ ....................................................42\n      13.1. Normative\
    \ References .....................................42\n      13.2. Informative\
    \ References ...................................43\n   Appendix A.  Timestamps,\
    \ Filestamps, and Partial Ordering .........45\n   Appendix B.  Identity Schemes\
    \ .....................................46\n   Appendix C.  Private Certificate\
    \ (PC) Scheme ......................47\n   Appendix D.  Trusted Certificate (TC)\
    \ Scheme ......................47\n   Appendix E.  Schnorr (IFF) Identity Scheme\
    \ ........................48\n   Appendix F.  Guillard-Quisquater (GQ) Identity\
    \ Scheme .............49\n   Appendix G.  Mu-Varadharajan (MV) Identity Scheme\
    \ .................51\n   Appendix H.  ASN.1 Encoding Rules .................................54\n\
    \   Appendix I.  COOKIE Request, IFF Response, GQ Response, MV\n             \
    \   Response .............................................54\n   Appendix J. \
    \ Certificates .........................................55\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   A distributed network service requires reliable, ubiquitous,\
    \ and\n   survivable provisions to prevent accidental or malicious attacks on\n\
    \   the servers and clients in the network or the values they exchange.\n   Reliability\
    \ requires that clients can determine that received packets\n   are authentic;\
    \ that is, were actually sent by the intended server and\n   not manufactured\
    \ or modified by an intruder.  Ubiquity requires that\n   a client can verify\
    \ the authenticity of a server using only public\n   information.  Survivability\
    \ requires protection from faulty\n   implementations, improper operation, and\
    \ possibly malicious clogging\n   and replay attacks.\n   This memo describes\
    \ a cryptographically sound and efficient\n   methodology for use in the Network\
    \ Time Protocol (NTP) [RFC5905].\n   The various key agreement schemes [RFC4306][RFC2412][RFC2522]\n\
    \   proposed require per-association state variables, which contradicts\n   the\
    \ principles of the remote procedure call (RPC) paradigm in which\n   servers\
    \ keep no state for a possibly large client population.  An\n   evaluation of\
    \ the PKI model and algorithms, e.g., as implemented in\n   the OpenSSL library,\
    \ leads to the conclusion that any scheme\n   requiring every NTP packet to carry\
    \ a PKI digital signature would\n   result in unacceptably poor timekeeping performance.\n\
    \   The Autokey protocol is based on a combination of PKI and a pseudo-\n   random\
    \ sequence generated by repeated hashes of a cryptographic value\n   involving\
    \ both public and private components.  This scheme has been\n   implemented, tested,\
    \ and deployed in the Internet of today.  A\n   detailed description of the security\
    \ model, design principles, and\n   implementation is presented in this memo.\n\
    \   This informational document describes the NTP extensions for Autokey\n   as\
    \ implemented in an NTPv4 software distribution available from\n   http://www.ntp.org.\
    \  This description is provided to offer a basis\n   for future work and a reference\
    \ for the software release.  This\n   document also describes the motivation for\
    \ the extensions within the\n   protocol.\n"
- title: 2.  NTP Security Model
  contents:
  - "2.  NTP Security Model\n   NTP security requirements are even more stringent\
    \ than most other\n   distributed services.  First, the operation of the authentication\n\
    \   mechanism and the time synchronization mechanism are inextricably\n   intertwined.\
    \  Reliable time synchronization requires cryptographic\n   keys that are valid\
    \ only over designated time intervals; but, time\n   intervals can be enforced\
    \ only when participating servers and clients\n   are reliably synchronized to\
    \ UTC.  In addition, the NTP subnet is\n   hierarchical by nature, so time and\
    \ trust flow from the primary\n   servers at the root through secondary servers\
    \ to the clients at the\n   leaves.\n   A client can claim authentic to dependent\
    \ applications only if all\n   servers on the path to the primary servers are\
    \ bona fide authentic.\n   In order to emphasize this requirement, in this memo,\
    \ the notion of\n   \"authentic\" is replaced by \"proventic\", an adjective new\
    \ to English\n   and derived from \"provenance\", as in the provenance of a painting.\n\
    \   Having abused the language this far, the suffixes fixable to the\n   various\
    \ derivatives of authentic will be adopted for proventic as\n   well.  In NTP,\
    \ each server authenticates the next-lower stratum\n   servers and proventicates\
    \ (authenticates by induction) the lowest\n   stratum (primary) servers.  Serious\
    \ computer linguists would\n   correctly interpret the proventic relation as the\
    \ transitive closure\n   of the authentic relation.\n   It is important to note\
    \ that the notion of proventic does not\n   necessarily imply the time is correct.\
    \  An NTP client mobilizes a\n   number of concurrent associations with different\
    \ servers and uses a\n   crafted agreement algorithm to pluck truechimers from\
    \ the population\n   possibly including falsetickers.  A particular association\
    \ is\n   proventic if the server certificate and identity have been verified\n\
    \   by the means described in this memo.  However, the statement \"the\n   client\
    \ is synchronized to proventic sources\" means that the system\n   clock has been\
    \ set using the time values of one or more proventic\n   associations and according\
    \ to the NTP mitigation algorithms.\n   Over the last several years, the IETF\
    \ has defined and evolved the\n   IPsec infrastructure for privacy protection\
    \ and source authentication\n   in the Internet.  The infrastructure includes\
    \ the Encapsulating\n   Security Payload (ESP) [RFC4303] and Authentication Header\
    \ (AH)\n   [RFC4302] for IPv4 and IPv6.  Cryptographic algorithms that use these\n\
    \   headers for various purposes include those developed for the PKI,\n   including\
    \ various message digest, digital signature, and key\n   agreement algorithms.\
    \  This memo takes no position on which message\n   digest or digital signature\
    \ algorithm is used.  This is established\n   by a profile for each community\
    \ of users.\n   It will facilitate the discussion in this memo to refer to the\n\
    \   reference implementation available at http://www.ntp.org.  It\n   includes\
    \ Autokey as described in this memo and is available to the\n   general public;\
    \ however, it is not part of the specification itself.\n   The cryptographic means\
    \ used by the reference implementation and its\n   user community are based on\
    \ the OpenSSL cryptographic software\n   library available at http://www.openssl.org,\
    \ but other libraries with\n   equivalent functionality could be used as well.\
    \  It is important for\n   distribution and export purposes that the way in which\
    \ these\n   algorithms are used precludes encryption of any data other than\n\
    \   incidental to the construction of digital signatures.\n   The fundamental\
    \ assumption in NTP about the security model is that\n   packets transmitted over\
    \ the Internet can be intercepted by those\n   other than the intended recipient,\
    \ remanufactured in various ways,\n   and replayed in whole or part.  These packets\
    \ can cause the client to\n   believe or produce incorrect information, cause\
    \ protocol operations\n   to fail, interrupt network service, or consume precious\
    \ network and\n   processor resources.\n   In the case of NTP, the assumed goal\
    \ of the intruder is to inject\n   false time values, disrupt the protocol or\
    \ clog the network, servers,\n   or clients with spurious packets that exhaust\
    \ resources and deny\n   service to legitimate applications.  The mission of the\
    \ algorithms\n   and protocols described in this memo is to detect and discard\n\
    \   spurious packets sent by someone other than the intended sender or\n   sent\
    \ by the intended sender, but modified or replayed by an intruder.\n   There are\
    \ a number of defense mechanisms already built in the NTP\n   architecture, protocol,\
    \ and algorithms.  The on-wire timestamp\n   exchange scheme is inherently resistant\
    \ to spoofing, packet-loss, and\n   replay attacks.  The engineered clock filter,\
    \ selection, and\n   clustering algorithms are designed to defend against evil\
    \ cliques of\n   Byzantine traitors.  While not necessarily designed to defeat\n\
    \   determined intruders, these algorithms and accompanying sanity checks\n  \
    \ have functioned well over the years to deflect improperly operating\n   but\
    \ presumably friendly scenarios.  However, these mechanisms do not\n   securely\
    \ identify and authenticate servers to clients.  Without\n   specific further\
    \ protection, an intruder can inject any or all of the\n   following attacks.\n\
    \   1.  An intruder can intercept and archive packets forever, as well as\n  \
    \     all the public values ever generated and transmitted over the\n       net.\n\
    \   2.  An intruder can generate packets faster than the server, network,\n  \
    \     or client can process them, especially if they require expensive\n     \
    \  cryptographic computations.\n   3.  In a wiretap attack, the intruder can intercept,\
    \ modify, and\n       replay a packet.  However, it cannot permanently prevent\
    \ onward\n       transmission of the original packet; that is, it cannot break\
    \ the\n       wire, only tell lies and congest it.  Except in the unlikely\n \
    \      cases considered in Section 12, the modified packet cannot arrive\n   \
    \    at the victim before the original packet, nor does it have the\n       server\
    \ private keys or identity parameters.\n   4.  In a man-in-the-middle or masquerade\
    \ attack, the intruder is\n       positioned between the server and client, so\
    \ it can intercept,\n       modify, and replay a packet and prevent onward transmission\
    \ of\n       the original packet.  Except in unlikely cases considered in\n  \
    \     Section 12, the middleman does not have the server private keys.\n   The\
    \ NTP security model assumes the following possible limitations.\n   1.  The running\
    \ times for public key algorithms are relatively long\n       and highly variable.\
    \  In general, the performance of the time\n       synchronization function is\
    \ badly degraded if these algorithms\n       must be used for every NTP packet.\n\
    \   2.  In some modes of operation, it is not feasible for a server to\n     \
    \  retain state variables for every client.  It is however feasible\n       to\
    \ regenerated them for a client upon arrival of a packet from\n       that client.\n\
    \   3.  The lifetime of cryptographic values must be enforced, which\n       requires\
    \ a reliable system clock.  However, the sources that\n       synchronize the\
    \ system clock must be cryptographically\n       proventicated.  This circular\
    \ interdependence of the timekeeping\n       and proventication functions requires\
    \ special handling.\n   4.  Client security functions must involve only public\
    \ values\n       transmitted over the net.  Private values must never be disclosed\n\
    \       beyond the machine on which they were created, except in the case\n  \
    \     of a special trusted agent (TA) assigned for this purpose.\n   Unlike the\
    \ Secure Shell (SSH) security model, where the client must\n   be securely authenticated\
    \ to the server, in NTP, the server must be\n   securely authenticated to the\
    \ client.  In SSH, each different\n   interface address can be bound to a different\
    \ name, as returned by a\n   reverse-DNS query.  In this design, separate public/private\
    \ key pairs\n   may be required for each interface address with a distinct name.\
    \  A\n   perceived advantage of this design is that the security compartment\n\
    \   can be different for each interface.  This allows a firewall, for\n   instance,\
    \ to require some interfaces to authenticate the client and\n   others not.\n"
- title: 3.  Approach
  contents:
  - "3.  Approach\n   The Autokey protocol described in this memo is designed to meet\
    \ the\n   following objectives.  In-depth discussions on these objectives is in\n\
    \   the web briefings and will not be elaborated in this memo.  Note that\n  \
    \ here, and elsewhere in this memo, mention of broadcast mode means\n   multicast\
    \ mode as well, with exceptions as noted in the NTP software\n   documentation\
    \ [RFC5905].\n   1.  It must interoperate with the existing NTP architecture model\
    \ and\n       protocol design.  In particular, it must support the symmetric\n\
    \       key scheme described in [RFC1305].  As a practical matter, the\n     \
    \  reference implementation must use the same internal key\n       management\
    \ system, including the use of 32-bit key IDs and\n       existing mechanisms\
    \ to store, activate, and revoke keys.\n   2.  It must provide for the independent\
    \ collection of cryptographic\n       values and time values.  An NTP packet is\
    \ accepted for processing\n       only when the required cryptographic values\
    \ have been obtained\n       and verified and the packet has passed all header\
    \ sanity checks.\n   3.  It must not significantly degrade the potential accuracy\
    \ of the\n       NTP synchronization algorithms.  In particular, it must not make\n\
    \       unreasonable demands on the network or host processor and memory\n   \
    \    resources.\n   4.  It must be resistant to cryptographic attacks, specifically\
    \ those\n       identified in the security model above.  In particular, it must\n\
    \       be tolerant of operational or implementation variances, such as\n    \
    \   packet loss or disorder, or suboptimal configurations.\n   5.  It must build\
    \ on a widely available suite of cryptographic\n       algorithms, yet be independent\
    \ of the particular choice.  In\n       particular, it must not require data encryption\
    \ other than that\n       which is incidental to signature and cookie encryption\n\
    \       operations.\n   6.  It must function in all the modes supported by NTP,\
    \ including\n       server, symmetric, and broadcast modes.\n"
- title: 4.  Autokey Cryptography
  contents:
  - "4.  Autokey Cryptography\n   Autokey cryptography is based on the PKI algorithms\
    \ commonly used in\n   the Secure Shell and Secure Sockets Layer (SSL) applications.\
    \  As in\n   these applications, Autokey uses message digests to detect packet\n\
    \   modification, digital signatures to verify credentials, and public\n   certificates\
    \ to provide traceable authority.  What makes Autokey\n   cryptography unique\
    \ is the way in which these algorithms are used to\n   deflect intruder attacks\
    \ while maintaining the integrity and accuracy\n   of the time synchronization\
    \ function.\n   Autokey, like many other remote procedure call (RPC) protocols,\n\
    \   depends on message digests for basic authentication; however, it is\n   important\
    \ to understand that message digests are also used by NTP\n   when Autokey is\
    \ not available or not configured.  Selection of the\n   digest algorithm is a\
    \ function of NTP configuration and is\n   transparent to Autokey.\n   The protocol\
    \ design and reference implementation support both 128-bit\n   and 160-bit message\
    \ digest algorithms, each with a 32-bit key ID.  In\n   order to retain backwards\
    \ compatibility with NTPv3, the NTPv4 key ID\n   space is partitioned in two subspaces\
    \ at a pivot point of 65536.\n   Symmetric key IDs have values less than the pivot\
    \ and indefinite\n   lifetime.  Autokey key IDs have pseudo-random values equal\
    \ to or\n   greater than the pivot and are expunged immediately after use.\n \
    \  Both symmetric key and public key cryptography authenticate as shown\n   in\
    \ Figure 1.  The server looks up the key associated with the key ID\n   and calculates\
    \ the message digest from the NTP header and extension\n   fields together with\
    \ the key value.  The key ID and digest form the\n   message authentication code\
    \ (MAC) included with the message.  The\n   client does the same computation using\
    \ its local copy of the key and\n   compares the result with the digest in the\
    \ MAC.  If the values agree,\n   the message is assumed authentic.\n         \
    \       +------------------+\n                | NTP Header and   |\n         \
    \       | Extension Fields |\n                +------------------+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      |       |        |   Message Authentication Code |\n  \
    \                   \\|/     \\|/       +              (MAC)            +\n  \
    \              ********************   | +-------------------------+   |\n    \
    \            *   Compute Hash   *<----| Key ID | Message Digest |   +\n      \
    \          ********************   | +-------------------------+   |\n        \
    \                  |            +-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+-+\n          \
    \               \\|/                        \\|/\n                +------------------+\
    \       +-------------+\n                |  Message Digest  |------>|   Compare\
    \   |\n                +------------------+       +-------------+\n          \
    \           Figure 1: Message Authentication\n   Autokey uses specially contrived\
    \ session keys, called autokeys, and a\n   precomputed pseudo-random sequence\
    \ of autokeys that are saved in the\n   autokey list.  The Autokey protocol operates\
    \ separately for each\n   association, so there may be several autokey sequences\
    \ operating\n   independently at the same time.\n                   +-------------+-------------+--------+--------+\n\
    \                   | Src Address | Dst Address | Key ID | Cookie |\n        \
    \           +-------------+-------------+--------+--------+\n                \
    \          Figure 2: NTPv4 Autokey\n   An autokey is computed from four fields\
    \ in network byte order as\n   shown in Figure 2.  The four values are hashed\
    \ using the MD5\n   algorithm to produce the 128-bit autokey value, which in the\n\
    \   reference implementation is stored along with the key ID in a cache\n   used\
    \ for symmetric keys as well as autokeys.  Keys are retrieved from\n   the cache\
    \ by key ID using hash tables and a fast lookup algorithm.\n   For use with IPv4,\
    \ the Src Address and Dst Address fields contain 32\n   bits; for use with IPv6,\
    \ these fields contain 128 bits.  In either\n   case, the Key ID and Cookie fields\
    \ contain 32 bits.  Thus, an IPv4\n   autokey has four 32-bit words, while an\
    \ IPv6 autokey has ten 32-bit\n   words.  The source and destination addresses\
    \ and key ID are public\n   values visible in the packet, while the cookie can\
    \ be a public value\n   or shared private value, depending on the NTP mode.\n\
    \   The NTP packet format has been augmented to include one or more\n   extension\
    \ fields piggybacked between the original NTP header and the\n   MAC.  For packets\
    \ without extension fields, the cookie is a shared\n   private value.  For packets\
    \ with extension fields, the cookie has a\n   default public value of zero, since\
    \ these packets are validated\n   independently using digital signatures.\n  \
    \ There are some scenarios where the use of endpoint IP addresses may\n   be difficult\
    \ or impossible.  These include configurations where\n   network address translation\
    \ (NAT) devices are in use or when\n   addresses are changed during an association\
    \ lifetime due to mobility\n   constraints.  For Autokey, the only restriction\
    \ is that the address\n   fields that are visible in the transmitted packet must\
    \ be the same as\n   those used to construct the autokey list and that these fields\
    \ be the\n   same as those visible in the received packet.  (The use of\n   alternative\
    \ means, such as Autokey host names (discussed later) or\n   hashes of these names\
    \ may be a topic for future study.)\n"
- title: +-----------+-----------+------+------+   +---------+  +-----+------+
  contents:
  - '+-----------+-----------+------+------+   +---------+  +-----+------+

    '
- title: '|Src Address|Dst Address|Key ID|Cookie|-->|         |  |Final|Final |'
  contents:
  - '|Src Address|Dst Address|Key ID|Cookie|-->|         |  |Final|Final |

    '
- title: +-----------+-----------+------+------+   | Session |  |Index|Key ID|
  contents:
  - "+-----------+-----------+------+------+   | Session |  |Index|Key ID|\n     |\
    \           |         |        |     | Key ID  |  +-----+------+\n    \\|/   \
    \      \\|/       \\|/      \\|/    |  List   |     |       |\n   *************************************\
    \  +---------+    \\|/     \\|/\n   *          COMPUTE HASH             *    \
    \         *******************\n   *************************************      \
    \       *COMPUTE SIGNATURE*\n     |                    Index n               \
    \     *******************\n    \\|/                                          \
    \             |\n   +--------+                                               \
    \  |\n   |  Next  |                                                \\|/\n   |\
    \ Key ID |                                           +-----------+\n   +--------+\
    \                                           | Signature |\n   Index n+1      \
    \                                      +-----------+\n                    Figure\
    \ 3: Constructing the Key List\n   Figure 3 shows how the autokey list and autokey\
    \ values are computed.\n   The key IDs used in the autokey list consist of a sequence\
    \ starting\n   with a random 32-bit nonce (autokey seed) greater than or equal\
    \ to\n   the pivot as the first key ID.  The first autokey is computed as\n  \
    \ above using the given cookie and autokey seed and assigned index 0.\n   The\
    \ first 32 bits of the result in network byte order become the next\n   key ID.\
    \  The MD5 hash of the autokey is the key value saved in the\n   key cache along\
    \ with the key ID.  The first 32 bits of the key become\n   the key ID for the\
    \ next autokey assigned index 1.\n   Operations continue to generate the entire\
    \ list.  It may happen that\n   a newly generated key ID is less than the pivot\
    \ or collides with\n   another one already generated (birthday event).  When this\
    \ happens,\n   which occurs only rarely, the key list is terminated at that point.\n\
    \   The lifetime of each key is set to expire one poll interval after its\n  \
    \ scheduled use.  In the reference implementation, the list is\n   terminated\
    \ when the maximum key lifetime is about one hour, so for\n   poll intervals above\
    \ one hour, a new key list containing only a\n   single entry is regenerated for\
    \ every poll.\n                   +------------------+\n                   | \
    \ NTP Header and  |\n                   | Extension Fields |\n               \
    \    +------------------+\n                        |       |\n               \
    \        \\|/     \\|/                     +---------+\n                     ****************\
    \    +--------+    | Session |\n                     * COMPUTE HASH *<---| Key\
    \ ID |<---| Key ID  |\n                     ****************    +--------+   \
    \ |  List   |\n                             |                |        +---------+\n\
    \                            \\|/              \\|/\n                   +-----------------------------------+\n\
    \                   | Message Authentication Code (MAC) |\n                  \
    \ +-----------------------------------+\n                      Figure 4: Transmitting\
    \ Messages\n   The index of the last autokey in the list is saved along with the\
    \ key\n   ID for that entry, collectively called the autokey values.  The\n  \
    \ autokey values are then signed for use later.  The list is used in\n   reverse\
    \ order as shown in Figure 4, so that the first autokey used is\n   the last one\
    \ generated.\n   The Autokey protocol includes a message to retrieve the autokey\n\
    \   values and verify the signature, so that subsequent packets can be\n   validated\
    \ using one or more hashes that eventually match the last key\n   ID (valid) or\
    \ exceed the index (invalid).  This is called the autokey\n   test in the following\
    \ and is done for every packet, including those\n   with and without extension\
    \ fields.  In the reference implementation,\n   the most recent key ID received\
    \ is saved for comparison with the\n   first 32 bits in network byte order of\
    \ the next following key value.\n   This minimizes the number of hash operations\
    \ in case a single packet\n   is lost.\n"
- title: 5.  Autokey Protocol Overview
  contents:
  - "5.  Autokey Protocol Overview\n   The Autokey protocol includes a number of request/response\
    \ exchanges\n   that must be completed in order.  In each exchange, a client sends\
    \ a\n   request message with data and expects a server response message with\n\
    \   data.  Requests and responses are contained in extension fields, one\n   request\
    \ or response in each field, as described later.  An NTP packet\n   can contain\
    \ one request message and one or more response messages.\n   The following is\
    \ a list of these messages.\n   o  Parameter exchange.  The request includes the\
    \ client host name and\n      status word; the response includes the server host\
    \ name and status\n      word.  The status word specifies the digest/signature\
    \ scheme to\n      use and the identity schemes supported.\n   o  Certificate\
    \ exchange.  The request includes the subject name of a\n      certificate; the\
    \ response consists of a signed certificate with\n      that subject name.  If\
    \ the issuer name is not the same as the\n      subject name, it has been signed\
    \ by a host one step closer to a\n      trusted host, so certificate retrieval\
    \ continues for the issuer\n      name.  If it is trusted and self-signed, the\
    \ trail concludes at\n      the trusted host.  If nontrusted and self-signed,\
    \ the host\n      certificate has not yet been signed, so the trail temporarily\n\
    \      loops.  Completion of this exchange lights the VAL bit as\n      described\
    \ below.\n   o  Identity exchange.  The certificate trail is generally not\n \
    \     considered sufficient protection against man-in-the-middle attacks\n   \
    \   unless additional protection such as the proof-of-possession\n      scheme\
    \ described in [RFC2875] is available, but this is expensive\n      and requires\
    \ servers to retain state.  Autokey can use one of the\n      challenge/response\
    \ identity schemes described in Appendix B.\n      Completion of this exchange\
    \ lights the IFF bit as described below.\n   o  Cookie exchange.  The request\
    \ includes the public key of the\n      server.  The response includes the server\
    \ cookie encrypted with\n      this key.  The client uses this value when constructing\
    \ the key\n      list.  Completion of this exchange lights the COOK bit as\n \
    \     described below.\n   o  Autokey exchange.  The request includes either no\
    \ data or the\n      autokey values in symmetric modes.  The response includes\
    \ the\n      autokey values of the server.  These values are used to verify the\n\
    \      autokey sequence.  Completion of this exchange lights the AUT bit\n   \
    \   as described below.\n   o  Sign exchange.  This exchange is executed only\
    \ when the client has\n      synchronized to a proventic source.  The request\
    \ includes the\n      self-signed client certificate.  The server acting as\n\
    \      certification authority (CA) interprets the certificate as a\n      X.509v3\
    \ certificate request.  It extracts the subject, issuer, and\n      extension\
    \ fields, builds a new certificate with these data along\n      with its own serial\
    \ number and expiration time, then signs it\n      using its own private key and\
    \ includes it in the response.  The\n      client uses the signed certificate\
    \ in its own role as server for\n      dependent clients.  Completion of this\
    \ exchange lights the SIGN\n      bit as described below.\n   o  Leapseconds exchange.\
    \  This exchange is executed only when the\n      client has synchronized to a\
    \ proventic source.  This exchange\n      occurs when the server has the leapseconds\
    \ values, as indicated in\n      the host status word.  If so, the client requests\
    \ the values and\n      compares them with its own values, if available.  If the\
    \ server\n      values are newer than the client values, the client replaces its\n\
    \      own with the server values.  The client, acting as server, can now\n  \
    \    provide the most recent values to its dependent clients.  In\n      symmetric\
    \ mode, this results in both peers having the newest\n      values.  Completion\
    \ of this exchange lights the LPT bit as\n      described below.\n   Once the\
    \ certificates and identity have been validated, subsequent\n   packets are validated\
    \ by digital signatures and the autokey sequence.\n   The association is now proventic\
    \ with respect to the downstratum\n   trusted host, but is not yet selectable\
    \ to discipline the system\n   clock.  The associations accumulate time values,\
    \ and the mitigation\n   algorithms continue in the usual way.  When these algorithms\
    \ have\n   culled the falsetickers and cluster outliers and at least three\n \
    \  survivors remain, the system clock has been synchronized to a\n   proventic\
    \ source.\n   The time values for truechimer sources form a proventic partial\n\
    \   ordering relative to the applicable signature timestamps.  This\n   raises\
    \ the interesting issue of how to differentiate between the\n   timestamps of\
    \ different associations.  It might happen, for instance,\n   that the timestamp\
    \ of some Autokey message is ahead of the system\n   clock by some presumably\
    \ small amount.  For this reason, timestamp\n   comparisons between different\
    \ associations and between associations\n   and the system clock are avoided,\
    \ except in the NTP intersection and\n   clustering algorithms and when determining\
    \ whether a certificate has\n   expired.\n"
- title: 6.  NTP Secure Groups
  contents:
  - "6.  NTP Secure Groups\n   NTP secure groups are used to define cryptographic\
    \ compartments and\n   security hierarchies.  A secure group consists of a number\
    \ of hosts\n   dynamically assembled as a forest with roots the trusted hosts\
    \ (THs)\n   at the lowest stratum of the group.  The THs do not have to be, but\n\
    \   often are, primary (stratum 1) servers.  A trusted authority (TA),\n   not\
    \ necessarily a group host, generates private identity keys for\n   servers and\
    \ public identity keys for clients at the leaves of the\n   forest.  The TA deploys\
    \ the server keys to the THs and other\n   designated servers using secure means\
    \ and posts the client keys on a\n   public web site.\n   For Autokey purposes,\
    \ all hosts belonging to a secure group have the\n   same group name but different\
    \ host names, not necessarily related to\n   the DNS names.  The group name is\
    \ used in the subject and issuer\n   fields of the TH certificates; the host name\
    \ is used in these fields\n   for other hosts.  Thus, all host certificates are\
    \ self-signed.\n   During the use of the Autokey protocol, a client requests that\
    \ the\n   server sign its certificate and caches the result.  A certificate\n\
    \   trail is constructed by each host, possibly via intermediate hosts\n   and\
    \ ending at a TH.  Thus, each host along the trail retrieves the\n   entire trail\
    \ from its server(s) and provides this plus its own signed\n   certificates to\
    \ its clients.\n   Secure groups can be configured as hierarchies where a TH of\
    \ one\n   group can be a client of one or more other groups operating at a\n \
    \  lower stratum.  In one scenario, THs for groups RED and GREEN can be\n   cryptographically\
    \ distinct, but both be clients of group BLUE\n   operating at a lower stratum.\
    \  In another scenario, THs for group\n   CYAN can be clients of multiple groups\
    \ YELLOW and MAGENTA, both\n   operating at a lower stratum.  There are many other\
    \ scenarios, but\n   all must be configured to include only acyclic certificate\
    \ trails.\n   In Figure 5, the Alice group consists of THs Alice, which is also\
    \ the\n   TA, and Carol.  Dependent servers Brenda and Denise have configured\n\
    \   Alice and Carol, respectively, as their time sources.  Stratum 3\n   server\
    \ Eileen has configured both Brenda and Denise as her time\n   sources.  Public\
    \ certificates are identified by the subject and\n   signed by the issuer.  Note\
    \ that the server group keys have been\n   previously installed on Brenda and\
    \ Denise and the client group keys\n   installed on all machines.\n          \
    \           +-------------+ +-------------+ +-------------+\n                \
    \     | Alice Group | |    Brenda   | |    Denise   |\n                     |\
    \    Alice    | |             | |             |\n                     | +-+-+-+-+\
    \   | | +-+-+-+-+   | | +-+-+-+-+   |\n   Certificate       | | Alice |   | |\
    \ | Brenda|   | | | Denise|   |\n   +-+-+-+-+-+       | +-+-+-+-+   | | +-+-+-+-+\
    \   | | +-+-+-+-+   |\n   | Subject |       | | Alice*| 1 | | | Alice | 4 | |\
    \ | Carol | 4 |\n   +-+-+-+-+-+       | +-+-+-+-+   | | +-+-+-+-+   | | +-+-+-+-+\
    \   |\n   | Issuer  | S     |             | |             | |             |\n\
    \   +-+-+-+-+-+       | +=======+   | | +-+-+-+-+   | | +-+-+-+-+   |\n      \
    \               | ||Alice|| 3 | | | Alice |   | | | Carol |   |\n    Group Key\
    \        | +=======+   | | +-+-+-+-+   | | +-+-+-+-+   |\n   +=========+     \
    \  +-------------+ | | Alice*| 2 | | | Carol*| 2 |\n   || Group || S     | Alice\
    \ Group | | +-+-+-+-+   | | +-+-+-+-+   |\n   +=========+       |     Carol  \
    \ | |             | |             |\n                     | +-+-+-+-+   | | +-+-+-+-+\
    \   | | +-+-+-+-+   |\n    S = step         | | Carol |   | | | Brenda|   | |\
    \ | Denise|   |\n    * = trusted      | +-+-+-+-+   | | +-+-+-+-+   | | +-+-+-+-+\
    \   |\n                     | | Carol*| 1 | | | Brenda| 1 | | | Denise| 1 |\n\
    \                     | +-+-+-+-+   | | +-+-+-+-+   | | +-+-+-+-+   |\n      \
    \               |             | |             | |             |\n            \
    \         | +=======+   | | +=======+   | | +=======+   |\n                  \
    \   | ||Alice|| 3 | | ||Alice|| 3 | | ||Alice|| 3 |\n                     | +=======+\
    \   | | +=======+   | | +=======+   |\n                     +-------------+ +-------------+\
    \ +-------------+\n                        Stratum 1                Stratum 2\n\
    \                     +---------------------------------------------+\n      \
    \               |                  Eileen                     |\n            \
    \         |                                             |\n                  \
    \   |           +-+-+-+-+   +-+-+-+-+             |\n                     |  \
    \         | Eileen|   | Eileen|             |\n                     |        \
    \   +-+-+-+-+   +-+-+-+-+             |\n                     |           | Brenda|\
    \ 4 | Carol | 4           |\n                     |           +-+-+-+-+   +-+-+-+-+\
    \             |\n                     |                                      \
    \       |\n                     |           +-+-+-+-+   +-+-+-+-+            \
    \ |\n                     |           | Alice |   | Carol |             |\n  \
    \                   |           +-+-+-+-+   +-+-+-+-+             |\n        \
    \             |           | Alice*| 2 | Carol*| 2           |\n              \
    \       |           +-+-+-+-+   +-+-+-+-+             |\n                    \
    \ |                                             |\n                     |    \
    \       +-+-+-+-+   +-+-+-+-+             |\n                     |          \
    \ | Brenda|   | Denise|             |\n                     |           +-+-+-+-+\
    \   +-+-+-+-+             |\n                     |           | Alice | 2 | Carol\
    \ | 2           |\n                     |           +-+-+-+-+   +-+-+-+-+    \
    \         |\n                     |                                          \
    \   |\n                     |                 +-+-+-+-+                   |\n\
    \                     |                 | Eileen|                   |\n      \
    \               |                 +-+-+-+-+                   |\n            \
    \         |                 | Eileen| 1                 |\n                  \
    \   |                 +-+-+-+-+                   |\n                     |  \
    \                                           |\n                     |        \
    \         +=======+                   |\n                     |              \
    \   ||Alice|| 3                 |\n                     |                 +=======+\
    \                   |\n                     +---------------------------------------------+\n\
    \                                       Stratum 3\n                        Figure\
    \ 5: NTP Secure Groups\n   The steps in hiking the certificate trails and verifying\
    \ identity are\n   as follows.  Note the step number in the description matches\
    \ the step\n   number in the figure.\n   1.  The girls start by loading the host\
    \ key, sign key, self-signed\n       certificate, and group key.  Each client\
    \ and server acting as a\n       client starts the Autokey protocol by retrieving\
    \ the server host\n       name and digest/signature.  This is done using the ASSOC\
    \ exchange\n       described later.\n   2.  They continue to load certificates\
    \ recursively until a self-\n       signed trusted certificate is found.  Brenda\
    \ and Denise\n       immediately find trusted certificates for Alice and Carol,\n\
    \       respectively, but Eileen will loop because neither Brenda nor\n      \
    \ Denise have their own certificates signed by either Alice or\n       Carol.\
    \  This is done using the CERT exchange described later.\n   3.  Brenda and Denise\
    \ continue with the selected identity schemes to\n       verify that Alice and\
    \ Carol have the correct group key previously\n       generated by Alice.  This\
    \ is done using one of the identity\n       schemes IFF, GQ, or MV, described\
    \ later.  If this succeeds, each\n       continues in step 4.\n   4.  Brenda and\
    \ Denise present their certificates for signature using\n       the SIGN exchange\
    \ described later.  If this succeeds, either one\n       of or both Brenda and\
    \ Denise can now provide these signed\n       certificates to Eileen, which may\
    \ be looping in step 2.  Eileen\n       can now verify the trail via either Brenda\
    \ or Denise to the\n       trusted certificates for Alice and Carol.  Once this\
    \ is done,\n       Eileen can complete the protocol just as Brenda and Denise\
    \ did.\n   For various reasons, it may be convenient for a server to have client\n\
    \   keys for more than one group.  For example, Figure 6 shows three\n   secure\
    \ groups Alice, Helen, and Carol arranged in a hierarchy.  Hosts\n   A, B, C,\
    \ and D belong to Alice with A and B as her THs.  Hosts R and\n   S belong to\
    \ Helen with R as her TH.  Hosts X and Y belong to Carol\n   with X as her TH.\
    \  Note that the TH for a group is always the lowest\n   stratum and that the\
    \ hosts of the combined groups form an acyclic\n   graph.  Note also that the\
    \ certificate trail for each group\n   terminates on a TH for that group.\n  \
    \                       *****     *****     @@@@@\n           Stratum 1     *\
    \ A *     * B *     @ R @\n                         *****     *****     @@@@@\n\
    \                             \\     /         /\n                           \
    \   \\   /         /\n                              *****     @@@@@          \
    \      *********\n                   2          * C *     @ S @              \
    \  * Alice *\n                              *****     @@@@@                *********\n\
    \                              /   \\     /\n                             /  \
    \   \\   /                     @@@@@@@@@\n                         *****     #####\
    \                     @ Helen @\n                   3     * D *     # X #    \
    \                 @@@@@@@@@\n                         *****     #####\n      \
    \                             /   \\                     #########\n         \
    \                         /     \\                    # Carol #\n            \
    \                  #####     #####                #########\n                \
    \   4          # Y #     # Z #\n                              #####     #####\n\
    \                 Figure 6: Hierarchical Overlapping Groups\n   The intent of\
    \ the scenario is to provide security separation, so that\n   servers cannot masquerade\
    \ as clients in other groups and clients\n   cannot masquerade as servers.  Assume,\
    \ for example, that Alice and\n   Helen belong to national standards laboratories\
    \ and their server keys\n   are used to confirm identity between members of each\
    \ group.  Carol is\n   a prominent corporation receiving standards products and\
    \ requiring\n   cryptographic authentication.  Perhaps under contract, host X\n\
    \   belonging to Carol has client keys for both Alice and Helen and\n   server\
    \ keys for Carol.  The Autokey protocol operates for each group\n   separately\
    \ while preserving security separation.  Host X can prove\n   identity in Carol\
    \ to clients Y and Z, but cannot prove to anybody\n   that it belongs to either\
    \ Alice or Helen.\n"
- title: 7.  Identity Schemes
  contents:
  - "7.  Identity Schemes\n   A digital signature scheme provides secure server authentication,\
    \ but\n   it does not provide protection against masquerade, unless the server\n\
    \   identity is verified by other means.  The PKI model requires a server\n  \
    \ to prove identity to the client by a certificate trail, but\n   independent\
    \ means such as a driver's license are required for a CA to\n   sign the server\
    \ certificate.  While Autokey supports this model by\n   default, in a hierarchical\
    \ ad hoc network, especially with server\n   discovery schemes like NTP manycast,\
    \ proving identity at each rest\n   stop on the trail must be an intrinsic capability\
    \ of Autokey itself.\n   While the identity scheme described in [RFC2875] is based\
    \ on a\n   ubiquitous Diffie-Hellman infrastructure, it is expensive to generate\n\
    \   and use when compared to others described in Appendix B.  In\n   principle,\
    \ an ordinary public key scheme could be devised for this\n   purpose, but the\
    \ most stringent Autokey design requires that every\n   challenge, even if duplicated,\
    \ results in a different acceptable\n   response.\n   1.  The scheme must have\
    \ a relatively long lifetime, certainly longer\n       than a typical certificate,\
    \ and have no specific lifetime or\n       expiration date.  At the time the scheme\
    \ is used, the host has\n       not yet synchronized to a proventic source, so\
    \ the scheme cannot\n       depend on time.\n   2.  As the scheme can be used\
    \ many times where the data might be\n       exposed to potential intruders, the\
    \ data must be either nonces or\n       encrypted nonces.\n   3.  The scheme should\
    \ allow designated servers to prove identity to\n       designated clients, but\
    \ not allow clients acting as servers to\n       prove identity to dependent clients.\n\
    \   4.  To the greatest extent possible, the scheme should represent a\n     \
    \  zero-knowledge proof; that is, the client should be able to\n       verify\
    \ that the server has the correct group key, but without\n       knowing the key\
    \ itself.\n   There are five schemes now implemented in the NTPv4 reference\n\
    \   implementation to prove identity: (1) private certificate (PC), (2)\n   trusted\
    \ certificate (TC), (3) a modified Schnorr algorithm (IFF aka\n   Identify Friendly\
    \ or Foe), (4) a modified Guillou-Quisquater (GQ)\n   algorithm, and (5) a modified\
    \ Mu-Varadharajan (MV) algorithm.  Not\n   all of these provide the same level\
    \ of protection and one, TC,\n   provides no protection but is included for comparison.\
    \  The following\n   is a brief summary description of each; details are given\
    \ in\n   Appendix B.\n   The PC scheme involves a private certificate as group\
    \ key.  The\n   certificate is distributed to all other group members by secure\
    \ means\n   and is never revealed outside the group.  In effect, the private\n\
    \   certificate is used as a symmetric key.  This scheme is used\n   primarily\
    \ for testing and development and is not recommended for\n   regular use and is\
    \ not considered further in this memo.\n   All other schemes involve a conventional\
    \ certificate trail as\n   described in [RFC5280].  This is the default scheme\
    \ when an identity\n   scheme is not required.  While the remaining identity schemes\n\
    \   incorporate TC, it is not by itself considered further in this memo.\n   The\
    \ three remaining schemes IFF, GQ, and MV involve a\n   cryptographically strong\
    \ challenge-response exchange where an\n   intruder cannot deduce the server key,\
    \ even after repeated\n   observations of multiple exchanges.  In addition, the\
    \ MV scheme is\n   properly described as a zero-knowledge proof, because the client\
    \ can\n   verify the server has the correct group key without either the server\n\
    \   or client knowing its value.  These schemes start when the client\n   sends\
    \ a nonce to the server, which then rolls its own nonce, performs\n   a mathematical\
    \ operation and sends the results to the client.  The\n   client performs another\
    \ mathematical operation and verifies the\n   results are correct.\n"
- title: 8.  Timestamps and Filestamps
  contents:
  - "8.  Timestamps and Filestamps\n   While public key signatures provide strong\
    \ protection against\n   misrepresentation of source, computing them is expensive.\
    \  This\n   invites the opportunity for an intruder to clog the client or server\n\
    \   by replaying old messages or originating bogus messages.  A client\n   receiving\
    \ such messages might be forced to verify what turns out to\n   be an invalid\
    \ signature and consume significant processor resources.\n   In order to foil\
    \ such attacks, every Autokey message carries a\n   timestamp in the form of the\
    \ NTP seconds when it was created.  If the\n   system clock is synchronized to\
    \ a proventic source, a signature is\n   produced with a valid (nonzero) timestamp.\
    \  Otherwise, there is no\n   signature and the timestamp is invalid (zero). \
    \ The protocol detects\n   and discards extension fields with old or duplicate\
    \ timestamps,\n   before any values are used or signatures are verified.\n   Signatures\
    \ are computed only when cryptographic values are created or\n   modified, which\
    \ is by design not very often.  Extension fields\n   carrying these signatures\
    \ are copied to messages as needed, but the\n   signatures are not recomputed.\
    \  There are three signature types:\n   1.  Cookie signature/timestamp.  The cookie\
    \ is signed when created by\n       the server and sent to the client.\n   2.\
    \  Autokey signature/timestamp.  The autokey values are signed when\n       the\
    \ key list is created.\n   3.  Public values signature/timestamp.  The public\
    \ key, certificate,\n       and leapsecond values are signed at the time of generation,\
    \ which\n       occurs when the system clock is first synchronized to a proventic\n\
    \       source, when the values have changed and about once per day after\n  \
    \     that, even if these values have not changed.\n   The most recent timestamp\
    \ received of each type is saved for\n   comparison.  Once a signature with a\
    \ valid timestamp has been\n   received, messages with invalid timestamps or earlier\
    \ valid\n   timestamps of the same type are discarded before the signature is\n\
    \   verified.  This is most important in broadcast mode, which could be\n   vulnerable\
    \ to a clogging attack without this test.\n   All cryptographic values used by\
    \ the protocol are time sensitive and\n   are regularly refreshed.  In particular,\
    \ files containing\n   cryptographic values used by signature and encryption algorithms\
    \ are\n   regenerated from time to time.  It is the intent that file\n   regenerations\
    \ occur without specific advance warning and without\n   requiring prior distribution\
    \ of the file contents.  While\n   cryptographic data files are not specifically\
    \ signed, every file is\n   associated with a filestamp showing the NTP seconds\
    \ at the creation\n   epoch.\n   Filestamps and timestamps can be compared in\
    \ any combination and use\n   the same conventions.  It is necessary to compare\
    \ them from time to\n   time to determine which are earlier or later.  Since these\
    \ quantities\n   have a granularity only to the second, such comparisons are ambiguous\n\
    \   if the values are in the same second.\n   It is important that filestamps\
    \ be proventic data; thus, they cannot\n   be produced unless the producer has\
    \ been synchronized to a proventic\n   source.  As such, the filestamps throughout\
    \ the NTP subnet represent\n   a partial ordering of all creation epochs and serve\
    \ as means to\n   expunge old data and ensure new data are consistent.  As the\
    \ data are\n   forwarded from server to client, the filestamps are preserved,\n\
    \   including those for certificate and leapseconds values.  Packets with\n  \
    \ older filestamps are discarded before spending cycles to verify the\n   signature.\n"
- title: 9.  Autokey Operations
  contents:
  - "9.  Autokey Operations\n   The NTP protocol has three principal modes of operation:\
    \ client/\n   server, symmetric, and broadcast and each has its own Autokey\n\
    \   program, or dance.  Autokey choreography is designed to be non-\n   intrusive\
    \ and to require no additional packets other than for regular\n   NTP operations.\
    \  The NTP and Autokey protocols operate simultaneously\n   and independently.\
    \  When the dance is complete, subsequent packets\n   are validated by the autokey\
    \ sequence and thus considered proventic\n   as well.  Autokey assumes NTP clients\
    \ poll servers at a relatively\n   low rate, such as once per minute or slower.\
    \  In particular, it\n   assumes that a request sent at one poll opportunity will\
    \ normally\n   result in a response before the next poll opportunity; however,\
    \ the\n   protocol is robust against a missed or duplicate response.\n   The server\
    \ dance was suggested by Steve Kent over lunch some time\n   ago, but considerably\
    \ modified since that meal.  The server keeps no\n   state for each client, but\
    \ uses a fast algorithm and a 32-bit random\n   private value (server seed) to\
    \ regenerate the cookie upon arrival of\n   a client packet.  The cookie is calculated\
    \ as the first 32 bits of\n   the autokey computed from the client and server\
    \ addresses, key ID\n   zero, and the server seed as cookie.  The cookie is used\
    \ for the\n   actual autokey calculation by both the client and server and is\
    \ thus\n   specific to each client separately.\n   In the server dance, the client\
    \ uses the cookie and each key ID on\n   the key list in turn to retrieve the\
    \ autokey and generate the MAC.\n   The server uses the same values to generate\
    \ the message digest and\n   verifies it matches the MAC.  It then generates the\
    \ MAC for the\n   response using the same values, but with the client and server\n\
    \   addresses interchanged.  The client generates the message digest and\n   verifies\
    \ it matches the MAC.  In order to deflect old replays, the\n   client verifies\
    \ that the key ID matches the last one sent.  In this\n   dance, the sequential\
    \ structure of the key list is not exploited, but\n   doing it this way simplifies\
    \ and regularizes the implementation while\n   making it nearly impossible for\
    \ an intruder to guess the next key ID.\n   In the broadcast dance, clients normally\
    \ do not send packets to the\n   server, except when first starting up.  At that\
    \ time, the client runs\n   the server dance to verify the server credentials\
    \ and calibrate the\n   propagation delay.  The dance requires the association\
    \ ID of the\n   particular server association, since there can be more than one\n\
    \   operating in the same server.  For this purpose, the server packet\n   includes\
    \ the association ID in every response message sent and, when\n   sending the\
    \ first packet after generating a new key list, it sends\n   the autokey values\
    \ as well.  After obtaining and verifying the\n   autokey values, no extension\
    \ fields are necessary and the client\n   verifies further server packets using\
    \ the autokey sequence.\n   The symmetric dance is similar to the server dance\
    \ and requires only\n   a small amount of state between the arrival of a request\
    \ and\n   departure of the response.  The key list for each direction is\n   generated\
    \ separately by each peer and used independently, but each is\n   generated with\
    \ the same cookie.  The cookie is conveyed in a way\n   similar to the server\
    \ dance, except that the cookie is a simple\n   nonce.  There exists a possible\
    \ race condition where each peer sends\n   a cookie request before receiving the\
    \ cookie response from the other\n   peer.  In this case, each peer winds up with\
    \ two values, one it\n   generated and one the other peer generated.  The ambiguity\
    \ is\n   resolved simply by computing the working cookie as the EXOR of the\n\
    \   two values.\n   Once the Autokey dance has completed, it is normally dormant.\
    \  In all\n   except the broadcast dance, packets are normally sent without\n\
    \   extension fields, unless the packet is the first one sent after\n   generating\
    \ a new key list or unless the client has requested the\n   cookie or autokey\
    \ values.  If for some reason the client clock is\n   stepped, rather than slewed,\
    \ all cryptographic and time values for\n   all associations are purged and the\
    \ dances in all associations\n   restarted from scratch.  This ensures that stale\
    \ values never\n   propagate beyond a clock step.\n"
- title: 10.  Autokey Protocol Messages
  contents:
  - "10.  Autokey Protocol Messages\n   The Autokey protocol data unit is the extension\
    \ field, one or more of\n   which can be piggybacked in the NTP packet.  An extension\
    \ field\n   contains either a request with optional data or a response with\n\
    \   optional data.  To avoid deadlocks, any number of responses can be\n   included\
    \ in a packet, but only one request can be.  A response is\n   generated for every\
    \ request, even if the requestor is not\n   synchronized to a proventic source,\
    \ but most contain meaningful data\n   only if the responder is synchronized to\
    \ a proventic source.  Some\n   requests and most responses carry timestamped\
    \ signatures.  The\n   signature covers the entire extension field, including\
    \ the timestamp\n   and filestamp, where applicable.  Only if the packet has correct\n\
    \   format, length, and message digest are cycles spent to verify the\n   signature.\n\
    \   There are currently eight Autokey requests and eight corresponding\n   responses.\
    \  The NTP packet format is described in [RFC5905] and the\n   extension field\
    \ format used for these messages is illustrated in\n   Figure 7.\n    0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |R|E|   Code    |  Field Type   |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Association ID                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Timestamp                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Filestamp                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          Value Length                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   \\                                                               /\n   / \
    \                            Value                             \\\n   \\     \
    \                                                          /\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Signature Length                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   \\                                                               /\n   / \
    \                          Signature                           \\\n   \\     \
    \                                                          /\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   \\                                                               /\n   / \
    \                     Padding (if needed)                      \\\n   \\     \
    \                                                          /\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 7: NTPv4 Extension Field Format\n   While each extension\
    \ field is zero-padded to a 4-octet (word)\n   boundary, the entire extension\
    \ is not word-aligned.  The Length field\n   covers the entire extension field,\
    \ including the Length and Padding\n   fields.  While the minimum field length\
    \ is 8 octets, a maximum field\n   length remains to be established.  The reference\
    \ implementation\n   discards any packet with a field length more than 1024 octets.\n\
    \   One or more extension fields follow the NTP packet header and the\n   last\
    \ followed by the MAC.  The extension field parser initializes a\n   pointer to\
    \ the first octet beyond the NTP packet header and\n   calculates the number of\
    \ octets remaining to the end of the packet.\n   If the remaining length is 20\
    \ (128-bit digest plus 4-octet key ID) or\n   22 (160-bit digest plus 4-octet\
    \ key ID), the remaining data are the\n   MAC and parsing is complete.  If the\
    \ remaining length is greater than\n   22, an extension field is present.  If\
    \ the remaining length is less\n   than 8 or not a multiple of 4, a format error\
    \ has occurred and the\n   packet is discarded; otherwise, the parser increments\
    \ the pointer by\n   the extension field length and then uses the same rules as\
    \ above to\n   determine whether a MAC is present or another extension field.\n\
    \   In Autokey the 8-bit Field Type field is interpreted as the version\n   number,\
    \ currently 2.  For future versions, values 1-7 have been\n   reserved for Autokey;\
    \ other values may be assigned for other\n   applications.  The 6-bit Code field\
    \ specifies the request or response\n   operation.  There are two flag bits: bit\
    \ 0 is the Response Flag (R)\n   and bit 1 is the Error Flag (E); the Reserved\
    \ field is unused and\n   should be set to 0.  The remaining fields will be described\
    \ later.\n   In the most common protocol operations, a client sends a request\
    \ to a\n   server with an operation code specified in the Code field and both\n\
    \   the R bit and E bit dim.  The server returns a response with the same\n  \
    \ operation code in the Code field and lights the R bit.  The server\n   can also\
    \ light the E bit in case of error.  Note that it is not\n   necessarily a protocol\
    \ error to send an unsolicited response with no\n   matching request.  If the\
    \ R bit is dim, the client sets the\n   Association ID field to the client association\
    \ ID, which the server\n   returns for verification.  If the two values do not\
    \ match, the\n   response is discarded as if never sent.  If the R bit is lit,\
    \ the\n   Association ID field is set to the server association ID obtained in\n\
    \   the initial protocol exchange.  If the Association ID field does not\n   match\
    \ any mobilized association ID, the request is discarded as if\n   never sent.\n\
    \   In some cases, not all fields may be present.  For requests, until a\n   client\
    \ has synchronized to a proventic source, signatures are not\n   valid.  In such\
    \ cases, the Timestamp field and Signature Length field\n   (which specifies the\
    \ length of the Signature) are zero and the\n   Signature field is absent.  Some\
    \ request and error response messages\n   carry no value or signature fields,\
    \ so in these messages only the\n   first two words (8 octets) are present.\n\
    \   The Timestamp and Filestamp words carry the seconds field of an NTP\n   timestamp.\
    \  The timestamp establishes the signature epoch of the data\n   field in the\
    \ message, while the filestamp establishes the generation\n   epoch of the file\
    \ that ultimately produced the data that is signed.\n   A signature and timestamp\
    \ are valid only when the signing host is\n   synchronized to a proventic source;\
    \ otherwise, the timestamp is zero.\n   A cryptographic data file can only be\
    \ generated if a signature is\n   possible; otherwise, the filestamp is zero,\
    \ except in the ASSOC\n   response message, where it contains the server status\
    \ word.\n   As in all other TCP/IP protocol designs, all data are sent in network\n\
    \   byte order.  Unless specified otherwise in the descriptions to\n   follow,\
    \ the data referred to are stored in the Value field.  The\n   Value Length field\
    \ specifies the length of the data in the Value\n   field.\n"
- title: 10.1.  No-Operation
  contents:
  - "10.1.  No-Operation\n   A No-operation request (Code 0) does nothing except return\
    \ an empty\n   response, which can be used as a crypto-ping.\n"
- title: 10.2.  Association Message (ASSOC)
  contents:
  - "10.2.  Association Message (ASSOC)\n   An Association Message (Code 1) is used\
    \ in the parameter exchange to\n   obtain the host name and status word.  The\
    \ request contains the\n   client status word in the Filestamp field and the Autokey\
    \ host name\n   in the Value field.  The response contains the server status word\
    \ in\n   the Filestamp field and the Autokey host name in the Value field.\n \
    \  The Autokey host name is not necessarily the DNS host name.  A valid\n   response\
    \ lights the ENAB bit and possibly others in the association\n   status word.\n\
    \   When multiple identity schemes are supported, the host status word\n   determines\
    \ which ones are available.  In server and symmetric modes,\n   the response status\
    \ word contains bits corresponding to the supported\n   schemes.  In all modes,\
    \ the scheme is selected based on the client\n   identity parameters that are\
    \ loaded at startup.\n"
- title: 10.3.  Certificate Message (CERT)
  contents:
  - "10.3.  Certificate Message (CERT)\n   A Certificate Message (Code 2) is used\
    \ in the certificate exchange to\n   obtain a certificate by subject name.  The\
    \ request contains the\n   subject name; the response contains the certificate\
    \ encoded in X.509\n   format with ASN.1 syntax as described in Appendix H.\n\
    \   If the subject name in the response does not match the issuer name,\n   the\
    \ exchange continues with the issuer name replacing the subject\n   name in the\
    \ request.  The exchange continues until a trusted, self-\n   signed certificate\
    \ is found and lights the CERT bit in the\n   association status word.\n"
- title: 10.4.  Cookie Message (COOKIE)
  contents:
  - "10.4.  Cookie Message (COOKIE)\n   The Cookie Message (Code 3) is used in server\
    \ and symmetric modes to\n   obtain the server cookie.  The request contains the\
    \ host public key\n   encoded with ASN.1 syntax as described in Appendix H.  The\
    \ response\n   contains the cookie encrypted by the public key in the request.\
    \  A\n   valid response lights the COOKIE bit in the association status word.\n"
- title: 10.5.  Autokey Message (AUTO)
  contents:
  - "10.5.  Autokey Message (AUTO)\n   The Autokey Message (Code 4) is used to obtain\
    \ the autokey values.\n   The request contains no value for a client or the autokey\
    \ values for\n   a symmetric peer.  The response contains two 32-bit words, the\
    \ first\n   is the final key ID, while the second is the index of the final key\n\
    \   ID.  A valid response lights the AUTO bit in the association status\n   word.\n"
- title: 10.6.  Leapseconds Values Message (LEAP)
  contents:
  - "10.6.  Leapseconds Values Message (LEAP)\n   The Leapseconds Values Message (Code\
    \ 5) is used to obtain the\n   leapseconds values as parsed from the leapseconds\
    \ table from the\n   National Institute of Standards and Technology (NIST).  The\
    \ request\n   contains no values.  The response contains three 32-bit integers:\n\
    \   first the NTP seconds of the latest leap event followed by the NTP\n   seconds\
    \ when the latest NIST table expires and then the TAI offset\n   following the\
    \ leap event.  A valid response lights the LEAP bit in\n   the association status\
    \ word.\n"
- title: 10.7.  Sign Message (SIGN)
  contents:
  - "10.7.  Sign Message (SIGN)\n   The Sign Message (Code 6) requests that the server\
    \ sign and return a\n   certificate presented in the request.  The request contains\
    \ the\n   client certificate encoded in X.509 format with ASN.1 syntax as\n  \
    \ described in Appendix H.  The response contains the client\n   certificate signed\
    \ by the server private key.  A valid response\n   lights the SIGN bit in the\
    \ association status word.\n"
- title: 10.8.  Identity Messages (IFF, GQ, MV)
  contents:
  - "10.8.  Identity Messages (IFF, GQ, MV)\n   The Identity Messages (Code 7 (IFF),\
    \ 8 (GQ), or 9 (MV)) contains the\n   client challenge, usually a 160- or 512-bit\
    \ nonce.  The response\n   contains the result of the mathematical operation defined\
    \ in\n   Appendix B.  The Response is encoded in ASN.1 syntax as described in\n\
    \   Appendix H.  A valid response lights the VRFY bit in the association\n   status\
    \ word.\n"
- title: 11.  Autokey State Machine
  contents:
  - "11.  Autokey State Machine\n   This section describes the formal model of the\
    \ Autokey state machine,\n   its state variables and the state transition functions.\n"
- title: 11.1.  Status Word
  contents:
  - "11.1.  Status Word\n   The server implements a host status word, while each client\n\
    \   implements an association status word.  These words have the format\n   and\
    \ content shown in Figure 8.  The low-order 16 bits of the status\n   word define\
    \ the state of the Autokey dance, while the high-order 16\n   bits specify the\
    \ Numerical Identifier (NID) as generated by the\n   OpenSSL library of the OID\
    \ for one of the message digest/signature\n   encryption schemes defined in [RFC3279].\
    \  The NID values for the\n   digest/signature algorithms defined in RFC 3279\
    \ are as follows:\n          +------------------------+----------------------+-----+\n\
    \          |        Algorithm       | OID                  | NID |\n         \
    \ +------------------------+----------------------+-----+\n          |       \
    \  pkcs-1         | 1.2.840.113549.1.1   |   2 |\n          |           md2  \
    \        | 1.2.840.113549.2.2   |   3 |\n          |           md5          |\
    \ 1.2.840.113549.2.5   |   4 |\n          |      rsaEncryption     | 1.2.840.113549.1.1.1\
    \ |   6 |\n          |  md2WithRSAEncryption  | 1.2.840.113549.1.1.2 |   7 |\n\
    \          |  md5WithRSAEncryption  | 1.2.840.113549.1.1.4 |   8 |\n         \
    \ |         id-sha1        | 1.3.14.3.2.26        |  64 |\n          | sha-1WithRSAEncryption\
    \ | 1.2.840.113549.1.1.5 |  65 |\n          |     id-dsa-wth-sha1    | 1.2.840.10040.4.3\
    \    | 113 |\n          |         id-dsa         | 1.2.840.10040.4.1    | 116\
    \ |\n          +------------------------+----------------------+-----+\n   Bits\
    \ 24-31 are reserved for server use, while bits 16-23 are reserved\n   for client\
    \ use.  In the host portion, bits 24-27 specify the\n   available identity schemes,\
    \ while bits 28-31 specify the server\n   capabilities.  There are two additional\
    \ bits implemented separately.\n                        1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Digest / Signature NID     |    Client     | Ident |  Host |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                           Figure 8: Status Word\n   The host status word is\
    \ included in the ASSOC request and response\n   messages.  The client copies\
    \ this word to the association status word\n   and then lights additional bits\
    \ as the dance proceeds.  Once enabled,\n   these bits ordinarily never become\
    \ dark unless a general reset occurs\n   and the protocol is restarted from the\
    \ beginning.\n   The host status bits are defined as follows:\n   o  ENAB (31)\
    \ is lit if the server implements the Autokey protocol.\n   o  LVAL (30) is lit\
    \ if the server has installed leapseconds values,\n      either from the NIST\
    \ leapseconds file or from another server.\n   o  Bits (28-29) are reserved -\
    \ always dark.\n   o  Bits 24-27 select which server identity schemes are available.\n\
    \      While specific coding for various schemes is yet to be determined,\n  \
    \    the schemes available in the reference implementation and\n      described\
    \ in Appendix B include the following:\n      *  none - Trusted Certificate (TC)\
    \ Scheme (default).\n      *  PC (27) Private Certificate Scheme.\n      *  IFF\
    \ (26) Schnorr aka Identify-Friendly-or-Foe Scheme.\n      *  GQ (25) Guillard-Quisquater\
    \ Scheme.\n      *  MV (24) Mu-Varadharajan Scheme.\n   o  The PC scheme is exclusive\
    \ of any other scheme.  Otherwise, the\n      IFF, GQ, and MV bits can be enabled\
    \ in any combination.\n   The association status bits are defined as follows:\n\
    \   o  CERT (23): Lit when the trusted host certificate and public key\n     \
    \ are validated.\n   o  VRFY (22): Lit when the trusted host identity credentials\
    \ are\n      confirmed.\n   o  PROV (21): Lit when the server signature is verified\
    \ using its\n      public key and identity credentials.  Also called the proventic\n\
    \      bit elsewhere in this memo.  When enabled, signed values in\n      subsequent\
    \ messages are presumed proventic.\n   o  COOK (20): Lit when the cookie is received\
    \ and validated.  When\n      lit, key lists with nonzero cookies are generated;\
    \ when dim, the\n      cookie is zero.\n   o  AUTO (19): Lit when the autokey\
    \ values are received and validated.\n      When lit, clients can validate packets\
    \ without extension fields\n      according to the autokey sequence.\n   o  SIGN\
    \ (18): Lit when the host certificate is signed by the server.\n   o  LEAP (17):\
    \ Lit when the leapseconds values are received and\n      validated.\n   o  Bit\
    \ 16: Reserved - always dark.\n   There are three additional bits: LIST, SYNC,\
    \ and PEER not included in\n   the association status word.  LIST is lit when\
    \ the key list is\n   regenerated and dim when the autokey values have been transmitted.\n\
    \   This is necessary to avoid livelock under some conditions.  SYNC is\n   lit\
    \ when the client has synchronized to a proventic source and never\n   dim after\
    \ that.  PEER is lit when the server has synchronized, as\n   indicated in the\
    \ NTP header, and never dim after that.\n"
- title: 11.2.  Host State Variables
  contents:
  - "11.2.  Host State Variables\n   The following is a list of host state variables.\n\
    \   Host Name:           The name of the host, by default the string\n       \
    \                 returned by the Unix gethostname() library\n               \
    \         function.  In the reference implementation, this\n                 \
    \       is a configurable value.\n   Host Status Word:    This word is initialized\
    \ when the host first\n                        starts up.  The format is described\
    \ above.\n   Host Key:            The RSA public/private key pair used to encrypt/\n\
    \                        decrypt cookies.  This is also the default sign\n   \
    \                     key.\n   Sign Key:            The RSA or Digital Signature\
    \ Algorithm (DSA)\n                        public/private key pair used to encrypt/decrypt\n\
    \                        signatures when the host key is not used for\n      \
    \                  this purpose.\n   Sign Digest:         The message digest algorithm\
    \ used to compute the\n                        message digest before encryption.\n\
    \   IFF Parameters:      The parameters used in the optional IFF identity\n  \
    \                      scheme described in Appendix B.\n   GQ Parameters:    \
    \   The parameters used in the optional GQ identity\n                        scheme\
    \ described in Appendix B.\n   MV Parameters:       The parameters used in the\
    \ optional MV identity\n                        scheme described in Appendix B.\n\
    \   Server Seed:         The private value hashed with the IP addresses\n    \
    \                    and key identifier to construct the cookie.\n   CIS:    \
    \             Certificate Information Structure.  This\n                     \
    \   structure includes certain information fields\n                        from\
    \ an X.509v3 certificate, together with the\n                        certificate\
    \ itself.  The fields extracted\n                        include the subject and\
    \ issuer names, subject\n                        public key and message digest\
    \ algorithm\n                        (pointers), and the beginning and end of\
    \ the\n                        valid period in NTP seconds.\n                \
    \        The certificate itself is stored as an extension\n                  \
    \      field in network byte order so it can be copied\n                     \
    \   intact to the message.  The structure is signed\n                        using\
    \ the sign key and carries the public values\n                        timestamp\
    \ at signature time and the filestamp of\n                        the original\
    \ certificate file.  The structure is\n                        used by the CERT\
    \ response message and SIGN\n                        request and response messages.\n\
    \                        A flags field in the CIS determines the status\n    \
    \                    of the certificate.  The field is encoded as\n          \
    \              follows:\n                        *  TRUST (0x01) - The certificate\
    \ has been\n                           signed by a trusted issuer.  If the\n \
    \                          certificate is self-signed and contains\n         \
    \                  \"trustRoot\" in the Extended Key Usage field,\n          \
    \                 this bit is lit when the CIS is constructed.\n             \
    \           *  SIGN (0x02) - The certificate signature has\n                 \
    \          been verified.  If the certificate is self-\n                     \
    \      signed and verified using the contained\n                           public\
    \ key, this bit is lit when the CIS is\n                           constructed.\n\
    \                        *  VALID (0x04) - The certificate is valid and\n    \
    \                       can be used to verify signatures.  This bit\n        \
    \                   is lit when a trusted certificate has been\n             \
    \              found on a valid certificate trail.\n                        *\
    \  PRIV (0x08) - The certificate is private and\n                           not\
    \ to be revealed.  If the certificate is\n                           self-signed\
    \ and contains \"Private\" in the\n                           Extended Key Usage\
    \ field, this bit is lit\n                           when the CIS is constructed.\n\
    \                        *  ERROR (0x80) - The certificate is defective\n    \
    \                       and not to be used in any way.\n   Certificate List: \
    \   CIS structures are stored on the certificate\n                        list\
    \ in order of arrival, with the most recently\n                        received\
    \ CIS placed first on the list.  The list\n                        is initialized\
    \ with the CIS for the host\n                        certificate, which is read\
    \ from the host\n                        certificate file.  Additional CIS entries\
    \ are\n                        added to the list as certificates are obtained\n\
    \                        from the servers during the certificate\n           \
    \             exchange.  CIS entries are discarded if\n                      \
    \  overtaken by newer ones.\n                        The following values are\
    \ stored as an extension\n                        field structure in network byte\
    \ order so they\n                        can be copied intact to the message.\
    \  They are\n                        used to send some Autokey requests and\n\
    \                        responses.  All but the Host Name Values\n          \
    \              structure are signed using the sign key and all\n             \
    \           carry the public values timestamp at signature\n                 \
    \       time.\n   Host Name Values:    This is used to send ASSOC request and\
    \ response\n                        messages.  It contains the host status word\
    \ and\n                        host name.\n   Public Key Values:   This is used\
    \ to send the COOKIE request message.\n                        It contains the\
    \ public encryption key used for\n                        the COOKIE response\
    \ message.\n   Leapseconds Values:  This is used to send the LEAP response message.\n\
    \                        It contains the leapseconds values in the LEAP\n    \
    \                    message description.\n"
- title: 11.3.  Client State Variables (all modes)
  contents:
  - "11.3.  Client State Variables (all modes)\n   The following is a list of state\
    \ variables used by the various dances\n   in all modes.\n   Association ID: \
    \          The association ID used in responses.  It\n                       \
    \      is assigned when the association is\n                             mobilized.\n\
    \   Association Status Word:  The status word copied from the ASSOC\n        \
    \                     response; subsequently modified by the\n               \
    \              state machine.\n   Subject Name:             The server host name\
    \ copied from the ASSOC\n                             response.\n   Issuer Name:\
    \              The host name signing the certificate.  It\n                  \
    \           is extracted from the current server\n                           \
    \  certificate upon arrival and used to\n                             request\
    \ the next host on the certificate\n                             trail.\n   Server\
    \ Public Key:        The public key used to decrypt signatures.\n            \
    \                 It is extracted from the server host\n                     \
    \        certificate.\n   Server Message Digest:    The digest/signature scheme\
    \ determined in\n                             the parameter exchange.\n   Group\
    \ Key:                A set of values used by the identity\n                 \
    \            exchange.  It identifies the cryptographic\n                    \
    \         compartment shared by the server and\n                             client.\n\
    \   Receive Cookie Values:    The cookie returned in a COOKIE response,\n    \
    \                         together with its timestamp and filestamp.\n   Receive\
    \ Autokey Values:   The autokey values returned in an AUTO\n                 \
    \            response, together with its timestamp and\n                     \
    \        filestamp.\n   Send Autokey Values:      The autokey values with signature\
    \ and\n                             timestamps.\n   Key List:                \
    \ A sequence of key IDs starting with the\n                             autokey\
    \ seed and each pointing to the next.\n                             It is computed,\
    \ timestamped, and signed at\n                             the next poll opportunity\
    \ when the key list\n                             becomes empty.\n   Current Key\
    \ Number:       The index of the entry on the Key List to\n                  \
    \           be used at the next poll opportunity.\n"
- title: 11.4.  Protocol State Transitions
  contents:
  - "11.4.  Protocol State Transitions\n   The protocol state machine is very simple\
    \ but robust.  The state is\n   determined by the client status word bits defined\
    \ above.  The state\n   transitions of the three dances are shown below.  The\
    \ capitalized\n   truth values represent the client status bits.  All bits are\n\
    \   initialized as dark and are lit upon the arrival of a specific\n   response\
    \ message as detailed above.\n"
- title: 11.4.1.  Server Dance
  contents:
  - "11.4.1.  Server Dance\n   The server dance begins when the client sends an ASSOC\
    \ request to the\n   server.  The clock is updated when PREV is lit and the dance\
    \ ends\n   when LEAP is lit.  In this dance, the autokey values are not used,\
    \ so\n   an autokey exchange is not necessary.  Note that the SIGN and LEAP\n\
    \   requests are not issued until the client has synchronized to a\n   proventic\
    \ source.  Subsequent packets without extension fields are\n   validated by the\
    \ autokey sequence.  This example and others assumes\n   the IFF identity scheme\
    \ has been selected in the parameter exchange.\n"
- title: 1       while (1) {
  contents:
  - '1       while (1) {

    '
- title: 2               wait_for_next_poll;
  contents:
  - '2               wait_for_next_poll;

    '
- title: 3               make_NTP_header;
  contents:
  - '3               make_NTP_header;

    '
- title: 4               if (response_ready)
  contents:
  - '4               if (response_ready)

    '
- title: 5                       send_response;
  contents:
  - '5                       send_response;

    '
- title: 6               if (!ENB)             /* parameter exchange */
  contents:
  - '6               if (!ENB)             /* parameter exchange */

    '
- title: 7                       ASSOC_request;
  contents:
  - '7                       ASSOC_request;

    '
- title: 8               else if (!CERT)       /* certificate exchange */
  contents:
  - '8               else if (!CERT)       /* certificate exchange */

    '
- title: 9                       CERT_request(Host_Name);
  contents:
  - '9                       CERT_request(Host_Name);

    '
- title: 10              else if (!IFF)        /* identity exchange */
  contents:
  - '10              else if (!IFF)        /* identity exchange */

    '
- title: 11                      IFF_challenge;
  contents:
  - '11                      IFF_challenge;

    '
- title: 12              else if (!COOK)       /* cookie exchange */
  contents:
  - '12              else if (!COOK)       /* cookie exchange */

    '
- title: 13                      COOKIE_request;
  contents:
  - '13                      COOKIE_request;

    '
- title: 14              else if (!SYNC)       /* wait for synchronization */
  contents:
  - '14              else if (!SYNC)       /* wait for synchronization */

    '
- title: 15                      continue;
  contents:
  - '15                      continue;

    '
- title: 16              else if (!SIGN)       /* sign exchange */
  contents:
  - '16              else if (!SIGN)       /* sign exchange */

    '
- title: 17                      SIGN_request(Host_Certificate);
  contents:
  - '17                      SIGN_request(Host_Certificate);

    '
- title: 18              else if (!LEAP)       /* leapsecond values exchange */
  contents:
  - '18              else if (!LEAP)       /* leapsecond values exchange */

    '
- title: 19                      LEAP_request;
  contents:
  - '19                      LEAP_request;

    '
- title: 20              send packet;
  contents:
  - '20              send packet;

    '
- title: 21      }
  contents:
  - "21      }\n                         Figure 9: Server Dance\n   If the server\
    \ refreshes the private seed, the cookie becomes invalid.\n   The server responds\
    \ to an invalid cookie with a crypto-NAK message,\n   which causes the client\
    \ to restart the protocol from the beginning.\n"
- title: 11.4.2.  Broadcast Dance
  contents:
  - "11.4.2.  Broadcast Dance\n   The broadcast dance is similar to the server dance\
    \ with the cookie\n   exchange replaced by the autokey values exchange.  The broadcast\n\
    \   dance begins when the client receives a broadcast packet including an\n  \
    \ ASSOC response with the server association ID.  This mobilizes a\n   client\
    \ association in order to proventicate the source and calibrate\n   the propagation\
    \ delay.  The dance ends when the LEAP bit is lit,\n   after which the client\
    \ sends no further packets.  Normally, the\n   broadcast server includes an ASSOC\
    \ response in each transmitted\n   packet.  However, when the server generates\
    \ a new key list, it\n   includes an AUTO response instead.\n   In the broadcast\
    \ dance, extension fields are used with every packet,\n   so the cookie is always\
    \ zero and no cookie exchange is necessary.  As\n   in the server dance, the clock\
    \ is updated when PREV is lit and the\n   dance ends when LEAP is lit.  Note that\
    \ the SIGN and LEAP requests\n   are not issued until the client has synchronized\
    \ to a proventic\n   source.  Subsequent packets without extension fields are\
    \ validated by\n   the autokey sequence.\n"
- title: 1       while (1) {
  contents:
  - '1       while (1) {

    '
- title: 2               wait_for_next_poll;
  contents:
  - '2               wait_for_next_poll;

    '
- title: 3               make_NTP_header;
  contents:
  - '3               make_NTP_header;

    '
- title: 4               if (response_ready)
  contents:
  - '4               if (response_ready)

    '
- title: 5                       send_response;
  contents:
  - '5                       send_response;

    '
- title: 6               if (!ENB)              /* parameters exchange */
  contents:
  - '6               if (!ENB)              /* parameters exchange */

    '
- title: 7                       ASSOC_request;
  contents:
  - '7                       ASSOC_request;

    '
- title: 8               else if (!CERT)        /* certificate exchange */
  contents:
  - '8               else if (!CERT)        /* certificate exchange */

    '
- title: 9                       CERT_request(Host_Name);
  contents:
  - '9                       CERT_request(Host_Name);

    '
- title: 10              else if (!IFF)         /* identity exchange */
  contents:
  - '10              else if (!IFF)         /* identity exchange */

    '
- title: 11                      IFF_challenge;
  contents:
  - '11                      IFF_challenge;

    '
- title: 12              else if (!AUT)         /* autokey values exchange */
  contents:
  - '12              else if (!AUT)         /* autokey values exchange */

    '
- title: 13                      AUTO_request;
  contents:
  - '13                      AUTO_request;

    '
- title: 14              else if (!SYNC)        /* wait for synchronization */
  contents:
  - '14              else if (!SYNC)        /* wait for synchronization */

    '
- title: 15                      continue;
  contents:
  - '15                      continue;

    '
- title: 16              else if (!SIGN)        /* sign exchange */
  contents:
  - '16              else if (!SIGN)        /* sign exchange */

    '
- title: 17                      SIGN_request(Host_Certificate);
  contents:
  - '17                      SIGN_request(Host_Certificate);

    '
- title: 18              else if (!LEAP)        /* leapsecond values exchange */
  contents:
  - '18              else if (!LEAP)        /* leapsecond values exchange */

    '
- title: 19                      LEAP_request;
  contents:
  - '19                      LEAP_request;

    '
- title: 20              send NTP_packet;
  contents:
  - '20              send NTP_packet;

    '
- title: 21      }
  contents:
  - "21      }\n                       Figure 10: Broadcast Dance\n   If a packet\
    \ is lost and the autokey sequence is broken, the client\n   hashes the current\
    \ autokey until either it matches the previous\n   autokey or the number of hashes\
    \ exceeds the count given in the\n   autokey values.  If the latter, the client\
    \ sends an AUTO request to\n   retrieve the autokey values.  If the client receives\
    \ a crypto-NAK\n   during the dance, or if the association ID changes, the client\n\
    \   restarts the protocol from the beginning.\n"
- title: 11.4.3.  Symmetric Dance
  contents:
  - "11.4.3.  Symmetric Dance\n   The symmetric dance is intricately choreographed.\
    \  It begins when the\n   active peer sends an ASSOC request to the passive peer.\
    \  The passive\n   peer mobilizes an association and both peers step a three-way\
    \ dance\n   where each peer completes a parameter exchange with the other.  Until\n\
    \   one of the peers has synchronized to a proventic source (which could\n   be\
    \ the other peer) and can sign messages, the other peer loops\n   waiting for\
    \ a valid timestamp in the ensuing CERT response.\n"
- title: 1       while (1) {
  contents:
  - '1       while (1) {

    '
- title: 2               wait_for_next_poll;
  contents:
  - '2               wait_for_next_poll;

    '
- title: 3               make_NTP_header;
  contents:
  - '3               make_NTP_header;

    '
- title: 4               if (!ENB)             /* parameters exchange */
  contents:
  - '4               if (!ENB)             /* parameters exchange */

    '
- title: 5                       ASSOC_request;
  contents:
  - '5                       ASSOC_request;

    '
- title: 6               else if (!CERT)       /* certificate exchange */
  contents:
  - '6               else if (!CERT)       /* certificate exchange */

    '
- title: 7                       CERT_request(Host_Name);
  contents:
  - '7                       CERT_request(Host_Name);

    '
- title: 8               else if (!IFF)        /* identity exchange */
  contents:
  - '8               else if (!IFF)        /* identity exchange */

    '
- title: 9                       IFF_challenge;
  contents:
  - '9                       IFF_challenge;

    '
- title: 10              else if (!COOK && PEER) /* cookie exchange */
  contents:
  - '10              else if (!COOK && PEER) /* cookie exchange */

    '
- title: 11                      COOKIE_request);
  contents:
  - '11                      COOKIE_request);

    '
- title: 12              else if (!AUTO)       /* autokey values exchange */
  contents:
  - '12              else if (!AUTO)       /* autokey values exchange */

    '
- title: 13                      AUTO_request;
  contents:
  - '13                      AUTO_request;

    '
- title: 14              else if (LIST)        /* autokey values response */
  contents:
  - '14              else if (LIST)        /* autokey values response */

    '
- title: 15                      AUTO_response;
  contents:
  - '15                      AUTO_response;

    '
- title: 16              else if (!SYNC)       /* wait for synchronization */
  contents:
  - '16              else if (!SYNC)       /* wait for synchronization */

    '
- title: 17                      continue;
  contents:
  - '17                      continue;

    '
- title: 18              else if (!SIGN)       /* sign exchange */
  contents:
  - '18              else if (!SIGN)       /* sign exchange */

    '
- title: 19                      SIGN_request;
  contents:
  - '19                      SIGN_request;

    '
- title: 20              else if (!LEAP)       /* leapsecond values exchange */
  contents:
  - '20              else if (!LEAP)       /* leapsecond values exchange */

    '
- title: 21                      LEAP_request;
  contents:
  - '21                      LEAP_request;

    '
- title: 22              send NTP_packet;
  contents:
  - '22              send NTP_packet;

    '
- title: 23      }
  contents:
  - "23      }\n                       Figure 11: Symmetric Dance\n   Once a peer\
    \ has synchronized to a proventic source, it includes\n   timestamped signatures\
    \ in its messages.  The other peer, which has\n   been stalled waiting for valid\
    \ timestamps, now mates the dance.  It\n   retrieves the now nonzero cookie using\
    \ a cookie exchange and then the\n   updated autokey values using an autokey exchange.\n\
    \   As in the broadcast dance, if a packet is lost and the autokey\n   sequence\
    \ broken, the peer hashes the current autokey until either it\n   matches the\
    \ previous autokey or the number of hashes exceeds the\n   count given in the\
    \ autokey values.  If the latter, the client sends\n   an AUTO request to retrieve\
    \ the autokey values.  If the peer receives\n   a crypto-NAK during the dance,\
    \ or if the association ID changes, the\n   peer restarts the protocol from the\
    \ beginning.\n"
- title: 11.5.  Error Recovery
  contents:
  - "11.5.  Error Recovery\n   The Autokey protocol state machine includes provisions\
    \ for various\n   kinds of error conditions that can arise due to missing files,\n\
    \   corrupted data, protocol violations, and packet loss or misorder, not\n  \
    \ to mention hostile intrusion.  This section describes how the\n   protocol responds\
    \ to reachability and timeout events that can occur\n   due to such errors.\n\
    \   A persistent NTP association is mobilized by an entry in the\n   configuration\
    \ file, while an ephemeral association is mobilized upon\n   the arrival of a\
    \ broadcast or symmetric active packet with no\n   matching association.  Subsequently,\
    \ a general reset reinitializes\n   all association variables to the initial state\
    \ when first mobilized.\n   In addition, if the association is ephemeral, the\
    \ association is\n   demobilized and all resources acquired are returned to the\
    \ system.\n   Every NTP association has two variables that maintain the liveness\n\
    \   state of the protocol, the 8-bit reach register and the unreach\n   counter\
    \ defined in [RFC5905].  At every poll interval, the reach\n   register is shifted\
    \ left, the low order bit is dimmed and the high\n   order bit is lost.  At the\
    \ same time, the unreach counter is\n   incremented by one.  If an arriving packet\
    \ passes all authentication\n   and sanity checks, the rightmost bit of the reach\
    \ register is lit and\n   the unreach counter is set to zero.  If any bit in the\
    \ reach register\n   is lit, the server is reachable; otherwise, it is unreachable.\n\
    \   When the first poll is sent from an association, the reach register\n   and\
    \ unreach counter are set to zero.  If the unreach counter reaches\n   16, the\
    \ poll interval is doubled.  In addition, if association is\n   persistent, it\
    \ is demobilized.  This reduces the network load for\n   packets that are unlikely\
    \ to elicit a response.\n   At each state in the protocol, the client expects\
    \ a particular\n   response from the server.  A request is included in the NTP\
    \ packet\n   sent at each poll interval until a valid response is received or\
    \ a\n   general reset occurs, in which case the protocol restarts from the\n \
    \  beginning.  A general reset also occurs for an association when an\n   unrecoverable\
    \ protocol error occurs.  A general reset occurs for all\n   associations when\
    \ the system clock is first synchronized or the clock\n   is stepped or when the\
    \ server seed is refreshed.\n   There are special cases designed to quickly respond\
    \ to broken\n   associations, such as when a server restarts or refreshes keys.\n\
    \   Since the client cookie is invalidated, the server rejects the next\n   client\
    \ request and returns a crypto-NAK packet.  Since the crypto-NAK\n   has no MAC,\
    \ the problem for the client is to determine whether it is\n   legitimate or the\
    \ result of intruder mischief.  In order to reduce\n   the vulnerability in such\
    \ cases, the crypto-NAK, as well as all\n   responses, is believed only if the\
    \ result of a previous packet sent\n   by the client and not a replay, as confirmed\
    \ by the NTP on-wire\n   protocol.  While this defense can be easily circumvented\
    \ by a man-in-\n   the-middle, it does deflect other kinds of intruder warfare.\n\
    \   There are a number of situations where some event happens that causes\n  \
    \ the remaining autokeys on the key list to become invalid.  When one\n   of these\
    \ situations happens, the key list and associated autokeys in\n   the key cache\
    \ are purged.  A new key list, signature, and timestamp\n   are generated when\
    \ the next NTP message is sent, assuming there is\n   one.  The following is a\
    \ list of these situations:\n   1.  When the cookie value changes for any reason.\n\
    \   2.  When the poll interval is changed.  In this case, the calculated\n   \
    \    expiration times for the keys become invalid.\n   3.  If a problem is detected\
    \ when an entry is fetched from the key\n       list.  This could happen if the\
    \ key was marked non-trusted or\n       timed out, either of which implies a software\
    \ bug.\n"
- title: 12.  Security Considerations
  contents:
  - "12.  Security Considerations\n   This section discusses the most obvious security\
    \ vulnerabilities in\n   the various Autokey dances.  In the following discussion,\
    \ the\n   cryptographic algorithms and private values themselves are assumed\n\
    \   secure; that is, a brute force cryptanalytic attack will not reveal\n   the\
    \ host private key, sign private key, cookie value, identity\n   parameters, server\
    \ seed or autokey seed.  In addition, an intruder\n   will not be able to predict\
    \ random generator values.\n"
- title: 12.1.  Protocol Vulnerability
  contents:
  - "12.1.  Protocol Vulnerability\n   While the protocol has not been subjected to\
    \ a formal analysis, a few\n   preliminary assertions can be made.  In the client/server\
    \ and\n   symmetric dances, the underlying NTP on-wire protocol is resistant to\n\
    \   lost, duplicate, and bogus packets, even if the clock is not\n   synchronized,\
    \ so the protocol is not vulnerable to a wiretapper\n   attack.  The on-wire protocol\
    \ is resistant to replays of both the\n   client request packet and the server\
    \ reply packet.  A man-in-the-\n   middle attack, even if it could simulate a\
    \ valid cookie, could not\n   prove identity.\n   In the broadcast dance, the\
    \ client begins with a volley in client/\n   server mode to obtain the autokey\
    \ values and signature, so has the\n   same protection as in that mode.  When\
    \ continuing in receive-only\n   mode, a wiretapper cannot produce a key list\
    \ with valid signed\n   autokey values.  If it replays an old packet, the client\
    \ will reject\n   it by the timestamp check.  The most it can do is manufacture\
    \ a\n   future packet causing clients to repeat the autokey hash operations\n\
    \   until exceeding the maximum key number.  If this happens the\n   broadcast\
    \ client temporarily reverts to client mode to refresh the\n   autokey values.\n\
    \   By assumption, a man-in-the-middle attacker that intercepts a packet\n   cannot\
    \ break the wire or delay an intercepted packet.  If this\n   assumption is removed,\
    \ the middleman could intercept a broadcast\n   packet and replace the data and\
    \ message digest without detection by\n   the clients.\n   As mentioned previously\
    \ in this memo, the TC identity scheme is\n   vulnerable to a man-in-the-middle\
    \ attack where an intruder could\n   create a bogus certificate trail.  To foil\
    \ this kind of attack,\n   either the PC, IFF, GQ, or MV identity schemes must\
    \ be used.\n   A client instantiates cryptographic variables only if the server\
    \ is\n   synchronized to a proventic source.  A server does not sign values or\n\
    \   generate cryptographic data files unless synchronized to a proventic\n   source.\
    \  This raises an interesting issue: how does a client generate\n   proventic\
    \ cryptographic files before it has ever been synchronized to\n   a proventic\
    \ source?  (Who shaves the barber if the barber shaves\n   everybody in town who\
    \ does not shave himself?)  In principle, this\n   paradox is resolved by assuming\
    \ the primary (stratum 1) servers are\n   proventicated by external phenomenological\
    \ means.\n"
- title: 12.2.  Clogging Vulnerability
  contents:
  - "12.2.  Clogging Vulnerability\n   A self-induced clogging incident cannot happen,\
    \ since signatures are\n   computed only when the data have changed and the data\
    \ do not change\n   very often.  For instance, the autokey values are signed only\
    \ when\n   the key list is regenerated, which happens about once an hour, while\n\
    \   the public values are signed only when one of them is updated during\n   a\
    \ dance or the server seed is refreshed, which happens about once per\n   day.\n\
    \   There are two clogging vulnerabilities exposed in the protocol\n   design:\
    \ an encryption attack where the intruder hopes to clog the\n   victim server\
    \ with needless cryptographic calculations, and a\n   decryption attack where\
    \ the intruder attempts to clog the victim\n   client with needless cryptographic\
    \ calculations.  Autokey uses public\n   key cryptography and the algorithms that\
    \ perform these functions\n   consume significant resources.\n   In client/server\
    \ and peer dances, an encryption hazard exists when a\n   wiretapper replays prior\
    \ cookie request messages at speed.  There is\n   no obvious way to deflect such\
    \ attacks, as the server retains no\n   state between requests.  Replays of cookie\
    \ request or response\n   messages are detected and discarded by the client on-wire\
    \ protocol.\n   In broadcast mode, a decryption hazard exists when a wiretapper\n\
    \   replays autokey response messages at speed.  Once synchronized to a\n   proventic\
    \ source, a legitimate extension field with timestamp the\n   same as or earlier\
    \ than the most recently received of that type is\n   immediately discarded. \
    \ This foils a man-in-the-middle cut-and-paste\n   attack using an earlier response,\
    \ for example.  A legitimate\n   extension field with timestamp in the future\
    \ is unlikely, as that\n   would require predicting the autokey sequence.  However,\
    \ this causes\n   the client to refresh and verify the autokey values and signature.\n\
    \   A determined attacker can destabilize the on-wire protocol or an\n   Autokey\
    \ dance in various ways by replaying old messages before the\n   client or peer\
    \ has synchronized for the first time.  For instance,\n   replaying an old symmetric\
    \ mode message before the peers have\n   synchronize will prevent the peers from\
    \ ever synchronizing.\n   Replaying out of order Autokey messages in any mode\
    \ during a dance\n   could prevent the dance from ever completing.  There is nothing\
    \ new\n   in these kinds of attack; a similar vulnerability even exists in TCP.\n"
- title: 13.  IANA Consideration
  contents:
  - "13.  IANA Consideration\n   The IANA has added the following entries to the NTP\
    \ Extensions Field\n   Types registry:\n      +------------+------------------------------------------+\n\
    \      | Field Type | Meaning                                  |\n      +------------+------------------------------------------+\n\
    \      |   0x0002   | No-Operation Request                     |\n      |   0x8002\
    \   | No-Operation Response                    |\n      |   0xC002   | No-Operation\
    \ Error Response              |\n      |   0x0102   | Association Message Request\
    \              |\n      |   0x8102   | Association Message Response          \
    \   |\n      |   0xC102   | Association Message Error Response       |\n     \
    \ |   0x0202   | Certificate Message Request              |\n      |   0x8202\
    \   | Certificate Message Response             |\n      |   0xC202   | Certificate\
    \ Message Error Response       |\n      |   0x0302   | Cookie Message Request\
    \                   |\n      |   0x8302   | Cookie Message Response          \
    \        |\n      |   0xC302   | Cookie Message Error Response            |\n\
    \      |   0x0402   | Autokey Message Request                  |\n      |   0x8402\
    \   | Autokey Message Response                 |\n      |   0xC402   | Autokey\
    \ Message Error Response           |\n      |   0x0502   | Leapseconds Value Message\
    \ Request        |\n      |   0x8502   | Leapseconds Value Message Response  \
    \     |\n      |   0xC502   | Leapseconds Value Message Error Response |\n   \
    \   |   0x0602   | Sign Message Request                     |\n      |   0x8602\
    \   | Sign Message Response                    |\n      |   0xC602   | Sign Message\
    \ Error Response              |\n      |   0x0702   | IFF Identity Message Request\
    \             |\n      |   0x8702   | IFF Identity Message Response          \
    \  |\n      |   0xC702   | IFF Identity Message Error Response      |\n      |\
    \   0x0802   | GQ Identity Message Request              |\n      |   0x8802  \
    \ | GQ Identity Message Response             |\n      |   0xC802   | GQ Identity\
    \ Message Error Response       |\n      |   0x0902   | MV Identity Message Request\
    \              |\n      |   0x8902   | MV Identity Message Response          \
    \   |\n      |   0xC902   | MV Identity Message Error Response       |\n     \
    \ +------------+------------------------------------------+\n"
- title: 14.  References
  contents:
  - '14.  References

    '
- title: 14.1.  Normative References
  contents:
  - "14.1.  Normative References\n   [RFC5905]  Mills, D., Martin, J., Ed., Burbank,\
    \ J., and W. Kasch,\n              \"Network Time Protocol Version 4: Protocol\
    \ and Algorithms\n              Specification\", RFC 5905, June 2010.\n"
- title: 14.2.  Informative References
  contents:
  - "14.2.  Informative References\n   [DASBUCH]  Mills, D., \"Computer Network Time\
    \ Synchronization - the\n              Network Time Protocol\", 2006.\n   [GUILLOU]\
    \  Guillou, L. and J. Quisquatar, \"A \"paradoxical\" identity-\n            \
    \  based signature scheme resulting from zero-knowledge\",\n              1990.\n\
    \   [MV]       Mu, Y. and V. Varadharajan, \"Robust and secure\n             \
    \ broadcasting\", 2001.\n   [RFC1305]  Mills, D., \"Network Time Protocol (Version\
    \ 3)\n              Specification, Implementation\", RFC 1305, March 1992.\n \
    \  [RFC2412]  Orman, H., \"The OAKLEY Key Determination Protocol\",\n        \
    \      RFC 2412, November 1998.\n   [RFC2522]  Karn, P. and W. Simpson, \"Photuris:\
    \ Session-Key Management\n              Protocol\", RFC 2522, March 1999.\n  \
    \ [RFC2875]  Prafullchandra, H. and J. Schaad, \"Diffie-Hellman Proof-\n     \
    \         of-Possession Algorithms\", RFC 2875, July 2000.\n   [RFC3279]  Bassham,\
    \ L., Polk, W., and R. Housley, \"Algorithms and\n              Identifiers for\
    \ the Internet X.509 Public Key\n              Infrastructure Certificate and\
    \ Certificate Revocation List\n              (CRL) Profile\", RFC 3279, April\
    \ 2002.\n   [RFC4210]  Adams, C., Farrell, S., Kause, T., and T. Mononen,\n  \
    \            \"Internet X.509 Public Key Infrastructure Certificate\n        \
    \      Management Protocol (CMP)\", RFC 4210, September 2005.\n   [RFC4302]  Kent,\
    \ S., \"IP Authentication Header\", RFC 4302,\n              December 2005.\n\
    \   [RFC4303]  Kent, S., \"IP Encapsulating Security Payload (ESP)\",\n      \
    \        RFC 4303, December 2005.\n   [RFC4306]  Kaufman, C., \"Internet Key Exchange\
    \ (IKEv2) Protocol\",\n              RFC 4306, December 2005.\n   [RFC5280]  Cooper,\
    \ D., Santesson, S., Farrell, S., Boeyen, S.,\n              Housley, R., and\
    \ W. Polk, \"Internet X.509 Public Key\n              Infrastructure Certificate\
    \ and Certificate Revocation List\n              (CRL) Profile\", RFC 5280, May\
    \ 2008.\n   [SCHNORR]  Schnorr, C., \"Efficient signature generation for smart\n\
    \              cards\", 1991.\n   [STINSON]  Stinson, D., \"Cryptography - Theory\
    \ and Practice\", 1995.\n"
- title: Appendix A.  Timestamps, Filestamps, and Partial Ordering
  contents:
  - "Appendix A.  Timestamps, Filestamps, and Partial Ordering\n   When the host starts,\
    \ it reads the host key and host certificate\n   files, which are required for\
    \ continued operation.  It also reads the\n   sign key and leapseconds values,\
    \ when available.  When reading these\n   files, the host checks the file formats\
    \ and filestamps for validity;\n   for instance, all filestamps must be later\
    \ than the time the UTC\n   timescale was established in 1972 and the certificate\
    \ filestamp must\n   not be earlier than its associated sign key filestamp.  At\
    \ the time\n   the files are read, the host is not synchronized, so it cannot\n\
    \   determine whether the filestamps are bogus other than by using these\n   simple\
    \ checks.  It must not produce filestamps or timestamps until\n   synchronized\
    \ to a proventic source.\n   In the following, the relation A --> B is Lamport's\
    \ \"happens before\"\n   relation, which is true if event A happens before event\
    \ B. When\n   timestamps are compared to timestamps, the relation is false if\
    \ A\n   <--> B; that is, false if the events are simultaneous.  For\n   timestamps\
    \ compared to filestamps and filestamps compared to\n   filestamps, the relation\
    \ is true if A <--> B. Note that the current\n   time plays no part in these assertions\
    \ except in (6) below; however,\n   the NTP protocol itself ensures a correct\
    \ partial ordering for all\n   current time values.\n   The following assertions\
    \ apply to all relevant responses:\n   1.  The client saves the most recent timestamp\
    \ T0 and filestamp F0\n       for the respective signature type.  For every received\
    \ message\n       carrying timestamp T1 and filestamp F1, the message is discarded\n\
    \       unless T0 --> T1 and F0 --> F1.  The requirement that T0 --> T1\n    \
    \   is the primary defense against replays of old messages.\n   2.  For timestamp\
    \ T and filestamp F, F --> T; that is, the filestamp\n       must happen before\
    \ the timestamp.  If not, this could be due to a\n       file generation error\
    \ or a significant error in the system clock\n       time.\n   3.  For sign key\
    \ filestamp S, certificate filestamp C, cookie\n       timestamp D and autokey\
    \ timestamp A, S --> C --> D --> A; that\n       is, the autokey must be generated\
    \ after the cookie, the cookie\n       after the certificate, and the certificate\
    \ after the sign key.\n   4.  For sign key filestamp S and certificate filestamp\
    \ C specifying\n       begin time B and end time E, S --> C--> B --> E; that is,\
    \ the\n       valid period must not be retroactive.\n   5.  A certificate for\
    \ subject S signed by issuer I and with filestamp\n       C1 obsoletes, but does\
    \ not necessarily invalidate, another\n       certificate with the same subject\
    \ and issuer but with filestamp\n       C0, where C0 --> C1.\n   6.  A certificate\
    \ with begin time B and end time E is invalid and\n       cannot be used to verify\
    \ signatures if t --> B or E --> t, where\n       t is the current proventic time.\
    \  Note that the public key\n       previously extracted from the certificate\
    \ continues to be valid\n       for an indefinite time.  This raises the interesting\
    \ possibility\n       where a truechimer server with expired certificate or a\n\
    \       falseticker with valid certificate are not detected until the\n      \
    \ client has synchronized to a proventic source.\n"
- title: Appendix B.  Identity Schemes
  contents:
  - "Appendix B.  Identity Schemes\n   There are five identity schemes in the NTPv4\
    \ reference\n   implementation: (1) private certificate (PC), (2) trusted certificate\n\
    \   (TC), (3) a modified Schnorr algorithm (IFF - Identify Friend or\n   Foe),\
    \ (4) a modified Guillou-Quisquater (GQ) algorithm, and (5) a\n   modified Mu-Varadharajan\
    \ (MV) algorithm.\n   The PC scheme is intended for testing and development and\
    \ not\n   recommended for general use.  The TC scheme uses a certificate trail,\n\
    \   but not an identity scheme.  The IFF, GQ, and MV identity schemes use\n  \
    \ a cryptographically strong challenge-response exchange where an\n   intruder\
    \ cannot learn the group key, even after repeated observations\n   of multiple\
    \ exchanges.  These schemes begin when the client sends a\n   nonce to the server,\
    \ which then rolls its own nonce, performs a\n   mathematical operation and sends\
    \ the results to the client.  The\n   client performs a second mathematical operation\
    \ to prove the server\n   has the same group key as the client.\n"
- title: Appendix C.  Private Certificate (PC) Scheme
  contents:
  - "Appendix C.  Private Certificate (PC) Scheme\n   The PC scheme shown in Figure\
    \ 12 uses a private certificate as the\n   group key.\n                      \
    \       Trusted\n                            Authority\n              Secure \
    \    +-------------+    Secure\n          +--------------| Certificate |-------------+\n\
    \          |              +-------------+             |\n          |         \
    \                                 |\n         \\|/                           \
    \             \\|/\n   +-------------+                            +-------------+\n\
    \   | Certificate |                            | Certificate |\n   +-------------+\
    \                            +-------------+\n       Server                  \
    \                   Client\n            Figure 12: Private Certificate (PC) Identity\
    \ Scheme\n   A certificate is designated private when the X.509v3 Extended Key\n\
    \   Usage extension field is present and contains \"Private\".  The private\n\
    \   certificate is distributed to all other group members by secret\n   means,\
    \ so in fact becomes a symmetric key.  Private certificates are\n   also trusted,\
    \ so there is no need for a certificate trail or identity\n   scheme.\n"
- title: Appendix D.  Trusted Certificate (TC) Scheme
  contents:
  - "Appendix D.  Trusted Certificate (TC) Scheme\n   All other schemes involve a\
    \ conventional certificate trail as shown\n   in Figure 13.\n                \
    \                                           Trusted\n                   Host \
    \                Host                 Host\n              +-----------+      \
    \  +-----------+        +-----------+\n         +--->|  Subject  |   +--->|  Subject\
    \  |   +--->|  Subject  |\n         |    +-----------+   |    +-----------+  \
    \ |    +-----------+\n   ...---+    |  Issuer   |---+    |  Issuer   |---+   \
    \ |  Issuer   |\n              +-----------+        +-----------+        +-----------+\n\
    \              | Signature |        | Signature |        | Signature |\n     \
    \         +-----------+        +-----------+        +-----------+\n          \
    \  Figure 13: Trusted Certificate (TC) Identity Scheme\n   As described in RFC\
    \ 4210 [RFC4210], each certificate is signed by an\n   issuer one step closer\
    \ to the trusted host, which has a self-signed\n   trusted certificate.  A certificate\
    \ is designated trusted when an\n   X.509v3 Extended Key Usage extension field\
    \ is present and contains\n   \"trustRoot\".  If no identity scheme is specified\
    \ in the parameter\n   exchange, this is the default scheme.\n"
- title: Appendix E.  Schnorr (IFF) Identity Scheme
  contents:
  - "Appendix E.  Schnorr (IFF) Identity Scheme\n   The IFF scheme is useful when\
    \ the group key is concealed, so that\n   client keys need not be protected. \
    \ The primary disadvantage is that\n   when the server key is refreshed all hosts\
    \ must update the client\n   key.  The scheme shown in Figure 14 involves a set\
    \ of public\n   parameters and a group key including both private and public\n\
    \   components.  The public component is the client key.\n                   \
    \                  Trusted\n                                    Authority\n  \
    \                                +------------+\n                            \
    \      | Parameters |\n                       Secure     +------------+   Insecure\n\
    \                    +-------------| Group Key  |-----------+\n              \
    \      |             +------------+           |\n                   \\|/     \
    \                               \\|/\n              +------------+         Challenge\
    \       +------------+\n              | Parameters |<------------------------|\
    \ Parameters |\n              +------------+                         +------------+\n\
    \              |  Group Key |------------------------>| Client Key |\n       \
    \       +------------+         Response        +------------+\n              \
    \    Server                                 Client\n                 Figure 14:\
    \ Schnorr (IFF) Identity Scheme\n   By happy coincidence, the mathematical principles\
    \ on which IFF is\n   based are similar to DSA.  The scheme is a modification\
    \ an algorithm\n   described in [SCHNORR] and [STINSON] (p. 285).  The parameters\
    \ are\n   generated by routines in the OpenSSL library, but only the moduli p,\n\
    \   q and generator g are used.  The p is a 512-bit prime, g a generator\n   of\
    \ the multiplicative group Z_p* and q a 160-bit prime that divides\n   (p-1) and\
    \ is a qth root of 1 mod p; that is, g^q = 1 mod p.  The TA\n   rolls a private\
    \ random group key b (0 < b < q), then computes public\n   client key v = g^(q-b)\
    \ mod p.  The TA distributes (p, q, g, b) to all\n   servers using secure means\
    \ and (p, q, g, v) to all clients not\n   necessarily using secure means.\n  \
    \ The TA hides IFF parameters and keys in an OpenSSL DSA cuckoo\n   structure.\
    \  The IFF parameters are identical to the DSA parameters,\n   so the OpenSSL\
    \ library can be used directly.  The structure shown in\n   Figure 15 is written\
    \ to a file as a DSA private key encoded in PEM.\n   Unused structure members\
    \ are set to one.\n              +----------------------------------+-------------+\n\
    \              |   IFF   |   DSA    |   Item      |   Include   |\n          \
    \    +=========+==========+=============+=============+\n              |    p\
    \    |    p     | modulus     |    all      |\n              +---------+----------+-------------+-------------+\n\
    \              |    q    |    q     | modulus     |    all      |\n          \
    \    +---------+----------+-------------+-------------+\n              |    g\
    \    |    g     | generator   |    all      |\n              +---------+----------+-------------+-------------+\n\
    \              |    b    | priv_key | group key   |   server    |\n          \
    \    +---------+----------+-------------+-------------+\n              |    v\
    \    | pub_key  | client key  |   client    |\n              +---------+----------+-------------+-------------+\n\
    \                 Figure 15: IFF Identity Scheme Structure\n   Alice challenges\
    \ Bob to confirm identity using the following protocol\n   exchange.\n   1.  Alice\
    \ rolls random r (0 < r < q) and sends to Bob.\n   2.  Bob rolls random k (0 <\
    \ k < q), computes y = k + br mod q and x =\n       g^k mod p, then sends (y,\
    \ hash(x)) to Alice.\n   3.  Alice computes z = g^y * v^r mod p and verifies hash(z)\
    \ equals\n       hash(x).\n   If the hashes match, Alice knows that Bob has the\
    \ group key b.\n   Besides making the response shorter, the hash makes it effectively\n\
    \   impossible for an intruder to solve for b by observing a number of\n   these\
    \ messages.  The signed response binds this knowledge to Bob's\n   private key\
    \ and the public key previously received in his\n   certificate.\n"
- title: Appendix F.  Guillard-Quisquater (GQ) Identity Scheme
  contents:
  - "Appendix F.  Guillard-Quisquater (GQ) Identity Scheme\n   The GQ scheme is useful\
    \ when the server key must be refreshed from\n   time to time without changing\
    \ the group key.  The NTP utility\n   programs include the GQ client key in the\
    \ X.509v3 Subject Key\n   Identifier extension field.  The primary disadvantage\
    \ of the scheme\n   is that the group key must be protected in both the server\
    \ and\n   client.  A secondary disadvantage is that when a server key is\n   refreshed,\
    \ old extension fields no longer work.  The scheme shown in\n   Figure 16 involves\
    \ a set of public parameters and a group key used to\n   generate private server\
    \ keys and client keys.\n                                     Trusted\n      \
    \                              Authority\n                                  +------------+\n\
    \                                  | Parameters |\n                       Secure\
    \     +------------+   Secure\n                    +-------------| Group Key \
    \ |-----------+\n                    |             +------------+           |\n\
    \                   \\|/                                    \\|/\n           \
    \   +------------+         Challenge       +------------+\n              | Parameters\
    \ |<------------------------| Parameters |\n              +------------+     \
    \                    +------------+\n              |  Group Key |            \
    \             |  Group Key |\n              +------------+         Response  \
    \      +------------+\n              | Server Key |------------------------>|\
    \ Client Key |\n              +------------+                         +------------+\n\
    \                  Server                                 Client\n           \
    \      Figure 16: Schnorr (IFF) Identity Scheme\n   By happy coincidence, the\
    \ mathematical principles on which GQ is\n   based are similar to RSA.  The scheme\
    \ is a modification of an\n   algorithm described in [GUILLOU] and [STINSON] (p.\
    \ 300) (with\n   errors).  The parameters are generated by routines in the OpenSSL\n\
    \   library, but only the moduli p and q are used.  The 512-bit public\n   modulus\
    \ is n=pq, where p and q are secret large primes.  The TA rolls\n   random large\
    \ prime b (0 < b < n) and distributes (n, b) to all group\n   servers and clients\
    \ using secure means, since an intruder in\n   possession of these values could\
    \ impersonate a legitimate server.\n   The private server key and public client\
    \ key are constructed later.\n   The TA hides GQ parameters and keys in an OpenSSL\
    \ RSA cuckoo\n   structure.  The GQ parameters are identical to the RSA parameters,\
    \ so\n   the OpenSSL library can be used directly.  When generating a\n   certificate,\
    \ the server rolls random server key u (0 < u < n) and\n   client key its inverse\
    \ obscured by the group key v = (u^-1)^b mod n.\n   These values replace the private\
    \ and public keys normally generated\n   by the RSA scheme.  The client key is\
    \ conveyed in a X.509 certificate\n   extension.  The updated GQ structure shown\
    \ in Figure 17 is written as\n   an RSA private key encoded in PEM.  Unused structure\
    \ members are set\n   to one.\n              +---------------------------------+-------------+\n\
    \              |   GQ    |   RSA    |   Item     |   Include   |\n           \
    \   +=========+==========+============+=============+\n              |    n  \
    \  |    n     | modulus    |    all      |\n              +---------+----------+------------+-------------+\n\
    \              |    b    |    e     | group key  |    all      |\n           \
    \   +---------+----------+------------+-------------+\n              |    u  \
    \  |    p     | server key |   server    |\n              +---------+----------+------------+-------------+\n\
    \              |    v    |    q     | client key |   client    |\n           \
    \   +---------+----------+------------+-------------+\n                  Figure\
    \ 17: GQ Identity Scheme Structure\n   Alice challenges Bob to confirm identity\
    \ using the following\n   exchange.\n   1.  Alice rolls random r (0 < r < n) and\
    \ sends to Bob.\n   2.  Bob rolls random k (0 < k < n) and computes y = ku^r mod\
    \ n and x\n       = k^b mod n, then sends (y, hash(x)) to Alice.\n   3.  Alice\
    \ computes z = (v^r)*(y^b) mod n and verifies hash(z) equals\n       hash(x).\n\
    \   If the hashes match, Alice knows that Bob has the corresponding\n   server\
    \ key u.  Besides making the response shorter, the hash makes it\n   effectively\
    \ impossible for an intruder to solve for u by observing a\n   number of these\
    \ messages.  The signed response binds this knowledge\n   to Bob's private key\
    \ and the client key previously received in his\n   certificate.\n"
- title: Appendix G.  Mu-Varadharajan (MV) Identity Scheme
  contents:
  - "Appendix G.  Mu-Varadharajan (MV) Identity Scheme\n   The MV scheme is perhaps\
    \ the most interesting and flexible of the\n   three challenge/response schemes,\
    \ but is devilishly complicated.  It\n   is most useful when a small number of\
    \ servers provide synchronization\n   to a large client population where there\
    \ might be considerable risk\n   of compromise between and among the servers and\
    \ clients.  The client\n   population can be partitioned into a modest number\
    \ of subgroups, each\n   associated with an individual client key.\n   The TA\
    \ generates an intricate cryptosystem involving encryption and\n   decryption\
    \ keys, together with a number of activation keys and\n   associated client keys.\
    \  The TA can activate and revoke individual\n   client keys without changing\
    \ the client keys themselves.  The TA\n   provides to the servers an encryption\
    \ key E, and partial decryption\n   keys g-bar and g-hat which depend on the activated\
    \ keys.  The servers\n   have no additional information and, in particular, cannot\
    \ masquerade\n   as a TA.  In addition, the TA provides to each client j individual\n\
    \   partial decryption keys x-bar_j and x-hat_j, which do not need to be\n   changed\
    \ if the TA activates or deactivates any client key.  The\n   clients have no\
    \ further information and, in particular, cannot\n   masquerade as a server or\
    \ TA.\n   The scheme uses an encryption algorithm similar to El Gamal\n   cryptography\
    \ and a polynomial formed from the expansion of product\n   terms (x-x_1)(x-x_2)(x-x_3)...(x-x_n),\
    \ as described in [MV].  The\n   paper has significant errors and serious omissions.\
    \  The cryptosystem\n   is constructed so that, for every encryption key E its\
    \ inverse is\n   (g-bar^x-hat_j)(g-hat^x-bar_j) mod p for every j.  This remains\
    \ true\n   if both quantities are raised to the power k mod p.  The difficulty\n\
    \   in finding E is equivalent to the discrete log problem.\n   The scheme is\
    \ shown in Figure 18.  The TA generates the parameters,\n   group key, server\
    \ keys, and client keys, one for each client, all of\n   which must be protected\
    \ to prevent theft of service.  Note that only\n   the TA has the group key, which\
    \ is not known to either the servers or\n   clients.  In this sense, the MV scheme\
    \ is a zero-knowledge proof.\n                                     Trusted\n \
    \                                   Authority\n                              \
    \    +------------+\n                                  | Parameters |\n      \
    \                            +------------+\n                                \
    \  | Group Key  |\n                                  +------------+\n        \
    \                          | Server Key |\n                       Secure     +------------+\
    \   Secure\n                    +-------------| Client Key |-----------+\n   \
    \                 |             +------------+           |\n                 \
    \  \\|/                                    \\|/\n              +------------+\
    \         Challenge       +------------+\n              | Parameters |<------------------------|\
    \ Parameters |\n              +------------+                         +------------+\n\
    \              | Server Key |------------------------>| Client Key |\n       \
    \       +------------+         Response        +------------+\n              \
    \    Server                                 Client\n              Figure 18: Mu-Varadharajan\
    \ (MV) Identity Scheme\n   The TA hides MV parameters and keys in OpenSSL DSA\
    \ cuckoo structures.\n   The MV parameters are identical to the DSA parameters,\
    \ so the OpenSSL\n   library can be used directly.  The structure shown in the\
    \ figures\n   below are written to files as a the fkey encoded in PEM.  Unused\n\
    \   structure members are set to one.  The Figure 19 shows the data\n   structure\
    \ used by the servers, while Figure 20 shows the client data\n   structure associated\
    \ with each activation key.\n              +---------------------------------+-------------+\n\
    \              |   MV    |   DSA    |   Item     |   Include   |\n           \
    \   +=========+==========+============+=============+\n              |    p  \
    \  |    p     | modulus    |    all      |\n              +---------+----------+------------+-------------+\n\
    \              |    q    |    q     | modulus    |   server    |\n           \
    \   +---------+----------+------------+-------------+\n              |    E  \
    \  |    g     | private    |   server    |\n              |         |        \
    \  | encrypt    |             |\n              +---------+----------+------------+-------------+\n\
    \              |  g-bar  | priv_key | public     |   server    |\n           \
    \   |         |          | decrypt    |             |\n              +---------+----------+------------+-------------+\n\
    \              |  g-hat  | pub_key  | public     |   server    |\n           \
    \   |         |          | decrypt    |             |\n              +---------+----------+------------+-------------+\n\
    \                   Figure 19: MV Scheme Server Structure\n              +---------------------------------+-------------+\n\
    \              |   MV    |   DSA    |   Item     |   Include   |\n           \
    \   +=========+==========+============+=============+\n              |    p  \
    \  |    p     | modulus    |    all      |\n              +---------+----------+------------+-------------+\n\
    \              | x-bar_j | priv_key | public     |   client    |\n           \
    \   |         |          | decrypt    |             |\n              +---------+----------+------------+-------------+\n\
    \              | x-hat_j | pub_key  | public     |   client    |\n           \
    \   |         |          | decrypt    |             |\n              +---------+----------+------------+-------------+\n\
    \                   Figure 20: MV Scheme Client Structure\n   The devil is in\
    \ the details, which are beyond the scope of this memo.\n   The steps in generating\
    \ the cryptosystem activating the keys and\n   generating the partial decryption\
    \ keys are in [DASBUCH] (page 170\n   ff).\n   Alice challenges Bob to confirm\
    \ identity using the following\n   exchange.\n   1.  Alice rolls random r (0 <\
    \ r < q) and sends to Bob.\n   2.  Bob rolls random k (0 < k < q) and computes\
    \ the session\n       encryption key E-prime = E^k mod p and partial decryption\
    \ keys\n       g-bar-prime = g-bar^k mod p and g-hat-prime = g-hat^k mod p.  He\n\
    \       encrypts x = E-prime * r mod p and sends (x, g-bar-prime, g-hat-\n   \
    \    prime) to Alice.\n   3.  Alice computes the session decryption key E^-1 =\
    \ (g-bar-prime)^x-\n       hat_j (g-hat-prime)^x-bar_j mod p and verifies that\
    \ r = E^-1 x.\n"
- title: Appendix H.  ASN.1 Encoding Rules
  contents:
  - "Appendix H.  ASN.1 Encoding Rules\n   Certain value fields in request and response\
    \ messages contain data\n   encoded in ASN.1 distinguished encoding rules (DER).\
    \  The BNF grammar\n   for each encoding rule is given below along with the OpenSSL\
    \ routine\n   used for the encoding in the reference implementation.  The object\n\
    \   identifiers for the encryption algorithms and message digest/\n   signature\
    \ encryption schemes are specified in [RFC3279].  The\n   particular algorithms\
    \ required for conformance are not specified in\n   this memo.\n"
- title: Appendix I.  COOKIE Request, IFF Response, GQ Response, MV Response
  contents:
  - "Appendix I.  COOKIE Request, IFF Response, GQ Response, MV Response\n   The value\
    \ field of the COOKIE request message contains a sequence of\n   two integers\
    \ (n, e) encoded by the i2d_RSAPublicKey() routine in the\n   OpenSSL distribution.\
    \  In the request, n is the RSA modulus in bits\n   and e is the public exponent.\n\
    \   RSAPublicKey ::= SEQUENCE {\n           n ::= INTEGER,\n           e ::= INTEGER\n\
    \   }\n   The IFF and GQ responses contain a sequence of two integers (r, s)\n\
    \   encoded by the i2d_DSA_SIG() routine in the OpenSSL distribution.  In\n  \
    \ the responses, r is the challenge response and s is the hash of the\n   private\
    \ value.\n   DSAPublicKey ::= SEQUENCE {\n           r ::= INTEGER,\n        \
    \   s ::= INTEGER\n   }\n   The MV response contains a sequence of three integers\
    \ (p, q, g)\n   encoded by the i2d_DSAparams() routine in the OpenSSL library.\
    \  In\n   the response, p is the hash of the encrypted challenge value and (q,\n\
    \   g) is the client portion of the decryption key.\n   DSAparameters ::= SEQUENCE\
    \ {\n           p ::= INTEGER,\n           q ::= INTEGER,\n           g ::= INTEGER\n\
    \   }\n"
- title: Appendix J.  Certificates
  contents:
  - "Appendix J.  Certificates\n   Certificate extension fields are used to convey\
    \ information used by\n   the identity schemes.  While the semantics of these\
    \ fields generally\n   conform with conventional usage, there are subtle variations.\
    \  The\n   fields used by Autokey version 2 include:\n   o  Basic Constraints.\
    \  This field defines the basic functions of the\n      certificate.  It contains\
    \ the string \"critical,CA:TRUE\", which\n      means the field must be interpreted\
    \ and the associated private key\n      can be used to sign other certificates.\
    \  While included for\n      compatibility, Autokey makes no use of this field.\n\
    \   o  Key Usage.  This field defines the intended use of the public key\n   \
    \   contained in the certificate.  It contains the string\n      \"digitalSignature,keyCertSign\"\
    , which means the contained public\n      key can be used to verify signatures\
    \ on data and other\n      certificates.  While included for compatibility, Autokey\
    \ makes no\n      use of this field.\n   o  Extended Key Usage.  This field further\
    \ refines the intended use\n      of the public key contained in the certificate\
    \ and is present only\n      in self-signed certificates.  It contains the string\
    \ \"Private\" if\n      the certificate is designated private or the string \"\
    trustRoot\" if\n      it is designated trusted.  A private certificate is always\n\
    \      trusted.\n   o  Subject Key Identifier.  This field contains the client\
    \ identity\n      key used in the GQ identity scheme.  It is present only if the\
    \ GQ\n      scheme is in use.\n   The value field contains an X.509v3 certificate\
    \ encoded by the\n   i2d_X509() routine in the OpenSSL distribution.  The encoding\
    \ follows\n   the rules stated in [RFC5280], including the use of X.509v3 extension\n\
    \   fields.\n   Certificate ::= SEQUENCE {\n           tbsCertificate        \
    \          TBSCertificate,\n           signatureAlgorithm              AlgorithmIdentifier,\n\
    \           signatureValue                  BIT STRING\n   }\n   The signatureAlgorithm\
    \ is the object identifier of the message\n   digest/signature encryption scheme\
    \ used to sign the certificate.  The\n   signatureValue is computed by the certificate\
    \ issuer using this\n   algorithm and the issuer private key.\n   TBSCertificate\
    \ ::= SEQUENCE {\n           version                         EXPLICIT v3(2),\n\
    \           serialNumber                    CertificateSerialNumber,\n       \
    \    signature                       AlgorithmIdentifier,\n           issuer \
    \                         Name,\n           validity                        Validity,\n\
    \           subject                         Name,\n           subjectPublicKeyInfo\
    \            SubjectPublicKeyInfo,\n           extensions                    \
    \  EXPLICIT Extensions OPTIONAL\n   }\n   The serialNumber is an integer guaranteed\
    \ to be unique for the\n   generating host.  The reference implementation uses\
    \ the NTP seconds\n   when the certificate was generated.  The signature is the\
    \ object\n   identifier of the message digest/signature encryption scheme used\
    \ to\n   sign the certificate.  It must be identical to the\n   signatureAlgorithm.\n\
    \   CertificateSerialNumber\n   SET { ::= INTEGER\n           Validity ::= SEQUENCE\
    \ {\n                   notBefore              UTCTime,\n                   notAfter\
    \               UTCTime\n           }\n   }\n   The notBefore and notAfter define\
    \ the period of validity as defined\n   in Appendix B.\n   SubjectPublicKeyInfo\
    \ ::= SEQUENCE {\n           algorithm                       AlgorithmIdentifier,\n\
    \           subjectPublicKey                BIT STRING\n   }\n   The AlgorithmIdentifier\
    \ specifies the encryption algorithm for the\n   subject public key.  The subjectPublicKey\
    \ is the public key of the\n   subject.\n   Extensions ::= SEQUENCE SIZE (1..MAX)\
    \ OF Extension\n   Extension ::= SEQUENCE {\n           extnID               \
    \           OBJECT IDENTIFIER,\n           critical                        BOOLEAN\
    \ DEFAULT FALSE,\n           extnValue                       OCTET STRING\n  \
    \ }\n   SET {\n           Name ::= SEQUENCE {\n                   OBJECT IDENTIFIER\
    \       commonName\n                   PrintableString         HostName\n    \
    \       }\n   }\n   For trusted host certificates, the subject and issuer HostName\
    \ is the\n   NTP name of the group, while for all other host certificates the\n\
    \   subject and issuer HostName is the NTP name of the host.  In the\n   reference\
    \ implementation, if these names are not explicitly\n   specified, they default\
    \ to the string returned by the Unix\n   gethostname() routine (trailing NUL removed).\
    \  For other than self-\n   signed certificates, the issuer HostName is the unique\
    \ DNS name of\n   the host signing the certificate.\n   It should be noted that\
    \ the Autokey protocol itself has no provisions\n   to revoke certificates.  The\
    \ reference implementation is purposely\n   restarted about once a week, leading\
    \ to the regeneration of the\n   certificate and a restart of the Autokey protocol.\
    \  This restart is\n   not enforced for the Autokey protocol but rather for NTP\n\
    \   functionality reasons.\n   Each group host operates with only one certificate\
    \ at a time and\n   constructs a trail by induction.  Since the group configuration\
    \ must\n   form an acyclic graph, with roots at the trusted hosts, it does not\n\
    \   matter which, of possibly several, signed certificates is used.  The\n   reference\
    \ implementation chooses a single certificate and operates\n   with only that\
    \ certificate until the protocol is restarted.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Brian Haberman (editor)\n   The Johns Hopkins University\
    \ Applied Physics Laboratory\n   11100 Johns Hopkins Road\n   Laurel, MD  20723-6099\n\
    \   US\n   Phone: +1 443 778 1319\n   EMail: brian@innovationslab.net\n   Dr.\
    \ David L. Mills\n   University of Delaware\n   Newark, DE  19716\n   US\n   Phone:\
    \ +1 302 831 8247\n   EMail: mills@udel.edu\n"
