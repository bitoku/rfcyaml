- contents:
  - ''
  - 'This RFC is a description of the protocol used in the DCN local

    '
  - 'networks to maintain connectivity, routing, and timekeeping

    '
  - 'information.  These procedures may be of interest to designers and

    '
  - 'implementers of other networks.

    '
  title: __initial_text__
- contents:
  - "1.  Introduction\n     This document describes the local-net architecture and
    protocols\n"
  - 'of the Distributed Computer Network (DCN), a family of local nets

    '
  - 'based on Internet technology and an implementation of PDP11-based

    '
  - 'software called the Fuzzball.  DCN local nets have been in operation

    '
  - 'for about three years and now include clones in the USA, UK, Norway

    '
  - 'and West Germany.  They typically include a number of PDP11 or LSI-11

    '
  - 'Fuzzballs, one of which is elected a gateway, and often include other

    '
  - "Internet-compatible hosts as well.\n     The DCN local-net protocols are intended
    to provide connectivity,\n"
  - 'routing and timekeeping functions for a set of randomly connected

    '
  - 'personal computers and service hosts.  The design philosophy guiding

    '
  - 'the Fuzzball implementation is to incorporate complete functionality

    '
  - 'in every host, which can serve as a packet switch, gateway and service

    '
  - 'host all at the same time.  When a set of Fuzzballs are connected

    '
  - 'together using a haphazard collection of serial, parallel and

    '
  - 'contention-bus interfaces, they organize themselves into a network

    '
  - "with routing based on minimum delay.\n     The purpose of this document is to
    describe the local-net\n"
  - 'protocols used by the DCN to maintain connectivity, routing and

    '
  - 'timekeeping functions.  The document is an extensive revision and

    '
  - 'expansion of Section 4.2 of [1] and is divided into two parts, the

    '
  - 'first of which is an informal description of the architecture,

    '
  - 'together with explanatory remarks.  The second part consists of a

    '
  - 'semi-formal specification of the entities and protocols used to

    '
  - 'determine connectivity, establish routing and maintain clock

    '
  - 'synchronization and is designed to aid in the implementation of cohort

    '
  - 'systems.  The link-level coding is described in the appendix.

    '
  title: 1.  Introduction
- contents:
  - "2.  Narrative Description\n     The DCN architecture is designed for local nets
    of up to 256\n"
  - 'hosts and gateways using the Internet Protocol (IP) and client

    '
  - 'protocols.  It provides adaptive routing and clock synchronization

    '
  - 'functions in an arbitrary topology including point-to-point links and

    '
  - 'multipoint bus systems.  It is intended for use in connecting personal

    '
  - 'computers to each other and to service machines, gateways and other

    '
  - 'hosts of the Internet community.  However, it is not intended for use

    '
  - 'in large, complex networks and does not support the sophisticated

    '
  - "routing and control algorithms of, for example, the ARPANET.\n     A brief description
    of the process and addressing structure used\n"
  - 'DCN physical host contains one or more internet processes, each of

    '
  - 'which supports a virtual host given a unique 8-bit identifier called

    '
  - "its host ID.\n     Each virtual host can support multiple internet protocols,\n"
  - 'connections and, in addition, a virtual clock.  Each physical host

    '
  - 'contains a physical clock which can operate at an arbitrary rate and,

    '
  - 'in addition, a 32-bit logical clock which operates at 1000 Hz and is

    '
  - 'assumed to be reset each day at 0000 hours UT.  Not all physical hosts

    '
  - 'implement the full 32-bit precision; however, in such cases the

    '
  - "resolution of the logical clock may be somewhat less.\n     There is a one-to-one
    correspondence between Internet addresses\n"
  - 'and host IDs.  The host ID is formed from a specified octet of the

    '
  - 'Internet address to which is added a specified offset.  The octet

    '
  - 'number and offset are selected at configuration time and must be the

    '
  - 'same for all DCN hosts sharing the local net.  For class-B and class-C

    '
  - 'nets normally the fourth octet is used in this way for routing within

    '
  - 'the local net.  In the case of class-B nets, the third octet is

    '
  - 'considered part of the net number by DCN hosts; therefore, this octet

    '
  - 'can be used for routing between DCN local nets.  For class-A nets

    '
  - 'normally the third octet (ARPANET logical-host field) is used for

    '
  - "routing where necessary.\n     Each DCN physical host is identified by a host
    ID for the purpose\n"
  - 'of detecting loops in routing updates, which establish the

    '
  - 'minimum-delay paths between the virtual hosts.  By convention, the

    '
  - 'physical host ID is assigned as the host ID of one of its virtual

    '
  - 'hosts.  A link to a neighbor net is associated with a special virtual

    '
  - "host, called a gateway, which is assigned a unique host ID.\n     The links connecting
    the various physical hosts together and to\n"
  - 'foreign nets can be distributed in arbitrary ways, so long as the net

    '
  - 'remains fully connected.  If full connectivity is lost, due to a link

    '
  - 'or host fault, the virtual hosts in each of the surviving segments can

    '
  - 'continue to operate with each other and, once connectivity is

    '
  - "restored, with all of them.\n     Datagram routing is determined entirely by
    internet address -\n"
  - 'there is no local leader as in the ARPANET.  Each physical host

    '
  - 'contains two tables, the Host Table, which is used to determine the

    '
  - 'outgoing link to each other local-net host, and the Net Table, which

    '
  - 'is used to determine the outgoing host (gateway) to each other net.

    '
  - 'The Host Table contains estimates of roundtrip delay and logical-clock

    '
  - 'offset for all virtual hosts in the net and is indexed by host ID.

    '
  - 'For the purpose of computing these estimates the delay and offset of

    '
  - 'each virtual host relative to the physical host in which it resides is

    '
  - 'assumed zero.  The single exception to this is a special virtual host

    '
  - 'associated with an NBS radio time-code receiver, where the offset is

    '
  - 'computed relative to the broadcast time.

    '
  - 'of the local-net gateway to that net.  The routing function simply

    '
  - 'looks up the net number in the Net Table, finds the host ID of the

    '
  - 'gateway and retrieves the port ID of the net-output process from the

    '
  - 'Host Table.  Other information is included in the Host Table and Net

    '
  - "Table as described below.\n     The delay and offset estimates are updated by
    HELLO messages\n"
  - 'exchanged on the links connecting physical-host neighbors.  The HELLO

    '
  - 'messages are exchanged frequently, but not so as to materially degrade

    '
  - 'the throughput of the link for ordinary data messages.  A HELLO

    '
  - 'message contains a copy of the delay and offset information from the

    '
  - 'Host Table of the sender, as well as information to compute the

    '
  - 'roundtrip delay and logical-clock offset of the receiver relative to

    '
  - "the sender.\n     The routing algorithm is similar to that (formerly) used in
    the\n"
  - 'ARPANET and other places in that the roundtrip (biased) delay estimate

    '
  - 'calculated to a neighbor is added to each of the delay estimates given

    '
  - 'in its HELLO message and compared with the corresponding delay

    '
  - 'estimates in the Host Table.  If a delay computed in this way is less

    '
  - 'than the delay already in the Host Table, the routing to the

    '
  - 'corresponding virtual host is changed accordingly.  The detailed

    '
  - 'operation of this algorithm, which includes provisions for host

    '
  - "up-down logic and loop suppression, is summarized in a later section.\n     DCN
    local nets are self-configuring for all hosts and neighbor\n"
  - 'nets; that is, the routing algorithms will find minimum-delay paths

    '
  - 'between all hosts and gateways to neighbor nets.  In addition,

    '
  - 'timekeeping information can be exchanged using special HELLO messages

    '
  - 'between neighboring DCN local nets.  For routing beyond neighbor nets

    '
  - 'additional entries can be configured in the Net Tables as required.

    '
  - 'In addition, a special entry can be configured in the Net Tables which

    '
  - 'specifies the host ID of the gateway to all nets not explicitly

    '
  - "included in the table.\n     For routing via the ARPANET and its reachable nets
    a selected\n"
  - 'local-net host is equipped with an IMP interface and configured with a

    '
  - 'GGP/EGP Gateway process.  This process maintains the Net Table of the

    '
  - 'local host, including ARPANET leaders, dynamically as part of the

    '
  - 'GGP/EGP protocol interactions with other ARPANET gateways.  GGP/EGP

    '
  - "protocol interactions are possibly with non-ARPANET gateways as well.\n     The
    portable virtual-host structure used in the DCN encourages a\n"
  - 'rather loose interpretation of addressing.  In order to minimize

    '
  - 'confusion in the following, the term "host ID" will be applied only to

    '
  - 'virtual hosts, while "host number" will be applied to the physical

    '
  - 'host, called generically the DCN host.

    '
  title: 2.  Narrative Description
- contents:
  - "2.1.  Net and Host Tables\n     There are two tables in every DCN host which
    control routing of\n"
  - 'while the Host Table is used to determine the link, with respect to

    '
  - 'the DCN host, on the route to a virtual host.  The Host Table is

    '
  - 'maintained dynamically using updates generated by periodic HELLO

    '
  - 'messages.  The Net Table is fixed at configuration time for all DCN

    '
  - 'hosts except those that support a GGP/EGP Gateway process.  In these

    '
  - 'cases the Net Table is updated as part of the gateway operations.  In

    '
  - "addition, entries in either table can be changed by operator commands.\n     The
    Net Table format is shown in Figure 1.\n                        1                   0
    \n              5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \            |           Net Name            |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \            |    Net(2)     |    Net(1)     |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \            |    Index      |    Net(3)     |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \            |     Hops      |  Gateway ID   |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \            |                               |\n             |        Gateway
    Leader         |\n             |                               |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \                Figure 1. Net Table Entry\n     The \"Net Name\" field defines
    a short (RAD50) name for the net,\n"
  - 'while the "Net" fields define the class A/B/C net number.  The

    '
  - '"Gateway ID" field contains the host ID of the first gateway to the

    '
  - 'net and the "Hops" field the number of hops to it.  The remaining

    '
  - 'fields are used only by the GGP/EGP Gateway process and include the

    '
  - '"Index" field, which contains an index into the routing matrix.  and

    '
  - 'the "Gateway Leader" field, which contains the (byte-swapped)

    '
  - "local-net leader for the gateway on a neighbor net.\n     The Net Table contains
    an indefinite number of entries and is\n"
  - 'terminated by a special entry with all "Net" fields set to zero.  If

    '
  - 'the "Hops" field of this entry is less than 255, the "Gateway ID"

    '
  - 'field of this entry is used for all nets not in the table.  If the

    '
  - "\"Hops\" field is 255 all nets not explicitly mentioned in the table\n                        1
    \                  0 \n              5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \            |             Name              |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \            |      TTL      |    Port ID    |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \            |             Delay             |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \            |             Offset            |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \            |                               |\n             +                               +\n
    \            |          Local Leader         |\n             +                               +\n
    \            |                               |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \            |                               |\n             +        Update Timestamp
    \      +\n             |                               |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \               Figure 2. Host Table Entry\n     The ordinal position of each
    Host Table entry corresponds to its\n"
  - 'host ID.  The "Name" field contains a short (RAD50) name for

    '
  - 'convenient reference.  The "Port ID" field contains the port ID of the

    '
  - 'net-output process on the shortest path to this virtual host and the

    '
  - '"Delay" field contains the measured roundtrip delay to it.  The

    '
  - '"Offset" field contains the difference between the logical clock of

    '
  - 'this host and the logical clock of the local host.  The "Local Leader"

    '
  - 'field contains information used to construct the local leader of the

    '
  - 'outgoing packet, for those nets that require it.  The "Update

    '
  - 'Timestamp" field contains the logical clock value when the entry was

    '
  - 'last updated and the "TTL" field the time (in seconds) remaining until

    '
  - "the virtual host is declared down.\n     All fields except the \"Name\" field
    are filled in as part of the\n"
  - "routing update process, which is initiated upon arrival of a HELLO\n                        1
    \                  0 \n              5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0\n         ---
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
  - 'Fixed        |           Checksum            |

    '
  - "Area         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Date
    \             |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |
    \                              |\n             +              Time             +\n
    \            |                               |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \            |           Timestamp           |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \            |     Offset    |   Hosts (n)   |\n         --- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
  - 'Host         |          Delay Host 0         |

    '
  - "Area         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |         Offset
    Host 0         |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            ...
    \                            ...\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \            |         Delay Host n-1        |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \            |         Offset Host n-1       |\n         --- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \              Figure 3. HELLO Message Format\n     There are two HELLO message
    formats, depending on the length of\n"
  - 'the message.  One format, sent by a DCN host to another host on the

    '
  - 'same local net, includes both the fixed and host areas shown above.

    '
  - 'The second format, sent in all other cases, includes only the fixed

    '
  - "area.\n     Note that all word fields shown are byte-swapped with respect to\n"
  - 'the ordinary PDP11 representation.  The "Checksum" field contains a

    '
  - 'checksum covering the fields indicated.  The "Date" and "Time" fields

    '
  - 'are filled in with the local date and time of origination.  The

    '
  - '"Timestamp" field is used in the computation of the roundtrip delay

    '
  - '(see below).  The "Offset" field contains the offset of the block af

    '
  - 'Internet addresses used by the local net.  The "Delay Host n" and

    '
  - '"Offset Host n" fields represent a copy of the corresponding entries

    '
  - 'of the Host Table as they exist at the time of origination.  The

    '
  - '"Hosts (n)" field contains the number of entries in this table.

    '
  title: 2.1.  Net and Host Tables
- contents:
  - "2.2.  Roundtrip Delay Calculations\n     Periodically, each DCN physical host
    sends a HELLO message to its\n"
  - 'neighbor on each of the communication links common to both of them.

    '
  - 'When constructing a HELLO message the sender sets the

    '
  - 'destination-address field to this state variable and the

    '
  - 'source-address field to its own address.  It then fills in the "Date"

    '
  - 'and "Time" fields from its logical clock and the "Timestamp" field

    '
  - 'from another state variable.  It finally copies the "Delay" and

    '
  - "\"Offset\" values from its Host Table into the message.\n     A host receiving
    a HELLO message discards it if the format is bad\n"
  - 'or the checksum fails.  If valid, it initializes a link state variable

    '
  - 'to show that the link is up.  Each time a HELLO message is transmitted

    '
  - 'this state variable is decremented.  If it decrements to zero the link

    '
  - "is declared down.\n     The host then checks if the source-address field matches
    the\n"
  - 'state variable containing the last address stored.  If not, the link

    '
  - 'has been switched to a new host, so the state variables are flushed

    '
  - 'and the link forced into a recovery state.  The host then checks if

    '
  - 'the destination-address field matches its own address.  If so, the

    '
  - 'message has been looped (legal only in the case of a broadcast net)

    '
  - 'and the roundtrip delay information is corrected.  The host and net

    '
  - 'areas are ignored in this case.  If not, the host and net areas of the

    '
  - "message are processed to update the Host and Net Tables.\n     Roundtrip delay
    calculations are performed in the following way.\n"
  - 'The link input/output processes assigned each link maintain an

    '
  - 'internal state variable which is updated as each HELLO message is

    '
  - 'received and transmitted.  When a HELLO message is received this

    '
  - 'variable takes the value of the "Time" field minus the current

    '
  - 'time-of-day.  When the next HELLO message is transmitted, the value

    '
  - 'assigned the "Timestamp" field is computed as the low-order 16-bits of

    '
  - 'this variable plus the current time-of-day.  The value of this

    '
  - 'variable is forced to zero if either the link is down of the system

    '
  - 'logical clock has been reset since the last HELLO message was

    '
  - "received.\n     If a HELLO message is received with zero \"Timestamp\" field,
    no\n"
  - 'processing other than filling in the internal state variable.

    '
  - 'Otherwise, the roundtrip delay is computed as the low-order 16-bits of

    '
  - 'the current time-of-day minus the value of this field.  In order to

    '
  - 'assure the highest accuracy, the calculation is performed only if the

    '
  - 'length of the last transmitted HELLO message (in octets) matches the

    '
  - "length of the received HELLO message.\n     The above technique renders the calculation
    independent of the\n"
  - 'clock offsets and intervals between HELLO messages at either host,

    '
  - 'protects against errors that might occur due to lost HELLO messages

    '
  - 'and works even when a neighbor host simply forwards the HELLO message

    '
  - 'back to the originator without modifying it.  The latter behavior,

    '
  - 'typical of ARPANET IMPs and gateways, as well as broadcast nets, relies

    '
  title: 2.2.  Roundtrip Delay Calculations
- contents:
  - "2.3.  Host Updates\n     When a HELLO message arrives which results in a valid
    roundtrip\n"
  - 'delay calculation, a host update process is performed.  This consists

    '
  - 'of adding the roundtrip delay to each of the "Delay Host n" entries in

    '
  - 'the HELLO message in turn and comparing each of these calculated

    '
  - 'delays to the "Host Delay" field of the corresponding Host Table

    '
  - 'entry.  Each entry is then updated according to the following rules:

    '
  - "1.  If the link connects to another DCN host on the same net and the\n    port
    ID (PID) of the link output process matches the \"Port ID\"\n    field of the
    entry, then update the entry.\n"
  - "2.  If the link connects to another DCN host on the same net, the PID\n    of
    the link output process does not match the \"Port ID\" field and the\n    calculated
    delay is less than the \"Host Delay\" field by at least a\n    specified switching
    threshold (currently 100 milliseconds), then\n    update the entry. \n"
  - "3.  If the link connects to a foreign net and is assigned a host ID\n    corresponding
    to the entry, then update the entry.  In this case\n    only, use as the calculated
    delay the roundtrip delay.\n"
  - "4.  If none of the above conditions are met, or if the virtual host\n    has
    been declared down and the \"TTL\" field contains a nonzero\n    value, then no
    update is performed.\n     The update process consists of replacing the \"Delay\"
    field with\n"
  - 'the calculated delay, the "Port ID" field with the PID of the link

    '
  - 'output process, the "Update Timestamp" field with the current time of

    '
  - 'day and the "TTL" field by a specified value (currently 120) in

    '
  - 'seconds.  If the calculated delay exceeds a specified maximum interval

    '
  - '(currently 30 seconds), the virtual host is declared down by setting

    '
  - 'the corresponding "Delay" field to the maximum and the remaining

    '
  - 'fields as before.  For the purposes of delay calculations values less

    '
  - 'than a specified minimum (currently 100 milliseconds) are rounded up

    '
  - "to that minimum.\n     The \"Offset\" field is also replaced during the update
    process.\n"
  - 'When the HELLO message arrives, The value of the current logical clock

    '
  - 'is subtracted from the "Time" field and the difference added to

    '
  - 'one-half the roundtrip delay.  The resulting sum, which represents the

    '
  - 'offset of the local clock to the clock of the sender, is added to the

    '
  - 'corresponding "Offset" field of the HELLO message and the sum replaces

    '
  - 'the "Offset" field of the Host Table.  Thus, the "Offset" field in the

    '
  - 'Host Table for a particular virtual host is replaced only if that host

    '
  - "is up and on the minimum-delay path to the DCN host.\n     The purpose of the
    switching threshold in (2) above and the\n"
  - 'minimum delay specification in the update process is to avoid

    '
  - "unnecessary switching between links and transient loops which can\n     In addition
    to the updates performed as HELLO messages arrive, each\n"
  - 'virtual host in a DCN host also performs a periodic update of its own

    '
  - 'Host Table entry.  The update procedure is identical to the above,

    '
  - 'except that the calculated delay and offset are taken as zero.  At

    '
  - 'least one of the virtual hosts in a DCN host must have the same host

    '
  - 'ID as the host number assigned the DCN host itself and all must be

    '
  - 'assigned the same net number.  Other than these, there are no

    '
  - 'restrictions on the number or addresses of internet processes resident

    '
  - "in a single DCN host.\n     It should be appreciated that virtual hosts are truly
    portable\n"
  - 'and can migrate about the net, should such a requirement arise.  The

    '
  - 'host update protocols described here insure that the routing

    '
  - 'procedures always converge to the minimum-delay paths via operational

    '
  - 'links and DCN hosts.  In the case of broadcast nets such as Ethernets,

    '
  - 'the procedures are modified slightly as described below.  In this case

    '
  - 'the HELLO messages are used to determine routing from the various

    '
  - 'Ethernet hosts to destinations off the cable, as well as to provide

    '
  - 'time synchronization.

    '
  title: 2.3.  Host Updates
- contents:
  - "2.4.  Timeouts\n     The \"TTL\" field in every Host Table entry is decremented
    once a\n"
  - 'second in normal operation.  Thus, if following a host update another

    '
  - 'update is not received within an interval corresponding to the value

    '
  - 'initialized in that field, it decrements to zero, at which point the

    '
  - 'virtual host is declared down and the Host Table entry set as

    '
  - 'described above.  The 120-second interval used currently provides for

    '
  - 'at least four HELLO messages to be generated by every neighbor on

    '
  - 'every link during that interval, since the maximum delay between HELLO

    '
  - 'messages is 30 seconds on the lowest-speed link (1200 bps).  Thus, if

    '
  - 'no HELLO messages are lost, the maximum number of links between any

    '
  - "virtual host and any other is four.\n     The \"TTL\" field is initialized at
    120 seconds when an update\n"
  - 'occurs and when the virtual host is declared down.  During the

    '
  - 'interval this field decrements to zero immediately after being

    '
  - 'declared down, updates are ignored.  This provides a decent interval

    '
  - 'for the bad news to propagate throughout the net and for the Host

    '
  - 'Tables in all DCN hosts to reflect the fact.  Thus, the formation of

    '
  - "routing loops is prevented.\n     The IP datagram forwarding procedures call
    for decrementing the\n"
  - '"time-to-live" field in the IP header once per second or at each point

    '
  - 'where it is forwarded, whichever comes first.  The value used

    '
  - 'currently for this purpose is 30, so that an IP datagram can live in

    '
  - 'the net no longer than that number of seconds.  This is thus the

    '
  - 'maximum delay allowed on any path between two virtual hosts.  If this

    '
  - 'maximum delay is exceeded in calculating the roundtrip delay for a

    '
  - 'data rate supported by the link.  As a general rule, this interval is

    '
  - 'set at 16 times the expected roundtrip time for the longest packet to

    '
  - 'be sent on that link.  For 1200-bps asynchronous transmission and

    '
  - 'packet lengths to 256 octets, this corresponds to a maximum HELLO

    '
  - "message interval of about 30 seconds. \n     Although the roundtrip delay calculation,
    upon which the routing\n"
  - 'process depends, is relatively insensitive to net traffic and

    '
  - 'congestion, stochastic variations in the calculated values ordinarily

    '
  - 'occur due to coding (bit or character stuffing) and medium

    '
  - 'perturbations.  In order to suppress loops and needless path changes a

    '
  - 'minimum switching threshold is incorporated into the routing mechanism

    '
  - '(see above).  The interval used for this threshold, as well as for the

    '
  - 'minimum delay on any path, is 100 milliseconds.

    '
  title: 2.4.  Timeouts
- contents:
  - "3.  Formal Specification\n     The following sections provide a formal framework
    which describe\n"
  - 'the DCN HELLO protocol.  This protocol is run between neighboring DCN

    '
  - 'hosts that share a common point-to-point link and provides automatic

    '
  - "connectivity determination, routing and timekeeping functions.\n     The descriptions
    to follow are organized as follows: First a\n"
  - 'summary of data structures describes the global variables and packet

    '
  - 'formats.  Then three processes which implement the protocol are

    '
  - 'described: the CLOCK, HELLO and HOST processes.  The description of

    '
  - 'these processes is organized into sections that describe (1) the local

    '
  - 'variables used by that process, (2) the parameters and constants and

    '
  - '(3) the events that initiate processing together with the procedures

    '
  - 'they evoke.  In the case of variables a distinction is made between

    '
  - 'state variables, which retain their contents between procedure calls,

    '
  - 'and temporaries, which have a lifetime extending only while the

    '
  - 'process is running.  Except as noted below, the initial contents of

    '
  - 'state variables are unimportant.

    '
  title: 3.  Formal Specification
- contents:
  - '3.1.  Data Structures

    '
  title: 3.1.  Data Structures
- contents:
  - '3.1.1.  Global Variables

    '
  - "ADDRESS\n    This is a 32-bit bit-string temporary variable used to contain an\n
    \   Internet address.\n"
  - "CLOCK-HID\n    This is an eight-bit integer state variable used to contain the\n
    \   host ID of the local-net host to be used as the master clock.  It\n    is
    initialized to the appropriate value depending upon the net\n    configuration.
    \n"
  - 'DATE

    '
  - "DATE-VALID\n    This is a one-bit state variable used to indicate whether the\n
    \   local date and time are synchronized with the master clock.  A\n    value
    of one indicates the local clock is not synchronized with\n    the master clock.
    \ This variable is set to one initially and when\n    the local time-of-day rolls
    over past midnight.  It is set to zero\n    each time a valid date and time update
    has been received from the\n    master clock. \n"
  - "DELAY\n    This is a 16-bit integer temporary variable which represents the\n
    \   roundtrip delay in milliseconds to a host.\n"
  - "HID\n    This is an eight-bit integer temporary variable containing the\n    host
    ID of some host on the local net.\n    There is a one-to-one correspondence between
    the Internet\n    addresses of local hosts and their HIDs.  The mapping between
    them\n    is selected on the basis of the octet number of the Internet\n    address.
    \ For DCN hosts it is the fourth octet, while for hosts\n    directly connected
    to a class-A ARPANET IMP or gateway, it is the\n    third octet (logical-host
    field).  The contents of this octet are\n    to be added to ADDRESS-OFFSET to
    form the HID associated \n    with the address.\n"
  - "HOLD\n    This is an eight-bit counter state variable indicating whether\n    timestamps
    are valid or not.  While HOLD is nonzero, timestamps\n    should be considered
    invalid.  When set to some nonzero value, the\n    counter decrements to zero
    at a 1-Hz rate.  Its initial value is\n    zero. \n"
  - "HOST-TABLE\n    This is a table of NHOSTS entries indexed by host ID (HID).  There\n
    \   is one entry for each host in the local net.  Each entry has the\n    following
    format:\n    HOST-TABLE.DELAY\n        This is a 16-bit field containing the computed
    roundtrip delay\n        in milliseconds to host HID.\n    HOST-TABLE.OFFSET\n
    \       This is a 16-bit field containing the computed signed offset\n        in
    milliseconds which must be added to the local apparent\n        clock to agree
    with the apparent clock of host HID.\n    HOST-TABLE.PID\n        This is an eight-bit
    field containing the PID of the net-output\n HOST-TABLE.TTL\n     This is an eight-bit
    field used as a time-to-live indicator.\n     It is decremented by the HOST process
    once each second and\n     initialized to a chosen value when a HELLO message
    is\n     received. The table is initialized with the HOST-TABLE.DELAY\n     field
    set to  MAXDELAY for all entries.  The contents of the\n     other fields are
    unimportant. \n"
  - "LOCAL-ADDRESS\n    This is a 32-bit bit-string state variable used to contain
    the \n    local host Internet address.\n"
  - "NET-TABLE\n    This is a table of NNETS entries with the following format:\n
    \   NET-TABLE.HID\n        This is an eight-bit field containing the host ID of
    the\n        pseudo-process to forward packets to the NET-TABLE.NET net.\n    NET-TABLE.NET\n
    \       This is a 24-bit field containing an Internet class-A (eight\n        bits),
    class-B (16 bits) or class-C (24 bits) net number.\n        Note that the actual
    field width for class-B net numbers is 24\n        bits in order to provide a
    subnet capability, in which the\n        high-order eight bits of the 16-bit host
    address is\n        interpreted as the subnet number. \n    The table is constructed
    at configuration time and must include an\n    entry for every net that is a potential
    neighbor.  A neighbor net\n    is defined as a net containing a host that can
    be directly\n    connected to a host on the local net.  The entry for such a net
    is\n    initialized with NET-TABLE.NET set to the neighbor net number and\n    NET-TABLE.HID
    set to an arbitrary vitual-host ID not assigned any\n    other local-net virtual
    host. \n    The remaining entries in NET-TABLE are initialized at initial-boot\n
    \   time with the NET-TABLE.NET fields set to zero and the\n    NET-TABLE.HID
    fields set to a configuration-selected host ID to be\n    used to forward packets
    to all nets other than neighbor nets.  In\n    the case where a gateway module
    is included in the local host\n    configuration, the GGP and/or EGP protocols
    will be used to\n    maintain these entries;  while, in the case where no gateway\n
    \   module is included, only one such entry is required. \n"
  - "OFFSET\n    This is a 16-bit signed integer temporary variable which\n    represents
    the offset in milliseconds to be added to the apparent\n    clock time to yield
    the apparent clock time of the neighbor host. \n"
  title: 3.1.1.  Global Variables
- contents:
  - "3.1.2.  Parameters\n    This is an integer which defines the number of entries
    in HOST-TABLE.\n"
  - "NNETS\n    This is an integer which defines the number of entries in MET-TABLE.\n"
  title: 3.1.2.  Parameters
- contents:
  - '3.1.3.  HELLO Packet Fields

    '
  - "PKT.ADDRESS-OFFSET\n    This eight-bit is copied from ADDRESS-OFFSET by the sender.\n"
  - "PKT.DATESTAMP\n    Bits 0-14 of this 16-bit field are copied from DATE by the
    sender, \n    while bit 15 is copied from DATE-VALID.\n"
  - "PKT.DATE-VALID\n    This one-bit field is bit 15 of PKT.DATESTAMP.\n"
  - "PKT.DESTINATION\n    This 32-bit field is part of the IP header.  It is copied
    from\n    HLO.NEIGHBOR-ADDRESS by the sender.\n"
  - "PKT.HOST-TABLE\n    This is a table of PKT.NHOSTS entries, each entry of which\n
    \   consists of two fields.  The entries are indexed by host ID and\n    have
    the following format: \n    PKT.HOST-TABLE.DELAY\n        This 16-bit field is
    copied from the corresponding HOST-TABLE.DELAY\n        field by the sender.\n
    \   PKT.HOST-TABLE.OFFSET\n        This 16-bit field is copied from the corresponding
    HOST-TABLE.OFFSET\n        field by the sender.\n"
  - "PKT.LENGTH\n    This 16-bit field is part of the IP header.  It is set by the
    sender to\n    the number of octets in the packet.\n"
  - "PKT.NHOSTS\n    This eight-bit field is copied from NHOST by the sender.\n"
  - "PKT.SOURCE\n    This 16-bit field is part of the IP header.  It is copied from\n
    \   LOCAL-ADDRESS by the sender.\n"
  - 'PKT.TIMESTAMP

    '
  - "PKT.TSP\n    This 16-bit field contains a variable used in roundtrip delay\n
    \   calculations.\n"
  title: 3.1.3.  HELLO Packet Fields
- contents:
  - "3.2 CLOCK Process (CLK)\n     The timekeeping system maintains three clocks:
    (1) the physical\n"
  - 'clock, which is determined by a hardware oscillator/counter; (2) the

    '
  - 'apparent clock, which maintains the time-of-day used by client

    '
  - 'processes and (3) the actual clock, which represents the time-of-day

    '
  - 'provided by an outside reference.  The apparent and actual clocks are

    '
  - 'maintained as 48-bit quantities with 32 bits of significance available

    '
  - 'to client processes.  These clocks run at a rate of 1000 Hz and are

    '
  - "reset at midnight UT.\n     The CLOCK process consists of a set of state variables
    along with\n"
  - 'a set of procedures that are called as the result of hardware

    '
  - 'interrupts and client requests.  An interval timer is assumed

    '
  - 'logically separate from the local clock mechanism, although both could

    '
  - 'be derived from the same timing source.

    '
  title: 3.2 CLOCK Process (CLK)
- contents:
  - '3.2.1.  Local Variables

    '
  - "CLK.CLOCK\n    This is a 48-bit fixed-point state variable used to represent
    the\n    apparent time-of-day.  The decimal point is to the right of bit 16\n
    \   (numbering from the right at bit 0).  Bit 16 increments at a rate\n    equivalent
    to 1000 Hz independent of the hardware clock.  (In the\n    case of programmable-clock
    hardware the value of CLK.CLOCK must be\n    corrected as described below.) \n"
  - "CLK.COUNT\n    This is a hardware register that increments at rate R.  It can
    be\n    represented by a simple line clock, which causes interrupts at the\n    line-frequency
    rate, or by a programmable clock, which contains a 16-bit\n    register that is
    programmed to count at a 1000-Hz rate and causes an\n    interrupt on overflow.
    \ The register is considered a fixed-point variable\n    with decimal point to
    the right of bit 0.\n"
  - "CLK.DELTA\n    This is a 48-bit signed fixed-point state variable used to represent
    the\n    increment to be added to CLK.CLOCK to yield the actual time-of-day.  The\n
    \   decimal point is to the right of bit 16.\n"
  title: 3.2.1.  Local Variables
- contents:
  - '3.2.3.  Parameters

    '
  - "ADJUST-FRACTION\n    This is an integer which defines the shift count used to
    compute a\n"
  - "ADJUST-INTERVAL\n    This is an integer which defines the clock-adjust interval
    in\n    milliseconds.  A value of 500 (one-half second) is suggested for\n    the
    line clock and 4000 (four seconds) for the 1000-Hz clock.\n"
  - "CLOCK-TICK\n    This is a fixed-point integer which defines the increment in\n
    \   milliseconds to be added to CLK.CLOCK as the result of a clock\n    tick.
    \ The decimal point is to the right of bit 16.  In the case\n    of a line-clock
    interrupt, the value of CLOCK-TICK should be\n    16.66666 (60 Hz) or 20.00000
    (50 Hz).  In the case of a 1000-Hz\n    programmable-clock overflow, the value
    should be 65536.00000.\n"
  - "HOLD-INTERVAL\n    This is an integer which defines the number of seconds that
    HOLD will\n    count down after CLK.CLOCK has been reset.  The resulting interval
    must be\n    at least as long as the maximum HELLO-INTERVAL used by any HELLO
    process.\n"
  title: 3.2.3.  Parameters
- contents:
  - '3.2.3.  Events and Procedures

    '
  - "INCREMENT-CLOCK Event\n    This event is evoked as the result of a tick interrupt,
    in the case of a\n    line clock, or a counter overflow, in the case of the 1000-Hz
    clock.  It\n    causes the logical clock to be incremented by the value of CLOCK-TICK.\n
    \   1.  Add the value of CLOCK-TICK to CLK.CLOCK.\n"
  - "ADJUST-CLOCK Event\n    This event is evoked once every ADJUST-INTERVAL milliseconds
    to slew the\n    apparent clock time to the actual clock time as set by the SET-CLOCK\n
    \   procedure.  This is done by subtracting a fraction of the correction\n    factor
    CLK.DELTA from the value of CLK.DELTA and adding the same fraction\n    to CLK.CLOCK.
    \ This continues until either the next SET-CLOCK call or\n    CLK.DELTA has been
    reduced to zero.\n    The suggested values for ADJUST-INTERVAL and ADJUST-FRACTION\n
    \   represent a maximum slew rate of less than +-2 milliseconds per\n    second,
    in the case of 1000-Hz clock.  The action is to smooth\n    noisy clock corrections
    received from neighboring systems to\n    obtain a high-quality local reference,
    while insuring the apparent\n    clock time is always monotonically increasing.
    \n    1.  Shift the 48-bit value of CLK.DELTA arithmetically ADJUST-FRACTION\n
    \       bits to the right, discarding bits from the right and saving the\n        result
    in a temporary variable F.  Assuming the decimal point of F to\n    This event
    is evoked once per second to decrement the value of HOLD.\n    1.  If the value
    of HOLD is zero, do nothing;  otherwise, decrement its\n        value.\n"
  - "READ-CLOCK Procedure\n    This procedure is called by a client process.  It returns
    the apparent\n    time-of-day computed as the integer part of the sum CLK.CLOCK
    plus\n    CLK.COUNT.  Note that the precision of the value returned is limited
    to\n    +-1 millisecond, so that client processes must expect the apparent\n    time
    to \"run backward\" occasionally due to drift corrections.  When\n    this happens
    the backward step will never be greater than one\n    millisecond and will never
    occur more often than twice per second.\n    1.  In the case of line clocks CLK.COUNT
    is always zero, while in\n        the case of programmable clocks the hardware
    must be\n        interrogated to extract the value of CLK.COUNT.  If following\n
    \       interrogation a counter-overflow condition is evident, add\n        CLOCK-TICK
    to CLK.CLOCK and interrogate the hardware again.\n    2.  When the value of CLK.COUNT
    has been determined compute the sum\n        CLK.COUNT + CLK.CLOCK.  If this sum
    exceeds the number of\n        milliseconds in 24 hours (86,400,000), reduce CLK.CLOCK
    by\n        86,400,000, set HOLD-INTERVAL -> HOLD, set CLOCK-VALID (bit 15\n        of
    DATE) to one, roll over DATE to the next calendar day and\n        start over.
    \ If not, return the integer part of the sum as the\n        apparent time-of-day.
    \n        The CLOCK-VALID bit is set to insure that a master-clock update is\n
    \       received at least once per day.  Note that, in the case of\n        uncompensated
    crystal oscillators of the type commonly used as the\n        1000-Hz time base,
    a drift of several parts per million can be\n        expected, which would result
    in a time drift of several tenths of a\n        second per day, if not corrected.\n"
  - "SET-CLOCK Procedure\n    This procedure is called by a client process.  It sets
    a time-of-day\n    correction factor in milliseconds.  The argument represents
    a 32-bit\n    signed fixed-point quantity with decimal point to the right of bit\n
    \   0 that is to be added to CLK.CLOCK so that READ-CLOCK subsequently\n    returns
    the actual time-of-day.  \n    1.  If the correction factor is in the range -2**(16-ADJUST-FRACTION)
    to\n        +2**(16-ADJUST-FRACTION) - 1 (about +-128 milliseconds with the\n
    \       suggested value of ADJUST-FRACTION), the value of the argument\n        replaces
    CLK.DELTA and the procedure is complete.  If not, add the\n        value of the
    sign-extended argument to CLK.CLOCK and set CLK.DELTA to\n        zero.  In addition,
    set HOLD-INTERVAL -> HOLD, since this\n        represents a relatively large step-change
    in apparent time.\n        The value of HOLD represents the remaining number of
    seconds\n"
  title: 3.2.3.  Events and Procedures
- contents:
  - "3.3.  HELLO Process\n     The HELLO process maintains clock synchronization with
    a neighbor\n"
  - 'HELLO process using the HELLO protocol.  It also participates in the

    '
  - 'routing algorithm.  There is one HELLO process and one set of local

    '
  - 'state variables for each link connecting the host to one of its

    '
  - 'neighbors.

    '
  title: 3.3.  HELLO Process
- contents:
  - '3.3.1.  Local variables

    '
  - "HLO.BROADCAST\n    This is a one-bit switch state variable.  When set to zero
    a\n    point-to-point link is assumed.  When set to one a broadcast (e.g.\n    Ethernet)
    link is assumed.\n"
  - "HLO.KEEP-ALIVE\n    This is an eight-bit counter state variable used to indicate
    whether the\n    link is up.  It is initialized with a value of zero.\n"
  - "HLO.LENGTH\n    This is a 16-bit integer state variable used to record the length
    in\n    octets of the last HELLO message sent.\n"
  - "HLO.NEIGHBOR-ADDRESS\n    This is a 32-bit integer state variable used to contain
    the neighbor host\n    Internet address.\n"
  - "HLO.PID\n    This is an eight-bit integer state variable used to identify the\n
    \   net-output process associated with this HELLO process.  It is initialized\n
    \   by the kernel when the process is created and remains unchanged\n    thereafter.\n"
  - "HLO.POLL\n    This is a one-bit switch state variable.  When set the HELLO process\n
    \   spontaneously sends HELLO messages.  When not set the HELLO process\n    responds
    to HELLO messages, but does not send them spontaneously.\n"
  - "HLO.TIMESTAMP\n    This is a 32-bit integer temporary variable used to record
    the time of\n    arrival of a HELLO message.\n"
  - 'HLO.TSP

    '
  title: 3.3.1.  Local variables
- contents:
  - '3.3.2.  Parameters

    '
  - "HELLO-INTERVAL\n    This is an integer which defines the interval in seconds
    between HELLO\n    messages.  It ranges from about eight to a maximum of 30 seconds,\n
    \   depending on line speed.\n"
  - "HOLD-DOWN-INTERVAL\n    This is an integer which defines the interval in seconds
    a host will be\n    considered up following receipt of a HELLO message indicating
    that\n    host is up.  A value of 120 is suggested.\n"
  - "KEEP-ALIVE-INTERVAL\n    This is an integer which defines the interval, in units
    of\n    HELLO-INTERVAL, that a HELLO process will consider the link up.  A\n    value
    of four is suggested.\n"
  - "MAXDELAY\n    This is an integer which defines the maximum roundtrip delay in\n
    \   seconds on a path to any reachable host.  A value of 30 is suggested.\n"
  - "MINDELAY\n    This is an integer which defines the minimum switching threshold
    in\n    milliseconds below which routes will not be changed.  A value of 100 is\n
    \   suggested.\n"
  title: 3.3.2.  Parameters
- contents:
  - '3.3.3.  Events and Procedures

    '
  - "INPUT-PACKET Event\n    When a packet arrives the net-input process first sets
    HLO.TIMESTAMP to\n    the value returned by the READ-CLOCK procedure, then checks
    the\n    packet for valid local leader, IP header format and checksum.  If\n    the
    protocol field in the IP header indicates a HELLO message, the\n    packet is
    passed to the HELLO process.  If any errors are found\n    the packet is dropped.
    \n    The HELLO process first checks the packet for valid HELLO header format\n
    \   and checksum.  If any errors are found the packet is dropped.  Otherwise,\n
    \   it proceeds as follows:\n    1.  If PKT.SOURCE is equal to LOCAL-ADDRESS,
    then the line to the\n        neighbor host is looped.  If this is a broadcast
    link\n        (HLO.BROADCAST is set to one), then ignore this nicety;  if\n        not,
    this is considered an error and further processing is\n        abandoned.  Note
    that, in special configurations involving\n        other systems (e.g.  ARPANET
    IMPs and gateways) it may be\n        useful to use looped HELLO to monitor connectivity.
    \ The DCN\n        implementation provides this feature, but is not described
    here.\n    2.  Set KEEP-ALIVE-INTERVAL -> HLO.KEEP-ALIVE.  This indicates the\n
    \   3.  Set PKT.TIMESTAMP - HLO.TIMESTAMP -> HLO.TSP.  This is part of the\n        roundtrip
    delay calculation.  The value of HLO.TSP will be\n        updated and returned
    to the neighbor in the next HELLO message\n        transmitted.  Next, compute
    the raw roundtrip delay and offset:\n        HLO.TIMESTAMP - PKT.TSP -> DELAY
    and HLO.TSP + DELAY/2 -> OFFSET. \n        Note:  in the case of a broadcast link
    (HLO.BROADCAST set to one) set\n        DELAY to zero.\n    4.  Perform this step
    only in the case of non-broadcast links\n        (HLO.BROADCAST set to zero).
    \ If PKT.SOURCE is not equal to\n        HLO.NEIGHBOR-ADDRESS, then a new neighbor
    has appeared on this\n        link. Set PKT.SOURCE -> HLO.NEIGHBOR ADDRESS, MAXDELAY
    ->\n        DELAY and proceed to the next step.  This will force the line\n        to
    be declared down and result in a hold-down cycle.\n        Otherwise, if either
    PKT.TSP is zero or HOLD is nonzero, then\n        the DELAY calculation is invalid
    and further processing is\n        abandoned.  Note that a hold-down cycle is
    forced in any \n        case if a new neighbor is recognized.\n    5.  If processing
    reaches this point the DELAY and OFFSET\n        variables can be assumed valid
    as well as the remaining data\n        in the packet.  First, if DELAY < MINDELAY,
    set MINDELAY ->\n        DELAY.  This avoids needless path switching when the\n
    \       difference in delays is not significant and has the effect\n        that
    on low-delay links the routing algorithm degenerates to \n        min-hop rather
    than min-delay.  Then set HLO.PID -> PID.  There are\n        two cases:\n        Case
    1:  PKT.NHOSTS is zero.\n            This will be the case when the neighbor host
    has just come up or\n            is on a different net or subnet.  Set NEIGHBOR-ADDRESS
    -> ADDRESS\n            and call the ROUTE procedure, which will return the host\n
    \           ID.  Then call the UPDATE procedure.  In the case of\n            errors,
    do nothing but return.\n        Case 2:  PKT.NHOSTS is nonzero.\n            This
    is the case when the neighbor host is on the same net or\n            subnet.
    \ First, save the values of DELAY and OFFSET in temporary\n            variables
    F and G.  Then, for each value of HID from zero to\n            NHOSTS-1 consider
    the corresponding PKT.HOSTS-TABLE entry and do\n            the following:  Set
    F + PKT.HOST-TABLE.DELAY -> DELAY and\n            G + PKT.HOST-TABLE.OFFSET ->
    OFFSET and call the UPDATE procedure.\n            This completes processing.\n
    \       ROUTE Procedure\n            This procedure returns the host ID in HID
    of the host represented\n            by the global variable ADDRESS.\n    1.  First,
    determine if the host represented by ADDRESS is on the same\n        local net
    as LOCAL-ADDRESS.  For the purposes of this\n        comparison bits 0-7 and 16-31
    are compared for class-A nets\n        Case 1:  The host is on the same net or
    subnet.\n            Extract the address field of ADDRESS, subtract ADDRESS-OFFSET
    and\n            store the result in HID.  If 0 <= HID < NHOSTS, the procedure\n
    \           completes normally;  otherwise it terminates in an error\n            condition.\n
    \       Case 2:  The host is not on the same net or subnet.\n            Search
    the NET-TABLE for a match of the net fields of\n            LOCAL-ADDRESS and
    NET-TABLE.NET.  If found set\n            NET-TABLE.HID -> HID and return normally.
    \ If the NET-TABLE.NET\n            field is zero, indicating the last entry in
    the table, set\n            HET-TABLE.HID -> HID and return normally.  Note that,
    in the case\n            of hosts including GGP/EGP gateway modules, if no match
    is found\n            the procedure terminates in an error condition.\n"
  - "UPDATE Procedure\n    This procedure updates the entry of HOST-TABLE indicated
    by HID using\n    three global variables:  DELAY, OFFSET and PID.  Its purpose
    is to update\n    the HOST-TABLE entry corresponding to host ID HID.  In the following
    all\n    references are to this entry.\n    1.  If PID is not equal to HOST-TABLE.PID,
    the route to host HID is not\n        via the net-output process associated with
    this HELLO process.  In\n        this case, if DELAY + MINDELAY > HOST-TABLE.DELAY,
    the path is longer\n        than one already in HOST-TABLE, so the procedure does
    nothing.\n    2.  This step is reached only if either the route to host HID is
    via the\n        net-output process associated with this HELLO process or the
    newly\n        reported path to this host is shorter by at least MINDELAY.  \n
    \       There are two cases:\n        Case 1:  HOST-TABLE.DELAY < MAXDELAY.\n
    \           The existing path to host HID is up and this is a point-to-point\n
    \           link (HLO.BROADCAST is set to zero).  If DELAY < MAXDELAY the\n            newly
    reported path is also up.  Proceed to the next step.\n            Otherwise, initiate
    a hold-down cycle by setting\n            MAXDELAY -> HOST-TABLE.DELAY and\n            HOLD-DOWN-INTERVAL
    -> HOST-TABLE.TTL and return.\n        Case 2:  HOST-TABLE.DELAY >= MAXDELAY.\n
    \           The existing path to host HID is down.  If DELAY < MAXDELAY and\n
    \           HOST-TABLE.TTL is zero, the hold-down period has expired and the\n
    \           newly reported path has just come up.  Proceed to the next step.\n
    \           Otherwise simply return.\n    3.  In this step the HOST-DELAY entry
    is updated.  Set\n    4.  For precise timekeeping, the offset can be considered
    valid only if\n        the length of the last HELLO packet transmitted is equal
    to\n        the length of the last one received.  Thus, if HLO.LENGTH\n        equal
    to PKT.LENGTH, set OFFSET -> HOST-TABLE.OFFSET;\n        otherwise, leave this
    field alone. Finally, if HID is equal to\n        CLOCK-HID and bit 15 (the DATE-VALID
    bit) \n        of DATE is zero, set PKT.DATESTAMP -> DATE and call the SET-CLOCK\n
    \       procedure of the CLOCK process with argument HLO.TIMESTAMP.\n"
  - "OUTPUT-PACKET Event\n    This event is evoked once every HELLO-INTERVAL seconds.
    \ It determines if\n    a HELLO message is to be transmitted, transmits it and
    updates state\n    variables.\n    1.  If HLO.KEEP-ALIVE is nonzero decrement
    its value.\n    2.  If HLO.POLL is zero and HLO.KEEP-ALIVE is zero, do not send
    a HELLO\n        message.  If either is nonzero initialize the packet fields as\n
    \       follows:  LOCAL-ADDRESS -> PKT.SOURCE,\n        HLO.NEIGHBOR-ADDRESS ->
    PKT.DESTINATION and DATE -> PKT.DATESTAMP.\n        Note:  PKT.DESTINATION is
    set to zero if this is a broadcast link\n        (HLO.BROADCAST set to one).  Also,
    note that bit 15 of DATE is the\n        DATE-VALID bit.  If this bit is one the
    receiver will not update its\n        master clock from the information in the
    transmitted packet.\n        This is significant only if the sending host is on
    the\n        least-delay path to the master clock.  Set PKT.TIMESTAMP to\n        the
    value returned from the READ-CLOCK procedure.  If\n        HLO.KEEP-ALIVE is zero
    or HOLD is nonzero, set PKT.TSP to\n        zero;  otherwise, set PKT.TIMESTAMP
    + HLO.TSP -> PKT.TSP.\n    3.  Determine if the neighbor is on the same net or
    subnet.  If the\n        neighbor is on a different net set PKT.NHOSTS to zero
    and\n        proceed with the next step.  Otherwise, set NHOSTS ->\n        PKT.NHOSTS
    and for each value of HID from zero to PKT.HOSTS-1\n        copy the HOST-TABLE.DELAY
    and HOST-TABLE.OFFSET fields of the\n        corresponding HOST-TABLE entry in
    order into the packet.  For\n        each entry copied test if the HOST-TABLE.PID
    field matches the\n        HLO.PID of the HELLO process.  If so, a potential routing
    loop\n        is possible.  In this case use MAXDELAY for the delay field in\n
    \       the packet instead. \n    4.  Finally, set HLO.LENGTH to the number of
    octets in the packet \n        and send the packet.\n"
  title: 3.3.3.  Events and Procedures
- contents:
  - "3.4.  HOST Process (HOS)\n     This process maintains the routing tables.  It
    is activated once per\n"
  title: 3.4.  HOST Process (HOS)
- contents:
  - '3.4.1.  Local variables

    '
  - "HOS.PID\n    This is an eight-bit integer used to identify the HOST process.
    \ It is\n    initialized by the kernel when the process is created and remains\n
    \   unchanged thereafter.\n"
  - "HOS.HID\n    This is an eight-bit temporary variable.\n"
  title: 3.4.1.  Local variables
- contents:
  - '3.4.2.  Events and Procedures

    '
  - "SCAN Event\n    This event is evoked once each second to scan the HOST-TABLE
    and perform\n    housekeeping functions.\n    1.  For each value of a temporary
    variable F from zero to NHOSTS-1 do the\n        following:  Set LOCAL-ADDRESS
    -> ADDRESS and call the ROUTE\n        procedure, which will return the host ID
    HID.  If F is equal\n        to HID, then set both DELAY and OFFSET to zero, HOS.PID
    -> PID\n        and call the UPDATE procedure.  This will cause all packets\n
    \       received with the local address to be routed to this process.\n        If
    HOST-TABLE.TTL is zero skip this step.  Otherwise, decrement\n        HOST-TABLE.TTL
    by one.  If the result is nonzero skip the\n        remainder of this step.  Otherwise,
    If HOST-TABLE.DELAY <MAXDELAY set\n        HOLDOFF-INTERVAL -> HOST-TABLE.TTL
    and MAXDELAY -> HOST-TABLE.DELAY.\n        The effect of this step is to declare
    a hold-down cycle when a host\n        goes down.\n"
  title: 3.4.2.  Events and Procedures
- contents:
  - '4.  References

    '
  title: 4.  References
- contents:
  - 'Appendix A.  Link-Level Packet Formats

    '
  title: Appendix A.  Link-Level Packet Formats
- contents:
  - "A.1.  Serial Links Using Program-Interrupt Interfaces\n     Following is a description
    of the frame format used on\n"
  - 'asynchronous and synchronous serial links with program-interrupt

    '
  - 'interfaces such as the DEC DLV11 and DPV11.  This format provides

    '
  - 'transparency coding for all messages, including HELLO messages, but

    '
  - 'does not provide error detection or retransmission functions.  It is

    '
  - 'designed to be easily implemented and compatible as far as possible

    '
  - "with standard industry protocols.\n     The protocol is serial-by-bit, with the
    same interpretation on\n"
  - 'the order of transmission as standard asynchronous and synchronous

    '
  - 'interface devices; that is, the low-order bit of each octet is

    '
  - 'transmitted first.  The data portion of the frame consists of one

    '
  - 'Internet datagram encoded according to a "character-stuffing"

    '
  - 'transparency convention:

    '
  - "1.  The frame begins with the two-octet sequence DLE-STX, in the case of\n    asynchronous
    links, or the four-octet sequence SYN-SYN-DLE-STX, in the\n    case of synchronous
    links.  The data portion is transmitted next,\n    encoded as described below,
    followed by the two-octet sequence\n    DLE-ETX.  No checksum is transmitted or
    expected.  If it is\n    necessary for any reason to transmit time-fill other
    than in the\n    data portion, the DEL (all ones) is used.\n"
  - "2.  Within the data portion of the frame the transmit buffer is\n    scanned
    for a DLE.  Each DLE found causes the sequence DLE-DLE to\n    be transmitted.
    \ If it is necessary for some reason for the\n    transmitter to insert time-fill
    within the data portion, the\n    sequence DLE-DEL is used. \n"
  - "3.  While scanning the data stream within the data portion of the\n    frame
    the sequence DLE-DLE is found, a single DLE is inserted in\n    the receive buffer.
    \ If the sequence DLE-ETX is found, the buffer\n    is passed on for processing.
    The sequence DLE-DEL is discarded.\n    Any other two-octet sequence beginning
    with DLE and ending with\n    other than DLE, ETX or DEL is considered a protocol
    error \n    (see note below). \n     Note: In the case of synchronous links using
    program-interrupt\n"
  - 'interfaces such as the DPV11, for example, a slightly modified

    '
  - 'protocol is suggested when both ends of the link concur.  These

    '
  - 'interfaces typically provide a parameter register which can be loaded

    '
  - 'with a code used both to detect the receiver synchronizing pattern and

    '
  - 'for time-fill when the transmit buffer register cannot be serviced in

    '
  - "time for the next character.\n     The parameter register must be loaded with
    the SYN code for this\n"
  - 'protocol to work properly.  However, should it be necessary to

    '
  - "1.  If the transmitter senses a time-fill condition (usually by a\n    control
    bit assigned for this purpose) between frames or\n    immediately following transmission
    of a DLE, the condition is ignored.\n"
  - "2.  If the transmitter senses a time-fill condition at other times it sends\n
    \   the sequence DLE-CAN.\n"
  - "3.  If the receiver finds a SYN either between frames or immediately\n    following
    DLE, the SYN is discarded without affecting sequence\n    decoding. \n"
  - "4.  If the receiver finds the sequence DLE-CAN in the data portion, it\n    discards
    the sequence and the immediately preceding octet.\n     These rules will work
    in cases where a single SYN has been\n"
  - 'inserted by the transmitter and even when a SYN has been inserted in

    '
  - 'the DLE-CAN sequence.  If an overrun (lost data) condition is sensed

    '
  - 'at the receiver, the appropriate action is to return to the

    '
  - 'initial-synchronization state.  This should also be the action if any

    '
  - 'code other than STX is found following the initial DLE.  or if any

    '
  - 'code other than DLE, ETX, DEL or CAN is found following a DLE in the

    '
  - 'data portion.

    '
  title: A.1.  Serial Links Using Program-Interrupt Interfaces
- contents:
  - "A.2.  Serial Links Using DDCMP Devices\n     Following is a description of the
    frame format used on DEC DDCMP links\n"
  - 'with DMA interfaces such as the DEC DMV11 and DMR11.  These interfaces

    '
  - 'implement the DEC DDCMP protocol, which includes error detection and

    '
  - 'retransmission capabilities.  The DDCMP frame format is as follows:

    '
  - '+-------------+-----+-----+-----+-----+-----+------+------+------+

    '
  - '| SYN SYN SOH |Count|Flag |Resp | Seq | Adr | CRC1 | Data | CRC2 |

    '
  - '+-------------+-----+-----+-----+-----+-----+------+------+------+

    '
  - 'bits   24       14     2     8     8     8     16     ...    16

    '
  - 'With respect to this diagram, each octet is transmitted starting from the

    '
  - 'leftmost octet, with the bits of each octet transmitted low-order bit first.

    '
  - 'The contents of all fields except the "Data" field are managed by the

    '
  - 'interface.  The Internet datagram is placed in this field as-is, with no

    '
  - 'character or bit stuffing (the extent of this field is indicated by the

    '
  - 'interface in the "Count" field.

    '
  title: A.2.  Serial Links Using DDCMP Devices
- contents:
  - "A.3.  Serial Links Using HDLC Devices\n     Following is a description of the
    frame format used on HDLC links with\n"
  - "program-interrupt interfaces such as the DEC DPV11.\n        +--------+--------+--------+--------+--------+--------+\n
    \       |  Flag  |  Addr  |  Ctrl  |  Data  |  CRC   |  Flag  |\n"
  - 'With respect to this diagram, each octet is transmitted starting from

    '
  - 'the leftmost octet, with the bits of each octet transmitted low-order

    '
  - 'bit first.  The code xxxxxxxx represents the data portion and cccccccc

    '
  - 'represents the checksum.  The bits between the "Flag" fields are

    '
  - 'encoded with a bit-stuffing convention in which a zero bit is stuffed

    '
  - 'following a string of five one bits.  The "Addr" and "Ctrl" fields are

    '
  - 'not used and the checksum is ignored.  The Internet datagram is placed

    '
  - 'in the "Data" field, which must be a multiple of eight bits in length.

    '
  title: A.3.  Serial Links Using HDLC Devices
- contents:
  - "A.4.  ARPANET 1822 Links Using Local or Distant Host Interfaces\n     Following
    is a description of the frame format used with ARPANET\n"
  - '1822 Local or Distant Host interfaces.  These interfaces can be used

    '
  - 'to connect a DCN host to an ARPANET IMP, Gateway or Port Expander or

    '
  - 'to connect two DCN hosts together.  When used to connect a DCN host to

    '
  - 'an ARPANET IMP, Gateway or Port Expander, a 96-bit 1822 leader is

    '
  - 'prepended ahead of the Internet datagram.  The coding of this leader

    '
  - 'is as described in BBN Report 1822.  When used to connect two DCN

    '
  - 'hosts together, no leader is used and the frame contains only the

    '
  - 'Internet datagram.

    '
  title: A.4.  ARPANET 1822 Links Using Local or Distant Host Interfaces
- contents:
  - "A.5.  ARPANET 1822 Links Using HDH Interfaces\n     Following is a description
    of the frame format used with ARPANET\n"
  - '1822 HDH interfaces.  These interfaces can be used to connect a DCN

    '
  - 'host to an ARPANET IMP or Gateway or to connect two DCN hosts

    '
  - 'together.  In either case, the frame format is as described in

    '
  - 'Appendix J of BBN Report 1822.

    '
  title: A.5.  ARPANET 1822 Links Using HDH Interfaces
- contents:
  - "A.6.  X.25 LAPB Links Using RSRE Interfaces\n     Following is a description
    of the frame format used on X.25 LAPB\n"
  - 'links with the Royal Signals and Radar Establishment interfaces.

    '
  - 'These interfaces implement the X.25 Link Access Protocol - Balanced

    '
  - '(LAPB), also known as the frame-level protocol, using a frame format

    '
  - 'similar to that described under A.3 above.  Internet datagrams are

    '
  - 'placed in the data portion of I frames and encoded with the

    '
  - 'bit-stuffing procedure described in A.3.  There is no packet-level

    '
  - 'format used with these interfaces.

    '
  title: A.6.  X.25 LAPB Links Using RSRE Interfaces
- contents:
  - "A.7.  Ethernet Links\n     Following is a description of the frame format used
    on Ethernet links.\n        +-----------+-----------+------+------+-----+\n        |
    Dest Addr | Srce Addr | Type | Data | CRC |\n        +-----------+-----------+------+------+-----+\n"
  - 'bits          48          48       16     ...   32

    '
  - 'With respect to this diagram, each field is transmitted starting from

    '
  - 'the leftmost field, with the bits of each field transmitted low-order

    '
  - 'ARP datagrams (0806 hex).  The Internet datagram is placed in the

    '
  title: A.7.  Ethernet Links
