- title: __initial_text__
  contents:
  - "                         DCN Local-Network Protocols\nThis RFC is a description\
    \ of the protocol used in the DCN local\nnetworks to maintain connectivity, routing,\
    \ and timekeeping\ninformation.  These procedures may be of interest to designers\
    \ and\nimplementers of other networks.\n1.  Introduction\n     This document describes\
    \ the local-net architecture and protocols\nof the Distributed Computer Network\
    \ (DCN), a family of local nets\nbased on Internet technology and an implementation\
    \ of PDP11-based\nsoftware called the Fuzzball.  DCN local nets have been in operation\n\
    for about three years and now include clones in the USA, UK, Norway\nand West\
    \ Germany.  They typically include a number of PDP11 or LSI-11\nFuzzballs, one\
    \ of which is elected a gateway, and often include other\nInternet-compatible\
    \ hosts as well.\n     The DCN local-net protocols are intended to provide connectivity,\n\
    routing and timekeeping functions for a set of randomly connected\npersonal computers\
    \ and service hosts.  The design philosophy guiding\nthe Fuzzball implementation\
    \ is to incorporate complete functionality\nin every host, which can serve as\
    \ a packet switch, gateway and service\nhost all at the same time.  When a set\
    \ of Fuzzballs are connected\ntogether using a haphazard collection of serial,\
    \ parallel and\ncontention-bus interfaces, they organize themselves into a network\n\
    with routing based on minimum delay.\n     The purpose of this document is to\
    \ describe the local-net\nprotocols used by the DCN to maintain connectivity,\
    \ routing and\ntimekeeping functions.  The document is an extensive revision and\n\
    expansion of Section 4.2 of [1] and is divided into two parts, the\nfirst of which\
    \ is an informal description of the architecture,\ntogether with explanatory remarks.\
    \  The second part consists of a\nsemi-formal specification of the entities and\
    \ protocols used to\ndetermine connectivity, establish routing and maintain clock\n\
    synchronization and is designed to aid in the implementation of cohort\nsystems.\
    \  The link-level coding is described in the appendix.\n2.  Narrative Description\n\
    \     The DCN architecture is designed for local nets of up to 256\nhosts and\
    \ gateways using the Internet Protocol (IP) and client\nprotocols.  It provides\
    \ adaptive routing and clock synchronization\nfunctions in an arbitrary topology\
    \ including point-to-point links and\nmultipoint bus systems.  It is intended\
    \ for use in connecting personal\ncomputers to each other and to service machines,\
    \ gateways and other\nhosts of the Internet community.  However, it is not intended\
    \ for use\nin large, complex networks and does not support the sophisticated\n\
    routing and control algorithms of, for example, the ARPANET.\n     A brief description\
    \ of the process and addressing structure used\nwhich is given a unique 8-bit\
    \ identifier called its port ID.  Every\nDCN physical host contains one or more\
    \ internet processes, each of\nwhich supports a virtual host given a unique 8-bit\
    \ identifier called\nits host ID.\n     Each virtual host can support multiple\
    \ internet protocols,\nconnections and, in addition, a virtual clock.  Each physical\
    \ host\ncontains a physical clock which can operate at an arbitrary rate and,\n\
    in addition, a 32-bit logical clock which operates at 1000 Hz and is\nassumed\
    \ to be reset each day at 0000 hours UT.  Not all physical hosts\nimplement the\
    \ full 32-bit precision; however, in such cases the\nresolution of the logical\
    \ clock may be somewhat less.\n     There is a one-to-one correspondence between\
    \ Internet addresses\nand host IDs.  The host ID is formed from a specified octet\
    \ of the\nInternet address to which is added a specified offset.  The octet\n\
    number and offset are selected at configuration time and must be the\nsame for\
    \ all DCN hosts sharing the local net.  For class-B and class-C\nnets normally\
    \ the fourth octet is used in this way for routing within\nthe local net.  In\
    \ the case of class-B nets, the third octet is\nconsidered part of the net number\
    \ by DCN hosts; therefore, this octet\ncan be used for routing between DCN local\
    \ nets.  For class-A nets\nnormally the third octet (ARPANET logical-host field)\
    \ is used for\nrouting where necessary.\n     Each DCN physical host is identified\
    \ by a host ID for the purpose\nof detecting loops in routing updates, which establish\
    \ the\nminimum-delay paths between the virtual hosts.  By convention, the\nphysical\
    \ host ID is assigned as the host ID of one of its virtual\nhosts.  A link to\
    \ a neighbor net is associated with a special virtual\nhost, called a gateway,\
    \ which is assigned a unique host ID.\n     The links connecting the various physical\
    \ hosts together and to\nforeign nets can be distributed in arbitrary ways, so\
    \ long as the net\nremains fully connected.  If full connectivity is lost, due\
    \ to a link\nor host fault, the virtual hosts in each of the surviving segments\
    \ can\ncontinue to operate with each other and, once connectivity is\nrestored,\
    \ with all of them.\n     Datagram routing is determined entirely by internet\
    \ address -\nthere is no local leader as in the ARPANET.  Each physical host\n\
    contains two tables, the Host Table, which is used to determine the\noutgoing\
    \ link to each other local-net host, and the Net Table, which\nis used to determine\
    \ the outgoing host (gateway) to each other net.\nThe Host Table contains estimates\
    \ of roundtrip delay and logical-clock\noffset for all virtual hosts in the net\
    \ and is indexed by host ID.\nFor the purpose of computing these estimates the\
    \ delay and offset of\neach virtual host relative to the physical host in which\
    \ it resides is\nassumed zero.  The single exception to this is a special virtual\
    \ host\nassociated with an NBS radio time-code receiver, where the offset is\n\
    computed relative to the broadcast time.\nneighbors.  Each entry contains the\
    \ net number, as well as the host ID\nof the local-net gateway to that net.  The\
    \ routing function simply\nlooks up the net number in the Net Table, finds the\
    \ host ID of the\ngateway and retrieves the port ID of the net-output process\
    \ from the\nHost Table.  Other information is included in the Host Table and Net\n\
    Table as described below.\n     The delay and offset estimates are updated by\
    \ HELLO messages\nexchanged on the links connecting physical-host neighbors. \
    \ The HELLO\nmessages are exchanged frequently, but not so as to materially degrade\n\
    the throughput of the link for ordinary data messages.  A HELLO\nmessage contains\
    \ a copy of the delay and offset information from the\nHost Table of the sender,\
    \ as well as information to compute the\nroundtrip delay and logical-clock offset\
    \ of the receiver relative to\nthe sender.\n     The routing algorithm is similar\
    \ to that (formerly) used in the\nARPANET and other places in that the roundtrip\
    \ (biased) delay estimate\ncalculated to a neighbor is added to each of the delay\
    \ estimates given\nin its HELLO message and compared with the corresponding delay\n\
    estimates in the Host Table.  If a delay computed in this way is less\nthan the\
    \ delay already in the Host Table, the routing to the\ncorresponding virtual host\
    \ is changed accordingly.  The detailed\noperation of this algorithm, which includes\
    \ provisions for host\nup-down logic and loop suppression, is summarized in a\
    \ later section.\n     DCN local nets are self-configuring for all hosts and neighbor\n\
    nets; that is, the routing algorithms will find minimum-delay paths\nbetween all\
    \ hosts and gateways to neighbor nets.  In addition,\ntimekeeping information\
    \ can be exchanged using special HELLO messages\nbetween neighboring DCN local\
    \ nets.  For routing beyond neighbor nets\nadditional entries can be configured\
    \ in the Net Tables as required.\nIn addition, a special entry can be configured\
    \ in the Net Tables which\nspecifies the host ID of the gateway to all nets not\
    \ explicitly\nincluded in the table.\n     For routing via the ARPANET and its\
    \ reachable nets a selected\nlocal-net host is equipped with an IMP interface\
    \ and configured with a\nGGP/EGP Gateway process.  This process maintains the\
    \ Net Table of the\nlocal host, including ARPANET leaders, dynamically as part\
    \ of the\nGGP/EGP protocol interactions with other ARPANET gateways.  GGP/EGP\n\
    protocol interactions are possibly with non-ARPANET gateways as well.\n     The\
    \ portable virtual-host structure used in the DCN encourages a\nrather loose interpretation\
    \ of addressing.  In order to minimize\nconfusion in the following, the term \"\
    host ID\" will be applied only to\nvirtual hosts, while \"host number\" will be\
    \ applied to the physical\nhost, called generically the DCN host.\n2.1.  Net and\
    \ Host Tables\n     There are two tables in every DCN host which control routing\
    \ of\nwhile the Host Table is used to determine the link, with respect to\nthe\
    \ DCN host, on the route to a virtual host.  The Host Table is\nmaintained dynamically\
    \ using updates generated by periodic HELLO\nmessages.  The Net Table is fixed\
    \ at configuration time for all DCN\nhosts except those that support a GGP/EGP\
    \ Gateway process.  In these\ncases the Net Table is updated as part of the gateway\
    \ operations.  In\naddition, entries in either table can be changed by operator\
    \ commands.\n     The Net Table format is shown in Figure 1.\n               \
    \         1                   0 \n              5 4 3 2 1 0 9 8 7 6 5 4 3 2 1\
    \ 0\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |          \
    \ Net Name            |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \         |    Net(2)     |    Net(1)     |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             |    Index      |    Net(3)     |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             |     Hops      |  Gateway ID   |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             |                               |\n             |        Gateway\
    \ Leader         |\n             |                               |\n         \
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                 Figure 1. Net Table Entry\n\
    \     The \"Net Name\" field defines a short (RAD50) name for the net,\nwhile\
    \ the \"Net\" fields define the class A/B/C net number.  The\n\"Gateway ID\" field\
    \ contains the host ID of the first gateway to the\nnet and the \"Hops\" field\
    \ the number of hops to it.  The remaining\nfields are used only by the GGP/EGP\
    \ Gateway process and include the\n\"Index\" field, which contains an index into\
    \ the routing matrix.  and\nthe \"Gateway Leader\" field, which contains the (byte-swapped)\n\
    local-net leader for the gateway on a neighbor net.\n     The Net Table contains\
    \ an indefinite number of entries and is\nterminated by a special entry with all\
    \ \"Net\" fields set to zero.  If\nthe \"Hops\" field of this entry is less than\
    \ 255, the \"Gateway ID\"\nfield of this entry is used for all nets not in the\
    \ table.  If the\n\"Hops\" field is 255 all nets not explicitly mentioned in the\
    \ table\n                        1                   0 \n              5 4 3 2\
    \ 1 0 9 8 7 6 5 4 3 2 1 0\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \           |             Name              |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             |      TTL      |    Port ID    |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             |             Delay             |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             |             Offset            |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             |                               |\n             +              \
    \                 +\n             |          Local Leader         |\n        \
    \     +                               +\n             |                      \
    \         |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |  \
    \                             |\n             +        Update Timestamp      \
    \ +\n             |                               |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 2. Host Table Entry\n     The ordinal position of each\
    \ Host Table entry corresponds to its\nhost ID.  The \"Name\" field contains a\
    \ short (RAD50) name for\nconvenient reference.  The \"Port ID\" field contains\
    \ the port ID of the\nnet-output process on the shortest path to this virtual\
    \ host and the\n\"Delay\" field contains the measured roundtrip delay to it. \
    \ The\n\"Offset\" field contains the difference between the logical clock of\n\
    this host and the logical clock of the local host.  The \"Local Leader\"\nfield\
    \ contains information used to construct the local leader of the\noutgoing packet,\
    \ for those nets that require it.  The \"Update\nTimestamp\" field contains the\
    \ logical clock value when the entry was\nlast updated and the \"TTL\" field the\
    \ time (in seconds) remaining until\nthe virtual host is declared down.\n    \
    \ All fields except the \"Name\" field are filled in as part of the\nrouting update\
    \ process, which is initiated upon arrival of a HELLO\n                      \
    \  1                   0 \n              5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0\n   \
    \      --- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\nFixed        |           Checksum\
    \            |\nArea         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |\
    \             Date              |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             |                               |\n             +              Time\
    \             +\n             |                               |\n            \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |           Timestamp      \
    \     |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |     Offset\
    \    |   Hosts (n)   |\n         --- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\nHost \
    \        |          Delay Host 0         |\nArea         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             |         Offset Host 0         |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            ...                             ...\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             |         Delay Host n-1        |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             |         Offset Host n-1       |\n         --- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 3. HELLO Message Format\n     There are two HELLO message\
    \ formats, depending on the length of\nthe message.  One format, sent by a DCN\
    \ host to another host on the\nsame local net, includes both the fixed and host\
    \ areas shown above.\nThe second format, sent in all other cases, includes only\
    \ the fixed\narea.\n     Note that all word fields shown are byte-swapped with\
    \ respect to\nthe ordinary PDP11 representation.  The \"Checksum\" field contains\
    \ a\nchecksum covering the fields indicated.  The \"Date\" and \"Time\" fields\n\
    are filled in with the local date and time of origination.  The\n\"Timestamp\"\
    \ field is used in the computation of the roundtrip delay\n(see below).  The \"\
    Offset\" field contains the offset of the block af\nInternet addresses used by\
    \ the local net.  The \"Delay Host n\" and\n\"Offset Host n\" fields represent\
    \ a copy of the corresponding entries\nof the Host Table as they exist at the\
    \ time of origination.  The\n\"Hosts (n)\" field contains the number of entries\
    \ in this table.\n2.2.  Roundtrip Delay Calculations\n     Periodically, each\
    \ DCN physical host sends a HELLO message to its\nneighbor on each of the communication\
    \ links common to both of them.\nWhen constructing a HELLO message the sender\
    \ sets the\ndestination-address field to this state variable and the\nsource-address\
    \ field to its own address.  It then fills in the \"Date\"\nand \"Time\" fields\
    \ from its logical clock and the \"Timestamp\" field\nfrom another state variable.\
    \  It finally copies the \"Delay\" and\n\"Offset\" values from its Host Table\
    \ into the message.\n     A host receiving a HELLO message discards it if the\
    \ format is bad\nor the checksum fails.  If valid, it initializes a link state\
    \ variable\nto show that the link is up.  Each time a HELLO message is transmitted\n\
    this state variable is decremented.  If it decrements to zero the link\nis declared\
    \ down.\n     The host then checks if the source-address field matches the\nstate\
    \ variable containing the last address stored.  If not, the link\nhas been switched\
    \ to a new host, so the state variables are flushed\nand the link forced into\
    \ a recovery state.  The host then checks if\nthe destination-address field matches\
    \ its own address.  If so, the\nmessage has been looped (legal only in the case\
    \ of a broadcast net)\nand the roundtrip delay information is corrected.  The\
    \ host and net\nareas are ignored in this case.  If not, the host and net areas\
    \ of the\nmessage are processed to update the Host and Net Tables.\n     Roundtrip\
    \ delay calculations are performed in the following way.\nThe link input/output\
    \ processes assigned each link maintain an\ninternal state variable which is updated\
    \ as each HELLO message is\nreceived and transmitted.  When a HELLO message is\
    \ received this\nvariable takes the value of the \"Time\" field minus the current\n\
    time-of-day.  When the next HELLO message is transmitted, the value\nassigned\
    \ the \"Timestamp\" field is computed as the low-order 16-bits of\nthis variable\
    \ plus the current time-of-day.  The value of this\nvariable is forced to zero\
    \ if either the link is down of the system\nlogical clock has been reset since\
    \ the last HELLO message was\nreceived.\n     If a HELLO message is received with\
    \ zero \"Timestamp\" field, no\nprocessing other than filling in the internal\
    \ state variable.\nOtherwise, the roundtrip delay is computed as the low-order\
    \ 16-bits of\nthe current time-of-day minus the value of this field.  In order\
    \ to\nassure the highest accuracy, the calculation is performed only if the\n\
    length of the last transmitted HELLO message (in octets) matches the\nlength of\
    \ the received HELLO message.\n     The above technique renders the calculation\
    \ independent of the\nclock offsets and intervals between HELLO messages at either\
    \ host,\nprotects against errors that might occur due to lost HELLO messages\n\
    and works even when a neighbor host simply forwards the HELLO message\nback to\
    \ the originator without modifying it.  The latter behavior,\ntypical of ARPANET\
    \ IMPs and gateways, as well as broadcast nets, relies\n2.3.  Host Updates\n \
    \    When a HELLO message arrives which results in a valid roundtrip\ndelay calculation,\
    \ a host update process is performed.  This consists\nof adding the roundtrip\
    \ delay to each of the \"Delay Host n\" entries in\nthe HELLO message in turn\
    \ and comparing each of these calculated\ndelays to the \"Host Delay\" field of\
    \ the corresponding Host Table\nentry.  Each entry is then updated according to\
    \ the following rules:\n1.  If the link connects to another DCN host on the same\
    \ net and the\n    port ID (PID) of the link output process matches the \"Port\
    \ ID\"\n    field of the entry, then update the entry.\n2.  If the link connects\
    \ to another DCN host on the same net, the PID\n    of the link output process\
    \ does not match the \"Port ID\" field and the\n    calculated delay is less than\
    \ the \"Host Delay\" field by at least a\n    specified switching threshold (currently\
    \ 100 milliseconds), then\n    update the entry. \n3.  If the link connects to\
    \ a foreign net and is assigned a host ID\n    corresponding to the entry, then\
    \ update the entry.  In this case\n    only, use as the calculated delay the roundtrip\
    \ delay.\n4.  If none of the above conditions are met, or if the virtual host\n\
    \    has been declared down and the \"TTL\" field contains a nonzero\n    value,\
    \ then no update is performed.\n     The update process consists of replacing\
    \ the \"Delay\" field with\nthe calculated delay, the \"Port ID\" field with the\
    \ PID of the link\noutput process, the \"Update Timestamp\" field with the current\
    \ time of\nday and the \"TTL\" field by a specified value (currently 120) in\n\
    seconds.  If the calculated delay exceeds a specified maximum interval\n(currently\
    \ 30 seconds), the virtual host is declared down by setting\nthe corresponding\
    \ \"Delay\" field to the maximum and the remaining\nfields as before.  For the\
    \ purposes of delay calculations values less\nthan a specified minimum (currently\
    \ 100 milliseconds) are rounded up\nto that minimum.\n     The \"Offset\" field\
    \ is also replaced during the update process.\nWhen the HELLO message arrives,\
    \ The value of the current logical clock\nis subtracted from the \"Time\" field\
    \ and the difference added to\none-half the roundtrip delay.  The resulting sum,\
    \ which represents the\noffset of the local clock to the clock of the sender,\
    \ is added to the\ncorresponding \"Offset\" field of the HELLO message and the\
    \ sum replaces\nthe \"Offset\" field of the Host Table.  Thus, the \"Offset\"\
    \ field in the\nHost Table for a particular virtual host is replaced only if that\
    \ host\nis up and on the minimum-delay path to the DCN host.\n     The purpose\
    \ of the switching threshold in (2) above and the\nminimum delay specification\
    \ in the update process is to avoid\nunnecessary switching between links and transient\
    \ loops which can\n     In addition to the updates performed as HELLO messages\
    \ arrive, each\nvirtual host in a DCN host also performs a periodic update of\
    \ its own\nHost Table entry.  The update procedure is identical to the above,\n\
    except that the calculated delay and offset are taken as zero.  At\nleast one\
    \ of the virtual hosts in a DCN host must have the same host\nID as the host number\
    \ assigned the DCN host itself and all must be\nassigned the same net number.\
    \  Other than these, there are no\nrestrictions on the number or addresses of\
    \ internet processes resident\nin a single DCN host.\n     It should be appreciated\
    \ that virtual hosts are truly portable\nand can migrate about the net, should\
    \ such a requirement arise.  The\nhost update protocols described here insure\
    \ that the routing\nprocedures always converge to the minimum-delay paths via\
    \ operational\nlinks and DCN hosts.  In the case of broadcast nets such as Ethernets,\n\
    the procedures are modified slightly as described below.  In this case\nthe HELLO\
    \ messages are used to determine routing from the various\nEthernet hosts to destinations\
    \ off the cable, as well as to provide\ntime synchronization.\n2.4.  Timeouts\n\
    \     The \"TTL\" field in every Host Table entry is decremented once a\nsecond\
    \ in normal operation.  Thus, if following a host update another\nupdate is not\
    \ received within an interval corresponding to the value\ninitialized in that\
    \ field, it decrements to zero, at which point the\nvirtual host is declared down\
    \ and the Host Table entry set as\ndescribed above.  The 120-second interval used\
    \ currently provides for\nat least four HELLO messages to be generated by every\
    \ neighbor on\nevery link during that interval, since the maximum delay between\
    \ HELLO\nmessages is 30 seconds on the lowest-speed link (1200 bps).  Thus, if\n\
    no HELLO messages are lost, the maximum number of links between any\nvirtual host\
    \ and any other is four.\n     The \"TTL\" field is initialized at 120 seconds\
    \ when an update\noccurs and when the virtual host is declared down.  During the\n\
    interval this field decrements to zero immediately after being\ndeclared down,\
    \ updates are ignored.  This provides a decent interval\nfor the bad news to propagate\
    \ throughout the net and for the Host\nTables in all DCN hosts to reflect the\
    \ fact.  Thus, the formation of\nrouting loops is prevented.\n     The IP datagram\
    \ forwarding procedures call for decrementing the\n\"time-to-live\" field in the\
    \ IP header once per second or at each point\nwhere it is forwarded, whichever\
    \ comes first.  The value used\ncurrently for this purpose is 30, so that an IP\
    \ datagram can live in\nthe net no longer than that number of seconds.  This is\
    \ thus the\nmaximum delay allowed on any path between two virtual hosts.  If this\n\
    maximum delay is exceeded in calculating the roundtrip delay for a\n     The interval\
    \ between HELLO messages on any link depends on the\ndata rate supported by the\
    \ link.  As a general rule, this interval is\nset at 16 times the expected roundtrip\
    \ time for the longest packet to\nbe sent on that link.  For 1200-bps asynchronous\
    \ transmission and\npacket lengths to 256 octets, this corresponds to a maximum\
    \ HELLO\nmessage interval of about 30 seconds. \n     Although the roundtrip delay\
    \ calculation, upon which the routing\nprocess depends, is relatively insensitive\
    \ to net traffic and\ncongestion, stochastic variations in the calculated values\
    \ ordinarily\noccur due to coding (bit or character stuffing) and medium\nperturbations.\
    \  In order to suppress loops and needless path changes a\nminimum switching threshold\
    \ is incorporated into the routing mechanism\n(see above).  The interval used\
    \ for this threshold, as well as for the\nminimum delay on any path, is 100 milliseconds.\n\
    3.  Formal Specification\n     The following sections provide a formal framework\
    \ which describe\nthe DCN HELLO protocol.  This protocol is run between neighboring\
    \ DCN\nhosts that share a common point-to-point link and provides automatic\n\
    connectivity determination, routing and timekeeping functions.\n     The descriptions\
    \ to follow are organized as follows: First a\nsummary of data structures describes\
    \ the global variables and packet\nformats.  Then three processes which implement\
    \ the protocol are\ndescribed: the CLOCK, HELLO and HOST processes.  The description\
    \ of\nthese processes is organized into sections that describe (1) the local\n\
    variables used by that process, (2) the parameters and constants and\n(3) the\
    \ events that initiate processing together with the procedures\nthey evoke.  In\
    \ the case of variables a distinction is made between\nstate variables, which\
    \ retain their contents between procedure calls,\nand temporaries, which have\
    \ a lifetime extending only while the\nprocess is running.  Except as noted below,\
    \ the initial contents of\nstate variables are unimportant.\n3.1.  Data Structures\n\
    3.1.1.  Global Variables\nADDRESS\n    This is a 32-bit bit-string temporary variable\
    \ used to contain an\n    Internet address.\nCLOCK-HID\n    This is an eight-bit\
    \ integer state variable used to contain the\n    host ID of the local-net host\
    \ to be used as the master clock.  It\n    is initialized to the appropriate value\
    \ depending upon the net\n    configuration. \nDATE\n    bits 10-14 contain the\
    \ month, starting with one for January.\nDATE-VALID\n    This is a one-bit state\
    \ variable used to indicate whether the\n    local date and time are synchronized\
    \ with the master clock.  A\n    value of one indicates the local clock is not\
    \ synchronized with\n    the master clock.  This variable is set to one initially\
    \ and when\n    the local time-of-day rolls over past midnight.  It is set to\
    \ zero\n    each time a valid date and time update has been received from the\n\
    \    master clock. \nDELAY\n    This is a 16-bit integer temporary variable which\
    \ represents the\n    roundtrip delay in milliseconds to a host.\nHID\n    This\
    \ is an eight-bit integer temporary variable containing the\n    host ID of some\
    \ host on the local net.\n    There is a one-to-one correspondence between the\
    \ Internet\n    addresses of local hosts and their HIDs.  The mapping between\
    \ them\n    is selected on the basis of the octet number of the Internet\n   \
    \ address.  For DCN hosts it is the fourth octet, while for hosts\n    directly\
    \ connected to a class-A ARPANET IMP or gateway, it is the\n    third octet (logical-host\
    \ field).  The contents of this octet are\n    to be added to ADDRESS-OFFSET to\
    \ form the HID associated \n    with the address.\nHOLD\n    This is an eight-bit\
    \ counter state variable indicating whether\n    timestamps are valid or not.\
    \  While HOLD is nonzero, timestamps\n    should be considered invalid.  When\
    \ set to some nonzero value, the\n    counter decrements to zero at a 1-Hz rate.\
    \  Its initial value is\n    zero. \nHOST-TABLE\n    This is a table of NHOSTS\
    \ entries indexed by host ID (HID).  There\n    is one entry for each host in\
    \ the local net.  Each entry has the\n    following format:\n    HOST-TABLE.DELAY\n\
    \        This is a 16-bit field containing the computed roundtrip delay\n    \
    \    in milliseconds to host HID.\n    HOST-TABLE.OFFSET\n        This is a 16-bit\
    \ field containing the computed signed offset\n        in milliseconds which must\
    \ be added to the local apparent\n        clock to agree with the apparent clock\
    \ of host HID.\n    HOST-TABLE.PID\n        This is an eight-bit field containing\
    \ the PID of the net-output\n HOST-TABLE.TTL\n     This is an eight-bit field\
    \ used as a time-to-live indicator.\n     It is decremented by the HOST process\
    \ once each second and\n     initialized to a chosen value when a HELLO message\
    \ is\n     received. The table is initialized with the HOST-TABLE.DELAY\n    \
    \ field set to  MAXDELAY for all entries.  The contents of the\n     other fields\
    \ are unimportant. \nLOCAL-ADDRESS\n    This is a 32-bit bit-string state variable\
    \ used to contain the \n    local host Internet address.\nNET-TABLE\n    This\
    \ is a table of NNETS entries with the following format:\n    NET-TABLE.HID\n\
    \        This is an eight-bit field containing the host ID of the\n        pseudo-process\
    \ to forward packets to the NET-TABLE.NET net.\n    NET-TABLE.NET\n        This\
    \ is a 24-bit field containing an Internet class-A (eight\n        bits), class-B\
    \ (16 bits) or class-C (24 bits) net number.\n        Note that the actual field\
    \ width for class-B net numbers is 24\n        bits in order to provide a subnet\
    \ capability, in which the\n        high-order eight bits of the 16-bit host address\
    \ is\n        interpreted as the subnet number. \n    The table is constructed\
    \ at configuration time and must include an\n    entry for every net that is a\
    \ potential neighbor.  A neighbor net\n    is defined as a net containing a host\
    \ that can be directly\n    connected to a host on the local net.  The entry for\
    \ such a net is\n    initialized with NET-TABLE.NET set to the neighbor net number\
    \ and\n    NET-TABLE.HID set to an arbitrary vitual-host ID not assigned any\n\
    \    other local-net virtual host. \n    The remaining entries in NET-TABLE are\
    \ initialized at initial-boot\n    time with the NET-TABLE.NET fields set to zero\
    \ and the\n    NET-TABLE.HID fields set to a configuration-selected host ID to\
    \ be\n    used to forward packets to all nets other than neighbor nets.  In\n\
    \    the case where a gateway module is included in the local host\n    configuration,\
    \ the GGP and/or EGP protocols will be used to\n    maintain these entries;  while,\
    \ in the case where no gateway\n    module is included, only one such entry is\
    \ required. \nOFFSET\n    This is a 16-bit signed integer temporary variable which\n\
    \    represents the offset in milliseconds to be added to the apparent\n    clock\
    \ time to yield the apparent clock time of the neighbor host. \n3.1.2.  Parameters\n\
    NHOSTS\n    This is an integer which defines the number of entries in HOST-TABLE.\n\
    NNETS\n    This is an integer which defines the number of entries in MET-TABLE.\n\
    3.1.3.  HELLO Packet Fields\nPKT.ADDRESS-OFFSET\n    This eight-bit is copied\
    \ from ADDRESS-OFFSET by the sender.\nPKT.DATESTAMP\n    Bits 0-14 of this 16-bit\
    \ field are copied from DATE by the sender, \n    while bit 15 is copied from\
    \ DATE-VALID.\nPKT.DATE-VALID\n    This one-bit field is bit 15 of PKT.DATESTAMP.\n\
    PKT.DESTINATION\n    This 32-bit field is part of the IP header.  It is copied\
    \ from\n    HLO.NEIGHBOR-ADDRESS by the sender.\nPKT.HOST-TABLE\n    This is a\
    \ table of PKT.NHOSTS entries, each entry of which\n    consists of two fields.\
    \  The entries are indexed by host ID and\n    have the following format: \n \
    \   PKT.HOST-TABLE.DELAY\n        This 16-bit field is copied from the corresponding\
    \ HOST-TABLE.DELAY\n        field by the sender.\n    PKT.HOST-TABLE.OFFSET\n\
    \        This 16-bit field is copied from the corresponding HOST-TABLE.OFFSET\n\
    \        field by the sender.\nPKT.LENGTH\n    This 16-bit field is part of the\
    \ IP header.  It is set by the sender to\n    the number of octets in the packet.\n\
    PKT.NHOSTS\n    This eight-bit field is copied from NHOST by the sender.\nPKT.SOURCE\n\
    \    This 16-bit field is part of the IP header.  It is copied from\n    LOCAL-ADDRESS\
    \ by the sender.\nPKT.TIMESTAMP\nPKT.TSP\n    This 16-bit field contains a variable\
    \ used in roundtrip delay\n    calculations.\n3.2 CLOCK Process (CLK)\n     The\
    \ timekeeping system maintains three clocks: (1) the physical\nclock, which is\
    \ determined by a hardware oscillator/counter; (2) the\napparent clock, which\
    \ maintains the time-of-day used by client\nprocesses and (3) the actual clock,\
    \ which represents the time-of-day\nprovided by an outside reference.  The apparent\
    \ and actual clocks are\nmaintained as 48-bit quantities with 32 bits of significance\
    \ available\nto client processes.  These clocks run at a rate of 1000 Hz and are\n\
    reset at midnight UT.\n     The CLOCK process consists of a set of state variables\
    \ along with\na set of procedures that are called as the result of hardware\n\
    interrupts and client requests.  An interval timer is assumed\nlogically separate\
    \ from the local clock mechanism, although both could\nbe derived from the same\
    \ timing source.\n3.2.1.  Local Variables\nCLK.CLOCK\n    This is a 48-bit fixed-point\
    \ state variable used to represent the\n    apparent time-of-day.  The decimal\
    \ point is to the right of bit 16\n    (numbering from the right at bit 0).  Bit\
    \ 16 increments at a rate\n    equivalent to 1000 Hz independent of the hardware\
    \ clock.  (In the\n    case of programmable-clock hardware the value of CLK.CLOCK\
    \ must be\n    corrected as described below.) \nCLK.COUNT\n    This is a hardware\
    \ register that increments at rate R.  It can be\n    represented by a simple\
    \ line clock, which causes interrupts at the\n    line-frequency rate, or by a\
    \ programmable clock, which contains a 16-bit\n    register that is programmed\
    \ to count at a 1000-Hz rate and causes an\n    interrupt on overflow.  The register\
    \ is considered a fixed-point variable\n    with decimal point to the right of\
    \ bit 0.\nCLK.DELTA\n    This is a 48-bit signed fixed-point state variable used\
    \ to represent the\n    increment to be added to CLK.CLOCK to yield the actual\
    \ time-of-day.  The\n    decimal point is to the right of bit 16.\n3.2.3.  Parameters\n\
    ADJUST-FRACTION\n    This is an integer which defines the shift count used to\
    \ compute a\nADJUST-INTERVAL\n    This is an integer which defines the clock-adjust\
    \ interval in\n    milliseconds.  A value of 500 (one-half second) is suggested\
    \ for\n    the line clock and 4000 (four seconds) for the 1000-Hz clock.\nCLOCK-TICK\n\
    \    This is a fixed-point integer which defines the increment in\n    milliseconds\
    \ to be added to CLK.CLOCK as the result of a clock\n    tick.  The decimal point\
    \ is to the right of bit 16.  In the case\n    of a line-clock interrupt, the\
    \ value of CLOCK-TICK should be\n    16.66666 (60 Hz) or 20.00000 (50 Hz).  In\
    \ the case of a 1000-Hz\n    programmable-clock overflow, the value should be\
    \ 65536.00000.\nHOLD-INTERVAL\n    This is an integer which defines the number\
    \ of seconds that HOLD will\n    count down after CLK.CLOCK has been reset.  The\
    \ resulting interval must be\n    at least as long as the maximum HELLO-INTERVAL\
    \ used by any HELLO process.\n3.2.3.  Events and Procedures\nINCREMENT-CLOCK Event\n\
    \    This event is evoked as the result of a tick interrupt, in the case of a\n\
    \    line clock, or a counter overflow, in the case of the 1000-Hz clock.  It\n\
    \    causes the logical clock to be incremented by the value of CLOCK-TICK.\n\
    \    1.  Add the value of CLOCK-TICK to CLK.CLOCK.\nADJUST-CLOCK Event\n    This\
    \ event is evoked once every ADJUST-INTERVAL milliseconds to slew the\n    apparent\
    \ clock time to the actual clock time as set by the SET-CLOCK\n    procedure.\
    \  This is done by subtracting a fraction of the correction\n    factor CLK.DELTA\
    \ from the value of CLK.DELTA and adding the same fraction\n    to CLK.CLOCK.\
    \  This continues until either the next SET-CLOCK call or\n    CLK.DELTA has been\
    \ reduced to zero.\n    The suggested values for ADJUST-INTERVAL and ADJUST-FRACTION\n\
    \    represent a maximum slew rate of less than +-2 milliseconds per\n    second,\
    \ in the case of 1000-Hz clock.  The action is to smooth\n    noisy clock corrections\
    \ received from neighboring systems to\n    obtain a high-quality local reference,\
    \ while insuring the apparent\n    clock time is always monotonically increasing.\
    \ \n    1.  Shift the 48-bit value of CLK.DELTA arithmetically ADJUST-FRACTION\n\
    \        bits to the right, discarding bits from the right and saving the\n  \
    \      result in a temporary variable F.  Assuming the decimal point of F to\n\
    DECREMENT-HOLD Event\n    This event is evoked once per second to decrement the\
    \ value of HOLD.\n    1.  If the value of HOLD is zero, do nothing;  otherwise,\
    \ decrement its\n        value.\nREAD-CLOCK Procedure\n    This procedure is called\
    \ by a client process.  It returns the apparent\n    time-of-day computed as the\
    \ integer part of the sum CLK.CLOCK plus\n    CLK.COUNT.  Note that the precision\
    \ of the value returned is limited to\n    +-1 millisecond, so that client processes\
    \ must expect the apparent\n    time to \"run backward\" occasionally due to drift\
    \ corrections.  When\n    this happens the backward step will never be greater\
    \ than one\n    millisecond and will never occur more often than twice per second.\n\
    \    1.  In the case of line clocks CLK.COUNT is always zero, while in\n     \
    \   the case of programmable clocks the hardware must be\n        interrogated\
    \ to extract the value of CLK.COUNT.  If following\n        interrogation a counter-overflow\
    \ condition is evident, add\n        CLOCK-TICK to CLK.CLOCK and interrogate the\
    \ hardware again.\n    2.  When the value of CLK.COUNT has been determined compute\
    \ the sum\n        CLK.COUNT + CLK.CLOCK.  If this sum exceeds the number of\n\
    \        milliseconds in 24 hours (86,400,000), reduce CLK.CLOCK by\n        86,400,000,\
    \ set HOLD-INTERVAL -> HOLD, set CLOCK-VALID (bit 15\n        of DATE) to one,\
    \ roll over DATE to the next calendar day and\n        start over.  If not, return\
    \ the integer part of the sum as the\n        apparent time-of-day. \n       \
    \ The CLOCK-VALID bit is set to insure that a master-clock update is\n       \
    \ received at least once per day.  Note that, in the case of\n        uncompensated\
    \ crystal oscillators of the type commonly used as the\n        1000-Hz time base,\
    \ a drift of several parts per million can be\n        expected, which would result\
    \ in a time drift of several tenths of a\n        second per day, if not corrected.\n\
    SET-CLOCK Procedure\n    This procedure is called by a client process.  It sets\
    \ a time-of-day\n    correction factor in milliseconds.  The argument represents\
    \ a 32-bit\n    signed fixed-point quantity with decimal point to the right of\
    \ bit\n    0 that is to be added to CLK.CLOCK so that READ-CLOCK subsequently\n\
    \    returns the actual time-of-day.  \n    1.  If the correction factor is in\
    \ the range -2**(16-ADJUST-FRACTION) to\n        +2**(16-ADJUST-FRACTION) - 1\
    \ (about +-128 milliseconds with the\n        suggested value of ADJUST-FRACTION),\
    \ the value of the argument\n        replaces CLK.DELTA and the procedure is complete.\
    \  If not, add the\n        value of the sign-extended argument to CLK.CLOCK and\
    \ set CLK.DELTA to\n        zero.  In addition, set HOLD-INTERVAL -> HOLD, since\
    \ this\n        represents a relatively large step-change in apparent time.\n\
    \        The value of HOLD represents the remaining number of seconds\n3.3.  HELLO\
    \ Process\n     The HELLO process maintains clock synchronization with a neighbor\n\
    HELLO process using the HELLO protocol.  It also participates in the\nrouting\
    \ algorithm.  There is one HELLO process and one set of local\nstate variables\
    \ for each link connecting the host to one of its\nneighbors.\n3.3.1.  Local variables\n\
    HLO.BROADCAST\n    This is a one-bit switch state variable.  When set to zero\
    \ a\n    point-to-point link is assumed.  When set to one a broadcast (e.g.\n\
    \    Ethernet) link is assumed.\nHLO.KEEP-ALIVE\n    This is an eight-bit counter\
    \ state variable used to indicate whether the\n    link is up.  It is initialized\
    \ with a value of zero.\nHLO.LENGTH\n    This is a 16-bit integer state variable\
    \ used to record the length in\n    octets of the last HELLO message sent.\nHLO.NEIGHBOR-ADDRESS\n\
    \    This is a 32-bit integer state variable used to contain the neighbor host\n\
    \    Internet address.\nHLO.PID\n    This is an eight-bit integer state variable\
    \ used to identify the\n    net-output process associated with this HELLO process.\
    \  It is initialized\n    by the kernel when the process is created and remains\
    \ unchanged\n    thereafter.\nHLO.POLL\n    This is a one-bit switch state variable.\
    \  When set the HELLO process\n    spontaneously sends HELLO messages.  When not\
    \ set the HELLO process\n    responds to HELLO messages, but does not send them\
    \ spontaneously.\nHLO.TIMESTAMP\n    This is a 32-bit integer temporary variable\
    \ used to record the time of\n    arrival of a HELLO message.\nHLO.TSP\n3.3.2.\
    \  Parameters\nHELLO-INTERVAL\n    This is an integer which defines the interval\
    \ in seconds between HELLO\n    messages.  It ranges from about eight to a maximum\
    \ of 30 seconds,\n    depending on line speed.\nHOLD-DOWN-INTERVAL\n    This is\
    \ an integer which defines the interval in seconds a host will be\n    considered\
    \ up following receipt of a HELLO message indicating that\n    host is up.  A\
    \ value of 120 is suggested.\nKEEP-ALIVE-INTERVAL\n    This is an integer which\
    \ defines the interval, in units of\n    HELLO-INTERVAL, that a HELLO process\
    \ will consider the link up.  A\n    value of four is suggested.\nMAXDELAY\n \
    \   This is an integer which defines the maximum roundtrip delay in\n    seconds\
    \ on a path to any reachable host.  A value of 30 is suggested.\nMINDELAY\n  \
    \  This is an integer which defines the minimum switching threshold in\n    milliseconds\
    \ below which routes will not be changed.  A value of 100 is\n    suggested.\n\
    3.3.3.  Events and Procedures\nINPUT-PACKET Event\n    When a packet arrives the\
    \ net-input process first sets HLO.TIMESTAMP to\n    the value returned by the\
    \ READ-CLOCK procedure, then checks the\n    packet for valid local leader, IP\
    \ header format and checksum.  If\n    the protocol field in the IP header indicates\
    \ a HELLO message, the\n    packet is passed to the HELLO process.  If any errors\
    \ are found\n    the packet is dropped. \n    The HELLO process first checks the\
    \ packet for valid HELLO header format\n    and checksum.  If any errors are found\
    \ the packet is dropped.  Otherwise,\n    it proceeds as follows:\n    1.  If\
    \ PKT.SOURCE is equal to LOCAL-ADDRESS, then the line to the\n        neighbor\
    \ host is looped.  If this is a broadcast link\n        (HLO.BROADCAST is set\
    \ to one), then ignore this nicety;  if\n        not, this is considered an error\
    \ and further processing is\n        abandoned.  Note that, in special configurations\
    \ involving\n        other systems (e.g.  ARPANET IMPs and gateways) it may be\n\
    \        useful to use looped HELLO to monitor connectivity.  The DCN\n      \
    \  implementation provides this feature, but is not described here.\n    2.  Set\
    \ KEEP-ALIVE-INTERVAL -> HLO.KEEP-ALIVE.  This indicates the\n    3.  Set PKT.TIMESTAMP\
    \ - HLO.TIMESTAMP -> HLO.TSP.  This is part of the\n        roundtrip delay calculation.\
    \  The value of HLO.TSP will be\n        updated and returned to the neighbor\
    \ in the next HELLO message\n        transmitted.  Next, compute the raw roundtrip\
    \ delay and offset:\n        HLO.TIMESTAMP - PKT.TSP -> DELAY and HLO.TSP + DELAY/2\
    \ -> OFFSET. \n        Note:  in the case of a broadcast link (HLO.BROADCAST set\
    \ to one) set\n        DELAY to zero.\n    4.  Perform this step only in the case\
    \ of non-broadcast links\n        (HLO.BROADCAST set to zero).  If PKT.SOURCE\
    \ is not equal to\n        HLO.NEIGHBOR-ADDRESS, then a new neighbor has appeared\
    \ on this\n        link. Set PKT.SOURCE -> HLO.NEIGHBOR ADDRESS, MAXDELAY ->\n\
    \        DELAY and proceed to the next step.  This will force the line\n     \
    \   to be declared down and result in a hold-down cycle.\n        Otherwise, if\
    \ either PKT.TSP is zero or HOLD is nonzero, then\n        the DELAY calculation\
    \ is invalid and further processing is\n        abandoned.  Note that a hold-down\
    \ cycle is forced in any \n        case if a new neighbor is recognized.\n   \
    \ 5.  If processing reaches this point the DELAY and OFFSET\n        variables\
    \ can be assumed valid as well as the remaining data\n        in the packet. \
    \ First, if DELAY < MINDELAY, set MINDELAY ->\n        DELAY.  This avoids needless\
    \ path switching when the\n        difference in delays is not significant and\
    \ has the effect\n        that on low-delay links the routing algorithm degenerates\
    \ to \n        min-hop rather than min-delay.  Then set HLO.PID -> PID.  There\
    \ are\n        two cases:\n        Case 1:  PKT.NHOSTS is zero.\n            This\
    \ will be the case when the neighbor host has just come up or\n            is\
    \ on a different net or subnet.  Set NEIGHBOR-ADDRESS -> ADDRESS\n           \
    \ and call the ROUTE procedure, which will return the host\n            ID.  Then\
    \ call the UPDATE procedure.  In the case of\n            errors, do nothing but\
    \ return.\n        Case 2:  PKT.NHOSTS is nonzero.\n            This is the case\
    \ when the neighbor host is on the same net or\n            subnet.  First, save\
    \ the values of DELAY and OFFSET in temporary\n            variables F and G.\
    \  Then, for each value of HID from zero to\n            NHOSTS-1 consider the\
    \ corresponding PKT.HOSTS-TABLE entry and do\n            the following:  Set\
    \ F + PKT.HOST-TABLE.DELAY -> DELAY and\n            G + PKT.HOST-TABLE.OFFSET\
    \ -> OFFSET and call the UPDATE procedure.\n            This completes processing.\n\
    \        ROUTE Procedure\n            This procedure returns the host ID in HID\
    \ of the host represented\n            by the global variable ADDRESS.\n    1.\
    \  First, determine if the host represented by ADDRESS is on the same\n      \
    \  local net as LOCAL-ADDRESS.  For the purposes of this\n        comparison bits\
    \ 0-7 and 16-31 are compared for class-A nets\n        Case 1:  The host is on\
    \ the same net or subnet.\n            Extract the address field of ADDRESS, subtract\
    \ ADDRESS-OFFSET and\n            store the result in HID.  If 0 <= HID < NHOSTS,\
    \ the procedure\n            completes normally;  otherwise it terminates in an\
    \ error\n            condition.\n        Case 2:  The host is not on the same\
    \ net or subnet.\n            Search the NET-TABLE for a match of the net fields\
    \ of\n            LOCAL-ADDRESS and NET-TABLE.NET.  If found set\n           \
    \ NET-TABLE.HID -> HID and return normally.  If the NET-TABLE.NET\n          \
    \  field is zero, indicating the last entry in the table, set\n            HET-TABLE.HID\
    \ -> HID and return normally.  Note that, in the case\n            of hosts including\
    \ GGP/EGP gateway modules, if no match is found\n            the procedure terminates\
    \ in an error condition.\nUPDATE Procedure\n    This procedure updates the entry\
    \ of HOST-TABLE indicated by HID using\n    three global variables:  DELAY, OFFSET\
    \ and PID.  Its purpose is to update\n    the HOST-TABLE entry corresponding to\
    \ host ID HID.  In the following all\n    references are to this entry.\n    1.\
    \  If PID is not equal to HOST-TABLE.PID, the route to host HID is not\n     \
    \   via the net-output process associated with this HELLO process.  In\n     \
    \   this case, if DELAY + MINDELAY > HOST-TABLE.DELAY, the path is longer\n  \
    \      than one already in HOST-TABLE, so the procedure does nothing.\n    2.\
    \  This step is reached only if either the route to host HID is via the\n    \
    \    net-output process associated with this HELLO process or the newly\n    \
    \    reported path to this host is shorter by at least MINDELAY.  \n        There\
    \ are two cases:\n        Case 1:  HOST-TABLE.DELAY < MAXDELAY.\n            The\
    \ existing path to host HID is up and this is a point-to-point\n            link\
    \ (HLO.BROADCAST is set to zero).  If DELAY < MAXDELAY the\n            newly\
    \ reported path is also up.  Proceed to the next step.\n            Otherwise,\
    \ initiate a hold-down cycle by setting\n            MAXDELAY -> HOST-TABLE.DELAY\
    \ and\n            HOLD-DOWN-INTERVAL -> HOST-TABLE.TTL and return.\n        Case\
    \ 2:  HOST-TABLE.DELAY >= MAXDELAY.\n            The existing path to host HID\
    \ is down.  If DELAY < MAXDELAY and\n            HOST-TABLE.TTL is zero, the hold-down\
    \ period has expired and the\n            newly reported path has just come up.\
    \  Proceed to the next step.\n            Otherwise simply return.\n    3.  In\
    \ this step the HOST-DELAY entry is updated.  Set\n    4.  For precise timekeeping,\
    \ the offset can be considered valid only if\n        the length of the last HELLO\
    \ packet transmitted is equal to\n        the length of the last one received.\
    \  Thus, if HLO.LENGTH\n        equal to PKT.LENGTH, set OFFSET -> HOST-TABLE.OFFSET;\n\
    \        otherwise, leave this field alone. Finally, if HID is equal to\n    \
    \    CLOCK-HID and bit 15 (the DATE-VALID bit) \n        of DATE is zero, set\
    \ PKT.DATESTAMP -> DATE and call the SET-CLOCK\n        procedure of the CLOCK\
    \ process with argument HLO.TIMESTAMP.\nOUTPUT-PACKET Event\n    This event is\
    \ evoked once every HELLO-INTERVAL seconds.  It determines if\n    a HELLO message\
    \ is to be transmitted, transmits it and updates state\n    variables.\n    1.\
    \  If HLO.KEEP-ALIVE is nonzero decrement its value.\n    2.  If HLO.POLL is zero\
    \ and HLO.KEEP-ALIVE is zero, do not send a HELLO\n        message.  If either\
    \ is nonzero initialize the packet fields as\n        follows:  LOCAL-ADDRESS\
    \ -> PKT.SOURCE,\n        HLO.NEIGHBOR-ADDRESS -> PKT.DESTINATION and DATE ->\
    \ PKT.DATESTAMP.\n        Note:  PKT.DESTINATION is set to zero if this is a broadcast\
    \ link\n        (HLO.BROADCAST set to one).  Also, note that bit 15 of DATE is\
    \ the\n        DATE-VALID bit.  If this bit is one the receiver will not update\
    \ its\n        master clock from the information in the transmitted packet.\n\
    \        This is significant only if the sending host is on the\n        least-delay\
    \ path to the master clock.  Set PKT.TIMESTAMP to\n        the value returned\
    \ from the READ-CLOCK procedure.  If\n        HLO.KEEP-ALIVE is zero or HOLD is\
    \ nonzero, set PKT.TSP to\n        zero;  otherwise, set PKT.TIMESTAMP + HLO.TSP\
    \ -> PKT.TSP.\n    3.  Determine if the neighbor is on the same net or subnet.\
    \  If the\n        neighbor is on a different net set PKT.NHOSTS to zero and\n\
    \        proceed with the next step.  Otherwise, set NHOSTS ->\n        PKT.NHOSTS\
    \ and for each value of HID from zero to PKT.HOSTS-1\n        copy the HOST-TABLE.DELAY\
    \ and HOST-TABLE.OFFSET fields of the\n        corresponding HOST-TABLE entry\
    \ in order into the packet.  For\n        each entry copied test if the HOST-TABLE.PID\
    \ field matches the\n        HLO.PID of the HELLO process.  If so, a potential\
    \ routing loop\n        is possible.  In this case use MAXDELAY for the delay\
    \ field in\n        the packet instead. \n    4.  Finally, set HLO.LENGTH to the\
    \ number of octets in the packet \n        and send the packet.\n3.4.  HOST Process\
    \ (HOS)\n     This process maintains the routing tables.  It is activated once\
    \ per\n3.4.1.  Local variables\nHOS.PID\n    This is an eight-bit integer used\
    \ to identify the HOST process.  It is\n    initialized by the kernel when the\
    \ process is created and remains\n    unchanged thereafter.\nHOS.HID\n    This\
    \ is an eight-bit temporary variable.\n3.4.2.  Events and Procedures\nSCAN Event\n\
    \    This event is evoked once each second to scan the HOST-TABLE and perform\n\
    \    housekeeping functions.\n    1.  For each value of a temporary variable F\
    \ from zero to NHOSTS-1 do the\n        following:  Set LOCAL-ADDRESS -> ADDRESS\
    \ and call the ROUTE\n        procedure, which will return the host ID HID.  If\
    \ F is equal\n        to HID, then set both DELAY and OFFSET to zero, HOS.PID\
    \ -> PID\n        and call the UPDATE procedure.  This will cause all packets\n\
    \        received with the local address to be routed to this process.\n     \
    \   If HOST-TABLE.TTL is zero skip this step.  Otherwise, decrement\n        HOST-TABLE.TTL\
    \ by one.  If the result is nonzero skip the\n        remainder of this step.\
    \  Otherwise, If HOST-TABLE.DELAY <MAXDELAY set\n        HOLDOFF-INTERVAL -> HOST-TABLE.TTL\
    \ and MAXDELAY -> HOST-TABLE.DELAY.\n        The effect of this step is to declare\
    \ a hold-down cycle when a host\n        goes down.\n4.  References\nAppendix\
    \ A.  Link-Level Packet Formats\nA.1.  Serial Links Using Program-Interrupt Interfaces\n\
    \     Following is a description of the frame format used on\nasynchronous and\
    \ synchronous serial links with program-interrupt\ninterfaces such as the DEC\
    \ DLV11 and DPV11.  This format provides\ntransparency coding for all messages,\
    \ including HELLO messages, but\ndoes not provide error detection or retransmission\
    \ functions.  It is\ndesigned to be easily implemented and compatible as far as\
    \ possible\nwith standard industry protocols.\n     The protocol is serial-by-bit,\
    \ with the same interpretation on\nthe order of transmission as standard asynchronous\
    \ and synchronous\ninterface devices; that is, the low-order bit of each octet\
    \ is\ntransmitted first.  The data portion of the frame consists of one\nInternet\
    \ datagram encoded according to a \"character-stuffing\"\ntransparency convention:\n\
    1.  The frame begins with the two-octet sequence DLE-STX, in the case of\n   \
    \ asynchronous links, or the four-octet sequence SYN-SYN-DLE-STX, in the\n   \
    \ case of synchronous links.  The data portion is transmitted next,\n    encoded\
    \ as described below, followed by the two-octet sequence\n    DLE-ETX.  No checksum\
    \ is transmitted or expected.  If it is\n    necessary for any reason to transmit\
    \ time-fill other than in the\n    data portion, the DEL (all ones) is used.\n\
    2.  Within the data portion of the frame the transmit buffer is\n    scanned for\
    \ a DLE.  Each DLE found causes the sequence DLE-DLE to\n    be transmitted. \
    \ If it is necessary for some reason for the\n    transmitter to insert time-fill\
    \ within the data portion, the\n    sequence DLE-DEL is used. \n3.  While scanning\
    \ the data stream within the data portion of the\n    frame the sequence DLE-DLE\
    \ is found, a single DLE is inserted in\n    the receive buffer.  If the sequence\
    \ DLE-ETX is found, the buffer\n    is passed on for processing. The sequence\
    \ DLE-DEL is discarded.\n    Any other two-octet sequence beginning with DLE and\
    \ ending with\n    other than DLE, ETX or DEL is considered a protocol error \n\
    \    (see note below). \n     Note: In the case of synchronous links using program-interrupt\n\
    interfaces such as the DPV11, for example, a slightly modified\nprotocol is suggested\
    \ when both ends of the link concur.  These\ninterfaces typically provide a parameter\
    \ register which can be loaded\nwith a code used both to detect the receiver synchronizing\
    \ pattern and\nfor time-fill when the transmit buffer register cannot be serviced\
    \ in\ntime for the next character.\n     The parameter register must be loaded\
    \ with the SYN code for this\nprotocol to work properly.  However, should it be\
    \ necessary to\n1.  If the transmitter senses a time-fill condition (usually by\
    \ a\n    control bit assigned for this purpose) between frames or\n    immediately\
    \ following transmission of a DLE, the condition is ignored.\n2.  If the transmitter\
    \ senses a time-fill condition at other times it sends\n    the sequence DLE-CAN.\n\
    3.  If the receiver finds a SYN either between frames or immediately\n    following\
    \ DLE, the SYN is discarded without affecting sequence\n    decoding. \n4.  If\
    \ the receiver finds the sequence DLE-CAN in the data portion, it\n    discards\
    \ the sequence and the immediately preceding octet.\n     These rules will work\
    \ in cases where a single SYN has been\ninserted by the transmitter and even when\
    \ a SYN has been inserted in\nthe DLE-CAN sequence.  If an overrun (lost data)\
    \ condition is sensed\nat the receiver, the appropriate action is to return to\
    \ the\ninitial-synchronization state.  This should also be the action if any\n\
    code other than STX is found following the initial DLE.  or if any\ncode other\
    \ than DLE, ETX, DEL or CAN is found following a DLE in the\ndata portion.\nA.2.\
    \  Serial Links Using DDCMP Devices\n     Following is a description of the frame\
    \ format used on DEC DDCMP links\nwith DMA interfaces such as the DEC DMV11 and\
    \ DMR11.  These interfaces\nimplement the DEC DDCMP protocol, which includes error\
    \ detection and\nretransmission capabilities.  The DDCMP frame format is as follows:\n\
    +-------------+-----+-----+-----+-----+-----+------+------+------+\n| SYN SYN\
    \ SOH |Count|Flag |Resp | Seq | Adr | CRC1 | Data | CRC2 |\n+-------------+-----+-----+-----+-----+-----+------+------+------+\n\
    bits   24       14     2     8     8     8     16     ...    16\nWith respect\
    \ to this diagram, each octet is transmitted starting from the\nleftmost octet,\
    \ with the bits of each octet transmitted low-order bit first.\nThe contents of\
    \ all fields except the \"Data\" field are managed by the\ninterface.  The Internet\
    \ datagram is placed in this field as-is, with no\ncharacter or bit stuffing (the\
    \ extent of this field is indicated by the\ninterface in the \"Count\" field.\n\
    A.3.  Serial Links Using HDLC Devices\n     Following is a description of the\
    \ frame format used on HDLC links with\nprogram-interrupt interfaces such as the\
    \ DEC DPV11.\n        +--------+--------+--------+--------+--------+--------+\n\
    \        |  Flag  |  Addr  |  Ctrl  |  Data  |  CRC   |  Flag  |\nWith respect\
    \ to this diagram, each octet is transmitted starting from\nthe leftmost octet,\
    \ with the bits of each octet transmitted low-order\nbit first.  The code xxxxxxxx\
    \ represents the data portion and cccccccc\nrepresents the checksum.  The bits\
    \ between the \"Flag\" fields are\nencoded with a bit-stuffing convention in which\
    \ a zero bit is stuffed\nfollowing a string of five one bits.  The \"Addr\" and\
    \ \"Ctrl\" fields are\nnot used and the checksum is ignored.  The Internet datagram\
    \ is placed\nin the \"Data\" field, which must be a multiple of eight bits in\
    \ length.\nA.4.  ARPANET 1822 Links Using Local or Distant Host Interfaces\n \
    \    Following is a description of the frame format used with ARPANET\n1822 Local\
    \ or Distant Host interfaces.  These interfaces can be used\nto connect a DCN\
    \ host to an ARPANET IMP, Gateway or Port Expander or\nto connect two DCN hosts\
    \ together.  When used to connect a DCN host to\nan ARPANET IMP, Gateway or Port\
    \ Expander, a 96-bit 1822 leader is\nprepended ahead of the Internet datagram.\
    \  The coding of this leader\nis as described in BBN Report 1822.  When used to\
    \ connect two DCN\nhosts together, no leader is used and the frame contains only\
    \ the\nInternet datagram.\nA.5.  ARPANET 1822 Links Using HDH Interfaces\n   \
    \  Following is a description of the frame format used with ARPANET\n1822 HDH\
    \ interfaces.  These interfaces can be used to connect a DCN\nhost to an ARPANET\
    \ IMP or Gateway or to connect two DCN hosts\ntogether.  In either case, the frame\
    \ format is as described in\nAppendix J of BBN Report 1822.\nA.6.  X.25 LAPB Links\
    \ Using RSRE Interfaces\n     Following is a description of the frame format used\
    \ on X.25 LAPB\nlinks with the Royal Signals and Radar Establishment interfaces.\n\
    These interfaces implement the X.25 Link Access Protocol - Balanced\n(LAPB), also\
    \ known as the frame-level protocol, using a frame format\nsimilar to that described\
    \ under A.3 above.  Internet datagrams are\nplaced in the data portion of I frames\
    \ and encoded with the\nbit-stuffing procedure described in A.3.  There is no\
    \ packet-level\nformat used with these interfaces.\nA.7.  Ethernet Links\n   \
    \  Following is a description of the frame format used on Ethernet links.\n  \
    \      +-----------+-----------+------+------+-----+\n        | Dest Addr | Srce\
    \ Addr | Type | Data | CRC |\n        +-----------+-----------+------+------+-----+\n\
    bits          48          48       16     ...   32\nWith respect to this diagram,\
    \ each field is transmitted starting from\nthe leftmost field, with the bits of\
    \ each field transmitted low-order\nARP datagrams (0806 hex).  The Internet datagram\
    \ is placed in the\n"
