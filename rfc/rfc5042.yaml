- title: __initial_text__
  contents:
  - "                Direct Data Placement Protocol (DDP) /\n         Remote Direct\
    \ Memory Access Protocol (RDMAP) Security\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document analyzes security issues around implementation and\
    \ use\n   of the Direct Data Placement Protocol (DDP) and Remote Direct Memory\n\
    \   Access Protocol (RDMAP).  It first defines an architectural model for\n  \
    \ an RDMA Network Interface Card (RNIC), which can implement DDP or\n   RDMAP\
    \ and DDP.  The document reviews various attacks against the\n   resources defined\
    \ in the architectural model and the countermeasures\n   that can be used to protect\
    \ the system.  Attacks are grouped into\n   those that can be mitigated by using\
    \ secure communication channels\n   across the network, attacks from Remote Peers,\
    \ and attacks from Local\n   Peers.  Attack categories include spoofing, tampering,\
    \ information\n   disclosure, denial of service, and elevation of privilege.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \   2. Architectural Model .............................................6\n  \
    \    2.1. Components .................................................7\n    \
    \  2.2. Resources ..................................................9\n      \
    \     2.2.1. Stream Context Memory ...............................9\n        \
    \   2.2.2. Data Buffers .......................................10\n          \
    \ 2.2.3. Page Translation Tables ............................10\n           2.2.4.\
    \ Protection Domain (PD) .............................11\n           2.2.5. STag\
    \ Namespace and Scope ...........................11\n           2.2.6. Completion\
    \ Queues ..................................12\n           2.2.7. Asynchronous\
    \ Event Queue ...........................12\n           2.2.8. RDMA Read Request\
    \ Queue ............................13\n      2.3. RNIC Interactions .........................................13\n\
    \           2.3.1. Privileged Control Interface Semantics .............13\n  \
    \         2.3.2. Non-Privileged Data Interface Semantics ............13\n    \
    \       2.3.3. Privileged Data Interface Semantics ................14\n      \
    \     2.3.4. Initialization of RNIC Data Structures for\n                  Data\
    \ Transfer ......................................14\n           2.3.5. RNIC Data\
    \ Transfer Interactions ....................16\n   3. Trust and Resource Sharing\
    \ .....................................17\n   4. Attacker Capabilities ..........................................18\n\
    \   5. Attacks That Can Be Mitigated with End-to-End Security .........18\n  \
    \    5.1. Spoofing ..................................................19\n    \
    \       5.1.1. Impersonation ......................................19\n      \
    \     5.1.2. Stream Hijacking ...................................20\n        \
    \   5.1.3. Man-in-the-Middle Attack ...........................20\n      5.2.\
    \ Tampering - Network-Based Modification of Buffer Content ..21\n      5.3. Information\
    \ Disclosure - Network-Based Eavesdropping ......21\n      5.4. Specific Requirements\
    \ for Security Services ...............21\n           5.4.1. Introduction to Security\
    \ Options ...................21\n           5.4.2. TLS Is Inappropriate for DDP/RDMAP\
    \ Security ........22\n           5.4.3. DTLS and RDDP ......................................23\n\
    \           5.4.4. ULPs That Provide Security .........................23\n  \
    \         5.4.5. Requirements for IPsec Encapsulation of DDP ........23\n   6.\
    \ Attacks from Remote Peers ......................................24\n      6.1.\
    \ Spoofing ..................................................25\n           6.1.1.\
    \ Using an STag on a Different Stream ................25\n      6.2. Tampering\
    \ .................................................26\n           6.2.1. Buffer\
    \ Overrun - RDMA Write or Read Response .......26\n           6.2.2. Modifying\
    \ a Buffer after Indication ................27\n           6.2.3. Multiple STags\
    \ to Access the Same Buffer ...........27\n      6.3. Information Disclosure ....................................28\n\
    \           6.3.1. Probing Memory Outside of the Buffer Bounds ........28\n  \
    \         6.3.2. Using RDMA Read to Access Stale Data ...............28\n    \
    \       6.3.3. Accessing a Buffer after the Transfer ..............28\n      \
    \     6.3.4. Accessing Unintended Data with a Valid STag ........29\n        \
    \   6.3.5. RDMA Read into an RDMA Write Buffer ................29\n          \
    \ 6.3.6. Using Multiple STags That Alias to the Same\n                  Buffer\
    \ .............................................29\n      6.4. Denial of Service\
    \ (DOS) ...................................30\n           6.4.1. RNIC Resource\
    \ Consumption ..........................30\n           6.4.2. Resource Consumption\
    \ by Idle ULPs ..................31\n           6.4.3. Resource Consumption by\
    \ Active ULPs ................32\n                  6.4.3.1. Multiple Streams\
    \ Sharing Receive Buffers ..32\n                  6.4.3.2. Remote or Local Peer\
    \ Attacking a\n                           Shared CQ .................................34\n\
    \                  6.4.3.3. Attacking the RDMA Read Request Queue .....36\n  \
    \         6.4.4. Exercise of Non-Optimal Code Paths .................37\n    \
    \       6.4.5. Remote Invalidate an STag Shared on\n                  Multiple\
    \ Streams ...................................37\n           6.4.6. Remote Peer\
    \ Attacking an Unshared CQ ...............38\n      6.5. Elevation of Privilege\
    \ ....................................38\n   7. Attacks from Local Peers .......................................38\n\
    \      7.1. Local ULP Attacking a Shared CQ ...........................39\n  \
    \    7.2. Local Peer Attacking the RDMA Read Request Queue ..........39\n    \
    \  7.3. Local ULP Attacking the PTT and STag Mapping ..............39\n   8. Security\
    \ considerations ........................................40\n   9. IANA Considerations\
    \ ............................................40\n   10. References ....................................................40\n\
    \      10.1. Normative References .....................................40\n  \
    \    10.2. Informative References ...................................41\n   Appendix\
    \ A. ULP Issues for RDDP Client/Server Protocols ...........43\n   Appendix B.\
    \ Summary of RNIC and ULP Implementation Requirements ...46\n   Appendix C. Partial\
    \ Trust Taxonomy ................................47\n   Acknowledgments ...................................................49\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   RDMA enables new levels of flexibility when communicating\
    \ between two\n   parties compared to current conventional networking practice\
    \ (e.g., a\n   stream-based model or datagram model).  This flexibility brings\
    \ new\n   security issues that must be carefully understood when designing\n \
    \  Upper Layer Protocols (ULPs) utilizing RDMA and when implementing\n   RDMA-aware\
    \ NICs (RNICs).  Note that for the purposes of this security\n   analysis, an\
    \ RNIC may implement RDMAP [RDMAP] and DDP [DDP], or just\n   DDP.  Also, a ULP\
    \ may be an application or it may be a middleware\n   library.\n   The key words\
    \ \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\"\
    , \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this\n   document\
    \ are to be interpreted as described in RFC 2119.\n   Additionally, the security\
    \ terminology defined in [RFC4949] is used\n   in this specification.\n   The\
    \ document first develops an architectural model that is relevant\n   for the\
    \ security analysis.  Section 2 details components, resources,\n   and system\
    \ properties that may be attacked.  The document uses Local\n   Peer to represent\
    \ the RDMA/DDP protocol implementation on the local\n   end of a Stream (implemented\
    \ with a transport protocol, such as\n   [RFC793] or [RFC4960]).  The local Upper-Layer-Protocol\
    \ (ULP) is used\n   to represent the application or middle-ware layer above the\
    \ Local\n   Peer.  The document does not attempt to differentiate between a\n\
    \   Remote Peer and a Remote ULP (an RDMA/DDP protocol implementation on\n   the\
    \ remote end of a Stream versus the application on the remote end)\n   for several\
    \ reasons: often, the source of the attack is difficult to\n   know for sure and,\
    \ regardless of the source, the mitigations required\n   of the Local Peer or\
    \ local ULP are the same.  Thus, the document\n   generically refers to a Remote\
    \ Peer rather than trying to further\n   delineate the attacker.\n   The document\
    \ then defines what resources a local ULP may share across\n   Streams and what\
    \ resources the local ULP may share with the Remote\n   Peer across Streams in\
    \ Section 3.\n   Intentional sharing of resources between multiple Streams may\
    \ imply\n   some level of trust between the Streams.  However, some types of\n\
    \   resource sharing have unmitigated security attacks, which would\n   mandate\
    \ not sharing a specific type of resource unless there is some\n   level of trust\
    \ between the Streams sharing resources.\n   This document defines a new term,\
    \ \"Partial Mutual Trust\", to address\n   this concept:\n      Partial Mutual\
    \ Trust - a collection of RDMAP/DDP Streams, which\n      represent the local\
    \ and remote end points of the Stream that are\n      willing to assume that the\
    \ Streams from the collection will not\n      perform malicious attacks against\
    \ any of the other Streams in the\n      collection.\n   ULPs have explicit control\
    \ of which collection of endpoints is in a\n   Partial Mutual Trust collection\
    \ through tools discussed in Appendix\n   C, Partial Trust Taxonomy.\n   An untrusted\
    \ peer relationship is appropriate when a ULP wishes to\n   ensure that it will\
    \ be robust and uncompromised even in the face of a\n   deliberate attack by its\
    \ peer.  For example, a single ULP that\n   concurrently supports multiple unrelated\
    \ Streams (e.g., a server)\n   would presumably treat each of its peers as an\
    \ untrusted peer.  For a\n   collection of Streams that share Partial Mutual Trust,\
    \ the assumption\n   is that any Stream not in the collection is untrusted.  For\
    \ the\n   untrusted peer, a brief list of capabilities is enumerated in Section\n\
    \   4.\n   The rest of the document is focused on analyzing attacks and\n   recommending\
    \ specific mitigations to the attacks.  Attacks are\n   categorized into attacks\
    \ mitigated by end-to-end security, attacks\n   initiated by Remote Peers, and\
    \ attacks initiated by Local Peers.  For\n   each attack, possible countermeasures\
    \ are reviewed.\n   ULPs within a host are divided into two categories - Privileged\
    \ and\n   Non-Privileged.  Both ULP types can send and receive data and request\n\
    \   resources.  The key differences between the two are:\n      The Privileged\
    \ ULP is trusted by the local system not to\n      maliciously attack the operating\
    \ environment, but it is not\n      trusted to optimize resource allocation globally.\
    \  For example,\n      the Privileged ULP could be a kernel ULP; thus, the kernel\n\
    \      presumably has in some way vetted the ULP before allowing it to\n     \
    \ execute.\n      A Non-Privileged ULP's capabilities are a logical sub-set of\
    \ the\n      Privileged ULP's.  It is assumed by the local system that a Non-\n\
    \      Privileged ULP is untrusted.  All Non-Privileged ULP interactions\n   \
    \   with the RNIC Engine that could affect other ULPs need to be done\n      through\
    \ a trusted intermediary that can verify the Non-Privileged\n      ULP requests.\n\
    \   The appendices provide focused summaries of this specification.\n   Appendix\
    \ A, ULP Issues for RDDP Client/Server Protocols, focuses on\n   implementers\
    \ of traditional client/server protocols.  Appendix B,\n   Summary of RNIC and\
    \ ULP Implementation Requirements, summarizes all\n   normative requirements in\
    \ this specification.  Appendix C, Partial\n   Trust Taxonomy, provides an abstract\
    \ model for categorizing trust\n   boundaries.\n   If an RDMAP/DDP protocol implementation\
    \ uses the mitigations\n   recommended in this document, that implementation should\
    \ not exhibit\n   additional security vulnerabilities above and beyond those of\
    \ an\n   implementation of the transport protocol (i.e., TCP or SCTP) and\n  \
    \ protocols beneath it (e.g., IP) without RDMAP/DDP.\n"
- title: 2.  Architectural Model
  contents:
  - "2.  Architectural Model\n   This section describes an RDMA architectural reference\
    \ model that is\n   used as security issues are examined.  It introduces the components\n\
    \   of the model, the resources that can be attacked, the types of\n   interactions\
    \ possible between components and resources, and the\n   system properties that\
    \ must be preserved.\n   Figure 1 shows the components comprising the architecture\
    \ and the\n   interfaces where potential security attacks could be launched.\n\
    \   External attacks can be injected into the system from a ULP that sits\n  \
    \ above the RNIC Interface or from the network.\n   The intent here is to describe\
    \ high level components and capabilities\n   that affect threat analysis, and\
    \ not focus on specific implementation\n   options.  Also note that the architectural\
    \ model is an abstraction,\n   and an actual implementation may choose to subdivide\
    \ its components\n   along different boundary lines from those defined here. \
    \ For example,\n   the Privileged Resource Manager may be partially or completely\n\
    \   encapsulated in the Privileged ULP.  Regardless, it is expected that\n   the\
    \ security analysis of the potential threats and countermeasures\n   still apply.\n\
    \   Note that the model below is derived from several specific RDMA\n   implementations.\
    \  A few of note are [VERBS-RDMAC], [VERBS-RDMAC-\n   Overview], and [INFINIBAND].\n\
    \             +-------------+\n             |  Privileged |\n             |  Resource\
    \   |\n    Admin<-+>|  Manager    |     ULP Control Interface\n           | |\
    \             |<------+-------------------+\n           | +-------------+    \
    \   |                   |\n           |       ^               v              \
    \     v\n           |       |         +-------------+   +-----------------+\n\
    \           +---------------->| Privileged  |   |  Non-Privileged |\n        \
    \           |         | ULP         |   |  ULP            |\n                \
    \   |         +-------------+   +-----------------+\n                   |    \
    \           ^                   ^\n                   |Privileged     |Privileged\
    \         |Non-Privileged\n                   |Control        |Data          \
    \     |Data\n                   |Interface      |Interface          |Interface\n\
    \   RNIC            |               |                   |\n   Interface      \
    \ v               v                   v\n   =================================================================\n\
    \                 +--------------------------------------+\n                 |\
    \                                      |\n                 |               RNIC\
    \ Engine            |\n                 |                                    \
    \  |\n                 +--------------------------------------+\n            \
    \                       ^\n                                   |\n            \
    \                       v\n                                Internet\n        \
    \              Figure 1 - RDMA Security Model\n"
- title: 2.1.  Components
  contents:
  - "2.1.  Components\n   The components shown in Figure 1 - RDMA Security Model are:\n\
    \   *   RDMA Network Interface Controller Engine (RNIC) - The component\n    \
    \   that implements the RDMA protocol and/or DDP protocol.\n   *   Privileged\
    \ Resource Manager - The component responsible for\n       managing and allocating\
    \ resources associated with the RNIC\n       Engine.  The Resource Manager does\
    \ not send or receive data.\n       Note that whether the Resource Manager is\
    \ an independent\n       component, part of the RNIC, or part of the ULP is implementation\n\
    \       dependent.\n   *   Privileged ULP - See Section 1, Introduction, for a\
    \ definition of\n       Privileged ULP.  The local host infrastructure can enable\
    \ the\n       Privileged ULP to map a Data Buffer directly from the RNIC Engine\n\
    \       to the host through the RNIC Interface, but it does not allow the\n  \
    \     Privileged ULP to directly consume RNIC Engine resources.\n   *   Non-Privileged\
    \ ULP - See Section 1, Introduction, for a\n       definition of Non-Privileged\
    \ ULP.\n   A design goal of the DDP and RDMAP protocols is to allow, under\n \
    \  constrained conditions, Non-Privileged ULP to send and receive data\n   directly\
    \ to/from the RDMA Engine without Privileged Resource Manager\n   intervention,\
    \ while ensuring that the host remains secure.  Thus, one\n   of the primary goals\
    \ of this document is to analyze this usage model\n   for the enforcement that\
    \ is required in the RNIC Engine to ensure\n   that the system remains secure.\n\
    \   DDP provides two mechanisms for transferring data:\n   *   Untagged Data Transfer\
    \ - The incoming payload simply consumes the\n       first buffer in a queue of\
    \ buffers that are in the order\n       specified by the receiving Peer (commonly\
    \ referred to as the\n       Receive Queue), and\n   *   Tagged Data Transfer\
    \ - The Peer transmitting the payload\n       explicitly states which destination\
    \ buffer is targeted, through\n       use of an STag.  STag-based transfers allow\
    \ the receiving ULP to\n       be indifferent to what order (or in what messages)\
    \ the opposite\n       Peer sent the data, or in what order packets are received.\n\
    \   Both data transfer mechanisms are also enabled through RDMAP, with\n   additional\
    \ control semantics.  Typically, Tagged Data Transfer can be\n   used for payload\
    \ transfer, while Untagged Data Transfer is best used\n   for control messages.\
    \  However, each Upper Layer Protocol can\n   determine the optimal use of Tagged\
    \ and Untagged messages for itself.\n   See [APPLICABILITY] for more information\
    \ on application applicability\n   for the two transfer mechanisms.\n   For DDP,\
    \ the two forms correspond to Untagged and Tagged DDP\n   Messages, respectively.\
    \  For RDMAP, the two forms correspond to Send\n   Type Messages and RDMA Messages\
    \ (either RDMA Read or RDMA Write\n   Messages), respectively.\n   The host interfaces\
    \ that could be exercised include:\n   *   Privileged Control Interface - A Privileged\
    \ Resource Manager uses\n       the RNIC Interface to allocate and manage RNIC\
    \ Engine resources,\n       control the state within the RNIC Engine, and monitor\
    \ various\n       events from the RNIC Engine.  It also uses this interface to\
    \ act\n       as a proxy for some operations that a Non-Privileged ULP may\n \
    \      require (after performing appropriate countermeasures).\n   *   ULP Control\
    \ Interface - A ULP uses this interface to the\n       Privileged Resource Manager\
    \ to allocate RNIC Engine resources.\n       The Privileged Resource Manager implements\
    \ countermeasures to\n       ensure that, if the Non-Privileged ULP launches an\
    \ attack, it can\n       prevent the attack from affecting other ULPs.\n   * \
    \  Non-Privileged Data Transfer Interface - A Non-Privileged ULP\n       uses\
    \ this interface to initiate and check the status of data\n       transfer operations.\n\
    \   *   Privileged Data Transfer Interface - A superset of the\n       functionality\
    \ provided by the Non-Privileged Data Transfer\n       Interface.  The ULP is\
    \ allowed to directly manipulate RNIC Engine\n       mapping resources to map\
    \ an STag to a ULP Data Buffer.\n   If Internet control messages, such as ICMP,\
    \ ARP, RIPv4, etc. are\n   processed by the RNIC Engine, the threat analyses for\
    \ those protocols\n   is also applicable, but outside the scope of this document.\n"
- title: 2.2.  Resources
  contents:
  - "2.2.  Resources\n   This section describes the primary resources in the RNIC\
    \ Engine that\n   could be affected if under attack.  For RDMAP, all the defined\n\
    \   resources apply.  For DDP, all the resources except the RDMA Read\n   Queue\
    \ apply.\n"
- title: 2.2.1.  Stream Context Memory
  contents:
  - "2.2.1.  Stream Context Memory\n   The state information for each Stream is maintained\
    \ in memory, which\n   could be located in a number of places - on the NIC, inside\
    \ RAM\n   attached to the NIC, in host memory, or in any combination of the\n\
    \   three, depending on the implementation.\n   Stream Context Memory includes\
    \ state associated with Data Buffers.\n   For Tagged Buffers, this includes how\
    \ STag names, Data Buffers, and\n   Page Translation Tables (see Section 2.2.3)\
    \ interrelate.  It also\n   includes the list of Untagged Data Buffers posted\
    \ for reception of\n   Untagged Messages (commonly called the Receive Queue),\
    \ and a list of\n   operations to perform to send data (commonly called the Send\
    \ Queue).\n"
- title: 2.2.2.  Data Buffers
  contents:
  - "2.2.2.  Data Buffers\n   As mentioned previously, there are two different ways\
    \ to expose a\n   local ULP's Data Buffers for data transfer: Untagged Data Transfer,\n\
    \   where a buffer can be exposed for receiving RDMAP Send Type Messages\n   (a.k.a.\
    \ DDP Untagged Messages) on DDP Queue zero, or Tagged Data\n   Transfer, where\
    \ the buffer can be exposed for remote access through\n   STags (a.k.a. DDP Tagged\
    \ Messages).  This distinction is important\n   because the attacks and the countermeasures\
    \ used to protect against\n   the attack are different depending on the method\
    \ for exposing the\n   buffer to the network.\n   For the purposes of the security\
    \ discussion, for Tagged Data\n   Transfer, a single logical Data Buffer is exposed\
    \ with a single STag\n   on a given Stream.  Actual implementations may support\
    \ scatter/gather\n   capabilities to enable multiple physical data buffers to\
    \ be accessed\n   with a single STag, but from a threat analysis perspective,\
    \ it is\n   assumed that a single STag enables access to a single logical Data\n\
    \   Buffer.\n   In any event, it is the responsibility of the Privileged Resource\n\
    \   Manager to ensure that no STag can be created that exposes memory\n   that\
    \ the consumer had no authority to expose.\n   A Data Buffer has specific access\
    \ rights.  The local ULP can control\n   whether a Data Buffer is exposed for\
    \ local only, or local and remote\n   access, and assign specific access privileges\
    \ (read, write, read and\n   write) on a per Stream basis.\n   For DDP, when an\
    \ STag is Advertised, the Remote Peer is presumably\n   given write access rights\
    \ to the data (otherwise, there would not be\n   much point to the Advertisement).\
    \  For RDMAP, when a ULP Advertises\n   an STag, it can enable write-only, read-only,\
    \ or both write and read\n   access rights.\n   Similarly, some ULPs may wish\
    \ to provide a single buffer with\n   different access rights on a per Stream\
    \ basis.  For example, some\n   Streams may have read-only access, some may have\
    \ remote read and\n   write access, while on other Streams, only the local ULP/Local\
    \ Peer\n   is allowed access.\n"
- title: 2.2.3.  Page Translation Tables
  contents:
  - "2.2.3.  Page Translation Tables\n   Page Translation Tables are the structures\
    \ used by the RNIC to be\n   able to access ULP memory for data transfer operations.\
    \  Even though\n   these structures are called \"Page\" Translation Tables, they\
    \ may not\n   reference a page at all - conceptually, they are used to map a ULP\n\
    \   address space representation (e.g., a virtual address) of a buffer to\n  \
    \ the physical addresses that are used by the RNIC Engine to move data.\n   If,\
    \ on a specific system, a mapping is not used, then a subset of the\n   attacks\
    \ examined may be appropriate.  Note that the Page Translation\n   Table may or\
    \ may not be a shared resource.\n"
- title: 2.2.4.  Protection Domain (PD)
  contents:
  - "2.2.4.  Protection Domain (PD)\n   A Protection Domain (PD) is a local construct\
    \ to the RDMA\n   implementation, and never visible over the wire.  Protection\
    \ Domains\n   are assigned to three of the resources of concern - Stream Context\n\
    \   Memory, STags associated with Page Translation Table entries, and\n   Data\
    \ Buffers.  A correct implementation of a Protection Domain\n   requires that\
    \ resources that belong to a given Protection Domain\n   cannot be used on a resource\
    \ belonging to another Protection Domain,\n   because Protection Domain membership\
    \ is checked by the RNIC prior to\n   taking any action involving such a resource.\
    \  Protection Domains are\n   therefore used to ensure that an STag can only be\
    \ used to access an\n   associated Data Buffer on one or more Streams that are\
    \ associated\n   with the same Protection Domain as the specific STag.\n   If\
    \ an implementation chooses not to share resources between Streams,\n   it is\
    \ recommended that each Stream be associated with its own, unique\n   Protection\
    \ Domain.  If an implementation chooses to allow resource\n   sharing, it is recommended\
    \ that Protection Domain be limited to the\n   collection of Streams that have\
    \ Partial Mutual Trust with each other.\n   Note that a ULP (either Privileged\
    \ or Non-Privileged) can potentially\n   have multiple Protection Domains.  This\
    \ could be used, for example,\n   to ensure that multiple clients of a server\
    \ do not have the ability\n   to corrupt each other.  The server would allocate\
    \ a Protection Domain\n   per client to ensure that resources covered by the Protection\
    \ Domain\n   could not be used by another (untrusted) client.\n"
- title: 2.2.5.  STag Namespace and Scope
  contents:
  - "2.2.5.  STag Namespace and Scope\n   The DDP specification defines a 32-bit namespace\
    \ for the STag.\n   Implementations may vary in terms of the actual number of\
    \ STags that\n   are supported.  In any case, this is a bounded resource that\
    \ can come\n   under attack.  Depending upon STag namespace allocation algorithms,\n\
    \   the actual name space to attack may be significantly less than 2^32.\n   The\
    \ scope of an STag is the set of DDP/RDMAP Streams on which the\n   STag is valid.\
    \  If an STag is valid on a particular DDP/RDMAP Stream,\n   then that stream\
    \ can modify the buffer, subject to the access rights\n   that the stream has\
    \ for the STag (see Section 2.2.2, Data Buffers,\n   for additional information).\n\
    \   The analysis presented in this document assumes two mechanisms for\n   limiting\
    \ the scope of Streams for which the STag is valid:\n   *   Protection Domain\
    \ scope.  The STag is valid if used on any Stream\n       within a specific Protection\
    \ Domain, and is invalid if used on\n       any Stream that is not a member of\
    \ the Protection Domain.\n   *   Single Stream scope.  The STag is valid on a\
    \ single Stream,\n       regardless of what the Stream association is to a Protection\n\
    \       Domain.  If used on any other Stream, it is invalid.\n"
- title: 2.2.6.  Completion Queues
  contents:
  - "2.2.6.  Completion Queues\n   Completion Queues (CQ) are used in this document\
    \ to conceptually\n   represent how the RNIC Engine notifies the ULP about the\
    \ completion\n   of the transmission of data, or the completion of the reception\
    \ of\n   data through the Data Transfer Interface (specifically for Untagged\n\
    \   Data Transfer; Tagged Data Transfer cannot cause a completion to\n   occur).\
    \  Because there could be many transmissions or receptions in\n   flight at any\
    \ one time, completions are modeled as a queue rather\n   than as a single event.\
    \  An implementation may also use the\n   Completion Queue to notify the ULP of\
    \ other activities; for example,\n   the completion of a mapping of an STag to\
    \ a specific ULP buffer.\n   Completion Queues may be shared by a group of Streams,\
    \ or may be\n   designated to handle a specific Stream's traffic.  Limiting\n\
    \   Completion Queue association to one, or a small number, of RDMAP/DDP\n   Streams\
    \ can prevent several forms of attacks by sharply limiting the\n   scope of the\
    \ attack's effect.\n   Some implementations may allow this queue to be manipulated\
    \ directly\n   by both Non-Privileged and Privileged ULPs.\n"
- title: 2.2.7.  Asynchronous Event Queue
  contents:
  - "2.2.7.  Asynchronous Event Queue\n   The Asynchronous Event Queue is a queue\
    \ from the RNIC to the\n   Privileged Resource Manager of bounded size.  It is\
    \ used by the RNIC\n   to notify the host of various events that might require\
    \ management\n   action, including protocol violations, Stream state changes,\
    \ local\n   operation errors, low water marks on receive queues, and possibly\n\
    \   other events.\n   The Asynchronous Event Queue is a resource that can be attacked\n\
    \   because Remote or Local Peers and/or ULPs can cause events to occur\n   that\
    \ have the potential of overflowing the queue.\n   Note that an implementation\
    \ is at liberty to implement the functions\n   of the Asynchronous Event Queue\
    \ in a variety of ways, including\n   multiple queues or even simple callbacks.\
    \  All vulnerabilities\n   identified are intended to apply, regardless of the\
    \ implementation of\n   the Asynchronous Event Queue.  For example, a callback\
    \ function may\n   be viewed simply as a very short queue.\n"
- title: 2.2.8.  RDMA Read Request Queue
  contents:
  - "2.2.8.  RDMA Read Request Queue\n   The RDMA Read Request Queue is the memory\
    \ that holds state\n   information for one or more RDMA Read Request Messages\
    \ that have\n   arrived, but for which the RDMA Read Response Messages have not\
    \ yet\n   been completely sent.  Because potentially more than one RDMA Read\n\
    \   Request can be outstanding at one time, the memory is modeled as a\n   queue\
    \ of bounded size.  Some implementations may enable sharing of a\n   single RDMA\
    \ Read Request Queue across multiple Streams.\n"
- title: 2.3.  RNIC Interactions
  contents:
  - "2.3.  RNIC Interactions\n   With RNIC resources and interfaces defined, it is\
    \ now possible to\n   examine the interactions supported by the generic RNIC functional\n\
    \   interfaces through each of the 3 interfaces: Privileged Control\n   Interface,\
    \ Privileged Data Interface, and Non-Privileged Data\n   Interface.  As mentioned\
    \ previously in Section 2.1, Components, there\n   are two data transfer mechanisms\
    \ to be examined, Untagged Data\n   Transfer and Tagged Data Transfer.\n"
- title: 2.3.1.  Privileged Control Interface Semantics
  contents:
  - "2.3.1.  Privileged Control Interface Semantics\n   Generically, the Privileged\
    \ Control Interface controls the RNIC's\n   allocation, de-allocation, and initialization\
    \ of RNIC global\n   resources.  This includes allocation and de-allocation of\
    \ Stream\n   Context Memory, Page Translation Tables, STag names, Completion\n\
    \   Queues, RDMA Read Request Queues, and Asynchronous Event Queues.\n   The Privileged\
    \ Control Interface is also typically used for managing\n   Non-Privileged ULP\
    \ resources for the Non-Privileged ULP (and possibly\n   for the Privileged ULP\
    \ as well).  This includes initialization and\n   removal of Page Translation\
    \ Table resources, and managing RNIC events\n   (possibly managing all events\
    \ for the Asynchronous Event Queue).\n"
- title: 2.3.2.  Non-Privileged Data Interface Semantics
  contents:
  - "2.3.2.  Non-Privileged Data Interface Semantics\n   The Non-Privileged Data Interface\
    \ enables data transfer (transmit and\n   receive) but does not allow initialization\
    \ of the Page Translation\n   Table resources.  However, once the Page Translation\
    \ Table resources\n   have been initialized, the interface may enable a specific\
    \ STag\n   mapping to be enabled and disabled by directly communicating with the\n\
    \   RNIC, or create an STag mapping for a buffer that has been previously\n  \
    \ initialized in the RNIC.\n   For RDMAP, ULP data can be sent by one of the previously\
    \ described\n   data transfer mechanisms: Untagged Data Transfer or Tagged Data\n\
    \   Transfer.  Two RDMAP data transfer mechanisms are defined, one using\n   Untagged\
    \ Data Transfer (Send Type Messages), and one using Tagged\n   Data Transfer (RDMA\
    \ Read Responses and RDMA Writes).  ULP data\n   reception through RDMAP can be\
    \ done by receiving Send Type Messages\n   into buffers that have been posted\
    \ on the Receive Queue or Shared\n   Receive Queue.  Thus, a Receive Queue or\
    \ Shared Receive Queue can\n   only be affected by Untagged Data Transfer.  Data\
    \ reception can also\n   be done by receiving RDMA Write and RDMA Read Response\
    \ Messages into\n   buffers that have previously been exposed for external write\
    \ access\n   through Advertisement of an STag (i.e., Tagged Data Transfer).\n\
    \   Additionally, to cause ULP data to be pulled (read) across the\n   network,\
    \ RDMAP uses an RDMA Read Request Message (which only contains\n   RDMAP control\
    \ information necessary to access the ULP buffer to be\n   read), to cause an\
    \ RDMA Read Response Message to be generated that\n   contains the ULP data.\n\
    \   For DDP, transmitting data means sending DDP Tagged or Untagged\n   Messages.\
    \  For data reception, DDP can receive Untagged Messages into\n   buffers that\
    \ have been posted on the Receive Queue or Shared Receive\n   Queue.  It can also\
    \ receive Tagged DDP Messages into buffers that\n   have previously been exposed\
    \ for external write access through\n   Advertisement of an STag.\n   Completion\
    \ of data transmission or reception generally entails\n   informing the ULP of\
    \ the completed work by placing completion\n   information on the Completion Queue.\
    \  For data reception, only an\n   Untagged Data Transfer can cause completion\
    \ information to be put in\n   the Completion Queue.\n"
- title: 2.3.3.  Privileged Data Interface Semantics
  contents:
  - "2.3.3.  Privileged Data Interface Semantics\n   The Privileged Data Interface\
    \ semantics are a superset of the Non-\n   Privileged Data Transfer semantics.\
    \  The interface can do everything\n   defined in the prior section, as well as\
    \ create/destroy buffer to\n   STag mappings directly.  This generally entails\
    \ initialization or\n   clearing of Page Translation Table state in the RNIC.\n"
- title: 2.3.4.  Initialization of RNIC Data Structures for Data Transfer
  contents:
  - "2.3.4.  Initialization of RNIC Data Structures for Data Transfer\n   Initialization\
    \ of the mapping between an STag and a Data Buffer can\n   be viewed in the abstract\
    \ as two separate operations:\n   a.  Initialization of the allocated Page Translation\
    \ Table entries\n       with the location of the Data Buffer, and\n   b.  Initialization\
    \ of a mapping from an allocated STag name to a set\n       of Page Translation\
    \ Table entry(s) or partial entries.\n   Note that an implementation may not have\
    \ a Page Translation Table\n   (i.e., it may support a direct mapping between\
    \ an STag and a Data\n   Buffer).  If there is no Page Translation Table, then\
    \ attacks based\n   on changing its contents or exhausting its resources are not\n\
    \   possible.\n   Initialization of the contents of the Page Translation Table\
    \ can be\n   done by either the Privileged ULP or by the Privileged Resource\n\
    \   Manager as a proxy for the Non-Privileged ULP.  By definition, the\n   Non-Privileged\
    \ ULP is not trusted to directly manipulate the Page\n   Translation Table.  In\
    \ general, the concern is that the Non-\n   Privileged ULP may try to maliciously\
    \ initialize the Page Translation\n   Table to access a buffer for which it does\
    \ not have permission.\n   The exact resource allocation algorithm for the Page\
    \ Translation\n   Table is outside the scope of this document.  It may be allocated\
    \ for\n   a specific Data Buffer, or as a pooled resource to be consumed by\n\
    \   potentially multiple Data Buffers, or be managed in some other way.\n   This\
    \ document attempts to abstract implementation dependent issues,\n   and group\
    \ them into higher level security issues, such as resource\n   starvation and\
    \ sharing of resources between Streams.\n   The next issue is how an STag name\
    \ is associated with a Data Buffer.\n   For the case of an Untagged Data Buffer\
    \ (i.e., Untagged Data\n   Transfer), there is no wire visible mapping between\
    \ an STag and the\n   Data Buffer.  Note that there may, in fact, be an STag that\n\
    \   represents the buffer, if an implementation chooses to internally\n   represent\
    \ Untagged Data Buffer using STags.  However, because the\n   STag, by definition,\
    \ is not visible on the wire, this is a local\n   host, implementation-specific\
    \ issue that should be analyzed in the\n   context of a local host implementation-specific\
    \ security analysis,\n   and thus, is outside the scope of this document.\n  \
    \ For a Tagged Data Buffer (i.e., Tagged Data Transfer), either the\n   Privileged\
    \ ULP or the Privileged Resource Manager acting on behalf of\n   the Non-Privileged\
    \ ULP may initialize a mapping from an STag to a\n   Page Translation Table, or\
    \ may have the ability to simply\n   enable/disable an existing STag to Page Translation\
    \ Table mapping.\n   There may also be multiple STag names that map to a specific\
    \ group of\n   Page Translation Table entries (or sub-entries).  Specific security\n\
    \   issues with this level of flexibility are examined in Section 6.2.3,\n   Multiple\
    \ STags to Access the Same Buffer.\n   There are a variety of implementation options\
    \ for initialization of\n   Page Translation Table entries and mapping an STag\
    \ to a group of Page\n   Translation Table entries that have security repercussions.\
    \  This\n   includes support for separation of mapping an STag versus mapping\
    \ a\n   set of Page Translation Table entries, and support for ULPs directly\n\
    \   manipulating STag to Page Translation Table entry mappings (versus\n   requiring\
    \ access through the Privileged Resource Manager).\n"
- title: 2.3.5.  RNIC Data Transfer Interactions
  contents:
  - "2.3.5.  RNIC Data Transfer Interactions\n   RNIC Data Transfer operations can\
    \ be subdivided into send and receive\n   operations.\n   For send operations,\
    \ there is typically a queue that enables the ULP\n   to post multiple operation\
    \ requests to send data (referred to as the\n   Send Queue).  Depending upon the\
    \ implementation, Data Buffers used in\n   the operations may or may not have\
    \ Page Translation Table entries\n   associated with them, and may or may not\
    \ have STags associated with\n   them.  Because this is a local host specific\
    \ implementation issue\n   rather than a protocol issue, the security analysis\
    \ of threats and\n   mitigations is left to the host implementation.\n   Receive\
    \ operations are different for Tagged Data Buffers versus\n   Untagged Data Buffers\
    \ (i.e., Tagged Data Transfer vs. Untagged Data\n   Transfer).  For Untagged Data\
    \ Transfer, if more than one Untagged\n   Data Buffer can be posted by the ULP,\
    \ the DDP specification requires\n   that they be consumed in sequential order\
    \ (the RDMAP specification\n   also requires this).  Thus, the most general implementation\
    \ is that\n   there is a sequential queue of receive Untagged Data Buffers (Receive\n\
    \   Queue).  Some implementations may also support sharing of the\n   sequential\
    \ queue between multiple Streams.  In this case, defining\n   \"sequential\" becomes\
    \ non-trivial - in general, the buffers for a\n   single Stream are consumed from\
    \ the queue in the order that they were\n   placed on the queue, but there is\
    \ no consumption order guarantee\n   between Streams.\n   For receive Tagged Data\
    \ Transfer (i.e., Tagged Data Buffers, RDMA\n   Write Buffers, or RDMA Read Buffers),\
    \ at some time prior to data\n   transfer, the mapping of the STag to specific\
    \ Page Translation Table\n   entries (if present) and the mapping from the Page\
    \ Translation Table\n   entries to the Data Buffer must have been initialized\
    \ (see Section\n   2.3.4 for interaction details).\n"
- title: 3.  Trust and Resource Sharing
  contents:
  - "3.  Trust and Resource Sharing\n   It is assumed that, in general, the Local\
    \ and Remote Peer are\n   untrusted, and thus attacks by either should have mitigations\
    \ in\n   place.\n   A separate, but related issue is resource sharing between\
    \ multiple\n   Streams.  If local resources are not shared, the resources are\n\
    \   dedicated on a per Stream basis.  Resources are defined in Section\n   2.2,\
    \ Resources.  The advantage of not sharing resources between\n   Streams is that\
    \ it reduces the types of attacks that are possible.\n   The disadvantage of not\
    \ sharing resources is that ULPs might run out\n   of resources.  Thus, there\
    \ can be a strong incentive for sharing\n   resources, if the security issues\
    \ associated with the sharing of\n   resources can be mitigated.\n   It is assumed\
    \ in this document that the component that implements the\n   mechanism to control\
    \ sharing of the RNIC Engine resources is the\n   Privileged Resource Manager.\
    \  The RNIC Engine exposes its resources\n   through the RNIC Interface to the\
    \ Privileged Resource Manager.  All\n   Privileged and Non-Privileged ULPs request\
    \ resources from the\n   Resource Manager (note that by definition both the Non-Privileged\
    \ and\n   the Privileged application might try to greedily consume resources,\n\
    \   thus creating a potential Denial of Service (DOS) attack).  The\n   Resource\
    \ Manager implements resource management policies to ensure\n   fair access to\
    \ resources.  The Resource Manager should be designed to\n   take into account\
    \ security attacks detailed in this document.  Note\n   that for some systems\
    \ the Privileged Resource Manager may be\n   implemented within the Privileged\
    \ ULP.\n   All Non-Privileged ULP interactions with the RNIC Engine that could\n\
    \   affect other ULPs MUST be done using the Privileged Resource Manager\n   as\
    \ a proxy.  All ULP resource allocation requests for scarce\n   resources MUST\
    \ also be done using a Privileged Resource Manager.\n   The sharing of resources\
    \ across Streams should be under the control\n   of the ULP, both in terms of\
    \ the trust model the ULP wishes to\n   operate under, as well as the level of\
    \ resource sharing the ULP\n   wishes to give local processes.  For more discussion\
    \ on types of\n   trust models that combine partial trust and sharing of resources,\
    \ see\n   Appendix C, Partial Trust Taxonomy.\n   The Privileged Resource Manager\
    \ MUST NOT assume that different\n   Streams share Partial Mutual Trust unless\
    \ there is a mechanism to\n   ensure that the Streams do indeed share Partial\
    \ Mutual Trust.  This\n   can be done in several ways, including explicit notification\
    \ from the\n   ULP that owns the Streams.\n"
- title: 4.  Attacker Capabilities
  contents:
  - "4.  Attacker Capabilities\n   An attacker's capabilities delimit the types of\
    \ attacks that the\n   attacker is able to launch.  RDMAP and DDP require that\
    \ the initial\n   LLP Stream (and connection) be set up prior to transferring\
    \ RDMAP/DDP\n   Messages.  This requires at least one round-trip handshake to\
    \ occur.\n   If the attacker is not the Remote Peer that created the initial\n\
    \   connection, then the attacker's capabilities can be segmented into\n   send\
    \ only capabilities or send and receive capabilities.  Attacking\n   with send\
    \ only capabilities requires the attacker to first guess the\n   current LLP Stream\
    \ parameters before they can attack RNIC resources\n   (e.g., TCP sequence number).\
    \  If this class of attacker also has\n   receive capabilities and the ability\
    \ to pose as the receiver to the\n   sender and the sender to the receiver, they\
    \ are typically referred to\n   as a \"man-in-the-middle\" attacker [RFC3552].\
    \  A man-in-the-middle\n   attacker has a much wider ability to attack RNIC resources.\
    \  The\n   breadth of attack is essentially the same as that of an attacking\n\
    \   Remote Peer (i.e., the Remote Peer that set up the initial LLP\n   Stream).\n"
- title: 5.  Attacks That Can Be Mitigated with End-to-End Security
  contents:
  - "5.  Attacks That Can Be Mitigated with End-to-End Security\n   This section describes\
    \ the RDMAP/DDP attacks where the only solution\n   is to implement some form\
    \ of end-to-end security.  The analysis\n   includes a detailed description of\
    \ each attack, what is being\n   attacked, and a description of the countermeasures\
    \ that can be taken\n   to thwart the attack.\n   Some forms of attack involve\
    \ modifying the RDMAP or DDP payload by a\n   network-based attacker or involve\
    \ monitoring the traffic to discover\n   private information.  An effective tool\
    \ to ensure confidentiality is\n   to encrypt the data stream through mechanisms,\
    \ such as IPsec\n   encryption.  Additionally, authentication protocols, such\
    \ as IPsec\n   authentication, are an effective tool to ensure the remote entity\
    \ is\n   who they claim to be, as well as ensuring that the payload is\n   unmodified\
    \ as it traverses the network.\n   Note that connection setup and tear down is\
    \ presumed to be done in\n   stream mode (i.e., no RDMA encapsulation of the payload),\
    \ so there\n   are no new attacks related to connection setup/tear down beyond\
    \ what\n   is already present in the LLP (e.g., TCP or SCTP).  Note, however,\n\
    \   that RDMAP/DDP parameters may be exchanged in stream mode, and if\n   they\
    \ are corrupted by an attacker unintended consequences will\n   result.  Therefore,\
    \ any existing mitigations for LLP Spoofing,\n   Tampering, Repudiation, Information\
    \ Disclosure, Denial of Service, or\n   Elevation of Privilege continue to apply\
    \ (and are out of scope of\n   this document).  Thus, the analysis in this section\
    \ focuses on\n   attacks that are present, regardless of the LLP Stream type.\n\
    \   Tampering is any modification of the legitimate traffic (machine\n   internal\
    \ or network).  Spoofing attack is a special case of tampering\n   where the attacker\
    \ falsifies an identity of the Remote Peer (identity\n   can be an IP address,\
    \ machine name, ULP level identity, etc.).\n"
- title: 5.1.  Spoofing
  contents:
  - "5.1.  Spoofing\n   Spoofing attacks can be launched by the Remote Peer, or by\
    \ a\n   network-based attacker.  A network-based spoofing attack applies to\n\
    \   all Remote Peers.  This section analyzes the various types of\n   spoofing\
    \ attacks applicable to RDMAP and DDP.\n"
- title: 5.1.1.  Impersonation
  contents:
  - "5.1.1.  Impersonation\n   A network-based attacker can impersonate a legal RDMAP/DDP\
    \ Peer (by\n   spoofing a legal IP address).  This can either be done as a blind\n\
    \   attack (see [RFC3552]) or by establishing an RDMAP/DDP Stream with\n   the\
    \ victim.  Because an RDMAP/DDP Stream requires an LLP Stream to be\n   fully\
    \ initialized (e.g., for [RFC793], it is in the ESTABLISHED\n   state), existing\
    \ transport layer protection mechanisms against blind\n   attacks remain in place.\n\
    \   For a blind attack to succeed, it requires the attacker to inject a\n   valid\
    \ transport layer segment (e.g., for TCP, it must match at least\n   the 4-tuple\
    \ as well as guess a sequence number within the window)\n   while also guessing\
    \ valid RDMAP or DDP parameters.  There are many\n   ways to attack the RDMAP/DDP\
    \ protocol if the transport protocol is\n   assumed to be vulnerable.  For example,\
    \ for Tagged Messages, this\n   entails guessing the STag and TO values.  If the\
    \ attacker wishes to\n   simply terminate the connection, it can do so by correctly\
    \ guessing\n   the transport and network layer values, and providing an invalid\n\
    \   STag.  Per the DDP specification, if an invalid STag is received, the\n  \
    \ Stream is torn down and the Remote Peer is notified with an error.\n   If an\
    \ attacker wishes to overwrite an Advertised Buffer, it must\n   successfully\
    \ guess the correct STag and TO.  Given that the TO will\n   often start at zero,\
    \ this is straightforward.  The value of the STag\n   should be chosen at random,\
    \ as discussed in Section 6.1.1, Using an\n   STag on a Different Stream.  For\
    \ Untagged Messages, if the MSN is\n   invalid then the connection may be torn\
    \ down.  If it is valid, then\n   the receive buffers can be corrupted.\n   End-to-end\
    \ authentication (e.g., IPsec or ULP authentication)\n   provides protection against\
    \ either the blind attack or the connected\n   attack.\n"
- title: 5.1.2.  Stream Hijacking
  contents:
  - "5.1.2.  Stream Hijacking\n   Stream hijacking happens when a network-based attacker\
    \ eavesdrops on\n   the LLP connection through the Stream establishment phase,\
    \ and waits\n   until the authentication phase (if such a phase exists) is completed\n\
    \   successfully.  The attacker then spoofs the IP address and re-directs\n  \
    \ the Stream from the victim to its own machine.  For example, an\n   attacker\
    \ can wait until an iSCSI authentication is completed\n   successfully, and then\
    \ hijack the iSCSI Stream.\n   The best protection against this form of attack\
    \ is end-to-end\n   integrity protection and authentication, such as IPsec, to\
    \ prevent\n   spoofing.  Another option is to provide a physically segregated\n\
    \   network for security.  Discussion of physical security is out of\n   scope\
    \ for this document.\n   Because the connection and/or Stream itself is established\
    \ by the\n   LLP, some LLPs are more difficult to hijack than others.  Please\
    \ see\n   the relevant LLP documentation on security issues around connection\n\
    \   and/or Stream hijacking.\n"
- title: 5.1.3.  Man-in-the-Middle Attack
  contents:
  - "5.1.3.  Man-in-the-Middle Attack\n   If a network-based attacker has the ability\
    \ to delete or modify\n   packets that will still be accepted by the LLP (e.g.,\
    \ TCP sequence\n   number is correct), then the Stream can be exposed to a man-in-the-\n\
    \   middle attack.  One style of attack is for the man-in-the-middle to\n   send\
    \ Tagged Messages (either RDMAP or DDP).  If it can discover a\n   buffer that\
    \ has been exposed for STag enabled access, then the man-\n   in-the-middle can\
    \ use an RDMA Read operation to read the contents of\n   the associated Data Buffer,\
    \ perform an RDMA Write Operation to modify\n   the contents of the associated\
    \ Data Buffer, or invalidate the STag to\n   disable further access to the buffer.\n\
    \   The best protection against this form of attack is end-to-end\n   integrity\
    \ protection and authentication, such as IPsec, to prevent\n   spoofing or tampering.\
    \  If authentication and integrity protections\n   are not used, then physical\
    \ protection must be employed to prevent\n   man-in-the-middle attacks.\n   Because\
    \ the connection/Stream itself is established by the LLP, some\n   LLPs are more\
    \ exposed to man-in-the-middle attack than others.\n   Please see the relevant\
    \ LLP documentation on security issues around\n   connection and/or Stream hijacking.\n\
    \   Another approach is to restrict access to only the local subnet/link,\n  \
    \ and provide some mechanism to limit access, such as physical security\n   or\
    \ 802.1.x.  This model is an extremely limited deployment scenario,\n   and will\
    \ not be further examined here.\n"
- title: 5.2.  Tampering - Network-Based Modification of Buffer Content
  contents:
  - "5.2.  Tampering - Network-Based Modification of Buffer Content\n   This is actually\
    \ a man-in-the-middle attack, but only on the content\n   of the buffer, as opposed\
    \ to the man-in-the-middle attack presented\n   above, where both the signaling\
    \ and content can be modified.  See\n   Section 5.1.3, Man-in-the-Middle Attack.\n"
- title: 5.3.  Information Disclosure - Network-Based Eavesdropping
  contents:
  - "5.3.  Information Disclosure - Network-Based Eavesdropping\n   An attacker that\
    \ is able to eavesdrop on the network can read the\n   content of all read and\
    \ write accesses to a Peer's buffers.  To\n   prevent information disclosure,\
    \ the read/written data must be\n   encrypted.  See also Section 5.1.3, Man-in-the-Middle\
    \ Attack.  The\n   encryption can be done either by the ULP, or by a protocol\
    \ that can\n   provide security services to RDMAP and DDP (e.g., IPsec).\n"
- title: 5.4.  Specific Requirements for Security Services
  contents:
  - "5.4.  Specific Requirements for Security Services\n   Generally speaking, Stream\
    \ confidentiality protects against\n   eavesdropping.  Stream and/or session authentication\
    \ and integrity\n   protection is a counter measurement against various spoofing\
    \ and\n   tampering attacks.  The effectiveness of authentication and integrity\n\
    \   against a specific attack depends on whether the authentication is\n   machine\
    \ level authentication (such as IPsec), or ULP authentication.\n"
- title: 5.4.1.  Introduction to Security Options
  contents:
  - "5.4.1.  Introduction to Security Options\n   The following security services\
    \ can be applied to an RDMAP/DDP\n   Stream:\n   1.  Session confidentiality -\
    \ Protects against eavesdropping (Section\n       5.3).\n   2.  Per-packet data\
    \ source authentication - Protects against the\n       following spoofing attacks:\
    \ network-based impersonation (Section\n       5.1.1) and Stream hijacking (Section\
    \ 5.1.2).\n   3.  Per-packet integrity - Protects against tampering done by\n\
    \       network-based modification of buffer content (Section 5.2) and\n     \
    \  when combined with authentication, also protects against man-in-\n       the-middle\
    \ attacks (Section 5.1.3).\n   4.  Packet sequencing - protects against replay\
    \ attacks, which is a\n       special case of the above tampering attack.\n  \
    \ If an RDMAP/DDP Stream may be subject to impersonation attacks, or\n   Stream\
    \ hijacking attacks, it is recommended that the Stream be\n   authenticated, integrity\
    \ protected, and protected from replay\n   attacks; it may use confidentiality\
    \ protection to protect from\n   eavesdropping (in case the RDMAP/DDP Stream traverses\
    \ a public\n   network).\n   IPsec is a protocol suite that is used to secure\
    \ communication at the\n   network layer between two peers.  The IPsec protocol\
    \ suite is\n   specified within the IP Security Architecture [RFC2401], IKE\n\
    \   [RFC2409], IPsec Authentication Header (AH) [RFC2402], and IPsec\n   Encapsulating\
    \ Security Payload (ESP) [RFC2406] documents.  IKE is the\n   key management protocol,\
    \ while AH and ESP are used to protect IP\n   traffic.  Please see those RFCs\
    \ for a complete description of the\n   respective protocols.\n   IPsec is capable\
    \ of providing the above security services for IP and\n   TCP traffic, respectively.\
    \  ULP protocols are able to provide only\n   part of the above security services.\n"
- title: 5.4.2.  TLS Is Inappropriate for DDP/RDMAP Security
  contents:
  - "5.4.2.  TLS Is Inappropriate for DDP/RDMAP Security\n   TLS [RFC4346] provides\
    \ Stream authentication, integrity and\n   confidentiality for TCP based ULPs.\
    \  TLS supports one-way (server\n   only) or mutual certificates based authentication.\n\
    \   If TLS is layered underneath RDMAP, TLS's connection orientation\n   makes\
    \ TLS inappropriate for DDP/RDMA security.  If a stream cipher or\n   block cipher\
    \ in CBC mode is used for bulk encryption, then a packet\n   can be decrypted\
    \ only after all the packets preceding it have already\n   arrived.  If TLS is\
    \ used to protect DDP/RDMAP traffic, then TCP must\n   gather all out-of-order\
    \ packets before TLS can decrypt them.  Only\n   after this is done can RDMAP/DDP\
    \ place them into the ULP buffer.\n   Thus, one of the primary features of DDP/RDMAP\
    \ - enabling\n   implementations to have a flow-through architecture with little\
    \ to no\n   buffering - cannot be achieved if TLS is used to protect the data\n\
    \   stream.\n   If TLS is layered on top of RDMAP or DDP, TLS does not protect\
    \ the\n   RDMAP and/or DDP headers.  Thus, a man-in-the-middle attack can still\n\
    \   occur by modifying the RDMAP/DDP header to place the data into the\n   wrong\
    \ buffer, thus effectively corrupting the data stream.\n   For these reasons,\
    \ it is not RECOMMENDED that TLS be layered on top\n   of RDMAP or DDP.\n"
- title: 5.4.3.  DTLS and RDDP
  contents:
  - "5.4.3.  DTLS and RDDP\n   DTLS [DTLS] provides security services for datagram\
    \ protocols,\n   including unreliable datagram protocols.  These services include\n\
    \   anti-replay based on a mechanism adapted from IPsec that is intended\n   to\
    \ operate on packets as they are received from the network.  For\n   these and\
    \ other reasons, DTLS is best applied to RDDP by employing\n   DTLS beneath TCP,\
    \ yielding a layering of RDDP over TCP over DTLS over\n   UDP/IP.  Such a layering\
    \ inserts DTLS at roughly the same level in\n   the protocol stack as IPsec, making\
    \ DTLS's security services an\n   alternative to IPsec's services from an RDDP\
    \ standpoint.\n   For RDDP, IPsec is the better choice for a security framework,\
    \ and\n   hence is mandatory-to-implement (as specified elsewhere in this\n  \
    \ document).  An important contributing factor to the specification of\n   IPsec\
    \ rather than DTLS is that the non-RDDP versions of two initial\n   adopters of\
    \ RDDP (iSCSI [iSCSI][iSER] and NFSv4 [NFSv4][NFSv4.1]) are\n   compatible with\
    \ IPsec but neither of these protocols currently uses\n   either TLS or DTLS.\
    \  For the specific case of iSCSI, IPsec is the\n   basis for mandatory-to-implement\
    \ security services [RFC3723].\n   Therefore, this document and the RDDP protocol\
    \ specifications contain\n   mandatory implementation requirements for IPsec rather\
    \ than for DTLS.\n"
- title: 5.4.4.  ULPs That Provide Security
  contents:
  - "5.4.4.  ULPs That Provide Security\n   ULPs that provide integrated security\
    \ but wish to leverage lower-\n   layer protocol security, should be aware of\
    \ security concerns around\n   correlating a specific channel's security mechanisms\
    \ to the\n   authentication performed by the ULP.  See [NFSv4CHANNEL] for\n  \
    \ additional information on a promising approach called \"channel\n   binding\"\
    .  From [NFSv4CHANNEL]:\n      \"The concept of channel bindings allows applications\
    \ to prove that\n      the end-points of two secure channels at different network\
    \ layers\n      are the same by binding authentication at one channel to the\n\
    \      session protection at the other channel.  The use of channel\n      bindings\
    \ allows applications to delegate session protection to\n      lower layers, which\
    \ may significantly improve performance for some\n      applications.\"\n"
- title: 5.4.5.  Requirements for IPsec Encapsulation of DDP
  contents:
  - "5.4.5.  Requirements for IPsec Encapsulation of DDP\n   The IP Storage working\
    \ group has spent significant time and effort to\n   define the normative IPsec\
    \ requirements for IP Storage [RFC3723].\n   Portions of that specification are\
    \ applicable to a wide variety of\n   protocols, including the RDDP protocol suite.\
    \  In order not to\n   replicate this effort, an RNIC implementation MUST follow\
    \ the\n   requirements defined in RFC 3723, Section 2.3 and Section 5,\n   including\
    \ the associated normative references for those sections.\n   Note that this means\
    \ that support for IPSEC ESP mode is normative.\n   Additionally, since IPsec\
    \ acceleration hardware may only be able to\n   handle a limited number of active\
    \ IKE Phase 2 SAs, Phase 2 delete\n   messages may be sent for idle SAs as a means\
    \ of keeping the number of\n   active Phase 2 SAs to a minimum.  The receipt of\
    \ an IKE Phase 2\n   delete message MUST NOT be interpreted as a reason for tearing\
    \ down a\n   DDP/RDMA Stream.  Rather, it is preferable to leave the Stream up,\n\
    \   and if additional traffic is sent on it, to bring up another IKE\n   Phase\
    \ 2 SA to protect it.  This avoids the potential for continually\n   bringing\
    \ Streams up and down.\n   Note that there are serious security issues if IPsec\
    \ is not\n   implemented end-to-end.  For example, if IPsec is implemented as\
    \ a\n   tunnel in the middle of the network, any hosts between the Peer and\n\
    \   the IPsec tunneling device can freely attack the unprotected Stream.\n   The\
    \ IPsec requirements for RDDP are based on the version of IPsec\n   specified\
    \ in RFC 2401 [RFC2401] and related RFCs, as profiled by RFC\n   3723 [RFC3723],\
    \ despite the existence of a newer version of IPsec\n   specified in RFC 4301\
    \ [RFC4301] and related RFCs.  One of the\n   important early applications of\
    \ the RDDP protocols is their use with\n   iSCSI [iSER]; RDDP's IPsec requirements\
    \ follow those of IPsec in\n   order to facilitate that usage by allowing a common\
    \ profile of IPsec\n   to be used with iSCSI and the RDDP protocols.  In the future,\
    \ RFC\n   3723 may be updated to the newer version of IPsec; the IPsec security\n\
    \   requirements of any such update should apply uniformly to iSCSI and\n   the\
    \ RDDP protocols.\n"
- title: 6.  Attacks from Remote Peers
  contents:
  - "6.  Attacks from Remote Peers\n   This section describes remote attacks that\
    \ are possible against the\n   RDMA system defined in Figure 1 - RDMA Security\
    \ Model and the RNIC\n   Engine resources defined in Section 2.2.  The analysis\
    \ includes a\n   detailed description of each attack, what is being attacked,\
    \ and a\n   description of the countermeasures that can be taken to thwart the\n\
    \   attack.\n   The attacks are classified into five categories: Spoofing, Tampering,\n\
    \   Information Disclosure, Denial of Service (DoS) attacks, and\n   Elevation\
    \ of Privileges.  As mentioned previously, tampering is any\n   modification of\
    \ the legitimate traffic (machine internal or network).\n   A spoofing attack\
    \ is a special case of tampering where the attacker\n   falsifies an identity\
    \ of the Remote Peer (identity can be an IP\n   address, machine name, ULP level\
    \ identity, etc.).\n"
- title: 6.1.  Spoofing
  contents:
  - "6.1.  Spoofing\n   This section analyzes the various types of spoofing attacks\n\
    \   applicable to RDMAP and DDP.  Spoofing attacks can be launched by the\n  \
    \ Remote Peer or by a network-based attacker.  For countermeasures\n   against\
    \ a network-based attacker, see Section 5, Attacks That Can Be\n   Mitigated with\
    \ End-to-End Security.\n"
- title: 6.1.1.  Using an STag on a Different Stream
  contents:
  - "6.1.1.  Using an STag on a Different Stream\n   One style of attack from the\
    \ Remote Peer is for it to attempt to use\n   STag values that it is not authorized\
    \ to use.  Note that if the\n   Remote Peer sends an invalid STag to the Local\
    \ Peer, per the DDP and\n   RDMAP specifications, the Stream must be torn down.\
    \  Thus, the threat\n   exists if an STag has been enabled for Remote Access on\
    \ one Stream\n   and a Remote Peer is able to use it on an unrelated Stream. \
    \ If the\n   attack is successful, the attacker could potentially be able to\n\
    \   either perform RDMA Read operations to read the contents of the\n   associated\
    \ Data Buffer, perform RDMA Write operations to modify the\n   contents of the\
    \ associated data buffer, or invalidate the STag to\n   disable further access\
    \ to the buffer.\n   An attempt by a Remote Peer to access a buffer with an STag\
    \ on a\n   different Stream in the same Protection Domain may or may not be an\n\
    \   attack, depending on whether resource sharing is intended (i.e.,\n   whether\
    \ the Streams shared Partial Mutual Trust).  For some ULPs,\n   using an STag\
    \ on multiple Streams within the same Protection Domain\n   could be desired behavior.\
    \  For other ULPs, attempting to use an STag\n   on a different Stream could be\
    \ considered an attack.  Since this\n   varies by ULP, a ULP typically would need\
    \ to be able to control the\n   scope of the STag.\n   In the case where an implementation\
    \ does not share resources between\n   Streams (including STags), this attack\
    \ can be defeated by assigning\n   each Stream to a different Protection Domain.\
    \  Before allowing remote\n   access to the buffer, the Protection Domain of the\
    \ Stream where the\n   access attempt was made is matched against the Protection\
    \ Domain of\n   the STag.  If the Protection Domains do not match, access to the\n\
    \   buffer is denied, an error is generated, and the RDMAP Stream\n   associated\
    \ with the attacking Stream is terminated.\n   For implementations that share\
    \ resources between multiple Streams, it\n   may not be practical to separate\
    \ each Stream into its own Protection\n   Domain.  In this case, the ULP can still\
    \ limit the scope of any of\n   the STags to a single Stream (if it is enabling\
    \ it for remote\n   access).  If the STag scope has been limited to a single Stream,\
    \ any\n   attempt to use that STag on a different Stream will result in an\n \
    \  error, and the RDMAP Stream is terminated.\n   Thus, for implementations that\
    \ do not share STags between Streams,\n   each Stream MUST either be in a separate\
    \ Protection Domain or the\n   scope of an STag MUST be limited to a single Stream.\n\
    \   An RNIC MUST ensure that a specific Stream in a specific Protection\n   Domain\
    \ cannot access an STag in a different Protection Domain.\n   An RNIC MUST ensure\
    \ that, if an STag is limited in scope to a single\n   Stream, no other Stream\
    \ can use the STag.\n   An additional issue may be unintended sharing of STags\
    \ (i.e., a bug\n   in the ULP) or a bug in the Remote Peer that causes an off-by-one\n\
    \   STag to be used.  For additional protection, an implementation should\n  \
    \ allocate STags in such a fashion that it is difficult to predict the\n   next\
    \ allocated STag number, and also ensure that STags are reused at\n   as slow\
    \ a rate as possible.  Any allocation method that would lead to\n   intentional\
    \ or unintentional reuse of an STag by the peer should be\n   avoided (e.g., a\
    \ method that always starts with a given STag and\n   monotonically increases\
    \ it for each new allocation, or a method that\n   always uses the same STag for\
    \ each operation).\n"
- title: 6.2.  Tampering
  contents:
  - "6.2.  Tampering\n   A Remote Peer or a network-based attacker can attempt to\
    \ tamper with\n   the contents of Data Buffers on a Local Peer that have been\
    \ enabled\n   for remote write access.  The types of tampering attacks from a\n\
    \   Remote Peer are outlined in the sections that follow.  For\n   countermeasures\
    \ against a network-based attacker, see Section 5,\n   Attacks That Can Be Mitigated\
    \ with End-to-End Security.\n"
- title: 6.2.1.  Buffer Overrun - RDMA Write or Read Response
  contents:
  - "6.2.1.  Buffer Overrun - RDMA Write or Read Response\n   This attack is an attempt\
    \ by the Remote Peer to perform an RDMA Write\n   or RDMA Read Response to memory\
    \ outside of the valid length range of\n   the Data Buffer enabled for remote\
    \ write access.  This attack can\n   occur even when no resources are shared across\
    \ Streams.  This issue\n   can also arise if the ULP has a bug.\n   The countermeasure\
    \ for this type of attack must be in the RNIC\n   implementation, leveraging the\
    \ STag.  When the local ULP specifies to\n   the RNIC the base address and the\
    \ umber of bytes in the buffer that\n   it wishes to make accessible, the RNIC\
    \ must ensure that the base and\n   bounds check are applied to any access to\
    \ the buffer referenced by\n   the STag before the STag is enabled for access.\
    \  When an RDMA data\n   transfer operation (which includes an STag) arrives on\
    \ a Stream, a\n   base and bounds byte granularity access check must be performed\
    \ to\n   ensure that the operation accesses only memory locations within the\n\
    \   buffer described by that STag.\n   Thus an RNIC implementation MUST ensure\
    \ that a Remote Peer is not\n   able to access memory outside of the buffer specified\
    \ when the STag\n   was enabled for remote access.\n"
- title: 6.2.2.  Modifying a Buffer after Indication
  contents:
  - "6.2.2.  Modifying a Buffer after Indication\n   This attack can occur if a Remote\
    \ Peer attempts to modify the\n   contents of an STag referenced buffer by performing\
    \ an RDMA Write or\n   an RDMA Read Response after the Remote Peer has indicated\
    \ to the\n   Local Peer or local ULP (by a variety of means) that the STag Data\n\
    \   Buffer contents are ready for use.  This attack can occur even when\n   no\
    \ resources are shared across Streams.  Note that a bug in a Remote\n   Peer,\
    \ or network-based tampering, could also result in this problem.\n   For example,\
    \ assume that the STag referenced buffer contains ULP\n   control information\
    \ as well as ULP payload, and the ULP sequence of\n   operation is to first validate\
    \ the control information and then\n   perform operations on the control information.\
    \  If the Remote Peer\n   can perform an additional RDMA Write or RDMA Read Response\
    \ (thus,\n   changing the buffer) after the validity checks have been completed\n\
    \   but before the control data is operated on, the Remote Peer could\n   force\
    \ the ULP down operational paths that were never intended.\n   The local ULP can\
    \ protect itself from this type of attack by revoking\n   remote access when the\
    \ original data transfer has completed and\n   before it validates the contents\
    \ of the buffer.  The local ULP can do\n   this either by explicitly revoking\
    \ remote access rights for the STag\n   when the Remote Peer indicates the operation\
    \ has completed, or by\n   checking to make sure the Remote Peer invalidated the\
    \ STag through\n   the RDMAP Remote Invalidate capability.  If the Remote Peer\
    \ did not\n   invalidate the STag, the local ULP then explicitly revokes the STag\n\
    \   remote access rights.  (See Section 6.4.5, Remote Invalidate an STag\n   Shared\
    \ on Multiple Streams for a definition of Remote Invalidate.)\n   The local ULP\
    \ SHOULD follow the above procedure to protect the buffer\n   before it validates\
    \ the contents of the buffer (or uses the buffer in\n   any way).\n   An RNIC\
    \ MUST ensure that network packets using the STag for a\n   previously Advertised\
    \ Buffer can no longer modify the buffer after\n   the ULP revokes remote access\
    \ rights for the specific STag.\n"
- title: 6.2.3.  Multiple STags to Access the Same Buffer
  contents:
  - "6.2.3.  Multiple STags to Access the Same Buffer\n   See Section 6.3.6 Using\
    \ Multiple STags That Alias to the Same Buffer,\n   for this analysis.\n"
- title: 6.3.  Information Disclosure
  contents:
  - "6.3.  Information Disclosure\n   The main potential source for information disclosure\
    \ is through a\n   local buffer that has been enabled for remote access.  If the\
    \ buffer\n   can be probed by a Remote Peer on another Stream, then there is\n\
    \   potential for information disclosure.\n   The potential attacks that could\
    \ result in unintended information\n   disclosure and countermeasures are detailed\
    \ in the following\n   sections.\n"
- title: 6.3.1.  Probing Memory Outside of the Buffer Bounds
  contents:
  - "6.3.1.  Probing Memory Outside of the Buffer Bounds\n   This is essentially the\
    \ same attack as described in Section 6.2.1,\n   Buffer Overrun - RDMA Write or\
    \ Read Response, except that an RDMA\n   Read Request is used to mount the attack.\
    \  The same countermeasure\n   applies.\n"
- title: 6.3.2.  Using RDMA Read to Access Stale Data
  contents:
  - "6.3.2.  Using RDMA Read to Access Stale Data\n   If a buffer is being used for\
    \ some combination of reads and writes\n   (either remote or local), and is exposed\
    \ to a Remote Peer with at\n   least remote read access rights before it is initialized\
    \ with the\n   correct data, there is a potential race condition where the Remote\n\
    \   Peer can view the prior contents of the buffer.  This becomes a\n   security\
    \ issue if the prior contents of the buffer were not intended\n   to be shared\
    \ with the Remote Peer.\n   To eliminate this race condition, the local ULP SHOULD\
    \ ensure that no\n   stale data is contained in the buffer before remote read\
    \ access\n   rights are granted (this can be done by zeroing the contents of the\n\
    \   memory, for example).  This ensures that the Remote Peer cannot\n   access\
    \ the buffer until the stale data has been removed.\n"
- title: 6.3.3.  Accessing a Buffer after the Transfer
  contents:
  - "6.3.3.  Accessing a Buffer after the Transfer\n   If the Remote Peer has remote\
    \ read access to a buffer and, by some\n   mechanism, tells the local ULP that\
    \ the transfer has been completed,\n   but the local ULP does not disable remote\
    \ access to the buffer before\n   modifying the data, it is possible for the Remote\
    \ Peer to retrieve\n   the new data.\n   This is similar to the attack defined\
    \ in Section 6.2.2, Modifying a\n   Buffer after Indication.  The same countermeasures\
    \ apply.  In\n   addition, the local ULP SHOULD grant remote read access rights\
    \ only\n   for the amount of time needed to retrieve the data.\n"
- title: 6.3.4.  Accessing Unintended Data with a Valid STag
  contents:
  - "6.3.4.  Accessing Unintended Data with a Valid STag\n   If the ULP enables remote\
    \ access to a buffer using an STag that\n   references the entire buffer, but\
    \ intends only a portion of the\n   buffer to be accessed, it is possible for\
    \ the Remote Peer to access\n   the other parts of the buffer anyway.\n   To prevent\
    \ this attack, the ULP SHOULD set the base and bounds of the\n   buffer when the\
    \ STag is initialized to expose only the data to be\n   retrieved.\n"
- title: 6.3.5.  RDMA Read into an RDMA Write Buffer
  contents:
  - "6.3.5.  RDMA Read into an RDMA Write Buffer\n   One form of disclosure can occur\
    \ if the access rights on the buffer\n   enabled remote read, when only remote\
    \ write access was intended.  If\n   the buffer contained ULP data, or data from\
    \ a transfer on an\n   unrelated Stream, the Remote Peer could retrieve the data\
    \ through an\n   RDMA Read operation.  Note that an RNIC implementation is not\n\
    \   required to support STags that have both read and write access.\n   The most\
    \ obvious countermeasure for this attack is to not grant\n   remote read access\
    \ if the buffer is intended to be write-only.  Then\n   the Remote Peer would\
    \ not be able to retrieve data associated with\n   the buffer.  An attempt to\
    \ do so would result in an error and the\n   RDMAP Stream associated with the\
    \ Stream would be terminated.\n   Thus, if a ULP only intends a buffer to be exposed\
    \ for remote write\n   access, it MUST set the access rights to the buffer to\
    \ only enable\n   remote write access.  Note that this requirement is not meant\
    \ to\n   restrict the use of zero-length RDMA Reads.  Zero-length RDMA Reads\n\
    \   do not expose ULP data.  Because they are intended to be used as a\n   mechanism\
    \ to ensure that all RDMA Writes have been received, and do\n   not even require\
    \ a valid STag, their use is permitted even if a\n   buffer has only been enabled\
    \ for write access.\n"
- title: 6.3.6.  Using Multiple STags That Alias to the Same Buffer
  contents:
  - "6.3.6.  Using Multiple STags That Alias to the Same Buffer\n   Multiple STags\
    \ that alias to the same buffer at the same time can\n   result in unintentional\
    \ information disclosure if the STags are used\n   by different, mutually untrusted\
    \ Remote Peers.  This model applies\n   specifically to client/server communication,\
    \ where the server is\n   communicating with multiple clients, each of which do\
    \ not mutually\n   trust each other.\n   If only read access is enabled, then\
    \ the local ULP has complete\n   control over information disclosure.  Thus, a\
    \ server that intended to\n   expose the same data (i.e., buffer) to multiple\
    \ clients by using\n   multiple STags to the same buffer creates no new security\
    \ issues\n   beyond what has already been described in this document.  Note that\n\
    \   if the server did not intend to expose the same data to the clients,\n   it\
    \ should use separate buffers for each client (and separate STags).\n   When one\
    \ STag has remote read access enabled and a different STag has\n   remote write\
    \ access enabled to the same buffer, it is possible for\n   one Remote Peer to\
    \ view the contents that have been written by\n   another Remote Peer.\n   If\
    \ both STags have remote write access enabled and the two Remote\n   Peers do\
    \ not mutually trust each other, it is possible for one Remote\n   Peer to overwrite\
    \ the contents that have been written by the other\n   Remote Peer.\n   Thus,\
    \ a ULP with multiple Remote Peers that do not share Partial\n   Mutual Trust\
    \ MUST NOT grant write access to the same buffer through\n   different STags.\
    \  A buffer should be exposed to only one untrusted\n   Remote Peer at a time\
    \ to ensure that no information disclosure or\n   information tampering occurs\
    \ between peers.\n"
- title: 6.4.  Denial of Service (DOS)
  contents:
  - "6.4.  Denial of Service (DOS)\n   A DOS attack is one of the primary security\
    \ risks of RDMAP.  This is\n   because RNIC resources are valuable and scarce,\
    \ and many ULP\n   environments require communication with untrusted Remote Peers.\
    \  If\n   the Remote Peer can be authenticated or the ULP payload encrypted,\n\
    \   clearly, the DOS profile can be reduced.  For the purposes of this\n   analysis,\
    \ it is assumed that the RNIC must be able to operate in\n   untrusted environments,\
    \ which are open to DOS-style attacks.\n   Denial of service attacks against RNIC\
    \ resources are not the typical\n   unknown party spraying packets at a random\
    \ host (such as a TCP SYN\n   attack).  Because the connection/Stream must be\
    \ fully established\n   (e.g., a 3-message transport layer handshake has occurred),\
    \ the\n   attacker must be able to both send and receive messages over that\n\
    \   connection/Stream, or be able to guess a valid packet on an existing\n   RDMAP\
    \ Stream.\n   This section outlines the potential attacks and the countermeasures\n\
    \   available for dealing with each attack.\n"
- title: 6.4.1.  RNIC Resource Consumption
  contents:
  - "6.4.1.  RNIC Resource Consumption\n   This section covers attacks that fall into\
    \ the general category of a\n   local ULP attempting to unfairly allocate scarce\
    \ (i.e., bounded) RNIC\n   resources.  The local ULP may be attempting to allocate\
    \ resources on\n   its own behalf, or on behalf of a Remote Peer.  Resources that\
    \ fall\n   into this category include Protection Domains, Stream Context Memory,\n\
    \   Translation and Protection Tables, and STag namespace.  These can be\n   due\
    \ to attacks by currently active local ULPs or ones that allocated\n   resources\
    \ earlier but are now idle.\n   This type of attack can occur regardless of whether\
    \ resources are\n   shared across Streams.\n   The allocation of all scarce resources\
    \ MUST be placed under the\n   control of a Privileged Resource Manager.  This\
    \ allows the Privileged\n   Resource Manager to:\n   *   prevent a local ULP from\
    \ allocating more than its fair share of\n       resources.\n   *   detect if\
    \ a Remote Peer is attempting to launch a DOS attack by\n       attempting to\
    \ create an excessive number of Streams (with\n       associated resources) and\
    \ take corrective action (such as\n       refusing the request or applying network\
    \ layer filters against\n       the Remote Peer).\n   This analysis assumes that\
    \ the Resource Manager is responsible for\n   handing out Protection Domains,\
    \ and that RNIC implementations will\n   provide enough Protection Domains to\
    \ allow the Resource Manager to be\n   able to assign a unique Protection Domain\
    \ for each unrelated,\n   untrusted local ULP (for a bounded, reasonable number\
    \ of local ULPs).\n   This analysis further assumes that the Resource Manager\
    \ implements\n   policies to ensure that untrusted local ULPs are not able to\
    \ consume\n   all the Protection Domains through a DOS attack.  Note that\n  \
    \ Protection Domain consumption cannot result from a DOS attack\n   launched by\
    \ a Remote Peer, unless a local ULP is acting on the Remote\n   Peer's behalf.\n"
- title: 6.4.2.  Resource Consumption by Idle ULPs
  contents:
  - "6.4.2.  Resource Consumption by Idle ULPs\n   The simplest form of a DOS attack,\
    \ given a fixed amount of resources,\n   is for the Remote Peer to create an RDMAP\
    \ Stream to a Local Peer,\n   request dedicated resources, and then do no actual\
    \ work.  This allows\n   the Remote Peer to be very light weight (i.e., only negotiate\n\
    \   resources, but do no data transfer) and consumes a disproportionate\n   amount\
    \ of resources at the Local Peer.\n   A general countermeasure for this style\
    \ of attack is to monitor\n   active RDMAP Streams and, if resources are getting\
    \ low, to reap the\n   resources from RDMAP Streams that are not transferring\
    \ data and\n   possibly terminate the Stream.  This would presumably be under\n\
    \   administrative control.\n   Refer to Section 6.4.1 for the analysis and countermeasures\
    \ for this\n   style of attack on the following RNIC resources: Stream Context\n\
    \   Memory, Page Translation Tables, and STag namespace.\n   Note that some RNIC\
    \ resources are not at risk of this type of attack\n   from a Remote Peer because\
    \ an attack requires the Remote Peer to send\n   messages in order to consume\
    \ the resource.  Receive Data Buffers,\n   Completion Queue, and RDMA Read Request\
    \ Queue resources are examples.\n   These resources are, however, at risk from\
    \ a local ULP that attempts\n   to allocate resources, then goes idle.  This could\
    \ also be created if\n   the ULP negotiates the resource levels with the Remote\
    \ Peer, which\n   causes the Local Peer to consume resources; however, the Remote\
    \ Peer\n   never sends data to consume them.  The general countermeasure\n   described\
    \ in this section can be used to free resources allocated by\n   an idle Local\
    \ Peer.\n"
- title: 6.4.3.  Resource Consumption by Active ULPs
  contents:
  - "6.4.3.  Resource Consumption by Active ULPs\n   This section describes DOS attacks\
    \ from Local and Remote Peers that\n   are actively exchanging messages.  Attacks\
    \ on each RDMA NIC resource\n   are examined and specific countermeasures are\
    \ identified.  Note that\n   attacks on Stream Context Memory, Page Translation\
    \ Tables, and STag\n   namespace are covered in Section 6.4.1, RNIC Resource Consumption,\
    \ so\n   they are not included here.\n"
- title: 6.4.3.1.  Multiple Streams Sharing Receive Buffers
  contents:
  - "6.4.3.1.  Multiple Streams Sharing Receive Buffers\n   The Remote Peer can attempt\
    \ to consume more than its fair share of\n   receive Data Buffers (i.e., Untagged\
    \ Buffers for DDP or Send Type\n   Messages for RDMAP) if receive buffers are\
    \ shared across multiple\n   Streams.\n   If resources are not shared across multiple\
    \ Streams, then this attack\n   is not possible because the Remote Peer will not\
    \ be able to consume\n   more buffers than were allocated to the Stream.  The\
    \ worst case\n   scenario is that the Remote Peer can consume more receive buffers\n\
    \   than the local ULP allowed, resulting in no buffers being available,\n   which\
    \ could cause the Remote Peer's Stream to the Local Peer to be\n   torn down,\
    \ and all allocated resources to be released.\n   If local receive Data Buffers\
    \ are shared among multiple Streams, then\n   the Remote Peer can attempt to consume\
    \ more than its fair share of\n   the receive buffers, causing a different Stream\
    \ to be short of\n   receive buffers, and thus, possibly causing the other Stream\
    \ to be\n   torn down.  For example, if the Remote Peer sent enough one-byte\n\
    \   Untagged Messages, they might be able to consume all locally shared,\n   receive\
    \ queue resources with little effort on their part.\n   One method the Local Peer\
    \ could use is to recognize that a Remote\n   Peer is attempting to use more than\
    \ its fair share of resources and\n   terminate the Stream (causing the allocated\
    \ resources to be\n   released).  However, if the Local Peer is sufficiently slow,\
    \ it may\n   be possible for the Remote Peer to still mount a denial of service\n\
    \   attack.  One countermeasure that can protect against this attack is\n   implementing\
    \ a low-water notification.  The low-water notification\n   alerts the ULP if\
    \ the number of buffers in the receive queue is less\n   than a threshold.\n \
    \  If all the following conditions are true, then the Local Peer or\n   local\
    \ ULP can size the amount of local receive buffers posted on the\n   receive queue\
    \ to ensure a DOS attack can be stopped.\n   *   A low-water notification is enabled,\
    \ and\n   *   The Local Peer is able to bound the amount of time that it takes\n\
    \       to replenish receive buffers, and\n   *   The Local Peer maintains statistics\
    \ to determine which Remote\n       Peer is consuming buffers.\n   The above conditions\
    \ enable the low-water notification to arrive\n   before resources are depleted,\
    \ and thus, the Local Peer or local ULP\n   can take corrective action (e.g.,\
    \ terminate the Stream of the\n   attacking Remote Peer).\n   A different, but\
    \ similar, attack is if the Remote Peer sends a\n   significant number of out-of-order\
    \ packets and the RNIC has the\n   ability to use the ULP buffer (i.e., the Untagged\
    \ Buffer for DDP or\n   the buffer consumed by a Send Type Message for RDMAP)\
    \ as a reassembly\n   buffer.  In this case, the Remote Peer can consume a significant\n\
    \   number of ULP buffers, but never send enough data to enable the ULP\n   buffer\
    \ to be completed to the ULP.\n   An effective countermeasure is to create a high-water\
    \ notification\n   that alerts the ULP if there is more than a specified number\
    \ of\n   receive buffers \"in process\" (partially consumed, but not completed).\n\
    \   The notification is generated when more than the specified number of\n   buffers\
    \ are in process simultaneously on a specific Stream (i.e.,\n   packets have started\
    \ to arrive for the buffer, but the buffer has not\n   yet been delivered to the\
    \ ULP).\n   A different countermeasure is for the RNIC Engine to provide the\n\
    \   capability to limit the Remote Peer's ability to consume receive\n   buffers\
    \ on a per Stream basis.  Unfortunately, this requires a large\n   amount of state\
    \ to be tracked in each RNIC on a per Stream basis.\n   Thus, if an RNIC Engine\
    \ provides the ability to share receive buffers\n   across multiple Streams, the\
    \ combination of the RNIC Engine and the\n   Privileged Resource Manager MUST\
    \ be able to detect if the Remote Peer\n   is attempting to consume more than\
    \ its fair share of resources so\n   that the Local Peer or local ULP can apply\
    \ countermeasures to detect\n   and prevent the attack.\n"
- title: 6.4.3.2.  Remote or Local Peer Attacking a Shared CQ
  contents:
  - "6.4.3.2.  Remote or Local Peer Attacking a Shared CQ\n   For an overview of the\
    \ shared CQ attack model, see Section 7.1.\n   The Remote Peer can attack a shared\
    \ CQ by consuming more than its\n   fair share of CQ entries by using one of the\
    \ following methods:\n   *   The ULP protocol allows the Remote Peer to cause\
    \ the local ULP to\n       reserve a specified number of CQ entries, possibly\
    \ leaving\n       insufficient entries for other Streams that are sharing the\
    \ CQ.\n   *   If the Remote Peer, Local Peer, or local ULP (or any combination)\n\
    \       can attack the CQ by overwhelming the CQ with completions, then\n    \
    \   completion processing on other Streams sharing that Completion\n       Queue\
    \ can be affected (e.g., the Completion Queue overflows and\n       stops functioning).\n\
    \   The first method of attack can be avoided if the ULP does not allow a\n  \
    \ Remote Peer to reserve CQ entries, or if there is a trusted\n   intermediary,\
    \ such as a Privileged Resource Manager.  Unfortunately,\n   it is often unrealistic\
    \ not to allow a Remote Peer to reserve CQ\n   entries, particularly if the number\
    \ of completion entries is\n   dependent on other ULP negotiated parameters, such\
    \ as the amount of\n   buffering required by the ULP.  Thus, an implementation\
    \ MUST\n   implement a Privileged Resource Manager to control the allocation of\n\
    \   CQ entries.  See Section 2.1, Components, for a definition of a\n   Privileged\
    \ Resource Manager.\n   One way that a Local or Remote Peer can attempt to overwhelm\
    \ a CQ\n   with completions is by sending minimum length RDMAP/DDP Messages to\n\
    \   cause as many completions (receive completions for the Remote Peer,\n   send\
    \ completions for the Local Peer) per second as possible.  If it\n   is the Remote\
    \ Peer attacking, and we assume that the Local Peer's\n   receive queue(s) do\
    \ not run out of receive buffers (if they do, then\n   this is a different attack,\
    \ documented in Section 6.4.3.1 Multiple\n   Streams Sharing Receive Buffers),\
    \ then it might be possible for the\n   Remote Peer to consume more than its fair\
    \ share of Completion Queue\n   entries.  Depending upon the CQ implementation,\
    \ this could either\n   cause the CQ to overflow (if it is not large enough to\
    \ handle all the\n   completions generated) or for another Stream not to be able\
    \ to\n   generate CQ entries (if the RNIC had flow control on generation of CQ\n\
    \   entries into the CQ).  In either case, the CQ will stop functioning\n   correctly,\
    \ and any Streams expecting completions on the CQ will stop\n   functioning.\n\
    \   This attack can occur regardless of whether all the Streams\n   associated\
    \ with the CQ are in the same or different Protection\n   Domains - the key issue\
    \ is that the number of Completion Queue\n   entries is less than the number of\
    \ all outstanding operations that\n   can cause a completion.\n   The Local Peer\
    \ can protect itself from this type of attack using\n   either of the following\
    \ methods:\n   *   Size the CQ to the appropriate level, as specified below (note\n\
    \       that if the CQ currently exists and needs to be resized, resizing\n  \
    \     the CQ is not required to succeed in all cases, so the CQ resize\n     \
    \  should be done before sizing the Send Queue and Receive Queue on\n       the\
    \ Stream), OR\n   *   Grant fewer resources than the Remote Peer requested (not\n\
    \       supplying the number of Receive Data Buffers requested).\n   The proper\
    \ sizing of the CQ is dependent on whether the local ULP(s)\n   will post as many\
    \ resources to the various queues as the size of the\n   queue enables.  If the\
    \ local ULP(s) can be trusted to post a number\n   of resources that is smaller\
    \ than the size of the specific resource's\n   queue, then a correctly sized CQ\
    \ means that the CQ is large enough to\n   hold completion status for all the\
    \ outstanding Data Buffers (both\n   send and receive buffers), or:\n        \
    \    CQ_MIN_SIZE = SUM(MaxPostedOnEachRQ)\n                          + SUM(MaxPostedOnEachSRQ)\n\
    \                          + SUM(MaxPostedOnEachSQ)\n   Where:\n           MaxPostedOnEachRQ\
    \ = the maximum number of requests that\n                  can cause a completion\
    \ that will be posted on a\n                  specific Receive Queue.\n      \
    \     MaxPostedOnEachSRQ = the maximum number of requests that\n             \
    \     can cause a completion that will be posted on a\n                  specific\
    \ Shared Receive Queue.\n           MaxPostedOnEachSQ = the maximum number of\
    \ requests that\n                  can cause a completion that will be posted\
    \ on a\n                  specific Send Queue.\n   If the local ULP must be able\
    \ to completely fill the queues, or\n   cannot be trusted to observe a limit smaller\
    \ than the queues, then\n   the CQ must be sized to accommodate the maximum number\
    \ of operations\n   that it is possible to post at any one time.  Thus, the equation\n\
    \   becomes:\n            CQ_MIN_SIZE = SUM(SizeOfEachRQ)\n                  \
    \        + SUM(SizeOfEachSRQ)\n                          + SUM(SizeOfEachSQ)\n\
    \   Where:\n          SizeOfEachRQ = the maximum number of requests that\n   \
    \               can cause a completion that can ever be posted\n             \
    \     on a specific Receive Queue.\n          SizeOfEachSRQ = the maximum number\
    \ of requests that\n                  can cause a completion that can ever be\
    \ posted\n                  on a specific Shared Receive Queue.\n          SizeOfEachSQ\
    \ = the maximum number of requests that\n                  can cause a completion\
    \ that can ever be posted\n                  on a specific Send Queue.\n   MaxPosted*OnEach*Q\
    \ and SizeOfEach*Q vary on a per Stream or per\n   Shared Receive Queue basis.\n\
    \   If the ULP is sharing a CQ across multiple Streams that do not share\n   Partial\
    \ Mutual Trust, then the ULP MUST implement a mechanism to\n   ensure that the\
    \ Completion Queue does not overflow.  Note that it is\n   possible to share CQs\
    \ even if the Remote Peers accessing the CQs are\n   untrusted if either of the\
    \ above two formulas are implemented.  If\n   the ULP can be trusted not to post\
    \ more than MaxPostedOnEachRQ,\n   MaxPostedOnEachSRQ, and MaxPostedOnEachSQ,\
    \ then the first formula\n   applies.  If the ULP cannot be trusted to obey the\
    \ limit, then the\n   second formula applies.\n"
- title: 6.4.3.3.  Attacking the RDMA Read Request Queue
  contents:
  - "6.4.3.3.  Attacking the RDMA Read Request Queue\n   The RDMA Read Request Queue\
    \ can be attacked if the Remote Peer sends\n   more RDMA Read Requests than the\
    \ depth of the RDMA Read Request Queue\n   at the Local Peer.  If the RDMA Read\
    \ Request Queue is a shared\n   resource, this could corrupt the queue.  If the\
    \ queue is not shared,\n   then the worst case is that the current Stream is no\
    \ longer\n   functional (e.g., torn down).  One approach to solving the shared\n\
    \   RDMA Read Request Queue would be to create thresholds, similar to\n   those\
    \ described in Section 6.4.3.1, Multiple Streams Sharing Receive\n   Buffers.\
    \  A simpler approach is to not share RDMA Read Request Queue\n   resources among\
    \ Streams or to enforce hard limits of consumption per\n   Stream.  Thus, RDMA\
    \ Read Request Queue resource consumption MUST be\n   controlled by the Privileged\
    \ Resource Manager such that RDMAP/DDP\n   Streams that do not share Partial Mutual\
    \ Trust do not share RDMA Read\n   Request Queue resources.\n   If the issue is\
    \ a bug in the Remote Peer's implementation, but not a\n   malicious attack, the\
    \ issue can be solved by requiring the Remote\n   Peer's RNIC to throttle RDMA\
    \ Read Requests.  By properly configuring\n   the Stream at the Remote Peer through\
    \ a trusted agent, the RNIC can\n   be made not to transmit RDMA Read Requests\
    \ that exceed the depth of\n   the RDMA Read Request Queue at the Local Peer.\
    \  If the Stream is\n   correctly configured, and if the Remote Peer submits more\
    \ requests\n   than the Local Peer's RDMA Read Request Queue can handle, the\n\
    \   requests would be queued at the Remote Peer's RNIC until previous\n   requests\
    \ complete.  If the Remote Peer's Stream is not configured\n   correctly, the\
    \ RDMAP Stream is terminated when more RDMA Read\n   Requests arrive at the Local\
    \ Peer than the Local Peer can handle\n   (assuming that the prior paragraph's\
    \ recommendation is implemented).\n   Thus, an RNIC implementation SHOULD provide\
    \ a mechanism to cap the\n   number of outstanding RDMA Read Requests.  The configuration\
    \ of this\n   limit is outside the scope of this document.\n"
- title: 6.4.4.  Exercise of Non-Optimal Code Paths
  contents:
  - "6.4.4.  Exercise of Non-Optimal Code Paths\n   Another form of a DOS attack is\
    \ to attempt to exercise data paths\n   that can consume a disproportionate amount\
    \ of resources.  An example\n   might be if error cases are handled on a \"slow\
    \ path\" (consuming\n   either host or RNIC computational resources), and an attacker\n\
    \   generates excessive numbers of errors in an attempt to consume these\n   resources.\
    \  Note that for most RDMAP or DDP errors, the attacking\n   Stream will simply\
    \ be torn down.  Thus, for this form of attack to be\n   effective, the Remote\
    \ Peer needs to exercise data paths that do not\n   cause the Stream to be torn\
    \ down.\n   If an RNIC implementation contains \"slow paths\" that do not result\
    \ in\n   the tear down of the Stream, it is recommended that an implementation\n\
    \   provide the ability to detect the above condition and allow an\n   administrator\
    \ to act, including potentially administratively tearing\n   down the RDMAP Stream\
    \ associated with the Stream that is exercising\n   data paths, which consume\
    \ a disproportionate amount of resources.\n"
- title: 6.4.5.  Remote Invalidate an STag Shared on Multiple Streams
  contents:
  - "6.4.5.  Remote Invalidate an STag Shared on Multiple Streams\n   If a Local Peer\
    \ has enabled an STag for remote access, the Remote\n   Peer could attempt to\
    \ remotely invalidate the STag by using the RDMAP\n   Send with Invalidate or\
    \ Send with SE and Invalidate Message.  If the\n   STag is only valid on the current\
    \ Stream, then the only side effect\n   is that the Remote Peer can no longer\
    \ use the STag; thus, there are\n   no security issues.\n   If the STag is valid\
    \ across multiple Streams, then the Remote Peer\n   can prevent other Streams\
    \ from using that STag by using the Remote\n   Invalidate functionality.\n   Thus,\
    \ if RDDP Streams do not share Partial Mutual Trust (i.e., the\n   Remote Peer\
    \ may attempt to remotely invalidate the STag prematurely),\n   the ULP MUST NOT\
    \ enable an STag that would be valid across multiple\n   Streams.\n"
- title: 6.4.6.  Remote Peer Attacking an Unshared CQ
  contents:
  - "6.4.6.  Remote Peer Attacking an Unshared CQ\n   The Remote Peer can attack an\
    \ unshared CQ if the Local Peer does not\n   size the CQ correctly.  For example,\
    \ if the Local Peer enables the CQ\n   to handle completions of received buffers,\
    \ and the receive buffer\n   queue is longer than the Completion Queue, then an\
    \ overflow can\n   potentially occur.  The effect on the attacker's Stream is\n\
    \   catastrophic.  However, if an RNIC does not have the proper\n   protections\
    \ in place, then an attack to overflow the CQ can also\n   cause corruption and/or\
    \ termination of an unrelated Stream.  Thus, an\n   RNIC MUST ensure that if a\
    \ CQ overflows, any Streams that do not use\n   the CQ MUST remain unaffected.\n"
- title: 6.5.  Elevation of Privilege
  contents:
  - "6.5.  Elevation of Privilege\n   The RDMAP/DDP Security Architecture explicitly\
    \ differentiates between\n   three levels of privilege: Non-Privileged, Privileged,\
    \ and the\n   Privileged Resource Manager.  If a Non-Privileged ULP is able to\n\
    \   elevate its privilege level to a Privileged ULP, then mapping a\n   physical\
    \ address list to an STag can provide local and remote access\n   to any physical\
    \ address location on the node.  If a Privileged Mode\n   ULP is able to promote\
    \ itself to be a Resource Manager, then it is\n   possible for it to perform denial\
    \ of service type attacks where\n   substantial amounts of local resources could\
    \ be consumed.\n   In general, elevation of privilege is a local implementation\
    \ specific\n   issue and is thus outside the scope of this document.\n"
- title: 7.  Attacks from Local Peers
  contents:
  - "7.  Attacks from Local Peers\n   This section describes local attacks that are\
    \ possible against the\n   RDMA system defined in Figure 1 - RDMA Security Model\
    \ and the RNIC\n   Engine resources defined in Section 2.2.\n"
- title: 7.1.  Local ULP Attacking a Shared CQ
  contents:
  - "7.1.  Local ULP Attacking a Shared CQ\n   DOS attacks against a Shared Completion\
    \ Queue (CQ - see Section\n   2.2.6, Completion Queues) can be caused by either\
    \ the local ULP or\n   the Remote Peer if either attempts to cause more completions\
    \ than its\n   fair share of the number of entries; thus, potentially starving\n\
    \   another unrelated ULP such that no Completion Queue entries are\n   available.\n\
    \   A Completion Queue entry can potentially be maliciously consumed by a\n  \
    \ completion from the Send Queue or a completion from the Receive\n   Queue. \
    \ In the former, the attacker is the local ULP.  In the latter,\n   the attacker\
    \ is the Remote Peer.\n   A form of attack can occur where the local ULPs can\
    \ consume resources\n   on the CQ.  A local ULP that is slow to free resources\
    \ on the CQ by\n   not reaping the completion status quickly enough could stall\
    \ all\n   other local ULPs attempting to use that CQ.\n   For these reasons, an\
    \ RNIC MUST NOT enable sharing a CQ across ULPs\n   that do not share Partial\
    \ Mutual Trust.\n"
- title: 7.2.  Local Peer Attacking the RDMA Read Request Queue
  contents:
  - "7.2.  Local Peer Attacking the RDMA Read Request Queue\n   If RDMA Read Request\
    \ Queue resources are pooled across multiple\n   Streams, one attack is if the\
    \ local ULP attempts to unfairly allocate\n   RDMA Read Request Queue resources\
    \ for its Streams.  For example, a\n   local ULP attempts to allocate all available\
    \ resources on a specific\n   RDMA Read Request Queue for its Streams, thereby\
    \ denying the resource\n   to ULPs sharing the RDMA Read Request Queue.  The same\
    \ type of\n   argument applies even if the RDMA Read Request is not shared, but\
    \ a\n   local ULP attempts to allocate all the RNIC's resources when the\n   queue\
    \ is created.\n   Thus, access to interfaces that allocate RDMA Read Request Queue\n\
    \   entries MUST be restricted to a trusted Local Peer, such as a\n   Privileged\
    \ Resource Manager.  The Privileged Resource Manager SHOULD\n   prevent a local\
    \ ULP from allocating more than its fair share of\n   resources.\n"
- title: 7.3.  Local ULP Attacking the PTT and STag Mapping
  contents:
  - "7.3.  Local ULP Attacking the PTT and STag Mapping\n   If a Non-Privileged ULP\
    \ is able to directly manipulate the RNIC Page\n   Translation Tables (which translate\
    \ from an STag to a host address),\n   it is possible that the Non-Privileged\
    \ ULP could point the Page\n   Translation Table at an unrelated Stream's or ULP's\
    \ buffers and,\n   thereby, be able to gain access to information of the unrelated\n\
    \   Stream/ULP.\n   As discussed in Section 2, Architectural Model, introduction\
    \ of a\n   Privileged Resource Manager to arbitrate the mapping requests is an\n\
    \   effective countermeasure.  This enables the Privileged Resource\n   Manager\
    \ to ensure that a local ULP can only initialize the Page\n   Translation Table\
    \ (PTT) to point to its own buffers.\n   Thus, if Non-Privileged ULPs are supported,\
    \ the Privileged Resource\n   Manager MUST verify that the Non-Privileged ULP\
    \ has the right to\n   access a specific Data Buffer before allowing an STag for\
    \ which the\n   ULP has access rights to be associated with a specific Data Buffer.\n\
    \   This can be done when the Page Translation Table is initialized to\n   access\
    \ the Data Buffer or when the STag is initialized to point to a\n   group of Page\
    \ Translation Table entries, or both.\n"
- title: 8.  Security considerations
  contents:
  - "8.  Security considerations\n   Please see Sections 5, Attacks That Can be Mitigated\
    \ with End-to-End\n   Security; Section 6, Attacks from Remote Peers; and Section\
    \ 7,\n   Attacks from Local Peers, for a detailed analysis of attacks and\n  \
    \ normative countermeasures to mitigate the attacks.\n   Additionally, the appendices\
    \ provide a summary of the security\n   requirements for specific audiences. \
    \ Appendix A, ULP Issues for RDDP\n   Client/Server Protocols, provides a summary\
    \ of implementation issues\n   and requirements for applications that implement\
    \ a traditional\n   client/server style of interaction.  It provides additional\
    \ insight\n   and applicability of the normative text in Sections 5, 6, and 7.\n\
    \   Appendix B, Summary of RNIC and ULP Implementation Requirements,\n   provides\
    \ a convenient summary of normative requirements for\n   implementers.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   IANA considerations are not addressed by this document.\
    \  Any IANA\n   considerations resulting from the use of DDP or RDMA must be\n\
    \   addressed in the relevant standards.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [DDP]         Shah, H., Pinkerton, J., Recio,\
    \ R., and P. Culley,\n                 \"Direct Data Placement over Reliable Transports\"\
    , RFC\n                 5041, October 2007.\n   [RDMAP]       Recio, R., Culley,\
    \ P., Garcia, D., and J. Hilland, \"A\n                 Remote Direct Memory Access\
    \ Protocol Specification\",\n                 RFC 5040, October 2007.\n   [RFC2401]\
    \     Kent, S. and R. Atkinson, \"Security Architecture for\n                \
    \ the Internet Protocol\", RFC 2401, November 1998.\n   [RFC2402]     Kent, S.\
    \ and R. Atkinson, \"IP Authentication Header\",\n                 RFC 2402, November\
    \ 1998.\n   [RFC2406]     Kent, S. and R. Atkinson, \"IP Encapsulating Security\n\
    \                 Payload (ESP)\", RFC 2406, November 1998.\n   [RFC2409]    \
    \ Harkins, D. and D. Carrel, \"The Internet Key Exchange\n                 (IKE)\"\
    , RFC 2409, November 1998.\n   [RFC3723]     Aboba, B., Tseng, J., Walker, J.,\
    \ Rangan, V., and F.\n                 Travostino, \"Securing Block Storage Protocols\
    \ over IP\",\n                 RFC 3723, April 2004.\n   [RFC4960]     Stewart,\
    \ R., Ed., \"Stream Control Transmission\n                 Protocol\", RFC 4960,\
    \ September 2007.\n   [RFC793]      Postel, J., \"Transmission Control Protocol\"\
    , STD 7, RFC\n                 793, September 1981.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [RFC4301]     Kent, S. and K. Seo, \"Security\
    \ Architecture for the\n                 Internet Protocol\", RFC 4301, December\
    \ 2005.\n   [RFC4346]     Dierks, T. and E. Rescorla, \"The Transport Layer\n\
    \                 Security (TLS) Protocol Version 1.1\", RFC 4346, April\n   \
    \              2006.\n   [RFC4949]     Shirey, R., \"Internet Security Glossary,\
    \ Version 2\",\n                 RFC 4949, August 2007.\n   [APPLICABILITY]\n\
    \                 Bestler, C. and L. Coene, \"Applicability of Remote\n      \
    \           Direct Memory Access Protocol (RDMA) and Direct Data\n           \
    \      Placement (DDP)\", RFC 5045, October 2007.\n   [NFSv4CHANNEL]\n       \
    \          Williams, N., \"On the Use of Channel Bindings to Secure\n        \
    \         Channels\", Work in Progress, July 2004.\n   [VERBS-RDMAC] \"RDMA Protocol\
    \ Verbs Specification\", RDMA Consortium\n                 standard, April 2003,\
    \ <http://www.rdmaconsortium.org/\n                 home/draft-hilland-iwarp-verbs-v1.0-RDMAC.pdf>.\n\
    \   [VERBS-RDMAC-Overview]\n                 \"RDMA enabled NIC (RNIC) Verbs Overview\"\
    , slide\n                 presentation by Renato Recio, April 2003,\n        \
    \         <http://www.rdmaconsortium.org/home/\n                 RNIC_Verbs_Overview2.pdf>.\n\
    \   [RFC3552]     Rescorla, E. and B. Korver, \"Guidelines for Writing RFC\n \
    \                Text on Security Considerations\", BCP 72, RFC 3552,\n      \
    \           July 2003.\n   [INFINIBAND]  \"InfiniBand Architecture Specification\
    \ Volume 1\",\n                 release 1.2, InfiniBand Trade Association standard,\n\
    \                 <http://www.infinibandta.org/specs>.  Verbs are\n          \
    \       documented in chapter 11.\n   [DTLS]        Rescorla, E. and N. Modadugu,\
    \ \"Datagram Transport Layer\n                 Security\", RFC 4347, April 2006.\n\
    \   [iSCSI]       Satran, J., Meth, K., Sapuntzakis, C., Chadalapaka, M.,\n  \
    \               and E. Zeidner, \"Internet Small Computer Systems\n          \
    \       Interface (iSCSI)\", RFC 3720, April 2004.\n   [iSER]        Ko, M., Chadalapaka,\
    \ M., Hufferd, J., Elzur, U., Shah,\n                 H., and P. Thaler, \"Internet\
    \ Small Computer System\n                 Interface (iSCSI) Extensions for Remote\
    \ Direct Memory\n                 Access (RDMA)\", RFC 5046, October 2007.\n \
    \  [NFSv4]       Shepler, S., Callaghan, B., Robinson, D., Thurlow, R.,\n    \
    \             Beame, C., Eisler, M., and D. Noveck, \"Network File\n         \
    \        System (NFS) version 4 Protocol\", RFC 3530, April 2003.\n   [NFSv4.1]\
    \     Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed.,\n               \
    \  \"NFSv4 Minor Version 1\", Work in Progress, September\n                 2007.\n"
- title: 'Appendix A: ULP Issues for RDDP Client/Server Protocols'
  contents:
  - "Appendix A: ULP Issues for RDDP Client/Server Protocols\n   This section is a\
    \ normative appendix to the document that is focused\n   on client/server ULP\
    \ implementation requirements to ensure a secure\n   server implementation.\n\
    \   The prior sections outlined specific attacks and their\n   countermeasures.\
    \  This section summarizes the attacks and\n   countermeasures that have been\
    \ defined in the prior section, which\n   are applicable to creation of a secure\
    \ ULP (e.g., application)\n   server.  A ULP server is defined as a ULP that must\
    \ be able to\n   communicate with many clients that do not necessarily have a\
    \ trust\n   relationship with each other, and to ensure that each client cannot\n\
    \   attack another client through server interactions.  Further, the\n   server\
    \ may wish to use multiple Streams to communicate with a\n   specific client,\
    \ and those Streams may share mutual trust.  Note that\n   this section assumes\
    \ a compliant RNIC and Privileged Resource Manager\n   implementation - thus,\
    \ it focuses specifically on ULP server (e.g.,\n   application) implementation\
    \ issues.\n   All of the prior section's details on attacks and countermeasures\n\
    \   apply to the server; thus, requirements that are repeated in this\n   section\
    \ use non-normative \"must\", \"should\", and \"may\".  In some\n   cases, normative\
    \ SHOULD statements for the ULP from the main body of\n   this document are made\
    \ MUST statements for the ULP server because the\n   operating conditions can\
    \ be refined to make the motives for a SHOULD\n   inapplicable.  If a prior SHOULD\
    \ is changed to a MUST in this\n   section, it is explicitly noted and it uses\
    \ uppercase normative\n   statements.\n   The following list summarizes the relevant\
    \ attacks that clients can\n   mount on the shared server by re-stating the previous\
    \ normative\n   statements to be client/server specific.  Note that each\n   client/server\
    \ ULP may employ explicit RDMA Operations (RDMA Read,\n   RDMA Write) in differing\
    \ fashions.  Therefore, where appropriate,\n   \"Local ULP\", \"Local Peer\",\
    \ and \"Remote Peer\" are used in place of\n   \"server\" or \"client\", in order\
    \ to retain full generality of each\n   requirement.\n   *   Spoofing\n     *\
    \   Sections 5.1.1 to 5.1.3.  For protection against many forms of\n         spoofing\
    \ attacks, enable IPsec.\n     *   Section 6.1.1, Using an STag on a Different\
    \ Stream.  To ensure\n         that one client cannot access another client's\
    \ data via use of\n         the other client's STag, the server ULP must either\
    \ scope an\n         STag to a single Stream or use a unique Protection Domain\
    \ per\n         client.  If a single client has multiple Streams that share\n\
    \         Partial Mutual Trust, then the STag can be shared between the\n    \
    \     associated Streams by using a single Protection Domain among\n         the\
    \ associated Streams (see Section 5.4.4, ULPs That Provide\n         Security,\
    \ for additional issues).  To prevent unintended\n         sharing of STags within\
    \ the associated Streams, a server ULP\n         should use STags in such a fashion\
    \ that it is difficult to\n         predict the next allocated STag number.\n\
    \   *   Tampering\n     *   6.2.2 Modifying a Buffer after Indication.  Before\
    \ the local\n         ULP operates on a buffer that was written by the Remote\
    \ Peer\n         using an RDMA Write or RDMA Read, the local ULP MUST ensure the\n\
    \         buffer can no longer be modified by invalidating the STag for\n    \
    \     remote access (note that this is stronger than the SHOULD in\n         Section\
    \ 6.2.2).  This can be done either by explicitly revoking\n         remote access\
    \ rights for the STag when the Remote Peer\n         indicates the operation has\
    \ completed, or by checking to make\n         sure the Remote Peer Invalidated\
    \ the STag through the RDMAP\n         Invalidate capability.  If the Remote Peer\
    \ did not invalidate\n         the STag, the local ULP then explicitly revokes\
    \ the STag remote\n         access rights.\n   *   Information Disclosure\n  \
    \   *   6.3.2, Using RDMA Read to Access Stale Data.  In a general\n         purpose\
    \ server environment, there is no compelling rationale\n         not to require\
    \ a buffer to be initialized before remote read is\n         enabled (and an enormous\
    \ downside of unintentionally sharing\n         data). Thus, a local ULP MUST\
    \ (this is stronger than the SHOULD\n         in Section 6.3.2) ensure that no\
    \ stale data is contained in a\n         buffer before remote read access rights\
    \ are granted to a Remote\n         Peer (this can be done by zeroing the contents\
    \ of the memory,\n         for example).\n     *   6.3.3, Accessing a Buffer after\
    \ the Transfer.  This mitigation\n         is already covered by Section 6.2.2\
    \ (above).\n     *   6.3.4, Accessing Unintended Data with a Valid STag.  The\
    \ ULP\n         must set the base and bounds of the buffer when the STag is\n\
    \         initialized to expose only the data to be retrieved.\n     *   6.3.5,\
    \ RDMA Read into an RDMA Write Buffer.  If a peer only\n         intends a buffer\
    \ to be exposed for remote write access, it must\n         set the access rights\
    \ to the buffer to only enable remote write\n         access.\n     *   6.3.6,\
    \ Using Multiple STags That Alias to the Same Buffer.  The\n         requirement\
    \ in Section 6.1.1 (above) mitigates this attack.  A\n         server buffer is\
    \ exposed to only one client at a time to ensure\n         that no information\
    \ disclosure or information tampering occurs\n         between peers.\n     *\
    \   5.3, Network-Based Eavesdropping.  Confidentiality services\n         should\
    \ be enabled by the ULP if this threat is a concern.\n   *   Denial of Service\n\
    \     *   6.4.3.1, Multiple Streams Sharing Receive Buffers.  ULP memory\n   \
    \      footprint size can be important for some server ULPs.  If a\n         server\
    \ ULP is expecting significant network traffic from\n         multiple clients,\
    \ using a receive buffer queue per Stream where\n         there is a large number\
    \ of Streams can consume substantial\n         amounts of memory.  Thus, a receive\
    \ queue that can be shared by\n         multiple Streams is attractive.\n    \
    \     However, because of the attacks outlined in this section,\n         sharing\
    \ a single receive queue between multiple clients must\n         only be done\
    \ if a mechanism is in place to ensure that one\n         client cannot consume\
    \ receive buffers in excess of its limits,\n         as defined by each ULP. \
    \ For multiple Streams within a single\n         client ULP (which presumably\
    \ shared Partial Mutual Trust), this\n         added overhead may be avoided.\n\
    \     *   7.1 Local ULP Attacking a Shared CQ.  The normative RNIC\n         mitigations\
    \ require that the RNIC not enable sharing of a CQ if\n         the local ULPs\
    \ do not share Partial Mutual Trust.  Thus, while\n         the ULP is not allowed\
    \ to enable this feature in an unsafe\n         mode, if the two local ULPs share\
    \ Partial Mutual Trust, they\n         must behave in the following manner:\n\
    \         1) The sizing of the completion queue is based on the size of\n    \
    \     the receive queue and send queues, as documented in 6.4.3.2,\n         Remote\
    \ or Local Peer Attacking a Shared CQ.\n         2) The local ULP ensures that\
    \ CQ entries are reaped frequently\n         enough to adhere to Section 6.4.3.2's\
    \ rules.\n     *   6.4.3.2, Remote or Local Peer Attacking a Shared CQ.  There\
    \ are\n         two mitigations specified in this section - one requires a\n \
    \        worst-case size of the CQ, and can be implemented entirely\n        \
    \ within the Privileged Resource Manager.  The second approach\n         requires\
    \ cooperation with the local ULP server (not to post too\n         many buffers),\
    \ and enables a smaller CQ to be used.\n         In some server environments,\
    \ partial trust of the server ULP\n         (but not the clients) is acceptable;\
    \ thus, the smaller CQ fully\n         mitigates the remote attacker.  In other\
    \ environments, the\n         local server ULP could also contain untrusted elements\
    \ that can\n         attack the local machine (or have bugs).  In those\n    \
    \     environments, the worst-case size of the CQ must be used.\n     *   6.4.3.3,\
    \ Attacking the RDMA Read Request Queue.  The section\n         requires a server's\
    \ Privileged Resource Manager not to allow\n         sharing of RDMA Read Request\
    \ Queues across multiple Streams\n         that do not share Partial Mutual Trust\
    \ for a ULP that performs\n         RDMA Read operations to server buffers.  However,\
    \ because the\n         server ULP knows which of its Streams best share Partial\
    \ Mutual\n         Trust, this requirement can be reflected back to the ULP. \
    \ The\n         ULP (i.e., server) requirement, in this case, is that it MUST\n\
    \         NOT allow RDMA Read Request Queues to be shared between ULPs\n     \
    \    that do not have Partial Mutual Trust.\n     *   6.4.5, Remote Invalidate\
    \ an STag Shared on Multiple Streams.\n         This mitigation is already covered\
    \ by Section 6.2.2 (above).\n"
- title: 'Appendix B: Summary of RNIC and ULP Implementation Requirements'
  contents:
  - "Appendix B: Summary of RNIC and ULP Implementation Requirements\n   This appendix\
    \ is informative.\n   Below is a summary of implementation requirements for the\
    \ RNIC:\n   *   3 Trust and Resource Sharing\n   *   5.4.5 Requirements for IPsec\
    \ Encapsulation of DDP\n   *   6.1.1 Using an STag on a Different Stream\n   *\
    \   6.2.1 Buffer Overrun - RDMA Write or Read Response\n   *   6.2.2 Modifying\
    \ a Buffer after Indication\n   *   6.4.1 RNIC Resource Consumption\n   *   6.4.3.1\
    \ Multiple Streams Sharing Receive Buffers\n   *   6.4.3.2 Remote or Local Peer\
    \ Attacking a Shared CQ\n   *   6.4.3.3 Attacking the RDMA Read Request Queue\n\
    \   *   6.4.6 Remote Peer Attacking an Unshared CQ\n   *   6.5 Elevation of Privilege\
    \ 39\n   *   7.1 Local ULP Attacking a Shared CQ\n   *   7.3 Local ULP Attacking\
    \ the PTT and STag Mapping\n   Below is a summary of implementation requirements\
    \ for the ULP above\n   the RNIC:\n   *   5.3 Information Disclosure - Network-Based\
    \ Eavesdropping\n   *   6.1.1 Using an STag on a Different Stream\n   *   6.2.2\
    \ Modifying a Buffer after Indication\n   *   6.3.2 Using RDMA Read to Access\
    \ Stale Data\n   *   6.3.3 Accessing a Buffer after the Transfer\n   *   6.3.4\
    \ Accessing Unintended Data with a Valid STag\n   *   6.3.5 RDMA Read into an\
    \ RDMA Write Buffer\n   *   6.3.6 Using Multiple STags That Alias to the Same\
    \ Buffer\n   *   6.4.5 Remote Invalidate an STag Shared on Multiple Streams\n"
- title: 'Appendix C: Partial Trust Taxonomy'
  contents:
  - "Appendix C: Partial Trust Taxonomy\n   This appendix is informative.\n   Partial\
    \ Trust is defined as when one party is willing to assume that\n   another party\
    \ will refrain from a specific attack or set of attacks,\n   the parties are said\
    \ to be in a state of Partial Trust.  Note that\n   the partially trusted peer\
    \ may attempt a different set of attacks.\n   This may be appropriate for many\
    \ ULPs where any adverse effects of\n   the betrayal is easily confined and does\
    \ not place other clients or\n   ULPs at risk.\n   The Trust Models described\
    \ in this section have three primary\n   distinguishing characteristics.  The\
    \ Trust Model refers to a local\n   ULP and Remote Peer, which are intended to\
    \ be the local and remote\n   ULP instances communicating via RDMA/DDP.\n   *\
    \   Local Resource Sharing (yes/no) - When local resources are\n       shared,\
    \ they are shared across a grouping of RDMAP/DDP Streams.\n       If local resources\
    \ are not shared, the resources are dedicated on\n       a per Stream basis. \
    \ Resources are defined in Section 2.2,\n       Resources.  The advantage of not\
    \ sharing resources between\n       Streams is that it reduces the types of attacks\
    \ that are\n       possible.  The disadvantage is that ULPs might run out of\n\
    \       resources.\n   *   Local Partial Trust (yes/no) - Local Partial Trust\
    \ is determined\n       based on whether the local grouping of RDMAP/DDP Streams\
    \ (which\n       typically equates to one ULP or group of ULPs) mutually trust\n\
    \       each other not to perform a specific set of attacks.\n   *   Remote Partial\
    \ Trust (yes/no) - The Remote Partial Trust level is\n       determined based\
    \ on whether the local ULP of a specific RDMAP/DDP\n       Stream partially trusts\
    \ the Remote Peer of the Stream (see the\n       definition of Partial Trust in\
    \ Section 1, Introduction).\n   Not all the combinations of the trust characteristics\
    \ are expected to\n   be used by ULPs.  This document specifically analyzes five\
    \ ULP Trust\n   Models that are expected to be in common use.  The Trust Models\
    \ are\n   as follows:\n   *   NS-NT - Non-Shared Local Resources, no Local Trust,\
    \ no Remote\n       Trust; typically, a server ULP that wants to run in the safest\n\
    \       mode possible.  All attack mitigations are in place to ensure\n      \
    \ robust operation.\n   *   NS-RT - Non-Shared Local Resources, no Local Trust,\
    \ Remote\n       Partial Trust; typically, a peer-to-peer ULP that has, by some\n\
    \       method outside of the scope of this document, authenticated the\n    \
    \   Remote Peer.  Note that unless some form of key based\n       authentication\
    \ is used on a per RDMA/DDP Stream basis, it may not\n       be possible for man-in-the-middle\
    \ attacks to occur.\n   *   S-NT - Shared Local Resources, no Local Trust, no\
    \ Remote Trust;\n       typically, a server ULP that runs in an untrusted environment\n\
    \       where the amount of resources required is either too large or too\n  \
    \     dynamic to dedicate for each RDMAP/DDP Stream.\n   *   S-LT - Shared Local\
    \ Resources, Local Partial Trust, no Remote\n       Trust; typically, a ULP that\
    \ provides a session layer and uses\n       multiple Streams, to provides additional\
    \ throughput or fail-over\n       capabilities.  All the Streams within the local\
    \ ULP partially\n       trust each other, but do not trust the Remote Peer.  This\
    \ Trust\n       Model may be appropriate for embedded environments.\n   *   S-T\
    \ - Shared Local Resources, Local Partial Trust, Remote Partial\n       Trust;\
    \ typically, a distributed application, such as a\n       distributed database\
    \ application or High Performance Computer\n       (HPC) application, which is\
    \ intended to run on a cluster.  Due to\n       extreme resource and performance\
    \ requirements, the application\n       typically authenticates with all of its\
    \ peers and then runs in a\n       highly trusted environment.  The application\
    \ peers are all in a\n       single application fault domain and depend on one\
    \ another to be\n       well-behaved when accessing data structures.  If a trusted\
    \ Remote\n       Peer has an implementation defect that results in poor behavior,\n\
    \       the entire application could be corrupted.\n   Models NS-NT and S-NT,\
    \ above, are typical for Internet networking -\n   neither the local ULP nor the\
    \ Remote Peer is trusted.  Sometimes,\n   optimizations can be done that enable\
    \ sharing of Page Translation\n   Tables across multiple local ULPs; thus, Model\
    \ S-LT can be\n   advantageous.  Model S-T is typically used when resource scaling\n\
    \   across a large parallel ULP makes it infeasible to use any other\n   model.\
    \  Resource scaling issues can either be due to performance\n   around scaling\
    \ or because there simply are not enough resources.\n   Model NS-RT is probably\
    \ the least likely model to be used, but is\n   presented for completeness.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   Sara Bitan\n   Microsoft Corporation\n   EMail: sarab@microsoft.com\n\
    \   Allyn Romanow\n   Cisco Systems\n   170 W Tasman Drive\n   San Jose, CA 95134\
    \ USA\n   Phone: +1 (408) 525-8836\n   EMail: allyn@cisco.com\n   Catherine Meadows\n\
    \   Naval Research Laboratory\n   Code 5543\n   Washington, DC 20375 USA\n   EMail:\
    \ meadows@itd.nrl.navy.mil\n   Patricia Thaler\n   Agilent Technologies, Inc.\n\
    \   1101 Creekside Ridge Drive, #100\n   M/S-RG10\n   Roseville, CA 95678 USA\n\
    \   Phone: +1 (916) 788-5662\n   EMail: pat_thaler@agilent.com\n   James Livingston\n\
    \   NEC Solutions (America), Inc.\n   7525 166th Ave. N.E., Suite D210\n   Redmond,\
    \ WA 98052-7811 USA\n   Phone: +1 (425) 897-2033\n   EMail: james.livingston@necsam.com\n\
    \   John Carrier\n   Cray Inc.\n   411 First Avenue S, Suite 600\n   Seattle,\
    \ WA 98104-2860\n   Phone: 206-701-2090\n   EMail: carrier@cray.com\n   Caitlin\
    \ Bestler\n   Broadcom\n   49 Discovery\n   Irvine, CA 92618\n   EMail: cait@asomi.com\n\
    \   Bernard Aboba\n   Microsoft Corporation\n   One Microsoft Way USA\n   Redmond,\
    \ WA 98052\n   Phone: +1 (425) 706-6606\n   EMail: bernarda@windows.microsoft.com\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   James Pinkerton\n   Microsoft Corporation\n   One Microsoft\
    \ Way\n   Redmond, WA 98052 USA\n   Phone: +1 (425) 705-5442\n   EMail: jpink@windows.microsoft.com\n\
    \   Ellen Deleganes\n   Self\n   P.O. Box 9245\n   Brooks, OR 97305\n   Phone:\
    \ (503) 642-3950\n   EMail: deleganes@yahoo.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
