- contents:
  - "             Specification for the Derivation of Root Keys\n               from
    an Extended Master Session Key (EMSK)\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Abstract\n   The Extensible Authentication Protocol (EAP) defined the Extended\n
    \  Master Session Key (EMSK) generation, but reserved it for unspecified\n   future
    uses.  This memo reserves the EMSK for the sole purpose of\n   deriving root keys.
    \ Root keys are master keys that can be used for\n   multiple purposes, identified
    by usage definitions.  This document\n   also specifies a mechanism for avoiding
    conflicts between root keys\n   by deriving them in a manner that guarantees cryptographic\n
    \  separation.  Finally, this document also defines one such root key\n   usage:
    Domain-Specific Root Keys are root keys made available to and\n   used within
    specific key management domains.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  3\n     1.1.  Applicable Usages of Keys Derived from the EMSK  .
    . . . .  3\n     1.2.  Terminology  . . . . . . . . . . . . . . . . . . . . .
    . .  5\n   2.  Cryptographic Separation and Coordinated Key Derivation  . . .
    \ 6\n   3.  EMSK Key Root Derivation Framework . . . . . . . . . . . . . .  7\n
    \    3.1.  USRK Derivation  . . . . . . . . . . . . . . . . . . . . .  8\n       3.1.1.
    \ On the KDFs  . . . . . . . . . . . . . . . . . . . . .  9\n       3.1.2.  Default
    KDF  . . . . . . . . . . . . . . . . . . . . .  9\n     3.2.  EMSK and USRK Name
    Derivation  . . . . . . . . . . . . . . 10\n   4.  Domain-Specific Root Key Derivation
    \ . . . . . . . . . . . . . 11\n     4.1.  Applicability of Multi-Domain Usages
    . . . . . . . . . . . 12\n   5.  Requirements for Usage Definitions . . . . .
    . . . . . . . . . 13\n     5.1.  Root Key Management Guidelines . . . . . . .
    . . . . . . . 13\n   6.  Requirements for EAP System  . . . . . . . . . . . .
    . . . . . 14\n   7.  Security Considerations  . . . . . . . . . . . . . . . .
    . . . 15\n     7.1.  Key Strength . . . . . . . . . . . . . . . . . . . . . .
    . 15\n     7.2.  Cryptographic Separation of Keys . . . . . . . . . . . . . 15\n
    \    7.3.  Implementation . . . . . . . . . . . . . . . . . . . . . . 15\n     7.4.
    \ Key Distribution . . . . . . . . . . . . . . . . . . . . . 16\n     7.5.  Key
    Lifetime . . . . . . . . . . . . . . . . . . . . . . . 16\n     7.6.  Entropy
    Consideration  . . . . . . . . . . . . . . . . . . 16\n   8.  IANA Considerations
    \ . . . . . . . . . . . . . . . . . . . . . 16\n     8.1.  Key Labels . . . .
    . . . . . . . . . . . . . . . . . . . . 17\n     8.2.  PRF Numbers  . . . . .
    . . . . . . . . . . . . . . . . . . 18\n   9.  Acknowledgements . . . . . . .
    . . . . . . . . . . . . . . . . 18\n   10. References . . . . . . . . . . . .
    . . . . . . . . . . . . . . 19\n     10.1. Normative References . . . . . . .
    . . . . . . . . . . . . 19\n     10.2. Informative References . . . . . . . .
    . . . . . . . . . . 19\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document deals with keys generated by authenticated
    key exchange\n   mechanisms defined within the EAP framework [RFC3748].  EAP defines\n
    \  two types of keying material: a Master Session Key (MSK) and an\n   Extended
    Master Session Key (EMSK).  The EAP specification implicitly\n   assumes that
    the MSK produced by EAP will be used for a single\n   purpose at a single device;
    however, it does reserve the EMSK for\n   future use.  This document defines the
    EMSK to be used solely for\n   deriving root keys using the key derivation specified.
    \ The root keys\n   are meant for specific purposes called usages; a special usage
    class\n   is the Domain-Specific Root Keys made available to and used within\n
    \  specific key management domains.  This document also provides\n   guidelines
    for creating usage definitions for the various uses of EAP\n   key material and
    for the management of the root keys.  In this\n   document, the terms application
    and usage (or \"usage definition\")\n   refer to a specific use case of the EAP
    keying material.\n   Different uses for keys derived from the EMSK have been proposed.\n
    \  Some examples include hand-off across access points in various mobile\n   technologies,
    mobile IP authentication, and higher-layer application\n   authentication.  In
    order for a particular usage of EAP key material\n   to make use of this specification,
    it must specify a so-called usage\n   definition.  This document does not define
    how the derived Usage-\n   Specific Root Keys (USRK) are used; see the following
    section for\n   discussion of applicable usages.  It does define a framework for
    the\n   derivation of USRKs for different purposes such that different usages\n
    \  can be developed independently from one another.  The goal is to have\n   security
    properties of one usage have minimal or no effect on the\n   security properties
    of other usages.\n   This document does define a special class of USRK, called
    a Domain-\n   Specific Root Key (DSRK) for use in deriving keys specific to a
    key\n   management domain.  Each DSRK is a root key used to derive Domain-\n   Specific
    Usage-Specific Root Keys (DSUSRK).  The DSUSRKs are USRKs\n   specific to a particular
    key management domain.\n   In order to keep root keys for specific purposes separate
    from one\n   another, two requirements are defined in the following sections.
    \ One\n   is coordinated key derivation and another is cryptographic\n   separation.\n"
  - contents:
    - "1.1.  Applicable Usages of Keys Derived from the EMSK\n   The EMSK is typically
      established as part of network access\n   authentication and authorization.
      \ It is expected that keys derived\n   from EMSK will be used in protocols related
      to network access, such\n   as handover optimizations, and the scope of these
      protocols is\n   usually restricted to the endpoints of the lower layers over
      which\n   EAP packets are sent.\n   In particular, it is inappropriate for the
      security of higher-layer\n   applications to solely rely on keys derived from
      network access\n   authentication.  Even when used together with another, independent\n
      \  security mechanism, the use of these keys needs to be carefully\n   evaluated
      with regards to the benefits of the optimization and the\n   need to support
      multiple solutions.  Performance optimizations may\n   not warrant the close
      tie-in that may be required between the layers\n   in order to use EAP-based
      keys.  Such optimizations may be offset by\n   the complexities of managing
      the validity and usage of key materials.\n   Keys generated from subsequent
      EAP authentications may be beyond the\n   knowledge and control of applications.\n
      \  From an architectural point of view, applications should not make\n   assumptions
      about the lower-layer technology (such as network access\n   authentication)
      used on any particular hop along the path between the\n   application endpoints.\n
      \  From a practical point of view, making such assumptions would\n   complicate
      using those applications over lower layers that do not use\n   EAP, and make
      it more difficult for applications and network access\n   technologies to evolve
      independently of each other.\n   Parties using keys derived from EMSK also need
      trust relationships\n   with the EAP endpoints, and mechanisms for securely
      communicating the\n   keys.\n   For most applications, it is not appropriate
      to assume that all\n   current and future access networks are trusted to secure
      the\n   application function.  Instead, applications should implement the\n
      \  required security mechanisms in an access-independent manner.\n   Implementation
      considerations may also complicate communication of\n   keys to an application
      from the lower layer.  For instance, in many\n   configurations, application
      protocol endpoints may be different from\n   the EAP endpoints.\n   Given all
      this, it is NOT RECOMMENDED to use keys derived from the\n   EMSK as an exclusive
      security mechanism, when their usage is not\n   inherently, and by permanent
      nature, tied to the lower layer where\n   network access authentication was
      performed.\n   Keys derived from EAP are pair-wise by nature and are not directly\n
      \  suitable for multicast or other group usages such as those involved\n   in
      some routing protocols.  It is possible to use keys derived from\n   EAP in
      protocols that distribute group keys to group participants.\n   The definition
      of these group key distribution protocols is beyond\n   the scope of this document
      and would require additional\n   specification.\n"
    title: 1.1.  Applicable Usages of Keys Derived from the EMSK
  - contents:
    - "1.2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
      \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and
      \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n
      \  The following terms are taken from [RFC3748]: EAP Server, peer,\n   authenticator,
      Master Session Key (MSK), Extended Master Session Key\n   (EMSK), Cryptographic
      Separation.\n   Usage Definition\n      An application of cryptographic key
      material to provide one or\n      more security functions such as authentication,
      authorization,\n      encryption, or integrity protection for related applications
      or\n      services.  This document provides guidelines and recommendations\n
      \     for what should be included in usage definitions.  This document\n      does
      not place any constraints on the types of use cases or\n      services that
      create usage definitions.\n   Usage-Specific Root Key (USRK)\n      Keying material
      derived from the EMSK for a particular usage\n      definition.  It is used
      to derive child keys in a way defined by\n      its usage definition.\n   Key
      Management Domain\n      A key management domain is specified by the scope of
      a given root\n      key.  The scope is the collection of systems authorized
      to access\n      key material derived from that key.  Systems within a key\n
      \     management domain may be authorized to (1) derive key materials,\n      (2)
      use key materials, or (3) distribute key materials to other\n      systems in
      the same domain.  A derived key's scope is constrained\n      to a subset of
      the scope of the key from which it is derived.  In\n      this document, the
      term \"domain\" refers to a key management domain\n      unless otherwise qualified.\n
      \  Domain Specific Root Key (DSRK)\n      Keying material derived from the EMSK
      that is restricted to use in\n      a specific key management domain.  It is
      used to derive child keys\n      for a particular usage definition.  The child
      keys derived from a\n      DSRK are referred to as Domain-Specific Usage-Specific
      Root Keys\n      (DSUSRKs).  A DSUSRK is similar to the USRK, except in the
      fact\n      that its scope is restricted to the same domain as the parent DSRK\n
      \     from which it is derived.\n"
    title: 1.2.  Terminology
  title: 1.  Introduction
- contents:
  - "2.  Cryptographic Separation and Coordinated Key Derivation\n   The EMSK is used
    to derive keys for multiple use cases, and thus it\n   is required that the derived
    keys are cryptographically separate.\n   Cryptographic separation means that when
    multiple keys are derived\n   from an EMSK, given any derived key, it is computationally
    infeasible\n   to derive any of the other derived keys.  Note that deriving the
    EMSK\n   from any combinations of the derived keys must also be\n   computationally
    infeasible.  In practice, this means that derivation\n   of an EMSK from a derived
    key or derivation of one child key from\n   another must require an amount of
    computation equivalent to that\n   required to, say, reversing a cryptographic
    hash function.\n   Cryptographic separation of keys derived from the same key
    can be\n   achieved in many ways.  Two obvious methods are as follows:\n   o  Use
    a Pseudo-Random Function (PRF) on the EMSK and generate a key\n      stream.  Keys
    of various lengths may be provided as required from\n      the key stream for
    various uses.\n   o  Derive keys from EMSK by providing different inputs to the
    PRF.\n   However, it is desirable that derivation of one child key from the\n
    \  EMSK is independent of derivation of another child key.  Independent\n   derivation
    of keys from the EMSK allows child keys to be derived in\n   any order, independent
    of other keys.  Thus, it is desirable to use\n   option 2 from above.  Using the
    second option implies the additional\n   input to the PRF must be different for
    each child key derivation.\n   This additional input to the PRF must be coordinated
    properly to meet\n   the requirement of cryptographic separation and to prevent
    reuse of\n   key material between usages.\n   If cryptographic separation is not
    maintained, then the security of\n   one usage depends upon the security of all
    other usages that use keys\n   derived from the EMSK.  If a system does not have
    this property, then\n   a usage's security depends upon all other usages deriving
    keys from\n   the same EMSK, which is undesirable.  In order to prevent security\n
    \  problems in one usage from interfering with another usage, the\n   following
    cryptographic separation is required:\n   o  It MUST be computationally infeasible
    to compute the EMSK from any\n      root key derived from it.\n   o  Any root
    key MUST be cryptographically separate from any other\n      root key derived
    from the same EMSK or DSRK.\n   o  Derivation of USRKs MUST be coordinated so
    that two separate\n      cryptographic usages do not derive the same key.\n   o
    \ Derivation of DSRKs MUST be coordinated so that two separate key\n      management
    domains do not derive the same key.\n   o  Derivation of DSRKs and USRKs MUST
    be specified such that no\n      domain can obtain a USRK by providing a domain
    name identical to a\n      Usage Key Label.\n   This document provides guidelines
    for a key derivation mechanism that\n   can be used with existing and new EAP
    methods to provide\n   cryptographic separation between usages of EMSK.  This
    allows for the\n   development of new usages without cumbersome coordination between\n
    \  different usage definitions.\n"
  title: 2.  Cryptographic Separation and Coordinated Key Derivation
- contents:
  - "3.  EMSK Key Root Derivation Framework\n   The EMSK key derivation framework
    provides a coordinated means for\n   generating multiple root keys from an EMSK.
    \ Further keys may then be\n   derived from the root key for various purposes,
    including encryption,\n   integrity protection, entity authentication by way of
    proof of\n   possession, and subsequent key derivation.  A root key is derived\n
    \  from the EMSK for a specific set of uses set forth in a usage\n   definition
    described in Section 5.\n   The basic EMSK root key hierarchy looks as follows:\n
    \                     EMSK\n                     /    \\\n                   USRK1
    \ USRK2\n   This document defines how to derive Usage-Specific Root Keys (USRKs)\n
    \  from the EMSK and also defines a specific USRK called a Domain-\n   Specific
    Root Key (DSRK).  DSRKs are root keys restricted to use in a\n   particular key
    management domain.  From the DSRK, Usage-Specific Root\n   Keys for a particular
    application may be derived (DSUSRKs).  The\n   DSUSRKs are equivalent to USRKs
    that are restricted to use in a\n   particular domain.  The details of lower levels
    of key hierarchy are\n   outside scope of this document.  The key hierarchy looks
    as follows:\n                      EMSK\n                     /    \\\n                  USRK
    \  DSRK\n                        /    \\\n                   DSUSRK1 DSUSRK2\n"
  - contents:
    - "3.1.  USRK Derivation\n   The EMSK Root Key Derivation Function (KDF) derives
      a USRK from the\n   EMSK, a key label, optional data, and output length.  The
      KDF is\n   expected to give the same output for the same input.  The basic key\n
      \  derivation function is given below.\n        USRK = KDF(EMSK, key label |
      \"\\0\" | optional data | length)\n      where:\n        | denotes concatenation\n
      \       \"\\0\" is a NULL octet (0x00 in hex)\n        length is a 2-octet unsigned
      integer in network byte order\n   The key labels are printable ASCII strings
      unique for each usage\n   definition and are a maximum of 255 octets.  In general,
      they are of\n   the form label-string@specorg, where specorg is the organization
      that\n   controls the specification of the usage definition of the Root Key.\n
      \  The key label is intended to provide global uniqueness.  Rules for\n   the
      allocation of these labels are given in Section 8.\n   The NULL octet after
      the key label is used to avoid collisions if one\n   key label is a prefix of
      another label (e.g., \"foobar\" and\n   \"foobarExtendedV2\").  This is considered
      a simpler solution than\n   requiring a key label assignment policy that prevents
      prefixes from\n   occurring.\n   For the optional data, the KDF MUST be capable
      of processing at least\n   2048 opaque octets.  The optional data must be constant
      during the\n   execution of the KDF.  Usage definitions MAY use the EAP Session-ID\n
      \  [RFC5247] in the specification of the optional data parameter that\n   goes
      into the KDF function.  In this case, the advantage is that data\n   provided
      into the key derivation is unique to the session that\n   generated the keys.\n
      \  The KDF must be able to process input keys of up to 256 bytes.  It\n   may
      do this by providing a mechanism for \"hashing\" long keys down to\n   a suitable
      size that can be consumed by the underlying derivation\n   algorithm.\n   The
      length is a 2-octet unsigned integer in network byte order of the\n   output
      key length in octets.  An implementation of the KDF MUST be\n   capable of producing
      at least 2048 octets of output; however, it is\n   RECOMMENDED that Root Keys
      be at least 64 octets long.\n   A usage definition requiring derivation of a
      Root Key must specify\n   all the inputs (other than EMSK) to the key derivation
      function.\n   USRKs MUST be at least 64 octets in length.\n"
    - contents:
      - "3.1.1.  On the KDFs\n   This specification allows for the use of different
        KDFs.  However, in\n   order to have a coordinated key derivation function,
        the same KDF\n   function MUST be used for all key derivations for a given
        EMSK.  If\n   no KDF is specified, then the default KDF specified in Section
        3.1.2\n   MUST be used.  A system may provide the capability to negotiate\n
        \  additional KDFs.  KDFs are assigned numbers through IANA following\n   the
        policy set in Section 8.  The rules for negotiating a KDF are as\n   follows:\n
        \  o  If no other KDF is specified, the KDF specified in this document\n      MUST
        be used.  This is the \"default\" KDF.\n   o  The initial authenticated key
        exchange MAY specify a favored KDF.\n      For example, an EAP method may
        define a preferred KDF to use in\n      its specification.  If the initial
        authenticated key exchange\n      specifies a KDF, then this MUST override
        the default KDF.\n   Note that usage definitions MUST NOT concern themselves
        with the\n   details of the KDF construction or the KDF selection, they only
        need\n   to worry about the inputs specified in Section 3.\n"
      title: 3.1.1.  On the KDFs
    - contents:
      - "3.1.2.  Default KDF\n   The default KDF for deriving root keys from an EMSK
        is taken from the\n   PRF+ key expansion specified in [RFC4306] based on HMAC-SHA-256\n
        \  [SHA256].  The PRF+ construction was chosen because of its simplicity\n
        \  and efficiency over other mechanisms such as those used in [RFC4346].\n
        \  The motivation for the design of PRF+ is described in [SIGMA].  The\n   definition
        of PRF+ from [RFC4306] is given below:\n        PRF+ (K,S) = T1 | T2 | T3
        | T4 | ...\n   where:\n        T1 = PRF (K, S | 0x01)\n        T2 = PRF (K,
        T1 | S | 0x02)\n        T3 = PRF (K, T2 | S | 0x03)\n        T4 = PRF (K,
        T3 | S | 0x04)\n   continuing as needed to compute the required length of
        key material.\n   The key, K, is the EMSK and S is the concatenation of the
        key label,\n   the NULL octet, optional data, and length defined in Section
        3.1.\n   For this specification, the PRF is taken as HMAC-SHA-256 [SHA256].\n
        \  Since PRF+ is only defined for 255 iterations, it may produce up to\n   8160
        octets of key material.\n"
      title: 3.1.2.  Default KDF
    title: 3.1.  USRK Derivation
  - contents:
    - "3.2.  EMSK and USRK Name Derivation\n   The EAP keying framework [RFC5247]
      specifies that the EMSK MUST be\n   named using the EAP Session-ID and a binary
      or textual indication.\n   Following that requirement, the EMSK name SHALL be
      derived as\n   follows:\n        EMSKname = KDF ( EAP Session-ID, \"EMSK\" |
      \"\\0\" | length )\n   where:\n        | denotes concatenation\n        \"EMSK\"
      consists of the 4 ASCII values for the letters\n        \"\\0\" = is a NULL
      octet (0x00 in hex)\n        length is the 2-octet unsigned integer 8 in network
      byte order\n   It is RECOMMENDED that all keys derived from the EMSK are referred
      to\n   by the EMSKname and the context of the descendant key usage.  This is\n
      \  the default behavior.  Any exceptions SHALL be signaled by individual\n   usages.\n
      \  USRKs MAY be named explicitly with a name derivation specified as\n   follows:\n
      \        USRKName =\n              KDF(EAP Session-ID, key label|\"\\0\"|optional
      data|length)\n    where:\n         key label and optional data MUST be the same
      as those used\n           in the corresponding USRK derivation\n         length
      is the 2-octet unsigned integer 8 in network byte order\n   USRKName derivation
      and usage are applicable when there is ambiguity\n   in referencing the keys
      using the EMSKname and the associated context\n   of the USRK usage.  The usage
      SHALL signal such an exception in key\n   naming, so both parties know the key
      name used.\n"
    title: 3.2.  EMSK and USRK Name Derivation
  title: 3.  EMSK Key Root Derivation Framework
- contents:
  - "4.  Domain-Specific Root Key Derivation\n   A specific USRK called a Domain-Specific
    Root Key (DSRK) is derived\n   from the EMSK for a specific set of usages in a
    particular key\n   management domain.  Usages derive specific keys for specific
    services\n   from this DSRK.  The DSRK may be distributed to a key management\n
    \  domain for a specific set of usages so that keys can be derived\n   within
    the key management domain for those usages.  DSRK-based usages\n   will follow
    a key hierarchy similar to the following:\n                                   EMSK\n
    \                                 /    \\\n                                 /
    \     \\\n                                /        \\\n                               /
    \         \\\n                          DSRK1            DSRK2\n                         /
    \ \\                /  \\\n                        /    \\              /    \\\n
    \                 DSUSRK11  DSUSRK12  DSUSRK21  DSUSRK22\n   The DSRK is a USRK
    with a key label of \"dsrk@ietf.org\" and the\n   optional data containing a domain
    label.  The optional data MUST\n   contain an ASCII string representing the key
    management domain for\n   which the root key is being derived.  The DSRK MUST
    be at least 64\n   octets long.\n   Domain-Specific Usage-Specific Root Keys (DSUSRKs)
    are derived from\n   the DSRK.  The KDF is expected to give the same output for
    the same\n   input.  The basic key derivation function is given below.\n        DSUSRK
    = KDF(DSRK, key label | \"\\0\" | optional data | length)\n   The key labels are
    printable ASCII strings unique for each usage\n   definition within a DSRK usage
    and are a maximum of 255 octets.  In\n   general, they are of the form label-string@specorg
    where specorg is\n   the organization that controls the specification of the usage\n
    \  definition of the DSRK.  The key label is intended to provide global\n   uniqueness.
    \ Rules for the allocation of these labels are given in\n   Section 8.  For the
    optional data, the KDF MUST be capable of\n   processing at least 2048 opaque
    octets.  The optional data must be\n   constant during the execution of the KDF.
    \ The length is a 2-octet\n   unsigned integer in network byte order of the output
    key length in\n   octets.  An implementation of the KDF MUST be capable of producing
    at\n   least 2048 octets of output; however, it is RECOMMENDED that DSUSRKs\n
    \  be at least 64 octets long.\n   Usages that make use of the DSRK must define
    how the peer learns the\n   domain label to use in a particular derivation.  A
    multi-domain usage\n   must define how both DSRKs and specific DSUSRKs are transported
    to\n   different key management domains.  Note that usages may define\n   alternate
    ways to constrain specific keys to particular key\n   management domains.\n   To
    facilitate the use of EMSKname to refer to keys derived from\n   DSRKs, EMSKname
    SHOULD be sent along with the DSRK.  The exception is\n   when a DSRKname is expected
    to be used.  The usage SHALL signal such\n   an exception in key naming, so both
    parties know the key name used.\n   DSUSRKs MAY be named explicitly with a name
    derivation specified as\n   follows:\n        DSUSRKName =\n             KDF(EMSKName,key
    label | \"\\0\" | optional data | length)\n   where length is the 2-octet unsigned
    integer 8 in network byte order.\n"
  - contents:
    - "4.1.  Applicability of Multi-Domain Usages\n   The DSUSRKs generated by a domain
      can be used to authorize entities\n   in a domain to perform specific functions.
      \ In cases where it is\n   appropriate for only a specific domain to be authorized
      to perform a\n   function, the usage SHOULD NOT be defined as multi-domain.\n
      \  In some cases, only certain domains are authorized for a particular\n   multi-domain
      usage.  In this case, domains that do not have full\n   authorization should
      not receive the DSRK and should only receive\n   DSUSRKs for the usages for
      which they are authorized.  If it is\n   possible for a peer to know which domains
      are authorized for a\n   particular usage without relying on restricting access
      to the DSRK to\n   specific domains, then this recommendation may be relaxed.\n"
    title: 4.1.  Applicability of Multi-Domain Usages
  title: 4.  Domain-Specific Root Key Derivation
- contents:
  - "5.  Requirements for Usage Definitions\n   In order for a usage definition to
    meet the guidelines for USRK\n   usage, it must meet the following recommendations:\n
    \  o  The usage must define if it is a domain-enabled usage.\n   o  The usage
    definition MUST NOT use the EMSK in any other way except\n      to derive Root
    Keys using the key derivation specified in\n      Section 3 of this document.
    \ They MUST NOT use the EMSK directly.\n   o  The usage definition SHOULD NOT
    require caching of the EMSK.  It\n      is RECOMMENDED that the Root Key derived
    specifically for the\n      usage definition (rather than the EMSK) should be
    used to derive\n      child keys for specific cryptographic operations.\n   o
    \ Usage definitions MUST define distinct key labels and optional\n      data used
    in the key derivation described in Section 3.  Usage\n      definitions are encouraged
    to use the key name described in\n      Section 3.2 and include additional data
    in the optional data to\n      provide additional entropy.\n   o  Usage definitions
    MUST define the length of their Root Keys.  It\n      is RECOMMENDED that the
    Root Keys be at least as long as the EMSK\n      (at least 64 octets).\n   o  Usage
    definitions MUST define how they use their Root Keys.  This\n      includes aspects
    of key management covered in the next section on\n      Root Key management guidelines.\n"
  - contents:
    - "5.1.  Root Key Management Guidelines\n   This section makes recommendations
      for various aspects of key\n   management of the Root Key including lifetime,
      child key derivation,\n   caching, and transport.\n   It is RECOMMENDED that
      the Root Key is only used for deriving child\n   keys.  A usage definition must
      specify how and when the derivation of\n   child keys should be done.  It is
      RECOMMENDED that usages following\n   similar considerations for key derivation
      are as outlined in this\n   document for the Root Key derivation with respect
      to cryptographic\n   separation and key reuse.  In addition, usages should take
      into\n   consideration the number of keys that will be derived from the Root\n
      \  Key and ensure that enough entropy is introduced in the derivation to\n   support
      this usage.  It is desirable that the entropy is provided by\n   the two parties
      that derive the child key.\n   Root Keys' lifetimes should not be more than
      that of the EMSK.  Thus,\n   when the EMSK expires, the Root Keys derived from
      it should be\n   removed from use.  If a new EMSK is derived from a subsequent
      EAP\n   transaction, then a usage implementation should begin to use the new\n
      \  Root Keys derived from the new EMSK as soon as possible.  Whether or\n   not
      child keys associated with a Root Key are replaced depends on the\n   requirements
      of the usage definition.  It is conceivable that some\n   usage definition forces
      the child key to be replaced and others allow\n   child keys to be used based
      on the policy of the entities that use\n   the child key.\n   Recall that the
      EMSK never leaves the EAP peer and server.  That also\n   holds true for some
      Root Keys; however, some Root Keys may be\n   provided to other entities for
      child key derivation and delivery.\n   Each usage definition specification will
      specify delivery caching\n   and/or delivery procedures.  Note that the purpose
      of the key\n   derivation in Section 3 is to ensure that Root Keys are\n   cryptographically
      separate from each other and the EMSK.  In other\n   words, given a Root Key,
      it is computationally infeasible to derive\n   the EMSK, any other Root Keys,
      or child keys associated with other\n   Root Keys.  In addition to the Root
      Key, several other parameters may\n   need to be sent.\n   Root Key names may
      be derived using the EAP Session-ID, and thus the\n   key name may need to be
      sent along with the key.  When Root Keys are\n   delivered to another entity,
      the EMSKname and the lifetime associated\n   with the specific root keys MUST
      also be transported to that entity.\n   Recommendations for transporting keys
      are discussed in the Security\n   Considerations (Section 7.4).\n   Usage definitions
      may also define how keys are bound to particular\n   entities.  This can be
      done through the inclusion of usage parameters\n   and identities in the child
      key derivation.  Some of this data is\n   described as \"channel bindings\"
      in [RFC3748].\n"
    title: 5.1.  Root Key Management Guidelines
  title: 5.  Requirements for Usage Definitions
- contents:
  - "6.  Requirements for EAP System\n   The system that wishes to make use of EAP
    root keys derived from the\n   EMSK must take certain things into consideration.
    \ The following is a\n   list of these considerations:\n   o  The EMSK MUST NOT
    be used for any other purpose than the key\n      derivation described in this
    document.\n   o  The EMSK MUST be secret and not known to someone observing the\n
    \     authentication mechanism protocol exchange.\n   o  The EMSK MUST be maintained
    within a protected location inside the\n      entity where it is generated.  Only
    root keys derived according to\n      this specification may be exported from
    this boundary.\n   o  The EMSK MUST be unique for each EAP session\n   o  The
    EAP method MUST provide an identifier for the EAP transaction\n      that generated
    the key.\n   o  The system MUST define which usage definitions are used and how\n
    \     they are invoked.\n   o  The system may define ways to select an alternate
    PRF for key\n      derivation as defined in Section 3.1.\n   The system MAY use
    the MSK transmitted to the Network Access Server\n   (NAS) in any way it chooses
    in accordance with [RFC3748], [RFC5247],\n   and other relevant specifications.
    \ This is required for backward\n   compatibility.  New usage definitions following
    this specification\n   MUST NOT use the MSK.  If more than one usage uses the
    MSK, then the\n   cryptographic separation is not achieved.  Implementations MUST\n
    \  prevent such combinations.\n"
  title: 6.  Requirements for EAP System
- contents:
  - '7.  Security Considerations

    '
  - contents:
    - "7.1.  Key Strength\n   The effective key strength of the derived keys will
      never be greater\n   than the strength of the EMSK (or a master key internal
      to an EAP\n   mechanism).\n"
    title: 7.1.  Key Strength
  - contents:
    - "7.2.  Cryptographic Separation of Keys\n   The intent of the KDF is to derive
      keys that are cryptographically\n   separate: the compromise of one of the Usage-Specific
      Root Keys\n   (USRKs) should not compromise the security of other USRKs or the\n
      \  EMSK.  It is believed that the KDF chosen provides the desired\n   separation.\n"
    title: 7.2.  Cryptographic Separation of Keys
  - contents:
    - "7.3.  Implementation\n   An implementation of an EAP framework should keep
      the EMSK internally\n   as close to where it is derived as possible and only
      provide an\n   interface for obtaining Root Keys.  It may also choose to restrict\n
      \  which callers have access to which keys.  A usage definition MUST NOT\n   assume
      that any entity outside the EAP server or EAP peer has access\n   to the EMSK.
      \ In particular, it MUST NOT assume that a lower layer\n   has access to the
      EMSK.\n"
    title: 7.3.  Implementation
  - contents:
    - "7.4.  Key Distribution\n   In some cases, it will be necessary or convenient
      to distribute USRKs\n   from where they are generated.  Since these are secret
      keys, they\n   MUST be transported with their integrity and confidentiality\n
      \  maintained.  They MUST be transmitted between authenticated and\n   authorized
      parties.  It is also important that the context of the key\n   usage be transmitted
      along with the key.  This includes information\n   to identify the key and constraints
      on its usage such as lifetime.\n   This document does not define a mechanism
      for key transport.  It is\n   up to usage definitions and the systems that use
      them to define how\n   keys are distributed.  Usage definition designers may
      enforce\n   constraints on key usage by various parties by deriving a key\n
      \  hierarchy and by providing entities only with the keys in the\n   hierarchy
      that they need.\n"
    title: 7.4.  Key Distribution
  - contents:
    - "7.5.  Key Lifetime\n   The key lifetime is dependent upon how the key is generated
      and how\n   the key is used.  Since the Root Key is the responsibility of the\n
      \  usage definition, it must determine how long the key is valid for.\n   If
      key lifetime or key strength information is available from the\n   authenticated
      key exchange, then this information SHOULD be used in\n   determining the lifetime
      of the key.  If possible, it is recommended\n   that key lifetimes be coordinated
      throughout the system.  Setting a\n   key lifetime shorter that a system lifetime
      may result in keys\n   becoming invalid with no convenient way to refresh them.
      \ Setting a\n   key lifetime to longer may result in decreased security since
      the key\n   may be used beyond its recommended lifetime.\n"
    title: 7.5.  Key Lifetime
  - contents:
    - "7.6.  Entropy Consideration\n   The number of root keys derived from the EMSK
      is expected to be low.\n   Note that there is no randomness required to be introduced
      into the\n   EMSK-to-Root-Key derivation beyond the root key labels.  Thus,
      if\n   many keys are going to be derived from a Root Key, it is important\n
      \  that Root-Key-to-child-key derivation introduce fresh random numbers\n   in
      deriving each key.\n"
    title: 7.6.  Entropy Consideration
  title: 7.  Security Considerations
- contents:
  - "8.  IANA Considerations\n   The keywords \"Private Use\", \"Specification Required\",
    and \"IETF\n   Consensus\" that appear in this document when used to describe\n
    \  namespace allocation are to be interpreted as described in [RFC5226].\n"
  - contents:
    - "8.1.  Key Labels\n   This specification introduces a new name space for \"USRK
      Key Labels\".\n   Key labels MUST be printable US-ASCII strings, and MUST NOT
      contain\n   the characters at-sign (\"@\") except as noted below, comma (\",\"),\n
      \  whitespace, control characters (ASCII codes 32 or less), or the ASCII\n   code
      127 (DEL).  Labels are case-sensitive and MUST NOT be longer\n   than 64 characters.\n
      \  Labels can be assigned based on Specification Required policy\n   [RFC5226].
      \ In addition, the labels \"experimental1\" and\n   \"experimental2\" are reserved
      for experimental use.  The following\n   considerations apply to their use:\n
      \  Production networks do not necessarily support the use of\n   experimental
      code points.  The network scope of support for\n   experimental values should
      carefully be evaluated before deploying\n   any experiment across extended network
      domains, such as the public\n   Internet.  The potential to disrupt the stable
      operation of EAP\n   devices is a consideration when planning an experiment
      using such\n   code points.\n   The network administrators should ensure that
      each code point is used\n   consistently to avoid interference between experiments.
      \ Particular\n   attention should be given to security vulnerabilities and the
      freedom\n   of different domains to employ their own experiments.  Cross-domain\n
      \  usage is NOT RECOMMENDED.\n   Similarly, labels \"private1\" and \"private2\"
      have been reserved for\n   Private Use within an organization.  Again, cross-domain
      usage of\n   these labels is NOT RECOMMENDED.\n   Labels starting with a string
      and followed by the \"@\" and a valid,\n   fully qualified Internet domain name
      [RFC1034] can be requested by\n   the person or organization that is in control
      of the domain name.\n   Such labels can be allocated based on Expert Review
      with\n   Specification Required.  Besides the review needed for Specification\n
      \  Required (see Section 4.1 of [RFC5226]), the expert needs to review\n   the
      proposed usage for conformance to this specification, including\n   the suitability
      of the usage according to the applicability statement\n   outlined in Section
      1.1.  It is RECOMMENDED that the specification\n   contain the following information:\n
      \  o  A description of the usage\n   o  The key label to be used\n   o  Length
      of the Root Key\n   o  If optional data is used, what it is and how it is maintained\n
      \  o  How child keys will be derived from the Root Key and how they will\n      be
      used\n   o  How lifetime of the Root Key and its child keys will be managed\n
      \  o  Where the Root Keys or child keys will be used and how they are\n      communicated
      if necessary\n   The following labels are reserved by this document: \"EMSK\",\n
      \  \"dsrk@ietf.org\".\n"
    title: 8.1.  Key Labels
  - contents:
    - "8.2.  PRF Numbers\n   This specification introduces a new number space for
      \"EMSK PRF\n   numbers\".  The numbers are in the range 0 to 255.  Numbers from
      0 to\n   220 are assigned through the policy IETF Consensus, and numbers in\n
      \  the range 221 to 255 are left for Private Use.  The initial registry\n   contains
      the following values:\n      0 RESERVED\n      1 HMAC-SHA-256 PRF+ (Default)\n"
    title: 8.2.  PRF Numbers
  title: 8.  IANA Considerations
- contents:
  - "9.  Acknowledgements\n   This document expands upon previous collaboration with
    Pasi Eronen.\n   This document reflects conversations with Bernard Aboba, Jari
    Arkko,\n   Avi Lior, David McGrew, Henry Haverinen, Hao Zhou, Russ Housley, Glen\n
    \  Zorn, Charles Clancy, Dan Harkins, Alan DeKok, Yoshi Ohba, and\n   members
    of the EAP and HOKEY working groups.\n   Thanks to Dan Harkins for the idea of
    using a single root key name to\n   refer to all keys.\n"
  title: 9.  Acknowledgements
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC3748]  Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and
      H.\n              Levkowetz, \"Extensible Authentication Protocol (EAP)\",\n
      \             RFC 3748, June 2004.\n   [RFC4306]  Kaufman, C., \"Internet Key
      Exchange (IKEv2) Protocol\",\n              RFC 4306, December 2005.\n   [RFC5226]
      \ Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n              IANA
      Considerations Section in RFCs\", BCP 26, RFC 5226,\n              May 2008.\n
      \  [RFC5247]  Aboba, B., Simon, D., and P. Eronen, \"Extensible\n              Authentication
      Protocol (EAP) Key Management Framework\",\n              RFC 5247, August 2008.\n
      \  [SHA256]   National Institute of Standards and Technology, \"Secure\n              Hash
      Standard\", FIPS 180-2, With Change Notice 1 dated\n              February 2004,
      August 2002.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [RFC1034]  Mockapetris, P., \"Domain names
      - concepts and facilities\",\n              STD 13, RFC 1034, November 1987.\n
      \  [RFC4346]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.1\", RFC 4346, April 2006.\n   [SIGMA]    Krawczyk, H., \"SIGMA:
      the 'SIGn-and-MAc' Approach to\n              Authenticated Diffie-Hellman and
      its Use in the IKE\n              Protocols\", LNCS 2729, Springer, 2003,\n
      \             <http://www.informatik.uni-trier.de/~ley/db/conf/\n              crypto/crypto2003.html>.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Authors' Addresses\n   Joseph Salowey\n   Cisco Systems\n   EMail: jsalowey@cisco.com\n
    \  Lakshminath Dondeti\n   Qualcomm, Inc\n   EMail: ldondeti@qualcomm.com\n   Vidya
    Narayanan\n   Qualcomm, Inc\n   EMail: vidyan@qualcomm.com\n   Madjid Nakhjiri\n
    \  Motorola\n   EMail: madjid.nakhjiri@motorola.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
