- title: __initial_text__
  contents:
  - '                Diameter Applications Design Guidelines

    '
- title: Abstract
  contents:
  - "Abstract\n   The Diameter base protocol provides facilities for protocol\n  \
    \ extensibility enabling the definition of new Diameter applications or\n   modification\
    \ of existing applications.  This document is a companion\n   document to the\
    \ Diameter base protocol that further explains and\n   clarifies the rules to\
    \ extend Diameter.  Furthermore, this document\n   provides guidelines to Diameter\
    \ application designers reusing/\n   defining Diameter applications or creating\
    \ generic Diameter\n   extensions.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo documents an Internet Best Current Practice.\n\
    \   This document is a product of the Internet Engineering Task Force\n   (IETF).\
    \  It represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   BCPs is available in Section\
    \ 2 of RFC 5741.\n   Information about the current status of this document, any\
    \ errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7423.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   5\n   3.  Overview  . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   5\n   4.  Reusing Existing Diameter Applications  . . . . . . . . .\
    \ . .   6\n     4.1.  Adding a New Command  . . . . . . . . . . . . . . . . .\
    \ .   7\n     4.2.  Deleting an Existing Command  . . . . . . . . . . . . . .\
    \   8\n     4.3.  Reusing Existing Commands . . . . . . . . . . . . . . . .  \
    \ 8\n       4.3.1.  Adding AVPs to a Command  . . . . . . . . . . . . . .   8\n\
    \       4.3.2.  Deleting AVPs from a Command  . . . . . . . . . . . .  10\n  \
    \     4.3.3.  Changing the Flag Settings of AVP in Existing\n               Commands\
    \  . . . . . . . . . . . . . . . . . . . . . .  11\n     4.4.  Reusing Existing\
    \ AVPs . . . . . . . . . . . . . . . . . .  11\n       4.4.1.  Setting of the\
    \ AVP Flags  . . . . . . . . . . . . . .  11\n       4.4.2.  Reuse of AVP of Type\
    \ Enumerated . . . . . . . . . . .  12\n   5.  Defining New Diameter Applications\
    \  . . . . . . . . . . . . .  12\n     5.1.  Introduction  . . . . . . . . . .\
    \ . . . . . . . . . . . .  12\n     5.2.  Defining New Commands . . . . . . .\
    \ . . . . . . . . . . .  12\n     5.3.  Use of Application Id in a Message  .\
    \ . . . . . . . . . .  13\n     5.4.  Application-Specific Session State Machines\
    \ . . . . . . .  14\n     5.5.  Session-Id AVP and Session Management . . . .\
    \ . . . . . .  14\n     5.6.  Use of Enumerated Type AVPs . . . . . . . . . .\
    \ . . . . .  15\n     5.7.  Application-Specific Message Routing  . . . . . .\
    \ . . . .  17\n     5.8.  Translation Agents  . . . . . . . . . . . . . . . .\
    \ . . .  18\n     5.9.  End-to-End Application Capabilities Exchange  . . . .\
    \ . .  18\n     5.10. Diameter Accounting Support . . . . . . . . . . . . . .\
    \ .  19\n     5.11. Diameter Security Mechanisms  . . . . . . . . . . . . . .\
    \  21\n   6.  Defining Generic Diameter Extensions  . . . . . . . . . . . .  21\n\
    \   7.  Guidelines for Registrations of Diameter Values . . . . . . .  23\n  \
    \ 8.  Security Considerations . . . . . . . . . . . . . . . . . . .  25\n   9.\
    \  References  . . . . . . . . . . . . . . . . . . . . . . . . .  25\n     9.1.\
    \  Normative References  . . . . . . . . . . . . . . . . . .  25\n     9.2.  Informative\
    \ References  . . . . . . . . . . . . . . . . .  25\n   Contributors . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . 28\n   Acknowledgments . . . . .\
    \ . . . . . . . . . . . . . . . . . . . .  28\n   Authors' Addresses  . . . .\
    \ . . . . . . . . . . . . . . . . . . .  29\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Diameter base protocol [RFC6733] is intended to provide\
    \ an\n   Authentication, Authorization, and Accounting (AAA) framework for\n \
    \  applications such as network access or IP mobility in both local and\n   roaming\
    \ situations.  This protocol provides the ability for Diameter\n   peers to exchange\
    \ messages carrying data in the form of Attribute-\n   Value Pairs (AVPs).\n \
    \  The Diameter base protocol provides facilities to extend Diameter\n   (see\
    \ Section 1.3 of [RFC6733]) to support new functionality.  In the\n   context\
    \ of this document, extending Diameter means one of the\n   following:\n   1.\
    \  The addition of new functionality to an existing Diameter\n       application\
    \ without defining a new application.\n   2.  The addition of new functionality\
    \ to an existing Diameter\n       application that requires the definition of\
    \ a new application.\n   3.  The definition of an entirely new Diameter application\
    \ to offer\n       functionality not supported by existing applications.\n   4.\
    \  The definition of a new generic functionality that can be reused\n       across\
    \ different applications.\n   All of these extensions are design decisions that\
    \ can be carried out\n   by any combination of reusing existing or defining new\
    \ commands,\n   AVPs, or AVP values.  However, application designers do not have\n\
    \   complete freedom when making their design.  A number of rules have\n   been\
    \ defined in [RFC6733] that place constraints on when an extension\n   requires\
    \ the allocation of a new Diameter application identifier or a\n   new command\
    \ code value.  The objective of this document is the\n   following:\n   o  Clarify\
    \ the Diameter extensibility rules as defined in the\n      Diameter base protocol.\n\
    \   o  Discuss design choices and provide guidelines when defining new\n     \
    \ applications.\n   o  Present trade-off choices.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   This document reuses the terminology defined in [RFC6733].\n\
    \   Additionally, the following terms and acronyms are used in this\n   application:\n\
    \   Application:  Extension of the Diameter base protocol [RFC6733] via\n    \
    \  the addition of new commands or AVPs.  Each application is\n      uniquely\
    \ identified by an IANA-allocated application identifier\n      value.\n   Command:\
    \  Diameter request or answer carrying AVPs between Diameter\n      endpoints.\
    \  Each command is uniquely identified by an IANA-\n      allocated Command Code\
    \ value and is described by a Command Code\n      Format (CCF) for an application.\n\
    \   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\"\
    ,\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in\
    \ this\n   document are to be interpreted as described in [RFC2119].\n"
- title: 3.  Overview
  contents:
  - "3.  Overview\n   As designed, the Diameter base protocol [RFC6733] can be seen\
    \ as a\n   two-layer protocol.  The lower layer is mainly responsible for\n  \
    \ managing connections between neighboring peers and for message\n   routing.\
    \  The upper layer is where the Diameter applications reside.\n   This model is\
    \ in line with a Diameter node having an application\n   layer and a peer-to-peer\
    \ delivery layer.  The Diameter base protocol\n   document defines the architecture\
    \ and behavior of the message\n   delivery layer and then provides the framework\
    \ for designing Diameter\n   applications on the application layer.  This framework\
    \ includes\n   definitions of application sessions and accounting support (see\n\
    \   Sections 8 and 9 of [RFC6733]).  Accordingly, a Diameter node is seen\n  \
    \ in this document as a single instance of a Diameter message delivery\n   layer\
    \ and one or more Diameter applications using it.\n   The Diameter base protocol\
    \ is designed to be extensible and the\n   principles are described in Section\
    \ 1.3 of [RFC6733].  In summary,\n   Diameter can be extended by the following:\n\
    \   1.  Defining new AVP values\n   2.  Creating new AVPs\n   3.  Creating new\
    \ commands\n   4.  Creating new applications\n   As a main guiding principle,\
    \ application designers SHOULD comply with\n   the following recommendation: \"\
    try to reuse as much as possible!\".\n   It will reduce the time to finalize specification\
    \ writing, and it\n   will lead to a smaller implementation effort as well as\
    \ reduce the\n   need for testing.  In general, it is clever to avoid duplicate\
    \ effort\n   when possible.\n   However, reuse is not appropriate when the existing\
    \ functionality\n   does not fit the new requirement and/or the reuse leads to\
    \ ambiguity.\n   The impact on extending existing applications can be categorized\
    \ into\n   two groups:\n   Minor Extension:  Enhancing the functional scope of\
    \ an existing\n      application by the addition of optional features to support\
    \ it.\n      Such enhancement has no backward-compatibility issue with the\n \
    \     existing application.\n      A typical example would be the definition of\
    \ a new optional AVP\n      for use in an existing command.  Diameter implementations\n\
    \      supporting the existing application but not the new AVP will\n      simply\
    \ ignore it, without consequences for the Diameter message\n      handling, as\
    \ described in [RFC6733].  The standardization effort\n      will be fairly small.\n\
    \   Major Extension:  Enhancing an application that requires the\n      definition\
    \ of a new Diameter application.  Such enhancement causes\n      a backward-compatibility\
    \ issue with existing implementations\n      supporting the application.\n   \
    \   Typical examples would be the creation of a new command for\n      providing\
    \ functionality not supported by existing applications or\n      the definition\
    \ of a new AVP to be carried in an existing command\n      with the M-bit set\
    \ in the AVP flags (see Section 4.1 of [RFC6733]\n      for definition of \"M-bit\"\
    ).  For such an extension, a significant\n      specification effort is required,\
    \ and a careful approach is\n      recommended.\n"
- title: 4.  Reusing Existing Diameter Applications
  contents:
  - "4.  Reusing Existing Diameter Applications\n   An existing application may need\
    \ to be enhanced to fulfill new\n   requirements, and these modifications can\
    \ be at the command level\n   and/or at the AVP level.  The following sections\
    \ describe the\n   possible modifications that can be performed on existing applications\n\
    \   and their related impact.\n"
- title: 4.1.  Adding a New Command
  contents:
  - "4.1.  Adding a New Command\n   Adding a new command to an existing application\
    \ is considered to be a\n   major extension and requires a new Diameter application\
    \ to be\n   defined, as stated in Section 1.3.4 of [RFC6733].  The need for a\
    \ new\n   application is because a Diameter node that is not upgraded to\n   support\
    \ the new command(s) within the (existing) application would\n   reject any unknown\
    \ command with the protocol error\n   DIAMETER_COMMAND_UNSUPPORTED and cause the\
    \ failure of the\n   transaction.  The new application ensures that Diameter nodes\
    \ only\n   receive commands within the context of applications they support.\n\
    \   Adding a new command means either defining a completely new command\n   or\
    \ importing the command's Command Code Format (CCF) syntax from\n   another application\
    \ whereby the new application inherits some or all\n   of the functionality of\
    \ the application from which the command came.\n   In the former case, the decision\
    \ to create a new application is\n   straightforward, since this is typically\
    \ a result of adding a new\n   functionality that does not exist yet.  For the\
    \ latter, the decision\n   to create a new application will depend on whether\
    \ importing the\n   command in a new application is more suitable than simply\
    \ using the\n   existing application as it is in conjunction with any other\n\
    \   application.\n   An example considers the Diameter Extensible Authentication\
    \ Protocol\n   (EAP) application [RFC4072] and the Diameter Network Access Server\n\
    \   application [RFC7155].  When network access authentication using EAP\n   is\
    \ required, the Diameter EAP commands (Diameter-EAP-Request/\n   Diameter-EAP-Answer)\
    \ are used; otherwise, the Diameter Network Access\n   Server application will\
    \ be used.  When the Diameter EAP application\n   is used, the accounting exchanges\
    \ defined in the Diameter Network\n   Access Server may be used.\n   However,\
    \ in general, it is difficult to come to a hard guideline, and\n   so a case-by-case\
    \ study of each application requirement should be\n   applied.  Before adding\
    \ or importing a command, application designers\n   should consider the following:\n\
    \   o  Can the new functionality be fulfilled by creating a new command\n    \
    \  independent from any existing command?  In this case, the\n      resulting\
    \ new application and the existing application can work\n      independent of,\
    \ but cooperating with, each other.\n   o  Can the existing command be reused\
    \ without major extensions and,\n      therefore, without the need for the definition\
    \ of a new\n      application, e.g., new functionality introduced by the creation\
    \ of\n      new optional AVPs.\n   It is important to note that importing commands\
    \ too liberally could\n   result in a monolithic and hard-to-manage application\
    \ supporting too\n   many different features.\n"
- title: 4.2.  Deleting an Existing Command
  contents:
  - "4.2.  Deleting an Existing Command\n   Although this process is not typical,\
    \ removing a command from an\n   application requires a new Diameter application\
    \ to be defined, and\n   then it is considered as a major extension.  This is\
    \ due to the fact\n   that the reception of the deleted command would systematically\
    \ result\n   in a protocol error (i.e., DIAMETER_COMMAND_UNSUPPORTED).\n   It\
    \ is unusual to delete an existing command from an application for\n   the sake\
    \ of deleting it or the functionality it represents.  An\n   exception might be\
    \ if the intent of the deletion is to create a newer\n   variance of the same\
    \ application that is somehow simpler than the\n   application initially specified.\n"
- title: 4.3.  Reusing Existing Commands
  contents:
  - "4.3.  Reusing Existing Commands\n   This section discusses rules in adding and/or\
    \ deleting AVPs from an\n   existing command of an existing application.  The\
    \ cases described in\n   this section may not necessarily result in the creation\
    \ of new\n   applications.\n   From a historical point of view, it is worth noting\
    \ that there was a\n   strong recommendation to reuse existing commands in [RFC3588]\
    \ to\n   prevent rapid depletion of code values available for vendor-specific\n\
    \   commands.  However, [RFC6733] has relaxed the allocation policy and\n   enlarged\
    \ the range of available code values for vendor-specific\n   applications.  Although\
    \ reuse of existing commands is still\n   RECOMMENDED, protocol designers can\
    \ consider defining a new command\n   when it provides a solution more suitable\
    \ than the twisting of an\n   existing command's use and applications.\n"
- title: 4.3.1.  Adding AVPs to a Command
  contents:
  - "4.3.1.  Adding AVPs to a Command\n   Based on the rules in [RFC6733], AVPs that\
    \ are added to an existing\n   command can be categorized as either:\n   o  Mandatory\
    \ (to understand) AVPs.  As defined in [RFC6733], these\n      are AVPs with the\
    \ M-bit flag set in this command, which means that\n      the Diameter node receiving\
    \ them is required to understand not\n      only their values but also their semantics.\
    \  Failure to do so will\n      cause a message handling error: either an error\
    \ message with the\n      result-code set to DIAMETER_AVP_UNSUPPORTED if the AVP\
    \ is not\n      understood in a request or an application-specific error handling\n\
    \      if the given AVP is in an answer.\n   o  Optional (to understand) AVPs.\
    \  As defined in [RFC6733], these are\n      AVPs with the M-bit flag cleared\
    \ in this command.  A Diameter node\n      receiving these AVPs can simply ignore\
    \ them if it does not support\n      them.\n   It is important to note that the\
    \ definitions given above are\n   independent of whether these AVPs are required\
    \ or optional in the\n   command as specified by the command's CCF syntax [RFC6733].\n\
    \      NOTE: As stated in [RFC6733], the M-bit setting for a given AVP is\n  \
    \    relevant to an application and each command within that\n      application\
    \ that includes the AVP.\n   The rules are strict in the case where the AVPs to\
    \ be added in an\n   exiting command are mandatory to understand, i.e., they have\
    \ the\n   M-bit set.  A mandatory AVP MUST NOT be added to an existing command\n\
    \   without defining a new Diameter application, as stated in [RFC6733].\n   This\
    \ falls into the \"Major Extensions\" category.  Despite the clarity\n   of the\
    \ rule, ambiguity still arises when evaluating whether a new AVP\n   being added\
    \ should be mandatory to begin with.  Application designers\n   should consider\
    \ the following questions when deciding about the M-bit\n   for a new AVP:\n \
    \  o  Would it be required for the receiving side to be able to process\n    \
    \  and understand the AVP and its content?\n   o  Would the new AVPs change the\
    \ state machine of the application?\n   o  Would the presence of the new AVP lead\
    \ to a different number of\n      round trips, effectively changing the state\
    \ machine of the\n      application?\n   o  Would the new AVP be used to differentiate\
    \ between old and new\n      variances of the same application whereby the two\
    \ variances are\n      not backward compatible?\n   o  Would the new AVP have\
    \ duality in meaning, i.e., be used to carry\n      application-related information\
    \ as well as to indicate that the\n      message is for a new application?\n \
    \  If the answer to at least one of the questions is \"yes\", then the\n   M-bit\
    \ MUST be set for the new AVP, and a new Diameter application\n   MUST be defined.\
    \  This list of questions is non-exhaustive, and other\n   criteria MAY be taken\
    \ into account in the decision process.\n   If application designers are instead\
    \ contemplating the use of\n   optional AVPs, i.e., with the M-bit cleared, there\
    \ are still pitfalls\n   that will cause interoperability problems; therefore,\
    \ they must be\n   avoided.  Some examples of these pitfalls are as follows:\n\
    \   o  Use of optional AVPs with intersecting meaning.  One AVP has\n      partially\
    \ the same usage and meaning as another AVP.  The presence\n      of both can\
    \ lead to confusion.\n   o  Optional AVPs with dual purpose, i.e., to carry application\
    \ data\n      as well as to indicate support for one or more features.  This has\n\
    \      a tendency to introduce interpretation issues.\n   o  Adding one or more\
    \ optional AVPs and indicating (usually within\n      descriptive text for the\
    \ command) that at least one of them has to\n      be understood by the receiver\
    \ of the command.  This would be\n      equivalent to adding a mandatory AVP,\
    \ i.e., an AVP with the M-bit\n      set, to the command.\n"
- title: 4.3.2.  Deleting AVPs from a Command
  contents:
  - "4.3.2.  Deleting AVPs from a Command\n   Application designers may want to reuse\
    \ an existing command, but some\n   of the AVPs present in the command's CCF syntax\
    \ specification may be\n   irrelevant for the functionality foreseen to be supported\
    \ by this\n   command.  It may be then tempting to delete those AVPs from the\n\
    \   command.\n   The impacts of deleting an AVP from a command depends on its\
    \ Command\n   Code format specification and M-bit setting:\n   o  Case 1: Deleting\
    \ an AVP that is indicated as a required AVP (noted\n      as {AVP}) in the command's\
    \ CCF syntax specification (regardless of\n      the M-bit setting).\n      In\
    \ this case, a new Command Code, and subsequently a new Diameter\n      application,\
    \ MUST be specified.\n   o  Case 2: Deleting an AVP, which has the M-bit set,\
    \ and is indicated\n      as an optional AVP (noted as [AVP] in the command CCF)\
    \ in the\n      command's CCF syntax specification.\n      In this case, no new\
    \ Command Code has to be specified, but the\n      definition of a new Diameter\
    \ application is REQUIRED.\n   o  Case 3: Deleting an AVP, which has the M-bit\
    \ cleared, and is\n      indicated as [AVP] in the command's CCF syntax specification.\n\
    \      In this case, the AVP can be deleted without consequences.\n   Application\
    \ designers SHOULD attempt to reuse the command's CCF\n   syntax specification\
    \ without modification and simply ignore (but not\n   delete) any optional AVPs\
    \ that will not be used.  This is to maintain\n   compatibility with existing\
    \ applications that will not know about the\n   new functionality as well as to\
    \ maintain the integrity of existing\n   dictionaries.\n"
- title: 4.3.3.  Changing the Flag Settings of AVP in Existing Commands
  contents:
  - "4.3.3.  Changing the Flag Settings of AVP in Existing Commands\n   Although unusual,\
    \ implementors may want to change the setting of the\n   AVP flags a given AVP\
    \ used in a command.\n   Into an existing command, an AVP that was initially defined\
    \ as a\n   mandatory AVP to understand, i.e., an AVP with the M-bit flag set in\n\
    \   the command MAY be safely turned to an optional AVP, i.e., with the\n   M-bit\
    \ cleared.  Any node supporting the existing application will\n   still understand\
    \ the AVP, whatever the setting of the M-bit.  On the\n   contrary, an AVP initially\
    \ defined as an optional AVP to understand,\n   i.e., an AVP with the M-bit flag\
    \ cleared in the command MUST NOT be\n   changed into a mandatory AVP with the\
    \ M-bit flag set without defining\n   a new Diameter application.  Setting the\
    \ M-bit for an AVP that was\n   defined as an optional AVP is equivalent to adding\
    \ a new mandatory\n   AVP to an existing command, and the rules given in Section\
    \ 4.3.1\n   apply.\n   All other AVP flags (V-bit, P-bit, reserved bits) MUST\
    \ remain\n   unchanged.\n"
- title: 4.4.  Reusing Existing AVPs
  contents:
  - "4.4.  Reusing Existing AVPs\n   This section discusses rules in reusing existing\
    \ AVPs when reusing an\n   existing command or defining a new command in a new\
    \ application.\n"
- title: 4.4.1.  Setting of the AVP Flags
  contents:
  - "4.4.1.  Setting of the AVP Flags\n   When reusing existing AVPs in a new application,\
    \ application\n   designers MUST specify the setting of the M-bit flag for a new\n\
    \   Diameter application and, if necessary, for every command of the\n   application\
    \ that can carry these AVPs.  In general, for AVPs defined\n   outside of the\
    \ Diameter base protocol, the characteristics of an AVP\n   are tied to its role\
    \ within a given application and the commands used\n   in this application.\n\
    \   All other AVP flags (V-bit, P-bit, reserved bits) MUST remain\n   unchanged.\n"
- title: 4.4.2.  Reuse of AVP of Type Enumerated
  contents:
  - "4.4.2.  Reuse of AVP of Type Enumerated\n   When reusing an AVP of type Enumerated\
    \ in a command for a new\n   application, it is RECOMMENDED to avoid modifying\
    \ the set of valid\n   values defined for this AVP.  Modifying the set of Enumerated\
    \ values\n   includes adding a value or deprecating the use of a value defined\n\
    \   initially for the AVP.  Modifying the set of values will impact the\n   application\
    \ defining this AVP and all the applications using this\n   AVP, causing potential\
    \ interoperability issues: a value used by a\n   peer that will not be recognized\
    \ by all the nodes between the client\n   and the server will cause an error response\
    \ with the Result-Code AVP\n   set to DIAMETER_INVALID_AVP_VALUE.  When the full\
    \ range of values\n   defined for this Enumerated AVP is not suitable for the\
    \ new\n   application, it is RECOMMENDED that a new AVP be defined to avoid\n\
    \   backward-compatibility issues with existing implementations.\n"
- title: 5.  Defining New Diameter Applications
  contents:
  - '5.  Defining New Diameter Applications

    '
- title: 5.1.  Introduction
  contents:
  - "5.1.  Introduction\n   This section discusses the case where new applications\
    \ have\n   requirements that cannot be fulfilled by existing applications and\n\
    \   would require definition of completely new commands, AVPs, and/or AVP\n  \
    \ values.  Typically, there is little ambiguity about the decision to\n   create\
    \ these types of applications.  Some examples are the interfaces\n   defined for\
    \ the IP Multimedia Subsystem of 3GPP, e.g., Cx/Dx\n   ([TS29.228] and [TS29.229]),\
    \ Sh ([TS29.328] and [TS29.329]), etc.\n   Application designers SHOULD try to\
    \ import existing AVPs and AVP\n   values for any newly defined commands.  In\
    \ certain cases where\n   accounting will be used, the models described in Section\
    \ 5.10 SHOULD\n   also be considered.\n   Additional considerations are described\
    \ in the following sections.\n"
- title: 5.2.  Defining New Commands
  contents:
  - "5.2.  Defining New Commands\n   As a general recommendation, commands SHOULD\
    \ NOT be defined from\n   scratch.  It is instead RECOMMENDED to reuse an existing\
    \ command\n   offering similar functionality and use it as a starting point. \
    \ Code\n   reuse leads to a smaller implementation effort as well as reduces the\n\
    \   need for testing.\n   Moreover, the new command's CCF syntax specification\
    \ SHOULD be\n   carefully defined when considering applicability and extensibility\
    \ of\n   the application.  If most of the AVPs contained in the command are\n\
    \   indicated as fixed or required, it might be difficult to reuse the\n   same\
    \ command and, therefore, the same application in a slightly\n   changed environment.\
    \  Defining a command with most of the AVPs\n   indicated as optional is considered\
    \ as a good design choice in many\n   cases, despite the flexibility it introduces\
    \ in the protocol.\n   Protocol designers MUST clearly state the reasons why these\
    \ optional\n   AVPs might or might not be present and properly define the\n  \
    \ corresponding behavior of the Diameter nodes when these AVPs are\n   absent\
    \ from the command.\n      NOTE: As a hint for protocol designers, it is not sufficient\
    \ to\n      just look at the command's CCF syntax specification.  It is also\n\
    \      necessary to carefully read through the accompanying text in the\n    \
    \  specification.\n   In the same way, the CCF syntax specification SHOULD be\
    \ defined such\n   that it will be possible to add any arbitrary optional AVPs\
    \ with the\n   M-bit cleared (including vendor-specific AVPs) without modifying\
    \ the\n   application.  For this purpose, \"* [AVP]\" SHOULD be added in the\n\
    \   command's CCF, which allows the addition of any arbitrary number of\n   optional\
    \ AVPs as described in [RFC6733].\n"
- title: 5.3.  Use of Application Id in a Message
  contents:
  - "5.3.  Use of Application Id in a Message\n   When designing new applications,\
    \ application designers SHOULD specify\n   that the Application Id carried in\
    \ all session-level messages is the\n   Application Id of the application using\
    \ those messages.  This\n   includes the session-level messages defined in the\
    \ Diameter base\n   protocol, i.e., Re-Auth-Request (RAR) / Re-Auth-Answer (RAA),\n\
    \   Session-Termination-Request (STR) / Session-Termination-Answer (STA),\n  \
    \ Abort-Session-Request (ASR) / Abort-Session-Answer (ASA), and\n   possibly Accounting-Request\
    \ (ACR) / Accounting Answer (ACA) in the\n   coupled accounting model; see Section\
    \ 5.10.  Some existing\n   specifications do not adhere to this rule for historical\
    \ reasons.\n   However, this guidance SHOULD be followed by new applications to\n\
    \   avoid routing problems.\n   When a new application has been allocated with\
    \ a new Application Id\n   and it also reuses existing commands with or without\
    \ modifications,\n   the commands SHOULD use the newly allocated Application Id\
    \ in the\n   header and in all relevant Application-Id AVPs (Auth-Application-Id\n\
    \   or Acct-Application-Id) present in the commands message body.\n   Additionally,\
    \ application designers using a vendor-specific\n   Application-Id AVP SHOULD\
    \ NOT use the Vendor-Id AVP to further\n   dissect or differentiate the vendor-specification\
    \ Application Id.\n   Diameter routing is not based on the Vendor Id.  As such,\
    \ the Vendor\n   Id SHOULD NOT be used as an additional input for routing or delivery\n\
    \   of messages.  The Vendor-Id AVP is an informational AVP only and kept\n  \
    \ for backward compatibility reasons.\n"
- title: 5.4.  Application-Specific Session State Machines
  contents:
  - "5.4.  Application-Specific Session State Machines\n   Section 8 of [RFC6733]\
    \ provides session state machines for AAA\n   services, and these session state\
    \ machines are not intended to cover\n   behavior outside of AAA.  If a new application\
    \ cannot clearly be\n   categorized into any of these AAA services, it is RECOMMENDED\
    \ that\n   the application define its own session state machine.  Support for\
    \ a\n   server-initiated request is a clear example where an application-\n  \
    \ specific session state machine would be needed, for example, the Rw\n   interface\
    \ for the ITU-T push model (cf.  [Q.3303.3]).\n"
- title: 5.5.  Session-Id AVP and Session Management
  contents:
  - "5.5.  Session-Id AVP and Session Management\n   Diameter applications are usually\
    \ designed with the aim of managing\n   user sessions (e.g., Diameter Network\
    \ Access Server (NAS) application\n   [RFC4005]) or a specific service access\
    \ session (e.g., Diameter SIP\n   application [RFC4740]).  In the Diameter base\
    \ protocol, session state\n   is referenced using the Session-Id AVP.  All Diameter\
    \ messages that\n   use the same Session-Id will be bound to the same session.\
    \  Diameter-\n   based session management also implies that both the Diameter\
    \ client\n   and server (and potentially proxy agents along the path) maintain\n\
    \   session state information.\n   However, some applications may not need to\
    \ rely on the Session-Id to\n   identify and manage sessions because other information\
    \ can be used\n   instead to correlate Diameter messages.  Indeed, the User-Name\
    \ AVP or\n   any other specific AVP can be present in every Diameter message and\n\
    \   used, therefore, for message correlation.  Some applications might\n   not\
    \ require the notion of the Diameter-session concept at all.  For\n   such applications,\
    \ the Auth-Session-State AVP is usually set to\n   NO_STATE_MAINTAINED in all\
    \ Diameter messages, and these applications\n   are, therefore, designed as a\
    \ set of stand-alone transactions.  Even\n   if an explicit access session termination\
    \ is required, application-\n   specific commands are defined and used instead\
    \ of the STR/STA or ASR/\n   ASA defined in the Diameter base protocol [RFC6733].\
    \  In such a case,\n   the Session-Id is not significant.\n   Based on these considerations,\
    \ protocol designers should carefully\n   appraise whether the Diameter application\
    \ being defined relies on the\n   session management specified in the Diameter\
    \ base protocol:\n   o  If it is, the Diameter command defined for the new application\n\
    \      MUST include the Session-Id AVP defined in the Diameter base\n      protocol\
    \ [RFC6733], and the Session-Id AVP MUST be used for\n      correlation of messages\
    \ related to the same session.  Guidance on\n      the use of the Auth-Session-State\
    \ AVP is given in the Diameter\n      base protocol [RFC6733].\n   o  Otherwise,\
    \ because session management is not required or the\n      application relies\
    \ on its own session management mechanism,\n      Diameter commands for the application\
    \ need not include the\n      Session-Id AVP.  If any specific session management\
    \ concept is\n      supported by the application, the application documentation\
    \ MUST\n      clearly specify how the session is handled between the client and\n\
    \      server (and possibly Diameter agents in the path).  Moreover,\n      because\
    \ the application is not maintaining session state at the\n      Diameter base\
    \ protocol level, the Auth-Session-State AVP MUST be\n      included in all Diameter\
    \ commands for the application and MUST be\n      set to NO_STATE_MAINTAINED.\n"
- title: 5.6.  Use of Enumerated Type AVPs
  contents:
  - "5.6.  Use of Enumerated Type AVPs\n   The type Enumerated was initially defined\
    \ to provide a list of valid\n   values for an AVP with their respective interpretation\
    \ described in\n   the specification.  For instance, AVPs of type Enumerated can\
    \ be used\n   to provide further information on the reason for the termination\
    \ of a\n   session or a specific action to perform upon the reception of the\n\
    \   request.\n   As described in Section 4.4.2 above, defining an AVP of type\n\
    \   Enumerated presents some limitations in terms of extensibility and\n   reusability.\
    \  Indeed, the finite set of valid values defined in the\n   definition of the\
    \ AVP of type Enumerated cannot be modified in\n   practice without causing backward-compatibility\
    \ issues with existing\n   implementations.  As a consequence, AVPs of type Enumerated\
    \ MUST NOT\n   be extended by adding new values to support new capabilities.\n\
    \   Diameter protocol designers SHOULD carefully consider before defining\n  \
    \ an Enumerated AVP whether the set of values will remain unchanged or\n   new\
    \ values may be required in the near future.  If such an extension\n   is foreseen\
    \ or cannot be avoided, it is RECOMMENDED to define AVPs of\n   type Unsigned32\
    \ or Unsigned64 in which the data field would contain\n   an address space representing\
    \ \"values\" that would have the same use\n   of Enumerated values.  Whereas only\
    \ the initial values defined at the\n   definition of the AVP of type Enumerated\
    \ are valid as described in\n   Section 4.4.2, any value from the address space\
    \ from 0 to 2^32 - 1\n   for AVPs of type Unsigned32 or from 0 to 2^64 - 1 for\
    \ AVPs of type\n   Unsigned64 is valid at the Diameter base protocol level and\
    \ will not\n   cause interoperability issues for intermediary nodes between clients\n\
    \   and servers.  Only clients and servers will be able to process the\n   values\
    \ at the application layer.\n   For illustration, an AVP describing possible access\
    \ networks would be\n   defined as follows:\n    Access-Network-Type AVP (XXX)\
    \ is of type Unsigned32 and\n    contains a 32-bit address space representing\
    \ types of access\n    networks.  This application defines the following classes\
    \ of access\n    networks, all identified by the thousands digit in the decimal\n\
    \    notation:\n    o  1xxx (Mobile Access Networks)\n    o  2xxx (Fixed Access\
    \ Networks)\n    o  3xxx (Wireless Access Networks)\n    Values that fall within\
    \ the Mobile Access Networks category are used\n    to inform a peer that a request\
    \ has been sent for a user attached to\n    a mobile access network.  The following\
    \ values are defined in this\n    application:\n    1001: 3GPP-GERAN\n       The\
    \ user is attached to a Global System for Mobile Communications\n       (GSM)\
    \ Enhanced Data rates for GSM Evolution (EDGE) Radio Access\n       Network.\n\
    \    1002: 3GPP-UTRAN-FDD\n       The user is attached to a Universal Mobile Telecommunications\n\
    \       System (UMTS) access network that uses frequency-division\n       duplexing\
    \ for duplexing.\n   Unlike Enumerated AVP, any new value can be added in the\
    \ address\n   space defined by this Unsigned32 AVP without modifying the definition\n\
    \   of the AVP.  There is, therefore, no risk of backward-compatibility\n   issues,\
    \ especially when intermediate nodes may be present between\n   Diameter endpoints.\n\
    \   Along the same line, AVPs of type Enumerated are too often used as a\n   simple\
    \ Boolean flag, indicating, for instance, a specific permission\n   or capability;\
    \ therefore, only three values are defined, e.g., TRUE/\n   FALSE, AUTHORIZED/UNAUTHORIZED,\
    \ or SUPPORTED/UNSUPPORTED.  This is a\n   sub-optimal design since it limits\
    \ the extensibility of the\n   application: any new capability/permission would\
    \ have to be supported\n   by a new AVP or new Enumerated value of the already-defined\
    \ AVP, with\n   the backward-compatibility issues described above.  Instead of\
    \ using\n   an Enumerated AVP for a Boolean flag, protocol designers SHOULD use\n\
    \   AVPs of type Unsigned32 or Unsigned64 in which the data field would\n   be\
    \ defined as a bit mask whose bit settings are described in the\n   relevant Diameter\
    \ application specification.  Such AVPs can be reused\n   and extended without\
    \ major impact on the Diameter application.  The\n   bit mask SHOULD leave room\
    \ for future additions.  Examples of AVPs\n   that use bit masks are the Session-Binding\
    \ AVP defined in [RFC6733]\n   and the MIP6-Feature-Vector AVP defined in [RFC5447].\n"
- title: 5.7.  Application-Specific Message Routing
  contents:
  - "5.7.  Application-Specific Message Routing\n   As described in [RFC6733], a Diameter\
    \ request that needs to be sent\n   to a home server serving a specific realm,\
    \ but not to a specific\n   server (such as the first request of a series of round\
    \ trips), will\n   contain a Destination-Realm AVP and no Destination-Host AVP.\n\
    \   For such a request, the message routing usually relies only on the\n   Destination-Realm\
    \ AVP and the Application Id present in the request\n   message header.  However,\
    \ some applications may need to rely on the\n   User-Name AVP or any other application-specific\
    \ AVPs present in the\n   request to determine the final destination of a request,\
    \ e.g., to\n   find the target AAA server hosting the authorization information\
    \ for\n   a given user when multiple AAA servers are addressable in the realm.\n\
    \   In such a context, basic routing mechanisms described in [RFC6733]\n   are\
    \ not fully suitable, and additional application-level routing\n   mechanisms\
    \ MUST be described in the application documentation to\n   provide such specific\
    \ AVP-based routing.  Such functionality will be\n   basically hosted by an application-specific\
    \ proxy agent that will be\n   responsible for routing decisions based on the\
    \ received specific\n   AVPs.\n   Examples of such application-specific routing\
    \ functions can be found\n   in the Cx/Dx applications ([TS29.228] and [TS29.229])\
    \ of the 3GPP IP\n   Multimedia Subsystem, in which the proxy agent (Subscriber\
    \ Location\n   Function, aka SLF) uses specific application-level identities found\n\
    \   in the request to determine the final destination of the message.\n   Whatever\
    \ the criteria used to establish the routing path of the\n   request, the routing\
    \ of the answer MUST follow the reverse path of\n   the request, as described\
    \ in [RFC6733], with the answer being sent to\n   the source of the received request,\
    \ using transaction states and\n   hop-by-hop identifier matching.  This ensures\
    \ that the Diameter relay\n   or proxy agents in the request routing path will\
    \ be able to release\n   the transaction state upon receipt of the corresponding\
    \ answer,\n   avoiding unnecessary failover.  Moreover, especially in roaming\n\
    \   cases, proxy agents in the path must be able to apply local policies\n   when\
    \ receiving the answer from the server during authentication/\n   authorization\
    \ and/or accounting procedures and maintain up-to-date\n   session state information\
    \ by keeping track of all authorized active\n   sessions.  Therefore, application\
    \ designers MUST NOT modify the\n   answer-routing principles described in [RFC6733]\
    \ when defining a new\n   application.\n"
- title: 5.8.  Translation Agents
  contents:
  - "5.8.  Translation Agents\n   As defined in [RFC6733], a translation agent is\
    \ a device that\n   provides interworking between Diameter and another AAA protocol,\
    \ such\n   as RADIUS.\n   In the case of RADIUS, it was initially thought that\
    \ defining the\n   translation function would be straightforward by adopting a\
    \ few basic\n   principles, e.g., by the use of a shared range of code values\
    \ for\n   RADIUS attributes and Diameter AVPs.  Guidelines for implementing a\n\
    \   RADIUS-Diameter translation agent were put into the Diameter NAS\n   Application\
    \ [RFC4005].\n   However, it was acknowledged that such a translation mechanism\
    \ was\n   not so obvious and deeper protocol analysis was required to ensure\n\
    \   efficient interworking between RADIUS and Diameter.  Moreover, the\n   interworking\
    \ requirements depend on the functionalities provided by\n   the Diameter application\
    \ under specification, and a case-by-case\n   analysis is required.  As a consequence,\
    \ all the material related to\n   RADIUS-to-Diameter translation is removed from\
    \ the new version of the\n   Diameter NAS Application specification [RFC7155],\
    \ which deprecates\n   RFC 4005 [RFC4005].\n   Therefore, protocol designers SHOULD\
    \ NOT assume the availability of a\n   \"standard\" Diameter-to-RADIUS gateway\
    \ agent when planning to\n   interoperate with the RADIUS infrastructure.  They\
    \ SHOULD specify the\n   required translation mechanism along with the Diameter\
    \ application,\n   if needed.  This recommendation applies for any kind of translation.\n"
- title: 5.9.  End-to-End Application Capabilities Exchange
  contents:
  - "5.9.  End-to-End Application Capabilities Exchange\n   Diameter applications\
    \ can rely on optional AVPs to exchange\n   application-specific capabilities\
    \ and features.  These AVPs can be\n   exchanged on an end-to-end basis at the\
    \ application layer.  Examples\n   of this can be found with the MIP6-Feature-Vector\
    \ AVP in [RFC5447]\n   and the QoS-Capability AVP in [RFC5777].\n   End-to-end\
    \ capabilities AVPs can be added as optional AVPs with the\n   M-bit cleared to\
    \ existing applications to announce support of new\n   functionality.  Receivers\
    \ that do not understand these AVPs or the\n   AVP values can simply ignore them,\
    \ as stated in [RFC6733].  When\n   supported, receivers of these AVPs can discover\
    \ the additional\n   functionality supported by the Diameter endpoint originating\
    \ the\n   request and behave accordingly when processing the request.  Senders\n\
    \   of these AVPs can safely assume the receiving endpoint does not\n   support\
    \ any functionality carried by the AVP if it is not present in\n   the corresponding\
    \ response.  This is useful in cases where deployment\n   choices are offered,\
    \ and the generic design can be made available for\n   a number of applications.\n\
    \   When used in a new application, these end-to-end capabilities AVPs\n   SHOULD\
    \ be added as an optional AVP into the CCF of the commands used\n   by the new\
    \ application.  Protocol designers SHOULD clearly specify\n   this end-to-end\
    \ capabilities exchange and the corresponding behavior\n   of the Diameter nodes\
    \ supporting the application.\n   It is also important to note that this end-to-end\
    \ capabilities\n   exchange relying on the use of optional AVPs is not meant as\
    \ a\n   generic mechanism to support extensibility of Diameter applications\n\
    \   with arbitrary functionality.  When the added features drastically\n   change\
    \ the Diameter application or when Diameter agents must be\n   upgraded to support\
    \ the new features, a new application SHOULD be\n   defined, as recommended in\
    \ [RFC6733].\n"
- title: 5.10.  Diameter Accounting Support
  contents:
  - "5.10.  Diameter Accounting Support\n   Accounting can be treated as an auxiliary\
    \ application that is used in\n   support of other applications.  In most cases,\
    \ accounting support is\n   required when defining new applications.  This document\
    \ provides two\n   possible models for using accounting:\n   Split Accounting\
    \ Model:\n      In this model, the accounting messages will use the Diameter base\n\
    \      accounting Application Id (value of 3).  The design implication\n     \
    \ for this is that the accounting is treated as an independent\n      application,\
    \ especially for Diameter routing.  This means that\n      accounting commands\
    \ emanating from an application may be routed\n      separately from the rest\
    \ of the other application messages.  This\n      may also imply that the messages\
    \ end up in a central accounting\n      server.  A split accounting model is a\
    \ good design choice when:\n      *  The application itself does not define its\
    \ own accounting\n         commands.\n      *  The overall system architecture\
    \ permits the use of centralized\n         accounting for one or more Diameter\
    \ applications.\n      Centralizing accounting may have advantages, but there\
    \ are also\n      drawbacks.  The model assumes that the accounting server can\n\
    \      differentiate received accounting messages.  Since the received\n     \
    \ accounting messages can be for any application and/or service, the\n      accounting\
    \ server MUST have a method to match accounting messages\n      with applications\
    \ and/or services being accounted for.  This may\n      mean defining new AVPs;\
    \ checking the presence, absence, or\n      contents of existing AVPs; or checking\
    \ the contents of the\n      accounting record itself.  One of these means could\
    \ be to insert\n      into the request sent to the accounting server an\n    \
    \  Auth-Application-Id AVP containing the identifier of the\n      application\
    \ for which the accounting request is sent.  But in\n      general, there is no\
    \ clean and generic scheme for sorting these\n      messages.  Therefore, this\
    \ model SHOULD NOT be used when all\n      received accounting messages cannot\
    \ be clearly identified and\n      sorted.  For most cases, the use of the Coupled\
    \ Accounting Model\n      is RECOMMENDED.\n   Coupled Accounting Model:\n    \
    \  In this model, the accounting messages will use the Application Id\n      of\
    \ the application using the accounting service.  The design\n      implication\
    \ for this is that the accounting messages are tightly\n      coupled with the\
    \ application itself, meaning that accounting\n      messages will be routed like\
    \ the other application messages.  It\n      would then be the responsibility\
    \ of the application server\n      (application entity receiving the ACR message)\
    \ to send the\n      accounting records carried by the accounting messages to\
    \ the\n      proper accounting server.  The application server is also\n     \
    \ responsible for formulating a proper response (ACA).  A coupled\n      accounting\
    \ model is a good design choice when:\n      *  The system architecture or deployment\
    \ does not provide an\n         accounting server that supports Diameter.  Consequently,\
    \ the\n         application server MUST be provisioned to use a different\n  \
    \       protocol to access the accounting server, e.g., via the\n         Lightweight\
    \ Directory Access Protocol (LDAP), SOAP, etc.  This\n         case includes the\
    \ support of older accounting systems that are\n         not Diameter aware.\n\
    \      *  The system architecture or deployment requires that the\n         accounting\
    \ service for the specific application should be\n         handled by the application\
    \ itself.\n      In all cases above, there will generally be no direct Diameter\n\
    \      access to the accounting server.\n   These models provide a basis for using\
    \ accounting messages.\n   Application designers may obviously deviate from these\
    \ models\n   provided that the factors being addressed here have also been taken\n\
    \   into account.  As a general recommendation, application designers\n   SHOULD\
    \ NOT define a new set of commands to carry application-specific\n   accounting\
    \ records.\n"
- title: 5.11.  Diameter Security Mechanisms
  contents:
  - "5.11.  Diameter Security Mechanisms\n   As specified in [RFC6733], the Diameter\
    \ message exchange SHOULD be\n   secured between neighboring Diameter peers using\
    \ Transport Layer\n   Security (TLS) / TCP or Datagram Transport Layer Security\
    \ (DTLS) /\n   Stream Control Transmission Protocol (SCTP).  However, IPsec MAY\
    \ also\n   be deployed to secure communication between Diameter peers.  When\n\
    \   IPsec is used instead of TLS or DTLS, the following recommendations\n   apply.\n\
    \   IPsec Encapsulating Security Payload (ESP) [RFC4301] in transport\n   mode\
    \ with non-null encryption and authentication algorithms MUST be\n   used to provide\
    \ per-packet authentication, integrity protection, and\n   confidentiality and\
    \ to support the replay protection mechanisms of\n   IPsec.  Internet Key Exchange\
    \ Protocol Version 2 (IKEv2) [RFC7296]\n   SHOULD be used for performing mutual\
    \ authentication and for\n   establishing and maintaining security associations\
    \ (SAs).\n   Version 1 of IKE (IKEv1), defined in [RFC2409], was initially used\n\
    \   for peer authentication, negotiation of security associations, and\n   key\
    \ management in RFC 3588 [RFC3588].  For easier migration from the\n   obsoleted\
    \ implementations based on IKEv1 to IKEv2, both RSA digital\n   signatures and\
    \ pre-shared keys SHOULD be supported in IKEv2.\n   However, if IKEv1 is used,\
    \ implementors SHOULD follow the guidelines\n   given in Section 13.1 of RFC 3588\
    \ [RFC3588].\n"
- title: 6.  Defining Generic Diameter Extensions
  contents:
  - "6.  Defining Generic Diameter Extensions\n   Generic Diameter extensions are\
    \ AVPs, commands, or applications that\n   are designed to support other Diameter\
    \ applications.  They are\n   auxiliary applications meant to improve or enhance\
    \ the Diameter\n   protocol itself or Diameter applications/functionality.  Some\n\
    \   examples include the extensions to support realm-based redirection of\n  \
    \ Diameter requests (see [RFC7075]), conveying a specific set of\n   priority\
    \ parameters influencing the distribution of resources (see\n   [RFC6735]), and\
    \ the support for QoS AVPs (see [RFC5777]).\n   Since generic extensions may cover\
    \ many aspects of Diameter and\n   Diameter applications, it is not possible to\
    \ enumerate all scenarios.\n   However, some of the most common considerations\
    \ are as follows:\n   Backward Compatibility:\n      When defining generic extensions\
    \ designed to be supported by\n      existing Diameter applications, protocol\
    \ designers MUST consider\n      the potential impacts of the introduction of\
    \ the new extension on\n      the behavior of the node that would not be yet upgraded\
    \ to\n      support/understand this new extension.  Designers MUST also ensure\n\
    \      that new extensions do not break expected message delivery layer\n    \
    \  behavior.\n   Forward Compatibility:\n      Protocol designers MUST ensure\
    \ that their design will not\n      introduce undue restrictions for future applications.\n\
    \   Trade-off in Signaling:\n      Designers may have to choose between the use\
    \ of optional AVPs\n      piggybacked onto existing commands versus defining new\
    \ commands\n      and applications.  Optional AVPs are simpler to implement and\
    \ may\n      not need changes to existing applications.  However, this ties the\n\
    \      sending of extension data to the application's transmission of a\n    \
    \  message.  This has consequences if the application and the\n      extensions\
    \ have different timing requirements.  The use of\n      commands and applications\
    \ solves this issue, but the trade-off is\n      the additional complexity of\
    \ defining and deploying a new\n      application.  It is left up to the designer\
    \ to find a good balance\n      among these trade-offs based on the requirements\
    \ of the extension.\n   In practice, generic extensions often use optional AVPs\
    \ because they\n   are simple and non-intrusive to the application that would\
    \ carry\n   them.  Peers that do not support the generic extensions need not\n\
    \   understand nor recognize these optional AVPs.  However, it is\n   RECOMMENDED\
    \ that the authors of the extension specify the context or\n   usage of the optional\
    \ AVPs.  As an example, in the case that the AVP\n   can be used only by a specific\
    \ set of applications, then the\n   specification MUST enumerate these applications\
    \ and the scenarios\n   when the optional AVPs will be used.  In the case where\
    \ the optional\n   AVPs can be carried by any application, it should be sufficient\
    \ to\n   specify such a use case and perhaps provide specific examples of\n  \
    \ applications using them.\n   In most cases, these optional AVPs piggybacked\
    \ by applications would\n   be defined as a Grouped AVP, and it would encapsulate\
    \ all the\n   functionality of the generic extension.  In practice, it is not\n\
    \   uncommon that the Grouped AVP will encapsulate an existing AVP that\n   has\
    \ previously been defined as mandatory ('M'-bit set), e.g., 3GPP IP\n   Multimedia\
    \ Subsystems (IMS) Cx/Dx interfaces ([TS29.228] and\n   [TS29.229]).\n"
- title: 7.  Guidelines for Registrations of Diameter Values
  contents:
  - "7.  Guidelines for Registrations of Diameter Values\n   As summarized in Section\
    \ 3 of this document and further described in\n   Section 1.3 of [RFC6733], there\
    \ are four main ways to extend\n   Diameter.  The process for defining new functionality\
    \ slightly varies\n   based on the different extensions.  This section provides\
    \ protocol\n   designers with some guidance regarding the definition of values\
    \ for\n   possible Diameter extensions and the necessary interaction with IANA\n\
    \   to register the new functionality.\n   a.  Defining New AVP Values\n     \
    \ The specifications defining AVPs and AVP values MUST provide\n      guidance\
    \ for defining new values and the corresponding policy for\n      adding these\
    \ values.  For example, RFC 5777 [RFC5777] defines the\n      Treatment-Action\
    \ AVP, which contains a list of valid values\n      corresponding to predefined\
    \ actions (drop, shape, mark, permit).\n      This set of values can be extended\
    \ following the Specification\n      Required policy defined in [RFC5226].  As\
    \ a second example, the\n      Diameter base specification [RFC6733] defines the\
    \ Result-Code AVP\n      that contains a 32-bit address space used to identity\
    \ possible\n      errors.  According to Section 11.3.2 of [RFC6733], new values\
    \ can\n      be assigned by IANA via an IETF Review process [RFC5226].\n   b.\
    \  Creating New AVPs\n      Two different types of AVP Codes namespaces can be\
    \ used to create\n      a new AVP:\n      *  IETF AVP Codes namespace.\n     \
    \ *  Vendor-specific AVP Codes namespace.\n      In the latter case, a vendor\
    \ needs to be first assigned by IANA\n      with a private enterprise number,\
    \ which can be used within the\n      Vendor-Id field of the vendor-specific AVP.\
    \  This enterprise\n      number delimits a private namespace in which the vendor\
    \ is\n      responsible for vendor-specific AVP code value assignment.  The\n\
    \      absence of a Vendor Id or a Vendor-Id value of zero (0) in the AVP\n  \
    \    header identifies standard AVPs from the IETF AVP Codes namespace\n     \
    \ managed by IANA.  The allocation of code values from the IANA-\n      managed\
    \ namespace is conditioned by an Expert Review of the\n      specification defining\
    \ the AVPs or an IETF Review if a block of\n      AVPs needs to be assigned. \
    \ Moreover, the remaining bits of the\n      AVP Flags field of the AVP header\
    \ are also assigned via Standards\n      Action if the creation of new AVP flags\
    \ is desired.\n   c.  Creating New Commands\n      Unlike the AVP Codes namespace,\
    \ the Command Code namespace is\n      flat, but the range of values is subdivided\
    \ into three chunks with\n      distinct IANA registration policies:\n      *\
    \  A range of standard Command Code values that are allocated via\n         IETF\
    \ Review;\n      *  A range of vendor-specific Command Code values that are\n\
    \         allocated on a first-come, first-served basis; and\n      *  A range\
    \ of values reserved only for experimental and testing\n         purposes.\n \
    \     As for AVP flags, the remaining bits of the Command Flags field of\n   \
    \   the Diameter header are also assigned via a Standards Action to\n      create\
    \ new Command flags if required.\n   d.  Creating New Applications\n      Similarly,\
    \ to the Command Code namespace, the Application-Id\n      namespace is flat but\
    \ divided into two distinct ranges:\n      *  A range of values reserved for standard\
    \ Application Ids,\n         allocated after Expert Review of the specification\
    \ defining the\n         standard application.\n      *  A range for values for\
    \ vendor-specific applications, allocated\n         by IANA on a first-come, first-served\
    \ basis.\n   The IANA AAA parameters page can be found at\n   <http://www.iana.org/assignments/aaa-parameters>,\
    \ and the enterprise\n   number IANA page is available at <http://www.iana.org/assignments/\n\
    \   enterprise-numbers>.  More details on the policies followed by IANA\n   for\
    \ namespace management (e.g., first-come, first-served; Expert\n   Review; IETF\
    \ Review; etc.) can be found in [RFC5226].\n      NOTE: When the same functionality/extension\
    \ is used by more than\n      one vendor, it is RECOMMENDED that a standard extension\
    \ be\n      defined.  Moreover, a vendor-specific extension SHOULD be\n      registered\
    \ to avoid interoperability issues in the same network.\n      With this aim,\
    \ the registration policy of a vendor-specific\n      extension has been simplified\
    \ with the publication of [RFC6733],\n      and the namespace reserved for vendor-specific\
    \ extensions is large\n      enough to avoid exhaustion.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   This document provides guidelines and considerations\
    \ for extending\n   Diameter and Diameter applications.  Although such an extension\
    \ may\n   be related to a security functionality, the document does not\n   explicitly\
    \ give additional guidance on enhancing Diameter with\n   respect to security.\
    \  However, as a general guideline, it is\n   recommended that any Diameter extension\
    \ SHOULD NOT break the security\n   concept given in [RFC6733].  In particular,\
    \ it is reiterated here\n   that any command defined or reused in a new Diameter\
    \ application\n   SHOULD be secured by using TLS [RFC5246] or DTLS/SCTP [RFC6083]\
    \ and\n   MUST NOT be used without one of the following: TLS, DTLS, or IPsec\n\
    \   [RFC4301].  When defining a new Diameter extension, any possible\n   impact\
    \ of the existing security principles described in [RFC6733]\n   MUST be carefully\
    \ appraised and documented in the Diameter\n   application specification.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC6733]\
    \  Fajardo, V., Arkko, J., Loughney, J., and G. Zorn,\n              \"Diameter\
    \ Base Protocol\", RFC 6733, October 2012,\n              <http://www.rfc-editor.org/info/rfc6733>.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [Q.3303.3] International Telecommunications\
    \ Union, \"Resource control\n              protocol No.  3: Protocols at the Rw\
    \ interface between the\n              policy decision physical entity (PD-PE)\
    \ and a policy\n              enforcement physical entity (PE-PE): Diameter profile\n\
    \              version 3\", ITU-T Recommendation Q.3303.3, August 2008.\n   [RFC2409]\
    \  Harkins, D. and D. Carrel, \"The Internet Key Exchange\n              (IKE)\"\
    , RFC 2409, November 1998,\n              <http://xml.resource.org/public/rfc/info/rfc2409>.\n\
    \   [RFC3588]  Calhoun, P., Loughney, J., Guttman, E., Zorn, G., and J.\n    \
    \          Arkko, \"Diameter Base Protocol\", RFC 3588, September 2003,\n    \
    \          <http://www.rfc-editor.org/info/rfc3588>.\n   [RFC4005]  Calhoun, P.,\
    \ Zorn, G., Spence, D., and D. Mitton,\n              \"Diameter Network Access\
    \ Server Application\", RFC 4005,\n              August 2005, <http://www.rfc-editor.org/info/rfc4005>.\n\
    \   [RFC4072]  Eronen, P., Hiller, T., and G. Zorn, \"Diameter Extensible\n  \
    \            Authentication Protocol (EAP) Application\", RFC 4072,\n        \
    \      August 2005, <http://www.rfc-editor.org/info/rfc4072>.\n   [RFC4301]  Kent,\
    \ S. and K. Seo, \"Security Architecture for the\n              Internet Protocol\"\
    , RFC 4301, December 2005,\n              <http://www.rfc-editor.org/info/rfc4301>.\n\
    \   [RFC4740]  Garcia-Martin, M., Belinchon, M., Pallares-Lopez, M.,\n       \
    \       Canales-Valenzuela, C., and K. Tammi, \"Diameter Session\n           \
    \   Initiation Protocol (SIP) Application\", RFC 4740, November\n            \
    \  2006, <http://www.rfc-editor.org/info/rfc4740>.\n   [RFC5226]  Narten, T. and\
    \ H. Alvestrand, \"Guidelines for Writing an\n              IANA Considerations\
    \ Section in RFCs\", BCP 26, RFC 5226,\n              May 2008, <http://www.rfc-editor.org/info/rfc5226>.\n\
    \   [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n  \
    \            (TLS) Protocol Version 1.2\", RFC 5246, August 2008,\n          \
    \    <http://www.rfc-editor.org/info/rfc5246>.\n   [RFC5447]  Korhonen, J., Bournelle,\
    \ J., Tschofenig, H., Perkins, C.,\n              and K. Chowdhury, \"Diameter\
    \ Mobile IPv6: Support for\n              Network Access Server to Diameter Server\
    \ Interaction\", RFC\n              5447, February 2009,\n              <http://www.rfc-editor.org/info/rfc5447>.\n\
    \   [RFC5777]  Korhonen, J., Tschofenig, H., Arumaithurai, M., Jones, M.,\n  \
    \            and A. Lior, \"Traffic Classification and Quality of\n          \
    \    Service (QoS) Attributes for Diameter\", RFC 5777, February\n           \
    \   2010, <http://www.rfc-editor.org/info/rfc5777>.\n   [RFC6083]  Tuexen, M.,\
    \ Seggelmann, R., and E. Rescorla, \"Datagram\n              Transport Layer Security\
    \ (DTLS) for Stream Control\n              Transmission Protocol (SCTP)\", RFC\
    \ 6083, January 2011,\n              <http://www.rfc-editor.org/info/rfc6083>.\n\
    \   [RFC6735]  Carlberg, K. and T. Taylor, \"Diameter Priority Attribute-\n  \
    \            Value Pairs\", RFC 6735, October 2012,\n              <http://www.rfc-editor.org/info/rfc6735>.\n\
    \   [RFC7075]  Tsou, T., Hao, R., and T. Taylor, \"Realm-Based Redirection\n \
    \             In Diameter\", RFC 7075, November 2013,\n              <http://www.rfc-editor.org/info/rfc7075>.\n\
    \   [RFC7155]  Zorn, G., \"Diameter Network Access Server Application\",\n   \
    \           RFC 7155, April 2014,\n              <http://www.rfc-editor.org/info/rfc7155>.\n\
    \   [RFC7296]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.\n       \
    \       Kivinen, \"Internet Key Exchange Protocol Version 2\n              (IKEv2)\"\
    , STD 79, RFC 7296, October 2014,\n              <http://www.rfc-editor.org/info/rfc7296>.\n\
    \   [TS29.228] 3rd Generation Partnership Project, \"Technical\n             \
    \ Specification Group Core Network and Terminals; IP\n              Multimedia\
    \ (IM) Subsystem Cx and Dx Interfaces; Signalling\n              flows and message\
    \ contents\", 3GPP TS 29.228, September\n              2014, <http://www.3gpp.org/ftp/Specs/html-info/29228.htm>.\n\
    \   [TS29.229] 3rd Generation Partnership Project, \"Technical\n             \
    \ Specification Group Core Network and Terminals; Cx and Dx\n              interfaces\
    \ based on the Diameter protocol; Protocol\n              details\", 3GPP TS 29.229,\
    \ September 2014,\n              <http://www.3gpp.org/ftp/Specs/html-info/29229.htm>.\n\
    \   [TS29.328] 3rd Generation Partnership Project, \"Technical\n             \
    \ Specification Group Core Network and Terminals; IP\n              Multimedia\
    \ (IM) Subsystem Sh interface; Signalling flows\n              and message contents\"\
    , 3GPP TS 29.328, September 2014,\n              <http://www.3gpp.org/ftp/Specs/html-info/29328.htm>.\n\
    \   [TS29.329] 3rd Generation Partnership Project, \"Technical\n             \
    \ Specification Group Core Network and Terminals; Sh\n              Interface\
    \ based on the Diameter protocol; Protocol\n              details\", 3GPP TS 29.329,\
    \ September 2014,\n              <http://www.3gpp.org/ftp/Specs/html-info/29329.htm>.\n"
- title: Contributors
  contents:
  - "Contributors\n   The content of this document was influenced by a design team\
    \ created\n   to revisit the Diameter extensibility rules.  The team was formed\
    \ in\n   February 2008 and finished its work in June 2008.  In addition to\n \
    \  those individuals listed in the Authors' Addresses section, the\n   design\
    \ team members were:\n   o  Avi Lior\n   o  Glen Zorn\n   o  Jari Arkko\n   o\
    \  Jouni Korhonen\n   o  Mark Jones\n   o  Tolga Asveren\n   o  Glenn McGregor\n\
    \   o  Dave Frascone\n   We would like to thank Tolga Asveren, Glenn McGregor,\
    \ and John\n   Loughney for their contributions as coauthors to earlier versions\
    \ of\n   this document.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   We greatly appreciate the insight provided by Diameter implementors\n\
    \   who have highlighted the issues and concerns being addressed by this\n   document.\
    \  The authors would also like to thank Jean Mahoney, Ben\n   Campbell, Sebastien\
    \ Decugis, and Benoit Claise for their invaluable,\n   detailed reviews and comments\
    \ on this document.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Lionel Morand (editor)\n   Orange Labs\n   38/40 rue du\
    \ General Leclerc\n   Issy-Les-Moulineaux Cedex 9  92794\n   France\n   Phone:\
    \ +33145296257\n   EMail: lionel.morand@orange.com\n   Victor Fajardo\n   Fluke\
    \ Networks\n   EMail: vf0213@gmail.com\n   Hannes Tschofenig\n   Hall in Tirol\
    \  6060\n   Austria\n   EMail: Hannes.Tschofenig@gmx.net\n   URI:   http://www.tschofenig.priv.at\n"
