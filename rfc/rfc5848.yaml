- title: __initial_text__
  contents:
  - '                         Signed Syslog Messages

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes a mechanism to add origin authentication,\n\
    \   message integrity, replay resistance, message sequencing, and\n   detection\
    \ of missing messages to the transmitted syslog messages.\n   This specification\
    \ is intended to be used in conjunction with the\n   work defined in RFC 5424,\
    \ \"The Syslog Protocol\".\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5848.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n   2.  Conventions Used in This Document  . . . . . . . . .\
    \ . . . . .  5\n   3.  Syslog Message Format  . . . . . . . . . . . . . . . .\
    \ . . . .  5\n   4.  Signature Blocks . . . . . . . . . . . . . . . . . . . .\
    \ . . .  6\n     4.1.  Syslog Messages Containing a Signature Block . . . . .\
    \ . .  7\n     4.2.  Signature Block Format and Fields  . . . . . . . . . . .\
    \ .  7\n       4.2.1.  Version  . . . . . . . . . . . . . . . . . . . . . . .\
    \  9\n       4.2.2.  Reboot Session ID  . . . . . . . . . . . . . . . . . . 10\n\
    \       4.2.3.  Signature Group and Signature Priority . . . . . . . . 10\n  \
    \     4.2.4.  Global Block Counter . . . . . . . . . . . . . . . . . 13\n    \
    \   4.2.5.  First Message Number . . . . . . . . . . . . . . . . . 13\n      \
    \ 4.2.6.  Count  . . . . . . . . . . . . . . . . . . . . . . . . 14\n       4.2.7.\
    \  Hash Block . . . . . . . . . . . . . . . . . . . . . . 14\n       4.2.8.  Signature\
    \  . . . . . . . . . . . . . . . . . . . . . . 14\n       4.2.9.  Example  . .\
    \ . . . . . . . . . . . . . . . . . . . . . 15\n   5.  Payload and Certificate\
    \ Blocks . . . . . . . . . . . . . . . . 15\n     5.1.  Preliminaries: Key Management\
    \ and Distribution Issues  . . 15\n     5.2.  Payload Block  . . . . . . . . .\
    \ . . . . . . . . . . . . . 16\n       5.2.1.  Block Format and Fields  . . .\
    \ . . . . . . . . . . . . 16\n       5.2.2.  Signer Authentication and Authorization\
    \  . . . . . . . 18\n     5.3.  Certificate Block  . . . . . . . . . . . . . .\
    \ . . . . . . 19\n       5.3.1.  Syslog Messages Containing a Certificate Block\
    \ . . . . 19\n       5.3.2.  Certificate Block Format and Fields  . . . . . .\
    \ . . . 20\n   6.  Redundancy and Flexibility . . . . . . . . . . . . . . . .\
    \ . . 24\n     6.1.  Configuration Parameters . . . . . . . . . . . . . . . .\
    \ . 24\n       6.1.1.  Configuration Parameters for Certificate Blocks  . . .\
    \ 24\n       6.1.2.  Configuration Parameters for Signature Blocks  . . . . 26\n\
    \     6.2.  Overlapping Signature Blocks . . . . . . . . . . . . . . . 27\n  \
    \ 7.  Efficient Verification of Logs . . . . . . . . . . . . . . . . 27\n    \
    \ 7.1.  Offline Review of Logs . . . . . . . . . . . . . . . . . . 28\n     7.2.\
    \  Online Review of Logs  . . . . . . . . . . . . . . . . . . 29\n   8.  Security\
    \ Considerations  . . . . . . . . . . . . . . . . . . . 32\n     8.1.  Cryptographic\
    \ Constraints  . . . . . . . . . . . . . . . . 32\n     8.2.  Packet Parameters\
    \  . . . . . . . . . . . . . . . . . . . . 33\n     8.3.  Message Authenticity\
    \ . . . . . . . . . . . . . . . . . . . 33\n     8.4.  Replaying  . . . . . .\
    \ . . . . . . . . . . . . . . . . . . 33\n     8.5.  Reliable Delivery  . . .\
    \ . . . . . . . . . . . . . . . . . 34\n     8.6.  Sequenced Delivery . . . .\
    \ . . . . . . . . . . . . . . . . 34\n     8.7.  Message Integrity  . . . . .\
    \ . . . . . . . . . . . . . . . 34\n     8.8.  Message Observation  . . . . .\
    \ . . . . . . . . . . . . . . 34\n     8.9.  Man-in-the-Middle Attacks  . . .\
    \ . . . . . . . . . . . . . 34\n     8.10. Denial of Service  . . . . . . . .\
    \ . . . . . . . . . . . . 35\n     8.11. Covert Channels  . . . . . . . . . .\
    \ . . . . . . . . . . . 35\n   9.  IANA Considerations  . . . . . . . . . . .\
    \ . . . . . . . . . . 35\n     9.1.  Structured Data and Syslog Messages  . .\
    \ . . . . . . . . . 35\n     9.2.  Version Field  . . . . . . . . . . . . . .\
    \ . . . . . . . . 36\n     9.3.  SG Field . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . 38\n     9.4.  Key Blob Type  . . . . . . . . . . . . . . . .\
    \ . . . . . . 38\n   10. Acknowledgements . . . . . . . . . . . . . . . . . .\
    \ . . . . . 39\n   11. References . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . 39\n     11.1. Normative References . . . . . . . . . . . . . . . .\
    \ . . . 39\n     11.2. Informative References . . . . . . . . . . . . . . . .\
    \ . . 40\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes a mechanism, called syslog-sign\
    \ in this\n   document, that adds origin authentication, message integrity, replay\n\
    \   resistance, message sequencing, and detection of missing messages to\n   syslog.\
    \  Essentially, this is accomplished by sending a special\n   syslog message.\
    \  The content of this syslog message is called a\n   Signature Block.  Each Signature\
    \ Block contains, in effect, a\n   detached signature on some number of previously\
    \ sent messages.  It is\n   cryptographically signed and contains the hashes of\
    \ previously sent\n   syslog messages.  The originator of syslog-sign messages\
    \ is simply\n   referred to as a \"signer\".  The signer can be the same originator\
    \ as\n   the originator whose messages it signs, or it can be a separate\n   originator.\n\
    \   While most implementations of syslog involve only a single originator\n  \
    \ and a single collector of each message, provisions need to be made to\n   cover\
    \ situations in which messages are sent to multiple collectors.\n   This concerns,\
    \ in particular, situations in which different messages\n   from the same originator\
    \ are sent to different collectors, which\n   means that some messages are sent\
    \ to some collectors but not to\n   others.  The required differentiation of messages\
    \ is generally\n   performed based on the Priority value of the individual messages.\n\
    \   For example, messages from any Facility with a Severity value of 3,\n   2,\
    \ 1, or 0 may be sent to one collector while all messages of\n   Facilities 4,\
    \ 10, 13, and 14 may be sent to another collector.\n   Appropriate syslog-sign\
    \ messages must be kept with their proper\n   syslog messages.  To address this,\
    \ syslog-sign uses a Signature\n   Group.  A Signature Group identifies a group\
    \ of messages that are all\n   kept together for signing purposes by the signer.\
    \  A Signature Block\n   always belongs to exactly one Signature Group and always\
    \ signs\n   messages belonging only to that Signature Group.\n   Additionally,\
    \ a signer sends Certificate Blocks to provide key\n   management information\
    \ between the signer and the collector.  A\n   Certificate Block has a field to\
    \ denote the type of key material\n   which may be such things as a Public Key\
    \ Infrastructure using X.509\n   (PKIX) certificate, an OpenPGP (Pretty Good Privacy)\
    \ certificate, or\n   even an indication that a key had been pre-distributed.\
    \  In the cases\n   of certificates being sent, the certificates may have to be\
    \ split\n   across multiple Certificate Blocks carried in separate messages.\n\
    \   It is possible that the same host contains multiple signers that each\n  \
    \ use their own keys to sign syslog messages.  In this case, each\n   signer sends\
    \ its own Certificate Block and Signature Blocks.\n   Furthermore, each signer\
    \ defines its own Signature Groups.  Each\n   signer on a given host needs to\
    \ use a distinct combination of APP-\n   NAME, and PROCID for its Signature Block\
    \ and Certificate Block\n   message.  (This implies that the combination of HOSTNAME,\
    \ APP-NAME,\n   and PROCID uniquely distinguishes originators of syslog-sign messages\n\
    \   across hosts, provided that the signers use a unique HOSTNAME.)\n   The collector\
    \ may verify that the hash of each received message\n   matches the signed hash\
    \ contained in the corresponding Signature\n   Block.  A collector may process\
    \ these Signature Blocks as they\n   arrive, building an authenticated log file.\
    \  Alternatively, it may\n   store all the log messages in the order they were\
    \ received.  This\n   allows a network operator to authenticate the log file at\
    \ the time\n   the logs are reviewed.\n   The process of signing works as long\
    \ as the collector accepts the\n   syslog messages, the Certificate Blocks and\
    \ the Signature Blocks.\n   Once that is done, the process is complete.  After\
    \ that, anyone can\n   go back, find the key material, and validate the received\
    \ messages\n   using the information in the Signature Blocks.  Finding the key\n\
    \   material is very easily done with Key Blob Types C, P, and K (see\n   Section\
    \ 4.2) since the public key is in the Payload Block.  If Key\n   Blob Types N\
    \ or U are used, some poking around may be required to\n   find the key material.\
    \  The only way to have a vendor-specific\n   implementation is through N or U;\
    \ however, also in that case, the key\n   material will have to be available in\
    \ some form which could be used\n   by implementations of other vendors.\n   Because\
    \ the mechanism that is described in this specification uses\n   the concept of\
    \ STRUCTURED-DATA elements defined in [RFC5424],\n   compliant implementations\
    \ of this specification MUST also implement\n   [RFC5424].  It is conceivable\
    \ that the concepts underlying this\n   specification could also be used in conjunction\
    \ with other message-\n   delivery mechanisms.  Designers of other efforts to\
    \ define event\n   notification mechanisms are therefore encouraged to consider\
    \ this\n   specification in their designs.\n"
- title: 2.  Conventions Used in This Document
  contents:
  - "2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 3.  Syslog Message Format
  contents:
  - "3.  Syslog Message Format\n   This specification is intended to be used in conjunction\
    \ with the\n   syslog protocol as defined in [RFC5424].  The syslog protocol\n\
    \   therefore MUST be supported by implementations of this specification.\n  \
    \ Because the originator generating the Signature Block message, also\n   simply\
    \ referred to as \"signer\", signs each message in its entirety,\n   the messages\
    \ MUST NOT be changed in transit.  By the same token, the\n   syslog-sign messages\
    \ MUST NOT be changed in transit.  One of the\n   effects of such behavior, including\
    \ message alteration by relays,\n   would be to render any signing invalid and\
    \ hence make the mechanism\n   useless.  Likewise, any truncation of messages\
    \ that occurs between\n   sending and receiving renders the mechanism useless.\
    \  For this\n   reason, syslog signer and collector implementations implementing\
    \ this\n   specification MUST support messages of up to and including 2048\n \
    \  octets in length, in order to minimize the chance of truncation.\n   While\
    \ syslog signer and collector implementations MAY support\n   messages with a\
    \ length longer than 2048 octets, implementers need to\n   be aware that any message\
    \ truncations that occur render the mechanism\n   useless.  In such cases, it\
    \ is up to the operator to ensure that the\n   syslog messages can be received\
    \ properly and can be validated.\n   [RFC5426] recommends using the Transport\
    \ Layer Security (TLS)\n   transport and deliberately constrains the use of UDP.\
    \  UDP is NOT\n   RECOMMENDED for use with signed syslog because its recommended\n\
    \   payload size of 480 octets is too restrictive for the purposes of\n   syslog-sign.\
    \  A 480-octet Signature Block could sign only 9 normal\n   messages, meaning\
    \ that at a significant proportion of messages would\n   be Signature Block messages.\
    \  The 480-octet limitation is primarily\n   geared towards small embedded systems\
    \ with significant resource\n   constraints that, because of those constraints,\
    \ would not implement\n   syslog-sign in the first place.  In addition, the use\
    \ of UDP is\n   geared towards syslog messages that are primarily intended for\n\
    \   troubleshooting, a very different purpose from the application\n   targeted\
    \ by syslog-sign.  Where syslog UDP transport is used, it is\n   the responsibility\
    \ of operators to ensure that network paths are\n   configured in a way that messages\
    \ of sufficient length (up to and\n   including 2048 octets) can be properly delivered.\n\
    \   This specification uses the syslog message format described in\n   [RFC5424].\
    \  Along with other fields, that document describes the\n   concept of Structured\
    \ Data (SD).  Structured Data is defined in terms\n   of SD ELEMENTS (SDEs). \
    \ An SDE consists of a name and a set of\n   parameter name-value pairs.  The\
    \ SDE name is referred to as SD-ID.\n   The name-value pairs are referred to as\
    \ SD-PARAM, or SD Parameters,\n   with the name constituting the SD-PARAM-NAME,\
    \ and the value\n   constituting the SD-PARAM-VALUE.\n   The syslog messages defined\
    \ in this document carry the data that is\n   associated with Signature Blocks\
    \ and Certificate Blocks as Structured\n   Data.  For this purpose, the special\
    \ syslog messages defined in this\n   document include definitions of SDEs to\
    \ convey parameters that relate\n   to the signing of syslog messages.  The MSG\
    \ part of the syslog\n   messages defined in this document SHOULD simply be empty\
    \ -- the\n   content of the messages is not intended for interpretation by humans\n\
    \   but by applications that use those messages to build an authenticated\n  \
    \ log.\n   Because the syslog messages defined in this document adhere to the\n\
    \   format described in [RFC5424], they identify the machine that\n   originates\
    \ the syslog message in the HOSTNAME field.  Therefore, the\n   Signature Block\
    \ and Certificate Block data do not need to include any\n   additional parameter\
    \ to identify the machine that originates the\n   message.\n   In addition, several\
    \ signers MAY sign messages on a single host\n   independently of each other,\
    \ each using their own Signature Groups.\n   In that case, each unique signer\
    \ is distinguished by the combination\n   of APP-NAME and PROCID.  (By the same\
    \ token, the same message might\n   be signed by multiple signers.)  Each unique\
    \ signer MUST have a\n   unique APP-NAME and PROCID on each host.  (This implies\
    \ that the\n   combination of HOSTNAME, APP-NAME and PROCID uniquely distinguishes\n\
    \   the originator of syslog-sign messages, provided that the signers use\n  \
    \ a unique HOSTNAME.)  A Signature Block message MUST use the same\n   combination\
    \ of HOSTNAME, APP-NAME, and PROC-ID that was used to send\n   the corresponding\
    \ Certificate Block messages containing the Payload\n   Block.\n"
- title: 4.  Signature Blocks
  contents:
  - "4.  Signature Blocks\n   This section describes the format of the Signature Block\
    \ and the\n   fields used within the Signature Block, as well as the syslog\n\
    \   messages used to carry the Signature Block.\n"
- title: 4.1.  Syslog Messages Containing a Signature Block
  contents:
  - "4.1.  Syslog Messages Containing a Signature Block\n   There is a need to distinguish\
    \ the Signature Block itself from the\n   syslog message that is used to carry\
    \ a Signature Block.  Signature\n   Blocks MUST be encompassed within completely\
    \ formed syslog messages.\n   Syslog messages that contain a Signature Block are\
    \ also referred to\n   as Signature Block messages.\n   A Signature Block message\
    \ is identified by the presence of an SD\n   ELEMENT with an SD-ID with the value\
    \ \"ssign\".  In addition, a\n   Signature Block message MUST contain valid APP-NAME,\
    \ PROCID, and\n   MSGID fields to be compliant with [RFC5424].  This specification\
    \ does\n   not mandate particular values for these fields; however, for\n   consistency,\
    \ a signer MUST use the same values for APP-NAME, PROCID,\n   and MSGID fields\
    \ for every Signature Block message that is sent,\n   whichever values are chosen.\
    \  It MUST also use the same value for its\n   HOSTNAME field.  To allow for the\
    \ possibility of multiple signers per\n   host, the combination of APP-NAME and\
    \ PROCID MUST be unique for each\n   such signer on any given host.  If a signer\
    \ daemon is restarted, it\n   MAY use a new PROCID for what is otherwise the same\
    \ signer but MUST\n   continue to use the same APP-NAME.  If it uses a new PROCID,\
    \ it MUST\n   send a new Payload Block using Certificate Block messages that use\n\
    \   the same new PROCID (and the same APP-NAME).  It is RECOMMENDED (but\n   not\
    \ required) to use 110 as value for the PRI field, corresponding to\n   facility\
    \ 13 (log audit) and severity 6 (informational).  The\n   Signature Block is carried\
    \ as Structured Data within the Signature\n   Block message, per the definitions\
    \ that follow in the next section.\n   A Signature Block message MAY carry other\
    \ Structured Data besides the\n   Structured Data of the Signature Block itself.\
    \  The MSG part of a\n   Signature Block message SHOULD be empty.\n   The syslog\
    \ messages defined as part of syslog-sign themselves\n   (Signature Block messages\
    \ and Certificate Block messages) MUST NOT be\n   signed by a Signature Block.\
    \  Collectors that implement syslog-sign\n   know to distinguish syslog messages\
    \ that are associated with syslog-\n   sign from those that are subjected to signing\
    \ and process them\n   differently.  The intent of syslog-sign is to sign a stream\
    \ of syslog\n   messages, not to alter it.\n"
- title: 4.2.  Signature Block Format and Fields
  contents:
  - "4.2.  Signature Block Format and Fields\n   The content of a Signature Block\
    \ message is the Signature Block\n   itself.  The Signature Block MUST be encoded\
    \ as an SD ELEMENT, as\n   defined in [RFC5424].\n   The SD-ID MUST have the value\
    \ of \"ssign\".\n   The SDE contains the fields of the Signature Block encoded\
    \ as SD\n   Parameters, as specified in the following.  The Signature Block is\n\
    \   composed of the following fields.  The value of each field MUST be\n   printable\
    \ ASCII, and any binary values MUST be base64 encoded, as\n   defined in [RFC4648].\n\
    \      Field                     SD-PARAM-NAME        Size in octets\n      -----\
    \                     -------------        ---- -- ------\n      Version     \
    \                     VER                 4\n      Reboot Session ID         \
    \      RSID                1-10\n      Signature Group                   SG  \
    \               1\n      Signature Priority              SPRI                1-3\n\
    \      Global Block Counter             GBC                1-10\n      First Message\
    \ Number             FMN                1-10\n      Count                    \
    \        CNT                1-2\n      Hash Block                        HB  \
    \    variable, size of hash\n                                              times\
    \ the number of hashes\n                                               (base64\
    \ encoded binary)\n      Signature                       SIGN             variable\n\
    \                                               (base64 encoded binary)\n   The\
    \ fields MUST be provided in the order listed.  Each SD parameter\n   MUST occur\
    \ once and only once in the Signature Block.  New SD\n   parameters MUST NOT be\
    \ added unless a new Version of the protocol is\n   defined.  (Implementations\
    \ that wish to add proprietary extensions\n   will need to define a separate SD\
    \ ELEMENT.)  A Signature Block is\n   accordingly encoded as follows, where xxx\
    \ denotes a placeholder for\n   the particular values:\n   [ssign VER=\"xxx\"\
    \ RSID=\"xxx\" SG=\"xxx\" SPRI=\"xxx\" GBC=\"xxx\" FMN=\"xxx\"\n   CNT=\"xxx\"\
    \ HB=\"xxx\" SIGN=\"xxx\"]\n   Values of the fields constitute SD parameter values\
    \ and are hence\n   enclosed in quotes, per [RFC5424].  The fields are separated\
    \ by\n   single spaces and are described in the subsequent subsections.\n"
- title: 4.2.1.  Version
  contents:
  - "4.2.1.  Version\n   The Version field is an alphanumeric value that has a length\
    \ of 4\n   octets, which may include leading zeroes.  The first 2 octets and the\n\
    \   last octet contain a decimal character in the range of \"0\" to \"9\",\n \
    \  whereas the third octet contains an alphanumeric character in the\n   range\
    \ of \"0\" to \"9\", \"a\" to \"z\", or \"A\" to \"Z\".  The value in this\n \
    \  field specifies the version of the syslog-sign protocol.  This is\n   extensible\
    \ to allow for different hash algorithms and signature\n   schemes to be used\
    \ in the future.  The value of this field is the\n   grouping of the protocol\
    \ version (2 octets), the hash algorithm (1\n   octet), and the signature scheme\
    \ (1 octet).\n      Protocol Version - 2 octets, with \"01\" as the value for\
    \ the\n      protocol version that is described in this document.\n      Hash\
    \ Algorithm - 1 octet, where, in conjunction with Protocol\n      Version 01,\
    \ a value of \"1\" denotes SHA1 and a value of \"2\" denotes\n      SHA256, as\
    \ defined in [FIPS.180-2.2002].  (This is the octet that\n      can have a value\
    \ of not just \"0\" to \"9\" but also \"a\" to \"z\" and\n      \"A\" to \"Z\"\
    .)\n      Signature Scheme - 1 octet, where, in conjunction with Protocol\n  \
    \    Version 01, a value of \"1\" denotes OpenPGP DSA, defined in\n      [RFC4880]\
    \ and [FIPS.186-2.2000].\n   The version, hash algorithm, and signature scheme\
    \ defined in this\n   document would accordingly be represented as \"0111\" (if\
    \ SHA1 is used\n   as Hash Algorithm) and \"0121\" (if SHA256 is used as Hash\
    \ Algorithm),\n   respectively (without the quotation marks).\n   The values of\
    \ the Hash Algorithm and Signature Scheme are defined\n   relative to the Protocol\
    \ Version.  If the single-octet representation\n   of the values for Hash Algorithm\
    \ and Signature Scheme were to ever\n   represent a limitation, this limitation\
    \ could be overcome by defining\n   a new Protocol Version with additional Hash\
    \ Algorithms and/or\n   Signature Schemes, and having implementations support\
    \ both Protocol\n   Versions concurrently.\n   As long as the sender and receiver\
    \ are both adhering to [RFC5424],\n   the prerequisites are in place so that signed\
    \ messages can be\n   received by the receiver and validated with a Signature\
    \ Block.  To\n   ensure immediate validation of received messages, all implementations\n\
    \   MUST support SHA1, and SHA256 SHOULD be supported.\n"
- title: 4.2.2.  Reboot Session ID
  contents:
  - "4.2.2.  Reboot Session ID\n   The Reboot Session ID is a decimal value that has\
    \ a length between 1\n   and 10 octets.  The acceptable values for this are between\
    \ 0 and\n   9999999999.  Leading zeroes MUST be omitted.\n   A Reboot Session\
    \ ID is expected to strictly monotonically increase\n   (i.e., to never repeat\
    \ or decrease) whenever a signer reboots in\n   order to allow collectors to distinguish\
    \ messages and message\n   signatures across reboots.  There are several ways\
    \ in which this may\n   be accomplished.  In one way, the Reboot Session ID may\
    \ increase by\n   1, starting with a value of 1.  Note that in this case, a signer\
    \ is\n   required to retain the previous Reboot Session ID across reboots.  In\n\
    \   another way, a value of the Unix time (number of seconds since 1\n   January\
    \ 1970) may be used.  Implementers of this method need to\n   beware of the possibility\
    \ of multiple reboots occurring within a\n   single second.  Implementers need\
    \ to also beware of the year 2038\n   problem, which will cause the 32-bit representation\
    \ of Unix time to\n   wrap in the year 2038.  In yet another way, implementations\
    \ where the\n   Simple Network Management Protocol (SNMP) engine and the signer\n\
    \   always reboot at the same time might consider using the\n   snmpEngineBoots\
    \ value as a source for this counter as defined in\n   [RFC3414].\n   In cases\
    \ where a signer is not able to guarantee that the Reboot\n   Session ID is always\
    \ increased after a reboot, the Reboot Session ID\n   MUST always be set to a\
    \ value of 0.  If the value can no longer be\n   increased (e.g., because it reaches\
    \ 9999999999), it SHOULD be reset\n   to a value of 1.  Implementations SHOULD\
    \ ensure that such a reset\n   does not go undetected, for example, by requesting\
    \ operator\n   acknowledgment when a reset is performed upon reboot.  (Operator\n\
    \   acknowledgment may not be possible in all situations, e.g., in the\n   case\
    \ of embedded devices.)\n   If a reboot of a signer takes place, Signature Block\
    \ messages MAY use\n   a new PROCID.  However, Signature Block messages of the\
    \ same signer\n   MUST continue to use the same HOSTNAME, APP-NAME, and MSGID.\n"
- title: 4.2.3.  Signature Group and Signature Priority
  contents:
  - "4.2.3.  Signature Group and Signature Priority\n   The SG parameter may take\
    \ any value from 0-3 inclusive.  The SPRI\n   parameter may take any value from\
    \ 0-191 inclusive.  These fields\n   taken together allow network administrators\
    \ to associate groupings of\n   syslog messages with appropriate Signature Blocks\
    \ and Certificate\n   Blocks.  Groupings of syslog messages that are signed together\
    \ are\n   also called Signature Groups.  A Signature Block contains only hashes\n\
    \   of those syslog messages that are part of the same Signature Group.\n   For\
    \ example, in some cases, network administrators might have\n   originators send\
    \ syslog messages of Facilities 0 through 15 to one\n   collector and those with\
    \ Facilities 16 through 23 to another.  In\n   such cases, associated Signature\
    \ Blocks should likely be sent to the\n   corresponding collectors as well, signing\
    \ the syslog messages that\n   are intended for each collector separately.  This\
    \ way, each collector\n   receives Signature Blocks for all syslog messages that\
    \ it receives,\n   and only for those.  The ability to associate different categories\
    \ of\n   syslog messages with different Signature Groups, signed in separate\n\
    \   Signature Blocks, provides administrators with flexibility in this\n   regard.\n\
    \   Syslog-sign provides four options for handling Signature Groups,\n   linking\
    \ them with PRI values so they may be routed to the destination\n   commensurate\
    \ with the corresponding syslog messages.  In all cases,\n   no more than 192\
    \ distinct Signature Groups (0-191) are permitted.\n   The Signature Group to\
    \ which a Signature Block pertains is indicated\n   by the Signature Priority\
    \ (SPRI) field.  The Signature Group (SG)\n   field indicates how to interpret\
    \ the Signature Priority field.  (Note\n   that the SG field does not indicate\
    \ the Signature Group itself, as\n   its name might suggest.)  The SG field can\
    \ have one of the following\n   values:\n   a.  \"0\" -- There is only one Signature\
    \ Group.  In this case, the\n       administrators want all Signature Blocks to\
    \ be sent to a single\n       destination; in all likelihood, all of the syslog\
    \ messages will\n       also be going to that same destination.  Signature Blocks\
    \ contain\n       signatures for all messages regardless of their PRI value. \
    \ This\n       means that, in effect, the Signature Block's SPRI value can be\n\
    \       ignored.  However, it is RECOMMENDED that a single SPRI value be\n   \
    \    used for all Signature Blocks.  Furthermore, it is RECOMMENDED to\n     \
    \  set that value to the same value as the PRI field of the\n       Signature\
    \ Block message.  This way, the PRI of the Signature\n       Block message matches\
    \ the SPRI of the Signature Block that it\n       contains.\n   b.  \"1\" -- Each\
    \ PRI value is associated with its own Signature Group.\n       Signature Blocks\
    \ for a given Signature Group have SPRI = PRI for\n       that Signature Group.\
    \  In other words, the SPRI of the Signature\n       Block matches the PRI value\
    \ of the syslog messages that are part\n       of the Signature Group and hence\
    \ signed by the Signature Block.\n       An SG value of 1 can, for example, be\
    \ used when the administrator\n       of a signer does not know where any of the\
    \ syslog messages will\n       ultimately go but anticipates that messages with\
    \ different PRI\n       values will be collected and processed separately.  Having\
    \ a\n       Signature Group per PRI value provides administrators with a\n   \
    \    large degree of flexibility with regard to how to divide up the\n       processing\
    \ of syslog messages and their signatures after they are\n       received, at\
    \ the same time allowing Signature Blocks to follow\n       the corresponding\
    \ syslog messages to their eventual destination.\n   c.  \"2\" -- Each Signature\
    \ Group contains a range of PRI values.\n       Signature Groups are assigned\
    \ sequentially.  A Signature Block\n       for a given Signature Group has its\
    \ own SPRI value denoting the\n       highest PRI value of syslog messages in\
    \ that Signature Group.\n       The lowest PRI value of syslog messages in that\
    \ Signature Group\n       will be 1 larger than the SPRI value of the previous\
    \ Signature\n       Group or \"0\" in case there is no other Signature Group with\
    \ a\n       lower SPRI value.  The specific Signature Groups and ranges they\n\
    \       are associated with are subject to configuration by a system\n       administrator.\n\
    \   d.  \"3\" -- Signature Groups are not assigned with any of the above\n   \
    \    relationships to PRI values of the syslog messages they sign.\n       Instead,\
    \ another scheme is used, which is outside the scope of\n       this specification.\
    \  There has to be some predefined arrangement\n       between the originator\
    \ and the intended collectors as to which\n       syslog messages are to be included\
    \ in which Signature Group,\n       requiring configuration by a system administrator.\
    \  This also\n       provides administrators with the flexibility to group syslog\n\
    \       messages into Signature Groups according to criteria that are not\n  \
    \     tied to the PRI value.  Note that this option is not intended for\n    \
    \   deployments that lack such an arrangement, as in those cases a\n       collector\
    \ could misinterpret the intended meaning of the\n       Signature Group.  A collector\
    \ that receives Signature Block\n       messages of a Signature Group of whose\
    \ scheme it is not aware\n       SHOULD bring this fact to the attention of the\
    \ system\n       administrator.  The particular mechanism used for that is\n \
    \      implementation-specific and outside the scope of this\n       specification.\n\
    \   One reasonable way to configure some installations is to have only\n   one\
    \ Signature Group, indicated with SG=0, and have the signer send a\n   copy of\
    \ each Signature Block to each collector.  In that case,\n   collectors that are\
    \ not configured to receive every syslog message\n   will still receive signatures\
    \ for every message, even ones they are\n   not supposed to receive.  While the\
    \ collector will not be able to\n   detect gaps in the messages (because the presence\
    \ of a signature of a\n   message that is missing does not tell the collector\
    \ whether or not\n   the corresponding message would be of the collector's concern),\
    \ it\n   does allow all messages that do arrive at each collector to be put\n\
    \   into the right order and to be verified.  It also allows each\n   collector\
    \ to detect duplicates.  Likewise, configuring only one\n   Signature Group can\
    \ be a reasonable way to configure installations\n   that involve relay chains,\
    \ where one or more interim relays may or\n   may not relay all messages to the\
    \ same destination.\n"
- title: 4.2.4.  Global Block Counter
  contents:
  - "4.2.4.  Global Block Counter\n   The Global Block Counter is a decimal value\
    \ representing the number\n   of Signature Blocks sent by syslog-sign before the\
    \ current one, in\n   this reboot session.  This takes at least 1 octet and at\
    \ most 10\n   octets displayed as a decimal counter.  The acceptable values for\n\
    \   this are between 0 and 9999999999, starting with 0.  Leading zeroes\n   MUST\
    \ be omitted.  If the value of the Global Block Counter has\n   reached 9999999999\
    \ and the Reboot Session ID has a value other than 0\n   (indicating the fact\
    \ that persistence of the Reboot Session ID is\n   supported), then the Reboot\
    \ Session ID MUST be incremented by 1 and\n   the Global Block Counter resumes\
    \ at 0.  When the Reboot Session ID is\n   0 (i.e., persistent Reboot Session\
    \ IDs are not supported) and the\n   Global Block Counter reaches its maximum\
    \ value, then the Global Block\n   Counter is reset to 0 and the Reboot Session\
    \ ID MUST remain at 0.\n   Note that the Global Block Counter crosses Signature\
    \ Groups; it\n   allows one to roughly synchronize when two messages were sent,\
    \ even\n   though they went to different collectors and are part of different\n\
    \   Signature Groups.\n   Because a reboot results in the start of a new reboot\
    \ session, the\n   signer MUST reset the Global Block Counter to 0 after a reboot\n\
    \   occurs.  Applications need to take into account the possibility that\n   a\
    \ reboot occurred when authenticating a log, and situations in which\n   reboots\
    \ occur frequently may result in losing the ability to verify\n   the proper sequence\
    \ in which messages were sent, hence jeopardizing\n   the integrity of the log.\n"
- title: 4.2.5.  First Message Number
  contents:
  - "4.2.5.  First Message Number\n   This is a decimal value between 1 and 10 octets,\
    \ with leading zeroes\n   omitted.  It contains the unique message number within\
    \ this Signature\n   Group of the first message whose hash appears in this block.\
    \  The\n   very first message of the reboot session is numbered \"1\".  This\n\
    \   implies that when the Reboot Session ID increases, the message number\n  \
    \ is reset to 1.\n   For example, if this Signature Group has processed 1000 messages\
    \ so\n   far and message number 1001 is the first message whose hash appears\n\
    \   in this Signature Block, then this field contains 1001.  The message\n   number\
    \ is relative to the Signature Group to which it belongs; hence,\n   a message\
    \ number does not identify a message beyond its Signature\n   Group.\n   Should\
    \ the message number reach 9999999999 within the same reboot\n   session and Signature\
    \ Group, the message number subsequently restarts\n   at 1.  In such an event,\
    \ the Global Block Counter will be vastly\n   different between two occurrences\
    \ of the same message number.\n"
- title: 4.2.6.  Count
  contents:
  - "4.2.6.  Count\n   The count is a 1- or 2-octet field that indicates the number\
    \ of\n   message hashes to follow.  The valid values for this field are 1\n  \
    \ through 99.  The number of hashes included in the Signature Block\n   MUST be\
    \ chosen such that the length of the resulting syslog message\n   does not exceed\
    \ the maximum permissible syslog message length.\n"
- title: 4.2.7.  Hash Block
  contents:
  - "4.2.7.  Hash Block\n   The hash block is a block of hashes, each separately encoded\
    \ in\n   base64.  Each hash in the hash block is the hash of the entire syslog\n\
    \   message represented by the hash, independent of the underlying\n   transport.\
    \  Hashes are ordered from left to right in the order of\n   occurrence of the\
    \ syslog messages that they represent.  The space\n   character is used to separate\
    \ the hashes.  Note, the hash block\n   constitutes a single SD-PARAM; a Signature\
    \ Block message MUST include\n   all its hashes in a single hash block and MUST\
    \ NOT spread its hashes\n   across several hash blocks.\n   The \"entire syslog\
    \ message\" refers to what is described as the syslog\n   message excluding transport\
    \ parts that are described in [RFC5425] and\n   [RFC5426], and excluding other\
    \ parts that may be defined in future\n   transports.  The hash value will be\
    \ the result of the hashing\n   algorithm run across the syslog message, starting\
    \ with the \"<\" of the\n   PRI portion of the header part of the message.  The\
    \ hash algorithm\n   used and indicated by the Version field determines the size\
    \ of each\n   hash, but the size MUST NOT be shorter than 160 bits without the\
    \ use\n   of padding.  It is base64 encoded as per [RFC4648].\n   The number of\
    \ hashes in a hash block SHOULD be chosen such that the\n   resulting Signature\
    \ Block message does not exceed a length of 2048\n   octets in order to avoid\
    \ the possibility that truncation occurs.\n   When more hashes need to be sent\
    \ than fit inside a Signature Block\n   message, it is advisable to start a new\
    \ Signature Block.\n"
- title: 4.2.8.  Signature
  contents:
  - "4.2.8.  Signature\n   This is a digital signature, encoded in base64 per [RFC4648].\
    \  The\n   signature is calculated over the completely formatted Signature Block\n\
    \   message (starting from the first octet of PRI and continuing to the\n   last\
    \ octet of MSG, or STRUCTURED-DATA if MSG is not present), before\n   the SIGN\
    \ parameter (SD Parameter Name and the space before it\n   [\" SIGN\"], \"=\"\
    , and the corresponding value) is added.  (In other\n   words, the digital signature\
    \ is calculated over the whole message,\n   with the \"SIGN=value\" portion removed.)\
    \  For the OpenPGP DSA\n   signature scheme, the value of the signature field\
    \ contains the DSA\n   values r and s, encoded as two multiprecision integers\
    \ (see\n   [RFC4880], Sections 5.2.2 and 3.2), concatenated, and then encoded\
    \ in\n   base64 [RFC4648].\n"
- title: 4.2.9.  Example
  contents:
  - "4.2.9.  Example\n   An example of a Signature Block message is depicted below,\
    \ broken\n   into lines to fit publication rules.  There is a space at the end\
    \ of\n   each line, with the exception of the last line, which ends with \"]\"\
    .\n   <110>1 2009-05-03T14:00:39.529966+02:00 host.example.org syslogd\n   2138\
    \ - [ssign VER=\"0111\" RSID=\"1\" SG=\"0\" SPRI=\"0\" GBC=\"2\" FMN=\"1\"\n \
    \  CNT=\"7\" HB=\"K6wzcombEvKJ+UTMcn9bPryAeaU= zrkDcIeaDluypaPCY8WWzwHpPok=\n\
    \   zgrWOdpx16ADc7UmckyIFY53icE= XfopJ+S8/hODapiBBCgVQaLqBKg=\n   J67gKMFl/OauTC20ibbydwIlJC8=\
    \ M5GziVgB6KPY3ERU1HXdSi2vtdw=\n   Wxd/lU7uG/ipEYT9xeqnsfohyH0=\"\n   SIGN=\"\
    AKBbX4J7QkrwuwdbV7Taujk2lvOf8gCgC62We1QYfnrNHz7FzAvdySuMyfM=\"]\n   The message\
    \ is of syslog-sign protocol version \"01\".  It uses SHA1 as\n   hash algorithm\
    \ and an OpenPGP DSA signature scheme.  Its reboot\n   session ID is 1.  Its Signature\
    \ Group is 0, which means that all\n   syslog messages go to the same destination;\
    \ its Signature Priority\n   (which can effectively be ignored because all syslog\
    \ messages will be\n   signed regardless of their PRI value) is 0.  Its Global\
    \ Block Counter\n   is 2.  The first message number is 1; the message contains\
    \ 7 message\n   hashes.\n"
- title: 5.  Payload and Certificate Blocks
  contents:
  - "5.  Payload and Certificate Blocks\n   Certificate Blocks and Payload Blocks\
    \ provide key management for\n   syslog-sign.  Their purpose is to support key\
    \ management that uses\n   public key cryptosystems.\n"
- title: '5.1.  Preliminaries: Key Management and Distribution Issues'
  contents:
  - "5.1.  Preliminaries: Key Management and Distribution Issues\n   A Payload Block\
    \ contains public-key-certificate information that is\n   to be conveyed to the\
    \ collector.  A Payload Block is sent at the\n   beginning of a new reboot session,\
    \ carrying public key information in\n   effect for the reboot session.  However,\
    \ a Payload Block is not sent\n   directly, but in (one or more) fragments.  Those\
    \ fragments are termed\n   Certificate Blocks.  Therefore, signers send at least\
    \ one Certificate\n   Block at the beginning of a new reboot session.\n   There\
    \ are three key points to understand about Certificate Blocks:\n   a.  They handle\
    \ a variable-sized payload, fragmenting it if necessary\n       and transmitting\
    \ the fragments as legal syslog messages.  This\n       payload is built (as described\
    \ below) at the beginning of a\n       reboot session and is transmitted in pieces\
    \ with each Certificate\n       Block carrying a piece.  There is exactly one\
    \ Payload Block per\n       reboot session.\n   b.  The Certificate Blocks are\
    \ digitally signed.  The signer does not\n       sign the Payload Block, but the\
    \ signatures on the Certificate\n       Blocks ensure its authenticity.  Note\
    \ that it may not even be\n       possible to verify the signature on the Certificate\
    \ Blocks\n       without the information in the Payload Block; in this case, the\n\
    \       Payload Block is reconstructed, the key is extracted, and then\n     \
    \  the Certificate Blocks are verified.  (This is necessary even\n       when\
    \ the Payload Block carries a certificate, because some other\n       fields of\
    \ the Payload Block are not otherwise verified.)  In\n       practice, most installations\
    \ keep the same public key over long\n       periods of time, so that most of\
    \ the time, it is easy to verify\n       the signatures on the Certificate Blocks,\
    \ and use the Payload\n       Block to provide other useful per-session information.\n\
    \   c.  The kind of Payload Block that is expected is determined by what\n   \
    \    kind of key material is on the collector that receives it.  The\n       signer\
    \ and collector (or offline log viewer) both have some key\n       material (such\
    \ as a root public key or pre-distributed public\n       key) and an acceptable\
    \ value for the Key Blob Type in the Payload\n       Block, below.  The collector\
    \ or offline log viewer MUST NOT\n       accept a Payload Block of the wrong type.\n"
- title: 5.2.  Payload Block
  contents:
  - "5.2.  Payload Block\n   The Payload Block is built when a new reboot session\
    \ is started.\n   There is a one-to-one correspondence between reboot sessions\
    \ and\n   Payload Blocks.  A signer creates a new Payload Block after each\n \
    \  reboot.  The Payload Block is used until the next reboot.\n"
- title: 5.2.1.  Block Format and Fields
  contents:
  - "5.2.1.  Block Format and Fields\n   A Payload Block MUST have the following fields:\n\
    \   a.  Full local timestamp for the signer at the time the reboot\n       session\
    \ started.  This must be in the timestamp format specified\n       in [RFC5424]\
    \ (essentially, timestamp format per [RFC3339] with\n       some further restrictions).\n\
    \   b.  Key Blob Type, a one-octet field containing one of five values:\n    \
    \   1.  'C' -- a PKIX certificate (per [RFC5280]).\n       2.  'P' -- an OpenPGP\
    \ KeyID and OpenPGP certificate (a\n           Transferable Public Key as defined\
    \ in [RFC4880], Section\n           11.1).  The first 8 octets of the key blob\
    \ field contain the\n           OpenPGP KeyID (identifying which key or subkey\
    \ inside the\n           OpenPGP certificate is used), followed by the OpenPGP\n\
    \           certificate itself.\n       3.  'K' -- the public key whose corresponding\
    \ private key is\n           being used to sign these messages.  For the OpenPGP\
    \ DSA\n           signature scheme, the key blob field contains the DSA prime\n\
    \           p, DSA group order q, DSA group generator g, and DSA public-\n   \
    \        key value y, encoded as 4 multiprecision integers (see\n           [RFC4880],\
    \ Sections 5.5.2 and 3.2).\n       4.  'N' -- no key information sent; key is\
    \ pre-distributed.\n       5.  'U' -- installation-specific key exchange information.\n\
    \   c.  The key blob, if any, base64 encoded per [RFC4648] and consisting\n  \
    \     of the raw key data.\n   The fields are separated by single space characters.\
    \  Because a\n   Payload Block is not carried in a syslog message directly, only\
    \ the\n   corresponding Certificate Blocks, it does not need to be encoded as\n\
    \   an SD ELEMENT.  The Payload Block does not contain a field that\n   identifies\
    \ the reboot session; instead, the reboot session can be\n   inferred from the\
    \ Reboot Session ID parameter of the Certificate\n   Blocks that are used to carry\
    \ the Payload Block.\n   To ensure that the sender and receiver have at least\
    \ one common Key\n   Blob Type, for immediate validation of received messages,\
    \ all\n   implementations MUST support Key Blob Type \"C\" (PKIX certificate).\n\
    \   When a PKIX certificate is used (\"C\" Key Blob Type), it is the\n   certificate\
    \ specified in [RFC5280].  Per [RFC5425], syslog messages\n   may be transported\
    \ over the TLS protocol, even where there is no PKI.\n   If that transport is\
    \ used, then the device will already have a PKIX\n   certificate, and it MAY use\
    \ the private key associated with that\n   certificate to sign messages.  In the\
    \ case where there is no PKI, the\n   chain of trust of a PKIX certificate must\
    \ still be established to\n   meet conventional security requirements.  The methods\
    \ for doing this\n   are described in [RFC5425].\n"
- title: 5.2.2.  Signer Authentication and Authorization
  contents:
  - "5.2.2.  Signer Authentication and Authorization\n   When the collector receives\
    \ a Payload Block, it needs to determine\n   whether the signatures are to be\
    \ trusted.  The following methods are\n   in scope of this specification:\n  \
    \ a.  X.509 certification path validation: The collector is configured\n     \
    \  with one or more trust anchors (typically root Certification\n       Authority\
    \ (CA) certificates), which allow it to verify a binding\n       between the subject\
    \ name and the public key.  Certification path\n       validation is performed\
    \ as specified in [RFC5280].\n       If the HOSTNAME contains a Fully-Qualified\
    \ Domain Name (FQDN) or\n       an IP address, it is then compared against the\
    \ certificate as\n       described in [RFC5425], Section 5.2.  Comparing other\
    \ forms of\n       HOSTNAMEs is beyond the scope of this specification.\n    \
    \   Collectors SHOULD support this method.  Note that due to message\n       size\
    \ restrictions, syslog-sign sends only the end-entity\n       certificate in the\
    \ Payload Block.  Depending on the PKI\n       deployment, the collector may need\
    \ to obtain intermediate\n       certificates by other means (for example, from\
    \ a directory).\n   b.  X.509 end-entity certificate matching: The collector is\n\
    \       configured with information necessary to identify the valid end-\n   \
    \    entity certificates of its valid peers, and for each peer, the\n       HOSTNAME(s)\
    \ it is authorized to use.\n       To ensure interoperability, collectors MUST\
    \ support fingerprints\n       of X.509 certificates as described below.  Other\
    \ methods MAY be\n       supported.\n       Collectors MUST support Key Blob Type\
    \ 'C', and configuring the\n       list of valid peers using certificate fingerprints.\
    \  The\n       fingerprint is calculated and formatted as specified in\n     \
    \  [RFC5425], Section 4.2.2.\n       For each peer, the collector MUST support\
    \ configuring a list of\n       HOSTNAMEs that this peer is allowed to use either\
    \ as FQDNs or IP\n       addresses.  Other forms of HOSTNAMEs are beyond the scope\
    \ of this\n       specification.\n       If the locally configured FQDN is an\
    \ internationalized domain\n       name, conforming implementations MUST convert\
    \ it to the ASCII\n       Compatible Encoding (ACE) format for performing comparisons\
    \ as\n       specified in Section 7 of [RFC5280].  An exact case-insensitive\n\
    \       string match MUST be supported, but the implementation MAY also\n    \
    \   support wildcards of any type (\"*\", regular expressions, etc.) in\n    \
    \   locally configured names.\n       Signer implementations MUST provide a means\
    \ to generate a key\n       pair and self-signed certificate in the case that\
    \ a key pair and\n       certificate are not available through another mechanism,\
    \ and MUST\n       make the certificate fingerprint available through a management\n\
    \       interface.\n   c.  OpenPGP V4 fingerprints: Like X.509 fingerprints, except\
    \ Key Blob\n       Type 'P' is used, and the fingerprint is calculated as specified\n\
    \       in [RFC4880], Section 12.2.  When the fingerprint value is\n       displayed\
    \ or configured, each byte is represented in hexadecimal\n       (using two uppercase\
    \ ASCII characters), and space is added after\n       every second byte.  For\
    \ example: \"0830 2A52 2CD1 D712 6E76 6EEC\n       32A5 CAE1 03C8 4F6E\".\n  \
    \     Signers and collectors MAY support this method.\n   Other methods, such\
    \ as \"web of trust\", are beyond the scope of this\n   document.\n"
- title: 5.3.  Certificate Block
  contents:
  - "5.3.  Certificate Block\n   This section describes the format of the Certificate\
    \ Block and the\n   fields used within the Certificate Block, as well as the syslog\n\
    \   messages used to carry Certificate Blocks.\n"
- title: 5.3.1.  Syslog Messages Containing a Certificate Block
  contents:
  - "5.3.1.  Syslog Messages Containing a Certificate Block\n   Certificate Blocks\
    \ are used to get the Payload Block to the\n   collector.  As with a Signature\
    \ Block, each Certificate Block is\n   carried in its own syslog message, called\
    \ a Certificate Block\n   message.  In case separate collectors are associated\
    \ with different\n   Signature Groups, Certificate Block messages need to be sent\
    \ to each\n   collector.\n   Because certificates can legitimately be much longer\
    \ than 2048\n   octets, the Payload Block can be split up into several pieces,\
    \ with\n   each Certificate Block carrying a piece of the Payload Block.  Note\n\
    \   that the signer MAY make the Certificate Blocks of any legal length\n   (that\
    \ is, any length that keeps the entire Certificate Block message\n   within 2048\
    \ octets) that holds all the required fields.  Software\n   that processes Certificate\
    \ Blocks MUST deal correctly with blocks of\n   any legal length.  The length\
    \ of the fragment of the Payload Block\n   that a Certificate Block carries MUST\
    \ be at least one octet.  The\n   length SHOULD be chosen such that the length\
    \ of the Certificate Block\n   message does not exceed 2048 octets.\n   A Certificate\
    \ Block message is identified by the presence of an SD\n   ELEMENT with an SD-ID\
    \ with the value \"ssign-cert\".  In addition, a\n   Certificate Block message\
    \ MUST contain valid APP-NAME, PROCID, and\n   MSGID fields to be compliant with\
    \ syslog protocol.  Syslog-sign does\n   not mandate particular values for these\
    \ fields; however, for\n   consistency, a signer MUST use the same value for APP-NAME,\
    \ PROCID,\n   and MSGID fields for every Certificate Block message, whichever\n\
    \   values are chosen.  It MUST also use the same value for its HOSTNAME\n   field.\
    \  To allow for the possibility of multiple signers per host,\n   the combination\
    \ of APP-NAME and PROCID MUST be unique for each such\n   originator.  If a signer\
    \ daemon is restarted, it MAY use a new PROCID\n   for what is otherwise the same\
    \ signer.  The combination of APP-NAME\n   and PROCID MUST be the same that is\
    \ used for Signature Block messages\n   of the same signer; however, a different\
    \ MSGID MAY be used for\n   Signature Block and Certificate Block messages.  It\
    \ is RECOMMENDED to\n   use 110 as the value for the PRI field, corresponding\
    \ to facility 13\n   (log audit) and severity 6 (informational).  The Certificate\
    \ Block is\n   carried as Structured Data within the Certificate Block message.\
    \  A\n   Certificate Block message MAY carry other Structured Data besides the\n\
    \   Structured Data of the Certificate Block itself.  The MSG part of a\n   Certificate\
    \ Block message SHOULD be empty.\n"
- title: 5.3.2.  Certificate Block Format and Fields
  contents:
  - "5.3.2.  Certificate Block Format and Fields\n   The contents of a Certificate\
    \ Block message is the Certificate Block\n   itself.  Like a Signature Block,\
    \ the Certificate Block is encoded as\n   an SD ELEMENT.  The SD-ID of the Certificate\
    \ Block is \"ssign-cert\".\n   The Certificate Block is composed of the following\
    \ fields, each of\n   which is encoded as an SD Parameter with parameter name\
    \ as indicated.\n   Each field must be printable ASCII, and any binary values\
    \ are base64\n   encoded per [RFC4648].\n       Field                       SD-PARAM-NAME\
    \      Size in octets\n       -----                       -------------      ----\
    \ -- ------\n       Version                          VER                 4\n \
    \      Reboot Session ID               RSID                1-10\n       Signature\
    \ Group                   SG                 1\n       Signature Priority    \
    \          SPRI                1-3\n       Total Payload Block Length      TPBL\
    \                1-8\n       Index into Payload Block       INDEX            \
    \    1-8\n       Fragment Length                 FLEN                1-4\n   \
    \    Payload Block Fragment          FRAG              variable\n            \
    \                                    (base64 encoded binary)\n       Signature\
    \                       SIGN             variable\n                          \
    \                      (base64 encoded binary)\n   The fields MUST be provided\
    \ in the order listed.  New SD parameters\n   MUST NOT be added unless a new Version\
    \ of the protocol is defined.\n   (Implementations that wish to add proprietary\
    \ extensions will need to\n   define a separate SD ELEMENT.)  A Certificate Block\
    \ is accordingly\n   encoded as follows, where xxx denotes a placeholder for the\n\
    \   particular values:\n   [ssign-cert VER=\"xxx\" RSID=\"xxx\" SG=\"xxx\" SPRI=\"\
    xxx\" TPBL=\"xxx\"\n   INDEX=\"xxx\" FLEN=\"xxx\" FRAG=\"xxx\" SIGN=\"xxx\"]\n\
    \   Values of the fields constitute SD parameter values and are hence\n   enclosed\
    \ in quotes, per [RFC5424].  The fields are separated by\n   single spaces and\
    \ are described below.  Each SD parameter MUST occur\n   once and only once.\n"
- title: 5.3.2.1.  Version
  contents:
  - "5.3.2.1.  Version\n   The Version field is 4 octets in length.  This field is\
    \ identical in\n   format and meaning to the Version field described in Section\
    \ 4.2.1.\n"
- title: 5.3.2.2.  Reboot Session ID
  contents:
  - "5.3.2.2.  Reboot Session ID\n   The Reboot Session ID is identical in format\
    \ and meaning to the RSID\n   field described in Section 4.2.2.\n"
- title: 5.3.2.3.  Signature Group and Signature Priority
  contents:
  - "5.3.2.3.  Signature Group and Signature Priority\n   The SIG field is identical\
    \ in format and meaning to the SIG field\n   described in Section 4.2.3.  The\
    \ SPRI field is identical in format\n   and meaning to the SPRI field described\
    \ there.\n   A signer SHOULD send separate Certificate Block messages for each\n\
    \   Signature Group.  This ensures that each collector that is associated\n  \
    \ with a Signature Group will receive the necessary key material in the\n   case\
    \ that messages of different Signature Groups are sent to\n   different collectors.\
    \  Note that the signer needs to get the same\n   Payload Block to each collector,\
    \ as for any given signer there is a\n   one-to-one relationship between Payload\
    \ Block and Reboot Session\n   across all Signature Groups.  Deployments that\
    \ wish to associate\n   different key material (and hence different Payload Blocks)\
    \ with\n   different Signature Groups can use separate signers for that purpose,\n\
    \   each distinguished by its own combination of HOSTNAME, APP-NAME, and\n   PROCID.\n"
- title: 5.3.2.4.  Total Payload Block Length
  contents:
  - "5.3.2.4.  Total Payload Block Length\n   The Total Payload Block Length is a\
    \ value representing the total\n   length of the Payload Block in octets, expressed\
    \ as a decimal with 1\n   to 8 octets with leading zeroes omitted.\n"
- title: 5.3.2.5.  Index into Payload Block
  contents:
  - "5.3.2.5.  Index into Payload Block\n   This is a decimal value between 1 and\
    \ 8 octets, with leading zeroes\n   omitted.  It contains the number of octets\
    \ into the Payload Block at\n   which this fragment starts.  The first octet of\
    \ the first fragment is\n   numbered \"1\".  (Note, it is not numbered \"0\".)\n"
- title: 5.3.2.6.  Fragment Length
  contents:
  - "5.3.2.6.  Fragment Length\n   The total length of this fragment expressed as\
    \ a decimal integer with\n   1 to 4 octets with leading zeroes omitted.  The fragment\
    \ length must\n   be at least 1.\n"
- title: 5.3.2.7.  Payload Block Fragment
  contents:
  - "5.3.2.7.  Payload Block Fragment\n   The Payload Block Fragment contains a fragment\
    \ of the payload block.\n   Its length must match the indicated fragment length.\n"
- title: 5.3.2.8.  Signature
  contents:
  - "5.3.2.8.  Signature\n   This is a digital signature, encoded in base64, as per\
    \ [RFC4648].\n   The Version field effectively specifies the original encoding\
    \ of the\n   signature.  The signature is calculated over the completely formatted\n\
    \   Certificate Block message, before the SIGN parameter is added (see\n   Section\
    \ 4.2.8).  For the OpenPGP DSA signature scheme, the value of\n   the signature\
    \ field contains the DSA values r and s, encoded as 2\n   multiprecision integers\
    \ (see [RFC4880], Sections 5.2.2 and 3.2),\n   concatenated, and then encoded\
    \ in base64 [RFC4648].\n"
- title: 5.3.2.9.  Example
  contents:
  - "5.3.2.9.  Example\n   An example of a Certificate Block message is depicted below,\
    \ broken\n   into lines to fit publication rules.  There are no spaces at the\
    \ end\n   of the lines that contain the key blob and the signature.\n   <110>1\
    \ 2009-05-03T14:00:39.519307+02:00 host.example.org syslogd\n   2138 - [ssign-cert\
    \ VER=\"0111\" RSID=\"1\" SG=\"0\" SPRI=\"0\" TPBL=\"587\"\n   INDEX=\"1\" FLEN=\"\
    587\" FRAG=\"2009-05-03T14:00:39.519005+02:00 K BACsLMZ\n   NCV2NUAwe4RAeAnSQuvv2KS51SnHFAaWJNU2XVDYvW1LjmJgg4vKvQPo3HEOD+2hEkt1z\n\
    \   cXADe03u5pmHoWy5FGiyCbglYxJkUJJrQqlTSS6vID9yhsmEnh07w3pOsxmb4qYo0uWQr\n  \
    \ AAenBweVMlBgV3ZA5IMA8xq8l+i8wCgkWJjCjfLar7s+0X3HVrRroyARv8EAIYoxofh9m\n   N8n821BTTuQnz5hp40d6Z3UudKePu2di5Mx3GFelwnV0Qh5mSs0YkuHJg0mcXyUAoeYry\n\
    \   5X6482fUxbm+gOHVmYSDtBmZEB8PTEt8Os8aedWgKEt/E4dT+Hmod4omECLteLXxtScTM\n  \
    \ gDXyC+bSBMjRRCaeWhHrYYdYBACCWMdTc12hRLJTn8LX99kv1I7qwgieyna8GCJv/rEgC\n   ssS9E1qARM+h19KovIUOhl4VzBw3rK7v8Dlw/CJyYDd5kwSvCwjhO21LiReeS90VPYuZF\n\
    \   RC1B82Sub152zOqIcAWsgd4myCCiZbWBsuJ8P0gtarFIpleNacCc6OV3i2Rg==\"\n   SIGN=\"\
    AKAQEUiQptgpd0lKcXbuggGXH/dCdQCgdysrTBLUlbeGAQ4vwrnLOqSL7+c=\"]\n   The message\
    \ is of syslog-sign protocol version \"01\".  It uses SHA1 as\n   hash algorithm\
    \ and an OpenPGP DSA signature scheme.  Its reboot\n   session ID is 1.  Its Signature\
    \ Group is 0; its Signature Priority is\n   0.  The Total Payload Block Length\
    \ is 587 octets.  The index into the\n   payload block is 1 (meaning this is the\
    \ first fragment).  The length\n   of the fragment is 587 (meaning that the Certificate\
    \ Block message\n   contains the entire Payload Block).  The Payload Block has\
    \ the\n   timestamp 2009-05-03T14:00:39.519005+02:00.  The Key Blob Type is\n\
    \   'K', meaning that it contains a public key whose corresponding\n   private\
    \ key is being used to sign these messages.\n   Note that the Certificate Block\
    \ message in this example has a\n   timestamp that is very close to the timestamp\
    \ in the Payload Block.\n   The fact that the timestamps are so close implies\
    \ that this is the\n   first Certificate Block message sent in this reboot session;\n\
    \   additional Certificate Block messages can be sent later with a later\n   timestamp,\
    \ which will carry the same Payload Block that will still\n   contain the same\
    \ timestamp.\n"
- title: 6.  Redundancy and Flexibility
  contents:
  - "6.  Redundancy and Flexibility\n   As described in Section 8.5 of [RFC5424],\
    \ a transport sender may\n   discard syslog messages.  Likewise, when syslog messages\
    \ are sent\n   over unreliable transport, they can be lost in transit.  However,\
    \ if\n   a collector does not receive Signature and Certificate Blocks, many\n\
    \   messages may not be able to be verified.  The signer is allowed to\n   send\
    \ Signature and Certificate Blocks multiple times.  Sending\n   Signature and\
    \ Certificate Blocks multiple times provides redundancy\n   with the intent to\
    \ ensure that the collector or relay does get the\n   Signature Blocks and in\
    \ particular the Payload Block at some point in\n   time.  In the meantime, any\
    \ online review of logs as described in\n   Section 7.2 is delayed until the needed\
    \ blocks are received.  The\n   collector MUST ignore duplicates of Signature\
    \ Blocks and Certificate\n   Blocks that it has already received and authenticated.\
    \  In principle,\n   the signer can change its redundancy level for any reason,\
    \ without\n   communicating this fact to the collector.\n   A signer that is also\
    \ the originator of messages that it signs does\n   not need to queue up other\
    \ messages while sending redundant\n   Certificate Block and Signature Block messages.\
    \  It MAY send\n   redundant Certificate Block messages even after Signature Block\n\
    \   messages and regular syslog messages have been sent.  By the same\n   token,\
    \ it MAY send redundant Signature Block messages even after\n   newer syslog messages\
    \ that are signed by a subsequent Signature Block\n   have been sent, or even\
    \ after a subsequent Signature Block message.\n   In addition, the signer has\
    \ flexibility in how many hashes to include\n   within a Signature Block.  It\
    \ is legitimate for an originator to send\n   short Signature Blocks to allow\
    \ the collector to verify messages with\n   minimal delay.\n"
- title: 6.1.  Configuration Parameters
  contents:
  - "6.1.  Configuration Parameters\n   Although the transport sender is not constrained\
    \ in how it decides to\n   send redundant Signature and Certificate Blocks, or\
    \ even in whether\n   it decides to send along multiple copies of normal syslog\
    \ messages,\n   we define some redundancy parameters below that may be useful\
    \ in\n   controlling redundant transmission from the transport sender to the\n\
    \   transport receiver and that may be useful for administrators to\n   configure.\n"
- title: 6.1.1.  Configuration Parameters for Certificate Blocks
  contents:
  - "6.1.1.  Configuration Parameters for Certificate Blocks\n   Certificate Blocks\
    \ are always sent at the beginning of a new reboot\n   session.  One technique\
    \ to ensure reliable delivery (see Section 8.5)\n   is to send multiple copies.\
    \  This can be controlled by a\n   \"certInitialRepeat\" parameter:\n      certInitialRepeat\
    \ = number of times each Certificate Block should\n      be sent before the first\
    \ message is sent.\n   It is also useful to resend Certificate Blocks every now\
    \ and then for\n   long-lived reboot sessions.  This can be controlled by the\n\
    \   certResendDelay and certResendCount parameters:\n      certResendDelay = maximum\
    \ time delay in seconds until resending\n      the Certificate Block.\n      certResendCount\
    \ = maximum number of other syslog messages to send\n      until resending the\
    \ Certificate Block.\n   In some cases, it may be desirable to allow for configuration\
    \ of the\n   transport sender such that Certificate Blocks are not sent at all\n\
    \   after the first normal syslog message has been sent.  This could be\n   expressed\
    \ by setting both certResendDelay and certResendCount to \"0\".\n   However, configuring\
    \ the transport sender to send redundant\n   Certificate Blocks even after the\
    \ first message, in particular when\n   the UDP transport [RFC5426] is used, is\
    \ RECOMMENDED.\n   In one set of circumstances, the receiver may receive a Certificate\n\
    \   Block, some group of syslog messages, and some corresponding\n   Signature\
    \ Blocks.  If the receiver reboots after that, then the\n   conditions of recovery\
    \ will vary depending upon the transport.  For\n   UDP [RFC5426], the receiver\
    \ SHOULD continue to use the cached\n   Certificate Block, but MUST validate the\
    \ RSID value to make sure that\n   it has the most current one.  If the receiver\
    \ cannot validate that it\n   has the most current Certificate Block, then it\
    \ MUST wait for a\n   retransmission of the Certificate Block, which may be controlled\
    \ by\n   the certResendDelay and certResendCount parameters.  It is up to the\n\
    \   operators to ensure that Certificate Blocks are sent frequently\n   enough\
    \ to meet this set of circumstances.\n   For TLS transport [RFC5425], the sender\
    \ MUST send a fresh Certificate\n   Block when a session is established.  This\
    \ will keep the sender and\n   receiver synchronized with the most current Certificate\
    \ Block.\n   Implementations that support sending syslog messages of different\n\
    \   Signature Groups to different collectors and which wish to offer very\n  \
    \ granular controls MAY allow the above parameters to be configured on\n   a per\
    \ Signature Group basis.\n   The choice of reasonable values in a given deployment\
    \ depends on\n   several factors, including the acceptable delay that may be incurred\n\
    \   from the receipt of a syslog message until the corresponding\n   Signature\
    \ Block is received, whether UDP or TLS transport is used,\n   and the available\
    \ management bandwidth.  The following might be a\n   reasonable choice for a\
    \ deployment in which reliability of underlying\n   transport and of collector\
    \ implementation are of little concern:\n   certInitialRepeat=1, certResendDelay=1800\
    \ seconds,\n   certResendCount=10000\n   The following might be a reasonable choice\
    \ for a deployment in which\n   reliability of transmission over UDP transport\
    \ could be an issue:\n   certInitialRepeat=2, certResendDelay=300 seconds,\n \
    \  certResendCount=1000\n"
- title: 6.1.2.  Configuration Parameters for Signature Blocks
  contents:
  - "6.1.2.  Configuration Parameters for Signature Blocks\n   Verification of log\
    \ messages involves a certain delay of time that is\n   caused by the lag in time\
    \ between the sending of the message itself\n   and the corresponding Signature\
    \ Block.  The following configuration\n   parameter can be useful to limit the\
    \ time lag that will be incurred\n   (note that the maximum message length may\
    \ also force generating a\n   Signature Block; see Sections 4.2.6 and 4.2.7):\n\
    \      sigMaxDelay = generate a new Signature Block if this many seconds\n   \
    \   have elapsed since the message with the First Message Number of\n      the\
    \ Signature Block was sent.\n   Retransmissions of Signature Blocks are not sent\
    \ immediately after\n   the original transmission, but slightly later.  The following\n\
    \   parameters control when those retransmissions are done:\n      sigNumberResends\
    \ = number of times a Signature Block is resent.\n      (It is recommended to\
    \ select a value of greater than \"0\" in\n      particular when the UDP transport\
    \ [RFC5426] is used.)\n      sigResendDelay = send the next retransmission when\
    \ this many\n      seconds have elapsed since the previous sending of this Signature\n\
    \      Block.\n      sigResendCount = send the next retransmission when this many\
    \ other\n      syslog messages have been sent since the previous sending of this\n\
    \      Signature Block.\n   The choice of reasonable values in a given deployment\
    \ depends on\n   several factors, including the acceptable delay that may be incurred\n\
    \   from the receipt of a syslog message until the corresponding\n   Signature\
    \ Block is received so that the syslog message can be\n   verified, the reliability\
    \ of the underlying transport, and the\n   available management bandwidth.  The\
    \ following might be a reasonable\n   choice for a deployment where reliability\
    \ of transport and collector\n   are of little concern and where there is a need\
    \ to have syslog\n   messages generally signed within 5 minutes:\n   sigMaxDelay=300\
    \ seconds, sigNumberResends=2, sigResendDelay=300\n   seconds, sigResendCount=500\n\
    \   The following would be a reasonable choice for a deployment that\n   needs\
    \ to validate syslog messages typically within 60 seconds, but no\n   more than\
    \ 3 minutes after receipt:\n   sigMaxDelay=30 seconds, sigNumberResends=5, sigResendDelay=30\n\
    \   seconds, sigResendCount=100\n"
- title: 6.2.  Overlapping Signature Blocks
  contents:
  - "6.2.  Overlapping Signature Blocks\n   Notwithstanding the fact that the signer\
    \ is not constrained in\n   whether it decides to send redundant Signature Block\
    \ messages,\n   Signature Blocks SHOULD NOT overlap.  This facilitates their\n\
    \   processing by the receiving collector.  This means that an originator\n  \
    \ of Signature Block messages, after having sent a first message with\n   some\
    \ First Message Number and a Count, SHOULD NOT send a second\n   message with\
    \ the same First Message Number but a different Count.  It\n   also means that\
    \ an originator of Signature Block messages SHOULD NOT\n   send a second message\
    \ whose First Message Number is greater than the\n   First Message Number, but\
    \ smaller than the First Message Number plus\n   the Count indicated in the first\
    \ message.\n   That said, the possibility of Signature Blocks that overlap does\n\
    \   provide additional flexibility with regard to redundancy; it provides\n  \
    \ an additional option that may be desirable in some deployments.\n   Therefore,\
    \ collectors MUST be designed in a way that they can cope\n   with overlapping\
    \ Signature Blocks when confronted with them.  The\n   collector MUST ignore hashes\
    \ of messages that it has already received\n   and validated.\n"
- title: 7.  Efficient Verification of Logs
  contents:
  - "7.  Efficient Verification of Logs\n   The logs secured with syslog-sign may\
    \ be reviewed either online or\n   offline.  Online review is somewhat more complicated\
    \ and\n   computationally expensive, but not prohibitively so.  This section\n\
    \   outlines a method for online and a method for offline verification of\n  \
    \ logs that implementations MAY choose to implement to verify logs\n   efficiently.\
    \  Implementations MAY also choose to implement a\n   different method; it is\
    \ ultimately up to each implementation how to\n   process the messages that it\
    \ receives.\n"
- title: 7.1.  Offline Review of Logs
  contents:
  - "7.1.  Offline Review of Logs\n   When the collector stores logs to be reviewed\
    \ later, they can be\n   authenticated offline just before they are reviewed.\
    \  Reviewing these\n   logs offline is simple and relatively inexpensive in terms\
    \ of\n   resources used, so long as there is enough space available on the\n \
    \  reviewing machine.\n   To do so, we first go through the stored log file. \
    \ Each message in\n   the log file is classified as a normal message, a Signature\
    \ Block\n   message, or a Certificate Block message.  Signature Blocks and\n \
    \  Certificate Blocks are then separated by signer (as identified by\n   HOSTNAME,\
    \ APP-NAME, PROCID), Reboot Session ID, and Signature Group,\n   and stored in\
    \ their own files.  Normal messages are stored in a keyed\n   file, indexed on\
    \ their hash values.  They are not separated by\n   signer, as their (HOSTNAME,\
    \ APP-NAME, PROCID) identifies the\n   application that generated the message.\
    \  The application that\n   generated the message does not have to coincide with\
    \ the signer.\n   For each signer, Reboot Session ID, and Signature Group, we\
    \ then:\n   a.  Sort the Certificate Block file by INDEX value, and check to see\n\
    \       whether we have a set of Certificate Blocks that can reconstruct\n   \
    \    the Payload Block.  If so, we reconstruct the Payload Block,\n       verify\
    \ any key-identifying information, and then use this to\n       verify the signatures\
    \ on the Certificate Blocks we have received.\n       When this is done, we have\
    \ verified the reboot session and key\n       used for the rest of the process.\n\
    \   b.  Sort the Signature Block file by First Message Number.  We now\n     \
    \  create an authenticated log file, which consists of some header\n       information\
    \ and then a (sequence of message number, message text\n       pairs).  We next\
    \ go through the Signature Block file.  We\n       initialize a cursor for the\
    \ last message number processed with\n       the number 0.  For each Signature\
    \ Block in the file, we do the\n       following:\n       1.  Verify the signature\
    \ on the Signature Block.\n       2.  If the value of the First Message Number\
    \ of the Signature\n           Block is less than or equal to the last message\
    \ number\n           processed, skip the first (last message number processed\n\
    \           minus First Message Number plus 1) hashes.\n       3.  For each remaining\
    \ hashed message in the Signature Block:\n           a.  Look up the hash value\
    \ in the keyed message file.\n           b.  If the message is found, write (message\
    \ number, message\n               text) to the authenticated log file.\n     \
    \  4.  Set the last message number processed to the value of the\n           First\
    \ Message Number plus the Count of the Signature Block\n           minus 1.\n\
    \       5.  Skip all other Signature Blocks with the same First Message\n    \
    \       Number unless one with a larger Count is encountered.\n       The resulting\
    \ authenticated log file contains all messages that\n       have been authenticated.\
    \  In addition, it implicitly indicates\n       all gaps in the authenticated\
    \ messages (specifically in the case\n       when all messages of the same Signature\
    \ Group are sent to the\n       same collector), because their message numbers\
    \ are missing.\n   One can see that, assuming sufficient space for building the\
    \ keyed\n   file, this whole process is linear in the number of messages\n   (generally\
    \ two seeks, one to write and the other to read, per normal\n   message received),\
    \ and O(N lg N) in the number of Signature Blocks.\n   This estimate comes with\
    \ two caveats: first, the Signature Blocks\n   arrive very nearly in sorted order,\
    \ and so can probably be sorted\n   more cheaply on average than O(N lg N) steps.\
    \  Second, the signature\n   verification on each Signature Block almost certainly\
    \ is more\n   expensive than the sorting step in practice.  We have not discussed\n\
    \   error-recovery, which may be necessary for the Certificate Blocks.\n   In\
    \ practice, a simple error-recovery strategy is probably enough: if\n   the Payload\
    \ Block is not valid, then we can just try alternate\n   instances of each Certificate\
    \ Block, if such are available, until we\n   get the Payload Block right.\n  \
    \ It is easy for an attacker to flood us with plausible-looking\n   messages,\
    \ Signature Blocks, and Certificate Blocks.\n"
- title: 7.2.  Online Review of Logs
  contents:
  - "7.2.  Online Review of Logs\n   Some collector implementations may need to monitor\
    \ log messages in\n   close to real time.  This can be done with syslog-sign,\
    \ though it is\n   somewhat more complex than offline verification.  This is done\
    \ as\n   follows:\n   a.  We have an authenticated message file, into which we\
    \ write\n       (message number, message text) pairs that have been\n       authenticated.\
    \  We will assume that we are handling only one\n       signer, Signature Group,\
    \ and Reboot Session ID at any given time.\n       (For the concurrent support\
    \ of multiple signers, Signature\n       Groups, and Reboot Session IDs, the same\
    \ procedure is applied\n       analogously to each.  Signature Block messages\
    \ and Certificate\n       Block messages clearly indicate their respective signer,\n\
    \       Signature Group, and Reboot Session ID.)\n   b.  We have two data structures:\
    \ A \"Waiting for Signature\" queue in\n       which (arrival sequence, hash of\
    \ message) pairs are kept in\n       sorted order, and a \"Waiting for Message\"\
    \ queue in which (message\n       number, hash of message) pairs are kept in sorted\
    \ order.  In\n       addition, we have a hash table that stores (message text,\
    \ count)\n       pairs indexed by hash value.  In the hash table, count may be\
    \ any\n       number greater than zero; when count is zero, the entry in the\n\
    \       hash table is cleared.\n       Note: The \"Waiting for Signature\" queue\
    \ gets used in the normal\n       case, when the signature arrives after the message\
    \ itself.  It\n       holds messages that have been received but whose signature\
    \ has\n       yet to arrive.  The \"Waiting for Message\" queue gets used in the\n\
    \       case that messages are lost or misordered (either in the network\n   \
    \    or in relays).  It holds signatures that have been received but\n       whose\
    \ corresponding messages have yet to arrive.  Since a single\n       Signature\
    \ Block can cover only a limited number of messages (due\n       to size restrictions),\
    \ and massive reordering/delaying is rare,\n       it is expected that both queues\
    \ would be relatively small.\n   c.  We must receive all the Certificate Blocks\
    \ before any other\n       processing can really be done.  (This is why they are\
    \ sent\n       first.)  Once that is done, any additional Certificate Block\n\
    \       message that arrives is discarded.  Any syslog messages or\n       Signature\
    \ Block messages that arrive before all Certificate\n       Blocks have been received\
    \ need to be buffered.  Once all\n       Certificate Blocks have been received,\
    \ the messages in the buffer\n       can be retrieved and processed as if they\
    \ were just arriving.\n   d.  Whenever a normal message arrives, we first check\
    \ if its hash\n       value is found in the \"Waiting for Message\" queue.  If\
    \ it is, we\n       write the message number (from the \"Waiting for Message\"\
    \ queue)\n       and the message into the authenticated message file and remove\n\
    \       the entry from the queue.\n       Otherwise, we add (arrival sequence,\
    \ hash of message) to the\n       \"Waiting for Signature\" queue.  If our hash\
    \ table already has an\n       entry for the message's hash value, we increment\
    \ its count by\n       one; otherwise, we create a new entry with Count = 1.\n\
    \       If the \"Waiting for Signature\" message queue is full, we remove\n  \
    \     the oldest message from the queue.  That message could not be\n       validated\
    \ close enough to real time.  In order to update the hash\n       table accordingly,\
    \ we use that entry's hash to index the hash\n       table.  If that entry has\
    \ count 1, we delete the entry from the\n       hash table; otherwise, we decrement\
    \ its count.  By removing the\n       message from the \"Waiting for Signature\"\
    \ message queue without\n       having actually received the message's signature,\
    \ we make it\n       impossible to authenticate the message should its signature\n\
    \       arrive later.  Implementers therefore need to ensure that queues\n   \
    \    are dimensioned sufficiently large to not expose the collector\n       against\
    \ Denial-of-Service (DoS) attacks that attempt to flood the\n       collector\
    \ with unsigned messages.\n   e.  Whenever a Signature Block message arrives,\
    \ we check its\n       originator, (i.e., the signer) by way of HOSTNAME, APP-NAME,\
    \ and\n       PROCID, as well as its Signature Group and Reboot Session ID to\n\
    \       ensure it matches our Certificate Blocks.  We then check to see\n    \
    \   whether the First Message Number value is too old to still be of\n       interest,\
    \ or if another Signature Block with that First Message\n       Number and the\
    \ same Count or a greater Count has already been\n       received.  If so, we\
    \ discard the Signature Block.  We then check\n       the signature.  Again, we\
    \ discard the Signature Block if the\n       signature is not valid.\n       Otherwise,\
    \ we proceed with processing the hashes in the Signature\n       Block.  A Signature\
    \ Block contains a sequence of hashes, each of\n       which is associated with\
    \ a message number, starting with the\n       First Message Number for the first\
    \ hash and incrementing by one\n       for each subsequent hash.  For each hash,\
    \ we first check to see\n       whether the message hash is in the hash table.\
    \  If this is the\n       case, it means that we have received the signature for\
    \ a message\n       that was received earlier, and we do the following:\n    \
    \   1.  We check if a message with the same message number is already\n      \
    \     in the authenticated message file.  If that is the case, the\n         \
    \  signed hash is a duplicate and we discard it.\n       2.  Otherwise (the signed\
    \ hash is not a duplicate), we write the\n           (message number, message\
    \ text) into the authenticated message\n           file.  We also update the hash\
    \ table accordingly, using that\n           entry's hash to index the hash table.\
    \  If that entry has\n           Count 1, we delete the entry from the hash table;\
    \ otherwise,\n           we decrement its count.\n       Otherwise (the message\
    \ hash is not in the hash table), we write\n       the (message number, message\
    \ hash) to the \"Waiting for Message\"\n       queue.\n       If the \"Waiting\
    \ for Message\" queue is full, we remove the oldest\n       entry.  In that case,\
    \ a message that was signed by the signer\n       could not be validated by the\
    \ receiver, either because the\n       message was lost or because the signature\
    \ arrived way ahead of\n       the actual message.  By removing the entry from\
    \ the \"Waiting for\n       Message\" queue without having actually received the\
    \ message, we\n       make it impossible to authenticate the a legitimate message\n\
    \       should that message still arrive later.  Implementers need to\n      \
    \ ensure queues are dimensioned sufficiently large so that the\n       chances\
    \ of such a scenario actually occurring is minimized.\n   f.  The result of this\
    \ is a sequence of messages in the authenticated\n       message file.  Each message\
    \ in the message file has been\n       authenticated.  The sequence is labeled\
    \ with numbers showing the\n       order in which the messages were originally\
    \ transmitted.\n   One can see that this whole process is roughly linear in the\
    \ number\n   of messages, and also in the number of Signature Blocks received.\n\
    \   The process is susceptible to flooding attacks; an attacker can send\n   enough\
    \ normal messages that the messages roll off their queue before\n   their Signature\
    \ Blocks can be processed.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   Normal syslog event messages are unsigned and\
    \ have most of the\n   security attributes described in Section 8 of [RFC5424].\
    \  This\n   document also describes Certificate Blocks and Signature Blocks,\n\
    \   which are signed syslog messages.  The Signature Blocks contain\n   signature\
    \ information for previously sent syslog event messages.  All\n   of this information\
    \ can be used to authenticate syslog messages and\n   to minimize or obviate many\
    \ of the security concerns described in\n   [RFC5424].\n   The model for syslog-sign\
    \ is a direct trust system where the\n   certificate transferred is its own trust\
    \ anchor.  If a transport\n   sender sends a stream of syslog messages that is\
    \ signed using a\n   certificate, the operator or application will transfer to\
    \ the\n   transport receiver the certificate that was used when signing.  There\n\
    \   is no need for a certificate chain.\n"
- title: 8.1.  Cryptographic Constraints
  contents:
  - "8.1.  Cryptographic Constraints\n   As with any technology involving cryptography,\
    \ it is advisable to\n   check the current literature to determine whether any\
    \ algorithms used\n   here have been found to be vulnerable to attack.\n   This\
    \ specification uses Public Key Cryptography technologies.  The\n   proper party\
    \ or parties have to control the private key portion of a\n   public-private key\
    \ pair.  Any party that controls a private key can\n   sign anything it pleases.\n\
    \   Certain operations in this specification involve the use of random\n   numbers.\
    \  An appropriate entropy source SHOULD be used to generate\n   these numbers.\
    \  See [RFC4086] and [NIST800.90].\n"
- title: 8.2.  Packet Parameters
  contents:
  - "8.2.  Packet Parameters\n   As a signer, it is advisable to avoid message lengths\
    \ exceeding 2048\n   octets.  Various problems might result if a signer were to\
    \ send\n   messages with a length greater than 2048 octets, because relays MAY\n\
    \   truncate messages with lengths greater than 2048 octets, which would\n   make\
    \ it impossible for collectors to validate a hash of the packet.\n   To increase\
    \ the chance of interoperability, it tends to be best to be\n   conservative with\
    \ what you send but liberal in what you are able to\n   receive.\n   Signers need\
    \ to rigidly adhere to the RFC 5424 format when sending\n   messages.  If a collector\
    \ receives a message that is not formatted\n   properly, then it might drop it,\
    \ or it may modify it while receiving\n   it.  (See Appendix A.2 of [RFC5424].)\
    \  If that were to happen, the\n   hash of the sent message would not match the\
    \ hash of the received\n   message.\n   Collectors are not to malfunction in the\
    \ case that they receive\n   malformed syslog messages or messages containing\
    \ characters other\n   than those specified in this document.  In other words,\
    \ they are to\n   ignore such messages and continue working.\n"
- title: 8.3.  Message Authenticity
  contents:
  - "8.3.  Message Authenticity\n   Syslog does not strongly associate the message\
    \ with the message\n   originator.  That association is established by the collector\
    \ upon\n   verification of the Signature Block.  Before a Signature Block is\n\
    \   used to ascertain the authenticity of an event message, it might be\n   received,\
    \ stored, and reviewed by a person or automated parser.  It\n   is advisable not\
    \ to assume a message is authentic until after a\n   message has been validated\
    \ by checking the contents of the Signature\n   Block.\n   With the Signature\
    \ Block checking, an attacker may only forge\n   messages if he or she can compromise\
    \ the private key of the true\n   originator.\n"
- title: 8.4.  Replaying
  contents:
  - "8.4.  Replaying\n   Event messages might be recorded and replayed by an attacker.\
    \  Using\n   the information contained in the Signature Blocks, a reviewer can\n\
    \   determine whether the received messages are the ones originally sent\n   by\
    \ an originator.  The reviewer can also identify messages that have\n   been replayed.\
    \  Using a method for the verification of logs such as\n   the one outlined in\
    \ Section 7, a replayed message can be detected by\n   checking prior to writing\
    \ a message to the authenticated log file\n   whether the message is already contained\
    \ in it.\n"
- title: 8.5.  Reliable Delivery
  contents:
  - "8.5.  Reliable Delivery\n   Event messages sent over UDP might be lost in transit.\
    \  [RFC5425] can\n   be used for the reliable delivery of syslog messages; however,\
    \ it\n   does not protect against loss of syslog messages at the application\n\
    \   layer, for example, if the TCP connection or TLS session has been\n   closed\
    \ by the transport receiver for some reason.  A reviewer can\n   identify any\
    \ messages sent by the originator but not received by the\n   collector by reviewing\
    \ the Signature Block information.  In addition,\n   the information in subsequent\
    \ Signature Blocks allows a reviewer to\n   determine whether any Signature Block\
    \ messages were lost in transit.\n"
- title: 8.6.  Sequenced Delivery
  contents:
  - "8.6.  Sequenced Delivery\n   Syslog messages delivered over UDP might not only\
    \ be lost, but also\n   arrive out of sequence.  A reviewer can determine the\
    \ original order\n   of syslog messages and identify which messages were delivered\
    \ out of\n   order by examining the information in the Signature Block along with\n\
    \   any timestamp information in the message.\n"
- title: 8.7.  Message Integrity
  contents:
  - "8.7.  Message Integrity\n   Syslog messages might be damaged in transit.  A review\
    \ of the\n   information in the Signature Block determines whether the received\n\
    \   message was the intended message sent by the originator.  A damaged\n   Signature\
    \ Block or Certificate Block is evident because the collector\n   will not be\
    \ able to validate that it was signed by the signer.\n"
- title: 8.8.  Message Observation
  contents:
  - "8.8.  Message Observation\n   Unless TLS is used as a secure transport [RFC5425],\
    \ event messages,\n   Certificate Blocks, and Signature Blocks are all sent in\
    \ plaintext.\n   This allows network administrators to read the message when sniffing\n\
    \   the wire.  However, this also allows an attacker to see the contents\n   of\
    \ event messages and perhaps to use that information for malicious\n   purposes.\n"
- title: 8.9.  Man-in-the-Middle Attacks
  contents:
  - "8.9.  Man-in-the-Middle Attacks\n   It is conceivable that an attacker might\
    \ intercept Certificate Block\n   messages and insert its own Certificate information.\
    \  In that case,\n   the attacker would be able to receive event messages from\
    \ the actual\n   originator and then relay modified messages, insert new messages,\
    \ or\n   delete messages.  It would then be able to construct a Signature\n  \
    \ Block and sign it with its own private key.  Network administrators\n   need\
    \ to verify that the key contained in the Payload Block is indeed\n   the key\
    \ being used on the actual signer.  If that is the case, then\n   this MITM attack\
    \ will not succeed.  Methods for establishing a chain\n   of trust are also described\
    \ in [RFC5425].\n"
- title: 8.10.  Denial of Service
  contents:
  - "8.10.  Denial of Service\n   An attacker might send invalid Signature Block messages\
    \ to overwhelm\n   the collector's processing capability and consume all available\n\
    \   resources.  For this reason, it can be appropriate to simply receive\n   the\
    \ Signature Block messages and process them only as time permits.\n   An attacker\
    \ might also just overwhelm a collector by sending more\n   messages to it than\
    \ it can handle.  Implementers are advised to\n   consider features that minimize\
    \ this threat, such as only accepting\n   syslog messages from known IP addresses.\n"
- title: 8.11.  Covert Channels
  contents:
  - "8.11.  Covert Channels\n   Nothing in this protocol attempts to eliminate covert\
    \ channels.  In\n   fact, just about every aspect of syslog messages lends itself\
    \ to the\n   conveyance of covert signals.  For example, a collusionist could\
    \ send\n   odd and even PRI values to indicate Morse Code dashes and dots.\n"
- title: 9.  IANA Considerations
  contents:
  - '9.  IANA Considerations

    '
- title: 9.1.  Structured Data and Syslog Messages
  contents:
  - "9.1.  Structured Data and Syslog Messages\n   With regard to [RFC5424], IANA\
    \ has added the following values (with\n   each parameter listed as mandatory)\
    \ to the registry titled \"syslog\n   Structured Data ID Values\":\n         \
    \ Structured Data ID  Structured Data Parameter\n          ------------------\
    \  -------------------------\n          ssign\n                              VER\n\
    \                              RSID\n                              SG\n      \
    \                        SPRI\n                              GBC\n           \
    \                   FMN\n                              CNT\n                 \
    \             HB\n                              SIGN\n          ssign-cert\n \
    \                             VER\n                              RSID\n      \
    \                        SG\n                              SPRI\n            \
    \                  TPBL\n                              INDEX\n               \
    \               FLEN\n                              FRAG\n                   \
    \           SIGN\n   In addition, several fields are controlled by the IANA in\
    \ both the\n   Signature Block and the Certificate Block, as outlined in the\n\
    \   following sections.\n"
- title: 9.2.  Version Field
  contents:
  - "9.2.  Version Field\n   IANA has created three registries, each associated with\
    \ a different\n   subfield of the Version field of Signature Blocks and Certificate\n\
    \   Blocks, described in Sections 4.2.1 and 5.3.2.1, respectively.\n   The first\
    \ registry that IANA has created is titled \"syslog-sign\n   Protocol Version\
    \ Values\".  It is for the values of the Protocol\n   Version subfield.  The Protocol\
    \ Version subfield constitutes the\n   first two octets in the Version field.\
    \  New values shall be assigned\n   by the IANA using the \"IETF Review\" policy\
    \ defined in [RFC5226].\n   Assigned numbers are to be increased by 1, up to a\
    \ maximum value of\n   \"50\".  Protocol Version numbers of \"51\" through \"\
    99\" are vendor\n   specific; values in this range are not to be assigned by the\
    \ IANA.\n   IANA has registered the Protocol Version values shown below.\n   \
    \      Value                    Protocol Version\n         -----             \
    \       ----------------\n         00                       Reserved\n       \
    \  01                       Defined in RFC 5848\n   The second registry that IANA\
    \ has created is titled \"syslog-sign Hash\n   Algorithm Values\".  It is for\
    \ the values of the Hash Algorithm\n   subfield.  The Hash Algorithm subfield\
    \ constitutes the third octet in\n   the Version field Signature Blocks and Certificate\
    \ Blocks.  New\n   values shall be assigned by the IANA using the \"IETF Review\"\
    \ policy\n   defined in [RFC5226].  Assigned values are to be increased\n   sequentially,\
    \ first up to a maximum value of \"9\", then from \"a\" to\n   \"z\", then from\
    \ \"A\" to \"Z\".  The values are registered relative to the\n   Protocol Version.\
    \  This means that the same Hash Algorithm value can\n   be reserved for different\
    \ Protocol Versions, possibly referring to a\n   different hash algorithm each\
    \ time.  This makes it possible to deal\n   with future scenarios in which the\
    \ single octet representation\n   becomes a limitation, as more Hash Algorithms\
    \ can be supported by\n   defining additional Protocol Versions that implementations\
    \ might\n   support concurrently.\n   IANA has registered the Hash Algorithm values\
    \ shown below.\n         Value     Protocol Version     Hash Algorithm\n     \
    \    -----     ----------------     --------------\n         0         01    \
    \               Reserved\n         1         01                   SHA1\n     \
    \    2         01                   SHA256\n   The third registry that IANA has\
    \ created is titled \"syslog-sign\n   Signature Scheme Values\".  It is for the\
    \ values of the Signature\n   Scheme subfield.  The Signature Scheme subfield\
    \ constitutes the\n   fourth octet in the Version field of Signature Blocks and\
    \ Certificate\n   Blocks.  New values shall be assigned by the IANA using the\
    \ \"IETF\n   Review\" policy defined in [RFC5226].  Assigned values are to be\n\
    \   increased by 1, up to a maximum value of \"9\".  This means that the\n   same\
    \ Signature Scheme value can be reserved for different Protocol\n   Versions,\
    \ possibly in each case referring to a different Signature\n   Scheme each time.\
    \  This makes it possible to deal with future\n   scenarios in which the single\
    \ octet representation becomes a\n   limitation, as more Signature Schemes can\
    \ be supported by defining\n   additional Protocol Versions that implementations\
    \ might support\n   concurrently.\n   IANA has registered the Signature Scheme\
    \ values shown below.\n         Value     Protocol Version    Signature Scheme\n\
    \         -----     ----------------    ----------------\n         0         01\
    \                  Reserved\n         1         01                  OpenPGP DSA\n"
- title: 9.3.  SG Field
  contents:
  - "9.3.  SG Field\n   IANA has created a registry titled \"syslog-sign SG Field\
    \ Values\".  It\n   is for values of the SG Field as defined in Section 4.2.3.\
    \  New\n   values shall be assigned by the IANA using the \"IETF Review\" policy\n\
    \   defined in [RFC5226].  Assigned values are to be incremented by 1, up\n  \
    \ to a maximum value of \"7\".  Values \"8\" and \"9\" shall be left as\n   vendor\
    \ specific and shall not be assigned by the IANA.\n   IANA has registered the\
    \ SG Field values shown below.\n         Value     Meaning\n         -----   \
    \  -------\n         0         There is only one Signature Group.\n         1\
    \         Each PRI value is associated with its own Signature\n              \
    \     Group.\n         2         Each Signature Group contains a range of PRI\n\
    \                   values.\n         3         Signature Groups are not assigned\
    \ with any of the\n                   above relationships to PRI values of the\
    \ syslog\n                   messages they sign.\n"
- title: 9.4.  Key Blob Type
  contents:
  - "9.4.  Key Blob Type\n   IANA has created a registry titled \"syslog-sign Key\
    \ Blob Type\n   Values\".  It is to register one-character identifiers for the\
    \ Key\n   Blob Type, per Section 5.2.  New values shall be assigned by the IANA\n\
    \   using the \"IETF Review\" policy defined in [RFC5226].  Uppercase\n   letters\
    \ may be assigned as values.  Lowercase letters are left as\n   vendor specific\
    \ and shall not be assigned by the IANA.\n   IANA has registered the Key Blob\
    \ Type values shown below.\n         Value     Key Blob Type\n         ----- \
    \    -------------\n         C         a PKIX certificate\n         P        \
    \ an OpenPGP certificate\n         K         the public key whose corresponding\
    \ private key is\n                   used to sign the messages\n         N   \
    \      no key information sent, key is pre-distributed\n         U         installation-specific\
    \ key exchange information\n"
- title: 10.  Acknowledgements
  contents:
  - "10.  Acknowledgements\n   The authors wish to thank the current Chairs of the\
    \ Syslog Working\n   Group, David Harrington and Chris Lonvick, and the other\
    \ members of\n   the Working Group, in particular Alex Brown, Chris Calabrese,\
    \ Steve\n   Chang, Pasi Eronen, Carson Gaspar, Rainer Gerhards, Drew Gross,\n\
    \   Albert Mietus, Darrin New, Marshall Rose, Andrew Ross, Martin\n   Schuette,\
    \ Holt Sorenson, Rodney Thayer, and the many Counterpane\n   Internet Security\
    \ engineering and operations people who commented on\n   various versions of this\
    \ proposal.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [FIPS.186-2.2000]  National Institute of Standards\
    \ and Technology,\n                      \"Digital Signature Standard\", FIPS\
    \ PUB 186-2,\n                      January 2000, <http://csrc.nist.gov/publications/\n\
    \                      fips/archive/fips186-2/fips186-2.pdf>.\n   [FIPS.180-2.2002]\
    \  National Institute of Standards and Technology,\n                      \"Secure\
    \ Hash Standard\", FIPS PUB 180-2,\n                      August 2002, <http://csrc.nist.gov/publications/\n\
    \                      fips/fips180-2/fips180-2.pdf>.\n   [RFC2119]          Bradner,\
    \ S., \"Key words for use in RFCs to\n                      Indicate Requirement\
    \ Levels\", BCP 14, RFC 2119,\n                      March 1997.\n   [RFC4648]\
    \          Josefsson, S., \"The Base16, Base32, and Base64\n                 \
    \     Data Encodings\", RFC 4648, October 2006.\n   [RFC4880]          Callas,\
    \ J., Donnerhacke, L., Finney, H., Shaw, D.,\n                      and R. Thayer,\
    \ \"OpenPGP Message Format\", RFC 4880,\n                      November 2007.\n\
    \   [RFC5226]          Narten, T. and H. Alvestrand, \"Guidelines for\n      \
    \                Writing an IANA Considerations Section in RFCs\",\n         \
    \             BCP 26, RFC 5226, May 2008.\n   [RFC5280]          Cooper, D., Santesson,\
    \ S., Farrell, S., Boeyen,\n                      S., Housley, R., and W. Polk,\
    \ \"Internet X.509\n                      Public Key Infrastructure Certificate\
    \ and\n                      Certificate Revocation List (CRL) Profile\",\n  \
    \                    RFC 5280, May 2008.\n   [RFC5424]          Gerhards, R.,\
    \ \"The syslog Protocol\", RFC 5424,\n                      March 2009.\n   [RFC5425]\
    \          Miao, F., Yuzhi, M., and J. Salowey, \"TLS\n                      Transport\
    \ Mapping for syslog\", RFC 5425,\n                      March 2009.\n   [RFC5426]\
    \          Okmianski, A., \"Transmission of syslog Messages\n                \
    \      over UDP\", RFC 5426, March 2009.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [NIST800.90]       National Institute of Standards\
    \ and Technology,\n                      \"NIST Special Publication 800-90: Recommendation\n\
    \                      for Random Number Generation using Deterministic\n    \
    \                  Random Bit Generators\", June 2006, <http://\n            \
    \          csrc.nist.gov/publications/nistpubs/800-90/\n                     \
    \ SP800-90revised_March2007.pdf>.\n   [RFC3339]          Klyne, G. and C. Newman,\
    \ \"Date and Time on the\n                      Internet: Timestamps\", RFC 3339,\
    \ July 2002.\n   [RFC3414]          Blumenthal, U. and B. Wijnen, \"User-based\
    \ Security\n                      Model (USM) for version 3 of the Simple Network\n\
    \                      Management Protocol (SNMPv3)\", RFC 3414,\n           \
    \           December 2002.\n   [RFC4086]          Eastlake, D., Schiller, J.,\
    \ and S. Crocker,\n                      \"Randomness Recommendations for Security\"\
    ,\n                      RFC 4086, June 2005.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   John Kelsey\n   NIST\n   EMail: john.kelsey@nist.gov\n\
    \   Jon Callas\n   PGP Corporation\n   EMail: jon@callas.org\n   Alexander Clemm\n\
    \   Cisco Systems\n   EMail: alex@cisco.com\n"
