- title: __initial_text__
  contents:
  - "                  HEMS Monitoring and Control Language\n   This RFC specifies\
    \ the design of a general-purpose, yet efficient,\n   monitoring and control language\
    \ for managing network entities.  The\n   data in the entity is modeled as a hierarchy\
    \ and specific items are\n   named by giving the path from the root of the tree.\
    \  Most items are\n   read-only, but some can be \"set\" in order to perform control\n\
    \   operations.  Both requests and responses are represented using the\n   ISO\
    \ ASN.1 data encoding rules.\n"
- title: STATUS OF THIS MEMO
  contents:
  - "STATUS OF THIS MEMO\n   The purpose of this RFC is provide a specification for\
    \ monitoring and\n   control of network entities in the Internet.  This is an\
    \ experimental\n   specification and is intended for use in testing the ideas\
    \ presented\n   here.  No proposals in this memo are intended as standards for\
    \ the\n   Internet at this time.  After sufficient experimentation and\n   discussion,\
    \ this RFC will be redrafted, perhaps as a standard.\n   Distribution of this\
    \ memo is unlimited.\n   This language is a component of the High-Level Entity\
    \ Monitoring\n   System (HEMS) described in RFC-1021 and RFC-1022.  Readers may\
    \ want\n   to consult these RFCs when reading this memo.  RFC-1024 contains\n\
    \   detailed assignments of numbers and structures used in this system.\n   This\
    \ memo assumes a knowledge of the ISO data encoding standard,\n   ASN.1.\n"
- title: OVERVIEW AND SCOPE
  contents:
  - "OVERVIEW AND SCOPE\n   The basic model of monitoring and control used in this\
    \ proposal is\n   that a query is sent to a monitored entity and the entity sends\
    \ back\n   a response.  The term query is used in the database sense -- it may\n\
    \   request information, modify things, or both.  We will use gateway-\n   oriented\
    \ examples, but it should be understood that this query-\n   response mechanism\
    \ can be applied to other entities besides just\n   gateways.\n   In particular,\
    \ there is no notion of an interactive \"conversation\" as\n   in SMTP [RFC-821]\
    \ or FTP [RFC-959].  A query is a complete request\n   that stands on its own\
    \ and elicits a complete response.\n   It is not necessary for a monitored entity\
    \ to be able to store the\n   complete query.  It is quite possible for an implementation\
    \ to\n   process the query on the fly, producing portions of the response\n  \
    \ while the query is still being received.\n   Other RFCs associated with HEMS\
    \ are:  RFC-1021 -- Overview; RFC-1022\n   -- transport protocol and message encapsulation;\
    \ RFC-1024 -- precise\n   data definitions.  These issues are not dealt with here.\
    \  It is\n   assumed that there is some mechanism to transport a sequence of\n\
    \   octets to a query processor within the monitored entity and that\n   there\
    \ is some mechanism to return a sequence of octets to the entity\n   making the\
    \ query.\n"
- title: ENCODING OF QUERIES AND RESPONSES
  contents:
  - "ENCODING OF QUERIES AND RESPONSES\n   Both queries and responses are encoded\
    \ using the representation\n   defined in ISO Standard ASN.1 (Abstract Syntax\
    \ Notation 1).  ASN.1\n   represents data as sequences of <tag,length,contents>\
    \ triples that\n   are encoded as a stream of octets.  The data tuples may be\n\
    \   recursively nested to represent structured data such as arrays or\n   records.\
    \  For a full description of this notation, see the ISO\n   documents IS 8824\
    \ and IS 8825.  See the end of this memo for\n   information about ordering these\
    \ documents.\n"
- title: NOTATION USED IN THIS PROPOSAL
  contents:
  - "NOTATION USED IN THIS PROPOSAL\n   The notation used in this memo is similar\
    \ to that used in ASN.1, but\n   less formal, smaller, and (hopefully) easier\
    \ to read.  The most\n   important difference is that, in this memo, we are not\
    \ concerned with\n   the length of the data items.\n   ASN.1 data items may be\
    \ either a \"simple type\" such as integer or\n   octet string or a \"structured\
    \ type\", a collection of data items.  The\n   notation or a \"structured type\"\
    , a collection of data items.  The\n   notation:\n        ID(value)\n   represents\
    \ a simple data item whose tag is \"ID\" with the given value.\n   A structured\
    \ data item is represented as:\n        ID { ... contents ... }\n   where contents\
    \ is a sequence of data items.  Remember that the\n   contents may include both\
    \ simple and structured types, so the\n   structure is fully recursive.\n   There\
    \ are situations where it is desirable to specify a type but give\n   no value,\
    \ such as when there is no meaningful value for a particular\n   measured parameter\
    \ or when the entire contents of a structured type\n   is being specified.  In\
    \ this situation, the same notation is used,\n   but with the value omitted:\n\
    \          ID()\n   or\n          ID{}\n   The representation of this is obvious\
    \ -- the data item has zero for\n   the length and no contents.\n"
- title: DATA MODEL
  contents:
  - "DATA MODEL\n   Data in a monitored entity is modeled as a hierarchy.\n   Implementations\
    \ are not required to organize the data internally as a\n   hierarchy, but they\
    \ must provide this view of the data through the\n   query language.  A hierarchy\
    \ offers useful structure for the\n   following operations:\n   Organization \
    \    A hierarchy allows related data to be grouped\n                    together\
    \ in a natural way.\n   Naming           The name of a piece of data is just the\
    \ path from\n                    the root to the data of interest.\n   Mapping\
    \ onto ASN.1\n                    ASN.1 can easily represent a hierarchy by using\n\
    \                    \"constructor\" types as an envelope for an entire\n    \
    \                subtree.\n   Efficient Representation\n                    Hierarchical\
    \ structures are quite compact and can\n                    be traversed very\
    \ quickly.\n   Each node in the hierarchy must have names for its component parts.\n\
    \   Although we would normally think of names as being ASCII strings such\n  \
    \ as \"input errors\", the actual name would just be an ASN.1 tag.  Such\n   names\
    \ would be small integers (typically, less than 100) and so could\n   easily be\
    \ mapped by the monitored entity onto its internal\n   representation.\n   We\
    \ will use the term \"dictionary\" to represent an internal node in\n   the hierarchy.\
    \  Here is a possible organization of the hierarchy in\n   an entity that has\
    \ several network interfaces and multiple processes.\n   The exact organization\
    \ of data in entities is specified in RFC-1024.\n          system {\n        \
    \          name                            -- host name\n                  clock-msec\
    \                      -- msec since boot\n                  interfaces      \
    \                -- # of interfaces\n                  }\n          interfaces\
    \ {                    -- one per interface\n                  interface { type,\
    \ ip-addr, in-pkts, out-pkts, . . . }\n                  interface { type, ip-addr,\
    \ in-pkts, out-pkts, . . . }\n                  interface { type, ip-addr, in-pkts,\
    \ out-pkts, . . . }\n                                  :\n                  }\n\
    \          processes {\n                  process { name, stack, interrupts, .\
    \ . . }\n                  process { name, stack, interrupts, . . . }\n      \
    \                            :\n                  }\n          route-table {\n\
    \                  route-entry { dest, interface, nexthop, cost, . . . }\n   \
    \               route-entry { dest, interface, nexthop, cost, . . . }\n      \
    \                            :\n                  }\n          arp-table {\n \
    \                 arp-entry { hard-addr, ip-addr, age }\n                  arp-entry\
    \ { hard-addr, ip-addr, age }\n                                  :\n         \
    \         }\n          memory { }\n   The \"name\" of the clock in this entity\
    \ would be:\n          system{ clock-msec }\n   and the name of a route-entry's\
    \ IP address would be:\n          route-table{ route-entry{ ip-addr } }.\n   Actually,\
    \ this is the name of the IP addresses of ALL of the routing\n   table entries.\
    \  This ambiguity is a problem in any situation where\n   there are several instances\
    \ of an item being monitored.  If there was\n   a meaningful index for such tabular\
    \ data (e.g., \"routing table entry\n   #1\"), there would be no problem.  Unfortunately,\
    \ there usually isn't\n   such an index.  The solution to this problem requires\
    \ that the data\n   be accessed on the basis of some of its content.  More on\
    \ this later.\n   More than one piece of data can be named by a single ASN.1 object.\n\
    \   The entire collection of system information is named by:\n          system{\
    \ }\n   and the name of a routing table's IP address and cost would be:\n    \
    \      route-table{ route-entry{ ip-addr, cost } }.\n"
- title: Arrays
  contents:
  - "Arrays\n   There is one sub-type of a dictionary that is used as the basis for\n\
    \   tables of objects with identical types.  We call these dictionaries\n   arrays.\
    \  In the example above, the dictionaries for interfaces,\n   processes, routing\
    \ tables, and ARP tables are all arrays.  In fact,\n   we expect that most of\
    \ the interesting data in an entity will be\n   contained in arrays.\n   The primary\
    \ difference between arrays and plain dictionaries is that\n   arrays may contain\
    \ only one type of item, while dictionaries, in\n   general, will contain many\
    \ different types of items.  Arrays are\n   usually accessed associatively using\
    \ special operators in the\n   language.\n   The fact that these objects are viewed\
    \ externally as arrays does not\n   mean that they are represented in an implementation\
    \ as linear lists\n   of objects.  Any collection of same-typed objects is viewed\
    \ as an\n   array, even though it might be represented as, for example, a hash\n\
    \   table.\n"
- title: REPRESENTATION OF A REPLY
  contents:
  - "REPRESENTATION OF A REPLY\n   The data returned to the monitoring entity is a\
    \ sequence of ASN.1\n   data items.  Each of these corresponds to one the top-level\n\
    \   dictionaries maintained by the monitored entity.  The tags for these\n   data\
    \ items will be in the \"application-specific\" class (e.g., if an\n   entity\
    \ has the above structure for its data, then the only top-level\n   data items\
    \ that will be returned will have tags corresponding to\n   these groups).  If\
    \ a query returned data from two of these, the\n   representation might look like:\n\
    \          interfaces{ . . . }  route-table{ . . . }\n   which is just a stream\
    \ of two ASN.1 objects (each of which may\n   consist of many sub-objects).\n\
    \   Data not in the root dictionary will have tags from the context-\n   specific\
    \ class.  Therefore, data must always be fully qualified.  For\n   example, the\
    \ name of the entity would always be returned encapsulated\n   inside an ASN.1\
    \ object for \"system\".  If it were not, there would be\n   no way to tell if\
    \ the object that was returned were \"name\" inside the\n   \"system\" dictionary\
    \ or \"dest\" inside the \"interfaces\" dictionary\n   (assuming in this case\
    \ that \"name\" and \"dest\" were assigned the same\n   ASN.1 tag).\n   Having\
    \ fully-qualified data simplifies decoding of the data at the\n   receiving end\
    \ and allows the tags to be locally chosen (e.g.,\n   definitions for tags dealing\
    \ with ARP tables can't conflict with\n   definitions for tags dealing with interfaces).\
    \  Therefore, the people\n   doing the name assignments are less constrained.\
    \  In addition, most\n   of the identifiers will be fairly small integers.\n \
    \  It will often be the case that requested data may not be available,\n   either\
    \ because the request was badly formed (asked for data that\n   couldn't exist)\
    \ or because the particular data item wasn't defined in\n   a particular situation\
    \ (time since last error, when there hasn't been\n   an error).  In this situation,\
    \ the returned data item will have the\n   same tag as in the request, but will\
    \ have zero-length data.\n   Therefore, there can NEVER be an \"undefined data\"\
    \ error.\n   This allows completely generic queries to be composed without regard\n\
    \   to whether the data is defined at all of the entities that will\n   receive\
    \ the request.  All of the available data will be returned,\n   without generating\
    \ errors that might otherwise terminate the\n   processing of the query.\n"
- title: REPRESENTATION OF A REQUEST
  contents:
  - "REPRESENTATION OF A REQUEST\n   A request to a monitored entity is also a sequence\
    \ of ASN.1 data\n   items.  Each item will fit into one of the following categories:\n\
    \   Template        These are objects with the same types as the\n           \
    \        objects returned by a request.  The difference\n                   is\
    \ that a template only specifies the shape of\n                   the data --\
    \ there are no values contained in\n                   it.  Templates are used\
    \ to select specific data\n                   to be returned.  No ordering of\
    \ returned data\n                   is implied by the ordering in a template.\
    \  A\n                   template may be either simple or structured,\n      \
    \             depending upon what data it is naming.  The\n                  \
    \ representations of the simple data items in a\n                   template all\
    \ have a length of zero.\n   Tag             A tag is a special case of a template\
    \ that is a\n                   simple (non-structured) type (i.e., it names\n\
    \                   exactly one node in the dictionary tree).\n   Opcodes    \
    \     These objects tell the query interpreter to do\n                   something.\
    \  They are described in detail later in\n                   this report.  Opcodes\
    \ are represented as an\n                   application-specific type whose value\
    \ determines\n                   the operation.  These values are defined in\n\
    \                   RFC-1024.\n   Data            These are the same objects that\
    \ are used to\n                   represent information returned from an entity.\n\
    \                   It is occasionally be necessary to send data as\n        \
    \           part of a request.  For example, when requesting\n               \
    \    information about the interface with IP address\n                   \"10.0.0.51\"\
    , the address would be sent in the\n                   same format in the request\
    \ as it would be seen\n                   in a reply.\n   Data, Tags, and Templates\
    \ are usually in either the context-specific\n   class, except for items in the\
    \ root dictionary and a few special\n   cases, which are in the application-specific\
    \ class.\n"
- title: QUERY LANGUAGE
  contents:
  - "QUERY LANGUAGE\n   Although queries are formed in a flexible way using what we\
    \ term a\n   \"language\", this is not a programming language.  There are operations\n\
    \   that operate on data, but most other features of programming\n   languages\
    \ are not present.  In particular:\n         - Programs are not stored in the\
    \ query processor.\n         - The only form of temporary storage is a stack.\n\
    \   In the current version of the query language:\n         - There are no subroutines.\n\
    \         - There are no control structures defined in the language.\n       \
    \  - There are no arithmetic or conditional operators.\n   These features could\
    \ be added to the language if needed.\n   This language is designed with the goal\
    \ of being expressive enough to\n   write useful queries with, but to guarantee\
    \ simplicity, both of query\n   execution and language implementation.\n   The\
    \ central element of the language is the stack.  It may contain\n   templates,\
    \ (and therefore tags), data, or dictionaries (and therefore\n   arrays) from\
    \ the entity being monitored.  Initially, it contains one\n   item, the root dictionary.\n\
    \   The overall operation consists of reading ASN.1 objects from the\n   input\
    \ stream.  All objects that aren't opcodes are pushed onto the\n   stack as soon\
    \ as they are read.  Each opcode is executed immediately\n   and may remove things\
    \ from the stack and may generate ASN.1 objects\n   and send them to the output\
    \ stream.  Note that portions of the\n   response may be generated while the query\
    \ is still being received.\n   The following opcodes are defined in the language.\
    \  This is a\n   provisional list -- changes may need to be made to deal with\n\
    \   additional needs.\n   In the descriptions below, opcode names are in capital\
    \ letters,\n   preceded by the arguments used from the stack and followed by results\n\
    \   left on the stack.  For example:\n   OP          a b    OP    t\n        \
    \       means that the OP operator takes <a> and <b> off of the\n            \
    \   stack and leaves <t> on the stack.  Many of the operators\n              \
    \ below leave the first operand (<a> in this example) on\n               the stack\
    \ for future use.\n   Here are the operators defined in the query language:\n\
    \   GET         dict template    GET    dict\n               Emit an ASN.1 object\
    \ with the same \"shape\" as the given\n               template.  Any items in\
    \ the template that are not in\n               <dictionary> (or its components)\
    \ are represented as\n               objects with a length of zero.  This handles\
    \ requests for\n               data that isn't available, either because it isn't\n\
    \               defined or because it doesn't apply in this situation.\n   or\
    \          dict    GET    dict\n               If there is no template, get all\
    \ of the items in the\n               dictionary.  This is equivalent to providing\
    \ a template\n               that lists all of the items in the dictionary.\n\
    \   BEGIN       dict1 tag    BEGIN     dict1 dict\n               Pushes the value\
    \ for dict{ tag } on the stack, which\n               should be another dictionary.\
    \  At the same time, produce\n               the beginning octets of an ASN.1\
    \ object corresponding to\n               that dictionary.  It is up to the implementation\
    \ to\n               choose between using the \"indefinite length\"\n        \
    \       representation or going back and filling the length in\n             \
    \  later.\n   END         dict    END    --\n               Pop the dictionary\
    \ off of the stack and terminate the\n               currently open ASN.1 object.\
    \  Must be paired with a\n               BEGIN.\n"
- title: Getting Items Based on Their Values
  contents:
  - "Getting Items Based on Their Values\n   One problem that has not been dealt with\
    \ was alluded to earlier:\n   When dealing with array data, how do you specify\
    \ one or more entries\n   based upon some value in the array entries?  Consider\
    \ the situation\n   where there are several interfaces.  The data might be organized\
    \ as:\n          interfaces {\n                  interface { type, ip-addr, in-pkts,\
    \ out-pkts, ...}\n                  interface { type, ip-addr, in-pkts, out-pkts,\
    \ ...}\n                                  :\n                                \
    \  :\n                  }\n   If you only want information about one interface\
    \ (perhaps because\n   there is an enormous amount of data about each), then you\
    \ have to\n   have some way to name it.  One possibility is to just number the\n\
    \   interfaces and refer to the desired interface as:\n          interfaces(3)\n\
    \   for the third one.\n   But this is probably not sufficient since interface\
    \ numbers may\n   change over time, perhaps from one reboot to the next.  This\
    \ method\n   is not sufficient at all for arrays with many elements, such as\n\
    \   processes, routing tables, etc.  Large, changing arrays are probably\n   the\
    \ more common case, in fact.\n   Because of the lack of utility of indexing in\
    \ this context, there is\n   no general mechanism in the language for indexing.\n\
    \   A better scheme is to select objects based upon some value contained\n   in\
    \ them, such as the IP address or process name.  The GET-MATCH\n   operator provides\
    \ this functionality in a fairly general way.\n   GET-MATCH   array value template\
    \    GET-MATCH    array\n               <array> should be a array (dictionary\
    \ containing only\n               one type of item).  The first tag in <value>\
    \ and\n               <template> must match this type.  For each entry in\n  \
    \             <array>, match the <value> against the contents of\n           \
    \    the entry.  If there is a match, emit the entry based\n               upon\
    \ <template>, just as in a GET operation.\n   If there are several leaf items\
    \ in the value to be matched against,\n   as in:\n          route-entry{ interface(1),\
    \ cost(3) }\n   all of them must match an array entry for it to be emitted.\n\
    \   Here is an example of how this operator would be used to obtain the\n   input\
    \ and output packet counts for the interface with ip-address\n   10.0.0.51.\n\
    \          interfaces BEGIN                    -- get dictionary\n          interface{\
    \ ip-addr(10.0.0.51) }     -- value to match\n          interface{ in-pkts out-pkts\
    \ }       -- data template to get\n          GET-MATCH\n          END        \
    \                         -- finished with dict\n   The exact meaning of a \"\
    match\" is dependent upon the characteristics\n   of the entities being compared.\
    \  In almost all cases, it is a\n   comparison for exact equality.  However, it\
    \ is quite reasonable to\n   define values that allow matches to do interesting\
    \ things.  For\n   example, one might define three different flavors of \"ip-addr\"\
    :  one\n   that has only the IP net number, one with the IP net+subnet, and the\n\
    \   whole IP address.  Another possibility is to allow for wildcards in\n   IP\
    \ addresses (e.g., if the \"host\" part of an IP address was all ones,\n   then\
    \ that would match against any IP address with the same net\n   number).\n   So,\
    \ for all data items defined, the behavior of the match operation\n   must be\
    \ defined if it is not simple equality.\n   Implementations don't have to provide\
    \ the ability to use all items in\n   an object to match against.  It is expected\
    \ that some data structures\n   that provide for efficient lookup for one item\
    \ may be very\n   inefficient for matching against others.  (For instance, routing\n\
    \   tables are designed for lookup with IP addresses.  It may be very\n   difficult\
    \ to search the routing table, matching against costs.)\n   NOTE:  It would be\
    \ desirable to provide a general-purpose filtering\n   capability, rather than\
    \ just \"equality\" as provided by GET-MATCH.\n   However, because of the potential\
    \ complexity of such a facility, lack\n   of a widely-accepted representation\
    \ for filter expressions, and time\n   pressure, we are not defining this mechanism\
    \ now.\n   However, if a generalized filtering mechanism is devised, the GET-\n\
    \   MATCH operator will disappear.\n"
- title: Data Attributes
  contents:
  - "Data Attributes\n   Although ASN.1 data is self-describing as far as the structure\
    \ goes,\n   it gives no information about what the data means (e.g., By looking\n\
    \   at the raw data, it is possible to tell that an item is of type\n   [context\
    \ 5] and 4 octets long).  That does not tell how to interpret\n   the data (is\
    \ this an integer, an IP address, or a 4-character\n   string?), or what the data\
    \ means (IP address of what?).\n   Most of the time, this information will come\
    \ from RFC-1024, which\n   defines all of the ASN.1 tags and their precise meaning.\
    \  When\n   extensions have been made, it may not be possible to get\n   documentation\
    \ on the extensions.  (See the section about extensions,\n   page 15.)\n   The\
    \ query language provides a set of operators parallel to the GET\n   and GET-MATCH\
    \ operators that return a set of attributes describing\n   the data.  This information\
    \ should be sufficient to let a human\n   understand the meaning of the data and\
    \ to let a sophisticated\n   application treat the data appropriately.  The information\
    \ is\n   sufficient to let an application format the information on a display\n\
    \   and decide whether or not to subtract one sample from another.\n   Some of\
    \ the attributes are textual descriptions to help a human\n   understand the nature\
    \ of the data and provide meaningful labels for\n   it.  Extensive descriptions\
    \ of standard data are optional, since they\n   are defined in RFC-1024.  Complete\
    \ descriptions of extensions must be\n   available, even if they are documented\
    \ in a user's manual.  Network\n   firefighters may not have the manual handy\
    \ when the network is\n   broken.\n   The format of the attributes is not as simple\
    \ as the format of the\n   data itself.  It isn't possible to use the data's tag,\
    \ since that\n   would just look exactly like the data itself.  The format is:\n\
    \          Attributes ::= [APPLICATION 2] IMPLICIT SEQUENCE {\n              \
    \    tagASN1       [0] IMPLICIT INTEGER,\n                  valueFormat   [1]\
    \ IMPLICIT INTEGER,\n                  longDesc      [2] IMPLICIT IA5String OPTIONAL,\n\
    \                  shortDesc     [3] IMPLICIT IA5String OPTIONAL,\n          \
    \        unitsDesc     [4] IMPLICIT IA5String OPTIONAL,\n                  precision\
    \     [5] IMPLICIT INTEGER OPTIONAL,\n                  properties    [6] IMPLICIT\
    \ BITSTRING OPTIONAL,\n          }\n   For example, the attributes for\n     \
    \  system{ name, clock-msec }\n   might be:\n       system{\n               Attributes{\n\
    \                       tagASN1(name), valueFormat(IA5String),\n             \
    \          longDesc(\"The name of the host\"),\n                       shortDesc(\"\
    hostname\")\n               },\n               Attributes{\n                 \
    \      tagASN1(clock-msec), valueFormat(Integer),\n                       longDesc(\"\
    milliseconds since boot\"),\n                       shortDesc(\"uptime\"), unitsDesc(\"\
    ms\")\n                       precision(4294967296),\n                       properties(1)\n\
    \               }\n   Note that in this example <name> and <clock-msec> are integer\
    \ values\n   for the ASN.1 tags for the two data items.  A complete definition\
    \ of\n   the contents of the Attributes type is in RFC-1024.\n   Note that there\
    \ will be exactly as many Attributes items in the\n   result as there are objects\
    \ in the template.  Attributes objects for\n   items which do not exist in the\
    \ entity will have a valueFormat of\n   NULL and none of the optional elements\
    \ will appear.\n   GET-ATTRIBUTES\n               dict template    GET-ATTRIBUTES\
    \    dict\n               Emit ASN.1 Attributes objects that for the objects named\n\
    \               in <template>.  Any items in the template that are not\n     \
    \          in <dictionary> (or its components), elicit an\n               Attributes\
    \ object with no.\n   or          dict    GET-ATTRIBUTES    dict\n           \
    \    If there is no template, emit Attribute objects for all\n               of\
    \ the items in the dictionary.  This is equivalent to\n               providing\
    \ a template that lists all of the items in the\n               dictionary.  This\
    \ allows a complete list of a\n               dictionary's contents to be obtained.\n\
    \   GET-ATTRIBUTES-MATCH\n               dict value template GET-ATTRIBUTES-MATCH\
    \ dict <array>\n               should be an array (dictionary containing only\
    \ one\n               type of item).  The first tag in <value> and\n         \
    \      <template> must match this type.  For each entry in\n               <array>,\
    \ match the <value> against the contents of the\n               entry.  If there\
    \ is a match, emit the atributes based\n               upon <template>, just as\
    \ in a GET-ATTRIBUTES operation.\n   GET-ATTRIBUTES-MATCH is necessary because\
    \ there will be situations\n   where the contents of the elements of an array\
    \ may differ, even\n   though the array elements themselves are of the same type.\
    \  The most\n   obvious example of this is the situation where several network\n\
    \   interfaces exist and are of different types, with different data\n   collected\
    \ for each type.\n   NOTE:  The GET-ATTRIBUTES-MATCH operator will disappear if\
    \ a\n   generalized filtering mechanism is devised.\n   ADDITIONAL NOTE:  A much\
    \ cleaner method would be to store the\n   attributes as sub-components of the\
    \ data item of interest.  For\n   example, requesting:\n          system{ clock-msec()\
    \ }  GET\n   would normally just get the value of the data.  Asking for an\n \
    \  additional layer down the tree would now get its attributes:\n          system{\
    \ clock-msec{ shortDesc, unitsDesc }  GET\n   would get the named attributes.\
    \  (The attributes would be named with\n   application-specific tags.)  Unfortunately,\
    \ ASN.1 doesn't provide an\n   obvious notation to describe this type of organization.\
    \  So, we're\n   stuck with the GET-ATTRIBUTES operator.  However, if this cleaner\n\
    \   organization becomes possible, this decision may be re-thought.\n"
- title: Examining Memory
  contents:
  - "Examining Memory\n   Even with the ability to symbolically access all of this\
    \ information\n   in an entity, there will still be times when it is necessary\
    \ to get\n   to very low levels and examine memory, as in remote debugging\n \
    \  operations.  The building blocks outlined so far can easily be\n   extended\
    \ to allow memory to be examined.\n   Memory is modeled as an array, with an ASN.1\
    \ representation of\n   OctetString.  Because of the variety of addressing architectures\
    \ in\n   existence, the conversion between the OctetString and \"memory\" is\n\
    \   very machine-dependent.  The only simple case is for byte-addressed\n   machines\
    \ with 8 bits per byte.\n   Each address space in an entity is represented by\
    \ one dictionary.  In\n   a one-address-space situation, this dictionary will\
    \ be at the top\n   level.  If each process has its own address space, then one\
    \ \"memory\"\n   dictionary may exist for each process.\n   The GET-RANGE operator\
    \ is provided for the primary purpose of\n   retrieving the contents of memory,\
    \ but can be used on any array.  It\n   is only useful in these other contexts\
    \ if the array index is\n   meaningful.\n   GET-RANGE   array start length   \
    \ GET-RANGE    dict\n               Get <length> elements of <array> starting\
    \ at <start>.\n               <start> and <length> are both ASN.1 INTEGER type.\n\
    \   The returned data may not be <length> octets long, since it may take\n   more\
    \ than one octet to represent one memory location.\n   Memory is special in that\
    \ it will not automatically be returned as\n   part of a request for an entire\
    \ dictionary (e.g., If memory is part\n   of the \"system\" dictionary, then requesting:\n\
    \          system{}\n   will emit the entire contents of the system dictionary,\
    \ but not the\n   memory item).\n   NOTE:  The GET-RANGE operator may disappear\
    \ if a generalized\n   filtering mechanism is devised.\n"
- title: Controlling Things
  contents:
  - "Controlling Things\n   All of the operators defined so far only allow data in\
    \ an entity to\n   be retrieved.  By replacing the \"template\" arguments used\
    \ in the GET\n   operators with values, data in the entity can be changed.\n \
    \  There are many control operations that do not correspond to simply\n   changing\
    \ the value of a piece of data, such as bringing an interface\n   \"down\" or\
    \ \"up\".  In these cases, a special data item associated with\n   the component\
    \ being controlled (e.g., each interface), would be\n   defined.  Control operations\
    \ then consist of \"setting\" this item to\n   an appropriate command code.\n\
    \   SET         dict value    SET    dict\n               Set the value(s) of\
    \ data in the entity to the value(s)\n               given in <value>.\n   SET-MATCH\
    \   array mvalue svalue    SET-MATCH    dict\n               <array> should be\
    \ a array (dictionary containing only one\n               type of item).  The\
    \ first tag in <mvalue> and <svalue>\n               must match this type.  For\
    \ each entry in <array>, match\n               the <mvalue> against the contents\
    \ of the entry.  If there\n               is a match, set value(s) in the entity\
    \ to the value(s) in\n               <svalue>, just as in SET.\n   CREATE    \
    \  array value    SET    dict\n               Insert a new entry into <array>.\
    \  Depending upon the\n               context, there may be severe restrictions\
    \ about what\n               constitutes a valid <value>.\n   DELETE      array\
    \ value    SET    dict\n               Delete the entry(s) in <array> that have\
    \ values that\n               match <value>.\n   If there are several leaf items\
    \ in the matched value, as in\n          route-entry{ interface(1), cost(3) }\n\
    \   all of them must match an array entry for any values to be changed.\n   Here\
    \ is an example of how this operator would be used to shut down\n   the interface\
    \ with ip-address 10.0.0.51 changing its status to\n   \"down\".\n          interfaces\
    \ BEGIN                    -- get dictionary\n          interface{ ip-addr(10.0.0.51)\
    \ }     -- value to match\n          interface{ status(down) }           -- value\
    \ to set\n          SET-MATCH\n          END                                 --\
    \ finished with dict\n   Delete the routing table entry for 36.0.0.0.\n      \
    \    route-table BEGIN                   -- get dictionary\n          route-entry{\
    \ ip-addr(36.0.0.0) }    -- value to match\n          DELETE\n          END  \
    \                               -- finished with dict\n   Note that this BEGIN/END\
    \ pair ends up sending an empty ASN.1 item.\n   We don't regard this as a problem,\
    \ as it is likely that there will be\n   some get operations executed in the same\
    \ context.  In addition, the\n   \"open\" ASN.1 item provides the correct context\
    \ for reporting errors.\n   (See page 14.)\n   NOTE:  The SET-MATCH operator will\
    \ disappear and the DELETE operator\n   will change if a generalized filtering\
    \ mechanism is devised.\n"
- title: Atomic Operations
  contents:
  - "Atomic Operations\n   Atomic operations can be provided if desired by allowing\
    \ the stack to\n   contain a fragment of a query.  A new operation would take\
    \ a query\n   fragment and verify its executability and execute it, atomically.\n\
    \   This is mentioned as a possibility, but it may be difficult to\n   implement.\
    \  More study is needed.\n"
- title: ERRORS
  contents:
  - "ERRORS\n   If some particular information is requested but is not available for\n\
    \   any reason (e.g., it doesn't apply to this implementation, isn't\n   collected,\
    \ etc.), it can ALWAYS be returned as \"no-value\" by giving\n   the ASN.1 length\
    \ as 0.\n   When there is any other kind of error, such as having improper\n \
    \  arguments on the top of the stack or trying to execute BEGIN when the\n   tag\
    \ doesn't refer to a dictionary, an ERROR object be emitted.  The\n   contents\
    \ of this object identify the exact nature of the error and\n   are discussed\
    \ in RFC-1024.\n   Since there may be several unterminated ASN.1 objects in progress\
    \ at\n   the time the error occurs, each one must be terminated.  Each\n   unterminated\
    \ object will be closed with a copy of the ERROR object.\n   Depending upon the\
    \ type of length encoding used for this object, this\n   will involve filling\
    \ the value for the length (definite length form)\n   or emitting two zero octets\
    \ (indefinite length form).  After all\n   objects are terminated, a final copy\
    \ of the ERROR object will be\n   emitted.  This structure guarantees that the\
    \ error will be noticed at\n   every level of interpretation on the receiving\
    \ end.\n   If there was an error before any ASN.1 objects were generated, then\n\
    \   the result would simply be:\n          error(details)\n   If a couple of ASN.1\
    \ objects were unterminated, the result might look\n   like:\n          interfaces{\n\
    \               interface { name(...) type(...) error(details) }\n           \
    \    error(details)\n               }\n          error{details}\n"
- title: EXTENDING THE SET OF VALUES
  contents:
  - "EXTENDING THE SET OF VALUES\n   There are two ways to extend the set of values\
    \ understood by the\n   query language.  The first is to register the data and\
    \ its meaning\n   and get an ASN.1 tag assigned for it.  This is the preferred\
    \ method\n   because it makes that data specification available for everyone to\n\
    \   use.\n   The second method is to use the VendorSpecific application type to\n\
    \   \"wrap\" the vendor-specific data.  Wherever an implementation defines\n \
    \  data that is not in RFC-1024, the \"VendorSpecific\" tag should be used\n \
    \  to label a dictionary containing the vendor-specific data.  For\n   example,\
    \ if a vendor had some data associated with interfaces that\n   was too strange\
    \ to get standard numbers assigned for, they could,\n   instead represent the\
    \ data like this:\n          interfaces {\n                  interface {\n   \
    \                       in-pkts, out-pkts, ...\n                          VendorSpecific\
    \ { ephemeris, declination }\n                          }\n                  }\n\
    \   In this case, ephemeris and declination are two context-dependent\n   tags\
    \ assigned by the vendor for its non-standard data.\n   If the vendor-specific\
    \ method is chosen, the private data MUST have\n   descriptions available through\
    \ the GET-ATTRIBUTES and GET-\n   ATTRIBUTESMATCH operators.  Even with this descriptive\
    \ ability, the\n   preferred method is to get standard numbers assigned if possible.\n"
- title: IMPLEMENTATION
  contents:
  - "IMPLEMENTATION\n   Although it is not normally in the spirit of RFCs to define\
    \ an\n   implementation, the authors feel that some suggestions will be useful\n\
    \   to early implementors of the query language.  This list is not meant\n   to\
    \ be complete, but merely to give some hints about how the authors\n   imagine\
    \ that the query processor might be implemented efficiently.\n         - The stack\
    \ is an abstraction -- it should be implemented\n           with pointers, not\
    \ by copying dictionaries, etc.\n         - An object-oriented approach should\
    \ make initial\n           implementation fairly easy.  Changes to the \"shape\"\
    \ if the\n           data items (which will certainly occur, early on) will also\n\
    \           be easier to make.\n         - Only a few \"messages\" need to be\
    \ understood by objects.\n         - Most interesting objects are dictionaries,\
    \ each of which\n           can be implemented using pointers to the data and\
    \ procedure\n           \"hooks\" to perform specific operations such as GET,\
    \ MATCH,\n           SET, etc.\n         - The hardest part is actually extracting\
    \ the data from an\n           existing TCP/IP implementions that weren't designed\
    \ with\n           detailed monitoring in mind.  This should be less of a\n  \
    \         problem if a system is designed with easy monitoring as a\n        \
    \   goal.\n"
- title: OBTAINING A COPY OF THE ASN.1 SPECIFICATION
  contents:
  - "OBTAINING A COPY OF THE ASN.1 SPECIFICATION\n   Copies of ISO Standard ASN.1\
    \ (Abstract Syntax Notation 1) are\n   available from the following source.  It\
    \ comes in two parts; both are\n   needed:\n          IS 8824 -- Specification\
    \ (meaning, notation)\n          IS 8825 -- Encoding Rules (representation)\n\
    \   They are available from:\n          Omnicom Inc.\n          115 Park St, S.E.\
    \          (new address as of March, 1987)\n          Vienna, VA  22180\n    \
    \      (703) 281-1135\n"
