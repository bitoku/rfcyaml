- contents:
  - '                              URI Template

    '
  title: __initial_text__
- contents:
  - "Abstract\n   A URI Template is a compact sequence of characters for describing
    a\n   range of Uniform Resource Identifiers through variable expansion.\n   This
    specification defines the URI Template syntax and the process\n   for expanding
    a URI Template into a URI reference, along with\n   guidelines for the use of
    URI Templates on the Internet.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6570.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \     1.1. Overview ...................................................3\n      1.2.
    Levels and Expression Types ................................5\n      1.3. Design
    Considerations ......................................9\n      1.4. Limitations
    ...............................................10\n      1.5. Notational Conventions
    ....................................11\n      1.6. Character Encoding and Unicode
    Normalization ..............12\n   2. Syntax .........................................................13\n
    \     2.1. Literals ..................................................13\n      2.2.
    Expressions ...............................................13\n      2.3. Variables
    .................................................14\n      2.4. Value Modifiers
    ...........................................15\n           2.4.1. Prefix Values
    ......................................15\n           2.4.2. Composite Values ...................................16\n
    \  3. Expansion ......................................................18\n      3.1.
    Literal Expansion .........................................18\n      3.2. Expression
    Expansion ......................................18\n           3.2.1. Variable
    Expansion .................................19\n           3.2.2. Simple String
    Expansion: {var} .....................21\n           3.2.3. Reserved Expansion:
    {+var} .........................22\n           3.2.4. Fragment Expansion: {#var}
    .........................23\n           3.2.5. Label Expansion with Dot-Prefix:
    {.var} ............24\n           3.2.6. Path Segment Expansion: {/var} .....................24\n
    \          3.2.7. Path-Style Parameter Expansion: {;var} .............25\n           3.2.8.
    Form-Style Query Expansion: {?var} .................26\n           3.2.9. Form-Style
    Query Continuation: {&var} ..............27\n   4. Security Considerations ........................................27\n
    \  5. Acknowledgments ................................................28\n   6.
    References .....................................................28\n      6.1.
    Normative References ......................................28\n      6.2. Informative
    References ....................................29\n   Appendix A. Implementation
    Hints ..................................30\n"
  title: Table of Contents
- contents:
  - '1.  Introduction

    '
  - contents:
    - "1.1.  Overview\n   A Uniform Resource Identifier (URI) [RFC3986] is often used
      to\n   identify a specific resource within a common space of similar\n   resources
      (informally, a \"URI space\").  For example, personal web\n   spaces are often
      delegated using a common pattern, such as\n     http://example.com/~fred/\n
      \    http://example.com/~mark/\n   or a set of dictionary entries might be grouped
      in a hierarchy by the\n   first letter of the term, as in\n     http://example.com/dictionary/c/cat\n
      \    http://example.com/dictionary/d/dog\n   or a service interface might be
      invoked with various user input in a\n   common pattern, as in\n     http://example.com/search?q=cat&lang=en\n
      \    http://example.com/search?q=chien&lang=fr\n   A URI Template is a compact
      sequence of characters for describing a\n   range of Uniform Resource Identifiers
      through variable expansion.\n   URI Templates provide a mechanism for abstracting
      a space of resource\n   identifiers such that the variable parts can be easily
      identified and\n   described.  URI Templates can have many uses, including the
      discovery\n   of available services, configuring resource mappings, defining\n
      \  computed links, specifying interfaces, and other forms of\n   programmatic
      interaction with resources.  For example, the above\n   resources could be described
      by the following URI Templates:\n     http://example.com/~{username}/\n     http://example.com/dictionary/{term:1}/{term}\n
      \    http://example.com/search{?q,lang}\n   We define the following terms:\n
      \  expression:  The text between '{' and '}', including the enclosing\n      braces,
      as defined in Section 2.\n   expansion:  The string result obtained from a template
      expression\n      after processing it according to its expression type, list
      of\n      variable names, and value modifiers, as defined in Section 3.\n   template
      processor:  A program or library that, given a URI Template\n      and a set
      of variables with values, transforms the template string\n      into a URI reference
      by parsing the template for expressions and\n      substituting each one with
      its corresponding expansion.\n   A URI Template provides both a structural description
      of a URI space\n   and, when variable values are provided, machine-readable
      instructions\n   on how to construct a URI corresponding to those values.  A
      URI\n   Template is transformed into a URI reference by replacing each\n   delimited
      expression with its value as defined by the expression type\n   and the values
      of variables named within the expression.  The\n   expression types range from
      simple string expansion to multiple\n   name=value lists.  The expansions are
      based on the URI generic\n   syntax, allowing an implementation to process any
      URI Template\n   without knowing the scheme-specific requirements of every possible\n
      \  resulting URI.\n   For example, the following URI Template includes a form-style\n
      \  parameter expression, as indicated by the \"?\" operator appearing\n   before
      the variable names.\n     http://www.example.com/foo{?query,number}\n   The
      expansion process for expressions beginning with the question-\n   mark (\"?\")
      operator follows the same pattern as form-style interfaces\n   on the World
      Wide Web:\n     http://www.example.com/foo{?query,number}\n                               \\_____________/\n
      \                                 |\n                                  |\n             For
      each defined variable in [ 'query', 'number' ],\n             substitute \"?\"
      if it is the first substitution or \"&\"\n             thereafter, followed
      by the variable name, '=', and the\n             variable's value.\n   If the
      variables have the values\n     query  := \"mycelium\"\n     number := 100\n
      \  then the expansion of the above URI Template is\n     http://www.example.com/foo?query=mycelium&number=100\n
      \  Alternatively, if 'query' is undefined, then the expansion would be\n     http://www.example.com/foo?number=100\n
      \  or if both variables are undefined, then it would be\n     http://www.example.com/foo\n
      \  A URI Template may be provided in absolute form, as in the examples\n   above,
      or in relative form.  A template is expanded before the\n   resulting reference
      is resolved from relative to absolute form.\n   Although the URI syntax is used
      for the result, the template string\n   is allowed to contain the broader set
      of characters that can be found\n   in Internationalized Resource Identifier
      (IRI) references [RFC3987].\n   Therefore, a URI Template is also an IRI template,
      and the result of\n   template processing can be transformed to an IRI by following
      the\n   process defined in Section 3.2 of [RFC3987].\n"
    title: 1.1.  Overview
  - contents:
    - "1.2.  Levels and Expression Types\n   URI Templates are similar to a macro
      language with a fixed set of\n   macro definitions: the expression type determines
      the expansion\n   process.  The default expression type is simple string expansion,\n
      \  wherein a single named variable is replaced by its value as a string\n   after
      pct-encoding any characters not in the set of unreserved URI\n   characters
      (Section 1.5).\n   Since most template processors implemented prior to this\n
      \  specification have only implemented the default expression type, we\n   refer
      to these as Level 1 templates.\n   .-----------------------------------------------------------------.\n
      \  | Level 1 examples, with variables having values of               |\n   |
      \                                                                |\n   |             var
      \  := \"value\"                                    |\n   |             hello
      := \"Hello World!\"                             |\n   |                                                                 |\n
      \  |-----------------------------------------------------------------|\n   |
      Op       Expression            Expansion                        |\n   |-----------------------------------------------------------------|\n
      \  |     | Simple string expansion                       (Sec 3.2.2) |\n   |
      \    |                                                           |\n   |     |
      \   {var}                 value                            |\n   |     |    {hello}
      \              Hello%20World%21                 |\n   `-----------------------------------------------------------------'\n
      \  Level 2 templates add the plus (\"+\") operator, for expansion of\n   values
      that are allowed to include reserved URI characters\n   (Section 1.5), and the
      crosshatch (\"#\") operator for expansion of\n   fragment identifiers.\n   .-----------------------------------------------------------------.\n
      \  | Level 2 examples, with variables having values of               |\n   |
      \                                                                |\n   |             var
      \  := \"value\"                                    |\n   |             hello
      := \"Hello World!\"                             |\n   |             path  :=
      \"/foo/bar\"                                 |\n   |                                                                 |\n
      \  |-----------------------------------------------------------------|\n   |
      Op       Expression            Expansion                        |\n   |-----------------------------------------------------------------|\n
      \  |  +  | Reserved string expansion                     (Sec 3.2.3) |\n   |
      \    |                                                           |\n   |     |
      \   {+var}                value                            |\n   |     |    {+hello}
      \             Hello%20World!                   |\n   |     |    {+path}/here
      \         /foo/bar/here                    |\n   |     |    here?ref={+path}
      \     here?ref=/foo/bar                |\n   |-----+-----------------------------------------------------------|\n
      \  |  #  | Fragment expansion, crosshatch-prefixed       (Sec 3.2.4) |\n   |
      \    |                                                           |\n   |     |
      \   X{#var}               X#value                          |\n   |     |    X{#hello}
      \            X#Hello%20World!                 |\n   `-----------------------------------------------------------------'\n
      \  Level 3 templates allow multiple variables per expression, each\n   separated
      by a comma, and add more complex operators for dot-prefixed\n   labels, slash-prefixed
      path segments, semicolon-prefixed path\n   parameters, and the form-style construction
      of a query syntax\n   consisting of name=value pairs that are separated by an
      ampersand\n   character.\n   .-----------------------------------------------------------------.\n
      \  | Level 3 examples, with variables having values of               |\n   |
      \                                                                |\n   |             var
      \  := \"value\"                                    |\n   |             hello
      := \"Hello World!\"                             |\n   |             empty :=
      \"\"                                         |\n   |             path  := \"/foo/bar\"
      \                                |\n   |             x     := \"1024\"                                     |\n
      \  |             y     := \"768\"                                      |\n   |
      \                                                                |\n   |-----------------------------------------------------------------|\n
      \  | Op       Expression            Expansion                        |\n   |-----------------------------------------------------------------|\n
      \  |     | String expansion with multiple variables      (Sec 3.2.2) |\n   |
      \    |                                                           |\n   |     |
      \   map?{x,y}             map?1024,768                     |\n   |     |    {x,hello,y}
      \          1024,Hello%20World%21,768        |\n   |     |                                                           |\n
      \  |-----+-----------------------------------------------------------|\n   |
      \ +  | Reserved expansion with multiple variables    (Sec 3.2.3) |\n   |     |
      \                                                          |\n   |     |    {+x,hello,y}
      \         1024,Hello%20World!,768          |\n   |     |    {+path,x}/here        /foo/bar,1024/here
      \              |\n   |     |                                                           |\n
      \  |-----+-----------------------------------------------------------|\n   |
      \ #  | Fragment expansion with multiple variables    (Sec 3.2.4) |\n   |     |
      \                                                          |\n   |     |    {#x,hello,y}
      \         #1024,Hello%20World!,768         |\n   |     |    {#path,x}/here        #/foo/bar,1024/here
      \             |\n   |     |                                                           |\n
      \  |-----+-----------------------------------------------------------|\n   |
      \ .  | Label expansion, dot-prefixed                 (Sec 3.2.5) |\n   |     |
      \                                                          |\n   |     |    X{.var}
      \              X.value                          |\n   |     |    X{.x,y}               X.1024.768
      \                      |\n   |     |                                                           |\n
      \  |-----+-----------------------------------------------------------|\n   |
      \ /  | Path segments, slash-prefixed                 (Sec 3.2.6) |\n   |     |
      \                                                          |\n   |     |    {/var}
      \               /value                           |\n   |     |    {/var,x}/here
      \        /value/1024/here                 |\n   |     |                                                           |\n
      \  |-----+-----------------------------------------------------------|\n   |
      \ ;  | Path-style parameters, semicolon-prefixed     (Sec 3.2.7) |\n   |     |
      \                                                          |\n   |     |    {;x,y}
      \               ;x=1024;y=768                    |\n   |     |    {;x,y,empty}
      \         ;x=1024;y=768;empty              |\n   |     |                                                           |\n
      \  |-----+-----------------------------------------------------------|\n   |
      \ ?  | Form-style query, ampersand-separated         (Sec 3.2.8) |\n   |     |
      \                                                          |\n   |     |    {?x,y}
      \               ?x=1024&y=768                    |\n   |     |    {?x,y,empty}
      \         ?x=1024&y=768&empty=             |\n   |     |                                                           |\n
      \  |-----+-----------------------------------------------------------|\n   |
      \ &  | Form-style query continuation                 (Sec 3.2.9) |\n   |     |
      \                                                          |\n   |     |    ?fixed=yes{&x}
      \       ?fixed=yes&x=1024                |\n   |     |    {&x,y,empty}          &x=1024&y=768&empty=
      \            |\n   |     |                                                           |\n
      \  `-----------------------------------------------------------------'\n   Finally,
      Level 4 templates add value modifiers as an optional suffix\n   to each variable
      name.  A prefix modifier (\":\") indicates that only a\n   limited number of
      characters from the beginning of the value are used\n   by the expansion (Section
      2.4.1).  An explode (\"*\") modifier\n   indicates that the variable is to be
      treated as a composite value,\n   consisting of either a list of names or an
      associative array of\n   (name, value) pairs, that is expanded as if each member
      were a\n   separate variable (Section 2.4.2).\n   .-----------------------------------------------------------------.\n
      \  | Level 4 examples, with variables having values of               |\n   |
      \                                                                |\n   |             var
      \  := \"value\"                                    |\n   |             hello
      := \"Hello World!\"                             |\n   |             path  :=
      \"/foo/bar\"                                 |\n   |             list  := (\"red\",
      \"green\", \"blue\")                   |\n   |             keys  := [(\"semi\",\";\"),(\"dot\",\".\"),(\"comma\",\",\")]
      \  |\n   |                                                                 |\n
      \  | Op       Expression            Expansion                        |\n   |-----------------------------------------------------------------|\n
      \  |     | String expansion with value modifiers         (Sec 3.2.2) |\n   |
      \    |                                                           |\n   |     |
      \   {var:3}               val                              |\n   |     |    {var:30}
      \             value                            |\n   |     |    {list}                red,green,blue
      \                  |\n   |     |    {list*}               red,green,blue                   |\n
      \  |     |    {keys}                semi,%3B,dot,.,comma,%2C         |\n   |
      \    |    {keys*}               semi=%3B,dot=.,comma=%2C         |\n   |     |
      \                                                          |\n   |-----+-----------------------------------------------------------|\n
      \  |  +  | Reserved expansion with value modifiers       (Sec 3.2.3) |\n   |
      \    |                                                           |\n   |     |
      \   {+path:6}/here        /foo/b/here                      |\n   |     |    {+list}
      \              red,green,blue                   |\n   |     |    {+list*}              red,green,blue
      \                  |\n   |     |    {+keys}               semi,;,dot,.,comma,,
      \            |\n   |     |    {+keys*}              semi=;,dot=.,comma=,             |\n
      \  |     |                                                           |\n   |-----+-----------------------------------------------------------|\n
      \  |  #  | Fragment expansion with value modifiers       (Sec 3.2.4) |\n   |
      \    |                                                           |\n   |     |
      \   {#path:6}/here        #/foo/b/here                     |\n   |     |    {#list}
      \              #red,green,blue                  |\n   |     |    {#list*}              #red,green,blue
      \                 |\n   |     |    {#keys}               #semi,;,dot,.,comma,,
      \           |\n   |     |    {#keys*}              #semi=;,dot=.,comma=,            |\n
      \  |     |                                                           |\n   |-----+-----------------------------------------------------------|\n
      \  |  .  | Label expansion, dot-prefixed                 (Sec 3.2.5) |\n   |
      \    |                                                           |\n   |     |
      \   X{.var:3}             X.val                            |\n   |     |    X{.list}
      \             X.red,green,blue                 |\n   |     |    X{.list*}             X.red.green.blue
      \                |\n   |     |    X{.keys}              X.semi,%3B,dot,.,comma,%2C
      \      |\n   |     |    X{.keys*}             X.semi=%3B.dot=..comma=%2C       |\n
      \  |     |                                                           |\n   |-----+-----------------------------------------------------------|\n
      \  |  /  | Path segments, slash-prefixed                 (Sec 3.2.6) |\n   |
      \    |                                                           |\n   |     |
      \   {/var:1,var}          /v/value                         |\n   |     |    {/list}
      \              /red,green,blue                  |\n   |     |    {/list*}              /red/green/blue
      \                 |\n   |     |    {/list*,path:4}       /red/green/blue/%2Ffoo
      \          |\n   |     |    {/keys}               /semi,%3B,dot,.,comma,%2C
      \       |\n   |     |    {/keys*}              /semi=%3B/dot=./comma=%2C        |\n
      \  |     |                                                           |\n   |-----+-----------------------------------------------------------|\n
      \  |  ;  | Path-style parameters, semicolon-prefixed     (Sec 3.2.7) |\n   |
      \    |                                                           |\n   |     |
      \   {;hello:5}            ;hello=Hello                     |\n   |     |    {;list}
      \              ;list=red,green,blue             |\n   |     |    {;list*}              ;list=red;list=green;list=blue
      \  |\n   |     |    {;keys}               ;keys=semi,%3B,dot,.,comma,%2C   |\n
      \  |     |    {;keys*}              ;semi=%3B;dot=.;comma=%2C        |\n   |
      \    |                                                           |\n   |-----+-----------------------------------------------------------|\n
      \  |  ?  | Form-style query, ampersand-separated         (Sec 3.2.8) |\n   |
      \    |                                                           |\n   |     |
      \   {?var:3}              ?var=val                         |\n   |     |    {?list}
      \              ?list=red,green,blue             |\n   |     |    {?list*}              ?list=red&list=green&list=blue
      \  |\n   |     |    {?keys}               ?keys=semi,%3B,dot,.,comma,%2C   |\n
      \  |     |    {?keys*}              ?semi=%3B&dot=.&comma=%2C        |\n   |
      \    |                                                           |\n   |-----+-----------------------------------------------------------|\n
      \  |  &  | Form-style query continuation                 (Sec 3.2.9) |\n   |
      \    |                                                           |\n   |     |
      \   {&var:3}              &var=val                         |\n   |     |    {&list}
      \              &list=red,green,blue             |\n   |     |    {&list*}              &list=red&list=green&list=blue
      \  |\n   |     |    {&keys}               &keys=semi,%3B,dot,.,comma,%2C   |\n
      \  |     |    {&keys*}              &semi=%3B&dot=.&comma=%2C        |\n   |
      \    |                                                           |\n   `-----------------------------------------------------------------'\n"
    title: 1.2.  Levels and Expression Types
  - contents:
    - "1.3.  Design Considerations\n   Mechanisms similar to URI Templates have been
      defined within several\n   specifications, including WSDL [WSDL], WADL [WADL],
      and OpenSearch\n   [OpenSearch].  This specification extends and formally defines
      the\n   syntax so that URI Templates can be used consistently across multiple\n
      \  Internet applications and within Internet message fields, while at\n   the
      same time retaining compatibility with those earlier definitions.\n   The URI
      Template syntax has been designed to carefully balance the\n   need for a powerful
      expansion mechanism with the need for ease of\n   implementation.  The syntax
      is designed to be trivial to parse while\n   at the same time providing enough
      flexibility to express many common\n   template scenarios.  Implementations
      are able to parse the template\n   and perform the expansions in a single pass.\n
      \  Templates are simple and readable when used with common examples\n   because
      the single-character operators match the URI generic syntax\n   delimiters.
      \ The operator's associated delimiter (\".\", \";\", \"/\", \"?\",\n   \"&\",
      and \"#\") is omitted when none of the listed variables are\n   defined.  Likewise,
      the expansion process for \";\" (path-style\n   parameters) will omit the \"=\"
      when the variable value is empty,\n   whereas the process for \"?\" (form-style
      parameters) will not omit the\n   \"=\" when the value is empty.  Multiple variables
      and list values have\n   their values joined with \",\" if there is no predefined
      joining\n   mechanism for the operator.  The \"+\" and \"#\" operators will\n
      \  substitute unencoded reserved characters found inside the variable\n   values;
      the other operators will pct-encode reserved characters found\n   in the variable
      values prior to expansion.\n   The most common cases for URI spaces can be described
      with Level 1\n   template expressions.  If we were only concerned with URI generation,\n
      \  then the template syntax could be limited to just simple variable\n   expansion,
      since more complex forms could be generated by changing\n   the variable values.
      \ However, URI Templates have the additional goal\n   of describing the layout
      of identifiers in terms of preexisting data\n   values.  Therefore, the template
      syntax includes operators that\n   reflect how resource identifiers are commonly
      allocated.  Likewise,\n   since prefix substrings are often used to partition
      large spaces of\n   resources, modifiers on variable values provide a way to
      specify both\n   the substring and the full value string with a single variable
      name.\n"
    title: 1.3.  Design Considerations
  - contents:
    - "1.4.  Limitations\n   Since a URI Template describes a superset of the identifiers,
      there\n   is no implication that every possible expansion for each delimited\n
      \  variable expression corresponds to a URI of an existing resource.\n   Our
      expectation is that an application constructing URIs according to\n   the template
      will be provided with an appropriate set of values for\n   the variables being
      substituted, or at least a means of validating\n   user data-entry for those
      values.\n   URI Templates are not URIs: they do not identify an abstract or\n
      \  physical resource, they are not parsed as URIs, and they should not\n   be
      used in places where a URI would be expected unless the template\n   expressions
      will be expanded by a template processor prior to use.\n   Distinct field, element,
      or attribute names should be used to\n   differentiate protocol elements that
      carry a URI Template from those\n   that expect a URI reference.\n   Some URI
      Templates can be used in reverse for the purpose of variable\n   matching: comparing
      the template to a fully formed URI in order to\n   extract the variable parts
      from that URI and assign them to the named\n   variables.  Variable matching
      only works well if the template\n   expressions are delimited by the beginning
      or end of the URI or by\n   characters that cannot be part of the expansion,
      such as reserved\n   characters surrounding a simple string expression.  In
      general,\n   regular expression languages are better suited for variable matching.\n"
    title: 1.4.  Limitations
  - contents:
    - "1.5.  Notational Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      [RFC2119].\n   This specification uses the Augmented Backus-Naur Form (ABNF)\n
      \  notation of [RFC5234].  The following ABNF rules are imported from\n   the
      normative references [RFC5234], [RFC3986], and [RFC3987].\n     ALPHA          =
      \ %x41-5A / %x61-7A   ; A-Z / a-z\n     DIGIT          =  %x30-39             ;
      0-9\n     HEXDIG         =  DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" /
      \"F\"\n                       ; case-insensitive\n     pct-encoded    =  \"%\"
      HEXDIG HEXDIG\n     unreserved     =  ALPHA / DIGIT / \"-\" / \".\" / \"_\"
      / \"~\"\n     reserved       =  gen-delims / sub-delims\n     gen-delims     =
      \ \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\n     sub-delims     =
      \ \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n                    /  \"*\"
      / \"+\" / \",\" / \";\" / \"=\"\n     ucschar        =  %xA0-D7FF / %xF900-FDCF
      / %xFDF0-FFEF\n                    /  %x10000-1FFFD / %x20000-2FFFD / %x30000-3FFFD\n
      \                   /  %x40000-4FFFD / %x50000-5FFFD / %x60000-6FFFD\n                    /
      \ %x70000-7FFFD / %x80000-8FFFD / %x90000-9FFFD\n                    /  %xA0000-AFFFD
      / %xB0000-BFFFD / %xC0000-CFFFD\n                    /  %xD0000-DFFFD / %xE1000-EFFFD\n
      \    iprivate       =  %xE000-F8FF / %xF0000-FFFFD / %x100000-10FFFD\n"
    title: 1.5.  Notational Conventions
  - contents:
    - "1.6.  Character Encoding and Unicode Normalization\n   This specification uses
      the terms \"character\", \"character encoding\n   scheme\", \"code point\",
      \"coded character set\", \"glyph\", \"non-ASCII\",\n   \"normalization\", \"protocol
      element\", and \"regular expression\" as they\n   are defined in [RFC6365].\n
      \  The ABNF notation defines its terminal values to be non-negative\n   integers
      (code points) that are a superset of the US-ASCII coded\n   character set [ASCII].
      \ This specification defines terminal values as\n   code points within the Unicode
      coded character set [UNIV6].\n   In spite of the syntax and template expansion
      process being defined\n   in terms of Unicode code points, it should be understood
      that\n   templates occur in practice as a sequence of characters in whatever\n
      \  form or encoding is suitable for the context in which they occur,\n   whether
      that be octets embedded in a network protocol element or\n   glyphs painted
      on the side of a bus.  This specification does not\n   mandate any particular
      character encoding scheme for mapping between\n   URI Template characters and
      the octets used to store or transmit\n   those characters.  When a URI Template
      appears in a protocol element,\n   the character encoding scheme is defined
      by that protocol; without\n   such a definition, a URI Template is assumed to
      be in the same\n   character encoding scheme as the surrounding text.  It is
      only during\n   the process of template expansion that a string of characters
      in a\n   URI Template is REQUIRED to be processed as a sequence of Unicode\n
      \  code points.\n   The Unicode Standard [UNIV6] defines various equivalences
      between\n   sequences of characters for various purposes.  Unicode Standard
      Annex\n   #15 [UTR15] defines various Normalization Forms for these\n   equivalences.
      \ The normalization form determines how to consistently\n   encode equivalent
      strings.  In theory, all URI processing\n   implementations, including template
      processors, should use the same\n   normalization form for generating a URI
      reference.  In practice, they\n   do not.  If a value has been provided by the
      same server as the\n   resource, then it can be assumed that the string is already
      in the\n   form expected by that server.  If a value is provided by a user,
      such\n   as via a data-entry dialog, then the string SHOULD be normalized as\n
      \  Normalization Form C (NFC: Canonical Decomposition, followed by\n   Canonical
      Composition) prior to being used in expansions by a\n   template processor.\n
      \  Likewise, when non-ASCII data that represents readable strings is\n   pct-encoded
      for use in a URI reference, a template processor MUST\n   first encode the string
      as UTF-8 [RFC3629] and then pct-encode any\n   octets that are not allowed in
      a URI reference.\n"
    title: 1.6.  Character Encoding and Unicode Normalization
  title: 1.  Introduction
- contents:
  - "2.  Syntax\n   A URI Template is a string of printable Unicode characters that\n
    \  contains zero or more embedded variable expressions, each expression\n   being
    delimited by a matching pair of braces ('{', '}').\n     URI-Template  = *( literals
    / expression )\n   Although templates (and template processor implementations)
    are\n   described above in terms of four gradual levels, we define the URI-\n
    \  Template syntax in terms of the ABNF for Level 4.  A template\n   processor
    limited to lower-level templates MAY exclude the ABNF rules\n   applicable only
    to higher levels.  However, it is RECOMMENDED that\n   all parsers implement the
    full syntax such that unsupported levels\n   can be properly identified as such
    to the end user.\n"
  - contents:
    - "2.1.  Literals\n   The characters outside of expressions in a URI Template
      string are\n   intended to be copied literally to the URI reference if the character\n
      \  is allowed in a URI (reserved / unreserved / pct-encoded) or, if not\n   allowed,
      copied to the URI reference as the sequence of pct-encoded\n   triplets corresponding
      to that character's encoding in UTF-8\n   [RFC3629].\n     literals      =  %x21
      / %x23-24 / %x26 / %x28-3B / %x3D / %x3F-5B\n                   /  %x5D / %x5F
      / %x61-7A / %x7E / ucschar / iprivate\n                   /  pct-encoded\n                        ;
      any Unicode character except: CTL, SP,\n                        ;  DQUOTE, \"'\",
      \"%\" (aside from pct-encoded),\n                        ;  \"<\", \">\", \"\\\",
      \"^\", \"`\", \"{\", \"|\", \"}\"\n"
    title: 2.1.  Literals
  - contents:
    - "2.2.  Expressions\n   Template expressions are the parameterized parts of a
      URI Template.\n   Each expression contains an optional operator, which defines
      the\n   expression type and its corresponding expansion process, followed by\n
      \  a comma-separated list of variable specifiers (variable names and\n   optional
      value modifiers).  If no operator is provided, the\n   expression defaults to
      simple variable expansion of unreserved\n   values.\n     expression    =  \"{\"
      [ operator ] variable-list \"}\"\n     operator      =  op-level2 / op-level3
      / op-reserve\n     op-level2     =  \"+\" / \"#\"\n     op-level3     =  \".\"
      / \"/\" / \";\" / \"?\" / \"&\"\n     op-reserve    =  \"=\" / \",\" / \"!\"
      / \"@\" / \"|\"\n   The operator characters have been chosen to reflect each
      of their\n   roles as reserved characters in the URI generic syntax.  The\n
      \  operators defined in Section 3 of this specification include:\n      +   Reserved
      character strings;\n      #   Fragment identifiers prefixed by \"#\";\n      .
      \  Name labels or extensions prefixed by \".\";\n      /   Path segments prefixed
      by \"/\";\n      ;   Path parameter name or name=value pairs prefixed by \";\";\n
      \     ?   Query component beginning with \"?\" and consisting of\n          name=value
      pairs separated by \"&\"; and,\n      &   Continuation of query-style &name=value
      pairs within\n          a literal query component.\n   The operator characters
      equals (\"=\"), comma (\",\"), exclamation (\"!\"),\n   at sign (\"@\"), and
      pipe (\"|\") are reserved for future extensions.\n   The expression syntax specifically
      excludes use of the dollar (\"$\")\n   and parentheses [\"(\" and \")\"] characters
      so that they remain\n   available for use outside the scope of this specification.
      \ For\n   example, a macro language might use these characters to apply macro\n
      \  substitution to a string prior to that string being processed as a\n   URI
      Template.\n"
    title: 2.2.  Expressions
  - contents:
    - "2.3.  Variables\n   After the operator (if any), each expression contains a
      list of one\n   or more comma-separated variable specifiers (varspec).  The
      variable\n   names serve multiple purposes: documentation for what kinds of
      values\n   are expected, identifiers for associating values within a template\n
      \  processor, and the literal string to use for the name in name=value\n   expansions
      (aside from when exploding an associative array).\n   Variable names are case-sensitive
      because the name might be expanded\n   within a case-sensitive URI component.\n
      \    variable-list =  varspec *( \",\" varspec )\n     varspec       =  varname
      [ modifier-level4 ]\n     varname       =  varchar *( [\".\"] varchar )\n     varchar
      \      =  ALPHA / DIGIT / \"_\" / pct-encoded\n   A varname MAY contain one
      or more pct-encoded triplets.  These\n   triplets are considered an essential
      part of the variable name and\n   are not decoded during processing.  A varname
      containing pct-encoded\n   characters is not the same variable as a varname
      with those same\n   characters decoded.  Applications that provide URI Templates
      are\n   expected to be consistent in their use of pct-encoding within\n   variable
      names.\n   An expression MAY reference variables that are unknown to the\n   template
      processor or whose value is set to a special \"undefined\"\n   value, such as
      undef or null.  Such undefined variables are given\n   special treatment by
      the expansion process (Section 3.2.1).\n   A variable value that is a string
      of length zero is not considered\n   undefined; it has the defined value of
      an empty string.\n   In Level 4 templates, a variable may have a composite value
      in the\n   form of a list of values or an associative array of (name, value)\n
      \  pairs.  Such value types are not directly indicated by the template\n   syntax,
      but they do have an impact on the expansion process\n   (Section 3.2.1).\n   A
      variable defined as a list value is considered undefined if the\n   list contains
      zero members.  A variable defined as an associative\n   array of (name, value)
      pairs is considered undefined if the array\n   contains zero members or if all
      member names in the array are\n   associated with undefined values.\n"
    title: 2.3.  Variables
  - contents:
    - "2.4.  Value Modifiers\n   Each of the variables in a Level 4 template expression
      can have a\n   modifier indicating either that its expansion is limited to a
      prefix\n   of the variable's value string or that its expansion is exploded
      as a\n   composite value in the form of a value list or an associative array\n
      \  of (name, value) pairs.\n     modifier-level4 =  prefix / explode\n"
    - contents:
      - "2.4.1.  Prefix Values\n   A prefix modifier indicates that the variable expansion
        is limited to\n   a prefix of the variable's value string.  Prefix modifiers
        are often\n   used to partition an identifier space hierarchically, as is
        common in\n   reference indices and hash-based storage.  It also serves to
        limit\n   the expanded value to a maximum number of characters.  Prefix\n
        \  modifiers are not applicable to variables that have composite values.\n
        \    prefix        =  \":\" max-length\n     max-length    =  %x31-39 0*3DIGIT
        \  ; positive integer < 10000\n   The max-length is a positive integer that
        refers to a maximum number\n   of characters from the beginning of the variable's
        value as a Unicode\n   string.  Note that this numbering is in characters,
        not octets, in\n   order to avoid splitting between the octets of a multi-octet-encoded\n
        \  character or within a pct-encoded triplet.  If the max-length is\n   greater
        than the length of the variable's value, then the entire\n   value string
        is used.\n   For example,\n     Given the variable assignments\n       var
        \  := \"value\"\n       semi  := \";\"\n     Example Template     Expansion\n
        \      {var}              value\n       {var:20}           value\n       {var:3}
        \           val\n       {semi}             %3B\n       {semi:2}           %3B\n"
      title: 2.4.1.  Prefix Values
    - contents:
      - "2.4.2.  Composite Values\n   An explode (\"*\") modifier indicates that the
        variable is to be\n   treated as a composite value consisting of either a
        list of values or\n   an associative array of (name, value) pairs.  Hence,
        the expansion\n   process is applied to each member of the composite as if
        it were\n   listed as a separate variable.  This kind of variable specification\n
        \  is significantly less self-documenting than non-exploded variables,\n   since
        there is less correspondence between the variable name and how\n   the URI
        reference appears after expansion.\n     explode       =  \"*\"\n   Since
        URI Templates do not contain an indication of type or schema,\n   the type
        for an exploded variable is assumed to be determined by\n   context.  For
        example, the processor might be supplied values in a\n   form that differentiates
        values as strings, lists, or associative\n   arrays.  Likewise, the context
        in which the template is used (script,\n   mark-up language, Interface Definition
        Language, etc.) might define\n   rules for associating variable names with
        types, structures, or\n   schema.\n   Explode modifiers improve brevity in
        the URI Template syntax.  For\n   example, a resource that provides a geographic
        map for a given street\n   address might accept a hundred permutations on
        fields for address\n   input, including partial addresses (e.g., just the
        city or postal\n   code).  Such a resource could be described as a template
        with each\n   and every address component listed in order, or with a far more\n
        \  simple template that makes use of an explode modifier, as in\n      /mapper{?address*}\n
        \  along with some context that defines what the variable named\n   \"address\"
        can include, such as by reference to some other standard\n   for addressing
        (e.g., [UPU-S42]).  A recipient aware of the schema\n   can then provide appropriate
        expansions, such as:\n      /mapper?city=Newport%20Beach&state=CA\n   The
        expansion process for exploded variables is dependent on both the\n   operator
        being used and whether the composite value is to be treated\n   as a list
        of values or as an associative array of (name, value)\n   pairs.  Structures
        are processed as if they are an associative array\n   with names corresponding
        to the fields in the structure definition\n   and \".\" separators used to
        indicate name hierarchy in substructures.\n   If a variable has a composite
        structure and only some of the fields\n   in that structure have defined values,
        then only the defined pairs\n   are present in the expansion.  This can be
        useful for templates that\n   consist of a large number of potential query
        terms.\n   An explode modifier applied to a list variable causes the expansion\n
        \  to iterate over the list's member values.  For path and query\n   parameter
        expansions, each member value is paired with the variable's\n   name as a
        (varname, value) pair.  This allows path and query\n   parameters to be repeated
        for multiple values, as in\n     Given the variable assignments\n       year
        \ := (\"1965\", \"2000\", \"2012\")\n       dom   := (\"example\", \"com\")\n
        \    Example Template     Expansion\n       find{?year*}       find?year=1965&year=2000&year=2012\n
        \      www{.dom*}         www.example.com\n"
      title: 2.4.2.  Composite Values
    title: 2.4.  Value Modifiers
  title: 2.  Syntax
- contents:
  - "3.  Expansion\n   The process of URI Template expansion is to scan the template
    string\n   from beginning to end, copying literal characters and replacing each\n
    \  expression with the result of applying the expression's operator to\n   the
    value of each variable named in the expression.  Each variable's\n   value MUST
    be formed prior to template expansion.\n   The requirements on expansion for each
    aspect of the URI Template\n   grammar are defined in this section.  A non-normative
    algorithm for\n   the expansion process as a whole is provided in Appendix A.\n
    \  If a template processor encounters a character sequence outside an\n   expression
    that does not match the <URI-Template> grammar, then\n   processing of the template
    SHOULD cease, the URI reference result\n   SHOULD contain the expanded part of
    the template followed by the\n   remainder unexpanded, and the location and type
    of error SHOULD be\n   indicated to the invoking application.\n   If an error
    is encountered in an expression, such as an operator or\n   value modifier that
    the template processor does not recognize or does\n   not yet support, or a character
    is found that is not allowed by the\n   <expression> grammar, then the unprocessed
    parts of the expression\n   SHOULD be copied to the result unexpanded, processing
    of the\n   remainder of the template SHOULD continue, and the location and type\n
    \  of error SHOULD be indicated to the invoking application.\n   If an error occurs,
    the result returned might not be a valid URI\n   reference; it will be an incompletely
    expanded template string that\n   is only intended for diagnostic use.\n"
  - contents:
    - "3.1.  Literal Expansion\n   If the literal character is allowed anywhere in
      the URI syntax\n   (unreserved / reserved / pct-encoded ), then it is copied
      directly to\n   the result string.  Otherwise, the pct-encoded equivalent of
      the\n   literal character is copied to the result string by first encoding\n
      \  the character as its sequence of octets in UTF-8 and then encoding\n   each
      such octet as a pct-encoded triplet.\n"
    title: 3.1.  Literal Expansion
  - contents:
    - "3.2.  Expression Expansion\n   Each expression is indicated by an opening brace
      (\"{\") character and\n   continues until the next closing brace (\"}\").  Expressions
      cannot be\n   nested.\n   An expression is expanded by determining its expression
      type and then\n   following that type's expansion process for each comma-separated\n
      \  varspec in the expression.  Level 1 templates are limited to the\n   default
      operator (simple string value expansion) and a single\n   variable per expression.
      \ Level 2 templates are limited to a single\n   varspec per expression.\n   The
      expression type is determined by looking at the first character\n   after the
      opening brace.  If the character is an operator, then\n   remember the expression
      type associated with that operator for later\n   expansion decisions and skip
      to the next character for the variable-\n   list.  If the first character is
      not an operator, then the expression\n   type is simple string expansion and
      the first character is the\n   beginning of the variable-list.\n   The examples
      in the subsections below use the following definitions\n   for variable values:\n
      \        count := (\"one\", \"two\", \"three\")\n         dom   := (\"example\",
      \"com\")\n         dub   := \"me/too\"\n         hello := \"Hello World!\"\n
      \        half  := \"50%\"\n         var   := \"value\"\n         who   := \"fred\"\n
      \        base  := \"http://example.com/home/\"\n         path  := \"/foo/bar\"\n
      \        list  := (\"red\", \"green\", \"blue\")\n         keys  := [(\"semi\",\";\"),(\"dot\",\".\"),(\"comma\",\",\")]\n
      \        v     := \"6\"\n         x     := \"1024\"\n         y     := \"768\"\n
      \        empty := \"\"\n         empty_keys  := []\n         undef := null\n"
    - contents:
      - "3.2.1.  Variable Expansion\n   A variable that is undefined (Section 2.3)
        has no value and is\n   ignored by the expansion process.  If all of the variables
        in an\n   expression are undefined, then the expression's expansion is the\n
        \  empty string.\n   Variable expansion of a defined, non-empty value results
        in a\n   substring of allowed URI characters.  As described in Section 1.6,\n
        \  the expansion process is defined in terms of Unicode code points in\n   order
        to ensure that non-ASCII characters are consistently pct-\n   encoded in the
        resulting URI reference.  One way for a template\n   processor to obtain a
        consistent expansion is to transcode the value\n   string to UTF-8 (if it
        is not already in UTF-8) and then transform\n   each octet that is not in
        the allowed set into the corresponding pct-\n   encoded triplet.  Another
        is to map directly from the value's native\n   character encoding to the set
        of allowed URI characters, with any\n   remaining disallowed characters mapping
        to the sequence of pct-\n   encoded triplets that correspond to the octet(s)
        of that character\n   when encoded as UTF-8 [RFC3629].\n   The allowed set
        for a given expansion depends on the expression type:\n   reserved (\"+\")
        and fragment (\"#\") expansions allow the set of\n   characters in the union
        of ( unreserved / reserved / pct-encoded ) to\n   be passed through without
        pct-encoding, whereas all other expression\n   types allow only unreserved
        characters to be passed through without\n   pct-encoding.  Note that the percent
        character (\"%\") is only allowed\n   as part of a pct-encoded triplet and
        only for reserved/fragment\n   expansion: in all other cases, a value character
        of \"%\" MUST be pct-\n   encoded as \"%25\" by variable expansion.\n   If
        a variable appears more than once in an expression or within\n   multiple
        expressions of a URI Template, the value of that variable\n   MUST remain
        static throughout the expansion process (i.e., the\n   variable must have
        the same value for the purpose of calculating each\n   expansion).  However,
        if reserved characters or pct-encoded triplets\n   occur in the value, they
        will be pct-encoded by some expression types\n   and not by others.\n   For
        a variable that is a simple string value, expansion consists of\n   appending
        the encoded value to the result string.  An explode\n   modifier has no effect.
        \ A prefix modifier limits the expansion to\n   the first max-length characters
        of the decoded value.  If the value\n   contains multi-octet or pct-encoded
        characters, care must be taken to\n   avoid splitting the value in mid-character:
        count each Unicode code\n   point as one character.\n   For a variable that
        is an associative array, expansion depends on\n   both the expression type
        and the presence of an explode modifier.  If\n   there is no explode modifier,
        expansion consists of appending a\n   comma-separated concatenation of each
        (name, value) pair that has a\n   defined value.  If there is an explode modifier,
        expansion consists\n   of appending each pair that has a defined value as
        either\n   \"name=value\" or, if the value is the empty string and the expression\n
        \  type does not indicate form-style parameters (i.e., not a \"?\" or \"&\"\n
        \  type), simply \"name\".  Both name and value strings are encoded in the\n
        \  same way as simple string values.  A separator string is appended\n   between
        defined pairs according to the expression type, as defined by\n   the following
        table:\n      Type    Separator\n                 \",\"     (default)\n        +
        \       \",\"\n        #        \",\"\n        .        \".\"\n        /        \"/\"\n
        \       ;        \";\"\n        ?        \"&\"\n        &        \"&\"\n   For
        a variable that is a list of values, expansion depends on both\n   the expression
        type and the presence of an explode modifier.  If\n   there is no explode
        modifier, the expansion consists of a comma-\n   separated concatenation of
        the defined member string values.  If\n   there is an explode modifier and
        the expression type expands named\n   parameters (\";\", \"?\", or \"&\"),
        then the list is expanded as if it\n   were an associative array in which
        each member value is paired with\n   the list's varname.  Otherwise, the value
        will be expanded as if it\n   were a list of separate variable values, each
        value separated by the\n   expression type's associated separator as defined
        by the table above.\n     Example Template     Expansion\n       {count}            one,two,three\n
        \      {count*}           one,two,three\n       {/count}           /one,two,three\n
        \      {/count*}          /one/two/three\n       {;count}           ;count=one,two,three\n
        \      {;count*}          ;count=one;count=two;count=three\n       {?count}
        \          ?count=one,two,three\n       {?count*}          ?count=one&count=two&count=three\n
        \      {&count*}          &count=one&count=two&count=three\n"
      title: 3.2.1.  Variable Expansion
    - contents:
      - "3.2.2.  Simple String Expansion: {var}\n   Simple string expansion is the
        default expression type when no\n   operator is given.\n   For each defined
        variable in the variable-list, perform variable\n   expansion, as defined
        in Section 3.2.1, with the allowed characters\n   being those in the unreserved
        set.  If more than one variable has a\n   defined value, append a comma (\",\")
        to the result string as a\n   separator between variable expansions.\n     Example
        Template     Expansion\n       {var}              value\n       {hello}            Hello%20World%21\n
        \      {half}             50%25\n       O{empty}X          OX\n       O{undef}X
        \         OX\n       {x,y}              1024,768\n       {x,hello,y}        1024,Hello%20World%21,768\n
        \      ?{x,empty}         ?1024,\n       ?{x,undef}         ?1024\n       ?{undef,y}
        \        ?768\n       {var:3}            val\n       {var:30}           value\n
        \      {list}             red,green,blue\n       {list*}            red,green,blue\n
        \      {keys}             semi,%3B,dot,.,comma,%2C\n       {keys*}            semi=%3B,dot=.,comma=%2C\n"
      title: '3.2.2.  Simple String Expansion: {var}'
    - contents:
      - "3.2.3.  Reserved Expansion: {+var}\n   Reserved expansion, as indicated by
        the plus (\"+\") operator for Level\n   2 and above templates, is identical
        to simple string expansion except\n   that the substituted values may also
        contain pct-encoded triplets and\n   characters in the reserved set.\n   For
        each defined variable in the variable-list, perform variable\n   expansion,
        as defined in Section 3.2.1, with the allowed characters\n   being those in
        the set (unreserved / reserved / pct-encoded).  If\n   more than one variable
        has a defined value, append a comma (\",\") to\n   the result string as a
        separator between variable expansions.\n     Example Template        Expansion\n
        \      {+var}                value\n       {+hello}              Hello%20World!\n
        \      {+half}               50%25\n       {base}index           http%3A%2F%2Fexample.com%2Fhome%2Findex\n
        \      {+base}index          http://example.com/home/index\n       O{+empty}X
        \           OX\n       O{+undef}X            OX\n       {+path}/here          /foo/bar/here\n
        \      here?ref={+path}      here?ref=/foo/bar\n       up{+path}{var}/here
        \  up/foo/barvalue/here\n       {+x,hello,y}          1024,Hello%20World!,768\n
        \      {+path,x}/here        /foo/bar,1024/here\n       {+path:6}/here        /foo/b/here\n
        \      {+list}               red,green,blue\n       {+list*}              red,green,blue\n
        \      {+keys}               semi,;,dot,.,comma,,\n       {+keys*}              semi=;,dot=.,comma=,\n"
      title: '3.2.3.  Reserved Expansion: {+var}'
    - contents:
      - "3.2.4.  Fragment Expansion: {#var}\n   Fragment expansion, as indicated by
        the crosshatch (\"#\") operator for\n   Level 2 and above templates, is identical
        to reserved expansion\n   except that a crosshatch character (fragment delimiter)
        is appended\n   first to the result string if any of the variables are defined.\n
        \    Example Template     Expansion\n       {#var}             #value\n       {#hello}
        \          #Hello%20World!\n       {#half}            #50%25\n       foo{#empty}
        \       foo#\n       foo{#undef}        foo\n       {#x,hello,y}       #1024,Hello%20World!,768\n
        \      {#path,x}/here     #/foo/bar,1024/here\n       {#path:6}/here     #/foo/b/here\n
        \      {#list}            #red,green,blue\n       {#list*}           #red,green,blue\n
        \      {#keys}            #semi,;,dot,.,comma,,\n       {#keys*}           #semi=;,dot=.,comma=,\n"
      title: '3.2.4.  Fragment Expansion: {#var}'
    - contents:
      - "3.2.5.  Label Expansion with Dot-Prefix: {.var}\n   Label expansion, as indicated
        by the dot (\".\") operator for Level 3\n   and above templates, is useful
        for describing URI spaces with varying\n   domain names or path selectors
        (e.g., filename extensions).\n   For each defined variable in the variable-list,
        append \".\" to the\n   result string and then perform variable expansion,
        as defined in\n   Section 3.2.1, with the allowed characters being those in
        the\n   unreserved set.\n   Since \".\" is in the unreserved set, a value
        that contains a \".\" has\n   the effect of adding multiple labels.\n     Example
        Template     Expansion\n       {.who}             .fred\n       {.who,who}
        \        .fred.fred\n       {.half,who}        .50%25.fred\n       www{.dom*}
        \        www.example.com\n       X{.var}            X.value\n       X{.empty}
        \         X.\n       X{.undef}          X\n       X{.var:3}          X.val\n
        \      X{.list}           X.red,green,blue\n       X{.list*}          X.red.green.blue\n
        \      X{.keys}           X.semi,%3B,dot,.,comma,%2C\n       X{.keys*}          X.semi=%3B.dot=..comma=%2C\n
        \      X{.empty_keys}     X\n       X{.empty_keys*}    X\n"
      title: '3.2.5.  Label Expansion with Dot-Prefix: {.var}'
    - contents:
      - "3.2.6.  Path Segment Expansion: {/var}\n   Path segment expansion, as indicated
        by the slash (\"/\") operator in\n   Level 3 and above templates, is useful
        for describing URI path\n   hierarchies.\n   For each defined variable in
        the variable-list, append \"/\" to the\n   result string and then perform
        variable expansion, as defined in\n   Section 3.2.1, with the allowed characters
        being those in the\n   unreserved set.\n   Note that the expansion process
        for path segment expansion is\n   identical to that of label expansion aside
        from the substitution of\n   \"/\" instead of \".\".  However, unlike \".\",
        a \"/\" is a reserved\n   character and will be pct-encoded if found in a
        value.\n     Example Template     Expansion\n       {/who}             /fred\n
        \      {/who,who}         /fred/fred\n       {/half,who}        /50%25/fred\n
        \      {/who,dub}         /fred/me%2Ftoo\n       {/var}             /value\n
        \      {/var,empty}       /value/\n       {/var,undef}       /value\n       {/var,x}/here
        \     /value/1024/here\n       {/var:1,var}       /v/value\n       {/list}
        \           /red,green,blue\n       {/list*}           /red/green/blue\n       {/list*,path:4}
        \   /red/green/blue/%2Ffoo\n       {/keys}            /semi,%3B,dot,.,comma,%2C\n
        \      {/keys*}           /semi=%3B/dot=./comma=%2C\n"
      title: '3.2.6.  Path Segment Expansion: {/var}'
    - contents:
      - "3.2.7.  Path-Style Parameter Expansion: {;var}\n   Path-style parameter expansion,
        as indicated by the semicolon (\";\")\n   operator in Level 3 and above templates,
        is useful for describing URI\n   path parameters, such as \"path;property\"
        or \"path;name=value\".\n   For each defined variable in the variable-list:\n
        \  o  append \";\" to the result string;\n   o  if the variable has a simple
        string value or no explode modifier\n      is given, then:\n      *  append
        the variable name (encoded as if it were a literal\n         string) to the
        result string;\n      *  if the variable's value is not empty, append \"=\"
        to the result\n         string;\n   o  perform variable expansion, as defined
        in Section 3.2.1, with the\n      allowed characters being those in the unreserved
        set.\n     Example Template     Expansion\n       {;who}             ;who=fred\n
        \      {;half}            ;half=50%25\n       {;empty}           ;empty\n
        \      {;v,empty,who}     ;v=6;empty;who=fred\n       {;v,bar,who}       ;v=6;who=fred\n
        \      {;x,y}             ;x=1024;y=768\n       {;x,y,empty}       ;x=1024;y=768;empty\n
        \      {;x,y,undef}       ;x=1024;y=768\n       {;hello:5}         ;hello=Hello\n
        \      {;list}            ;list=red,green,blue\n       {;list*}           ;list=red;list=green;list=blue\n
        \      {;keys}            ;keys=semi,%3B,dot,.,comma,%2C\n       {;keys*}
        \          ;semi=%3B;dot=.;comma=%2C\n"
      title: '3.2.7.  Path-Style Parameter Expansion: {;var}'
    - contents:
      - "3.2.8.  Form-Style Query Expansion: {?var}\n   Form-style query expansion,
        as indicated by the question-mark (\"?\")\n   operator in Level 3 and above
        templates, is useful for describing an\n   entire optional query component.\n
        \  For each defined variable in the variable-list:\n   o  append \"?\" to
        the result string if this is the first defined value\n      or append \"&\"
        thereafter;\n   o  if the variable has a simple string value or no explode
        modifier\n      is given, append the variable name (encoded as if it were
        a\n      literal string) and an equals character (\"=\") to the result\n      string;
        and,\n   o  perform variable expansion, as defined in Section 3.2.1, with
        the\n      allowed characters being those in the unreserved set.\n     Example
        Template     Expansion\n       {?who}             ?who=fred\n       {?half}
        \           ?half=50%25\n       {?x,y}             ?x=1024&y=768\n       {?x,y,empty}
        \      ?x=1024&y=768&empty=\n       {?x,y,undef}       ?x=1024&y=768\n       {?var:3}
        \          ?var=val\n       {?list}            ?list=red,green,blue\n       {?list*}
        \          ?list=red&list=green&list=blue\n       {?keys}            ?keys=semi,%3B,dot,.,comma,%2C\n
        \      {?keys*}           ?semi=%3B&dot=.&comma=%2C\n"
      title: '3.2.8.  Form-Style Query Expansion: {?var}'
    - contents:
      - "3.2.9.  Form-Style Query Continuation: {&var}\n   Form-style query continuation,
        as indicated by the ampersand (\"&\")\n   operator in Level 3 and above templates,
        is useful for describing\n   optional &name=value pairs in a template that
        already contains a\n   literal query component with fixed parameters.\n   For
        each defined variable in the variable-list:\n   o  append \"&\" to the result
        string;\n   o  if the variable has a simple string value or no explode modifier\n
        \     is given, append the variable name (encoded as if it were a\n      literal
        string) and an equals character (\"=\") to the result\n      string; and,\n
        \  o  perform variable expansion, as defined in Section 3.2.1, with the\n
        \     allowed characters being those in the unreserved set.\n     Example
        Template     Expansion\n       {&who}             &who=fred\n       {&half}
        \           &half=50%25\n       ?fixed=yes{&x}     ?fixed=yes&x=1024\n       {&x,y,empty}
        \      &x=1024&y=768&empty=\n       {&x,y,undef}       &x=1024&y=768\n       {&var:3}
        \          &var=val\n       {&list}            &list=red,green,blue\n       {&list*}
        \          &list=red&list=green&list=blue\n       {&keys}            &keys=semi,%3B,dot,.,comma,%2C\n
        \      {&keys*}           &semi=%3B&dot=.&comma=%2C\n"
      title: '3.2.9.  Form-Style Query Continuation: {&var}'
    title: 3.2.  Expression Expansion
  title: 3.  Expansion
- contents:
  - "4.  Security Considerations\n   A URI Template does not contain active or executable
    content.\n   However, it might be possible to craft unanticipated URIs if an\n
    \  attacker is given control over the template or over the variable\n   values
    within an expression that allows reserved characters in the\n   expansion.  In
    either case, the security considerations are largely\n   determined by who provides
    the template, who provides the values to\n   use for variables within the template,
    in what execution context the\n   expansion occurs (client or server), and where
    the resulting URIs are\n   used.\n   This specification does not limit where URI
    Templates might be used.\n   Current implementations exist within server-side
    development\n   frameworks and within client-side javascript for computed links
    or\n   forms.\n   Within frameworks, templates usually act as guides for where
    data\n   might occur within later (request-time) URIs in client requests.\n   Hence,
    the security concerns are not in the templates themselves, but\n   rather in how
    the server extracts and processes the user-provided\n   data within a normal Web
    request.\n   Within client-side implementations, a URI Template has many of the\n
    \  same properties as HTML forms, except limited to URI characters and\n   possibly
    included in HTTP header field values instead of just message\n   body content.
    \ Care ought to be taken to ensure that potentially\n   dangerous URI reference
    strings, such as those beginning with\n   \"javascript:\", do not appear in the
    expansion unless both the\n   template and the values are provided by a trusted
    source.\n   Other security considerations are the same as those for URIs, as\n
    \  described in Section 7 of [RFC3986].\n"
  title: 4.  Security Considerations
- contents:
  - "5.  Acknowledgments\n   The following people made contributions to this specification:
    Mike\n   Burrows, Michaeljohn Clement, DeWitt Clinton, John Cowan, Stephen\n   Farrell,
    Robbie Gates, Vijay K. Gurbani, Peter Johanson, Murray S.\n   Kucherawy, James
    H. Manger, Tom Petch, Marc Portier, Pete Resnick,\n   James Snell, and Jiankang
    Yao.\n"
  title: 5.  Acknowledgments
- contents:
  - '6.  References

    '
  - contents:
    - "6.1.  Normative References\n   [ASCII]       American National Standards Institute,
      \"Coded Character\n                 Set - 7-bit American Standard Code for Information\n
      \                Interchange\", ANSI X3.4, 1986.\n   [RFC2119]     Bradner,
      S., \"Key words for use in RFCs to Indicate\n                 Requirement Levels\",
      BCP 14, RFC 2119, March 1997.\n   [RFC3629]     Yergeau, F., \"UTF-8, a transformation
      format of ISO\n                 10646\", STD 63, RFC 3629, November 2003.\n
      \  [RFC3986]     Berners-Lee, T., Fielding, R., and L. Masinter,\n                 \"Uniform
      Resource Identifier (URI): Generic Syntax\",\n                 STD 66, RFC 3986,
      January 2005.\n   [RFC3987]     Duerst, M. and M. Suignard, \"Internationalized
      Resource\n                 Identifiers (IRIs)\", RFC 3987, January 2005.\n   [RFC5234]
      \    Crocker, D. and P. Overell, \"Augmented BNF for Syntax\n                 Specifications:
      ABNF\", STD 68, RFC 5234, January 2008.\n   [RFC6365]     Hoffman, P. and J.
      Klensin, \"Terminology Used in\n                 Internationalization in the
      IETF\", BCP 166, RFC 6365,\n                 September 2011.\n   [UNIV6]       The
      Unicode Consortium, \"The Unicode Standard, Version\n                 6.0.0\",
      (Mountain View, CA: The Unicode Consortium,\n                 2011.  ISBN 978-1-936213-01-6),\n
      \                <http://www.unicode.org/versions/Unicode6.0.0/>.\n   [UTR15]
      \      Davis, M. and M. Duerst, \"Unicode Normalization Forms\",\n                 Unicode
      Standard Annex # 15, April 2003,\n                 <http://www.unicode.org/unicode/reports/tr15/\n
      \                tr15-23.html>.\n"
    title: 6.1.  Normative References
  - contents:
    - "6.2.  Informative References\n   [OpenSearch]  Clinton, D., \"OpenSearch 1.1\",
      Draft 5, December 2011,\n                 <http://www.opensearch.org/Specifications/OpenSearch>.\n
      \  [UPU-S42]     Universal Postal Union, \"International Postal Address\n                 Components
      and Templates\", UPU S42-1, November 2002,\n                 <http://www.upu.int/en/activities/addressing/\n
      \                standards.html>.\n   [WADL]        Hadley, M., \"Web Application
      Description Language\",\n                 World Wide Web Consortium Member Submission\n
      \                SUBM-wadl-20090831, August 2009,\n                 <http://www.w3.org/Submission/2009/\n
      \                SUBM-wadl-20090831/>.\n   [WSDL]        Weerawarana, S., Moreau,
      J., Ryman, A., and R.\n                 Chinnici, \"Web Services Description
      Language (WSDL)\n                 Version 2.0 Part 1: Core Language\", World
      Wide Web\n                 Consortium Recommendation REC-wsdl20-20070626,\n
      \                June 2007, <http://www.w3.org/TR/2007/\n                 REC-wsdl20-20070626>.\n"
    title: 6.2.  Informative References
  title: 6.  References
- contents:
  - "Appendix A.  Implementation Hints\n   The normative sections on expansion describe
    each operator with a\n   separate expansion process for the sake of descriptive
    clarity.  In\n   actual implementations, we expect the expressions to be processed\n
    \  left-to-right using a common algorithm that has only minor variations\n   in
    process per operator.  This non-normative appendix describes one\n   such algorithm.\n
    \  Initialize an empty result string and its non-error state.\n   Scan the template
    and copy literals to the result string (as in\n   Section 3.1) until an expression
    is indicated by a \"{\", an error is\n   indicated by the presence of a non-literals
    character other than \"{\",\n   or the template ends.  When it ends, return the
    result string and its\n   current error or non-error state.\n   o  If an expression
    is found, scan the template to the next \"}\" and\n      extract the characters
    in between the braces.\n   o  If the template ends before a \"}\", then append
    the \"{\" and\n      extracted characters to the result string and return with
    an error\n      status indicating the expression is malformed.\n   Examine the
    first character of the extracted expression for an\n   operator.\n   o  If the
    expression ended (i.e., is \"{}\"), an operator is found that\n      is unknown
    or unimplemented, or the character is not in the\n      varchar set (Section 2.3),
    then append \"{\", the extracted\n      expression, and \"}\" to the result string,
    remember that the result\n      is in an error state, and then go back to scan
    the remainder of\n      the template.\n   o  If a known and implemented operator
    is found, store the operator\n      and skip to the next character to begin the
    varspec-list.\n   o  Otherwise, store the operator as NUL (simple string expansion).\n
    \  Use the following value table to determine the processing behavior by\n   expression
    type operator.  The entry for \"first\" is the string to\n   append to the result
    first if any of the expression's variables are\n   defined.  The entry for \"sep\"
    is the separator to append to the\n   result before any second (or subsequent)
    defined variable expansion.\n   The entry for \"named\" is a boolean for whether
    or not the expansion\n   includes the variable or key name when no explode modifier
    is given.\n   The entry for \"ifemp\" is a string to append to the name if its\n
    \  corresponding value is empty.  The entry for \"allow\" indicates what\n   characters
    to allow unencoded within the value expansion: (U) means\n   any character not
    in the unreserved set will be encoded; (U+R) means\n   any character not in the
    union of (unreserved / reserved / pct-\n   encoding) will be encoded; and, for
    both cases, each disallowed\n   character is first encoded as its sequence of
    octets in UTF-8 and\n   then each such octet is encoded as a pct-encoded triplet.\n
    \  .------------------------------------------------------------------.\n   |
    \         NUL     +      .       /       ;      ?      &      #   |\n   |------------------------------------------------------------------|\n
    \  | first |  \"\"     \"\"     \".\"     \"/\"     \";\"    \"?\"    \"&\"    \"#\"
    \ |\n   | sep   |  \",\"    \",\"    \".\"     \"/\"     \";\"    \"&\"    \"&\"
    \   \",\"  |\n   | named | false  false  false   false   true   true   true   false
    |\n   | ifemp |  \"\"     \"\"     \"\"      \"\"      \"\"     \"=\"    \"=\"
    \   \"\"   |\n   | allow |   U     U+R     U       U       U      U      U     U+R
    \ |\n   `------------------------------------------------------------------'\n
    \  With the above table in mind, process the variable-list as follows:\n   For
    each varspec, extract a variable name and optional modifier from\n   the expression
    by scanning the variable-list until a character not in\n   the varname set is
    found or the end of the expression is reached.\n   o  If it is the end of the
    expression and the varname is empty, go\n      back to scan the remainder of the
    template.\n   o  If it is not the end of the expression and the last character\n
    \     found indicates a modifier (\"*\" or \":\"), remember that modifier.\n      If
    it is an explode (\"*\"), scan the next character.  If it is a\n      prefix (\":\"),
    continue scanning the next one to four characters\n      for the max-length represented
    as a decimal integer and then, if\n      it is still not the end of the expression,
    scan the next\n      character.\n   o  If it is not the end of the expression
    and the last character\n      found is not a comma (\",\"), append \"{\", the
    stored operator (if\n      any), the scanned varname and modifier, the remaining
    expression,\n      and \"}\" to the result string, remember that the result is
    in an\n      error state, and then go back to scan the remainder of the\n      template.\n
    \  Lookup the value for the scanned variable name, and then\n   o  If the varname
    is unknown or corresponds to a variable with an\n      undefined value (Section
    2.3), then skip to the next varspec.\n   o  If this is the first defined variable
    for this expression, append\n      the first string for this expression type to
    the result string and\n      remember that it has been done.  Otherwise, append
    the sep string\n      to the result string.\n   o  If this variable's value is
    a string, then\n      *  if named is true, append the varname to the result string
    using\n         the same encoding process as for literals, and\n         +  if
    the value is empty, append the ifemp string to the result\n            string
    and skip to the next varspec;\n         +  otherwise, append \"=\" to the result
    string.\n      *  if a prefix modifier is present and the prefix length is less\n
    \        than the value string length in number of Unicode characters,\n         append
    that number of characters from the beginning of the\n         value string to
    the result string, after pct-encoding any\n         characters that are not in
    the allow set, while taking care not\n         to split multi-octet or pct-encoded
    triplet characters that\n         represent a single Unicode code point;\n      *
    \ otherwise, append the value to the result string after pct-\n         encoding
    any characters that are not in the allow set.\n   o  else if no explode modifier
    is given, then\n      *  if named is true, append the varname to the result string
    using\n         the same encoding process as for literals, and\n         +  if
    the value is empty, append the ifemp string to the result\n            string
    and skip to the next varspec;\n         +  otherwise, append \"=\" to the result
    string; and\n      *  if this variable's value is a list, append each defined
    list\n         member to the result string, after pct-encoding any characters\n
    \        that are not in the allow set, with a comma (\",\") appended to\n         the
    result between each defined list member;\n      *  if this variable's value is
    an associative array or any other\n         form of paired (name, value) structure,
    append each pair with a\n         defined value to the result string as \"name,value\",
    after pct-\n         encoding any characters that are not in the allow set, with
    a\n         comma (\",\") appended to the result between each defined pair.\n
    \  o  else if an explode modifier is given, then\n      *  if named is true, then
    for each defined list member or array\n         (name, value) pair with a defined
    value, do:\n         +  if this is not the first defined member/value, append
    the\n            sep string to the result string;\n         +  if this is a list,
    append the varname to the result string\n            using the same encoding process
    as for literals;\n         +  if this is a pair, append the name to the result
    string\n            using the same encoding process as for literals;\n         +
    \ if the member/value is empty, append the ifemp string to the\n            result
    string; otherwise, append \"=\" and the member/value to\n            the result
    string, after pct-encoding any member/value\n            characters that are not
    in the allow set.\n      *  else if named is false, then\n         +  if this
    is a list, append each defined list member to the\n            result string,
    after pct-encoding any characters that are\n            not in the allow set,
    with the sep string appended to the\n            result between each defined list
    member.\n         +  if this is an array of (name, value) pairs, append each pair\n
    \           with a defined value to the result string as \"name=value\",\n            after
    pct-encoding any characters that are not in the allow\n            set, with the
    sep string appended to the result between each\n            defined pair.\n   When
    the variable-list for this expression is exhausted, go back to\n   scan the remainder
    of the template.\n"
  title: Appendix A.  Implementation Hints
- contents:
  - "Authors' Addresses\n   Joe Gregorio\n   Google\n   EMail: joe@bitworking.org\n
    \  URI:   http://bitworking.org/\n   Roy T. Fielding\n   Adobe Systems Incorporated\n
    \  EMail: fielding@gbiv.com\n   URI:   http://roy.gbiv.com/\n   Marc Hadley\n
    \  The MITRE Corporation\n   EMail: mhadley@mitre.org\n   URI:   http://mitre.org/\n
    \  Mark Nottingham\n   Rackspace\n   EMail: mnot@mnot.net\n   URI:   http://www.mnot.net/\n
    \  David Orchard\n   Salesforce.com\n   EMail: orchard@pacificspirit.com\n   URI:
    \  http://www.pacificspirit.com/\n"
  title: Authors' Addresses
