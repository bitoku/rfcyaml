- title: __initial_text__
  contents:
  - '   A Framework for Session Initiation Protocol (SIP) Session Policies

    '
- title: Abstract
  contents:
  - "Abstract\n   Proxy servers play a central role as an intermediary in the Session\n\
    \   Initiation Protocol (SIP) as they define and impact policies on call\n   routing,\
    \ rendezvous, and other call features.  This document\n   specifies a framework\
    \ for SIP session policies that provides a\n   standard mechanism by which a proxy\
    \ can define or influence policies\n   on sessions, such as the codecs or media\
    \ types to be used.  It\n   defines a model, an overall architecture and new protocol\
    \ mechanisms\n   for session policies.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6794.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Terminology .....................................................5\n  \
    \ 3. Session-Independent Policies ....................................5\n    \
    \  3.1. Architecture and Overview ..................................5\n      3.2.\
    \ Policy Subscription ........................................6\n           3.2.1.\
    \ User Agent Client (UAC) Behavior ....................6\n           3.2.2. User\
    \ Agent Server (UAS) Behavior ....................8\n   4. Session-Specific Policies\
    \ .......................................8\n      4.1. Architecture ...............................................8\n\
    \      4.2. Overview ...................................................9\n  \
    \    4.3. Examples ..................................................11\n    \
    \       4.3.1. Offer in Request ...................................11\n      \
    \     4.3.2. Offer in Response ..................................13\n      4.4.\
    \ UA/Policy Server Rendezvous ...............................15\n           4.4.1.\
    \ UAC Behavior .......................................15\n           4.4.2. Proxy\
    \ Behavior .....................................17\n           4.4.3. UAS Behavior\
    \ .......................................20\n           4.4.4. Caching the Local\
    \ Policy Server URI ................21\n           4.4.5. Header Field Definition\
    \ and Syntax .................22\n      4.5. Policy Channel ............................................23\n\
    \           4.5.1. Creation and Management ............................24\n  \
    \         4.5.2. Contacting the Policy Server .......................25\n    \
    \       4.5.3. Using Session Policies .............................26\n   5. Security\
    \ Considerations ........................................27\n   6. IANA Considerations\
    \ ............................................29\n      6.1. Registration of the\
    \ \"Policy-ID\" Header Field ..............29\n      6.2. Registration of the\
    \ \"Policy-Contact\" Header Field .........29\n      6.3. Registration of the\
    \ \"non-cacheable\" Policy-Contact\n           Header Field Parameter ....................................29\n\
    \      6.4. Registration of the \"policy\" SIP Option Tag ...............29\n\
    \   7. References .....................................................30\n  \
    \    7.1. Normative References ......................................30\n    \
    \  7.2. Informative References ....................................31\n   Appendix\
    \ A. Acknowledgements ......................................32\n   Appendix B.\
    \ Session-Specific Policies - Call Flows ................32\n      B.1. Offer\
    \ in Invite ...........................................32\n      B.2. Offer in\
    \ Response .........................................34\n      B.3. Multiple Policy\
    \ Servers for the UAS .......................35\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Session Initiation Protocol (SIP) [RFC3261] is a signaling\n\
    \   protocol for creating, modifying and terminating multimedia sessions.\n  \
    \ A central element in SIP is the proxy server.  Proxy servers are\n   intermediaries\
    \ that are responsible for request routing, rendezvous,\n   authentication and\
    \ authorization, mobility, and other signaling\n   services.  However, proxies\
    \ are divorced from the actual sessions --\n   audio, video, and session-mode\
    \ messaging -- that SIP establishes.\n   Details of the sessions are carried in\
    \ the payload of SIP messages,\n   and are usually described with the Session\
    \ Description Protocol (SDP)\n   [RFC4566].\n   Experience has shown that there\
    \ is a need for SIP intermediaries to\n   impact aspects of a session.  For example,\
    \ SIP can be used in a\n   wireless network, which has limited resources for media\
    \ traffic.\n   During periods of high activity, the wireless network provider\
    \ could\n   want to restrict the amount of bandwidth available to each user.\n\
    \   With session policies, an intermediary in the wireless network can\n   inform\
    \ the user agent (UA) about the bandwidth it has available.\n   This information\
    \ enables the user agent to make an informed decision\n   about the number of\
    \ streams, the media types, and the codecs it can\n   successfully use in a session.\
    \  Similarly, a network provider can\n   have a service level agreement with a\
    \ user that defines the set of\n   media types the user can use.  With session\
    \ policies, the network can\n   convey the current set of policies to user agents,\
    \ enabling them to\n   set up sessions without inadvertently violating any of\
    \ the network\n   policies.\n   In another example, a SIP user agent is using\
    \ a network that is\n   connected to the public Internet through a firewall or\
    \ a network\n   border device.  The network provider would like to tell the user\n\
    \   agent that it needs to send its media streams to a specific IP\n   address\
    \ and port on the firewall or border device to reach the public\n   Internet.\
    \  Knowing this policy enables the user agent to set up\n   sessions across the\
    \ firewall or the network border.  In contrast to\n   other methods for inserting\
    \ a media intermediary, the use of session\n   policies does not require the inspection\
    \ or modification of SIP\n   message bodies.\n   Domains often have the need to\
    \ enforce the session policies they have\n   in place.  For example, a domain\
    \ might have a policy that disallows\n   the use of video and can have an enforcement\
    \ mechanism that drops all\n   packets containing a video encoding.  Unfortunately,\
    \ these\n   enforcement mechanisms usually do not inform the user about the\n\
    \   policies they are enforcing.  Instead, they silently keep the user\n   from\
    \ doing anything against them.  This can lead to a malfunctioning\n   of devices\
    \ that is incomprehensible to the user.  With session\n   policies, the user knows\
    \ about the current network policies and can\n   set up policy-compliant sessions\
    \ or simply connect to a domain with\n   less stringent policies.  Thus, session\
    \ policies provide an important\n   combination of consent coupled with enforcement.\
    \  That is, the user\n   becomes aware of the policy and needs to act on it, but\
    \ the provider\n   still retains the right to enforce the policy.\n   Two types\
    \ of session policies exist: session-specific policies and\n   session-independent\
    \ policies.  Session-specific policies are policies\n   that are created for one\
    \ particular session, based on the session\n   description of that session.  They\
    \ enable a network intermediary to\n   examine the session description a UA is\
    \ proposing and to return a\n   policy specifically for that session description.\
    \  For example, an\n   intermediary could open pinholes in a firewall/NAT for\
    \ each media\n   stream in the proposed session description.  It can then return\
    \ a\n   policy for the session description that replaces the IP addresses and\n\
    \   ports of the UA with the ones opened in the firewall/NAT that are\n   reachable\
    \ from the exterior.  Session-specific policies provide\n   information about\
    \ a specific session to a domain, which can be used\n   to implement policies\
    \ for opening pinholes on a firewall/NAT.  Since\n   session-specific policies\
    \ are tailored to a session, they only apply\n   to the session for which they\
    \ are created.  Session-specific policies\n   are created on a session-by-session\
    \ basis at the time the session is\n   established.\n   Session-independent policies,\
    \ on the other hand, are policies that\n   are created independent of a session\
    \ and generally apply to all SIP\n   sessions set up by a user agent.  A session-independent\
    \ policy can,\n   for example, be used to inform user agents about an existing\n\
    \   bandwidth limit or media type restrictions.  Since these policies are\n  \
    \ not based on a specific session description, they can be created\n   independent\
    \ of an attempt to set up a session and only need to be\n   conveyed to the user\
    \ agent when it initializes (e.g., at the time the\n   device is powered on) and\
    \ when policies are changed.\n   This specification defines a framework for SIP\
    \ session policies.  It\n   specifies a model, the overall architecture and new\
    \ protocol\n   mechanisms that are needed for session-independent and session-\n\
    \   specific policies.  Since session-specific and session-independent\n   policies\
    \ have different requirements, this specification defines two\n   different mechanisms\
    \ to deliver them to user agents.  These\n   mechanisms are independent of each\
    \ other, and, depending on whether\n   one or both types of session policies are\
    \ needed, it is possible to\n   use the session-specific or the session-independent\
    \ mechanism or both\n   to deliver policies to user agents.\n   It is RECOMMENDED\
    \ that UAs and intermediaries use the mechanisms\n   defined in this specification\
    \ for signaling session policies to\n   endpoints.  To ensure backwards compatibility\
    \ with UAs that do not\n   support this specification, intermediaries may choose\
    \ to resort to\n   existing mechanisms such as rejecting sessions that are not\
    \ policy\n   compliant with a 488 response as a fallback solution if a UA does\
    \ not\n   indicate support for session policies.  UAs that do not support\n  \
    \ session policies will receive the same user experience as they would\n   today.\
    \  As these techniques are known to have many drawbacks, it is\n   RECOMMENDED\
    \ that UAs and intermediaries use explicit signaling of\n   policies using the\
    \ mechanisms defined in this specification.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
- title: 3.  Session-Independent Policies
  contents:
  - "3.  Session-Independent Policies\n   Session-independent policies are policies\
    \ that are created\n   independent of a session and generally apply to all sessions\
    \ a user\n   agent is setting up.  They typically remain stable for a longer\n\
    \   period of time and apply to any session set up while they are valid.\n   However,\
    \ it is possible for session-independent policies to change\n   over time.  For\
    \ example, a policy that defines a bandwidth limit for\n   a user can change during\
    \ the day, defining a lower limit during peak\n   hours and allow more bandwidth\
    \ off-peak.  The policy server informs a\n   UA when session-independent policies\
    \ change.\n"
- title: 3.1.  Architecture and Overview
  contents:
  - "3.1.  Architecture and Overview\n                        +-------------+\n  \
    \               /------|   policy    |\n      +----+    /       |  server 1  \
    \ |\n      |    |---/        +-------------+\n      | UA |                 ...\n\
    \      |    |---\\        +-------------+\n      +----+    \\       |   policy\
    \    |\n                 \\------|  server n   |\n                        +-------------+\n\
    \                                 Figure 1\n   A SIP UA can receive session-independent\
    \ policies from one or more\n   policy servers.  In a typical configuration, a\
    \ UA receives session-\n   independent policies from a policy server in the local\
    \ network domain\n   (i.e., the domain from which the UA receives IP service)\
    \ and possibly\n   the SIP service provider domain (i.e., the domain at which\
    \ the UA\n   registers).  The local network can have policies that support the\n\
    \   access network infrastructure.  For example, in a wireless network\n   where\
    \ bandwidth is scarce, a provider can restrict the bandwidth\n   available to\
    \ an individual user.  The SIP service provider can have\n   policies that are\
    \ needed to support services or policies that reflect\n   the service level agreement\
    \ with the user.  Thus, in most cases, a UA\n   will receive session-independent\
    \ policies from one or two policy\n   servers.\n   Setting up session-independent\
    \ policies involves the following steps:\n   1.  A user agent discovers session-independent\
    \ policy servers in the\n       local network and SIP service provider domain.\n\
    \   2.  A user agent requests session-independent policies from the\n       discovered\
    \ policy servers.  A user agent typically requests these\n       policies when\
    \ it starts up or connects to a new network domain.\n   3.  The policy server\
    \ selects the policies that apply to this user\n       agent.  The policy server\
    \ can have general policies that apply to\n       all users or maintain separate\
    \ policies for each individual user.\n       The selected policies are returned\
    \ to the user agent.\n   4.  The policy server can update the policies, for example,\
    \ when\n       network conditions change.\n"
- title: 3.2.  Policy Subscription
  contents:
  - '3.2.  Policy Subscription

    '
- title: 3.2.1.  User Agent Client (UAC) Behavior
  contents:
  - "3.2.1.  User Agent Client (UAC) Behavior\n   A UA that supports session-independent\
    \ policies compliant to this\n   specification MUST attempt to retrieve session-independent\
    \ policies\n   from the local network and the SIP service provider domain, unless\n\
    \   the UA knows (e.g., through configuration) that a domain does not\n   provide\
    \ session-independent policies (in which case the UA SHOULD NOT\n   retrieve session-independent\
    \ policies from this specific domain).\n   A UA that supports session-independent\
    \ policies compliant to this\n   specification MUST support the retrieval of session-independent\n\
    \   policies from the local network and the SIP service provider domain\n   using\
    \ the \"ua-profile\" event package defined in \"A Framework for\n   Session Initiation\
    \ Protocol User Agent Profile Delivery\" [RFC6080].\n   The UA MAY support other\
    \ methods of retrieving session-independent\n   policies from the local network\
    \ and the SIP service provider domains.\n   The \"ua-profile\" event package [RFC6080]\
    \ provides a mechanism to\n   subscribe to session-independent policies.  A UA\
    \ subscribes to the\n   policy server in the local network domain using the procedures\n\
    \   defined for the \"local-network\" profile-type.  The UA uses the\n   procedures\
    \ defined for the \"user\" profile type to subscribe to the\n   policy server\
    \ in the SIP service provider domain.\n   A UA (re-)subscribes to session-independent\
    \ policies when the\n   following events occur:\n   o  The UA registers a new\
    \ address-of-record (AoR) or removes an AoR\n      from the set of AoRs it has\
    \ registered.  In these cases, the UA\n      MUST establish subscriptions for\
    \ each new AoR using the \"user\" and\n      the \"local-network\" profile-types.\
    \  The UA MUST terminate all\n      subscriptions for AoRs it has removed.\n \
    \  o  The UA changes the domain to which it is connected.  The UA MUST\n     \
    \ terminate all existing subscriptions for the \"local-network\"\n      profile-type.\
    \  The UA MUST then create a new subscription for each\n      AoR it maintains\
    \ using the \"local-network\" profile-type.  This\n      way, the UA stops receiving\
    \ policies from the previous local\n      domain and starts to receive the policies\
    \ of the new local domain.\n      The UA does not need to change the subscriptions\
    \ for \"user\"\n      profiles.\n   If a UA is unable to establish a subscription,\
    \ the UA SHOULD NOT\n   attempt to retry this subscription, unless one of the\
    \ above events\n   occurs again.  This is to limit the number of SUBSCRIBE requests\
    \ sent\n   within domains that do not support session-independent policies.\n\
    \   However, a UA SHOULD retry the subscription with a longer time\n   interval\
    \ (e.g., once every 24 hours).  This enables UAs to detect new\n   policies that\
    \ are deployed in a network that previously did not have\n   policies.\n   A UA\
    \ that supports session-independent policies compliant to this\n   specification\
    \ MUST support the User Agent Profile Data Set for Media\n   Policy [RFC6796].\
    \  To indicate that the UA wants to receive session-\n   independent policies,\
    \ the UA includes the MIME type \"application/\n   media-policy-dataset+xml\"\
    \ in the Accept header field of a SUBSCRIBE\n   request.\n   A UA MUST apply the\
    \ session-independent policies it has received and\n   use these policies in the\
    \ session descriptions it creates.  If the UA\n   decides not to use the received\
    \ policies, then the UA MUST NOT set up\n   a session unless it changes the domain\
    \ that provided these policies.\n   A UA MAY try to connect to another local network\
    \ and/or SIP service\n   provider domain with a different set of policies.\n \
    \  If a UA receives both session-independent and session-specific\n   policies,\
    \ the UA MUST apply the session-independent policies to the\n   session description\
    \ before the session description is sent to the\n   session-specific policy server\
    \ (see Section 4).  Thus, session-\n   independent policies are always applied\
    \ before session-specific\n   policies are retrieved.\n"
- title: 3.2.2.  User Agent Server (UAS) Behavior
  contents:
  - "3.2.2.  User Agent Server (UAS) Behavior\n   A policy server MAY send a notification\
    \ to the UA every time the\n   session-independent policies covered by the subscription\
    \ change.  The\n   definition of what causes a policy to change is at the discretion\
    \ of\n   the administrator.  A change in the policy can be triggered, for\n  \
    \ example, by a change in the network status, by the change in the time\n   of\
    \ day or by an update of the service level agreement with the\n   customer.\n"
- title: 4.  Session-Specific Policies
  contents:
  - "4.  Session-Specific Policies\n   Session-specific policies are policies that\
    \ are created specifically\n   for one particular session of a UA.  Thus, session-specific\
    \ policies\n   will typically be different for different sessions.  The session-\n\
    \   specific policies for a session can change during the course of the\n   session.\
    \  For example, a user can run out of credit during a session,\n   which will\
    \ cause the network to disallow the transmission all media\n   streams from this\
    \ point on.\n"
- title: 4.1.  Architecture
  contents:
  - "4.1.  Architecture\n                           domain 1\n                   \
    \     +-----------+\n                 /------|   proxy   |----...\n      +----+\
    \    /       +-----------+\n      |    |---/        +-----------+\n      |   \
    \ |            |  policy   |\n      | UA |============|  server   |\n      | \
    \   |            +-----------+\n      |    |****        +-----------+\n      +----+\
    \    *       |  policy   |\n                 *******|enforcement|****...\n   \
    \                     +-----------+\n      --- SIP Signaling\n      === Policy\
    \ Channel\n      *** Media\n                                 Figure 2\n   The\
    \ following entities are needed for session-specific policies (see\n   Figure\
    \ 2): a user agent (UA), a proxy, a policy server, and possibly\n   a policy enforcement\
    \ entity.\n   The role of the proxy is to provide a rendezvous mechanism for UAs\n\
    \   and policy servers.  It ensures that each UA has the URI [RFC3986] of\n  \
    \ the policy server in its domain and knows from where to retrieve\n   policies.\
    \  The proxy conveys the policy server URI to UAs in case\n   they have not yet\
    \ received it (e.g., in a previous call or through\n   configuration).  The proxy\
    \ does not deliver the actual policies to\n   UAs.\n   The policy server is a\
    \ separate logical entity that can be physically\n   co-located with the proxy.\
    \  The role of the policy server is to\n   deliver session policies to UAs.  The\
    \ policy server receives session\n   information from the UA, uses this information\
    \ to determine the\n   policies that apply to the session, and returns these policies\
    \ to the\n   UA.  The mechanism for generating policies (i.e., making policy\n\
    \   decisions) is outside of the scope of this specification.  A policy\n   server\
    \ can, for example, query an external entity to get policies or\n   it can directly\
    \ incorporate a policy decision point and generate\n   policies locally.\n   A\
    \ UA receives the URI of a policy server from a proxy.  It uses this\n   URI to\
    \ contact the policy server.  It provides information about the\n   current session\
    \ to the policy server and receives session policies in\n   response.  The UA\
    \ can also receive policy updates from the policy\n   server during the course\
    \ of a session.\n   A network can have a policy enforcement infrastructure in\
    \ place.\n   However, this specification does not make any assumptions about the\n\
    \   enforcement of session policies and the mechanisms defined here are\n   orthogonal\
    \ to a policy enforcement infrastructure.\n   In principle, each domain that is\
    \ traversed by SIP signaling messages\n   can define session-specific policies\
    \ for a session.  Each domain\n   needs to run a policy server and a proxy that\
    \ is able to rendezvous a\n   UA with the policy server (as shown in Figure 2).\
    \  However, it is\n   expected that session-specific policies will often only\
    \ be provided\n   by the local domain of the user agent.\n"
- title: 4.2.  Overview
  contents:
  - "4.2.  Overview\n   The protocol defined in this specification clearly separates\
    \ SIP\n   signaling and the exchange of policies.  SIP signaling is only used\n\
    \   to rendezvous the UA with the policy server.  From this point on, UA\n   and\
    \ policy server communicate directly with each other over a\n   separate policy\
    \ channel.  This is opposed to a piggyback model, where\n   the exchange of policy\
    \ information between endpoint and a policy\n   server in the network is piggybacked\
    \ onto the SIP signaling messages\n   that are exchanged between endpoints.\n\
    \   The main advantage of using a separate policy channel is that it\n   decouples\
    \ signaling between endpoints from the policy exchange\n   between an endpoint\
    \ and a policy server.  This decoupling has a\n   number of desirable properties.\
    \  It enables the use of separate\n   encryption mechanisms on the signaling path,\
    \ to secure the\n   communication between endpoints, and on the policy channel,\
    \ to secure\n   the communication between endpoint and policy server.  Policies\
    \ can\n   be submitted directly from the policy server to the endpoint.  They\n\
    \   do not travel along the signaling path, which can potentially cross\n   many\
    \ domains.  Endpoints set up a separate policy channel to each\n   policy server\
    \ and can disclose the information requested by the\n   specific policy server\
    \ (e.g., offer or offer/answer).  Finally,\n   policy servers do not need to rely\
    \ on a SIP signaling message flowing\n   by to send policies or policy updates\
    \ to an endpoint.  A policy\n   server can use the policy channel at any time\
    \ to update session\n   policies as needed.  A disadvantage of the separate channel\
    \ model is\n   that it requires additional messages for the exchange of policy\n\
    \   information.\n   Following this model, signaling for session-specific policies\n\
    \   involves the following two fundamental tasks:\n   1.  UA/policy server rendezvous:\
    \ a UA setting up a session needs to\n       be able to discover the policy servers\
    \ that are relevant to this\n       session.\n   2.  Policy channel: once the\
    \ UA has discovered the relevant policy\n       servers for a session, it needs\
    \ to connect to these servers,\n       disclose session information, and retrieve\
    \ the policies that\n       apply to this session.\n   The communication between\
    \ UA and policy server on the policy channel\n   involves the following steps:\n\
    \   1.  A user agent submits information about the session it is trying\n    \
    \   to establish to the policy server and asks whether a session\n       using\
    \ these parameters is permissible.\n   2.  The policy server generates a policy\
    \ decision for this session\n       and returns the decision to the user agent.\
    \  Possible policy\n       decisions are (1) to deny the session, (2) to propose\
    \ changes to\n       the session parameters with which the session would be\n\
    \       acceptable, or (3) to accept the session as it was proposed.\n   3.  The\
    \ policy server can update the policy decision at a later time.\n       A policy\
    \ decision update can, for example, propose additional\n       changes to the\
    \ session (e.g., change the available bandwidth) or\n       deny a previously\
    \ accepted session (i.e., disallow the\n       continuation of a session).\n \
    \  In many cases, the mechanism for session-specific policies will be\n   used\
    \ to disclose session information and return session policies.\n   However, some\
    \ scenarios only involve the disclosure of session\n   information to a network\
    \ intermediary.  If an intermediary does not\n   intend to return a policy, it\
    \ can simply accept the session as it was\n   proposed.  Similarly, some session-specific\
    \ policies only apply to\n   the offer (and therefore only require the disclosure\
    \ of the offer)\n   whereas others apply to offer and answer.  Both types of policies\
    \ are\n   supported by session-specific policy mechanism.\n"
- title: 4.3.  Examples
  contents:
  - "4.3.  Examples\n   This section provides two examples to illustrate the overall\n\
    \   operation of session-specific policies.  The call flows depict the\n   rendezvous\
    \ mechanism between UA and policy server and indicate the\n   points at which\
    \ the UA exchanges policy information with the policy\n   server.\n   The example\
    \ is based on the following scenario: there are two domains\n   (domain A and\
    \ domain B), which both have session-specific policies\n   for the UAs in their\
    \ domain.  Neither domain provides policies to the\n   UAs outside of their own\
    \ domain.  The two domains have a proxy (Proxy\n   A and Proxy B) and a policy\
    \ server (PS A and PS B).  The policies in\n   both domains involve the session\
    \ description offer and answer.\n"
- title: 4.3.1.  Offer in Request
  contents:
  - "4.3.1.  Offer in Request\n   The first call flow shown in Figure 3 depicts an\
    \ INVITE transaction\n   with the offer in the request.  It is assumed that this\
    \ is the first\n   INVITE request the UAC creates in this domain and that it therefore\n\
    \   does not have previous knowledge about the policy server URIs in this\n  \
    \ domain.\n   (1) UA A sends an INVITE request to Proxy A.  Proxy A knows that\n\
    \   policies apply to this session and (2) returns a 488 (Not Acceptable\n   Here)\
    \ response to UA A.  Proxy A includes the URI of PS A in the 488\n   (Not Acceptable\
    \ Here) response.  This step is needed since the UAC\n   has no prior knowledge\
    \ about the URI of PS A. (3) UA A uses the URI\n   to contact PS A, discloses\
    \ the session description offer to PS A, and\n   (4) receives policies for the\
    \ offer. (5) UA A reformulates the INVITE\n   request under consideration of the\
    \ received policies and includes a\n   Policy-ID header field to indicate that\
    \ it has already contacted PS\n   A.  Proxy A does not reject the INVITE request\
    \ this time and removes\n   the Policy-ID header field when forwarding the INVITE\
    \ request.  Proxy\n   B adds a Policy-Contact header field containing the URI\
    \ of PS B. (6)\n   UA B uses this URI to contact PS B and disclose the offer and\
    \ the\n   answer it is about to send. (7) UA B receives policies from PS B and\n\
    \   applies them to the offer and answer, respectively. (8) UA B returns\n   the\
    \ updated answer in the 200 (OK) response. (9) UA A contacts PS A\n   again with\
    \ the current offer and answer and (10) retrieves the\n   policies for both from\
    \ PS A.\n    UA A           Proxy A           Proxy B             UA B\n     |\
    \                 |                |                 |\n     | INVITE offer  \
    \  |                |                 |\n     |---------------->|            \
    \    |                 | (1)\n     | 488             |                |      \
    \           |\n     | + Policy-Contact|                |                 |\n \
    \    |<----------------|                |                 | (2)\n     | ACK  \
    \           |                |                 |\n     |---------------->|   \
    \             |                 |\n     |                 | PS A           | \
    \                |\n     |                    |             |                \
    \ |\n     | PolicyChannel      |             |                 |\n     | + InfoOffer\
    \        |             |                 |\n     |------------------->|      \
    \       |                 | (3)\n     | PolicyChannel      |             |   \
    \              |\n     | + PolicyOffer      |             |                 |\n\
    \     |<-------------------|             |                 | (4)\n     |     \
    \               |             |                 |\n     |                 |  \
    \              |                 |\n     | INVITE offer'   | INVITE offer'  |\
    \ INVITE offer'   |\n     | + Policy-ID     |                | + Policy-Contact|\n\
    \     |---------------->|--------------->|---------------->| (5)\n     |     \
    \            |                |                 |\n     |                 |  \
    \         PS B |                 |\n     |                 |             |   \
    \                 |\n     |                 |             | PolicyChannel    \
    \  |\n     |                 |             | + InfoOffer'       |\n     |    \
    \             |             | + InfoAnswer       |\n     |                 | \
    \            |<-------------------| (6)\n     |                 |            \
    \ | PolicyChannel      |\n     |                 |             | + PolicyOffer\
    \      |\n     |                 |             | + PolicyAnswer     |\n     |\
    \                 |             |------------------->| (7)\n     |           \
    \      |             |                    |\n     |                 |        \
    \        |                 |\n     | OK answer'      | OK answer'     | OK answer'\
    \      |\n     |<----------------|<---------------|<----------------| (8)\n  \
    \   | ACK                                                |\n     |--------------------------------------------------->|\n\
    \     |                 |                |                 |\n     |         \
    \           |             |                 |\n     | PolicyChannel      |   \
    \          |                 |\n     | + InfoOffer'       |             |    \
    \             |\n     | + InfoAnswer'      |             |                 |\n\
    \     |------------------->|             |                 | (9)\n     | PolicyChannel\
    \      |             |                 |\n     | + PolicyOffer      |        \
    \     |                 |\n     | + PolicyAnswer     |             |         \
    \        |\n     |<-------------------|             |                 | (10)\n\
    \     |                    |             |                 |\n               \
    \                  Figure 3\n"
- title: 4.3.2.  Offer in Response
  contents:
  - "4.3.2.  Offer in Response\n   The call flow shown in Figure 4 depicts an INVITE\
    \ transaction with\n   the offer in the response.\n   (1) UA A sends an INVITE\
    \ request without an offer to Proxy A and (2)\n   Proxy A returns a 488 (Not Acceptable\
    \ Here) response containing the\n   URI of PS A.  (3),(4) UA A uses this policy\
    \ server URI to set up the\n   policy channel.  At this time, UA A does not disclose\
    \ a session\n   description since it does not have the offer yet. (5) UA A re-sends\n\
    \   the INVITE request and includes a Policy-ID header field to indicate\n   that\
    \ it has contacted PS A.  Proxy A does not reject the INVITE\n   request this\
    \ time and removes the Policy-ID header field when\n   forwarding the INVITE request.\
    \  Proxy B adds a Policy-Contact header\n   field containing the URI of PS B.\
    \ (6) UA B uses this URI to discloses\n   the offer to PS B. (7) UA B receives\
    \ policies from PS B and applies\n   them to the offer. (8) UA B returns the updated\
    \ offer the 200 (OK)\n   response. (9),(10) UA A contacts PS and discloses the\
    \ offer and the\n   answer it is about to send.  An important difference to the\
    \ flow in\n   the previous example is that UA A performs steps (9) and (10) before\n\
    \   returning the answer in step (11).  This enables UA A to return the\n   final\
    \ answer in the ACK request, which includes all applicable\n   policies.  However,\
    \ it requires that PS A immediately returns a\n   policy to avoid a delay in the\
    \ transmission of the ACK request.\n   (12),(13) UA B again sends the current\
    \ offer and answer to PS B and\n   applies the policies it receives to both before\
    \ using them.\n    UA A           Proxy A            Proxy B            UA B\n\
    \     |                 |                |                 |\n     | INVITE  \
    \        |                |                 |\n     |---------------->|      \
    \          |                 | (1)\n     | 488             |                |\
    \                 |\n     | + Policy-Contact|                |               \
    \  |\n     |<----------------|                |                 | (2)\n     |\
    \ ACK             |                |                 |\n     |---------------->|\
    \                |                 |\n     |                 | PS A          \
    \ |                 |\n     |                    |             |             \
    \    |\n     | PolicyChannel      |             |                 |\n     |------------------->|\
    \             |                 | (3)\n     | PolicyChannel      |           \
    \  |                 |\n     |<-------------------|             |            \
    \     | (4)\n     |                    |             |                 |\n   \
    \  |                 |                |                 |\n     | INVITE     \
    \     | INVITE         | INVITE          |\n     | + Policy-ID     |         \
    \       | + Policy-Contact|\n     |---------------->|--------------->|---------------->|\
    \ (5)\n     |                 |                |                 |\n     |   \
    \              |           PS B |                 |\n     |                 |\
    \             |                    |\n     |                 |             | PolicyChannel\
    \      |\n     |                 |             | + InfoOffer        |\n     |\
    \                 |             |<-------------------| (6)\n     |           \
    \      |             | PolicyChannel      |\n     |                 |        \
    \     | + PolicyOffer      |\n     |                 |             |------------------->|\
    \ (7)\n     |                 |             |                    |\n     |   \
    \              |                |                 |\n     | OK offer'       |\
    \ OK offer'      | OK offer'       |\n     |<----------------|<---------------|<----------------|\
    \ (8)\n     |                 |                |                 |\n     |   \
    \                 |             |                 |\n     | PolicyChannel    \
    \  |             |                 |\n     | + InfoOffer'       |            \
    \ |                 |\n     | + InfoAnswer       |             |             \
    \    |\n     |------------------->|             |                 | (9)\n    \
    \ | PolicyChannel      |             |                 |\n     | + PolicyOffer\
    \      |             |                 |\n     | + PolicyAnswer     |        \
    \     |                 |\n     |<-------------------|             |         \
    \        | (10)\n     |                    |             |                 |\n\
    \     | ACK answer'                                        |\n     |--------------------------------------------------->|\
    \ (11)\n     |                 |                |                 |\n     |  \
    \               |             |                    |\n     |                 |\
    \             | PolicyChannel      |\n     |                 |             | +\
    \ InfoOffer'       |\n     |                 |             | + InfoAnswer'   \
    \   |\n     |                 |             |<-------------------| (12)\n    \
    \ |                 |             | PolicyChannel      |\n     |             \
    \    |             | + PolicyOffer      |\n     |                 |          \
    \   | + PolicyAnswer     |\n     |                 |             |------------------->|\
    \ (13)\n     |                 |             |                    |\n        \
    \                         Figure 4\n"
- title: 4.4.  UA/Policy Server Rendezvous
  contents:
  - "4.4.  UA/Policy Server Rendezvous\n   The first step in setting up session-specific\
    \ policies is to\n   rendezvous the UAs with the relevant policy servers.  This\
    \ is\n   achieved by providing the URIs of all policy servers relevant for a\n\
    \   session to the UAs.\n"
- title: 4.4.1.  UAC Behavior
  contents:
  - "4.4.1.  UAC Behavior\n   A UAC compliant to this specification MUST include a\
    \ Supported header\n   field with the option tag \"policy\" into all requests\
    \ that can\n   initiate an offer/answer exchange [RFC3264] (e.g., INVITE, UPDATE\n\
    \   [RFC3311], and PRACK [RFC3262] requests).  The UAC MUST include the\n   \"\
    policy\" option tag into these requests even if the particular\n   request does\
    \ not contain an offer or answer (e.g., an INVITE request\n   without an offer).\
    \  A UAC MAY include the \"policy\" option tag into\n   all requests.\n   A UAC\
    \ can receive a 488 (Not Acceptable Here) response that contains\n   a Policy-Contact\
    \ header field.  The Policy-Contact header field is a\n   new header field defined\
    \ in this specification.  It contains one (or\n   multiple alternative) URI(s)\
    \ for a policy server.  A 488 (Not\n   Acceptable Here) response with this header\
    \ field is generated by a\n   proxy to convey a URI of the local policy server\
    \ to the UAC.  After\n   receiving a 488 (Not Acceptable Here) response with a\
    \ Policy-Contact\n   header field, a UAC compliant to this specification needs\
    \ to decide\n   if it wants to continue with the session now knowing that there\
    \ is a\n   policy server.  If the UAC decides to continue, the UAC MUST use one\n\
    \   of the policy server URIs to contact the policy server using the\n   mechanism\
    \ defined in Section 4.5.\n   The Policy-Contact header can contain multiple URIs\
    \ each with a\n   different URI scheme and containing an \"alt-uri\" parameter\
    \ with\n   identical values.  These URIs represent alternative policy channel\n\
    \   mechanisms for obtaining the same policy.  The UAC chooses one of the\n  \
    \ alternative URIs to use to obtain the policy.  The UAC MAY take as a\n   hint\
    \ the order of the alternative URIs as indicating a preference as\n   to which\
    \ URI to use.  The topmost URI in the list might be more\n   preferred by the\
    \ domain of the proxy for use to obtain the policy.\n   After receiving policies\
    \ from the policy server, the UAC decides\n   whether or not it wants to accept\
    \ these policies.  If the UAC accepts\n   these policies, the UAC MUST apply them\
    \ to the current request and\n   re-send the updated request.  If no changes are\
    \ required by policies\n   or no policies have been received, the request can\
    \ be re-sent without\n   any policy-induced changes.  If the UAC decides that\
    \ the list of\n   policy servers or the received session policies are unacceptable,\n\
    \   then the UAC MUST NOT re-send the request.\n   To protect the integrity of\
    \ the policy server URI in a Policy-Contact\n   header field, the UAC SHOULD use\
    \ a secured transport protocol such as\n   Transport Layer Security (TLS) [RFC5246]\
    \ between UAC and proxy.\n   The UAC MUST insert a Policy-ID header field into\
    \ requests for which\n   it has contacted a policy server and accepted the policies\
    \ received.\n   The Policy-ID header field is a new header field that is defined\
    \ in\n   this specification.  The UA MUST create a Policy-ID header field\n  \
    \ value for each policy server it has contacted during the preparation\n   of\
    \ the request.  A Policy-ID header field value contains two pieces\n   of information:\
    \ the policy server URI and an optional token.  The\n   policy server URI is the\
    \ URI the UA has used to contact the policy\n   server.  The token is an opaque\
    \ string the UAC can receive from the\n   policy server.  A token can, for example,\
    \ be contained in the policy\n   document [RFC6796].  If the UAC has received\
    \ a token from the policy\n   server, the UAC MUST include the token in the Policy-ID\
    \ header field.\n   The format of the Policy-ID header field is defined in Section\
    \ 4.4.5.\n   The main purpose of the Policy-ID header field is to enable a proxy\n\
    \   to determine if the UAC already knows a URI of the local policy\n   server.\
    \  If the policy server URI is not yet known to the UAC, the\n   proxy can convey\
    \ this URI to the UAC by rejecting the request with a\n   488 (Not Acceptable\
    \ Here) response.\n   In some cases, a request can traverse multiple domains with\
    \ a\n   session-policy server.  Each of these domains can return a 488 (Not\n\
    \   Acceptable Here) response containing a policy server URI.  A UAC\n   contacts\
    \ a policy server after receiving a 488 (Not Acceptable Here)\n   response from\
    \ a domain and before re-sending the request.  This\n   creates an implicit order\
    \ between the policy servers in multiple\n   domains.  That is, a UAC contacts\
    \ the first policy server, re-sends\n   the modified request, contacts the second\
    \ policy server, re-sends the\n   modified request, and so on.  This way, session\
    \ policies are always\n   applied to a request in the order in which the request\
    \ traverses\n   through the domains.  The UAC MUST NOT change this implicit order\n\
    \   among policy servers.\n   A UAC frequently needs to contact the policy server\
    \ in the local\n   domain before setting up a session.  To avoid the retransmission\
    \ of\n   the local policy server URI in a 488 (Not Acceptable Here) response\n\
    \   for each new request, a UA SHOULD maintain a cache that contains the\n   URI\
    \ of the policy server in the local domain (see Section 4.4.4).\n   The UAC SHOULD\
    \ use the cached policy server URI to contact the local\n   policy server before\
    \ sending a request that initiates the offer/\n   answer exchange for a new session\
    \ (e.g., an INVITE request).  The UAC\n   SHOULD NOT cache a policy server URI\
    \ that is in a different domain\n   than the UAC, even if it is the first policy\
    \ server URI returned.\n   The first policy server URI returned can be from another\
    \ domain if\n   the local domain does not have a policy server.  Note that UACs\n\
    \   perform exact domain comparisons.  That is, foo.example.com and\n   example.com\
    \ are not considered equivalent.\n   UAs can renegotiate the session description\
    \ during a session by\n   initiating a subsequent offer/answer exchange, e.g.,\
    \ in an INVITE,\n   UPDATE, or PRACK request.  When creating such a mid-dialog\
    \ request, a\n   UA SHOULD contact all policy servers to which it has established\
    \ a\n   policy channel during the initial offer/answer exchange (see\n   Section\
    \ 4.5) before sending the request.  This avoids the\n   retransmission of all\
    \ policy server URIs in 488 (Not Acceptable Here)\n   responses for mid-dialog\
    \ requests.\n"
- title: 4.4.2.  Proxy Behavior
  contents:
  - "4.4.2.  Proxy Behavior\n   A proxy provides rendezvous functionalities for UAs\
    \ and policy\n   server.  This is achieved by conveying the URI of a policy server\
    \ to\n   the UAC or the UAS (or both) when processing INVITE, UPDATE, or PRACK\n\
    \   requests (or any other request that can initiate an offer/answer\n   exchange).\n\
    \   If an offer/answer exchange initiating request contains a Supported\n   header\
    \ field with the option tag \"policy\", the proxy MAY reject the\n   request with\
    \ a 488 (Not Acceptable Here) response to provide the\n   local policy server\
    \ URI to the UAC.  Before rejecting a request, the\n   proxy MUST verify that\
    \ the request does not contain a Policy-ID\n   header field with the local policy\
    \ server URI as a value.  If the\n   request does not contain such a header field\
    \ or a local policy server\n   URI is not present in this header field, then the\
    \ proxy MAY reject\n   the request with a 488 (Not Acceptable Here) response.\
    \  The proxy\n   MUST insert a Policy-Contact header field in the 488 (Not Acceptable\n\
    \   Here) response that contains one (or multiple) URI(s) of its\n   associated\
    \ policy server.  The proxy MAY add the header field\n   parameter \"non-cacheable\"\
    \ to prevent the UAC from caching this policy\n   server URI (see Section 4.4.4).\n\
    \   More than one URI for the policy server using different URI schemes\n   MAY\
    \ be provided by the proxy as alternative URIs to contact the\n   policy.  If\
    \ a proxy includes multiple URIs for the same policy, the\n   proxy MUST include\
    \ an \"alt-uri\" parameter for all policy server URIs\n   that are alternatives\
    \ for obtaining the same policy.  The \"alt-uri\"\n   parameter MUST contain either\
    \ the domain name of the domain for which\n   all the alternative policy server\
    \ URIs relate to or a Fully Qualified\n   Domain Name (FQDN) (e.g., the hostname\
    \ of a policy server).  All URIs\n   that are alternatives for the same policy\
    \ MUST have the same value\n   for the \"alt-uri\" parameter.  The value used\
    \ for the \"alt-uri\"\n   parameter MUST be such that the same value will not\
    \ be included with\n   other policy server URIs that a UA needs to contact by\
    \ any other\n   proxy within the same domain or another domain.  A method to create\
    \ a\n   new unique \"alt-uri\" parameter value is to examine the value of\n  \
    \ existing \"alt-uri\" parameters and to make sure that the new value\n   differs.\
    \  A proxy MAY hint to a UA at a preference as to which URI to\n   use by including\
    \ the more preferred URI higher in the list than the\n   other alternative URIs.\
    \  URIs with the same \"alt-uri\" parameter MUST\n   use different URI schemes.\
    \  A SIP or SIPS URI MUST be included even\n   if other URI schemes are defined\
    \ and used in the future.\n   If a local policy server URI is present in a Policy-ID\
    \ header field\n   value of a request, then the proxy MUST NOT reject the request\
    \ as\n   described above (it can still reject the request for other reasons).\n\
    \   The proxy SHOULD remove the Policy-ID header field value of its\n   associated\
    \ policy server from the Policy-ID header field before\n   forwarding the request.\
    \  Not removing the Policy-ID header field\n   value will not cause harm; however,\
    \ the value is not relevant to any\n   other proxy on the path and only increases\
    \ message size.  It also\n   would disclose the policy server URI to subsequent\
    \ proxies.\n   The Policy-ID header field serves two main purposes: first and\
    \ most\n   important, it enables the proxy to determine if a UAC already knows\n\
    \   the URI of the local policy server.  The second purpose of the\n   Policy-ID\
    \ header field is to enable a domain to route all requests\n   that belong to\
    \ the same session (i.e., the initial request and\n   requests a UA retransmits\
    \ after contacting the policy server) to the\n   same proxy and policy server.\
    \  This is important if a domain has\n   multiple proxy/policy server combinations\
    \ (e.g., in a proxy/policy\n   server farm that receives requests through a load\
    \ balancer), which\n   create per-session state in the network.  An example for\
    \ such a\n   scenario is a policy server that is associated with a session border\n\
    \   device.  The policy server configures the session border device after\n  \
    \ receiving a session description from the UAC via the policy channel.\n   Retransmitted\
    \ requests for such a session need to be routed to the\n   same proxy/policy server\
    \ as the initial request since this proxy/\n   policy server combination has configured\
    \ the associated border device\n   for the session.\n   Routing all requests that\
    \ belong to the same session to the same\n   proxy can be achieved by using the\
    \ Policy-ID header field token.  It\n   requires that the policy server return\
    \ a token to the UAC that\n   uniquely identifies the specific proxy/policy server\
    \ combination.\n   The UAC includes this token in the Policy-ID header field,\
    \ and it can\n   be used (together with the policy server URI) by the proxies\
    \ in this\n   domain to route the request along the desired path.  The format\
    \ of\n   this token does not require standardization.  The only requirement is\n\
    \   that the token provide sufficient information for proxies to route\n   the\
    \ message inside a domain to the desired proxy/policy server.  The\n   token can,\
    \ for example, be a numeric identifier or an IP address.\n      Note: it has been\
    \ proposed to use the Policy-ID header field to\n      provide a hint for a proxy\
    \ that the UAC has actually contacted the\n      policy server.  This usage also\
    \ requires the policy server to\n      return a token to the UA.  In addition,\
    \ the policy server needs to\n      share valid tokens with the proxy.  After\
    \ receiving a request with\n      a Policy-ID header field, the proxy can determine\
    \ if the token in\n      the Policy-ID header field is valid.  If it is valid,\
    \ the proxy\n      knows that the UA has contacted the policy server for this\n\
    \      session.  However, this token does not provide any proof that the\n   \
    \   UA has actually used the policies it has received from the policy\n      server.\
    \  A malicious UA can simply contact the policy server,\n      discard all policies\
    \ it receives, and still use the token in the\n      Policy-ID header field.\n\
    \   The proxy MAY insert a Policy-Contact header field into INVITE,\n   UPDATE,\
    \ or PRACK requests (or any other request that can initiate an\n   offer/answer\
    \ exchange) in order to convey the policy server URI to\n   the UAS.  If the request\
    \ already contains a Policy-Contact header\n   field, the proxy MUST insert the\
    \ URI after all existing values at the\n   end of the list.  A proxy MUST NOT\
    \ change the order of existing\n   Policy-Contact header field values.\n   A proxy\
    \ MUST use the Record-Route mechanism [RFC3261] if its\n   associated policy server\
    \ has session policies that apply to mid-\n   dialog requests.  The Record-Route\
    \ header field enables a proxy to\n   stay in the signaling path and resubmit\
    \ the policy server URIs to UAs\n   during mid-dialog requests that initiate an\
    \ offer/answer exchange.\n   Resubmitting the policy server URI to UAs ensures\
    \ that UAs keep\n   contacting the policy server for mid-dialog requests.\n  \
    \ A proxy can find out if the UAS supports this extension by examining\n   the\
    \ Supported header field of responses.  The proxy knows that the\n   UAS supports\
    \ this extension if the Supported header field of a\n   response contains the\
    \ option tag \"policy\".  A proxy can use this\n   information to determine if\
    \ the UAS has understood the Policy-Contact\n   header field it has inserted into\
    \ the request.\n   To protect the integrity of the policy server URI in a Policy-Contact\n\
    \   header field, the proxy SHOULD use a secured transport protocol such\n   as\
    \ TLS [RFC5246] between proxy and UAs.\n"
- title: 4.4.3.  UAS Behavior
  contents:
  - "4.4.3.  UAS Behavior\n   A UAS can receive an INVITE, UPDATE, or PRACK request\
    \ (or another\n   request that can initiate offer/answer exchanges) that contains\
    \ a\n   Policy-Contact header field with a list of policy server URIs.  A UAS\n\
    \   that receives such a request needs to decide if it wants to accept\n   the\
    \ session knowing that there are policy servers involved.  If the\n   Policy-Contact\
    \ header contains multiple URIs, each with a different\n   URI scheme and containing\
    \ an \"alt-uri\" parameter with identical\n   values, these URI schemes represent\
    \ alternative policy channel\n   mechanisms for obtaining the same policy.  If\
    \ the UAS accepts the\n   session, the UAS MUST contact one URI out of each group\
    \ of URIs with\n   identical \"alt-uri\" parameter values to obtain the policy.\
    \  The UAS\n   MAY take as a hint the order of the alternative URIs as indicating\
    \ a\n   preference as to which URI to use.  The topmost URI in the list might\n\
    \   be more preferred by the domain of the proxy for use to obtain the\n   policy.\
    \  The UAS MUST contact all policy server URIs in a Policy-\n   Contact header\
    \ field that are not part of a group of alternative URIs\n   and MUST contact\
    \ one URI in each group of alternative URIs.  The UAS\n   MUST contact these policy\
    \ server URIs in the order in which they were\n   contained in the Policy-Contact\
    \ header field, starting with the\n   topmost value (i.e., the value that was\
    \ inserted first).\n   If a UAS decides that it does not want to accept a session\
    \ because\n   there are policy servers involved or because one of the session\n\
    \   policies received from a policy server is not acceptable, the UAS\n   MUST\
    \ reject the request with a 488 (Not Acceptable Here) response.\n   The UAS MAY\
    \ accept a request and continue with setting up a session\n   if it cannot set\
    \ up a policy channel to the policy server, for\n   example, because the policy\
    \ server is unreachable or returns an error\n   condition that cannot be resolved\
    \ by the UAS (i.e., error conditions\n   other than, for example, a 401 (Unauthorized)\
    \ response).  This is to\n   avoid that the failure of a policy server prevents\
    \ a UA from\n   communicating.  Since this session might not be policy compliant\n\
    \   without the policy subscription, it can be blocked by policy\n   enforcement\
    \ mechanisms if they are in place.\n   A UAS can receive a token from a policy\
    \ server via the policy\n   channel.  Since the UAS does not create a Policy-ID\
    \ header field, it\n   can simply ignore this token.\n   A UAS compliant to this\
    \ specification MUST include a Supported header\n   field with the option tag\
    \ \"policy\" into responses to requests that\n   can initiate an offer/answer\
    \ exchange.  The UAS MAY include this\n   option tag in all responses.  This way,\
    \ a proxy that has inserted the\n   Policy-Contact header field can know that\
    \ the header field was\n   understood by the UAS.\n"
- title: 4.4.4.  Caching the Local Policy Server URI
  contents:
  - "4.4.4.  Caching the Local Policy Server URI\n   A UAC frequently needs to contact\
    \ the policy server in the local\n   domain before setting up a session.  To avoid\
    \ the retransmission of\n   the local policy server URI for each session, a UA\
    \ SHOULD maintain a\n   cache that contains the URI of the local policy server.\n\
    \   A UA can receive this URI in a Policy-Contact header field of a\n   request\
    \ or a 488 (Not Acceptable Here) response.  The UA can also\n   receive the local\
    \ policy server URI through configuration, for\n   example, via the configuration\
    \ framework [RFC6080].  If a UA has\n   received a local policy server URI through\
    \ configuration and receives\n   another local policy server URI in a Policy-Contact\
    \ header field, the\n   UA SHOULD overwrite the configured URI with the most recent\
    \ one\n   received in a Policy-Contact header field.  A policy server URI\n  \
    \ received in a Policy-Contact header field expires if it has not been\n   refreshed\
    \ before it reaches the maximum cached URI validity.  The\n   default maximum\
    \ cached URI validity is 24 hours.\n   Domains can prevent a UA from caching the\
    \ local policy server URI.\n   This is useful, for example, if the policy server\
    \ does not need to be\n   involved in all sessions or the policy server URI changes\
    \ from\n   session to session.  A proxy can mark the URI of such a policy server\n\
    \   as \"non-cacheable\".  A UA MUST NOT cache a non-cacheable policy\n   server\
    \ URI.  The UA SHOULD remove the current URI from the cache when\n   receiving\
    \ a local policy server URI that is marked as \"non-\n   cacheable\".  This is\
    \ to avoid the use of policy server URIs that are\n   outdated.\n   The UA SHOULD\
    \ NOT cache policy server URIs it has received from\n   proxies outside of the\
    \ local domain.  These policy servers need not\n   be relevant for subsequent\
    \ sessions, which can go to a different\n   destination, traversing different\
    \ domains.\n   The UA MUST NOT cache tokens it has received from a policy server.\
    \  A\n   token is only valid for one request.\n"
- title: 4.4.5.  Header Field Definition and Syntax
  contents:
  - '4.4.5.  Header Field Definition and Syntax

    '
- title: 4.4.5.1.  Policy-ID Header Field
  contents:
  - "4.4.5.1.  Policy-ID Header Field\n   The Policy-ID header field is inserted by\
    \ the UAC into INVITE,\n   UPDATE, or PRACK requests (or any other request that\
    \ can be used to\n   initiate an offer/answer exchange).  The Policy-ID header\
    \ field\n   identifies all policy servers the UAC has contacted for this request.\n\
    \   The value of a Policy-ID header field consists of a policy server URI\n  \
    \ and an optional token parameter.  The token parameter contains a\n   token the\
    \ UA might have received from the policy server.\n   The syntax of the Policy-ID\
    \ header field is described below in ABNF,\n   according to [RFC5234], as an extension\
    \ to the ABNF for SIP in\n   [RFC3261]:\n     Policy-ID        = \"Policy-ID\"\
    \ HCOLON policyURI\n                        *(COMMA  policyURI)\n     policyURI\
    \        = ( SIP-URI / SIPS-URI / absoluteURI )\n                        [ SEMI\
    \ token-param ] *( SEMI generic-param )\n     token-param      = \"token=\" token\n"
- title: 4.4.5.2.  Policy-Contact Header Field
  contents:
  - "4.4.5.2.  Policy-Contact Header Field\n   The Policy-Contact header field can\
    \ be inserted by a proxy into a 488\n   (Not Acceptable Here) response to INVITE,\
    \ UPDATE, or PRACK requests\n   (or other requests that initiate an offer/answer\
    \ exchange).  The\n   value of a Policy-Contact header field consists of a policy\
    \ server\n   URI and an optional \"non-cacheable\" header field parameter.  The\n\
    \   policy server URI identifies the policy server that needs to be\n   contacted\
    \ by a UAC.  The \"non-cacheable\" header field parameter\n   indicates that the\
    \ policy server URI is not intended to be cached by\n   the UAC.\n   The Policy-Contact\
    \ header field can also be inserted by a proxy into\n   INVITE, UPDATE, and PRACK\
    \ requests (or other requests that can be\n   used to initiate an offer/answer\
    \ exchange).  It contains an ordered\n   list of policy server URIs that need\
    \ to be contacted by the UAS.  The\n   topmost value of this list identifies the\
    \ policy server that is\n   contacted first.  New header field values are inserted\
    \ at the end.\n   With this, the Policy-Contact header field effectively forms\
    \ a fist-\n   in-first-out queue.\n   The syntax of the Policy-Contact header\
    \ field is described below in\n   ABNF, according to [RFC5234], as an extension\
    \ to the ABNF for SIP in\n   [RFC3261]:\n   Policy-Contact         = \"Policy-Contact\"\
    \ HCOLON policyContact-info\n                            *(COMMA policyContact-info)\n\
    \   policyContact-info     = LAQUOT policyContact-uri RAQUOT\n               \
    \             *( SEMI policyContact-param )\n   policyContact-uri      = ( SIP-URI\
    \ / SIPS-URI / absoluteURI )\n   policyContact-param    = ( \"non-cacheable\"\
    \ / policyContact-alt-uri\n                            / generic-param )\n   policyContact-alt-uri\
    \  = \"alt-uri\" EQUAL hostname\n   Tables 1 and 2 are extensions of Tables 2\
    \ and 3 in [RFC3261].  The\n   column \"INF\" is for the INFO method [RFC6086],\
    \ \"PRA\" is for the PRACK\n   method [RFC3262], \"UPD\" is for the UPDATE method\
    \ [RFC3311], \"SUB\" is\n   for the SUBSCRIBE method [RFC6665], \"NOT\" is for\
    \ the NOTIFY method\n   [RFC6665], \"MSG\" is for the MESSAGE method [RFC3428],\
    \ \"REF\" is for\n   the REFER method [RFC3515], and \"PUB\" is for the PUBLISH\
    \ method\n   [RFC3903].\n     Header field          where   proxy ACK BYE CAN\
    \ INV OPT REG UPD\n     _______________________________________________________________\n\
    \     Policy-ID               R       rd   -   -   -   c   -   -   c\n     Policy-Contact\
    \          R       a    -   -   -   c   -   -   c\n     Policy-Contact       \
    \  488      a    -   -   -   c   -   -   c\n           Table 1: Policy-ID and\
    \ Policy-Contact Header Fields\n     Header field          where   proxy PRA PUB\
    \ SUB NOT INF MSG REF\n     _______________________________________________________________\n\
    \     Policy-ID               R       rd   c   -   -   -   -   -   -\n     Policy-Contact\
    \          R       a    c   -   -   -   -   -   -\n     Policy-Contact       \
    \  488      a    c   -   -   -   -   -   -\n           Table 2: Policy-ID and\
    \ Policy-Contact Header Fields\n"
- title: 4.5.  Policy Channel
  contents:
  - "4.5.  Policy Channel\n   The main task of the policy channel is to enable a UA\
    \ to submit\n   information about the session it is trying to establish (i.e.,\
    \ the\n   offer and the answer) to a policy server and to receive the resulting\n\
    \   session-specific policies and possible updates to these policies in\n   response.\n\
    \   The Event Package for Session-Specific Policies [RFC6795] defines a\n   SUBSCRIBE/NOTIFY-based\
    \ [RFC6665] policy channel mechanism.  A UA\n   compliant to this specification\
    \ MUST support the Event Package for\n   Session-Specific Policies [RFC6795].\
    \  The UA MUST use this event\n   package to contact a policy server if the policy\
    \ server URI is a\n   SIP-URI or SIPS-URI.  A UA MAY support other policy channel\n\
    \   mechanisms.\n"
- title: 4.5.1.  Creation and Management
  contents:
  - "4.5.1.  Creation and Management\n   A UA discovers the list of policy servers\
    \ relevant for a session\n   during the initial offer/answer exchange (see Section\
    \ 4.4).  A UA\n   compliant to this specification MUST set up a policy channel\
    \ to each\n   of the discovered policy servers.  If the UA does not want to set\
    \ up\n   a policy channel to one of the policy servers provided, the UA MUST\n\
    \   cancel or reject a pending INVITE transaction for the session or\n   terminate\
    \ the session if it is already in progress.\n   A UA MUST maintain the policy\
    \ channel to each discovered policy\n   server during the lifetime of a session,\
    \ unless the policy channel is\n   closed by the policy server or the UA discovers\
    \ that the policy\n   server is no longer relevant for the session as described\
    \ below.\n   A UAC can receive a 488 (Not Acceptable Here) response with a Policy-\n\
    \   Contact header field containing a new policy server URI in response\n   to\
    \ a mid-dialog request.  This indicates that the set of policy\n   servers relevant\
    \ for the current session has changed.  If this\n   occurs, the UAC MUST retry\
    \ sending the request as if it were the\n   first request in a dialog (i.e., without\
    \ applying any policies except\n   the policies from the local policy server).\
    \  This way, the UAC will\n   rediscover the list of policy servers for the current\
    \ session.  This\n   is necessary since the UAC has no other way of knowing when\
    \ to\n   contact the newly discovered policy server relative to the existing\n\
    \   policy servers and if any of the existing policy servers do not need\n   to\
    \ be contacted any more.  The UAC MUST set up a policy channel to\n   each new\
    \ policy server.  The UAC SHOULD close policy channels to\n   policy server that\
    \ are not listed any more.  If the policy channel to\n   these servers is not\
    \ closed, the UAC can receive policies that do not\n   apply to the session any\
    \ more.  The UAC MUST contact policy servers\n   in the order in which they were\
    \ discovered in the most recent\n   request.\n   If a UAS receives a mid-dialog\
    \ request with a Policy-Contact header\n   field containing a list of policy server\
    \ URIs that is different from\n   the list of policy servers to which the UAS\
    \ has currently established\n   a policy channel, then the UAS MUST set up a policy\
    \ channel to all\n   new policy servers and contact them.  The UAS SHOULD close\
    \ policy\n   channels to servers that are not listed any more.  If the policy\n\
    \   channel to these servers is not closed, the UAS can receive policies\n   that\
    \ do not apply to the session any more.  The UAS MUST use policy\n   servers in\
    \ the order in which they were contained in the most recent\n   Policy-Contact\
    \ header field.\n   A UA MUST inform the policy server when a session is terminated\n\
    \   (e.g., when the UA has either sent or received a BYE) via the policy\n   channel,\
    \ unless a policy server indicates via the policy channel that\n   it does not\
    \ need to be contacted at the end of the session.  This\n   enables a policy server\
    \ to free all resources it has allocated for\n   this session.\n"
- title: 4.5.2.  Contacting the Policy Server
  contents:
  - "4.5.2.  Contacting the Policy Server\n   A UA MUST contact all policy servers\
    \ to which it has established a\n   policy channel before sending or after receiving\
    \ a mid-dialog\n   request.  The UA MUST contact the policy servers in the order\
    \ in\n   which they were discovered most recently.\n   A UA that receives a SIP\
    \ message containing an offer or answer SHOULD\n   completely process the message\
    \ (e.g., according to [RFC3261]) before\n   contacting the policy server.  The\
    \ SIP processing of the message\n   includes, for example, updating dialog state\
    \ and timers as well as\n   creating ACK or PRACK requests as necessary.  This\
    \ ensures that\n   contacting a policy server does not interfere with SIP message\n\
    \   processing and timing (e.g., by inadvertently causing timers to\n   expire).\
    \  This implies, for example, that a UAC that has received a\n   response to an\
    \ INVITE request would normally finish the processing of\n   the response including\
    \ transmitting the ACK request before it\n   contacts the policy server.  An important\
    \ exception to this rule is\n   discussed in the next paragraph.\n   In some cases,\
    \ a UA needs to use the offer/answer it has received in\n   a SIP message to create\
    \ an ACK or PRACK request for this message;\n   i.e., it needs to use the offer/answer\
    \ before finishing the SIP\n   machinery for this message.  For example, a UAC\
    \ that has received an\n   offer in the response to an INVITE request needs to\
    \ apply policies to\n   the offer and the answer before it can send the answer\
    \ in an ACK\n   request.  In these cases, a UA SHOULD contact the policy server\
    \ even\n   if this is during the processing of a SIP message.  This implies that\n\
    \   a UA, which has received an offer in the response of an INVITE\n   request,\
    \ would normally contact the policy server and apply session\n   policies before\
    \ sending the answer in the ACK request.\n      Note: this assumes that the policy\
    \ server can always respond\n      immediately to a policy request and does not\
    \ require manual\n      intervention to create a policy.  This will be the case\
    \ for most\n      policy servers.  If, however, a policy server cannot respond\
    \ with\n      a policy right away, it can return a policy that temporarily\n \
    \     denies the session and update this policy as the actual policy\n      decision\
    \ becomes available.  A delay in the response from the\n      policy server to\
    \ the UA would delay the transmission of the ACK\n      request and could trigger\
    \ retransmissions of the INVITE response\n      (also see the recommendations\
    \ for Flow I in [RFC3725]).\n   The case of multiple policy servers providing\
    \ policies to the same UA\n   requires additional considerations.  A policy returned\
    \ by one policy\n   server can contain information that needs to be shared with\
    \ the other\n   policy servers.  For example, two policy servers can have the\
    \ policy\n   to insert a media intermediary by modifying the IP addresses and\n\
    \   ports of media streams.  In order for media streams to pass through\n   both\
    \ intermediaries, each intermediary needs to know the IP address\n   and port\
    \ on which the other media intermediary is expecting the\n   stream to arrive.\
    \  If media streams are flowing in both directions,\n   this means that each intermediary\
    \ needs to know IP addresses and\n   ports of the other intermediary.\n   UACs\
    \ usually contact a policy server twice during an offer/answer\n   exchange (unless\
    \ a policy server indicates that it only needs to be\n   contacted once).  Therefore,\
    \ the case of multiple policy servers\n   providing policies to a single UAC does\
    \ not require additional steps\n   in most cases.  However, a UAS usually contacts\
    \ each policy server\n   only once (see Figure 4).  If a session policy returned\
    \ by one of the\n   policy servers requires that information be shared between\
    \ multiple\n   servers and the UAS receives policies from more than one policy\n\
    \   server, then the UAS MUST contact all policy servers a second time\n   after\
    \ contacting all servers the first time.  Whether or not a second\n   round is\
    \ required is determined by the type of information returned\n   by the policy\
    \ server.  A data format for session policies (e.g.,\n   [RFC6796]) needs to explicitly\
    \ state if a second round is needed for\n   a particular data element.  If a UA\
    \ receives such an element, it\n   knows that is expected to contact policy servers\
    \ a second time.  If\n   such a data element is modified during a mid-call offer/answer\n\
    \   exchange and multiple policy servers are providing policies to a UA,\n   then\
    \ all UAs MUST contact policy servers in a first and second round.\n   An example\
    \ call flow is shown in Appendix B.3.\n   A UA that supports session-specific\
    \ policies compliant to this\n   specification MUST support the User Agent Profile\
    \ Data Set for Media\n   Policy [RFC6796] as data format for session policies.\n"
- title: 4.5.3.  Using Session Policies
  contents:
  - "4.5.3.  Using Session Policies\n   A UA MUST disclose the session description(s)\
    \ for the current session\n   to policy servers through the policy channel.  The\
    \ UA MUST apply\n   session policies it receives to the offer and, if one is received,\
    \ to\n   the answer before using the offer/answer.  If these policies are\n  \
    \ unacceptable, the UA MUST NOT continue with the session.  This means\n   that\
    \ the UA MUST cancel or reject a pending INVITE transaction for\n   the session\
    \ or terminate the session if it is already in progress.\n   If the UA receives\
    \ an unacceptable policy in an INVITE response, the\n   UA MUST complete the INVITE\
    \ transaction and then terminate the\n   session.\n   When a UA receives a notification\
    \ about a change in the current\n   policies, the UA MUST apply the updated policies\
    \ to the current\n   session or the UA MUST terminate the session.  If the policy\
    \ update\n   causes a change in the session description of a session, then the\
    \ UA\n   needs to renegotiate the modified session description with its peer\n\
    \   UA, for example, using a re-INVITE or UPDATE request.  For example,\n   if\
    \ a policy update disallows the use of video and video is part of\n   the current\
    \ session description, then the UA will need to create an\n   new session description\
    \ offer without video.  After receiving this\n   offer, the peer UA knows that\
    \ video can't be used any more and\n   responds with the corresponding answer.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   Policy enforcement mechanisms can prevent a UA\
    \ from communicating\n   with another UA if the UAs are not aware of the policies\
    \ that are\n   enforced.  Policy enforcement mechanisms without policy signaling\
    \ can\n   therefore create a denial-of-service condition for UAs.  This\n   specification\
    \ provides a mechanism for intermediaries to signal the\n   policies that are\
    \ enforced to UAs.  It enables UAs to establish\n   sessions that are conform\
    \ and pass through policy enforcement.\n   Session policies can significantly\
    \ change the behavior of a UA and\n   can be used by an attacker to compromise\
    \ a UA.  For example, session\n   policies can be used to prevent a UA from successfully\
    \ establishing a\n   session (e.g., by setting the available bandwidth to zero).\
    \  Such a\n   policy can be submitted to the UA during a session, which causes\
    \ the\n   UA to terminate the session.\n   A UA transmits session information\
    \ to a policy server for session-\n   specific policies.  This session information\
    \ can contain sensitive\n   data the user does not want an eavesdropper or an\
    \ unauthorized policy\n   server to see.  Vice versa, session policies can contain\
    \ sensitive\n   information about the network or service level agreements the\
    \ service\n   provider does not want to disclose to an eavesdropper or an\n  \
    \ unauthorized UA.\n   It is important to secure the communication between the\
    \ proxy and the\n   UA (for session-specific policies) as well as the UA and the\
    \ policy\n   server.  The following four discrete attributes need to be protected:\n\
    \   1.  integrity of the policy server URI (for session-specific\n       policies),\n\
    \   2.  authentication of the policy server and, if needed, the user\n       agent,\n\
    \   3.  confidentiality of the messages exchanged between the user agent\n   \
    \    and the policy server and\n   4.  ensuring that private information is not\
    \ exchanged between the\n       two parties, even over a confidentiality-assured\
    \ and\n       authenticated session.\n   To protect the integrity of the policy\
    \ server URI, a UA SHOULD use a\n   secured transport protocol such as TLS [RFC5246]\
    \ between proxies and\n   the UA.  Protecting the integrity of the policy server\
    \ URI is\n   important since an attacker could intercept SIP messages between\
    \ the\n   UA and the proxy and remove the policy header fields needed for\n  \
    \ session-specific policies.  This would impede the rendezvous between\n   UA\
    \ and policy server and, since the UA would not contact the policy\n   server,\
    \ can prevent a UA from setting up a session.\n   Instead of removing a policy\
    \ server URI, an attacker can also modify\n   the policy server URI and point\
    \ the UA to a compromised policy\n   server.  It is RECOMMENDED that a UA authenticate\
    \ policy servers to\n   prevent such an attack from being effective.\n   It is\
    \ RECOMMENDED that the UA only accept session-independent\n   policies from trustworthy\
    \ policy servers as these policies affect all\n   sessions of a UA.  A list of\
    \ trustworthy session-independent policy\n   servers can be provided to the UA\
    \ through configuration.  As SIP\n   messages can be affected by any proxy on\
    \ a path and session-specific\n   policies only apply to a single session, a UA\
    \ MAY choose to accept\n   session-specific policies from other policy servers\
    \ as well.\n   Policy servers SHOULD authenticate UAs to protect the information\n\
    \   that is contained in a session policy.  However, a policy server can\n   also\
    \ frequently encounter UAs it cannot authenticate.  In these\n   cases, the policy\
    \ server MAY provide a generic policy that does not\n   reveal sensitive information\
    \ to these UAs.\n   It is RECOMMENDED that administrators use SIPS URIs as policy\
    \ server\n   URIs so that subscriptions to session policies are transmitted over\n\
    \   TLS.\n   The above security attributes are important to protect the\n   communication\
    \ between the UA and policy server.  This document does\n   not define the protocol\
    \ used for the communication between UA and\n   policy server and merely refers\
    \ to other specifications for this\n   purpose.  The security considerations of\
    \ these specifications need to\n   address the above security aspects.\n"
- title: 6.  IANA Considerations
  contents:
  - '6.  IANA Considerations

    '
- title: 6.1.  Registration of the "Policy-ID" Header Field
  contents:
  - "6.1.  Registration of the \"Policy-ID\" Header Field\n   Name of Header Field:\
    \ Policy-ID\n   Short form: none\n   Normative description: Section 4.4.5 of this\
    \ document\n"
- title: 6.2.  Registration of the "Policy-Contact" Header Field
  contents:
  - "6.2.  Registration of the \"Policy-Contact\" Header Field\n   Name of Header\
    \ Field: Policy-Contact\n   Short form: none\n   Normative description: Section\
    \ 4.4.5 of this document\n"
- title: 6.3.  Registration of the "non-cacheable" Policy-Contact Header Field
  contents:
  - "6.3.  Registration of the \"non-cacheable\" Policy-Contact Header Field\n   \
    \   Parameter\n   Registry Name: Header Field Parameters and Parameter Values\n\
    \   Reference: [RFC3968]\n   Registry:\n   Header Field               Parameter\
    \ Name   Predefined  Reference\n                                             \
    \    Values\n   _____________________________________________________________________\n\
    \   Policy-Contact             non-cacheable       Yes      this document\n"
- title: 6.4.  Registration of the "policy" SIP Option Tag
  contents:
  - "6.4.  Registration of the \"policy\" SIP Option Tag\n   This specification registers\
    \ a new SIP option tag, as per the\n   guidelines in Section 27.1 of [RFC3261].\n\
    \   This document defines the SIP option tag \"policy\".\n   The following row\
    \ has been added to the \"Option Tags\" section of the\n   SIP Parameter Registry:\n\
    \   +------------+------------------------------------------+-----------+\n  \
    \ | Name       | Description                              | Reference |\n   +------------+------------------------------------------+-----------+\n\
    \   | policy     | This option tag is used to indicate that | this      |\n  \
    \ |            | a UA can process policy server URIs for  | document  |\n   |\
    \            | and subscribe to session-specific        |           |\n   |  \
    \          | policies.                                |           |\n   +------------+------------------------------------------+-----------+\n\
    \      Name of option: policy\n      Description: Support for the Policy-Contact\
    \ and Policy-ID header\n      fields.\n      SIP header fields defined: Policy-Contact,\
    \ Policy-ID\n      Normative description: This document\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n\
    \              A., Peterson, J., Sparks, R., Handley, M., and E.\n           \
    \   Schooler, \"SIP: Session Initiation Protocol\", RFC 3261,\n              June\
    \ 2002.\n   [RFC3262]  Rosenberg, J. and H. Schulzrinne, \"Reliability of\n  \
    \            Provisional Responses in Session Initiation Protocol\n          \
    \    (SIP)\", RFC 3262, June 2002.\n   [RFC3264]  Rosenberg, J. and H. Schulzrinne,\
    \ \"An Offer/Answer Model\n              with Session Description Protocol (SDP)\"\
    , RFC 3264,\n              June 2002.\n   [RFC3311]  Rosenberg, J., \"The Session\
    \ Initiation Protocol (SIP)\n              UPDATE Method\", RFC 3311, October\
    \ 2002.\n   [RFC3968]  Camarillo, G., \"The Internet Assigned Number Authority\n\
    \              (IANA) Header Field Parameter Registry for the Session\n      \
    \        Initiation Protocol (SIP)\", BCP 98, RFC 3968,\n              December\
    \ 2004.\n   [RFC5234]  Crocker, D. and P. Overell, \"Augmented BNF for Syntax\n\
    \              Specifications: ABNF\", STD 68, RFC 5234, January 2008.\n   [RFC6080]\
    \  Petrie, D. and S. Channabasappa, \"A Framework for Session\n              Initiation\
    \ Protocol User Agent Profile Delivery\",\n              RFC 6080, March 2011.\n\
    \   [RFC6665]  Roach, A., \"SIP-Specific Event Notification\", RFC 6665,\n   \
    \           July 2012.\n   [RFC6795]  Hilt, V. and G. Camarillo, \"A Session Initiation\
    \ Protocol\n              (SIP) Event Package for Session-Specific Policies\"\
    ,\n              RFC 6795, December 2012.\n   [RFC6796]  Hilt, V., Camarillo,\
    \ G., Rosenberg, J., and D. Worley, \"A\n              User Agent Profile Data\
    \ Set for Media Policy\", RFC 6796,\n              December 2012.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [RFC3428]  Campbell, B., Rosenberg, J., Schulzrinne,\
    \ H., Huitema, C.,\n              and D. Gurle, \"Session Initiation Protocol\
    \ (SIP) Extension\n              for Instant Messaging\", RFC 3428, December 2002.\n\
    \   [RFC3515]  Sparks, R., \"The Session Initiation Protocol (SIP) Refer\n   \
    \           Method\", RFC 3515, April 2003.\n   [RFC3725]  Rosenberg, J., Peterson,\
    \ J., Schulzrinne, H., and G.\n              Camarillo, \"Best Current Practices\
    \ for Third Party Call\n              Control (3pcc) in the Session Initiation\
    \ Protocol (SIP)\",\n              BCP 85, RFC 3725, April 2004.\n   [RFC3903]\
    \  Niemi, A., \"Session Initiation Protocol (SIP) Extension\n              for\
    \ Event State Publication\", RFC 3903, October 2004.\n   [RFC3986]  Berners-Lee,\
    \ T., Fielding, R., and L. Masinter, \"Uniform\n              Resource Identifier\
    \ (URI): Generic Syntax\", STD 66,\n              RFC 3986, January 2005.\n  \
    \ [RFC4566]  Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session\n     \
    \         Description Protocol\", RFC 4566, July 2006.\n   [RFC5246]  Dierks,\
    \ T. and E. Rescorla, \"The Transport Layer Security\n              (TLS) Protocol\
    \ Version 1.2\", RFC 5246, August 2008.\n   [RFC6086]  Holmberg, C., Burger, E.,\
    \ and H. Kaplan, \"Session\n              Initiation Protocol (SIP) INFO Method\
    \ and Package\n              Framework\", RFC 6086, January 2011.\n"
- title: Appendix A.  Acknowledgements
  contents:
  - "Appendix A.  Acknowledgements\n   Many thanks to Allison Mankin, Andrew Allen,\
    \ Cullen Jennings and\n   Vijay Gurbani for their contributions to this document.\
    \  Many thanks\n   to Roni Even, Bob Penfield, Mary Barnes, Shida Schubert, Keith\
    \ Drage,\n   Lisa Dusseault, Tim Polk and Pasi Eronen for their reviews and\n\
    \   suggestions.\n"
- title: Appendix B.  Session-Specific Policies - Call Flows
  contents:
  - "Appendix B.  Session-Specific Policies - Call Flows\n   The following call flows\
    \ illustrate the overall operation of session-\n   specific policies including\
    \ the policy channel protocol as defined in\n   \"A Session Initiation Protocol\
    \ (SIP) Event Package for Session-\n   Specific Policies\" [RFC6795].\n   The\
    \ following abbreviations are used:\n      o: offer\n      o': offer modified\
    \ by a policy\n      po: offer policy\n      a: answer\n      a': answer modified\
    \ by a policy\n      pa: answer policy\n      ps uri: policy server URI (in Policy-Contact\
    \ header field)\n      ps id: policy server id (in Policy-ID header field)\n"
- title: B.1.  Offer in Invite
  contents:
  - "B.1.  Offer in Invite\n   UA A       P A      PS A      PS B       P B      UA\
    \ B\n     |         |         |         |         |         |\n     |(1) INV <o>\
    \        |         |         |         |\n     |-------->|         |         |\
    \         |         |\n     |(2) 488 <ps uri>   |         |         |        \
    \ |\n     |<--------|         |         |         |         |\n     |(3) ACK \
    \ |         |         |         |         |\n     |-------->|         |      \
    \   |         |         |\n     |(4) SUBSCRIBE <o>  |         |         |    \
    \     |\n     |------------------>|         |         |         |\n     |(5) 200\
    \ OK         |         |         |         |\n     |<------------------|     \
    \    |         |         |\n     |(6) NOTIFY <po>    |         |         |   \
    \      |\n     |<------------------|         |         |         |\n     |(7)\
    \ 200 OK         |         |         |         |\n     |------------------>| \
    \        |         |         |\n     |(8) INV <ps id, o'>|         |         |\
    \         |\n     |-------->|         |         |         |         |\n     |\
    \         |(9) INV <o'>       |         |         |\n     |         |---------------------------->|\
    \         |\n     |         |         |         |         |(10) INV <o', ps uri>\n\
    \     |         |         |         |         |-------->|\n     |         |  \
    \       |         |(11) SUBSCRIBE <o', a>\n     |         |         |        \
    \ |<------------------|\n     |         |         |         |(12) 200 OK     \
    \   |\n     |         |         |         |------------------>|\n     |      \
    \   |         |         |(13) NOTIFY <po, pa>\n     |         |         |    \
    \     |------------------>|\n     |         |         |         |(14) 200 OK \
    \       |\n     |         |         |         |<------------------|\n     |  \
    \       |         |         |         |(15) 200 OK <a'>\n     |         |    \
    \     |         |         |<--------|\n     |         |(16) 200 OK <a'>   |  \
    \       |         |\n     |         |<----------------------------|         |\n\
    \     |(17) 200 OK <a'>   |         |         |         |\n     |<--------|  \
    \       |         |         |         |\n     |(18) ACK |         |         |\
    \         |         |\n     |------------------------------------------------>|\n\
    \     |(19) SUBSCRIBE <o', a'>      |         |         |\n     |------------------>|\
    \         |         |         |\n     |(20) 200 OK        |         |        \
    \ |         |\n     |<------------------|         |         |         |\n    \
    \ |(21) NOTIFY <po, pa>         |         |         |\n     |<------------------|\
    \         |         |         |\n     |(22) 200 OK        |         |        \
    \ |         |\n     |------------------>|         |         |         |\n    \
    \ |         |         |         |         |         |\n     |         |      \
    \   |         |         |         |\n"
- title: B.2.  Offer in Response
  contents:
  - "B.2.  Offer in Response\n   UA A       P A      PS A      PS B       P B    \
    \  UA B\n     |         |         |         |         |         |\n     |(1) INV\
    \  |         |         |         |         |\n     |-------->|         |     \
    \    |         |         |\n     |(2) 488 <ps uri>   |         |         |   \
    \      |\n     |<--------|         |         |         |         |\n     |(3)\
    \ ACK  |         |         |         |         |\n     |-------->|         | \
    \        |         |         |\n     |(4) SUBSCRIBE      |         |         |\
    \         |\n     |------------------>|         |         |         |\n     |(5)\
    \ 200 OK         |         |         |         |\n     |<------------------| \
    \        |         |         |\n     |(6) NOTIFY         |         |         |\
    \         |\n     |<------------------|         |         |         |\n     |(7)\
    \ 200 OK         |         |         |         |\n     |------------------>| \
    \        |         |         |\n     |(8) INV <ps id>    |         |         |\
    \         |\n     |-------->|         |         |         |         |\n     |\
    \         |(9) INV  |         |         |         |\n     |         |---------------------------->|\
    \         |\n     |         |         |         |         |(10) INV <ps uri>\n\
    \     |         |         |         |         |-------->|\n     |         |  \
    \       |         |(11) SUBSCRIBE <o> |\n     |         |         |         |<------------------|\n\
    \     |         |         |         |(12) 200 OK        |\n     |         |  \
    \       |         |------------------>|\n     |         |         |         |(13)\
    \ NOTIFY <po>   |\n     |         |         |         |------------------>|\n\
    \     |         |         |         |(14) 200 OK        |\n     |         |  \
    \       |         |<------------------|\n     |         |         |         |\
    \         |(15) 200 OK <o'>\n     |         |         |         |         |<--------|\n\
    \     |         |(16) 200 OK <o'>   |         |         |\n     |         |<----------------------------|\
    \         |\n     |(17) 200 OK <o'>   |         |         |         |\n     |<--------|\
    \         |         |         |         |\n     |(18) SUBSCRIBE <o', a>      \
    \ |         |         |\n     |------------------>|         |         |      \
    \   |\n     |(19) 200 OK        |         |         |         |\n     |<------------------|\
    \         |         |         |\n     |(20) NOTIFY <po, pa>         |        \
    \ |         |\n     |<------------------|         |         |         |\n    \
    \ |(21) 200 OK        |         |         |         |\n     |------------------>|\
    \         |         |         |\n     |(22) ACK <a'>      |         |        \
    \ |         |\n     |------------------------------------------------>|\n    \
    \ |         |         |         |(23) SUBSCRIBE <o', a'>\n     |         |   \
    \      |         |<------------------|\n     |         |         |         |(24)\
    \ 200 OK        |\n     |         |         |         |------------------>|\n\
    \     |         |         |         |(25) NOTIFY <po, pa>\n     |         |  \
    \       |         |------------------>|\n     |         |         |         |(26)\
    \ 200 OK        |\n     |         |         |         |<------------------|\n\
    \     |         |         |         |         |         |\n     |         |  \
    \       |         |         |         |\n"
- title: B.3.  Multiple Policy Servers for the UAS
  contents:
  - 'B.3.  Multiple Policy Servers for the UAS

    '
- title: UA A       P A      PS A      PS B       P B      UA B
  contents:
  - "UA A       P A      PS A      PS B       P B      UA B\n  |         |       \
    \  |         |         |         |\n  |         |         |         |        \
    \ |         |\n  |         |         |         |         |         |\n  |(1) INV\
    \ <o>        |         |         |         |\n  |-------->|         |        \
    \ |         |         |\n  |         |(2) INV <o, uri PSA>         |         |\n\
    \  |         |---------------------------->|         |\n  |         |        \
    \ |         |         |(3) INV <o, uri PSA, uri PSB>\n  |         |         |\
    \         |         |-------->|\n  |         |         |(4) SUBSCRIBE <o, a> \
    \        |\n  |         |         |<----------------------------|\n  |       \
    \  |         |(5) 200 OK         |         |\n  |         |         |---------------------------->|\n\
    \  |         |         |(6) NOTIFY <po, pa>|         |\n  |         |        \
    \ |---------------------------->|\n  |         |         |(7) 200 OK         |\
    \         |\n  |         |         |<----------------------------|\n  |      \
    \   |         |         |(8) SUBSCRIBE <o', a'>\n  |         |         |     \
    \    |<------------------|\n  |         |         |         |(9) 200 OK      \
    \   |\n  |         |         |         |------------------>|\n  |         |  \
    \       |         |(10) NOTIFY <po, pa>\n  |         |         |         |------------------>|\n\
    \  |         |         |         |(11) 200 OK        |\n  |         |        \
    \ |         |<------------------|\n  |         |         |(12) SUBSCRIBE <o\"\
    , a\">      |\n  |         |         |<----------------------------|\n  |    \
    \     |         |(13) 200 OK        |         |\n  |         |         |---------------------------->|\n\
    \  |         |         |(14) NOTIFY <po, pa>         |\n  |         |        \
    \ |---------------------------->|\n  |         |         |(15) 200 OK        |\
    \         |\n  |         |         |<----------------------------|\n  |      \
    \   |         |         |(16) SUBSCRIBE <o\", a\">\n  |         |         |  \
    \       |<------------------|\n  |         |         |         |(17) 200 OK  \
    \      |\n  |         |         |         |------------------>|\n  |         |\
    \         |         |(18) NOTIFY <po, pa>\n  |         |         |         |------------------>|\n\
    \  |         |         |         |(19) 200 OK        |\n  |         |        \
    \ |         |<------------------|\n  |         |         |         |         |(20)\
    \ 200 OK <a\">\n  |         |         |         |         |<--------|\n  |   \
    \      |(21) 200 OK <a\">   |         |         |\n  |         |<----------------------------|\
    \         |\n  |(22) 200 OK <a\">   |         |         |         |\n  |<--------|\
    \         |         |         |         |\n  |(23) ACK |         |         | \
    \        |         |\n  |------------------------------------------------>|\n\
    \  |         |         |         |         |         |\n  |         |        \
    \ |         |         |         |\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Volker Hilt\n   Bell Labs/Alcatel-Lucent\n   Lorenzstrasse\
    \ 10\n   70435 Stuttgart\n   Germany\n   EMail: volker.hilt@bell-labs.com\n  \
    \ Gonzalo Camarillo\n   Ericsson\n   Hirsalantie 11\n   Jorvas  02420\n   Finland\n\
    \   EMail: Gonzalo.Camarillo@ericsson.com\n   Jonathan Rosenberg\n   jdrosen.net\n\
    \   Monmouth, NJ\n   USA\n   EMail: jdrosen@jdrosen.net\n"
