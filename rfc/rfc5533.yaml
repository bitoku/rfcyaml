- contents:
  - '           Shim6: Level 3 Multihoming Shim Protocol for IPv6

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents
    in effect on the date of\n   publication of this document (http://trustee.ietf.org/license-info).\n
    \  Please review these documents carefully, as they describe your rights\n   and
    restrictions with respect to this document.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document defines the Shim6 protocol, a layer 3 shim for\n   providing
    locator agility below the transport protocols, so that\n   multihoming can be
    provided for IPv6 with failover and load-sharing\n   properties, without assuming
    that a multihomed site will have a\n   provider-independent IPv6 address prefix
    announced in the global IPv6\n   routing table.  The hosts in a site that has
    multiple provider-\n   allocated IPv6 address prefixes will use the Shim6 protocol
    specified\n   in this document to set up state with peer hosts so that the state\n
    \  can later be used to failover to a different locator pair, should the\n   original
    one stop working.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \     1.1. Goals ......................................................5\n      1.2.
    Non-Goals ..................................................5\n      1.3. Locators
    as Upper-Layer Identifiers (ULID) .................6\n      1.4. IP Multicast
    ...............................................7\n      1.5. Renumbering Implications
    ...................................8\n      1.6. Placement of the Shim ......................................9\n
    \     1.7. Traffic Engineering .......................................11\n   2.
    Terminology ....................................................12\n      2.1.
    Definitions ...............................................12\n      2.2. Notational
    Conventions ....................................15\n      2.3. Conceptual ................................................15\n
    \  3. Assumptions ....................................................15\n   4.
    Protocol Overview ..............................................17\n      4.1.
    Context Tags ..............................................19\n      4.2. Context
    Forking ...........................................19\n      4.3. API Extensions
    ............................................20\n      4.4. Securing Shim6 ............................................20\n
    \     4.5. Overview of Shim Control Messages .........................21\n      4.6.
    Extension Header Order ....................................22\n   5. Message Formats
    ................................................23\n      5.1. Common Shim6 Message
    Format ...............................23\n      5.2. Shim6 Payload Extension Header
    Format .....................24\n      5.3. Common Shim6 Control Header ...............................25\n
    \     5.4. I1 Message Format .........................................26\n      5.5.
    R1 Message Format .........................................28\n      5.6. I2 Message
    Format .........................................29\n      5.7. R2 Message Format
    .........................................31\n      5.8. R1bis Message Format ......................................33\n
    \     5.9. I2bis Message Format ......................................34\n      5.10.
    Update Request Message Format ............................37\n      5.11. Update
    Acknowledgement Message Format ....................38\n      5.12. Keepalive Message
    Format .................................40\n      5.13. Probe Message Format .....................................40\n
    \     5.14. Error Message Format .....................................40\n      5.15.
    Option Formats ...........................................42\n           5.15.1.
    Responder Validator Option Format .................44\n           5.15.2. Locator
    List Option Format ........................44\n           5.15.3. Locator Preferences
    Option Format .................46\n           5.15.4. CGA Parameter Data Structure
    Option Format ........48\n           5.15.5. CGA Signature Option Format .......................49\n
    \          5.15.6. ULID Pair Option Format ...........................49\n           5.15.7.
    Forked Instance Identifier Option Format ..........50\n           5.15.8. Keepalive
    Timeout Option Format ...................50\n   6. Conceptual Model of a Host
    .....................................51\n      6.1. Conceptual Data Structures
    ................................51\n      6.2. Context STATES ............................................52\n
    \  7. Establishing ULID-Pair Contexts ................................54\n      7.1.
    Uniqueness of Context Tags ................................54\n      7.2. Locator
    Verification ......................................55\n      7.3. Normal Context
    Establishment ..............................56\n      7.4. Concurrent Context
    Establishment ..........................56\n      7.5. Context Recovery ..........................................58\n
    \     7.6. Context Confusion .........................................60\n      7.7.
    Sending I1 Messages .......................................61\n      7.8. Retransmitting
    I1 Messages ................................62\n      7.9. Receiving I1 Messages
    .....................................62\n      7.10. Sending R1 Messages ......................................63\n
    \          7.10.1. Generating the R1 Validator .......................64\n      7.11.
    Receiving R1 Messages and Sending I2 Messages ............64\n      7.12. Retransmitting
    I2 Messages ...............................65\n      7.13. Receiving I2 Messages
    ....................................66\n      7.14. Sending R2 Messages ......................................67\n
    \     7.15. Match for Context Confusion ..............................68\n      7.16.
    Receiving R2 Messages ....................................69\n      7.17. Sending
    R1bis Messages ...................................69\n           7.17.1. Generating
    the R1bis Validator ....................70\n      7.18. Receiving R1bis Messages
    and Sending I2bis Messages ......71\n      7.19. Retransmitting I2bis Messages
    ............................72\n      7.20. Receiving I2bis Messages and Sending
    R2 Messages .........72\n   8. Handling ICMP Error Messages ...................................74\n
    \  9. Teardown of the ULID-Pair Context ..............................76\n   10.
    Updating the Peer .............................................77\n      10.1.
    Sending Update Request Messages ..........................77\n      10.2. Retransmitting
    Update Request Messages ...................78\n      10.3. Newer Information while
    Retransmitting ...................78\n      10.4. Receiving Update Request Messages
    ........................79\n      10.5. Receiving Update Acknowledgement Messages
    ................81\n   11. Sending ULP Payloads ..........................................81\n
    \     11.1. Sending ULP Payload after a Switch .......................82\n   12.
    Receiving Packets .............................................83\n      12.1.
    Receiving Payload without Extension Headers ..............83\n      12.2. Receiving
    Shim6 Payload Extension Headers ................83\n      12.3. Receiving Shim
    Control Messages ..........................84\n      12.4. Context Lookup ...........................................84\n
    \  13. Initial Contact ...............................................86\n   14.
    Protocol Constants ............................................87\n   15. Implications
    Elsewhere ........................................88\n      15.1. Congestion Control
    Considerations ........................88\n      15.2. Middle-Boxes Considerations
    ..............................88\n      15.3. Operation and Management Considerations
    ..................89\n      15.4. Other Considerations .....................................90\n
    \  16. Security Considerations .......................................91\n      16.1.
    Interaction with IPSec ...................................93\n      16.2. Residual
    Threats .........................................94\n   17. IANA Considerations
    ...........................................95\n   18. Acknowledgements ..............................................97\n
    \  19. References ....................................................97\n      19.1.
    Normative References .....................................97\n      19.2. Informative
    References ...................................97\n   Appendix A.  Possible Protocol
    Extensions ........................100\n   Appendix B.  Simplified STATE Machine
    ............................101\n      B.1.  Simplified STATE Machine Diagram
    ........................108\n   Appendix C.  Context Tag Reuse ...................................109\n
    \     C.1.  Context Recovery ........................................109\n      C.2.
    \ Context Confusion .......................................109\n      C.3.  Three-Party
    Context Confusion .........................110\n      C.4.  Summary .................................................110\n
    \  Appendix D.  Design Alternatives .................................111\n      D.1.
    \ Context Granularity .....................................111\n      D.2.  Demultiplexing
    of Data Packets in Shim6 Communications ..111\n        D.2.1.   Flow Label .........................................112\n
    \       D.2.2.   Extension Header ...................................115\n      D.3.
    \ Context-Loss Detection ................................115\n      D.4.  Securing
    Locator Sets ...................................117\n      D.5.  ULID-Pair Context-Establishment
    Exchange ............120\n      D.6.  Updating Locator Sets ...................................121\n
    \     D.7.  State Cleanup ...........................................122\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document describes a layer 3 shim approach and protocol
    for\n   providing locator agility below the transport protocols, so that\n   multihoming
    can be provided for IPv6 with failover and load-sharing\n   properties [11], without
    assuming that a multihomed site will have a\n   provider-independent IPv6 address
    announced in the global IPv6\n   routing table.  The hosts in a site that has
    multiple provider-\n   allocated IPv6 address prefixes will use the Shim6 protocol
    specified\n   in this document to set up state with peer hosts so that the state\n
    \  can later be used to failover to a different locator pair, should the\n   original
    one stop working (the term locator is defined in Section 2).\n   The Shim6 protocol
    is a site-multihoming solution in the sense that\n   it allows existing communication
    to continue when a site that has\n   multiple connections to the Internet experiences
    an outage on a\n   subset of these connections or further upstream.  However,
    Shim6\n   processing is performed in individual hosts rather than through site-\n
    \  wide mechanisms.\n   We assume that redirection attacks are prevented using
    Hash-Based\n   Addresses (HBA) as defined in [3].\n   The reachability and failure-detection
    mechanisms, including how a\n   new working locator pair is discovered after a
    failure, are specified\n   in RFC 5534 [4].  This document allocates message types
    and option\n   types for that sub-protocol, and leaves the specification of the\n
    \  message and option formats, as well as the protocol behavior, to RFC\n   5534.\n"
  - contents:
    - "1.1.  Goals\n   The goals for this approach are to:\n   o  Preserve established
      communications in the presence of certain\n      classes of failures, for example,
      TCP connections and UDP streams.\n   o  Have minimal impact on upper-layer protocols
      in general and on\n      transport protocols and applications in particular.\n
      \  o  Address the security threats in [15] through a combination of the\n      HBA/CGA
      approach specified in RFC 5535 [3] and the techniques\n      described in this
      document.\n   o  Not require an extra roundtrip up front to set up shim-specific\n
      \     state.  Instead, allow the upper-layer traffic (e.g., TCP) to flow\n      as
      normal and defer the set up of the shim state until some number\n      of packets
      have been exchanged.\n   o  Take advantage of multiple locators/addresses for
      load spreading\n      so that different sets of communication to a host (e.g.,
      different\n      connections) might use different locators of the host.  Note
      that\n      this might cause load to be spread unevenly; thus, we use the term\n
      \     \"load spreading\" instead of \"load balancing\".  This capability\n      might
      enable some forms of traffic engineering, but the details\n      for traffic
      engineering, including what requirements can be\n      satisfied, are not specified
      in this document, and form part of\n      potential extensions to this protocol.\n"
    title: 1.1.  Goals
  - contents:
    - "1.2.  Non-Goals\n   The problem we are trying to solve is site multihoming,
      with the\n   ability to have the set of site prefixes change over time due to
      site\n   renumbering.  Further, we assume that such changes to the set of\n
      \  locator prefixes can be relatively slow and managed: slow enough to\n   allow
      updates to the DNS to propagate (since the protocol defined in\n   this document
      depends on the DNS to find the appropriate locator\n   sets).  However, note
      that it is an explicit non-goal to make\n   communication survive a renumbering
      event (which causes all the\n   locators of a host to change to a new set of
      locators).  This\n   proposal does not attempt to solve the related problem
      of host\n   mobility.  However, it might turn out that the Shim6 protocol can
      be\n   a useful component for future host mobility solutions, e.g., for\n   route
      optimization.\n   Finally, this proposal also does not try to provide a new
      network-\n   level or transport-level identifier name space distinct from the\n
      \  current IP address name space.  Even though such a concept would be\n   useful
      to upper-layer protocols (ULPs) and applications, especially\n   if the management
      burden for such a name space was negligible and\n   there was an efficient yet
      secure mechanism to map from identifiers\n   to locators, such a name space
      isn't necessary (and furthermore\n   doesn't seem to help) to solve the multihoming
      problem.\n   The Shim6 proposal doesn't fully separate the identifier and locator\n
      \  functions that have traditionally been overloaded in the IP address.\n   However,
      throughout this document the term \"identifier\" or, more\n   specifically,
      upper-layer identifier (ULID), refers to the\n   identifying function of an
      IPv6 address.  \"Locator\" refers to the\n   network-layer routing and forwarding
      properties of an IPv6 address.\n"
    title: 1.2.  Non-Goals
  - contents:
    - "1.3.  Locators as Upper-Layer Identifiers (ULID)\n   The approach described
      in this document does not introduce a new\n   identifier name space but instead
      uses the locator that is selected\n   in the initial contact with the remote
      peer as the preserved upper-\n   layer identifier (ULID).  While there may be
      subsequent changes in\n   the selected network-level locators over time (in
      response to\n   failures in using the original locator), the upper-level protocol\n
      \  stack elements will continue to use this upper-level identifier\n   without
      change.\n   This implies that the ULID selection is performed as today's default\n
      \  address selection as specified in RFC 3484 [7].  Some extensions are\n   needed
      to RFC 3484 to try different source addresses, whether or not\n   the Shim6
      protocol is used, as outlined in [9].  Underneath, and\n   transparently, the
      multihoming shim selects working locator pairs\n   with the initial locator
      pair being the ULID pair.  If communication\n   subsequently fails, the shim
      can test and select alternate locators.\n   A subsequent section discusses the
      issues that arise when the\n   selected ULID is not initially working, which
      creates the need to\n   switch locators up front.\n   Using one of the locators
      as the ULID has certain benefits for\n   applications that have long-lived session
      state or that perform\n   callbacks or referrals, because both the Fully Qualified
      Domain Name\n   (FQDN) and the 128-bit ULID work as handles for the applications.\n
      \  However, using a single 128-bit ULID doesn't provide seamless\n   communication
      when that locator is unreachable.  See [18] for further\n   discussion of the
      application implications.\n   There has been some discussion of using non-routable
      addresses, such\n   as Unique-Local Addresses (ULAs) [14], as ULIDs in a multihoming\n
      \  solution.  While this document doesn't specify all aspects of this,\n   it
      is believed that the approach can be extended to handle the non-\n   routable
      address case.  For example, the protocol already needs to\n   handle ULIDs that
      are not initially reachable.  Thus, the same\n   mechanism can handle ULIDs
      that are permanently unreachable from\n   outside their site.  The issue becomes
      how to make the protocol\n   perform well when the ULID is known a priori to
      be unreachable (e.g.,\n   the ULID is a ULA), for instance, avoiding any timeout
      and retries in\n   this case.  In addition, one would need to understand how
      the ULAs\n   would be entered in the DNS to avoid a performance impact on\n
      \  existing, non-Shim6-aware IPv6 hosts potentially trying to\n   communicate
      to the (unreachable) ULA.\n"
    title: 1.3.  Locators as Upper-Layer Identifiers (ULID)
  - contents:
    - "1.4.  IP Multicast\n   IP multicast requires that the IP Source Address field
      contain a\n   topologically correct locator for the interface that is used to
      send\n   the packet, since IP multicast routing uses both the source address\n
      \  and the destination group to determine where to forward the packet.\n   In
      particular, IP multicast routing needs to be able to do the\n   Reverse Path
      Forwarding (RPF) check.  (This isn't much different than\n   the situation with
      widely implemented ingress filtering [6] for\n   unicast.)\n   While in theory
      it would be possible to apply the shim re-mapping of\n   the IP address fields
      between ULIDs and locators, the fact that all\n   the multicast receivers would
      need to know the mapping to perform\n   makes such an approach difficult in
      practice.  Thus, it makes sense\n   to have multicast ULPs operate directly
      on locators and not use the\n   shim.  This is quite a natural fit for protocols
      that use RTP [10],\n   since RTP already has an explicit identifier in the form
      of the\n   synchronization source (SSRC) field in the RTP headers.  Thus, the\n
      \  actual IP address fields are not important to the application.\n   In summary,
      IP multicast will not need the shim to remap the IP\n   addresses.\n   This
      doesn't prevent the receiver of multicast to change its\n   locators, since
      the receiver is not explicitly identified; the\n   destination address is a
      multicast address and not the unicast\n   locator of the receiver.\n"
    title: 1.4.  IP Multicast
  - contents:
    - "1.5.  Renumbering Implications\n   As stated above, this approach does not
      try to make communication\n   survive renumbering in the general case.\n   When
      a host is renumbered, the effect is that one or more locators\n   become invalid,
      and zero or more locators are added to the host's\n   network interface.  This
      means that the set of locators that is used\n   in the shim will change, which
      the shim can handle as long as not all\n   the original locators become invalid
      at the same time; the shim's\n   ability to handle this also depends on the
      time that is required to\n   update the DNS and for those updates to propagate.\n
      \  But IP addresses are also used as ULIDs, and making the communication\n   survive
      locators becoming invalid can potentially cause some\n   confusion at the upper
      layers.  The fact that a ULID might be used\n   with a different locator over
      time opens up the possibility that\n   communication between two ULIDs might
      continue to work after one or\n   both of those ULIDs are no longer reachable
      as locators, for example,\n   due to a renumbering event.  This opens up the
      possibility that the\n   ULID (or at least the prefix on which it is based)
      may be reassigned\n   to another site while it is still being used (with another
      locator)\n   for existing communication.\n   In the worst case, we could end
      up with two separate hosts using the\n   same ULID while both of them are communicating
      with the same host.\n   This potential source for confusion is avoided by requiring
      that any\n   communication using a ULID MUST be terminated when the ULID becomes\n
      \  invalid (due to the underlying prefix becoming invalid).  This\n   behavior
      can be accomplished by explicitly discarding the shim state\n   when the ULID
      becomes invalid.  The context-recovery mechanism will\n   then make the peer
      aware that the context is gone and that the ULID\n   is no longer present at
      the same locator(s).\n"
    title: 1.5.  Renumbering Implications
  - contents:
    - "1.6.  Placement of the Shim\n                             -----------------------\n
      \                            | Transport Protocols |\n                             -----------------------\n
      \                         -------------- -------------    IP endpoint\n                          |
      Frag/reass | | Dest opts |    sub-layer\n                          --------------
      -------------\n                              ---------------------\n                              |
      Shim6 shim layer  |\n                              ---------------------\n                                     ------
      \              IP routing\n                                     | IP |               sub-layer\n
      \                                    ------\n                         Figure
      1: Protocol Stack\n   The proposal uses a multihoming shim layer within the
      IP layer, i.e.,\n   below the ULPs, as shown in Figure 1, in order to provide
      ULP\n   independence.  The multihoming shim layer behaves as if it is\n   associated
      with an extension header, which would be placed after any\n   routing-related
      headers in the packet (such as any hop-by-hop\n   options).  However, when the
      locator pair is the ULID pair, there is\n   no data that needs to be carried
      in an extension header; thus, none\n   is needed in that case.\n   Layering
      the Fragmentation header above the multihoming shim makes\n   reassembly robust
      in the case that there is broken multi-path routing\n   that results in using
      different paths, hence potentially different\n   source locators, for different
      fragments.  Thus, the multihoming shim\n   layer is placed between the IP endpoint
      sublayer (which handles\n   fragmentation and reassembly) and the IP routing
      sublayer (which\n   selects the next hop and interface to use for sending out
      packets).\n   Applications and upper-layer protocols use ULIDs that the Shim6
      layer\n   maps to/from different locators.  The Shim6 layer maintains state,\n
      \  called ULID-pair context, per ULID pair (that is, such state applies\n   to
      all ULP connections between the ULID pair) in order to perform\n   this mapping.
      \ The mapping is performed consistently at the sender\n   and the receiver so
      that ULPs see packets that appear to be sent\n   using ULIDs from end to end.
      \ This property is maintained even though\n   the packets travel through the
      network containing locators in the IP\n   address fields, and even though those
      locators may be changed by the\n   transmitting Shim6 layer.\n   The context
      state is maintained per remote ULID, i.e., approximately\n   per peer host,
      and not at any finer granularity.  In particular, the\n   context state is independent
      of the ULPs and any ULP connections.\n   However, the forking capability enables
      Shim6-aware ULPs to use more\n   than one locator pair at a time for a single
      ULID pair.\n    ----------------------------          ----------------------------\n
      \   | Sender A                 |          | Receiver B               |\n    |
      \                         |          |                          |\n    |     ULP
      \                 |          |     ULP                  |\n    |      | src
      ULID(A)=L1(A) |          |      ^                   |\n    |      | dst ULID(B)=L1(B)
      |          |      | src ULID(A)=L1(A) |\n    |      v                   |          |
      \     | dst ULID(B)=L1(B) |\n    |   multihoming shim       |          |   multihoming
      shim       |\n    |      | src L2(A)         |          |      ^                   |\n
      \   |      | dst L3(B)         |          |      | src L2(A)         |\n    |
      \     v                   |          |      | dst L3(B)         |\n    |      IP
      \                 |          |      IP                  |\n    ----------------------------
      \         ----------------------------\n           |                                     ^\n
      \          ------- cloud with some routers -------\n                  Figure
      2: Mapping with Changed Locators\n   The result of this consistent mapping is
      that there is no impact on\n   the ULPs.  In particular, there is no impact
      on pseudo-header\n   checksums and connection identification.\n   Conceptually,
      one could view this approach as if both ULIDs and\n   locators are present in
      every packet, and as if a header-compression\n   mechanism is applied that removes
      the need for the ULIDs to be\n   carried in the packets once the compression
      state has been\n   established.  In order for the receiver to re-create a packet
      with\n   the correct ULIDs, there is a need to include some \"compression tag\"\n
      \  in the data packets.  This serves to indicate the correct context to\n   use
      for decompression when the locator pair in the packet is\n   insufficient to
      uniquely identify the context.\n   There are different types of interactions
      between the Shim6 layer and\n   other protocols.  Those interactions are influenced
      by the usage of\n   the addresses in these other protocols and the impact of
      the Shim6\n   mapping on these usages.  A detailed analysis of the interactions
      of\n   different protocols, including the Stream Control Transmission\n   Protocol
      (SCTP), mobile IP (MIP), and Host Identity Protocol (HIP),\n   can be found
      in [19].  Moreover, some applications may need to have a\n   richer interaction
      with the Shim6 sublayer.  In order to enable that,\n   an API [23] has been
      defined to enable greater control and\n   information exchange for those applications
      that need it.\n"
    title: 1.6.  Placement of the Shim
  - contents:
    - "1.7.  Traffic Engineering\n   At the time of this writing, it is not clear
      what requirements for\n   traffic engineering make sense for the Shim6 protocol,
      since the\n   requirements must both result in some useful behavior as well
      as be\n   implementable using a host-to-host locator agility mechanism like\n
      \  Shim6.\n   Inherent in a scalable multihoming mechanism that separates the\n
      \  locator function of the IP address from identifying function of the\n   IP
      address is that each host ends up with multiple locators.  This\n   means that,
      at least for initial contact, it is the remote peer\n   application (or layer
      working on its behalf) that needs to select an\n   initial ULID, which automatically
      becomes the initial locator.  In\n   the case of Shim6, this is performed by
      applying RFC 3484 address\n   selection.\n   This is quite different than the
      common case of IPv4 multihoming\n   where the site has a single IP address prefix,
      since in that case the\n   peer performs no destination address selection.\n
      \  Thus, in \"single prefix multihoming\", the site (and in many cases its\n
      \  upstream ISPs) can use BGP to exert some control of the ingress path\n   used
      to reach the site.  This capability does not by itself exist in\n   \"multiple
      prefix multihoming\" approaches such as Shim6.  It is\n   conceivable that extensions
      allowing site or provider guidance of\n   host-based mechanisms could be developed.
      \ But it should be noted\n   that traffic engineering via BGP, MPLS, or other
      similar techniques\n   can still be applied for traffic on each individual prefix;
      Shim6\n   does not remove the capability for this.  It does provide some\n   additional
      capabilities for hosts to choose between prefixes.\n   These capabilities also
      carry some risk for non-optimal behaviour\n   when more than one mechanism attempts
      to correct problems at the same\n   time.  However, it should be noted that
      this is not necessarily a\n   situation brought about by Shim6.  A more constrained
      form of this\n   capability already exists in IPv6, itself, via its support
      of\n   multiple prefixes and address-selection rules for starting new\n   communications.
      \ Even IPv4 hosts with multiple interfaces may have\n   limited capabilities
      to choose interfaces on which they communicate.\n   Similarly, upper layers
      may choose different addresses.\n   In general, it is expected that Shim6 is
      applicable in relatively\n   small sites and individual hosts where BGP-style
      traffic engineering\n   operations are unavailable, unlikely, or if run with
      provider-\n   independent addressing, possibly even harmful, considering the
      growth\n   rates in the global routing table.\n   The protocol provides a placeholder,
      in the form of the Locator\n   Preferences option, that can be used by hosts
      to express priority and\n   weight values for each locator.  This option is
      merely a placeholder\n   when it comes to providing traffic engineering; in
      order to use this\n   in a large site, there would have to be a mechanism by
      which the host\n   can find out what preference values to use, either statically
      (e.g.,\n   some new DHCPv6 option) or dynamically.\n   Thus, traffic engineering
      is listed as a possible extension in\n   Appendix A.\n"
    title: 1.7.  Traffic Engineering
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in RFC 2119 [1].\n"
  - contents:
    - "2.1.  Definitions\n   This document introduces the following terms:\n   upper-layer
      protocol (ULP)\n                       A protocol layer immediately above IP.
      \ Examples\n                       are transport protocols such as TCP and UDP;\n
      \                      control protocols such as ICMP; routing protocols\n                       such
      as OSPF; and Internet or lower-layer\n                       protocols being
      \"tunneled\" over (i.e.,\n                       encapsulated in) IP, such as
      the Internet Packet\n                       Exchange (IPX), AppleTalk, or IP
      itself.\n   interface           A node's attachment to a link.\n   address             An
      IP-layer name that both contains topological\n                       significance
      and acts as a unique identifier for\n                       an interface. 128
      bits.  This document only uses\n                       the \"address\" term
      in the case where it isn't\n                       specific whether it is a
      locator or an\n                       identifier.\n   locator             An
      IP-layer topological name for an interface or\n                       a set
      of interfaces. 128 bits.  The locators are\n                       carried in
      the IP address fields as the packets\n                       traverse the network.\n
      \  identifier          An IP-layer name for an IP-layer endpoint.  The\n                       transport
      endpoint name is a function of the\n                       transport protocol
      and would typically include\n                       the IP identifier plus a
      port number.\n                       NOTE: This proposal does not specify any
      new form\n                       of IP-layer identifier, but still separates
      the\n                       identifying and locating properties of the IP\n
      \                      addresses.\n   upper-layer identifier (ULID)\n                       An
      IP address that has been selected for\n                       communication
      with a peer to be used by the\n                       upper-layer protocol.
      128 bits.  This is used for\n                       pseudo-header checksum computation
      and connection\n                       identification in the ULP.  Different
      sets of\n                       communication to a host (e.g., different\n                       connections)
      might use different ULIDs in order\n                       to enable load spreading.\n
      \                      Since the ULID is just one of the IP locators/\n                       addresses
      of the node, there is no need for a\n                       separate name space
      and allocation mechanisms.\n   address field       The Source and Destination
      Address fields in the\n                       IPv6 header.  As IPv6 is currently
      specified,\n                       these fields carry \"addresses\".  If identifiers\n
      \                      and locators are separated, these fields will\n                       contain
      locators for packets on the wire.\n   FQDN                Fully Qualified Domain
      Name\n   ULID-pair context   The state that the multihoming shim maintains\n
      \                      between a pair of upper-layer identifiers.  The\n                       context
      is identified by a Context Tag for each\n                       direction of
      the communication and also by a\n                       ULID-pair and a Forked
      Instance Identifier (see\n                       below).\n   Context Tag         Each
      end of the context allocates a Context Tag\n                       for the context.
      \ This is used to uniquely\n                       associate both received control
      packets and Shim6\n                       Payload Extension headers as belonging
      to the\n                       context.\n   current locator pair\n                       Each
      end of the context has a current locator\n                       pair that is
      used to send packets to the peer.\n                       However, the two ends
      might use different current\n                       locator pairs.\n   default
      context     At the sending end, the shim uses the ULID pair\n                       (passed
      down from the ULP) to find the context\n                       for that pair.
      \ Thus, normally, a host can have\n                       at most one context
      for a ULID pair.  We call\n                       this the \"default context\".\n
      \  context forking     A mechanism that allows ULPs that are aware of\n                       multiple
      locators to use separate contexts for\n                       the same ULID
      pair, in order to be able use\n                       different locator pairs
      for different\n                       communication to the same ULID.  Context
      forking\n                       causes more than just the default context to
      be\n                       created for a ULID pair.\n   Forked Instance Identifier
      (FII)\n                       In order to handle context forking, a context
      is\n                       identified by a ULID pair and a Forked Context\n
      \                      Identifier.  The default context has an FII of\n                       zero.\n
      \  initial contact     We use this term to refer to the pre-shim\n                       communication
      when a ULP decides to start\n                       communicating with a peer
      by sending and\n                       receiving ULP packets.  Typically, this
      would not\n                       invoke any operations in the shim, since the
      shim\n                       can defer the context establishment until some\n
      \                      arbitrary, later point in time.\n   Hash-Based Addresses
      (HBA)\n                       A form of IPv6 address where the interface ID
      is\n                       derived from a cryptographic hash of all the\n                       prefixes
      assigned to the host.  See [3].\n   Cryptographically Generated Addresses (CGA)\n
      \                      A form of IPv6 address where the interface ID is\n                       derived
      from a cryptographic hash of the public\n                       key.  See [2].\n
      \  CGA Parameter Data Structure (PDS)\n                       The information
      that CGA and HBA exchange in\n                       order to inform the peer
      of how the interface ID\n                       was computed.  See [2] and [3].\n"
    title: 2.1.  Definitions
  - contents:
    - "2.2.  Notational Conventions\n   A, B, and C are hosts.  X is a potentially
      malicious host.\n   FQDN(A) is the Fully Qualified Domain Name for A.\n   Ls(A)
      is the locator set for A, which consists of the locators L1(A),\n   L2(A), ...
      \ Ln(A).  The locator set is not ordered in any particular\n   way other than
      maybe what is returned by the DNS.  A host might form\n   different locator
      sets containing different subnets of the host's IP\n   addresses.  This is necessary
      in some cases for security reasons.\n   See Section 16.1.\n   ULID(A) is an
      upper-layer identifier for A.  In this proposal,\n   ULID(A) is always one member
      of A's locator set.\n   CT(A) is a Context Tag assigned by A.\n   STATE (in
      uppercase) refers to the specific state of the state\n   machine described in
      Section 6.2\n"
    title: 2.2.  Notational Conventions
  - contents:
    - "2.3.  Conceptual\n   This document also makes use of internal conceptual variables
      to\n   describe protocol behavior and external variables that an\n   implementation
      must allow system administrators to change.  The\n   specific variable names,
      how their values change, and how their\n   settings influence protocol behavior
      are provided to demonstrate\n   protocol behavior.  An implementation is not
      required to have them in\n   the exact form described here, so long as its external
      behavior is\n   consistent with that described in this document.  See Section
      6 for a\n   description of the conceptual data structures.\n"
    title: 2.3.  Conceptual
  title: 2.  Terminology
- contents:
  - "3.  Assumptions\n   The design intent is to ensure that the Shim6 protocol is
    capable of\n   handling path failures independently of the number of IP addresses\n
    \  (locators) available to the two communicating hosts, and\n   independently
    of which host detects the failure condition.\n   Consider, for example, the case
    in which both A and B have active\n   Shim6 state and where A has only one locator
    while B has multiple\n   locators.  In this case, it might be that B is trying
    to send a\n   packet to A, and has detected a failure condition with the current\n
    \  locator pair.  Since B has multiple locators, it presumably has\n   multiple
    ISPs, and (consequently) likely has alternate egress paths\n   toward A.  B cannot
    vary the destination address (i.e., A's locator),\n   since A has only one locator.
    \ However, B may need to vary the source\n   address in order to ensure packet
    delivery.\n   In many cases, normal operation of IP routing may cause the packets\n
    \  to follow a path towards the correct (currently operational) egress.\n   In
    some cases, it is possible that a path may be selected based on\n   the source
    address, implying that B will need to select a source\n   address corresponding
    to the currently operating egress.  The details\n   of how routing can be accomplished
    is beyond the scope of this\n   document.\n   Also, when the site's ISPs perform
    ingress filtering based on packet\n   source addresses, Shim6 assumes that packets
    sent with different\n   source and destination combinations have a reasonable
    chance of\n   making it through the relevant ISP's ingress filters.  This can
    be\n   accomplished in several ways (all outside the scope of this\n   document),
    such as having the ISPs relax their ingress filters or\n   selecting the egress
    such that it matches the IP source address\n   prefix.  In the case that one egress
    path has failed but another is\n   operating correctly, it may be necessary for
    the packet's source\n   (node B in the previous paragraph) to select a source
    address that\n   corresponds to the operational egress, in order to pass the ISP's\n
    \  ingress filters.\n   The Shim6 approach assumes that there are no IPv6-to-IPv6
    NATs on the\n   paths, i.e., that the two ends can exchange their own notion of
    their\n   IPv6 addresses and that those addresses will also make sense to their\n
    \  peer.\n   The security of the Shim6 protocol relies on the usage of Hash-Based\n
    \  Addresses (HBA) [3] and/or Cryptographically Generated Addresses\n   (CGA)
    [2].  In the case that HBAs are used, all the addresses\n   assigned to the host
    that are included in the Shim6 protocol (either\n   as a locator or as a ULID)
    must be part of the same HBA set.  In the\n   case that CGAs are used, the address
    used as ULID must be a CGA, but\n   the other addresses that are used as locators
    do not need to be\n   either CGAs or HBAs.  It should be noted that it is perfectly\n
    \  acceptable to run the Shim6 protocol between a host that has multiple\n   locators
    and another host that has a single IP address.  In this\n   case, the address
    of the host with a single address does not need to\n   be an HBA or a CGA.\n"
  title: 3.  Assumptions
- contents:
  - "4.  Protocol Overview\n   The Shim6 protocol operates in several phases over
    time.  The\n   following sequence illustrates the concepts:\n   o  An application
    on host A decides to contact an application on host\n      B using some upper-layer
    protocol.  This results in the ULP on\n      host A sending packets to host B.
    \ We call this the initial\n      contact.  Assuming the IP addresses selected
    by default address\n      selection [7] and its extensions [9] work, then there
    is no action\n      by the shim at this point in time.  Any shim context establishment\n
    \     can be deferred until later.\n   o  Some heuristic on A or B (or both) determine
    that it is\n      appropriate to pay the Shim6 overhead to make this host-to-host\n
    \     communication robust against locator failures.  For instance, this\n      heuristic
    might be that more than 50 packets have been sent or\n      received, or that
    there was a timer expiration while active packet\n      exchange was in place.
    \ This makes the shim initiate the 4-way,\n      context-establishment exchange.
    \ The purpose of this heuristic is\n      to avoid setting up a shim context when
    only a small number of\n      packets is exchanged between two hosts.\n      As
    a result of this exchange, both A and B will know a list of\n      locators for
    each other.\n      If the context-establishment exchange fails, the initiator
    will\n      then know that the other end does not support Shim6, and will\n      continue
    with standard (non-Shim6) behavior for the session.\n   o  Communication continues
    without any change for the ULP packets.\n      In particular, there are no Shim6
    Extension headers added to the\n      ULP packets, since the ULID pair is the
    same as the locator pair.\n      In addition, there might be some messages exchanged
    between the\n      shim sublayers for (un)reachability detection.\n   o  At some
    point in time, something fails.  Depending on the approach\n      to reachability
    detection, there might be some advice from the\n      ULP, or the shim (un)reachability
    detection might discover that\n      there is a problem.\n      At this point
    in time, one or both ends of the communication need\n      to probe the different
    alternate locator pairs until a working\n      pair is found, and then switch
    to using that locator pair.\n   o  Once a working alternative locator pair has
    been found, the shim\n      will rewrite the packets on transmit and tag the packets
    with the\n      Shim6 Payload Extension header, which contains the receiver's\n
    \     Context Tag.  The receiver will use the Context Tag to find the\n      context
    state, which will indicate which addresses to place in the\n      IPv6 header
    before passing the packet up to the ULP.  The result\n      is that, from the
    perspective of the ULP, the packet passes\n      unmodified end-to-end, even though
    the IP routing infrastructure\n      sends the packet to a different locator.\n
    \  o  The shim (un)reachability detection will monitor the new locator\n      pair
    as it monitored the original locator pair, so that subsequent\n      failures
    can be detected.\n   o  In addition to failures detected based on end-to-end observations,\n
    \     one endpoint might know for certain that one or more of its\n      locators
    is not working.  For instance, the network interface\n      might have failed
    or gone down (at layer 2), or an IPv6 address\n      might have become deprecated
    or invalid.  In such cases, the host\n      can signal its peer that trying this
    address is no longer\n      recommended.  This triggers something similar to a
    failure\n      handling, and a new working locator pair must be found.\n      The
    protocol also has the ability to express other forms of\n      locator preferences.
    \ A change in any preference can be signaled\n      to the peer, which will have
    made the peer record the new\n      preferences.  A change in the preferences
    might optionally make\n      the peer want to use a different locator pair.  In
    this case, the\n      peer follows the same locator switching procedure as after
    a\n      failure (by verifying that its peer is indeed present at the\n      alternate
    locator, etc).\n   o  When the shim thinks that the context state is no longer
    used, it\n      can garbage collect the state; there is no coordination necessary\n
    \     with the peer host before the state is removed.  There is a\n      recovery
    message defined to be able to signal when there is no\n      context state, which
    can be used to detect and recover from both\n      premature garbage collection
    as well as from complete state loss\n      (crash and reboot) of a peer.\n      The
    exact mechanism to determine when the context state is no\n      longer used is
    implementation dependent.  For example, an\n      implementation might use the
    existence of ULP state (where known\n      to the implementation) as an indication
    that the state is still\n      used, combined with a timer (to handle ULP state
    that might not be\n      known to the shim sublayer) to determine when the state
    is likely\n      to no longer be used.\n   NOTE 1: The ULP packets in Shim6 can
    be carried completely unmodified\n   as long as the ULID pair is used as the locator
    pair.  After a switch\n   to a different locator pair, the packets are \"tagged\"
    with a Shim6\n   Extension header so that the receiver can always determine the\n
    \  context to which they belong.  This is accomplished by including an\n   8-octet
    Shim6 Payload Extension header before the (extension) headers\n   that are processed
    by the IP endpoint sublayer and ULPs.  If,\n   subsequently, the original ULIDs
    are selected as the active locator\n   pair, then the tagging of packets with
    the Shim6 Extension header is\n   no longer necessary.\n"
  - contents:
    - "4.1.  Context Tags\n   A context between two hosts is actually a context between
      two ULIDs.\n   The context is identified by a pair of Context Tags.  Each end
      gets\n   to allocate a Context Tag, and once the context is established, most\n
      \  Shim6 control messages contain the Context Tag that the receiver of\n   the
      message allocated.  Thus, at a minimum, the combination of <peer\n   ULID, local
      ULID, local Context Tag> have to uniquely identify one\n   context.  But, since
      the Shim6 Payload Extension headers are\n   demultiplexed without looking at
      the locators in the packet, the\n   receiver will need to allocate Context Tags
      that are unique for all\n   its contexts.  The Context Tag is a 47-bit number
      (the largest that\n   can fit in an 8-octet extension header), while preserving
      one bit to\n   differentiate the Shim6 signaling messages from the Shim6 header\n
      \  included in data packets, allowing both to use the same protocol\n   number.\n
      \  The mechanism for detecting a loss of context state at the peer\n   assumes
      that the receiver can tell the packets that need locator\n   rewriting, even
      after it has lost all state (e.g., due to a crash\n   followed by a reboot).
      \ This is achieved because, after a rehoming\n   event, the packets that need
      receive-side rewriting carry the Shim6\n   Payload Extension header.\n"
    title: 4.1.  Context Tags
  - contents:
    - "4.2.  Context Forking\n   It has been asserted that it will be important for
      future ULPs -- in\n   particular, future transport protocols -- to be able to
      control which\n   locator pairs are used for different communication.  For instance,\n
      \  host A and host B might communicate using both Voice over IP (VoIP)\n   traffic
      and ftp traffic, and those communications might benefit from\n   using different
      locator pairs.  However, the basic Shim6 mechanism\n   uses a single current
      locator pair for each context; thus, a single\n   context cannot accomplish
      this.\n   For this reason, the Shim6 protocol supports the notion of context\n
      \  forking.  This is a mechanism by which a ULP can specify (using some\n   API
      not yet defined) that a context, e.g., the ULID pair <A1, B2>,\n   should be
      forked into two contexts.  In this case, the forked-off\n   context will be
      assigned a non-zero Forked Instance Identifier, while\n   the default context
      has FII zero.\n   The Forked Instance Identifier (FII) is a 32-bit identifier
      that has\n   no semantics in the protocol other than being part of the tuple
      that\n   identifies the context.  For example, a host might allocate FIIs as\n
      \  sequential numbers for any given ULID pair.\n   No other special considerations
      are needed in the Shim6 protocol to\n   handle forked contexts.\n   Note that
      forking as specified does NOT allow A to be able to tell B\n   that certain
      traffic (a 5-tuple?) should be forked for the reverse\n   direction.  The Shim6
      forking mechanism as specified applies only to\n   the sending of ULP packets.
      \ If some ULP wants to fork for both\n   directions, it is up to the ULP to
      set this up and then instruct the\n   shim at each end to transmit using the
      forked context.\n"
    title: 4.2.  Context Forking
  - contents:
    - "4.3.  API Extensions\n   Several API extensions have been discussed for Shim6,
      but their\n   actual specification is out of scope for this document.  The simplest\n
      \  one would be to add a socket option to be able to have traffic bypass\n   the
      shim (not create any state and not use any state created by other\n   traffic).
      \ This could be an IPV6_DONTSHIM socket option.  Such an\n   option would be
      useful for protocols, such as DNS, where the\n   application has its own failover
      mechanism (multiple NS records in\n   the case of DNS) and using the shim could
      potentially add extra\n   latency with no added benefits.\n   Some other API
      extensions are discussed in Appendix A.  The actual\n   API extensions are defined
      in [23].\n"
    title: 4.3.  API Extensions
  - contents:
    - "4.4.  Securing Shim6\n   The mechanisms are secured using a combination of
      techniques:\n   o  The HBA technique [3] for verifying the locators to prevent
      an\n      attacker from redirecting the packet stream to somewhere else.\n   o
      \ Requiring a Reachability Probe+Reply (defined in [4]) before a new\n      locator
      is used as the destination, in order to prevent 3rd party\n      flooding attacks.\n
      \  o  The first message does not create any state on the responder.\n      Essentially,
      a 3-way exchange is required before the responder\n      creates any state.
      \ This means that a state-based DoS attack\n      (trying to use up all memory
      on the responder) at least provides\n      an IPv6 address that the attacker
      was using.\n   o  The context-establishment messages use nonces to prevent replay\n
      \     attacks and to prevent off-path attackers from interfering with\n      the
      establishment.\n   o  Every control message of the Shim6 protocol, past the
      context\n      establishment, carries the Context Tag assigned to the particular\n
      \     context.  This implies that an attacker needs to discover that\n      Context
      Tag before being able to spoof any Shim6 control message.\n      Such discovery
      probably requires any potential attacker to be\n      along the path in order
      to sniff the Context Tag value.  The\n      result is that through this technique,
      the Shim6 protocol is\n      protected against off-path attackers.\n"
    title: 4.4.  Securing Shim6
  - contents:
    - "4.5.  Overview of Shim Control Messages\n   The Shim6 context establishment
      is accomplished using four messages;\n   I1, R1, I2, R2.  Normally, they are
      sent in that order from initiator\n   and responder, respectively.  Should both
      ends attempt to set up\n   context state at the same time (for the same ULID
      pair), then their\n   I1 messages might cross in flight, and result in an immediate
      R2\n   message.  (The names of these messages are borrowed from HIP [20].)\n
      \  R1bis and I2bis messages are defined; they are used to recover a\n   context
      after it has been lost.  An R1bis message is sent when a\n   Shim6 control or
      Shim6 Payload Extension header arrives and there is\n   no matching context
      state at the receiver.  When such a message is\n   received, it will result
      in the re-creation of the Shim6 context\n   using the I2bis and R2 messages.\n
      \  The peers' lists of locators are normally exchanged as part of the\n   context-establishment
      exchange.  But the set of locators might be\n   dynamic.  For this reason, there
      are Update Request and Update\n   Acknowledgement messages as well as a Locator
      List option.\n   Even when the list of locators is fixed, a host might determine
      that\n   some preferences might have changed.  For instance, it might\n   determine
      that there is a locally visible failure that implies that\n   some locator(s)
      are no longer usable.  This uses a Locator\n   Preferences option in the Update
      Request message.\n   The mechanism for (un)reachability detection is called
      Forced\n   Bidirectional Communication (FBD).  FBD uses a Keepalive message\n
      \  which is sent when a host has received packets from its peer but has\n   not
      yet sent any packets from its ULP to the peer.  The message type\n   is reserved
      in this document, but the message format and processing\n   rules are specified
      in [4].\n   In addition, when the context is established and there is a\n   subsequent
      failure, there needs to be a way to probe the set of\n   locator pairs to efficiently
      find a working pair.  This document\n   reserves a Probe message type, with
      the packet format and processing\n   rules specified in [4].\n   The above Probe
      and Keepalive messages assume we have an established\n   ULID-pair context.
      \ However, communication might fail during the\n   initial contact (that is,
      when the application or transport protocol\n   is trying to set up some communication).
      \ This is handled using the\n   mechanisms in the ULP to try different address
      pairs as specified in\n   [7] and [9].  In future versions of the protocol,
      and with a richer\n   API between the ULP and the shim, the shim might be able
      to help\n   optimize discovering a working locator pair during initial contact.\n
      \  This is for further study.\n"
    title: 4.5.  Overview of Shim Control Messages
  - contents:
    - "4.6.  Extension Header Order\n   Since the shim is placed between the IP endpoint
      sublayer and the IP\n   routing sublayer, the Shim header will be placed before
      any Endpoint\n   Extension headers (Fragmentation headers, Destination Options
      header,\n   AH, ESP) but after any routing-related headers (Hop-by-Hop Extensions\n
      \  header, Routing header, and a Destinations Options header, which\n   precedes
      a Routing header).  When tunneling is used, whether IP-in-IP\n   tunneling or
      the special form of tunneling that Mobile IPv6 uses\n   (with Home Address options
      and Routing header type 2), there is a\n   choice whether the shim applies inside
      the tunnel or outside the\n   tunnel, which affects the location of the Shim6
      header.\n   In most cases, IP-in-IP tunnels are used as a routing technique;\n
      \  thus, it makes sense to apply them on the locators, which means that\n   the
      sender would insert the Shim6 header after any IP-in-IP\n   encapsulation.  This
      is what occurs naturally when routers apply IP-\n   in-IP encapsulation.  Thus,
      the packets would have:\n   o  Outer IP header\n   o  Inner IP header\n   o
      \ Shim6 Extension header (if needed)\n   o  ULP\n   But the shim can also be
      used to create \"shimmed tunnels\", i.e.,\n   where an IP-in-IP tunnel uses
      the shim to be able to switch the\n   tunnel endpoint addresses between different
      locators.  In such a\n   case, the packets would have:\n   o  Outer IP header\n
      \  o  Shim6 Extension header (if needed)\n   o  Inner IP header\n   o  ULP\n
      \  In any case, the receiver behavior is well-defined; a receiver\n   processes
      the Extension headers in order.  However, the precise\n   interaction between
      Mobile IPv6 and Shim6 is for further study; it\n   might make sense to have
      Mobile IPv6 operate on locators as well,\n   meaning that the shim would be
      layered on top of the MIPv6 mechanism.\n"
    title: 4.6.  Extension Header Order
  title: 4.  Protocol Overview
- contents:
  - "5.  Message Formats\n   The Shim6 messages are all carried using a new IP protocol
    number\n   (140).  The Shim6 messages have a common header (defined below) with\n
    \  some fixed fields, followed by type-specific fields.\n   The Shim6 messages
    are structured as an IPv6 Extension header since\n   the Shim6 Payload Extension
    header is used to carry the ULP packets\n   after a locator switch.  The Shim6
    control messages use the same\n   extension header formats so that a single \"protocol
    number\" needs to\n   be allowed through firewalls in order for Shim6 to function
    across\n   the firewall.\n"
  - contents:
    - "5.1.  Common Shim6 Message Format\n   The first 17 bits of the Shim6 header
      is common for the Shim6 Payload\n   Extension header and for the control messages.
      \ It looks as follows:\n     0                   1\n     0 1 2 3 4 5 6 7 8 9
      0 1 2 3 4 5 6\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |  Next Header  |
      \ Hdr Ext Len  |P|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Fields:\n   Next
      Header:   The payload that follows this header.\n   Hdr Ext Len:   8-bit unsigned
      integer.  Length of the Shim6 header in\n                  8-octet units, not
      including the first 8 octets.\n   P:             A single bit to distinguish
      Shim6 Payload Extension\n                  headers from control messages.\n
      \  Shim6 signaling packets may not be larger than 1280 bytes, including\n   the
      IPv6 header and any intermediate headers between the IPv6 header\n   and the
      Shim6 header.  One way to meet this requirement is to omit\n   part of the locator
      address information if, with this information\n   included, the packet would
      become larger than 1280 bytes.  Another\n   option is to perform option engineering,
      dividing into different\n   Shim6 messages the information to be transmitted.
      \ An implementation\n   may impose administrative restrictions to avoid excessively
      large\n   Shim6 packets, such as a limitation on the number of locators to be\n
      \  used.\n"
    title: 5.1.  Common Shim6 Message Format
  - contents:
    - "5.2.  Shim6 Payload Extension Header Format\n   The Shim6 Payload Extension
      header is used to carry ULP packets where\n   the receiver must replace the
      content of the Source and/or\n   Destination fields in the IPv6 header before
      passing the packet to\n   the ULP.  Thus, this extension header is required
      when the locator\n   pair that is used is not the same as the ULID pair.\n     0
      \                  1                   2                   3\n     0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |  Next Header  |       0       |1|                             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                            |\n    |                      Receiver Context
      Tag                     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Fields:\n   Next Header:   The payload that follows this header.\n   Hdr
      Ext Len:   0 (since the header is 8 octets).\n   P:             Set to one.
      \ A single bit to distinguish this from the\n                  Shim6 control
      messages.\n   Receiver Context Tag:\n                  47-bit unsigned integer.
      \ Allocated by the receiver to\n                  identify the context.\n"
    title: 5.2.  Shim6 Payload Extension Header Format
  - contents:
    - "5.3.  Common Shim6 Control Header\n   The common part of the header has a Next
      Header field and a Header\n   Extension Length field that are consistent with
      the other IPv6\n   Extension headers, even if the Next Header value is always
      \"NO NEXT\n   HEADER\" for the control messages.\n   The Shim6 headers must
      be a multiple of 8 octets; hence, the minimum\n   size is 8 octets.\n   The
      common Shim6 Control message header is as follows:\n     0                   1
      \                  2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |  Next Header  |  Hdr Ext Len  |P|     Type    |Type-specific|S|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |            Checksum           |                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                              |\n    |                    Type-specific format
      \                      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Fields:\n   Next Header:   8-bit selector.  Normally set to NO_NXT_HDR (59).\n
      \  Hdr Ext Len:   8-bit unsigned integer.  Length of the Shim6 header in\n                  8-octet
      units, not including the first 8 octets.\n   P:             Set to zero.  A
      single bit to distinguish this from\n                  the Shim6 Payload Extension
      header.\n   Type:          7-bit unsigned integer.  Identifies the actual message\n
      \                 from the table below.  Type codes 0-63 will not\n                  trigger
      R1bis messages on a missing context, while\n                  codes 64-127 will
      trigger R1bis.\n   S:             A single bit set to zero that allows Shim6
      and HIP to\n                  have a common header format yet still distinguishes\n
      \                 between Shim6 and HIP messages.\n   Checksum:      16-bit
      unsigned integer.  The checksum is the 16-bit\n                  one's complement
      of the one's complement sum of the\n                  entire Shim6 header message,
      starting with the Shim6\n                  Next Header field and ending as indicated
      by the Hdr\n                  Ext Len.  Thus, when there is a payload following
      the\n                  Shim6 header, the payload is NOT included in the Shim6\n
      \                 checksum.  Note that, unlike protocols like ICMPv6,\n                  there
      is no pseudo-header checksum part of the\n                  checksum; this provides
      locator agility without having\n                  to change the checksum.\n
      \  Type-specific: Part of the message that is different for different\n                  message
      types.\n    +------------+----------------------------------------------------+\n
      \   | Type Value |                       Message                      |\n    +------------+----------------------------------------------------+\n
      \   |      1     |  I1 (1st establishment message from the initiator) |\n    |
      \     2     |  R1 (1st establishment message from the responder) |\n    |      3
      \    |  I2 (2nd establishment message from the initiator) |\n    |      4     |
      \ R2 (2nd establishment message from the responder) |\n    |      5     | R1bis
      (Reply to reference to non-existent context) |\n    |      6     |          I2bis
      (Reply to an R1bis message)         |\n    |     64     |                   Update
      Request                   |\n    |     65     |               Update Acknowledgement
      \              |\n    |     66     |                      Keepalive                     |\n
      \   |     67     |                    Probe Message                   |\n    |
      \    68     |                    Error Message                   |\n    +------------+----------------------------------------------------+\n
      \                                 Table 1\n"
    title: 5.3.  Common Shim6 Control Header
  - contents:
    - "5.4.  I1 Message Format\n   The I1 message is the first message in the context-establishment\n
      \  exchange.\n     0                   1                   2                   3\n
      \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |       59      |  Hdr Ext Len  |0|  Type = 1   |   Reserved1 |0|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |            Checksum           |R|                             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                            |\n    |                  Initiator Context Tag
      \                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                    Initiator Nonce                            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                                                               |\n    +
      \                        Options                               +\n    |                                                               |\n
      \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Fields:\n
      \  Next Header:   NO_NXT_HDR (59).\n   Hdr Ext Len:   At least 1, since the
      header is 16 octets when there\n                  are no options.\n   Type:
      \         1\n   Reserved1:     7-bit field.  Reserved for future use.  Zero
      on\n                  transmit.  MUST be ignored on receipt.\n   R:             1-bit
      field.  Reserved for future use.  Zero on\n                  transmit.  MUST
      be ignored on receipt.\n   Initiator Context Tag:\n                  47-bit
      field.  The Context Tag that the initiator has\n                  allocated
      for the context.\n   Initiator Nonce:\n                  32-bit unsigned integer.
      \ A random number picked by\n                  the initiator, which the responder
      will return in the\n                  R1 message.\n   The following options
      are defined for this message:\n   ULID pair:     When the IPv6 source and destination
      addresses in the\n                  IPv6 header does not match the ULID pair,
      this option\n                  MUST be included.  An example of this is when\n
      \                 recovering from a lost context.\n   Forked Instance Identifier:\n
      \                 When another instance of an existent context with the\n                  same
      ULID pair is being created, a Forked Instance\n                  Identifier
      option MUST be included to distinguish this\n                  new instance
      from the existent one.\n   Future protocol extensions might define additional
      options for this\n   message.  The C-bit in the option format defines how such
      a new\n   option will be handled by an implementation.  See Section 5.15.\n"
    title: 5.4.  I1 Message Format
  - contents:
    - "5.5.  R1 Message Format\n   The R1 message is the second message in the context-establishment\n
      \  exchange.  The responder sends this in response to an I1 message,\n   without
      creating any state specific to the initiator.\n     0                   1                   2
      \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |       59      |  Hdr Ext Len  |0|  Type = 2   |   Reserved1 |0|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |            Checksum           |           Reserved2           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                    Initiator Nonce                            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                    Responder Nonce                            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                                                               |\n    +
      \                        Options                               +\n    |                                                               |\n
      \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Fields:\n
      \  Next Header:   NO_NXT_HDR (59).\n   Hdr Ext Len:   At least 1, since the
      header is 16 octets when there\n                  are no options.\n   Type:
      \         2\n   Reserved1:     7-bit field.  Reserved for future use.  Zero
      on\n                  transmit.  MUST be ignored on receipt.\n   Reserved2:
      \    16-bit field.  Reserved for future use.  Zero on\n                  transmit.
      \ MUST be ignored on receipt.\n   Initiator Nonce:\n                  32-bit
      unsigned integer.  Copied from the I1 message.\n   Responder Nonce:\n                  32-bit
      unsigned integer.  A number picked by the\n                  responder, which
      the initiator will return in the I2\n                  message.\n   The following
      options are defined for this message:\n   Responder Validator:\n                  Variable
      length option.  This option MUST be included\n                  in the R1 message.
      \ Typically, it contains a hash\n                  generated by the responder,
      which the responder uses\n                  together with the Responder Nonce
      value to verify that\n                  an I2 message is indeed sent in response
      to an R1\n                  message, and that the parameters in the I2 message
      are\n                  the same as those in the I1 message.\n   Future protocol
      extensions might define additional options for this\n   message.  The C-bit
      in the option format defines how such a new\n   option will be handled by an
      implementation.  See Section 5.15.\n"
    title: 5.5.  R1 Message Format
  - contents:
    - "5.6.  I2 Message Format\n   The I2 message is the third message in the context-establishment\n
      \  exchange.  The initiator sends this in response to an R1 message,\n   after
      checking the Initiator Nonce, etc.\n     0                   1                   2
      \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |       59      |  Hdr Ext Len  |0|  Type = 3   |   Reserved1 |0|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |            Checksum           |R|                             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                            |\n    |                  Initiator Context Tag
      \                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                    Initiator Nonce                            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                    Responder Nonce                            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                       Reserved2                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                                                               |\n    +
      \                        Options                               +\n    |                                                               |\n
      \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Fields:\n
      \  Next Header:   NO_NXT_HDR (59).\n   Hdr Ext Len:   At least 2, since the
      header is 24 octets when there\n                  are no options.\n   Type:
      \         3\n   Reserved1:     7-bit field.  Reserved for future use.  Zero
      on\n                  transmit.  MUST be ignored on receipt.\n   R:             1-bit
      field.  Reserved for future use.  Zero on\n                  transmit.  MUST
      be ignored on receipt.\n   Initiator Context Tag:\n                  47-bit
      field.  The Context Tag that the initiator has\n                  allocated
      for the context.\n   Initiator Nonce:\n                  32-bit unsigned integer.
      \ A random number picked by\n                  the initiator, which the responder
      will return in the\n                  R2 message.\n   Responder Nonce:\n                  32-bit
      unsigned integer.  Copied from the R1 message.\n   Reserved2:     32-bit field.
      \ Reserved for future use.  Zero on\n                  transmit.  MUST be ignored
      on receipt.  (Needed to\n                  make the options start on a multiple
      of 8 octet\n                  boundary.)\n   The following options are defined
      for this message:\n   Responder Validator:\n                  Variable length
      option.  This option MUST be included\n                  in the I2 message and
      MUST be generated by copying the\n                  Responder Validator option
      received in the R1 message.\n   ULID pair:     When the IPv6 source and destination
      addresses in the\n                  IPv6 header do not match the ULID pair,
      this option\n                  MUST be included.  An example of this is when\n
      \                 recovering from a lost context.\n   Forked Instance Identifier:\n
      \                 When another instance of an existent context with the\n                  same
      ULID pair is being created, a Forked Instance\n                  Identifier
      option MUST be included to distinguish this\n                  new instance
      from the existent one.\n   Locator List:  Optionally sent when the initiator
      immediately wants\n                  to tell the responder its list of locators.
      \ When it\n                  is sent, the necessary HBA/CGA information for\n
      \                 verifying the locator list MUST also be included.\n   Locator
      Preferences:\n                  Optionally sent when the locators don't all
      have equal\n                  preference.\n   CGA Parameter Data Structure:\n
      \                 This option MUST be included in the I2 message when\n                  the
      locator list is included so the receiver can\n                  verify the locator
      list.\n   CGA Signature: This option MUST be included in the I2 message when\n
      \                 some of the locators in the list use CGA (and not HBA)\n                  for
      verification.\n   Future protocol extensions might define additional options
      for this\n   message.  The C-bit in the option format defines how such a new\n
      \  option will be handled by an implementation.  See Section 5.15.\n"
    title: 5.6.  I2 Message Format
  - contents:
    - "5.7.  R2 Message Format\n   The R2 message is the fourth message in the context-establishment\n
      \  exchange.  The responder sends this in response to an I2 message.\n   The
      R2 message is also used when both hosts send I1 messages at the\n   same time
      and the I1 messages cross in flight.\n     0                   1                   2
      \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |       59      |  Hdr Ext Len  |0|  Type = 4   |   Reserved1 |0|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |            Checksum           |R|                             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                            |\n    |                  Responder Context Tag
      \                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                    Initiator Nonce                            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                                                               |\n    +
      \                        Options                               +\n    |                                                               |\n
      \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Fields:\n
      \  Next Header:   NO_NXT_HDR (59).\n   Hdr Ext Len:   At least 1, since the
      header is 16 octets when there\n                  are no options.\n   Type:
      \         4\n   Reserved1:     7-bit field.  Reserved for future use.  Zero
      on\n                  transmit.  MUST be ignored on receipt.\n   R:             1-bit
      field.  Reserved for future use.  Zero on\n                  transmit.  MUST
      be ignored on receipt.\n   Responder Context Tag:\n                  47-bit
      field.  The Context Tag that the responder has\n                  allocated
      for the context.\n   Initiator Nonce:\n                  32-bit unsigned integer.
      \ Copied from the I2 message.\n   The following options are defined for this
      message:\n   Locator List:  Optionally sent when the responder immediately wants\n
      \                 to tell the initiator its list of locators.  When it\n                  is
      sent, the necessary HBA/CGA information for\n                  verifying the
      locator list MUST also be included.\n   Locator Preferences:\n                  Optionally
      sent when the locators don't all have equal\n                  preference.\n
      \  CGA Parameter Data Structure:\n                  Included when the locator
      list is included so the\n                  receiver can verify the locator list.\n
      \  CGA Signature: Included when some of the locators in the list use CGA\n                  (and
      not HBA) for verification.\n   Future protocol extensions might define additional
      options for this\n   message.  The C-bit in the option format defines how such
      a new\n   option will be handled by an implementation.  See Section 5.15.\n"
    title: 5.7.  R2 Message Format
  - contents:
    - "5.8.  R1bis Message Format\n   Should a host receive a packet with a Shim6
      Payload Extension header\n   or Shim6 control message with type code 64-127
      (such as an Update or\n   Probe message), and the host does not have any context
      state for the\n   received Context Tag, then it will generate a R1bis message.\n
      \  This message allows the sender of the packet referring to the non-\n   existent
      context to re-establish the context with a reduced context-\n   establishment
      exchange.  Upon the reception of the R1bis message, the\n   receiver can proceed
      with re-establishing the lost context by\n   directly sending an I2bis message.\n
      \    0                   1                   2                   3\n     0 1
      2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |       59      |  Hdr Ext Len  |0|  Type = 5   |   Reserved1 |0|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |            Checksum           |R|                             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                            |\n    |                     Packet Context Tag
      \                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                    Responder Nonce                            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                                                               |\n    +
      \                        Options                               +\n    |                                                               |\n
      \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Fields:\n
      \  Next Header:   NO_NXT_HDR (59).\n   Hdr Ext Len:   At least 1, since the
      header is 16 octets when there\n                  are no options.\n   Type:
      \         5\n   Reserved1:     7-bit field.  Reserved for future use.  Zero
      on\n                  transmit.  MUST be ignored on receipt.\n   R:             1-bit
      field.  Reserved for future use.  Zero on\n                  transmit.  MUST
      be ignored on receipt.\n   Packet Context Tag:\n                  47-bit unsigned
      integer.  The Context Tag contained in\n                  the received packet
      that triggered the generation of\n                  the R1bis message.\n   Responder
      Nonce:\n                  32-bit unsigned integer.  A number picked by the\n
      \                 responder which the initiator will return in the I2bis\n                  message.\n
      \  The following options are defined for this message:\n   Responder Validator:\n
      \                 Variable length option.  Typically, a hash generated\n                  by
      the responder, which the responder uses together\n                  with the
      Responder Nonce value to verify that an I2bis\n                  message is
      indeed sent in response to an R1bis\n                  message.\n   Future protocol
      extensions might define additional options for this\n   message.  The C-bit
      in the option format defines how such a new\n   option will be handled by an
      implementation.  See Section 5.15.\n"
    title: 5.8.  R1bis Message Format
  - contents:
    - "5.9.  I2bis Message Format\n   The I2bis message is the third message in the
      context-recovery\n   exchange.  This is sent in response to an R1bis message,
      after\n   checking that the R1bis message refers to an existing context, etc.\n
      \    0                   1                   2                   3\n     0 1
      2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |       59      |  Hdr Ext Len  |0|  Type = 6  |   Reserved1 |0|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |            Checksum           |R|                             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                            |\n    |                  Initiator Context Tag
      \                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                    Initiator Nonce                            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                    Responder Nonce                            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                       Reserved2                               |\n    |
      \                                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |                                 |
      \                            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                             |\n
      \   |                     Packet Context Tag                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                                                               |\n    +
      \                        Options                               +\n    |                                                               |\n
      \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Fields:\n
      \  Next Header:   NO_NXT_HDR (59).\n   Hdr Ext Len:   At least 3, since the
      header is 32 octets when there\n                  are no options.\n   Type:
      \         6\n   Reserved1:     7-bit field.  Reserved for future use.  Zero
      on\n                  transmit.  MUST be ignored on receipt.\n   R:             1-bit
      field.  Reserved for future use.  Zero on\n                  transmit.  MUST
      be ignored on receipt.\n   Initiator Context Tag:\n                  47-bit
      field.  The Context Tag that the initiator has\n                  allocated
      for the context.\n   Initiator Nonce:\n                  32-bit unsigned integer.
      \ A random number picked by\n                  the initiator, which the responder
      will return in the\n                  R2 message.\n   Responder Nonce:\n                  32-bit
      unsigned integer.  Copied from the R1bis\n                  message.\n   Reserved2:
      \    49-bit field.  Reserved for future use.  Zero on\n                  transmit.
      \ MUST be ignored on receipt.  (Note that 17\n                  bits are not
      sufficient since the options need to\n                  start on a multiple-of-8-octet
      boundary.)\n   Packet Context Tag:\n                  47-bit unsigned integer.
      \ Copied from the Packet\n                  Context Tag field contained in the
      received R1bis.\n   The following options are defined for this message:\n   Responder
      Validator:\n                  Variable length option.  Just a copy of the Responder\n
      \                 Validator option in the R1bis message.\n   ULID pair:     When
      the IPv6 source and destination addresses in the\n                  IPv6 header
      do not match the ULID pair, this option\n                  MUST be included.\n
      \  Forked Instance Identifier:\n                  When another instance of an
      existent context with the\n                  same ULID pair is being created,
      a Forked Instance\n                  Identifier option is included to distinguish
      this new\n                  instance from the existent one.\n   Locator List:
      \ Optionally sent when the initiator immediately wants\n                  to
      tell the responder its list of locators.  When it\n                  is sent,
      the necessary HBA/CGA information for\n                  verifying the locator
      list MUST also be included.\n   Locator Preferences:\n                  Optionally
      sent when the locators don't all have equal\n                  preference.\n
      \  CGA Parameter Data Structure:\n                  Included when the locator
      list is included so the\n                  receiver can verify the locator list.\n
      \  CGA Signature: Included when some of the locators in the list use CGA\n                  (and
      not HBA) for verification.\n   Future protocol extensions might define additional
      options for this\n   message.  The C-bit in the option format defines how such
      a new\n   option will be handled by an implementation.  See Section 5.15.\n"
    title: 5.9.  I2bis Message Format
  - contents:
    - "5.10.  Update Request Message Format\n   The Update Request message is used
      to update either the list of\n   locators, the locator preferences, or both.
      \ When the list of\n   locators is updated, the message also contains the option(s)\n
      \  necessary for HBA/CGA to secure this.  The basic sanity check that\n   prevents
      off-path attackers from generating bogus updates is the\n   Context Tag in the
      message.\n   The Update Request message contains options (the Locator List and
      the\n   Locator Preferences) that, when included, completely replace the\n   previous
      locator list and locator preferences, respectively.  Thus,\n   there is no mechanism
      to just send deltas to the locator list.\n     0                   1                   2
      \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |       59      |  Hdr Ext Len  |0|  Type = 64  |   Reserved1 |0|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |            Checksum           |R|                             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                            |\n    |                   Receiver Context Tag
      \                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                    Request Nonce                              |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                                                               |\n    +
      \                        Options                               +\n    |                                                               |\n
      \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Fields:\n
      \  Next Header:   NO_NXT_HDR (59).\n   Hdr Ext Len:   At least 1, since the
      header is 16 octets when there\n                  are no options.\n   Type:
      \         64\n   Reserved1:     7-bit field.  Reserved for future use.  Zero
      on\n                  transmit.  MUST be ignored on receipt.\n   R:             1-bit
      field.  Reserved for future use.  Zero on\n                  transmit.  MUST
      be ignored on receipt.\n   Receiver Context Tag:\n                  47-bit field.
      \ The Context Tag that the receiver has\n                  allocated for the
      context.\n   Request Nonce:\n                  32-bit unsigned integer.  A random
      number picked by\n                  the initiator, which the peer will return
      in the\n                  Update Acknowledgement message.\n   The following
      options are defined for this message:\n   Locator List:  The list of the sender's
      (new) locators.  The locators\n                  might be unchanged and only
      the preferences have\n                  changed.\n   Locator Preferences:\n
      \                 Optionally sent when the locators don't all have equal\n                  preference.\n
      \  CGA Parameter Data Structure (PDS):\n                  Included when the
      locator list is included and the PDS\n                  was not included in
      the I2/ I2bis/R2 messages, so the\n                  receiver can verify the
      locator list.\n   CGA Signature: Included when some of the locators in the list
      use CGA\n                  (and not HBA) for verification.\n   Future protocol
      extensions might define additional options for this\n   message.  The C-bit
      in the option format defines how such a new\n   option will be handled by an
      implementation.  See Section 5.15.\n"
    title: 5.10.  Update Request Message Format
  - contents:
    - "5.11.  Update Acknowledgement Message Format\n   This message is sent in response
      to an Update Request message.  It\n   implies that the Update Request has been
      received and that any new\n   locators in the Update Request can now be used
      as the source locators\n   of packets.  But it does not imply that the (new)
      locators have been\n   verified to be used as a destination, since the host
      might defer the\n   verification of a locator until it sees a need to use a
      locator as\n   the destination.\n     0                   1                   2
      \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |       59      |  Hdr Ext Len  |0|  Type = 65  |   Reserved1 |0|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |            Checksum           |R|                             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                            |\n    |                   Receiver Context Tag
      \                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                      Request Nonce                            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                                                               |\n    +
      \                        Options                               +\n    |                                                               |\n
      \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Fields:\n
      \  Next Header:   NO_NXT_HDR (59).\n   Hdr Ext Len:   At least 1, since the
      header is 16 octets when there\n                  are no options.\n   Type:
      \         65\n   Reserved1:     7-bit field.  Reserved for future use.  Zero
      on\n                  transmit.  MUST be ignored on receipt.\n   R:             1-bit
      field.  Reserved for future use.  Zero on\n                  transmit.  MUST
      be ignored on receipt.\n   Receiver Context Tag:\n                  47-bit field.
      \ The Context Tag the receiver has\n                  allocated for the context.\n
      \  Request Nonce: 32-bit unsigned integer.  Copied from the Update\n                  Request
      message.\n   No options are currently defined for this message.\n   Future protocol
      extensions might define additional options for this\n   message.  The C-bit
      in the option format defines how such a new\n   option will be handled by an
      implementation.  See Section 5.15.\n"
    title: 5.11.  Update Acknowledgement Message Format
  - contents:
    - "5.12.  Keepalive Message Format\n   This message format is defined in [4].\n
      \  The message is used to ensure that when a peer is sending ULP packets\n   on
      a context, it always receives some packets in the reverse\n   direction.  When
      the ULP is sending bidirectional traffic, no extra\n   packets need to be inserted.
      \ But for a unidirectional ULP traffic\n   pattern, the shim will send back
      some Keepalive messages when it is\n   receiving ULP packets.\n"
    title: 5.12.  Keepalive Message Format
  - contents:
    - "5.13.  Probe Message Format\n   This message and its semantics are defined
      in [4].\n   The goal of this mechanism is to test whether or not locator pairs\n
      \  work in the general case.  In particular, this mechanism is to be\n   able
      to handle the case when one locator pair works from A to B and\n   another locator
      pair works from B to A, but there is no locator pair\n   that works in both
      directions.  The protocol mechanism is that, as A\n   is sending Probe messages
      to B, B will observe which locator pairs it\n   has received and report that
      back in Probe messages it sends to A.\n"
    title: 5.13.  Probe Message Format
  - contents:
    - "5.14.  Error Message Format\n   The Error message is generated by a Shim6 receiver
      upon the reception\n   of a Shim6 message containing critical information that
      cannot be\n   processed properly.\n   In the case that a Shim6 node receives
      a Shim6 packet that contains\n   information that is critical for the Shim6
      protocol and that is not\n   supported by the receiver, it sends an Error Message
      back to the\n   originator of the Shim6 message.  The Error message is\n   unacknowledged.\n
      \  In addition, Shim6 Error messages defined in this section can be used\n   to
      identify problems with Shim6 implementations.  In order to do so,\n   a range
      of Error Code types is reserved for that purpose.  In\n   particular, implementations
      may generate Shim6 Error messages with\n   Code types in that range, instead
      of silently discarding Shim6\n   packets during the debugging process.\n     0
      \                  1                   2                   3\n     0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |       59      |  Hdr Ext Len  |0|  Type = 68  |  Error Code |0|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |            Checksum           |            Pointer            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                                                               |\n    +
      \                        Packet in error                       +\n    |                                                               |\n
      \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Fields:\n
      \  Next Header:   NO_NXT_HDR (59).\n   Hdr Ext Len:   At least 1, since the
      header is 16 octets.  Depends on\n                  the specific Error Data.\n
      \  Type:          68\n   Error Code:    7-bit field describing the error that
      generated the\n                  Error message.  See Error Code list below.\n
      \  Pointer:       16-bit field.  Identifies the octet offset within the\n                  invoking
      packet where the error was detected.\n   Packet in error:\n                  As
      much of invoking packet as possible without the\n                  Error message
      packet exceeding the minimum IPv6 MTU.\n   The following Error Codes are defined:\n
      \  +---------+---------------------------------------------------------+\n   |
      \  Code  |                       Description                       |\n   |  Value
      \ |                                                         |\n   +---------+---------------------------------------------------------+\n
      \  |    0    |                Unknown Shim6 message type               |\n   |
      \   1    |              Critical option not recognized             |\n   |    2
      \   |    Locator verification method failed (Pointer to the   |\n   |         |
      \        inconsistent verification method octet)         |\n   |    3    |       Locator
      List Generation number out of sync.       |\n   |    4    | Error in the number
      of locators in a Locator Preference |\n   |         |                          option
      \                        |\n   | 120-127 |             Reserved for debugging
      purposes             |\n   +---------+---------------------------------------------------------+\n
      \                                 Table 2\n"
    title: 5.14.  Error Message Format
  - contents:
    - "5.15.  Option Formats\n   The format of the options is a snapshot of the current
      HIP option\n   format [20].  However, there is no intention to track any changes
      to\n   the HIP option format, nor is there an intent to use the same name\n
      \  space for the option type values.  But using the same format will\n   hopefully
      make it easier to import HIP capabilities into Shim6 as\n   extensions to Shim6,
      should this turn out to be useful.\n   All of the TLV parameters have a length
      (including Type and Length\n   fields) that is a multiple of 8 bytes.  When
      needed, padding MUST be\n   added to the end of the parameter so that the total
      length becomes a\n   multiple of 8 bytes.  This rule ensures proper alignment
      of data.  If\n   padding is added, the Length field MUST NOT include the padding.
      \ Any\n   added padding bytes MUST be zeroed by the sender, and their values\n
      \  SHOULD NOT be checked by the receiver.\n   Consequently, the Length field
      indicates the length of the Contents\n   field (in bytes).  The total length
      of the TLV parameter (including\n   Type, Length, Contents, and Padding) is
      related to the Length field\n   according to the following formula:\n   Total
      Length = 11 + Length - (Length + 3) mod 8;\n   The total length of the option
      is the smallest multiple of 8 bytes\n   that allows for the 4 bytes of the Option
      header and option, itself.\n   The amount of padding required can be calculated
      as follows:\n   padding = 7 - ((Length + 3) mod 8)\n   And:\n   Total Length
      = 4 + Length + padding\n     0                   1                   2                   3\n
      \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |             Type            |C|             Length            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   ~                                                               ~\n    ~
      \                         Contents                             ~\n    ~                                               +-+-+-+-+-+-+-+-+\n
      \   ~                                               |    Padding    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Fields:\n   Type:          15-bit identifier of the type of option.  The
      options\n                  defined in this document are below.\n   C:             Critical.
      \ One, if this parameter is critical and MUST\n                  be recognized
      by the recipient; zero otherwise.  An\n                  implementation might
      view the C-bit as part of the\n                  Type field by multiplying the
      type values in this\n                  specification by two.\n   Length:        Length
      of the Contents, in bytes.\n   Contents:      Parameter-specific, defined by
      Type.\n   Padding:       Padding, 0-7 bytes, added if needed.\n                  +------+------------------------------+\n
      \                 | Type |          Option Name         |\n                  +------+------------------------------+\n
      \                 |   1  |      Responder Validator     |\n                  |
      \  2  |         Locator List         |\n                  |   3  |      Locator
      Preferences     |\n                  |   4  | CGA Parameter Data Structure |\n
      \                 |   5  |         CGA Signature        |\n                  |
      \  6  |           ULID Pair          |\n                  |   7  |  Forked Instance
      Identifier  |\n                  |  10  |   Keepalive Timeout Option   |\n                  +------+------------------------------+\n
      \                                 Table 3\n   Future protocol extensions might
      define additional options for the\n   Shim6 messages.  The C-bit in the option
      format defines how such a\n   new option will be handled by an implementation.\n
      \  If a host receives an option that it does not understand (an option\n   that
      was defined in some future extension to this protocol) or that\n   is not listed
      as a valid option for the different message types\n   above, then the Critical
      bit in the option determines the outcome.\n   o  If C=0, then the option is
      silently ignored, and the rest of the\n      message is processed.\n   o  If
      C=1, then the host SHOULD send back a Shim6 Error message with\n      Error
      Code=1, with the Pointer field referencing the first octet\n      in the Option
      Type field.  When C=1, the rest of the message MUST\n      NOT be processed.\n"
    - contents:
      - "5.15.1.  Responder Validator Option Format\n   The responder can choose exactly
        what input is used to compute the\n   validator and what one-way function
        (such as MD5 or SHA1) it uses, as\n   long as the responder can check that
        the validator it receives back\n   in the I2 or I2bis message is indeed one
        that:\n   1) computed,\n   2) computed for the particular context, and\n   3)
        isn't a replayed I2/I2bis message.\n   Some suggestions on how to generate
        the validators are captured in\n   Sections 7.10.1 and 7.17.1.\n     0                   1
        \                  2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |           Type = 1          |0|            Length             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ~                           Validator                           ~\n    ~
        \                                              +-+-+-+-+-+-+-+-+\n    ~                                               |
        \   Padding    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Fields:\n   Validator:     Variable length content whose interpretation
        is local\n                  to the responder.\n   Padding:       Padding,
        0-7 bytes, added if needed.  See\n                  Section 5.15.\n"
      title: 5.15.1.  Responder Validator Option Format
    - contents:
      - "5.15.2.  Locator List Option Format\n   The Locator List option is used to
        carry all the locators of the\n   sender.  Note that the order of the locators
        is important, since the\n   Locator Preferences option refers to the locators
        by using the index\n   in the list.\n   Note that we carry all the locators
        in this option even though some\n   of them can be created automatically from
        the CGA Parameter Data\n   Structure.\n     0                   1                   2
        \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |           Type = 2          |0|            Length             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Locator List Generation                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Num Locators |            N Octets of Verification Method    |\n    +-+-+-+-+-+-+-+-+
        \                                              |\n    ~                                                               ~\n
        \   ~                                               +-+-+-+-+-+-+-+-+\n    ~
        \                                              |    Padding    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ~                     Locators 1 through N                      ~\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Fields:\n   Locator List Generation:\n                  32-bit unsigned
        integer.  Indicates a generation\n                  number that is increased
        by one for each new locator\n                  list.  This is used to ensure
        that the index in the\n                  Locator Preferences refers to the
        right version of the\n                  locator list.\n   Num Locators:  8-bit
        unsigned integer.  The number of locators that\n                  are included
        in the option.  We call this number \"N\"\n                  below.\n   Verification
        Method:\n                  N octets.  The ith octet specifies the verification\n
        \                 method for the ith locator.\n   Padding:       Padding,
        0-7 bytes, added if needed so that the\n                  Locators start on
        a multiple-of-8-octet boundary.\n                  Note that for this option,
        there is never a need to\n                  pad at the end since the Locators
        are a multiple-of-8-\n                  octets in length.  This internal padding
        is included\n                  in the Length field.\n   Locators:      N 128-bit
        locators.\n   The defined verification methods are:\n              +---------+----------------------------------+\n
        \             |  Value  |              Method              |\n              +---------+----------------------------------+\n
        \             |    0    |             Reserved             |\n              |
        \   1    |                HBA               |\n              |    2    |                CGA
        \              |\n              |  3-200  | Allocated using Standards action
        |\n              | 201-254 |         Experimental use         |\n              |
        \  255   |             Reserved             |\n              +---------+----------------------------------+\n
        \                                 Table 4\n"
      title: 5.15.2.  Locator List Option Format
    - contents:
      - "5.15.3.  Locator Preferences Option Format\n   The Locator Preferences option
        can have some flags to indicate\n   whether or not a locator is known to work.
        \ In addition, the sender\n   can include a notion of preferences.  It might
        make sense to define\n   \"preferences\" as a combination of priority and
        weight, the same way\n   that DNS SRV records have such information.  The
        priority would\n   provide a way to rank the locators, and, within a given
        priority, the\n   weight would provide a way to do some load sharing.  See
        [5] for how\n   SRV defines the interaction of priority and weight.\n   The
        minimum notion of preferences we need is to be able to indicate\n   that a
        locator is \"dead\".  We can handle this using a single octet\n   flag for
        each locator.\n   We can extend that by carrying a larger \"element\" for
        each locator.\n   This document presently also defines 2-octet and 3-octet
        elements,\n   and we can add more information by having even larger elements
        if\n   need be.\n   The locators are not included in the preference list.
        \ Instead, the\n   first element refers to the locator that was in the first
        element in\n   the Locator List option.  The generation number carried in
        this\n   option and the Locator List option is used to verify that they refer\n
        \  to the same version of the locator list.\n     0                   1                   2
        \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |           Type = 3          |0|            Length             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                     Locator List Generation                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |  Element Len  |  Element[1]   |  Element[2]   |  Element[3]   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ~                              ...                              ~\n    ~
        \                                              +-+-+-+-+-+-+-+-+\n    ~                                               |
        \   Padding    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Case of Element Len = 1 is depicted.\n   Fields:\n   Locator List Generation:\n
        \                 32-bit unsigned integer.  Indicates a generation\n                  number
        for the locator list to which the elements\n                  should apply.\n
        \  Element Len:   8-bit unsigned integer.  The length in octets of each\n
        \                 element.  This specification defines the cases when\n                  the
        length is 1, 2, or 3.\n   Element[i]:    A field with a number of octets defined
        by the Element\n                  Len field.  Provides preferences for the
        ith locator\n                  in the Locator List option that is in use.\n
        \  Padding:       Padding, 0-7 bytes, added if needed.  See\n                  Section
        5.15.\n   When the Element length equals one, then the element consists of
        only\n   a one-octet Flags field.  The currently defined set of flags are:\n
        \     BROKEN: 0x01\n      TRANSIENT: 0x02\n   The intent of the BROKEN flag
        is to inform the peer that a given\n   locator is known to be not working.
        \ The intent of TRANSIENT is to\n   allow the distinction between more stable
        addresses and less stable\n   addresses when Shim6 is combined with IP mobility,
        and when we might\n   have more stable home locators and less stable care-of-locators.\n
        \  When the Element length equals two, then the element consists of a\n   one-octet
        Flags field followed by a one-octet Priority field.  This\n   Priority field
        has the same semantics as the Priority field in DNS\n   SRV records.\n   When
        the Element length equals three, then the element consists of a\n   one-octet
        Flags field followed by a one-octet Priority field and a\n   one-octet Weight
        field.  This Weight field has the same semantics as\n   the Weight field in
        DNS SRV records.\n   This document doesn't specify the format when the Element
        length is\n   more than three, except that any such formats MUST be defined
        so that\n   the first three octets are the same as in the above case, that
        is, a\n   one-octet Flags field followed by a one-octet Priority field, and
        a\n   one-octet Weight field.\n"
      title: 5.15.3.  Locator Preferences Option Format
    - contents:
      - "5.15.4.  CGA Parameter Data Structure Option Format\n   This option contains
        the CGA Parameter Data Structure (PDS).  When\n   HBA is used to verify the
        locators, the PDS contains the HBA\n   multiprefix extension in addition to
        the PDS mandatory fields and\n   other extensions unrelated to Shim6 that
        the PDS might have.  When\n   CGA is used to verify the locators, in addition
        to the PDS option,\n   the host also needs to include the signature in the
        form of a CGA\n   Signature option.\n     0                   1                   2
        \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |           Type = 4          |0|            Length             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ~                   CGA Parameter Data Structure                ~\n    ~
        \                                              +-+-+-+-+-+-+-+-+\n    ~                                               |
        \   Padding    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Fields:\n   CGA Parameter Data Structure:\n                  Variable length
        content.  Content defined in [2] and\n                  [3].\n   Padding:
        \      Padding, 0-7 bytes, added if needed.  See\n                  Section
        5.15.\n"
      title: 5.15.4.  CGA Parameter Data Structure Option Format
    - contents:
      - "5.15.5.  CGA Signature Option Format\n   When CGA is used for verification
        of one or more of the locators in\n   the Locator List option, then the message
        in question will need to\n   contain this option.\n     0                   1
        \                  2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |           Type = 5          |0|            Length             |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   ~                        CGA Signature                          ~\n    ~
        \                                              +-+-+-+-+-+-+-+-+\n    ~                                               |
        \   Padding    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Fields:\n   CGA Signature: A variable-length field containing a PKCS#1
        v1.5\n                  signature, constructed by using the sender's private\n
        \                 key over the following sequence of octets:\n                  1.
        \ The 128-bit CGA Message Type tag [CGA] value for\n                      Shim6:
        0x4A 30 5662 4858 574B 3655 416F 506A 6D48.\n                      (The tag
        value has been generated randomly by the\n                      editor of
        this specification.).\n                  2.  The Locator List Generation number
        of the\n                      correspondent Locator List option.\n                  3.
        \ The subset of locators included in the\n                      correspondent
        Locator List option whose\n                      verification method is set
        to CGA.  The locators\n                      MUST be included in the order
        in which they are\n                      listed in the Locator List Option.\n
        \  Padding:       Padding, 0-7 bytes, added if needed.  See\n                  Section
        5.15.\n"
      title: 5.15.5.  CGA Signature Option Format
    - contents:
      - "5.15.6.  ULID Pair Option Format\n   I1, I2, and I2bis messages MUST contain
        the ULID pair; normally, this\n   is in the IPv6 Source and Destination fields.
        \ In case the ULID for\n   the context differs from the address pair included
        in the Source and\n   Destination Address fields of the IPv6 packet used to
        carry the I1/\n   I2/I2bis message, the ULID Pair option MUST be included
        in the I1/I2/\n   I2bis message.\n     0                   1                   2
        \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |           Type = 6          |0|        Length = 36            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                       Reserved2                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                                                               |\n    +
        \                        Sender ULID                           +\n    |                                                               |\n
        \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |
        \                                                              |\n    +                        Receiver
        ULID                          +\n    |                                                               |\n
        \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Fields:\n
        \  Reserved2:     32-bit field.  Reserved for future use.  Zero on\n                  transmit.
        \ MUST be ignored on receipt.  (Needed to\n                  make the ULIDs
        start on a multiple-of-8-octet\n                  boundary.)\n   Sender ULID:
        \  A 128-bit IPv6 address.\n   Receiver ULID: A 128-bit IPv6 address.\n"
      title: 5.15.6.  ULID Pair Option Format
    - contents:
      - "5.15.7.  Forked Instance Identifier Option Format\n     0                   1
        \                  2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |           Type = 7          |0|         Length = 4            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   |                  Forked Instance Identifier                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Fields:\n   Forked Instance Identifier:\n                  32-bit field
        containing the identifier of the\n                  particular forked instance.\n"
      title: 5.15.7.  Forked Instance Identifier Option Format
    - contents:
      - "5.15.8.  Keepalive Timeout Option Format\n   This option is defined in [4].\n"
      title: 5.15.8.  Keepalive Timeout Option Format
    title: 5.15.  Option Formats
  title: 5.  Message Formats
- contents:
  - "6.  Conceptual Model of a Host\n   This section describes a conceptual model
    of one possible data\n   structure organization that hosts will maintain for the
    purposes of\n   Shim6.  The described organization is provided to facilitate the\n
    \  explanation of how the Shim6 protocol should behave.  This document\n   does
    not mandate that implementations adhere to this model as long as\n   their external
    behavior is consistent with that described in this\n   document.\n"
  - contents:
    - "6.1.  Conceptual Data Structures\n   The key conceptual data structure for
      the Shim6 protocol is the ULID-\n   pair context.  This is a data structure
      that contains the following\n   information:\n   o  The state of the context.
      \ See Section 6.2.\n   o  The peer ULID: ULID(peer).\n   o  The local ULID:
      ULID(local).\n   o  The Forked Instance Identifier: FII.  This is zero for the
      default\n      context, i.e., when there is no forking.\n   o  The list of peer
      locators with their preferences: Ls(peer).\n   o  The generation number for
      the most recently received, verified\n      peer locator list.\n   o  For each
      peer locator, the verification method to use (from the\n      Locator List option).\n
      \  o  For each peer locator, a flag specifying whether it has been\n      verified
      using HBA or CGA, and a bit specifying whether the\n      locator has been probed
      to verify that the ULID is present at that\n      location.\n   o  The current
      peer locator is the locator used as the destination\n      address when sending
      packets: Lp(peer).\n   o  The set of local locators and the preferences: Ls(local).\n
      \  o  The generation number for the most recently sent Locator List\n      option.\n
      \  o  The current local locator is the locator used as the source\n      address
      when sending packets: Lp(local).\n   o  The Context Tag used to transmit control
      messages and Shim6\n      Payload Extension headers; this is allocated by the
      peer:\n      CT(peer).\n   o  The context to expect in received control messages
      and Shim6\n      Payload Extension headers; this is allocated by the local host:\n
      \     CT(local).\n   o  Timers for retransmission of the messages during context-\n
      \     establishment and update messages.\n   o  Depending how an implementation
      determines whether a context is\n      still in use, there might be a need to
      track the last time a\n      packet was sent/received using the context.\n   o
      \ Reachability state for the locator pairs as specified in [4].\n   o  During
      pair exploration, information about the Probe messages that\n      have been
      sent and received as specified in [4].\n   o  During context-establishment phase,
      the Initiator Nonce, Responder\n      Nonce, Responder Validator, and timers
      related to the different\n      packets sent (I1,I2, R2), as described in Section
      7.\n"
    title: 6.1.  Conceptual Data Structures
  - contents:
    - "6.2.  Context STATES\n   The STATES that are used to describe the Shim6 protocol
      are as\n   follows:\n   +---------------------+---------------------------------------------+\n
      \  | STATE               | Explanation                                 |\n   +---------------------+---------------------------------------------+\n
      \  | IDLE                | State machine start                         |\n   |
      \                    |                                             |\n   | I1-SENT
      \            | Initiating context-establishment exchange   |\n   |                     |
      \                                            |\n   | I2-SENT             | Waiting
      to complete context-establishment   |\n   |                     | exchange                                    |\n
      \  |                     |                                             |\n   |
      I2BIS-SENT          | Potential context loss detected             |\n   |                     |
      \                                            |\n   | ESTABLISHED         | SHIM
      context established                    |\n   |                     |                                             |\n
      \  | E-FAILED            | Context-establishment exchange failed       |\n   |
      \                    |                                             |\n   | NO-SUPPORT
      \         | ICMP Unrecognized Next Header type          |\n   |                     |
      (type 4, code 1) received, indicating       |\n   |                     | that
      Shim6 is not supported                 |\n   +---------------------+---------------------------------------------+\n
      \  In addition, in each of the aforementioned STATES, the following\n   state
      information is stored:\n   +---------------------+---------------------------------------------+\n
      \  | STATE               | Information                                 |\n   +---------------------+---------------------------------------------+\n
      \  | IDLE                | None                                        |\n   |
      \                    |                                             |\n   | I1-SENT
      \            | ULID(peer), ULID(local), [FII], CT(local),  |\n   |                     |
      INIT Nonce, Lp(local), Lp(peer), Ls(local)  |\n   |                     |                                             |\n
      \  | I2-SENT             | ULID(peer), ULID(local), [FII], CT(local),  |\n   |
      \                    | INIT Nonce, RESP Nonce, Lp(local), Lp(peer),|\n   |                     |
      Ls(local), Responder Validator              |\n   |                     |                                             |\n
      \  | ESTABLISHED         | ULID(peer), ULID(local), [FII], CT(local),  |\n   |
      \                    | CT(peer), Lp(local), Lp(peer), Ls(local),   |\n   |                     |
      Ls(peer), INIT Nonce?(to receive late R2)   |\n   |                     |                                             |\n
      \  | I2BIS-SENT          | ULID(peer), ULID(local), [FII], CT(local),  |\n   |
      \                    | CT(peer), Lp(local), Lp(peer), Ls(local),   |\n   |                     |
      Ls(peer), CT(R1bis), RESP Nonce,            |\n   |                     | INIT
      Nonce, Responder Validator             |\n   |                     |                                             |\n
      \  | E-FAILED            | ULID(peer), ULID(local)                     |\n   |
      \                    |                                             |\n   | NO-SUPPORT
      \         | ULID(peer), ULID(local)                     |\n   +---------------------+---------------------------------------------+\n"
    title: 6.2.  Context STATES
  title: 6.  Conceptual Model of a Host
- contents:
  - "7.  Establishing ULID-Pair Contexts\n   ULID-pair contexts are established using
    a 4-way exchange, which\n   allows the responder to avoid creating state on the
    first packet.  As\n   part of this exchange, each end allocates a Context Tag
    and shares\n   this Context Tag and its set of locators with the peer.\n   In
    some cases, the 4-way exchange is not necessary -- for instance,\n   when both
    ends try to set up the context at the same time, or when\n   recovering from a
    context that has been garbage collected or lost at\n   one of the hosts.\n"
  - contents:
    - "7.1.  Uniqueness of Context Tags\n   As part of establishing a new context,
      each host has to assign a\n   unique Context Tag.  Since the Shim6 Payload Extension
      headers are\n   demultiplexed based solely on the Context Tag value (without
      using\n   the locators), the Context Tag MUST be unique for each context.\n
      \  It is important that Context Tags are hard to guess for off-path\n   attackers.
      \ Therefore, if an implementation uses structure in the\n   Context Tag to facilitate
      efficient lookups, at least 30 bits of the\n   Context Tag MUST be unstructured
      and populated by random or pseudo-\n   random bits.\n   In addition, in order
      to minimize the reuse of Context Tags, the host\n   SHOULD randomly cycle through
      the unstructured tag name space that is\n   reserved for randomly assigned Context
      Tag values (e.g., following\n   the guidelines described in [13]).\n"
    title: 7.1.  Uniqueness of Context Tags
  - contents:
    - "7.2.  Locator Verification\n   The peer's locators might need to be verified
      during context\n   establishment as well as when handling locator updates in
      Section 10.\n   There are two separate aspects of locator verification.  One
      is to\n   verify that the locator is tied to the ULID, i.e., that the host that\n
      \  \"owns\" the ULID is also the one that is claiming the locator\n   \"ownership\".
      \ The Shim6 protocol uses the HBA or CGA techniques for\n   doing this verification.
      \ The other aspect is to verify that the host\n   is indeed reachable at the
      claimed locator.  Such verification is\n   needed not only to make sure communication
      can proceed but also to\n   prevent 3rd party flooding attacks [15].  These
      different aspects of\n   locator verification happen at different times since
      the first might\n   need to be performed before packets can be received by the
      peer with\n   the source locator in question, but the latter verification is
      only\n   needed before packets are sent to the locator.\n   Before a host can
      use a locator (different than the ULID) as the\n   source locator, it must know
      that the peer will accept packets with\n   that source locator as part of this
      context.  Thus, the HBA/CGA\n   verification SHOULD be performed by the host
      before the host\n   acknowledges the new locator by sending either an Update\n
      \  Acknowledgement message or an R2 message.\n   Before a host can use a locator
      (different than the ULID) as the\n   destination locator, it MUST perform the
      HBA/CGA verification if this\n   was not performed upon reception of the locator
      set.  In addition, it\n   MUST verify that the ULID is indeed present at that
      locator.  This\n   verification is performed by doing a return-routability test
      as part\n   of the Probe sub-protocol [4].\n   If the verification method in
      the Locator List option is not\n   supported by the host, or if the verification
      method is not\n   consistent with the CGA Parameter Data Structure (e.g., the
      Parameter\n   Data Structure doesn't contain the multiprefix extension and the\n
      \  verification method says to use HBA), then the host MUST ignore the\n   Locator
      List and the message in which it is contained.  The host\n   SHOULD generate
      a Shim6 Error message with Error Code=2 and with the\n   Pointer referencing
      the octet in the verification method that was\n   found inconsistent.\n"
    title: 7.2.  Locator Verification
  - contents:
    - "7.3.  Normal Context Establishment\n   The normal context establishment consists
      of a 4-message exchange in\n   the order of I1, R1, I2, R2, as can be seen in
      Figure 3.\n         Initiator                          Responder\n          IDLE
      \                              IDLE\n               ------------- I1 -------------->\n
      \         I1-SENT\n               <------------ R1 ---------------\n                                             IDLE\n
      \              ------------- I2 -------------->\n          I2-SENT\n               <------------
      R2 ---------------\n          ESTABLISHED                        ESTABLISHED\n
      \                 Figure 3: Normal Context Establishment\n"
    title: 7.3.  Normal Context Establishment
  - contents:
    - "7.4.  Concurrent Context Establishment\n   When both ends try to initiate a
      context for the same ULID pair, then\n   we might end up with crossing I1 messages.
      \ Alternatively, since no\n   state is created when receiving the I1, a host
      might send an I1 after\n   having sent an R1 message.\n   Since a host remembers
      that it has sent an I1, it can respond to an\n   I1 from the peer (for the same
      ULID pair) with an R2, resulting in\n   the message exchange shown in Figure
      4.  Such behavior is needed for\n   reasons such as correctly responding to
      retransmitted I1 messages,\n   which occur when the R2 message has been lost.\n
      \        Host A                             Host B\n          IDLE                               IDLE\n
      \              -\\\n          I1-SENT---\\\n                     ---\\                  /---\n
      \                        --- I1 ---\\   /---  I1-SENT\n                                    ---\\\n
      \                       /--- I1 ---/    ---\\\n                   /---                     -->\n
      \              <---\n               -\\\n          I1-SENT---\\\n                     ---\\
      \                 /---\n                         --- R2 ---\\   /---  I1-SENT\n
      \                                   ---\\\n                        /--- R2 ---/
      \   ---\\\n                   /---                     -->\n               <---
      \                         ESTABLISHED\n          ESTABLISHED\n                      Figure
      4: Crossing I1 Messages\n   If a host has received an I1 and sent an R1, it
      has no state to\n   remember this.  Thus, if the ULP on the host sends down
      packets, this\n   might trigger the host to send an I1 message itself.  Thus,
      while one\n   end is sending an I1, the other is sending an I2, as can be seen
      in\n   Figure 5.\n         Host A                             Host B\n          IDLE
      \                              IDLE\n               -\\\n                 ---\\\n
      \         I1-SENT    ---\\\n                         --- I1 ---\\\n                                    ---\\\n
      \                                       ---\\\n                                            -->\n
      \                                          /---\n                                       /---
      \ IDLE\n                                    ---\n                        /---
      R1--/\n                   /---\n               <---\n               -\\\n          I2-SENT---\\\n
      \                    ---\\                  /---\n                         ---
      I2---\\   /---   I1-SENT\n                                    ---\\\n                        /---
      I1 ---/    ---\\\n                   /---                     -->\n               <---
      \                         ESTABLISHED\n               -\\\n          I2-SENT---\\\n
      \                    ---\\                  /---\n                         ---
      R2 ---\\   /---\n                                    ---\\\n                        /---
      R2 ---/    ---\\\n                   /---                     -->\n               <---
      \                         ESTABLISHED\n          ESTABLISHED\n                       Figure
      5: Crossing I2 and I1\n"
    title: 7.4.  Concurrent Context Establishment
  - contents:
    - "7.5.  Context Recovery\n   Due to garbage collection, we can end up with one
      end having and\n   using the context state, and the other end not having any
      state.  We\n   need to be able to recover this state at the end that has lost
      it\n   before we can use it.\n   This need can arise in the following cases:\n
      \  o  The communication is working using the ULID pair as the locator\n      pair
      but a problem arises, and the end that has retained the\n      context state
      decides to probe alternate locator pairs.\n   o  The communication is working
      using a locator pair that is not the\n      ULID pair; hence, the ULP packets
      sent from a peer that has\n      retained the context state use the Shim6 Payload
      Extension header.\n   o  The host that retained the state sends a control message
      (e.g., an\n      Update Request message).\n   In all cases, the result is that
      the peer without state receives a\n   shim message for which it has no context
      for the Context Tag.\n   We can recover the context by having the node that
      doesn't have a\n   context state send back an R1bis message, and then complete
      the\n   recovery with an I2bis and R2 message, as can be seen in Figure 6.\n
      \          Host A                             Host B\n         Context for\n
      \        CT(peer)=X                         Discards context for\n                                            CT(local)=X\n
      \         ESTABLISHED                        IDLE\n               ---- payload,
      probe, etc. -----> No context state\n                                                for
      CT(local)=X\n               <------------ R1bis ------------\n                                             IDLE\n
      \              ------------- I2bis ----------->\n          I2BIS_SENT\n               <------------
      R2 ---------------\n          ESTABLISHED                        ESTABLISHED\n
      \                   Figure 6: Context Loss at Receiver\n   If one end has garbage
      collected or lost the context state, it might\n   try to create a new context
      state (for the same ULID pair), by\n   sending an I1 message.  In this case,
      the peer (that still has the\n   context state) will reply with an R1 message,
      and the full 4-way\n   exchange will be performed again, as can be seen in Figure
      7.\n           Host A                             Host B\n         Context for\n
      \        CT(peer)=X                         Discards context for\n         ULIDs
      A1, B1                       CT(local)=X\n          ESTABLISHED                        IDLE\n
      \       Finds  <------------ I1 --------------- Tries to set up\n        existing
      \                               for ULIDs A1, B1\n        context,\n        but
      CT(peer)                         I1-SENT\n        doesn't match\n               -------------
      R1 --------------->\n        Left old context\n        in ESTABLISHED\n               <------------
      I2 ---------------\n        Re-create context\n        with new CT(peer)                    I2-SENT\n
      \       and Ls(peer).\n          ESTABLISHED\n               ------------- R2
      -------------->\n          ESTABLISHED                        ESTABLISHED\n
      \                    Figure 7: Context Loss at Sender\n"
    title: 7.5.  Context Recovery
  - contents:
    - "7.6.  Context Confusion\n   Since each end might garbage collect the context
      state, we can have\n   the case where one end has retained the context state
      and tries to\n   use it, while the other end has lost the state.  We discussed
      this in\n   the previous section on recovery.  But, for the same reasons, when\n
      \  one host retains Context Tag X as CT(peer) for ULID pair <A1, B1>,\n   the
      other end might end up allocating that Context Tag as CT(local)\n   for another
      ULID pair (e.g., <A3, B1>) between the same hosts.  In\n   this case, we cannot
      use the recovery mechanisms since there needs to\n   be separate Context Tags
      for the two ULID pairs.\n   This type of \"confusion\" can be observed in two
      cases (assuming it is\n   A that has retained the state and B that has dropped
      it):\n   o  B decides to create a context for ULID pair <A3, B1>, allocates
      X\n      as its Context Tag for this, and sends an I1 to A.\n   o  A decides
      to create a context for ULID pair <A3, B1> and starts\n      the exchange by
      sending I1 to B.  When B receives the I2 message,\n      it allocates X as the
      Context Tag for this context.\n   In both cases, A can detect that B has allocated
      X for ULID pair <A3,\n   B1> even though A still has X as CT(peer) for ULID
      pair <A1, B1>.\n   Thus, A can detect that B must have lost the context for
      <A1, B1>.\n   The confusion can be detected when I2/I2bis/R2 is received, since
      we\n   require that those messages MUST include a sufficiently large set of\n
      \  locators in a Locator List option that the peer can determine whether\n   or
      not two contexts have the same host as the peer by comparing if\n   there is
      any common locators in Ls(peer).\n   The old context that used the Context Tag
      MUST be removed; it can no\n   longer be used to send packets.  Thus, A would
      forcibly remove the\n   context state for <A1, B1, X> so that it can accept
      the new context\n   for <A3, B1, X>.  An implementation MAY re-create a context
      to\n   replace the one that was removed -- in this case, for <A1, B1>.  The\n
      \  normal I1, R1, I2, R2 establishment exchange would then pick unique\n   Context
      Tags for that replacement context.  This re-creation is\n   OPTIONAL, but might
      be useful when there is ULP communication that is\n   using the ULID pair whose
      context was removed.\n   Note that an I1 message with a duplicate Context Tag
      should not cause\n   the removal of the old context state; this operation needs
      to be\n   deferred until the reception of the I2 message.\n"
    title: 7.6.  Context Confusion
  - contents:
    - "7.7.  Sending I1 Messages\n   When the shim layer decides to set up a context
      for a ULID pair, it\n   starts by allocating and initializing the context state
      for its end.\n   As part of this, it assigns a random Context Tag to the context
      that\n   is not being used as CT(local) by any other context .  In the case\n
      \  that a new API is used and the ULP requests a forked context, the\n   Forked
      Instance Identifier value will be set to a non-zero value.\n   Otherwise, the
      FII value is zero.  Then the initiator can send an I1\n   message and set the
      context STATE to I1-SENT.  The I1 message MUST\n   include the ULID pair --
      normally, in the IPv6 Source and Destination\n   fields.  But if the ULID pair
      for the context is not used as a\n   locator pair for the I1 message, then a
      ULID option MUST be included\n   in the I1 message.  In addition, if a Forked
      Instance Identifier\n   value is non-zero, the I1 message MUST include a Context
      Instance\n   Identifier option containing the correspondent value.\n"
    title: 7.7.  Sending I1 Messages
  - contents:
    - "7.8.  Retransmitting I1 Messages\n   If the host does not receive an R1 or
      R2 message in response to the\n   I1 message after I1_TIMEOUT time, then it
      needs to retransmit the I1\n   message.  The retransmissions should use a retransmission
      timer with\n   binary exponential backoff to avoid creating congestion issues
      for\n   the network when lots of hosts perform I1 retransmissions.  Also, the\n
      \  actual timeout value should be randomized between 0.5 and 1.5 of the\n   nominal
      value to avoid self-synchronization.\n   If, after I1_RETRIES_MAX retransmissions,
      there is no response, then\n   most likely the peer does not implement the Shim6
      protocol (or there\n   could be a firewall that blocks the protocol).  In this
      case, it\n   makes sense for the host to remember not to try again to establish
      a\n   context with that ULID.  However, any such negative caching should be\n
      \  retained for at most NO_R1_HOLDDOWN_TIME, in order to be able to\n   later
      set up a context should the problem have been that the host was\n   not reachable
      at all when the shim tried to establish the context.\n   If the host receives
      an ICMP error with \"Unrecognized Next Header\"\n   type (type 4, code 1) and
      the included packet is the I1 message it\n   just sent, then this is a more
      reliable indication that the peer ULID\n   does not implement Shim6.  Again,
      in this case, the host should\n   remember not to try again to establish a context
      with that ULID.\n   Such negative caching should be retained for at most\n   ICMP_HOLDDOWN_TIME,
      which should be significantly longer than the\n   previous case.\n"
    title: 7.8.  Retransmitting I1 Messages
  - contents:
    - "7.9.  Receiving I1 Messages\n   A host MUST silently discard any received I1
      messages that do not\n   satisfy all of the following validity checks in addition
      to those\n   specified in Section 12.3:\n   o  The Hdr Ext Len field is at least
      1, i.e., the length is at least\n      16 octets.\n   Upon the reception of
      an I1 message, the host extracts the ULID pair\n   and the Forked Instance Identifier
      from the message.  If there is no\n   ULID-pair option, then the ULID pair is
      taken from the Source and\n   Destination fields in the IPv6 header.  If there
      is no FII option in\n   the message, then the FII value is taken to be zero.\n
      \  Next, the host looks for an existing context that matches the ULID\n   pair
      and the FII.\n   If no state is found (i.e., the STATE is IDLE), then the host
      replies\n   with an R1 message as specified below.\n   If such a context exists
      in ESTABLISHED STATE, the host verifies that\n   the locator of the initiator
      is included in Ls(peer).  (This check is\n   unnecessary if there is no ULID-pair
      option in the I1 message.)\n   If the state exists in ESTABLISHED STATE and
      the locators do not fall\n   in the locator sets, then the host replies with
      an R1 message as\n   specified below.  This completes the I1 processing, with
      the context\n   STATE being unchanged.\n   If the state exists in ESTABLISHED
      STATE and the locators do fall in\n   the sets, then the host compares CT(peer)
      for the context with the CT\n   contained in the I1 message.\n   o  If the Context
      Tags match, then this probably means that the R2\n      message was lost and
      this I1 is a retransmission.  In this case,\n      the host replies with an
      R2 message containing the information\n      available for the existent context.\n
      \  o  If the Context Tags do not match, then it probably means that the\n      initiator
      has lost the context information for this context and is\n      trying to establish
      a new one for the same ULID pair.  In this\n      case, the host replies with
      an R1 message as specified below.\n      This completes the I1 processing, with
      the context STATE being\n      unchanged.\n   If the state exists in other STATE
      (I1-SENT, I2-SENT, I2BIS-SENT), we\n   are in the situation of concurrent context
      establishment, described\n   in Section 7.4.  In this case, the host leaves
      CT(peer) unchanged and\n   replies with an R2 message.  This completes the I1
      processing, with\n   the context STATE being unchanged.\n"
    title: 7.9.  Receiving I1 Messages
  - contents:
    - "7.10.  Sending R1 Messages\n   When the host needs to send an R1 message in
      response to the I1\n   message, it copies the Initiator Nonce from the I1 message
      to the R1\n   message, generates a Responder Nonce, and calculates a Responder\n
      \  Validator option as suggested in the following section.  No state is\n   created
      on the host in this case.  (Note that the information used to\n   generate the
      R1 reply message is either contained in the received I1\n   message or is global
      information that is not associated with the\n   particular requested context
      (the S and the Responder Nonce values.))\n   When the host needs to send an
      R2 message in response to the I1\n   message, it copies the Initiator Nonce
      from the I1 message to the R2\n   message, and otherwise follows the normal
      rules for forming an R2\n   message (see Section 7.14).\n"
    - contents:
      - "7.10.1.  Generating the R1 Validator\n   As it is stated in Section 5.15.1,
        the validator-generation mechanism\n   is a local choice since the validator
        is generated and verified by\n   the same node, i.e., the responder.  However,
        in order to provide the\n   required protection, the validator needs to be
        generated by\n   fulfilling the conditions described in Section 5.15.1.  One
        way for\n   the responder to properly generate validators is to maintain a
        single\n   secret (S) and a running counter (C) for the Responder Nonce that
        is\n   incremented in fixed periods of time (this allows the responder to\n
        \  verify the age of a Responder Nonce, independently of the context in\n
        \  which it is used).\n   When the validator is generated to be included in
        an R1 message sent\n   in response to a specific I1 message, the responder
        can perform the\n   following procedure to generate the validator value:\n
        \  First, the responder uses the current counter C value as the\n   Responder
        Nonce.\n   Second, it uses the following information (concatenated) as input
        to\n   the one-way function:\n   o  The secret S\n   o  That Responder Nonce\n
        \  o  The Initiator Context Tag from the I1 message\n   o  The ULIDs from
        the I1 message\n   o  The locators from the I1 message (strictly only needed
        if they are\n      different from the ULIDs)\n   o  The Forked Instance Identifier,
        if such option was included in the\n      I1 message\n   Third, it uses the
        output of the hash function as the validator value\n   included in the R1
        message.\n"
      title: 7.10.1.  Generating the R1 Validator
    title: 7.10.  Sending R1 Messages
  - contents:
    - "7.11.  Receiving R1 Messages and Sending I2 Messages\n   A host MUST silently
      discard any received R1 messages that do not\n   satisfy all of the following
      validity checks in addition to those\n   specified in Section 12.3:\n   o  The
      Hdr Ext Len field is at least 1, i.e., the length is at least\n      16 octets.\n
      \  Upon the reception of an R1 message, the host extracts the Initiator\n   Nonce
      and the Locator Pair from the message (the latter from the\n   Source and Destination
      fields in the IPv6 header).  Next, the host\n   looks for an existing context
      that matches the Initiator Nonce and\n   where the locators are contained in
      Ls(peer) and Ls(local),\n   respectively.  If no such context is found, then
      the R1 message is\n   silently discarded.\n   If such a context is found, then
      the host looks at the STATE:\n   o  If the STATE is I1-SENT, then it sends an
      I2 message as specified\n      below.\n   o  In any other STATE (I2-SENT, I2BIS-SENT,
      ESTABLISHED), then the\n      host has already sent an I2 message and this is
      probably a reply\n      to a retransmitted I1 message, so this R1 message MUST
      be silently\n      discarded.\n   When the host sends an I2 message, it includes
      the Responder\n   Validator option that was in the R1 message.  The I2 message
      MUST\n   include the ULID pair -- normally, in the IPv6 Source and Destination\n
      \  fields.  If a ULID-pair option was included in the I1 message, then\n   it
      MUST be included in the I2 message as well.  In addition, if the\n   Forked
      Instance Identifier value for this context is non-zero, the I2\n   message MUST
      contain a Forked Instance Identifier option carrying the\n   Forked Instance
      Identifier value.  Besides, the I2 message contains\n   an Initiator Nonce.
      \ This is not required to be the same as the one\n   included in the previous
      I1 message.\n   The I2 message may also include the initiator's locator list.
      \ If\n   this is the case, then it must also include the CGA Parameter Data\n
      \  Structure.  If CGA (and not HBA) is used to verify one or more of the\n   locators
      included in the locator list, then the initiator must also\n   include a CGA
      Signature option containing the signature.\n   When the I2 message has been
      sent, the STATE is set to I2-SENT.\n"
    title: 7.11.  Receiving R1 Messages and Sending I2 Messages
  - contents:
    - "7.12.  Retransmitting I2 Messages\n   If the initiator does not receive an
      R2 message after I2_TIMEOUT time\n   after sending an I2 message, it MAY retransmit
      the I2 message, using\n   binary exponential backoff and randomized timers.
      \ The Responder\n   Validator option might have a limited lifetime -- that is,
      the peer\n   might reject Responder Validator options that are older than\n
      \  VALIDATOR_MIN_LIFETIME to avoid replay attacks.  In the case that the\n   initiator
      decides not to retransmit I2 messages, or in the case that\n   the initiator
      still does not receive an R2 message after\n   retransmitting I2 messages I2_RETRIES_MAX
      times, the initiator SHOULD\n   fall back to retransmitting the I1 message.\n"
    title: 7.12.  Retransmitting I2 Messages
  - contents:
    - "7.13.  Receiving I2 Messages\n   A host MUST silently discard any received
      I2 messages that do not\n   satisfy all of the following validity checks in
      addition to those\n   specified in Section 12.3:\n   o  The Hdr Ext Len field
      is at least 2, i.e., the length is at least\n      24 octets.\n   Upon the reception
      of an I2 message, the host extracts the ULID pair\n   and the Forked Instance
      Identifier from the message.  If there is no\n   ULID-pair option, then the
      ULID pair is taken from the Source and\n   Destination fields in the IPv6 header.
      \ If there is no FII option in\n   the message, then the FII value is taken
      to be zero.\n   Next, the host verifies that the Responder Nonce is a recent
      one\n   (nonces that are no older than VALIDATOR_MIN_LIFETIME SHOULD be\n   considered
      recent) and that the Responder Validator option matches\n   the validator the
      host would have computed for the ULID, locators,\n   Responder Nonce, Initiator
      Nonce, and FII.\n   If a CGA Parameter Data Structure (PDS) is included in the
      message,\n   then the host MUST verify if the actual PDS contained in the message\n
      \  corresponds to the ULID(peer).\n   If any of the above verifications fail,
      then the host silently\n   discards the message; it has completed the I2 processing.\n
      \  If all the above verifications are successful, then the host proceeds\n   to
      look for a context state for the initiator.  The host looks for a\n   context
      with the extracted ULID pair and FII.  If none exist, then\n   STATE of the
      (non-existing) context is viewed as being IDLE; thus,\n   the actions depend
      on the STATE as follows:\n   o  If the STATE is IDLE (i.e., the context does
      not exist), the host\n      allocates a Context Tag (CT(local)), creates the
      context state for\n      the context, and sets its STATE to ESTABLISHED.  It
      records\n      CT(peer) and the peer's locator set as well as its own locator
      set\n      in the context.  It SHOULD perform the HBA/CGA verification of the\n
      \     peer's locator set at this point in time, as specified in\n      Section
      7.2.  Then, the host sends an R2 message back as specified\n      below.\n   o
      \ If the STATE is I1-SENT, then the host verifies if the source\n      locator
      is included in Ls(peer) or in the Locator List contained\n      in the I2 message
      and that the HBA/CGA verification for this\n      specific locator is successful.\n
      \     *  If this is not the case, then the message is silently discarded\n         and
      the context STATE remains unchanged.\n      *  If this is the case, then the
      host updates the context\n         information (CT(peer), Ls(peer)) with the
      data contained in the\n         I2 message, and the host MUST send an R2 message
      back as\n         specified below.  Note that before updating Ls(peer)\n         information,
      the host SHOULD perform the HBA/CGA validation of\n         the peer's locator
      set at this point in time, as specified in\n         Section 7.2.  The host
      moves to ESTABLISHED STATE.\n   o  If the STATE is ESTABLISHED, I2-SENT, or
      I2BIS-SENT, then the host\n      verifies if the source locator is included
      in Ls(peer) or in the\n      Locator List contained in the I2 message and that
      the HBA/CGA\n      verification for this specific locator is successful.\n      *
      \ If this is not the case, then the message is silently discarded\n         and
      the context STATE remains unchanged.\n      *  If this is the case, then the
      host updates the context\n         information (CT(peer), Ls(peer)) with the
      data contained in the\n         I2 message, and the host MUST send an R2 message
      back as\n         specified in Section 7.14.  Note that before updating Ls(peer)\n
      \        information, the host SHOULD perform the HBA/CGA validation of\n         the
      peer's locator set at this point in time, as specified in\n         Section
      7.2.  The context STATE remains unchanged.\n"
    title: 7.13.  Receiving I2 Messages
  - contents:
    - "7.14.  Sending R2 Messages\n   Before the host sends the R2 message, it MUST
      look for a possible\n   context confusion, i.e., where it would end up with
      multiple contexts\n   using the same CT(peer) for the same peer host.  See Section
      7.15.\n   When the host needs to send an R2 message, the host forms the message\n
      \  and its Context Tag, and copies the Initiator Nonce from the\n   triggering
      message (I2, I2bis, or I1).  In addition, it may include\n   alternative locators
      and necessary options so that the peer can\n   verify them.  In particular,
      the R2 message may include the\n   responder's locator list and the PDS option.
      \ If CGA (and not HBA) is\n   used to verify the locator list, then the responder
      also signs the\n   key parts of the message and includes a CGA Signature option\n
      \  containing the signature.\n   R2 messages are never retransmitted.  If the
      R2 message is lost, then\n   the initiator will retransmit either the I2/I2bis
      or I1 message.\n   Either retransmission will cause the responder to find the
      context\n   state and respond with an R2 message.\n"
    title: 7.14.  Sending R2 Messages
  - contents:
    - "7.15.  Match for Context Confusion\n   When the host receives an I2, I2bis,
      or R2, it MUST look for a\n   possible context confusion, i.e., where it would
      end up with multiple\n   contexts using the same CT(peer) for the same peer
      host.  This can\n   happen when the host has received the above messages, since
      they\n   create a new context with a new CT(peer).  The same issue applies\n
      \  when CT(peer) is updated for an existing context.\n   The host takes CT(peer)
      for the newly created or updated context, and\n   looks for other contexts which:\n
      \  o  Are in STATE ESTABLISHED or I2BIS-SENT\n   o  Have the same CT(peer)\n
      \  o  Have an Ls(peer) that has at least one locator in common with the\n      newly
      created or updated context\n   If such a context is found, then the host checks
      if the ULID pair or\n   the Forked Instance Identifier are different than the
      ones in the\n   newly created or updated context:\n   o  If either or both are
      different, then the peer is reusing the\n      Context Tag for the creation
      of a context with different ULID pair\n      or FII, which is an indication
      that the peer has lost the original\n      context.  In this case, we are in
      a context confusion situation,\n      and the host MUST NOT use the old context
      to send any packets.  It\n      MAY just discard the old context (after all,
      the peer has\n      discarded it), or it MAY attempt to re-establish the old
      context\n      by sending a new I1 message and moving its STATE to I1-SENT.
      \ In\n      any case, once that this situation is detected, the host MUST NOT\n
      \     keep two contexts with overlapping Ls(peer) locator sets and the\n      same
      Context Tag in ESTABLISHED STATE, since this would result in\n      demultiplexing
      problems on the peer.\n   o  If both are the same, then this context is actually
      the context\n      that is created or updated; hence, there is no confusion.\n"
    title: 7.15.  Match for Context Confusion
  - contents:
    - "7.16.  Receiving R2 Messages\n   A host MUST silently discard any received
      R2 messages that do not\n   satisfy all of the following validity checks in
      addition to those\n   specified in Section 12.3:\n   o  The Hdr Ext Len field
      is at least 1, i.e., the length is at least\n      16 octets.\n   Upon the reception
      of an R2 message, the host extracts the Initiator\n   Nonce and the Locator
      Pair from the message (the latter from the\n   Source and Destination fields
      in the IPv6 header).  Next, the host\n   looks for an existing context that
      matches the Initiator Nonce and\n   where the locators are Lp(peer) and Lp(local),
      respectively.  Based\n   on the STATE:\n   o  If no such context is found, i.e.,
      the STATE is IDLE, then the\n      message is silently dropped.\n   o  If STATE
      is I1-SENT, I2-SENT, or I2BIS-SENT, then the host\n      performs the following
      actions.  If a CGA Parameter Data Structure\n      (PDS) is included in the
      message, then the host MUST verify that\n      the actual PDS contained in the
      message corresponds to the\n      ULID(peer) as specified in Section 7.2.  If
      the verification\n      fails, then the message is silently dropped.  If the
      verification\n      succeeds, then the host records the information from the
      R2\n      message in the context state; it records the peer's locator set\n
      \     and CT(peer).  The host SHOULD perform the HBA/CGA verification of\n      the
      peer's locator set at this point in time, as specified in\n      Section 7.2.
      \ The host sets its STATE to ESTABLISHED.\n   o  If the STATE is ESTABLISHED,
      the R2 message is silently ignored,\n      (since this is likely to be a reply
      to a retransmitted I2\n      message).\n   Before the host completes the R2
      processing, it MUST look for a\n   possible context confusion, i.e., where it
      would end up with multiple\n   contexts using the same CT(peer) for the same
      peer host.  See\n   Section 7.15.\n"
    title: 7.16.  Receiving R2 Messages
  - contents:
    - "7.17.  Sending R1bis Messages\n   Upon the receipt of a Shim6 Payload Extension
      header where there is\n   no current Shim6 context at the receiver, the receiver
      is to respond\n   with an R1bis message in order to enable a fast re-establishment
      of\n   the lost Shim6 context.\n   Also, a host is to respond with an R1bis
      upon receipt of any control\n   messages that have a message type in the range
      64-127 (i.e.,\n   excluding the context-setup messages such as I1, R1, R1bis,
      I2,\n   I2bis, R2, and future extensions), where the control message refers\n
      \  to a non-existent context.\n   We assume that all the incoming packets that
      trigger the generation\n   of an R1bis message contain a locator pair (in the
      address fields of\n   the IPv6 header) and a Context Tag.\n   Upon reception
      of any of the packets described above, the host will\n   reply with an R1bis
      including the following information:\n   o  The Responder Nonce is a number
      picked by the responder that the\n      initiator will return in the I2bis message.\n
      \  o  Packet Context Tag is the Context Tag contained in the received\n      packet
      that triggered the generation of the R1bis message.\n   o  The Responder Validator
      option is included, with a validator that\n      is computed as suggested in
      the next section.\n"
    - contents:
      - "7.17.1.  Generating the R1bis Validator\n   One way for the responder to
        properly generate validators is to\n   maintain a single secret (S) and a
        running counter C for the\n   Responder Nonce that is incremented in fixed
        periods of time (this\n   allows the responder to verify the age of a Responder
        Nonce,\n   independently of the context in which it is used).\n   When the
        validator is generated to be included in an R1bis message --\n   that is,
        sent in response to a specific control packet or a packet\n   containing the
        Shim6 Payload Extension header message -- the\n   responder can perform the
        following procedure to generate the\n   validator value:\n   First, the responder
        uses the counter C value as the Responder Nonce.\n   Second, it uses the following
        information (concatenated) as input to\n   the one-way function:\n   o  The
        secret S\n   o  That Responder Nonce\n   o  The Receiver Context Tag included
        in the received packet\n   o  The locators from the received packet\n   Third,
        it uses the output of the hash function as the validator\n   string.\n"
      title: 7.17.1.  Generating the R1bis Validator
    title: 7.17.  Sending R1bis Messages
  - contents:
    - "7.18.  Receiving R1bis Messages and Sending I2bis Messages\n   A host MUST
      silently discard any received R1bis messages that do not\n   satisfy all of
      the following validity checks in addition to those\n   specified in Section
      12.3:\n   o  The Hdr Ext Len field is at least 1, i.e., the length is at least\n
      \     16 octets.\n   Upon the reception of an R1bis message, the host extracts
      the Packet\n   Context Tag and the Locator Pair from the message (the latter
      from\n   the Source and Destination fields in the IPv6 header).  Next, the\n
      \  host looks for an existing context where the Packet Context Tag\n   matches
      CT(peer) and where the locators match Lp(peer) and Lp(local),\n   respectively.\n
      \  o  If no such context is found, i.e., the STATE is IDLE, then the\n      R1bis
      message is silently discarded.\n   o  If the STATE is I1-SENT, I2-SENT, or I2BIS-SENT,
      then the R1bis\n      message is silently discarded.\n   o  If the STATE is
      ESTABLISHED, then we are in the case where the\n      peer has lost the context,
      and the goal is to try to re-establish\n      it.  For that, the host leaves
      CT(peer) unchanged in the context\n      state, transitions to I2BIS-SENT STATE,
      and sends an I2bis\n      message, including the computed Responder Validator
      option, the\n      Packet Context Tag, and the Responder Nonce that were received
      in\n      the R1bis message.  This I2bis message is sent using the locator\n
      \     pair included in the R1bis message.  In the case that this locator\n      pair
      differs from the ULID pair defined for this context, then a\n      ULID option
      MUST be included in the I2bis message.  In addition,\n      if the Forked Instance
      Identifier for this context is non-zero,\n      then a Forked Instance Identifier
      option carrying the instance\n      identifier value for this context MUST be
      included in the I2bis\n      message.  The I2bis message may also include a
      locator list.  If\n      this is the case, then it must also include the CGA
      Parameter Data\n      Structure.  If CGA (and not HBA) is used to verify one
      or more of\n      the locators included in the locator list, then the initiator
      must\n      also include a CGA Signature option containing the signature.\n"
    title: 7.18.  Receiving R1bis Messages and Sending I2bis Messages
  - contents:
    - "7.19.  Retransmitting I2bis Messages\n   If the initiator does not receive
      an R2 message after I2bis_TIMEOUT\n   time after sending an I2bis message, it
      MAY retransmit the I2bis\n   message, using binary exponential backoff and randomized
      timers.  The\n   Responder Validator option might have a limited lifetime --
      that is,\n   the peer might reject Responder Validator options that are older
      than\n   VALIDATOR_MIN_LIFETIME to avoid replay attacks.  In the case that the\n
      \  initiator decides not to retransmit I2bis messages, or in the case\n   that
      the initiator still does not receive an R2 message after\n   retransmitting
      I2bis messages I2bis_RETRIES_MAX times, the initiator\n   SHOULD fall back to
      retransmitting the I1 message.\n"
    title: 7.19.  Retransmitting I2bis Messages
  - contents:
    - "7.20.  Receiving I2bis Messages and Sending R2 Messages\n   A host MUST silently
      discard any received I2bis messages that do not\n   satisfy all of the following
      validity checks in addition to those\n   specified in Section 12.3:\n   o  The
      Hdr Ext Len field is at least 3, i.e., the length is at least\n      32 octets.\n
      \  Upon the reception of an I2bis message, the host extracts the ULID\n   pair
      and the Forked Instance Identifier from the message.  If there\n   is no ULID-pair
      option, then the ULID pair is taken from the Source\n   and Destination fields
      in the IPv6 header.  If there is no FII option\n   in the message, then the
      FII value is taken to be zero.\n   Next, the host verifies that the Responder
      Nonce is a recent one\n   (nonces that are no older than VALIDATOR_MIN_LIFETIME
      SHOULD be\n   considered recent) and that the Responder Validator option matches\n
      \  the validator the host would have computed for the locators,\n   Responder
      Nonce, and Receiver Context Tag as part of sending an R1bis\n   message.\n   If
      a CGA Parameter Data Structure (PDS) is included in the message,\n   then the
      host MUST verify if the actual PDS contained in the message\n   corresponds
      to the ULID(peer).\n   If any of the above verifications fail, then the host
      silently\n   discards the message; it has completed the I2bis processing.\n
      \  If both verifications are successful, then the host proceeds to look\n   for
      a context state for the initiator.  The host looks for a context\n   with the
      extracted ULID pair and FII.  If none exist, then STATE of\n   the (non-existing)
      context is viewed as being IDLE; thus, the actions\n   depend on the STATE as
      follows:\n   o  If the STATE is IDLE (i.e., the context does not exist), the
      host\n      allocates a Context Tag (CT(local)), creates the context state for\n
      \     the context, and sets its STATE to ESTABLISHED.  The host SHOULD\n      NOT
      use the Packet Context Tag in the I2bis message for CT(local);\n      instead,
      it should pick a new random Context Tag just as when it\n      processes an
      I2 message.  It records CT(peer) and the peer's\n      locator set as well as
      its own locator set in the context.  It\n      SHOULD perform the HBA/CGA verification
      of the peer's locator set\n      at this point in time, as specified in Section
      7.2.  Then the host\n      sends an R2 message back as specified in Section
      7.14.\n   o  If the STATE is I1-SENT, then the host verifies if the source\n
      \     locator is included in Ls(peer) or in the Locator List contained\n      in
      the I2bis message and if the HBA/CGA verification for this\n      specific locator
      is successful.\n      *  If this is not the case, then the message is silently\n
      \        discarded.  The context STATE remains unchanged.\n      *  If this
      is the case, then the host updates the context\n         information (CT(peer),
      Ls(peer)) with the data contained in the\n         I2bis message, and the host
      MUST send an R2 message back as\n         specified below.  Note that before
      updating Ls(peer)\n         information, the host SHOULD perform the HBA/CGA
      validation of\n         the peer's locator set at this point in time, as specified
      in\n         Section 7.2.  The host moves to ESTABLISHED STATE.\n   o  If the
      STATE is ESTABLISHED, I2-SENT, or I2BIS-SENT, then the host\n      determines
      whether at least one of the two following conditions\n      hold: i) if the
      source locator is included in Ls(peer) or, ii) if\n      the source locator
      is included in the Locator List contained in\n      the I2bis message and if
      the HBA/CGA verification for this\n      specific locator is successful.\n      *
      \ If none of the two aforementioned conditions hold, then the\n         message
      is silently discarded.  The context STATE remains\n         unchanged.\n      *
      \ If at least one of the two aforementioned conditions hold, then\n         the
      host updates the context information (CT(peer), Ls(peer))\n         with the
      data contained in the I2bis message, and the host MUST\n         send an R2
      message back, as specified in Section 7.14.  Note\n         that before updating
      Ls(peer) information, the host SHOULD\n         perform the HBA/CGA validation
      of the peer's locator set at\n         this point in time, as specified in Section
      7.2.  The context\n         STATE remains unchanged.\n"
    title: 7.20.  Receiving I2bis Messages and Sending R2 Messages
  title: 7.  Establishing ULID-Pair Contexts
- contents:
  - "8.  Handling ICMP Error Messages\n   The routers in the path as well as the destination
    might generate\n   ICMP error messages.  In some cases, the Shim6 can take action
    and\n   solve the problem that resulted in the error.  In other cases, the\n   Shim6
    layer cannot solve the problem, and it is critical that these\n   packets make
    it back up to the ULPs so that they can take appropriate\n   action.\n   This
    is an implementation issue in the sense that the mechanism is\n   completely local
    to the host itself.  But the issue of how ICMP\n   errors are correctly dispatched
    to the ULP on the host are important;\n   hence, this section specifies the issue.\n
    \  All ICMP messages MUST be delivered to the ULP in all cases, except\n   when
    Shim6 successfully acts on the message (e.g., selects a new\n   path).  There
    SHOULD be a configuration option to unconditionally\n   deliver all ICMP messages
    (including ones acted on by shim6) to the\n   ULP.\n   According to that recommendation,
    the following ICMP error messages\n   should be processed by the Shim6 layer and
    not passed to the ULP:\n      ICMP error Destination Unreachable, with codes:\n
    \        0 (No route to destination)\n         1 (Communication with destination
    administratively prohibited)\n         2 (Beyond scope of source address)\n         3
    (Address unreachable)\n         5 (Source address failed ingress/egress policy)\n
    \        6 (Reject route to destination)\n      ICMP Time exceeded error.\n      ICMP
    Parameter problem error, with the parameter that caused the\n      error being
    a Shim6 parameter.\n   The following ICMP error messages report problems that
    cannot be\n   addressed by the Shim6 layer and that should be passed to the ULP
    (as\n   described below):\n      ICMP Packet too big error.\n      ICMP Destination
    Unreachable with Code 4 (Port unreachable).\n      ICMP Parameter problem (if
    the parameter that caused the problem\n      is not a Shim6 parameter).\n                +--------------+\n
    \               | IPv6 Header  |\n                |              |\n                +--------------+\n
    \               |    ICMPv6    |\n                |    Header    |\n         -
    -    +--------------+   - -\n                | IPv6 Header  |\n                |
    src, dst as  |   Can be dispatched\n        IPv6    | sent by ULP  |   unmodified
    to ULP\n                | on host      |   ICMP error handler\n        Packet
    \ +--------------+\n                |     ULP      |\n        in      |    Header
    \   |\n                +--------------+\n        Error   |              |\n                ~
    \    Data     ~\n                |              |\n         - -    +--------------+
    \  - -\n                Figure 8: ICMP Error Handling without the\n                      Shim6
    Payload Extension Header\n   When the ULP packets are sent without the Shim6 Payload
    Extension\n   header -- that is, while the initial locators=ULIDs are working
    --\n   this introduces no new concerns; an implementation's existing\n   mechanism
    for delivering these errors to the ULP will work.  See\n   Figure 8.\n   But when
    the shim on the transmitting side inserts the Shim6 Payload\n   Extension header
    and replaces the ULIDs in the IP address fields with\n   some other locators,
    then an ICMP error coming back will have a\n   \"packet in error\", which is not
    a packet that the ULP sent.  Thus,\n   the implementation will have to apply reverse
    mapping to the \"packet\n   in error\" before passing the ICMP error up to the
    ULP, including the\n   ICMP extensions defined in [25].  See Figure 9.\n                +--------------+\n
    \               | IPv6 Header  |\n                |              |\n                +--------------+\n
    \               |    ICMPv6    |\n                |    Header    |\n         -
    -    +--------------+   - -\n                | IPv6 Header  |\n                |
    src, dst as  |   Needs to be\n        IPv6    | modified by  |   transformed to\n
    \               | shim on host |   have ULIDs\n                +--------------+
    \  in src, dst fields,\n        Packet  |  Shim6 ext.  |   and Shim6 Ext.\n                |
    \   Header    |   header removed\n         in     +--------------+   before it
    can be\n                |  Transport   |   dispatched to the ULP\n        Error
    \  |    Header    |   ICMP error handler.\n                +--------------+\n
    \               |              |\n                ~     Data     ~\n                |
    \             |\n         - -    +--------------+   - -\n   Figure 9: ICMP Error
    Handling with the Shim6 Payload Extension Header\n   Note that this mapping is
    different than when receiving packets from\n   the peer with Shim6 Payload Extension
    headers because, in that case,\n   the packets contain CT(local).  But the ICMP
    errors have a \"packet in\n   error\" with a Shim6 Payload Extension header containing
    CT(peer).\n   This is because they were intended to be received by the peer.  In\n
    \  any case, since the <Source Locator, Destination Locator, CT(peer)>\n   has
    to be unique when received by the peer, the local host should\n   also only be
    able to find one context that matches this tuple.\n   If the ICMP error is a \"packet
    too big\", the reported MTU must be\n   adjusted to be 8 octets less, since the
    shim will add 8 octets when\n   sending packets.\n   After the \"packet in error\"
    has had the original ULIDs inserted, then\n   this Shim6 Payload Extension header
    can be removed.  The result is a\n   \"packet in error\" that is passed to the
    ULP which looks as if the\n   shim did not exist.\n"
  title: 8.  Handling ICMP Error Messages
- contents:
  - "9.  Teardown of the ULID-Pair Context\n   Each host can unilaterally decide when
    to tear down a ULID-pair\n   context.  It is RECOMMENDED that hosts do not tear
    down the context\n   when they know that there is some upper-layer protocol that
    might use\n   the context.  For example, an implementation might know this if
    there\n   is an open socket that is connected to the ULID(peer).  However,\n   there
    might be cases when the knowledge is not readily available to\n   the shim layer,
    for instance, for UDP applications that do not\n   connect their sockets or for
    any application that retains some\n   higher-level state across (TCP) connections
    and UDP packets.\n   Thus, it is RECOMMENDED that implementations minimize premature\n
    \  teardown by observing the amount of traffic that is sent and received\n   using
    the context, and tear down the state only after it appears\n   quiescent.  A reasonable
    approach would be to not tear down a context\n   until at least 5 minutes have
    passed since the last message was sent\n   or received using the context.  (Note
    that packets that use the ULID\n   pair as a locator pair and that do not require
    address rewriting by\n   the Shim6 layer are also considered as packets using
    the associated\n   Shim6 context.)\n   Since there is no explicit, coordinated
    removal of the context state,\n   there are potential issues around Context Tag
    reuse.  One end might\n   remove the state and potentially reuse that Context
    Tag for some\n   other communication, and the peer might later try to use the
    old\n   context (which it didn't remove).  The protocol has mechanisms to\n   recover
    from this, which work whether the state removal was total and\n   accidental (e.g.,
    crash and reboot of the host) or just a garbage\n   collection of shim state that
    didn't seem to be used.  However, the\n   host should try to minimize the reuse
    of Context Tags by trying to\n   randomly cycle through the 2^47 Context Tag values.
    \ (See Appendix C\n   for a summary of how the recovery works in the different
    cases.)\n"
  title: 9.  Teardown of the ULID-Pair Context
- contents:
  - "10.  Updating the Peer\n   The Update Request and Acknowledgement are used both
    to update the\n   list of locators (only possible when CGA is used to verify the\n
    \  locator(s)) and to update the preferences associated with each\n   locator.\n"
  - contents:
    - "10.1.  Sending Update Request Messages\n   When a host has a change in the
      locator set, it can communicate this\n   to the peer by sending an Update Request.
      \ When a host has a change\n   in the preferences for its locator set, it can
      also communicate this\n   to the peer.  The Update Request message can include
      just a Locator\n   List option (to convey the new set of locators), just a Locator\n
      \  Preferences option, or both a new Locator List and new Locator\n   Preferences.\n
      \  Should the host send a new Locator List, the host picks a new random,\n   local
      generation number, records this in the context, and puts it in\n   the Locator
      List option.  Any Locator Preference option, whether sent\n   in the same Update
      Request or in some future Update Request, will use\n   that generation number
      to make sure the preferences get applied to\n   the correct version of the locator
      list.\n   The host picks a random Request Nonce for each update and keeps the\n
      \  same nonce for any retransmissions of the Update Request.  The nonce\n   is
      used to match the acknowledgement with the request.\n   The Update Request message
      can also include a CGA Parameter Data\n   Structure (this is needed if the CGA
      PDS was not previously\n   exchanged).  If CGA (and not HBA) is used to verify
      one or more of\n   the locators included in the locator list, then a CGA Signature\n
      \  option containing the signature must also be included in the Update\n   Request
      message.\n"
    title: 10.1.  Sending Update Request Messages
  - contents:
    - "10.2.  Retransmitting Update Request Messages\n   If the host does not receive
      an Update Acknowledgement R2 message in\n   response to the Update Request message
      after UPDATE_TIMEOUT time,\n   then it needs to retransmit the Update Request
      message.  The\n   retransmissions should use a retransmission timer with binary\n
      \  exponential backoff to avoid creating congestion issues for the\n   network
      when lots of hosts perform Update Request retransmissions.\n   Also, the actual
      timeout value should be randomized between 0.5 and\n   1.5 of the nominal value
      to avoid self-synchronization.\n   Should there be no response, the retransmissions
      continue forever.\n   The binary exponential backoff stops at MAX_UPDATE_TIMEOUT.
      \ But the\n   only way the retransmissions would stop when there is no\n   acknowledgement
      is when Shim6, through the REAP protocol or some\n   other mechanism, decides
      to discard the context state due to lack of\n   ULP usage in combination with
      no responses to the REAP protocol.\n"
    title: 10.2.  Retransmitting Update Request Messages
  - contents:
    - "10.3.  Newer Information while Retransmitting\n   There can be at most one
      outstanding Update Request message at any\n   time.  Thus until, for example,
      an update with a new Locator List has\n   been acknowledged, any newer Locator
      List or new Locator Preferences\n   cannot just be sent.  However, when there
      is newer information and\n   the older information has not yet been acknowledged,
      the host can,\n   instead of waiting for an acknowledgement, abandon the previous\n
      \  update and construct a new Update Request (with a new Request Nonce)\n   that
      includes the new information as well as the information that\n   hasn't yet
      been acknowledged.\n   For example, if the original locator list was just (A1,
      A2), and if\n   an Update Request with the Locator List (A1, A3) is outstanding,
      and\n   the host determines that it should both add A4 to the locator list\n
      \  and mark A1 as BROKEN, then it would need to:\n   o  Pick a new random Request
      Nonce for the new Update Request.\n   o  Pick a new random generation number
      for the new locator list.\n   o  Form the new locator list: (A1, A3, A4).\n
      \  o  Form a Locator Preference option that uses the new generation\n      number
      and has the BROKEN flag for the first locator.\n   o  Send the Update Request
      and start a retransmission timer.\n   Any Update Acknowledgement that doesn't
      match the current Request\n   Nonce (for instance, an acknowledgement for the
      abandoned Update\n   Request) will be silently ignored.\n"
    title: 10.3.  Newer Information while Retransmitting
  - contents:
    - "10.4.  Receiving Update Request Messages\n   A host MUST silently discard any
      received Update Request messages\n   that do not satisfy all of the following
      validity checks in addition\n   to those specified in Section 12.3:\n   o  The
      Hdr Ext Len field is at least 1, i.e., the length is at least\n      16 octets.\n
      \  Upon the reception of an Update Request message, the host extracts\n   the
      Context Tag from the message.  It then looks for a context that\n   has a CT(local)
      that matches the Context Tag.  If no such context is\n   found, it sends an
      R1bis message as specified in Section 7.17.\n   Since Context Tags can be reused,
      the host MUST verify that the IPv6\n   Source Address field is part of Ls(peer)
      and that the IPv6\n   Destination Address field is part of Ls(local).  If this
      is not the\n   case, the sender of the Update Request has a stale context that\n
      \  happens to match the CT(local) for this context.  In this case, the\n   host
      MUST send an R1bis message and otherwise ignore the Update\n   Request message.\n
      \  If a CGA Parameter Data Structure (PDS) is included in the message,\n   then
      the host MUST verify if the actual PDS contained in the packet\n   corresponds
      to the ULID(peer).  If this verification fails, the\n   message is silently
      discarded.\n   Then, depending on the STATE of the context:\n   o  If ESTABLISHED,
      proceed to process message.\n   o  If I1-SENT, discard the message and stay
      in I1-SENT.\n   o  If I2-SENT, send I2 and proceed to process the message.\n
      \  o  If I2BIS-SENT, send I2bis and proceed to process the message.\n   The
      verification issues for the locators carried in the Update\n   Request message
      are specified in Section 7.2.  If the locator list\n   cannot be verified, this
      procedure should send a Shim6 Error message\n   with Error Code=2.  In any case,
      if it cannot be verified, there is\n   no further processing of the Update Request.\n
      \  Once any Locator List option in the Update Request has been verified,\n   the
      peer generation number in the context is updated to be the one in\n   the Locator
      List option.\n   If the Update Request message contains a Locator Preference
      option,\n   then the generation number in the preference option is compared
      with\n   the peer generation number in the context.  If they do not match,\n
      \  then the host generates a Shim6 Error message with Error Code=3 and\n   with
      the Pointer field referring to the first octet in the Locator\n   List Generation
      number in the Locator Preference option.  In\n   addition, if the number of
      elements in the Locator Preference option\n   does not match the number of locators
      in Ls(peer), then a Shim6 Error\n   message with Error Code=4 is sent with the
      Pointer field referring to\n   the first octet of the Length field in the Locator
      Preference option.\n   In both cases of failure, no further processing is performed
      for the\n   Update Request message.\n   If the generation numbers match, the
      locator preferences are recorded\n   in the context.\n   Once the Locator List
      option (if present) has been verified and any\n   new locator list or locator
      preferences have been recorded, the host\n   sends an Update Acknowledgement
      message, copying the nonce from the\n   request and using the CT(peer) as the
      Receiver Context Tag.\n   Any new locators (or, more likely, new locator preferences)
      might\n   result in the host wanting to select a different locator pair for
      the\n   context -- for instance, if the Locator Preferences option lists the\n
      \  current Lp(peer) as BROKEN.  The host uses the reachability\n   exploration
      procedure described in [4] to verify that the new locator\n   is reachable before
      changing Lp(peer).\n"
    title: 10.4.  Receiving Update Request Messages
  - contents:
    - "10.5.  Receiving Update Acknowledgement Messages\n   A host MUST silently discard
      any received Update Acknowledgement\n   messages that do not satisfy all of
      the following validity checks in\n   addition to those specified in Section
      12.3:\n   o  The Hdr Ext Len field is at least 1, i.e., the length is at least\n
      \     16 octets.\n   Upon the reception of an Update Acknowledgement message,
      the host\n   extracts the Context Tag and the Request Nonce from the message.
      \ It\n   then looks for a context that has a CT(local) that matches the\n   Context
      Tag.  If no such context is found, it sends an R1bis message\n   as specified
      in Section 7.17.\n   Since Context Tags can be reused, the host MUST verify
      that the IPv6\n   Source Address field is part of Ls(peer) and that the IPv6\n
      \  Destination Address field is part of Ls(local).  If this is not the\n   case,
      the sender of the Update Acknowledgement has a stale context\n   that happens
      to match the CT(local) for this context.  In this case,\n   the host MUST send
      an R1bis message and otherwise ignore the Update\n   Acknowledgement message.\n
      \  Then, depending on the STATE of the context:\n   o  If ESTABLISHED, proceed
      to process message.\n   o  If I1-SENT, discard the message and stay in I1-SENT.\n
      \  o  If I2-SENT, send R2 and proceed to process the message.\n   o  If I2BIS-SENT,
      send R2 and proceed to process the message.\n   If the Request Nonce doesn't
      match the nonce for the last sent Update\n   Request for the context, then the
      Update Acknowledgement is silently\n   ignored.  If the nonce matches, then
      the update has been completed\n   and the Update retransmit timer can be reset.\n"
    title: 10.5.  Receiving Update Acknowledgement Messages
  title: 10.  Updating the Peer
- contents:
  - "11.  Sending ULP Payloads\n   When there is no context state for the ULID pair
    on the sender, there\n   is no effect on how ULP packets are sent.  If the host
    is using some\n   heuristic for determining when to perform a deferred context\n
    \  establishment, then the host might need to do some accounting (count\n   the
    number of packets sent and received) even before there is a ULID-\n   pair context.\n
    \  If the context is not in ESTABLISHED or I2BIS-SENT STATE, then there\n   is
    also no effect on how the ULP packets are sent.  Only in the\n   ESTABLISHED and
    I2BIS-SENT STATEs does the host have CT(peer) and\n   Ls(peer) set.\n   If there
    is a ULID-pair context for the ULID pair, then the sender\n   needs to verify
    whether the context uses the ULIDs as locators --\n   that is, whether Lp(peer)
    == ULID(peer) and Lp(local) == ULID(local).\n   If this is the case, then packets
    can be sent unmodified by the shim.\n   If it is not the case, then the logic
    in Section 11.1 will need to be\n   used.\n   There will also be some maintenance
    activity relating to\n   (un)reachability detection, whether or not packets are
    sent with the\n   original locators.  The details of this are out of scope for
    this\n   document and are specified in [4].\n"
  - contents:
    - "11.1.  Sending ULP Payload after a Switch\n   When sending packets, if there
      is a ULID-pair context for the ULID\n   pair, and if the ULID pair is no longer
      used as the locator pair,\n   then the sender needs to transform the packet.
      \ Apart from replacing\n   the IPv6 Source and Destination fields with a locator
      pair, an\n   8-octet header is added so that the receiver can find the context
      and\n   inverse the transformation.\n   If there has been a failure causing
      a switch, and later the context\n   switches back to sending things using the
      ULID pair as the locator\n   pair, then there is no longer a need to do any
      packet transformation\n   by the sender; hence, there is no need to include
      the 8-octet\n   Extension header.\n   First, the IP address fields are replaced.
      \ The IPv6 Source Address\n   field is set to Lp(local) and the Destination
      Address field is set to\n   Lp(peer).  Note that this MUST NOT cause any recalculation
      of the ULP\n   checksums, since the ULP checksums are carried end-to-end and
      the ULP\n   pseudo-header contains the ULIDs that are preserved end-to-end.\n
      \  The sender skips any \"Routing Sublayer Extension headers\" that the\n   ULP
      might have included; thus, it skips any Hop-by-Hop Extension\n   header, any
      Routing header, and any Destination Options header that\n   is followed by a
      Routing header.  After any such headers, the Shim6\n   Extension header will
      be added.  This might be before a Fragment\n   header, a Destination Options
      header, an ESP or AH header, or a ULP\n   header.\n   The inserted Shim6 Payload
      Extension header includes the peer's\n   Context Tag.  It takes on the Next
      Header value from the preceding\n   Extension header, since that Extension header
      will have a Next Header\n   value of Shim6.\n"
    title: 11.1.  Sending ULP Payload after a Switch
  title: 11.  Sending ULP Payloads
- contents:
  - "12.  Receiving Packets\n   The receive side of the communication can receive
    packets associated\n   to a Shim6 context, with or without the Shim6 Extension
    header.  In\n   case the ULID pair is being used as a locator pair, the packets\n
    \  received will not have the Shim6 Extension header and will be\n   processed
    by the Shim6 layer as described below.  If the received\n   packet does carry
    the Shim6 Extension header, as in normal IPv6\n   receive-side packet processing,
    the receiver parses the (extension)\n   headers in order.  Should it find a Shim6
    Extension header, it will\n   look at the \"P\" field in that header.  If this
    bit is zero, then the\n   packet must be passed to the Shim6 payload handling
    for rewriting.\n   Otherwise, the packet is passed to the Shim6 control handling.\n"
  - contents:
    - "12.1.  Receiving Payload without Extension Headers\n   The receiver extracts
      the IPv6 Source and Destination fields and uses\n   this to find a ULID-pair
      context, such that the IPv6 address fields\n   match the ULID(local) and ULID(peer).
      \ If such a context is found,\n   the context appears not to be quiescent; this
      should be remembered in\n   order to avoid tearing down the context and for
      reachability\n   detection purposes as described in [4].  The host continues
      with the\n   normal processing of the IP packet.\n"
    title: 12.1.  Receiving Payload without Extension Headers
  - contents:
    - "12.2.  Receiving Shim6 Payload Extension Headers\n   The receiver extracts
      the Context Tag from the Shim6 Payload\n   Extension header and uses this to
      find a ULID-pair context.  If no\n   context is found, the receiver SHOULD generate
      an R1bis message (see\n   Section 7.17).\n   Then, depending on the STATE of
      the context:\n   o  If ESTABLISHED, proceed to process message.\n   o  If I1-SENT,
      discard the message and stay in I1-SENT.\n   o  If I2-SENT, send I2 and proceed
      to process the message.\n   o  If I2BIS-SENT, send I2bis and proceed to process
      the message.\n   With the context in hand, the receiver can now replace the
      IP address\n   fields with the ULIDs kept in the context.  Finally, the Shim6\n
      \  Payload Extension header is removed from the packet (so that the ULP\n   doesn't
      get confused by it), and the Next Header value in the\n   preceding header is
      set to be the actual protocol number for the\n   payload.  Then the packet can
      be passed to the protocol identified by\n   the Next Header value (which might
      be some function associated with\n   the IP endpoint sublayer or a ULP).\n   If
      the host is using some heuristic for determining when to perform a\n   deferred
      context establishment, then the host might need to do some\n   accounting (count
      the number of packets sent and received) for\n   packets that do not have a
      Shim6 Extension header and for which there\n   is no context.  But the need
      for this depends on what heuristics the\n   implementation has chosen.\n"
    title: 12.2.  Receiving Shim6 Payload Extension Headers
  - contents:
    - "12.3.  Receiving Shim Control Messages\n   A shim control message has the Checksum
      field verified.  The Shim\n   Header Length field is also verified against the
      length of the IPv6\n   packet to make sure that the shim message doesn't claim
      to end past\n   the end of the IPv6 packet.  Finally, it checks that neither
      the IPv6\n   Destination field nor the IPv6 Source field is a multicast address
      or\n   an unspecified address.  If any of those checks fail, the packet is\n
      \  silently dropped.\n   The message is then dispatched based on the shim message
      type.  Each\n   message type is then processed as described elsewhere in this\n
      \  document.  If the packet contains a shim message type that is unknown\n   to
      the receiver, then a Shim6 Error message with Error Code=0 is\n   generated
      and sent back.  The Pointer field is set to point at the\n   first octet of
      the shim message type.\n   All the control messages can contain any options
      with C=0.  If there\n   is any option in the message with C=1 that isn't known
      to the host,\n   then the host MUST send a Shim6 Error message with Error Code=1
      with\n   the Pointer field referencing the first octet of the Option Type.\n"
    title: 12.3.  Receiving Shim Control Messages
  - contents:
    - "12.4.  Context Lookup\n   We assume that each shim context has its own STATE
      machine.  We\n   assume that a dispatcher delivers incoming packets to the STATE\n
      \  machine that it belongs to.  Here, we describe the rules used for the\n   dispatcher
      to deliver packets to the correct shim context STATE\n   machine.\n   There
      is one STATE machine per identified context that is\n   conceptually identified
      by the ULID pair and Forked Instance\n   Identifier (which is zero by default)
      or identified by CT(local).\n   However, the detailed lookup rules are more
      complex, especially\n   during context establishment.\n   Clearly, if the required
      context is not established, it will be in\n   IDLE STATE.\n   During context
      establishment, the context is identified as follows:\n   o  I1 packets: Deliver
      to the context associated with the ULID pair\n      and the Forked Instance
      Identifier.\n   o  I2 packets: Deliver to the context associated with the ULID
      pair\n      and the Forked Instance Identifier.\n   o  R1 packets: Deliver to
      the context with the locator pair included\n      in the packet and the Initiator
      Nonce included in the packet (R1\n      does not contain a ULID pair or the
      CT(local)).  If no context\n      exists with this locator pair and Initiator
      Nonce, then silently\n      discard.\n   o  R2 packets: Deliver to the context
      with the locator pair included\n      in the packet and the Initiator Nonce
      included in the packet (R2\n      does not contain a ULID pair or the CT(local)).
      \ If no context\n      exists with this locator pair and Initiator Nonce, then
      silently\n      discard.\n   o  R1bis packets: Deliver to the context that has
      the locator pair\n      and the CT(peer) equal to the Packet Context Tag included
      in the\n      R1bis packet.\n   o  I2bis packets: Deliver to the context associated
      with the ULID\n      pair and the Forked Instance Identifier.\n   o  Shim6 Payload
      Extension headers: Deliver to the context with\n      CT(local) equal to the
      Receiver Context Tag included in the\n      packet.\n   o  Other control messages
      (Update, Keepalive, Probe): Deliver to the\n      context with CT(local) equal
      to the Receiver Context Tag included\n      in the packet.  Verify that the
      IPv6 Source Address field is part\n      of Ls(peer) and that the IPv6 Destination
      Address field is part of\n      Ls(local).  If not, send an R1bis message.\n
      \  o  Shim6 Error messages and ICMP errors that contain a Shim6 Payload\n      Extension
      header or other shim control packet in the \"packet in\n      error\": Use the
      \"packet in error\" for dispatching as follows.\n      Deliver to the context
      with CT(peer) equal to the Receiver Context\n      Tag -- Lp(local) being the
      IPv6 source address and Lp(peer) being\n      the IPv6 destination address.\n
      \  In addition, the shim on the sending side needs to be able to find\n   the
      context state when a ULP packet is passed down from the ULP.  In\n   that case,
      the lookup key is the pair of ULIDs and FII=0.  If we have\n   a ULP API that
      allows the ULP to do context forking, then presumably\n   the ULP would pass
      down the Forked Instance Identifier.\n"
    title: 12.4.  Context Lookup
  title: 12.  Receiving Packets
- contents:
  - "13.  Initial Contact\n   The initial contact is some non-shim communication between
    two ULIDs,\n   as described in Section 2.  At that point in time, there is no\n
    \  activity in the shim.\n   Whether or not the shim ends up being used (e.g.,
    the peer might not\n   support Shim6), it is highly desirable that the initial
    contact can\n   be established even if there is a failure for one or more IP\n
    \  addresses.\n   The approach taken is to rely on the applications and the transport\n
    \  protocols to retry with different source and destination addresses,\n   consistent
    with what is already specified in \"Default Address\n   Selection for IPv6\" [7]
    as well as with some fixes to that\n   specification [9], to make it try different
    source addresses and not\n   only different destination addresses.\n   The implementation
    of such an approach can potentially result in long\n   timeouts.  For instance,
    consider a naive implementation at the\n   socket API that uses getaddrinfo()
    to retrieve all destination\n   addresses and then tries to bind() and connect()
    to try all source\n   and destination address combinations and waits for TCP to
    time out\n   for each combination before trying the next one.\n   However, if
    implementations encapsulate this in some new connect-by-\n   name() API and use
    non-blocking connect calls, it is possible to\n   cycle through the available
    combinations in a more rapid manner until\n   a working source and destination
    pair is found.  Thus, the issues in\n   this domain are issues of implementations
    and the current socket API,\n   and not issues of protocol specification.  In
    all honesty, while\n   providing an easy to use connect-by-name() API for TCP
    and other\n   connection-oriented transports is easy, providing a similar\n   capability
    at the API for UDP is hard due to the protocol itself not\n   providing any \"success\"
    feedback.  Yet, even the UDP issue is one of\n   APIs and implementation.\n"
  title: 13.  Initial Contact
- contents:
  - "14.  Protocol Constants\n   The protocol uses the following constants:\n   I1_RETRIES_MAX
    = 4\n   I1_TIMEOUT = 4 seconds\n   NO_R1_HOLDDOWN_TIME = 1 min\n   ICMP_HOLDDOWN_TIME
    = 10 min\n   I2_TIMEOUT = 4 seconds\n   I2_RETRIES_MAX = 2\n   I2bis_TIMEOUT =
    4 seconds\n   I2bis_RETRIES_MAX = 2\n   VALIDATOR_MIN_LIFETIME = 30 seconds\n
    \  UPDATE_TIMEOUT = 4 seconds\n   MAX_UPDATE_TIMEOUT = 120 seconds\n   The retransmit
    timers (I1_TIMEOUT, I2_TIMEOUT, UPDATE_TIMEOUT) are\n   subject to binary exponential
    backoff as well as to randomization\n   across a range of 0.5 and 1.5 times the
    nominal (backed off) value.\n   This removes any risk of synchronization between
    lots of hosts\n   performing independent shim operations at the same time.\n   The
    randomization is applied after the binary exponential backoff.\n   Thus, the first
    retransmission would happen based on a uniformly\n   distributed random number
    in the range of [0.5*4, 1.5*4] seconds; the\n   second retransmission, [0.5*8,
    1.5*8] seconds after the first one,\n   etc.\n"
  title: 14.  Protocol Constants
- contents:
  - '15.  Implications Elsewhere

    '
  - contents:
    - "15.1.  Congestion Control Considerations\n   When the locator pair currently
      used for exchanging packets in a\n   Shim6 context becomes unreachable, the
      Shim6 layer will divert the\n   communication through an alternative locator
      pair, which in most\n   cases will result in redirecting the packet flow through
      an\n   alternative network path.  In this case, it is recommended that the\n
      \  Shim6 follows the recommendation defined in [21] and informs the\n   upper
      layers about the path change, in order to allow the congestion\n   control mechanisms
      of the upper layers to react accordingly.\n"
    title: 15.1.  Congestion Control Considerations
  - contents:
    - "15.2.  Middle-Boxes Considerations\n   Data packets belonging to a Shim6 context
      carrying the Shim6 Payload\n   header contain alternative locators other than
      the ULIDs in the\n   Source and Destination Address fields of the IPv6 header.
      \ On the\n   other hand, the upper layers of the peers involved in the\n   communication
      operate on the ULID pair presented to them by the Shim6\n   layer, rather than
      on the locator pair contained in the IPv6 header\n   of the actual packets.
      \ It should be noted that the Shim6 layer does\n   not modify the data packets
      but, because a constant ULID pair is\n   presented to upper layers irrespective
      of the locator pair changes,\n   the relation between the upper-layer header
      (such as TCP, UDP, ICMP,\n   ESP, etc) and the IPv6 header is modified.  In
      particular, when the\n   Shim6 Extension header is present in the packet, if
      those data\n   packets are TCP, UDP, or ICMP packets, the pseudo-header used
      for the\n   checksum calculation will contain the ULID pair, rather than the\n
      \  locator pair contained in the data packet.\n   It is possible that some firewalls
      or other middle-boxes will try to\n   verify the validity of upper-layer sanity
      checks of the packet on the\n   fly.  If they do that based on the actual source
      and destination\n   addresses contained in the IPv6 header without considering
      the Shim6\n   context information (in particular, without replacing the locator\n
      \  pair by the ULID pair used by the Shim6 context), such verifications\n   may
      fail.  Those middle-boxes need to be updated in order to be able\n   to parse
      the Shim6 Payload header and find the next header.  It is\n   recommended that
      firewalls and other middle-boxes do not drop packets\n   that carry the Shim6
      Payload header with apparently incorrect upper-\n   layer validity checks that
      involve the addresses in the IPv6 header\n   for their computation, unless they
      are able to determine the ULID\n   pair of the Shim6 context associated to the
      data packet and use the\n   ULID pair for the verification of the validity check.\n
      \  In the particular case of TCP, UDP, and ICMP checksums, it is\n   recommended
      that firewalls and other middle-boxes do not drop TCP,\n   UDP, and ICMP packets
      that carry the Shim6 Payload header with\n   apparently incorrect checksums
      when using the addresses in the IPv6\n   header for the pseudo-header computation,
      unless they are able to\n   determine the ULID pair of the Shim6 context associated
      to the data\n   packet and use the ULID pair to determine the checksum that
      must be\n   present in a packet with addresses rewritten by Shim6.\n   In addition,
      firewalls that today pass limited traffic, e.g.,\n   outbound TCP connections,
      would presumably block the Shim6 protocol.\n   This means that even when Shim6-capable
      hosts are communicating, the\n   I1 messages would be dropped; hence, the hosts
      would not discover\n   that their peer is Shim6-capable.  This is, in fact,
      a benefit since,\n   if the hosts managed to establish a ULID-pair context,
      the firewall\n   would probably drop the \"different\" packets that are sent
      after a\n   failure (those using the Shim6 Payload Extension header with a TCP\n
      \  packet inside it).  Thus, stateful firewalls that are modified to\n   pass
      Shim6 messages should also be modified to pass the Shim6 Payload\n   Extension
      header so that the shim can use the alternate locators to\n   recover from failures.
      \ This presumably implies that the firewall\n   needs to track the set of locators
      in use by looking at the Shim6\n   control exchanges.  Such firewalls might
      even want to verify the\n   locators using the HBA/CGA verification themselves,
      which they can do\n   without modifying any of the Shim6 packets through which
      they pass.\n"
    title: 15.2.  Middle-Boxes Considerations
  - contents:
    - "15.3.  Operation and Management Considerations\n   This section considers some
      aspects related to the operations and\n   management of the Shim6 protocol.\n
      \  Deployment of the Shim6 protocol: The Shim6 protocol is a host-based\n   solution.
      \ So, in order to be deployed, the stacks of the hosts using\n   the Shim6 protocol
      need to be updated to support it.  This enables an\n   incremental deployment
      of the protocol since it does not require a\n   flag day for the deployment
      -- just single host updates.  If the\n   Shim6 solution will be deployed in
      a site, the host can be gradually\n   updated to support the solution.  Moreover,
      for supporting the Shim6\n   protocol, only end hosts need to be updated and
      no router changes are\n   required.  However, it should be noted that, in order
      to benefit from\n   the Shim6 protocol, both ends of a communication should
      support the\n   protocol, meaning that both hosts must be updated to be able
      to use\n   the Shim6 protocol.  Nevertheless, the Shim6 protocol uses a deferred\n
      \  context-setup capability that allows end hosts to establish normal\n   IPv6
      communications and, later on, if both endpoints are Shim6-\n   capable, establish
      the Shim6 context using the Shim6 protocol.  This\n   has an important deployment
      benefit, since Shim6-enabled nodes can\n   talk perfectly to non-Shim6-capable
      nodes without introducing any\n   problem into the communication.\n   Configuration
      of Shim6-capable nodes: The Shim6 protocol itself does\n   not require any specific
      configuration to provide its basic features.\n   The Shim6 protocol is designed
      to provide a default service to upper\n   layers that should satisfy general
      applications.  The Shim6 layer\n   would automatically attempt to protect long-lived
      communications by\n   triggering the establishment of the Shim6 context using
      some\n   predefined heuristics.  Of course, if some special tunning is\n   required
      by some applications, this may require additional\n   configuration.  Similar
      considerations apply to a site attempting to\n   perform some forms of traffic
      engineering by using different\n   preferences for different locators.\n   Address
      and prefix configuration: The Shim6 protocol assumes that, in\n   a multihomed
      site, multiple prefixes will be available.  Such\n   configuration can increase
      the operation work in a network.  However,\n   it should be noted that the capability
      of having multiple prefixes in\n   a site and multiple addresses assigned to
      an interface is an IPv6\n   capability that goes beyond the Shim6 case, and
      it is expected to be\n   widely used.  So, even though this is the case for
      Shim6, we consider\n   that the implications of such a configuration is beyond
      the\n   particular case of Shim6 and must be addressed for the generic IPv6\n
      \  case.  Nevertheless, Shim6 also assumes the usage of CGA/HBA\n   addresses
      by Shim6 hosts.  This implies that Shim6-capable hosts\n   should configure
      addresses using HBA/CGA generation mechanisms.\n   Additional consideration
      about this issue can be found at [19].\n"
    title: 15.3.  Operation and Management Considerations
  - contents:
    - "15.4.  Other Considerations\n   The general Shim6 approach as well as the specifics
      of this proposed\n   solution have implications elsewhere, including:\n   o
      \ Applications that perform referrals or callbacks using IP\n      addresses
      as the 'identifiers' can still function in limited ways,\n      as described
      in [18].  But, in order for such applications to be\n      able to take advantage
      of the multiple locators for redundancy,\n      the applications need to be
      modified to either use Fully Qualified\n      Domain Names as the 'identifiers'
      or they need to pass all the\n      locators as the 'identifiers', i.e., the
      'identifier' from the\n      application's perspective becomes a set of IP addresses
      instead of\n      a single IP address.\n   o  Signaling protocols for QoS or
      for other things that involve\n      having devices in the network path look
      at IP addresses and port\n      numbers (or at IP addresses and Flow Labels)
      need to be invoked on\n      the hosts when the locator pair changes due to
      a failure.  At that\n      point in time, those protocols need to inform the
      devices that a\n      new pair of IP addresses will be used for the flow.  Note
      that\n      this is the case even though this protocol, unlike some earlier\n
      \     proposals, does not overload the Flow Label as a Context Tag; the\n      in-path
      devices need to know about the use of the new locators\n      even though the
      Flow Label stays the same.\n   o  MTU implications.  By computing a minimum
      over the recently\n      observed path MTUs, the path MTU mechanisms we use
      are robust\n      against different packets taking different paths through the\n
      \     Internet.  When Shim6 fails over from using one locator pair to\n      another,
      this means that packets might travel over a different\n      path through the
      Internet; hence, the path MTU might be quite\n      different.  In order to
      deal with this change in the MTU, the\n      usage of Packetization Layer Path
      MTU Discovery as defined in [24]\n      is recommended.\n      The fact that
      the shim will add an 8-octet Shim6 Payload Extension\n      header to the ULP
      packets after a locator switch can also affect\n      the usable path MTU for
      the ULPs.  In this case, the MTU change is\n      local to the sending host;
      thus, conveying the change to the ULPs\n      is an implementation matter.  By
      conveying the information to the\n      transport layer, it can adapt and reduce
      the Maximum Segment Size\n      (MSS) accordingly.\n"
    title: 15.4.  Other Considerations
  title: 15.  Implications Elsewhere
- contents:
  - "16.  Security Considerations\n   This document satisfies the concerns specified
    in [15] as follows:\n   o  The HBA [3] and CGA [2] techniques for verifying the
    locators to\n      prevent an attacker from redirecting the packet stream to\n
    \     somewhere else, prevent threats described in Sections 4.1.1,\n      4.1.2,
    4.1.3, and 4.2 of [15].  These two techniques provide a\n      similar level of
    protection but also provide different\n      functionality with different computational
    costs.\n      The HBA mechanism relies on the capability of generating all the\n
    \     addresses of a multihomed host as an unalterable set of\n      intrinsically
    bound IPv6 addresses, known as an HBA set.  In this\n      approach, addresses
    incorporate a cryptographic one-way hash of\n      the prefix set available into
    the interface identifier part.  The\n      result is that the binding between
    all the available addresses is\n      encoded within the addresses themselves,
    providing hijacking\n      protection.  Any peer using the shim protocol node
    can efficiently\n      verify that the alternative addresses proposed for continuing
    the\n      communication are bound to the initial address through a simple\n      hash
    calculation.\n      In a CGA-based approach, the address used as the ULID is a
    CGA\n      that contains a hash of a public key in its interface identifier.\n
    \     The result is a secure binding between the ULID and the associated\n      key
    pair.  This allows each peer to use the corresponding private\n      key to sign
    the shim messages that convey locator set information.\n      The trust chain
    in this case is the following: the ULID used for\n      the communication is securely
    bound to the key pair because it\n      contains the hash of the public key, and
    the locator set is bound\n      to the public key through the signature.\n      Either
    of these two mechanisms, HBA and CGA, provides time-shifted\n      attack protection
    (as described in Section 4.1.2 of [15]), since\n      the ULID is securely bound
    to a locator set that can only be\n      defined by the owner of the ULID.  The
    minimum acceptable key\n      length for RSA keys used in the generation of CGAs
    MUST be at\n      least 1024 bits.  Any implementation should follow prudent\n
    \     cryptographic practice in determining the appropriate key lengths.\n   o
    \ 3rd party flooding attacks, described in Section 4.3 of [15], are\n      prevented
    by requiring a Shim6 peer to perform a successful\n      Reachability probe +
    reply exchange before accepting a new locator\n      for use as a packet destination.\n
    \  o  The first message does not create any state on the responder.\n      Essentially,
    a 3-way exchange is required before the responder\n      creates any state.  This
    means that a state-based DoS attack\n      (trying to use up all memory on the
    responder) at least requires\n      the attacker to create state, consuming his
    own resources; it also\n      provides an IPv6 address that the attacker was using.\n
    \  o  The context-establishment messages use nonces to prevent replay\n      attacks,
    which are described in Section 4.1.4 of [15], and to\n      prevent off-path attackers
    from interfering with the\n      establishment.\n   o  Every control message of
    the Shim6 protocol, past the context\n      establishment, carry the Context Tag
    assigned to the particular\n      context.  This implies that an attacker needs
    to discover that\n      Context Tag before being able to spoof any Shim6 control
    message\n      as described in Section 4.4 of [15].  Such discovery probably\n
    \     requires an attacker to be along the path in order to sniff the\n      Context
    Tag value.  The result is that, through this technique,\n      the Shim6 protocol
    is protected against off-path attackers.\n"
  - contents:
    - "16.1.  Interaction with IPSec\n   Shim6 has two modes of processing data packets.
      \ If the ULID pair is\n   also the locator pair being used, then the data packet
      is not\n   modified by Shim6.  In this case, the interaction with IPSec is\n
      \  exactly the same as if the Shim6 layer was not present in the host.\n   If
      the ULID pair differs from the current locator pair for that Shim6\n   context,
      then Shim6 will take the data packet, replace the ULIDs\n   contained in the
      IP Source and Destination Address fields with the\n   current locator pair,
      and add the Shim6 extension with the\n   corresponding Context Tag.  In this
      case, as is mentioned in Section\n   1.6, Shim6 conceptually works as a tunnel
      mechanism, where the inner\n   header contains the ULID and the outer header
      contains the locators.\n   The main difference is that the inner header is \"compressed\"
      and a\n   compression tag, namely the Context Tag, is added to decompress the\n
      \  inner header at the receiving end.\n   In this case, the interaction between
      IPSec and Shim6 is then similar\n   to the interaction between IPSec and a tunnel
      mechanism.  When the\n   packet is generated by the upper-layer protocol, it
      is passed to the\n   IP layer containing the ULIDs in the IP Source and Destination
      field.\n   IPSec is then applied to this packet.  Then the packet is passed
      to\n   the Shim6 sublayer, which \"encapsulates\" the received packet and\n
      \  includes a new IP header containing the locator pair in the IP Source\n   and
      Destination field.  This new IP packet is in turn passed to IPSec\n   for processing,
      just as in the case of a tunnel.  This can be viewed\n   as if IPSec is located
      both above and below the Shim6 sublayer and as\n   if IPSec policies apply both
      to ULIDs and locators.\n   When IPSec processed the packet after the Shim6 sublayer
      has\n   processed it (i.e., the packet carrying the locators in the IP Source\n
      \  and Destination Address field), the Shim6 sublayer may have added the\n   Shim6
      Extension header.  In that case, IPSec needs to skip the Shim6\n   Extension
      header to find the selectors for the next layer's protocols\n   (e.g., TCP,
      UDP, Stream Control Transmission Protocol (SCTP)).\n   When a packet is received
      at the other end, it is processed based on\n   the order of the extension headers.
      \ Thus, if an ESP or AH header\n   precedes a Shim6 header, that determines
      the order.  Shim6 introduces\n   the need to do policy checks, analogous to
      how they are done for\n   tunnels, when Shim6 receives a packet and the ULID
      pair for that\n   packet is not identical to the locator pair in the packet.\n"
    title: 16.1.  Interaction with IPSec
  - contents:
    - "16.2.  Residual Threats\n   Some of the residual threats in this proposal are:\n
      \  o  An attacker that arrives late on the path (after the context has\n      been
      established) can use the R1bis message to cause one peer to\n      re-create
      the context and, at that point in time, can observe all\n      of the exchange.
      \ But this doesn't seem to open any new doors for\n      the attacker since
      such an attacker can observe the Context Tags\n      that are being used and,
      once known, can use those to send bogus\n      messages.\n   o  An attacker
      present on the path in order to find out the Context\n      Tags can generate
      an R1bis message after it has moved off the\n      path.  For this packet to
      be effective, it needs to have a source\n      locator that belongs to the context;
      thus, there cannot be \"too\n      much\" ingress filtering between the attacker's
      new location and\n      the communicating peers.  But this doesn't seem to be
      that severe\n      because, once the R1bis causes the context to be re-established,
      a\n      new pair of Context Tags will be used, which will not be known to\n
      \     the attacker.  If this is still a concern, we could require a\n      2-way
      handshake, \"did you really lose the state?\", in response to\n      the error
      message.\n   o  It might be possible for an attacker to try random 47-bit Context\n
      \     Tags and see if they can cause disruption for communication\n      between
      two hosts.  In particular, in the case of payload packets,\n      the effects
      of such an attack would be similar to those of an\n      attacker sending packets
      with a spoofed source address.  In the\n      case of control packets, it is
      not enough to find the correct\n      Context Tag -- additional information
      is required (e.g., nonces,\n      proper source addresses; see previous bullet
      for the case of\n      R1bis).  If a 47-bit tag, which is the largest that fits
      in an\n      8-octet Extension header, isn't sufficient, one could use an even\n
      \     larger tag in the Shim6 control messages and use the low-order 47\n      bits
      in the Shim6 Payload Extension header.\n   o  When the Shim6 Payload Extension
      header is used, an attacker that\n      can guess the 47-bit random Context
      Tag can inject packets into\n      the context with any source locator.  Thus,
      if there is ingress\n      filtering between the attacker and its target, this
      could\n      potentially allow the attacker to bypass the ingress filtering.\n
      \     However, in addition to guessing the 47-bit Context Tag, the\n      attacker
      also needs to find a context where, after the receiver's\n      replacement
      of the locators with the ULIDs, the ULP checksum is\n      correct.  But even
      this wouldn't be sufficient with ULPs like TCP,\n      since the TCP port numbers
      and sequence numbers must match an\n      existing connection.  Thus, even though
      the issues for off-path\n      attackers injecting packets are different than
      today with ingress\n      filtering, it is still very hard for an off-path attacker
      to\n      guess.  If IPsec is applied, then the issue goes away completely.\n
      \  o  The validator included in the R1 and R1bis packets is generated as\n      a
      hash of several input parameters.  While most of the inputs are\n      actually
      determined by the sender, and only the secret value S is\n      unknown to the
      sender, the resulting protection is deemed to be\n      enough since it would
      be easier for the attacker to just obtain a\n      new validator by sending
      an I1 packet than to perform all the\n      computations required to determine
      the secret S.  Nevertheless, it\n      is recommended that the host change the
      secret S periodically.\n"
    title: 16.2.  Residual Threats
  title: 16.  Security Considerations
- contents:
  - "17.  IANA Considerations\n   IANA allocated a new IP Protocol Number value (140)
    for the Shim6\n   Protocol.\n   IANA recorded a CGA message type for the Shim6
    protocol in the CGA\n   Extension Type Tags registry with the value 0x4A30 5662
    4858 574B\n   3655 416F 506A 6D48.\n   IANA established a Shim6 Parameter Registry
    with four components:\n   Shim6 Type registrations, Shim6 Options registrations,
    Shim6 Error\n   Code registrations, and Shim6 Verification Method registrations.\n
    \  The initial contents of the Shim6 Type registry are as follows:\n   +------------+-----------------------------------------------------+\n
    \  | Type Value |                       Message                       |\n   +------------+-----------------------------------------------------+\n
    \  |      0     |                       RESERVED                      |\n   |
    \     1     | I1 (first establishment message from the initiator) |\n   |      2
    \    | R1 (first establishment message from the responder) |\n   |      3     |
    \ I2 (2nd establishment message from the initiator)  |\n   |      4     |  R2
    (2nd establishment message from the responder)  |\n   |      5     |  R1bis (Reply
    to reference to non-existent context) |\n   |      6     |           I2bis (Reply
    to a R1bis message)          |\n   |    7-59    |           Allocated using Standards
    action          |\n   |    60-63   |                 For Experimental use                |\n
    \  |     64     |                    Update Request                   |\n   |
    \    65     |                Update Acknowledgement               |\n   |     66
    \    |                      Keepalive                      |\n   |     67     |
    \                   Probe Message                    |\n   |     68     |                    Error
    Message                    |\n   |   69-123   |           Allocated using Standards
    action          |\n   |   124-127  |                 For Experimental use                |\n
    \  +------------+-----------------------------------------------------+\n   The
    initial contents of the Shim6 Options registry are as follows:\n            +-------------+----------------------------------+\n
    \           |     Type    |            Option Name           |\n            +-------------+----------------------------------+\n
    \           |      0      |             RESERVED             |\n            |
    \     1      |        Responder Validator       |\n            |      2      |
    \          Locator List           |\n            |      3      |        Locator
    Preferences       |\n            |      4      |   CGA Parameter Data Structure
    \  |\n            |      5      |           CGA Signature          |\n            |
    \     6      |             ULID Pair            |\n            |      7      |
    \   Forked Instance Identifier    |\n            |     8-9     | Allocated using
    Standards action |\n            |      10     |     Keepalive Timeout Option     |\n
    \           |   11-16383  | Allocated using Standards action |\n            |
    16384-32767 |       For Experimental use       |\n            +-------------+----------------------------------+\n
    \  The initial contents of the Shim6 Error Code registry are as follows:\n        +------------+--------------------------------------------+\n
    \       | Code Value |                 Description                |\n        +------------+--------------------------------------------+\n
    \       |      0     |         Unknown Shim6 message type         |\n        |
    \     1     |       Critical Option not recognized       |\n        |      2     |
    \    Locator verification method failed     |\n        |      3     | Locator
    List Generation number out of sync |\n        |      4     |       Error in the
    number of locators      |\n        |    5-19    |      Allocated using Standards
    action      |\n        |   120-127  |       Reserved for debugging purposes      |\n
    \       +------------+--------------------------------------------+\n   The initial
    contents of the Shim6 Verification Method registry are as\n   follows:\n              +---------+----------------------------------+\n
    \             |  Value  |        Verification Method       |\n              +---------+----------------------------------+\n
    \             |    0    |             RESERVED             |\n              |
    \   1    |                CGA               |\n              |    2    |                HBA
    \              |\n              |  3-200  | Allocated using Standards action |\n
    \             | 201-254 |       For Experimental use       |\n              |
    \  255   |             RESERVED             |\n              +---------+----------------------------------+\n"
  title: 17.  IANA Considerations
- contents:
  - "18.  Acknowledgements\n   Over the years, many people active in the multi6 and
    shim6 WGs have\n   contributed ideas and suggestions that are reflected in this\n
    \  specification.  Special thanks to the careful comments from Sam\n   Hartman,
    Cullen Jennings, Magnus Nystrom, Stephen Kent, Geoff Huston,\n   Shinta Sugimoto,
    Pekka Savola, Dave Meyer, Deguang Le, Jari Arkko,\n   Iljitsch van Beijnum, Jim
    Bound, Brian Carpenter, Sebastien Barre,\n   Matthijs Mekking, Dave Thaler, Bob
    Braden, Wesley Eddy, Pasi Eronen,\n   and Tom Henderson on earlier versions of
    this document.\n"
  title: 18.  Acknowledgements
- contents:
  - '19.  References

    '
  - contents:
    - "19.1.  Normative References\n   [1]   Bradner, S., \"Key words for use in RFCs
      to Indicate Requirement\n         Levels\", BCP 14, RFC 2119, March 1997.\n
      \  [2]   Aura, T., \"Cryptographically Generated Addresses (CGA)\",\n         RFC
      3972, March 2005.\n   [3]   Bagnulo, M., \"Hash-Based Addresses (HBA)\", RFC
      5535, June 2009.\n   [4]   Arkko, J. and I. van Beijnum, \"Failure Detection
      and Locator\n         Pair Exploration Protocol for IPv6 Multihoming\", RFC
      5534,\n         June 2009.\n"
    title: 19.1.  Normative References
  - contents:
    - "19.2.  Informative References\n   [5]   Gulbrandsen, A., Vixie, P., and L.
      Esibov, \"A DNS RR for\n         specifying the location of services (DNS SRV)\",
      RFC 2782,\n         February 2000.\n   [6]   Ferguson, P. and D. Senie, \"Network
      Ingress Filtering:\n         Defeating Denial of Service Attacks which employ
      IP Source\n         Address Spoofing\", BCP 38, RFC 2827, May 2000.\n   [7]
      \  Draves, R., \"Default Address Selection for Internet Protocol\n         version
      6 (IPv6)\", RFC 3484, February 2003.\n   [8]   Nordmark, E., \"Multihoming without
      IP Identifiers\", Work\n         in Progress, July 2004.\n   [9]   Bagnulo,
      M., \"Updating RFC 3484 for multihoming support\", Work\n         in Progress,
      November 2007.\n   [10]  Schulzrinne, H., Casner, S., Frederick, R., and V.
      Jacobson,\n         \"RTP: A Transport Protocol for Real-Time Applications\",
      STD 64,\n         RFC 3550, July 2003.\n   [11]  Abley, J., Black, B., and V.
      Gill, \"Goals for IPv6 Site-\n         Multihoming Architectures\", RFC 3582,
      August 2003.\n   [12]  Rajahalme, J., Conta, A., Carpenter, B., and S. Deering,
      \"IPv6\n         Flow Label Specification\", RFC 3697, March 2004.\n   [13]
      \ Eastlake, D., Schiller, J., and S. Crocker, \"Randomness\n         Requirements
      for Security\", BCP 106, RFC 4086, June 2005.\n   [14]  Hinden, R. and B. Haberman,
      \"Unique Local IPv6 Unicast\n         Addresses\", RFC 4193, October 2005.\n
      \  [15]  Nordmark, E. and T. Li, \"Threats Relating to IPv6 Multihoming\n         Solutions\",
      RFC 4218, October 2005.\n   [16]  Huitema, C., \"Ingress filtering compatibility
      for IPv6\n         multihomed sites\", Work in Progress, September 2005.\n   [17]
      \ Bagnulo, M. and E. Nordmark, \"SHIM - MIPv6 Interaction\", Work\n         in
      Progress, July 2005.\n   [18]  Nordmark, E., \"Shim6-Application Referral Issues\",
      Work\n         in Progress, July 2005.\n   [19]  Bagnulo, M. and J. Abley, \"Applicability
      Statement for the\n         Level 3 Multihoming Shim Protocol (Shim6)\", Work
      in Progress,\n         July 2007.\n   [20]  Moskowitz, R., Nikander, P., Jokela,
      P., and T. Henderson,\n         \"Host Identity Protocol\", RFC 5201, April
      2008.\n   [21]  Schuetz, S., Koutsianas, N., Eggert, L., Eddy, W., Swami, Y.,\n
      \        and K. Le, \"TCP Response to Lower-Layer Connectivity-Change\n         Indications\",
      Work in Progress, February 2008.\n   [22]  Williams, N. and M. Richardson, \"Better-Than-Nothing
      Security:\n         An Unauthenticated Mode of IPsec\", RFC 5386, November 2008.\n
      \  [23]  Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, \"Socket\n         Application
      Program Interface (API) for Multihoming Shim\", Work\n         in Progress,
      November 2008.\n   [24]  Mathis, M. and J. Heffner, \"Packetization Layer Path
      MTU\n         Discovery\", RFC 4821, March 2007.\n   [25]  Bonica, R., Gan,
      D., Tappan, D., and C. Pignataro, \"Extended\n         ICMP to Support Multi-Part
      Messages\", RFC 4884, April 2007.\n"
    title: 19.2.  Informative References
  title: 19.  References
- contents:
  - "Appendix A.  Possible Protocol Extensions\n   During the development of this
    protocol, several issues have been\n   brought up that are important to address
    but that do not need to be\n   in the base protocol itself; instead, these can
    be done as extensions\n   to the protocol.  The key ones are:\n   o  As stated
    in the assumptions in Section 3, in order for the Shim6\n      protocol to be
    able to recover from a wide range of failures (for\n      instance, when one of
    the communicating hosts is single-homed) and\n      to cope with a site's ISPs
    that do ingress filtering based on the\n      source IPv6 address, there is a
    need for the host to be able to\n      influence the egress selection from its
    site.  Further discussion\n      of this issue is captured in [16].\n   o  Is
    there need for keeping the list of locators private between the\n      two communicating
    endpoints?  We can potentially accomplish that\n      when using CGA (not when
    using HBA), but only at the cost of doing\n      some public key encryption and
    decryption operations as part of\n      the context establishment.  The suggestion
    is to leave this for a\n      future extension to the protocol.\n   o  Defining
    some form of end-to-end \"compression\" mechanism that\n      removes the need
    to include the Shim6 Payload Extension header\n      when the locator pair is
    not the ULID pair.\n   o  Supporting the dynamic setting of locator preferences
    on a site-\n      wide basis and using the Locator Preference option in the Shim6\n
    \     protocol to convey these preferences to remote communicating\n      hosts.
    \ This could mirror the DNS SRV record's notion of priority\n      and weight.\n
    \  o  Specifying APIs in order for the ULPs to be aware of the locators\n      that
    the shim is using and to be able to influence the choice of\n      locators (controlling
    preferences as well as triggering a locator-\n      pair switch).  This includes
    providing APIs that the ULPs can use\n      to fork a shim context.\n   o  Determining
    whether it is feasible to relax the suggestions for\n      when context state
    is removed so that one can end up with an\n      asymmetric distribution of the
    context state and still get (most\n      of) the shim benefits.  For example,
    the busy server would go\n      through the context setup but would quickly remove
    the context\n      state after this (in order to save memory); however, the not-so-\n
    \     busy client would retain the context state.  The context-recovery\n      mechanism
    presented in Section 7.5 would then re-create the state\n      should the client
    send either a shim control message (e.g., Probe\n      message because it sees
    a problem) or a ULP packet in a Shim6\n      Payload Extension header (because
    it had earlier failed over to an\n      alternative locator pair but had been
    silent for a while).  This\n      seems to provide the benefits of the shim as
    long as the client\n      can detect the failure.  If the client doesn't send
    anything and\n      it is the server that tries to send, then it will not be able
    to\n      recover because the shim on the server has no context state and\n      hence
    doesn't know any alternate locator pairs.\n   o  Study what it would take to make
    the Shim6 control protocol not\n      rely at all on a stable source locator in
    the packets.  This can\n      probably be accomplished by having all the shim
    control messages\n      include the ULID-pair option.\n   o  If each host might
    have lots of locators, then the current\n      requirement to include essentially
    all of them in the I2 and R2\n      messages might be constraining.  If this is
    the case, we can look\n      into using the CGA Parameter Data Structure for the
    comparison,\n      instead of the prefix sets, to be able to detect context\n
    \     confusion.  This would place some constraint on a (logical) only\n      using,
    for example, one CGA public key; it would also require some\n      carefully crafted
    rules on how two PDSs are compared for \"being\n      the same host\".  But if
    we don't expect more than a handful of\n      locators per host, then we don't
    need this added complexity.\n   o  ULP-specified timers for the reachability detection
    mechanism\n      (which can be particularly useful when there are forked contexts).\n
    \  o  Pre-verify some \"backup\" locator pair, so that the failover time\n      can
    be shorter.\n   o  Study how Shim6 and Mobile IPv6 might interact [17].\n"
  title: Appendix A.  Possible Protocol Extensions
- contents:
  - "Appendix B.  Simplified STATE Machine\n   The STATEs are defined in Section 6.2.
    \ The intent is for the\n   stylized description below to be consistent with the
    textual\n   description in the specification; however, should they conflict, the\n
    \  textual description is normative.\n   The following table describes the possible
    actions in STATE IDLE and\n   their respective triggers:\n   +---------------------+---------------------------------------------+\n
    \  | Trigger             | Action                                      |\n   +---------------------+---------------------------------------------+\n
    \  | Receive I1          | Send R1 and stay in IDLE                    |\n   |
    \                    |                                             |\n   | Heuristics
    trigger  | Send I1 and move to I1-SENT                 |\n   | a new context       |
    \                                            |\n   | establishment       |                                             |\n
    \  |                     |                                             |\n   |
    Receive I2, verify  | If successful, send R2 and move to          |\n   | validator
    and       | ESTABLISHED                                 |\n   | RESP Nonce          |
    \                                            |\n   |                     | If
    fail, stay in IDLE                       |\n   |                     |                                             |\n
    \  | Receive I2bis,      | If successful, send R2 and move to          |\n   |
    verify validator    | ESTABLISHED                                 |\n   | and
    RESP Nonce      |                                             |\n   |                     |
    If fail, stay in IDLE                       |\n   |                     |                                             |\n
    \  | R1, R1bis, R2       | N/A (This context lacks the required info   |\n   |
    \                    | for the dispatcher to deliver them)         |\n   |                     |
    \                                            |\n   | Receive Payload     | Send
    R1bis and stay in IDLE                 |\n   | Extension header    |                                             |\n
    \  | or other control    |                                             |\n   |
    packet              |                                             |\n   +---------------------+---------------------------------------------+\n
    \  The following table describes the possible actions in STATE I1-SENT\n   and
    their respective triggers:\n   +---------------------+---------------------------------------------+\n
    \  | Trigger             | Action                                      |\n   +---------------------+---------------------------------------------+\n
    \  | Receive R1, verify  | If successful, send I2 and move to I2-SENT  |\n   |
    INIT Nonce          |                                             |\n   |                     |
    If fail, discard and stay in I1-SENT        |\n   |                     |                                             |\n
    \  | Receive I1          | Send R2 and stay in I1-SENT                 |\n   |
    \                    |                                             |\n   | Receive
    R2, verify  | If successful, move to ESTABLISHED          |\n   | INIT Nonce          |
    \                                            |\n   |                     | If
    fail, discard and stay in I1-SENT        |\n   |                     |                                             |\n
    \  | Receive I2, verify  | If successful, send R2 and move to          |\n   |
    validator and RESP  | ESTABLISHED                                 |\n   | Nonce
    \              |                                             |\n   |                     |
    If fail, discard and stay in I1-SENT        |\n   |                     |                                             |\n
    \  | Receive I2bis,      | If successful, send R2 and move to          |\n   |
    verify validator    | ESTABLISHED                                 |\n   | and
    RESP Nonce      |                                             |\n   |                     |
    If fail, discard and stay in I1-SENT        |\n   |                     |                                             |\n
    \  | Timeout, increment  | If counter =< I1_RETRIES_MAX, send I1 and   |\n   |
    timeout counter     | stay in I1-SENT                             |\n   |                     |
    \                                            |\n   |                     | If
    counter > I1_RETRIES_MAX, go to E-FAILED |\n   |                     |                                             |\n
    \  | Receive ICMP payload| Move to E-FAILED                            |\n   |
    unknown error       |                                             |\n   |                     |
    \                                            |\n   | R1bis               | N/A
    (Dispatcher doesn't deliver since       |\n   |                     | CT(peer)
    is not set)                        |\n   |                     |                                             |\n
    \  | Receive Payload     | Discard and stay in I1-SENT                 |\n   |
    Extension header    |                                             |\n   | or other
    control    |                                             |\n   | packet              |
    \                                            |\n   +---------------------+---------------------------------------------+\n
    \  The following table describes the possible actions in STATE I2-SENT\n   and
    their respective triggers:\n   +---------------------+---------------------------------------------+\n
    \  | Trigger             | Action                                      |\n   +---------------------+---------------------------------------------+\n
    \  | Receive R2, verify  | If successful, move to ESTABLISHED          |\n   |
    INIT Nonce          |                                             |\n   |                     |
    If fail, stay in I2-SENT                    |\n   |                     |                                             |\n
    \  | Receive I1          | Send R2 and stay in I2-SENT                 |\n   |
    \                    |                                             |\n   | Receive
    I2,         | Send R2 and stay in I2-SENT                 |\n   | verify validator
    \   |                                             |\n   | and RESP Nonce      |
    \                                            |\n   |                     |                                             |\n
    \  | Receive I2bis,      | Send R2 and stay in I2-SENT                 |\n   |
    verify validator    |                                             |\n   | and
    RESP Nonce      |                                             |\n   |                     |
    \                                            |\n   | Receive R1          | Discard
    and stay in I2-SENT                 |\n   |                     |                                             |\n
    \  | Timeout, increment  | If counter =< I2_RETRIES_MAX, send I2 and   |\n   |
    timeout counter     | stay in I2-SENT                             |\n   |                     |
    \                                            |\n   |                     | If
    counter > I2_RETRIES_MAX, send I1 and go |\n   |                     | to I1-SENT
    \                                 |\n   |                     |                                             |\n
    \  | R1bis               | N/A (Dispatcher doesn't deliver since       |\n   |
    \                    | CT(peer) is not set)                        |\n   |                     |
    \                                            |\n   | Receive Payload     | Accept
    and send I2 (probably R2 was sent    |\n   | Extension header    | by peer and
    lost)                           |\n   | or other control    |                                             |\n
    \  | packet              |                                             |\n   +---------------------+---------------------------------------------+\n
    \  The following table describes the possible actions in STATE I2BIS-\n   SENT
    and their respective triggers:\n   +---------------------+---------------------------------------------+\n
    \  | Trigger             | Action                                      |\n   +---------------------+---------------------------------------------+\n
    \  | Receive R2, verify  | If successful, move to ESTABLISHED          |\n   |
    INIT Nonce          |                                             |\n   |                     |
    If fail, stay in I2BIS-SENT                 |\n   |                     |                                             |\n
    \  | Receive I1          | Send R2 and stay in I2BIS-SENT              |\n   |
    \                    |                                             |\n   | Receive
    I2,         | Send R2 and stay in I2BIS-SENT              |\n   | verify validator
    \   |                                             |\n   | and RESP Nonce      |
    \                                            |\n   |                     |                                             |\n
    \  | Receive I2bis,      | Send R2 and stay in I2BIS-SENT              |\n   |
    verify validator    |                                             |\n   | and
    RESP Nonce      |                                             |\n   |                     |
    \                                            |\n   | Receive R1          | Discard
    and stay in I2BIS-SENT              |\n   |                     |                                             |\n
    \  | Timeout, increment  | If counter =< I2_RETRIES_MAX, send I2bis    |\n   |
    timeout counter     | and stay in I2BIS-SENT                      |\n   |                     |
    \                                            |\n   |                     | If
    counter > I2_RETRIES_MAX, send I1 and    |\n   |                     | go to I1-SENT
    \                              |\n   |                     |                                             |\n
    \  | R1bis               | N/A (Dispatcher doesn't deliver since       |\n   |
    \                    | CT(peer) is not set)                        |\n   |                     |
    \                                            |\n   | Receive Payload     | Accept
    and send I2bis (probably R2 was      |\n   | Extension header    | sent by peer
    and lost)                      |\n   | or other control    |                                             |\n
    \  | packet              |                                             |\n   +---------------------+---------------------------------------------+\n
    \  The following table describes the possible actions in STATE\n   ESTABLISHED
    and their respective triggers:\n   +---------------------+---------------------------------------------+\n
    \  | Trigger             | Action                                      |\n   +---------------------+---------------------------------------------+\n
    \  | Receive I1, compare | If no match, send R1 and stay in ESTABLISHED|\n   |
    CT(peer) with       |                                             |\n   | received
    CT         | If match, send R2 and stay in ESTABLISHED   |\n   |                     |
    \                                            |\n   |                     |                                             |\n
    \  | Receive I2, verify  | If successful, send R2 and stay in          |\n   |
    validator and RESP  | ESTABLISHED                                 |\n   | Nonce
    \              |                                             |\n   |                     |
    Otherwise, discard and stay in ESTABLISHED  |\n   |                     |                                             |\n
    \  | Receive I2bis,      | If successful, send R2 and stay in          |\n   |
    verify validator    | ESTABLISHED                                 |\n   | and
    RESP Nonce      |                                             |\n   |                     |
    Otherwise, discard and stay in ESTABLISHED  |\n   |                     |                                             |\n
    \  | Receive R2          | Discard and stay in ESTABLISHED             |\n   |
    \                    |                                             |\n   | Receive
    R1          | Discard and stay in ESTABLISHED             |\n   |                     |
    \                                            |\n   | Receive R1bis       | Send
    I2bis and move to I2BIS-SENT           |\n   |                     |                                             |\n
    \  |                     |                                             |\n   |
    Receive Payload     | Process and stay in ESTABLISHED             |\n   | Extension
    header    |                                             |\n   | or other control
    \   |                                             |\n   | packet              |
    \                                            |\n   |                     |                                             |\n
    \  | Implementation-     | Discard state and go to IDLE                |\n   |
    specific heuristic  |                                             |\n   | (e.g.,
    No open ULP  |                                             |\n   | sockets and
    idle    |                                             |\n   | for some time )
    \    |                                             |\n   +---------------------+---------------------------------------------+\n
    \  The following table describes the possible actions in STATE E-FAILED\n   and
    their respective triggers:\n   +---------------------+---------------------------------------------+\n
    \  | Trigger             | Action                                      |\n   +---------------------+---------------------------------------------+\n
    \  | Wait for            | Go to IDLE                                  |\n   |
    NO_R1_HOLDDOWN_TIME |                                             |\n   |                     |
    \                                            |\n   | Any packet          | Process
    as in IDLE                          |\n   +---------------------+---------------------------------------------+\n
    \  The following table describes the possible actions in STATE NO-\n   SUPPORT
    and their respective triggers:\n   +---------------------+---------------------------------------------+\n
    \  | Trigger             | Action                                      |\n   +---------------------+---------------------------------------------+\n
    \  | Wait for            | Go to IDLE                                  |\n   |
    ICMP_HOLDDOWN_TIME  |                                             |\n   |                     |
    \                                            |\n   | Any packet          | Process
    as in IDLE                          |\n   +---------------------+---------------------------------------------+\n"
  - contents:
    - "B.1.  Simplified STATE Machine Diagram\n                                          Timeout/Null
      \   +------------+\n                            I1/R1      +------------------|
      NO SUPPORT |\n            Payload or Control/R1bis   |                  +------------+\n
      \                       +---------+    |                              ^\n                        |
      \        |    |               ICMP Error/Null|\n                        |         V
      \   V                              |\n                      +-----------------+
      \ Timeout/Null  +----------+ |\n                      |                 |<---------------|
      E-FAILED | |\n                    +-|      IDLE       |                +----------+
      |\n     I2 or I2bis/R2 | |                 |                          ^  |\n
      \                   | +-----------------+       (Tiemout#>MAX)/Null|  |\n                    |
      \   ^            |                            |  |\n                    |    |
      \           +------+                     |  |\n   I2 or I2bis/R2   |    |       Heuristic/I1|
      \           I1/R2    |  |\n     Payload/Null   |    |                   |       Control/Null
      \ |  |\n      I1/R1 or R2   | +--+                   |       Payload/Null  |
      \ |\n    R1 or R2/Null   | |Heuristic/Null        |  (Tiemout#<MAX)/I1  |  |\n
      \     +----------+  | |                      |         +--------+  |  |\n      |
      \         V  V |                      |         |        V  |  |\n    +-------------------+
      \  R2/Null          |        +----------------+\n    |                   |   I2
      or I2bis/R2   +------->|                |\n    |   ESTABLISHED     |<----------------------------|
      \   I1-SENT     |\n    |                   |                             |                |\n
      \   +-------------------+                             +----------------+\n       |
      \    ^        ^                                   |   ^       ^\n       |     |
      \       |R2/Null              +-------------+   |       |\n       |     |        +----------+
      \         |R1/I2            |       |\n       |     |                   |          V
      \                |       |\n       |     |               +------------------+
      \            |       |\n       |     |               |                  |-------------+
      \      |\n       |     |               |     I2-SENT      | (Timeout#>Max)/I1
      \  |\n       |     |               |                  |                     |\n
      \      |     |               +------------------+                     |\n       |
      \    |                 |              ^                       |\n       |     |
      \                +--------------+                       |\n       |     |                I1
      or I2bis or I2/R2                    |\n       |     |           (Timeout#<Max)
      or Payload/I2                 |\n       |     |                 R1 or R1bis/Null
      \                      |\n       |     +-------+                              (Timeout#>Max)/I1
      |\n       |      R2/Null|     +------------------------------------------+\n
      \      |             V     |\n       |         +-------------------+\n       |
      \        |                   |<-+ (Timeout#<Max)/I2bis\n       +-------->|   I2bis-SENT
      \     |  | I1 or I2 or I2bis/R2\n     R1bis/I2bis |                   |--+ R1
      or R1bis/Null\n                 +-------------------+    Payload/I2bis\n"
    title: B.1.  Simplified STATE Machine Diagram
  title: Appendix B.  Simplified STATE Machine
- contents:
  - "Appendix C.  Context Tag Reuse\n   The Shim6 protocol doesn't have a mechanism
    for coordinated state\n   removal between the peers because such state removal
    doesn't seem to\n   help, given that a host can crash and reboot at any time.
    \ A result\n   of this is that the protocol needs to be robust against a Context
    Tag\n   being reused for some other context.  This section summarizes the\n   different
    cases in which a Tag can be reused, and how the recovery\n   works.\n   The different
    cases are exemplified by the following case.  Assume\n   hosts A and B were communicating
    using a context with the ULID pair\n   <A1, B2>, and that B had assigned Context
    Tag X to this context.  We\n   assume that B uses only the Context Tag to demultiplex
    the received\n   Shim6 Payload Extension headers, since this is the more general
    case.\n   Further, we assume that B removes this context state, while A retains\n
    \  it.  B might then at a later time assign CT(local)=X to some other\n   context,
    at which time, we have several possible cases:\n   o  The Context Tag is reassigned
    to a context for the same ULID pair\n      <A1, B2>.  We've called this \"context
    recovery\" in this document.\n   o  The Context Tag is reassigned to a context
    for a different ULID\n      pair between the same two hosts, e.g., <A3, B3>.  We've
    called\n      this \"context confusion\" in this document.\n   o  The Context
    Tag is reassigned to a context between B and another\n      host C, for instance,
    for the ULID pair <C3, B2>.  That is a form\n      of three-party context confusion.\n"
  - contents:
    - "C.1.  Context Recovery\n   This case is relatively simple and is discussed
      in Section 7.5.  The\n   observation is that since the ULID pair is the same,
      when either A or\n   B tries to establish the new context, A can keep the old
      context\n   while B re-creates the context with the same Context Tag CT(B) =
      X.\n"
    title: C.1.  Context Recovery
  - contents:
    - "C.2.  Context Confusion\n   This case is a bit more complex and is discussed
      in Section 7.6.\n   When the new context is created, whether A or B initiates
      it, host A\n   can detect when it receives B's locator set (in the I2 or R2
      message)\n   in that it ends up with two contexts to the same peer host\n   (overlapping
      Ls(peer) locator sets) that have the same Context Tag:\n   CT(peer) = X.  At
      this point in time, host A can clear up any\n   possibility of causing confusion
      by not using the old context to send\n   any more packets.  It either just discards
      the old context (it might\n   not be used by any ULP traffic, since B had discarded
      it) or it re-\n   creates a different context for the old ULID pair (<A1, B2>),
      for\n   which B will assign a unique CT(B) as part of the normal context-\n
      \  establishment mechanism.\n"
    title: C.2.  Context Confusion
  - contents:
    - "C.3.  Three-Party Context Confusion\n   The third case does not have a place
      where the old state on A can be\n   verified since the new context is established
      between B and C.  Thus,\n   when B receives Shim6 Payload Extension headers
      with X as the Context\n   Tag, it will find the context for <C3, B2> and, hence,
      will rewrite\n   the packets to have C3 in the Source Address field and B2 in
      the\n   Destination Address field before passing them up to the ULP.  This\n
      \  rewriting is correct when the packets are in fact sent by host C, but\n   if
      host A ever happens to send a packet using the old context, then\n   the ULP
      on A sends a packet with ULIDs <A1, B2> and the packet\n   arrives at the ULP
      on B with ULIDs <C3, B2>.\n   This is clearly an error, and the packet will
      most likely be rejected\n   by the ULP on B due to a bad pseudo-header checksum.
      \ Even if the\n   checksum is okay (probability 2^-16), the ULP isn't likely
      to have a\n   connection for those ULIDs and port numbers.  And if the ULP is\n
      \  connection-less, processing the packet is most likely harmless; such\n   a
      ULP must be able to copy with random packets being sent by random\n   peers
      in any case.\n   This broken state, where packets are sent from A to B using
      the old\n   context on host A, might persist for some time but will not remain\n
      \  for very long.  The unreachability detection on host A will kick in\n   because
      it does not see any return traffic (payload or Keepalive\n   messages) for the
      context.  This will result in host A sending Probe\n   messages to host B to
      find a working locator pair.  The effect of\n   this is that host B will notice
      that it does not have a context for\n   the ULID pair <A1, B2> and CT(B) = X,
      which will make host B send an\n   R1bis packet to re-establish that context.
      \ The re-established\n   context, just like in the previous section, will get
      a unique CT(B)\n   assigned by host B; thus, there will no longer be any confusion.\n"
    title: C.3.  Three-Party Context Confusion
  - contents:
    - "C.4.  Summary\n   In summary, there are cases where a Context Tag might be
      reused while\n   some peer retains the state, but the protocol can recover from
      it.\n   The probability of these events is low, given the 47-bit Context Tag\n
      \  size.  However, it is important that these recovery mechanisms be\n   tested.
      \ Thus, during development and testing, it is recommended that\n   implementations
      not use the full 47-bit space but instead keep, for\n   example, the top 40
      bits as zero, only leaving the host with 128\n   unique Context Tags.  This
      will help test the recovery mechanisms.\n"
    title: C.4.  Summary
  title: Appendix C.  Context Tag Reuse
- contents:
  - "Appendix D.  Design Alternatives\n   This document has picked a certain set of
    design choices in order to\n   try to work out a bunch of the details and to stimulate
    discussion.\n   But, as has been discussed on the mailing list, there are other\n
    \  choices that make sense.  This appendix tries to enumerate some\n   alternatives.\n"
  - contents:
    - "D.1.  Context Granularity\n   Over the years, various suggestions have been
      made whether the shim\n   should, even if it operates at the IP layer, be aware
      of ULP\n   connections and sessions and, as a result, be able to make separate\n
      \  shim contexts for separate ULP connections and sessions.  A few\n   different
      options have been discussed:\n   o  Each ULP connection maps to its own shim
      context.\n   o  The shim is unaware of the ULP notion of connections and just\n
      \     operates on a host-to-host (IP address) granularity.\n   o  Hybrids in
      which the shim is aware of some ULPs (such as TCP) and\n      handles other
      ULPs on a host-to-host basis.\n   Having shim state for every ULP connection
      potentially means higher\n   overhead since the state-setup overhead might become
      significant;\n   there is utility in being able to amortize this over multiple\n
      \  connections.\n   But being completely unaware of the ULP connections might
      hamper ULPs\n   that want different communication to use different locator pairs,
      for\n   instance, for quality or cost reasons.\n   The protocol has a shim that
      operates with host-level granularity\n   (strictly speaking, with ULID-pair
      granularity) to be able to\n   amortize the context establishment over multiple
      ULP connections.\n   This is combined with the ability for Shim6-aware ULPs
      to request\n   context forking so that different ULP traffic can use different\n
      \  locator pairs.\n"
    title: D.1.  Context Granularity
  - contents:
    - "D.2.  Demultiplexing of Data Packets in Shim6 Communications\n   Once a ULID-pair
      context is established between two hosts, packets\n   may carry locators that
      differ from the ULIDs presented to the ULPs\n   using the established context.
      \ One of the main functions of the\n   Shim6 layer is to perform the mapping
      between the locators used to\n   forward packets through the network and the
      ULIDs presented to the\n   ULP.  In order to perform that translation for incoming
      packets, the\n   Shim6 layer needs to first identify which of the incoming packets\n
      \  need to be translated and then perform the mapping between locators\n   and
      ULIDs using the associated context.  Such operation is called\n   \"demultiplexing\".
      \ It should be noted that, because any address can\n   be used both as a locator
      and as a ULID, additional information,\n   other than the addresses carried
      in packets, needs to be taken into\n   account for this operation.\n   For example,
      if a host has addresses A1 and A2 and starts\n   communicating with a peer with
      addresses B1 and B2, then some\n   communication (connections) might use the
      pair <A1, B1> as ULID and\n   others might use, for example, <A2, B2>.  Initially
      there are no\n   failures, so these address pairs are used as locators, i.e.,
      in the\n   IP address fields in the packets on the wire.  But when there is
      a\n   failure, the Shim6 layer on A might decide to send packets that used\n
      \  <A1, B1> as ULIDs using <A2, B2> as the locators.  In this case, B\n   needs
      to be able to rewrite the IP address field for some packets and\n   not others,
      but the packets all have the same locator pair.\n   In order to accomplish the
      demultiplexing operation successfully,\n   data packets carry a Context Tag
      that allows the receiver of the\n   packet to determine the shim context to
      be used to perform the\n   operation.\n   Two mechanisms for carrying the Context
      Tag information have been\n   considered in depth during the shim protocol design:
      those carrying\n   the Context Tag in the Flow Label field of the IPv6 header
      and those\n   using a new Extension header to carry the Context Tag.  In this\n
      \  appendix, we will describe the pros and cons of each mechanism and\n   justify
      the selected option.\n"
    - contents:
      - "D.2.1.  Flow Label\n   A possible approach is to carry the Context Tag in
        the Flow Label\n   field of the IPv6 header.  This means that when a Shim6
        context is\n   established, a Flow Label value is associated with this context
        (and\n   perhaps a separate Flow Label for each direction).\n   The simplest
        way to do this is to have the triple <Flow Label, Source\n   Locator, Destination
        Locator> identify the context at the receiver.\n   The problem with this approach
        is that, because the locator sets are\n   dynamic, it is not possible at any
        given moment to be sure that two\n   contexts for which the same Context Tag
        is allocated will have\n   disjoint locator sets during the lifetime of the
        contexts.\n   Suppose that Node A has addresses IPA1, IPA2, IPA3, and IPA4
        and that\n   Host B has addresses IPB1 and IPB2.\n   Suppose that two different
        contexts are established between Host A\n   and Host B.\n   Context #1 is
        using IPA1 and IPB1 as ULIDs.  The locator set\n   associated to IPA1 is IPA1
        and IPA2, while the locator set associated\n   to IPB1 is just IPB1.\n   Context
        #2 uses IPA3 and IPB2 as ULIDs.  The locator set associated\n   to IPA3 is
        IPA3 and IPA4, while the locator set associated to IPB2 is\n   just IPB2.\n
        \  Because the locator sets of Context #1 and Context #2 are disjoint,\n   hosts
        could think that the same Context Tag value can be assigned to\n   both of
        them.  The problem arrives when, later on, IPA3 is added as a\n   valid locator
        for IPA1 in Context #2 and IPB2 is added as a valid\n   locator for IPB1 in
        Context #1.  In this case, the triple <Flow\n   Label, Source Locator, Destination
        Locator> would not identify a\n   unique context anymore, and correct demultiplexing
        is no longer\n   possible.\n   A possible approach to overcome this limitation
        is to simply not\n   repeat the Flow Label values for any communication established
        in a\n   host.  This basically means that each time a new communication that\n
        \  is using different ULIDs is established, a new Flow Label value is\n   assigned
        to it.  By these means, each communication that is using\n   different ULIDs
        can be differentiated because each has a different\n   Flow Label value.\n
        \  The problem with such an approach is that it requires the receiver of\n
        \  the communication to allocate the Flow Label value used for incoming\n
        \  packets, in order to assign them uniquely.  For this, a shim\n   negotiation
        of the Flow Label value to use in the communication is\n   needed before exchanging
        data packets.  This poses problems with non-\n   Shim6-capable hosts, since
        they would not be able to negotiate an\n   acceptable value for the Flow Label.
        \ This limitation can be lifted\n   by marking the packets that belong to
        shim sessions from those that\n   do not.  These markings would require at
        least a bit in the IPv6\n   header that is not currently available, so more
        creative options\n   would be required, for instance, using new Next Header
        values to\n   indicate that the packet belongs to a Shim6-enabled communication
        and\n   that the Flow Label carries context information as proposed in [8].\n
        \  However, even if new Next Header values are used in this way, such an\n
        \  approach is incompatible with the deferred-establishment capability\n   of
        the shim protocol, which is a preferred function since it\n   suppresses delay
        due to shim context establishment prior to the\n   initiation of communication.
        \ Such capability also allows nodes to\n   define at which stage of the communication
        they decide, based on\n   their own policies, that a given communication requires
        protection by\n   the shim.\n   In order to cope with the identified limitations,
        an alternative\n   approach that does not constrain the Flow Label values
        that are used\n   by communications using ULIDs equal to the locators (i.e.,
        no shim\n   translation) is to only require that different Flow Label values
        are\n   assigned to different shim contexts.  In such an approach,\n   communications
        start with unmodified Flow Label usage (could be zero\n   or as suggested
        in [12]).  The packets sent after a failure when a\n   different locator pair
        is used would use a completely different Flow\n   Label, and this Flow Label
        could be allocated by the receiver as part\n   of the shim context establishment.
        \ Since it is allocated during the\n   context establishment, the receiver
        of the \"failed over\" packets can\n   pick a Flow Label of its choosing (that
        is unique in the sense that\n   no other context is using it as a Context
        Tag), without any\n   performance impact, respecting that, for each locator
        pair, the Flow\n   Label value used for a given locator pair doesn't change
        due to the\n   operation of the multihoming shim.\n   In this approach, the
        constraint is that Flow Label values being used\n   as context identifiers
        cannot be used by other communications that\n   use non-disjoint locator sets.
        \ This means that once a given Flow\n   Label value has been assigned to a
        shim context that has a certain\n   locator sets associated, the same value
        cannot be used for other\n   communications that use an address pair that
        is contained in the\n   locator sets of the context.  This is a constraint
        in the potential\n   Flow Label allocation strategies.\n   A possible workaround
        to this constraint is to mark shim packets that\n   require translation, in
        order to differentiate them from regular IPv6\n   packets, using the artificial
        Next Header values described above.  In\n   this case, the Flow Label values
        constrained are only those of the\n   packets that are being translated by
        the shim.  This last approach\n   would be the preferred approach if the Context
        Tag is to be carried\n   in the Flow Label field.  This is the case not only
        because it\n   imposes the minimum constraints to the Flow Label allocation\n
        \  strategies, limiting the restrictions only to those packets that need\n
        \  to be translated by the shim, but also because context-loss detection\n
        \  mechanisms greatly benefit from the fact that shim data packets are\n   identified
        as such, allowing the receiving end to identify if a shim\n   context associated
        to a received packet is supposed to exist, as will\n   be discussed in the
        context-loss detection appendix below.\n"
      title: D.2.1.  Flow Label
    - contents:
      - "D.2.2.  Extension Header\n   Another approach, which is the one selected
        for this protocol, is to\n   carry the Context Tag in a new Extension header.
        \ These Context Tags\n   are allocated by the receiving end during the Shim6
        protocol initial\n   negotiation, implying that each context will have two
        Context Tags,\n   one for each direction.  Data packets will be demultiplexed
        using the\n   Context Tag carried in the Extension header.  This seems a clean\n
        \  approach since it does not overload existing fields.  However, it\n   introduces
        additional overhead in the packet due to the additional\n   header.  The additional
        overhead introduced is 8 octets.  However, it\n   should be noted that the
        Context Tag is only required when a locator\n   other than the one used as
        ULID is contained in the packet.  Packets\n   where both the Source and Destination
        Address fields contain the\n   ULIDs do not require a Context Tag, since no
        rewriting is necessary\n   at the receiver.  This approach would reduce the
        overhead because the\n   additional header is only required after a failure.
        \ On the other\n   hand, this approach would cause changes in the available
        MTU for some\n   packets, since packets that include the Extension header
        will have an\n   MTU that is 8 octets shorter.  However, path changes through
        the\n   network can result in a different MTU in any case; thus, having a\n
        \  locator change, which implies a path change, affect the MTU doesn't\n   introduce
        any new issues.\n"
      title: D.2.2.  Extension Header
    title: D.2.  Demultiplexing of Data Packets in Shim6 Communications
  - contents:
    - "D.3.  Context-Loss Detection\n   In this appendix, we will present different
      approaches considered to\n   detect context loss and potential context-recovery
      strategies.  The\n   scenario being considered is the following: Node A and
      Node B are\n   communicating using IPA1 and IPB1.  Sometime later, a shim context
      is\n   established between them, with IPA1 and IPB1 as ULIDs and with\n   IPA1,...,IPAn
      and IPB1,...,IPBm as locator sets, respectively.\n   It may happen that, later
      on, one of the hosts (e.g., Host A) loses\n   the shim context.  The reason
      for this can be that Host A has a more\n   aggressive garbage collection policy
      than Host B or that an error\n   occurred in the shim layer at Host A and resulted
      in the loss of the\n   context state.\n   The mechanisms considered in this
      appendix are aimed at dealing with\n   this problem.  There are essentially
      two tasks that need to be\n   performed in order to cope with this problem:
      first, the context loss\n   must be detected and, second, the context needs
      to be recovered/\n   re-established.\n   Mechanisms for detecting context loss.\n
      \  These mechanisms basically consist in each end of the context that\n   periodically
      sends a packet containing context-specific information\n   to the other end.
      \ Upon reception of such packets, the receiver\n   verifies that the required
      context exists.  In the case that the\n   context does not exist, it sends a
      packet notifying the sender of the\n   problem.\n   An obvious alternative for
      this would be to create a specific context\n   keepalive exchange, which consists
      in periodically sending packets\n   with this purpose.  This option was considered
      and discarded because\n   it seemed an overkill to define a new packet exchange
      to deal with\n   this issue.\n   Another alternative is to piggyback the context-loss
      detection\n   function in other existent packet exchanges.  In particular, both\n
      \  shim control and data packets can be used for this.\n   Shim control packets
      can be trivially used for this because they\n   carry context-specific information.
      \ This way, when a node receives\n   one such packet, it will verify if the
      context exists.  However, shim\n   control frequency may not be adequate for
      context-loss detection\n   since control packet exchanges can be very limited
      for a session in\n   certain scenarios.\n   Data packets, on the other hand,
      are expected to be exchanged with a\n   higher frequency but do not necessarily
      carry context-specific\n   information.  In particular, packets flowing before
      a locator change\n   (i.e., a packet carrying the ULIDs in the address fields)
      do not need\n   context information since they do not need any shim processing.\n
      \  Packets that carry locators that differ from the ULIDs carry context\n   information.\n
      \  However, we need to make a distinction here between the different\n   approaches
      considered to carry the Context Tag -- in particular,\n   between those approaches
      where packets are explicitly marked as shim\n   packets and those approaches
      where packets are not marked as such.\n   For instance, in the case where the
      Context Tag is carried in the\n   Flow Label and packets are not marked as shim
      packets (i.e., no new\n   Next Header values are defined for shim), a receiver
      that has lost\n   the associated context is not able to detect that the packet
      is\n   associated with a missing context.  The result is that the packet\n   will
      be passed unchanged to the upper-layer protocol, which in turn\n   will probably
      silently discard it due to a checksum error.  The\n   resulting behavior is
      that the context loss is undetected.  This is\n   one additional reason to discard
      an approach that carries the Context\n   Tag in the Flow Label field and does
      not explicitly mark the shim\n   packets as such.  On the other hand, approaches
      that mark shim data\n   packets (like those that use the Extension header or
      the Flow Label\n   with new Next Header values) allow the receiver to detect
      if the\n   context associated to the received packet is missing.  In this case,\n
      \  data packets also perform the function of a context-loss detection\n   exchange.
      \ However, it must be noted that only those packets that\n   carry a locator
      that differs from the ULID are marked.  This\n   basically means that context
      loss will be detected after an outage\n   has occurred, i.e., alternative locators
      are being used.\n   Summarizing, the proposed context-loss detection mechanisms
      use shim\n   control packets and Shim6 Payload Extension headers to detect context\n
      \  loss.  Shim control packets detect context loss during the whole\n   lifetime
      of the context, but the expected frequency in some cases is\n   very low.  On
      the other hand, Shim6 Payload Extension headers have a\n   higher expected frequency
      in general, but they only detect context\n   loss after an outage.  This behavior
      implies that it will be common\n   that context loss is detected after a failure,
      i.e., once it is\n   actually needed.  Because of that, a mechanism for recovering
      from\n   context loss is required if this approach is used.\n   Overall, the
      mechanism for detecting lost context would work as\n   follows: the end that
      still has the context available sends a message\n   referring to the context.
      \ Upon the reception of such message, the\n   end that has lost the context
      identifies the situation and notifies\n   the other end of the context-loss
      event by sending a packet\n   containing the lost context information extracted
      from the received\n   packet.\n   One option is to simply send an error message
      containing the received\n   packets (or at least as much of the received packet
      that the MTU\n   allows to fit).  One of the goals of this notification is to
      allow\n   the other end that still retains context state to re-establish the\n
      \  lost context.  The mechanism to re-establish the lost context\n   consists
      in performing the 4-way initial handshake.  This is a time-\n   consuming exchange
      and, at this point, time may be critical since we\n   are re-establishing a
      context that is currently needed (because\n   context-loss detection may occur
      after a failure).  So another\n   option, which is the one used in this protocol,
      is to replace the\n   error message with a modified R1 message so that the time
      required to\n   perform the context-establishment exchange can be reduced.  Upon
      the\n   reception of this modified R1 message, the end that still has the\n
      \  context state can finish the context-establishment exchange and\n   restore
      the lost context.\n"
    title: D.3.  Context-Loss Detection
  - contents:
    - "D.4.  Securing Locator Sets\n   The adoption of a protocol like SHIM, which
      allows the binding of a\n   given ULID with a set of locators, opens the door
      for different types\n   of redirection attacks as described in [15].  The goal,
      in terms of\n   security, for the design of the shim protocol is to not introduce
      any\n   new vulnerability into the Internet architecture.  It is a non-goal\n
      \  to provide additional protection other than what is currently\n   available
      in the single-homed IPv6 Internet.\n   Multiple security mechanisms were considered
      to protect the shim\n   protocol.  In this appendix we will present some of
      them.\n   The simplest option to protect the shim protocol is to use cookies,\n
      \  i.e., a randomly generated bit string that is negotiated during the\n   context-establishment
      phase and then is included in subsequent\n   signaling messages.  By these means,
      it would be possible to verify\n   that the party that was involved in the initial
      handshake is the same\n   party that is introducing new locators.  Moreover,
      before using a new\n   locator, an exchange is performed through the new locator,
      verifying\n   that the party located at the new locator knows the cookie, i.e.,\n
      \  that it is the same party that performed the initial handshake.\n   While
      this security mechanism does indeed provide a fair amount of\n   protection,
      it leaves the door open for so-called time-shifted\n   attacks.  In these attacks,
      an attacker on the path discovers the\n   cookie by sniffing any signaling message.
      \ After that, the attacker\n   can leave the path and still perform a redirection
      attack since, as\n   he is in possession of the cookie, he can introduce a new
      locator\n   into the locator set and can also successfully perform the\n   reachability
      exchange if he is able to receive packets at the new\n   locator.  The difference
      with the current single-homed IPv6 situation\n   is that in the current situation
      the attacker needs to be on-path\n   during the whole lifetime of the attack,
      while in this new situation\n   (where only cookie protection is provided),
      an attacker that was once\n   on the path can perform attacks after he has left
      the on-path\n   location.\n   Moreover, because the cookie is included in signaling
      messages, the\n   attacker can discover the cookie by sniffing any of them,
      making the\n   protocol vulnerable during the whole lifetime of the shim context.
      \ A\n   possible approach to increase security is to use a shared secret,\n
      \  i.e., a bit string that is negotiated during the initial handshake\n   but
      that is used as a key to protect following messages.  With this\n   technique,
      the attacker must be present on the path and sniffing\n   packets during the
      initial handshake, since this is the only moment\n   when the shared secret
      is exchanged.  Though it imposes that the\n   attacker must be on path at a
      very specific moment (the establishment\n   phase), and though it improves security,
      this approach is still\n   vulnerable to time-shifted attacks.  It should be
      noted that,\n   depending on protocol details, an attacker may be able to force
      the\n   re-creation of the initial handshake (for instance, by blocking\n   messages
      and making the parties think that the context has been\n   lost); thus, the
      resulting situation may not differ that much from\n   the cookie-based approach.\n
      \  Another option that was discussed during the design of this protocol\n   was
      the possibility of using IPsec for protecting the shim protocol.\n   Now, the
      problem under consideration in this scenario is how to\n   securely bind an
      address that is being used as ULID with a locator\n   set that can be used to
      exchange packets.  The mechanism provided by\n   IPsec to securely bind the
      address that is used with cryptographic\n   keys is the usage of digital certificates.
      \ This implies that an\n   IPsec-based solution would require a common and mutually
      trusted\n   third party to generate digital certificates that bind the key and\n
      \  the ULID.  Considering that the scope of application of the shim\n   protocol
      is global, this would imply a global public key\n   infrastructure (PKI).  The
      major issues with this approach are the\n   deployment difficulties associated
      with a global PKI.  The other\n   possibility would be to use some form of opportunistic
      IPSec, like\n   Better-Than-Nothing-Security (BTNS) [22].  However, this would
      still\n   present some issues.  In particular, this approach requires a leap-\n
      \  of-faith in order to bind a given address to the public key that is\n   being
      used, which would actually prevent the most critical security\n   feature that
      a Shim6 security solution needs to achieve from being\n   provided: proving
      identifier ownership.  On top of that, using IPsec\n   would require to turn
      on per-packet AH/ESP just for multihoming to\n   occur.\n   In general, SHIM6
      was expected to work between pairs of hosts that\n   have no prior arrangement,
      security association, or common, trusted\n   third party.  It was also seen
      as undesirable to have to turn on per-\n   packet AH/ESP just for the multihoming
      to occur.  However, Shim6\n   should work and have an additional level of security
      where two hosts\n   choose to use IPsec.\n   Another design alternative would
      have employed some form of\n   opportunistic or Better-Than-Nothing Security
      (BTNS) IPsec to perform\n   these tasks with IPsec instead.  Essentially, HIP
      in opportunistic\n   mode is very similar to SHIM6, except that HIP uses IPsec,
      employs\n   per-packet ESP, and introduces another set of identifiers.\n   Finally,
      two different technologies were selected to protect the shim\n   protocol: HBA
      [3] and CGA [2].  These two techniques provide a\n   similar level of protection
      but also provide different functionality\n   with different computational costs.\n
      \  The HBA mechanism relies on the capability of generating all the\n   addresses
      of a multihomed host as an unalterable set of intrinsically\n   bound IPv6 addresses,
      known as an HBA set.  In this approach,\n   addresses incorporate a cryptographic
      one-way hash of the prefix set\n   available into the interface identifier part.
      \ The result is that the\n   binding between all the available addresses is
      encoded within the\n   addresses themselves, providing hijacking protection.
      \ Any peer using\n   the shim protocol node can efficiently verify that the
      alternative\n   addresses proposed for continuing the communication are bound
      to the\n   initial address through a simple hash calculation.  A limitation
      of\n   the HBA technique is that, once generated, the address set is fixed\n
      \  and cannot be changed without also changing all the addresses of the\n   HBA
      set.  In other words, the HBA technique does not support dynamic\n   addition
      of address to a previously generated HBA set.  An advantage\n   of this approach
      is that it requires only hash operations to verify a\n   locator set, imposing
      very low computational cost to the protocol.\n   In a CGA-based approach, the
      address used as ULID is a CGA that\n   contains a hash of a public key in its
      interface identifier.  The\n   result is a secure binding between the ULID and
      the associated key\n   pair.  This allows each peer to use the corresponding
      private key to\n   sign the shim messages that convey locator set information.
      \ The\n   trust chain in this case is the following: the ULID used for the\n
      \  communication is securely bound to the key pair because it contains\n   the
      hash of the public key, and the locator set is bound to the\n   public key through
      the signature.  The CGA approach then supports\n   dynamic addition of new locators
      in the locator set, since in order\n   to do that the node only needs to sign
      the new locator with the\n   private key associated with the CGA used as ULID.
      \ A limitation of\n   this approach is that it imposes systematic usage of public
      key\n   cryptography with its associate computational cost.\n   Either of these
      two mechanisms, HBA and CGA, provides time-shifted\n   attack protection, since
      the ULID is securely bound to a locator set\n   that can only be defined by
      the owner of the ULID.\n   So the design decision adopted was that both mechanisms,
      HBA and CGA,\n   are supported.  This way, when only stable address sets are
      required,\n   the nodes can benefit from the low computational cost offered
      by HBA,\n   while when dynamic locator sets are required, this can be achieved\n
      \  through CGAs with an additional cost.  Moreover, because HBAs are\n   defined
      as a CGA extension, the addresses available in a node can\n   simultaneously
      be CGAs and HBAs, allowing the usage of the HBA and\n   CGA functionality when
      needed, without requiring a change in the\n   addresses used.\n"
    title: D.4.  Securing Locator Sets
  - contents:
    - "D.5.  ULID-Pair Context-Establishment Exchange\n   Two options were considered
      for the ULID-pair context-establishment\n   exchange: a 2-way handshake and
      a 4-way handshake.\n   A key goal for the design of this exchange was protection
      against DoS\n   attacks.  The attack under consideration was basically a situation\n
      \  where an attacker launches a great amount of ULID-pair establishment-\n   request
      packets, exhausting the victim's resources similarly to TCP\n   SYN flooding
      attacks.\n   A 4-way handshake exchange protects against these attacks because
      the\n   receiver does not create any state associated to a given context\n   until
      the reception of the second packet, which contains prior-\n   contact proof
      in the form of a token.  At this point, the receiver\n   can verify that at
      least the address used by the initiator is valid\n   to some extent, since the
      initiator is able to receive packets at\n   this address.  In the worst case,
      the responder can track down the\n   attacker using this address.  The drawback
      of this approach is that\n   it imposes a 4-packet exchange for any context
      establishment.  This\n   would be a great deal if the shim context needed to
      be established up\n   front, before the communication can proceed.  However,
      thanks to the\n   deferred context-establishment capability of the shim protocol,
      this\n   limitation has a reduced impact in the performance of the protocol.\n
      \  (However, it may have a greater impact in the situation of context\n   recovery,
      as discussed earlier.  However, in this case, it is\n   possible to perform
      optimizations to reduce the number of packets as\n   described above.)\n   The
      other option considered was a 2-way handshake with the\n   possibility to fall
      back to a 4-way handshake in case of attack.  In\n   this approach, the ULID-pair
      establishment exchange normally consists\n   of a 2-packet exchange and does
      not verify that the initiator has\n   performed a prior contact before creating
      context state.  In case a\n   DoS attack is detected, the responder falls back
      to a 4-way handshake\n   similar to the one described previously, in order to
      prevent the\n   detected attack from proceeding.  The main difficulty with this\n
      \  attack is how to detect that a responder is currently under attack.\n   It
      should be noted that, because this is a 2-way exchange, it is not\n   possible
      to use the number of half-open sessions (as in TCP) to\n   detect an ongoing
      attack; different heuristics need to be considered.\n   The design decision
      taken was that, considering the current impact of\n   DoS attacks and the low
      impact of the 4-way exchange in the shim\n   protocol (thanks to the deferred
      context-establishment capability), a\n   4-way exchange would be adopted for
      the base protocol.\n"
    title: D.5.  ULID-Pair Context-Establishment Exchange
  - contents:
    - "D.6.  Updating Locator Sets\n   There are two possible approaches to the addition
      and removal of\n   locators: atomic and differential approaches.  The atomic
      approach\n   essentially sends the complete locator set each time a variation
      in\n   the locator set occurs.  The differential approach sends the\n   differences
      between the existing locator set and the new one.  The\n   atomic approach imposes
      additional overhead since all of the locator\n   set has to be exchanged each
      time, while the differential approach\n   requires re-synchronization of both
      ends through changes (i.e.,\n   requires that both ends have the same idea about
      what the current\n   locator set is).\n   Because of the difficulties imposed
      by the synchronization\n   requirement, the atomic approach was selected.\n"
    title: D.6.  Updating Locator Sets
  - contents:
    - "D.7.  State Cleanup\n   There are essentially two approaches for discarding
      an existing state\n   about locators, keys, and identifiers of a correspondent
      node: a\n   coordinated approach and an unilateral approach.\n   In the unilateral
      approach, each node discards information about the\n   other node without coordination
      with the other node, based on some\n   local timers and heuristics.  No packet
      exchange is required for\n   this.  In this case, it would be possible that
      one of the nodes has\n   discarded the state while the other node still hasn't.
      \ In this case,\n   a No Context Error message may be required to inform the
      other node\n   about the situation; possibly a recovery mechanism is also needed.\n
      \  A coordinated approach would use an explicit CLOSE mechanism, akin to\n   the
      one specified in HIP [20].  If an explicit CLOSE handshake and\n   associated
      timer is used, then there would no longer be a need for\n   the No Context Error
      message due to a peer having garbage collected\n   at its end of the context.
      \ However, there is still potentially a\n   need to have a No Context Error
      message in the case of a complete\n   state loss of the peer (also known as
      a crash followed by a reboot).\n   Only if we assume that the reboot takes at
      least the time of the\n   CLOSE timer, or that it is okay to not provide complete
      service until\n   CLOSE-timer minutes after the crash, can we completely do
      away with\n   the No Context Error message.\n   In addition, another aspect
      that is relevant for this design choice\n   is the context confusion issue.
      \ In particular, using a unilateral\n   approach to discard context state clearly
      opens up the possibility of\n   context confusion, where one of the ends unilaterally
      discards the\n   context state, while the other does not.  In this case, the
      end that\n   has discarded the state can re-use the Context Tag value used for
      the\n   discarded state for another context, creating potential context\n   confusion.
      \ In order to illustrate the cases where problems would\n   arise, consider
      the following scenario:\n   o  Hosts A and B establish context 1 using CTA and
      CTB as Context\n      Tags.\n   o  Later on, A discards context 1 and the Context
      Tag value CTA\n      becomes available for reuse.\n   o  However, B still keeps
      context 1.\n   This would create context confusion in the following two cases:\n
      \  o  A new context 2 is established between A and B with a different\n      ULID
      pair (or Forked Instance Identifier), and A uses CTA as the\n      Context Tag.
      \ If the locator sets used for both contexts are not\n      disjoint, we have
      context confusion.\n   o  A new context is established between A and C, and
      A uses CTA as\n      the Context Tag value for this new context.  Later on,
      B sends\n      Payload Extension header and/or control messages containing CTA,\n
      \     which could be interpreted by A as belonging to context 2 (if no\n      proper
      care is taken).  Again we have context confusion.\n   One could think that using
      a coordinated approach would eliminate\n   such context confusion, making the
      protocol much simpler.  However,\n   this is not the case, because even in the
      case of a coordinated\n   approach using a CLOSE/CLOSE ACK exchange, there is
      still the\n   possibility of a host rebooting without having the time to perform\n
      \  the CLOSE exchange.  So, it is true that the coordinated approach\n   eliminates
      the possibility of context confusion due to premature\n   garbage collection,
      but it does not prevent the same situations due\n   to a crash and reboot of
      one of the involved hosts.  The result is\n   that, even if we went for a coordinated
      approach, we would still need\n   to deal with context confusion and provide
      the means to detect and\n   recover from these situations.\n"
    title: D.7.  State Cleanup
  title: Appendix D.  Design Alternatives
- contents:
  - "Authors' Addresses\n   Erik Nordmark\n   Sun Microsystems\n   17 Network Circle\n
    \  Menlo Park, CA 94025\n   USA\n   Phone: +1 650 786 2921\n   EMail: erik.nordmark@sun.com\n
    \  Marcelo Bagnulo\n   Universidad Carlos III de Madrid\n   Av. Universidad 30\n
    \  Leganes, Madrid  28911\n   SPAIN\n   Phone: +34 91 6248814\n   EMail: marcelo@it.uc3m.es\n
    \  URI:   http://www.it.uc3m.es\n"
  title: Authors' Addresses
