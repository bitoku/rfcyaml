- title: __initial_text__
  contents:
  - '        The EAP Protected One-Time Password Protocol (EAP-POTP)

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a general Extensible Authentication Protocol\n\
    \   (EAP) method suitable for use with One-Time Password (OTP) tokens,\n   and\
    \ offers particular advantages for tokens with direct electronic\n   interfaces\
    \ to their associated clients.  The method can be used to\n   provide unilateral\
    \ or mutual authentication, and key material, in\n   protocols utilizing EAP,\
    \ such as PPP, IEEE 802.1X, and Internet Key\n   Exchange Protocol Version 2 (IKEv2).\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Scope ......................................................4\n  \
    \    1.2. Background .................................................4\n    \
    \  1.3. Rationale behind the Design ................................4\n      1.4.\
    \ Relationship with EAP Methods in RFC 3748 ..................5\n   2. Conventions\
    \ Used in This Document ...............................5\n   3. Authentication\
    \ Model ............................................5\n   4. Description of the\
    \ EAP-POTP Method ..............................6\n      4.1. Overview ...................................................6\n\
    \      4.2. Version Negotiation ........................................9\n  \
    \    4.3. Cryptographic Algorithm Negotiation .......................10\n    \
    \  4.4. Session Resumption ........................................11\n      4.5.\
    \ Key Derivation and Session Identifiers ....................13\n      4.6. Error\
    \ Handling and Result Indications .....................13\n      4.7. Use of the\
    \ EAP Notification Method ........................14\n      4.8. Protection against\
    \ Brute-Force Attacks ....................14\n      4.9. MAC Calculations in EAP-POTP\
    \ ..............................16\n           4.9.1. Introduction .......................................16\n\
    \           4.9.2. MAC Calculation ....................................16\n  \
    \         4.9.3. Message Hash Algorithm .............................16\n    \
    \       4.9.4. Design Rationale ...................................17\n      \
    \     4.9.5. Implementation Considerations ......................17\n      4.10.\
    \ EAP-POTP Packet Format ...................................17\n      4.11. EAP-POTP\
    \ TLV Objects .....................................20\n           4.11.1. Version\
    \ TLV .......................................20\n           4.11.2. Server-Info\
    \ TLV ...................................21\n           4.11.3. OTP TLV ...........................................23\n\
    \           4.11.4. NAK TLV ...........................................33\n  \
    \         4.11.5. New PIN TLV .......................................35\n    \
    \       4.11.6. Confirm TLV .......................................38\n      \
    \     4.11.7. Vendor-Specific TLV ...............................41\n        \
    \   4.11.8. Resume TLV ........................................43\n          \
    \ 4.11.9. User Identifier TLV ...............................46\n           4.11.10.\
    \ Token Key Identifier TLV .........................47\n           4.11.11. Time\
    \ Stamp TLV ...................................48\n           4.11.12. Counter\
    \ TLV ......................................49\n           4.11.13. Challenge\
    \ TLV ....................................50\n           4.11.14. Keep-Alive TLV\
    \ ...................................51\n           4.11.15. Protected TLV ....................................52\n\
    \           4.11.16. Crypto Algorithm TLV .............................54\n  \
    \ 5. EAP Key Management Framework Considerations ....................57\n   6.\
    \ Security Considerations ........................................57\n      6.1.\
    \ Security Claims ...........................................57\n      6.2. Passive\
    \ and Active Attacks ................................58\n      6.3. Denial-of-Service\
    \ Attacks .................................59\n      6.4. The Use of Pepper .........................................59\n\
    \      6.5. The Race Attack ...........................................60\n  \
    \ 7. IANA Considerations ............................................60\n    \
    \  7.1. General ...................................................60\n      7.2.\
    \ Cryptographic Algorithm Identifier Octets .................61\n   8. Intellectual\
    \ Property Considerations ...........................61\n   9. Acknowledgments\
    \ ................................................61\n   10. References ....................................................62\n\
    \      10.1. Normative References .....................................62\n  \
    \    10.2. Informative References ...................................62\n   Appendix\
    \ A. Profile of EAP-POTP for RSA SecurID ...................64\n   Appendix B.\
    \ Examples of EAP-POTP Exchanges ........................65\n      B.1. Basic\
    \ Mode, Unilateral Authentication .....................65\n      B.2. Basic Mode,\
    \ Session Resumption ............................66\n      B.3. Mutual Authentication\
    \ without Session Resumption ..........67\n      B.4. Mutual Authentication with\
    \ Transfer of Pepper .............69\n      B.5. Failed Mutual Authentication\
    \ ..............................70\n      B.6. Session Resumption ........................................71\n\
    \      B.7. Failed Session Resumption .................................73\n  \
    \    B.8. Mutual Authentication, and New PIN Requested ..............75\n    \
    \  B.9. Use of Next OTP Mode ......................................78\n   Appendix\
    \ C. Use of the MPPE-Send/Receive-Key RADIUS Attributes ....80\n      C.1. Introduction\
    \ ..............................................80\n      C.2. MPPE Key Attribute\
    \ Population .............................80\n   Appendix D. Key Strength Considerations\
    \ ...........................80\n      D.1. Introduction ..............................................80\n\
    \      D.2. Example 1: 6-Digit One-Time Passwords .....................81\n  \
    \    D.3. Example 2: 8-Digit One-Time Passwords .....................81\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1.  Scope
  contents:
  - "1.1.  Scope\n   This document describes an Extensible Authentication Protocol\
    \ (EAP)\n   [1] method suitable for use with One-Time Password (OTP) tokens, and\n\
    \   offers particular advantages for tokens that are electronically\n   connected\
    \ to a user's computer, e.g., through a USB interface.  The\n   method can be\
    \ used to provide unilateral or mutual authentication,\n   and key material, in\
    \ protocols utilizing EAP, such as PPP [10], IEEE\n   802.1X [11], and IKEv2 [12].\n"
- title: 1.2.  Background
  contents:
  - "1.2.  Background\n   A One-Time Password (OTP) token may be a handheld hardware\
    \ device, a\n   hardware device connected to a personal computer through an\n\
    \   electronic interface such as USB, or a software module resident on a\n   personal\
    \ computer, which generates one-time passwords that may be\n   used to authenticate\
    \ a user towards some service.  This document\n   describes an EAP method intended\
    \ to meet the needs of organizations\n   wishing to use OTP tokens in an interoperable\
    \ manner to authenticate\n   users over EAP.  The method is designed to be independent\
    \ of\n   particular OTP algorithms and to meet the requirements on modern EAP\n\
    \   methods (see [13]).\n   The basic variant of this method provides client authentication\
    \ only.\n   This mode is only to be used within a secured tunnel.  A more\n  \
    \ advanced variant provides mutual authentication, integrity protection\n   of\
    \ the exchange, protection against eavesdroppers, and establishment\n   of authenticated\
    \ keying material.  Both variants allow for fast\n   session resumption.\n   While\
    \ this document also includes a profile of the general method for\n   the RSA\
    \ SecurID(TM) mechanism, it is described in terms of general\n   constructions.\
    \  It is therefore intended that the document will also\n   serve as a framework\
    \ for use with other OTP algorithms.\n   Note: The term \"OTP\" as used herein\
    \ shall not be confused with the\n   EAP OTP method defined in [1].\n"
- title: 1.3.  Rationale behind the Design
  contents:
  - "1.3.  Rationale behind the Design\n   EAP-POTP has been designed with the intent\
    \ that its messages and data\n   elements be easily parsed by EAP implementations.\
    \  This makes it\n   easier to programmatically use the EAP method in the peer\
    \ and the\n   authenticator, reducing the need for user interactions and allowing\n\
    \   for local generation of user prompts, when needed.  In contrast, the\n   Generic\
    \ Token Card (GTC) method from [1], which uses text strings\n   generated by the\
    \ EAP server, is intended to be interpreted and acted\n   upon by humans.  Furthermore,\
    \ EAP-POTP allows for mutual\n   authentication and establishment of keying material,\
    \ which GTC does\n   not.  To retain the generic nature of GTC, the EAP-POTP method\
    \ has\n   been designed to support a wide range of OTP algorithms, with\n   profiling\
    \ expected for specific such algorithms.  This document\n   provides a profile\
    \ of EAP-POTP for RSA SecurID tokens.\n"
- title: 1.4.  Relationship with EAP Methods in RFC 3748
  contents:
  - "1.4.  Relationship with EAP Methods in RFC 3748\n   The EAP OTP method defined\
    \ in [1], which builds on [14], is an\n   example of a particular OTP algorithm\
    \ and is not related to the EAP\n   method defined in this document, other than\
    \ that a profile of EAP-\n   POTP may be created for the OTP algorithm from [14].\n\
    \   The Generic Token Card EAP method defined in [1] is intended to work\n   with\
    \ a variety of OTP algorithms.  The same is true for EAP-POTP, the\n   EAP method\
    \ defined herein.  Advantages of profiling a particular OTP\n   algorithm for\
    \ use with EAP-POTP, compared to using EAP GTC, are\n   described in Section 1.3.\n"
- title: 2.  Conventions Used in This Document
  contents:
  - "2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n   \"SHOULD NOT\", \"RECOMMENDED\", and\
    \ \"MAY\", in this document are to be\n   interpreted as described in RFC 2119\
    \ [2].\n"
- title: 3.  Authentication Model
  contents:
  - "3.  Authentication Model\n   The EAP-POTP method provides user authentication\
    \ as defined below.\n   Additionally, it may provide mutual authentication (authenticating\n\
    \   the EAP server to the EAP client) and establish keying material.\n   There\
    \ are basically three entities in the authentication method\n   described here:\n\
    \   o  A client, or \"peer\", using EAP terminology, acting on behalf of a\n \
    \     user possessing an OTP token;\n   o  A server, or \"authenticator\", using\
    \ EAP terminology, to which the\n      user needs to authenticate; and\n   o \
    \ A backend authentication server, providing an authentication\n      service\
    \ to the authenticator.\n   The term \"EAP server\" is used here with the same\
    \ meaning as in [1].\n   Any protocol used between the authenticator and the backend\n\
    \   authentication server is outside the scope of this document, although\n  \
    \ RADIUS [15] is a typical choice.  It is assumed that the EAP client\n   and\
    \ the peer are located on the same host, and hence only the term\n   \"peer\"\
    \ is used in the following for these entities.\n   The EAP-POTP method assumes\
    \ the use of a shared secret key, or\n   \"seed\", which is known both by the\
    \ user and the backend\n   authentication server.  The secret seed is stored on\
    \ an OTP token\n   that the user possesses, as well as on the authentication server.\n\
    \   In its most basic variant, the EAP-POTP method provides only one\n   Service\
    \ (namely, user authentication) where the user provides\n   information to the\
    \ authentication server so that the server can\n   authenticate the user.  A more\
    \ advanced variant provides mutual\n   authentication, protection against eavesdropping,\
    \ and establishment\n   of authenticated keying material.\n"
- title: 4.  Description of the EAP-POTP Method
  contents:
  - '4.  Description of the EAP-POTP Method

    '
- title: 4.1.  Overview
  contents:
  - "4.1.  Overview\n   Note: Since the EAP-POTP method is general in nature, the\
    \ term\n   \"POTP-X\" is used below as a placeholder for an EAP method type\n\
    \   identifier, identifying the use of a particular OTP algorithm with\n   EAP-POTP.\
    \  As an example, in the case of using RSA SecurID tokens\n   within EAP-POTP,\
    \ the EAP method type shall be 32 (see Appendix A).\n   A typical EAP-POTP authentication\
    \ is performed as follows (Appendix B\n   provides more detailed examples):\n\
    \   a.  The optional EAP Identity Request/Response is exchanged, as per\n    \
    \   RFC 3748 [1].  An identity provided here may alleviate the need\n       for\
    \ a \"User Identifier\" or a \"Token Key Identifier\" triplet\n       (TLV), defined\
    \ below, later in the exchange.\n   b.  The EAP server sends an EAP-Request of\
    \ type POTP-X with a Version\n       TLV.  The Version TLV indicates the highest\
    \ and lowest version of\n       this method supported by the server.  The EAP\
    \ server typically\n       also includes an OTP TLV in the EAP-Request.  The OTP\
    \ TLV\n       instructs the peer to respond with the current OTP (possibly in\n\
    \       protected form), and may contain a challenge and some other\n       information,\
    \ like server policies.  The EAP server should also\n       include a Server-Info\
    \ TLV in the request, and must do so if it\n       supports session resumption.\
    \  The Server-Info TLV identifies the\n       authentication server, contains\
    \ an identifier for this (new)\n       session, and may be used by the peer to\
    \ find an already existing\n       session with the EAP server.\n   c.  The peer\
    \ responds with an EAP-Response of type Nak (3) if it does\n       not support\
    \ POTP-X or if it does not support a version of this\n       method that is also\
    \ supported by the server, as indicated in the\n       server's Version TLV.\n\
    \       If the peer supports a version of this method that is also\n       supported\
    \ by the EAP server, the peer generates an EAP-Response\n       of type POTP-X\
    \ as follows:\n       *  First, it generates a Version TLV, which indicates the\
    \ peer's\n          highest supported version within the range of versions offered\n\
    \          by the server.  This Version TLV will be part of the EAP-\n       \
    \   Response to the EAP server.\n       *  Next, if the peer's highest supported\
    \ version equals that of\n          the EAP server, and the EAP server sent a\
    \ Server-Info TLV, the\n          peer checks if it has a saved session with the\
    \ EAP server.  If\n          an existing session with the server is found, and\
    \ session\n          resumption is possible (the Server-Info TLV may explicitly\n\
    \          disallow it), the peer calculates new session keys (if the\n      \
    \    session is a protected-mode session) and responds with a\n          Resume\
    \ TLV and the Version TLV.\n       *  Otherwise, if the peer's highest supported\
    \ version equals that\n          of the EAP server, and the received EAP-Request\
    \ message\n          contains an OTP TLV, the peer requests (possibly through\
    \ user\n          interaction) the OTP token to calculate a one-time password\n\
    \          based on the information in the received EAP-Request message\n    \
    \      (which could, for example, carry a challenge), the current\n          token\
    \ state (e.g., token time), a shared secret (the \"seed\"),\n          and a user-provided\
    \ PIN (note that, depending on the OTP token\n          type, some of the information\
    \ in the EAP-Request may not be\n          used in the OTP calculation, and the\
    \ PIN may be optional too).\n          If the received OTP TLV has the P bit set\
    \ (see below), the\n          peer then combines the token-provided OTP with other\n\
    \          information, and provides the combined data to a key\n          derivation\
    \ function.  The key derivation function generates\n          several keys, of\
    \ which one is used to calculate a Message\n          Authentication Code (MAC)\
    \ on the received message, together\n          with some other information.  The\
    \ resulting MAC, together with\n          some additional information, is then\
    \ placed in an OTP TLV\n          (with the P bit set) that is sent in a response\
    \ to the EAP\n          server, together with the Version TLV.  If the P bit is\
    \ not\n          set in the received OTP TLV, the peer instead inserts the\n \
    \         calculated OTP value directly in an OTP TLV, which then is\n       \
    \   sent to the EAP server together with the Version TLV.\n       *  Finally,\
    \ if the peer's highest supported version differs from\n          the server's,\
    \ or if the server did not provide any TLVs\n          besides the Version TLV\
    \ in its initial request, the peer just\n          sends back the generated Version\
    \ TLV as an EAP-Response to the\n          EAP server.\n   d.  If the EAP server\
    \ receives an EAP-Response of type Nak (3), the\n       session negotiation failed\
    \ and the EAP server may try with\n       another EAP method.  Otherwise, the\
    \ EAP server checks the peer's\n       supported version.  If the peer did not\
    \ support the highest\n       version supported by the server, the server will\
    \ send a new EAP-\n       Request with TLVs adjusted for that version.  Otherwise,\
    \ assuming\n       the EAP server did send additional TLVs in its initial EAP-\n\
    \       Request, the EAP server will attempt to authenticate the peer\n      \
    \ based on the response provided in c).  Depending on the result of\n       this\
    \ authentication, the EAP server may do one of the following:\n       *  send\
    \ a new EAP-Request of type POTP-X to the peer indicating\n          that session\
    \ resumption was not possible, and ask for a new\n          OTP (this would be\
    \ the case when the peer responded with a\n          Resume TLV, and the session\
    \ indicated in the Resume TLV was\n          not valid),\n       *  send a new\
    \ EAP-Request of type POTP-X to the peer (e.g., to\n          ask for the next\
    \ OTP),\n       *  accept the authentication (and send an EAP-Request message\n\
    \          containing a Confirm TLV to the peer if the received response\n   \
    \       has the P bit set or was a successful attempt at a protected-\n      \
    \    mode session resumption; otherwise, send an EAP-Success\n          message\
    \ to the peer), or\n       *  fail the authentication (and send an EAP-Failure\
    \ message --\n          possibly preceded by an EAP-Request message of type\n\
    \          Notification (2) -- to the peer).\n   e.  If the peer receives an EAP-Success\
    \ or an EAP-Failure message the\n       protocol run is finished.  If the peer\
    \ receives an EAP-Request of\n       type Notification, it responds as specified\
    \ by RFC 3748 [1].  If\n       the peer receives an EAP-Request of type POTP-X\
    \ with a Confirm\n       TLV, it attempts to authenticate the EAP server using\
    \ the\n       provided data.  If the authentication is successful, the peer\n\
    \       responds with an EAP-Response of type POTP-X with a Confirm TLV.\n   \
    \    If it is unsuccessful, the peer responds with an empty EAP-\n       Response\
    \ of type POTP-X.  If the peer receives an EAP-Request of\n       type POTP-X\
    \ containing some other TLVs, it continues as specified\n       in c) above (though\
    \ no version negotiation will take place in\n       this case) or as described\
    \ for those TLVs.\n   f.  When an EAP server, which has sent an EAP-Request of\
    \ type POTP-X\n       with a Confirm TLV, receives an EAP-Response of type POTP-X\
    \ with\n       a Confirm TLV present, it can proceed in one of two ways: If it\n\
    \       has detected that there is a need to send additional EAP-Requests\n  \
    \     of type POTP-X, it shall enter a \"protected state\", where, from\n    \
    \   then on, all POTP-X TLVs must be encrypted and integrity-\n       protected\
    \ before being sent (at this point, the parties shall\n       have calculated\
    \ a master session key as described in Section\n       4.5).  One reason to continue\
    \ the POTP-X conversation after\n       exchange of the Confirm TLV could be that\
    \ the user needs to\n       update her OTP PIN; hence, the EAP server needs to\
    \ send a New PIN\n       TLV.  At that point, the handshake is back at step c)\
    \ above\n       (except for the version negotiation and the protection of all\n\
    \       TLVs).  If there is no need to send additional EAP-Request\n       packets,\
    \ the EAP server shall instead send an EAP-Success method\n       to the peer\
    \ to indicate successful protocol completion.  The EAP\n       server may not\
    \ continue the conversation unless it indicates its\n       intent to do so in\
    \ the Confirm TLV.\n       An EAP server, which has sent an EAP-Request of type\
    \ POTP-X with\n       a Confirm TLV and receives an EAP-Response of type POTP-X,\
    \ which\n       is empty (i.e., does not contain any TLVs), shall respond with\
    \ an\n       EAP-Failure and terminate the handshake.\n   As implied by the description,\
    \ steps c) through f) may be carried out\n   a number of times before completion\
    \ of the exchange.  One example of\n   this is when the authentication server\
    \ initially requests an OTP,\n   accepts the response from the peer, performs\
    \ an (intermediary)\n   Confirm TLV exchange, requests the peer to select a new\
    \ PIN, and\n   finally asks the peer to authenticate with an OTP based on the\
    \ new\n   PIN (which again will be followed with a final Confirm TLV exchange).\n"
- title: 4.2.  Version Negotiation
  contents:
  - "4.2.  Version Negotiation\n   The EAP-POTP method provides a version negotiation\
    \ mechanism that\n   enables implementations to be backward compatible with previous\n\
    \   versions of the protocol.  This specification documents the EAP-POTP\n   protocol\
    \ version 1.  Version negotiation proceeds as follows:\n   a.  In the first EAP-Request\
    \ of type POTP-X, the EAP server MUST send\n       a Version TLV in which it sets\
    \ the \"Highest\" field to its highest\n       supported version number, and the\
    \ \"Lowest\" field to its lowest\n       supported version number.  The EAP server\
    \ MAY include other TLV\n       triplets, as described below, that are compatible\
    \ with the\n       \"Highest\" supported version number to optimize the number\
    \ of\n       round-trips in the case of a peer supporting the server's\n     \
    \  \"Highest\" version number.\n   b.  If the peer supports a version of the protocol\
    \ that falls within\n       the range of versions indicated by the EAP server,\
    \ it MUST\n       respond with an EAP-Response of type POTP-X that contains a\n\
    \       Version TLV with the \"Highest\" field set to the highest version\n  \
    \     supported by the peer.  The peer MUST also respond to any TLV\n       triplets\
    \ included in the EAP-Request, if it supported the\n       \"Highest\" supported\
    \ version indicated in the server's Version\n       TLV.\n       The EAP peer\
    \ MUST respond with an EAP-Response of type Nak (3) if\n       it does not support\
    \ a version that falls within the range of\n       versions indicated by the EAP\
    \ server.  This will allow the EAP\n       server to use another EAP method for\
    \ peer authentication.\n   c.  When the EAP server receives an EAP-Response containing\
    \ a Version\n       TLV from the peer, but the \"Highest\" supported version field\
    \ in\n       the TLV differs from the \"Highest\" supported version field sent\n\
    \       by the EAP server, or when the version is the same as the one\n      \
    \ originally proposed by the EAP server, but the EAP server did not\n       include\
    \ any TLV triplets in the initial request, the EAP server\n       sends a new\
    \ EAP-Request of type POTP-X with the negotiated\n       version and TLV triplets\
    \ as desired and described herein.\n   The version negotiation procedure guarantees\
    \ that the EAP peer and\n   server will agree to the highest version supported\
    \ by both parties.\n   If version negotiation fails, use of EAP-POTP will not\
    \ be possible,\n   and another mutually acceptable EAP method will need to be\
    \ negotiated\n   if authentication is to proceed.\n   The EAP-POTP version field\
    \ may be modified in transit by an attacker.\n   It is therefore important that\
    \ EAP entities only accept EAP-POTP\n   versions according to an explicit policy.\n"
- title: 4.3.  Cryptographic Algorithm Negotiation
  contents:
  - "4.3.  Cryptographic Algorithm Negotiation\n   Cryptographic algorithms are negotiated\
    \ through the use of the Crypto\n   Algorithm TLV.  EAP-POTP provides a default\
    \ digest algorithm\n   (SHA-256) [3], a default encryption algorithm (AES-CBC)\
    \ [4] , and a\n   default MAC algorithm (HMAC) [5], and these algorithms MUST\
    \ be\n   supported by all EAP-POTP implementations.  An EAP server that does\n\
    \   not want to make use of any other algorithms than the default ones\n   need\
    \ not send a Crypto Algorithm TLV.  An EAP server that does want\n   to negotiate\
    \ use of some other algorithms MUST send the Crypto\n   Algorithm TLV in the initial\
    \ EAP-Request of type POTP-X that also\n   contains an OTP TLV with the P bit\
    \ set.  The TLV MUST NOT be present\n   in any other EAP-Request in the session.\
    \ (The two exceptions to this\n   are 1) if the client attempted a session resumption\
    \ that failed and\n   therefore did not evaluate a sent Crypto Algorithm TLV,\
    \ or 2) if the\n   Crypto Algorithm TLV was part of the initial message from the\
    \ EAP\n   server, and the client negotiated another EAP-POTP version than the\n\
    \   highest one supported by the EAP server.  When either of these cases\n   apply,\
    \ the server MUST include the Crypto Algorithm TLV in the first\n   EAP-Request\
    \ that also contains an OTP TLV with the P bit set\n   subsequent to the failed\
    \ session resumption / protocol version\n   negotiation.)  In the Crypto Algorithm\
    \ TLV, the EAP server suggests\n   some combination of digest, encryption, and\
    \ MAC algorithms. (If the\n   server only wants to negotiate a particular class\
    \ of algorithms, then\n   suggestions for the other classes need not be present,\
    \ since the\n   default applies.)\n   The peer MUST include a Crypto Algorithm\
    \ TLV in an EAP-Response if\n   and only if an EAP-Request of type POTP-X has\
    \ been received\n   containing a Crypto Algorithm TLV, it was legal for that EAP-Request\n\
    \   to contain a Crypto Algorithm TLV, the peer does not try to resume an\n  \
    \ existing session, and the peer and the EAP server agree on at least\n   one\
    \ algorithm not being the default one.  If the peer does not supply\n   a value\
    \ for a particular class of algorithms in a responding Crypto\n   Algorithm TLV,\
    \ then the default algorithm applies for that class.\n   When resuming an existing\
    \ session (see the next section), there is no\n   need for the peer to negotiate\
    \ since the session already is\n   associated with a set of algorithms.  Servers\
    \ MUST fail a session\n   (i.e., send an EAP-Failure) if they receive an EAP-Response\
    \ TLV\n   containing both a Resume TLV and a Crypto Algorithm TLV.\n   Clearly,\
    \ EAP servers and peers MUST NOT suggest any other algorithms\n   than the ones\
    \ their policy allows them to use.  Policies may also\n   restrict what combinations\
    \ of cryptographic algorithms are\n   acceptable.\n"
- title: 4.4.  Session Resumption
  contents:
  - "4.4.  Session Resumption\n   This method makes use of session identifiers and\
    \ server identifiers\n   to allow for improved efficiency in the case where a\
    \ peer repeatedly\n   attempts to authenticate to an EAP server within a short\
    \ period of\n   time.  This capability is particularly useful for support of wireless\n\
    \   roaming.\n   In order to help the peer find a session associated with the\
    \ EAP\n   server, an EAP server that supports session resumption MUST send a\n\
    \   Server-Info TLV containing a server identifier in its initial EAP-\n   Request\
    \ of type POTP-X that also contains an OTP TLV.  The identifier\n   may then be\
    \ used by the peer for lookup purposes.\n   It is left to the peer whether or\
    \ not to attempt to continue a\n   previous session, thus shortening the negotiation.\
    \  Typically, the\n   peer's decision will be made based on the time elapsed since\
    \ the\n   previous authentication attempt to that EAP server.  If the peer\n \
    \  decides to attempt to resume a session with the EAP server, it sends\n   a\
    \ Resume TLV identifying the chosen session and other contents, as\n   described\
    \ below, to the EAP server.\n   Based on the session identifier chosen by the\
    \ peer, and the time\n   elapsed since the previous authentication, the EAP server\
    \ will decide\n   whether to allow the session resumption, or continue with a\
    \ new\n   session.\n   o  If the EAP server is willing to resume a previously\
    \ established\n      session, it MUST authenticate the peer based on the contents\
    \ of\n      the Resume TLV.  If the authentication succeeds, the handshake\n \
    \     will continue in one of two ways:\n      *  If the session is a protected-mode\
    \ session, then the server\n         MUST respond with a request containing a\
    \ Confirm TLV.  If the\n         Confirm TLV authenticates the EAP server, then\
    \ the peer\n         responds with an empty Confirm TLV, to which the EAP server\n\
    \         responds with an EAP-Success message.  If the Confirm TLV does\n   \
    \      not authenticate the EAP server, the peer responds with an\n         empty\
    \ EAP-Response of type POTP-X.\n      *  If the session is not a protected-mode\
    \ session, i.e., it is a\n         session created from a basic-mode peer authentication,\
    \ then the\n         server MUST respond with an EAP-Success message.\n      If\
    \ the authentication of the peer fails, the EAP server SHOULD\n      send another\
    \ EAP-Request containing an OTP TLV and a Server-Info\n      TLV with the N bit\
    \ set to indicate that no session resumption is\n      possible.  The EAP server\
    \ MAY also send an EAP-Failure message,\n      possibly preceded by an EAP-Request\
    \ of type Notification (2), in\n      which case, the EAP run will terminate.\n\
    \   o  If the EAP server is not willing or able to resume a previously\n     \
    \ established session, it will respond with another EAP-Request\n      containing\
    \ an OTP TLV and a Server-Info TLV with the N bit set\n      (indicating no session\
    \ resumption).\n   Sessions SHOULD NOT be maintained longer than the security\
    \ of the\n   exchange which created the session permits.  For example, if it is\n\
    \   estimated that an attacker could be successful in brute-force\n   searching\
    \ for the OTP in 24 hours, then EAP-POTP session lifetimes\n   should be clearly\
    \ less than this value.\n"
- title: 4.5.  Key Derivation and Session Identifiers
  contents:
  - "4.5.  Key Derivation and Session Identifiers\n   The EAP-POTP method described\
    \ herein makes use of a key derivation\n   function denoted \"PBKDF2\".  PBKDF2\
    \ is described in [6], Section 5.2.\n   The PBKDF2 PRF SHALL be set to the negotiated\
    \ MAC algorithm.  The\n   default MAC algorithm, which MUST be supported, is HMAC-SHA256.\
    \  HMAC\n   is defined in [5], and SHA-256 is defined in [3].  HMAC-SHA256 is\
    \ the\n   HMAC construct from [5] with SHA-256 as the hash function H.  The\n\
    \   output length of HMAC-SHA256, when used as a PRF for PBKDF2, shall be\n  \
    \ 32 octets (i.e., the full output length).\n   The output from PBKDF2 as described\
    \ here will consist of five keys\n   (see Section 4.11.3 for details on how to\
    \ calculate these keys):\n   o  K_MAC, a MAC key used for mutual authentication\
    \ and integrity\n      protection,\n   o  K_ENC, an encryption key used to protect\
    \ certain data during the\n      authentication,\n   o  SRK, a session resumption\
    \ key only used for session resumption\n      purposes,\n   o  MSK, a Master Session\
    \ Key, as defined in [1], and\n   o  EMSK, an Extended Master Session Key, also\
    \ as defined in [1].\n      For the default algorithms, K_MAC, K_ENC, and SRK\
    \ SHALL be 16\n      octets.  For other cases, the key lengths will be as determined\
    \ by\n      the negotiated algorithms.  The MSK and the EMSK SHALL each be 64\n\
    \      octets, in conformance with [1].  Therefore, in the case of\n      default\
    \ algorithms, the \"dkLen\" parameter from Section 5.2 of [6]\n      SHALL be\
    \ set to 176 (the combined length of K_MAC, K_ENC, SRK,\n      MSK, and EMSK).\n\
    \   [1] and [16] define usage of the MSK and the EMSK .  For a particular\n  \
    \ use case, see also Appendix C.\n"
- title: 4.6.  Error Handling and Result Indications
  contents:
  - "4.6.  Error Handling and Result Indications\n   EAP does not allow for the sending\
    \ of an EAP-Response of type Nak (3)\n   within a method after the initial EAP-Request\
    \ and EAP-Response pair\n   of that particular method has been exchanged (see\
    \ [1], Section 2.1).\n   Instead, when a peer is unable to continue an EAP-POTP\
    \ session, the\n   peer MAY respond to an outstanding EAP-Request by sending an\
    \ empty\n   EAP-Response of type POTP-X rather than immediately terminating the\n\
    \   conversation.  This allows the EAP server to log the cause of the\n   error.\n\
    \   To ensure that the EAP server receives the empty EAP-Response, the\n   peer\
    \ SHOULD wait for the EAP server to reply before terminating the\n   conversation.\
    \  The EAP server MUST reply with an EAP-Failure.\n   When EAP-POTP is run in\
    \ protected mode, the exchange of the Confirm\n   TLV (Section 4.11.6) serves\
    \ as a success result indication; when the\n   peer receives a Confirm TLV, it\
    \ knows that the EAP server has\n   successfully authenticated it.  Similarly,\
    \ when the EAP server\n   receives the Confirm TLV response from the peer, it\
    \ knows that the\n   peer has authenticated it.  In protected mode, the peer will\
    \ not\n   accept an EAP-Success packet unless it has received and validated a\n\
    \   Confirm TLV.  The Confirm TLV sent from the EAP server to the peer is\n  \
    \ a \"protected result indication\" as defined in [1], as it is integrity\n  \
    \ protected and cannot be replayed.  The Confirm TLV sent from the peer\n   to\
    \ the EAP server is, however, not a protected result indication.  An\n   empty\
    \ EAP-POTP response sent from the peer to the EAP server serves\n   as a failure\
    \ result indication.\n"
- title: 4.7.  Use of the EAP Notification Method
  contents:
  - "4.7.  Use of the EAP Notification Method\n   Except where explicitly allowed\
    \ in the following, the EAP\n   Notification method MUST NOT be used within an\
    \ EAP-POTP session.  The\n   EAP Notification method MAY be used within an EAP-POTP\
    \ session in the\n   following situations:\n   o  The EAP server MAY send an EAP-Request\
    \ of type Notification (2)\n      when it has received an EAP-Response containing\
    \ an OTP TLV and is\n      unable to authenticate the user.  In this case, once\
    \ the EAP-\n      Response of type Notification is received, the EAP server MAY\n\
    \      retry the authentication and send a new EAP-Request containing an\n   \
    \   OTP TLV, or it MAY fail the session and send an EAP-Failure\n      message.\n\
    \   o  The EAP server MAY send an EAP-Request of type Notification (2)\n     \
    \ when it has received an unacceptable New PIN TLV.  In this case,\n      once\
    \ the EAP-Response of type Notification is received, the EAP\n      server MAY\
    \ retry the PIN update and send a new EAP-Request with a\n      New PIN TLV, or\
    \ it MAY fail the session and send an EAP-Failure\n      message.\n"
- title: 4.8.  Protection against Brute-Force Attacks
  contents:
  - "4.8.  Protection against Brute-Force Attacks\n   Since OTPs may be relatively\
    \ short, it is important to slow down an\n   attacker sufficiently so that it\
    \ is economically unattractive to\n   brute-force search for an OTP, given an\
    \ observed EAP-POTP handshake\n   in protected mode.  One way to do this is to\
    \ do a high number of\n   iterated hashes in the PBKDF2 function.  Another is\
    \ for the client to\n   include a value (\"pepper\") unknown to the attacker in\
    \ the hash\n   computation.  Whereas a traditional \"salt\" value normally is\
    \ sent in\n   the clear, this \"pepper\" value will not be sent in the clear,\
    \ but may\n   instead be transferred to the EAP server in encrypted form.  In\n\
    \   practice, the procedure is as follows:\n   a.  The EAP server indicates in\
    \ its OTP TLV whether it supports\n       pepper searching.  Additionally, it\
    \ may indicate to the peer that\n       a new pepper shall be chosen.\n   b. \
    \ If the peer supports the use of pepper, the peer checks whether\n       it already\
    \ has established a shared pepper with this server:\n       If it does have a\
    \ pepper stored for this server, and the server\n       did not indicate that\
    \ a new pepper shall be generated, then it\n       uses the existing pepper value,\
    \ as specified in Section 4.11.3\n       below, to calculate an OTP TLV response.\
    \  In this case, the\n       iteration count shall be kept to a minimum, as the\
    \ security of\n       the scheme is provided through the pepper, and efficiency\n\
    \       otherwise is lost.\n       If the peer does not have a pepper stored for\
    \ this server, but\n       the server indicated support for pepper searching,\
    \ or the server\n       indicated that a new pepper shall be generated, then the\
    \ peer\n       generates a random and uniformly distributed pepper of sufficient\n\
    \       length (the maximum length supported by the server is provided in\n  \
    \     the server's OTP TLV), and includes the new pepper in the PBKDF2\n     \
    \  computation.\n       If the peer does not have a pepper stored for this server,\
    \ and\n       the server did not indicate support for pepper searching, then a\n\
    \       pepper will not be used in the response computation.\n       Clearly,\
    \ if the peer itself does not support the use of pepper,\n       then a pepper\
    \ will not be used in the response computation.\n   c.  The EAP server may, in\
    \ its subsequent Confirm TLV, provide a\n       pepper to the peer for later use.\
    \  In this case, the pepper will\n       be substantially longer than a peer-chosen\
    \ pepper, and encrypted\n       with a key derived from the PBKDF2 computation.\n\
    \   The above procedure allows for pepper updates to be initiated by\n   either\
    \ side, e.g., based on policy.  Since the pepper can be seen as\n   a MAC key,\
    \ its lifetime should be limited.\n   An EAP server that is not capable of storing\
    \ pepper values for each\n   user it is authenticating may still support the use\
    \ of pepper; the\n   cost for this will be the extra computation time to do pepper\n\
    \   searches.  This cost is still substantially lower than the cost for\n   an\
    \ attacker, however, since the server already knows the underlying\n   OTP.\n"
- title: 4.9.  MAC Calculations in EAP-POTP
  contents:
  - '4.9.  MAC Calculations in EAP-POTP

    '
- title: 4.9.1.  Introduction
  contents:
  - "4.9.1.  Introduction\n   In protected mode, EAP-POTP uses MACs for authentication\
    \ purposes, as\n   well as to ensure the integrity of protocol sessions.  This\
    \ section\n   defines how the MACs are calculated and the rationale for the design.\n"
- title: 4.9.2.  MAC Calculation
  contents:
  - "4.9.2.  MAC Calculation\n   In protected mode, and when resuming a previous session,\
    \ rather than\n   sending authenticating credentials (such as one-time passwords\
    \ or\n   shared keys) directly, evidence of knowledge of the credentials is\n\
    \   sent.  This evidence is a MAC on the hash of (certain parts of) EAP-\n   POTP\
    \ messages exchanged so far in a session using a key K_MAC:\n   mac = MAC(K_MAC,\
    \ msg_hash(msg_1, msg_2, ..., msg_n))\n   where\n   \"MAC\" is the negotiated\
    \ MAC algorithm, \"K_MAC\" is a key derived as\n   specified in Section 4.5, and\
    \ \"msg_hash(msg_1, msg_2, ..., msg_n)\" is\n   the message hash defined below\
    \ of messages msg_1, msg_2, ..., msg_n.\n"
- title: 4.9.3.  Message Hash Algorithm
  contents:
  - "4.9.3.  Message Hash Algorithm\n   To compute a message hash for the MAC, given\
    \ a sequence of EAP\n   messages msg_1, msg_2, ..., msg_n, the following operations\
    \ shall be\n   carried out:\n   a.  Re-transmitted messages are removed from the\
    \ sequence of\n       messages.\n       Note: The resulting sequence of messages\
    \ must be an alternating\n       sequence of EAP Request and EAP Response messages.\n\
    \   b.  The contents (i.e., starting with the EAP \"Type\" field and\n       excluding\
    \ the EAP \"Code\", \"Identifier\", and \"Length\" fields) of\n       each message,\
    \ msg_1, msg_2, ..., msg_n, is concatenated together.\n   c.  User identifier\
    \ TLVs MUST NOT be included in the hash (this is to\n       allow for a backend\
    \ service that does not know about individual\n       user names), i.e., any such\
    \ TLV is removed from the message in\n       which it appeared.\n   d.  The resulting\
    \ string is hashed using the negotiated hash\n       algorithm.\n"
- title: 4.9.4.  Design Rationale
  contents:
  - "4.9.4.  Design Rationale\n   The reason for excluding the \"Identifier\" field\
    \ is that the actual,\n   transmitted \"Identifier\" field is not always known\
    \ to the EAP method\n   layer.  The reason for excluding the \"Length\" field\
    \ is to allow the\n   possibility for an intermediary to remove or replace a Username\
    \ TLV\n   (e.g., for anonymity or service reasons) before passing a received\n\
    \   response on to an authentication server.  While this on the surface\n   may\
    \ appear as bad security practice, it may in practice only result\n   in denial\
    \ of service, something which always may be achieved by an\n   attacker able to\
    \ modify messages in transit.  By excluding the \"Code\"\n   field, the hash is\
    \ simply calculated on applicable sent and received\n   message contents.  Excluding\
    \ the \"Code\" field is regarded as harmless\n   since the hash is to be made\
    \ on the sequence of POTP-X messages, all\n   having alternating (known) Code\
    \ values, namely 1 (Request) and 2\n   (Response).\n"
- title: 4.9.5.  Implementation Considerations
  contents:
  - "4.9.5.  Implementation Considerations\n   To save on storage space, each EAP\
    \ entity may partially hash messages\n   as they are sent and received (e.g.,\
    \ HashInit(); HashUpdate(message\n   1); ...; HashUpdate(message n-1); HashFinal(message\
    \ n)).  This\n   reduces the amount of state needed for this purpose to the internal\n\
    \   state required for the negotiated hash algorithm.\n"
- title: 4.10.  EAP-POTP Packet Format
  contents:
  - "4.10.  EAP-POTP Packet Format\n   A summary of the EAP-POTP packet format is\
    \ shown below.  The fields\n   are transmitted from left to right.\n    0    \
    \               1                   2                   3\n    0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Code      |   Identifier  |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Type      |   Reserved    | TLV-based EAP-POTP message ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Code\n      1 - Request\n      2 - Response\n   Identifier\n      The Identifier\
    \ field is 1 octet and aids in matching responses\n      with requests.  For a\
    \ more detailed description of this field and\n      how to use it, see [1].\n\
    \   Length\n      The Length field is 2 octets and indicates the length of the\
    \ EAP\n      packet including the Code, Identifier, Length, Type, Version,\n \
    \     Flags, and TLV-based EAP-POTP message fields.\n   Type\n      Identifies\
    \ use of a particular OTP algorithm with EAP-POTP.\n   Reserved\n      This octet\
    \ is reserved for future use.  It SHALL be set to zero\n      for this version.\
    \  Recipients SHALL ignore this octet for this\n      version of EAP-POTP.\n \
    \  TLV-based EAP-POTP message\n   This field will contain 0, 1, or more Type-Length-Value\
    \ triplets\n   defined as follows (this is similar to the EAP-TLV TLVs defined\
    \ in\n   PEAPv2 [17], and the explanation of the generic fields is borrowed\n\
    \   from that document).\n    0                   1                   2      \
    \             3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              Value ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      0 - Non-mandatory TLV\n      1 - Mandatory TLV\n      The TLVs within\
    \ EAP POTP-X are used to carry parameters between\n      the EAP peer and the\
    \ EAP server.  An EAP peer may not necessarily\n      implement all the TLVs supported\
    \ by an EAP server, and to allow\n      for interoperability, a special TLV allows\
    \ an EAP server to\n      discover if a TLV is supported by the EAP peer.\n  \
    \    The mandatory bit in a TLV indicates that if the peer or server\n      does\
    \ not support the TLV, it MUST send a NAK TLV in response; all\n      other TLVs\
    \ in the message MUST be ignored.  If an EAP peer or\n      server finds an unsupported\
    \ TLV that is marked as non-mandatory\n      (i.e., optional), it MUST NOT send\
    \ a NAK TLV on this ground only.\n      The mandatory bit does not imply that\
    \ the peer or server is\n      required to understand the contents of the TLV.\
    \  The appropriate\n      response to a supported TLV with content that is not\
    \ understood is\n      defined by the specification of the particular TLV.\n \
    \  R\n      Reserved for future use.  This bit SHALL be set to zero (0) for\n\
    \      this version.  Recipients SHALL ignore this bit for this version\n    \
    \  of the EAP-POTP.\n   TLV Type\n      The following TLV types are defined for\
    \ use with EAP-POTP:\n       0 - Reserved for future use\n       1 - Version\n\
    \       2 - Server-Info\n       3 - OTP\n       4 - NAK\n       5 - New PIN\n\
    \       6 - Confirm\n       7 - Vendor-Specific\n       8 - Resume\n       9 -\
    \ User Identifier\n      10 - Token Key Identifier\n      11 - Time Stamp\n  \
    \    12 - Counter\n      13 - Keep-Alive\n      14 - Protected\n      15 - Crypto\
    \ Algorithm\n      16 - Challenge\n      These TLVs are defined in the following.\
    \  With the exception of\n      the NAK TLV, a particular TLV type MUST NOT appear\
    \ more than once\n      in a message of type POTP-X.\n   Length\n      The length\
    \ of the Value field in octets.\n   Value\n      The value of the TLV.\n"
- title: 4.11.  EAP-POTP TLV Objects
  contents:
  - '4.11.  EAP-POTP TLV Objects

    '
- title: 4.11.1.  Version TLV
  contents:
  - "4.11.1.  Version TLV\n   The Version TLV carries information about the supported\
    \ EAP-POTP\n   method version.\n   This TLV MUST be present in the initial EAP-Request\
    \ of type POTP-X\n   from the EAP server and in the initial response of type POTP-X\
    \ from\n   the peer.  It MUST NOT be present in any subsequent EAP-Request or\n\
    \   EAP-Response in the session.  The Version TLV MUST be supported by\n   all\
    \ peers, and all EAP servers conforming to this specification and\n   MUST NOT\
    \ be responded to with a NAK TLV.  The version negotiation\n   procedure is described\
    \ in detail in Section 4.2.\n    0                   1                   2   \
    \                3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Reserved    |    Highest    |    Lowest     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      1 - Mandatory TLV\n   R\n      Reserved for future use.  This bit\
    \ SHALL be set to zero (0) for\n      this version.  Recipients SHALL ignore this\
    \ bit for this version\n      of EAP-POTP.\n   TLV Type\n      1\n   Length\n\
    \      3 in EAP-Requests, 2 in EAP-Responses\n   Reserved\n      Reserved for\
    \ future use.  This octet MUST be set to zero for this\n      version.  Recipients\
    \ SHALL ignore this octet for this version of\n      EAP-POTP.\n   Highest\n \
    \     This field contains an unsigned integer representing the highest\n     \
    \ protocol version supported by the sender.  If a value provided by\n      a peer\
    \ to an EAP server falls between the server's \"Highest\" and\n      \"Lowest\"\
    \ supported version (inclusive), then that value will be\n      the negotiated\
    \ version for the authentication session.\n   Lowest\n      This field contains\
    \ an unsigned integer representing the lowest\n      version acceptable by the\
    \ EAP server.  The field MUST be present\n      in an EAP-Request.  The field\
    \ MUST NOT be present in an EAP-\n      Response.  A peer SHALL respond to an\
    \ EAP-Request of type POTP-X\n      with an EAP-Response of type Nak (3) if the\
    \ peer's highest\n      supported version is lower than the value of this field.\n\
    \   This document defines version 1 of the protocol.  Therefore, EAP\n   server\
    \ implementations conforming to this document SHALL set the\n   \"Highest\" field\
    \ to 1.  Peer implementations conforming to this\n   document SHALL set the \"\
    Highest\" field to 1.\n"
- title: 4.11.2.  Server-Info TLV
  contents:
  - "4.11.2.  Server-Info TLV\n   The Server-Info TLV carries information about the\
    \ EAP server and the\n   session (when applicable).  It provides one piece in\
    \ the framework\n   for fast session resumption.\n   This TLV SHOULD always be\
    \ present in an EAP-Request of type POTP-X\n   that also carries an OTP TLV, as\
    \ long as the peer has not been\n   authenticated, and MUST be present in such\
    \ a request if the server\n   supports session resumption.  It MUST NOT be present\
    \ in any other\n   EAP-Request of type POTP-X or in any EAP-Response packets.\
    \  This TLV\n   type MUST be supported by all peers conforming to this specification\n\
    \   and MUST NOT be responded to with a NAK TLV (this is not to say that\n   all\
    \ peers need to support session resumption, only that they cannot\n   respond\
    \ to this TLV with a NAK TLV).\n    0                   1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Reserved  |N|            Session Identifier                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                Session Identifier (continued)                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Sess.Id (cont.)|             Nonce ... (16 octets)\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Server Identifier ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      1 - Mandatory TLV\n   R\n      Reserved for future use.  This bit\
    \ SHALL be set to zero (0) for\n      this version.  Recipients SHALL ignore this\
    \ bit for this version\n      of EAP-POTP.\n   TLV Type\n      2\n   Length\n\
    \      25 + length of Server Identifier field\n   Reserved\n      Reserved for\
    \ future use.  All 7 bits MUST be set to zero for this\n      version.  Recipients\
    \ SHALL ignore this bit for this version of\n      EAP-POTP.\n   N\n      The\
    \ N bit signals that the peer MUST NOT attempt to resume any\n      session it\
    \ has stored associated with this server.\n   Session Identifier\n      An 8-octet\
    \ identifier for the session about to be negotiated.\n      Note that, in the\
    \ case of session resumption, this session\n      identifier will not be used\
    \ (the session identifier for the\n      resumed session will continue to be used).\n\
    \   Nonce\n      A 16-octet nonce chosen by the server.  During session resumption,\n\
    \      this nonce is used when calculating new K_ENC, K_MAC, SRK, MSK,\n     \
    \ and EMSK keys as specified below.\n   Server Identifier\n      An identifier\
    \ for the authentication server.  The peer MAY use\n      this identifier to search\
    \ for a stored session associated with\n      this server, or to associate the\
    \ session to be negotiated with the\n      server.  The value of the identifier\
    \ SHOULD be chosen so as to\n      reduce the risk of collisions with other EAP\
    \ server identifiers as\n      much as possible.  One possibility is to use the\
    \ DNS name of the\n      EAP server.  The identifier MAY also be used by the peer\
    \ to select\n      a suitable key on the OTP token (when there are multiple keys\n\
    \      available).\n      The identifier MUST NOT be longer than 128 octets. \
    \ The identifier\n      SHALL be a UTF-8 [7] encoded string of printable characters\n\
    \      (without any terminating NULL character).\n"
- title: 4.11.3.  OTP TLV
  contents:
  - "4.11.3.  OTP TLV\n   In an EAP-Request, the OTP TLV is used to request an OTP\
    \ (or a value\n   derived from an OTP) from the peer.  In an EAP-Response, the\
    \ OTP TLV\n   carries an OTP or a value derived from an OTP.\n   This TLV type\
    \ MUST be supported by all peers and all EAP servers\n   conforming to this specification\
    \ and MUST NOT be responded to with a\n   NAK TLV.  The OTP TLV MUST NOT be present\
    \ in an EAP-Request of type\n   POTP-X that contains a New PIN TLV.  Further,\
    \ the OTP TLV MUST NOT be\n   present in an EAP-Response of type POTP-X unless\
    \ the preceding EAP-\n   Request of type POTP-X contained an OTP TLV and it was\
    \ valid for it\n   to do so.  Finally, an OTP TLV MUST NOT be present in an EAP-\n\
    \   Response of type POTP-X that also contains a Resume TLV.  The OTP TLV\n  \
    \ is defined as follows:\n    0                   1                   2      \
    \             3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Reserved    |A|P|C|N|T|E|S| Pepper Length |Iteration Count|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Iteration Count (cont.)            |  Auth. Data   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 Authentication Data (cont.) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      1 - Mandatory TLV\n   R\n      Reserved for future use.  This bit\
    \ SHALL be set to zero (0) for\n      this version.  Recipients SHALL ignore this\
    \ bit for this version\n      of EAP-POTP.\n   TLV Type\n      3\n   Length\n\
    \      7 + length of Authentication Data field\n   Reserved\n      Reserved for\
    \ future use.  All 9 bits SHALL be set to zero (0) for\n      this version.  Recipients\
    \ SHALL ignore these bits for this version\n      of EAP-POTP.\n   A\n      The\
    \ A bit MUST be set in an EAP-Request if and only if the request\n      immediately\
    \ follows an EAP-Response of type POTP-X containing a\n      New PIN TLV (see\
    \ Section 4.11.5), and the new PIN in the response\n      was accepted by the\
    \ EAP server.  In this case, the A bit signals\n      that the EAP-server has\
    \ accepted the PIN, and that the peer SHALL\n      use the newly established PIN\
    \ when calculating the response (when\n      applicable).  The A bit MUST NOT\
    \ be set if the S bit is set.  If a\n      request has both the S bit and the\
    \ A bit set, the peer SHALL\n      regard the request as invalid, and return an\
    \ empty POTP-X EAP-\n      Response message.\n      In an EAP-Response, the A\
    \ bit, when set, indicates that the OTP\n      was calculated with the use of\
    \ the newly selected user PIN.  The A\n      bit MUST be set in a response if\
    \ and only if the EAP-Request which\n      triggered the response contained an\
    \ OTP TLV with the A bit set.\n   P\n      In an EAP-Request, the P bit indicates\
    \ that the OTP in the\n      response MUST be protected.  Use of this bit also\
    \ indicates that\n      mutual authentication will take place, as well as generation\
    \ of\n      keying material.  It is RECOMMENDED to always set the P bit.  If a\n\
    \      peer receives an EAP-Request with an OTP TLV that does not have\n     \
    \ the P bit set, and the peer's policy dictates protected mode, the\n      peer\
    \ MUST respond with an empty POTP-X EAP-Response message.  All\n      peers MUST\
    \ support protected mode.\n      In an EAP-Response, this bit indicates that the\
    \ provided OTP has\n      been protected (see below).  The P bit MUST be set in\
    \ a response\n      (and hence the OTP MUST be protected) if and only if the EAP-\n\
    \      Request that triggered the response contained an OTP TLV with the\n   \
    \   P bit set.\n      In an 802.1x EAP over LAN (EAPOL) environment (this includes\n\
    \      wireless LAN environments), the P bit MUST be set, or,\n      alternatively,\
    \ the EAP-POTP method MUST be carried out inside an\n      authenticated tunnel\
    \ that provides a cryptographic binding with\n      inner EAP methods such as\
    \ the one provided by PEAPv2 [17].\n   C\n      The C bit carries meaning only\
    \ when the OTP algorithm in question\n      makes use of server challenges.  For\
    \ other OTP algorithms, the C\n      bit SHALL always be set to zero.\n      In\
    \ an EAP-Request, the C bit (\"Combine\") indicates that the OTP\n      SHALL\
    \ be calculated using both the provided challenge and internal\n      state (e.g.,\
    \ current token time).  The OTP SHALL be calculated\n      based only on the provided\
    \ challenge (and the shared secret) if\n      the C bit is not set, and a challenge\
    \ is present.  The returned\n      OTP SHALL always be calculated based on the\
    \ peer's current state\n      (and the shared secret) if no challenge is present.\
    \  If the C bit\n      is set but no challenge is provided, the peer SHALL regard\
    \ the\n      request as invalid, and return an empty POTP-X EAP-Response\n   \
    \   message.\n      In an EAP response, this bit indicates that the provided OTP\
    \ has\n      been calculated using a provided challenge and the token state.\n\
    \      The C bit MUST be set in a response if and only if the EAP-Request\n  \
    \    that triggered the response contained an OTP TLV with the C bit\n      set\
    \ and a challenge.\n   N\n      In an EAP-Request, the N bit, when set, indicates\
    \ that the OTP to\n      calculate SHALL be based on the next token \"state\"\
    , and not the\n      current one.  As an example, for a time-based token, this\
    \ means\n      the next time slot.  For an event-based token, this could mean\
    \ the\n      next counter value, if counter values are used.  This bit will\n\
    \      normally not be set in initial EAP-Request messages, but may be\n     \
    \ set in subsequent ones.  Further, the N bit carries no meaning in\n      an\
    \ EAP-Request if a challenge is present and the C bit is not set,\n      and SHALL\
    \ be set to 0, in this case.  If a request that has the N\n      bit set also\
    \ contains a challenge, but does not have the C bit\n      set, the peer SHALL\
    \ regard the request as invalid, and return an\n      empty POTP-X EAP-Response\
    \ message.  Note that setting the N bit in\n      an EAP-Request will normally\
    \ advance the internal state of the\n      token.\n      In an EAP-Response, the\
    \ N bit, when set, indicates that the OTP\n      was calculated based on the next\
    \ token \"state\" (as explained\n      above), and not the current one.  The N\
    \ bit MUST be set in a\n      response if and only if the EAP-Request that triggered\
    \ the\n      response contained an OTP TLV with the N bit set.\n   T\n      The\
    \ T bit only carries meaning for OTP methods normally\n      incorporating a user\
    \ PIN in the OTP computation.\n      In an EAP-Request, the T bit, when set, indicates\
    \ that the OTP to\n      calculate MUST NOT include a user PIN.\n      In an EAP-Response,\
    \ the T bit, when set, indicates that the OTP\n      was calculated without the\
    \ use of a user PIN.  The T bit MUST be\n      set in a response if and only if\
    \ the EAP-Request that triggered\n      the response contained an OTP TLV with\
    \ the T bit set.  Note that\n      client policy may prohibit PIN-less calculations;\
    \ in these cases,\n      the client MAY respond with an empty POTP-X EAP response\
    \ message.\n   E\n      In an EAP-Request, the E bit, when set, indicates that\
    \ the peer\n      MUST NOT use any stored pepper value associated with this server\n\
    \      in the PBKDF2 computation.  Rather, it MUST generate a new pepper\n   \
    \   (if supported by the peer) and/or use the iteration count\n      parameter\
    \ to protect the OTP (if the server's Max Pepper Length is\n      0, then the\
    \ peer MUST rely on the iteration count only to protect\n      the OTP).  This\
    \ bit will usually not be set in initial EAP-Request\n      messages, but may\
    \ be set in subsequent ones, e.g., if the server,\n      upon receipt of an OTP\
    \ TLV with a pepper identifier, detects that\n      it does not have a pepper\
    \ with that identifier in storage.  This\n      bit carries no meaning, and MUST\
    \ be set to zero, when the P bit is\n      not set.  If a request has the E bit\
    \ set but not the P bit, a peer\n      SHALL regard the request as invalid, and\
    \ return an empty POTP-X\n      EAP-Response message.\n      In an EAP-Response,\
    \ the E bit indicates that the response has been\n      calculated without use\
    \ of any stored pepper value.\n   S\n      In an EAP-Request, the S bit (\"Same\"\
    ), when set, indicates that\n      the peer SHOULD calculate its response based\
    \ on the same OTP value\n      as was used for the preceding response.  This bit\
    \ MAY be set when\n      the EAP server has received an OTP TLV from the peer\
    \ protected\n      with a pepper, of which the server is no longer in possession.\n\
    \      Since the server has not attempted validation of the provided\n      data,\
    \ there is no need for the EAP peer to retrieve a new OTP\n      value.  This\
    \ bit carries no meaning, and MUST be set to zero, when\n      the E bit is not\
    \ set.  A peer SHALL regard a request where the S\n      bit is set, but not the\
    \ E bit, as invalid, and return an empty\n      POTP-X EAP-Response message. \
    \ Further, the S bit MUST NOT be set\n      when the A bit also is set; see above.\n\
    \      In an EAP-Response, the S bit is never set.\n   Pepper Length\n      This\
    \ octet SHALL be present if and only if the P bit is set.  When\n      present,\
    \ it contains an unsigned integer, having a value between 0\n      and 255 (inclusive).\
    \  In an EAP-Request, the integer represents\n      the maximum length (in bits)\
    \ of a client-generated pepper the\n      server is prepared to search for.  Peers\
    \ MUST NOT generate peppers\n      longer than this value.  If the value is set\
    \ to zero, it means the\n      peer MUST NOT generate a pepper for the PBKDF2\
    \ calculation.  In an\n      EAP-Response, it indicates the length of the used\
    \ pepper.\n   Iteration Count\n      These 4 octets SHALL be present if and only\
    \ if the P bit is set.\n      When present, they contain an unsigned, 4-octet\
    \ integer in network\n      byte order.  In an EAP-Request, the integer represents\
    \ the maximum\n      iteration count the peer may use in the PBKDF2 computation.\
    \  Peers\n      MUST NOT use iteration counts higher than this value.  In an EAP-\n\
    \      Response, it indicates the actual iteration count used.\n   Note regarding\
    \ the Pepper Length and Iteration Count parameters: A\n   peer MUST compare these\
    \ policy parameters provided by the EAP server\n   with local policy and MUST\
    \ NOT continue the handshake if use of the\n   EAP server's suggested parameters\
    \ would result in a lower security\n   than the client's acceptable policy.  If\
    \ the security given by the\n   EAP server's provided policy parameters surpasses\
    \ the security level\n   given by the peer's local policy, the client SHOULD use\
    \ the server's\n   parameters (subject to reason - active attackers could otherwise\n\
    \   mount simple denial-of-service attacks against peers or servers,\n   e.g.,\
    \ by providing unreasonably high values for the iteration count).\n   Note that\
    \ the server-provided parameters only apply to the case where\n   the peer cannot\
    \ use or does not have a previously provided server-\n   provided pepper.  If\
    \ a peer cannot continue the handshake due to the\n   server's policy being unacceptable,\
    \ it MUST return an empty POTP-X\n   EAP-Response message.\n   Authentication\
    \ Data\n   EAP-Request:  In an EAP-Request, the Authentication Data field, when\n\
    \      present, contains an optional \"challenge\".  The challenge is an\n   \
    \   octet string that SHOULD be uniquely generated for each request in\n     \
    \ which it is present (i.e., it is a \"nonce\"), and SHOULD be 8\n      octets\
    \ or longer.  To avoid fragmentation (i.e., EAP messages\n      longer than the\
    \ minimum EAP MTU size; see [1]), the challenge MUST\n      NOT be longer than\
    \ 64 octets.  When the challenge is not present,\n      the OTP will be calculated\
    \ on the current token state only.  The\n      peer MAY ignore a provided challenge\
    \ if and only if the OTP token\n      the peer is interacting with is not capable\
    \ of including a\n      challenge in the OTP calculation.  In this case, EAP server\n\
    \      policies will determine whether or not to accept a provided OTP\n     \
    \ value.\n   EAP-Response: The following applies to the Authentication Data field\n\
    \      in an EAP-Response:\n      *  When the P bit is not set, the peer SHALL\
    \ directly place the\n         OTP value calculated by the token in the Authentication\
    \ Data\n         field.  In this case, the EAP server MUST NOT send a Confirm\n\
    \         TLV upon successful authentication of the peer (instead, it\n      \
    \   sends an EAP-Success message).\n      *  When the P bit is set, the peer SHALL\
    \ populate this field as\n         follows.  After the token has calculated the\
    \ OTP value, the\n         peer SHALL compute:\n            K_MAC | K_ENC | MSK\
    \ | EMSK | SRK = PBKDF2(otp, salt | pepper\n            | auth_id, iteration_count,\
    \ key_length)\n            where\n            \"|\" denotes concatenation,\n \
    \           \"otp\" is the already computed OTP value,\n            \"salt\" is\
    \ a 16-octet nonce,\n            \"pepper\" is an optional nonce (at most, 255\
    \ bits long, and,\n            if necessary, padded to be a multiple of 8 bits\
    \ long; see\n            below) included to complicate the task of finding a matching\n\
    \            \"otp\" value for an attacker,\n            \"auth_id\" is an identifier\
    \ (at most, 255 octets in length)\n            for the authenticator (i.e., the\
    \ network access server) as\n            reported by lower layers and as specified\
    \ below,\n            \"iteration_count\" is an iteration count chosen such that\
    \ the\n            computation time on the peer is acceptable (based on the\n\
    \            server's indicated policy and the peer's local policy),\n       \
    \     while an attacker, having observed the response and\n            initiating\
    \ a search for a matching OTP, will be sufficiently\n            slowed down.\
    \  The \"iteration_count\" value MUST be chosen to\n            provide a suitable\
    \ level of protection (e.g., at least\n            100,000) unless a server-provided\
    \ pepper is being used, in\n            which case, it SHOULD be 1.\n        \
    \    \"key_length\" is the combined length of the desired key\n            material,\
    \ in octets.  When the default algorithms are used,\n            key_length is\
    \ 176.\n            The \"pepper\" values are only included in PBKDF2 calculations\n\
    \            and are never sent to EAP servers (though the peers do send\n   \
    \         their length, in bits).  The purpose of the pepper values\n        \
    \    are, as mentioned above, to slow down an attacker's search\n            for\
    \ a matching OTP, while not slowing down the peer (which\n            iterated\
    \ hashes do).  If the pepper has been generated by\n            the peer, and\
    \ the chosen pepper length in bits is not a\n            multiple of 8, then the\
    \ pepper value SHALL be padded to the\n            left, with '0' bits to the\
    \ nearest multiple of 8 before\n            being used in the PBKDF2 calculation.\
    \  This is to ensure the\n            input to the calculation consists only of\
    \ whole octets.  As\n            an example, if the chosen pepper length is 4,\
    \ the pepper\n            value will be padded to the left, with 4 '0' bits to\
    \ form an\n            octet before being used in the PBKDF2 calculation.\n  \
    \          When pepper is used, it is RECOMMENDED that the length of\n       \
    \     the pepper and the iteration count are chosen in such a way\n          \
    \  that it is computationally infeasible/unattractive for an\n            attacker\
    \ to brute-force search for the given OTP within the\n            lifetime of\
    \ that OTP.\n            As mentioned previously, a peer MUST NOT include a newly\n\
    \            generated pepper value in the PBKDF2 computation if the\n       \
    \     server did not indicate its support for pepper searching in\n          \
    \  this session.  If the server did not indicate support for\n            pepper\
    \ searching, then the PBKDF2 computation MUST be\n            carried out with\
    \ a sufficiently higher number of iterations\n            so as to compensate\
    \ for the lack of pepper (see further\n            Appendix D).\n            A\
    \ server may, in an earlier session, have transferred a\n            pepper value\
    \ to the peer in a Confirm TLV (see below).  When\n            this is the case,\
    \ and the peer still has that pepper value\n            stored for this server,\
    \ the peer MUST NOT generate a new\n            pepper but MUST, instead, use\
    \ this transferred pepper value\n            in the PBKDF2 calculations.  The\
    \ only exception to this is\n            when a local policy (e.g., timer) dictates\
    \ that the peer\n            must switch to a new pepper (and the server indicated\n\
    \            support for pepper searching).\n            The following applies\
    \ to the auth_id component:\n            -  For dial-up, \"auth_id\" SHALL be\
    \ either the empty string\n               or the phone number called by the peer.\
    \  The phone number\n               SHALL be specified in the form of a URL conformant\
    \ with\n               RFC 3966 [8], e.g., \"tel:+16175550101\".  Processing of\n\
    \               received phone numbers SHALL be conformant with RFC 3966\n   \
    \            (this assumes that \"tel\" URIs will be shorter than 256\n      \
    \         octets, which would normally be the case).\n            -  For use with\
    \ IEEE 802.1X, \"auth_id\" SHALL be either the\n               empty string or\
    \ the MAC address of the authenticator in\n               canonical binary format\
    \ (6 octets).\n            -  For IP-based EAP, \"auth_id\" SHALL be either the\
    \ empty\n               string or the IPv4 or IPv6 address of the authenticator\n\
    \               as seen by the peer and in binary format (4 or 16 octets,\n  \
    \             respectively).  As an example, the IPv4 address\n              \
    \ \"192.0.2.5\" would be represented as (in hex) C0 00 02 05,\n              \
    \ whereas the IPv6 address \"2001:DB8::101\" would be\n               represented\
    \ as (in hex) 20 01 0D B8 00 00 00 00 00 00 00\n               00 00 00 01 01.\n\
    \            Note: Use of the authenticator's identifying information\n      \
    \      within the computation aids in protection against man-in-\n           \
    \ the-middle attacks, where a rogue authenticator seeks to\n            intercept\
    \ and forward the Authentication Data in order to\n            impersonate the\
    \ peer at a legitimate authenticator (but see\n            also the discussion\
    \ around spoofed authenticator addresses\n            in Section 6).  For these\
    \ reasons, a peer SHOULD NOT set the\n            auth_id component to the empty\
    \ string unless it is unable to\n            learn the identifying information\
    \ of the authenticator.  In\n            these cases, the EAP server's policy\
    \ will determine whether\n            or not the session may continue.\n     \
    \       As an example, when otp = \"12345678\", salt =\n            0x54434534543445435465768789099880,\
    \ pepper is not used,\n            auth_id = \"192.0.2.5\", iteration_count =\
    \ 2000 (decimal), and\n            key_length = 176 (decimal), the input to the\
    \ PBKDF2\n            calculation will be (first two parameters in hex, line wrap\n\
    \            for readability):\n            (3132333435363738, 54434534543445435465768789099880\
    \ |\n            c0000205, 2000, 176)\n            As described, when the default\
    \ algorithms are used, K_MAC is\n            the first 16 octets of the output\
    \ from PBKDF2, K_ENC the\n            next 16 octets, MSK the following 64 octets,\
    \ EMSK the next\n            64 octets, and SRK the final 16 octets.  Using K_MAC,\
    \ the\n            peer calculates:\n            mac = MAC(K_MAC, msg_hash(msg_1,\
    \ msg_2, ..., msg_n))\n            as specified in Section 4.9 and where msg_1,\
    \ msg_2, ...,\n            msg_n is a sequence of all EAP messages of type POTP-X\n\
    \            exchanged so far in this session, as sent and received by\n     \
    \       the peer (for the peer's initial MAC, it will typically be\n         \
    \   just one message: the EAP server's initial EAP-Request of\n            type\
    \ POTP-X).\n            The peer then places the first 16 octets of \"mac\" in\
    \ the\n            Authentication Data field, followed by the \"salt\" value,\n\
    \            followed by one octet representing the length of the\n          \
    \  \"auth_id\" value in octets, followed by the actual \"auth_id\"\n         \
    \   value in binary form, and optionally followed by a pepper\n            identifier\
    \ (only when the peer made use of a pepper value\n            previously provided\
    \ by the EAP server).  Pepper identifiers,\n            when present, are always\
    \ 4 octets.  All variables SHALL be\n            present in the form they were\
    \ input to the PBKDF2 algorithm.\n            This will result in the Authentication\
    \ Data field being 33 +\n            (length of auth_id in octets) + (4, for pepper\
    \ identifier,\n            when present) octets in length.\n            Continuing\
    \ the previous example, the Authentication Data\n            field will be populated\
    \ with (in hex, line wrap for\n            readability):\n            < 16 octets\
    \ of mac > | 54434534543445435465768789099880 |\n            04 | c0000205\n \
    \           Note: Since in this case (i.e., when the P bit is set)\n         \
    \   successful authentication of the peer by the EAP server will\n           \
    \ be followed by the transmission of an EAP-Request of type\n            POTP-X\
    \ containing a Confirm TLV for mutual authentication,\n            the peer MUST\
    \ save either all the input parameters to the\n            PBKDF2 computation\
    \ or the keys K_MAC, K_ENC, SRK, MSK, and\n            EMSK (recommended, since\
    \ they will be used later).  This is\n            because the peer cannot be guaranteed\
    \ to be able to generate\n            the same OTP value again.  For the same\
    \ reason (the Confirm-\n            TLV from the EAP server), the peer MUST also\
    \ store either\n            the hash of the contents of the sent EAP-Response\
    \ or the\n            EAP-Response itself (but see the note above about not\n\
    \            including any User Identifier TLVs in the hash computation).\n  \
    \          Given a set of possible OTP values, the authentication\n          \
    \  server verifies an authentication request from the peer by\n            computing\n\
    \            K_MAC' | K_ENC' | MSK' | EMSK' | SRK' = PBKDF2 (otp',\n         \
    \     salt | pepper' | auth_id, iteration_count, key_length)\n            for\
    \ each possible OTP value otp' and each possible pepper\n            value pepper'\
    \ , and the provided values for salt,\n            authenticator identity, and\
    \ iteration count, as well as the\n            applicable key length (default:\
    \ 176).  Note: Doing the\n            computation for each possible pepper value\
    \ implements the\n            pepper search mentioned elsewhere in this document.\
    \  Note\n            also that the EAP server may accept more than one OTP value\n\
    \            at a given time, e.g., due to clock drift in the token.  If\n   \
    \         the given pepper length is not a multiple of 8, each tested\n      \
    \      pepper value will be padded to the left to the nearest\n            multiple\
    \ of 8, in the same manner as was done by the peer.\n            If the server\
    \ already shares a secret pepper value with this\n            peer, then obviously\
    \ there will only be one possible pepper\n            value, and the server will\
    \ find it based on the\n            pepper_identifier provided by the peer.  The\
    \ server SHALL\n            send a new EAP-Request of type POTP-X with an OTP\
    \ TLV with\n            the E bit set if the peer provided a pepper identifier\n\
    \            unknown to the server.\n            For each K_MAC', the EAP server\
    \ computes\n            mac' = MAC(K_MAC', msg_hash(msg_1', msg_2', ..., msg_n'))\n\
    \            where MAC is the negotiated MAC algorithm, msg_hash is the\n    \
    \        message hash algorithm defined in Section 4.9, and msg_1',\n        \
    \    msg_2', ... msg_n' are the same messages on which the peer\n            calculated\
    \ its message hash, but this time, as sent and\n            received by the EAP\
    \ server.  If the first 16 octets of mac'\n            matches the first 16 octets\
    \ in the Authentication Data field\n            of the EAP-Response in question,\
    \ and the provided\n            authenticator identity is acceptable (e.g., matches\
    \ the EAP\n            server's view of the authenticator's identity), then the\n\
    \            peer is authenticated.\n            If the authentication is successful,\
    \ the authentication\n            server then attempts to authenticate itself\
    \ to the peer by\n            use of the Confirm TLV (see below).  If the authentication\n\
    \            fails, the EAP server MAY send another EAP-Request of type\n    \
    \        POTP-X containing an OTP TLV to the peer, or it MAY send an\n       \
    \     EAP-Failure message (in both cases, possibly preceded by an\n          \
    \  EAP-Request of type Notification).\n"
- title: 4.11.4.  NAK TLV
  contents:
  - "4.11.4.  NAK TLV\n   Presence of this TLV indicates that the peer did not support\
    \ a\n   received TLV with the M bit set.  This TLV may occur 0, 1, or more\n \
    \  times in an EAP-Response of type POTP-X.  Each occurrence flags the\n   non-support\
    \ of a particular received TLV.\n   The NAK TLV MUST be supported by all peers\
    \ and all EAP servers\n   conforming to this specification and MUST NOT be responded\
    \ to with a\n   NAK TLV.  Receipt of a NAK TLV by an EAP server MAY cause an\n\
    \   authentication to fail, and the EAP server to send an EAP-Failure\n   message\
    \ to the peer.\n   Note: The definition of the NAK TLV herein matches the definition\n\
    \   made in [17], and has the same type number.  Field descriptions are\n   copied\
    \ from that document, with some minor modifications.\n    0                  \
    \ 1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          Vendor-Id                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            NAK-Type           |           TLVs ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      1 - Mandatory TLV\n   R\n      Reserved for future use.  This bit\
    \ SHALL be set to zero (0) for\n      this version.  Recipients SHALL ignore this\
    \ bit for this version\n      of EAP-POTP.\n   TLV Type\n      4\n   Length\n\
    \      6 + cumulative total length of embedded TLVs\n   Vendor-Id\n      The Vendor-Id\
    \ field is 4 octets, and contains the Vendor-Id of the\n      TLV that was not\
    \ supported.  The high-order octet is 0 and the\n      low-order 3 octets are\
    \ the Structure of Management Information\n      (SMI) Network Management Private\
    \ Enterprise Code of the Vendor in\n      network byte order.  The Vendor-Id field\
    \ MUST be zero for TLVs\n      that are not Vendor-Specific TLVs.  For Vendor-Specific\
    \ TLVs, the\n      Vendor-ID MUST be set to the SMI code.\n   NAK-Type\n   The\
    \ type of the unsupported TLV.  The TLV MUST have been included in\n   the most\
    \ recently received EAP message.\n   TLVs\n   This field contains a list of TLVs,\
    \ each of which MUST NOT have the\n   mandatory bit set.  These optional TLVs\
    \ can be used in the future to\n   communicate why the offending TLV was determined\
    \ to be unsupported.\n"
- title: 4.11.5.  New PIN TLV
  contents:
  - "4.11.5.  New PIN TLV\n   In an EAP-Request, the New PIN TLV is used to request\
    \ a new user PIN\n   from the peer.  The EAP server MAY provide a new PIN, as\
    \ described\n   below.  In an EAP-Response, the New PIN TLV carries a chosen new\
    \ user\n   PIN.  This TLV may be used by an EAP server when policy dictates that\n\
    \   the peer (user) needs to change a PIN associated with the OTP Token.\n   This\
    \ TLV type SHOULD be supported by peers and EAP servers conforming\n   to this\
    \ specification.  The New PIN TLV MUST NOT be sent by an EAP\n   server unless\
    \ the peer has been authenticated.  If the peer was\n   authenticated in protected\
    \ mode, then the New PIN TLV MUST NOT be\n   present in an EAP-Request until after\
    \ the exchange of the Confirm TLV\n   (i.e., until after mutual authentication\
    \ has occurred and keys are in\n   place to protect the TLV).  The New PIN TLV\
    \ MUST be sent by a peer if\n   and only if the EAP-Request that triggered the\
    \ response contained a\n   New PIN TLV, it was valid for the EAP server to send\
    \ such a TLV in\n   that request, and the TLV is supported by the peer.\n    0\
    \                   1                   2                   3\n    0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Reserved  |Q|A|  PIN Length   |             PIN ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Min. PIN Length|Max. PIN Length|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      1 - Mandatory TLV\n   R\n      Reserved for future use.  This bit\
    \ SHALL be set to zero (0) for\n      this version.  Recipients SHALL ignore this\
    \ bit for this version\n      of EAP-POTP.\n   TLV Type\n      5\n   Length\n\
    \      2 + length of the PIN field (as specified in the PIN Length field)\n  \
    \      + (0, 1, or 2)\n      Note: The final term above is\n      -  0 if none\
    \ of the optional Min. / Max. PIN Length fields is\n           present in the\
    \ TLV,\n      -  1 if only the Min. PIN Length field is present in the TLV,\n\
    \      -  2 if both of these optional fields are present in the TLV.\n   Reserved\n\
    \      Reserved for future use.  All six bits SHALL be set to zero for\n     \
    \ this version.  Recipients SHALL ignore these bits for this version\n      of\
    \ EAP-POTP.\n   Q\n      The Q bit, when set in an EAP-Request, indicates that\
    \ an\n      accompanying PIN is required, i.e., the peer (user) is not free to\n\
    \      choose another PIN.  When the Q bit is set, there MUST be an\n      accompanying\
    \ PIN and the provided PIN MUST be used in subsequent\n      OTP generations.\
    \  A peer SHALL respond with an empty POTP-X EAP-\n      Response message if the\
    \ Q bit is set but there is not any\n      accompanying PIN.  When the Q bit is\
    \ not set, any provided PIN is\n      suggested only, and the peer is free to\
    \ choose another PIN,\n      subject to local policy.\n      The Q bit carries\
    \ no meaning, and SHALL be set to zero, in an EAP-\n      Response.\n   A\n  \
    \    This bit allows methods that distinguish between two different PIN\n    \
    \  types (e.g., decimal vs. alphanumeric) to designate whether the\n      augmented\
    \ set is to be used (when set) or not (when not set).  The\n      A bit carries\
    \ no meaning, and SHALL be set to zero, in an EAP-\n      Response.\n   PIN Length\n\
    \      This field contains an unsigned integer representing the length of\n  \
    \    the provided PIN (this implies that the maximum length of a PIN\n      will\
    \ be 255 octets).\n   PIN\n      In an EAP-Request, subject to the setting of\
    \ the Q bit, the PIN\n      field MAY be empty.  If empty, the peer (user) will\
    \ need to choose\n      a PIN subject to local and (any) provided policy.  When\
    \ the PIN\n      field is not empty, it MUST consist of UTF-8 encoded printable\n\
    \      characters without a terminating NULL character.\n      In an EAP-Response,\
    \ the PIN value SHALL consist of a UTF-8 encoded\n      string of printable characters\
    \ without a terminating NULL\n      character.\n      The peer accepts a PIN suggested\
    \ by the EAP server by replying\n      with the same PIN, but MAY replace it with\
    \ another one, depending\n      on the server's setting of the Q bit.  The length\
    \ of the PIN is\n      application-dependent, as are any other requirements for\
    \ the PIN,\n      e.g., allowed characters.  The peer MUST be prepared to receive\
    \ a\n      repeated request for a new PIN, as described above, if the EAP\n  \
    \    server, for some reason does not accept the received PIN.  Such a\n     \
    \ request MAY be preceded by an EAP-Request of type Notification (2)\n      providing\
    \ information to the user about the reason for the\n      rejection.  Mechanisms\
    \ for transferring knowledge about PIN\n      requirements from the EAP server\
    \ to the peer (beyond those\n      specified for this TLV, such as maximal and\
    \ minimal PIN length)\n      are outside the scope of this document.  However,\
    \ some information\n      MAY be provided in notification messages transferred\
    \ from the EAP\n      server to the peer, as per above.\n   Min. PIN Length\n\
    \      This field MAY be present in an EAP-Request.  This field MUST NOT\n   \
    \   be present in an EAP-Response.  It SHALL be interpreted as an\n      unsigned\
    \ integer in network byte order representing the minimum\n      length allowed\
    \ for a new PIN.\n   Max. PIN Length\n      This field MUST NOT be present in\
    \ an EAP-Request unless the Min.\n      PIN Length field is present, in which\
    \ case it MAY be present.  The\n      field MUST NOT be present in an EAP-Response.\
    \  It SHALL be\n      interpreted as an unsigned integer in network byte order\n\
    \      representing the maximum length allowed for a new PIN.  The value\n   \
    \   of this field, when present, MUST be equal to, or larger than, the\n     \
    \ value of the Min. PIN Length field.\n"
- title: 4.11.6.  Confirm TLV
  contents:
  - "4.11.6.  Confirm TLV\n   Presence of this TLV in a request indicates that the\
    \ EAP server has\n   successfully authenticated the peer and now attempts to authenticate\n\
    \   itself to the peer.  Presence of this TLV in a response indicates\n   that\
    \ the peer successfully authenticated the EAP server, and that\n   calculated\
    \ keys (K_MAC, K_ENC, MSK, EMSK, and SRK) now become\n   available for use.\n\
    \   The Confirm TLV MUST NOT appear together with any other TLV in an\n   EAP-Request\
    \ message of type POTP-X and MUST NOT be sent unless the\n   peer has been authenticated\
    \ through an OTP TLV with the P bit set or\n   through a Resume TLV for which\
    \ the underlying session was established\n   in protected mode.  The Confirm TLV\
    \ MUST be present in an EAP-\n   Response if and only if the request that triggered\
    \ the response\n   contained a Confirm TLV, it was legal for it to do so, and\
    \ the\n   Confirm TLV authenticated the EAP server to the peer.  If the peer\n\
    \   was not able to authenticate the server, then it MUST send an empty\n   (i.e.,\
    \ no TLVs present) EAP-Response of type POTP-X.\n   An EAP server MUST send an\
    \ EAP-Success message after receiving an\n   EAP-Response of type POTP-X containing\
    \ a valid Confirm TLV, sent in\n   response to an EAP-Request containing a Confirm\
    \ TLV where the C bit\n   was not set.  A peer MUST NOT accept an EAP-Success\
    \ message when it\n   has sent an OTP TLV with the P bit set unless it has received\
    \ an\n   acceptable Confirm TLV from the EAP server.\n   This TLV type MUST be\
    \ supported by all peers and EAP servers\n   conforming to this specification\
    \ and MUST NOT be responded to with a\n   NAK TLV.\n    0                   1\
    \                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Reserved  |C|       Authentication Data ... (16 octets)\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Pepper Identifier                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              IV ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                Encrypted Pepper ... (16 octets)\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      1 - Mandatory TLV\n   R\n      Reserved for future use.  This bit\
    \ SHALL be set to zero (0) for\n      this version.  Recipients SHALL ignore this\
    \ bit for this version\n      of EAP-POTP.\n   TLV Type\n      6\n   Length\n\
    \      17 or 37 + length of IV in requests, 1 in responses.\n   Reserved\n   \
    \   Reserved for future use.  These 7 bits SHALL be set to zero (0)\n      for\
    \ this version.  Recipients SHALL ignore these bits for this\n      version of\
    \ EAP-POTP.\n   C\n      The C bit, when set in an EAP-Request, indicates that\
    \ the EAP\n      server intends to send more EAP-Requests of type POTP-X in this\n\
    \      session, after receipt of a Confirm TLV from the peer.\n      The C bit\
    \ carries no meaning in EAP-Responses, and MUST NOT be set\n      within them.\n\
    \      Note: An EAP-Response containing a Confirm TLV, sent in response\n    \
    \  to an EAP-Request containing a Confirm TLV that did not have the C\n      bit\
    \ set, MUST be followed by an EAP-Success message from the EAP\n      server concluding\
    \ the handshake.  However, when the C bit was set\n      in an EAP-Request, the\
    \ EAP server MAY send another EAP-Request\n      (containing, for example, a New\
    \ PIN TLV wrapped in a Protected\n      TLV) rather than an EAP-Success message.\
    \  Therefore, peers MUST\n      NOT assume that the only EAP message following\
    \ an EAP-Response of\n      type POTP-X containing a Confirm TLV is EAP-Success.\
    \  The C bit\n      gives EAP servers a way to indicate their intent to follow\
    \ the\n      Confirm TLV with more requests, and allows the peer's state\n   \
    \   machine to adapt to this.\n   Authentication Data\n   EAP-Request:\n     \
    \    In a request, this field consists of the first 16 octets of\n         (see\
    \ also Section 4.11.3):\n         mac_a = MAC(K_MAC', msg_hash(trig_msg))\n  \
    \       where\n         MAC is the negotiated MAC algorithm,\n         \"K_MAC'\"\
    \ has been calculated as described in Section 4.11.3 or\n         (in the case\
    \ of session resumption) Section 4.11.8, and\n         \"msg_hash\" is the message\
    \ hash algorithm defined in Section\n         4.9, and \"trig_msg\" the latest\
    \ EAP-Response of type POTP-X\n         received from the peer (the one which\
    \ triggered this request).\n         Given a saved or recomputed value for K_MAC,\
    \ the peer\n         authenticates the EAP server by computing\n         mac''\
    \ = MAC(K_MAC, msg_hash(trig_msg'))\n         where \"msg_hash(trig_msg')\" is\
    \ the peer's hash of the EAP-\n         Response message that it sent to the server\
    \ (and that the\n         server calculated its message hash on).  If the first\
    \ 16 octets\n         of mac'' matches the first 16 octets in the Authentication\
    \ Data\n         field of the EAP-Request in question, then the EAP server is\n\
    \         authenticated.\n   EAP-Response:\n         Not used in this version,\
    \ and SHALL NOT be present in EAP-\n         Responses.\n   Pepper Identifier\n\
    \      In an EAP-Request, the truncated MAC MAY optionally be followed by\n  \
    \    an encrypted pepper and its identifier.  This initial, 4-octet\n      field\
    \ identifies a pepper generated by the server.\n      For this version of EAP-POTP,\
    \ this field SHALL NOT be present in\n      EAP-Responses.\n   IV (Initialization\
    \ Vector)\n      An initialization vector for the encryption.  The length of the\n\
    \      vector is dependent on the negotiated encryption algorithm.  For\n    \
    \  example, for AES-CBC, it SHALL be 16 octets.  The IV is only\n      present\
    \ if a pepper is present, and the negotiated encryption\n      algorithm makes\
    \ use of an IV.  This field SHALL NOT be present in\n      EAP-Response messages\
    \ for this version of EAP-POTP.\n   Encrypted Pepper\n      When present in an\
    \ EAP-Request, this will be a uniformly\n      distributed and randomly chosen\
    \ 16-octet pepper generated by the\n      EAP server and encrypted with the negotiated\
    \ encryption algorithm,\n      using K_ENC as the encryption key and possibly\
    \ (depending on the\n      encryption algorithm) using an IV (stored in the IV\
    \ field).  This\n      field MUST be present if and only if the Pepper Identifier\
    \ field\n      is present.\n      EAP servers are RECOMMENDED to include a freshly\
    \ generated\n      encrypted pepper (and a corresponding Pepper Identifier) in\
    \ every\n      Confirm TLV.\n      This field SHALL NOT be present in EAP-Response\
    \ messages for this\n      version of EAP-POTP.\n   When a new pepper is generated\
    \ by the server and transferred in\n   encrypted form to the peer, then this new\
    \ pepper value will be stored\n   in the EAP server upon receipt of the Confirm\
    \ TLV from the peer, and\n   SHOULD be stored with its identifier and associated\
    \ with the EAP\n   server and the current user in the peer upon receipt of the\
    \ EAP-\n   Success message.  If the peer already had a pepper stored for the EAP\n\
    \   server, it SHALL replace it with the newly received one.\n"
- title: 4.11.7.  Vendor-Specific TLV
  contents:
  - "4.11.7.  Vendor-Specific TLV\n   The Vendor-Specific TLV is available to allow\
    \ vendors to support\n   their own extended attributes not suitable for general\
    \ usage.  A\n   Vendor-Specific TLV can contain one or more inner TLVs, referred\
    \ to\n   as Vendor TLVs.  The TLV-type of a Vendor TLV will be defined by the\n\
    \   vendor.  All the Vendor TLVs inside a single Vendor-Specific TLV\n   SHALL\
    \ belong to the same vendor.\n   This TLV type MAY be sent by EAP servers, as\
    \ well as by peers, and\n   MUST be supported by all entities conforming to this\
    \ specification.\n   Conforming implementations may not support specific Vendor\
    \ TLVs\n   inside a Vendor-Specific TLV, however.  They MAY, in this case,\n \
    \  respond to the Vendor TLVs with a NAK TLV containing the appropriate\n   Vendor-ID\
    \ and Vendor TLV type.\n   The presence of a Vendor-Specific TLV in an EAP-Request\
    \ or EAP-\n   Response of type POTP-X MUST NOT violate any existing rules for\n\
    \   coexistence of TLVs in such requests or responses.  If it does, then\n   it\
    \ will result in an EAP-Failure (when the peer made the violation)\n   or an empty\
    \ EAP-POTP response (when the EAP-server made the\n   violation).  It is left\
    \ to the definition of specific Vendor-Specific\n   TLVs to further constrain\
    \ when they are allowed to appear.  In\n   particular, EAP-POTP implementations\
    \ may have policies that\n   completely disallow use of the Vendor-Specific TLV\
    \ before protected\n   mode mutual authentication has occurred (since the Protected\
    \ TLV,\n   Section 4.11.15, then can be used to protect all TLVs).\n   Note: This\
    \ TLV type has the same definition and TLV type number as\n   the Vendor-Specific\
    \ TLV in [17], and the description of it is largely\n   borrowed from that document.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          Vendor-Id                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Vendor TLVs ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      1 - Mandatory TLV\n   R\n      Reserved for future use.  This bit\
    \ SHALL be set to zero (0) for\n      this version.  Recipients SHALL ignore this\
    \ bit for this version\n      of EAP-POTP.\n   TLV Type\n      7\n   Length\n\
    \      4 + cumulative total length of inner Vendor TLVs\n   Vendor-ID\n      The\
    \ Vendor-Id field is 4 octets.  The high-order octet SHALL be\n      set to 0,\
    \ and the low-order 3 octets SHALL be set to the SMI\n      Network Management\
    \ Private Enterprise Code (see [18]) of the\n      Vendor in network byte order.\n\
    \   Vendor TLVs\n      This field shall contain vendor-specific TLVs, in a format\
    \ defined\n      by the vendor.  To avoid fragmentation (i.e., EAP messages longer\n\
    \      than the minimum EAP MTU size), the field SHOULD NOT be longer\n      than\
    \ 256 octets.\n   To ensure interoperability when an EAP entity (peer or server)\
    \ from\n   vendor A sends a vendor-specific TLV that is not understood by the\n\
    \   recipient EAP entity from vendor B, the vendor A entity SHALL, upon\n   receipt\
    \ of the NAK TLV from the recipient, refrain from usage of the\n   vendor-specific\
    \ TLV in question for the rest of the handshake, and\n   MUST NOT fail the session\
    \ due to the receipt of the NAK TLV for the\n   Vendor TLV (i.e., it SHALL continue\
    \ as if the vendor-specific TLV had\n   not been sent).  Additionally, all implementations\
    \ conformant with\n   this document SHOULD allow use of vendor-specific extensions\
    \ to be\n   turned off via configuration.\n"
- title: 4.11.8.  Resume TLV
  contents:
  - "4.11.8.  Resume TLV\n   The Resume TLV MAY be sent by a peer to an authentication\
    \ server to\n   attempt session resumption.\n   This TLV type MUST only be sent\
    \ in response to an EAP-Request of type\n   POTP-X containing a Server-Info TLV\
    \ allowing session resumption.  The\n   Resume TLV MUST be supported by all EAP\
    \ servers that send a Server-\n   Info TLV allowing session resumption.\n    0\
    \                   1                   2                   3\n    0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Reserved    |               Session Identifier              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                Session Identifier (continued)                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Sess.Id (cont.)|             Authentication Data               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Authentication Data (cont.) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      0 - Non-mandatory TLV\n   R\n      Reserved for future use.  This\
    \ bit SHALL be set to zero (0) for\n      this version.  Recipients SHALL ignore\
    \ this bit for this version\n      of EAP-POTP.\n   TLV Type\n      8\n   Length\n\
    \      45\n   Reserved\n      Reserved for future use.  This octet SHALL be set\
    \ to zero (0) for\n      this version.  Recipients SHALL ignore this octet for\
    \ this version\n      of EAP-POTP.\n   Session Identifier\n      An 8-octet identifier\
    \ for the session the peer is trying to\n      resume.\n   Authentication Data\n\
    \      Upon receipt of the Server-Info TLV, and if the N bit is not set,\n   \
    \   the peer searches for any stored sessions associated with the\n      server\
    \ identified by the Server Name field.  If a stored session\n      is found, the\
    \ peer generates a random, 16-octet nonce, \"c_nonce\",\n      and calculates:\n\
    \      K_MAC | K_ENC | MSK | EMSK | SRK = PBKDF2(base_key, c_nonce |\n      s_nonce,\
    \ iteration_count, key_length)\n      where\n      \"|\" denotes concatenation,\n\
    \      \"base_key\" is either the current SRK for the session (if the\n      session\
    \ was created in protected mode) or the OTP used when the\n      session was created\
    \ (if the session was created in basic mode),\n      \"c_nonce\" is the generated\
    \ 16-octet nonce,\n      \"s_nonce\" is the server nonce from the Server-Info\
    \ TLV,\n      \"iteration_count\" is the iteration count as determined by local\n\
    \      policy, and\n      \"key_length\" is the combined length of the desired\
    \ key material,\n      in octets.  When the default algorithms are used, key_length\
    \ is\n      176.\n      The iteration count need only be 1 (one) when resuming\
    \ a session\n      established in protected mode, but MUST be chosen to provide\
    \ a\n      suitable level of protection when resuming a session established\n\
    \      in basic mode (see also Section 4.11.3).\n      Note: Session resumption\
    \ for basic mode MUST only be carried out\n      in a server-authenticated and\
    \ protected tunnel that also provides\n      a cryptographic binding for inner\
    \ EAP methods.\n      The peer then calculates:\n      mac = MAC(K_MAC, msg_hash(resume_req))\n\
    \      where\n      \"MAC\" is the negotiated MAC algorithm, and\n      \"msg_hash(resume_req)\
    \ is the message hash algorithm defined in\n      Section 4.9 applied on resume_req,\
    \ the EAP server's EAP-Request of\n      type POTP-X containing the Server-Info\
    \ TLV that allowed session\n      resumption.\n      The peer then places the\
    \ first 16 octets of the MAC value,\n      followed by the c_nonce value, followed\
    \ by the iteration count\n      value (as a 4-byte unsigned integer in network\
    \ byte order), in the\n      Authentication Data field.  As an example, when c_nonce\
    \ =\n      0x2b3b1b12babdebebfb43bd7bdfbeb8df and iteration_count = 1, the\n \
    \     Authentication Data field will be populated with (in hex):\n      < 16 octets\
    \ of mac > | 2b3b1b12babdebebfb43bd7bdfbeb8df | 00000001\n      The server authenticates\
    \ the peer by performing the corresponding\n      calculations.  If the authentication\
    \ is successful, the server\n      MUST send an EAP-Request of type POTP-X containing\
    \ a Confirm TLV\n      to the peer.  If the authentication fails, the server MUST\
    \ either\n      send an EAP-Request of type POTP-X containing an OTP TLV and a\n\
    \      Server-Info TLV, where the Server-Info TLV indicates that session\n   \
    \   resumption is not possible, or send an EAP-Failure.\n      When resuming in\
    \ basic mode, all calculated keys SHALL be\n      discarded after the MAC has\
    \ been calculated and verified.  When\n      resuming in protected mode, the new\
    \ SRK will replace the stored\n      SRK, and the new MSK and EMSK will be exported\
    \ upon successful\n      completion of the method.\n"
- title: 4.11.9.  User Identifier TLV
  contents:
  - "4.11.9.  User Identifier TLV\n   The User Identifier TLV carries an identifier,\
    \ typically the\n   username, for the holder of the OTP token used to generate\
    \ the OTP.\n   At least one of the User Identifier TLV and the Token Key Identifier\n\
    \   TLV SHOULD be present in the session's first EAP-Response of type\n   POTP-X\
    \ that also carries an OTP TLV unless a suitable identity has\n   been provided\
    \ in a preceding EAP-Response of type Identity (1) or is\n   determined by some\
    \ other means (see [1], Section 2).  Use of the User\n   Identifier TLV and/or\
    \ the Token Key Identifier TLV is RECOMMENDED\n   even when an EAP-Response of\
    \ type Identity (1) has been sent.  If a\n   peer sends both a User Identifier\
    \ TLV and a Token Key Identifier TLV,\n   then the EAP server SHALL interpret\
    \ the Token Key Identifier TLV as\n   specifying a particular token key for the\
    \ given user.  The EAP server\n   MUST respond with an EAP-Failure if it cannot\
    \ find a token key for\n   the provided user.\n   This TLV type is sent by peers\
    \ and MUST be supported by all EAP\n   servers conforming to this specification.\
    \  The User Identifier TLV\n   MUST NOT be present in a response that does not\
    \ also carry an OTP\n   TLV.\n    0                   1                   2  \
    \                 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       User Identifier ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      1 - Mandatory TLV\n   R\n      Reserved for future use.  This bit\
    \ SHALL be set to zero (0) for\n      this version.  Recipients SHALL ignore this\
    \ bit for this version\n      of EAP-POTP.\n   TLV Type\n      9\n   Length\n\
    \      Length of User Identifier, >= 1\n   User Identifier\n      The value SHALL\
    \ be an UTF-8 encoded string representing the holder\n      of the token (MUST\
    \ NOT be NULL-terminated).  The string MUST be\n      less than 128 octets in\
    \ length.\n"
- title: 4.11.10.  Token Key Identifier TLV
  contents:
  - "4.11.10.  Token Key Identifier TLV\n   The Token Key Identifier TLV carries an\
    \ identifier for the token key\n   used to generate the OTP.\n   At least one\
    \ of the User Identifier TLV and the Token Key Identifier\n   TLV SHOULD be present\
    \ in the session's first EAP-Response of type\n   POTP-X, which also carries the\
    \ OTP TLV unless a suitable identity has\n   been provided in a preceding EAP-Response\
    \ of type Identity (1) or is\n   determined by some other means (see [1], Section\
    \ 2).  Use of the User\n   Identifier TLV and/or the Token Key Identifier TLV\
    \ is RECOMMENDED\n   even when an EAP-Response of type Identity (1) has been sent.\
    \  If a\n   peer sends both a User Identifier TLV and a Token Key Identifier TLV,\n\
    \   then the EAP server SHALL interpret the Token Key Identifier TLV as\n   specifying\
    \ a particular token key for the given user.  The EAP server\n   MUST respond\
    \ with an EAP-Failure if it cannot find a token key\n   corresponding to the provided\
    \ token key identifier.\n   This TLV type is sent by peers and MUST be supported\
    \ by all EAP\n   servers conforming to this specification.  The Token Key Identifier\n\
    \   TLV MUST NOT be present in a response that does not also carry an OTP\n  \
    \ TLV.\n    0                   1                   2                   3\n  \
    \  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Token Key Identifier ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      1 - Mandatory TLV\n   R\n      Reserved for future use.  This bit\
    \ SHALL be set to zero (0) for\n      this version.  Recipients SHALL ignore this\
    \ bit for this version\n      of EAP-POTP.\n   TLV Type\n      10\n   Length\n\
    \      Length of Token Key Identifier, >= 1\n   Token Key Identifier\n      An\
    \ identifier for the OTP token key used to generate the OTP.  The\n      field\
    \ MUST be less than 128 octets in length.\n"
- title: 4.11.11.  Time Stamp TLV
  contents:
  - "4.11.11.  Time Stamp TLV\n   The Time Stamp TLV MAY be sent by peers to simplify\
    \ authentications.\n   When present, it carries the time as reported by the OTP\
    \ Token.\n   An EAP server conformant with this specification SHOULD support\n\
    \   (i.e., recognize) this TLV, but need not be able to process or act on\n  \
    \ it.  An EAP server that does not support this TLV, but receives an\n   EAP-Response\
    \ with the TLV present, MAY ignore the value.  The Time\n   Stamp TLV MUST NOT\
    \ be present in any EAP-Responses of type POTP-X\n   other than those that also\
    \ carries an OTP TLV.\n    0                   1                   2         \
    \          3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Time Stamp ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      0 - Non-mandatory TLV\n   R\n      Reserved for future use.  This\
    \ bit SHALL be set to zero (0) for\n      this version.  Recipients SHALL ignore\
    \ this bit for this version\n      of EAP-POTP.\n   TLV Type\n      11\n   Length\n\
    \      Length of Time Stamp field, >= 20 (depending on precision)\n   Time Stamp\n\
    \      The time, as reported by the OTP token, at which the OTP used for\n   \
    \   the accompanying OTP TLV was calculated.  The field SHALL contain\n      a\
    \ UTF-8 encoded value of the XML simple type \"dateTime\", with time\n      zone\
    \ information and precision down to at least seconds, e.g.,\n      \"2004-06-16T15:20:02Z\"\
    .\n"
- title: 4.11.12.  Counter TLV
  contents:
  - "4.11.12.  Counter TLV\n   The Counter TLV MAY be sent by peers to simplify authentications.\n\
    \   When present, it carries the token counter value, as reported by the\n   OTP\
    \ Token.\n   An EAP server conformant with this specification SHOULD support\n\
    \   (i.e., recognize) this TLV, but need not be able to process or act on\n  \
    \ it.  An EAP server that does not support this TLV, but receives an\n   EAP-Response\
    \ with the TLV present, MAY ignore the value.  The Counter\n   TLV MUST NOT be\
    \ present in any EAP-Responses of type POTP-X other\n   than those that also carries\
    \ an OTP TLV.\n    0                   1                   2                 \
    \  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |M|R|\
    \          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                            Counter ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      0 - Non-mandatory TLV\n   R\n      Reserved for future use.  This\
    \ bit SHALL be set to zero (0) for\n      this version.  Recipients SHALL ignore\
    \ this bit for this version\n      of EAP-POTP.\n   TLV Type\n      12\n   Length\n\
    \      Length of Counter field, >= 1 (depending on precision)\n   Counter\n  \
    \    The counter value, as reported by the OTP token, at which the OTP\n     \
    \ used for the accompanying OTP TLV was calculated.  The counter\n      value\
    \ SHALL be represented as an unsigned integer in network-byte\n      order, e.g.,\
    \ a counter value of 1030 may be sent as the 2 octets\n      (in hex) 04 06.\n"
- title: 4.11.13.  Challenge TLV
  contents:
  - "4.11.13.  Challenge TLV\n   The Challenge TLV carries the challenge used by the\
    \ token to\n   calculate the OTP, as reported by the token to the peer.  The\n\
    \   Challenge TLV MUST be sent by a peer if and only if the challenge\n   otherwise\
    \ would be unknown to the EAP server (e.g., the token or peer\n   modified a received\
    \ challenge or generated its own challenge).\n   An EAP server conformant with\
    \ this specification SHOULD support\n   (i.e., recognize) this TLV, but need not\
    \ be able to process or act on\n   it.  An EAP server that does not support this\
    \ TLV, but receives an\n   EAP-Response with the TLV present, MAY ignore the value.\
    \  The\n   Challenge TLV MUST NOT be present in any EAP-Responses of type POTP-X\n\
    \   other than those that also carry an OTP TLV.\n    0                   1  \
    \                 2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Challenge ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      0 - Non-mandatory TLV\n   R\n      Reserved for future use.  This\
    \ bit SHALL be set to zero (0) for\n      this version.  Recipients SHALL ignore\
    \ this bit for this version\n      of EAP-POTP.\n   TLV Type\n      16\n   Length\n\
    \      Length of Challenge field, >= 1\n   Challenge\n      The challenge value\
    \ that was used to calculate the OTP used for\n      the accompanying OTP TLV.\n"
- title: 4.11.14.  Keep-Alive TLV
  contents:
  - "4.11.14.  Keep-Alive TLV\n   The Keep-Alive is used to avoid EAP-POTP timeouts.\n\
    \   The Keep-Alive TLV MAY be sent by a peer to avoid timeouts when the\n   peer\
    \ has received an EAP-Request containing an OTP TLV or a New PIN\n   TLV and is\
    \ waiting for a response from the user.\n   An EAP-Request containing a Keep-Alive\
    \ TLV MUST be sent by an EAP\n   server when the server receives an EAP-Response\
    \ containing a Keep-\n   Alive TLV, and the server has an outstanding request\
    \ that did not\n   contain a Keep-Alive TLV.  In this situation, the server does\
    \ not\n   need to re-transmit its latest outstanding request, but, due to the\n\
    \   synchronous nature of EAP, it needs to send another request.  Re-\n   transmission\
    \ of the latest outstanding request could be confusing for\n   the peer since\
    \ the request would get a new Identifier value.  The\n   Keep-Alive TLV MAY also\
    \ be sent by an EAP server when the server\n   detects that its processing time\
    \ will exceed some locally configured\n   threshold and may cause a network timeout.\
    \  In this case, the peer\n   MUST respond with an EAP-Response containing a Keep-Alive\
    \ TLV.\n   This TLV type MUST be supported by all peers and all EAP servers\n\
    \   conforming to this specification and MUST NOT be responded to with a\n   NAK\
    \ TLV.  The Keep-Alive TLV MUST NOT be sent in any other situations\n   than the\
    \ ones described above.  The Keep-Alive TLV MUST NOT be sent\n   together with\
    \ any other TLVs defined herein.  Implementations SHOULD\n   also follow recommendations\
    \ made in Section 4.3 of [1].\n    0                   1                   2 \
    \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      1 - Mandatory TLV\n   R\n   Reserved for future use.  This bit SHALL\
    \ be set to zero (0) for this\n   version.  Recipients SHALL ignore this bit for\
    \ this version of EAP-\n   POTP.\n   TLV Type\n      13\n   Length\n      0\n"
- title: 4.11.15.  Protected TLV
  contents:
  - "4.11.15.  Protected TLV\n   The Protected TLV SHALL be used to encrypt individual\
    \ or multiple\n   TLVs after successful exchange of the Confirm TLV (i.e., as\
    \ soon as\n   calculated keys have been confirmed).  The Protected TLV therefore\n\
    \   wraps \"ordinary\" TLVs.\n   This TLV type may be sent by EAP servers as well\
    \ as by peers and MUST\n   be supported by all peers conforming to this specification.\
    \  It\n   SHOULD be supported by all EAP servers conforming to this\n   specification\
    \ (it need not be supported if a server never will have a\n   need to continue\
    \ a POTP-X conversation after exchange of the Confirm\n   TLV).\n    0       \
    \            1                   2                   3\n    0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Message Authentication Code ... (16 octets)\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             IV ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Encrypted TLVs ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      1 - Mandatory TLV\n   R\n      Reserved for future use.  This bit\
    \ SHALL be set to zero (0) for\n      this version.  Recipients SHALL ignore this\
    \ bit for this version\n      of EAP-POTP.\n   TLV Type\n      14\n   Length\n\
    \      >32\n   Message Authentication Code (MAC)\n      This field integrity-protects\
    \ the TLV.  The MAC SHALL be\n      calculated over the IV and the Encrypted TLVs\
    \ field in the\n      following manner:\n      mac = MAC(K_MAC, iv | encrypted_tlvs)\n\
    \      where\n      MAC is the negotiated MAC algorithm, \"iv\" is the IV field's\
    \ value,\n      and \"encrypted_tlvs\" is the value of the Encrypted TLVs field.\n\
    \      The first 16 octets of the MAC is placed in the Message\n      Authentication\
    \ Code field.\n      Recipients MUST verify the MAC.  If the verification fails,\
    \ the\n      conversation SHALL be terminated (i.e., peers send an empty POTP-X\n\
    \      EAP-Response message, and EAP servers send an EAP-Failure message\n   \
    \   possibly preceded by an EAP-Request of type Notification).\n   IV\n      An\
    \ initialization vector for the encryption; see below.  The\n      length of the\
    \ vector is dependent on the negotiated encryption\n      algorithm, e.g., for\
    \ AES-CBC, it shall be 16 octets.  For some\n      encryption algorithms, there\
    \ may not be any initialization vector.\n      An IV, when present, shall be randomly\
    \ chosen and non-predictable.\n   Encrypted TLVs\n      This field SHALL contain\
    \ one or more encrypted POTP-X TLVs.  The\n      encryption algorithm SHALL be\
    \ as negotiated; use K_ENC as the\n      encryption key, and use the IV field\
    \ as the initialization vector\n      (when applicable), to encrypt the concatenation\
    \ of all the TLVs to\n      be protected.\n"
- title: 4.11.16.  Crypto Algorithm TLV
  contents:
  - "4.11.16.  Crypto Algorithm TLV\n   The Crypto Algorithm TLV allows for negotiation\
    \ of cryptographic\n   algorithms.  Cryptographic Algorithm negotiation is described\
    \ in\n   detail in Section 4.3.\n   This TLV MUST be present in the initial EAP-Request\
    \ of type POTP-X\n   that also carries an OTP TLV indicating protected mode, assuming\
    \ the\n   EAP server wants to negotiate use of any other algorithms than the\n\
    \   default ones.  It MAY also be present in an EAP-Request of type\n   POTP-X\
    \ that carries an OTP TLV that is sent as a result of a failed\n   session resumption\
    \ (in this case, the peer has not yet responded to\n   this TLV), or when the\
    \ Crypto Algorithm TLV was part of the initial\n   message from the EAP server,\
    \ and the client negotiated another EAP-\n   POTP version than the highest one\
    \ supported by the EAP server.  The\n   Crypto Algorithm TLV MUST NOT be present\
    \ in any other EAP-Requests.\n   Further, the Crypto Algorithm TLV MUST NOT be\
    \ present in an EAP-\n   Response of type POTP-X unless the preceding EAP-Request\
    \ also\n   contained it, and it was legal for it to do so.  This TLV MUST be\n\
    \   supported by all peers and all EAP servers conforming to this\n   specification\
    \ and MUST NOT be responded to with a NAK TLV.\n    0                   1    \
    \               2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |M|R|          TLV Type         |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Reserved    |Hash Alg.Length|        Hash Algorithms ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Encr.Alg.Length|             Encryption Algorithms ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |MAC Alg. Length|                  MAC Algorithms ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   M\n      1 - Mandatory TLV\n   R\n      Reserved for future use.  This bit\
    \ SHALL be set to zero (0) for\n      this version.  Recipients SHALL ignore this\
    \ bit for this version\n      of EAP-POTP.\n   TLV Type\n      15\n   Length\n\
    \      >=4 (at least one class of algorithms and one algorithm for that\n    \
    \  class needs to be present)\n   Reserved\n      Reserved for future use.  This\
    \ octet MUST be set to zero for this\n      version.  Recipients SHALL ignore\
    \ this octet for this version of\n      EAP-POTP.\n   Hash Alg. Length\n     \
    \ The length of the Hash Algorithms field in octets.\n   Hash Algorithms\n   \
    \   Each octet pair of this field represents a hash algorithm as\n      follows.\
    \  An EAP server MAY supply several suggestions for hash\n      algorithms.  Each\
    \ algorithm MUST appear only once.  The algorithms\n      SHALL be supplied in\
    \ order of priority.  Peers MUST supply, at\n      most, one algorithm (if none\
    \ is present, the default applies).\n      The defined values are:\n        Value\n\
    \   Octet 1 Octet 2  Hash algorithm\n   ------- -------  ----------------------------------\n\
    \   0x00    0x00     Reserved\n   0x00    0x01     SHA-1\n   0x00    0x02    \
    \ SHA-224\n   0x00    0x03     SHA-256 (default)\n   0x00    0x04     SHA-384\n\
    \   0x00    0x05     SHA-512\n   0x80     -       Vendor-specific (or experimental)\n\
    \      As indicated, values 0x8000 and higher are for proprietary\n      vendor-specific\
    \ algorithms.  Values in the range 0x0006 - 0x7fff\n      are to be assigned through\
    \ IANA; see Section 7.\n   Encr Alg. Length\n      The length of the Encryption\
    \ Algorithms field in octets.\n   Encryption Algorithms\n      Each octet pair\
    \ of this field represents an encryption algorithm\n      as follows.  An EAP\
    \ server MAY supply several suggestions for\n      encryption algorithms.  Each\
    \ algorithm MUST appear only once.  The\n      algorithms SHALL be supplied in\
    \ order of priority.  Peers MUST\n      supply, at most, one algorithm (if none\
    \ is present, the default\n      applies).  The defined values are:\n        Value\n\
    \   Octet 1 Octet 2  Encryption algorithm\n   ------- -------  ------------------------\n\
    \   0x00    0x00     Reserved\n   0x00    0x01     AES-CBC (default) with 128-bit\
    \ keys and 16-octet IVs\n   0x00    0x02     3DES-CBC with 112-bit keys and 8-octet\
    \ IVs\n   0x80     -       Vendor-specific\n      As indicated, values 0x8000\
    \ and higher are for vendor-specific\n      proprietary algorithms.  Values in\
    \ the range 0x0003 - 0x7fff are\n      to be assigned through IANA; see Section\
    \ 7.\n   MAC Alg. Length\n      The length of the MAC Algorithms field in octets.\n\
    \   MAC Algorithms\n      Each octet pair of this field represents a MAC algorithm\
    \ as\n      follows.  An EAP server MAY supply several suggestions for MAC\n \
    \     algorithms.  Each algorithm MUST appear only once.  The algorithms\n   \
    \   SHALL be supplied in order of priority.  Peers MUST supply, at\n      most,\
    \ one algorithm (if none is present, the default applies).\n      The defined\
    \ values are:\n        Value\n   Octet 1 Octet 2  MAC algorithm\n   ------- -------\
    \  -----------------\n   0x00    0x00     Reserved\n   0x00    0x01     HMAC (default)\n\
    \   0x80     -       Vendor-specific\n      As indicated, values 0x8000 and higher\
    \ are for vendor-specific\n      proprietary algorithms.  Values in the range\
    \ 0x0002 - 0x7fff are\n      to be assigned through IANA; see Section 7.\n   \
    \   When HMAC is negotiated, the hash algorithm used for HMAC SHALL be\n     \
    \ the negotiated hash algorithm.\n"
- title: 5.  EAP Key Management Framework Considerations
  contents:
  - "5.  EAP Key Management Framework Considerations\n   In line with recommendations\
    \ made in [16], EAP-POTP defines the\n   following identifiers to be associated\
    \ with generated key material:\n      Peer-ID: The combined contents of the User\
    \ Identifier TLV and the\n      Token Key Identifier TLV.\n      Server-ID: The\
    \ contents of the Server Identifier field of the\n      Server-Info TLV.\n   \
    \   Method-ID: The identifier of the established session (i.e., the\n      contents\
    \ of the Session Identifier field of the Server-Info TLV\n      that defined the\
    \ session).\n"
- title: 6.  Security Considerations
  contents:
  - '6.  Security Considerations

    '
- title: 6.1.  Security Claims
  contents:
  - "6.1.  Security Claims\n   In conformance with RFC 3748 [1], the following security\
    \ claims are\n   made for the EAP-POTP method:\n   Authentication mechanism: \
    \ Generic OTP\n   Ciphersuite negotiation:   Yes (No in basic variant)\n   Mutual\
    \ authentication:     Yes (No in basic variant)\n   Integrity protection:    \
    \  Yes (No in basic variant)\n   Replay protection:         Yes (see below)\n\
    \   Confidentiality:           Only in the OTP protection variant, and\n     \
    \                         then only OTP values and any information\n         \
    \                     sent after exchange of the Confirm TLV\n   Key derivation:\
    \            Yes (No in basic variant)\n   Key strength:              Depends\
    \ on size of OTP value, strength of\n                              underlying\
    \ shared secret, strength and\n                              characteristics of\
    \ OTP algorithm, pepper\n                              length, iteration count,\
    \ and whether the\n                              method is used within a tunnel\
    \ such as\n                              PEAPv2.  For some illustrative examples,\n\
    \                              and a further discussion of this, see\n       \
    \                       Appendix D.\n   Dictionary attack prot.:   N/A (Human-selected\
    \ passwords not used)\n   Fast reconnect:            Yes\n   Crypt. binding: \
    \           N/A (EAP-POTP is not a tunnel method)\n   Session independence:  \
    \    Yes\n   Fragmentation:             N/A (Packets shall not exceed MTU of 1020)\n\
    \   Channel binding:           Yes (No in basic variant)\n   Acknowledged S/F:\
    \          Yes\n   State Synchronization:     Yes (No in basic variant)\n"
- title: 6.2.  Passive and Active Attacks
  contents:
  - "6.2.  Passive and Active Attacks\n   The basic variant (i.e., when the protection\
    \ of OTPs and mutual\n   authentication is not used) of this EAP method does not\
    \ provide\n   session privacy, session integrity, server authentication, or\n\
    \   protection from active attacks.  In particular, man-in-the-middle\n   attacks,\
    \ where an attacker acts as an authenticator in order to\n   acquire a valid OTP,\
    \ are possible.\n   Similarly, the basic variant of this EAP method does not protect\n\
    \   against session hijacking taking place after authentication.  Nor\n   does\
    \ it, in itself, protect against replay attacks, where the\n   attacker gains\
    \ access by replaying a previous valid request, but see\n   also the next subsection.\
    \  When PIN codes are transmitted, they are\n   sent without protection and are\
    \ also subject to replay attacks.\n   In order to protect against these attacks,\
    \ the peer MUST only use the\n   basic variant of this method over a server-authenticated\
    \ and\n   confidentiality-protected connection.  This can be achieved via use\n\
    \   of, PEAPv2 [17], for example.\n   When the OTP protection variant is used,\
    \ however, the EAP method\n   provides privacy for OTPs and new PINs, negotiation\
    \ of cryptographic\n   algorithms, mutual authentication, and protection against\
    \ replay\n   attacks and protocol version downgrades.  It also provides protection\n\
    \   against man-in-the-middle attacks, not due to the infeasibility for a\n  \
    \ man-in-the-middle to solve for a valid OTP given an OTP TLV, but due\n   to\
    \ the computational expense of finding the OTP in the limited time\n   period\
    \ during which it is valid (this is mainly true for tokens,\n   including the\
    \ current time in their OTP calculations, or when a sent\n   challenge has a certain\
    \ lifetime).  It should be noted, however, that\n   a retrieved OTP, even if \"\
    old\" and invalid, still may divulge some\n   information about the user's PIN.\
    \  Clearly, this is also true for the\n   basic variant.  Implementations of this\
    \ EAP method, where user PINs\n   are sent with OTPs, are therefore RECOMMENDED\
    \ to ensure regular user\n   PIN changes, regardless of whether the protected\
    \ variant or the basic\n   variant is employed.\n   It should also be noted that,\
    \ while it is possible for a rogue access\n   point, e.g., to clone MAC addresses,\
    \ and hence mount a man-in-the-\n   middle attack, such an access point will not\
    \ be able to calculate the\n   session keys MSK and EMSK.  This demonstrates the\
    \ importance of using\n   the derived key material properly to protect a subsequent\
    \ session.\n   Protected mode protects against version downgrade attacks due to\
    \ the\n   HMAC both parties transmit in this mode.  As described, each party\n\
    \   calculates the HMAC on sent and received EAP-POTP handshake messages.\n  \
    \ If an attacker were to modify a Version TLV, this would be reflected\n   in\
    \ a difference between the calculated MACs (since the recipient of\n   the Version\
    \ TLV received a different value than the sender sent).\n   Unless the attacker\
    \ knows K_MAC, he cannot calculate the correct MAC,\n   and hence the difference\
    \ will be detected.\n   The OTP protection variant also protects against session\
    \ hijacking,\n   if the derived key material is used (directly or indirectly)\
    \ to\n   protect a subsequent session.  For these reasons, use of the OTP\n  \
    \ protection variant is RECOMMENDED.\n   However, it should be noted that not\
    \ even the OTP protection variant\n   provides privacy for user names and/or token\
    \ key identifiers.  EAP-\n   POTP MUST be used within a secure tunnel such as\
    \ the one provided by\n   PEAPv2 [17] if privacy for these parameters is required.\n\
    \   When resuming sessions created in the basic variant (which MUST only\n   take\
    \ place within a protected tunnel), the peer is authenticated by\n   demonstrating\
    \ knowledge of not just a valid session identifier, but\n   also the OTP used\
    \ when the session was created.  Server nonces\n   prevent replay attacks, but\
    \ there still remains some likelihood of an\n   attacker guessing the correct\
    \ combination of session identifier and\n   OTP value.  Assuming OTPs with entropy\
    \ about 32 bits, this means that\n   the likelihood of succeeding with such an\
    \ attack is about 1/2^48 due\n   to the birthday paradox.  Servers allowing session\
    \ resumption for the\n   basic variant MUST protect against such attacks, e.g.,\
    \ by keeping\n   track of the rate of failed resumption attempts.\n"
- title: 6.3.  Denial-of-Service Attacks
  contents:
  - "6.3.  Denial-of-Service Attacks\n   An active attacker may replace the iteration\
    \ count value in OTP TLVs\n   sent by the peer to slow down an authentication\
    \ server.\n   Authentication servers SHOULD protect against this, e.g., by\n \
    \  disregarding OTP TLVs with an iteration count value higher than some\n   number\
    \ that is preset or dynamically set (depending on load).\n"
- title: 6.4.  The Use of Pepper
  contents:
  - "6.4.  The Use of Pepper\n   As described in Section 4.8, the use of pepper will\
    \ slow down an\n   attacker's search for a matching OTP.  The ability to transfer\
    \ a\n   pepper value in encrypted form from the EAP server to the peer means\n\
    \   that, even though there may be an initial computational cost for the\n   EAP\
    \ server to authenticate the peer, subsequent authentications will\n   be efficient,\
    \ while at the same time more secure, since a pre-shared,\n   128-bit-long pepper\
    \ value will not be easily found by an attacker.\n   An attacker, observing an\
    \ EAP-Request containing an OTP TLV\n   calculated using a pepper chosen by the\
    \ peer, may, however, depending\n   on available resources, be able to successfully\
    \ attack that\n   particular EAP-POTP session, since it most likely will be based\
    \ on a\n   relatively short pepper value or only an iteration count.  Once the\n\
    \   correct OTP has been found, eavesdropping on the EAP server's Confirm\n  \
    \ TLV will potentially give the attacker access to the longer, server-\n   provided\
    \ pepper for the remaining lifetime of that pepper value.  For\n   this reason,\
    \ initial exchanges with EAP servers SHOULD occur in a\n   secure environment\
    \ (e.g., in a PEAPv2 tunnel offering cryptographic\n   binding with inner EAP\
    \ methods).  If initial exchanges do not occur\n   in a secure environment, the\
    \ iteration count MUST be significantly\n   higher than for messages where a pre-shared\
    \ pepper is used.  The\n   lifetime of the shared pepper must also be calculated\
    \ with this in\n   mind.  Finally, the peer and the EAP server MUST store the\
    \ pepper\n   value securely and associated with the user.\n"
- title: 6.5.  The Race Attack
  contents:
  - "6.5.  The Race Attack\n   In the case of fragmentation of EAP messages, it is\
    \ possible (in the\n   basic variant of this method) for an attacker to listen\
    \ to most of an\n   OTP, guess the remainder, and then race the legitimate user\
    \ to\n   complete the authentication.  Conforming backend authentication\n   server\
    \ implementations MUST protect against this race condition.  One\n   defense against\
    \ this attack is outlined below and borrowed from [14];\n   implementations MAY\
    \ use this approach or MAY select an alternative\n   defense.  Note that the described\
    \ defense relies on the user\n   providing the identity in response to an initial\
    \ Identity EAP-\n   Request.\n   One possible defense is to prevent a user from\
    \ starting multiple\n   simultaneous authentication sessions.  This means that\
    \ once the\n   legitimate user has initiated authentication, an attacker would\
    \ be\n   blocked until the first authentication process has completed.  In\n \
    \  this approach, a timeout is necessary to thwart a denial-of-service\n   attack.\n"
- title: 7.  IANA Considerations
  contents:
  - '7.  IANA Considerations

    '
- title: 7.1.  General
  contents:
  - "7.1.  General\n   This document is a description of a general EAP method for\
    \ OTP\n   tokens.  It also defines EAP method 32 as a profile of the general\n\
    \   method.  Extending the set of EAP-POTP TLVs or the set of EAP-POTP\n   cryptographic\
    \ algorithms shall be seen as revisions of the protocol\n   and hence shall require\
    \ an RFC that updates or obsoletes this\n   document.\n"
- title: 7.2.  Cryptographic Algorithm Identifier Octets
  contents:
  - "7.2.  Cryptographic Algorithm Identifier Octets\n   A new registry for EAP-POTP\
    \ cryptographic algorithm identifier octets\n   has been created.  The initial\
    \ contents of this registry are as\n   specified in Section 4.11.16.\n   Assignment\
    \ of new values for hash algorithms, encryption algorithms,\n   and MAC algorithms\
    \ in the Crypto Algorithm TLV MUST be done through\n   IANA with \"Specification\
    \ Required\" and \"IESG Approval\" (see [9] for\n   the meaning of these terms).\n"
- title: 8.  Intellectual Property Considerations
  contents:
  - "8.  Intellectual Property Considerations\n   RSA, RSA Security, and SecurID are\
    \ either registered trademarks or\n   trademarks of RSA Security Inc. in the United\
    \ States and/or other\n   countries.  The names of other products and services\
    \ mentioned may be\n   the trademarks of their respective owners.\n"
- title: 9.  Acknowledgments
  contents:
  - "9.  Acknowledgments\n   This document was improved by comments from, and discussion\
    \ with, a\n   number of RSA Security employees.  Simon Josefsson drafted the\n\
    \   initial versions of an RSA SecurID EAP method while working for RSA\n   Laboratories.\
    \  The inspiration for the TLV-type of information\n   exchange comes from [17].\
    \  Special thanks to Oliver Tavakoli of Funk\n   Software who provided numerous\
    \ useful comments and suggestions, Randy\n   Chou of Aruba Networks for good suggestions\
    \ in the session resumption\n   area, and Jim Burns of Meetinghouse who provided\
    \ inspiration for the\n   Protected TLV.  Thanks also to the IESG reviewers, Pasi\
    \ Eronen, David\n   Black, and Uri Blumenthal, for insightful comments that helped\
    \ to\n   improve the document, and to Alfred Hoenes for a thorough editorial\n\
    \   review.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [1]   Blunk, L., Vollbrecht, J., Aboba, B., Carlson,\
    \ J., and H.\n         Levkowetz, Ed., \"Extensible Authentication Protocol (EAP)\"\
    , RFC\n         3748, June 2004.\n   [2]   Bradner, S., \"Key words for use in\
    \ RFCs to Indicate Requirement\n         Levels\", BCP 14, RFC 2119, March 1997.\n\
    \   [3]   National Institute of Standards and Technology, \"Secure Hash\n    \
    \     Standard\", FIPS 180-2, February 2004.\n   [4]   National Institute of Standards\
    \ and Technology, \"Specification\n         for the Advanced Encryption Standard\
    \ (AES)\", FIPS 197, November\n         2001.\n   [5]   Krawczyk, H., Bellare,\
    \ M., and R. Canetti, \"HMAC: Keyed-Hashing\n         for Message Authentication\"\
    , RFC 2104, February 1997.\n   [6]  Kaliski, B., \"PKCS #5: Password-Based Cryptography\
    \ Specification\n         Version 2.0\", RFC 2898, September 2000.\n   [7]   Yergeau,\
    \ F., \"UTF-8, a transformation format of ISO 10646\", STD\n         63, RFC 3629,\
    \ November 2003.\n   [8]   Schulzrinne, H., \"The tel URI for Telephone Numbers\"\
    , RFC 3966,\n         December 2004.\n   [9]   Narten, T. and H. Alvestrand, \"\
    Guidelines for Writing an IANA\n         Considerations Section in RFCs\", RFC\
    \ 2434, October 1998.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [10]  Simpson, W., Ed., \"The Point-to-Point\
    \ Protocol (PPP)\", STD 51,\n         RFC 1661, July 1994.\n   [11]  The Institute\
    \ of Electrical and Electronics Engineers, Inc.,\n         \"IEEE Standard for\
    \ Local and metropolitan area networks --\n         Port-Based Network Access\
    \ Control\", IEEE 802.1X-2001, July\n         2001.\n   [12]  Kaufman, C., Ed.,\
    \ \"Internet Key Exchange (IKEv2) Protocol\", RFC\n         4306, December 2005.\n\
    \   [13]  Stanley, D., Walker, J., and B. Aboba, \"Extensible\n         Authentication\
    \ Protocol (EAP) Method Requirements for Wireless\n         LANs\", RFC 4017,\
    \ March 2005.\n   [14]  Haller, N., Metz, C., Nesser, P., and M. Straw, \"A One-Time\n\
    \         Password System\", STD 61, RFC 2289, February 1998.\n   [15]  Rigney,\
    \ C., Willens, S., Rubens, A., and W. Simpson, \"Remote\n         Authentication\
    \ Dial In User Service (RADIUS)\", RFC 2865, June\n         2000.\n   [16]  Aboba,\
    \ B., Simon, D., Eronen, P., and H. Levkowetz, Ed.,\n         \"Extensible Authentication\
    \ Protocol (EAP) Key Management\n         Framework\", Work in Progress, October\
    \ 2006.\n   [17]  Palekar, A., Simon, D., Zorn, G., Salowey, J., Zhou, H., and\
    \ S.\n         Josefsson, \"Protected EAP Protocol (PEAP) Version 2\", Work in\n\
    \         Progress, October 2004.\n   [18]  Internet Assigned Numbers Authority,\
    \ \"Private Enterprise\n         Numbers\", December 2006.\n   [19]  Zorn, G.,\
    \ \"Microsoft Vendor-specific RADIUS Attributes\", RFC\n         2548, March 1999.\n"
- title: Appendix A.  Profile of EAP-POTP for RSA SecurID
  contents:
  - "Appendix A.  Profile of EAP-POTP for RSA SecurID\n   Note: The RSA SecurID product\
    \ is a hardware token card (or software\n   emulation thereof) produced by RSA\
    \ Security Inc., which is used for\n   end-user authentication.\n   The EAP method\
    \ type identifier for the RSA SecurID profile of EAP-\n   POTP is 32.\n   Peers\
    \ and EAP servers implementing the SecurID profile of EAP-POTP\n   SHALL conform\
    \ to all EAP-POTP normative requirements in this\n   Document.  In addition, the\
    \ New PIN TLV and the Protected TLV MUST be\n   supported by peers.\n"
- title: Appendix B.  Examples of EAP-POTP Exchanges
  contents:
  - "Appendix B.  Examples of EAP-POTP Exchanges\n   This appendix is non-normative.\
    \  In the examples, \"V1\", \"V2\", \"V3\",\n   etc., stand for arbitrary values\
    \ of the correct type.\n"
- title: B.1.  Basic Mode, Unilateral Authentication
  contents:
  - "B.1.  Basic Mode, Unilateral Authentication\n   This mode should only be used\
    \ within a secured tunnel.  The peer\n   identifies itself with a User Identifier\
    \ TLV.\n   Peer                                 EAP server\n                 \
    \                       <- EAP-Request\n                                     \
    \      Type=Identity\n   EAP-Response ->\n   Type=Identity\n                 \
    \                       <- EAP-Request\n                                     \
    \      Type=OTP-X\n                                           Version TLV:\n \
    \                                          Highest=0,Lowest=0\n              \
    \                             OTP TLV:\n                                     \
    \      P=0,C=0,N=0,T=0,E=0,R=0\n   EAP-Response ->\n   Type=OTP-X\n   Version\
    \ TLV:\n   Highest=0\n   OTP TLV:\n   P=0,C=0,N=0,T=0,E=0,R=0\n   Authentication\
    \ Data=V1\n   User Identifier TLV:\n   User Identifier=V2\n                  \
    \                      <- EAP-Success\n"
- title: B.2.  Basic Mode, Session Resumption
  contents:
  - "B.2.  Basic Mode, Session Resumption\n   This example illustrates successful\
    \ resumption of a basic mode\n   session.  It must be carried out only in a protected\
    \ tunnel.\n   Peer                                 EAP server\n              \
    \                          <- EAP-Request\n                                  \
    \         Type=Identity\n   EAP-Response ->\n   Type=Identity\n              \
    \                          <- EAP-Request\n                                  \
    \         Type=OTP-X\n                                           Version TLV:\n\
    \                                           Highest=0,Lowest=0\n             \
    \                              OTP TLV:\n                                    \
    \       P=0,C=0,N=0,T=0,E=0,R=0\n                                           Server-Info\
    \ TLV:\n                                           N=0\n                     \
    \                      Session Identifier=V1\n                               \
    \            Server  Identifier=V2\n                                         \
    \  Nonce=V3\n   EAP-Response ->\n   Type=OTP-X\n   Version TLV:\n   Highest=0\n\
    \   Resume TLV:\n   Session Identifier=V4 (indicating earlier, basic mode, session)\n\
    \   Authentication Data=V5\n                                        <- EAP-Success\n"
- title: B.3.  Mutual Authentication without Session Resumption
  contents:
  - "B.3.  Mutual Authentication without Session Resumption\n   In this case, the\
    \ peer uses the token key identifier, in addition to\n   the user identifier.\
    \  The initial EAP-Identity exchange may also\n   provide user information, or\
    \ may be restricted to only general domain\n   information.  Pepper is not used,\
    \ but will be used in a subsequent\n   session since the server provides the peer\
    \ with an encrypted pepper\n   in its Confirm TLV.  Absence of the Crypto Algorithm\
    \ TLV indicates\n   use of default cryptographic algorithms.\n   Peer        \
    \                         EAP server\n                                       \
    \ <- EAP-Request\n                                           Type=Identity\n \
    \  EAP-Response ->\n   Type=Identity\n                                       \
    \ <- EAP-Request\n                                           Type=OTP-X\n    \
    \                                       Version TLV:\n                       \
    \                    Highest=0,Lowest=0\n                                    \
    \       Server-Info TLV:\n                                           N=0\n   \
    \                                        Session Identifier=V1\n             \
    \                              Server  Identifier=V2\n                       \
    \                    Nonce=V3\n                                           OTP\
    \ TLV:\n                                           P=1,C=0,N=0,T=0,E=0,R=0\n \
    \                                          Pepper Length=0\n                 \
    \                          Iteration Count=V4\n   EAP-Response ->\n   Type=OTP-X\n\
    \   Version TLV:\n   Highest=0\n   OTP TLV:\n   P=1,C=0,N=0,T=0,E=0,R=0\n   Pepper\
    \ Length=0\n   Iteration Count=V4\n   Authentication Data=V5\n   User Identifier\
    \ TLV:\n   User Identifier=V6\n   Token Key Identifier TLV:\n   Token Key Identifier=V7\n\
    \                                        <- EAP-Request\n                    \
    \                       Type=OTP-X\n                                         \
    \  Confirm TLV:\n                                           C=0\n            \
    \                               Authentication Data=V8\n                     \
    \                      Pepper Identifier=V9\n                                \
    \           Encrypted Pepper=V10\n   EAP-Response ->\n   Type=OTP-X\n   Confirm\
    \ TLV:\n   (no data)\n                                        <- EAP-Success\n"
- title: B.4.  Mutual Authentication with Transfer of Pepper
  contents:
  - "B.4.  Mutual Authentication with Transfer of Pepper\n   The difference between\
    \ this example and the previous one is that the\n   peer makes use of an existing\
    \ pepper in the PBKDF2 computation.  The\n   EAP server provides a new pepper\
    \ to the peer in the Confirm TLV.\n   Note that the peer had not been able to\
    \ use a pepper in the response\n   calculation unless it had found the existing\
    \ pepper, since the server\n   specified a maximum (new) pepper length of zero.\n\
    \   Peer                                 EAP server\n                        \
    \                <- EAP-Request\n                                           Type=Identity\n\
    \   EAP-Response ->\n   Type=Identity\n                                      \
    \  <- EAP-Request\n                                           Type=OTP-X\n   \
    \                                        Version TLV:\n                      \
    \                     Highest=0,Lowest=0\n                                   \
    \        Server-Info TLV:\n                                           N=0\n  \
    \                                         Session Identifier=V1\n            \
    \                               Server  Identifier=V2\n                      \
    \                     Nonce=V3\n                                           OTP\
    \ TLV:\n                                           P=1,C=0,N=0,T=0,E=0,R=0\n \
    \                                          Pepper Length=0\n                 \
    \                          Iteration Count=V4\n   EAP-Response ->\n   Type=OTP-X\n\
    \   Version TLV:\n   Highest=0\n   OTP TLV:\n   P=1,C=0,N=0,T=0,E=0,R=0\n   Pepper\
    \ Length=V5\n   Iteration Count=V6\n   Authentication Data=V7\n   (includes a\
    \ pepper identifier)\n   User Identifier TLV:\n   User Identifier=V8\n   Token\
    \ Key Identifier TLV:\n   Token Key Identifier=V9\n                          \
    \              <- EAP-Request\n                                           Type=OTP-X\n\
    \                                           Confirm TLV:\n                   \
    \                        C=0\n                                           Authentication\
    \ Data=V10\n                                           Pepper Identifier=V11\n\
    \                                           Encrypted Pepper=V12\n   EAP-Response\
    \ ->\n   Type=OTP-X\n   Confirm TLV:\n   (no data)\n                         \
    \               <- EAP-Success\n"
- title: B.5.  Failed Mutual Authentication
  contents:
  - "B.5.  Failed Mutual Authentication\n   This example differs from the previous\
    \ one in that the peer is not\n   able to authenticate the server.  Therefore,\
    \ it sends an empty EAP-\n   Response of type POTP-X, which the EAP server acknowledges\
    \ by\n   responding with an EAP-Failure.  Pepper is not used.\n   Peer       \
    \                          EAP server\n                                      \
    \  <- EAP-Request\n                                           Type=Identity\n\
    \   EAP-Response ->\n   Type=Identity\n                                      \
    \  <- EAP-Request\n                                           Type=OTP-X\n   \
    \                                        Version TLV:\n                      \
    \                     Highest=0,Lowest=0\n                                   \
    \        OTP TLV:\n                                           P=1,C=0,N=0,T=0,E=0,R=0\n\
    \                                           Pepper Length=V1\n               \
    \                            Iteration Count=V2\n                            \
    \               Server-Info TLV:\n                                           N=0\n\
    \                                           Session Identifier=V3\n          \
    \                                 Server  Identifier=V4\n                    \
    \                       Nonce=V5\n   EAP-Response ->\n   Type=OTP-X\n   Version\
    \ TLV:\n   Highest=0\n   OTP TLV:\n   P=1,C=0,N=0,T=0,E=0,R=0\n   Pepper Length=V1\n\
    \   Iteration Count=V2\n   Authentication Data=V6\n   User Identifier TLV:\n \
    \  User Identifier=V7\n   Token Key Identifier TLV:\n   Token Key Identifier=V8\n\
    \                                        <- EAP-Request\n                    \
    \                       Type=OTP-X\n                                         \
    \  Confirm TLV:\n                                           C=0\n            \
    \                               Authentication Data=V9\n   EAP-Response ->\n \
    \  Type=OTP-X\n   (no data)\n                                        <- EAP-Failure\n"
- title: B.6.  Session Resumption
  contents:
  - "B.6.  Session Resumption\n   This example illustrates successful session resumption.\n\
    \   Peer                                 EAP server\n                        \
    \                <- EAP-Request\n                                           Type=Identity\n\
    \   EAP-Response ->\n   Type=Identity\n                                      \
    \  <- EAP-Request\n                                           Type=OTP-X\n   \
    \                                        Version TLV:\n                      \
    \                     Highest=0,Lowest=0\n                                   \
    \        OTP TLV:\n                                           P=1,C=0,N=0,T=0,E=0,R=0\n\
    \                                           Pepper Length=V1\n               \
    \                            Iteration Count=V2\n                            \
    \               Server-Info TLV:\n                                           N=0\n\
    \                                           Session Identifier=V3\n          \
    \                                 Server  Identifier=V4\n                    \
    \                       Nonce=V5\n   EAP-Response ->\n   Type=OTP-X\n   Version\
    \ TLV:\n   Highest=0\n   Resume TLV:\n   Session Identifier=V6 (indicating earlier,\
    \ protected mode, session)\n   Authentication Data=V7\n                      \
    \                  <- EAP-Request\n                                          \
    \ Type=OTP-X\n                                           Confirm TLV:\n      \
    \                                     C=0\n                                  \
    \         Authentication Data=V8\n   EAP-Response ->\n   Type=OTP-X\n   Confirm\
    \ TLV:\n   (no data)\n                                        <- EAP-Success\n"
- title: B.7.  Failed Session Resumption
  contents:
  - "B.7.  Failed Session Resumption\n   This example illustrates a failed session\
    \ resumption, followed by a\n   complete mutual authentication.  The user is identified\
    \ through the\n   User Identifier TLV.  The client is able to reuse an older pepper.\n\
    \   The server sends a new pepper for subsequent use in its Confirm TLV.\n   The\
    \ server suggests some non-default cryptographic algorithms, but\n   the client\
    \ only supports the default ones.\n   Peer                                 EAP\
    \ server\n                                        <- EAP-Request\n           \
    \                                Type=Identity\n   EAP-Response ->\n   Type=Identity\n\
    \                                        <- EAP-Request\n                    \
    \                       Type=OTP-X\n                                         \
    \  Version TLV:\n                                           Highest=0,Lowest=0\n\
    \                                           OTP TLV:\n                       \
    \                    P=1,C=0,N=0,T=0,E=0,R=0\n                               \
    \            Pepper Length=V1\n                                           Iteration\
    \ Count=V2\n                                           Server-Info TLV:\n    \
    \                                       N=0\n                                \
    \           Session Identifier=V3\n                                          \
    \ Server  Identifier=V4\n                                           Nonce=V5\n\
    \                                           Crypto Algorithm TLV:\n          \
    \                                 Hash Alg. Length=V6\n                      \
    \                     Hash Algorithms=V7\n                                   \
    \        Encr. Alg. Length=V8\n                                           Encr.\
    \ Algorithms=V9\n                                           MAC Alg. Length=V10\n\
    \                                           MAC Algorithms=V11\n   EAP-Response\
    \ ->\n   Type=OTP-X\n   Version TLV:\n   Highest=0\n   Resume TLV:\n   Session\
    \ Identifier=V12 (indicating earlier session)\n   Authentication Data=V13\n  \
    \                                      <- EAP-Request\n                      \
    \                     Type=OTP-X\n                                           OTP\
    \ TLV:\n                                           P=1,C=0,N=0,T=0,E=0,R=0\n \
    \                                          Pepper Length=V14\n               \
    \                            Iteration Count=V15\n                           \
    \                Server-Info TLV:\n                                          \
    \ N=1 (no resumption)\n                                           Session Identifier=V3\n\
    \                                           Server  Identifier=V4\n          \
    \                                 Nonce=V16\n   EAP-Response ->\n   Type=OTP-X\n\
    \   OTP TLV:\n   P=1,C=0,N=1,T=1,E=0,R=0\n   Pepper Length=V17\n   Iteration Count=V18\n\
    \   Authentication Data=V19 (with pepper identifier)\n   User Identifier TLV:\n\
    \   User Identifier=V20\n                                        <- EAP-Request\n\
    \                                           Type=OTP-X\n                     \
    \                      Confirm TLV:\n                                        \
    \   C=0\n                                           Authentication Data=V21\n\
    \                                           Pepper Identifier=V22\n          \
    \                                 Encrypted Pepper=V23\n   EAP-Response ->\n \
    \  Type=OTP-X\n   Confirm TLV:\n   (no data)\n                               \
    \         <- EAP-Success\n"
- title: B.8.  Mutual Authentication, and New PIN Requested.
  contents:
  - "B.8.  Mutual Authentication, and New PIN Requested.\n   In this example, the\
    \ user is also requested to select a new PIN.  The\n   new PIN is allowed to be\
    \ alphanumeric, and must be at least 6\n   characters long.  The user selects\
    \ another PIN than the one suggested\n   by the server.  The token key is identified\
    \ through a combination of\n   the user identifier and the token key identifier.\
    \  While waiting for\n   the user input, to avoid network timeouts, the peer sends\
    \ an EAP-\n   Response containing a Keep-Alive TLV to the EAP server.  The EAP\n\
    \   server responds by sending an EAP-Request containing a Keep-Alive TLV\n  \
    \ back to the peer.  Note that all TLVs exchanged after the Confirm TLV\n   exchange\
    \ are wrapped in the Protected TLV.  Absence of the Crypto\n   Algorithm TLV indicates\
    \ use of default cryptographic algorithms.\n   Peer                          \
    \       EAP server\n                                        <- EAP-Request\n \
    \                                          Type=Identity\n   EAP-Response ->\n\
    \   Type=Identity\n                                        <- EAP-Request\n  \
    \                                         Type=OTP-X\n                       \
    \                    Version TLV:\n                                          \
    \ Highest=0,Lowest=0\n                                           OTP TLV:\n  \
    \                                         P=1,C=0,N=0,T=0,E=0,R=0\n          \
    \                                 Pepper Length=V1\n                         \
    \                  Iteration Count=V2\n                                      \
    \     Server-Info TLV:\n                                           N=0\n     \
    \                                      Session Identifier=V3\n               \
    \                            Server  Identifier=V4\n                         \
    \                  Nonce=V5\n   EAP-Response ->\n   Type=OTP-X\n   Version TLV:\n\
    \   Highest=0\n   OTP TLV:\n   P=1,C=0,N=0,T=0,E=0,R=0\n   Pepper Length=V6\n\
    \   Iteration Count=V7\n   Authentication Data=V8 (with pepper identifier)\n \
    \  User Identifier TLV:\n   User Identifier=V9\n   Token Key Identifier TLV:\n\
    \   Token Key Identifier=V10\n                                        <- EAP-Request\n\
    \                                           Type=OTP-X\n                     \
    \                      Confirm TLV:\n                                        \
    \   C=1\n                                           Authentication Data=V11\n\
    \   EAP-Response ->\n   Type=OTP-X\n   Confirm TLV:\n   (no data)\n          \
    \                              <- EAP-Request\n                              \
    \             Type=OTP-X\n                                           Protected\
    \ TLV:\n                                           MAC=V12\n                 \
    \                          IV=V13\n                                          \
    \ Encrypted TLVs=V14\n                                           (Contains:\n\
    \                                           New PIN TLV:\n                   \
    \                        Q=0,A=1\n                                           PIN=V15\n\
    \                                           Min. PIN Length=6)\n   EAP-Response\
    \ ->\n   Type=OTP-X\n   Protected TLV:\n   MAC=V16\n   IV=V17\n   Encrypted TLVs=V18\n\
    \   (Contains:\n   Keep-Alive TLV:\n   (no data))\n                          \
    \              <- EAP-Request\n                                           Type=OTP-X\n\
    \                                           Protected TLV:\n                 \
    \                          MAC=V19\n                                         \
    \  IV=V20\n                                           Encrypted TLVs=V21\n   \
    \                                        (Contains:\n                        \
    \                   Keep-Alive TLV:\n                                        \
    \   (no data))\n   EAP-Response ->\n   Type=OTP-X\n   Protected TLV:\n   MAC=V22\n\
    \   IV=V23\n   Encrypted TLVs=V24\n   (Contains:\n   New PIN TLV:\n   Q=0,A=0\n\
    \   PIN=V25)\n                                        <- EAP-Request\n       \
    \                                    Type=OTP-X\n                            \
    \               Protected TLV:\n                                           MAC=V26\n\
    \                                           IV=V27\n                         \
    \                  Encrypted TLVs=V28\n                                      \
    \     (Contains:\n                                           OTP TLV:\n      \
    \                                     P=1,C=0,N=0,T=0,E=0,R=0\n              \
    \                             Pepper Length=V1\n                             \
    \              Iteration Count=V2)\n   EAP-Response ->\n   Type=OTP-X\n   Protected\
    \ TLV\n   MAC=V29\n   IV=V30\n   Encrypted TLVs=V31\n   (Contains:\n   OTP TLV:\n\
    \   P=1,C=0,N=0,T=0,E=0,R=0\n   Pepper Length=V6\n   Iteration Count=V7\n   Authentication\
    \ Data=V31)\n                                        <- EAP-Request\n        \
    \                                   Type=OTP-X\n                             \
    \              Protected TLV\n                                           MAC=V32\n\
    \                                           IV=V33\n                         \
    \                  Encrypted TLVs=V34\n                                      \
    \     (Contains:\n                                           Confirm TLV:\n  \
    \                                         C=0\n                              \
    \             Authentication Data=V35)\n   EAP-Response ->\n   Type=OTP-X\n  \
    \ Protected TLV\n   MAC=V36\n   IV=V37\n   Encrypted TLVs=V38\n   (Contains:\n\
    \   Confirm TLV:\n   (no data))\n                                        <- EAP-Success\n"
- title: B.9.  Use of Next OTP Mode
  contents:
  - "B.9.  Use of Next OTP Mode\n   In this example, the peer is requested to provide\
    \ a second OTP to the\n   EAP server.\n   Peer                               \
    \  EAP server\n                                        <- EAP-Request\n      \
    \                                     Type=Identity\n   EAP-Response ->\n   Type=Identity\n\
    \                                        <- EAP-Request\n                    \
    \                       Type=OTP-X\n                                         \
    \  Version TLV:\n                                           Highest=0,Lowest=0\n\
    \                                           OTP TLV:\n                       \
    \                    P=1,C=0,N=0,T=0,E=0,R=0\n                               \
    \            Pepper Length=V1\n                                           Iteration\
    \ Count=V2\n                                           Server-Info TLV:\n    \
    \                                       N=0\n                                \
    \           Session Identifier=V3\n                                          \
    \ Server  Identifier=V4\n                                           Nonce=V5\n\
    \   EAP-Response ->\n   Type=OTP-X\n   Version TLV:\n   Highest=0\n   OTP TLV:\n\
    \   P=1,C=0,N=0,T=0,E=0,R=0\n   Pepper Length=V6\n   Iteration Count=V7\n   Authentication\
    \ Data=V8\n   User Identifier TLV:\n   User Identifier=V9\n                  \
    \                      <- EAP-Request\n                                      \
    \     Type=OTP-X\n                                           OTP TLV:\n      \
    \                                     P=1,C=0,N=1,T=1,E=0,R=0\n              \
    \                             Pepper Length=V1\n                             \
    \              Iteration Count=V2\n   EAP-Response ->\n   Type=OTP-X\n   OTP TLV:\n\
    \   P=1,C=0,N=1,T=1,E=0,R=0\n   Pepper Length=V6\n   Iteration Count=V7\n   Authentication\
    \ Data=V10\n                                        <- EAP-Request\n         \
    \                                  Type=OTP-X\n                              \
    \             Confirm TLV:\n                                           C=0\n \
    \                                          Authentication Data=V11\n   EAP-Response\
    \ ->\n   Type=OTP-X\n   Confirm TLV:\n   (no data)\n                         \
    \               <- EAP-Success\n"
- title: Appendix C.  Use of the MPPE-Send/Receive-Key RADIUS Attributes
  contents:
  - 'Appendix C.  Use of the MPPE-Send/Receive-Key RADIUS Attributes

    '
- title: C.1.  Introduction
  contents:
  - "C.1.  Introduction\n   This section describes how to populate the MPPE-Send-Key\
    \ and the\n   MPPE-Receive-Key RADIUS attributes defined in [19], using an MSK\n\
    \   established in EAP-POTP.\n"
- title: C.2.  MPPE Key Attribute Population
  contents:
  - "C.2.  MPPE Key Attribute Population\n   Once the EAP-POTP MSK has been generated,\
    \ it is used as follows to\n   populate the MPPE-Send-Key and the MPPE-Receive-Key\
    \ attributes:\n   Use the initial 32 octets of the MSK as the value for the \"\
    Key\" sub-\n   field in the plaintext \"String\" field of the MPPE-Send-Key attribute,\n\
    \   and use the final 32 octets of the MSK as the \"Key\" sub-field in the\n \
    \  plaintext \"String\" field of the MPPE-Receive-Key attribute (Note:\n   \"\
    Send\" and \"Receive\" here refer to the Authenticator; for the peer,\n   they\
    \ are reversed).\n"
- title: Appendix D.  Key Strength Considerations
  contents:
  - 'Appendix D.  Key Strength Considerations

    '
- title: D.1.  Introduction
  contents:
  - "D.1.  Introduction\n   As described in Section 6, the strength of keys generated\
    \ in EAP-POTP\n   protected mode depends on a number of factors.  This appendix\n\
    \   provides examples of actual key strengths achieved under various\n   assumptions.\n\
    \   It should be noted that, while some of the examples indicate that the\n  \
    \ strength of generated keys is relatively weak, the strength applies\n   only\
    \ to those EAP-POTP sessions between a peer and an EAP server that\n   do not\
    \ share a pepper.  Once a pepper, provided by an EAP server to a\n   peer, has\
    \ been established, future sessions using this pepper will\n   provide full-strength\
    \ keys.\n"
- title: 'D.2.  Example 1: 6-Digit One-Time Passwords'
  contents:
  - "D.2.  Example 1: 6-Digit One-Time Passwords\n   In this example we assume the\
    \ following:\n      OTPs are six decimal digits long;\n      4-digit PINs are\
    \ added to generated OTPs; and\n      OTP hardening (iteration count and pepper\
    \ searching combined)\n      effectively adds 10 bits of entropy.  One way of\
    \ achieving this\n      without use of pepper searching is to have the iteration\
    \ count in\n      PBKDF2 set to 1,000,000.\n   The effective key strength then\
    \ becomes roughly:\n   log_2(10**6) + log_2(10**4) + log_2(2**10) = 43 bits\n\
    \   The above assumes that the entropy of the underlying shared secret is\n  \
    \ >43 bits and that there are no other weaknesses in the OTP algorithm.\n"
- title: 'D.3.  Example 2: 8-Digit One-Time Passwords'
  contents:
  - "D.3.  Example 2: 8-Digit One-Time Passwords\n   In this example we assume the\
    \ following:\n      OTPs are eight decimal digits long;\n      4-character alphanumeric\
    \ PINs are added to generated OTPs; and\n      OTP hardening (iteration count\
    \ and pepper searching combined)\n      effectively adds 10 bits of entropy.\n\
    \   The effective key strength then becomes roughly:\n   log_2(10**8) + log_2(26**4)\
    \ + log_2(2**10) = 55 bits\n   The above assumes that the entropy of the underlying\
    \ shared secret is\n   >55 bits and that there are no other weaknesses in the\
    \ OTP algorithm.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Magnus Nystroem\n   RSA Security\n   EMail: magnus@rsa.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
