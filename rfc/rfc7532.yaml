- title: __initial_text__
  contents:
  - '     Namespace Database (NSDB) Protocol for Federated File Systems

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes a file system federation protocol that\n\
    \   enables file access and namespace traversal across collections of\n   independently\
    \ administered fileservers.  The protocol specifies a set\n   of interfaces by\
    \ which fileservers with different administrators can\n   form a fileserver federation\
    \ that provides a namespace composed of\n   the file systems physically hosted\
    \ on and exported by the constituent\n   fileservers.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7532.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Requirements Language ......................................5\n  \
    \ 2. Overview of Features and Concepts ...............................5\n    \
    \  2.1. File-Access Protocol .......................................5\n      2.2.\
    \ File-Access Client .........................................5\n      2.3. Fileserver\
    \ .................................................5\n      2.4. Referral ...................................................5\n\
    \      2.5. Namespace ..................................................6\n  \
    \    2.6. Fileset ....................................................6\n    \
    \  2.7. Fileset Name (FSN) .........................................6\n      2.8.\
    \ Fileset Location (FSL) .....................................7\n           2.8.1.\
    \ The NFS URI Scheme ..................................8\n           2.8.2. Mutual\
    \ Consistency across Fileset Locations ........10\n           2.8.3. Caching of\
    \ Fileset Locations .......................11\n           2.8.4. Generating a\
    \ Referral from Fileset Locations .......12\n      2.9. Namespace Database (NSDB)\
    \ .................................13\n           2.9.1. NSDB Client ........................................14\n\
    \      2.10. Junctions and Referrals ..................................14\n  \
    \    2.11. Unified Namespace and the Root Fileset ...................15\n    \
    \  2.12. UUID Considerations ......................................15\n   3. Examples\
    \ .......................................................16\n      3.1. Creating\
    \ a Fileset and Its FSL(s) .........................16\n           3.1.1. Creating\
    \ a Fileset and an FSN ......................17\n           3.1.2. Adding a Replica\
    \ of a Fileset ......................17\n      3.2. Junction Resolution .......................................17\n\
    \      3.3. Example Use Cases for Fileset Annotations .................18\n  \
    \ 4. NSDB Configuration and Schema ..................................19\n    \
    \  4.1. LDAP Configuration ........................................19\n      4.2.\
    \ LDAP Schema ...............................................21\n           4.2.1.\
    \ LDAP Attributes ....................................23\n           4.2.2. LDAP\
    \ Object Classes ................................38\n   5. NSDB Operations ................................................42\n\
    \      5.1. NSDB Operations for Administrators ........................43\n  \
    \         5.1.1. Create an FSN ......................................43\n    \
    \       5.1.2. Delete an FSN ......................................44\n      \
    \     5.1.3. Create an FSL ......................................44\n        \
    \   5.1.4. Delete an FSL ......................................47\n          \
    \ 5.1.5. Update an FSL ......................................48\n      5.2. NSDB\
    \ Operations for Fileservers ...........................49\n           5.2.1.\
    \ NSDB Container Entry (NCE) Enumeration .............49\n           5.2.2. Lookup\
    \ FSLs for an FSN .............................49\n      5.3. NSDB Operations\
    \ and LDAP Referrals ........................50\n   6. Security Considerations\
    \ ........................................51\n   7. IANA Considerations ............................................52\n\
    \      7.1. Registry for the fedfsAnnotation Key Namespace ............52\n  \
    \    7.2. Registry for FedFS Object Identifiers .....................52\n    \
    \  7.3. LDAP Descriptor Registration ..............................55\n   8. Glossary\
    \ .......................................................58\n   9. References\
    \ .....................................................60\n      9.1. Normative\
    \ References ......................................60\n      9.2. Informative\
    \ References ....................................62\n   Acknowledgments ...................................................64\n\
    \   Authors' Addresses ................................................65\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   A federated file system enables file access and namespace\
    \ traversal\n   in a uniform, secure, and consistent manner across multiple\n\
    \   independent fileservers within an enterprise or across multiple\n   enterprises.\n\
    \   This document specifies a set of protocols that allow fileservers,\n   possibly\
    \ from different vendors and with different administrators, to\n   cooperatively\
    \ form a federation containing one or more federated file\n   systems.  Each federated\
    \ file system's namespace is composed of the\n   file systems physically hosted\
    \ on and exported by the federation's\n   fileservers.  A federation comprises\
    \ a common namespace across all\n   its fileservers.  A federation can project\
    \ multiple namespaces and\n   enable clients to traverse each one.  A federation\
    \ can contain an\n   arbitrary number of namespace repositories, each belonging\
    \ to a\n   different administrative entity and each rendering a part of the\n\
    \   namespace.  A federation might also have an arbitrary number of\n   administrative\
    \ entities responsible for administering disjoint\n   subsets of the fileservers.\n\
    \   Traditionally, building a namespace that spans multiple fileservers\n   has\
    \ been difficult for two reasons.  First, the fileservers that\n   export pieces\
    \ of the namespace are often not in the same\n   administrative domain.  Second,\
    \ there is no standard mechanism for\n   the fileservers to cooperatively present\
    \ the namespace.  Fileservers\n   may provide proprietary management tools, and\
    \ in some cases, an\n   administrator may be able to use the proprietary tools\
    \ to build a\n   shared namespace out of the exported file systems.  However,\
    \ relying\n   on vendor-specific proprietary tools does not work in larger\n \
    \  enterprises or when collaborating across enterprises because the\n   fileservers\
    \ are likely to be from multiple vendors or use different\n   software versions,\
    \ each with their own namespace protocols, with no\n   common mechanism to manage\
    \ the namespace or exchange namespace\n   information.\n   The federated file\
    \ system protocols in this document define how to\n   construct a namespace accessible\
    \ by a Network File System (NFS)\n   version 4.0 [RFC7530], NFSv4.1 [RFC5661],\
    \ or newer client and have\n   been designed to accommodate other file-access\
    \ protocols in the\n   future.\n   The requirements for federated file systems\
    \ are described in\n   [RFC5716].  A protocol for administering a fileserver's\
    \ namespace is\n   described in [RFC7533].  The mechanism for discovering the\
    \ root of a\n   federated namespace is described in [RFC6641].\n   In the rest\
    \ of the document, the term \"fileserver\" denotes a\n   fileserver that is part\
    \ of a federation.\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 2.  Overview of Features and Concepts
  contents:
  - '2.  Overview of Features and Concepts

    '
- title: 2.1.  File-Access Protocol
  contents:
  - "2.1.  File-Access Protocol\n   A file-access protocol is a network protocol for\
    \ accessing data.  The\n   NFSv4.0 protocol [RFC7530] is an example of a file-access\
    \ protocol.\n"
- title: 2.2.  File-Access Client
  contents:
  - "2.2.  File-Access Client\n   File-access clients are standard, off-the-shelf\
    \ network-attached\n   storage (NAS) clients that communicate with fileservers\
    \ using a\n   standard file-access protocol.\n"
- title: 2.3.  Fileserver
  contents:
  - "2.3.  Fileserver\n   Fileservers are servers that store physical fileset data\
    \ or refer\n   file-access clients to other fileservers.  A fileserver provides\n\
    \   access to its shared file system data via a file-access protocol.  A\n   fileserver\
    \ may be implemented in a number of different ways,\n   including a single system,\
    \ a cluster of systems, or some other\n   configuration.\n"
- title: 2.4.  Referral
  contents:
  - "2.4.  Referral\n   A referral is a mechanism by which a fileserver redirects\
    \ a file-\n   access client to a different fileserver or export.  The exact\n\
    \   information contained in a referral varies from one file-access\n   protocol\
    \ to another.  The NFSv4.0 protocol, for example, defines the\n   fs_locations\
    \ attribute for returning referral information to NFSv4.0\n   clients.  The NFSv4.1\
    \ protocol introduces the fs_locations_info\n   attribute that can return richer\
    \ referral information to its clients.\n   NFSv4.1 fileservers may use either\
    \ attribute during a referral.  Both\n   attributes are defined in [RFC5661].\n"
- title: 2.5.  Namespace
  contents:
  - "2.5.  Namespace\n   The goal of a unified namespace is to make all managed data\
    \ available\n   to any file-access client via the same path in a common file system\n\
    \   namespace.  This should be achieved with minimal or zero\n   configuration\
    \ on file-access clients.  In particular, updates to the\n   common namespace\
    \ should not require configuration changes to any\n   file-access client.\n  \
    \ Filesets, which are the units of data management, are a set of files\n   and\
    \ directories.  From the perspective of file-access clients, the\n   common namespace\
    \ is constructed by mounting filesets that are\n   physically located on different\
    \ fileservers.  The namespace, which is\n   defined in terms of fileset names\
    \ and locations, is stored in a set\n   of namespace repositories, each managed\
    \ by an administrative entity.\n   The namespace schema defines the model used\
    \ for populating,\n   modifying, and querying the namespace repositories.  It\
    \ is not\n   required by the federation that the namespace be common across all\n\
    \   fileservers.  It should be possible to have several independently\n   rooted\
    \ namespaces.\n"
- title: 2.6.  Fileset
  contents:
  - "2.6.  Fileset\n   A fileset is loosely defined as a set of files and the directory\
    \ tree\n   that contains them.  The fileset abstraction is the basic unit of\n\
    \   data management.  Depending on the configuration, a fileset may be\n   anything\
    \ from an individual directory of an exported file system to\n   an entire exported\
    \ file system on a fileserver.\n"
- title: 2.7.  Fileset Name (FSN)
  contents:
  - "2.7.  Fileset Name (FSN)\n   A fileset is uniquely represented by its fileset\
    \ name (FSN).  An FSN\n   is considered unique across a federation.  After an\
    \ FSN is created,\n   it is associated with one or more fileset locations (FSLs)\
    \ on one or\n   more fileservers.\n   An FSN consists of:\n      NsdbName:  the\
    \ network location of the Namespace Database (NSDB)\n         node that contains\
    \ authoritative information for this FSN.\n      FsnUuid:  a UUID (universally\
    \ unique identifier), conforming to\n         [RFC4122], that is used to uniquely\
    \ identify an FSN.\n      FsnTTL:  the time-to-live of the FSN's FSL information,\
    \ in\n         seconds.  Fileservers MUST NOT use cached FSL records after the\n\
    \         parent FSN's FsnTTL has expired.  An FsnTTL value of zero\n        \
    \ indicates that fileservers MUST NOT cache the results of\n         resolving\
    \ this FSN.\n   The NsdbName is not physically stored as an attribute of the record.\n\
    \   The NsdbName is obvious to any client that accesses an NSDB and is\n   indeed\
    \ authenticated in cases where Transport Layer Security (TLS) is\n   in effect.\n\
    \   The FsnUuid and NsdbName values never change during an FSN's\n   lifetime.\
    \  However, an FSN's FSL information can change over time and\n   is typically\
    \ cached on fileservers for performance.  More detail on\n   FSL caching is provided\
    \ in Section 2.8.3.\n   An FSN record may also contain:\n      Annotations:  name/value\
    \ pairs that can be interpreted by a\n         fileserver.  The semantics of this\
    \ field are not defined by\n         this document.  These tuples are intended\
    \ to be used by higher-\n         level protocols.\n      Descriptions:  text\
    \ descriptions.  The semantics of this field are\n         not defined by this\
    \ document.\n"
- title: 2.8.  Fileset Location (FSL)
  contents:
  - "2.8.  Fileset Location (FSL)\n   An FSL describes one physical location where\
    \ a complete copy of the\n   fileset's data resides.  An FSL contains generic\
    \ and type-specific\n   information that together describe how to access the fileset\
    \ data at\n   this location.  An FSL's attributes can be used by a fileserver\
    \ to\n   decide which locations it will return to a file-access client.\n   An\
    \ FSL consists of:\n      FslUuid:  a UUID, conforming to [RFC4122], that is used\
    \ to\n         uniquely identify an FSL.\n      FsnUuid:  the UUID of the FSL's\
    \ FSN.\n      NsdbName:  the network location of the NSDB node that contains\n\
    \         authoritative information for this FSL.\n   The NsdbName is not stored\
    \ as an attribute of an FSL record for the\n   same reason it is not stored in\
    \ FSN records.\n   An FSL record may also contain:\n      Annotations:  name/value\
    \ pairs that can be interpreted by a\n         fileserver.  The semantics of this\
    \ field are not defined by\n         this document.  These tuples are intended\
    \ to be used by higher-\n         level protocols.\n      Descriptions:  text\
    \ descriptions.  The semantics of this field are\n         not defined by this\
    \ document.\n   In addition to the attributes defined above, an FSL record contains\n\
    \   attributes that allow a fileserver to construct referrals.  For each\n   file-access\
    \ protocol, a corresponding FSL record subtype is defined.\n   This document defines\
    \ an FSL subtype for NFS.  An NFS FSL contains\n   information suitable for use\
    \ in one of the NFSv4 referral attributes\n   (e.g., fs_locations or fs_locations_info,\
    \ described in [RFC5661]).\n   Section 4.2.2.4 describes the contents of an NFS\
    \ FSL record.\n   A fileset may also be accessible by file-access protocols other\
    \ than\n   NFS.  The contents and format of such FSL subtypes are not defined\
    \ in\n   this document.\n"
- title: 2.8.1.  The NFS URI Scheme
  contents:
  - "2.8.1.  The NFS URI Scheme\n   To capture the location of an NFSv4 fileset, we\
    \ extend the NFS URL\n   scheme specified in [RFC2224].  This extension follows\
    \ rules for\n   defining Uniform Resource Identifier schemes (see [RFC3986]).\
    \  In the\n   following text, we refer to this extended NFS URL scheme as an NFS\n\
    \   URI.\n   An NFS URI MUST contain both an authority and a path component. \
    \ It\n   MUST NOT contain a query component or a fragment component.  Use of\n\
    \   the familiar \"nfs\" scheme name is retained.\n"
- title: 2.8.1.1.  The NFS URI Authority Component
  contents:
  - "2.8.1.1.  The NFS URI Authority Component\n   The rules for encoding the authority\
    \ component of a generic URI are\n   specified in section 3.2 of [RFC3986].  The\
    \ authority component of an\n   NFS URI MUST contain the host subcomponent.  For\
    \ globally scoped NFS\n   URIs, a hostname used in such URIs SHOULD be a fully\
    \ qualified domain\n   name.  See section 3.2.2 of [RFC3986] for rules on encoding\
    \ non-ASCII\n   characters in hostnames.\n   An NFS URI MAY contain a port subcomponent\
    \ as described in section\n   3.2.3 of [RFC3986].  If this subcomponent is missing,\
    \ a port value of\n   2049 is assumed, as specified in [RFC7530], Section 3.1.\n"
- title: 2.8.1.2.  The NFS URI Path Component
  contents:
  - "2.8.1.2.  The NFS URI Path Component\n   The rules for encoding the path component\
    \ of a generic URI are\n   specified in Section 3.3 of [RFC3986].\n   According\
    \ to Sections 5 and 6 of [RFC2224], NFS URLs specify a\n   pathname relative to\
    \ an NFS fileserver's public filehandle.  However,\n   NFSv4 fileservers do not\
    \ expose a public filehandle.  Instead, NFSv4\n   pathnames contained in an NFS\
    \ URI are evaluated relative to the\n   pseudoroot of the fileserver identified\
    \ in the URI's authority\n   component.\n   Each component of an NFSv4 pathname\
    \ is represented as a component4\n   string (see Section 3.2, \"Basic Data Types\"\
    , of [RFC5661]).  The\n   component4 elements of an NFSv4 pathname are encoded\
    \ as path segments\n   in an NFS URI.  NFSv4 pathnames MUST be expressed in an\
    \ NFS URI as an\n   absolute path.  An NFS URI path component MUST NOT be empty.\
    \  The NFS\n   URI path component starts with a slash (\"/\") character, followed\
    \ by\n   one or more path segments that each start with a slash (\"/\")\n   character\
    \ [RFC3986].\n   Therefore, a double slash always follows the authority component\
    \ of\n   an NFS URI.  For example, the NFSv4 pathname \"/\" is represented by\n\
    \   two slash (\"/\") characters following an NFS URI's authority\n   component.\n\
    \   The component names of an NFSv4 pathname MUST be prepared using the\n   component\
    \ name rules defined in Section 12 (\"Internationalization\")\n   of [RFC7530]\
    \ prior to encoding the path component of an NFS URI.  As\n   specified in [RFC3986],\
    \ any non-ASCII characters and any URI-reserved\n   characters, such as the slash\
    \ (\"/\") character, contained in a\n   component4 element MUST be represented\
    \ by URI percent encoding.\n"
- title: 2.8.1.3.  Encoding an NFS Location in an FSL
  contents:
  - "2.8.1.3.  Encoding an NFS Location in an FSL\n   The path component of an NFS\
    \ URI encodes the rootpath field of the\n   NFSv4 fs_location4 data type or the\
    \ \"fli_rootpath\" of the NFSv4\n   fs_locations_item4 data type (see [RFC5661]).\n\
    \   In its server field, the NFSv4 fs_location4 data type contains a list\n  \
    \ of universal addresses and DNS labels.  Each may optionally include a\n   port\
    \ number.  The exact encoding requirements for this information is\n   found in\
    \ Section 12.6 of [RFC7530].  The NFSv4 fs_locations_item4\n   data type encodes\
    \ the same data in its fli_entries field (see\n   [RFC5661]).  This information\
    \ is encoded in the authority component\n   of an NFS URI.\n   The server and\
    \ fli_entries fields can encode multiple server\n   hostnames that share the same\
    \ pathname.  An NFS URI, and hence an FSL\n   record, represents only a single\
    \ hostname and pathname pair.  An NFS\n   fileserver MUST NOT combine a set of\
    \ FSL records into a single\n   fs_location4 or fs_locations_item4 unless each\
    \ FSL record in the set\n   contains the same rootpath value and extended file\
    \ system\n   information.\n"
- title: 2.8.2.  Mutual Consistency across Fileset Locations
  contents:
  - "2.8.2.  Mutual Consistency across Fileset Locations\n   All of the FSLs that\
    \ have the same FSN (and thereby reference the\n   same fileset) are equivalent\
    \ from the point of view of access by a\n   file-access client.  Different fileset\
    \ locations for an FSN represent\n   the same data, though potentially at different\
    \ points in time.\n   Fileset locations are equivalent but not identical.  Locations\
    \ may be\n   either read-only or read-write.  Typically, multiple read-write\n\
    \   locations are backed by a clustered file system while read-only\n   locations\
    \ are replicas created by a federation-initiated or external\n   replication operation.\
    \  Read-only locations may represent consistent\n   point-in-time copies of a\
    \ read-write location.  The federation\n   protocols, however, cannot prevent\
    \ subsequent changes to a read-only\n   location nor guarantee point-in-time consistency\
    \ of a read-only\n   location if the read-write location is changing.\n   Regardless\
    \ of the type, one file-access client may be referred to a\n   location described\
    \ by one FSL while another client chooses to use a\n   location described by another\
    \ FSL.  Since updates to each fileset\n   location are not controlled by the federation\
    \ protocol, it is the\n   responsibility of administrators to guarantee the functional\n\
    \   equivalence of the data.\n   The federation protocols do not guarantee that\
    \ different fileset\n   locations are mutually consistent in terms of the currency\
    \ of their\n   data.  However, they provide a means to publish currency information\n\
    \   so that all fileservers in a federation can convey the same\n   information\
    \ to file-access clients during referrals.  Clients use\n   this information to\
    \ ensure they do not revert to an out-of-date\n   version of a fileset's data\
    \ when switching between fileset locations.\n   NFSv4.1 provides guidance on how\
    \ replication can be handled in such a\n   manner.  In particular, see Section\
    \ 11.7 of [RFC5661].\n"
- title: 2.8.3.  Caching of Fileset Locations
  contents:
  - "2.8.3.  Caching of Fileset Locations\n   To resolve an FSN to a set of FSL records,\
    \ a fileserver queries the\n   NSDB node named in the FSN for FSL records associated\
    \ with this FSN.\n   The parent FSN's FsnTTL attribute (see Section 2.7) specifies\
    \ the\n   period of time during which a fileserver may cache these FSL records.\n\
    \   The combination of FSL caching and FSL migration presents a\n   challenge.\
    \  For example, suppose there are three fileservers named A,\n   B, and C.  Suppose\
    \ further that fileserver A contains a junction J to\n   fileset X stored on fileserver\
    \ B (see Section 2.10 for a description\n   of junctions).\n   Now suppose that\
    \ fileset X is migrated from fileserver B to\n   fileserver C, and the corresponding\
    \ FSL information for fileset X in\n   the authoritative NSDB is updated.\n  \
    \ If fileserver A has cached FSLs for fileset X, a file-access client\n   traversing\
    \ junction J on fileserver A will be referred to fileserver\n   B, even though\
    \ fileset X has migrated to fileserver C.  If fileserver\n   A had not cached\
    \ the FSL records, it would have queried the NSDB and\n   obtained the correct\
    \ location of fileset X.\n   Typically, the process of fileset migration leaves\
    \ a redirection on\n   the source fileserver in place of a migrated fileset (without\
    \ such a\n   redirection, file-access clients would find an empty space where\
    \ the\n   migrated fileset was, which defeats the purpose of a managed\n   migration).\n\
    \   This redirection might be a new junction that targets the same FSN as\n  \
    \ other junctions referring to the migrated fileset, or it might be\n   some other\
    \ kind of directive, depending on the fileserver\n   implementation, that simply\
    \ refers file-access clients to the new\n   location of the migrated fileset.\n\
    \   Back to our example.  Suppose, as part of the migration process, a\n   junction\
    \ replaces fileset X on fileserver B.  Later, either:\n   o  New file-access clients\
    \ are referred to fileserver B by stale FSL\n      information cached on fileserver\
    \ A, or\n   o  File-access clients continue to access fileserver B because they\n\
    \      cache stale location data for fileset X.\n   In either case, thanks to\
    \ the redirection, file-access clients are\n   informed by fileserver B that fileset\
    \ X has moved to fileserver C.\n   Such redirecting junctions (here, on fileserver\
    \ B) would not be\n   required to be in place forever.  They need to stay in place\
    \ at least\n   until FSL entries cached on fileservers and locations cached on\
    \ file-\n   access clients for the target fileset are invalidated.\n   The FsnTTL\
    \ field in the FSL's parent FSN (see Section 2.7) specifies\n   an upper bound\
    \ for the lifetime of cached FSL information and thus\n   can act as a lower bound\
    \ for the lifetime of redirecting junctions.\n   For example, suppose the FsnTTL\
    \ field contains the value 3600 seconds\n   (one hour).  In such a case, administrators\
    \ SHOULD keep the\n   redirection in place for at least one hour after a fileset\
    \ migration\n   has taken place because a referring fileserver might cache the\
    \ FSL\n   data during that time before refreshing it.\n   To get file-access clients\
    \ to access the destination fileserver more\n   quickly, administrators SHOULD\
    \ set the FsnTTL field of the migrated\n   fileset to a low number or zero before\
    \ migration begins.  It can be\n   reset to a more reasonable number at a later\
    \ point.\n   Note that some file-access protocols do not communicate location\n\
    \   cache expiry information to file-access clients.  In some cases, it\n   may\
    \ be difficult to determine an appropriate lifetime for redirecting\n   junctions\
    \ because file-access clients may cache location information\n   indefinitely.\n"
- title: 2.8.4.  Generating a Referral from Fileset Locations
  contents:
  - "2.8.4.  Generating a Referral from Fileset Locations\n   After resolving an FSN\
    \ to a set of FSL records, the fileserver\n   generates a referral to redirect\
    \ a file-access client to one or more\n   of the FSN's FSLs.  The fileserver converts\
    \ the FSL records to a\n   referral format understood by a particular file-access\
    \ client, such\n   as an NFSv4 fs_locations or fs_locations_info attribute.\n\
    \   To give file-access clients as many options as possible, the\n   fileserver\
    \ SHOULD include the maximum possible number of FSL records\n   in a referral.\
    \  However, the fileserver MAY omit some of the FSL\n   records from the referral.\
    \  For example, the fileserver might omit an\n   FSL record because of limitations\
    \ in the file-access protocol's\n   referral format.\n   For a given FSL record,\
    \ the fileserver MAY convert or reduce the FSL\n   record's contents in a manner\
    \ appropriate to the referral format.\n   For example, an NFS FSL record contains\
    \ all the data necessary to\n   construct an fs_locations_info attribute, but\
    \ an fs_locations_info\n   attribute contains several pieces of information that\
    \ are not found\n   in the simpler fs_locations attribute.  A fileserver constructs\n\
    \   entries in an fs_locations attribute using the relevant contents of\n   an\
    \ NFS FSL record.\n   Whenever the fileserver converts or reduces FSL data, the\
    \ fileserver\n   SHOULD attempt to maintain the original meaning where possible.\
    \  For\n   example, an NFS FSL record contains the rank and order information\n\
    \   that is included in an fs_locations_info attribute (see NFSv4.1's\n   FSLI4BX_READRANK,\
    \ FSLI4BX_READORDER, FSLI4BX_WRITERANK, and\n   FSLI4BX_WRITEORDER).  While this\
    \ rank and order information is not\n   explicitly expressible in an fs_locations\
    \ attribute, the fileserver\n   can arrange the fs_locations attribute's locations\
    \ list based on the\n   rank and order values.\n   Another example: A single NFS\
    \ FSL record contains the hostname of one\n   fileserver.  A single fs_locations\
    \ attribute can contain a list of\n   fileserver names.  An NFS fileserver MAY\
    \ combine two or more FSL\n   records into a single entry in an fs_locations or\
    \ fs_locations_info\n   array only if each FSL record contains the same pathname\
    \ and extended\n   file system information.\n   Refer to Sections 11.9 and 11.10\
    \ of the NFSv4.1 protocol\n   specification [RFC5661] for further details.\n"
- title: 2.9.  Namespace Database (NSDB)
  contents:
  - "2.9.  Namespace Database (NSDB)\n   The NSDB service is a federation-wide service\
    \ that provides\n   interfaces to define, update, and query FSN information, FSL\n\
    \   information, and FSN-to-FSL mapping information.\n   An individual repository\
    \ of namespace information is called an NSDB\n   node.  The difference between\
    \ the NSDB service and an NSDB node is\n   analogous to that between the DNS service\
    \ and a particular DNS\n   server.\n   Each NSDB node is managed by a single administrative\
    \ entity.  A\n   single administrative entity can manage multiple NSDB nodes.\n\
    \   Each NSDB node stores the definition of the FSNs for which it is\n   authoritative.\
    \  It also stores the definitions of the FSLs associated\n   with those FSNs.\
    \  An NSDB node is authoritative for the filesets that\n   it defines.\n   An\
    \ NSDB MAY be replicated throughout the federation.  If an NSDB is\n   replicated,\
    \ the NSDB MUST exhibit loose, converging consistency as\n   defined in [RFC3254].\
    \  The mechanism by which this is achieved is\n   outside the scope of this document.\
    \  Many Lightweight Directory\n   Access Protocol (LDAP) implementations support\
    \ replication.  These\n   features MAY be used to replicate the NSDB.\n"
- title: 2.9.1.  NSDB Client
  contents:
  - "2.9.1.  NSDB Client\n   Each NSDB node supports an LDAP [RFC4510] interface.\
    \  An NSDB client\n   is software that uses the LDAP protocol to access or update\
    \ namespace\n   information stored on an NSDB node.\n   A domain's administrative\
    \ entity uses NSDB client software to manage\n   information stored on NSDB nodes.\
    \  Details of these transactions are\n   discussed in Section 5.1.\n   Fileservers\
    \ act as an NSDB client when contacting a particular NSDB\n   node to resolve\
    \ an FSN to a set of FSL records.  The resulting\n   location information is then\
    \ transferred to file-access clients via\n   referrals.  Therefore, file-access\
    \ clients never need to access NSDBs\n   directly.  These transactions are described\
    \ in Section 5.2.\n"
- title: 2.10.  Junctions and Referrals
  contents:
  - "2.10.  Junctions and Referrals\n   A junction is a point in a particular fileset\
    \ namespace where a\n   specific target fileset may be attached.  If a file-access\
    \ client\n   traverses the path leading from the root of a federated namespace\
    \ to\n   the junction referring to a target fileset, it should be able to\n  \
    \ mount and access the data in that target fileset (assuming\n   appropriate permissions).\
    \  In other words, a junction can be viewed\n   as a reference from a directory\
    \ in one fileset to the root of the\n   target fileset.\n   A junction can be\
    \ implemented as a special marker on a directory or\n   by some other mechanism\
    \ in the fileserver's underlying file system.\n   What data is used by the fileserver\
    \ to represent junctions is not\n   defined by this document.  The essential property\
    \ is that given a\n   junction, a fileserver must be able to find the FSN for\
    \ the target\n   fileset.\n   When a file-access client reaches a junction, the\
    \ fileserver refers\n   the client to a list of FSLs associated with the FSN targeted\
    \ by the\n   junction.  The client can then mount one of the associated FSLs.\n\
    \   The federation protocols do not limit where and how many times a\n   fileset\
    \ is mounted in the namespace.  Filesets can be nested; a\n   fileset can be mounted\
    \ under another fileset.\n"
- title: 2.11.  Unified Namespace and the Root Fileset
  contents:
  - "2.11.  Unified Namespace and the Root Fileset\n   The root fileset, when defined,\
    \ is the top-level fileset of the\n   federation-wide namespace.  The root of\
    \ the unified namespace is the\n   top level directory of this fileset.  A set\
    \ of designated fileservers\n   in the federation can export the root fileset\
    \ to render the\n   federation-wide unified namespace.  When a file-access client\
    \ mounts\n   the root fileset from any of these designated fileservers, it can\n\
    \   view a common federation-wide namespace.\n"
- title: 2.12.  UUID Considerations
  contents:
  - "2.12.  UUID Considerations\n   To ensure FSN and FSL records are unique across\
    \ a domain, Federated\n   File System (FedFS) employs UUIDs conforming to [RFC4122]\
    \ to form the\n   distinguished names of LDAP records containing FedFS data (see\n\
    \   Section 4.2.2.2).\n   Because junctions store a tuple containing an FSN UUID\
    \ and the name\n   and port of an NSDB node, an FSN UUID must be unique only on\
    \ a single\n   NSDB node.  An FSN UUID collision can be detected immediately when\
    \ an\n   administrator attempts to publish an FSN or FSL by storing it under a\n\
    \   specific NSDB Container Entry (NCE) on an authoritative NSDB host.\n   Note\
    \ that one NSDB node may store multiple NCEs, each under a\n   different namingContext.\
    \  If an NSDB node must contain more than one\n   NCE, the federation's admin\
    \ entity SHOULD provide a robust method for\n   preventing FSN UUID collisions\
    \ between FSNs that reside on the same\n   NSDB node but under different NCEs.\n\
    \   Because FSLs are children of FSNs, FSL UUIDs must be unique for just\n   a\
    \ single FSN.  As with FSNs, as soon as an FSL is published, its\n   uniqueness\
    \ is guaranteed.\n   A fileserver performs the operations described in Section\
    \ 5.2 as an\n   unauthenticated user.  Thus, distinguished names of FSN and FSL\n\
    \   records, as well as the FSN and FSL records themselves, are required\n   to\
    \ be readable by anyone who can bind anonymously to an NSDB node.\n   Therefore,\
    \ FSN and FSL UUIDs should be considered public information.\n   Version 1 UUIDs\
    \ contain a host's Media Access Control (MAC) address\n   and a timestamp in the\
    \ clear.  This gives provenance to each UUID,\n   but attackers can use such details\
    \ to guess information about the\n   host where the UUID was generated.  Security-sensitive\
    \ installations\n   should be aware that on externally facing NSDBs, UUIDs can\
    \ reveal\n   information about the hosts where they are generated.\n   In addition,\
    \ version 1 UUIDs depend on the notion that a hardware MAC\n   address is unique\
    \ across machines.  As virtual machines do not depend\n   on unique physical MAC\
    \ addresses and, in any event, an administrator\n   can modify the physical MAC\
    \ address, version 1 UUIDs are no longer\n   considered sufficient.\n   To minimize\
    \ the probability of UUIDs colliding, a consistent\n   procedure for generating\
    \ UUIDs should be used throughout a\n   federation.  Within a federation, UUIDs\
    \ SHOULD be generated using the\n   procedure described for version 4 of the UUID\
    \ variant specified in\n   [RFC4122].\n"
- title: 3.  Examples
  contents:
  - "3.  Examples\n   In this section we provide examples and discussion of the basic\n\
    \   operations facilitated by the federated file system protocol:\n   creating\
    \ a fileset, adding a replica of a fileset, resolving a\n   junction, and creating\
    \ a junction.\n"
- title: 3.1.  Creating a Fileset and Its FSL(s)
  contents:
  - "3.1.  Creating a Fileset and Its FSL(s)\n   A fileset is the abstraction of a\
    \ set of files and the directory tree\n   that contains them.  The fileset abstraction\
    \ is the fundamental unit\n   of data management in the federation.  This abstraction\
    \ is\n   implemented by an actual directory tree whose root location is\n   specified\
    \ by a fileset location (FSL).\n   In this section, we describe the basic requirements\
    \ for starting with\n   a directory tree and creating a fileset that can be used\
    \ in the\n   federation protocols.  Note that we do not assume that the process\
    \ of\n   creating a fileset requires any transformation of the files or the\n\
    \   directory hierarchy.  The only thing that is required by this process\n  \
    \ is assigning the fileset a fileset name (FSN) and expressing the\n   location\
    \ of the implementation of the fileset as an FSL.\n   There are many possible\
    \ variations to this procedure, depending on\n   how the FSN that binds the FSL\
    \ is created and whether other replicas\n   of the fileset exist, are known to\
    \ the federation, and need to be\n   bound to the same FSN.\n   It is easiest\
    \ to describe this in terms of how to create the initial\n   implementation of\
    \ the fileset and then describe how to add replicas.\n"
- title: 3.1.1.  Creating a Fileset and an FSN
  contents:
  - "3.1.1.  Creating a Fileset and an FSN\n   The following administrative steps\
    \ create an FSN, which is used to\n   track all replicas of a single physical\
    \ dataset.\n   1.  Choose the NSDB node that will keep track of the FSL(s) and\n\
    \       related information for the fileset.\n   2.  Create an FSN in the NSDB\
    \ node.\n       The FSN UUID is chosen by the administrator or generated\n   \
    \    automatically by administration software.  The former case is\n       used\
    \ if the fileset is being restored, perhaps as part of\n       disaster recovery,\
    \ and the administrator wishes to specify the\n       FSN UUID in order to permit\
    \ existing junctions that reference\n       that FSN to work again.\n       At\
    \ this point, the FSN exists, but its fileset locations are\n       unspecified.\n\
    \   3.  For the FSN created above, create an FSL in the NSDB node that\n     \
    \  describes the physical location of the fileset data.\n"
- title: 3.1.2.  Adding a Replica of a Fileset
  contents:
  - "3.1.2.  Adding a Replica of a Fileset\n   Adding a replica is straightforward:\
    \ the NSDB node and the FSN are\n   already known.  The only remaining step is\
    \ to add another FSL.\n   Note that the federation protocols provide only the\
    \ mechanisms to\n   register and unregister replicas of a fileset.  Fileserver-to-\n\
    \   fileserver replication protocols are not defined.\n"
- title: 3.2.  Junction Resolution
  contents:
  - "3.2.  Junction Resolution\n   A fileset may contain references to other filesets.\
    \  These references\n   are represented by junctions.  If a file-access client\
    \ requests\n   access to a fileset object that is a junction, the fileserver\n\
    \   resolves the junction to discover one or more FSLs that implement the\n  \
    \ referenced fileset.\n   There are many possible variations to this procedure,\
    \ depending on\n   how the junctions are represented by the fileserver and how\
    \ the\n   fileserver performs junction resolution.\n   Step 4 is the only step\
    \ that interacts directly with the federation\n   protocols.  The rest of the\
    \ steps may use platform-specific\n   interfaces.\n   1.  The fileserver determines\
    \ that the object being accessed is a\n       junction.\n   2.  The fileserver\
    \ does a local lookup to find the FSN of the target\n       fileset.\n   3.  Using\
    \ the FSN, the fileserver finds the NSDB node responsible for\n       the target\
    \ FSN.\n   4.  The fileserver contacts that NSDB node and asks for the set of\n\
    \       FSLs that implement the target FSN.  The NSDB node responds with\n   \
    \    a (possibly empty) set of FSLs.\n   5.  The fileserver converts one or more\
    \ of the FSLs to the location\n       type used by the file-access client (e.g.,\
    \ an NFSv4 fs_locations\n       attribute as described in [RFC5661]).\n   6. \
    \ The fileserver redirects (in whatever manner is appropriate for\n       the\
    \ client) the client to the location(s).\n"
- title: 3.3.  Example Use Cases for Fileset Annotations
  contents:
  - "3.3.  Example Use Cases for Fileset Annotations\n   Fileset annotations can convey\
    \ additional attributes of a fileset.\n   For example, fileset annotations can\
    \ be used to define relationships\n   between filesets that can be used by an\
    \ auxiliary replication\n   protocol.  Consider the scenario where a fileset is\
    \ created and\n   mounted at some point in the namespace.  A snapshot of the read-write\n\
    \   FSL of that fileset is taken periodically at different frequencies\n   (say,\
    \ a daily or weekly snapshot).  The different snapshots are\n   mounted at different\
    \ locations in the namespace.\n   The daily snapshots are considered as different\
    \ filesets from the\n   weekly ones, but both are related to the source fileset.\
    \  We can\n   define an annotation labeling the filesets as source and replica.\n\
    \   The replication protocol can use this information to copy data from\n   one\
    \ or more FSLs of the source fileset to all the FSLs of the replica\n   fileset.\
    \  The replica filesets are read-only while the source fileset\n   is read-write.\n\
    \   This follows the traditional Andrew File System (AFS) model of\n   mounting\
    \ the read-only volume at a path in the namespace different\n   from that of the\
    \ read-write volume [AFS].\n   The federation protocol does not control or manage\
    \ the relationship\n   among filesets.  It merely enables annotating the filesets\
    \ with user-\n   defined relationships.\n   Another potential use for annotations\
    \ is recording references to an\n   FSN.  A single annotation containing the number\
    \ of references could\n   be defined, or multiple annotations, one per reference,\
    \ could be used\n   to store detailed information on the location of each reference.\n\
    \   As with the replication annotation described above, the maintenance\n   of\
    \ reference information would not be controlled by the federation\n   protocol.\
    \  The information would most likely be non-authoritative\n   because the ability\
    \ to create a junction does not require the\n   authority to update the FSN record.\
    \  In any event, such annotations\n   could be useful to administrators for determining\
    \ if an FSN is\n   referenced by a junction.\n"
- title: 4.  NSDB Configuration and Schema
  contents:
  - "4.  NSDB Configuration and Schema\n   This section describes how an NSDB is constructed\
    \ using an LDAP\n   Version 3 [RFC4510] directory.  Section 4.1 describes the\
    \ basic\n   properties of the LDAP configuration that MUST be used in order to\n\
    \   ensure compatibility between different implementations.  Section 4.2\n   defines\
    \ the new LDAP attribute types and the new object types; it\n   also specifies\
    \ how the distinguished name (DN) of each object\n   instance MUST be constructed.\n"
- title: 4.1.  LDAP Configuration
  contents:
  - "4.1.  LDAP Configuration\n   An NSDB is constructed using an LDAP directory.\
    \  This LDAP directory\n   MAY have multiple naming contexts.  The LDAP directory's\
    \ entry\n   specific to Digital Signature Algorithm (DSA) (its rootDSE) has a\n\
    \   multi-valued namingContext attribute.  Each value of the\n   namingContext\
    \ attribute is the DN of a naming context's root entry\n   (see [RFC4512]).\n\
    \   For each naming context that contains federation entries (e.g., FSNs\n   and\
    \ FSLs):\n   1.  There MUST be an LDAP entry that is superior to all of the naming\n\
    \       context's federation entries in the Directory Information Tree\n     \
    \  (DIT).  This entry is termed the NSDB Container Entry (NCE).  The\n       NCE's\
    \ children are FSNs.  An FSN's children are FSLs.\n   2.  The naming context's\
    \ root entry MUST include\n       \"fedfsNsdbContainerInfo\" (defined in Section\
    \ 4.2.2.1) as one of\n       its object classes.  The fedfsNsdbContainerInfo's\
    \ fedfsNceDN\n       attribute is used to locate the naming context's NCE.\n \
    \  If a naming context does not contain federation entries, it will not\n   contain\
    \ an NCE, and its root entry will not include a\n   \"fedfsNsdbContainerInfo\"\
    \ as one of its object classes.\n   A fedfsNsdbContainerInfo's fedfsNceDN attribute\
    \ contains the\n   distinguished name (DN) of the NSDB Container Entry residing\
    \ under\n   this naming context.  The fedfsNceDN attribute MUST NOT be empty.\n\
    \   For example, an LDAP directory might have the following entries:\n       \
    \    -+ [root DSE]\n            |  namingContext: o=fedfs\n            |  namingContext:\
    \ dc=example,dc=com\n            |  namingContext: ou=system\n            |\n\
    \            |\n            +---- [o=fedfs]\n            |      fedfsNceDN: o=fedfs\n\
    \            |\n            |\n            +---- [dc=example,dc=com]\n       \
    \     |      fedfsNceDN: ou=fedfs,ou=corp-it,dc=example,dc=com\n            |\n\
    \            |\n            +---- [ou=system]\n   In this case, the \"o=fedfs\"\
    \ namingContext has an NSDB Container Entry\n   at \"o=fedfs\", the \"dc=example,dc=com\"\
    \ namingContext has an NSDB\n   Container Entry at \"ou=fedfs,ou=corp-it,dc=example,dc=com\"\
    , and the\n   \"ou=system\" namingContext has no NSDB Container Entry.\n   The\
    \ NSDB SHOULD be configured with one or more privileged LDAP users.\n   These\
    \ users are able to modify the contents of the LDAP database.  An\n   administrator\
    \ that performs the operations described in Section 5.1\n   SHOULD authenticate\
    \ using the DN of a privileged LDAP user.\n   It MUST be possible for an unprivileged\
    \ (unauthenticated) user to\n   perform LDAP queries that access the NSDB data.\
    \  A fileserver\n   performs the operations described in Section 5.2 as an unprivileged\n\
    \   user.\n   All implementations SHOULD use the same schema.  At minimum, each\n\
    \   MUST use a schema that includes all objects named in the following\n   sections,\
    \ with all associated attributes.  If it is necessary for an\n   implementation\
    \ to extend the schema defined here, consider using one\n   of the following ways\
    \ to extend the schema:\n   o  Define a fedfsAnnotation key and values (see Section\
    \ 4.2.1.6).\n      Register the new key and values with IANA (see Section 7.1).\n\
    \   o  Define additional attribute types and object classes, then have\n     \
    \ entries inherit from a class defined in this document and from the\n      implementation-defined\
    \ ones.\n   Given the above configuration guidelines, an NSDB SHOULD be\n   constructed\
    \ using a dedicated LDAP server.  If LDAP directories are\n   needed for other\
    \ purposes, such as to store user account information,\n   use of a separate LDAP\
    \ server for those is RECOMMENDED.  By using an\n   LDAP server dedicated to storing\
    \ NSDB records, there is no need to\n   disturb the configuration of any other\
    \ LDAP directories that store\n   information unrelated to an NSDB.\n"
- title: 4.2.  LDAP Schema
  contents:
  - "4.2.  LDAP Schema\n   The schema definitions provided in this document use the\
    \ LDAP schema\n   syntax defined in [RFC4512].  The definitions are formatted\
    \ to allow\n   the reader to easily extract them from the document.  The reader\
    \ can\n   use the following shell script to extract the definitions:\n       \
    \    <CODE BEGINS>\n           #!/bin/sh\n           grep '^ *///' | sed 's?^\
    \ */// ??' | sed 's?^ *///$??'\n           <CODE ENDS>\n   If the above script\
    \ is stored in a file called \"extract.sh\", and this\n   document is in a file\
    \ called \"spec.txt\", then the reader can do:\n           <CODE BEGINS>\n   \
    \        sh extract.sh < spec.txt > fedfs.schema\n           <CODE ENDS>\n   The\
    \ effect of the script is to remove leading white space from each\n   line, plus\
    \ a sentinel sequence of \"///\".\n   Code components extracted from this document\
    \ must include the\n   following license:\n   <CODE BEGINS>\n     /// #\n    \
    \ /// # Copyright (c) 2015 IETF Trust and the persons identified\n     /// # as\
    \ authors of the code.  All rights reserved.\n     /// #\n     /// # The authors\
    \ of the code are:\n     /// # J. Lentini, C. Everhart, D. Ellard, R. Tewari,\
    \ and M. Naik.\n     /// #\n     /// # Redistribution and use in source and binary\
    \ forms, with\n     /// # or without modification, are permitted provided that\
    \ the\n     /// # following conditions are met:\n     /// #\n     /// # - Redistributions\
    \ of source code must retain the above\n     /// #   copyright notice, this list\
    \ of conditions and the\n     /// #   following disclaimer.\n     /// #\n    \
    \ /// # - Redistributions in binary form must reproduce the above\n     /// #\
    \   copyright notice, this list of conditions and the\n     /// #   following\
    \ disclaimer in the documentation and/or other\n     /// #   materials provided\
    \ with the distribution.\n     /// #\n     /// # - Neither the name of Internet\
    \ Society, IETF or IETF\n     /// #   Trust, nor the names of specific contributors,\
    \ may be\n     /// #   used to endorse or promote products derived from this\n\
    \     /// #   software without specific prior written permission.\n     /// #\n\
    \     /// #   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n     /// # \
    \  AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED\n     /// #   WARRANTIES,\
    \ INCLUDING, BUT NOT LIMITED TO, THE\n     /// #   IMPLIED WARRANTIES OF MERCHANTABILITY\
    \ AND FITNESS\n     /// #   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n\
    \     /// #   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n     /// # \
    \  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n     /// #   EXEMPLARY,\
    \ OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n     /// #   NOT LIMITED TO, PROCUREMENT\
    \ OF SUBSTITUTE GOODS OR\n     /// #   SERVICES; LOSS OF USE, DATA, OR PROFITS;\
    \ OR BUSINESS\n     /// #   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n\
    \     /// #   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n     /// #  \
    \ OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n     /// #   IN ANY WAY\
    \ OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n     /// #   ADVISED OF THE POSSIBILITY\
    \ OF SUCH DAMAGE.\n     /// #\n   <CODE ENDS>\n"
- title: 4.2.1.  LDAP Attributes
  contents:
  - "4.2.1.  LDAP Attributes\n   The following definitions are used in this document:\n\
    \   o  The name attribute described in [RFC4519].\n   o  The Integer syntax (1.3.6.1.4.1.1466.115.121.1.27)\
    \ described in\n      [RFC4517].\n   o  The integerMatch rule described in [RFC4517].\n\
    \   o  The Octet String syntax (1.3.6.1.4.1.1466.115.121.1.40) described\n   \
    \   in [RFC4517].\n   o  The octetStringMatch rule described in [RFC4517].\n \
    \  o  The Boolean syntax (1.3.6.1.4.1.1466.115.121.1.7) described in\n      [RFC4517].\n\
    \   o  The booleanMatch rule described in [RFC4517].\n   o  The distinguishedNameMatch\
    \ rule described in [RFC4517].\n   o  The DN syntax (1.3.6.1.4.1.1466.115.121.1.12)\
    \ described in\n      [RFC4517].\n   o  The labeledURI attribute described in\
    \ [RFC2079].\n   o  The UUID syntax (1.3.6.1.1.16.1) described in [RFC4530].\n\
    \   o  The UuidMatch rule described in [RFC4530].\n   o  The UuidOrderingMatch\
    \ rule described in [RFC4530].\n"
- title: 4.2.1.1.  fedfsUuid
  contents:
  - "4.2.1.1.  fedfsUuid\n   A fedfsUuid is the base type for all of the universally\
    \ unique\n   identifiers (UUIDs) used by the federated file system protocols.\n\
    \   The fedfsUuid type is based on rules and syntax defined in [RFC4530].\n  \
    \ A fedfsUuid is a single-valued LDAP attribute.\n   <CODE BEGINS>\n         \
    \  ///\n           /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.1\
    \ NAME 'fedfsUuid'\n           ///     DESC 'A UUID used by NSDB'\n          \
    \ ///     EQUALITY uuidMatch\n           ///     ORDERING uuidOrderingMatch\n\
    \           ///     SYNTAX 1.3.6.1.1.16.1\n           ///     SINGLE-VALUE\n \
    \          ///     )\n           ///\n   <CODE ENDS>\n"
- title: 4.2.1.2.  fedfsFsnUuid
  contents:
  - "4.2.1.2.  fedfsFsnUuid\n   A fedfsFsnUuid represents the UUID component of an\
    \ FSN.  An NSDB\n   SHOULD ensure that no two FSNs it stores have the same fedfsFsnUuid.\n\
    \   This attribute is single-valued.\n   <CODE BEGINS>\n           ///\n     \
    \      /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.4 NAME 'fedfsFsnUuid'\n\
    \           ///     DESC 'The FSN UUID component of an FSN'\n           ///  \
    \   SUP fedfsUuid\n           ///     SINGLE-VALUE\n           ///     )\n   \
    \        ///\n   <CODE ENDS>\n"
- title: 4.2.1.3.  fedfsFsnTTL
  contents:
  - "4.2.1.3.  fedfsFsnTTL\n   A fedfsFsnTTL is the time-to-live in seconds of a cached\
    \ FSN and its\n   child FSL records.  It corresponds to the FsnTTL as defined\
    \ in\n   Section 2.7.  See also Section 2.8.3 for information about caching\n\
    \   FSLs.  A fedfsFsnTTL MUST be encoded as an Integer syntax value\n   [RFC4517]\
    \ in the range [0, 4294967295].\n   This attribute is single-valued.\n   <CODE\
    \ BEGINS>\n           ///\n           /// attributetype (\n           ///    \
    \ 1.3.6.1.4.1.31103.1.11 NAME 'fedfsFsnTTL'\n           ///     DESC 'Time to\
    \ live of an FSN tree'\n           ///     EQUALITY integerMatch\n           ///\
    \     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27\n           ///     SINGLE-VALUE\n\
    \           ///     )\n           ///\n   <CODE ENDS>\n   OID 1.3.6.1.4.1.1466.115.121.1.27\
    \ is the Integer syntax [RFC4517].\n"
- title: 4.2.1.4.  fedfsNceDN
  contents:
  - "4.2.1.4.  fedfsNceDN\n   A fedfsNceDN stores a distinguished name (DN).\n   This\
    \ attribute is single-valued.\n   <CODE BEGINS>\n           ///\n           ///\
    \ attributetype (\n           ///     1.3.6.1.4.1.31103.1.14 NAME 'fedfsNceDN'\n\
    \           ///     DESC 'NCE Distinguished Name'\n           ///     EQUALITY\
    \ distinguishedNameMatch\n           ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.12\n\
    \           ///     SINGLE-VALUE\n           ///     )\n           ///\n   <CODE\
    \ ENDS>\n   OID 1.3.6.1.4.1.1466.115.121.1.12 is the DN syntax [RFC4517].\n"
- title: 4.2.1.5.  fedfsFslUuid
  contents:
  - "4.2.1.5.  fedfsFslUuid\n   A fedfsFslUuid represents the UUID of an FSL.  An\
    \ NSDB SHOULD ensure\n   that no two FSLs it stores have the same fedfsFslUuid.\n\
    \   This attribute is single-valued.\n   <CODE BEGINS>\n           ///\n     \
    \      /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.8 NAME 'fedfsFslUuid'\n\
    \           ///     DESC 'UUID of an FSL'\n           ///     SUP fedfsUuid\n\
    \           ///     SINGLE-VALUE\n           ///     )\n           ///\n   <CODE\
    \ ENDS>\n"
- title: 4.2.1.6.  fedfsAnnotation
  contents:
  - "4.2.1.6.  fedfsAnnotation\n   A fedfsAnnotation contains an object annotation\
    \ formatted as a key/\n   value pair.\n   This attribute is multi-valued; an object\
    \ type that permits\n   annotations may have any number of annotations per instance.\n\
    \   A fedfsAnnotation attribute is a human-readable sequence of UTF-8\n   characters\
    \ with no non-terminal NUL characters.  The value MUST be\n   formatted according\
    \ to the following ABNF [RFC5234] rules:\n      ANNOTATION = KEY \"=\" VALUE\n\
    \      KEY        = ITEM\n      VALUE      = ITEM\n      ITEM       = *WSP DQUOTE\
    \ UTF8-octets DQUOTE *WSP\n   DQUOTE and WSP are defined in [RFC5234], and UTF8-octets\
    \ is defined\n   in [RFC3629].\n   The following escape sequences are allowed:\n\
    \                     +-----------------+-------------+\n                    \
    \ | escape sequence | replacement |\n                     +-----------------+-------------+\n\
    \                     |        \\\\       |      \\      |\n                 \
    \    |        \\\"       |      \"      |\n                     +-----------------+-------------+\n\
    \   A fedfsAnnotation value might be processed as follows:\n   1.  Parse the attribute\
    \ value according to the ANNOTATION rule,\n       ignoring the escape sequences\
    \ above.\n   2.  Scan through results of the previous step and replace the escape\n\
    \       sequences above.\n   A fedfsAnnotation attribute that does not adhere\
    \ to this format\n   SHOULD be ignored in its entirety.  It MUST NOT prevent further\n\
    \   processing of its containing entry.\n   The following are examples of valid\
    \ fedfsAnnotation attributes:\n            \"key1\" = \"foo\"\n            \"\
    another key\" = \"x=3\"\n            \"key-2\" = \"A string with \\\" and \\\\\
    \ characters.\"\n            \"key3\"=\"bar\"\n   These correspond to the following\
    \ key/value pairs:\n            +-------------+-----------------------------------+\n\
    \            |     key     |               value               |\n           \
    \ +-------------+-----------------------------------+\n            |     key1\
    \    |                foo                |\n            | another key |      \
    \          x=3                |\n            |    key-2    | A string with \"\
    \ and \\ characters. |\n            |     key3    |                bar       \
    \         |\n            +-------------+-----------------------------------+\n\
    \   <CODE BEGINS>\n           ///\n           /// attributetype (\n          \
    \ ///     1.3.6.1.4.1.31103.1.12 NAME 'fedfsAnnotation'\n           ///     DESC\
    \ 'Annotation of an object'\n           ///     SUP name\n           ///     )\n\
    \           ///\n   <CODE ENDS>\n"
- title: 4.2.1.7.  fedfsDescr
  contents:
  - "4.2.1.7.  fedfsDescr\n   A fedfsDescr stores an object description.  The description\
    \ MUST be\n   encoded as a UTF-8 string.\n   This attribute is multi-valued, which\
    \ permits any number of\n   descriptions per entry.\n   <CODE BEGINS>\n      \
    \     ///\n           /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.13\
    \ NAME 'fedfsDescr'\n           ///     DESC 'Description of an object'\n    \
    \       ///     SUP name\n           ///     )\n           ///\n   <CODE ENDS>\n"
- title: 4.2.1.8.  fedfsNfsURI
  contents:
  - "4.2.1.8.  fedfsNfsURI\n   A fedfsNfsURI stores the host and pathname components\
    \ of an FSL.  A\n   fedfsNfsURI MUST be encoded as an NFS URI (see Section 2.8.1).\n\
    \   The fedfsNfsURI is a subtype of the labeledURI type [RFC2079], with\n   the\
    \ same encoding rules.\n   This attribute is single-valued.\n   <CODE BEGINS>\n\
    \           ///\n           /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.120\
    \ NAME 'fedfsNfsURI'\n           ///     DESC 'Location of fileset'\n        \
    \   ///     SUP labeledURI\n           ///     SINGLE-VALUE\n           ///  \
    \   )\n           ///\n   <CODE ENDS>\n"
- title: 4.2.1.9.  fedfsNfsCurrency
  contents:
  - "4.2.1.9.  fedfsNfsCurrency\n   A fedfsNfsCurrency stores the NFSv4.1 fs_locations_server's\n\
    \   fls_currency value [RFC5661].  A fedfsNfsCurrency MUST be encoded as\n   an\
    \ Integer syntax value [RFC4517] in the range [-2147483648,\n   2147483647].\n\
    \   This attribute is single-valued.\n   <CODE BEGINS>\n           ///\n     \
    \      /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.103 NAME 'fedfsNfsCurrency'\n\
    \           ///     DESC 'up-to-date measure of the data'\n           ///    \
    \ EQUALITY integerMatch\n           ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27\n\
    \           ///     SINGLE-VALUE\n           ///     )\n           ///\n   <CODE\
    \ ENDS>\n   OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer syntax [RFC4517].\n"
- title: 4.2.1.10.  fedfsNfsGenFlagWritable
  contents:
  - "4.2.1.10.  fedfsNfsGenFlagWritable\n   A fedfsNfsGenFlagWritable stores the value\
    \ of an FSL's NFSv4.1\n   FSLI4GF_WRITABLE bit [RFC5661].  A value of \"TRUE\"\
    \ indicates the bit\n   is set.  A value of \"FALSE\" indicates the bit is not\
    \ set.\n   <CODE BEGINS>\n          ///\n          /// attributetype (\n     \
    \     ///     1.3.6.1.4.1.31103.1.104 NAME 'fedfsNfsGenFlagWritable'\n       \
    \   ///     DESC 'Indicates if the file system is writable'\n          ///   \
    \  EQUALITY booleanMatch\n          ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.7\n\
    \          ///     SINGLE-VALUE\n          ///     )\n          ///\n   <CODE\
    \ ENDS>\n   OID 1.3.6.1.4.1.1466.115.121.1.7 is the Boolean syntax [RFC4517].\n"
- title: 4.2.1.11.  fedfsNfsGenFlagGoing
  contents:
  - "4.2.1.11.  fedfsNfsGenFlagGoing\n   A fedfsNfsGenFlagGoing stores the value of\
    \ an FSL's NFSv4.1\n   FSLI4GF_GOING bit [RFC5661].  A value of \"TRUE\" indicates\
    \ the bit is\n   set.  A value of \"FALSE\" indicates the bit is not set.\n  \
    \ <CODE BEGINS>\n           ///\n           /// attributetype (\n           ///\
    \     1.3.6.1.4.1.31103.1.105 NAME 'fedfsNfsGenFlagGoing'\n           ///    \
    \ DESC 'Indicates if the file system is going'\n           ///     EQUALITY booleanMatch\n\
    \           ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.7\n           ///     SINGLE-VALUE\n\
    \           ///     )\n           ///\n   <CODE ENDS>\n   OID 1.3.6.1.4.1.1466.115.121.1.7\
    \ is the Boolean syntax [RFC4517].\n"
- title: 4.2.1.12.  fedfsNfsGenFlagSplit
  contents:
  - "4.2.1.12.  fedfsNfsGenFlagSplit\n   A fedfsNfsGenFlagSplit stores the value of\
    \ an FSL's NFSv4.1\n   FSLI4GF_SPLIT bit [RFC5661].  A value of \"TRUE\" indicates\
    \ the bit is\n   set.  A value of \"FALSE\" indicates the bit is not set.\n  \
    \ <CODE BEGINS>\n           ///\n           /// attributetype (\n           ///\
    \     1.3.6.1.4.1.31103.1.106 NAME 'fedfsNfsGenFlagSplit'\n           ///    \
    \ DESC 'Indicates if there are multiple file systems'\n           ///     EQUALITY\
    \ booleanMatch\n           ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.7\n     \
    \      ///     SINGLE-VALUE\n           ///     )\n           ///\n   <CODE ENDS>\n\
    \   OID 1.3.6.1.4.1.1466.115.121.1.7 is the Boolean syntax [RFC4517].\n"
- title: 4.2.1.13.  fedfsNfsTransFlagRdma
  contents:
  - "4.2.1.13.  fedfsNfsTransFlagRdma\n   A fedfsNfsTransFlagRdma stores the value\
    \ of an FSL's NFSv4.1\n   FSLI4TF_RDMA bit [RFC5661].  A value of \"TRUE\" indicates\
    \ the bit is\n   set.  A value of \"FALSE\" indicates the bit is not set.\n  \
    \ <CODE BEGINS>\n           ///\n           /// attributetype (\n           ///\
    \     1.3.6.1.4.1.31103.1.107 NAME 'fedfsNfsTransFlagRdma'\n           ///   \
    \  DESC 'Indicates if the transport supports RDMA'\n           ///     EQUALITY\
    \ booleanMatch\n           ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.7\n     \
    \      ///     SINGLE-VALUE\n           ///     )\n           ///\n   <CODE ENDS>\n\
    \   OID 1.3.6.1.4.1.1466.115.121.1.7 is the Boolean syntax [RFC4517].\n"
- title: 4.2.1.14.  fedfsNfsClassSimul
  contents:
  - "4.2.1.14.  fedfsNfsClassSimul\n   A fedfsNfsClassSimul contains the FSL's NFSv4.1\
    \ FSLI4BX_CLSIMUL\n   [RFC5661] value.  A fedfsNfsClassSimul MUST be encoded as\
    \ an Integer\n   syntax value [RFC4517] in the range [0, 255].\n   <CODE BEGINS>\n\
    \           ///\n           /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.108\
    \ NAME 'fedfsNfsClassSimul'\n           ///     DESC 'The simultaneous-use class\
    \ of the file system'\n           ///     EQUALITY integerMatch\n           ///\
    \     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27\n           ///     SINGLE-VALUE\n\
    \           ///     )\n           ///\n   <CODE ENDS>\n   OID 1.3.6.1.4.1.1466.115.121.1.27\
    \ is the Integer syntax [RFC4517].\n"
- title: 4.2.1.15.  fedfsNfsClassHandle
  contents:
  - "4.2.1.15.  fedfsNfsClassHandle\n   A fedfsNfsClassHandle contains the FSL's NFSv4.1\
    \ FSLI4BX_CLHANDLE\n   [RFC5661] value.  A fedfsNfsClassHandle MUST be encoded\
    \ as an Integer\n   syntax value [RFC4517] in the range [0, 255].\n   <CODE BEGINS>\n\
    \           ///\n           /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.109\
    \ NAME 'fedfsNfsClassHandle'\n           ///     DESC 'The handle class of the\
    \ file system'\n           ///     EQUALITY integerMatch\n           ///     SYNTAX\
    \ 1.3.6.1.4.1.1466.115.121.1.27\n           ///     SINGLE-VALUE\n           ///\
    \     )\n           ///\n   <CODE ENDS>\n   OID 1.3.6.1.4.1.1466.115.121.1.27\
    \ is the Integer syntax [RFC4517].\n"
- title: 4.2.1.16.  fedfsNfsClassFileid
  contents:
  - "4.2.1.16.  fedfsNfsClassFileid\n   A fedfsNfsClassFileid contains the FSL's NFSv4.1\
    \ FSLI4BX_CLFILEID\n   [RFC5661] value.  A fedfsNfsClassFileid MUST be encoded\
    \ as an Integer\n   syntax value [RFC4517] in the range [0, 255].\n   <CODE BEGINS>\n\
    \           ///\n           /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.110\
    \ NAME 'fedfsNfsClassFileid'\n           ///     DESC 'The fileid class of the\
    \ file system'\n           ///     EQUALITY integerMatch\n           ///     SYNTAX\
    \ 1.3.6.1.4.1.1466.115.121.1.27\n           ///     SINGLE-VALUE\n           ///\
    \     )\n           ///\n   <CODE ENDS>\n   OID 1.3.6.1.4.1.1466.115.121.1.27\
    \ is the Integer syntax [RFC4517].\n"
- title: 4.2.1.17.  fedfsNfsClassWritever
  contents:
  - "4.2.1.17.  fedfsNfsClassWritever\n   A fedfsNfsClassWritever contains the FSL's\
    \ NFSv4.1 FSLI4BX_CLWRITEVER\n   [RFC5661] value.  A fedfsNfsClassWritever MUST\
    \ be encoded as an\n   Integer syntax value [RFC4517] in the range [0, 255].\n\
    \   <CODE BEGINS>\n           ///\n           /// attributetype (\n          \
    \ ///     1.3.6.1.4.1.31103.1.111 NAME 'fedfsNfsClassWritever'\n           ///\
    \     DESC 'The write-verifier class of the file system'\n           ///     EQUALITY\
    \ integerMatch\n           ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27\n    \
    \       ///     SINGLE-VALUE\n           ///     )\n           ///\n   <CODE ENDS>\n\
    \   OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer syntax [RFC4517].\n"
- title: 4.2.1.18.  fedfsNfsClassChange
  contents:
  - "4.2.1.18.  fedfsNfsClassChange\n   A fedfsNfsClassChange contains the FSL's NFSv4.1\
    \ FSLI4BX_CLCHANGE\n   [RFC5661] value.  A fedfsNfsClassChange MUST be encoded\
    \ as an Integer\n   syntax value [RFC4517] in the range [0, 255].\n   <CODE BEGINS>\n\
    \           ///\n           /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.112\
    \ NAME 'fedfsNfsClassChange'\n           ///     DESC 'The change class of the\
    \ file system'\n           ///     EQUALITY integerMatch\n           ///     SYNTAX\
    \ 1.3.6.1.4.1.1466.115.121.1.27\n           ///     SINGLE-VALUE\n           ///\
    \     )\n           ///\n   <CODE ENDS>\n   OID 1.3.6.1.4.1.1466.115.121.1.27\
    \ is the Integer syntax [RFC4517].\n"
- title: 4.2.1.19.  fedfsNfsClassReaddir
  contents:
  - "4.2.1.19.  fedfsNfsClassReaddir\n   A fedfsNfsClassReaddir contains the FSL's\
    \ NFSv4.1 FSLI4BX_CLREADDIR\n   [RFC5661] value.  A fedfsNfsClassReaddir MUST\
    \ be encoded as an\n   Integer syntax value [RFC4517] in the range [0, 255].\n\
    \   <CODE BEGINS>\n           ///\n           /// attributetype (\n          \
    \ ///     1.3.6.1.4.1.31103.1.113 NAME 'fedfsNfsClassReaddir'\n           ///\
    \     DESC 'The readdir class of the file system'\n           ///     EQUALITY\
    \ integerMatch\n           ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27\n    \
    \       ///     SINGLE-VALUE\n           ///     )\n           ///\n   <CODE ENDS>\n\
    \   OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer syntax [RFC4517].\n"
- title: 4.2.1.20.  fedfsNfsReadRank
  contents:
  - "4.2.1.20.  fedfsNfsReadRank\n   A fedfsNfsReadRank contains the FSL's NFSv4.1\
    \ FSLI4BX_READRANK\n   [RFC5661] value.  A fedfsNfsReadRank MUST be encoded as\
    \ an Integer\n   syntax value [RFC4517] in the range [0, 255].\n   <CODE BEGINS>\n\
    \           ///\n           /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.114\
    \ NAME 'fedfsNfsReadRank'\n           ///     DESC 'The read rank of the file\
    \ system'\n           ///     EQUALITY integerMatch\n           ///     SYNTAX\
    \ 1.3.6.1.4.1.1466.115.121.1.27\n           ///     SINGLE-VALUE\n           ///\
    \     )\n           ///\n   <CODE ENDS>\n   OID 1.3.6.1.4.1.1466.115.121.1.27\
    \ is the Integer syntax [RFC4517].\n"
- title: 4.2.1.21.  fedfsNfsReadOrder
  contents:
  - "4.2.1.21.  fedfsNfsReadOrder\n   A fedfsNfsReadOrder contains the FSL's NFSv4.1\
    \ FSLI4BX_READORDER\n   [RFC5661] value.  A fedfsNfsReadOrder MUST be encoded\
    \ as an Integer\n   syntax value [RFC4517] in the range [0, 255].\n   <CODE BEGINS>\n\
    \           ///\n           /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.115\
    \ NAME 'fedfsNfsReadOrder'\n           ///     DESC 'The read order of the file\
    \ system'\n           ///     EQUALITY integerMatch\n           ///     SYNTAX\
    \ 1.3.6.1.4.1.1466.115.121.1.27\n           ///     SINGLE-VALUE\n           ///\
    \     )\n           ///\n   <CODE ENDS>\n   OID 1.3.6.1.4.1.1466.115.121.1.27\
    \ is the Integer syntax [RFC4517].\n"
- title: 4.2.1.22.  fedfsNfsWriteRank
  contents:
  - "4.2.1.22.  fedfsNfsWriteRank\n   A fedfsNfsWriteRank contains the FSL's FSLI4BX_WRITERANK\
    \ [RFC5661]\n   value.  A fedfsNfsWriteRank MUST be encoded as an Integer syntax\n\
    \   value [RFC4517] in the range [0, 255].\n   <CODE BEGINS>\n           ///\n\
    \           /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.116 NAME\
    \ 'fedfsNfsWriteRank'\n           ///     DESC 'The write rank of the file system'\n\
    \           ///     EQUALITY integerMatch\n           ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27\n\
    \           ///     SINGLE-VALUE\n           ///     )\n           ///\n   <CODE\
    \ ENDS>\n   OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer syntax [RFC4517].\n"
- title: 4.2.1.23.  fedfsNfsWriteOrder
  contents:
  - "4.2.1.23.  fedfsNfsWriteOrder\n   A fedfsNfsWriteOrder contains the FSL's FSLI4BX_WRITEORDER\
    \ [RFC5661]\n   value.  A fedfsNfsWriteOrder MUST be encoded as an Integer syntax\n\
    \   value [RFC4517] in the range [0, 255].\n   <CODE BEGINS>\n           ///\n\
    \           /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.117 NAME\
    \ 'fedfsNfsWriteOrder'\n           ///     DESC 'The write order of the file system'\n\
    \           ///     EQUALITY integerMatch\n           ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27\n\
    \           ///     SINGLE-VALUE\n           ///     )\n           ///\n   <CODE\
    \ ENDS>\n   OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer syntax [RFC4517].\n"
- title: 4.2.1.24.  fedfsNfsVarSub
  contents:
  - "4.2.1.24.  fedfsNfsVarSub\n   A fedfsNfsVarSub stores the value of an FSL's NFSv4.1\
    \ FSLI4IF_VAR_SUB\n   bit [RFC5661].  A value of \"TRUE\" indicates the bit is\
    \ set.  A value\n   of \"FALSE\" indicates the bit is not set.\n   <CODE BEGINS>\n\
    \           ///\n           /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.118\
    \ NAME 'fedfsNfsVarSub'\n           ///     DESC 'Indicates if variable substitution\
    \ is present'\n           ///     EQUALITY booleanMatch\n           ///     SYNTAX\
    \ 1.3.6.1.4.1.1466.115.121.1.7\n           ///     SINGLE-VALUE\n           ///\
    \     )\n           ///\n   <CODE ENDS>\n   OID 1.3.6.1.4.1.1466.115.121.1.7 is\
    \ the Boolean syntax [RFC4517].\n"
- title: 4.2.1.25.  fedfsNfsValidFor
  contents:
  - "4.2.1.25.  fedfsNfsValidFor\n   A fedfsNfsValidFor stores an FSL's NFSv4.1 fs_locations_info\n\
    \   fli_valid_for value [RFC5661].  A fedfsNfsValidFor MUST be encoded as\n  \
    \ an Integer syntax value [RFC4517] in the range [-2147483648,\n   2147483647].\n\
    \   An FSL's parent's fedfsFsnTTL value and its fedfsNfsValidFor value\n   MAY\
    \ be different.\n   This attribute is single-valued.\n   <CODE BEGINS>\n     \
    \      ///\n           /// attributetype (\n           ///     1.3.6.1.4.1.31103.1.19\
    \ NAME 'fedfsNfsValidFor'\n           ///     DESC 'Valid for time'\n        \
    \   ///     EQUALITY integerMatch\n           ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27\n\
    \           ///     SINGLE-VALUE\n           ///     )\n           ///\n   OID\
    \ 1.3.6.1.4.1.1466.115.121.1.27 is the Integer syntax [RFC4517].\n   <CODE ENDS>\n"
- title: 4.2.2.  LDAP Object Classes
  contents:
  - '4.2.2.  LDAP Object Classes

    '
- title: 4.2.2.1.  fedfsNsdbContainerInfo
  contents:
  - "4.2.2.1.  fedfsNsdbContainerInfo\n   A fedfsNsdbContainerInfo describes the location\
    \ of the NCE.\n   A fedfsNsdbContainerInfo's fedfsNceDN attribute is REQUIRED.\n\
    \   A fedfsNsdbContainerInfo's fedfsAnnotation and fedfsDescr attributes\n   are\
    \ OPTIONAL.\n   <CODE BEGINS>\n          ///\n          /// objectclass (\n  \
    \        ///     1.3.6.1.4.1.31103.1.1001 NAME 'fedfsNsdbContainerInfo'\n    \
    \      ///     DESC 'Describes NCE location'\n          ///     SUP top AUXILIARY\n\
    \          ///     MUST (\n          ///             fedfsNceDN\n          ///\
    \     )\n          ///     MAY (\n          ///             fedfsAnnotation\n\
    \          ///             $ fedfsDescr\n          ///     ))\n          ///\n\
    \   <CODE ENDS>\n"
- title: 4.2.2.2.  fedfsFsn
  contents:
  - "4.2.2.2.  fedfsFsn\n   A fedfsFsn represents an FSN.\n   A fedfsFsn's fedfsFsnUuid\
    \ and fedfsFsnTTL attributes are REQUIRED.\n   A fedfsFsn's fedfsAnnotation and\
    \ fedfsDescr attributes are OPTIONAL.\n   The DN of an FSN is REQUIRED to take\
    \ the following form:\n   \"fedfsFsnUuid=$FSNUUID,$NCE\", where $FSNUUID is the\
    \ UUID of the FSN\n   and $NCE is the DN of the NCE.  Since LDAP requires a DN\
    \ to be\n   unique, this ensures that each FSN entry has a unique UUID value\n\
    \   within the LDAP directory.\n   <CODE BEGINS>\n           ///\n           ///\
    \ objectclass (\n           ///     1.3.6.1.4.1.31103.1.1002 NAME 'fedfsFsn'\n\
    \           ///     DESC 'Represents a fileset'\n           ///     SUP top STRUCTURAL\n\
    \           ///     MUST (\n           ///             fedfsFsnUuid\n        \
    \   ///             $ fedfsFsnTTL\n           ///     )\n           ///     MAY\
    \ (\n           ///             fedfsAnnotation\n           ///             $\
    \ fedfsDescr\n           ///     ))\n           ///\n   <CODE ENDS>\n"
- title: 4.2.2.3.  fedfsFsl
  contents:
  - "4.2.2.3.  fedfsFsl\n   The fedfsFsl object class represents an FSL.\n   The fedfsFsl\
    \ is an abstract object class.  Protocol-specific subtypes\n   of this object\
    \ class are used to store FSL information.  The\n   fedfsNfsFsl object class defined\
    \ in Section 4.2.2.4 is used to record\n   an NFS FSL's location.  Other subtypes\
    \ MAY be defined for other\n   protocols (e.g., Common Internet File System (CIFS)).\n\
    \   A fedfsFsl's fedfsFslUuid and fedfsFsnUuid attributes are REQUIRED.\n   A\
    \ fedfsFsl's fedfsAnnotation and fedfsDescr attributes are OPTIONAL.\n   The DN\
    \ of an FSL is REQUIRED to take the following form:\n   \"fedfsFslUuid=$FSLUUID,fedfsFsnUuid=$FSNUUID,$NCE\"\
    , where $FSLUUID is\n   the FSL's UUID, $FSNUUID is the FSN's UUID, and $NCE is\
    \ the DN of the\n   NCE.  Since LDAP requires a DN to be unique, this ensures\
    \ that each\n   FSL entry has a unique UUID value within the LDAP directory.\n\
    \   <CODE BEGINS>\n           ///\n           /// objectclass (\n           ///\
    \     1.3.6.1.4.1.31103.1.1003 NAME 'fedfsFsl'\n           ///     DESC 'A physical\
    \ location of a fileset'\n           ///     SUP top ABSTRACT\n           ///\
    \     MUST (\n           ///             fedfsFslUuid\n           ///        \
    \     $ fedfsFsnUuid\n           ///     )\n           ///     MAY (\n       \
    \    ///             fedfsAnnotation\n           ///             $ fedfsDescr\n\
    \           ///     ))\n           ///\n   <CODE ENDS>\n"
- title: 4.2.2.4.  fedfsNfsFsl
  contents:
  - "4.2.2.4.  fedfsNfsFsl\n   A fedfsNfsFsl is used to represent an NFS FSL.  The\
    \ fedfsNfsFsl\n   inherits all of the attributes of the fedfsFsl and extends the\n\
    \   fedfsFsl with information specific to the NFS protocol.\n   The DN of an NFS\
    \ FSL is REQUIRED to take the following form:\n   \"fedfsFslUuid=$FSLUUID,fedfsFsnUuid=$FSNUUID,$NCE\"\
    , where $FSLUUID is\n   the FSL's UUID, $FSNUUID is the FSN's UUID, and $NCE is\
    \ the DN of the\n   NCE.  Since LDAP requires a DN to be unique, this ensures\
    \ that each\n   NFS FSL entry has a unique UUID value within the LDAP directory.\n\
    \   <CODE BEGINS>\n           ///\n           /// objectclass (\n           ///\
    \     1.3.6.1.4.1.31103.1.1004 NAME 'fedfsNfsFsl'\n           ///     DESC 'An\
    \ NFS location of a fileset'\n           ///     SUP fedfsFsl STRUCTURAL\n   \
    \        ///     MUST (\n           ///             fedfsNfsURI\n           ///\
    \             $ fedfsNfsCurrency\n           ///             $ fedfsNfsGenFlagWritable\n\
    \           ///             $ fedfsNfsGenFlagGoing\n           ///           \
    \  $ fedfsNfsGenFlagSplit\n           ///             $ fedfsNfsTransFlagRdma\n\
    \           ///             $ fedfsNfsClassSimul\n           ///             $\
    \ fedfsNfsClassHandle\n           ///             $ fedfsNfsClassFileid\n    \
    \       ///             $ fedfsNfsClassWritever\n           ///             $\
    \ fedfsNfsClassChange\n           ///             $ fedfsNfsClassReaddir\n   \
    \        ///             $ fedfsNfsReadRank\n           ///             $ fedfsNfsReadOrder\n\
    \           ///             $ fedfsNfsWriteRank\n           ///             $\
    \ fedfsNfsWriteOrder\n           ///             $ fedfsNfsVarSub\n          \
    \ ///             $ fedfsNfsValidFor\n           ///     ))\n           ///\n\
    \   <CODE ENDS>\n"
- title: 5.  NSDB Operations
  contents:
  - "5.  NSDB Operations\n   The operations defined by the protocol can be described\
    \ as several\n   sub-protocols that are used by entities within a federation to\n\
    \   perform different roles.\n   The first of these sub-protocols defines how\
    \ the state of an NSDB\n   node can be initialized and updated.  The primary use\
    \ of this sub-\n   protocol is by an administrator to add, edit, or delete filesets,\n\
    \   their properties, and their fileset locations.\n   The second of these sub-protocols\
    \ defines the queries that are sent\n   to an NSDB node in order to perform resolution\
    \ (or to find other\n   information about the data stored within that NSDB node)\
    \ and the\n   responses returned by the NSDB node.  The primary use of this sub-\n\
    \   protocol is by a fileserver in order to perform resolution, but it\n   may\
    \ also be used by an administrator to query the state of the\n   system.\n   The\
    \ first and second sub-protocols are defined as LDAP operations,\n   using the\
    \ schema defined in the previous section.  If each NSDB node\n   is a standard\
    \ LDAP server, then, in theory, it is unnecessary to\n   describe the LDAP operations\
    \ in detail because the operations are\n   ordinary LDAP operations to query and\
    \ update records.  However, we do\n   not require that an NSDB node implement\
    \ a complete LDAP service.\n   Therefore, we define the minimum level of LDAP\
    \ functionality required\n   to implement an NSDB node.\n   The NSDB sub-protocols\
    \ are defined in Section 5.1 and Section 5.2.\n   The descriptions of LDAP messages\
    \ in these sections use the LDAP Data\n   Interchange Format (LDIF) [RFC2849].\
    \  In order to differentiate\n   constant and variable strings in the LDIF specifications,\
    \ variables\n   are prefixed by a $ character and use all uppercase characters.\
    \  For\n   example, a variable named FOO would be specified as $FOO.\n   This\
    \ document uses the term \"NSDB client\" to refer to an LDAP client\n   that uses\
    \ either of the NSDB sub-protocols.\n   The third sub-protocol defines the queries\
    \ and other requests that\n   are sent to a fileserver in order to get information\
    \ from it or to\n   modify the state of the fileserver in a manner related to\
    \ the\n   federation protocols.  The primary purpose of this protocol is for an\n\
    \   administrator to create or delete a junction or discover related\n   information\
    \ about a particular fileserver.\n   The third sub-protocol is defined as an Open\
    \ Network Computing (ONC)\n   Remote Procedure Call (RPC) protocol.  The reason\
    \ for using ONC RPC\n   instead of LDAP is that all fileservers support ONC RPC,\
    \ but some do\n   not support an LDAP directory server.\n   The ONC RPC administration\
    \ protocol is defined in [RFC7533].\n"
- title: 5.1.  NSDB Operations for Administrators
  contents:
  - "5.1.  NSDB Operations for Administrators\n   The admin entity initiates and controls\
    \ the commands to manage\n   fileset and namespace information.  The protocol\
    \ used for\n   communicating between the admin entity and each NSDB node MUST\
    \ be the\n   LDAPv3 [RFC4510] protocol.\n   The names we assign to these operations\
    \ are entirely for the purpose\n   of exposition in this document and are not\
    \ part of the LDAP dialogs.\n"
- title: 5.1.1.  Create an FSN
  contents:
  - "5.1.1.  Create an FSN\n   This operation creates a new FSN in the NSDB by adding\
    \ a new fedfsFsn\n   entry in the NSDB's LDAP directory.\n   A fedfsFsn entry\
    \ contains a fedfsFsnUuid.  The administrator chooses\n   the fedfsFsnUuid by\
    \ the process described in Section 2.12.  A\n   fedfsFsn entry also contains a\
    \ fedfsFsnTTL.  The fedfsFsnTTL is\n   chosen by the administrator as described\
    \ in Section 2.8.3.\n"
- title: 5.1.1.1.  LDAP Request
  contents:
  - "5.1.1.1.  LDAP Request\n   This operation is implemented using the LDAP ADD request\
    \ described by\n   the LDIF below.\n           dn: fedfsFsnUuid=$FSNUUID,$NCE\n\
    \           changeType: add\n           objectClass: fedfsFsn\n           fedfsFsnUuid:\
    \ $FSNUUID\n           fedfsFsnTTL: $TTL\n   For example, if $FSNUUID is \"e8c4761c-eb3b-4307-86fc-f702da197966\"\
    ,\n   $TTL is \"300\" seconds, and $NCE is \"o=fedfs\", the operation would be:\n\
    \           dn: fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs\n  \
    \         changeType: add\n           objectClass: fedfsFsn\n           fedfsFsnUuid:\
    \ e8c4761c-eb3b-4307-86fc-f702da197966\n           fedfsFsnTTL: 300\n"
- title: 5.1.2.  Delete an FSN
  contents:
  - "5.1.2.  Delete an FSN\n   This operation deletes an FSN by removing a fedfsFsn\
    \ entry in the\n   NSDB's LDAP directory.\n   If the FSN entry being deleted has\
    \ child FSL entries, this function\n   MUST return an error.  This ensures that\
    \ the NSDB will not contain\n   any orphaned FSL entries.  A compliant LDAP implementation\
    \ will meet\n   this requirement since Section 4.8 of [RFC4511] defines the LDAP\n\
    \   delete operation to only be capable of removing leaf entries.\n   Note that\
    \ the FSN delete function removes the fileset only from a\n   federation namespace\
    \ (by removing the records for that FSN from the\n   NSDB node that receives this\
    \ request).  The fileset and its data are\n   not deleted.  Any junction that\
    \ has this FSN as its target may\n   continue to point to this non-existent FSN.\
    \  A dangling reference may\n   be detected when a fileserver tries to resolve\
    \ a junction that refers\n   to the deleted FSN.\n"
- title: 5.1.2.1.  LDAP Request
  contents:
  - "5.1.2.1.  LDAP Request\n   This operation is implemented using the LDAP DELETE\
    \ request described\n   by the LDIF below.\n           dn: fedfsFsnUuid=$FSNUUID,$NCE\n\
    \           changeType: delete\n   For example, if $FSNUUID is \"e8c4761c-eb3b-4307-86fc-f702da197966\"\
    \n   and $NCE is \"o=fedfs\", the operation would be:\n           dn: fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs\n\
    \           changeType: delete\n"
- title: 5.1.3.  Create an FSL
  contents:
  - "5.1.3.  Create an FSL\n   This operation creates a new FSL for the given FSN\
    \ by adding a new\n   fedfsFsl entry in the NSDB's LDAP directory.\n   A fedfsFsl\
    \ entry contains a fedfsFslUuid and fedfsFsnUuid.  The\n   administrator chooses\
    \ the fedfsFslUuid.  The process for choosing the\n   fedfsFslUuid is described\
    \ in Section 2.12.  The fedfsFsnUuid is the\n   UUID of the FSL's FSN.\n   The\
    \ administrator will also set additional attributes depending on\n   the FSL type.\n"
- title: 5.1.3.1.  LDAP Request
  contents:
  - "5.1.3.1.  LDAP Request\n   This operation is implemented using the LDAP ADD request\
    \ described by\n   the LDIF below (Note: the LDIF shows the creation of an NFS\
    \ FSL.)\n           dn: fedfsFslUuid=$FSLUUID,fedfsFsnUuid=$FSNUUID,$NCE\n   \
    \        changeType: add\n           objectClass: fedfsNfsFsl\n           fedfsFslUuid:\
    \ $FSLUUID\n           fedfsFsnUuid: $FSNUUID\n           fedfsNfsURI: nfs://$HOST:$PORT//$PATH\n\
    \           fedfsNfsCurrency: $CURRENCY\n           fedfsNfsGenFlagWritable: $WRITABLE\n\
    \           fedfsNfsGenFlagGoing: $GOING\n           fedfsNfsGenFlagSplit: $SPLIT\n\
    \           fedfsNfsTransFlagRdma: $RDMA\n           fedfsNfsClassSimul: $CLASS_SIMUL\n\
    \           fedfsNfsClassHandle:$CLASS_HANDLE\n           fedfsNfsClassFileid:$CLASS_FILEID\n\
    \           fedfsNfsClassWritever:$CLASS_WRITEVER\n           fedfsNfsClassChange:\
    \ $CLASS_CHANGE\n           fedfsNfsClassReaddir: $CLASS_READDIR\n           fedfsNfsReadRank:\
    \ $READ_RANK\n           fedfsNfsReadOrder: $READ_ORDER\n           fedfsNfsWriteRank:\
    \ $WRITE_RANK\n           fedfsNfsWriteOrder: $WRITE_ORDER\n           fedfsNfsVarSub:\
    \ $VAR_SUB\n           fedfsNfsValidFor: $TIME\n           fedfsAnnotation: $ANNOTATION\n\
    \           fedfsDescr: $DESCR\n   For example, if $FSNUUID is \"e8c4761c-eb3b-4307-86fc-f702da197966\"\
    ,\n   $FSLUUID is \"ba89a802-41a9-44cf-8447-dda367590eb3\", $HOST is\n   \"server.example.com\"\
    , $PORT is \"20049\", $PATH is stored in the file\n   \"/tmp/fsl_path\", $CURRENCY\
    \ is \"0\" (an up-to-date copy), the FSL is\n   writable, but not going, split,\
    \ or accessible via Remote Direct\n   Memory Access (RDMA), the simultaneous-use\
    \ class is \"1\", the handle\n   class is \"0\", the fileid class is \"1\", the\
    \ write-verifier class is\n   \"1\", the change class is \"1\", the readdir class\
    \ is \"9\", the read rank\n   is \"7\", the read order is \"8\", the write rank\
    \ is \"5\", the write order\n   is \"6\", variable substitution is false, $TIME\
    \ is \"300\" seconds,\n   $ANNOTATION is \"\"foo\" = \"bar\"\", $DESC is \"This\
    \ is a description.\",\n   and $NCE is \"o=fedfs\", the operation would be (for\
    \ readability, the\n   DN is split into two lines):\n           dn: fedfsFslUuid=ba89a802-41a9-44cf-8447-dda367590eb3,\n\
    \            fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs\n     \
    \      changeType: add\n           objectClass: fedfsNfsFsl\n           fedfsFslUuid:\
    \ ba89a802-41a9-44cf-8447-dda367590eb3\n           fedfsFsnUuid: e8c4761c-eb3b-4307-86fc-f702da197966\n\
    \           fedfsNfsURI: nfs://server.example.com:20049//tmp/fsl_path\n      \
    \     fedfsNfsCurrency: 0\n           fedfsNfsGenFlagWritable: TRUE\n        \
    \   fedfsNfsGenFlagGoing: FALSE\n           fedfsNfsGenFlagSplit: FALSE\n    \
    \       fedfsNfsTransFlagRdma: FALSE\n           fedfsNfsClassSimul: 1\n     \
    \      fedfsNfsClassHandle: 0\n           fedfsNfsClassFileid: 1\n           fedfsNfsClassWritever:\
    \ 1\n           fedfsNfsClassChange: 1\n           fedfsNfsClassReaddir: 9\n \
    \          fedfsNfsReadRank: 7\n           fedfsNfsReadOrder: 8\n           fedfsNfsWriteRank:\
    \ 5\n           fedfsNfsWriteOrder: 6\n           fedfsNfsVarSub: FALSE\n    \
    \       fedfsNfsValidFor: 300\n           fedfsAnnotation: \"foo\" = \"bar\"\n\
    \           fedfsDescr: This is a description.\n"
- title: 5.1.3.2.  Selecting fedfsNfsFsl Values
  contents:
  - "5.1.3.2.  Selecting fedfsNfsFsl Values\n   The fedfsNfsFSl object class is used\
    \ to describe NFSv4-accessible\n   filesets.  For the reasons described in Section\
    \ 2.8.4, administrators\n   SHOULD choose reasonable values for all LDAP attributes\
    \ of an\n   NFSv4-accessible fedfsNfsFsl even though some of these LDAP\n   attributes\
    \ are not explicitly contained in an NFSv4 fs_locations\n   attribute.\n   When\
    \ the administrator is unable to choose reasonable values for the\n   LDAP attributes\
    \ not explicitly contained in an NFSv4 fs_locations\n   attribute, the values\
    \ in the following table are RECOMMENDED.\n   +-------------------------+----------+------------------------------+\n\
    \   | LDAP attribute          | LDAP     | Notes                        |\n  \
    \ |                         | value    |                              |\n   +-------------------------+----------+------------------------------+\n\
    \   | fedfsNfsCurrency        | negative | Indicates that the server    |\n  \
    \ |                         | value    | does not know the currency   |\n   |\
    \                         |          | (see Section 11.10.1 of      |\n   |  \
    \                       |          | [RFC5661]).                  |\n   | fedfsNfsGenFlagWritable\
    \ | FALSE    | Leaving unset is not harmful |\n   |                         |\
    \          | (see Section 11.10.1 of      |\n   |                         |  \
    \        | [RFC5661]).                  |\n   | fedfsNfsGenFlagGoing    | FALSE\
    \    | NFS client will detect a     |\n   |                         |        \
    \  | migration event if the FSL   |\n   |                         |          |\
    \ becomes unavailable.         |\n   | fedfsNfsGenFlagSplit    | TRUE     | Safe\
    \ to assume that the FSL  |\n   |                         |          | is split.\
    \                    |\n   | fedfsNfsTransFlagRdma   | TRUE     | NFS client will\
    \ detect if    |\n   |                         |          | RDMA access is available.\
    \    |\n   | fedfsNfsClassSimul      | 0        | 0 is treated as non-matching\
    \ |\n   |                         |          | (see Section 11.10.1 of      |\n\
    \   |                         |          | [RFC5661]).                  |\n  \
    \ | fedfsNfsClassHandle     | 0        | See fedfsNfsClassSimul note. |\n   |\
    \ fedfsNfsClassFileid     | 0        | See fedfsNfsClassSimul note. |\n   | fedfsNfsClassWritever\
    \   | 0        | See fedfsNfsClassSimul note. |\n   | fedfsNfsClassChange    \
    \ | 0        | See fedfsNfsClassSimul note. |\n   | fedfsNfsClassReaddir    |\
    \ 0        | See fedfsNfsClassSimul note. |\n   | fedfsNfsReadRank        | 0\
    \        | Highest value ensures FSL    |\n   |                         |    \
    \      | will be tried.               |\n   | fedfsNfsReadOrder       | 0    \
    \    | See fedfsNfsReadRank note.   |\n   | fedfsNfsWriteRank       | 0      \
    \  | See fedfsNfsReadRank note.   |\n   | fedfsNfsWriteOrder      | 0        |\
    \ See fedfsNfsReadRank note.   |\n   | fedfsNfsVarSub          | FALSE    | NFSv4\
    \ does not define        |\n   |                         |          | variable\
    \ substitution in     |\n   |                         |          | paths.    \
    \                   |\n   | fedfsNfsValidFor        | 0        | Indicates no\
    \ appropriate     |\n   |                         |          | refetch interval\
    \ (see        |\n   |                         |          | Section 11.10.2 of\
    \           |\n   |                         |          | [RFC5661]).         \
    \         |\n   +-------------------------+----------+------------------------------+\n"
- title: 5.1.4.  Delete an FSL
  contents:
  - "5.1.4.  Delete an FSL\n   This operation deletes an FSL record.  The admin requests\
    \ the NSDB\n   node storing the fedfsFsl to delete it from its database.  This\n\
    \   operation does not result in fileset data being deleted on any\n   fileserver.\n"
- title: 5.1.4.1.  LDAP Request
  contents:
  - "5.1.4.1.  LDAP Request\n   The admin sends an LDAP DELETE request to the NSDB\
    \ node to remove the\n   FSL.\n           dn: fedfsFslUuid=$FSLUUID,fedfsFsnUuid=$FSNUUID,$NCE\n\
    \           changeType: delete\n   For example, if $FSNUUID is \"e8c4761c-eb3b-4307-86fc-f702da197966\"\
    ,\n   $FSLUUID is \"ba89a802-41a9-44cf-8447-dda367590eb3\", and $NCE is\n   \"\
    o=fedfs\", the operation would be (for readability, the DN is split\n   into two\
    \ lines):\n           dn: fedfsFslUuid=ba89a802-41a9-44cf-8447-dda367590eb3,\n\
    \            fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs\n     \
    \      changeType: delete\n"
- title: 5.1.5.  Update an FSL
  contents:
  - "5.1.5.  Update an FSL\n   This operation updates the attributes of a given FSL.\
    \  This command\n   results in a change in the attributes of the fedfsFsl at the\
    \ NSDB\n   node maintaining this FSL.  The values of the fedfsFslUuid and\n  \
    \ fedfsFsnUuid attributes MUST NOT change during an FSL update.\n"
- title: 5.1.5.1.  LDAP Request
  contents:
  - "5.1.5.1.  LDAP Request\n   The admin sends an LDAP MODIFY request to the NSDB\
    \ node to update the\n   FSL.\n           dn: fedfsFslUuid=$FSLUUID,fedfsFsnUuid=$FSNUUID,$NCE\n\
    \           changeType: modify\n           replace: $ATTRIBUTE-TYPE\n   For example,\
    \ if $FSNUUID is \"e8c4761c-eb3b-4307-86fc-f702da197966\",\n   $FSLUUID is \"\
    ba89a802-41a9-44cf-8447-dda367590eb3\", $NCE is\n   \"o=fedfs\", and the administrator\
    \ wished to change the NFS read rank\n   to 10, the operation would be (for readability,\
    \ the DN is split into\n   two lines):\n           dn: fedfsFslUuid=ba89a802-41a9-44cf-8447-dda367590eb3,\n\
    \            fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs\n     \
    \      changeType: modify\n           replace: fedfsNfsReadClass\n           fedfsNfsReadRank:\
    \ 10\n"
- title: 5.2.  NSDB Operations for Fileservers
  contents:
  - '5.2.  NSDB Operations for Fileservers

    '
- title: 5.2.1.  NSDB Container Entry (NCE) Enumeration
  contents:
  - "5.2.1.  NSDB Container Entry (NCE) Enumeration\n   To find the NCEs for the NSDB\
    \ nsdb.example.com, a fileserver would do\n   the following:\n        nce_list\
    \ = empty\n        connect to the LDAP directory at nsdb.example.com\n       \
    \ for each namingContext value $BAR in the root DSE\n            /* $BAR is a\
    \ DN */\n            query for a fedfsNceDN value at $BAR\n            /*\n  \
    \           * The RFC 4516 LDAP URL for this search would be\n             *\n\
    \             *  ldap://nsdb.example.com:389/$BAR?fedfsNceDN??\n             *\
    \                      (objectClass=fedfsNsdbContainerInfo)\n             *\n\
    \             */\n            if a fedfsNceDN value is found\n               \
    \ add the value to the nce_list\n"
- title: 5.2.2.  Lookup FSLs for an FSN
  contents:
  - "5.2.2.  Lookup FSLs for an FSN\n   Using an LDAP search, the fileserver can obtain\
    \ all of the FSLs for a\n   given FSN.  The FSN's fedfsFsnUuid is used as the\
    \ search key.  The\n   following examples use the LDAP Uniform Resource Identifier\
    \ (URI)\n   format defined in [RFC4516].\n   To obtain a list of all FSLs for\
    \ $FSNUUID on the NSDB named\n   $NSDBNAME, the following search can be used (for\
    \ readability, the URI\n   is split into two lines):\n       for each $NCE in\
    \ nce_list\n           ldap://$NSDBNAME/fedfsFsnUuid=$FSNUUID,$NCE??one?\n   \
    \            (objectClass=fedfsFsl)\n   This search is for the children of the\
    \ object with DN\n   \"fedfsFsnUuid=$FSNUUID,$NCE\" with a filter for\n   \"objectClass=fedfsFsl\"\
    .  The scope value of \"one\" restricts the\n   search to the entry's children\
    \ (rather than the entire subtree below\n   the entry), and the filter ensures\
    \ that only FSL entries are\n   returned.\n   For example, if $NSDBNAME is \"\
    nsdb.example.com\", $FSNUUID is\n   \"e8c4761c-eb3b-4307-86fc-f702da197966\",\
    \ and $NCE is \"o=fedfs\", the\n   search would be (for readability, the URI is\
    \ split into three lines):\n       ldap://nsdb.example.com/\n               fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs\n\
    \               ??one?(objectClass=fedfsFsl)\n   The following search can be used\
    \ to obtain only the NFS FSLs for\n   $FSNUUID on the NSDB named $NSDBNAME (for\
    \ readability, the URI is\n   split into two lines):\n       for each $NCE in\
    \ nce_list\n           ldap://$NSDBNAME/fedfsFsnUuid=$FSNUUID,$NCE??one?\n   \
    \            (objectClass=fedfsNfsFsl)\n   This also searches for the children\
    \ of the object with DN\n   \"fedfsFsnUuid=$FSNUUID,$NCE\", but the filter for\
    \ \"objectClass =\n   fedfsNfsFsl\" restricts the results to only NFS FSLs.\n\
    \   For example, if $NSDBNAME is nsdb.example.com, $FSNUUID is \"e8c4761c-\n \
    \  eb3b-4307-86fc-f702da197966\", and $NCE is \"o=fedfs\", the search would\n\
    \   be (for readability, the URI is split into three lines):\n       ldap://nsdb.example.com/\n\
    \               fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs\n  \
    \             ??one?(objectClass=fedfsNfsFsl)\n   The fileserver will generate\
    \ a referral based on the set of FSLs\n   returned by these queries using the\
    \ process described in\n   Section 2.8.4.\n"
- title: 5.3.  NSDB Operations and LDAP Referrals
  contents:
  - "5.3.  NSDB Operations and LDAP Referrals\n   The LDAPv3 protocol defines an LDAP\
    \ referral mechanism that allows an\n   LDAP server to redirect an LDAP client.\
    \  LDAPv3 defines two types of\n   LDAP referrals: the Referral type defined in\
    \ Section 4.1.10 of\n   [RFC4511] and the SearchResultReference type defined in\
    \ Section 4.5.3\n   of [RFC4511].  In both cases, the LDAP referral lists one\
    \ or more\n   URIs for services that can be used to complete the operation.  In\
    \ the\n   remainder of this document, the term \"LDAP referral\" is used to\n\
    \   indicate either of these types.\n   If an NSDB operation results in an LDAP\
    \ referral, the NSDB client MAY\n   follow the LDAP referral.  An NSDB client's\
    \ decision to follow an\n   LDAP referral is implementation and configuration\
    \ dependent.  For\n   example, an NSDB client might be configured to follow only\
    \ those LDAP\n   referrals that were received over a secure channel or only those\
    \ that\n   target an NSDB that supports encrypted communication.  If an NSDB\n\
    \   client chooses to follow an LDAP referral, the NSDB client MUST\n   process\
    \ the LDAP referral and prevent looping as described in\n   Section 4.1.10 of\
    \ [RFC4511].\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   Both the NFSv4 and LDAPv3 protocols provide security\
    \ mechanisms.\n   When used in conjunction with the federated file system protocols\n\
    \   described in this document, the use of these mechanisms is\n   RECOMMENDED.\
    \  Specifically, the use of RPCSEC_GSS [RFC2203], which is\n   built on the Generic\
    \ Security Service Application Program Interface\n   (GSS-API) [RFC2743], is RECOMMENDED\
    \ on all NFS connections between a\n   file-access client and fileserver.  The\
    \ security considerations\n   sections of the NFSv4.0 [RFC7530] and NFSv4.1 [RFC5661]\n\
    \   specifications contain special considerations for the handling of\n   GETATTR\
    \ operations for the fs_locations and fs_locations_info\n   attributes.\n   NSDB\
    \ nodes and NSDB clients MUST implement support for TLS [RFC5246],\n   as described\
    \ in [RFC4513].  For all LDAP connections established by\n   the federated file\
    \ system protocols, the use of TLS is RECOMMENDED.\n   If an NSDB client chooses\
    \ to follow an LDAP referral, the NSDB client\n   SHOULD authenticate the LDAP\
    \ referral's target NSDB using the target\n   NSDB's credentials (not the credentials\
    \ of the NSDB that generated\n   the LDAP referral).  The NSDB client SHOULD NOT\
    \ follow an LDAP\n   referral that targets an NSDB for which it does not know\
    \ the NSDB's\n   credentials.\n   Within a federation, there are two types of\
    \ components an attacker\n   may compromise: a fileserver and an NSDB.\n   If\
    \ an attacker compromises a fileserver, the attacker can interfere\n   with a\
    \ file-access client's file system input/output (I/O) operations\n   (e.g., by\
    \ returning fictitious data in the response to a read\n   request) or can fabricate\
    \ a referral.  The attacker's abilities are\n   the same regardless of whether\
    \ or not the federation protocols are in\n   use.  While the federation protocols\
    \ do not give the attacker\n   additional capabilities, they are additional targets\
    \ for attack.  The\n   LDAP protocol described in Section 5.2 SHOULD be secured\
    \ using the\n   methods described above to defeat attacks on a fileserver via\
    \ this\n   channel.\n   If an attacker compromises an NSDB, the attacker will\
    \ be able to\n   forge FSL information and thus poison the fileserver's referral\n\
    \   information.  Therefore, an NSDB should be as secure as the\n   fileservers\
    \ that query it.  The LDAP operations described in\n   Section 5 SHOULD be secured\
    \ using the methods described above to\n   defeat attacks on an NSDB via this\
    \ channel.\n   A fileserver binds anonymously when performing NSDB operations.\n\
    \   Thus, the contents and distinguished names of FSN and FSL records are\n  \
    \ required to be readable by anyone who can bind anonymously to an NSDB\n   service.\
    \  Section 2.12 presents the security considerations in the\n   choice of the\
    \ type of UUID used in these records.\n   It should be noted that the federation\
    \ protocols do not directly\n   provide access to file system data.  The federation\
    \ protocols only\n   provide a mechanism for building a namespace.  All data transfers\n\
    \   occur between a file-access client and fileserver just as they would\n   if\
    \ the federation protocols were not in use.  As a result, the\n   federation protocols\
    \ do not require new user authentication and\n   authorization mechanisms or require\
    \ a fileserver to act as a proxy\n   for a client.\n"
- title: 7.  IANA Considerations
  contents:
  - '7.  IANA Considerations

    '
- title: 7.1.  Registry for the fedfsAnnotation Key Namespace
  contents:
  - "7.1.  Registry for the fedfsAnnotation Key Namespace\n   This document defines\
    \ the fedfsAnnotation key in Section 4.2.1.6.\n   The fedfsAnnotation key namespace\
    \ is managed by IANA.  IANA has\n   created and now maintains a new registry entitled\
    \ \"FedFS Annotation\n   Keys\".  The location of this registry is under a new\
    \ heading called\n   \"Federated File System (FedFS) Parameters\".  The URL address\
    \ is\n   <http://www.iana.org/assignments/fedfs-parameters>.\n   Future registrations\
    \ are to be administered by IANA using the \"First\n   Come First Served\" policy\
    \ defined in [RFC5226].  Registration\n   requests MUST include the key (a valid\
    \ UTF-8 string of any length), a\n   brief description of the key's purpose, and\
    \ an email contact for the\n   registration.  For viewing, the registry should\
    \ be sorted\n   lexicographically by key.  There are no initial assignments for\
    \ this\n   registry.\n"
- title: 7.2.  Registry for FedFS Object Identifiers
  contents:
  - "7.2.  Registry for FedFS Object Identifiers\n   Using the process described in\
    \ [RFC2578], one of the authors was\n   assigned the Internet Private Enterprise\
    \ Numbers range\n   1.3.6.1.4.1.31103.x.  Within this range, the subrange\n  \
    \ 1.3.6.1.4.1.31103.1.x is permanently dedicated for use by the\n   federated\
    \ file system protocols.  Unassigned OIDs in this range MAY\n   be used for Private\
    \ Use or Experimental Use as defined in [RFC5226].\n   New permanent FedFS OID\
    \ assignments MUST NOT be made using OIDs in\n   this range.\n   IANA has created\
    \ and now maintains a new registry entitled \"FedFS\n   Object Identifiers\" for\
    \ the purpose of recording the allocations of\n   FedFS Object Identifiers (OIDs)\
    \ specified by this document.  No\n   future allocations in this registry are\
    \ allowed.\n   The location of this registry is under the heading \"Federated\
    \ File\n   System (FedFS) Parameters\", created in Section 7.1.  The URL address\n\
    \   is <http://www.iana.org/assignments/fedfs-parameters>.\n   For viewing, the\
    \ registry has been sorted numerically by OID value.\n   The contents of the \"\
    FedFS Object Identifiers\" registry are given in\n   Table 1.\n   Note: A descriptor\
    \ designated below as \"historic\" reserves an OID\n   used in a past version\
    \ of the NSDB protocol.  Registering such OIDs\n   retains compatibility among\
    \ existing implementations of the NSDB\n   protocol.  This document does not otherwise\
    \ refer to historic OIDs.\n   +---------------------------+--------------------------+-----------+\n\
    \   | OID                       | Description              | Reference |\n   +---------------------------+--------------------------+-----------+\n\
    \   | 1.3.6.1.4.1.31103.1.1     | fedfsUuid                | RFC 7532  |\n   |\
    \ 1.3.6.1.4.1.31103.1.2     | fedfsNetAddr             | historic  |\n   | 1.3.6.1.4.1.31103.1.3\
    \     | fedfsNetPort             | historic  |\n   | 1.3.6.1.4.1.31103.1.4   \
    \  | fedfsFsnUuid             | RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.5     |\
    \ fedfsNsdbName            | historic  |\n   | 1.3.6.1.4.1.31103.1.6     | fedfsNsdbPort\
    \            | historic  |\n   | 1.3.6.1.4.1.31103.1.7     | fedfsNcePrefix  \
    \         | historic  |\n   | 1.3.6.1.4.1.31103.1.8     | fedfsFslUuid       \
    \      | RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.9     | fedfsFslHost          \
    \   | historic  |\n   | 1.3.6.1.4.1.31103.1.10    | fedfsFslPort             |\
    \ historic  |\n   | 1.3.6.1.4.1.31103.1.11    | fedfsFslTTL              | historic\
    \  |\n   | 1.3.6.1.4.1.31103.1.12    | fedfsAnnotation          | RFC 7532  |\n\
    \   | 1.3.6.1.4.1.31103.1.13    | fedfsDescr               | RFC 7532  |\n   |\
    \ 1.3.6.1.4.1.31103.1.14    | fedfsNceDN               | RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.15\
    \    | fedfsFsnTTL              | RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.100  \
    \ | fedfsNfsPath             | historic  |\n   | 1.3.6.1.4.1.31103.1.101   | fedfsNfsMajorVer\
    \         | historic  |\n   | 1.3.6.1.4.1.31103.1.102   | fedfsNfsMinorVer   \
    \      | historic  |\n   | 1.3.6.1.4.1.31103.1.103   | fedfsNfsCurrency      \
    \   | RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.104   | fedfsNfsGenFlagWritable  |\
    \ RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.105   | fedfsNfsGenFlagGoing     | RFC\
    \ 7532  |\n   | 1.3.6.1.4.1.31103.1.106   | fedfsNfsGenFlagSplit     | RFC 7532\
    \  |\n   | 1.3.6.1.4.1.31103.1.107   | fedfsNfsTransFlagRdma    | RFC 7532  |\n\
    \   | 1.3.6.1.4.1.31103.1.108   | fedfsNfsClassSimul       | RFC 7532  |\n   |\
    \ 1.3.6.1.4.1.31103.1.109   | fedfsNfsClassHandle      | RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.110\
    \   | fedfsNfsClassFileid      | RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.111   |\
    \ fedfsNfsClassWritever    | RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.112   | fedfsNfsClassChange\
    \      | RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.113   | fedfsNfsClassReaddir  \
    \   | RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.114   | fedfsNfsReadRank         |\
    \ RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.115   | fedfsNfsReadOrder        | RFC\
    \ 7532  |\n   | 1.3.6.1.4.1.31103.1.116   | fedfsNfsWriteRank        | RFC 7532\
    \  |\n   | 1.3.6.1.4.1.31103.1.117   | fedfsNfsWriteOrder       | RFC 7532  |\n\
    \   | 1.3.6.1.4.1.31103.1.118   | fedfsNfsVarSub           | RFC 7532  |\n   |\
    \ 1.3.6.1.4.1.31103.1.119   | fedfsNfsValidFor         | RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.120\
    \   | fedfsNfsURI              | RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.1001  |\
    \ fedfsNsdbContainerInfo   | RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.1002  | fedfsFsn\
    \                 | RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.1003  | fedfsFsl   \
    \              | RFC 7532  |\n   | 1.3.6.1.4.1.31103.1.1004  | fedfsNfsFsl   \
    \           | RFC 7532  |\n   +---------------------------+--------------------------+-----------+\n\
    \                                  Table 1\n"
- title: 7.3.  LDAP Descriptor Registration
  contents:
  - "7.3.  LDAP Descriptor Registration\n   In accordance with Sections 3.4 and 4\
    \ of [RFC4520], the object\n   identifier descriptors defined in this document\
    \ (listed below) have\n   been registered via the Expert Review process.\n   Subject:\
    \  Request for LDAP Descriptor Registration\n   Person & email address to contact\
    \ for further information:  See\n      \"Author/Change Controller\"\n   Specification:\
    \  RFC 7532\n   Author/Change Controller:  IESG (iesg@ietf.org)\n   Object Identifier:\
    \  1.3.6.1.4.1.31103.1.1\n   Descriptor (short name):  fedfsUuid\n   Usage:  attribute\
    \ type\n   Object Identifier:  1.3.6.1.4.1.31103.1.2\n   Descriptor (short name):\
    \  fedfsNetAddr\n   Usage:  attribute type (historic)\n   Object Identifier: \
    \ 1.3.6.1.4.1.31103.1.3\n   Descriptor (short name):  fedfsNetPort\n   Usage:\
    \  attribute type (historic)\n   Object Identifier:  1.3.6.1.4.1.31103.1.4\n \
    \  Descriptor (short name):  fedfsFsnUuid\n   Usage:  attribute type\n   Object\
    \ Identifier:  1.3.6.1.4.1.31103.1.5\n   Descriptor (short name):  fedfsNsdbName\n\
    \   Usage:  attribute type (historic)\n   Object Identifier:  1.3.6.1.4.1.31103.1.6\n\
    \   Descriptor (short name):  fedfsNsdbPort\n   Usage:  attribute type (historic)\n\
    \   Object Identifier:  1.3.6.1.4.1.31103.1.7\n   Descriptor (short name):  fedfsNcePrefix\n\
    \   Usage:  attribute type (historic)\n   Object Identifier:  1.3.6.1.4.1.31103.1.8\n\
    \   Descriptor (short name):  fedfsFslUuid\n   Usage:  attribute type\n   Object\
    \ Identifier:  1.3.6.1.4.1.31103.1.9\n   Descriptor (short name):  fedfsFslHost\n\
    \   Usage:  attribute type (historic)\n   Object Identifier:  1.3.6.1.4.1.31103.1.10\n\
    \   Descriptor (short name):  fedfsFslPort\n   Usage:  attribute type (historic)\n\
    \   Object Identifier:  1.3.6.1.4.1.31103.1.11\n   Descriptor (short name):  fedfsFslTTL\n\
    \   Usage:  attribute type (historic)\n   Object Identifier:  1.3.6.1.4.1.31103.1.12\n\
    \   Descriptor (short name):  fedfsAnnotation\n   Usage:  attribute type\n   Object\
    \ Identifier:  1.3.6.1.4.1.31103.1.13\n   Descriptor (short name):  fedfsDescr\n\
    \   Usage:  attribute type\n   Object Identifier:  1.3.6.1.4.1.31103.1.14\n  \
    \ Descriptor (short name):  fedfsNceDN\n   Usage:  attribute type\n   Object Identifier:\
    \  1.3.6.1.4.1.31103.1.15\n   Descriptor (short name):  fedfsFsnTTL\n   Usage:\
    \  attribute type\n   Object Identifier:  1.3.6.1.4.1.31103.1.100\n   Descriptor\
    \ (short name):  fedfsNfsPath\n   Usage:  attribute type (historic)\n   Object\
    \ Identifier:  1.3.6.1.4.1.31103.1.101\n   Descriptor (short name):  fedfsNfsMajorVer\n\
    \   Usage:  attribute type (historic)\n   Object Identifier:  1.3.6.1.4.1.31103.1.102\n\
    \   Descriptor (short name):  fedfsNfsMinorVer\n   Usage:  attribute type (historic)\n\
    \   Object Identifier:  1.3.6.1.4.1.31103.1.103\n   Descriptor (short name): \
    \ fedfsNfsCurrency\n   Usage:  attribute type\n   Object Identifier:  1.3.6.1.4.1.31103.1.104\n\
    \   Descriptor (short name):  fedfsNfsGenFlagWritable\n   Usage:  attribute type\n\
    \   Object Identifier:  1.3.6.1.4.1.31103.1.105\n   Descriptor (short name): \
    \ fedfsNfsGenFlagGoing\n   Usage:  attribute type\n   Object Identifier:  1.3.6.1.4.1.31103.1.106\n\
    \   Descriptor (short name):  fedfsNfsGenFlagSplit\n   Usage:  attribute type\n\
    \   Object Identifier:  1.3.6.1.4.1.31103.1.107\n   Descriptor (short name): \
    \ fedfsNfsTransFlagRdma\n   Usage:  attribute type\n   Object Identifier:  1.3.6.1.4.1.31103.1.108\n\
    \   Descriptor (short name):  fedfsNfsClassSimul\n   Usage:  attribute type\n\
    \   Object Identifier:  1.3.6.1.4.1.31103.1.109\n   Descriptor (short name): \
    \ fedfsNfsClassHandle\n   Usage:  attribute type\n   Object Identifier:  1.3.6.1.4.1.31103.1.110\n\
    \   Descriptor (short name):  fedfsNfsClassFileid\n   Usage:  attribute type\n\
    \   Object Identifier:  1.3.6.1.4.1.31103.1.111\n   Descriptor (short name): \
    \ fedfsNfsClassWritever\n   Usage:  attribute type\n   Object Identifier:  1.3.6.1.4.1.31103.1.112\n\
    \   Descriptor (short name):  fedfsNfsClassChange\n   Usage:  attribute type\n\
    \   Object Identifier:  1.3.6.1.4.1.31103.1.113\n   Descriptor (short name): \
    \ fedfsNfsClassReaddir\n   Usage:  attribute type\n   Object Identifier:  1.3.6.1.4.1.31103.1.114\n\
    \   Descriptor (short name):  fedfsNfsReadRank\n   Usage:  attribute type\n  \
    \ Object Identifier:  1.3.6.1.4.1.31103.1.115\n   Descriptor (short name):  fedfsNfsReadOrder\n\
    \   Usage:  attribute type\n   Object Identifier:  1.3.6.1.4.1.31103.1.116\n \
    \  Descriptor (short name):  fedfsNfsWriteRank\n   Usage:  attribute type\n  \
    \ Object Identifier:  1.3.6.1.4.1.31103.1.117\n   Descriptor (short name):  fedfsNfsWriteOrder\n\
    \   Usage:  attribute type\n   Object Identifier:  1.3.6.1.4.1.31103.1.118\n \
    \  Descriptor (short name):  fedfsNfsVarSub\n   Usage:  attribute type\n   Object\
    \ Identifier:  1.3.6.1.4.1.31103.1.119\n   Descriptor (short name):  fedfsNfsValidFor\n\
    \   Usage:  attribute type\n   Object Identifier:  1.3.6.1.4.1.31103.1.120\n \
    \  Descriptor (short name):  fedfsNfsURI\n   Usage:  attribute type\n   Object\
    \ Identifier:  1.3.6.1.4.1.31103.1.1001\n   Descriptor (short name):  fedfsNsdbContainerInfo\n\
    \   Usage:  object class\n   Object Identifier:  1.3.6.1.4.1.31103.1.1002\n  \
    \ Descriptor (short name):  fedfsFsn\n   Usage:  object class\n   Object Identifier:\
    \  1.3.6.1.4.1.31103.1.1003\n   Descriptor (short name):  fedfsFsl\n   Usage:\
    \  object class\n   Object Identifier:  1.3.6.1.4.1.31103.1.1004\n   Descriptor\
    \ (short name):  fedfsNfsFsl\n   Usage:  object class\n"
- title: 8.  Glossary
  contents:
  - "8.  Glossary\n   Administrator:  A user with the necessary authority to initiate\n\
    \      administrative tasks on one or more servers.\n   Admin Entity:  A server\
    \ or agent that administers a collection of\n      fileservers and persistently\
    \ stores the namespace information.\n   File-Access Client:  Standard off-the-shelf,\
    \ network-attached storage\n      (NAS) client software that communicates with\
    \ fileservers using a\n      standard file-access protocol.\n   Federation:  A\
    \ set of fileserver collections and singleton\n      fileservers that use a common\
    \ set of interfaces and protocols in\n      order to provide to file-access clients\
    \ a federated namespace\n      accessible through a file system access protocol.\n\
    \   Fileserver:  A server that stores physical fileset data or refers\n      file-access\
    \ clients to other fileservers.  A fileserver provides\n      access to its shared\
    \ file system data via a file-access protocol.\n   Fileset:  The abstraction of\
    \ a set of files and the directory tree\n      that contains them.  A fileset\
    \ is the fundamental unit of data\n      management in the federation.\n     \
    \ Note that all files within a fileset are descendants of one\n      directory\
    \ and that filesets do not span file systems.\n   File System:  A self-contained\
    \ unit of export for a fileserver and\n      the mechanism used to implement filesets.\
    \  The fileset does not\n      need to be rooted at the root of the file system,\
    \ nor at the\n      export point for the file system.\n      A single file system\
    \ MAY implement more than one fileset, if the\n      file-access protocol and\
    \ the fileserver permit this.\n   File-Access Protocol:  A network file system\
    \ access protocol such as\n      NFSv3 [RFC1813], NFSv4 [RFC7530], or CIFS (Common\
    \ Internet File\n      System) [MS-SMB] [MS-SMB2] [MS-CIFS].\n   FSL (Fileset\
    \ Location):  The location of the implementation of a\n      fileset at a particular\
    \ moment in time.  An FSL MUST be something\n      that can be translated into\
    \ a protocol-specific description of a\n      resource that a file-access client\
    \ can access directly, such as an\n      fs_locations attribute (for NFSv4) or\
    \ a share name (for CIFS).\n   FSN (Fileset Name):  A platform-independent and\
    \ globally unique name\n      for a fileset.  Two FSLs that implement replicas\
    \ of the same\n      fileset MUST have the same FSN, and if a fileset is migrated\
    \ from\n      one location to another, the FSN of that fileset MUST remain the\n\
    \      same.\n   Junction:  A file system object used to link a directory name\
    \ in the\n      current fileset with an object within another fileset.  The\n\
    \      server-side \"link\" from a leaf node in one fileset to the root of\n \
    \     another fileset.\n   Namespace:  A filename/directory tree that a sufficiently\
    \ authorized\n      file-access client can observe.\n   NSDB (Namespace Database)\
    \ Service:  A service that maps FSNs to FSLs.\n      The NSDB may also be used\
    \ to store other information, such as\n      annotations for these mappings and\
    \ their components.\n   NSDB Node:  The name or location of a server that implements\
    \ part of\n      the NSDB service and is responsible for keeping track of the\
    \ FSLs\n      (and related information) that implement a given partition of the\n\
    \      FSNs.\n   Referral:  A server response to a file-access client access that\n\
    \      directs the client to evaluate the current object as a reference\n    \
    \  to an object at a different location (specified by an FSL) in\n      another\
    \ fileset and possibly hosted on another fileserver.  The\n      client re-attempts\
    \ the access to the object at the new location.\n   Replica:  A redundant implementation\
    \ of a fileset.  Each replica\n      shares the same FSN but has a different FSL.\n\
    \      Replicas may be used to increase availability or performance.\n      Updates\
    \ to replicas of the same fileset MUST appear to occur in\n      the same order;\
    \ therefore, each replica is self-consistent at any\n      moment.\n      We do\
    \ not assume that updates to each replica occur\n      simultaneously.  If a replica\
    \ is offline or unreachable, the other\n      replicas may be updated.\n   Server\
    \ Collection:  A set of fileservers administered as a unit.  A\n      server collection\
    \ may be administered with vendor-specific\n      software.\n      The namespace\
    \ provided by a server collection could be part of the\n      federated namespace.\n\
    \   Singleton Server:  A server collection containing only one server; a\n   \
    \   stand-alone fileserver.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC2079]  Smith, M., \"Definition of an X.500\
    \ Attribute Type and an\n              Object Class to Hold Uniform Resource Identifiers\
    \ (URIs)\",\n              RFC 2079, January 1997,\n              <http://www.rfc-editor.org/info/rfc2079>.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC2203]  Eisler, M., Chiu, A., and L. Ling, \"RPCSEC_GSS Protocol\n    \
    \          Specification\", RFC 2203, September 1997,\n              <http://www.rfc-editor.org/info/rfc2203>.\n\
    \   [RFC2578]  McCloghrie, K., Ed., Perkins, D., Ed., and J.\n              Schoenwaelder,\
    \ Ed., \"Structure of Management Information\n              Version 2 (SMIv2)\"\
    , STD 58, RFC 2578, April 1999,\n              <http://www.rfc-editor.org/info/rfc2578>.\n\
    \   [RFC2743]  Linn, J., \"Generic Security Service Application Program\n    \
    \          Interface Version 2, Update 1\", RFC 2743, January 2000,\n        \
    \      <http://www.rfc-editor.org/info/rfc2743>.\n   [RFC2849]  Good, G., \"The\
    \ LDAP Data Interchange Format (LDIF) -\n              Technical Specification\"\
    , RFC 2849, June 2000,\n              <http://www.rfc-editor.org/info/rfc2849>.\n\
    \   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n        \
    \      10646\", STD 63, RFC 3629, November 2003,\n              <http://www.rfc-editor.org/info/rfc3629>.\n\
    \   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n   \
    \           Resource Identifier (URI): Generic Syntax\", STD 66, RFC\n       \
    \       3986, January 2005,\n              <http://www.rfc-editor.org/info/rfc3986>.\n\
    \   [RFC4122]  Leach, P., Mealling, M., and R. Salz, \"A Universally\n       \
    \       Unique IDentifier (UUID) URN Namespace\", RFC 4122, July\n           \
    \   2005, <http://www.rfc-editor.org/info/rfc4122>.\n   [RFC4510]  Zeilenga, K.,\
    \ Ed., \"Lightweight Directory Access Protocol\n              (LDAP): Technical\
    \ Specification Road Map\", RFC 4510, June\n              2006, <http://www.rfc-editor.org/info/rfc4510>.\n\
    \   [RFC4511]  Sermersheim, J., Ed., \"Lightweight Directory Access\n        \
    \      Protocol (LDAP): The Protocol\", RFC 4511, June 2006,\n              <http://www.rfc-editor.org/info/rfc4511>.\n\
    \   [RFC4512]  Zeilenga, K., Ed., \"Lightweight Directory Access Protocol\n  \
    \            (LDAP): Directory Information Models\", RFC 4512, June\n        \
    \      2006, <http://www.rfc-editor.org/info/rfc4512>.\n   [RFC4513]  Harrison,\
    \ R., Ed., \"Lightweight Directory Access Protocol\n              (LDAP): Authentication\
    \ Methods and Security Mechanisms\",\n              RFC 4513, June 2006,\n   \
    \           <http://www.rfc-editor.org/info/rfc4513>.\n   [RFC4516]  Smith, M.,\
    \ Ed. and T. Howes, \"Lightweight Directory Access\n              Protocol (LDAP):\
    \ Uniform Resource Locator\", RFC 4516, June\n              2006, <http://www.rfc-editor.org/info/rfc4516>.\n\
    \   [RFC4517]  Legg, S., Ed., \"Lightweight Directory Access Protocol\n      \
    \        (LDAP): Syntaxes and Matching Rules\", RFC 4517, June 2006,\n       \
    \       <http://www.rfc-editor.org/info/rfc4517>.\n   [RFC4519]  Sciberras, A.,\
    \ Ed., \"Lightweight Directory Access Protocol\n              (LDAP): Schema for\
    \ User Applications\", RFC 4519, June\n              2006, <http://www.rfc-editor.org/info/rfc4519>.\n\
    \   [RFC4520]  Zeilenga, K., \"Internet Assigned Numbers Authority (IANA)\n  \
    \            Considerations for the Lightweight Directory Access\n           \
    \   Protocol (LDAP)\", BCP 64, RFC 4520, June 2006,\n              <http://www.rfc-editor.org/info/rfc4520>.\n\
    \   [RFC4530]  Zeilenga, K., \"Lightweight Directory Access Protocol\n       \
    \       (LDAP) entryUUID Operational Attribute\", RFC 4530, June\n           \
    \   2006, <http://www.rfc-editor.org/info/rfc4530>.\n   [RFC5226]  Narten, T.\
    \ and H. Alvestrand, \"Guidelines for Writing an\n              IANA Considerations\
    \ Section in RFCs\", BCP 26, RFC 5226,\n              May 2008, <http://www.rfc-editor.org/info/rfc5226>.\n\
    \   [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n \
    \             Specifications: ABNF\", STD 68, RFC 5234, January 2008,\n      \
    \        <http://www.rfc-editor.org/info/rfc5234>.\n   [RFC5246]  Dierks, T. and\
    \ E. Rescorla, \"The Transport Layer Security\n              (TLS) Protocol Version\
    \ 1.2\", RFC 5246, August 2008,\n              <http://www.rfc-editor.org/info/rfc5246>.\n\
    \   [RFC5661]  Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed.,\n      \
    \        \"Network File System (NFS) Version 4 Minor Version 1\n             \
    \ Protocol\", RFC 5661, January 2010,\n              <http://www.rfc-editor.org/info/rfc5661>.\n\
    \   [RFC7530]  Haynes, T., Ed. and D. Noveck, Ed., \"Network File System\n   \
    \           (NFS) Version 4 Protocol\", RFC 7530, March 2015,\n              <http://www.rfc-editor.org/info/rfc7530>.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [AFS]      Howard, J., \"An Overview of the\
    \ Andrew File System\",\n              Proceedings of the USENIX Winter Technical\
    \ Conference ,\n              1988.\n   [MS-CIFS]  Microsoft Corporation, \"Common\
    \ Internet File System (CIFS)\n              Protocol Specification\", MS-CIFS\
    \ 24.0, May 2014.\n   [MS-SMB]   Microsoft Corporation, \"Server Message Block\
    \ (SMB)\n              Protocol Specification\", MS-SMB 43.0, May 2014.\n   [MS-SMB2]\
    \  Microsoft Corporation, \"Server Message Block (SMB) Version\n             \
    \ 2 Protocol Specification\", MS-SMB2 46.0, May 2014.\n   [RFC1813]  Callaghan,\
    \ B., Pawlowski, B., and P. Staubach, \"NFS\n              Version 3 Protocol\
    \ Specification\", RFC 1813, June 1995,\n              <http://www.rfc-editor.org/info/rfc1813>.\n\
    \   [RFC2224]  Callaghan, B., \"NFS URL Scheme\", RFC 2224, October 1997,\n  \
    \            <http://www.rfc-editor.org/info/rfc2224>.\n   [RFC3254]  Alvestrand,\
    \ H., \"Definitions for talking about\n              directories\", RFC 3254,\
    \ April 2002,\n              <http://www.rfc-editor.org/info/rfc3254>.\n   [RFC5662]\
    \  Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed.,\n              \"Network\
    \ File System (NFS) Version 4 Minor Version 1\n              External Data Representation\
    \ Standard (XDR) Description\",\n              RFC 5662, January 2010,\n     \
    \         <http://www.rfc-editor.org/info/rfc5662>.\n   [RFC5716]  Lentini, J.,\
    \ Everhart, C., Ellard, D., Tewari, R., and M.\n              Naik, \"Requirements\
    \ for Federated File Systems\", RFC 5716,\n              January 2010, <http://www.rfc-editor.org/info/rfc5716>.\n\
    \   [RFC6641]  Everhart, C., Adamson, W., and J. Zhang, \"Using DNS SRV to\n \
    \             Specify a Global File Namespace with NFS Version 4\", RFC\n    \
    \          6641, June 2012, <http://www.rfc-editor.org/info/rfc6641>.\n   [RFC7533]\
    \  Lentini, J., Tewari, R., and C. Lever, Ed.,\n              \"Administration\
    \ Protocol for Federated File Systems\", RFC\n              7533, March 2015,\n\
    \              <http://www.rfc-editor.org/info/rfc7533>.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   Daniel Ellard contributed significant parts of this document.\n\
    \   The authors and editor would like to thank Craig Everhart and Manoj\n   Naik,\
    \ who were co-authors of an earlier draft version of this\n   document.  In addition,\
    \ we would like to thank Andy Adamson, Paul\n   Lemahieu, Mario Wurzl, and Robert\
    \ Thurlow for helping to author this\n   document.\n   We would like to thank\
    \ George Amvrosiadis, Trond Myklebust, Howard\n   Chu, and Nicolas Williams for\
    \ their comments and review.\n   The editor gratefully acknowledges the IESG reviewers,\
    \ whose\n   constructive comments helped make this a much stronger document.\n\
    \   Finally, we would like to thank Andy Adamson, Rob Thurlow, and Tom\n   Haynes\
    \ for helping to get this document out the door.\n   The extract.sh shell script\
    \ and formatting conventions were first\n   described by the authors of the NFSv4.1\
    \ XDR specification [RFC5662].\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   James Lentini\n   NetApp\n   1601 Trapelo Rd, Suite 16\n\
    \   Waltham, MA  02451\n   United States\n   Phone: +1 781-768-5359\n   EMail:\
    \ jlentini@netapp.com\n   Renu Tewari\n   IBM Almaden\n   650 Harry Rd\n   San\
    \ Jose, CA  95120\n   United States\n   EMail: tewarir@us.ibm.com\n   Charles\
    \ Lever (editor)\n   Oracle Corporation\n   1015 Granger Avenue\n   Ann Arbor,\
    \ MI  48104\n   United States\n   Phone: +1 248-614-5091\n   EMail: chuck.lever@oracle.com\n"
