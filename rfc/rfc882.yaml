- title: __initial_text__
  contents:
  - "                 DOMAIN NAMES - CONCEPTS and FACILITIES\n        | This RFC introduces\
    \ domain style names, their use   |\n        | for ARPA Internet mail and host\
    \ address support,    |\n        | and the protocols and servers used to implement\
    \     |\n        | domain name facilities.                             |\n   \
    \     | This memo describes the conceptual framework of the |\n        | domain\
    \ system and some uses, but it omits many      |\n        | uses, fields, and\
    \ implementation details.  A        |\n        | complete specification of formats,\
    \ timeouts, etc.   |\n        | is presented in RFC 883, \"Domain Names -    \
    \        |\n        | Implementation and Specification\".  That RFC        |\n\
    \        | assumes that the reader is familiar with the        |\n        | concepts\
    \ discussed in this memo.                    |\n"
- title: INTRODUCTION
  contents:
  - "INTRODUCTION\n   The need for domain names\n      As applications grow to span\
    \ multiple hosts, then networks, and\n      finally internets, these applications\
    \ must also span multiple\n      administrative boundaries and related methods\
    \ of operation\n      (protocols, data formats, etc).  The number of resources\
    \ (for\n      example mailboxes), the number of locations for resources, and the\n\
    \      diversity of such an environment cause formidable problems when we\n  \
    \    wish to create consistent methods for referencing particular\n      resources\
    \ that are similar but scattered throughout the\n      environment.\n      The\
    \ ARPA Internet illustrates the size-related problems; it is a\n      large system\
    \ and is likely to grow much larger.  The need to have\n      a mapping between\
    \ host names (e.g., USC-ISIF) and ARPA Internet\n      addresses (e.g., 10.2.0.52)\
    \ is beginning to stress the existing\n      mechanisms.  Currently hosts in the\
    \ ARPA Internet are registered\n      with the Network Information Center (NIC)\
    \ and listed in a global\n      table (available as the file <NETINFO>HOSTS.TXT\
    \ on the SRI-NIC\n      host) [1].  The size of this table, and especially the\
    \ frequency\n      of updates to the table are near the limit of manageability.\
    \  What\n      is needed is a distributed database that performs the same\n  \
    \    function, and hence avoids the problems caused by a centralized\n      database.\n\
    \      The problem for computer mail is more severe.  While mail system\n    \
    \  implementers long ago recognized the impossibility of centralizing\n      \
    \                            Domain Names - Concepts and Facilities\n      mailbox\
    \ names, they have also created an increasingly large and\n      irregular set\
    \ of methods for identifying the location of a\n      mailbox.  Some of these\
    \ methods involve the use of routes and\n      forwarding hosts as part of the\
    \ mail destination address, and\n      consequently force the mail user to know\
    \ multiple address formats,\n      the capabilities of various forwarders, and\
    \ ad hoc tricks for\n      passing address specifications through intermediaries.\n\
    \      These problems have common characteristics that suggest the nature\n  \
    \    of any solution:\n         The basic need is for a consistent name space\
    \ which will be\n         used for referring to resources.  In order to avoid\
    \ the\n         problems caused by ad hoc encodings, names should not contain\n\
    \         addresses, routes, or similar information as part of the name.\n   \
    \      The sheer size of the database and frequency of updates suggest\n     \
    \    that it must be maintained in a distributed manner, with local\n        \
    \ caching to improve performance.  Approaches that attempt to\n         collect\
    \ a consistent copy of the entire database will become\n         more and more\
    \ expensive and difficult, and hence should be\n         avoided.  The same principle\
    \ holds for the structure of the\n         name space, and in particular mechanisms\
    \ for creating and\n         deleting names; these should also be distributed.\n\
    \         The costs of implementing such a facility dictate that it be\n     \
    \    generally useful, and not restricted to a single application.\n         We\
    \ should be able to use names to retrieve host addresses,\n         mailbox data,\
    \ and other as yet undetermined information.\n         Because we want the name\
    \ space to be useful in dissimilar\n         networks, it is unlikely that all\
    \ users of domain names will be\n         able to agree on the set of resources\
    \ or resource information\n         that names will be used to retrieve.  Hence\
    \ names refer to a\n         set of resources, and queries contain resource identifiers.\n\
    \         The only standard types of information that we expect to see\n     \
    \    throughout the name space is structuring information for the\n         name\
    \ space itself, and resources that are described using\n         domain names\
    \ and no nonstandard data.\n         We also want the name server transactions\
    \ to be independent of\n         the communications system that carries them.\
    \ Some systems may\n         wish to use datagrams for simple queries and responses,\
    \ and\n         only establish virtual circuits for transactions that need the\n\
    \         reliability (e.g. database updates, long transactions); other\n    \
    \     systems will use virtual circuits exclusively.\n                       \
    \           Domain Names - Concepts and Facilities\n   Elements of the solution\n\
    \      The proposed solution has three major components:\n         The DOMAIN\
    \ NAME SPACE, which is a specification for a tree\n         structured name space.\
    \  Conceptually, each node and leaf of the\n         domain name space tree names\
    \ a set of information, and query\n         operations are attempts to extract\
    \ specific types of\n         information from a particular set.  A query names\
    \ the domain\n         name of interest and describes the type of resource information\n\
    \         that is desired.  For example, the ARPA Internet uses some of\n    \
    \     its domain names to identify hosts; queries for address\n         resources\
    \ return ARPA Internet host addresses.  However, to\n         preserve the generality\
    \ of the domain mechanism, domain names\n         are not required to have a one-to-one\
    \ correspondence with host\n         names, host addresses, or any other type\
    \ of information.\n         NAME SERVERS are server programs which hold information\
    \ about\n         the domain tree's structure and set information.  A name server\n\
    \         may cache structure or set information about any part of the\n     \
    \    domain tree, but in general a particular name server has\n         complete\
    \ information about a subset of the domain space, and\n         pointers to other\
    \ name servers that can be used to lead to\n         information from any part\
    \ of the domain tree.  Name servers\n         know the parts of the domain tree\
    \ for which they have complete\n         information; these parts are called ZONEs;\
    \ a name server is an\n         AUTHORITY for these parts of the name space.\n\
    \         RESOLVERS are programs that extract information from name\n        \
    \ servers in response to user requests.  Resolvers must be able\n         to access\
    \ at least one name server and use that name server's\n         information to\
    \ answer a query directly, or pursue the query\n         using referrals to other\
    \ name servers.  A resolver will\n         typically be a system routine that\
    \ is directly accessible to\n         user programs; hence no protocol is necessary\
    \ between the\n         resolver and the user program.\n      These three components\
    \ roughly correspond to the three layers or\n      views of the domain system:\n\
    \         From the user's point of view, the domain system is accessed\n     \
    \    through simple procedure or OS calls to resolvers.  The domain\n        \
    \ space consists of a single tree and the user can request\n         information\
    \ from any section of the tree.\n         From the resolver's point of view, the\
    \ domain system is\n         composed of an unknown number of name servers.  Each\
    \ name\n         server has one or more pieces of the whole domain tree's data,\n\
    \                                  Domain Names - Concepts and Facilities\n  \
    \       but the resolver views each of these databases as essentially\n      \
    \   static.\n         From a name server's point of view, the domain system consists\n\
    \         of separate sets of local information called zones.  The name\n    \
    \     server has local copies of some of the zones.  The name server\n       \
    \  must periodically refresh its zones from master copies in local\n         files\
    \ or foreign name servers.  The name server must\n         concurrently process\
    \ queries that arrive from resolvers using\n         the local zones.\n      In\
    \ the interests of performance, these layers blur a bit.  For\n      example,\
    \ resolvers on the same machine as a name server may share\n      a database and\
    \ may also introduce foreign information for use in\n      later queries.  This\
    \ cached information is treated differently\n      from the authoritative data\
    \ in zones.\n   Database model\n      The organization of the domain system derives\
    \ from some\n      assumptions about the needs and usage patterns of its user\n\
    \      community and is designed to avoid many of the the complicated\n      problems\
    \ found in general purpose database systems.\n      The assumptions are:\n   \
    \      The size of the total database will initially be proportional\n       \
    \  to the number of hosts using the system, but will eventually\n         grow\
    \ to be proportional to the number of users on those hosts\n         as mailboxes\
    \ and other information are added to the domain\n         system.\n         Most\
    \ of the data in the system will change very slowly (e.g.,\n         mailbox bindings,\
    \ host addresses), but that the system should\n         be able to deal with subsets\
    \ that change more rapidly (on the\n         order of minutes).\n         The\
    \ administrative boundaries used to distribute responsibility\n         for the\
    \ database will usually correspond to organizations that\n         have one or\
    \ more hosts.  Each organization that has\n         responsibility for a particular\
    \ set of domains will provide\n         redundant name servers, either on the\
    \ organization's own hosts\n         or other hosts that the organization arranges\
    \ to use.\n         Clients of the domain system should be able to identify trusted\n\
    \         name servers they prefer to use before accepting referrals to\n    \
    \     name servers outside of this \"trusted\" set.\n         Access to information\
    \ is more critical than instantaneous\n                                  Domain\
    \ Names - Concepts and Facilities\n         updates or guarantees of consistency.\
    \  Hence the update process\n         allows updates to percolate out though the\
    \ users of the domain\n         system rather than guaranteeing that all copies\
    \ are\n         simultaneously updated.  When updates are unavailable due to\n\
    \         network or host failure, the usual course is to believe old\n      \
    \   information while continuing efforts to update it.  The general\n        \
    \ model is that copies are distributed with timeouts for\n         refreshing.\
    \  The distributor sets the timeout value and the\n         recipient of the distribution\
    \ is responsible for performing the\n         refresh.  In special situations,\
    \ very short intervals can be\n         specified, or the owner can prohibit copies.\n\
    \         Some users will wish to access the database via datagrams;\n       \
    \  others will prefer virtual circuits.  The domain system is\n         designed\
    \ so that simple queries and responses can use either\n         style, although\
    \ refreshing operations need the reliability of\n         virtual circuits.  The\
    \ same overall message format is used for\n         all communication.  The domain\
    \ system does not assume any\n         special properties of the communications\
    \ system, and hence\n         could be used with any datagram or virtual circuit\
    \ protocol.\n         In any system that has a distributed database, a particular\n\
    \         name server may be presented with a query that can only be\n       \
    \  answered by some other server.  The two general approaches to\n         dealing\
    \ with this problem are \"recursive\", in which the first\n         server pursues\
    \ the query for the client at another server, and\n         \"iterative\", in\
    \ which the server refers the client to another\n         server and lets the\
    \ client pursue the query.  Both approaches\n         have advantages and disadvantages,\
    \ but the iterative approach\n         is preferred for the datagram style of\
    \ access.  The domain\n         system requires implementation of the iterative\
    \ approach, but\n         allows the recursive approach as an option.  The optional\n\
    \         recursive style is discussed in [14], and omitted from further\n   \
    \      discussion in this memo.\n      The domain system assumes that all data\
    \ originates in master files\n      scattered through the hosts that use the domain\
    \ system.  These\n      master files are updated by local system administrators.\
    \  Master\n      files are text files that are read by a local name server, and\n\
    \      hence become available to users of the domain system.  A standard\n   \
    \   format for these files is given in [14].\n      The standard format allows\
    \ these files to be exchanged between\n      hosts (via FTP, mail, or some other\
    \ mechanism); this facility is\n      useful when an organization wants a domain,\
    \ but doesn't want to\n      support a name server.  The organization can maintain\
    \ the master\n      files locally using a text editor, transfer them to a foreign\
    \ host\n      which runs a name server, and then arrange with the system\n   \
    \   administrator of the name server to get the files loaded.\n              \
    \                    Domain Names - Concepts and Facilities\n      Each host's\
    \ name servers and resolvers are configured by a local\n      system administrator.\
    \  For a name server, this configuration data\n      includes the identity of\
    \ local master files and instructions on\n      which non-local master files are\
    \ to be loaded from foreign\n      servers.  The name server uses the master files\
    \ or copies to load\n      its zones.  For resolvers, the configuration data identifies\
    \ the\n      name servers which should be the primary sources of information.\n\
    \      The domain system defines procedures for accessing the data and\n     \
    \ for referrals to other name servers.  The domain system also\n      defines\
    \ procedures for caching retrieved data and for periodic\n      refreshing of\
    \ data defined by the system administrator.\n      The system administrators provide:\n\
    \         The definition of zone boundaries\n         Master files of data\n \
    \        Updates to master files\n         Statements of the refresh policies\
    \ desired\n      The domain system provides:\n         Standard formats for resource\
    \ data\n         Standard methods for querying the database\n         Standard\
    \ methods for name servers to refresh local data from\n         foreign name servers\n"
- title: DOMAIN NAME SPACE
  contents:
  - "DOMAIN NAME SPACE\n   Name space specifications and terminology\n      The domain\
    \ name space is a tree structure.  Each node and leaf on\n      the tree corresponds\
    \ to a resource set (which may be empty).  Each\n      node and leaf has an associated\
    \ label.  Labels are NOT guaranteed\n      to be unique, with the exception of\
    \ the root node, which has a\n      null label.  The domain name of a node or\
    \ leaf is the path from\n      the root of the tree to the node or leaf.  By convention,\
    \ the\n      labels that compose a domain name are read left to right, from the\n\
    \      most specific (lowest) to the least specific (highest).\n      Internally,\
    \ programs that manipulate domain names represent them\n      as sequences of\
    \ labels, where each label is a length octet\n      followed by an octet string.\
    \  Because all domain names end at the\n      root, which has a null string for\
    \ a label, these internal\n                                  Domain Names - Concepts\
    \ and Facilities\n      representations can use a length byte of zero to terminate\
    \ a\n      domain name.  When domain names are printed, labels in a path are\n\
    \      separated by dots (\".\").  The root label and its associated dot\n   \
    \   are omitted from printed domain names, but the root can be named\n      by\
    \ a null domain name (\" \" in this memo).\n      To simplify implementations,\
    \ the total number of octets that\n      represent label octets and label lengths\
    \ is limited to 255.  Thus\n      a printed domain name can be up to 254 characters.\n\
    \      A special label is defined that matches any other label.  This\n      label\
    \ is the asterisk or \"*\".  An asterisk matches a single label.\n      Thus *.ARPA\
    \ matches FOO.ARPA, but does not match FOO.BAR.ARPA.\n      The asterisk is mainly\
    \ used to create default resource records at\n      the boundary between protocol\
    \ families, and requires prudence in\n      its use.\n      A domain is identified\
    \ by a domain name, and consists of that part\n      of the domain name space\
    \ that is at or below the domain name which\n      specifies the domain.  A domain\
    \ is a subdomain of another domain\n      if it is contained within that domain.\
    \  This relationship can be\n      tested by seeing if the subdomain's name has\
    \ the containing\n      domain's name as the right part of its name.  For example,\
    \ A.B.C.D\n      is a subdomain of B.C.D, C.D, D, and \" \".\n      This tree\
    \ structure is intended to parallel the administrative\n      organization and\
    \ delegation of authority.  Potentially, each node\n      or leaf on the tree\
    \ can create new subdomains ad infinitum.  In\n      practice, this delegation\
    \ can be limited by the administrator of\n      the name servers that manage the\
    \ domain space and resource data.\n      The following figure shows an example\
    \ of a domain name space.\n                                   |              \
    \              \n                +------------------+------------------+     \
    \    \n                |                  |                  |         \n    \
    \          COLORS            FLAVORS             TRUTH       \n              \
    \  |                  |                            \n          +-----+-----+ \
    \           |                            \n          |     |     |         NATURAL\
    \                         \n         RED  BLUE  GREEN          |             \
    \               \n                                   |                       \
    \     \n                   +---------------+---------------+            \n   \
    \                |               |               |            \n             \
    \  CHOCOLATE        VANILLA        STRAWBERRY       \n      In this example, the\
    \ root domain has three immediate subdomains:\n      COLORS, FLAVORS, and TRUTH.\
    \  The FLAVORS domain has one immediate\n      subdomain named NATURAL.FLAVORS.\
    \  All of the leaves are also\n                                  Domain Names\
    \ - Concepts and Facilities\n      domains.  This domain tree has the names \"\
    \ \"(the root), COLORS,\n      RED.COLORS, BLUE.COLORS, GREEN.COLORS, FLAVORS,\
    \ NATURAL.FLAVORS,\n      CHOCOLATE.NATURAL.FLAVORS, VANILLA.NATURAL.FLAVORS,\n\
    \      STRAWBERRY.NATURAL.FLAVORS, and TRUTH.  If we wished to add a new\n   \
    \   domain of ARTIFICIAL under FLAVORS, FLAVORS would typically be the\n     \
    \ administrative entity that would decide; if we wished to create\n      CHIP\
    \ and MOCHA names under CHOCOLATE, CHOCOLATE.NATURAL.FLAVORS\n      would typically\
    \ be the appropriate administrative entity.\n   Resource set information\n   \
    \   A domain name identifies a set of resource information.  The set\n      of\
    \ resource information associated with a particular name is\n      composed of\
    \ separate resource records (RRs).\n      Each resource record has the following\
    \ major components:\n         The domain name which identifies resource set that\
    \ holds this\n         record, and hence the \"owner\" of the information.  For\
    \ example,\n         a RR that specifies a host address has a domain name the\n\
    \         specifies the host having that address.  Thus F.ISI.ARPA might\n   \
    \      be the owner of a RR which specified an address field of\n         10.2.0.52.\
    \  Since name servers typically store their resource\n         information in\
    \ tree structures paralleling the organization of\n         the domain space,\
    \ this information can usually be stored\n         implicitly in the database;\
    \ however it is always included in\n         each resource record carried in a\
    \ message.\n         Other information used to manage the RR, such as length fields,\n\
    \         timeouts, etc.  This information is omitted in much of this\n      \
    \   memo, but is discussed in [14].\n         A resource type field that specifies\
    \ the type of the resource\n         in this resource record.  Types refer to\
    \ abstract resources\n         such as host addresses or mail delivery agents.\
    \  The type field\n         is two octets long and uses an encoding that is standard\n\
    \         throughout the domain name system.\n         A class field identifies\
    \ the format of the resource data, such\n         as the ARPA Internet format\
    \ (IN) or the Computer Science\n         Network format (CSNET), for certain RR\
    \ types (such as address\n         data).  Note that while the class may separate\
    \ different\n         protocol families, networks, etc. it does not do so in all\n\
    \         cases.  For example, the IN class uses 32 bit IP addresses\n       \
    \  exclusively, but the CSNET class uses 32 bit IP addresses, X.25\n         addresses,\
    \ and phone numbers.  Thus the class field should be\n         used as a guide\
    \ for interpreting the resource data.  The class\n         field is two octets\
    \ long and uses an encoding that is standard\n         throughout the domain name\
    \ system.\n                                  Domain Names - Concepts and Facilities\n\
    \         Resource data that describes the resource.  The format of this\n   \
    \      data can be determined given the type and class fields, but\n         always\
    \ starts with a two octet length field that allows a name\n         server or\
    \ resolver to determine the boundaries of the resource\n         data in any transaction,\
    \ even if it cannot \"understand\" the\n         resource data itself.  Thus name\
    \ servers and resolvers can hold\n         and pass on records which they cannot\
    \ interpret.  The format of\n         the internal data is restricted only by\
    \ the maximum length of\n         65535 octets; for example the host address record\
    \ might specify\n         a fixed 32 bit number for one class, and a variable\
    \ length list\n         of addresses in another class.\n      While the class\
    \ field in effect partitions the resource data in\n      the domain name system\
    \ into separate parallel sections according\n      to class, services can span\
    \ class boundaries if they use\n      compatible resource data formats.  For example,\
    \ the domain name\n      system uses compatible formats for structure information,\
    \ and the\n      mail data decouples mail agent identification from details of\
    \ how\n      to contact the agent (e.g. host addresses).\n      This memo uses\
    \ the following types in its examples:\n         A     - the host address associated\
    \ with the domain name\n         MF    - identifies a mail forwarder for the domain\n\
    \         MD    - identifies a mail destination for the domain\n         NS  \
    \  - the authoritative name server for the domain\n         SOA   - identifies\
    \ the start of a zone of authority\n         CNAME - identifies the canonical\
    \ name of an alias\n      This memo uses the following classes in its examples:\n\
    \         IN - the ARPA Internet system\n         CS - the CSNET system\n    \
    \  The first type of resource record holds a host name to host\n      address\
    \ binding.  Its fields are:\n  +--------+--------+--------+--------------//----------------------+\n\
    \  |<owner> |   A    | <class>| <class specific address>information  |\n  +--------+--------+--------+--------------//----------------------+\n\
    \                                  Domain Names - Concepts and Facilities\n  \
    \    The content of the class specific information varies according to\n     \
    \ the value in the CLASS field; for the ARPA Internet, it is the 32\n      bit\
    \ ARPA Internet address of the host, for the CSNET it might be\n      the phone\
    \ number of the host.  For example, F.ISI.ARPA might have\n      two A records\
    \ of the form:\n       +----------+--------+--------+----------------------------+\n\
    \       |F.ISI.ARPA|   A    |   IN   |          10.2.0.52         |\n       +----------+--------+--------+----------------------------+\n\
    \                                  and\n       +----------+--------+--------+----------------------------+\n\
    \       |F.ISI.ARPA|   A    |   CS   |         213-822-2112       |\n       +----------+--------+--------+----------------------------+\n\
    \      Note that the data formats for the A type are class dependent, and\n  \
    \    the Internet address and phone number formats shown above are for\n     \
    \ purposes of illustration only.  The actual data formats are\n      specified\
    \ in [14].  For example, CS class data for type A records\n      might actually\
    \ be a list of Internet addresses, phone numbers and\n      TELENET addresses.\n\
    \      The mail forwarder (MF) and mail delivery (MD) records have the\n     \
    \ following format:\n        +--------+--------+--------+----------------------------+\n\
    \        |<owner> | MD/MF  | <class>|       <domain name>        |\n        +--------+--------+--------+----------------------------+\n\
    \      The <domain name> field is a domain name of the host that will\n      handle\
    \ mail; note that this domain name may be completely\n      different from the\
    \ domain name which names the resource record.\n      For example, F.ISI.ARPA\
    \ might have two records of the form:\n       +----------+--------+--------+----------------------------+\n\
    \       |F.ISI.ARPA|  MD    |   IN   |         F.ISI.ARPA         |\n       +----------+--------+--------+----------------------------+\n\
    \                                  and\n       +----------+--------+--------+----------------------------+\n\
    \       |F.ISI.ARPA|  MF    |   IN   |         B.ISI.ARPA         |\n       +----------+--------+--------+----------------------------+\n\
    \      These records mean that mail for F.ISI.ARPA can either be\n      delivered\
    \ to the host F.ISI.ARPA or forwarded to B.ISI.ARPA, which\n      will accept\
    \ responsibility for its eventual delivery.  In\n      principle, an additional\
    \ name lookup is required to map the domain\n      name of the host to the appropriate\
    \ address, in practice this\n      information is usually returned in the response\
    \ to the mail query.\n      The SOA and NS types of resource records are used\
    \ to define limits\n                                  Domain Names - Concepts\
    \ and Facilities\n      of authority.  The domain name given by the owner field\
    \ of a SOA\n      record is the start of a zone; the domain name given by the\
    \ owner\n      field of a NS record identifies a point in the name space where\n\
    \      authority has been delegated, and hence marks the zone boundary.\n    \
    \  Except in the case where a name server delegates authority to\n      itself,\
    \ the SOA identifies the top limit of authority, and NS\n      records define\
    \ the first name outside of a zone.  These resource\n      records have a standard\
    \ format for all of the name space:\n      +----------+--------+--------+-----------------------------+\n\
    \      | <owner>  |   SOA  | <class>|       <domain name, etc>    |\n      +----------+--------+--------+-----------------------------+\n\
    \      +----------+--------+--------+-----------------------------+\n      | <owner>\
    \  |   NS   | <class>|       <domain name>         |\n      +----------+--------+--------+-----------------------------+\n\
    \      The SOA record marks the start of a zone when it is present in a\n    \
    \  database; the NS record both marks the end of a zone started by an\n      SOA\
    \ (if a higher SOA is present) and also points to a name server\n      that has\
    \ a copy of the zone specified by the <owner. field of the\n      NS record.\n\
    \      The <domain name, etc> in the SOA record specifies the original\n     \
    \ source of the information in the zone and other information used\n      by name\
    \ servers to organize their activities.  SOA records are\n      never cached (otherwise\
    \ they would create false zones); they can\n      only be created in special name\
    \ server maintenance operations.\n      The NS record says that a name server\
    \ which is authoritative for\n      records of the given CLASS can be found at\
    \ <domain name>.\n   Queries\n      Queries to a name server must include a domain\
    \ name which\n      identifies the target resource set (QNAME), and the type and\
    \ class\n      of desired resource records.  The type and class fields in a query\n\
    \      can include any of the corresponding type and class fields that\n     \
    \ are defined for resource records; in addition, the query type\n      (QTYPE)\
    \ and query class (QCLASS) fields may contain special values\n      that match\
    \ more than one of the corresponding fields in RRs.\n      For example, the QTYPE\
    \ field may contain:\n         MAILA - matches all mail agent RRs (e.g. MD and\
    \ MF).\n         *     - matches any RR type.\n                              \
    \    Domain Names - Concepts and Facilities\n      The QCLASS field may contain:\n\
    \         *    - matches any RR class.\n      Using the query domain name, QTYPE,\
    \ and QCLASS, the name server\n      looks for matching RRs.  In addition to relevant\
    \ records, the name\n      server may return RRs that point toward a name server\
    \ that has the\n      desired information or RRs that are expected to be useful\
    \ in\n      interpreting the relevant RRs.  For example a name server that\n \
    \     doesn't have the requested information may know a name server that\n   \
    \   does; a name server that returns a domain name in a relevant RR\n      may\
    \ also return the RR that binds that domain name to an address.\n      Note that\
    \ the QCLASS=* construct requires special interpretation\n      regarding authority.\
    \  Since a name server may not know all of the\n      classes available in the\
    \ domain system, it can never know if it is\n      authoritative for all classes.\
    \  Hence responses to QCLASS=*\n      queries can never be authoritative.\n  \
    \ Example space\n      For purposes of exposition, the following name space is\
    \ used for\n      the remainder of this memo:\n                              \
    \      |                            \n                 +------------------+------------------+\
    \         \n                 |                  |                  |         \n\
    \                DDN               ARPA               CSNET       \n         \
    \        |                  |                  |         \n           +-----+-----+\
    \            |            +-----+-----+   \n           |     |     |         \
    \   |            |           |   \n          JCS  ARMY  NAVY           |     \
    \      UDEL        UCI  \n                                    |              \
    \              \n           +--------+---------------+---------------+--------+\
    \   \n           |        |               |               |        |   \n    \
    \      DTI      MIT             ISI             UDEL     NBS  \n             \
    \       |               |                            \n                +---+---+\
    \       +---+---+                        \n                |       |       | \
    \  |   |                        \n               DMS     AI       A   B   F  \
    \                      \n                                  Domain Names - Concepts\
    \ and Facilities\n"
- title: NAME SERVERS
  contents:
  - "NAME SERVERS\n   Introduction\n      Name servers store a distributed database\
    \ consisting of the\n      structure of the domain name space, the resource sets\
    \ associated\n      with domain names, and other information used to coordinate\n\
    \      actions between name servers.\n      In general, a name server will be\
    \ an authority for all or part of\n      a particular domain.  The region covered\
    \ by this authority is\n      called a zone.  Name servers may be responsible\
    \ for no\n      authoritative data, and hence have no zones, or may have several\n\
    \      zones.  When a name server has multiple zones, the zones may have\n   \
    \   no common borders or zones may be contiguous.\n      While administrators\
    \ should not construct overlapping zones, and\n      name servers must defend\
    \ against overlapping zones, overlapping is\n      regarded as a non-fatal flaw\
    \ in the database.  Hence the measures\n      taken to protect against it are\
    \ omitted for the remainder of this\n      memo.  A detailed discussion can be\
    \ found in [14].\n      When presented with a query for a domain name over which\
    \ it has\n      authority, a name server returns the desired resource information\n\
    \      or an indication that the query refers to a domain name or\n      resource\
    \ that does not exist.  If a name server is presented with\n      a query for\
    \ a domain name that is not within its authority, it may\n      have the desired\
    \ information, but it will also return a response\n      that points toward an\
    \ authoritative name server.  If a name server\n      is not an authority for\
    \ a query, it can never return a negative\n      response.\n      There is no\
    \ requirement that a name server for a domain reside in\n      a host which has\
    \ a name in the same domain, although this will\n      usually be the case.  There\
    \ is also no restriction on the number\n      of name servers that can have authority\
    \ over a particular domain;\n      most domains will have redundant authoritative\
    \ name servers.  The\n      assumption is that different authoritative copies\
    \ are identical,\n      even though inconsistencies are possible as updates are\
    \ made.\n      Name server functions are designed to allow for very simple\n \
    \     implementations of name servers.  The simplest name server has a\n     \
    \ static set of information and uses datagrams to receive queries\n      and return\
    \ responses.\n      More sophisticated name server implementations can improve\
    \ the\n      performance of their clients by caching information from other\n\
    \      domains.  Although this information can be acquired in a number of\n  \
    \    ways, the normal method is to store the information acquired by a\n     \
    \                             Domain Names - Concepts and Facilities\n      resolver\
    \ when the resolver consults other name servers.  In a\n      sophisticated host,\
    \ the resolver and name server will coordinate\n      their actions and use a\
    \ shared database.  This cooperation\n      requires the incorporation of a time-to-live\
    \ (TTL) field in all\n      cached resource records.  Caching is discussed in\
    \ the resolver\n      section of this memo; this section is devoted to the actions\
    \ of a\n      name servers that don't cache.\n      In order to free simple name\
    \ servers of the requirement of\n      managing these timeouts, simple name servers\
    \ should only contain\n      resource records that are expected to remain constant\
    \ over very\n      long periods or resource records for which the name server\
    \ is an\n      authority.  In the following discussion, the TTL field is assumed\n\
    \      to be stored in the resource record but is omitted in descriptions\n  \
    \    of databases and responses in the interest of clarity.\n   Authority and\
    \ administrative control of domains\n      Although we want to have the potential\
    \ of delegating the\n      privileges of name space management at every node,\
    \ we don't want\n      such delegation to be required.\n      Hence we introduce\
    \ the concept of authority.  Authority is vested\n      in name servers.  A name\
    \ server has authority over all of its\n      domain until it delegates authority\
    \ for a subdomain to some other\n      name server.\n      Any administrative\
    \ entity that wishes to establish its own domain\n      must provide a name server,\
    \ and have that server accepted by the\n      parent name server (i.e. the name\
    \ server that has authority over\n      the place in the domain name space that\
    \ will hold the new domain).\n      While the principles of authority allow acceptance\
    \ to be at the\n      discretion of parent name servers, the following criteria\
    \ are used\n      by the root, and are recommended to all name servers because\
    \ they\n      are responsible for their children's actions:\n         1.  It must\
    \ register with the parent administrator of domains.\n         2.  It must identify\
    \ a responsible person.\n         3.  In must provide redundant name servers.\n\
    \      The domain name must be registered with the administrator to avoid\n  \
    \    name conflicts and to make the domain related information\n      available\
    \ to other domains.  The central administrator may have\n      further requirements,\
    \ and a domain is not registered until the\n      central administrator agrees\
    \ that all requirements are met.\n      There must be a responsible person associated\
    \ with each domain to\n                                  Domain Names - Concepts\
    \ and Facilities\n      be a contact point for questions about the domain, to\
    \ verify and\n      update the domain related information, and to resolve any\
    \ problems\n      (e.g., protocol violations) with hosts in the domain.\n    \
    \  The domain must provide redundant (i.e., two or more) name servers\n      to\
    \ provide the name to address resolution service.  These name\n      servers must\
    \ be accessible from outside the domain (as well as\n      inside) and must resolve\
    \ names for at least all the hosts in the\n      domain.\n      Once the central\
    \ administrator is satisfied, he will communicate\n      the existence to the\
    \ appropriate administrators of other domains\n      so that they can incorporate\
    \ NS records for the new name server\n      into their databases.\n   Name server\
    \ logic\n      The processing steps that a name server performs in responding\
    \ to\n      a query are conceptually simple, although implementations may have\n\
    \      internal databases that are quite complex.\n      For purposes of explanation,\
    \ we assume that the query consists of\n      a type QTYPE, a class QCLASS, and\
    \ a domain name QNAME; we assume\n      that the name server stores its RRs in\
    \ sets where each set has all\n      of the RRs for a particular domain.  Note\
    \ that this database\n      structure and the following algorithms are meant to\
    \ illustrate one\n      possible implementation, rather than a specification of\
    \ how all\n      servers must be implemented.\n      The following notation is\
    \ used:\n      ord(DOMAIN-NAME)     returns the number of labels in DOMAIN-NAME.\n\
    \      findset(DOMAIN-NAME) returns a pointer to the set of stored RRs\n     \
    \                      for DOMAIN-NAME, or NULL if there is no such\n        \
    \                   information.\n      set(POINTER)         refers to a set located\
    \ previously by\n                           findset, where POINTER is the value\
    \ returned\n                           by findset.\n      relevant(QTYPE,TYPE)\
    \ returns true if a RR of the specified TYPE is\n                           relevant\
    \ to the specified QTYPE.  For\n                           example, relevant(MAILA,MF)\
    \ is true and\n                           relevant(MAILA,NS) is false.\n     \
    \ right(NAME,NUMBER)   returns a domain name that is the rightmost\n         \
    \                  NUMBER labels in the string NAME.\n                       \
    \           Domain Names - Concepts and Facilities\n      copy(RR)           \
    \  copies the resource record specified by RR\n                           into\
    \ the response.\n      The name server code could be represented as the following\n\
    \      sequence of steps:\n     {    find out whether the database makes this\
    \ server          \n          authoritative for the domain name specified by QNAME\
    \   } \n     for i:=0 to ord(QNAME) { sequence through all nodes in QNAME }\n\
    \     do   begin                                                    \n       \
    \   ptr:=findset(right(QNAME,i));                            \n          if ptr<>NULL\
    \                                             \n          then { there is domain\
    \ data for this domain name }       \n               begin                   \
    \                            \n               for all RRs in set(ptr)        \
    \                     \n               do   if type(RR)=NS and class(RR)=QCLASS\
    \            \n                    then begin                                \
    \     \n                         auth=false;                               \n\
    \                         NSptr:=ptr                                \n       \
    \                  end;                                      \n              \
    \ for all RRs in set(ptr)                             \n               do   if\
    \ type(RR)=SOA and class(RR)=QCLASS           \n                    then auth:=true\
    \                                \n                    end                   \
    \                         \n               end;                              \
    \                  \n           end;                                         \
    \           \n      {    copy out authority search results }                 \
    \    \n      if auth                                                      \n \
    \     then { if authority check for domain found }                 \n        \
    \   if ptr=null                                             \n           then\
    \ return(Name error)                                 \n           else       \
    \                                             \n      else { if not authority,\
    \ copy NS RRs }                       \n           for all RRs in set(nsptr) \
    \                              \n           do   if (type(RR)=NS and class(RR)=QCLASS)\
    \              \n                                 or                         \
    \       \n                              (QCLASS=*)                           \n\
    \                then copy(RR);                                     \n      {\
    \    Copy all RRs that answer the question }                 \n      for all RRs\
    \ in set(ptr)                                      \n      do   if class(RR)=QCLASS\
    \ and relevant(QTYPE,type(RR))        \n           then copy(RR);            \
    \                              \n      The first section of the code (delimited\
    \ by the for loop over all\n                                  Domain Names - Concepts\
    \ and Facilities\n      of the subnodes of QNAME) discovers whether the name server\
    \ is\n      authoritative for the domain specified by QNAME.  It sequences\n \
    \     through all containing domains of QNAME, starting at the root.  If\n   \
    \   it encounters a SOA it knows that the name server is authoritative\n     \
    \ unless it finds a lower NS RR which delegates authority.  If the\n      name\
    \ server is authoritative, it sets auth=true; if the name\n      server is not\
    \ authoritative, it sets NSptr to point to the set\n      which contains the NS\
    \ RR closest to the domain specified by QNAME.\n      The second section of the\
    \ code reflects the result of the\n      authority search into the response. \
    \ If the name server is\n      authoritative, the code checks to see that the\
    \ domain specified by\n      QNAME exists; if not, a name error is returned. \
    \ If the name\n      server is not authoritative, the code copies the RRs for\
    \ a closer\n      name server into the response.\n      The last section of the\
    \ code copies all relevant RRs into the\n      response.\n      Note that this\
    \ code is not meant as an actual implementation and\n      is incomplete in several\
    \ aspects.  For example, it doesn't deal\n      with providing additional information,\
    \ wildcards, QCLASS=*, or\n      with overlapping zones.  The first two of these\
    \ issues are dealt\n      with in the following discussions, the remaining issues\
    \ are\n      discussed in [14].\n   Additional information\n      When a resolver\
    \ returns information to a user program, the\n      returned information will\
    \ often lead to a second query.  For\n      example, if a mailer asks a resolver\
    \ for the appropriate mail\n      agent for a particular domain name, the name\
    \ server queried by the\n      resolver returns a domain name that identifies\
    \ the agent.  In\n      general, we would expect that the mailer would then request\
    \ the\n      domain name to address binding for the mail agent, and a new name\n\
    \      server query would result.\n      To avoid this duplication of effort,\
    \ name servers return\n      additional information with a response which satisfies\
    \ the\n      anticipated query.  This information is kept in a separate section\n\
    \      of the response.  Name servers are required to complete the\n      appropriate\
    \ additional information if such information is\n      available, but the requestor\
    \ should not depend on the presence of\n      the information since the name server\
    \ may not have it.  If the\n      resolver caches the additional information,\
    \ it can respond to the\n      second query without an additional network transaction.\n\
    \      The appropriate information is defined in [14], but generally\n       \
    \                           Domain Names - Concepts and Facilities\n      consists\
    \ of host to address bindings for domain names in returned\n      RRs.\n   Aliases\
    \ and canonical names\n      In existing systems, hosts and other resources often\
    \ have several\n      names that identify the same resource.  For example, under\
    \ current\n      ARPA Internet naming support, USC-ISIF and ISIF both identify\
    \ the\n      same host.  Similarly, in the case of mailboxes, many\n      organizations\
    \ provide many names that actually go to the same\n      mailbox; for example\
    \ Mockapetris@ISIF, Mockapetris@ISIB, etc., all\n      go to the same mailbox\
    \ (although the mechanism behind this is\n      somewhat complicated).\n     \
    \ Most of these systems have a notion that one of the equivalent set\n      of\
    \ names is the canonical name and all others are aliases.\n      The domain system\
    \ provides a similar feature using the canonical\n      name (CNAME) RR.  When\
    \ a name server fails to find a desired RR in\n      a set associated with some\
    \ domain name, it checks to see if the\n      resource set contains a CNAME record\
    \ with a matching class.  If\n      so, the name server includes the CNAME record\
    \ in the response, and\n      continues the query at the domain name specified\
    \ in the data field\n      of the CNAME record.\n      Suppose a name server was\
    \ processing a query with QNAME=ISIF.ARPA,\n      QTYPE=A, and QCLASS=IN, and\
    \ had the following resource records:\n            ISIF.ARPA     CNAME   IN  \
    \   F.ISI.ARPA         \n            F.ISI.ARPA    A       IN     10.2.0.52  \
    \        \n      Both of these RRs would be returned in the response.\n      In\
    \ the above example, because ISIF.ARPA has no RRs other than the\n      CNAME\
    \ RR, the resources associated with ISIF.ARPA will appear to\n      be exactly\
    \ those associated with F.ISI.ARPA for the IN CLASS.\n      Since the CNAME is\
    \ effective only when the search fails, a CNAME\n      can also be used to construct\
    \ defaults.  For example, suppose the\n      name server had the following set\
    \ of RRs:\n            F.ISI.ARPA    A       IN     10.2.0.52          \n    \
    \        F.ISI.ARPA    MD      IN     F.ISI.ARPA         \n            XXXX.ARPA\
    \     CNAME   IN     F.ISI.ARPA         \n            XXXX.ARPA     MF      IN\
    \     A.ISI.ARPA         \n      Using this database, type A queries for XXXX.ARPA\
    \ would return the\n      XXXX.ARPA CNAME RR and the F.ISI.ARPA A RR, but MAILA\
    \ or MF\n      queries to XXXX.ARPA would return the XXXX.ARPA MF RR without any\n\
    \      information from F.ISI.ARPA.  This structure might be used to send\n  \
    \                                Domain Names - Concepts and Facilities\n    \
    \  mail addressed to XXXX.ARPA to A.ISI.ARPA and to direct TELNET for\n      XXXX.ARPA\
    \ to F.ISI.ARPA.\n   Wildcards\n      In certain cases, an administrator may wish\
    \ to associate default\n      resource information for all or part of a domain.\
    \  For example,\n      the CSNET domain administrator may wish to establish IN\
    \ class mail\n      forwarding for all hosts in the CSNET domain without IN\n\
    \      capability.  In such a case, the domain system provides a special\n   \
    \   label \"*\" that matches any other label.  Note that \"*\" matches\n     \
    \ only a single label, and not zero or more than one label.  Note\n      also\
    \ that the \"*\" is distinct from the \"*\" values for QCLASS and\n      QTYPE.\n\
    \      The semantics of \"*\" depend upon whether it appears in a query\n    \
    \  domain name (QNAME) or in a RR in a database.\n         When an \"*\" is used\
    \ in a QNAME, it can only match a \"*\" in a\n         resource record.\n    \
    \     When \"*\" appears in a RR in a database, it can never override\n      \
    \   an existing exact match.  For example, if a name server\n         received\
    \ a query for the domain UDEL.CSNET, and had appropriate\n         RRs for both\
    \ UDEL.CSNET and *.CSNET, the UDEL.CSNET RRs would\n         be used and the *.CSNET\
    \ RRs would be ignored.  If a query to\n         the same database specified FOO.CSNET,\
    \ the *.CSNET RR would be\n         used, but the corresponding labels from the\
    \ QNAME would replace\n         the \"*\".  Thus the FOO.CSNET query would match\
    \ the *.CSNET RR\n         and return a RR for FOO.CSNET rather than *.CSNET.\n\
    \         RRs containing \"*\" labels are copied exactly when zones are\n    \
    \     transfered via name server maintenance operations.\n      These semantics\
    \ are easily implemented by having the name server\n      first search for an\
    \ exact match for a query, and then replacing\n      the leftmost label with a\
    \ \"*\" and trying again, repeating the\n      process until all labels became\
    \ \"*\" or the search succeeded.\n      TYPE=* in RRs is prohibited.  If it were\
    \ to be allowed, the\n      requestor would have no way of interpreting the data\
    \ in the RR\n      because this data is type dependent.\n      CLASS=* is also\
    \ prohibited.  Similar effects can be achieved using\n      QCLASS=*, and allowing\
    \ both QCLASS=* and CLASS=* leads to\n      complexities without apparent benefit.\n\
    \                                  Domain Names - Concepts and Facilities\n  \
    \ A scenario\n      In our sample domain space, suppose we wanted separate\n \
    \     administrative control for the root, DDN, ARPA, CSNET, MIT and ISI\n   \
    \   domains.  We might allocate name servers as follows:\n                   \
    \                |(B.ISI.ARPA)                  \n                           \
    \        |(UDEL.CSNET)                  \n                +------------------+------------------+\
    \           \n                |                  |                  |        \
    \   \n               DDN               ARPA               CSNET         \n   \
    \             |(JCS.DDN)         |(F.ISI.ARPA)      |(UDEL.ARPA)\n          +-----+-----+\
    \            |(A.ISI.ARPA)+-----+-----+     \n          |     |     |        \
    \    |            |           |     \n         JCS  ARMY  NAVY           |   \
    \        UDEL        UCI    \n                                   |           \
    \                   \n          +--------+---------------+---------------+--------+\
    \     \n          |        |               |               |        |     \n \
    \        DTI      MIT             ISI             UDEL     NBS    \n         \
    \          |(AI.MIT.ARPA)  |(F.ISI.ARPA)                  \n               +---+---+\
    \       +---+---+                          \n               |       |       |\
    \   |   |                          \n              DMS     AI       A   B   F\
    \                          \n      In this example the authoritative name server\
    \ is shown in\n      parentheses at the point in the domain tree at which is assumes\n\
    \      control.\n      Thus the root name servers are on B.ISI.ARPA and UDEL.CSNET,\
    \ the\n      DDN name server is on JCS.DDN, the CSNET domain server is on\n  \
    \    UDEL.ARPA, etc.\n      In an actual system, all domains should have redundant\
    \ name\n      servers, but in this example only the ARPA domain has redundant\n\
    \      servers A.ISI.ARPA and F.ISI.ARPA.  (The B.ISI.ARPA and UDEL.CSNET\n  \
    \    name servers happen to be not redundant because they handle\n      different\
    \ classes.)  The F.ISI.ARPA name server has authority over\n      the ARPA domain,\
    \ but delegates authority over the MIT.ARPA domain\n      to the name server on\
    \ AI.MIT.ARPA.  The A.ISI.ARPA name server\n      also has authority over the\
    \ ARPA domain, but delegates both the\n      ISI.ARPA and MIT.ARPA domains to\
    \ other name servers.\n                                  Domain Names - Concepts\
    \ and Facilities\n   B.ISI.ARPA Name server for \" \"\n      B.ISI.ARPA has the\
    \ root name server for the IN class.  Its\n      database might contain:\n   \
    \         Domain        Resource Record                   \n            \" \"\
    \           SOA     IN     A.ISI.ARPA         \n            DDN           NS \
    \     IN     JCS.DDN            \n            ARPA          NS      IN     F.ISI.ARPA\
    \         \n            CSNET         NS      IN     UDEL.ARPA          \n   \
    \         \" \"           NS      IN     B.ISI.ARPA         \n            \" \"\
    \           NS      CS     UDEL.CSNET         \n            JCS.DDN       A  \
    \     IN     9.0.0.1            \n            F.ISI.ARPA    A       IN     10.2.0.52\
    \          \n            UDEL.CSNET    A       CS     302-555-0000       \n  \
    \          UDEL.ARPA     A       IN     10.0.0.96          \n      The SOA record\
    \ for the root is necessary so that the name server\n      knows that it is authoritative\
    \ for the root domain for class IN.\n      The contents of the SOA resource record\
    \ point back to A.ISI.ARPA\n      and denote that the master data for the zone\
    \ of authority is\n      originally from this host.  The first three NS records\
    \ denote\n      delegation of authority.  The NS root entry for the B.ISI.ARPA\n\
    \      name server is necessary so that this name server knows about\n      itself,\
    \ and can respond correctly to a query for NS information\n      about the root\
    \ (for which it is an authority).  The root entry for\n      class CS denotes\
    \ that UDEL.CSNET is the authoritative name server\n      for the CS class root.\
    \  UDEL.CSNET and UDEL.ARPA may or may not\n      refer to the same name server;\
    \ from this information it is\n      impossible to tell.\n      If this name server\
    \ was sent a query specifying QTYPE=MAILA,\n      QCLASS=IN, QNAME=F.ISI.ARPA,\
    \ it would begin processing (using the\n      previous algorithm) by determining\
    \ that it was not an authority\n      for F.ISI.ARPA.  The test would note that\
    \ it had authority at \" \",\n      but would also note that the authority was\
    \ delegated at ARPA and\n      never reestablished via another SOA.  Thus the\
    \ response would\n      return the NS record for the domain ARPA.\n      Any queries\
    \ presented to this server with QCLASS=CS would result\n      in the UDEL.CSNET\
    \ NS record being returned in the response.\n                                \
    \  Domain Names - Concepts and Facilities\n   F.ISI.ARPA Name server for ARPA\
    \ and ISI.ARPA\n      In the same domain space, the F.ISI.ARPA database for the\
    \ domains\n      ARPA and ISI.ARPA might be:\n            Domain        Resource\
    \ Record                   \n            \" \"           NS      IN     B.ISI.ARPA\
    \         \n            \" \"           NS      CS     CSNET.UDEL         \n \
    \           ARPA          SOA     IN     B.ISI.ARPA         \n            ARPA\
    \          NS      IN     A.ISI.ARPA         \n            ARPA          NS  \
    \    IN     F.ISI.ARPA         \n            MIT.ARPA      NS      IN     AI.MIT.ARPA\
    \        \n            ISI.ARPA      SOA     IN     F.ISI.ARPA         \n    \
    \        ISI.ARPA      NS      IN     F.ISI.ARPA         \n            A.ISI.ARPA\
    \    MD      IN     A.ISI.ARPA         \n            ISI.ARPA      MD      IN\
    \     F.ISI.ARPA         \n            A.ISI.ARPA    MF      IN     F.ISI.ARPA\
    \         \n            B.ISI.ARPA    MD      IN     B.ISI.ARPA         \n   \
    \         B.ISI.ARPA    MF      IN     F.ISI.ARPA         \n            F.ISI.ARPA\
    \    MD      IN     F.ISI.ARPA         \n            F.ISI.ARPA    MF      IN\
    \     A.ISI.ARPA         \n            DTI.ARPA      MD      IN     DTI.ARPA \
    \          \n            NBS.ARPA      MD      IN     NBS.ARPA           \n  \
    \          UDEL.ARPA     MD      IN     UDEL.ARPA          \n            A.ISI.ARPA\
    \    A       IN     10.1.0.32          \n            F.ISI.ARPA    A       IN\
    \     10.2.0.52          \n            B.ISI.ARPA    A       IN     10.3.0.52\
    \          \n            DTI.ARPA      A       IN     10.0.0.12          \n  \
    \          AI.MIT.ARPA   A       IN     10.2.0.6           \n            DMS.MIT.ARPA\
    \  A       IN     10.1.0.6           \n            NBS.ARPA      A       IN  \
    \   10.0.0.19          \n            UDEL.ARPA     A       IN     10.0.0.96  \
    \        \n      For the IN class, the SOA RR for ARPA denotes that this name\n\
    \      server is authoritative for the domain ARPA, and that the master\n    \
    \  file for this authority is stored on B.ISI.ARPA.  This zone\n      extends\
    \ to ISI.ARPA, where the database delegates authority back\n      to this name\
    \ server in another zone, and doesn't include the\n      domain MIT.ARPA, which\
    \ is served by a name server on AI.MIT.ARPA.\n      This name server is not authoritative\
    \ for any data in the CS\n      class.  It has a pointer to the root server for\
    \ CS data which\n      could be use to resolve CS class queries.\n      Suppose\
    \ this name server received a query of the form\n      QNAME=A.ISI.ARPA, QTYPE=A,\
    \ and QCLASS=IN.  The authority search\n                                  Domain\
    \ Names - Concepts and Facilities\n      would notice the NS record for \" \"\
    , its SOA at ARPA, a delegation\n      at ISI.ARPA, and the reassumption of authority\
    \ at ISI.ARPA.  Hence\n      it would know that it was an authority for this query.\
    \  It would\n      then find the A record for A.ISI.ARPA, and return a datagram\n\
    \      containing this record.\n      Another query might be QNAME=B.ISI.ARPA,\
    \ QTYPE=MAILA, QCLASS=*.\n      In this case the name server would know that it\
    \ cannot be\n      authoritative because of the \"*\" value of QCLASS, and would\
    \ look\n      for records for domain B.ISI.ARPA that match.  Assuming that the\n\
    \      name server performs the additional record inclusion mentioned in\n   \
    \   the name server algorithm, the returned datagram would include:\n        \
    \    ISI.ARPA      NS      IN     F.ISI.ARPA         \n            \" \"     \
    \      NS      CS     UDEL.CSNET         \n            B.ISI.ARPA    MD      IN\
    \     B.ISI.ARPA         \n            B.ISI.ARPA    MF      IN     F.ISI.ARPA\
    \         \n            B.ISI.ARPA    A       IN     10.3.0.52          \n   \
    \         F.ISI.ARPA    A       IN     10.2.0.52          \n      If the query\
    \ were QNAME=DMS.MIT.ARPA, QTYPE=MAILA, QCLASS=IN, the\n      name server would\
    \ discover that AI.MIT.ARPA was the authoritative\n      name server and return\
    \ the following:\n            MIT.ARPA      NS      IN     AI.MIT.ARPA       \
    \ \n            AI.MIT.ARPA   A       IN     10.2.0.6           \n      In this\
    \ case, the requestor is directed to seek information from\n      the MIT.ARPA\
    \ domain name server residing on AI.MIT.ARPA.\n                              \
    \    Domain Names - Concepts and Facilities\n   UDEL.ARPA and UDEL.CSNET name\
    \ server\n      In the previous discussion of the sample domain, we stated that\n\
    \      UDEL.CSNET and UDEL.ARPA might be the same name server.  In this\n    \
    \  example, we assume that this is the case.  As such, the name\n      server\
    \ is an authority for the root for class CS, and an authority\n      for the CSNET\
    \ domain for class IN.\n      This name server deals with mail forwarding between\
    \ the ARPA\n      Internet and CSNET systems.  Its RRs illustrate one approach\
    \ to\n      solving this problem.  The name server has the following resource\n\
    \      records:\n            \" \"           SOA     CS     UDEL.CSNET       \
    \  \n            \" \"           NS      CS     UDEL.CSNET         \n        \
    \    \" \"           NS      IN     B.ISI.ARPA         \n            CSNET   \
    \      SOA     IN     UDEL.ARPA          \n            CSNET         NS      IN\
    \     UDEL.ARPA          \n            ARPA          NS      IN     A.ISI.ARPA\
    \         \n            *.CSNET       MF      IN     UDEL.ARPA          \n   \
    \         UDEL.CSNET    MD      CS     UDEL.CSNET         \n            UCI.CSNET\
    \     MD      CS     UCI.CSNET          \n            UDEL.ARPA     MD      IN\
    \     UDEL.ARPA          \n            B.ISI.ARPA    A       IN     10.3.0.52\
    \          \n            UDEL.ARPA     A       IN     10.0.0.96          \n  \
    \          UDEL.CSNET    A       CS     302-555-0000       \n            UCI.CSNET\
    \     A       CS     714-555-0000       \n      Suppose this name server received\
    \ a query of the form\n      QNAME=UCI.CSNET, QTYPE=MAILA, and QCLASS=IN.  The\
    \ name server\n      would discover it was authoritative for the CSNET domain\
    \ under\n      class IN, but would find no explicit mail data for UCI.CSNET.\n\
    \      However, using the *.CSNET record, it would construct a reply:\n      \
    \      UCI.CSNET     MF      IN     UDEL.ARPA          \n            UDEL.ARPA\
    \     A       IN     10.0.0.96          \n      If this name server received a\
    \ query of the form QNAME=UCI.CSNET,\n      QTYPE=MAILA, and QCLASS=CS, the name\
    \ server would return:\n            UCI.CSNET     MD      CS     UCI.CSNET   \
    \       \n            UCI.CSNET     A       CS     714-555-0000       \n     \
    \ Note that although this scheme allows for forwarding of all mail\n      addressed\
    \ as <anything>.CSNET, it doesn't help with names that\n      have more than two\
    \ components, e.g. A.B.CSNET.  Although this\n      problem could be \"fixed\"\
    \ by a series of MF entries for *.*.CSNET,\n                                 \
    \ Domain Names - Concepts and Facilities\n      *.*.*.CSNET, etc, a more tasteful\
    \ solution would be to introduce a\n      cleverer pattern matching algorithm\
    \ in the CSNET name server.\n   Summary of requirements for name servers\n   \
    \   The requirements for a name server are as follows:\n         1. It must be\
    \ recognized by its parent.\n         2. It must have complete resource information\
    \ for all domain\n            names for which it is the authority.\n         3.\
    \ It must periodically refresh authoritative information from\n            a master\
    \ file or name server which holds the master.\n         4. If it caches information\
    \ it must also handle TTL management\n            for that information.\n    \
    \     5. It must answer simple queries.\n   Inverse queries\n      Name servers\
    \ may also support inverse queries that map a\n      particular resource to a\
    \ domain name or domain names that have\n      that resource.  For example, while\
    \ a query might map a domain name\n      to a host address, the corresponding\
    \ inverse query might map the\n      address back to the domain name.\n      Implementation\
    \ of this service is optional in a name server, but\n      all name servers must\
    \ at least be able to understand an inverse\n      query message and return an\
    \ error response.\n      The domain system cannot guarantee the completeness or\
    \ uniqueness\n      of inverse queries because the domain system is organized\
    \ by\n      domain name rather than by host address or any other resource\n  \
    \    type.  In general, a resolver or other program that wishes to\n      guarantee\
    \ that an inverse query will work must use a name server\n      that is known\
    \ to have the appropriate data, or ask all name\n      servers in a domain of\
    \ interest.\n      For example, if a resolver wishes to perform an inverse query\
    \ for\n      an arbitrary host on the ARPA Internet, it must consult a set of\n\
    \      name servers sufficient to know that all IN data was considered.\n    \
    \  In practice, a single inverse query to a name server that has a\n      fairly\
    \ comprehensive database should satisfy the vast majority of\n      inverse queries.\n\
    \      A detailed discussion of inverse queries is contained in [14].\n      \
    \                            Domain Names - Concepts and Facilities\n   Completion\
    \ services\n      Some existing systems provide the ability to complete partial\n\
    \      specifications of arguments.  The general principle is that the\n     \
    \ user types the first few characters of the argument and then hits\n      an\
    \ escape character to prompt the system to complete the rest.\n      Some completion\
    \ systems require that the user type enough of the\n      argument to be unique;\
    \ others do not.\n      Other systems allow the user to specify one argument and\
    \ ask the\n      system to fill in other arguments.  For example, many mail systems\n\
    \      allow the user to specify a username without a host for local mail\n  \
    \    delivery.\n      The domain system defines name server completion transactions\
    \ that\n      perform the analogous service for the domain system.\n      Implementation\
    \ of this service is optional in a name server, but\n      all name servers must\
    \ at least be able to understand a completion\n      request and return an error\
    \ response.\n      When a resolver wishes to request a completion, it sends a\
    \ name\n      server a message that sets QNAME to the partial string, QTYPE to\n\
    \      the type of resource desired, and QCLASS to the desired class.\n      The\
    \ completion request also includes a RR for the target domain.\n      The target\
    \ domain RR identifies the preferred location of the\n      resource.  In completion\
    \ requests, QNAME must still have a null\n      label to terminate the name, but\
    \ its presence is ignored.  Note\n      that a completion request is not a query,\
    \ but shares some of the\n      same field formats.\n      For example, a completion\
    \ request might contain QTYPE=A, QNAME=B,\n      QCLASS=IN and a RR for ISI.ARPA.\
    \  This request asks for completion\n      for a resource whose name begins with\
    \ \"B\" and is \"close\" to\n      ISI.ARPA.  This might be a typical shorthand\
    \ used in the ISI\n      community which uses \"B\" as a way of referring to B.ISI.ARPA.\n\
    \      The first step in processing a completion request is to look for a\n  \
    \    \"whole label\" match.  When the name server receives the request\n     \
    \ mentioned above, it looks at all records that are of type A, class\n      IN,\
    \ and whose domain name starts (on the left) with the labels of\n      QNAME,\
    \ in this case, \"B\".  If multiple records match, the name\n      server selects\
    \ those whose domain names match (from the right) the\n      most labels of the\
    \ preferred domain name.  If there are still\n      multiple candidates, the name\
    \ server selects the records that have\n      the shortest (in terms of octets\
    \ in the name) domain name.  If\n      several records remain, then the name server\
    \ returns them all.\n      If no records are found in the previous algorithm,\
    \ the name server\n      assumes that the rightmost label in QNAME is not complete,\
    \ and\n                                  Domain Names - Concepts and Facilities\n\
    \      looks for records that match but require addition of characters to\n  \
    \    the rightmost label of QNAME.  For example, the previous search\n      would\
    \ not match BB.ARPA to B, but this search would.  If multiple\n      hits are\
    \ found, the same discarding strategy is followed.\n      A detailed discussion\
    \ of completion can be found in [14].\n"
- title: RESOLVERS
  contents:
  - "RESOLVERS\n   Introduction\n      Resolvers are programs that interface user\
    \ programs to domain name\n      servers.  In the simplest case, a resolver receives\
    \ a request from\n      a user program (e.g. mail programs, TELNET, FTP) in the\
    \ form of a\n      subroutine call, system call etc., and returns the desired\n\
    \      information in a form compatible with the local host's data\n      formats.\n\
    \      Because a resolver may need to consult several name servers, the\n    \
    \  amount of time that a resolver will take to complete can vary.\n      This\
    \ variance is part of the justification for the split between\n      name servers\
    \ and resolvers; name servers may use datagrams and\n      have a response time\
    \ that is essentially equal to network delay\n      plus a short service time,\
    \ while resolvers may take an essentially\n      indeterminate amount of time.\n\
    \      We expect to see two types of resolvers: simple resolvers that can\n  \
    \    chain through multiple name servers when required, and more\n      complicated\
    \ resolvers that cache resource records for use in\n      future queries.\n  \
    \ Simple resolvers\n      A simple resolver needs the following capabilities:\n\
    \      1. It must know how to access a name server, and should know the\n    \
    \     authoritative name server for the host that it services.\n      2. It must\
    \ know the protocol capabilities for its clients so that\n         it can set\
    \ the class fields of the queries it sends to return\n         information that\
    \ is useful to its clients.  If the resolver\n         serves a client that has\
    \ multiple protocol capabilities, it\n         should be able to support the preferences\
    \ of the client.\n         The resolver for a multiple protocol client can either\
    \ collect\n         information for all classes using the * class value, or iterate\n\
    \         on the classes supported by the client.  Note that in either\n     \
    \    case, the resolver must understand the preferences of the host.\n       \
    \  For example, the host that supports both CSNET and ARPA\n                 \
    \                 Domain Names - Concepts and Facilities\n         Internet protocols\
    \ might prefer mail delivery (MD) to mail\n         forwarding (MF), regardless\
    \ of protocol, or might prefer one\n         protocol regardless of whether MD\
    \ or MF is required.  Care is\n         required to prevent loops.\n      3. The\
    \ resolver must be capable of chaining through multiple name\n         servers\
    \ to get to an authoritative name server for any query.\n         The resolver\
    \ should guard against loops in referrals; a simple\n         policy is to discard\
    \ referrals that don't match more of the\n         query name than the referring\
    \ name server, and also to avoid\n         querying the same name server twice\
    \ (This test should be done\n         using addresses of name servers instead\
    \ of domain names to\n         avoid problems when a name server has multiple\
    \ domain names or\n         errors are present in aliases).\n      4. The resolver\
    \ must be able to try alternate name servers when a\n         name server doesn't\
    \ respond.\n      5. The resolver must be able to communicate different failure\n\
    \         conditions to its client.  These failure conditions include\n      \
    \   unknown domain name, unknown resource for a know domain name,\n         and\
    \ inability to access any of the authoritative name servers\n         for a domain.\n\
    \      6. If the resolver uses datagrams for queries, it must recover\n      \
    \   from lost and duplicate datagrams.\n   Resolvers with cache management\n \
    \     Caching provides a tool for improving the performance of name\n      service,\
    \ but also is a potential source of incorrect results.  For\n      example, a\
    \ database might cache information that is later changed\n      in the authoritative\
    \ name servers.  While this problem can't be\n      eliminated without eliminating\
    \ caching, it can be reduced to an\n      infrequent problem through the use of\
    \ timeouts.\n      When name servers return resource records, each record has\
    \ an\n      associated time-to-live (TTL) field.  This field is expressed in\n\
    \      seconds, and has 16 bits of significance.\n      When a resolver caches\
    \ a returned resource record it must also\n      remember the TTL field.  The\
    \ resolver must discard the record when\n      the equivalent amount of time has\
    \ passed.  If the resolver shares\n      a database with a name server, it must\
    \ decrement the TTL field of\n      imported records periodically rather than\
    \ simply deleting the\n      record.  This strategy is necessary to avoid exporting\
    \ a resource\n      record whose TTL field doesn't reflect the amount of time\
    \ that the\n      resource record has been cached.  Of course, the resolver should\n\
    \                                  Domain Names - Concepts and Facilities\n  \
    \    not decrement the TTL fields of records for which the associated\n      name\
    \ server is an authority.\n                                  Domain Names - Concepts\
    \ and Facilities\n"
- title: Appendix 1 - Domain Name Syntax Specification
  contents:
  - "Appendix 1 - Domain Name Syntax Specification\n   The preferred syntax of domain\
    \ names is given by the following BNF\n   rules.  Adherence to this syntax will\
    \ result in fewer problems with\n   many applications that use domain names (e.g.,\
    \ mail, TELNET).  Note\n   that some applications described in [14] use domain\
    \ names containing\n   binary information and hence do not follow this syntax.\n\
    \      <domain> ::=  <subdomain> | \" \"\n      <subdomain> ::=  <label> | <subdomain>\
    \ \".\" <label>\n      <label> ::= <letter> [ [ <ldh-str> ] <let-dig> ]\n    \
    \  <ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>\n      <let-dig-hyp>\
    \ ::= <let-dig> | \"-\"\n      <let-dig> ::= <letter> | <digit>\n      <letter>\
    \ ::= any one of the 52 alphabetic characters A through Z\n      in upper case\
    \ and a through z in lower case\n      <digit> ::= any one of the ten digits 0\
    \ through 9\n   Note that while upper and lower case letters are allowed in domain\n\
    \   names no significance is attached to the case.  That is, two names\n   with\
    \ the same spelling but different case are to be treated as if\n   identical.\n\
    \   The labels must follow the rules for ARPANET host names.  They must\n   start\
    \ with a letter, end with a letter or digit, and have as interior\n   characters\
    \ only letters, digits, and hyphen.  There are also some\n   restrictions on the\
    \ length.  Labels must be 63 characters or less.\n   For example, the following\
    \ strings identify hosts in the ARPA\n   Internet:\n      F.ISI.ARPA     LINKABIT-DCN5.ARPA\
    \     UCL-TAC.ARPA\n                                  Domain Names - Concepts\
    \ and Facilities\n"
- title: REFERENCES and BIBLIOGRAPHY
  contents:
  - "REFERENCES and BIBLIOGRAPHY\n   [1]  E. Feinler, K. Harrenstien, Z. Su, and V.\
    \ White, \"DOD Internet\n        Host Table Specification\", RFC 810, Network\
    \ Information Center,\n        SRI International, March 1982.\n   [2]  J. Postel,\
    \ \"Computer Mail Meeting Notes\", RFC 805,\n        USC/Information Sciences\
    \ Institute, February 1982.\n   [3]  Z. Su, and J. Postel, \"The Domain Naming\
    \ Convention for Internet\n        User Applications\", RFC 819, Network Information\
    \ Center, SRI\n        International, August 1982.\n   [4]  Z. Su, \"A Distributed\
    \ System for Internet Name Service\",\n        RFC 830, Network Information Center,\
    \ SRI International,\n        October 1982.\n   [5]  K. Harrenstien, and V. White,\
    \ \"NICNAME/WHOIS\", RFC 812, Network\n        Information Center, SRI International,\
    \ March 1982.\n   [6]  M. Solomon, L. Landweber, and D. Neuhengen, \"The CSNET\
    \ Name\n        Server\", Computer Networks, vol 6, nr 3, July 1982.\n   [7] \
    \ K. Harrenstien, \"NAME/FINGER\", RFC 742, Network Information\n        Center,\
    \ SRI International, December 1977.\n   [8]  J. Postel, \"Internet Name Server\"\
    , IEN 116, USC/Information\n        Sciences Institute, August 1979.\n   [9] \
    \ K. Harrenstien, V. White, and E. Feinler, \"Hostnames Server\",\n        RFC\
    \ 811, Network Information Center, SRI International,\n        March 1982.\n \
    \  [10] J. Postel, \"Transmission Control Protocol\", RFC 793,\n        USC/Information\
    \ Sciences Institute, September 1981.\n   [11] J. Postel, \"User Datagram Protocol\"\
    , RFC 768, USC/Information\n        Sciences Institute, August 1980.\n   [12]\
    \ J. Postel, \"Simple Mail Transfer Protocol\", RFC 821,\n        USC/Information\
    \ Sciences Institute, August 1980.\n   [13] J. Reynolds, and J. Postel, \"Assigned\
    \ Numbers\", RFC 870,\n        USC/Information Sciences Institute, October 1983.\n\
    \   [14] P. Mockapetris, \"Domain Names - Implementation and\n        Specification\"\
    , RFC 883, USC/Information Sciences Institute,\n        November 1983.\n"
