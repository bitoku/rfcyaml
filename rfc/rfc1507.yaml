- title: __initial_text__
  contents:
  - '              Distributed Authentication Security Service

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard.  Discussion and\n  \
    \ suggestions for improvement are requested.  Please refer to the\n   current\
    \ edition of the \"Internet Official Protocol Standards\" for the\n   standardization\
    \ state and status of this protocol.  Distribution of\n   this memo is unlimited.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n    1.   Introduction ................................................\
    \ 2\n         1.1  What is DASS? .......................................... 2\n\
    \         1.2  Central Concepts ....................................... 4\n  \
    \       1.3  What This Document Won't Tell You ..................... 11\n    \
    \     1.4  The Relationship between DASS and ISO Standards ....... 17\n      \
    \   1.5  An Authentication Walkthrough ......................... 20\n    2.  \
    \ Services Used .............................................. 25\n         2.1\
    \  Time Service .......................................... 25\n         2.2  Random\
    \ Numbers ........................................ 26\n         2.3  Naming Service\
    \ ........................................ 26\n    3.   Services Provided ..........................................\
    \ 37\n         3.1  Certificate Contents .................................. 38\n\
    \         3.2  Encrypted Private Key Structure ....................... 40\n  \
    \       3.3  Authentication Tokens ................................. 40\n    \
    \     3.4  Credentials ........................................... 43\n      \
    \   3.5  CA State .............................................. 47\n        \
    \ 3.6  Data types used in the routines ....................... 47\n         3.7\
    \  Error conditions ...................................... 49\n         3.8  Certificate\
    \ Maintenance Functions ..................... 49\n         3.9  Credential Maintenance\
    \ Functions ...................... 55\n         3.10 Authentication Procedures\
    \ ............................. 63\n         3.11 DASSlessness Determination Functions\
    \ .................. 87\n    4.   Certificate and message formats ............................\
    \ 89\n         4.1  ASN.1 encodings ....................................... 89\n\
    \         4.2  Encoding Rules ........................................ 96\n  \
    \       4.3  Version numbers and forward compatibility ............. 96\n    \
    \     4.4  Cryptographic Encodings ............................... 97\n    Annex\
    \ A - Typical Usage ........................................ 101\n         A.1\
    \  Creating a CA ........................................ 101\n         A.2  Creating\
    \ a User Principal ............................ 102\n         A.3  Creating a\
    \ Server Principal .......................... 103\n         A.4  Booting a Server\
    \ Principal ........................... 103\n         A.5  A user logs on to the\
    \ network ........................ 103\n         A.6  An Rlogin (TCP/IP) connection\
    \ is made ................ 104\n         A.7  A Transport-Independent Connection\
    \ ................... 104\n    Annex B - Support of the GSSAPI ................................\
    \ 104\n         B.1  Summary of GSSAPI .................................... 105\n\
    \         B.2  Implementation of GSSAPI over DASS ................... 106\n  \
    \       B.3  Syntax ............................................... 110\n    Annex\
    \ C - Imported ASN.1 definitions ........................... 112\n    Glossary\
    \ ....................................................... 114\n   Security Considerations\
    \ ......................................... 119\n   Author's Address ................................................\
    \ 119\n   Figures\n    Figure 1 - Authentication Exchange Overview ....................\
    \  24\n"
- title: 1. Introduction
  contents:
  - '1. Introduction

    '
- title: 1.1 What is DASS?
  contents:
  - "1.1 What is DASS?\n   Authentication is a security service. The goal of authentication\
    \ is\n   to reliably learn the name of the originator of a message or request.\n\
    \   The classic way by which people authenticate to computers (and by\n   which\
    \ computers authenticate to one another) is by supplying a\n   password.  There\
    \ are a number of problems with existing password\n   based schemes which DASS\
    \ attempts to solve.  The goal of DASS is to\n   provide authentication services\
    \ in a distributed environment which\n   are both more secure (more difficult\
    \ for a bad guy to impersonate a\n   good guy) and easier to use than existing\
    \ mechanisms.\n   In a distributed environment, authentication is particularly\n\
    \   challenging.  Users do not simply log on to one machine and use\n   resources\
    \ there.  Users start processes on one machine which may\n   request services\
    \ on another.  In some cases, the second system must\n   request services from\
    \ a third system on behalf of the user.  Further,\n   given current network technology,\
    \ it is fairly easy to eavesdrop on\n   conversations between computers and pick\
    \ up any passwords that might\n   be going by.\n   DASS uses cryptographic mechanisms\
    \ to provide \"strong, mutual\"\n   authentication.  Mutual authentication means\
    \ that the two parties\n   communicating each reliably learn the name of the other.\
    \  Strong\n   authentication means that in the exchange neither obtains any\n\
    \   information that it could use to impersonate the other to a third\n   party.\
    \  This can't be done with passwords alone.  Mutual\n   authentication can be\
    \ done with passwords by having a \"sign\" and a\n   \"counter-sign\" which the\
    \ two parties must utter to assure one another\n   of their identities.  But whichever\
    \ party speaks first reveals\n   information which can be used by the second (unauthenticated)\
    \ party\n   to impersonate it.  Longer sequences (often seen in spy movies)\n\
    \   cannot solve the problem in general.  Further, anyone who can\n   eavesdrop\
    \ on the conversation can impersonate either party in a\n   subsequent conversation\
    \ (unless passwords are only good once).\n   Cryptography provides a means whereby\
    \ one can prove knowledge of a\n   secret without revealing it.  People cannot\
    \ execute cryptographic\n   algorithms in their heads, and thus cannot strongly\
    \ authenticate to\n   computers directly.  DASS lays the groundwork for \"smart\
    \ cards\":\n   microcomputers sealed in credit cards which when activated by a\
    \ PIN\n   will strongly authenticate to a computer.  Until smart cards are\n \
    \  available, the first link from a user to a DASS node remains\n   vulnerable\
    \ to eavesdropping.  DASS mechanisms are constructed so that\n   after the initial\
    \ authentication, smart card or password based\n   authentication looks the same.\n\
    \   Today, systems are constructed to think of user identities in terms\n   of\
    \ accounts on individual computers.  If I have accounts on ten\n   machines, there\
    \ is no way a priori to see that those ten accounts all\n   belong to the same\
    \ individual.  If I want to be able to access a\n   resource through any of the\
    \ ten machines, I must tell the resource\n   about all ten accounts.  I must also\
    \ tell the resource when I get an\n   eleventh account.\n   DASS supports the\
    \ concept of global identity and network login.  A\n   user is assigned a name\
    \ from a global namespace and that name will be\n   recognized by any node in\
    \ the network.  (In some cases, a resource\n   may be configured as accessible\
    \ only by a particular user acting\n   through a particular node.  That is an\
    \ access control decision, and\n   it is supported by DASS, but the user is still\
    \ known by his global\n   identity).  From a practical point of view, this means\
    \ that a user\n   can have a single password (or smart card) which can be used\
    \ on all\n   systems which allow him access and access control mechanisms can\n\
    \   conveniently give access to a user through any computer the user\n   happens\
    \ to be logged into.  Because a single user secret is good on\n   all systems,\
    \ it should never be necessary for a user to enter a\n   password other than at\
    \ initial login.  Because cryptographic\n   mechanisms are used, the password\
    \ should never appear on the network\n   beyond the initial login node.\n   DASS\
    \ was designed as a component of the Distributed System Security\n   Architecture\
    \ (DSSA) (see \"The Digital Distributed System Security\n   Architecture\" by\
    \ M. Gasser, A. Goldstein, C. Kaufman, and B. Lampson,\n   1989 National Computer\
    \ Security Conference).  It is a goal of DSSA\n   that access control on all systems\
    \ be based on users' global names\n   and the concept of \"accounts\" on computers\
    \ eventually be replaced\n   with unnamed rights to execute processes on those\
    \ computers.  Until\n   this happens, computers will continue to support the concept\
    \ of\n   \"local accounts\" and access controls on resources on those systems\n\
    \   will still be based on those accounts.  There is today within the\n   Berkeley\
    \ rtools running over the Internet Protocol suite the concept\n   of a \".rhosts\
    \ database\" which gives access to local accounts from\n   remote accounts.  We\
    \ envision that those databases will be extended\n   to support granting access\
    \ to local accounts based on DASS global\n   names as a bridge between the past\
    \ and the future.  DASS should\n   greatly simplify the administration of those\
    \ databases for the\n   (presumably common) case where a user should be granted\
    \ access to an\n   account ignoring his choice of intermediate systems.\n"
- title: 1.2 Central Concepts
  contents:
  - '1.2 Central Concepts

    '
- title: 1.2.1 Strong Authentication with Public Keys
  contents:
  - "1.2.1 Strong Authentication with Public Keys\n   DASS makes heavy use of the\
    \ RSA Public Key cryptosystem.  The\n   important properties of the RSA algorithms\
    \ for purposes of this\n   discussion are:\n    - It supports the creation of\
    \ a public/private key pair, where\n      operations with one key of the pair\
    \ reverse the operations of\n      the other, but it is computationally infeasible\
    \ to derive the\n      private key from the public key.\n    - It supports the\
    \ \"signing\" of a message with the private key,\n      after which anyone knowing\
    \ the public key can \"verify\" the\n      signature and know that it was constructed\
    \ with knowledge of\n      the private key and that the message was not subsequently\n\
    \      altered.\n    - It supports the \"enciphering\" of a message by anyone\
    \ knowing\n      the public key such that only someone with knowledge of the\n\
    \      private key can recover the message.\n   With access to the RSA algorithms,\
    \ it is easy to see how one could\n   construct a \"strong\" authentication mechanism.\
    \  Each \"principal\"\n   (user or computer) would construct a public/private\
    \ key pair, publish\n   the public key, and keep secret the private key.  To authenticate\
    \ to\n   you, I would write a message, sign it with my private key, and send\n\
    \   it to you.  You would verify the message using my public key and know\n  \
    \ the message came from me.  If mutual authentication were desired, you\n   could\
    \ create an acknowledgment and sign it with your private key; I\n   could verify\
    \ it with your public key and I would know you received my\n   message.\n   The\
    \ authentication algorithms used by DASS are considerably more\n   complex than\
    \ those described in the paragraph above in order to deal\n   with a large number\
    \ of practical concerns including subtle security\n   threats.  Some of these\
    \ are discussed below.\n"
- title: 1.2.2 Timestamps vs. Challenge/Response
  contents:
  - "1.2.2 Timestamps vs. Challenge/Response\n   Cryptosystems give you the ability\
    \ to sign messages so that the\n   receiver has assurance that the signer of the\
    \ message knew some\n   cryptographic secret.  Free-standing public key based\
    \ authentication\n   is sufficiently expensive that it is unlikely that anyone\
    \ would want\n   to sign every message of an interactive communication, and even\
    \ if\n   they did they would still face the threat of someone rearranging the\n\
    \   messages or playing them multiple times.  Authentication generally\n   takes\
    \ place in the context of establishing some sort of \"connection,\"\n   where\
    \ a conversation will ensue under the auspices of the single\n   peer-entity authentication.\
    \  This connection might be\n   cryptographically protected against modification\
    \ or reordering of the\n   messages, but any such protection would be largely\
    \ independent of the\n   authentication which occurred at the start of the connection.\
    \  DASS\n   provides as a side effect of authentication the provision of a shared\n\
    \   key which may be used for this purpose.\n   If in our simple minded authentication\
    \ above, I signed the message\n   \"It's really me!\" with my private key and\
    \ sent it to you, you could\n   verify the signature and know the message came\
    \ from me and give the\n   connection in which this message arrived access to\
    \ my resources.\n   Anyone watching this message over the network, however, could\
    \ replay\n   it to any server (just like a password!) and impersonate me.  It\
    \ is\n   important that the message I send you only be accepted by you and\n \
    \  only once.  I can prevent the message from being useful at any other\n   server\
    \ by including your name in the message.  You will only accept\n   the message\
    \ if you see your name in it.  Keeping you from accepting\n   the message twice\
    \ is harder.\n   There are two \"standard\" ways of providing this replay protection.\n\
    \   One is called challenge/response and the other is called timestamp-\n   based.\
    \  In a challenge response type scheme, I tell you I want to\n   authenticate,\
    \ you generate a \"challenge\" (generally a number), and I\n   include the challenge\
    \ in the message I sign.  You will only accept a\n   message if it contains the\
    \ recently generated challenge and you will\n   make sure you never issue the\
    \ same challenge to me twice (either by\n   using a sequence number, a timestamp,\
    \ or a random number big enough\n   that the probability of a duplicate is negligible).\
    \  In the\n   timestamp-based scheme, I include the current time in my message.\n\
    \   You have a rule that you will not accept messages more than - say -\n   five\
    \ minutes old and you keep track of all messages you've seen in\n   the last five\
    \ minutes.  If someone replays the message within five\n   minutes, you will reject\
    \ it because you will remember you've seen it\n   before; if someone replays it\
    \ after five minutes, you will reject it\n   as timed out.\n   The disadvantage\
    \ of the challenge/response based scheme is that it\n   requires extra messages.\
    \  While one-way authentication could\n   otherwise be done with a single message\
    \ and mutual authentication\n   with one message in each direction, the challenge/response\
    \ scheme\n   always requires at least three messages.\n   The disadvantage of\
    \ the timestamp-based scheme is that it requires\n   secure synchronized time.\
    \  If our clocks drift apart by more than\n   five minutes, you will reject all\
    \ of my attempts to authenticate.  If\n   a network time service spoofer can convince\
    \ you to turn back your\n   clock and then subsequently replays an expired message,\
    \ you will\n   accept it again.  The multicast nature of existing distributed\
    \ time\n   services and the likelihood of detection make this an unlikely\n  \
    \ threat, but it must be considered in any analysis of the security of\n   the\
    \ scheme.  The timestamp scheme also requires the server to keep\n   state about\
    \ all messages seen in the clock skew interval.  To be\n   secure, this must be\
    \ kept on stable storage (unless rebooting takes\n   longer than the permitted\
    \ clock skew interval).\n   DASS uses the timestamp-based scheme.  The primary\
    \ motivations behind\n   this decision were so that authentication messages could\
    \ be\n   \"piggybacked\" on existing connection establishment messages and so\n\
    \   that DASS would fit within the same \"form factor\" (number and\n   direction\
    \ of messages) as Kerberos.\n"
- title: 1.2.3 Delegation
  contents:
  - "1.2.3 Delegation\n   In a distributed environment, authentication alone is not\
    \ enough.\n   When I log onto a computer, not only do I want to prove my identity\n\
    \   to that computer, I want to use that computer to access network\n   resources\
    \ (e.g., file systems, database systems) on my behalf.  My\n   files should (normally)\
    \ be protected so that I can access them\n   through any node I log in through.\
    \  DASS allows them to be so\n   protected without allowing all of the systems\
    \ that I might ever use\n   to access those files in my absence.  In the process\
    \ of logging in,\n   my password gives my login node access to my RSA secret.\
    \  It can use\n   that secret to \"impersonate\" me on any requests it makes on\
    \ my\n   behalf.  It should forget all secrets associated with me when I log\n\
    \   off.  This limits the trust placed in computer systems.  If someone\n   takes\
    \ control of a computer, they can impersonate all people who use\n   that computer\
    \ after it is taken over but no others.\n   Normally when I access a network service,\
    \ I want to strongly\n   authenticate to it.  That is, I want to prove my identity\
    \ to that\n   service, but I don't want to allow that service to learn anything\n\
    \   that would allow it to impersonate me.  This allows me to use a\n   service\
    \ without trusting it for more than the service it is\n   delivering.  When using\
    \ some services, for example remote login\n   services, I may want that service\
    \ to act on my behalf in calling\n   additional services.  DASS provides a mechanism\
    \ whereby I can pass\n   secrets to such services that allow them to impersonate\
    \ me.\n   Future versions of this architecture may allow \"limited delegation\"\
    \n   so that a user may delegate to a server only those rights the server\n  \
    \ needs to carry out the user's wishes.  This version  can limit\n   delegation\
    \ only in terms of time.  The information a user gives a\n   server (other than\
    \ the initial login node) can be used to impersonate\n   the user but only for\
    \ a limited period of time.  Smart cards will\n   permit that time limitation\
    \ to apply to the initial login node as\n   well.\n"
- title: 1.2.4 Certification Authorities
  contents:
  - "1.2.4 Certification Authorities\n   A flaw in the strong authentication mechanism\
    \ described above is that\n   it assumes that every \"principal\" (user and node)\
    \ knows the public\n   key of every other principal it wants to authenticate.\
    \  If I can fool\n   a server into thinking my public key is actually your public\
    \ key, I\n   can impersonate you by signing a message, saying it is from you,\
    \ and\n   having the server verify the message with what it thinks is your\n \
    \  public key.\n   To avoid the need to securely install the public key of every\n\
    \   principal in the database of every other principal, the concept of a\n   \"\
    Certification Authority\" was invented.  A certification authority is\n   a principal\
    \ trusted to act as an introduction service.  Each\n   principal goes to the certification\
    \ authority, presents its public\n   key, and proves it has a particular name\
    \ (the exact mechanisms for\n   this vary with the type of principal and the level\
    \ of security to be\n   provided).  The CA then creates a \"certificate\" which\
    \ is a message\n   containing the name and public key of the principal, an expiration\n\
    \   date, and bookkeeping information signed by the CA's private key.\n   All\
    \ \"subscribers\" to a particular CA can then be authenticated to one\n   another\
    \ by presenting their certificates and proving knowledge of the\n   corresponding\
    \ secret.  CAs need only act when new principals are\n   being named and new private\
    \ keys created, so that can be maintained\n   under tight physical security.\n\
    \   The two problems with the scheme as described so far are \"revocation\"\n\
    \   and \"scaleability\".\n"
- title: 1.2.4.1 Certificate Revocation
  contents:
  - "1.2.4.1 Certificate Revocation\n   Revocation is the process of announcing that\
    \ a key has (or may have)\n   fallen into the wrong hands and should no longer\
    \ be accepted as proof\n   of some particular identity.  With certificates as\
    \ described above,\n   someone who learns your secret and your certificate can\
    \ impersonate\n   you indefinitely - even after you have learned of the compromise.\
    \  It\n   lacks the ability corresponding to changing your password.  DASS\n \
    \  supports two independent mechanisms for revoking certificates. In the\n   future,\
    \ a third may be added.\n   One method for revocation is using timeouts and renewals\
    \ of\n   certificates.  Part of the signed message which is a certificate may\n\
    \   be a time after which the certificate should not be believed.\n   Periodically,\
    \ the CA would renew certificates by signing one with a\n   later timeout.  If\
    \ a key were compromised, a new key would be\n   generated and a new certificate\
    \ signed.  The old certificate would\n   only be valid until its timeout.  Timeouts\
    \ are not perfect revocation\n   mechanisms because they provide only slow revocation\
    \ (timeouts are\n   typically measured in months for the load on the CA and communication\n\
    \   with users to be kept manageable) and they depend on servers having\n   an\
    \ accurate source of the current time.  Someone who can trick a\n   server into\
    \ turning back its clock can use expired certificates.\n   The second method is\
    \ by listing all non-revoked certificates in the\n   naming service and believing\
    \ only certificates found there.  The\n   advantage of this method is that it\
    \ is almost immediate (the only\n   delay is for name service \"skulking\" and\
    \ caching delays).  The\n   disadvantages are: (1) the availability of authentication\
    \ is only as\n   good as the availability of the naming service and (2) the security\n\
    \   of revocation is only as good as the security of the naming service.\n   A\
    \ third method for revocation - not currently supported by DASS - is\n   for certification\
    \ authorities to periodically issue \"revocation\n   lists\" which list certificates\
    \ which should no longer be accepted.\n"
- title: 1.2.4.2 Certification Authority Hierarchy
  contents:
  - "1.2.4.2 Certification Authority Hierarchy\n   While using a certification authority\
    \ as an introduction service\n   scales much better than having every principal\
    \ learn the public key\n   of every other principal by some out of band means,\
    \ it has the\n   problem that it creates a central point of trust.  The certification\n\
    \   authority can impersonate any principal by inventing a new key and\n   creating\
    \ a certificate stating that the new key represents the\n   principal.  In a large\
    \ organization, there may be no individual who\n   is sufficiently trusted to\
    \ operate the CA.  Even if there were, in a\n   large organization it would be\
    \ impractical to have every individual\n   authenticate to that single person.\
    \  Replicating the CA solves the\n   availability problem but makes the trust\
    \ problem worse.  When\n   authentication is to be used in a global context -\
    \ between companies\n   - the concept of a single CA is untenable.\n   DASS addresses\
    \ this problem by creating a hierarchy of CAs.  The CA\n   hierarchy is tied to\
    \ the naming hierarchy.  For each directory in the\n   namespace, there is a single\
    \ CA responsible for certifying the public\n   keys of its members.  That CA will\
    \ also certify the public keys of\n   the CAs of all child directories and of\
    \ the CA of the parent\n   directory.  With this cross-certification, it is possible\
    \ knowing the\n   public key of any CA to verify the public keys of a series of\n\
    \   intermediate CAs and finally to verify the public key of any\n   principal.\n\
    \   Because the CA hierarchy is tied to the naming hierarchy, the trust\n   placed\
    \ in any individual CA is limited.  If a CA is compromised, it\n   can impersonate\
    \ any of the principals listed in its directory, but it\n   cannot impersonate\
    \ arbitrary principals.\n   DASS provides mechanisms for every principal to know\
    \ the public key\n   of its \"parent\" CA - the CA controlling the directory in\
    \ which it is\n   named.  The result is the following rules for the implications\
    \ of a\n   compromised CA:\n    a) A CA can impersonate any principal named in\
    \ its directory.\n    b) A CA can impersonate any principal to a server named\
    \ in its\n       directory.\n    c) A CA can impersonate any principal named in\
    \ a subdirectory to\n       any server not named in the same subdirectory.\n \
    \   d) A CA can impersonate to any server in a subdirectory any\n       principal\
    \ not named in the same subdirectory.\n   The implication is that a compromise\
    \ low in the naming tree will\n   compromise all principals below that directory\
    \ while a compromise\n   high in the naming tree will compromise only the authentication\
    \ of\n   principals far apart in the naming hierarchy.  In particular, when\n\
    \   multiple organizations share a namespace (as they do in the case of\n   X.500),\
    \ the compromise of a CA in one organization can not result in\n   false authentication\
    \ within another organization.\n   DASS uses the X.500 directory hierarchy for\
    \ principal naming.  At the\n   top of the hierarchy are names of countries. \
    \ National authorities\n   are not expected to establish certification authorities\
    \ (at least\n   initially), so an alternative mechanism must be used to authenticate\n\
    \   entities \"distant\" in the naming hierarchy.  The mechanism for this\n  \
    \ in DASS is the \"cross-certificate\" where a CA certifies the public\n   key\
    \ for some CA or principal not its parent or child.  By limiting\n   the chains\
    \ of certificates they will use to parent certificates\n   followed by a single\
    \ \"cross certificate\" followed by child\n   certificates, a DASS implementation\
    \ can avoid the need to have CAs\n   near the root of the tree or can avoid the\
    \ requirement to trust them\n   even if they do exist.  A special case can also\
    \ be supported whereby\n   a global authority whose name is not the root can certify\
    \ the local\n   roots of independent \"islands\".\n"
- title: 1.2.5 User vs. Node Authentication
  contents:
  - "1.2.5 User vs. Node Authentication\n   In concept, DASS mechanisms support the\
    \ mutual authentication of two\n   principals regardless of whether those principals\
    \ are people,\n   computers, or applications.  Those mechanisms have been extended,\n\
    \   however, to deal with a common case of a pair of principals acting\n   together\
    \ (a user and a node) authenticating to a single principal (a\n   remote server).\
    \  This is done by having optionally in each\n   credentials structure two sets\
    \ of secrets - one for the user and one\n   for the node.  When authentication\
    \ is done using such credentials,\n   both secrets sign the request so the receiving\
    \ party can verify that\n   both principals are present.\n   This setup has a\
    \ number of advantages.  It permits access controls to\n   be enforced based on\
    \ both the identity of the user and the identity\n   of the originating node.\
    \  It also makes it possible to define users\n   of systems who have no network\
    \ wide identities who can access network\n   resources on the basis of node credentials\
    \ alone.  The security of\n   such a setup is less because a node can impersonate\
    \ all of its users\n   even when they are not logged in, but it offers an easier\
    \ transition\n   from existing global identities for all users.\n"
- title: 1.2.6 Protection of User Keys
  contents:
  - "1.2.6 Protection of User Keys\n   DASS mechanisms generally deal with authentication\
    \ between principals\n   each knowing a private key.  For principals who are people,\
    \ special\n   mechanisms are provided for maintaining that private key.  In\n\
    \   particular, it many cases it will be most convenient to keep\n   passwords\
    \ as secrets rather than private keys.  This architecture\n   specifies a means\
    \ of storing private keys encrypted under passwords.\n   This would provide security\
    \ as good as hiding a private key were it\n   not that people tend to choose passwords\
    \ from a small space (like\n   words in a dictionary) such that a password can\
    \ be more easily\n   guessed than a private key.  To address this potential weakness,\
    \ DASS\n   specifies a protocol between a login node and a login agent whereby\n\
    \   the login agent can audit and limit the rate of password guesses.\n   Use\
    \ of these features is optional.  A user with a smart card could\n   store a private\
    \ key directly and bypass all of these mechanisms.  If\n   users can be forced\
    \ to choose \"good\" passwords, the login agent could\n   be eliminated and encrypted\
    \ credentials could be stored directly in\n   the naming service.\n   Another\
    \ way in which user keys are protected is that the architecture\n   does not require\
    \ that they be available except briefly at login.\n   This reduces the threat\
    \ of a user walking away from a logged on\n   workstation and having someone take\
    \ over the workstation and extract\n   his key.  It also makes the use of RSA\
    \ based smart cards practical;\n   the card could keep the user's private key\
    \ and execute one signature\n   operation at login time to authenticate an entire\
    \ session.\n"
- title: 1.3 What This Document Won't Tell You
  contents:
  - "1.3 What This Document Won't Tell You\n   Architecture documents are by their\
    \ nature difficult to read.  This\n   one is no exception. The reason is that\
    \ an architecture document\n   contains the details sufficient to build interoperable\n\
    \   implementations, but it is not a design specification. It goes out of\n  \
    \ its way to leave out any details which an implementation could choose\n   without\
    \ affecting interoperability. It also does not specify all the\n   uses of the\
    \ services provided because these services are properly\n   regarded as general\
    \ purpose tools.\n   The remainder of this section includes information which\
    \ is not\n   properly part of the authentication architecture, but which may be\n\
    \   useful in understanding why the architecture is the way it is.\n"
- title: 1.3.1 How DASS is Embedded in an Operating System
  contents:
  - "1.3.1 How DASS is Embedded in an Operating System\n   While architecturally DASS\
    \ does not require any operating system\n   support in order to be used by an\
    \ application (other than the\n   services listed in Section 2), it is expected\
    \ that actual\n   implementations of DASS will be closely tied to the operating\
    \ systems\n   of host computers.  This is done both for security and for\n   convenience.\n\
    \   In particular, it is expected that when a user logs into a node, a\n   set\
    \ of credentials will be created for that user and then associated\n   by the\
    \ operating system with all processes initiated by or on behalf\n   of the user.\
    \  When a user delegates to a service, the remote\n   operating system is expected\
    \ to accept the delegation and start up\n   the remote process with the delegated\
    \ credentials.  Most nodes are\n   expected to have credentials of their own and\
    \ support the concept of\n   user accounts.  When user credentials are created,\
    \ the node is\n   expected to verify them in its own context, determine the appropriate\n\
    \   user account, and add node credentials to the created credentials\n   set.\n"
- title: 1.3.2 Forms of Credentials
  contents:
  - "1.3.2 Forms of Credentials\n   In the DASS architecture, there is a single data\
    \ structure called\n   \"Credentials\" with a large number of optional parts.\
    \  In an\n   implementation, it is possible that not all of the architecturally\n\
    \   allowed subsets will be supported and credentials structures with\n   different\
    \ subsets of the data may be implemented quite differently.\n   The major categories\
    \ of credentials likely to be supported in an\n   implementation are:\n    - Claimant\
    \ credentials  - these are the credentials which would\n      normally be associated\
    \ with a user process in order that it be\n      able to create authentication\
    \ tokens.  It would contain the\n      user's name, login ticket, session private\
    \ key, and (at least\n      logically) local node credentials and cached outgoing\n\
    \      contexts.\n    - Verifier credentials -  these are the credentials which\
    \ would\n      normally be associated with a server which must verify tokens\n\
    \      and produce mutual authentication response tokens.  Since\n      servers\
    \ may be started by a node on demand, some\n      representation of verifier credentials\
    \ must exist independent\n      of a process.  If an operating system wishes to\
    \ authenticate a\n      request before starting a server process, the credentials\
    \ must\n      exist in usable form.  An implementation may choose to have\n  \
    \    all services on a \"node\" share a verifier credentials\n      structure,\
    \ or it may choose to have each service have its own.\n    - Combined credentials\
    \ - architecturally, a server may have a\n      structure which is both claimant\
    \ credentials and verifier\n      credentials combined so that the server may\
    \ act in either role\n      using a single structure.  There is some overlap in\
    \ the\n      contents.  There is no requirement, however, that an\n      implementation\
    \ support such a structure.\n    - Stub credentials - In the architecture, a credentials\n\
    \      structure is created whenever a token is accepted.  If delegation\n   \
    \   took place, these are claimant credentials usable by their\n      possessor\
    \ to create additional tokens.  If no delegation took\n      place, this structure\
    \ exists as an architectural place holder\n      against which an implementation\
    \ may attempt to authenticate\n      user and node names.  An implementation might\
    \ choose to\n      implement  stub credentials  with a different mechanism than\n\
    \      claimant or verifier credentials.  In particular, it might do\n      whatever\
    \ user and node authentication is useful itself and not\n      support this structure\
    \ at all.\n"
- title: 1.3.3 Support for Alternative Certification Authority
  contents:
  - "1.3.3 Support for Alternative Certification Authority\n      Implementations\n\
    \   A motivating factor in much of the design of DASS is the need to\n   protect\
    \ certification authorities from compromise. CAs are only used\n   to create certificates\
    \ for new principals and to renew them on\n   expiration (expiration intervals\
    \ are likely to be measured in\n   months). They therefore do not need to be highly\
    \ available. For\n   maximum security, CAs could be implemented on standalone\
    \ PCs where\n   the hardware, software, and keys can be locked in a safe when\
    \ the CA\n   is not in use. The certificates the CA generates must be delivered\
    \ to\n   the naming service to be registered, and a possible mechanism for\n \
    \  this is for the CA to have an RS232 line to an on-line component\n   which\
    \ can pass certificates and related information but not login\n   sessions. The\
    \ intent would be to make it implausible to mount a\n   network attack against\
    \ the CA.  Alternatively, certificates could be\n   carried to the network on\
    \ a floppy disk.\n   For CAs to be secure, a whole host of design details must\
    \ be done\n   right. The most important of these is the design of user and system\n\
    \   manager interfaces that make it difficult to \"trick\" a user or system\n\
    \   manager into doing the wrong thing and certifying an impostor or\n   revealing\
    \ a key. Mechanisms for generating keys must also be\n   carefully protected to\
    \ assure that the generated key cannot be\n   guessed (because of lack of randomness)\
    \ and is not recorded where a\n   penetrator can get it. Because a certificate\
    \ contains relatively\n   little human intelligible information (its most important\
    \ components\n   are UIDs and public keys), it will be a challenge to design a\
    \ user\n   interface that assures the human operator only authorizes the signing\n\
    \   of intented certificates. Such considerations are beyond the scope of\n  \
    \ the architecture (since they do not affect interoperability), but\n   they did\
    \ affect the design in subtle ways.  In particular, it does\n   not assume uniform\
    \ security throughout the CA hierarchy and is\n   designed to assure that the\
    \ compromise of a CA in one part of the\n   hierarchy does not have global implications.\n\
    \   The architecture does not require that CAs be off-line. The CA could\n   be\
    \ software that can run on any node when the proper secret is\n   installed. \
    \ Administrative convenience can be gained by integrating\n   the CA with account\
    \ registration utilities and naming service\n   maintenance. As such, the CA would\
    \ have to be on-line when in use in\n   order to register certificates in the\
    \ naming service.  The CA key\n   could be unlocked with a password and the password\
    \ could be entered\n   on each use both to authenticate the CA operator and to\
    \ assure that\n   compromise of the host node while the CA is not in use will\
    \ not\n   compromise the CA.  This design would be subject to attacks based on\n\
    \   planting Trojan horses in the CA software, but is entirely\n   interoperable\
    \ with a more secure implementation.  Realistic tradeoffs\n   must be made between\
    \ security, cost, and administrative convenience\n   bearing in mind that a system\
    \ is only as secure as its weakest link\n   and that there is no benefit in making\
    \ the CA substantially more\n   secure than the other components of the system.\n"
- title: 1.3.4 Services Provided vs. Application Program Interface
  contents:
  - "1.3.4 Services Provided vs. Application Program Interface\n   Section 3 of this\
    \ document specifies \"abstract interfaces\" to the\n   services provided by DASS.\
    \ This means it tells what services are\n   provided, what parameters are supplied\
    \ by the caller, and what data\n   is returned. It does not specify the calling\
    \ interfaces.  Calling\n   interfaces may be platform, operating system, and language\
    \ dependent.\n   They do not affect interoperability; different implementations\
    \ which\n   implement completely different calling interfaces can still\n   interoperate\
    \ over a network. They do, however, affect portability. A\n   program which runs\
    \ on one platform can only run on another which\n   implements an identical API.\n\
    \   In order to support portability of applications - not just between\n   implementations\
    \ of DASS but between implementations of DASS and\n   implementations of Kerberos\
    \ - a \"Generic Security Service API\" has\n   been designed and is outlined in\
    \ Annex B. This API could be the only\n   \"published\" interface to DASS services.\
    \  This interface does not,\n   however, give access to all the functions provided\
    \ by DASS and it\n   provides some non-DASS services. It does not give access\
    \ to the\n   \"login\" service, for example, so the login function cannot be\n\
    \   implemented in a portable way. Clearly an implementation must provide\n  \
    \ some implementation of the login function, though perhaps only to one\n   system\
    \ program and the implementation need not be portable.\n   Similarly, the Generic\
    \ API provides no access to node authentication\n   information, so applications\
    \ which use these services may not be\n   portable.\n   The Generic API provides\
    \ services for encryption of user data for\n   integrity and possibly privacy.\
    \ These services are not specified as a\n   part of the DASS architecture. This\
    \ is because we envisioned that\n   such services would be provided by the communications\
    \ network and not\n   in applications. These services are provided by the Generic\
    \ API\n   because these services are provided by Kerberos, there exist\n   applications\
    \ which use these services, and they are desired in the\n   context of the IETF-CAT\
    \ work. The DASS architecture includes a Key\n   Distribution service so that\
    \ the encryption functions of the Generic\n   API can be supported and integrated.\
    \ Annex B specifies how those\n   services can be implemented using DASS services.\n\
    \   The Services Provided also differ from the GSSAPI because there are\n   important\
    \ extensions envisioned to the API for future applications\n   and it was important\
    \ to assure that architecturally those services\n   were available.  In particular,\
    \ DASS provides the ability for a\n   principal to have multiple aliases and for\
    \ the receiver of an\n   authentication token to verify any one of them.  We want\
    \ DASS to\n   support the case where a server only learns the name it is trying\
    \ to\n   validate in the course of evaluating an ACL.  This may be long after\n\
    \   a connection is accepted.  The Services Provided section therefore\n   separates\
    \ the Accept_token function from the Verify Principal Name.\n   The other motivation\
    \ behind a different interface is that DASS\n   provides node authentication -\
    \ the ability to authenticate the node\n   from which a request originates as\
    \ well as the user.  Because\n   Kerberos provides no such mechanism, the capability\
    \ is missing from\n   the GSSAPI, but we expect some applications will want to\
    \ make use of\n   it.\n"
- title: 1.3.5 Use of a Naming Service
  contents:
  - "1.3.5 Use of a Naming Service\n   With the exception of the syntactical representation\
    \ of names, which\n   is tied to X.500, the DASS architecture is designed to be\
    \ independent\n   of the particular underlying naming service.  While the intention\
    \ is\n   that certificates be stored in an X.500 naming service in the fields\n\
    \   architecturally reserved for this purpose in the standard, this\n   specification\
    \ allows for the possibility of different forms of\n   certificate stores.  The\
    \ SPX implementation of DASS implements its\n   own certificate distribution service\
    \ because we did not want to\n   introduce a dependency on an X.500 naming service.\n"
- title: 1.3.6 Key Hiding - Credentials
  contents:
  - "1.3.6 Key Hiding - Credentials\n   The abstract interfaces described in section\
    \ 3 specify that\n   \"credentials\" and \"keys\" are the inputs and outputs of\
    \ various\n   routines.  Credentials structures in particular contain secret\n\
    \   information which should not be made available to the calling\n   application.\
    \  In most cases, keeping this information from\n   applications is simply a matter\
    \ of prudence - a misbehaving\n   application can do nearly as much damage using\
    \ the credentials as it\n   can by using the secrets directly.  Having access\
    \ to the keys\n   themselves may allow an application to bypass auditing or leak\
    \ a key\n   to an accomplice who can use it on another node where a large amount\n\
    \   of activity is less likely to be noticed.  In some cases, most\n   dramatically\
    \ where a \"node key\" is present in user credentials, it is\n   vital that the\
    \ contents of the credentials be kept out of the hands\n   of applications.\n\
    \   To accomplish this, a concrete interface is expected to create\n   \"credentials\
    \ handles\" that are passed in and out of DASS routines.\n   The credentials themselves\
    \ would be kept in some portion of memory\n   where unprivileged code can't get\
    \ at them.\n   There is another aspect of the way credentials are used which is\n\
    \   important to the design of real implementations.  In normal use, a\n   user\
    \ will create a set of credentials in the process of logging on to\n   a system\
    \ and then use them from many processes or jobs.  When many\n   processes share\
    \ a set of credentials, it is important for the sake of\n   performance that they\
    \ share one set of credentials rather than having\n   a copy of the credentials\
    \ made for each.  This is because information\n   is cached in credentials as\
    \ a side effect of some requests and for\n   good performance those caches should\
    \ be shared.\n   As an example, consider a system executing a series of copy commands\n\
    \   moving files from one system to another.  The credentials of the user\n  \
    \ will have been established when the user logged on.  The first time a\n   copy\
    \ is requested, a new process will start up, open a connection to\n   the destination\
    \ system, and create a token to authenticate itself.\n   Creating that token will\
    \ be an expensive operation, but information\n   will be computed and \"cached\"\
    \ in the credentials structure which will\n   allow any subsequent tokens on behalf\
    \ of that user to that server to\n   be computed cheaply.  After the copy completes,\
    \ the connection is\n   closed and the process terminates.  In response to a second\
    \ copy\n   request, another new process will be created and a new token\n   computed.\
    \  For this operation to get a performance benefit from the\n   caching, the information\
    \ computed by the first process must somehow\n   make it to the second.\n   A\
    \ model for how this caching might work can be seen in the way\n   Kerberos caches\
    \ credentials.  Kerberos keeps credentials in a file\n   whose name can be computed\
    \ from the name of the local user.  This\n   file is initialized as part of the\
    \ login process and its protection\n   is set so that only processes running under\
    \ the UID of the user may\n   read and write the file.  Processes cache information\
    \ there; all\n   processes running on behalf of the user share the file.\n   There\
    \ are two problems with this scheme: first, on a diskless node\n   putting information\
    \ in a file exposes it to eavesdroppers on the\n   network; second, it does not\
    \ accomplish the \"key hiding\" function\n   described earlier in this section.\
    \  In a more secure implementation,\n   the kernel or a privileged process would\
    \ manage some \"pool\" of\n   credentials for all processes on a node and would\
    \ grant access to\n   them only through the DASS calls.  Credentials structures\
    \ are complex\n   and varying length; DASS may organize them as a set of pools\
    \ rather\n   than as contiguous blocks of data.  All such design issues are\n\
    \   \"beyond the scope of the architecture\".  Implementations must decide\n \
    \  how to control access to credentials.  They could copy the Kerberos\n   scheme\
    \ of having credentials available to processes with the UID of\n   the login session\
    \ which created them and to privileged processes or\n   there may be a more elaborate\
    \ mechanism for \"passing\" credentials\n   handles from process to process. \
    \ This design should probably follow\n   the operating system mechanisms for passing\
    \ around local privileges.\n"
- title: 1.3.7 Key Hiding - Contexts
  contents:
  - "1.3.7 Key Hiding - Contexts\n   The \"GSSAPI\" has a concept of a security context\
    \ which has some of\n   the same key hiding problems as a credentials structure.\
    \  Security\n   contexts are used in calls to cryptographically protect user data\n\
    \   (from modification or from disclosure and modification) using keys\n   established\
    \ during authentication.  The \"services provided\"\n   specification says that\
    \ create_ and accept_token return a \"shared\n   key\" and \"instance identifier\"\
    .  The GSSAPI says that a context\n   handle is returned which is an integer.\
    \  A secure implementation\n   would keep the key and instance identifier in protected\
    \ memory and\n   only allow access to them through provided interfaces.\n   Unlike\
    \ credentials, there is probably no need to provide mechanisms\n   for contexts\
    \ to be shared between processes.  Contexts will normally\n   be associated with\
    \ some notion of a communications \"connection\" and\n   ends of a connection\
    \ are not normally shared.  If an implementation\n   chooses to provide additional\
    \ services to applications like message\n   sequencing or duplicate detection,\
    \ contexts will have to contain\n   additional fields.  These can be created and\
    \ maintained without any\n   additional authentication services.\n"
- title: 1.4 The Relationship between DASS and ISO Standards
  contents:
  - "1.4 The Relationship between DASS and ISO Standards\n   This section provides\
    \ an introduction to DASS authentication in terms\n   of the ISO Authentication\
    \ Framework (DP10181-2).   The purpose of\n   this introduction is to give the\
    \ reader an intuitive understanding of\n   the way DASS works and how its mechanisms\
    \ and terminology relate to\n   standards.  Important details have been omitted\
    \ here but are spelled\n   out in section 3.\n"
- title: 1.4.1 Concepts
  contents:
  - "1.4.1 Concepts\n   The primary goal of authentication is to prevent impersonation,\
    \ that\n   is, the pretense to a false identity. Authentication always involves\n\
    \   identification in some form. Without authentication, anyone could\n   claim\
    \ to be whomever they wished and get away with it.\n   If it didn't matter with\
    \ whom one was communicating, elaborate\n   procedures for authentication would\
    \ be unnecessary. However, in most\n   systems, and in timesharing and distributed\
    \ processing environments\n   in particular, the rights of individuals are often\
    \ circumscribed by\n   security policy. In particular, authorization (identity\
    \ based access\n   control) and accountability (audit) provisions could be circumvented\n\
    \   if masquerading attempts were impossible to prevent or detect.\n   Almost\
    \ all practical authentication mechanisms suitable for use in\n   distributed\
    \ environments rely on knowledge of some secret\n   information. Most differences\
    \ lie in how one presents evidence that\n   they know the secret. Some schemes,\
    \ in particular the familiar simple\n   use of passwords, are quite susceptible\
    \ to attack. Generally, the\n   threats to authentication may be classified as:\n\
    \    - forgery, attempting to guess or otherwise fabricate evidence;\n    - replay,\
    \ where one can eavesdrop upon another's authentication\n      exchange and learn\
    \ enough to impersonate them; and\n    - interception, where one slips between\
    \ the communicants and is\n      able to modify the communications channel unnoticed.\n\
    \   Most such attacks can be countered by using what is known as strong\n   authentication.\
    \ Strong authentication refers to techniques that\n   permit one to provide evidence\
    \ that they know a particular secret\n   without revealing even a hint about the\
    \ secret. Thus neither the\n   entity to whom one is authenticating, nor an eavesdropper\
    \ on the\n   conversation can further their ability to impersonate the\n   authenticating\
    \ principal at some future time as the result of an\n   authentication exchange.\n\
    \   Strong authentication mechanisms, in particular those used here, rely\n  \
    \ on cryptographic techniques. In particular, DASS uses public key\n   cryptography.\
    \ Note that interception attacks cannot be countered by\n   strong authentication\
    \ alone, but generally need additional security\n   mechanisms to secure the communication\
    \ channel, such as data\n   encryption.\n"
- title: 1.4.2 Principals and Their Roles
  contents:
  - "1.4.2 Principals and Their Roles\n   All authentication is on behalf of principals.\
    \ In DASS the following\n   types of principals are recognized:\n    - user principals,\
    \ normally people with accounts who are\n      responsible for performing particular\
    \ tasks. Generally it is\n      users that are authorized to do things by virtue\
    \ of having\n      been granted access rights, or who are to be held accountable\n\
    \      for specific actions subject to being audited.\n    - server principals,\
    \ which are accessed by users.\n    - node principals,  corresponding to locations\
    \ where users and\n      servers, or more accurately, processes acting on behalf\
    \ of\n      principals can reside.\n   Principals can act in one of two capacities:\n\
    \    - the claimant is the active entity seeking to authenticate\n      itself,\
    \ and\n    - the verifier is the passive entity to whom the claimant is\n    \
    \  authenticating.\n   Users normally are claimants, whereas servers are usually\
    \ verifiers,\n   although sometimes servers can also be claimants.\n   There is\
    \ another kind of principal:\n    - certification authorities (CA's) issue certificates\
    \ which\n      attest to another principal's public key.\n"
- title: 1.4.3 Representation, Delegation and Representation Transfer
  contents:
  - "1.4.3 Representation, Delegation and Representation Transfer\n   Of course, although\
    \ it is users that are responsible for what the\n   computer does, human beings\
    \ are physically unable to directly do\n   anything within a computer system.\
    \ In point of fact, it is a\n   process executing on behalf of a user that actually\
    \ performs\n   useful work. From the point of view of performing security\n  \
    \ controlled functions, the process is the agent, or\n   representative, of the\
    \ user, and is authorized by that user to do\n   things on his behalf. In the\
    \ terms used in the ISO Authentication\n   Framework, the user is said to have\
    \ a representation in the\n   process.\n   The representation has to come into\
    \ existence somehow.  Delegation\n   refers to the act of creating a representation.\
    \ A user is said to\n   create a representation for themselves by delegating to\
    \ a process. If\n   the user creates another process, say by doing an rlogin on\
    \ a\n   different computer, a representation may be needed there as well. This\n\
    \   may be accomplished automatically by a process known as representation\n \
    \  transfer.  DASS uses the term delegation to also mean the act of\n   creating\
    \ additional representations on a remote systems.\n   A representation is instantiated\
    \ in DASS as credentials.  Credentials\n   include the identity of the principal\
    \ as well as the cryptographic\n   \"state\" needed to engage in strong authentication\
    \ procedures. Claimant\n   information in credentials enable principals to authenticate\n\
    \   themselves to others, whereas verifier information in credentials\n   permit\
    \ principals to verify the claims of others.  Credentials\n   intended primarily\
    \ for use by a claimant will be referred to as\n   claimant credentials in the\
    \ text which follows.  Credentials intended\n   primarily for use in verification\
    \ will be referred to as verifier\n   credentials.  A particular set of credentials\
    \ may or may not contain\n   all of the data necessary to be used in both roles.\
    \  That will depend\n   on the mechanisms by which the credentials were created.\n\
    \   In some contexts, but not here, the concept of representation\n   and/or delegation\
    \ is sometimes referred to as proxy. This term is\n   used in ECMA TR/46.  We\
    \ avoid use of the term because of possible\n   confusion with an unrelated use\
    \ of the term in the context of\n   DECnet.\n"
- title: 1.4.4 Key Distribution, Replay, Mutual Authentication and Trust
  contents:
  - "1.4.4 Key Distribution, Replay, Mutual Authentication and Trust\n   Strong authentication\
    \ uses cryptographic techniques. The\n   particular mechanisms used in DASS result\
    \ in the distribution of\n   cryptographic keys as a side effect. These keys are\
    \ suitable for\n   use for providing a data origin authentication service and/or\
    \ a\n   data confidentiality service between a pair of authenticated\n   principals.\n\
    \   Replay detection is provided using timestamps on relevant\n   authentication\
    \ messages, combined with remembering previously\n   accepted messages until they\
    \ become \"stale\". This is in contrast\n   to other techniques, such as challenge\
    \ and response exchanges.\n   Authentication can be one-way or mutual. One-way\
    \ authentication is\n   when only one party, in DASS the claimant, authenticates\
    \ to the other.\n   Mutual authentication provides, in addition, authentication\
    \ of the\n   verifier back to the claimant. In certain communications schemes,\
    \ for\n   example connectionless transfer, only one-way authentication is\n  \
    \ meaningful. DASS supports mutual authentication as a simple extension\n   of\
    \ one-way authentication for use in environments where it makes\n   sense.\n \
    \  DASS potentially can allow many different \"trust relationships\"\n   to exist.\
    \ All principals trust one or more CA's to safeguard the\n   certification process.\
    \ Principals use certificates as the basis\n   for authenticating identities,\
    \ and trust that CA's which issue\n   certificates act responsibly. Users expect\
    \ CA's to make sure that\n   certificates (and related secrets) are only made\
    \ for principals\n   that the CA knows or has properly authenticated on its own.\n"
- title: 1.5 An Authentication Walkthrough
  contents:
  - "1.5 An Authentication Walkthrough\n   The OSI Authentication Framework characterizes\
    \ authentication as\n   occurring in six phases. This section attempts to describe\
    \ DASS\n   in these terms.\n"
- title: 1.5.1 Installation
  contents:
  - "1.5.1 Installation\n   In this phase, principal certificates are created, as\
    \ is the\n   additional information needed to create claimant and verifier\n \
    \  credentials. OSI defines three sub-phases:\n    - Enrollment. In DASS, this\
    \ is the definition of a principal in\n      terms of a key, name and UID.\n \
    \   - Validation,  confirmation of identity to the satisfaction of\n      the\
    \ CA, after which the CA generates a certificate.\n    - Confirmation.  In DASS,\
    \ this is the act of providing the user\n      with the certificate and with the\
    \ CA's own name, key and UID,\n      followed up by the user creating a  trusted\
    \ authority for that\n      CA. A trusted authority is a certificate for the CA\
    \ signed by\n      the user.\n   Included in this step in DASS is the posting\
    \ of the certificate so as\n   to be available to principals wishing to verify\
    \ the principal's\n   identity. In addition, the user principal saves the trusted\
    \ authority\n   so as to be available when it creates credentials.\n"
- title: 1.5.2 Distribution
  contents:
  - "1.5.2 Distribution\n   DASS distributes certificates by placing them in the name\
    \ service.\n"
- title: 1.5.3 Acquisition
  contents:
  - "1.5.3 Acquisition\n   Whenever principals wish to authenticate to one another,\
    \ they access\n   the Name Service to obtain whatever public key certificates\
    \ they need\n   and create the necessary credentials. In DASS, acquisition means\n\
    \   obtaining credentials.\n   Claimant credentials implement the representation\
    \ of a principal in a\n   process, or, more accurately, provide a representation\
    \ of the\n   principal for use by a process. In making this representation, the\n\
    \   principal delegates to a temporary delegation key. In this fashion\n   the\
    \ claimant's long term principal key need not remain in the system.\n   Claimant\
    \ credentials are made by invoking the get credentials\n   primitive. Claimant\
    \ credentials are a DASS specific data structure\n   containing:\n    - a name\n\
    \    - a ticket, a data structure containing\n      .  a validity interval,\n\
    \      .  UID, and\n      .  (temporary) delegation public key, along with a\n\
    \      .  digital signature on the above made with the principal\n         private\
    \ key\n    - the delegation private key\n   Optionally in addition, there may\
    \ be credential information relating\n   to the node on which the user is logged\
    \ in and the account on that\n   node.  A detailed description of all the information\
    \ found in\n   credentials can be found in section 3.  Verifier credentials are\
    \ made\n   with initialize_server. Verifier credentials consist of a principal\n\
    \   (long term) private key. The rationale is that these credentials are\n   usually\
    \ needed by servers that must be able to run indefinitely\n   without re-entry\
    \ of any long term key.\n   In addition, claimants and verifiers have a trusted\
    \ authority, which\n   consists of information about a trusted CA.  That information\
    \ is its:\n    - name (this will appear in the \"issuer\" field in principal\n\
    \      certificates),\n    - public key (to use in verifying certificates issued\
    \ by that\n      CA), and\n    - UID.\n   Trusted authorities are used by principals\
    \ to verify certificates for\n   other principals' public keys.  CAs are arranged\
    \ in a hierarchy\n   corresponding to the naming hierarchy, where each directory\
    \ in the\n   naming hierarchy is controlled by a single CA.  Each CA certifies\
    \ the\n   CA of its parent directory, the CAs of each of its child directories,\n\
    \   and optionally CAs elsewhere in the naming hierarchy (mainly to deal\n   with\
    \ the case where the directories up to a common ancestor lack\n   CAs).  Even\
    \ though a principal has only a single CA as a trusted\n   authority, it can securely\
    \ obtain the public key of any principal in\n   the namespace by \"walking the\
    \ CA hierarchy\".\n"
- title: 1.5.4 Transfer
  contents:
  - "1.5.4 Transfer\n   The DASS exchange of authentication information is illustrated\
    \ in\n   Figure 1-1. During the transfer phase, the DASS claimant sends an\n \
    \  authentication token  to the verifier. Authentication tokens are made\n   by\
    \ invoking the create_token primitive. The authentication token is\n   cryptographically\
    \ protected and specified as a DASS data structure in\n   ASN.1. The authentication\
    \ token includes:\n    - a ticket,\n    - a DES authenticating key encrypted using\
    \ the intended\n      verifier's public key\n    - one of the following:\n   \
    \   . if delegation is not being performed, a digital signature on\n        the\
    \ encrypted DES key using the delegation private key, or\n      . if delegation\
    \ is being performed, sending the delegation\n        private key, DES encrypted\
    \ using the DES authenticating key\n    - an authenticator, which is a cryptographic\
    \ checksum made using\n      the DES authenticating key over a buffer containing\n\
    \      . a timestamp\n      . any application supplied \"channel bindings\". For\
    \ example,\n        addresses or other context information. The purpose of this\n\
    \        field is to thwart substitution and replay attacks.\n    - additional\
    \ optional information concerning node authentication\n      and context.\n  \
    \ As a side effect, after init_authentication_context, the caller\n   receives\
    \ a local authentication context, a data structure containing:\n    - the DES\
    \ key, and\n    - if mutual authentication is being requested, the expected\n\
    \      response.\n   In order to construct an authentication token, the claimant\
    \ needs to\n   access the verifier's public key certificate from the Name Service\n\
    \   (labeled CDC, for Certificate Distribution Center, in the figure).\n   Note\
    \ that while an authenticator can only be used once, it is\n   permissible to\
    \ re-establish the same local authentication context\n   multiple times. That\
    \ is, the ticket and DES key establishment\n   components of the authentication\
    \ token may have a relatively long\n   lifetime. This permits a performance improvement\
    \ in that repeated\n   applications of public key operations can be alleviated\
    \ if one caches\n   authentication contexts, along with other components from\
    \ a\n   successfully used authentication token and the associated verified\n \
    \  principal public key value. It is a relatively inexpensive operation\n   to\
    \ create (and verify) \"fresh\" authenticators based on cached\n   authentication\
    \ context.\n      Claimant Actions      | Communications |  Verifier Actions\n\
    \                            |                |\n           verifier name    |\
    \                |\n                   |        |                |\n         \
    \          |        |           +---+|\n                   \\------------------->|\
    \   ||\n     trusted                |           |   ||\n   authorities       \
    \       |           |CDC||\n        |    +-----------+  |certificate|   ||\n \
    \       |    |  Verify   |<-------------|   ||\n        \\--->|Certificate|  |\
    \           +---+|\n             +-----------+  |                |\n     Claimant\
    \        |      |                |\n   credentials    Verifier  |            \
    \    |   Verifier\n        |       Public Key  |                | Credentials\n\
    \        |            |      |                |       |\n        |           \
    \ V      |                |       V\n        |    +-----------+  | Authentication\
    \ | +-----------+\n        |    |   Make    |  |     Token      | |   Check  \
    \ |   Replay\n        \\--->|  Token    |-------------------->|   Token   |<-->Cache\n\
    \             +-----------+  |                | +-----------+\n      DES <---/\
    \      |      |                |  |   |    \\----->DES\n      key            |\
    \      |                | /Claimant        key\n                     |      |\
    \                |/Public Key\n                     |      |                /\
    \      |        trusted\n                     |      |      Claimant /|      V\
    \     authorities\n                     |      |+---+   Name  / | +-----------+\
    \     |\n            authentication  ||   |<-------/  | |  Verify   |<----/\n\
    \               context      ||   |certificate| |Certificate|\n              \
    \       |      ||CDC|------------>|           |-->accept/\n                  \
    \   |      ||   |           | +-----------+   reject\n                     | \
    \     ||   |           |      |      \\\n                     |      |+---+  \
    \         |authentication\\\n                     V      |     mutual     |  \
    \ context     V\n             +-----------+  | authentication |      |      claimant\n\
    \          /--|  Accept   |  |    response    | +----------+credentials\n    \
    \     V   |  Mutual   |<--------------------|  Make    |(delegation)\n     accept/\
    \ +-----------+  |                | | Response |\n     reject                \
    \ |                | +----------+\n                            |             \
    \   |\n              Figure 1 - Authentication Exchange Overview\n"
- title: 1.5.5 Verification
  contents:
  - "1.5.5 Verification\n   Upon receipt of an authentication token, the verifier\
    \ extracts the\n   DES key using its verifier credentials, accesses the Name Service\n\
    \   (labeled CDC for Certificate Distribution Center) to obtain the\n   certificates\
    \ needed to perform cryptographic checks on the incoming\n   information, and\
    \ verifies all of the signatures on the received\n   certificates and the authentication\
    \ token.  Verification can result\n   in creation of new claimant credentials\
    \ if delegation is performed.\n   As part of this process, verified authenticators\
    \ are retained for a\n   suitable timeout period.\n"
- title: 1.5.6 Unenrolment
  contents:
  - "1.5.6 Unenrolment\n   This is the removal of information from the Name Service.\
    \ The only\n   other form of revocation supported by DASS is certificate timeout.\n\
    \   Every certificate contains an expiration time (expected in ordinary\n   use\
    \ to be about a year from its signing date).  DASS does not\n   currently support\
    \ the revocation lists in X.509.\n"
- title: 2. Services Used
  contents:
  - "2. Services Used\n   Aside from operating system services needed to maintain\
    \ its internal\n   state, DASS relies on a global distributed database in which\
    \ to store\n   its certificates, a reliable source of time, and a source of random\n\
    \   numbers for creating cryptographic keys.\n"
- title: 2.1 Time Service
  contents:
  - "2.1 Time Service\n   DASS requires access to the current time in several of its\n\
    \   algorithms.  Some of its uses of time are security critical.  In\n   others,\
    \ network synchronization of clocks is required.  DASS does\n   not, however,\
    \ depend on having a single source of time which is both\n   secure and tightly\
    \ synchronized.\n   The requirements on system provided time are:\n    - For purposes\
    \ of validating certificates and tickets, the\n      system needs access to know\
    \ the date and time accurate to\n      within a few hours with no particular synchronization\n\
    \      requirements.  If this time is inaccurate, then valid requests\n      may\
    \ be rejected and expired messages may be accepted.\n      Certificate expiration\
    \ is a backup revocation mechanism, so\n      this can only cause a security compromise\
    \ in the event of\n      multiple failures.  In theory, this could be provided\
    \ by\n      having a local clock on every node accurate to within a few\n    \
    \  hours over the life of the product to provide this function.\n      If an insecure\
    \ network time service is used to provide this\n      time, there are theoretical\
    \ security threats, but they are\n      expected to be logistically impractical\
    \ to exploit.\n    - For purposes of detecting replay of authentication tokens,\
    \ the\n      system needs access to a  strictly monotonic time source which\n\
    \      is reasonably synchronized across the network (within a few\n      minutes)\
    \ for the system to work, but inaccuracy does not\n      present a security threat\
    \ except as noted below. It may\n      constitute an availability threat because\
    \ valid requests may\n      be rejected.  In order to get strict monotonicity\
    \ in the\n      presence of a rapid series of requests, time must be returned\n\
    \      with high precision.  There is no requirement for a high\n      degree\
    \ of accuracy.  Inaccurate time could present a security\n      threat in the\
    \ following scenario: if a client's clock is made\n      sufficiently fast that\
    \ its tokens are rejected, someone\n      harvesting those tokens from the wire\
    \ could replay them later\n      and impersonate the client.  In some environments,\
    \ this might\n      be an easier threat than harvesting tokens and preventing\n\
    \      their delivery.\n    - For purposes of aging stale entries from caches,\
    \ DASS requires\n      reasonably accurate timing of intervals.  To the extent\
    \ that\n      intervals are reported as shorter than the actually were,\n    \
    \  revocation of certificates from the naming service may not be\n      as timely\
    \ as it should be.\n"
- title: 2.2 Random Numbers
  contents:
  - "2.2 Random Numbers\n   In order to generate keys, DASS needs a source of \"cryptographic\n\
    \   quality\" random numbers.  Cryptographic quality means that\n   knowing any\
    \ of the \"random numbers\" returned from a series and\n   knowing all state information\
    \ which is not protected, an attacker\n   cannot predict any of the other numbers\
    \ in the series.  Hardware\n   sources are ideal, but there are alternative techniques\
    \ which may\n   also be acceptable. A 56 bit \"truly random\" seed (say from a\n\
    \   series of coin tosses) could be used as a DES key to encrypt an\n   infinite\
    \ length known text block in CBC mode to produce a pseudo-rand\n   sequence provided\
    \ the key and current point in the sequence were\n   adequately protected.  There\
    \ is considerable controversy\n   surrounding what constitutes cryptographic quality\
    \ random\n   numbers, and it is not a goal of this document to resolve it.\n"
- title: 2.3 Naming Service
  contents:
  - "2.3 Naming Service\n   DASS stores creates and uses \"certificates\" associated\
    \ with every\n   principal in the system, and encrypted credentials associated\n\
    \   with most.  This information is stored in an on-line service\n   associated\
    \ with the principal being certified.  The long term\n   vision is for DASS to\
    \ use an X.500 naming service, and DASS will\n   from its inception authenticate\
    \ X.500 names.  To avoid a\n   dependence on having an X.500 naming service available\
    \ (and to\n   gain the benefits of a \"login agent\" that controls password\n\
    \   guessing), an alternative certificate  distribution center\n   protocol is\
    \ also described.\n   The specific requirements DASS places on the naming service\
    \ are:\n    - It must be highly available.  A user's naming service entry\n  \
    \    must be available to any node where the user is to obtain\n      services\
    \ (or service will be denied).  A server's naming\n      service entry must be\
    \ available from any node from which the\n      service is to be invoked (or service\
    \ will be denied).\n    - It must be timely.  The presence of \"stale\" information\
    \ in the\n      naming service may cause some problems.  When a password\n   \
    \   changes, the old password may remain valid (and the new\n      password invalid)\
    \ to the extent the naming service provides\n      stale information.  When a\
    \ user or server is added to the\n      network, it will not be able to participate\
    \ in authentication\n      until the information added to the naming service is\
    \ available\n      at the node doing the authentication.  In the unusual\n   \
    \   circumstance that a key changes, the entity whose key has\n      changed will\
    \ not be able to use the new key until the new\n      certificate is uniformly\
    \ available.\n    - It must be secure with regard to certain specific properties.\n\
    \      In general, the security of DASS protected applications does\n      not\
    \ depend on the security of the naming service.  It is\n      expected that the\
    \ availability needs of the naming service\n      will prevent it from being as\
    \ secure as some applications need\n      to be.  There are two aspects of DASS\
    \ security which do depend\n      on the security of the naming service: timely\
    \ revocation of\n      certificates and protection of user secrets against dictionary\n\
    \      based password guessing. DASS depends on the removal of\n      certificates\
    \ from the naming service in order to revoke them\n      more quickly than waiting\
    \ for them to time out.  For this\n      mechanism to provide any actual security,\
    \ it must not be\n      possible for a network entity to \"impersonate\" the naming\n\
    \      service and the naming service must be able to enforce access\n      controls\
    \ which prevent a revoked certificate from being\n      reinstated by an unauthorized\
    \ entity.  In the long run, it is\n      expected that DASS itself will be used\
    \ to secure the naming\n      service, which presents certain potential recursion\
    \ problems\n      (to be addressed in the naming service design).  If the naming\n\
    \      service is not authenticated (as is expected in early\n      versions)\
    \ attacks where a revoked certificate is \"reinstated\"\n      through impersonation\
    \ of the naming service are possible.\n   The specific functions DASS requests\
    \ of the naming service are\n   simple:\n    - Given an X.500 name, store a set\
    \ of certificates associated\n      with that name.\n    - Given an X.500 name,\
    \ retrieve the set of certificates\n      associated with that name.\n    - Given\
    \ an X.500 name, store a set of encrypted credentials\n      associated with that\
    \ name.\n    - Given and X.500 name, retrieve a set of encrypted credentials\n\
    \      associated with that name.\n   Implementation over a particular naming\
    \ service may implement more\n   specialized functions for reasons of efficiency.\
    \  For example, the\n   certificates associated with a name may be separated into\
    \ several\n   sets (child, parent, cross, self) so that only the relevant ones\
    \ may\n   be retrieved.  In order that access to the naming service itself be\n\
    \   secure, the protocols should be authenticated.  Certificates should\n   generally\
    \ be readable without authentication in order to avoid\n   recursion problems.\
    \  Requests to read encrypted credentials should be\n   specialized and should\
    \ include proof of knowledge of the password in\n   order that the naming service\
    \ can audit and slow down false password\n   guesses.\n   The following sections\
    \ describe the interfaces to specific naming\n   services:\n"
- title: 2.3.1 Interface to X.500
  contents:
  - "2.3.1 Interface to X.500\n   Certificates associated with a particular name are\
    \ stored as\n   attributes of the entry as specified in X.509.  X.509 defines\n\
    \   attributes appropriate for parent and cross certificates\n   (CrossCertificatePair,\
    \ CACertificate) for some principals; we will\n   have to define a DASSUserPrincipal\
    \ object class including these\n   attributes in order to properly use them with\
    \ ordinary users.\n   Retrieval is via normal X.500 protocols.  Certificates should\
    \ be\n   world readable and modifiable only by appropriate authorities.\n   Encrypted\
    \ credentials are stored with the entry of the principal\n   under a yet to be\
    \ defined attribute.  The credentials should be\n   encoded as specified in section\
    \ 4.  In the absence of extensions to\n   the X.500 protocol to control password\
    \ guessing, the encrypted\n   credentials should be world readable and updatable\
    \ only by the named\n   principal and other appropriate authorities.\n"
- title: 2.3.2 Interface to CDC
  contents:
  - "2.3.2 Interface to CDC\n   The CDC (Certificate Distribution Center) is a special\
    \ purpose name\n   server created to service DASS until an X.500 service is available\
    \ in\n   all of the environments where DASS needs to operate.  The CDC uses a\n\
    \   special purpose protocol to communicate with DASS clients.  The\n   protocol\
    \ was designed for efficiency, simplicity, and security.  CDCs\n   use DASS as\
    \ an authentication mechanism and to protect encrypted\n   credentials from unaudited\
    \ password guessing.\n   Each DASS client maintains a list of CDCs and the portion\
    \ of the\n   namespace served by that CDC.  Each directory has a master replica\n\
    \   which is the only one which will accept updates.  The CDCs maintain\n   consistency\
    \ with one another using protocols beyond the scope of this\n   document.  When\
    \ a DASS client wishes to make a request of a CDC, it\n   opens a TCP or DECnet\
    \ connection to the CDC and sends an ASN.1 (BER)\n   encoded request and receives\
    \ a corresponding ASN.1 (BER) encoded\n   response.  Clients are expected to learn\
    \ the IP or DECnet address and\n   port number of the CDC supporting a particular\
    \ name from a local\n   configuration file.  To maximize performance, the requests\
    \ bundle\n   what would be several requests if made in terms of requests for\n\
    \   individual certificates.  It is intended that all certificates needed\n  \
    \ for an authentication operation be retrievable with at most two CDC\n   requests/responses\
    \ (one to the CDC of the client and one to the CDC\n   of the server).\n   Documented\
    \ here is the protocol a DASS client would use to retrieve\n   certificates and\
    \ credentials from a CDC and update a user password.\n   This protocol does not\
    \ provide for updates to the certificate and\n   credential databases.  Such updates\
    \ must be supported for a practical\n   system, but could be done either by extensions\
    \ to this protocol or by\n   local security mechanisms implemented on nodes supporting\
    \ the CDC.\n   Similarly, availability can be enhanced by replicating the CDC.\n\
    \   Automating the replication of updates could be implemented by\n   extensions\
    \ to this protocol or by some other mechanism.  This\n   specification assumes\
    \ that updates and replication are local matters\n   solved by individual CA/CDC\
    \ implementations.\n   Requests and responses are encoded as follows:\n"
- title: 2.3.2.1 ReadPrinCertRequest
  contents:
  - "2.3.2.1 ReadPrinCertRequest\n   This request asks the CDC to return the child\
    \ certificates and\n   selected incoming cross certificates for the specified\
    \ object.  The\n   format of the request is:\n        ReadPrinCertRequest ::=\
    \ [4] IMPLICIT SEQUENCE {\n             flags [0] BIT STRING DEFAULT {},\n   \
    \          index [1] IMPLICIT INTEGER DEFAULT 0,\n             resolveFrom [2]\
    \ Name OPTIONAL,\n             principal Name,\n             crossCertIssuers\
    \ ListOfIssuers OPTIONAL\n             }\n        ListOfIssuers ::= SEQUENCE OF\
    \ Name\n   The first 24 bits of flags, if present, contain a protocol version\n\
    \   number.  Clients following this spec should place the value 2.0.0 in\n   the\
    \ three bytes.  Servers following this spec should accept any value\n   of the\
    \ form 1.x.x or 2.x.x.  flags bits beyond the first 24 are\n   reserved for future\
    \ use (should not be supplied by clients and should\n   be ignored by servers).\n\
    \   index is only used if the response exceeds the size of a single\n   message;\
    \ in that case, the query is repeated with index set to the\n   value that was\
    \ returned by ReadPrinCertResponse.  resolveFrom and\n   principal imply a set\
    \ of entities for which certificates should be\n   retrieved.  resolveFrom (if\
    \ present) must be an ancestor of principal\n   and child certificates will be\
    \ retrieved for principal and all names\n   which are ancestors of principal but\
    \ descendants of resolveFrom.  The\n   encoding of names is per X.500 and is specified\
    \ in more detail in\n   section 4.  The CDC returns the certificates in order\
    \ of the object\n   they came from, parents before children.\n   crossCertIssuers\
    \ is a list of cross certifiers that would be believed\n   in the context of this\
    \ authentication.  If supplied, the CDC may\n   return a chain of certificates\
    \ starting with one of the named\n   crossCertIssuers and ending with the named\
    \ principal.  One of\n   resolveFrom or crossCertIssuers must be present in any\
    \ request; if\n   both are present, the CDC may return either chain.\n"
- title: 2.3.2.2 ReadPrinCertResponse
  contents:
  - "2.3.2.2 ReadPrinCertResponse\n   This is the response a CDC sends to a ReadPrinCertRequest.\
    \  Its\n   syntax is:\n        ReadPrinCertResponse ::= [5] IMPLICIT SEQUENCE\
    \ {\n             status [0] IMPLICIT CDCstatus DEFAULT success,\n           \
    \  index [1] INTEGER OPTIONAL,\n             resolveTo [2] Name OPTIONAL,\n  \
    \           certSequence [3] IMPLICIT CertSequence,\n             indexInvalidator\
    \ [4] OCTET STRING (SIZE(8)) OPTIONAL,\n             flags [5] BIT STRING OPTIONAL\n\
    \             }\n        CertSequence ::= SEQUENCE OF Certificate\n   status indicates\
    \ success or the cause of the failure.\n   index if present indicates that the\
    \ request could not be fully\n   satisfied in a single request because of size\
    \ limitations.  The\n   request should be repeated with this index supplied in\
    \ the request to\n   get more.\n   resolveTo will be present if index is present\
    \ and should be supplied\n   in the request for more certificates.  certSequence\
    \ contains\n   certificates found matching the search criteria.\n   indexInvalidator\
    \ may be present and indicates the version of the\n   database being read.  If\
    \ a set of certificates is being read in\n   multiple requests (because there\
    \ were too many to return in a single\n   message), the reader should check that\
    \ the value for indexInvalidator\n   is the same on each request.  If it is not,\
    \ the server may have\n   skipped or duplicated some certificates.  This field\
    \ must not be\n   present if the version number in the request was missing or\
    \ version\n   1.x.x.\n   The first 24 bits of flags, if present, indicate the\
    \ protocol version\n   number.  Implementers of this version of the spec should\
    \ supply 2.0.0\n   and should accept any version number of the form 1.x.x or 2.x.x.\n"
- title: 2.3.2.3 ReadOutgoingCertRequest
  contents:
  - "2.3.2.3 ReadOutgoingCertRequest\n   This requests from the CDC a list of all\
    \ parent and outgoing cross\n   certificates for a specified object.  A CDC is\
    \ capable of storing\n   cross certificates either with the subject or the issuer\
    \ of the cross\n   certificate.  In response to this request, the CDC will return\
    \ all\n   parent and cross certificates stored with the issuer for the named\n\
    \   principal and all of its ancestors. Its syntax is:\n        ReadOutgoingCertRequest\
    \ ::= [6] IMPLICIT SEQUENCE {\n             flags [0] BIT STRING DEFAULT {},\n\
    \             index [1] IMPLICIT INTEGER DEFAULT 0,\n             principal Name\n\
    \             }\n   The first 24 bits of flags is a protocol version number and\
    \ should\n   contain 2.0.0 for clients implementing this version of the spec.\n\
    \   Servers implementing this version of the spec should accept any\n   version\
    \ number of the form 1.x.x or 2.x.x.  The remaining bits are\n   reserved for\
    \ future use (they should not be supplied by clients and\n   they should be ignored\
    \ by servers).\n   index is used for continuation (see ReadPrinCertRequest).\n\
    \   principal is the name for which certificates are requested.\n"
- title: 2.3.2.4 ReadOutgoingCertResponse
  contents:
  - "2.3.2.4 ReadOutgoingCertResponse\n   This is the response to a ReadOutgoingCertRequest.\
    \  Its syntax is:\n        ReadOutgoingCertResponse::= [7] IMPLICIT SEQUENCE {\n\
    \             status [0] IMPLICIT CDCStatus DEFAULT success,\n             index\
    \ [1] INTEGER OPTIONAL,\n             certSequence [2] IMPLICIT CertSequence,\n\
    \             indexInvalidator [3] OCTET STRING (SIZE(8))\n        OPTIONAL,\n\
    \             flags [4] BIT STRING OPTIONAL\n             }\n        CertSequence\
    \ ::= SEQUENCE OF Certificate\n   status indicates success of the cause of failure\
    \ of the operation.\n   index is used for continuation; see ReadPrinCertRequest.\n\
    \   certSequence is the list of parent and outgoing cross certificates.\n   indexInvalidator\
    \ is used for continuation; see ReadPrinCertResponse\n   (the same rules apply\
    \ with respect to version numbers).\n   The first 24 bits of flags, if present,\
    \ contain the protocol version\n   number.  Clients implementing this version\
    \ of the spec should supply\n   the value 2.0.0.  Servers should accept any values\
    \ of the form 1.x.x\n   or 2.x.x.  The remaining bits are reserved for future\
    \ use (they\n   should not be supplied by clients and should be ignored by servers).\n"
- title: 2.3.2.5 ReadCredentialRequest
  contents:
  - "2.3.2.5 ReadCredentialRequest\n   This request is made to retrieve an principal's\
    \ encrypted\n   credentials.  To prevent unaudited password guessing, this structure\n\
    \   includes an encrypted value that proves that the requester knows the\n   password\
    \ that will decrypt the structure.  The syntax of the request\n   is:\n      \
    \  ReadCredentialRequest ::= [2] IMPLICIT SEQUENCE {\n             flags [0] BIT\
    \ STRING DEFAULT {}\n             principal Name,\n             logindata [2]\
    \ BIT STRING DEFAULT {},\n             token [3] BIT STRING OPTIONAL\n       \
    \      }\n   The first 24 bits of flags contains the version number of the\n \
    \  protocol.  The value 2.0.0 should be supplied. Any value of the form\n   1.x.x\
    \ or 2.x.x should be accepted. Any additional bits are reserved\n   for future\
    \ use (should not be supplied by clients and should be\n   ignored by servers).\n\
    \   principal is the name of the principal for whom encrypted credentials\n  \
    \ are desired.\n   logindata is an encrypted value.  It may only be present if\
    \ the\n   version number is 2.0.0 or higher.  It must be present to read\n   credentials\
    \ which are protected by the login agent functionality of\n   the CDC.  It is\
    \ constructed as a single RSA block encrypted under the\n   public key of the\
    \ CDC.  The public key of the CDC is learned by some\n   local means.  Possibilities\
    \ include a local configuration file or by\n   using DASS to read and verify a\
    \ chain of certificates ending with the\n   CDC [the CDC serving a directory should\
    \ have its public key listed\n   under a name consisting of the directory name\
    \ with the RDN\n   \"CSS=X509\"; the OID for the type CSS is 1.3.24.9.1].  The\
    \ contents of\n   the block are as follows:\n    - The low order eight bytes contain\
    \ a randomly generated DES key\n      with the last byte of the DES key placed\
    \ in the last byte of\n      the RSA block.  This DES key will be used by the\
    \ CDC to\n      encrypt the response.  Key parity bits are ignored.\n    - The\
    \ next to last eight bytes contain a long Posix time with\n      the integer time\
    \ encoded as a byte string using big endian\n      order.\n    - The next eight\
    \ bytes (from the end) contain a hash of the\n      password.  The algorithm for\
    \ computing this hash is listed in\n      section 4.4.2.  The CDC never computes\
    \ this hash; it simply\n      compares the value it receives with the value associated\
    \ with\n      the credentials.\n    - The next sixteen bytes (from the end) contain\
    \ zero.\n    - The remainder of the RSA block (which should be the same size\n\
    \      as the public modulus of the CDC) contains a random number.\n      The\
    \ first byte should be chosen to be non-zero but so the\n      value in the block\
    \ does not exceed the RSA modulus.  Servers\n      should ignore these bits. \
    \ This random number need not be of\n      cryptographic strength, but should\
    \ not be the same value for\n      all encryptions.  Repeating the DES key would\
    \ be adequate.\n    - The byte string thus constructed is encrypted using the\
    \ RSA\n      algorithm by treating the string of bytes as a \"big endian\"\n \
    \     integer and treating the integer result as \"big endian\" to\n      make\
    \ a string of bytes.\n   token will not be present in the initial implementation\
    \ but a space\n   is reserved in case some future implementation wants to authenticate\n\
    \   and audit the node from which a user is logging in.\n"
- title: 2.3.2.6 ReadCredentialProtectedResponse
  contents:
  - "2.3.2.6 ReadCredentialProtectedResponse\n   This is the second possible response\
    \ to a ReadPrinLoginRequest.  It\n   is returned when the encrypted credentials\
    \ are protected from\n   password guessing by the CDC acting as a login agent.\
    \  Its syntax is:\n   ReadCredentialProtectedResponse::=[16] IMPLICIT SEQUENCE\
    \ {\n           status [0] IMPLICIT CDCStatus DEFAULT success,\n           encryptedCredential\
    \ [1] BIT STRING,\n           flags [2] BIT STRING OPTIONAL\n           }\n  \
    \ status indicates that the request succeeded or the cause of the\n   failure.\n\
    \   encryptedCredential contains the DASSPrivateKey structure (defined in\n  \
    \ section 4.1) encrypted under a DES key computed from the user's name\n   and\
    \ password as specified in section 4.4.2 and then reencrypted under\n   the DES\
    \ key provided in the ReadPrinLoginRequest.\n   The first 24 bits of flags, if\
    \ present, contains the version number\n   of the protocol.  Implementers of this\
    \ version of the spec should\n   supply 2.0.0 and should accept any version number\
    \ of the form 2.x.x.\n   Other bits are reserved for future use (they should not\
    \ be supplied\n   and they should be ignored).\n"
- title: 2.3.2.7 WriteCredentialRequest
  contents:
  - "2.3.2.7 WriteCredentialRequest\n   This is a request to update the encrypted\
    \ credential structure.  It\n   is used when a user's key or password changes.\
    \  The syntax of the\n   request is:\n        WriteCredentialRequest ::= [17]\
    \ IMPLICIT SEQUENCE {\n             flags [0] BIT STRING DEFAULT {},\n       \
    \      authtoken [2] BIT STRING OPTIONAL,\n             principal [3] Name,\n\
    \             logindata [4] BIT STRING DEFAULT {},\n             furtherSensitiveStuff\
    \ [5] BIT STRING\n             }\n   The first 24 bits of flags is a version number.\
    \  Clients implementing\n   this version of the spec should supply 2.0.0.  Servers\
    \ should accept\n   any value of the form 2.x.x.  Additional bits are reserved\
    \ for future\n   use (clients should not supply them and servers should ignore\
    \ them).\n   token, if present, authenticates the entity making the request. \
    \ A\n   request will be accepted either from a principal proving knowledge of\n\
    \   the password (see logindata below) or a principal presenting a token\n   in\
    \ this field and satisfying the authorization policy of the CDC.\n   This field\
    \ need not be present if logindata includes the hash2 of the\n   password (anyone\
    \ knowing the old password may set a new one).\n   principal is the name of the\
    \ object for which encrypted credentials\n   should be updated.\n   logindata\
    \ is encrypted as in ReadPrinLoginRequest.  It proves that\n   the requester knows\
    \ the old password of the principal to be updated\n   (unless the token supplied\
    \ is from the user's CA) and includes the\n   key which encrypts furtherSensitiveStuff.\n\
    \   furtherSensitiveStuff is an encrypted field constructed as follows:\n    -\
    \ The first eight bytes consist of the hash2 defined in section\n      4.4.2 with\
    \ the last byte of the hash2 value stored first.  The\n      CDC stores this value\
    \ and compares it with the values supplied\n      in future requests of ReadCredentialRequest\
    \ and\n      WriteCredentialRequest.\n    - The next (variable number of) bytes\
    \ contains a DASSPrivateKey\n      structure (defined in section 4.1).  This is\
    \ the new\n      credential structure that will be returned by the CDC on\n  \
    \    future ReadCredentialRequests.\n    - The result is padded with zero bytes\
    \ to a multiple of eight\n      bytes.\n    - The entire padded string is encrypted\
    \ using the key from\n      logindata or token using DES in CBC mode with zero\
    \ IV.\n   the new eight byte \"hash2\" defined in section 4.4.2 concatenated with\n\
    \   the DASSPrivateKey structure encrypted under the new \"hash1\" all\n   encrypted\
    \ under the DES key included in logindata.\n"
- title: 2.3.2.8 HereIsStatus
  contents:
  - "2.3.2.8 HereIsStatus\n   This is the response message to ill-formed requests\
    \ and requests that\n   only return a status and no data.  It's syntax is:\n \
    \       HereIsStatus ::= [1] IMPLICIT SEQUENCE {\n             status [0] IMPLICIT\
    \ CDCStatus DEFAULT success\n             }\n   status indicates success or the\
    \ cause of the failure.\n"
- title: 2.3.2.9 Status Codes
  contents:
  - "2.3.2.9 Status Codes\n   The following are the CDCStatus codes that can be returned\
    \ by\n   servers.  Not all of these values are possible with all calls, and\n\
    \   some of the status codes are not possible with any of the calls\n   described\
    \ in this document.\n        CDCStatus ::= INTEGER {\n             success(0),\n\
    \             accessDenied(1),\n             wrongCDC(2),     --this CDC does\
    \ not store the\n                              --requested information\n     \
    \        unrecognizedCA(3),\n             unrecognizedPrincipal(4),\n        \
    \     decodeRequestError(5),--invalid BER\n             illegalRequest(6),   \
    \ --request not recognised\n             objectDoesNotExist(7),\n            \
    \ illegalAttribute(8),\n             notPrimaryCDC(9),--write requests not accepted\n\
    \                              --at this CDC replica\n             authenticationFailure(11),\n\
    \             incorrectPassword(12),\n             objectAlreadyExists(13),\n\
    \             objectWouldBeOrphan(15),\n             objectIsPermanent(16),\n\
    \             objectIsTentative(17),\n             parentIsTentative(18),\n  \
    \           certificateNotFound(19),\n             attributeNotFound(20),\n  \
    \           ioErrorOnCertifDatabase(100),\n             databaseFull(101),\n \
    \            serverInternalError(102),\n             serverFatalError(103),\n\
    \             insufficientResources(104)\n             }\n"
- title: 3. Services Provided
  contents:
  - "3. Services Provided\n   This section specifies the services provided by DASS\
    \ in terms of\n   abstract interfaces and a model implementation.  A particular\n\
    \   implementation may support only a subset of these services and may\n   provide\
    \ them through interfaces which combine functions and supply\n   some parameters\
    \ implicitly. The specific calling interfaces are in\n   some cases language and\
    \ operating system specific.  An actual\n   implementation may choose, for example,\
    \ to structure interfaces so\n   that security contexts are established and then\
    \ passed implicitly in\n   calls rather than explicitly including them in every\
    \ call.  It might\n   also bundle keys into opaque structures to be used with\
    \ supplied\n   encryption and decryption routines in order to enhance security\
    \ and\n   modularity and better comply with export regulations. Annex B\n   describes\
    \ a Portable API designed so that applications using a\n   limited subset of the\
    \ capabilities of DASS can be easily ported\n   between operating systems and\
    \ between DASS and Kerberos based\n   environments.  The model implementation\
    \ describes data structures\n   which include cached values to enhance performance.\
    \  Implementations\n   may choose different contents or different caching strategies\
    \ so long\n   as the same sequence of calls would produce the same output for\
    \ some\n   caching policy.\n   DASS operates on four kinds of data structures:\
    \ Certificates,\n   Credentials, Tokens, and Certification Authority State.  Certificates\n\
    \   and Tokens are passed between implementations and thus their exact\n   format\
    \ must be architecturally specified. This detailed bit-for-bit\n   specification\
    \ is in section 4. Credentials generally exist only\n   within a single node and\
    \ their format is therefore not specified\n   here. The contents of all of these\
    \ data structures is listed below\n   followed by the algorithms for manipulating\
    \ them.\n   There are three kinds of services provided by DASS: Certificate\n\
    \   Maintenance, Credential Maintenance, and Authentication. The first\n   two\
    \ kinds exist only in support of the third. Certificate maintenance\n   functions\
    \ maintain the database of public keys in the naming service.\n   These functions\
    \ tend to be fairly specialized and may not be\n   supported on all platforms.\
    \ Before authentication can take place,\n   both authenticating principals must\
    \ have constructed credentials\n   structures. These are built using the Credential\
    \ Maintenance calls.\n   The Authentication functions use credential information\
    \ and\n   certificates, produce and consume authentication tokens and tell the\n\
    \   two communicating parties one another's names.\n"
- title: 3.1 Certificate Contents
  contents:
  - "3.1 Certificate Contents\n   For purposes of this architecture, a certificate\
    \ is a data structure\n   posted in the naming service which proclaims that knowledge\
    \ of the\n   private key associated with a stated public key authenticates a named\n\
    \   principal. Certificates are \"signed\" by some authority, are readable\n \
    \  by anyone, and can be verified by anyone knowing the public key of\n   the\
    \ authority.  DASS organizes the CA trust hierarchy around the\n   naming hierarchy.\
    \ There exists a trusted authority associated with\n   each directory in the naming\
    \ hierarchy. Generally, each authority\n   creates certificates stating the public\
    \ keys of each of its children\n   (in the naming hierarchy) and the public key\
    \ of its parent (in the\n   naming hierarchy). In this way, anyone knowing the\
    \ public key of any\n   authority can learn the public key of any other by \"\
    walking the\n   tree\". In order that principals may authenticate even when all\
    \ of\n   their ancestor directories do not participate in DASS, authorities\n\
    \   may also create \"cross-certificates\" which certify the public key of\n \
    \  a named entity which is not a descendent.  Rules for finding and\n   following\
    \ these cross-certificates are described in the Get_Pub_Keys\n   routines.  Every\
    \ principal is expected to know the public key of the\n   CA of the directory\
    \ in which it is named. This must be securely\n   learned when the principal is\
    \ initialized and may be maintained in\n   some form of local storage or by having\
    \ the principal sign a\n   certificate listing the name and public key of its\
    \ parent and posting\n   that certificate in the naming service.\n   The syntax\
    \ and content of DASS certificates are defined in terms of\n   X.509 (Directory\
    \ - Authentication Framework).  While that standard\n   prescribes a single syntax\
    \ for certificates, DASS considers\n   certificates to be of one of six types:\n\
    \    - Normal Principal certificates are signed by a CA and certify\n      the\
    \ name and public key of a principal where the name of the\n      CA is a prefix\
    \ of the name of the principal and is one\n      component shorter.\n    - Trusted\
    \ Authority certificates are signed by an ordinary\n      principal and certify\
    \ the name and public key of the\n      principal's CA (i.e., the CA whose name\
    \ is a prefix of the\n      principal's name and is one component shorter).\n\
    \    - Child certificates are signed by a CA and certify the name and\n      public\
    \ key of a CA of a descendent directory (i.e., where the\n      name of the issuing\
    \ CA is a prefix of the name of the subject\n      CA and is one component shorter).\n\
    \    - Parent certificates are signed by a CA and certify the name\n      and\
    \ public key of the CA of its parent directory (i.e., whose\n      name is a prefix\
    \ of the name of the issuer and is one\n      component shorter).\n    - Cross\
    \ certificates are signed by a CA and certify the name and\n      public key of\
    \ a CA of a directory where neither name is a\n      prefix of the other.\n  \
    \  - Self certificates are signed by a principal or a CA and the\n      issuer\
    \ and subject name are the same.  They are not used in\n      this version of\
    \ the architecture but are defined as a\n      convenient data structure in which\
    \ in which implementations\n      may insecurely pass public keys and they may\
    \ be used in the\n      future in certain key roll-over procedures.\n   It is\
    \ intended that some future version of the architecture relax the\n   restrictions\
    \ above where prefixes must be one component shorter.\n   Being able to handle\
    \ certificates where prefixes are two or more\n   components shorter complicates\
    \ the logic of treewalking somewhat and\n   is not immediately necessary, so such\
    \ certificates are disallowed for\n   now.\n   The syntax of certificates is defined\
    \ in section 4. For purposes of\n   the algorithms which follow, the following\
    \ is the portion of the\n   content which is used (names in brackets refer to\
    \ the field names in\n   the ASN.1 encoded structure):\n    - UID of the issuer\
    \ (optional)\n    - Full name of the issuer (the authority or principal signing)\n\
    \      [issuer]\n    - UID of the subject (optional)\n    - Full name of the subject\
    \ (the authority or principal whose key\n      is being certified) [subject]\n\
    \    - Public Key of the subject [subjectPublicKey]\n    - Period of validity\
    \ (effective date and expiration date)\n      [valid]\n    - Signature over the\
    \ entire content of the certificate created\n      using the private key of the\
    \ issuer.\n   When parsing a certificate, the reader compares the two name fields\n\
    \   to determine what type of certificate it is. For Parent and Trusted\n   Authority\
    \ certificates, the names are ignored for purposes of all\n   further processing.\
    \ For Child and Normal Principal certificates, only\n   the suffix by which the\
    \ child's name is longer than the parent's is\n   used for further processing.\
    \ The reason for this is so that if a\n   branch of the namespace is renamed,\
    \ all of the certificates in the\n   moved branch remain valid for purposes of\
    \ DASS processing. The only\n   purposes of having full names in these certificates\
    \ are (1) to comply\n   with X.509, (2) for possible interoperability with other\n\
    \   architectures using different algorithms, and (3) to allow principals\n  \
    \ to securely store their own names in trusted authority certificates\n   in the\
    \ case where they do not have enough local storage to keep it.\n"
- title: 3.2 Encrypted Private Key Structure
  contents:
  - "3.2 Encrypted Private Key Structure\n   In order that humans need only remember\
    \ a password rather than a full\n   set of credentials, and also to make installation\
    \ of nodes and\n   servers easier, there is a defined format for encrypting RSA\
    \ secrets\n   under a password and posting in the naming service. This structure\n\
    \   need only exist when passwords are used to protect RSA secrets; for\n   servers\
    \ which keep their secrets in non-volatile memory or users who\n   carry smart\
    \ cards, they are unnecessary.\n   This structure includes the RSA private/public\
    \ key pair encrypted\n   under a DES key. The DES key is computed as a one-way\
    \ hash of the\n   password.  This structure also optionally includes the UID of\
    \ the\n   principal.  It is needed only if a single RSA key is shared by\n   multiple\
    \ principals (with multiple UIDs).\n   Since this structure is posted in the name\
    \ service and may be used by\n   multiple implementations, its format must be\
    \ architecturally defined.\n   The exact encoding is listed in section 4.\n"
- title: 3.3 Authentication Tokens
  contents:
  - "3.3 Authentication Tokens\n   This section of the document defines the contents\
    \ of the\n   authentication tokens which are produced and consumed by Create_token\n\
    \   and Accept_token. With DASS, the token passed from the client to the\n   server\
    \ is complex, with a large number of optional parts, while the\n   token passed\
    \ from server to client (in the case of mutual\n   authentication only) is small\
    \ and simple.\n   The authentication token potentially contains a large number\
    \ of\n   parts, most of which are optional depending on the type of\n   authentication.\
    \ The following defines the content and purpose of each\n   of the parts, but\
    \ does not describe the actual encoding (in the\n   belief that such details would\
    \ be distracting). The encoding is in\n   section 4.\n   The authentication process\
    \ begins when the initiator calls\n   Create_token with the name of the target.\
    \ This routine returns an\n   authentication token, which is sent to the target.\
    \ The target calls\n   Accept_token passing it the token. Both routines produce\
    \ a second\n   \"mutual authentication token\". The target returns this to the\n\
    \   initiator to prove that it received the token.\n"
- title: 3.3.1 Initial Authentication Token
  contents:
  - "3.3.1 Initial Authentication Token\n   The components of the initial authentication\
    \ token are (names in\n   brackets refer to the field names within the ASN.1 encoded\
    \ structures\n   defined in section 4):\n    a) Encrypted Shared Key - [authenticatingKey]\
    \ - This is a Shared\n       (DES) key encrypted under the public key of the target.\
    \ Also\n       included in the encrypted structure is a validity interval and\n\
    \       a recognizable pattern so that the receiver can tell whether\n       the\
    \ decryption was successful.\n    b) Login Ticket - [sourcePrincipal.userTicket]\
    \ - This is a\n       \"delegation certificate\" signed by a principal's long\
    \ term\n       private key delegating to a short term public key. Its \"active\n\
    \       ingredients\" are:\n      1) UID of delegating principal [subjectUID]\n\
    \      2) Period of validity [validity]\n      3) Delegation public key [delegatingPublicKey]\n\
    \      4) Signature by private key of principal\n         The existence of this\
    \ signature is testimony that the\n         private key corresponding to the delegation\
    \ public key\n         speaks for the user during the validity interval.\n   \
    \      This data structure is optional and will be missing if the\n         authentication\
    \ is only on behalf of a Local Username on a\n         node (i.e., proxy) rather\
    \ than on behalf of a real principal\n         with a real key.\n    c) Shared\
    \ Key Ticket - [sourcePrincipal.sharedKeyTicketSignature]\n       - This is a\
    \ signature of the Encrypted Shared Key by the\n       Delegation Public key in\
    \ the Login Ticket.  The existence of\n       this signature is testimony that\
    \  the DES key in the encrypted\n       shared key speaks for the user.\n    \
    \   This data structure is optional and will be missing if the\n       authentication\
    \ is only on behalf of a Local Username on a node\n       (i.e., proxy) rather\
    \ than on behalf of a real principal with a\n       real key. It will also be\
    \ missing if delegation is taking\n       place.\n    d) Node Ticket - [sourceNode.nodeTicketSignature]\
    \ - This is a\n       signature of the Encrypted Shared key and a \"Local Username\"\
    \n       on the host node by the node's private key.  The existence of\n     \
    \  this signature is testimony by the node that the DES key in\n       the encrypted\
    \ shared key speaks for the named account on that\n       node.\n    e) Delegator\
    \ - [sourcePrincipal.delegator] - This data structure\n       contains the private\
    \ login key encrypted under the Shared key.\n       It is optional and is present\
    \ only if the initiator is\n       delegating to the destination.\n    f) Authenticator\
    \ - [authenticatorData] - This data structure\n       contains a timestamp and\
    \ a message digest of the channel\n       bindings signed by the Shared Key. It\
    \ is always present.\n    g) Principal name - [sourcePrincipal.userName] - This\
    \ is the name\n       of the initiating principal. It is optional and will be\n\
    \       missing for strong proxy where bits on the wire are at a\n       premium\
    \ and where the destination is capable of independently\n       constructing the\
    \ name.\n    h) Node name - [sourceNode.nodeName] - This is the name of the\n\
    \       initiating node. It is optional and will be missing for strong\n     \
    \  proxy where bits on the wire are at a premium and the name is\n       present\
    \ elsewhere in the message being passed.\n    i) Local Username - [sourceNode.username]\
    \ - This is the local\n       user name on the initiating node. It is optional\
    \ and will be\n       missing for strong proxy where bits on the wire are at a\n\
    \       premium and where the name is present elsewhere in the message\n     \
    \  being passed.\n"
- title: 3.3.2 Mutual Authentication Token
  contents:
  - "3.3.2 Mutual Authentication Token\n   The authentication buffer sent from the\
    \ target to the initiator (in\n   the case of mutual authentication) is much simpler.\
    \ It contains only\n   the timestamp taken from the authenticator encrypted under\
    \ the Shared\n   Key.  It is ASN.1 encoded to allow for future extensions.\n"
- title: 3.4 Credentials
  contents:
  - "3.4 Credentials\n   DASS organizes its internal state with Credentials structures.\
    \  There\n   are many kinds of information which can be stored in credentials.\n\
    \   Rather than making a different kind of data structure for each kind\n   of\
    \ data, DASS provides a single credentials structure where most of\n   its fields\
    \ are optional.  Operating systems must provide some\n   mechanism for having\
    \ several processes share credentials. An example\n   of a mechanism for doing\
    \ this would be for credentials to be stored\n   in a file and the name of the\
    \ file is used as a \"handle\" by all\n   processes which use those credentials.\
    \ Some of the calls which follow\n   cause credentials structures to be updated.\
    \ It is important to the\n   performance of a system that updates to credentials\
    \ (such as occur\n   during the routines Verify_Principal_Name and Verify_Node_Name,\
    \ where\n   the caches are updated) be visible to all processes sharing those\n\
    \   credentials.\n   In many of the calls which follow, the credentials passed\
    \ may be\n   labeled: claimant credentials, verifier credentials or some such.\n\
    \   This indicates whose credentials are being passed rather than a type\n   of\
    \ credentials. DASS supports only one type of credentials, though\n   the fields\
    \ present in the credentials of one sort of principal may be\n   quite different\
    \ from those present in the credentials of another.\n   An implementation may\
    \ choose to support multiple kinds of credentials\n   structures each of which\
    \ will support only a subset of the functions\n   available if it is not implementing\
    \ the full architecture.  This\n   would be the case, for example, if an implementation\
    \ did not support\n   the case where a server both received requests from other\
    \ principals\n   and made requests on its own behalf using a single set of\n \
    \  credentials.\n   The following are a list of the fields that may be contained\
    \ in a\n   credentials structure. They are grouped according to common usage.\n"
- title: 3.4.1 Claimant information
  contents:
  - "3.4.1 Claimant information\n   This is the information used when the holder of\
    \ these credentials is\n   requesting something. It includes:\n    a) Full X.500\
    \ name of the principal\n    b) Public Key of the principal\n    c) Login Ticket\
    \ - a login ticket contains:\n      1) the UID of the principal\n      2) a period\
    \ of validity (effective date & expiration date)\n      3) a delegation public\
    \ key\n      4) a signature of the ticket contents by the principal's long\n \
    \        term key\n    d) Delegation Private Key (corresponding to the public\
    \ key in c3)\n    e) Encrypted Shared Key (present only when credentials were\n\
    \       created by accept_token; this information is needed to verify\n      \
    \ a node ticket after credentials are accepted)\n"
- title: 3.4.2 Verifier information
  contents:
  - "3.4.2 Verifier information\n   This is the information needed by a server to\
    \ decrypt incoming\n   requests. It is also used by generate_server_ticket to\
    \ generate a\n   login ticket.\n    a) RSA private key.\n"
- title: 3.4.3 Trusted Authority
  contents:
  - "3.4.3 Trusted Authority\n   This is information used to seed the walk of the\
    \ CA hierarchy to\n   reliably find the public key(s) associated with a name.\n\
    \   Normally, the trusted authority in a set of credentials will be\n   the directory\
    \ parent of the principal named in Claimant\n   information.  In some circumstances,\
    \ it may instead be the\n   directory parent of the node on which the credentials\
    \ reside.\n    a) Full X.500 name of a CA\n    b) Corresponding RSA Public Key\n\
    \    c) Corresponding UID\n"
- title: 3.4.4 Remote node authentication
  contents:
  - "3.4.4 Remote node authentication\n   This information is present only for credentials\
    \ generated by\n   \"Accept_token\". It includes information about any remote\
    \ node which\n   vouched for the request.\n    a) Full X.500 name of the node\n\
    \    b) Local Username on the node\n    c) Node ticket.\n"
- title: 3.4.5 Local node credentials
  contents:
  - "3.4.5 Local node credentials\n   This information is added by Combine_credentials,\
    \ and is used by\n   Create_token to add a node signature to outbound requests.\n\
    \    a) Full X.500 name of the node\n    b) Local Username on the node\n    c)\
    \ RSA private key of the node\n"
- title: 3.4.6 Cached outgoing contexts
  contents:
  - "3.4.6 Cached outgoing contexts\n   There may be one (or more) such structures\
    \ for each server for which\n   this principal has created authentication tokens.\
    \ These represent a\n   cache: they may be discarded at any time with no effect\
    \ except on\n   performance. For each association, the following information is\
    \ kept:\n    a) Destination RSA Public Key (index)\n    b) Encrypted Shared key\n\
    \    c) Shared Key Ticket (optional, included if there has been a\n       non-delegating\
    \ connection)\n    d) Node Ticket\n    e) Delegator (optional, included if there\
    \ has been a delegating\n       connection)\n    f) Validity interval\n    g)\
    \ Shared Key\n"
- title: 3.4.7 Cached Incoming Contexts
  contents:
  - "3.4.7 Cached Incoming Contexts\n   There may be one such structure for each client\
    \ from which this server\n   has received an authentication token.  These represent\
    \ a cache: they\n   may be discarded at any time with no effect except on performance.\
    \ (An\n   implementation may choose to keep one System-wide Cache (and list of\n\
    \   incoming timestamps). While it is unlikely that the same Encrypted\n   Shared\
    \ Key will result from encryption of Shared keys generated by\n   different clients\
    \ or for different servers, an implementation must\n   ensure that an entry made\
    \ for one client/server can not be reused by\n   another client/server.  Similarly\
    \ an implementation may choose to keep\n   separate caches for the Shared Key/Validity\
    \ Interval/Delegation Public\n   Key, the Nodename/UID/key/username and the Principal\
    \ name/UID/key.)\n   For each association, the following information is kept:\n\
    \    a) Encrypted Shared key (index)\n    b) Shared Key\n    c) Validity Interval\n\
    \    d) Full X.500 name of Client Principal\n    e) UID of Client Principal\n\
    \    f) Public Key of Client Principal\n    g) Name of Client Node\n    h) UID\
    \ of Client Node\n    i) Public Key of Client Node\n    j) Local Username on Client\
    \ node\n    k) Delegation Public key of Client Principal's Login Ticket\n   The\
    \ Name, UID and Public key of the Principal are all entered\n   together once\
    \ the Login Ticket has been verified. Similarly the Node\n   name, Node key and\
    \ Username are entered together once the Node Ticket\n   has been verified. These\
    \ pieces of information are only present if\n   they have been verified.\n"
- title: 3.4.8 Received Authenticators
  contents:
  - "3.4.8 Received Authenticators\n   A record of all the authenticators received\
    \ is kept. This is used to\n   detect replayed messages. (This list must be common\
    \ to all targets\n   that could accept the same authenticator (channel bindings\
    \ will\n   prevent other targets from accepting the same authenticator). This\n\
    \   includes different `servers' sharing the same key.)  The entries in\n   this\
    \ list may be deleted when the timestamp is old enough that they\n   would no\
    \ longer be accepted. This list is kept separate from the\n   Cached incoming\
    \ context in order that the information in the cached\n   incoming context can\
    \ be discarded at any time. An implementation\n   could choose to save these timestamps\
    \ with the cached incoming\n   context if it ensures that it can never purge entries\
    \ from the cache\n   before the timestamp has aged sufficiently. This list is\
    \ accessed\n   based on an extract from the signature from the Authenticator.\
    \ The\n   extract must be at least 64 bits, to ensure that it is very unlikely\n\
    \   that 2 authenticators will be received with matching signatures.\n    a) Extract\
    \ from Signature from Authenticator\n    b) Timestamp\n   If an implementation\
    \ runs out of space to store additional\n   authenticators, it may either reject\
    \ the token which would have\n   overflowed the table or it may temporarily narrow\
    \ the allowed clock\n   skew to allow it to free some of the space used to hold\
    \ \"old\"\n   authenticators.  The first strategy will always falsely reject\n\
    \   tokens; the second may cause false rejection of tokens if the allowed\n  \
    \ clock skew gets narrowed beyond the actual clock skew in the network.\n"
- title: 3.5 CA State
  contents:
  - "3.5 CA State\n   The CA needs to maintain some internal state in order to generate\n\
    \   certificates. This internal state must be protected at all times, and\n  \
    \ great care must be taken to prevent its being disclosed. A CA may\n   choose\
    \ to maintain additional state information in order to enhance\n   security. \
    \ In particular, it is the responsibility of the CA to\n   assure that the same\
    \ UID is not serially reused by two holders of a\n   single name.  In most cases,\
    \ this can be done by creating the UID at\n   the time the user is registered.\
    \  To securely permit users to keep\n   their UIDs when transferring from another\
    \ CA, the CA must keep a\n   record of any UIDs used by previous holders of the\
    \ name. Since\n   actions of a CA are so security sensitive, the CA should also\n\
    \   maintain an audit trail of all certificates signed so that a history\n   can\
    \ be reconstructed in the event of a compromise.  Finally, for the\n   convenience\
    \ of the CA operator, the CA should record a list of the\n   directories for which\
    \ it is responsible and their UIDs so that these\n   need not be entered whenever\
    \ the CA is to be used.  The state\n   includes at least the following information:\n\
    \    - Public Key of CA\n    - Private Key of CA\n    - Serial number of next\
    \ certificate to be issued\n"
- title: 3.6 Data types used in the routines
  contents:
  - "3.6 Data types used in the routines\n   There are several abstract data types\
    \ used as parameters to the\n   routines described in this section. These are\
    \ listed here\n    a) Integer\n    b) Name\n       Names unless otherwise noted\
    \ are always X.500 names.  While\n       most of the design of DASS is naming\
    \ service independent, the\n       syntax of certificates and tokens only permits\
    \ X.500 names to\n       be used.  If DASS is to be used in an environment where\
    \ some\n       other form of name is used, those names must be translated\n  \
    \     into something syntactically compliant with X.500 using some\n       mechanism\
    \ which is beyond the scope of this architecture.  The\n       only other form\
    \ of name appearing in this architecture is a\n       \"local user name\", which\
    \ corresponds to the simple name of an\n       \"account\" on a node.  As a type,\
    \ such names appear in\n       parameter lists as \"Strings\".\n    c) String\n\
    \       A String is a sequence of printable characters.\n    d) Absolute Time\n\
    \       A UTC time. The precision of these Times is not stated. A\n       precision\
    \ of the order of one second in all times is\n       sufficient.\n    e) Time\
    \ Interval\n       A Time interval is composed of 2 times. A Start Time and an\n\
    \       End Time, both of which are Absolute Times\n    f) Timestamp\n       A\
    \ Timestamp is a time in POSIX format. I.e., two 32 bit\n       Integers. The\
    \ first representing seconds, and the second\n       representing nanoseconds.\n\
    \    g) Duration\n       A Duration is the length of a time interval.\n    h)\
    \ Octet String\n       A sequence of bytes containing binary data\n    i) Boolean\n\
    \       A value of either True or False\n    j) UID\n       A UID is an bit string\
    \ of 128 bits.\n    k) OID\n       An OID is an ISO Object Identifier.\n    l)\
    \ Shared key\n       A Shared key is a DES key, a sequence of 8 bytes\n    m)\
    \ CA State\n       A structure of the form described in '3.5\n    n) Credentials\n\
    \       A structure of the form described in '3.4\n    o) Certificate\n      \
    \ An ASN.1 encoding of the structure described in '3.1\n    p) Authentication\
    \ Token\n       An ASN.1 encoding of the structure described in '3.3.1\n    q)\
    \ Mutual Authentication Token\n       An ASN.1 encoding of the structure described\
    \ in '3.3.2\n    r) Encrypted Credentials\n       An ASN.1 encoding of  the  structure\
    \ described in '3.2\n    s) Public key\n       A representation of an RSA Public\
    \ key, including all the\n       information needed to encode the public key in\
    \ a certificate.\n    t) Set of Public key/UID pairs\n       A set of Public key/UID\
    \ pairs. This Data type is only used\n       internally in DASS - it does not\
    \ appear in any interface used\n       to other architectures.\n"
- title: 3.7 Error conditions
  contents:
  - "3.7 Error conditions\n   These routines can return the following error conditions\
    \ (an\n   implementation may indicate errors with more or less precision):\n \
    \   a) Incomplete chain of trustworthy CAs\n    b) Target has no keys which can\
    \ be trusted.\n    c) Invalid Authentication Token\n    d) Login Ticket Expired\n\
    \    e) Invalid Password\n    f) Invalid Credentials\n    g) Invalid Authenticator\n\
    \    h) Duplicate Authenticator\n"
- title: 3.8 Certificate Maintenance Functions
  contents:
  - "3.8 Certificate Maintenance Functions\n   Authentication services depend on a\
    \ set of data structures maintained\n   in the naming service. There are two kinds\
    \ of information:\n   Certificates, which associate names and public keys and\
    \ are signed by\n   off-line Certification Authorities; and Encrypted Credentials,\
    \ which\n   contain RSA Private Keys and certain context information encrypted\n\
    \   under passwords. Encrypted Credentials are only necessary in\n   environments\
    \ where passwords are used. Credentials may alternatively\n   be stored in some\
    \ other secure manner (for example on a smart card).\n   The certificate maintenance\
    \ services are designed so that the most\n   sensitive - the actual signing of\
    \ certificates - may be done by an\n   off-line authority.  Once signed, certificates\
    \ must be posted in the\n   naming service to be believed.  The precise mechanisms\
    \ for moving\n   certificates between off-line CAs and the on-line naming service\
    \ are\n   implementation dependent.  For the off-line mechanisms to provide any\n\
    \   actual security, the CAs must be told what to sign in some reliable\n   manner.\
    \  The mechanisms for doing this are implementation dependent.\n   The abstract\
    \ interface says that the CA is given all of the\n   information that goes into\
    \ a certificate and it produces the signed\n   certificate.  There are requirements\
    \ surrounding the auditing of a\n   CA's actions. The details of what actions\
    \ are audited, where the\n   audit trail is maintained, and what utilities exist\
    \ to search that\n   audit trail are not specified here. The functions a CA must\
    \ provide\n   are:\n"
- title: 3.8.1 Install CA
  contents:
  - "3.8.1 Install CA\n   Install_CA(\n                       keysize            \
    \   Integer,   --inputs\n                       CA_state              CA State,\
    \  --outputs\n                       CA_Public_Key         Public Key)\n   This\
    \ routine need only generate a public/private key pair of the\n   requested size.\
    \ Keysize is likely to be in implementation constant\n   rather than a parameter.\
    \  The value is likely to be either 512 or\n   640.  Key sizes throughout will\
    \ have to increase over time as\n   factoring technology and CPU speeds improve.\
    \  Both keys are stored as\n   part of the CA_state; the public key is returned\
    \ so that other CAs\n   may cross-certify this one. The `Next Serial number' in\
    \ the CA state\n   is set to 1.\n"
- title: 3.8.2 Create Certificate
  contents:
  - "3.8.2 Create Certificate\n   Create_certificate(\n                          \
    \                          --inputs\n                       Renewal          \
    \     Boolean,\n                       Include_UID           Boolean,\n      \
    \                 Issuer_name           Name,\n                       Issuer_UID\
    \            UID,\n                       Effective_date        Absolute Time,\n\
    \                       Expiration_date       Absolute Time,\n               \
    \        Subject_name          Name,\n                       Subject_UID     \
    \      UID,\n                       Subject_public_key    Public Key,\n      \
    \                                              --updated\n                   \
    \    CA_state              CA State,\n                                       \
    \             --outputs\n                       Certificate           Certificate)\n\
    \   This procedure creates and signs a certificate.  Note that the\n   various\
    \ contents of the certificate must be communicated to the CA in\n   some reliable\
    \ fashion.  The Issuer_name and UID are the name and UID\n   of the directory\
    \ on whose behalf the certificate is being signed.\n   This routine formats and\
    \ signs a certificate with the private key in\n   CA_state. It audits the creation\
    \ of the certificate and updates the\n   sequence number which is part of CA_state.\
    \ The Issuer and Subject\n   names are X.500 names.  If the CA state includes\
    \ a history of what\n   UIDs have previously been used by what names, this call\
    \ will only\n   succeed in the collision case if the Renewal boolean is set true.\
    \  If\n   the Include_UID boolean is set true, this routine will generate a\n\
    \   1992 format X.509 certificate; otherwise it will generate a 1988\n   format\
    \ X.509 certificate.\n"
- title: 3.8.3 Create Principal
  contents:
  - "3.8.3 Create Principal\n   Create_principal(\n                              \
    \                      --inputs\n                       Password             \
    \ String,\n                       keysize               Integer,\n           \
    \            Principal_name        Name,\n                       Principal_UID\
    \         UID,\n                       Parent_Public_key     Public Key,\n   \
    \                    Parent_UID            UID,\n                            \
    \                        --outputs\n                       Encrypted_Credentials\
    \ Encrypted Credentials,\n                       Trusted_authority_certificate\
    \ Certificate)\n   This procedure creates a new principal by generating a new\n\
    \   public/private key pair, encrypting the public and private keys under\n  \
    \ the password, and signing a trusted authority certificate for the\n   parent\
    \ CA.  In an implementation not using passwords (e.g., smart\n   cards), an alternative\
    \ mechanism must be used for initially creating\n   principals.  If a principal\
    \ has protected storage for trusted\n   authority information, it is not necessary\
    \ to create a trusted\n   authority certificate and store it in the naming service.\
    \  Some\n   procedure analogous to this one must be executed, however, in which\n\
    \   the principal learns the public key and UID of its CA and its own\n   name.\n\
    \   This routine creates two output structures with the following steps:\n   \
    \ a) Generate a public/private key pair using the indicated\n       keysize. An\
    \ implementation will likely fix the keysize as an\n       implementation constant,\
    \ most likely 512 or 640 bits, rather\n       than accepting it as a parameter.\
    \  Key sizes generally will\n       have to increase over time as factoring technology\
    \ and CPU\n       speeds improve.\n    b) Form the encrypted credentials by using\
    \ the public key,\n       private key, and Principal_UID and encrypting them using\
    \ a\n       hash of the password as the key.\n    c) Generate a trusted authority\
    \ certificate (which is identical\n       in format to a \"parent\" certificate)\
    \ getting fields as\n       follows:\n      1) Certificate version is X.509 1992.\n\
    \      2) Issuer name is the Principal name (which is an X.500 name).\n      3)\
    \ Issuer UID is the Principal UID.\n      4) Validity is for all time.\n     \
    \ 5) Subject name is constructed from the Principal name by\n         removing\
    \ the last simple name from the hierarchical name.\n      6) Subject UID is the\
    \ CA_UID.\n      7) Subject Public Key is the CA_Public_Key\n      8) Sequence\
    \ number is 1.\n      9) Sign the certificate with the newly generated private\
    \ key of\n         the principal.\n"
- title: 3.8.4 Change Password
  contents:
  - "3.8.4 Change Password\n   Change_password(                                 --inputs\n\
    \                       Encrypted_credentials Encrypted Credentials,\n       \
    \                Old_password          String,\n                       New_password\
    \          String,\n                                                    --outputs\n\
    \                       Encrypted_credentials Encrypted Credentials)\n   If credentials\
    \ are stored encrypted under a password, it is possible\n   to change the password\
    \ if the old one is known.  Note that it is\n   insufficient to just change a\
    \ user's password if the password has\n   been disclosed.  Anyone knowing the\
    \ old password may have already\n   learned the user's private key.  If a password\
    \ has been disclosed,\n   the secure recovery procedure is to call create_principal\
    \ again\n   followed by create_certificate to certify the new key.\n   Using DASS,\
    \ it may not be appropriate for users to periodically\n   change their passwords\
    \ as a precaution unless they also change their\n   private keys by the procedure\
    \ above.  The only likely use of the\n   change_password procedure is to handle\
    \ the case where an\n   administrator has chosen a password for the user in the\
    \ course of\n   setting up the account and the user wishes to change it to something\n\
    \   the user can remember.  A future version of the architecture may\n   smooth\
    \ key roll-over by having the change_password command also\n   generate a new\
    \ key and sign a \"self\" certificate in which the old key\n   certifies the new\
    \ one.  As a separate step, a CA which notices a self\n   certificate posted in\
    \ the naming service could certify the new key\n   instead of the old one when\
    \ the user's certificate is renewed.  While\n   this procedure is not as rapid\
    \ or as reliable as having the user\n   directly interact with the CA, it offers\
    \ a reasonable tradeoff\n   between security and convenience when there is no\
    \ evidence of\n   password compromise.\n   This routine simply decrypts the encrypted\
    \ credentials structure\n   supplied using the password supplied. It returns a\
    \ bad status if the\n   format of the decrypted information is bad (indicating\
    \ an incorrect\n   password). Otherwise, it creates a new encrypted credentials\n\
    \   structure by encrypting the same data with the new password. It would\n  \
    \ be highly desirable for the user interface to this function to\n   provide the\
    \ capability to randomly generate passwords and prohibit\n   easily guessed user\
    \ chosen passwords using length, character set, and\n   dictionary lookup rules,\
    \ but such capabilities are beyond the scope\n   of this document.  If encrypted\
    \ credentials are stored in some local\n   secure storage, the above function\
    \ is all that is necessary (in fact,\n   if the storage is sufficiently secure,\
    \ no password is needed;\n   credentials could be stored unenciphered).  If they\
    \ are stored in a\n   naming service, this function must be coupled with one which\n\
    \   retrieves the old encrypted credentials from the naming service and\n   stores\
    \ the new.  The full protocol is likely to include access\n   control checks that\
    \ require the principal to acquire credentials and\n   produce tokens.  For best\
    \ security, the encrypted credentials should\n   be accessible only through a\
    \ login agent.  The role of the login\n   agent is to audit and limit the rate\
    \ of password guessing.  If\n   passwords are well chosen, there is no significant\
    \ threat from\n   password guessing because searching the space is computationally\n\
    \   infeasible.  In the context of a login agent, change password will be\n  \
    \ implemented with a specialized protocol requiring knowledge of the\n   password\
    \ and (for best security) a trusted authority from which the\n   public key of\
    \ the login agent can be learned.  See section 2.3.2 for\n   the plans for the\
    \ non-X.500 credential storage facility.\n"
- title: 3.8.5 Change Name
  contents:
  - "3.8.5 Change Name\n   Change_name(\n                                        \
    \            --inputs\n                       Claimant_Credentials  Credentials,\n\
    \                       New_name              Name,\n                       CA_Public_Key\
    \         Public Key,\n                       CA_UID                UID,\n   \
    \                                                 --outputs\n                \
    \       Trusted_Authority_Certificate Certificate)\n   DASS permits a principal\
    \ to have many current aliases, but only one\n   current name.  A principal can\
    \ authenticate itself as any of its\n   aliases but verifies the names of others\
    \ relative to the name by\n   which it knows itself.  Aliases can be created simply\
    \ by using the\n   create_certificate function once for each alias.  To change\
    \ the name\n   of a principal, however, requires that the principal securely learn\n\
    \   the public key and UID of its new parent CA.  As with\n   create_principal,\
    \ if a principal has secure private storage for its\n   trusted authority information,\
    \ it need not create a certificate, but\n   some analogous procedure must be able\
    \ to install new naming\n   information.\n   This routine produces a new Trusted\
    \ Authority Certificate with\n   contents as follows:\n    a) Issuer name is New_name\
    \ (an X.500 name)\n    b) Issuer_UID is Principal UID from Credentials.\n    c)\
    \ Validity is for all time.\n    d) Subject name is constructed from the Issuer\
    \ name by removing\n       the last simple name from the hierarchical name, and\n\
    \       converting to an X.500 name.\n    e) Subject UID is CA_UID\n    f) Subject\
    \ Public Key is CA_Public_Key\n    g) Sequence number is 1.\n    h) The certificate\
    \ is signed with the private key of the\n       principal from the credentials.\
    \ Note that this call will only\n       succeed if the principal's private key\
    \ is in the credentials,\n       which will only be true if the credentials were\
    \ created by\n       calling Create_server_credentials.\n"
- title: 3.9 Credential Maintenance Functions
  contents:
  - "3.9 Credential Maintenance Functions\n   DASS credentials can potentially have\
    \ information about two\n   principals.  This functionality is included to support\
    \ the case\n   where a user on a node has two identities that might be\n   recognized\
    \ for purposes of managing access controls.  First,\n   there is the user's network\
    \ identity; second, there is an\n   identity as controlling a particular \"account\"\
    \ or \"username\" on\n   that node.  There are two reasons for recognizing this\
    \ second\n   identity: first, access controls might be specified such that\n \
    \  only a user is only permitted access to certain resources when\n   coming through\
    \ certain trusted nodes (e.g., files that can't be\n   accessed from a terminal\
    \ at home); and second, before the\n   transition strategy to global identities\
    \ is complete, as a way to\n   refer to USER@NODE in a way analogous to existing\
    \ mechanisms but\n   with greater security.\n   The mapping of global usernames\
    \ to local user names on a node is\n   outside the scope of DASS.  This is done\
    \ via a \"proxy database\"\n   or some analogous local mechanism.  What DASS provides\
    \ are\n   mechanisms for adding node oriented credentials into a user's\n   credentials\
    \ structure, carrying the dual authentication\n   information in authentication\
    \ tokens, and extracting the\n   information from the credentials structure created\
    \ by\n   Accept_token.\n   Some applications of DASS will not make use of the\
    \ node\n   authentication related extensions.  In that case, they will never\n\
    \   use the Combine_credentials, Create_credentials, Get_node_info,\n   or Verify_node_name\
    \ functions.\n   The \"normal\" sequence of events surrounding a user logging\
    \ into a\n   node are as follows:\n    a) When the user logs in, he types either\
    \ a local user ID known\n       to the node or a global name (the details of the\
    \ user\n       interface are implementation specific).  Through some sort of\n\
    \       local mapping, the node determines both a global name and a\n       local\
    \ account name.  The user also enters a password\n       corresponding to the\
    \ global name.\n    b) The node calls network_login specifying the user's global\
    \ name\n       and the supplied password.  The result is credentials which\n \
    \      can be used to access network services but which have not yet\n       been\
    \ verified to be valid.\n    c) The node calls verify_principal_name using its\
    \ own credentials\n       to verify the authenticity of the user's credentials\
    \ (these\n       node credentials must have previously been established by a\n\
    \       call to initialize_server during node initialization).\n    d) If that\
    \ test succeeds, the node adds its credentials to those\n       of the user by\
    \ calling combine_credentials.\n   The set of facilities for manipulating credentials\
    \ follow:\n"
- title: 3.9.1 Network login
  contents:
  - "3.9.1 Network login\n   Network_login(\n                                    \
    \                --inputs\n                       Name                  Name,\n\
    \                       password              String,\n                      \
    \ keysize               Integer,\n                       expiration          \
    \  Time interval,\n                       TA_credentials        Credentials,--optional\n\
    \                                                    --outputs\n             \
    \          Claimant_credentials  Credentials)\n   This function creates credentials\
    \ for a principal when the principal\n   \"logs into the network\".\n   Name is\
    \ the X.500 name of the principal.\n   Password is a secret which authenticates\
    \ the principal to the\n   network.\n   Keysize specifies the size of the temporary\
    \ \"login\" or \"delegation\"\n   key.  In a real implementation, it is expected\
    \ to be an\n   implementation constant (most likely 384 or 512 bits).\n   Expiration\
    \ sets a lifetime for the credentials created.  For a normal\n   login, this is\
    \ likely to be an implementation constant on the order\n   of 8-72 hours.  Some\
    \ mechanism for overriding it must be provided to\n   make it possible (for example)\
    \ to submit a background job that might\n   run days or even months after they\
    \ are submitted.\n   TA_credentials   are used if the encrypted credentials are\
    \ protected\n   by a login agent. If they are missing, the password will be less\
    \ well\n   protected from guessing attacks.\n   This routine does not (as one\
    \ might expect) securely authenticate the\n   principal to the calling procedure.\
    \  Since the password is used to\n   obtain the principal's private key, this\
    \ call will normally fail if\n   the principal supplies an invalid password. \
    \ A penetrator who has\n   compromised the naming service could plant fake encrypted\
    \ credentials\n   under any name and impersonate that name as far as this call\
    \ is\n   concerned. A caller that wishes to authenticate the user in addition\n\
    \   to obtaining credentials to be able to act on the user's behalf\n   should\
    \ call Verify_principal_name (below) with the created\n   credentials and the\
    \ credentials of the calling process.\n   This routine constructs a credentials\
    \ structure from information\n   found in the naming service encrypted using the\
    \ supplied password.\n    a) If the encrypted credentials structure is protected\
    \ with a\n       login agent, retrieve the public key of the login agent:\n  \
    \    1) If TA_credentials are available, use them in a call to\n         Get_Pub_Keys\
    \ to get the public key of the login agent (whose\n         name is derived from\
    \ the name of the principal by truncating\n         the last element of the RDN\
    \ and adding CSS=X509).\n      2) If TA_credentials are not available, look up\
    \ the public key\n         of the login agent in the naming service.\n       Login\
    \ agents limit and audit password guesses, and are\n       important when passwords\
    \ may not be well chosen (as when users\n       are allowed to choose their own).\
    \  To fully prevent the\n       password guessing threat, principals may only\
    \ log onto nodes\n       that already have TA_credentials which can be used to\n\
    \       authenticate the login agent.  To support nodes which have no\n      \
    \ credentials of their own and to allow this procedure to\n       support node\
    \ initialization, it is possible to network login\n       without TA credentials.\n\
    \       A principal who logs into a node that lacks TA credentials is\n      \
    \ subject to the following subtle security threat:  A penetrator\n       who impersonates\
    \ the naming service could post his own public\n       key and address as those\
    \ of the login agent.  This procedure\n       would then in the process of logging\
    \ in reveal the the\n       penetrator enough information for the penetrator to\
    \ mount an\n       unaudited password guessing attack against the principal's\n\
    \       credentials.\n    b) Retrieve the encrypted credentials from the naming\
    \ service or\n       login agent.  In the case of the login agent, the password\
    \ is\n       one-way hashed to produce proof of knowledge of the password\n  \
    \     and the hashed value is supplied to the login agent encrypted\n       under\
    \ its public key as part of the request.\n    c) Decrypt the encrypted credentials\
    \ structure using a the\n       supplied password. Verify that the decryption\
    \ was successful\n       by verifying that the resulting structure can be parsed\n\
    \       according the the ASN.1 rules for Encrypted_Credentials and\n       that\
    \ the two included primes when multiplied together produce\n       the included\
    \ modulus. If the decryption was unsuccessful then\n       the routine returns\
    \ the `Invalid password' error status. The\n       decryption results in both\
    \ the Private Key and the Public Key.\n    d) Generate a public/private key pair\
    \ for the Delegation Key,\n       using the indicated keysize. Key size is likely\
    \ to be an\n       implementation constant rather than a supplied parameter, with\n\
    \       likely values being 384 and 512 bits.  Key sizes generally\n       will\
    \ have to increase over time as factoring technology and\n       CPU speeds improve.\
    \  Delegation keys can be relatively shorter\n       than long term keys because\
    \ DASS is designed so that\n       compromise of the delegation key after it has\
    \ expired does not\n       result in a security compromise.  An important advantage\
    \ of\n       making key size an implementation constant is that nodes can\n  \
    \     generate key pairs in advance, thus speeding up this procedure.\n      \
    \ Key generation is the most CPU intensive RSA procedure and\n       could make\
    \ login annoyingly slow.\n    e) Construct a Login Ticket by signing with the\
    \ user's private\n       key a combination of the public key, a validity period\n\
    \       constructed from the current time and the expiration passed in\n     \
    \  the call, and the principal UID found in the encrypted-key\n       structure.\n\
    \    f) Forget the user's private key.\n    g) Retrieve from the naming service\
    \ any trusted authority\n       certificates stored with the user's entry. Discard\
    \ any that\n       are not signed by the user's public key and UID.  An\n    \
    \   implementation in which the login node has credentials of its\n       own\
    \ may choose its trusted authority information instead of\n       retrieving and\
    \ verifying trusted authority certificates from\n       the naming service.  This\
    \ will have a subtle effect on the\n       security of the resulting system.\n\
    \    h) Construct a credentials structure from:\n      1) Claimant credentials:\n\
    \        (i)  Name of the principal from calling parameter\n        (ii) Login\
    \ Ticket as constructed in (e)\n        (iii)Delegation Private key as constructed\
    \ in (d)\n        (iv) Public key from the encrypted credentials structure\n \
    \     2) No verifier credentials\n      3) Trusted Authorities: for the most recently\
    \ signed trusted\n         authority certificate (There is normally only one Trusted\n\
    \         Authority Certificate.  If there is more than one then an\n        \
    \ implementation may choose to maintain a list of all the valid\n         keys.\
    \ They should all refer to the same CA (UID and name).):\n        (i)  Name of\
    \ the CA from the subject field of the certificate\n        (ii) Public Key of\
    \ the CA from the subject public key field\n        (iii)UID of the CA from the\
    \ subject UID field\n      4) no remote node credentials\n      5) no local node\
    \ credentials\n      6) no cached outgoing associations\n      7) no cached incoming\
    \ associations\n"
- title: 3.9.2 Create Credentials
  contents:
  - "3.9.2 Create Credentials\n   Create_credentials(\n                          \
    \                            --outputs\n                       Claimant_credentials\
    \  Credentials)\n   This routine creates an \"empty\" credentials structure. \
    \ It is needed\n   in the case of a user logging into a node and obtaining node\
    \ oriented\n   credentials but no global username credentials.  Because the\n\
    \   \"combine_credentials\" call wants to modify a set of user credentials\n \
    \  rather than create a new set, this call is needed to produce the\n   \"shell\"\
    \ for combine_credentials to fill in.\n   It is unlikely that any real implementation\
    \ would support this\n   function, but rather would have some functions which\
    \ combine\n   network_login, create_credentials, and combine_credentials in\n\
    \   whatever ways are supported by that node.\n"
- title: 3.9.3 Combine Credentials
  contents:
  - "3.9.3 Combine Credentials\n   Combine_credentials(\n                        \
    \                            --inputs\n                       node_credentials\
    \      Credentials,\n                       localusername         String,\n  \
    \                                                  --updated\n               \
    \        user_credentials      Credentials)\n   This routine is provided by implementations\
    \ which support the notion\n   of local node credentials.  After the node has\
    \ verified to its own\n   satisfaction that the user_credentials are entitled\
    \ to access to a\n   particular local account, this call adds node credential\
    \ information\n   to the user_credential structure.  This function may be applied\
    \ to\n   user_credentials created by network_login, create_credentials, or\n \
    \  accept_token.\n    a) Fill in the local node credentials substructure of\n\
    \       user_credentials as follows:\n      1) Full name of the node: from Full\
    \ name of the Principal in\n         node_credentials\n      2) Local username\
    \ on the node: from proxy lookup\n      3) RSA private key of the node: from verifier\
    \ credentials in\n         node_credentials\n    b) Optionally,  change the trusted\
    \ authorities to match the\n       trusted authorities from the node credentials.\
    \  This is an\n       implementation option, done most likely as a performance\n\
    \       optimization.  The only case where this option is required is\n      \
    \ where no trusted authorities existed in the user credentials\n       (because\
    \ they were created by create_credentials of\n       accept_token).  Server credentials\
    \ should generally keep their\n       own trusted authorities.\n   It is likely\
    \ that an implementation will choose not to replicate its\n   node credentials\
    \ in every credentials structure that it supports, but\n   rather will maintain\
    \ some sort of pointer to a single copy.  This\n   algorithm is stated as it is\
    \ only for ease of specification.\n"
- title: 3.9.4 Initialize_server
  contents:
  - "3.9.4 Initialize_server\n   initialize_server(\n                            \
    \                        --inputs\n                       Name               \
    \   Name,\n                       password              String,\n            \
    \           TA_credentials        Credentials, --optional\n                  \
    \                                  --outputs\n                       Server_credentials\
    \    Credentials)\n   Somehow a server must get access to its credentials. One\
    \ way is for\n   the credentials to be stored in the naming service like user\n\
    \   credentials encrypted under a service password. The service then\n   needs\
    \ to gain at startup time access to a service password. This may\n   be easier\
    \ to manage and is not insecure so long as the service\n   password is well chosen.\
    \ Alternately, the service needs some\n   mechanism to gain access directly to\
    \ its credentials. The credentials\n   created by this call are intended to be\
    \ very long lived. They do not\n   time out, so a node or server might store them\
    \ in Non-Volatile memory\n   after \"initial installation\" rather than calling\
    \ this routine at each\n   \"boot\". These credentials are shared between all\
    \ servers which use\n   the same key. This routine works as follows:\n    a) Retrieve\
    \ from the naming service or login agent the encrypted\n       credentials structure\
    \ corresponding to the supplied name. See\n       Network_login for a discussion\
    \ of the use of TA_credentials\n       and login agents.\n    b) Decrypt that\
    \ structure using a one-way hash of the supplied\n       password. Verify that\
    \ the decryption was successful. Verify\n       that the public key in the structure\
    \ matches the private key.\n    c) Retrieve from the naming service any trusted\
    \ authority\n       certificates stored under the supplied name. Discard any which\n\
    \       do not contain the UID from the encrypted credentials\n       structure\
    \ or are not signed by the key in the encrypted\n       credentials structure.\n\
    \    d) Construct a credentials structure from:\n      1) Claimant credentials:\n\
    \        (i)   Name of the principal from the calling parameter\n        (ii)\
    \  UID of the principal from the encrypted-key structure\n        (iii) No login\
    \ ticket\n        (iv)  No login secret key\n      2) Verifier credentials:\n\
    \        (i)   Server secret key from the encrypted-key structure\n      3) Trusted\
    \ Authorities: from the most recently signed Trusted\n         Authority Certificate:\n\
    \        (i)   Name of CA from the Subject Name field\n        (ii)  UID of the\
    \ CA from the Subject UID field\n        (iii) Public Key of the CA from the Subject\
    \ Public Key field\n      4) no node credentials\n      5) no cached outgoing\
    \ associations\n      6) no cached incoming associations\n"
- title: 3.9.5 Generate Server Ticket
  contents:
  - "3.9.5 Generate Server Ticket\n   generate_server_ticket(\n                  \
    \                                  --inputs\n                       expiration\
    \            Time interval,\n                                                \
    \    --updated\n                       Server_credentials    Credentials)\n  \
    \ Server credentials created by initialize_server can be used to accept\n   incoming\
    \ authentication tokens and can act as node_credentials for\n   outgoing authentications,\
    \ but cannot create user_credentials of their\n   own. If a server initiates connections\
    \ on its own behalf, it must\n   have a ticket just like any other user might\
    \ have. That ticket has\n   limited lifetime and the right to act on behalf of\
    \ the server can be\n   delegated. The server cannot, however, delegate the right\
    \ to receive\n   connections intended for it. An implementation must come up with\
    \ a\n   policy for the expiration of server tickets and how long before\n   expiration\
    \ they are renewed.  A likely policy is for this procedure\n   to be implicitly\
    \ called by Create_token if there is no current ticket\n   present in the credentials.\
    \  If so, this interface need not be\n   exposed.\n   This routine is implemented\
    \ as follows:\n    a) Generate an RSA public/private key pair.\n    b) Compute\
    \ a validity interval from the current time and the\n       expiration supplied.\n\
    \    c) Construct a login ticket from the RSA public key (from a),\n       validity\
    \ interval (from b), the UID from the credentials, and\n       signed with the\
    \ server key in the credentials. (Discard\n       previous Login Ticket if there\
    \ was one).\n    d) Discard all information in the  Cached Outgoing Contexts.\n"
- title: 3.9.6 Delete Credentials
  contents:
  - "3.9.6 Delete Credentials\n   delete_credentials(\n                          \
    \                          --updated\n                       credentials     \
    \      Credentials)\n   Erases the secrets in the credentials structure and deallocates\
    \ the\n   storage.\n"
- title: 3.10 Authentication Procedures
  contents:
  - "3.10 Authentication Procedures\n   The guts of the authentication process takes\
    \ place in the next two\n   calls. When one principal wishes to authenticate to\
    \ another, it calls\n   Create_token and sends the token which results to the\
    \ other. The\n   recipient calls Accept_token and creates a new set of credentials.\n\
    \   The other calls in this section manipulate the received credentials\n   in\
    \ order to retrieve its contents and verify the identity of the\n   token creator.\n"
- title: 3.10.1  Create Token
  contents:
  - "3.10.1  Create Token\n   Create_token(\n                                    \
    \                --inputs\n                       target_name            Name,\n\
    \                       deleg_req_flag         Boolean,\n                    \
    \   mutual_req_flag        Boolean,\n                       replay_det_req_flag\
    \    Boolean,\n                       sequence_req_flag      Boolean,\n      \
    \                 chan_bindings          Octet String,\n                     \
    \  Include_principal_name Boolean,\n                       Include_node_name \
    \     Boolean,\n                       Include_username       Boolean,\n     \
    \                                                 --updated\n                \
    \       claimant_credentials   Credentials,\n                                \
    \                    --outputs\n                       authentication_token  \
    \ Authentication token,\n                       mutual_authentication_token\n\
    \                                   Mutual Authentication token,\n           \
    \            Shared_key             Shared Key,\n                       instance_identifier\
    \    Timestamp)\n   This routine is used by the initiator of a connection to create\
    \ an\n   authentication token which will prove its identity. If the claimant\n\
    \   credentials includes node/account information, the token will include\n  \
    \ node authentication.\n   target_name is the X.500 name of the intended recipient\
    \ of the token.\n   Only an entity with access to the private key associated with\
    \ that\n   name will be able to verify the created token and generate the\n  \
    \ mutual_authentication_token.\n   deleg_req_flag indicates whether the caller\
    \ wishes to delegate to the\n   recipient of the token. If it is set, the delegated_credentials\n\
    \   returned by Accept_token will be capable of generating tokens on\n   behalf\
    \ of the caller. Node based authentication information cannot be\n   delegated.\
    \ The mutual_req_flag, replay_det_req_flag , and\n   sequence_req_flag are put\
    \ in the authentication token and passed to\n   the target.  This information\
    \ is included in the token to make it\n   easier to implement the GSSAPI over\
    \ DASS.  DASS itself makes no use\n   of this information.\n   In most applications,\
    \ the purpose of a token exchange is to\n   authenticate the principals controlling\
    \ the two ends of a\n   communication channel.  chan_bindings contains an identifier\
    \ of the\n   channel which is being authenticated, and thus its format and content\n\
    \   should be tied to the underlying communication protocol.  DASS only\n   guarantees\
    \ that the information has been communicated reliably to the\n   named target.\
    \ If DASS is used with a cryptographically protected\n   channel (such as SP4),\
    \ this data should contain a one-way hash of the\n   key used to encrypt the channel.\
    \ If that channel is multiplexed, the\n   data should also include the ID of the\
    \ subchannel.  If the channel is\n   not encrypted, the network must be trusted\
    \ not to modify data on a\n   connection.  The source and target network addresses\
    \ and a connection\n   ID should be included in the chan_bindings at the source\
    \ and checked\n   at the target.  A token exchange also results in the two ends\
    \ sharing\n   a key and an instance identifier.  If that key and instance\n  \
    \ identifier are used to cryptographically protect subsequent\n   communications,\
    \ then chan_bindings need not have any cryptographic\n   significance but may\
    \ be used to differentiate multiple entities\n   sharing the public keys of communicating\
    \ principals.  For example, if\n   a service is replicated and all replicas share\
    \ a public key,\n   chan_bindings should include something that identifies a single\n\
    \   instance of the service (such as current address) so that the token\n   cannot\
    \ be successfully presented to more than one of the servers.\n   include_principal_name,\
    \ include_node_name, and include_username are\n   flags which determine whether\
    \ the principal name, node name, and/or\n   username from the credentials structure\
    \ are to be included in the\n   token.  This information is made optional in a\
    \ token so that\n   applications which communicate this information out of band\
    \ can\n   produce \"compressed\" tokens.  If this information is included in the\n\
    \   token, it will be used to populate the corresponding fields in the\n   credentials\
    \ structure created by Accept_token.  claimant_credentials\n   are the credentials\
    \ of the calling procedure.  The secrets contained\n   therein are used to sign\
    \ the token and the trusted authorities are\n   used to securely learn the public\
    \ key of the target.  The cached\n   outgoing contexts portion of the credentials\
    \ may be updated as a side\n   effect of this call.\n   The major output of this\
    \ routine is an  authentication_token which\n   can be passed to the target in\
    \ order to authenticate the caller.\n   In addition to returning an authentication\
    \ token, this routine\n   returns a mutual_authentication_token,  a shared_key,\
    \ and an\n   instance_identifier. The mutual authentication token is the same\
    \ as\n   the one generated by the Accept_token call at the target. If the\n  \
    \ protocol using DASS wishes mutual authentication, the target should\n   return\
    \ this token to the source. The source will compare it to the\n   one returned\
    \ by this routine using Compare_Mutual_Token (below) and\n   know that the token\
    \ was accepted at its proper destination.\n   The DES key and instance identifier\
    \ can be used to encrypt or sign\n   data to be sent to this target. The key and\
    \ instance will be given to\n   the target by Accept_token, and the key will only\
    \ be known by the two\n   parties to the authentication. If a single set of credentials\
    \ is used\n   to authenticate to the same target more than once, the same DES\
    \ key\n   is likely to be returned each time.  If the parties wish to protect\n\
    \   against the possibility of an outside agent mixing and matching\n   messages\
    \ from one authenticated session with those of another, they\n   should include\
    \ the instance identifier in the messages. The instance\n   identifier is a timestamp\
    \ and it is guaranteed that the DES\n   key/instance identifier pair will be unique.\n\
    \   An implementation may wish to \"hide\" the DES key from calling\n   applications\
    \ by placing it in system storage and providing calls\n   which encrypt/decrypt/sign/verify\
    \ using the key.\n   The primary tasks of this routine are to create its output\n\
    \   parameters. As a side effect, it may also update claimant_credentials\n  \
    \ It's algorithm is as follows:\n    a) The login ticket is checked. If it has\
    \ passed the end of its\n       lifetime an `Login Ticket Expired' error is returned.\
    \ If there\n       is a login ticket, but no corresponding private key then an\n\
    \       `Invalid credentials' error is returned (this is the case if\n       the\
    \ credentials were created by an authentication-without-\n       delegation operation).\
    \  If there is no login ticket or an\n       expired one and if the long term\
    \ private key is present in the\n       credentials, an implementation may choose\
    \ to automatically call\n       create_server_ticket to renew the ticket.\n  \
    \  b) Create new timestamp using the current time.  (This timestamp\n       must\
    \ be unique for this Shared Key. The timestamp is a 64 bit\n       POSIX time,\
    \ with a resolution of 1 nanosecond An implemen tation\n       must ensure that\
    \ timestamps cannot be reused.)\n    c) The public key and UID of target_name\
    \ are looked up by calling\n       get_pub_keys, using the target_name and the\
    \ Trusted Authority\n       section of the claimant_credentials structure. If\
    \ none is\n       found, an error status is returned. Otherwise, the cached\n\
    \       outbound connections portion of credentials are searched\n       (indexed\
    \ by target Public Key) for a cached Shared key with a\n       validity interval\
    \ which has not expired. If a suitable one is\n       found skip to step g, else\
    \ create a cache entry as follows:\n    d) Destination Public Key is the one found\
    \ looking up the target.\n       A Shared Key is generated at random. A validity\
    \ interval is\n       chosen according to node policy but not to exceed the validity\n\
    \       interval of the ticket in the credentials (if any).\n    e) Create the\
    \ Encrypted Shared Key, using the public key of the\n       Target, and place\
    \ in the cache.\n    f) If node authentication credentials are available in the\n\
    \       credentials structure, create a \"Node Ticket\" signature using\n    \
    \   the node secret and include it in the cache.\n    g) If delegation is requested\
    \ and no delegator is present in the\n       cache, create one by encrypting the\
    \ delegation private key\n       under the Shared key. The delegation private\
    \ key is\n       represented as an ASN.1 data structure containing only one of\n\
    \       the primes (p).\n    h) If delegation is not requested and no Shared Key\
    \ Ticket is in\n       the cache, create one by signing the requisite information\n\
    \       with the delegation private key.\n    i) Create the Authenticator.  The\
    \ contents of the Authenticator\n       (including the channel bindings) are encoded\
    \ into ASN.1, and\n       the signature is computed. The Authenticator is then\n\
    \       re-encoded, without including the Channel Bindings but using\n       the\
    \ same signature.\n    j) Create output_token as follows:\n      1) Encrypted\
    \ Shared Key from cache\n      2) Login Ticket from Claimant Credentials (if present)\n\
    \      3) Shared Key Ticket from cache (if no delegation and if\n         present)\n\
    \      4) Node Ticket from cache (if present)\n      5) Delegator from cache (if\
    \ delegation and if present)\n      6) Authenticator\n      7) Principal name\
    \ from credentials (if present and parameter\n         requests this)\n      8)\
    \ Node name from credentials (if present and parameter request\n         this)\n\
    \      9) Local Username from credentials (if present and parameter\n        \
    \ requests this)\n    k) Compute Mutual_authentication_token by encrypting the\n\
    \       timestamp from the authenticator using the Shared key.\n    l) The instance_identifier\
    \ is the timestamp. This and the Shared\n       key are returned for use by the\
    \ caller for further encryption\n       operations (if these are supported).\n"
- title: 3.10.2 Accept_token
  contents:
  - "3.10.2 Accept_token\n   Accept_token(\n                                     \
    \               --inputs\n                       authentication_token  Authentication\
    \ Token,\n                       chan_bindings         Octet String,\n       \
    \                                              --updated\n                   \
    \    verifying_credentials Credentials,\n                                    \
    \                --outputs\n                       accepted_credentials  Credentials,\n\
    \                       deleg_req_flag        Boolean,\n                     \
    \  mutual_req_flag       Boolean,\n                       replay_det_req_flag\
    \   Boolean,\n                       sequence_req_flag     Boolean,\n        \
    \               mutual_authentication_token\n                                \
    \        Mutual authentication token\n                       shared_key      \
    \      Shared Key,\n                       instance_identifier   Timestamp)\n\
    \   This routine is used by the recipient of an authentication token to\n   validate\
    \ it.  authentication_token is the token as received;\n   chan_bindings is the\
    \ identifier of the channel being authenticated.\n   See the description of Create_token\
    \ for information on the\n   appropriate contents for chan_bindings.  DASS does\
    \ not enforce any\n   particular content, but checks to assure that the same value\
    \ is\n   supplied to both Create_token and Accept_token.\n   Verifying_credentials\
    \ are the credentials of the recipient of the\n   token.  They must include the\
    \ private key of the entity named as the\n   target in Create_token or the call\
    \ will fail.  The cached incoming\n   contexts section of the verifying credentials\
    \ may be modified as a\n   side effect of this call.\n   Accepted_credentials\
    \ will contain additional information about the\n   token creator. If delegation\
    \ was requested, these credentials can be\n   used to make additional calls to\
    \ Create_token on the creator's\n   behalf. Whether or not delegation was requested,\
    \ they can also be\n   used in the calls which follow to gain additional information\
    \ about\n   the token creator.\n   The deleg_req_flag indicates whether the accepted_credentials\
    \ include\n   delegation which can be used by the recipient to act on behalf of\
    \ the\n   principal.  Mutual_req_flag, replay_det_req_flag, and\n   sequence_req_flag\
    \ are passed through from Create_token in support of\n   the GSSAPI.  DASS makes\
    \ no use of these fields.\n   The mutual_authentication_token can be returned\
    \ to the token creator\n   as proof of receipt. In many protocols, this will be\
    \ used by a client\n   to authenticate a server. Only the genuine server would\
    \ be able to\n   compute the mutual_authentication_token from the token.\n   The\
    \ shared_key and instance_identifier can be used to encrypt or sign\n   data between\
    \ the two authenticating parties. See Create_token.\n   This routine verifies\
    \ the contents of the authentication token in the\n   context of the verifying\
    \ credentials (In particular, the Private Key\n   of the server is used.  Also,\
    \ the Cached Incoming Contexts and\n   Incoming Timestamp list is used.) and returns\
    \ information about it.\n   The algorithm updates a cache of information. This\
    \ cache is not\n   updated if the algorithm exits with an error. The algorithm\
    \ is as\n   follows:\n    a) If there is a Login Ticket, but no Shared Key Ticket\
    \ or\n       Delegator then exit with error `Invalid Authenticator'. If\n    \
    \   there is a Shared Key Ticket or Delegator, but no Login Ticket\n       then\
    \ exit with error `Invalid Authentication Token'.\n       Look up the Encrypted\
    \ Shared key in the Cached Incoming Contexts\n       of the credentials structure.\
    \ (This cache entry is used during\n       the execution of this routine. An implementation\
    \ must ensure that\n       references to the cache entry can not be affected by\
    \ other users\n       modifying the cache.  One way is to use a copy of the cache\
    \ entry,\n       and update it at exit.)  If it is not found then create\n   \
    \    a new cache entry as follows:\n      1) Encrypted Shared Key, from the Authentication\
    \ Token.\n      2) Shared Key and Validity Interval, by decrypting the\n     \
    \    Encrypted Shared Key using the server private key in\n         credentials.\
    \ If the decryption fails then exit with error\n         `Invalid Authentication\
    \ Token'.\n    b) Check that the Validity Interval (in the cache entry) includes\n\
    \       the current time; return `Invalid Authentication Token' if not.\n    \
    \   Check the Timestamp is within max-clock-skew of the current\n       time,\
    \ return `invalid Authentication Token' if not.\n       Reconstruct the Authenticator\
    \ including the Channel Bindings\n       passed as a parameter.\n       Check\
    \ that the reconstructed Authenticator is signed by the\n       Shared key. If\
    \ not then exit with error `Invalid\n       Authentication Token'.\n       Look\
    \ up the Authenticator Signature in the Received\n       Authenticators. If the\
    \ same Signature is found in the list\n       then exit with error `Duplicate\
    \ Authenticator'. Otherwise add\n       the Signature and timestamp to the list.\n\
    \       If there is a Login Ticket and the Delegation Public key is in\n     \
    \  the cache entry, then check that the same key is specified in\n       the Login\
    \ Ticket, if not then exit with error `Invalid\n       Authentication Token'.\
    \ Place the Delegation Public key in the\n       cache if it is not already there.\n\
    \       If there is a Login Ticket, the Delegation Public key was not\n      \
    \ previously in the cache entry, and there is a Shared Key\n       Ticket in the\
    \ Authentication Token, then check that the Shared\n       Key Ticket is signed\
    \ by the Delegation Public Key in the Login\n       Ticket. If not then exit with\
    \ error `Invalid Authentication\n       Token'.\n       If a delegator is present\
    \ in the message then decrypt the\n       delegator using the Shared key. If the\
    \ private key does not\n       match the Delegation Public key then exit with\
    \ error\n       `Invalid Authentication Token' (The prime in the delegator\n \
    \      is used to find the other prime (from the modulus). The division\n    \
    \   must not have a remainder.  Neither prime may be 1. The two\n       primes\
    \ are then used to reconstruct any other information\n       needed to perform\
    \ cryptographic operations.).\n       Build the delegation credentials data structure\
    \ as follows:\n       1) Claimant credentials:\n        (i)  Login Ticket from\
    \ the Authentication token\n        (ii) Delegation Private key from the decrypted\
    \ delegator if\n              the token is delegating.\n        (iii)Encrypted\
    \ Shared Key from the Authentication token.\n       2) There are no verifier credentials.\n\
    \       3) Trusted authorities are copied from the verifying_credentials\n   \
    \       passed to this routine (If an implementation is able to\n          obtain\
    \ the original Trusted Authorities of the Principal then\n          it may do\
    \ so instead of using the server's Trusted\n          Authorities.).\n       4)\
    \ Remote node credentials (Node name, Username, Node Ticket)\n       5) There\
    \ are no local node credentials.\n       6) There are no cached contexts.\n  \
    \  c) The returned boolean values are obtained from the\n       Authenticator.\n\
    \    d) Mutual_authentication_token is computed by encrypting the\n       timestamp\
    \ from the Authenticator with the Shared key from the\n       cache.\n    e) Instance_identifier\
    \ is the timestamp from the Authenticator.\n       This and the Shared key are\
    \ returned to the caller for further\n       encryption operations (if these are\
    \ supported).\n"
- title: 3.10.3 Compare Mutual Token
  contents:
  - "3.10.3 Compare Mutual Token\n   Compare_mutual_token(\n                     \
    \                               --inputs\n                       Generated_token\
    \    Mutual authentication token,\n                       Received_token     Mutual\
    \ authentication token,\n                                                    \
    \ --outputs\n                       equality_flag         Boolean)\n   This routine\
    \ compares two mutual authentication tokens and tells\n   whether they match.\
    \  In the expected use, the first is the token\n   generated by Create_token at\
    \ the initiating end and the second is the\n   token generated by Accept_token\
    \ at the accepting end and returned to\n   the initiating end.  This routine can\
    \ be implemented as a byte by\n   byte comparison of the two parameters.\n"
- title: 3.10.4 Get Node Info
  contents:
  - "3.10.4 Get Node Info\n   get_node_info(\n                                   \
    \                 --inputs\n                       accepted_credentials  Credentials,\n\
    \                                                    --outputs\n             \
    \          nodename              Name,\n                       username      \
    \        String)\n   This routine extracts from accepted credentials the name\
    \ of the node\n   from which the authentication token came and the named account\
    \ on\n   that node. Because this information is not cryptographically\n   protected\
    \ within the token, this information can only be regarded as\n   a \"hint\" by\
    \ the receiving application.  It can, however, be verified\n   using Verify_node_name\
    \ in a cryptographically secure manner.  This\n   information will only be present\
    \ if these are accepted credentials\n   and it the caller of Create_token set\
    \ the include_node_name and/or\n   include_username flags.\n   An actual implementation\
    \ is not likely to have get_node_info and\n   verify_node_name as separate calls.\
    \  They are specified this way\n   because there are different ways this information\
    \ might be used.  For\n   most applications, the nodename and username will be\
    \ included in the\n   token, and a single function might extract and verify them\
    \ (it might\n   in fact be part of accept token).  For other applications, the\n\
    \   nodename and username will not be in the token but rather will be\n   computed\
    \ from other information passed during connection initiation\n   so a call would\
    \ have to take these as inputs.  Still other\n   applications such as ACL evaluators\
    \ that want to support the renaming\n   and aliasing capabilities of DASS would\
    \ defer verifying node\n   information until they came upon an ACL which allowed\
    \ access only\n   from a particular node.  They would then verify that the name\
    \ on the\n   ACL was an authenticatable alias for the node which created the\n\
    \   token.  All of these uses can be defined in terms of calls to\n   get_node_info\
    \ and verify_node_name.\n"
- title: 3.10.5 Get Principal UID
  contents:
  - "3.10.5 Get Principal UID\n   get_principal_uid(\n                           \
    \                         --inputs\n                       accepted_credentials\
    \  Credentials,\n                                                    --outputs\n\
    \                       uid                   UID)\n   This routine extracts a\
    \ principal UID from a set of credentials.\n   As with Get_Node_Info, this interface\
    \ is not likely to appear in an\n   actual implementation, but rather will be\
    \ bundled with other\n   routines.  It is specified this way because there might\
    \ be a variety\n   of algorithms by which credentials are evaluated and all of\
    \ them can\n   be defined in terms of these primitives.\n   In DASS, it is possible\
    \ for a principal to have many aliases.  This\n   can happen either because the\
    \ principal was given multiple names to\n   limit the number of CAs that need\
    \ to be trusted when authenticating\n   to different servers or because the principal's\
    \ name has changed and\n   the old name remains behind as an alias.  Accept_token\
    \ returns the\n   name by which the principal identified itself when creating\
    \ its\n   credentials. A service may know the user by some alias. The normal\n\
    \   way to handle this is for the service to know the principal's UID\n   (which\
    \ is constant over name changes) and to compare it with the UID\n   in the token\
    \ to identify a likely alias situation. It gets the UID\n   from the token using\
    \ this routine. It then confirms the alias by\n   calling verify_principal_name.\n\
    \   The UID is in a signed portion of accepted credentials, but the\n   signature\
    \ may not have been verified at the time this call is issued.\n   The information\
    \ returned by this routine must therefore be regarded\n   as a hint.  If a call\
    \ to Verify_principal_name succeeds, however,\n   then the caller can securely\
    \ know that the name given to that routine\n   and the UID returned by this one\
    \ are the authenticated source of the\n   token.\n"
- title: 3.10.6 Get Principal Name
  contents:
  - "3.10.6 Get Principal Name\n   get_principal_name(\n                         \
    \                           --inputs\n                       accepted_credentials\
    \  Credentials,\n                                                    --outputs\n\
    \                       name                  Name)\n   This routine extracts\
    \ a principal name from a set of credentials.\n   This name is the name most recently\
    \ associated with the principal. It\n   may be the name that the principal supplied\
    \ when the credentials were\n   created (in which case it may not have been verified\
    \ yet) or it may\n   be a different name that has been verified.\n   As with Get_Node_Info\
    \ and Get_Principal_UID, this routine is not\n   likely to appear in an actual\
    \ implementation, but will be bundled in\n   some fashion with related procedures.\
    \  The name returned by this\n   procedure is not guaranteed to have been cryptographically\
    \ verified.\n   Verify_Principal_Name performs that function.\n"
- title: 3.10.7 Get Lifetime
  contents:
  - "3.10.7 Get Lifetime\n   get_lifetime(\n                                     \
    \               --inputs\n                       Claimant_credentials  Credentials,\n\
    \                                                    --outputs\n             \
    \          lifetime              Duration)\n   This routine computes the life\
    \ remaining in a set of credentials.\n   Its most common use would be to know\
    \ to renew credentials before they\n   expire.\n   Returns the remaining lifetime\
    \ of the login ticket in the\n   credentials. This can either be the done on the\
    \ node where the\n   original login took place, or at a server which has been\
    \ delegated\n   to. It indicates how much longer these credentials can be used\
    \ for\n   further delegations. This routine will return 0 if the login ticket\n\
    \   has passed the end of its life, if there is no login ticket, or if\n   the\
    \ credentials do not contain the private key certified by the\n   ticket (i.e.,\
    \ where they were created by an authentication-without-\n   delegation operation).\n"
- title: 3.10.8 Verify Node Name
  contents:
  - "3.10.8 Verify Node Name\n   Verify_node_name(\n                             \
    \                       --inputs\n                       nodename            \
    \  Name,\n                       username              String,\n             \
    \                                        --updated\n                       verifying_credentials\
    \ Credentials,\n                       accepted_credentials  Credentials,\n  \
    \                                                  --outputs\n               \
    \        Name matches          Boolean)\n   This routine tests whether the originating\
    \ node of an authentication\n   token can be authenticated as having the provided\
    \ name. Like a\n   principal, a node may have multiple aliases. One of them may\
    \ be\n   returned by Get_node_info, but this call allows a suspected alias to\n\
    \   be verified.  The verifying credentials supplied with this call must\n   be\
    \ the same credentials as were used in the Accept_token call. The\n   procedure\
    \ for completing this request is as follows:\n    a) If there is no Node Ticket\
    \ in the claimant credentials then\n       return False.\n    b) Search the incoming\
    \ context cache of the verifying credentials\n       for an entry containing the\
    \ same encrypted shared key as the\n       encrypted shared key subfield of the\
    \ claimant information of\n       the accepted credentials.  In the steps which\
    \ follow,\n       references to \"the cache\" refer to this entry.  If none is\n\
    \       found, initialize such an entry as follows:\n      1) Encrypted shared\
    \ key from the encrypted shared key subfield\n         of the claimant information\
    \ of the accepted credentials.\n      2) The shared key and validity interval\
    \ are determined by\n         decrypting the encrypted shared key using the RSA\
    \ private\n         key in the verifier information of the server credentials.\n\
    \         If this procedure is called after a call to Accept_token\n         using\
    \ the same server credentials (as is required for\n         correct use), the\
    \ shared key and validity interval must\n         correctly decrypt.  If called\
    \ in some other context, the\n         results are undefined.  The validity interval\
    \ is not\n         checked.\n      3) Initialize all other entries in the cache\
    \ to missing.\n    c) If there is a \"local username on client node\" in the cache\
    \ and\n       it does not match the username supplied as a parameter, return\n\
    \       False.\n    d) If there is a \"name of client node\" in the cache and\
    \ it\n       matches the nodename supplied as a parameter:\n      1) Set the \"\
    Full name of the node\" subfield of the remote node\n         authentication field\
    \ of the accepted credentials to be the\n         nodename supplied as a parameter.\n\
    \      2) Set the \"Local Username on the node\" subfield of the remote\n    \
    \     node authentication field of the accepted credentials to be\n         the\
    \ username supplied as a parameter.\n      3) return True.\n    e) Call the Get_Pub_Keys\
    \ subroutine with the server_credentials,\n       the nodename supplied as a parameter,\
    \ and Try_Hard=False.\n    f) If \"Public Key of Client Node\" is missing from\
    \ the cache,\n       check all of the Public keys returned to see if one verifies\n\
    \       the node ticket.  If one does, set the \"Public Key of Client\n      \
    \ Node\" and \"UID of Client Node\" fields in the cache to be the\n       PK/UID\
    \ pair that verified the ticket and set the \"Local\n       Username on Client\
    \ node\" field to be the username supplied as\n       a parameter..\n    g) If\
    \ any of the Public Key/UID pairs match the \"Public Key of\n       Client Node\"\
    \ and \"UID of Client Node\" fields in the cache,\n       then:\n      1) Set\
    \ the \"name of client node\" in the cache equal to the\n         nodename supplied\
    \ as a parameter.\n      2) Set the \"Full name of the node\" subfield of the\
    \ remote node\n         authentication field of the accepted credentials to be\
    \ the\n         nodename supplied as a parameter.\n      3) Set the \"Local Username\
    \ on the node\" subfield of the remote\n         node authentication field of\
    \ the accepted credentials to be\n         the username supplied as a parameter.\n\
    \      4) Return True.\n    h) If none of them match, call Get_Pub_Keys again\
    \ with\n       Try_Hard=True and repeat steps 6 & 7.  If Step 7 fails a\n    \
    \   second time, return False.\n"
- title: 3.10.9 Verify Principal Name
  contents:
  - "3.10.9 Verify Principal Name\n   Verify_principal_name(\n                   \
    \                                 --inputs\n                       principal_name\
    \        Name,\n                                                     --updated\n\
    \                       verifier_credentials  Credentials,\n                 \
    \      claimant_credentials  Credentials,\n                                  \
    \                  --outputs\n                       Name matches          Boolean)\n\
    \   This routine tests (in the context of the verifier credentials)\n   whether\
    \ the claimant credentials are authenticatable as being those\n   of the named\
    \ principal.  This procedure is called with a set of\n   accepted credentials\
    \ to authenticate their source, or with a set of\n   credentials produced by network_login\
    \ to authenticate the creator of\n   those credentials.  If the claimant credentials\
    \ were created by\n   Accept_token, then the verifier credentials supplied in\
    \ this call\n   must be the same as those used in that call.  The procedure for\n\
    \   completing this request is as follows:\n    a) If there is no Login Ticket\
    \ in the claimant credentials, then\n       return False.\n    b) If the current\
    \ time is not within the validity interval of the\n       Login Ticket, then return\
    \ False.\n    c) If there is an Encrypted Shared Key present in the Claimant\n\
    \       information field of the claimant credentials, then find or\n       create\
    \ a matching cache entry in the Cached Incoming Contexts\n       of the verifier\
    \ credentials.  In the description which\n       follows, references to \"the\
    \ cache\" refer to this entry.  If\n       the cache entry must be created, its\
    \ contents is set to be as\n       follows:\n      1) Encrypted shared key from\
    \ the encrypted shared key subfield\n         of the claimant information of the\
    \ accepted credentials.\n      2) The shared key and validity interval are determined\
    \ by\n         decrypting the encrypted shared key using the RSA private\n   \
    \      key in the verifier information of the server credentials.\n         If\
    \ this procedure is called after a call to Accept_token\n         using the same\
    \ server credentials (as is required for\n         correct use), the shared key\
    \ and validity interval must\n         correctly decrypt.  If called in some other\
    \ context, the\n         results are undefined.  The validity interval is not\n\
    \         checked.\n      3) Initialize all other entries in the cache to missing.\n\
    \    d) If there is a cache entry and if the \"Public Key of Client\n       Principal\"\
    \ field is present and if the \"UID of Client\n       Principal\" field is present\
    \ and matches the UID in the Login\n       Ticket, then:\n      1) Set the Public\
    \ Key of the principal field in the Claimant\n         information to be the Public\
    \ Key of Client Principal.\n      2) If the \"Full name of the principal\" field\
    \ is missing from\n         the claimant information of the claimant credentials,\
    \ then\n         set it to the \"Name of Client Principal\" field from the\n \
    \        cache.\n    e) If there is a cache entry and if the \"Name of Client\n\
    \       Principal\" field is present and if it matches the principal\n       name\
    \ supplied to this routine and if the UID in the cache\n       matches the UID\
    \ in the Login Ticket, return True.\n    f) Call the Get_Pub_Keys subroutine with\
    \ the name and verifier\n       credentials supplied to this routine and Try_Hard=FALSE.\n\
    \       Ignore any keys retrieved where the corresponding UID does not\n     \
    \  match the UID in the claimant credentials.\n    g) If the Public Key of the\
    \ principal is missing from the\n       claimant information of the claimant credentials,\
    \ then attempt\n       to verify the signature on the login ticket with each public\n\
    \       key returned by Get_Pub_Keys.  If verification succeeds:\n      1) Set\
    \ the Public Key of the principal in the claimant\n         information of the\
    \ claimant credentials to be the Public Key\n         that verified the ticket.\n\
    \      2) If the Full name of the principal in the claimant\n         information\
    \ of the claimant credentials is missing, set it\n         to the name supplied\
    \ to this routine.\n      3) If there is a cache entry, set the Name of Client\
    \ Principal\n         to be the name supplied to this routine, the UID of Client\n\
    \         Principal to be the UID from the Login Ticket, and the\n         Public\
    \ Key of Client Principal to be the Public Key that\n         verified the ticket.\n\
    \      4) Return True.\n    h) If the Public Key of the principal is present in\
    \ the claimant\n       information of the claimant credentials, then see if it\n\
    \       matches any of the public keys returned by Get_Pub_Keys.  If\n       one\
    \ of them matches:\n      1) If the Full name of the principal in the claimant\n\
    \         information of the claimant credentials is missing, set it\n       \
    \  to the name supplied to this routine.\n      2) If there is a cache entry,\
    \ set the Name of Client Principal\n         to be the name supplied to this routine,\
    \ the UID of Client\n         Principal to be the UID from the Login Ticket, and\
    \ the\n         Public Key of Client Principal to be the Public Key that\n   \
    \      verified the ticket.\n      3) Return True.\n    i) If steps 7 & 8 fail,\
    \ retry the call to Get_Pub_Keys with\n       Try_Hard=TRUE, and retry steps 7\
    \ & 8.  If they fail again,\n       return false.\n"
- title: 3.10.10 Get Pub Keys
  contents:
  - "3.10.10 Get Pub Keys\n   Get_Pub_Keys(\n                                    \
    \                --inputs\n                       TA_credentials     Credentials\n\
    \                       Try_Hard           Boolean,\n                       Target\
    \ Name        Name,\n                                                    --outputs\n\
    \                       Pub_keys           Set of Public key/UID pairs\n   This\
    \ common subroutine is used in the execution of Create_Token,\n   Verify_Principal_Name,\
    \ and Verify_Node_Name.  Given the name of a\n   principal, it retrieves a set\
    \ of public key/UID pairs which\n   authenticate that principal (normally only\
    \ one pair).  It does this\n   by retrieving from the naming service a series\
    \ of certificates,\n   verifying the signatures on those certificates, and verifying\
    \ that\n   the sequence of certificates constitute a valid \"treewalk\".\n   The\
    \ credentials structure passed into this procedure represent a\n   starting point\
    \ for the treewalk.  Included in these credentials will\n   be the public key,\
    \ UID, and name of an authority that is trusted to\n   authenticate all remote\
    \ principals (directly or indirectly).\n   The \"Try_Hard\" bit is a specification\
    \ anomaly resulting from the fact\n   that caches maintained by this routine are\
    \ not transparent to the\n   calling routines.  It tells this procedure to bypass\
    \ caches when\n   doing all name service lookups because the information in caches\
    \ is\n   believed to be stale.  In general, a routine will call Get_Pub_Keys\n\
    \   with Try_Hard set false and try to use the keys returned.  If use of\n   those\
    \ keys fails, the calling routine may call this routine again\n   with Try_Hard\
    \ set true in hopes of getting additional keys.\n   Routinely calling this routine\
    \ with Try_Hard set true is likely to\n   have adverse performance implications\
    \ but would not affect the\n   correctness or the security of the operation.\n\
    \   The name supplied is the full X.500 name of the principal for whom\n   public\
    \ keys are needed as part of some authentication process.\n   This procedure securely\
    \ learns the public keys and UIDs of foreign\n   principals by constructing a\
    \ valid chain of certificates between its\n   trusted TA and the certificate naming\
    \ the foreign principal.  In the\n   simplest case, where the TA has signed a\
    \ certificate for the foreign\n   principal, the chain consists of a single certificate.\
    \  Otherwise,\n   the chain must consist of a series of certificates where the\
    \ first is\n   signed by the TA, the last is a certificate for the foreign\n \
    \  principal, and the subject of each principal in the chain is the\n   issuer\
    \ of the next.  What follows is first a definition of what\n   constitutes a valid\
    \ chain of certificates followed by a model\n   algorithm which constructs all\
    \ of (and only) the valid chains which\n   exist between the TA and the target\
    \ name.\n   In order to limit the implications of the compromise of a single CA,\n\
    \   and also to limit the complexity of the search of the certificate\n   space,\
    \ there are restrictions on what constitutes a valid chain of\n   certificates\
    \ from the TA to the Name provided.  The only CAs whose\n   compromise should\
    \ be able to compromise an authentication are those\n   controlling directories\
    \ that are ancestors of one of the two names\n   and that are not above a common\
    \ ancestor.  Therefore, only\n   certificates signed by those CAs will be considered\
    \ valid in a\n   certificate chain.  Normally, the CA for a directory is expected\
    \ to\n   certify a public key and UID for the CA of each child directory and\n\
    \   one parent directory.  A CA may also certify another CA for some\n   remote\
    \ part of the naming hierarchy, and such certificates are\n   necessary if there\
    \ are no CAs assigned to directories high in the\n   naming hierarchy.\n   A certificate\
    \ chain is considered valid if it meets the following\n   criteria:\n    a) It\
    \ must consist of zero or more  parent certificates, followed\n       by zero\
    \ or one   cross certificates, followed by zero or more\n       child certificates.\n\
    \    b) The number of parent certificates may not exceed the number of\n     \
    \  levels in the naming hierarchy between the TA name and the\n       name of\
    \ the least common ancestor in the naming hierarchy\n       between the TA name\
    \ and the target name.\n    c) Each  parent certificate must be stored in the\
    \ naming service\n       under the entry of its issuer.\n    d) The subject of\
    \ the cross certificate (if any) must be an\n       ancestor of the target name\
    \ but must be a longer name than the\n       least common ancestor of the TA name\
    \ and the target name.\n    e) The cross certificate (if any) must have been stored\
    \ in the\n       naming service under the entry of its issuer or there must\n\
    \       have been an indication in the naming service that\n       certificates\
    \ signed by this issuer may be stored with their\n       subjects.\n    f) The\
    \ issuer of each parent certificate does not have stored\n       with it in the\
    \ naming service a cross certificate with the\n       same issuer whose subject\
    \ is an ancestor of the target name.\n    g) Each child certificate must be stored\
    \ in the naming service\n       under the entry of its subject.\n    h) The subject\
    \ of each child certificate does not have associated\n       with it in the naming\
    \ service a cross certificate with the\n       same subject whose issuer is the\
    \ same as the issuer of any of\n       the parent certificates or the cross certificate\
    \ of the chain.\n    i) The subject of each certificate must be the issuer of\
    \ the\n       certificate that follows in the chain.  The equality test can\n\
    \       be met by either of two methods:\n      1) The public key of the subject\
    \ in the earlier certificate\n         verifies the signature of the later and\
    \ the subject UID in\n         the earlier certificate is equal to the issuer\
    \ UID in the\n         later; or\n      2) The public key of the subject in the\
    \ earlier certificate\n         verifies the signature of the later, the earlier\
    \ lacks a\n         subject UID and/or the later lacks an issuer UID and the\n\
    \         name of the subject in the earlier certificate is equal to\n       \
    \  the name of the issuer in the later.\n    j) The Public Key of the TA verifies\
    \ the signature of the first\n       certificate.\n    k) The UID of the TA equals\
    \ the UID of the issuer of the first\n       certificate  or the UID is missing\
    \ on one or both places and\n       the name of the TA equals the name of the\
    \ issuer of the first\n       certificate.\n    l) All of the certificates are\
    \ valid X.509 encodings and the\n       current time is within all of their validity\
    \ intervals.\n   If a chain is valid, the name which it authenticates can be\n\
    \   constructed as follows:\n    a) If the chain contains a cross certificate,\
    \ the name\n       authenticated can be constructed by taking the subject name\n\
    \       from the cross certificate and appending to it a relative name\n     \
    \  for each child certificate which follows.  The relative name\n       is the\
    \ extension by which the subject name in the child\n       certificate extends\
    \ the issuer name.\n    b) If the chain does not contain a cross certificate,\
    \ the name\n       authenticated can be constructed by taking the TA name,\n \
    \      truncating from it the last  n name components where  n is the\n      \
    \ number of  parent certificates in the chain, and appending to\n       the result\
    \ a relative name for each child certificate.  The\n       relative name is the\
    \ extension by which the subject name in\n       the child certificate extends\
    \ the issuer name.\n   In the common case, the authenticated name will be the\
    \ subject\n   name in the last certificate.  The authenticated name is\n   constructed\
    \ by the rules above to deal with namespace\n   reorganization.  If a branch of\
    \ the namespace is renamed (due to,\n   for example, a corporate acquisition or\
    \ reorganization), only the\n   certificates around the break point need to be\
    \ regenerated.\n   Certificates below the break will continue to contain the old\n\
    \   names (until renewed), but the algorithms above assure the\n   principals\
    \ in that branch will be able to authenticate as their\n   new names.  Further,\
    \ if the certificates at the branch point are\n   maintained for both the old\
    \ and new names for an interim period,\n   principals in the moved branch will\
    \ be able to authenticate as\n   either their old or new names for that interim\
    \ period without\n   having duplicate certificates.\n   A final complication that\
    \ the algorithm must deal with is the\n   location of  cross certificates.  If\
    \ a key is compromised or for\n   some other reason it is important to revoke\
    \ a certificate ahead\n   of its expiration, it is removed from the naming service.\
    \  This\n   algorithm will only use certificates that it has recently\n   retrieved\
    \ from the naming service, so revocation is as effective\n   as the mechanisms\
    \ that prevent impersonation of the naming\n   service.   There are plans to eventually\
    \ use DASS mechanisms to\n   secure access to the naming service; until they are\
    \ in place,\n   name service impersonation is a theoretical threat to the\n  \
    \ security of revocation.  Opinions differ as to whether it is a\n   practical\
    \ threat.   Child certificates are always stored with the\n   subject and will\
    \ not be found unless stored in the name server of\n   the subject.    Parent\
    \  certificates are always stored with the\n   issuer and will not be found unless\
    \ stored in the name server of\n   the issuer.  For best security, cross certificates\
    \ should be\n   stored with the issuer because the name server for the subject\n\
    \   may not be adequately trustworthy to perform revocation.  There\n   are performance\
    \ and availability penalties, however, in doing so.\n   The architecture and the\
    \ algorithm therefore support storing\n   cross certificates with either the issuer\
    \ or the subject.  There\n   must be some sort of flag in the name service associated\
    \ with the\n   issuer saying whether cross certificates from that issuer are\n\
    \   permitted to be stored in the subject's name service entry, and\n   if that\
    \ flag is set such certificates will be found and used.\n   In order to make revocation\
    \ effective, DASS must assure that\n   naming service caches do not become arbitrarily\
    \ stale (the\n   allowed age of a cache entry is included in the sum of times\
    \ with\n   together make up the revocation time).  If DASS uses a naming\n   service\
    \ such as DNS that does not time out cache entries, it must\n   bypass cache on\
    \ all calls and (to achieve reasonable performance)\n   maintain its own naming\
    \ service cache.  It may be advantageous to\n   maintain a cache in any case so\
    \ the that the fact that the\n   certificates have been verified can be cached\
    \ as well as the fact\n   that they are current.\n"
- title: 3.10.10.1 Basic Algorithm
  contents:
  - "3.10.10.1 Basic Algorithm\n   For ease of exposition, this first description\
    \ will ignore the\n   operation of any caches.  Permissible modifications to take\n\
    \   advantage of caches and enhance performance will be covered in\n   the next\
    \ section.  This path will be followed if the Try_Hard bit\n   is set True on\
    \ the call.\n   Rather than trying construct all possible chains between the TA\n\
    \   and the name to be authenticated (in the event of multiple\n   certificates\
    \ per principal, there could be exponentially many\n   valid chains), this algorithm\
    \ computes a set of PK/UID/Name\n   triples that are valid for each principal\
    \ on the path between the\n   TA and the name to be authenticated.  By doing so,\
    \ it minimizes\n   the processing of redundant information.\n    a) Determining\
    \ path and initialization\n       Several state variables are manipulated during\
    \ the tree walk.\n       These are called:\n      1) Current-directory-name\n\
    \         This is the name indicating the current place in the tree\n        \
    \ walk.  Initially, this is the name of the TA.\n      2) Least-Common-Ancestor-Name\n\
    \         This is the portion of the names which is common to both the\n     \
    \    CA and the Target.  This is computed at initialization and\n         does\
    \ not change during the treewalk.\n      3) Trusted-Key-Set\n         For each\
    \ name which is an ancestor of either the TA or the\n         Target but not of\
    \ the Least-Common-Ancestor, a list of\n         PK/UID/Name triples.  This is\
    \ initialized to a single triple\n         from the TA information in the supplied\
    \ credentials.\n      4) Search-when-descending\n         This is a list of PK/UID/Name\
    \ triples of issuers that will\n         be trusted when descending the tree.\
    \  This set is initially\n         empty.\n      5) Saved-RDNs\n         This\
    \ is a sequence of Relative Distinguished Names (RDNs)\n         stripped off\
    \ the right of the target name to form\n         Least-common-ancestor-name. \
    \ This \"stack\" is initially empty\n         and is populated during Step 3.\n\
    \    b) Ascending the \"TA side\" of the tree\n       While Current-directory-name\
    \ is not identical to\n       Common-point-Name the algorithm moves up the tree.\
    \ At each\n       step it does the following operations.\n      1) Find all cross\
    \ certificates stored in the naming service\n         under Current-directory-name\
    \ in which the subject is an\n         ancestor of the principal to be authenticated\
    \ or an\n         indication that cross certificates from this issuer are\n  \
    \       stored in the subject entry.  If there is an indication that\n       \
    \  such certificates are stored in the subject entry, copy all\n         triples\
    \ in Trusted-Key-Set for Current-directory-name into\n         the \"Search-when-descending\"\
    \ list.  If any such certificates\n         are found, filter them to include\
    \ only those which meet the\n         following criteria:\n        (i)  For some\
    \ triple in the Trusted-Key-Set corresponding to\n             the Current-directory-name,\
    \ the public key in the triple\n             verifies the signature on the certificate\
    \  and either the\n             UID in the triple matches the issuer UID in the\n\
    \             certificate  or the UID in the triple and/or the\n             certificate\
    \ is missing and the name in the triple matches\n             the issuer name\
    \ in the certificate.\n        (ii) No certificates were found signed by this\
    \ issuer in which\n             the subject name is longer than the subject name\
    \ in this\n             certificate (i.e., if there are cross certificates to\
    \ two\n             different ancestors, accept only those which lead to the\n\
    \             closest ancestor).\n        (iii)The current time is within the\
    \ validity interval of the\n             certificate.\n      2) If any cross certificates\
    \ were found (whether or not they\n         were all eliminated as part of the\
    \ filtering process), set\n         Current-directory-name to the longest name\
    \ that was found in\n         any certificate and construct a set of PK/UID/Name\
    \ triples\n         for that name from the certificates which pass the filter\n\
    \         and place them in the Trusted Key Set associated with their\n      \
    \   subject.  Exit the ascending tree loop at this point and\n         proceed\
    \ directly to step 3.  Note that this means that if\n         there are cross\
    \ certificates to an ancestor of the target\n         but they are all rejected\
    \ (for example if they have\n         expired), the treewalk will   not construct\
    \ a chain through\n         the least common ancestor and will ultimately fail\
    \ unless a\n         crosslink from a lower ancestor is found stored with its\n\
    \         subject.  This is a security feature.\n      3) If no cross certificates\
    \ are found, find all the parent\n         directory certificates for the directory\
    \ whose name is in\n         the Current-directory-name.  Filter these to find\
    \ only those\n         which meet the following criteria:\n        (i)  The current\
    \ time is within the validity interval.\n        (ii) For some triple corresponding\
    \ to the\n             Current-directory-name, the public key in the triple\n\
    \             verifies the signature on the certificate  and either  the\n   \
    \          UID in the triple matches the issuer UID in the\n             certificate\
    \  or the UID in the triple and/or the\n             certificate is missing and\
    \ the name in the triple matches\n             the issuer name in the certificate.\n\
    \      4) Construct PK/UID/Name triples from the remaining\n         certificates\
    \ for the directory whose name is constructed by\n         stripping the rightmost\
    \ simple name from the\n         Current-directory-name and place them in the\
    \ Trusted-Key-Set.\n      5) Strip the rightmost simple name of the\n        \
    \ Current-directory-name.\n      6) Repeat from step (a) (testing to see if\n\
    \         current-directory-name is the same as Common-point-Name).\n    c) Searching\
    \ the \"target side\" of the tree for a crosslink:\n      1) Initialization: set\
    \ Current-directory-name to the name\n         supplied as input to this procedure.\n\
    \      2) Retrieve from the naming service all cross certificates\n         associated\
    \ with Current-directory-name.  Filter to only\n         those that meet the following\
    \ criteria:\n        (i)  The current time is within their validity interval.\n\
    \        (ii) The subject name is equal to Current-directory-name.\n        (iii)For\
    \ some PK/UID/Name triple in the\n             \"Search-when-descending\" list\
    \ compiled while ascending\n             the tree, the Public Key verifies the\
    \ signature on the\n             certificate and  either the UID matches the issuer\
    \ UID in\n             the certificate   or a UID is missing from the triple\n\
    \             and/or the certificate and the Name in the triple matches\n    \
    \         the issuer name in the certificate.\n        (iv) There are no certificates\
    \ found meeting criteria (ii) and\n             (iii) matching a PK/UID/Name triple\
    \ in the\n             Search-when-descending list whose subject is a directory\n\
    \             lower in the naming hierarchy.\n      3) If any qualifying certificates\
    \ are found, construct\n         PK/UID/Name triples for each of them; these should\
    \ replace\n         rather than supplement any triples already in the\n      \
    \   Trusted-key-set for that directory.\n      4) If after steps (b) and (c),\
    \ there are no PK/UID/Name triples\n         corresponding to Current-directory-name\
    \ in Trusted-Key-Set,\n         shorten Current-directory-name by one RDN (pushing\
    \ it onto\n         the Saved-RDNs stack) and repeat this process until\n    \
    \     Current-directory-name is equal to\n         Least-common-ancestor-name\
    \  or there is at least one triple\n         in Trusted-key-set corresponding\
    \ to Current-directory-name.\n    d) Descending the tree\n       While the list\
    \ Saved-RDNs is not Empty the algorithm moves\n       down the tree. At each step\
    \ it does the following operations.\n      1) Remove the first RDN from Saved-RDNs\
    \ and append it to the\n         Current-directory-name.\n      2) Find all the\
    \ child directory certificates for the directory\n         whose name is in the\
    \ current-directory-name.\n      3) Filter these certificates to find only those\
    \ which meet the\n         following criteria:\n        (i)  The current time\
    \ is within the validity interval.\n        (ii) For some PK/UID/Name triple in\
    \ the Current-key-set for\n             the parent directory, the Public Key verifies\
    \ the\n             signature on the certificate and either the UID matches\n\
    \             the issuer UID of the certificate   or the UID is missing\n    \
    \         from the triple and/or the certificate and the Name in\n           \
    \  the triple matches the issuer name in the certificate.\n        (iii)The issuer\
    \ name in the certificate is a prefix of the\n             subject name and the\
    \ difference between the two names is\n             the final RDN of Current-directory-name.\n\
    \      4) Take the key, UID, and name from each remaining certificate\n      \
    \   and form a new triple corresponding to\n         Current-directory-name in\
    \ Trusted-Key-Set. If this set is\n         empty then the algorithm exits with\
    \ the\n         'Incomplete-chain-of-trustworthy-CAs' error condition.\n     \
    \ 5) repeat from step (a), appending a new simple name to\n         Current-directory-name.\n\
    \    e) Find public keys:\n       If there are no triples in the Trusted-Key-Set\
    \ for the named\n       principal, then the algorithm exits with the `Target-has-no-keys-w\n\
    \       error condition. Otherwise, the Public Key and UID are\n       extracted\
    \ from each pair, duplicates are eliminated, and this\n       set is returned\
    \ as the Pub_keys.\n"
- title: 3.10.10.2 Allowed Variations - Caching
  contents:
  - "3.10.10.2 Allowed Variations - Caching\n   Some use of caches can be implemented\
    \ without affecting the semantics\n   of the Get_Pub_Keys routine.  For example,\
    \ a crypto-cache could\n   remember the public key that verified a signature in\
    \ the past and\n   could avoid the verification operation if the same key was\
    \ used to\n   verify the same data structure again.  In some cases, however, it\
    \ is\n   impossible (or at least inconvenient) for a cache implementation to\n\
    \   be completely transparent.\n   In particular, for good performance it is important\
    \ that certificates\n   not be re-retrieved from the naming service on every authentication.\n\
    \   This must be balanced against the need to have changes to the\n   contents\
    \ of the naming service be reflected in DASS calls on a timely\n   basis.  There\
    \ are two cases of interest: changes which cause an\n   authentication which previously\
    \ would have succeeded to fail and\n   changes which cause an authentication which\
    \ previously would have\n   failed to succeed.  These two cases are subject to\
    \ different time\n   constraints.\n   In general, changes that cause authentication\
    \ to succeed must be\n   reflected quite quickly - on the order of minutes.  If\
    \ a user\n   attempts an operation, it fails, the user tracks down a system\n\
    \   manager and causes the appropriate updates to take place, and the\n   user\
    \ retries the operation, it is unacceptable for the operation to\n   continue\
    \ to fail for an extended period because of stale caches.\n   Changes that cause\
    \ authentication to fail must be reflected reliably\n   within a bounded period\
    \ of time for security reasons.  If a user\n   leaves the company, it must be\
    \ possible to revoke his ability to\n   authenticate within a relatively short\
    \ period of time - say hours.\n   These constraints mean that a naming service\
    \ cache which contains\n   arbitrarily old information is unacceptable.  To meet\
    \ the second\n   constraint, naming service cache entries must be timed out within\
    \ a\n   reasonable period of time unless in implementation verifies that the\n\
    \   certificate is still present (a crypto-cache which lasted longer\n   would\
    \ be legal; rather than deleting a name service cache entry, in\n   implementation\
    \ might instead verify that the entry was still present\n   in the naming service.\
    \  This would avoid repeating the cryptographic\n   \"verify\").\n   In order\
    \ to assure that information cached for even a few hours not\n   deny authentication\
    \ for that extended period, it must be possible to\n   bypass caches when the\
    \ result would otherwise be a failure.  Since\n   the performance of authentication\
    \ failures is not a serious concern,\n   it is acceptable to expect that before\
    \ an operation fails a retry\n   will be made to the naming service to see if\
    \ there are any new\n   relevant certificates (or in certain obscure conditions,\
    \ to see if\n   any relevant certificates have been deleted).\n   If on a call\
    \ to Get_Pub_Keys, the Try_Hard bit is True, then this\n   procedure must return\
    \ results based on the contents of the naming\n   service no more than five minutes\
    \ previous (this would normally be\n   accomplished by ignoring name service caches\
    \ and making all\n   operations directly to the naming service).  If the Try_Hard\
    \ bit is\n   False, this procedure may return results based on the contents of\
    \ the\n   naming service any time in the previous few hours, in the sense that\n\
    \   it may ignore any certificate added in the previous few hours and may\n  \
    \ use any certificate deleted in the previous few hours.  Procedures\n   which\
    \ call this routine with Try_Hard set to false must be prepared\n   to call it\
    \ again with Try_Hard True if their operation fails possibly\n   from this result.\n\
    \   The exact timer values for \"five minutes\" and \"a few hours\" are\n   expected\
    \ to be implementation constants.\n   In the envisioned implementation, the entire\
    \ \"ascending treewalk\" is\n   retrieved, verified, and its digested contents\
    \ cached when a\n   principal first establishes credentials.  A mechanism should\
    \ be\n   provided to refresh this information periodically for principals\n  \
    \ whose sessions might be long lived, but it would probably be\n   acceptable\
    \ in the unlikely event of a user's ancestor's keys changing\n   to require that\
    \ the user log out and log back in.  This is consistent\n   with the observed\
    \ behavior of existing security mechanisms.\n   The descending treewalk, on the\
    \ other hand, is expected to be\n   maintained as a more conventional cache, where\
    \ entries are kept in a\n   fixed amount of memory with a \"least recently used\"\
    \ replacement\n   policy and a watchdog timer that assures that stale information\
    \ is\n   not kept indefinitely.  A call to Get_Pub_Keys with Try_Hard set\n  \
    \ false would first check that cache for relevant certificates and only\n   if\
    \ none were found there would it go out to the naming service.  If\n   there were\
    \ newer certificates in the naming service, they might not\n   be found and an\
    \ authentication might therefore fail.\n   When Try_Hard is false, an implementation\
    \ may assume that\n   certificates not in the cache do not exist so long as that\
    \ assumption\n   does not cause an authentication to falsely succeed.  In that\
    \ case,\n   it may only make that assumption if the certificates have been\n \
    \  verified to not exist within the revocation time (a few hours).\n"
- title: 3.11 DASSlessness Determination Functions
  contents:
  - "3.11 DASSlessness Determination Functions\n   In order to provide better interoperability\
    \ with alternative\n   authentication mechanisms and to provide backward compatibility\
    \ with\n   older (insecure) authentication mechanisms, it is sometimes important\n\
    \   to be able to determine in a secure way what the appropriate\n   authentication\
    \ mechanism is for a particular named principal.  For\n   some applications, this\
    \ will be done by a local mechanism, where\n   either the person creating access\
    \ control information must know and\n   specify the mechanism for each principal\
    \ or a system administrator on\n   the node must maintain a database mapping names\
    \ to mechanisms.  Three\n   applications come to mind where scaleability makes\
    \ such mechanisms\n   implausible:\n    a) To transparently secure proxy-based\
    \ applications (like rlogin)\n       in an environment where some hosts have been\
    \ upgraded to\n       support DASS and some have not, a node must be willing to\n\
    \       accept connections authenticated only by their network\n       addresses\
    \ but only if they can be assured that such nodes do\n       not have DASS installed.\
    \  Access to a resource becomes secure\n       without administrative action when\
    \ all nodes authorized to\n       access it have been upgraded.\n       In this\
    \ scenario, the server node must be able to determine\n       whether the client\
    \ node is DASSless in a secure fashion.\n    b) Similarly, in a mixed environment\
    \ where some servers are\n       running DASS and some are not, it may be desirable\
    \ for clients\n       to authenticate servers if they can but it would be\n  \
    \     unacceptable for a client to stop being able to access a\n       DASSless\
    \ server once DASS is installed on the client.  In such\n       a situation where\
    \ server authentication is desirable but not\n       essential, the client would\
    \ like to determine in a secure\n       fashion whether the server can accept\
    \ DASS authentication.\n    c) In a DASS/Kerberos interoperability scenario, a\
    \ server may\n       decide that Kerberos authentication is \"good enough\" for\n\
    \       principals that do not have DASS credentials without\n       introducing\
    \ trust in on-line authorities when DASS credentials\n       are available.  In\
    \ parallel with case 1, we want it to be true\n       that when the last principal\
    \ with authority to access an\n       object is upgraded to DASS, we automatically\
    \ cease to trust\n       PasswdEtc servers without administrative action on the\
    \ part of\n       the object owner.  For this purpose, the authenticator must\n\
    \       learn in a secure fashion that the principal is incapable of\n       DASS\
    \ authentication.\n   Reliably determining DASSlessness is optional for implementations\
    \ of\n   DASS and for applications.  No other capabilities of DASS rely on\n \
    \  this one.\n   The interface to the DASSlessness inquiry function is specified\
    \ as a\n   call independent of all others.  This capability must be exposed to\n\
    \   the calling application so that a server that receives a request and\n   no\
    \ token can ask whether the named principal should be believed\n   without a token.\
    \  It might improve performance and usability if in\n   real interfaces DASSlessness\
    \ were returned in addition to a bad\n   status on the function that creates a\
    \ token if the token is targeted\n   toward a server incapable or processing it.\
    \  An application could\n   then decide whether to make the request without a\
    \ token (and give up\n   server authentication) or to abort the request.\n"
- title: 3.11.1 Query DASSlessness
  contents:
  - "3.11.1 Query DASSlessness\n   Query_DASSlessness(\n                         \
    \                             --inputs\n                       verifying_credentials\
    \ Credentials,\n                       principal_name        Name,\n         \
    \                                             --outputs\n                    \
    \   alternate_authentication Set of OIDs)\n   This function uses the verifying\
    \ credentials to search for an\n   alternative authentication mechanism certificate\
    \ for the named\n   principal or for any CA on the path between the verifying\
    \ credentials\n   and the named principal.  Such a certificate is identical to\
    \ an DASS\n   X.509 certificate except that it lists a different algorithm\n \
    \  identifier for the public key of the subject than that expected by\n   DASS.\n\
    \   This function is implemented identically to Get_Pub_Keys except:\n    a) If\
    \ in any set of certificates found, no valid DASS certificate\n       is found\
    \ and one or more certificates are found that would\n       otherwise be valid\
    \ except for an invalid subject public key\n       OID, the OID from that certificate\
    \ or certificates is returned\n       and the algorithm terminates.\n    b) On\
    \ initial execution, Try_Hard=False.  If the first execution\n       fails to\
    \ retrieve any valid PK/UID pairs but also fails to\n       find any invalid OID\
    \ certificates, repeat the execution with\n       Try_Hard=True.\n    c) If the\
    \ either execution finds PK/UID pairs or if neither finds\n       and invalid\
    \ OID certificates, fail by returning a null set.\n"
- title: 4. Certificate and message formats
  contents:
  - '4. Certificate and message formats

    '
- title: 4.1 ASN.1 encoding
  contents:
  - "4.1 ASN.1 encoding\n   Some definitions are taken from X.501 and X.509.\n   Dass\
    \ DEFINITIONS ::=\n   BEGIN\n   --CCITT Definitions:\n   joint-iso-ccitt     \
    \ OBJECT IDENTIFIER ::= {2}\n   ds                   OBJECT IDENTIFIER ::= {joint-iso-ccitt\
    \ 5}\n   algorithm            OBJECT IDENTIFIER ::= {ds 8}\n   encryptionAlgorithm\
    \  OBJECT IDENTIFIER ::= {algorithm 1}\n   hashAlgorithm        OBJECT IDENTIFIER\
    \ ::= {algorithm 2}\n   signatureAlgorithm   OBJECT IDENTIFIER ::= {algorithm\
    \ 3}\n   rsa                  OBJECT IDENTIFIER ::= {encryptionAlgorithm 1}\n\
    \   iso                  OBJECT IDENTIFIER ::= {1}\n   identified-organization\
    \ OBJECT IDENTIFIER ::= {iso 3}\n   ecma               OBJECT IDENTIFIER ::= {identified-organization\
    \ 12}\n   member-company       OBJECT IDENTIFIER ::= {ecma 2}\n   digital    \
    \          OBJECT IDENTIFIER ::= {member-company 1011}\n   --1989 OSI Implementors\
    \ Workshop \"Stable\" Agreements\n   oiw                OBJECT IDENTIFIER ::=\
    \ {identified-organization 14}\n   dssig                  OBJECT IDENTIFIER ::=\
    \ {oiw 7}\n   oiwAlgorithm           OBJECT IDENTIFIER ::= {dssig 2}\n   oiwEncryptionAlgorithm\
    \ OBJECT IDENTIFIER ::= {oiwAlgorithm 1}\n   oiwHashAlgorithm       OBJECT IDENTIFIER\
    \ ::= {oiwAlgorithm 2}\n   oiwSignatureAlgorithm  OBJECT IDENTIFIER ::= {oiwAlgorithm\
    \ 3}\n   oiwMD2                 OBJECT IDENTIFIER ::= {oiwHashAlgorithm 1}\n \
    \                                                 --null parameter\n   oiwMD2withRSA\
    \          OBJECT IDENTIFIER ::= {oiwSignatureAlgorithm 1}\n                 \
    \                                 --null parameter\n   --X.501 definitions\n \
    \  AttributeType ::= OBJECT IDENTIFIER\n   AttributeValue ::= ANY\n   AttributeValueAssertion\
    \ ::= SEQUENCE {AttributeType,AttributeValue}\n   Name ::= CHOICE {       --only\
    \ one for now\n                   RDNSequence\n                       }\n   RDNSequence\
    \ ::= SEQUENCE OF RelativeDistinguishedName\n   DistinguishedName ::= RDNSequence\n\
    \   RelativeDistinguishedName ::= SET OF AttributeValueAssertion\n   --X.509 definitions\
    \ (with proposed 1992 extensions presumed)\n   ENCRYPTED MACRO ::=\n   BEGIN\n\
    \   TYPE NOTATION   ::= type(ToBeEnciphered)\n   VALUE NOTATION  ::= value(VALUE\
    \ BIT STRING)\n   END     -- of ENCRYPTED\n   SIGNED MACRO    ::=\n   BEGIN\n\
    \   TYPE NOTATION   ::= type (ToBeSigned)\n   VALUE NOTATION  ::= value (VALUE\n\
    \   SEQUENCE{\n           ToBeSigned,\n           AlgorithmIdentifier,    --of\
    \ the algorithm used to\n                                   --generate the signature\n\
    \           ENCRYPTED OCTET STRING  --where the octet string is the\n        \
    \                           --result of the hashing of the\n                 \
    \                  --value of \"ToBeSigned\"\n           }\n                 \
    \          )\n   END     -- of SIGNED\n   SIGNATURE MACRO ::=\n   BEGIN\n   TYPE\
    \ NOTATION   ::= type (OfSignature)\n   VALUE NOTATION  ::= value (VALUE\n   SEQUENCE\
    \ {\n           AlgorithmIdentifier,    --of the algorithm used to compute\n \
    \          ENCRYPTED OCTET STRING  -- the signature where the octet\n        \
    \                           -- string is a function (e.g., a\n               \
    \                    -- compressed or hashed version)\n                      \
    \             -- of the value 'OfSignature',\n                               \
    \    -- which may include the\n                                   -- identifier\
    \ of the algorithm\n                                   -- used to compute the\
    \ signature\n           }\n                           )\n   END     -- of SIGNATURE\n\
    \   Certificate ::= SIGNED SEQUENCE {\n           version [0]             Version\
    \ DEFAULT v1988,\n           serialNumber    CertificateSerialNumber,\n      \
    \     signature               AlgorithmIdentifier,\n           issuer        \
    \  Name,\n           valid           Validity,\n           subject         Name,\n\
    \           subjectPublicKey        SubjectPublicKeyInfo,\n           issuerUID\
    \ [1]   IMPLICIT UID OPTIONAL,  -- v1992\n           subjectUID [2]  IMPLICIT\
    \ UID OPTIONAL   -- v1992\n           }\n           --The Algorithm Identifier\
    \ for both the signature field\n           --and in the signature itself is:\n\
    \           --      oiwMD2withRSA (1.3.14.7.2.3.1)\n   Version ::= INTEGER {v1988(0),\
    \ v1992(1)}\n   CertificateSerialNumber ::= INTEGER\n   Validity ::= SEQUENCE\
    \ {\n           NotBefore       UTCTime,\n           NotAfter        UTCTime\n\
    \           }\n   AlgorithmIdentifier ::= SEQUENCE {\n           algorithm   \
    \    OBJECT IDENTIFIER,\n           parameter       ANY DEFINED BY algorithm OPTIONAL\n\
    \           }\n   --The algorithms we support in one context or another are:\n\
    \           --oiwMD2withRSA (1.3.14.7.2.3.1) with parameter NULL\n           --rsa\
    \ (2.5.8.1.1) with parameter keysize INTEGER which is\n           --         \
    \  the keysize in bits\n           --decDEA (1.3.12.1001.7.1.2) with optional\
    \ parameter\n           --           missing\n           --decDEAMAC (1.3.12.2.1011.7.3.3)\
    \ with optional parameter\n           --           missing\n   SubjectPublicKeyInfo\
    \  ::=  SEQUENCE {\n           algorithm       AlgorithmIdentifier,     -- rsa\
    \ (2.5.8.1.1)\n           subjectPublicKey        BIT STRING\n               \
    \    -- the \"bits\" further decode into a DASS public key\n           }\n   UID\
    \ ::= BIT STRING\n   -- the following definitions are for Digital specified Algorithms\n\
    \   cryptoAlgorithm OBJECT IDENTIFIER ::= {digital 7}\n   decEncryptionAlgorithm\
    \  OBJECT IDENTIFIER ::= {cryptoAlgorithm 1}\n   decHashAlgorithm        OBJECT\
    \ IDENTIFIER ::= {cryptoAlgorithm 2}\n   decSignatureAlgorithm   OBJECT IDENTIFIER\
    \ ::= {cryptoAlgorithm 3}\n   decDASSLessness         OBJECT IDENTIFIER ::= {cryptoAlgorithm\
    \ 6}\n   decMD2withRSA   OBJECT IDENTIFIER ::= {decSignatureAlgorithm 1}\n   decMD4withRSA\
    \   OBJECT IDENTIFIER ::= {decSignatureAlgorithm 2}\n   decDEAMAC       OBJECT\
    \ IDENTIFIER ::= {decSignatureAlgorithm 3}\n   decDEA          OBJECT IDENTIFIER\
    \ ::= {decEncryptionAlgorithm 2}\n   decMD2          OBJECT IDENTIFIER ::= {decHashAlgorithm\
    \ 1}\n   decMD4          OBJECT IDENTIFIER ::= {decHashAlgorithm 2}\n   ShortPosixTime\
    \ ::= INTEGER   -- number of seconds since base time\n   LongPosixTime ::= SEQUENCE\
    \ {\n           INTEGER,             -- number of seconds since base time\n  \
    \         INTEGER              -- number of nanoseconds since second\n       \
    \    }\n   ShortPosixValidity ::=  SEQUENCE {\n           notBefore       ShortPosixTime,\n\
    \           notAfter        ShortPosixTime }\n   -- Note: Annex C of X.509 prescribes\
    \ the following format for the\n   -- representation of a public key, but does\
    \ not give the structure\n   -- a name.\n   DASSPublicKey ::=  SEQUENCE {\n  \
    \         modulus         INTEGER,\n           exponent        INTEGER\n     \
    \      }\n   DASSPrivateKey ::= SEQUENCE {\n           p       INTEGER ,     \
    \                 -- prime p\n           q [0]   IMPLICIT INTEGER OPTIONAL , \
    \   -- prime q\n           mod[1]  IMPLICIT INTEGER OPTIONAL,     -- modulus\n\
    \           exp [2] IMPLICIT INTEGER OPTIONAL,     -- public exponent\n      \
    \     dp [3]  IMPLICIT INTEGER OPTIONAL ,    -- exponent mod p\n           dq\
    \ [4]  IMPLICIT INTEGER OPTIONAL ,    -- exponent mod q\n           cr [5]  IMPLICIT\
    \ INTEGER OPTIONAL ,    -- Chinese\n                                         \
    \     --remainder coefficient\n           uid[6]  IMPLICIT UID OPTIONAL,\n   \
    \        more[7] IMPLICIT BIT STRING OPTIONAL   --Reserved for\n             \
    \                                     --future use\n           }\n   LocalUserName\
    \   ::= OCTET STRING\n   ChannelId               ::= OCTET STRING\n   VersionNumber\
    \           ::= OCTET STRING (SIZE(3))\n                           -- first octet\
    \ is major version\n                           -- second octet is minor version\n\
    \                           -- third octet is ECO rev.\n   versionZero  VersionNumber\
    \ ::= '000000'H\n   Authenticator ::= SIGNED SEQUENCE {\n           type     \
    \       BIT STRING,\n                    -- first bit `delegation required'\n\
    \                    -- second bit `Mutual Authentication Requested'\n       \
    \    whenSigned      LongPosixTime ,\n           channelId  [3]  IMPLICIT ChannelId\
    \ OPTIONAL\n                   -- channel bindings are included when doing the\n\
    \                   -- signature, but excluded when transmitting the\n       \
    \            -- Authenticator\n           }\n                   -- uses decDEAMAC\
    \ (1.3.12.2.1011.7.3.3)\n   EncryptedKey ::= SEQUENCE {\n           algorithm\
    \               AlgorithmIdentifier,\n                           -- uses rsa (2.5.8.1.1)\n\
    \           encryptedAuthKey        BIT STRING\n                           --\
    \ as defined in section 4.4.5\n           }\n   SignatureOnEncryptedKey ::=  SIGNATURE\
    \ EncryptedKey\n                -- uses oiwMD2withRSA (1.3.14.7.2.3.1)\n     \
    \           -- Signature bits computed over EncryptedKey structure\n   LoginTicket\
    \ ::= SIGNED SEQUENCE {\n           version [0]         IMPLICIT VersionNumber\
    \ DEFAULT versionZero,\n           validity            ShortPosixValidity ,\n\
    \           subjectUID          UID ,\n           delegatingPublicKey SubjectPublicKeyInfo\n\
    \           }\n           -- uses oiwMD2withRSA (1.3.14.7.2.3.1)\n   Delegator\
    \ ::= SEQUENCE {\n           algorithm               AlgorithmIdentifier\n   \
    \                        -- decDEA encryption (1.3.12.1001.7.1.2)\n          \
    \ encryptedPrivKey        ENCRYPTED  DASSPrivateKey,\n                       \
    \    -- (only p is included)\n           }\n   UserClaimant ::=  SEQUENCE {\n\
    \           userTicket [0]  IMPLICIT LoginTicket,\n           evidence  CHOICE\
    \ {\n                   delegator [1]   IMPLICIT Delegator ,\n               \
    \                 -- encrypted delegation private key\n                      \
    \          -- under DES authenticating key\n                                --\
    \ present if delegating\n                   sharedKeyTicketSignature [2]\n   \
    \                        IMPLICIT SignatureOnEncryptedKey\n                  \
    \              -- present if not delegating\n                   } ,\n        \
    \   userName [3]    IMPLICIT Name OPTIONAL\n                                --\
    \ name of user principal\n           }\n   EncryptedKeyandUserName ::= SEQUENCE\
    \ {\n           encryptedKey    EncryptedKey ,\n           username          \
    \      LocalUserName\n           }\n   SignatureOnEncryptedKeyandUserName ::=\n\
    \           SIGNATURE EncryptedKeyandUserName\n                   -- uses oiwMD2withRSA\
    \ (1.3.14.7.2.3.1)\n                   -- Signature bits computed over\n     \
    \              -- EncryptedKeyandUserName structure\n                   -- using\
    \ node private key\n           }\n   NodeClaimant ::= SEQUENCE {\n           nodeTicket\
    \ Signature[0] IMPLICIT\n                   SignatureOnEncryptedKeyandUserName,\n\
    \           nodeName  [1]   IMPLICIT Name OPTIONAL,\n           username  [2]\
    \   IMPLICIT LocalUserName OPTIONAL\n           }\n   AuthenticationToken ::=\
    \ SEQUENCE {\n           version [0]    IMPLICIT VersionNumber DEFAULT versionZero,\n\
    \           authenticator [1]       IMPLICIT Authenticator ,\n           encryptedKey\
    \  [2]       IMPLICIT EncryptedKey OPTIONAL ,\n                    -- required\
    \ if initiating token\n           userclaimant  [3]       IMPLICIT UserClaimant\
    \ OPTIONAL ,\n                    -- missing if only doing node authentication\n\
    \                    -- required if not doing node authentication\n          \
    \ nodeclaimant [4]        IMPLICIT NodeClaimant OPTIONAL\n                   \
    \ -- missing if only doing principal authentication\n                    -- required\
    \ if not doing principal authentication\n           }\n   MutualAuthenticationToken\
    \ ::= CHOICE {\n           v1Response [0] IMPLICIT  OCTET STRING (SIZE(6))\n \
    \                -- Constructed as follows:  A single DES block\n            \
    \     -- of eight octets is constructed from the two\n                 -- integers\
    \ in the timestamp.  First four bytes\n                 -- are the high order\
    \ integer encoded MSB\n                 -- first; Last four bytes are the low\
    \ order\n                 -- integer encoded MSB first.  The block is\n      \
    \           -- encrypted using the shared DES key, and\n                 -- the\
    \ first six bytes are the OCTET STRING.\n                 -- With the [0] type\
    \ and 6-byte length, the\n                 -- MutualAuthenticationToken has a\
    \ fixed\n                 -- length of eight bytes.\n           }\n   END\n"
- title: 4.2 Encoding Rules
  contents:
  - "4.2 Encoding Rules\n   Whenever a structure is to be signed it must always be\
    \ constructed\n   the same way. This is particularly important where a signed\
    \ structure\n   has to be reconstructed by the recipient before the signature\
    \ is\n   verified. The rules listed below are taken from X.509.\n    - the definite\
    \ form of length encoding shall be used, encoded in\n      the minimum number\
    \ of octets;\n    - for string types, the constructed form of encoding shall not\n\
    \      be used;\n    - if the value of a type is its default value, it shall be\n\
    \      absent;\n    - the components of a Set type shall be encoded in ascending\n\
    \      order of their tag value;\n    - the components of a Set-of type shall\
    \ be encoded in ascending\n      order of their octet value;\n    - if the value\
    \ of a Boolean type is true, the encoding shall\n      have its contents octet\
    \ set to `FF'16;\n    - each unused bits in the final octet of the encoding of\
    \ a\n      BitString value, if there are any, shall be set to zero;\n    - the\
    \ encoding of a Real type shall be such that bases 8, 10 and\n      16 shall not\
    \  be used, and the binary scaling factor shall be\n      zero.\n"
- title: 4.3 Version numbers and forward compatibility
  contents:
  - "4.3 Version numbers and forward compatibility\n   The LoginTicket and AuthenticationToken\
    \ structures contain a\n   three octet version identifier which is intended to\
    \ ease\n   transition to future revisions of this architecture.  The default\n\
    \   value, and the value which should always be supplied by\n   implementations\
    \ of this version of the architecture is 0.0.0\n   (three zero octets).  The first\
    \ octet is the major version.  An\n   implementation of this version of the architecture\
    \ should refuse\n   to process data structures where it is other than zero, because\n\
    \   changing it indicates that the interpretation of some subsidiary\n   data\
    \ structure has changed.  The second octet is the minor\n   version.  An implementation\
    \ of this version of the architecture\n   should ignore the value of this octet.\
    \  Some future version of\n   the architecture may set a value other than zero\
    \ and may specify\n   some different processing of the remainder of the structure\
    \ based\n   on that different value.  Such a change would be backward compatible\n\
    \   and interoperable.  The third octet is the ECO revision.  No\n   implementation\
    \ should make any processing decisions based on the\n   value of that octet. \
    \ It may be logged, however, to help in\n   debugging interoperability problems.\n\
    \   In the CDC protocol, there is also a three octet version\n   numbering scheme,\
    \ where versions 1.0.0 and 2.0.0 have been\n   defined.  Implementations should\
    \ follow the same rules above and\n   reject major version numbers greater than\
    \ 2.\n   ASN.1 is inherently extensible because it allows new fields to be\n \
    \  added \"onto the end\" of existing data structures in an\n   unambiguous way.\
    \  Implementations of DASS are encouraged to\n   ignore any such additional fields\
    \ in order to enhance backwards\n   compatibility with future versions of the\
    \ architecture.\n   Unfortunately, commonly available ASN.1 compilers lack this\n\
    \   capability, so this behavior cannot reasonably be required and\n   may limit\
    \ options for future extensions.\n"
- title: 4.4 Cryptographic Encoding
  contents:
  - "4.4 Cryptographic Encoding\n   Some of the substructures listed in the previous\
    \ sections are\n   specified as ENCRYPTED OCTET STRINGs containing encrypted\n\
    \   information.  DASS uses the DES, RSA, and MD2 cryptosystems  Each\n   of those\
    \ cryptosystems specifies a function from octet string\n   into another in the\
    \ presence of a key (except MD2, which is\n   keyless).  This section describes\
    \ how to form the octet strings\n   on which the DES and RSA operations are performed.\n"
- title: 4.4.1 Algorithm Independence vs. Key Parity
  contents:
  - "4.4.1 Algorithm Independence vs. Key Parity\n   All of the defined encodings\
    \ for DASS for secret key encryption\n   are based on DES.  It is intended, however,\
    \ that other\n   cryptosystems could be substituted without any other changes\
    \ for\n   formats or algorithms.  The required \"form factor\" for such a\n  \
    \ cryptosystem is that it have a 64 bit key and operate on 64 bit\n   blocks (this\
    \ appears to be a common form factor for a\n   cryptosystem).  For this reason,\
    \ DES keys are in all places\n   treated as though they were 64 bits long rather\
    \ than 56.  Only in\n   the operation of the algorithm itself are eight bits of\
    \ the key\n   dropped and key parity bits substituted. Choosing a key always\n\
    \   involves picking a 64 bit random number.\n"
- title: 4.4.2 Password Hashing
  contents:
  - "4.4.2 Password Hashing\n   Encrypted credentials are encrypted using DES as described\
    \ in the\n   next section.  The key for that encryption is derived from the\n\
    \   user's password and name by the following algorithm:\n    a) Put the rightmost\
    \ RDN of the user's name in canonical form\n       according to BER and the X.509\
    \ encoding rules.  For any string\n       types that are case insensitive, map\
    \ to upper case, and where\n       matching is independent of number of spaces\
    \ collapse all\n       multiple spaces to a single space and delete leading and\n\
    \       trailing spaces.\n       Note:  the RDN is used to add \"salt\" to the\
    \ hash calculation\n       so that someone can't precompute the hash of all the\
    \ words in\n       a dictionary and then apply them against all names.  Deriving\n\
    \       the salt from the last RDN of the name is a compromise.  If it\n     \
    \  were derived from the whole name, all encrypted keys would be\n       obsoleted\
    \ when a branch of the namespace was renamed.  If it\n       were independent\
    \ of name, interaction with a login agent would\n       take two extra messages\
    \ to retrieve the salt.  With this\n       scheme, encrypted keys are obsoleted\
    \ by a change in the last\n       RDN and if a final RDN is common to a large\
    \ number of users,\n       dictionary attacks against them are easier; but the\
    \ common\n       case works as desired.\n    b) Compute TEMP as the MD2 message\
    \ digest of the concatenation of\n       the password and the RDN computed above.\n\
    \    c) Repeat the following 40 times:  Use the first 64 bits of TEMP\n      \
    \ as a DES key to encrypt the second 64 bits;  XOR the result\n       with the\
    \ first 64 bits of TEMP; and compute a new TEMP as MD2\n       of the 128 bit\
    \ result.\n    d) Use the final 64 bits of the result (called hash1) as the key\n\
    \       to decrypt the encrypted credentials.  Use the first 64 bits\n       (called\
    \ hash2) as the proof of knowledge of the password for\n       presentation to\
    \ a login agent (if any).\n"
- title: 4.4.3 Digital DEA encryption
  contents:
  - "4.4.3 Digital DEA encryption\n   DES encryption is used in the following places:\n\
    \    - In the encryption of the encrypted credentials structure\n    - To encrypt\
    \ the delegator in authentication tokens\n    - To encrypt the time in the mutual\
    \ authenticator\n   In the first two cases, a varying length block of information\n\
    \   coded in ASN.1 is encrypted.  This is done by dividing the block\n   of information\
    \ into 8 octet blocks, padding the last block with\n   zero bytes if necessary,\
    \ and encrypting the result using the CBC\n   mode of DES.  A zero IV is used.\n\
    \   In the third case, a fixed length (8 byte) quantity (a timestamp)\n   is encrypted.\
    \  The timestamp is mapped to a byte string using\n   \"big endian\" order and\
    \ the block is encrypted using the ECB mode\n   of DES.\n"
- title: 4.4.4  Digital MAC Signing
  contents:
  - "4.4.4  Digital MAC Signing\n   DES signing is used in the Authenticator.  Here,\
    \ the signature is\n   computed over an ASN.1 structure.  The signature is the\
    \ CBC residue\n   of the structure padded to a multiple of eight bytes with zeros.\
    \  The\n   CBC is computed with an IV of zero.\n"
- title: 4.4.5 RSA Encryption
  contents:
  - "4.4.5 RSA Encryption\n   RSA encryption is used in the Encrypted Shared Key.\
    \  RSA encryption\n   is best thought of as operating on blocks which are integers\
    \ rather\n   than octet strings and the results are also integers.  Because an\
    \ RSA\n   encryption permutes the integers between zero and (modulus-1), it is\n\
    \   generally thought of as acting on a block of size (keysizeinbits-1)\n   and\
    \ producing a block of size (keysizeinbits) where keysizeinbits is\n   the smallest\
    \ number of bits in which the modulus can be represented.\n   DASS only supports\
    \ key sizes which are a multiple of eight bits (This\n   restriction is only required\
    \ to support interoperation with certain\n   existing implementations.  If the\
    \ key size is not a multiple of eight\n   bits, the high order byte may not be\
    \ able to hold values as large as\n   the mandated '64'.  This is not a problem\
    \ so long as the two high\n   order bytes together are non-zero, but certain early\
    \ implementations\n   check for the value '64' and will not interoperate with\n\
    \   implementations that use some other value.).\n   The encrypted shared key\
    \ structure is laid out as follows:\n    - The DES key to be shared is placed\
    \ in the last eight bytes\n    - The POSIX format creation time encoded in four\
    \ bytes using big\n      endian byte order is placed in the next four (from the\
    \ end)\n      bytes\n    - The POSIX format expiration time encoded in four bytes\
    \ using\n      big endian byte order is placed in the next four (from the\n  \
    \    end) bytes\n    - Four zero bytes are placed in the next four (from the end)\n\
    \      bytes\n    - The first byte contains the constant '64' (decimal)\n    -\
    \ All remaining bytes are filled with random bytes (the security\n      of the\
    \ system does not depend on the cryptographic randomness\n      of these bytes,\
    \ but they should not be a frequently repeating\n      or predictable value. \
    \ Repeating the DES key from the last\n      bytes would be good).\n   The RSA\
    \ algorithm is applied to the integer formed by treating the\n   bytes above as\
    \ an integer in big endian order and the resulting\n   integer is converted to\
    \ a BIT STRING by laying out the integer in\n   'big endian' order.\n   On decryption,\
    \ the process is reversed; the decryptor should verify\n   the four explicitly\
    \ zero bytes but should not verify the contents of\n   the high order byte or\
    \ the random bytes.\n"
- title: 4.4.6 oiwMD2withRSA Signatures
  contents:
  - "4.4.6 oiwMD2withRSA Signatures\n   RSA-MD2 signatures are used on certificates,\
    \ login tickets, shared\n   key tickets, and node tickets.  In all cases, a signature\
    \ is computed\n   on an ASN.1 encoded string using an RSA private key.  This is\
    \ done as\n   follows:\n    - The MD2 algorithm is applied to the ASN.1 encoded\
    \ string to\n      produce a 128 bit message digest\n    - The message digest\
    \ is placed in the low order bytes of the RSA\n      block (big endian)\n    -\
    \ The next two lowest order bytes are the ASN.1 'T' and 'L' for\n      an OCTET\
    \ STRING.\n    - The remainder of the RSA block is filled with zeros\n    - The\
    \ RSA operation is performed, and the resulting integer is\n      converted to\
    \ an octet string by laying out the bytes in big\n      endian order.\n   On verification,\
    \ a value like the above  or one where the message\n   digest is present but the\
    \ 'T' and 'L' are missing (zero) should be\n   accepted for backwards compatibility\
    \ with an earlier definition of\n   this crypto algorithm.\n"
- title: 4.4.7 decMD2withRSA Signatures
  contents:
  - "4.4.7 decMD2withRSA Signatures\n   This algorithm is the same as the oiwMD2withRSA\
    \ algorithm as defined\n   above.  We allocated an algorithm object identifier\
    \ from the Digital\n   space in case the definition of that OID should change.\
    \  It will not\n   be used unless the meaning of oiwMD2withRSA becomes unstable.\n"
- title: Annex A
  contents:
  - 'Annex A

    '
- title: Typical Usage
  contents:
  - "Typical Usage\n   This annex describes one way a system could use DASS services\
    \ (as\n   described in section 3) to provide security services.  While this\n\
    \   example provided motivation for some of the properties of DASS, it is\n  \
    \ not intended to represent the only way that DASS may be used.  This\n   goes\
    \ through the steps that would be needed to install DASS \"from\n   scratch\"\
    .\n"
- title: A.1 Creating a CA
  contents:
  - "A.1 Creating a CA\n   A CA is created by initializing its state. Each CA can\
    \ sign\n   certificates that will be placed in some directory in the name\n  \
    \ service. Before these certificates will be believed in a wider\n   context than\
    \ the sub-tree of the name space which is headed by that\n   directory, the CA\
    \ must be certified by a CA for the parent directory.\n   The procedure below\
    \ accomplishes this. For most secure operation, the\n   CA should run on an off-line\
    \ system and communicate with the rest of\n   the network by interchanging files\
    \ using a simple specialized\n   mechanism such as an RS232 line or a floppy disk.\
    \ It is assumed that\n   access to the CA is controlled and that the CA will accept\n\
    \   instructions from an operator.\n    - Call Install_CA to create the CA State.\n\
    \      This state is saved within the CA system and is never\n      disclosed.\n\
    \    - If this is the first CA in the namespace and the CA is\n      intended\
    \ to certify only members of a single directory, we are\n      done.  Otherwise,\
    \ the new CA must be linked into the CA\n      hierarchy by cross-certifying the\
    \ parent and children of this\n      CA.  There is no requirement that CA hierarchies\
    \ be created\n      from the root down, but to simplify exposition, only this\
    \ case\n      will be described.  The newly created CA must learn its name,\n\
    \      its UID, the UID of its parent directory, and the public key\n      of\
    \ the parent directory CA by some out of band reliable means.\n      Most likely,\
    \ this would be done by looking up the information\n      in the naming service\
    \ and asking the CA operator to verify it.\n      The CA then forms this information\
    \ into a   parent certificate\n      and signs it using the Create_certificate\
    \ function.  It\n      communicates the certificate to the network and posts it\
    \ in\n      the naming service.\n    - This name, UID, and public key of the new\
    \ CA are taken to the\n      CA of the parent directory, which verifies it (again\
    \ by some\n      unspecified out-of-band mechanism) and calls\n      Create_Certificate\
    \ to create a child  certificate using its own\n      Name and UID in the issuer\
    \ fields. This certificate is also\n      placed in the naming service.\n   A\
    \ CA can sign certificates for more than one directory. In this case\n   it is\
    \ possible that a single CA will take the role of both CAs in the\n   example\
    \ above. The above procedure can be simplified in this case, as\n   no interchange\
    \ of information is required.\n"
- title: A.2 Creating a User Principal
  contents:
  - "A.2 Creating a User Principal\n   A system manager may create a new user principal\
    \ by invoking the\n   Create_principal function supplying the principal's name,\
    \ UID, and\n   the public key/UID of the parent CA.  The public key and UID must\
    \ be\n   obtained in a reliable out of band manner.  This is probably by\n   having\
    \ knowledge of that information \"wired into\" the utility which\n   creates new\
    \ principals.  At account creation time, the system manager\n   must supply what\
    \ will become the user's password.  This might be done\n   by having the user\
    \ present and directly enter a password or by having\n   the password selected\
    \ by some random generator.\n   The trusted authority certificate and corresponding\
    \ user public key\n   generated by the Create_principal function are sent to the\
    \ CA which\n   verifies its contents (again by an out-of-band mechanism) and signs\
    \ a\n   corresponding certificate.  The encrypted credentials, CA signed\n   certificate,\
    \ and trusted authority certificates are all placed in the\n   naming service.\
    \  The process by which the password is made known to\n   the user must be protected\
    \ by some out-of-band mechanism.\n   In some cases the principal may wish to generate\
    \ its own key, and not\n   use the Encrypted_Credentials. (e.g., if the Principal\
    \ is represented\n   by a Smart Card). This may be done using a procedure similar\
    \ to the\n   one for creating a new CA.\n"
- title: A.3 Creating a Server Principal
  contents:
  - "A.3 Creating a Server Principal\n   A server also has a public/private key pair.\
    \ Conceptually, the same\n   procedure used to create a user principal can be\
    \ used to create a\n   server.  In practice, the most important difference  is\
    \ likely to be\n   how the password is protected when installing it on a server\
    \ compared\n   to giving it to a user.\n   A server may wish to retrieve (and\
    \ store) its Encrypted Credentials\n   directly and never have them placed in\
    \ the naming service. In this\n   case some other mechanism can be used (e.g.,\
    \ passing the floppy disk\n   containing the encrypted credentials to the server).\
    \ This would\n   require a variant of the Initialize_Server routine which does\
    \ not\n   fetch the Encrypted Credentials from the naming service.\n"
- title: A.4 Booting a Server Principal
  contents:
  - "A.4 Booting a Server Principal\n   When the server first boots it needs its name\
    \ (unreliably) and\n   password (reliably). It then calls Initialize_Server to\
    \ obtain its\n   credentials and trusted authority certificates (which it will\
    \ later\n   need in order to authenticate users).  These credentials never time\n\
    \   out, and are expected to be saved for a long time.  In particular the\n  \
    \ associated Incoming Timestamp List must be preserved while there are\n   any\
    \ timestamps on it. It is desirable to preserve the Cached Incoming\n   Contexts\
    \ as long as there are any contexts likely to be reused.\n   If a server wants\
    \ to initiate associations on its own behalf then it\n   must call Generate_Server_Ticket.\
    \  It must repeat this at intervals\n   if the expiration period expires.\n  \
    \ A node that wishes to do node authentication (or which acts as a\n   server\
    \ under its own name) must be created as a server.\n"
- title: A.5 A user logs on to the network
  contents:
  - "A.5 A user logs on to the network\n   The system that the user logs onto finds\
    \ the user's name and\n   password. It then calls Network_Login to obtain credentials\
    \ for the\n   user. These credentials are saved until the user wants to make a\n\
    \   network connection. The credentials have a time limit, so the user\n   will\
    \ have to obtain new credentials in order to make connections\n   after the time\
    \ limit. The credentials are then checked by calling\n   Verify_Principal_Name,\
    \ in order to check that the key specified in\n   the encrypted credentials has\
    \ been certified by the CA.\n   If the system does source node authentication\
    \ it will call\n   Combine_credentials, once the local username has been found.\
    \  (This\n   can either be found by looking the principal's global name up in\
    \ a\n   file, or the user can be asked to give the local name directly.\n   Alternatively\
    \ the user can be asked to give his local username, which\n   the system looks\
    \ up to find the global name).\n"
- title: A.6 An Rlogin (TCP/IP) connection is made
  contents:
  - "A.6 An Rlogin (TCP/IP) connection is made\n   When the user calls a modified\
    \ version of the rlogin utility, it\n   calls Create_token in order to create\
    \ the Initial Authentication\n   Token, which is passed to the other system as\
    \ part of the rlogin\n   protocol.  The rlogind utility at the destination node\
    \ calls\n   Accept_token to verify it.  It then looks up in a local rhosts-like\n\
    \   database to determine whether this global user is allowed access to\n   the\
    \ requested destination account.  It calls Verify_principal_name\n   and/or Verify_node_name\
    \ to confirm the identity of the requester.  If\n   access is allowed, the connection\
    \ is accepted and the Mutual\n   Authentication Token is returned in the response\
    \ message.\n   The source receives the returned Mutual Authentication Token and\
    \ uses\n   it to confirm it communicating with the correct destination node.\n\
    \   Rlogind then calls Combine_credentials to combine its node/account\n   information\
    \ with the global user identification in the received\n   credentials in case\
    \ the user accesses any network resources from the\n   destination system.\n"
- title: A.7 A Transport-Independent Connection
  contents:
  - "A.7 A Transport-Independent Connection\n   As an alternative to the description\
    \ in A.6, an application wishing\n   to be portable between different underlying\
    \ transports may call\n   create_token to create an authentication token which\
    \ it then sends to\n   its peer.  The peer can then call accept_token and\n  \
    \ verify_principal_name and learn the identity of the requester.\n"
- title: Annex B
  contents:
  - 'Annex B

    '
- title: Support of the GSSAPI
  contents:
  - "Support of the GSSAPI\n   In order to support applications which need to be portable\
    \ across a\n   variety of underlying security mechanisms, a \"Generic Security\n\
    \   Service API\" (or GSSAPI) was designed which gives access to a common\n  \
    \ core of security services expected to be provided by several\n   mechanisms.\
    \  The GSSAPI was designed with DASS, Kerberos V4, and\n   Kerberos V5 in mind,\
    \ and could be written as a front end to any or\n   all of those systems.  It\
    \ is hoped that it could serve as an\n   interface to other security systems as\
    \ well.\n   Application portability requires that the security services supported\n\
    \   be comparable.  Applications using the GSSAPI will not be able to\n   access\
    \ all of the features of the underlying security mechanisms.\n   For example,\
    \ the GSSAPI does not allow access to the \"node\n   authentication\" features\
    \ of DASS.  To the extent the underlying\n   security mechanisms do not support\
    \ all the features of GSSAPI,\n   applications using those features will not be\
    \ portable to those\n   security mechanisms.  For example, Kerberos V4 does not\
    \ support\n   delegation, so applications using that feature of the GSSAPI will\
    \ not\n   be portable to Kerberos V4.\n   This annex explains how the GSSAPI can\
    \ be implemented using the\n   primitive services provided by DASS.\n"
- title: B.1 Summary of GSSAPI
  contents:
  - "B.1 Summary of GSSAPI\n   The latest draft of the GSSAPI specification is available\
    \ as an\n   internet draft.  The following is a brief summary of that evolving\n\
    \   document and should not be taken as definitive.  Included here are\n   only\
    \ those aspects of GSSAPI whose implementation would be DASS\n   specific.\n \
    \  The GSSAPI provides four classes of functions: Credential Management,\n   Context-Level\
    \ Calls, Per-message calls, and Support Calls; two types\n   of objects: Credentials\
    \ and Contexts; and two kinds of data\n   structures to be transmitted as opaque\
    \ byte strings: Tokens and\n   Messages. Credentials hold keys and support information\
    \ used in\n   creating tokens.  Contexts hold keys and support information used\
    \ in\n   signing and encrypting messages.\n   The Credential Management functions\
    \ of GSSAPI are \"incomplete\" in the\n   sense that one could not build a useful\
    \ security implementation using\n   only GSSAPI.  Functions which create credentials\
    \ based on passwords\n   or smart cards are needed but not provided by GSSAPI.\
    \  It is\n   envisioned that such functions would be invoked by security mechanism\n\
    \   specific functions at user login or via some separate utility rather\n   than\
    \ from within applications intended to be portable.  The\n   Credential Management\
    \ functions available to portable applications\n   are:\n    - GSS_Acquire_cred:\
    \  get a handle to an existing credential\n      structure based on a name or\
    \ process default.\n    - GSS_Release_cred:  release credentials after use.\n\
    \   The Context-Level Calls use credentials to establish contexts.\n   Contexts\
    \ are like connections: they are created in pairs and are\n   generally used at\
    \ the two ends of a connection to process messages\n   associated with that connection.\
    \  The Context-Level Calls of interest\n   are:\n    - GSS_Init_sec_context: \
    \ given credentials and the name of a\n      destination, create a new context\
    \ and a token which will\n      permit the destination to create a corresponding\
    \ context.\n    - GSS_Accept_sec_context:  given credentials and an incoming\n\
    \      token, create a context corresponding to the one at the\n      initiating\
    \ end and provide information identifying the\n      initiator.\n    - GSS_Delete_sec_context:\
    \  delete a context after use.\n   The Per-Message Calls use contexts to sign,\
    \ verify, encrypt, and\n   decrypt messages between the holders of matching contexts.\
    \  The Per-\n   Message Calls are:\n    - GSS_Sign:  Given a context and a message,\
    \ produces a string of\n      bytes which constitute a signature on a provided\
    \ message.\n    - GSS_Verify:  Given a context, a message, and the bytes\n   \
    \   returned by GSS_Sign, verifies the message to be authentic\n      (unaltered\
    \ since it was signed by the corresponding context).\n    - GSS_Seal:  Given a\
    \ context and a message, produces a string of\n      bytes which include the message\
    \ and a signature; the message\n      may optionally be encrypted.\n    - GSS_Unseal:\
    \  Given a context and the string of bytes from\n      GSS_Seal, returns the original\
    \ message and a status indicating\n      its authenticity.\n   The Support Calls\
    \ provide utilities like translating names and status\n   codes into printable\
    \ strings.\n"
- title: B.2 Implementation of GSSAPI over DASS
  contents:
  - 'B.2 Implementation of GSSAPI over DASS

    '
- title: B.2.1 Data Structures
  contents:
  - "B.2.1 Data Structures\n   The objects and data structures of the GSSAPI do not\
    \ map neatly into\n   the objects and data structures of the DASS architecture.\n\
    \   This section describes how those data structures can be implemented\n   using\
    \ the DASS data structures and primitives\n   Credential handles correspond to\
    \ the credentials structures in DASS,\n   where the portable API assumes that\
    \ the credential structures\n   themselves are kept from applications and handles\
    \ are passed to and\n   from the various subroutines.\n   Context initialization\
    \ tokens correspond to the tokens of DASS.  The\n   GSSAPI prescribes a particular\
    \ ASN.1 encoded form for tokens which\n   includes a mechanism specific bit string\
    \ within it.  An\n   implementation of GSSAPI should enclose the DASS token within\
    \ the\n   GSSAPI \"wrapper\".\n   Context handles have no corresponding structure\
    \ in DASS. The\n   Create_token and Accept_token calls of DASS return a shared\
    \ key and\n   instance identifier. An implementation of the GSSAPI must take those\n\
    \   values along with some other status information and package it as a\n   \"\
    context\" opaque structure.  These data structures must be allocated\n   and freed\
    \ with the appropriate calls.\n   Per-message tokens and sealed messages have\
    \ no corresponding data\n   structure within DASS.  To fully support the GSSAPI\
    \ functionality,\n   DASS must be extended to include this functionality.  These\
    \ data\n   structures are created by cryptographic routines given the keys and\n\
    \   status information in context structures and the messages passed to\n   them.\
    \  While not properly part of the DASS architecture, the formats\n   of these\
    \ data structures are included in section C.3.\n"
- title: B.2.2 Procedures
  contents:
  - "B.2.2 Procedures\n   This section explains how the functions of the GSSAPI can\
    \ be provided\n   in terms of the Services Provided by DASS.  Not all of the DASS\n\
    \   features are accessible through the GSSAPI.\n"
- title: B.2.2.1 GSS_Acquire_cred
  contents:
  - "B.2.2.1 GSS_Acquire_cred\n   The GSSAPI does not provide a mechanism for logging\
    \ in users or\n   establishing server credentials. It assumes that some system\
    \ specific\n   mechanism created those credentials and that applications need\
    \ some\n   mechanism for getting at them. A model implementation might save all\n\
    \   credentials in a node-global pool indexed by some sort of credential\n   name.\
    \ The credentials in the pool would be access controlled by some\n   local policy\
    \ which is not concern of portable applications. Those\n   applications would\
    \ simply call GSS_Acquire_cred and if they passed\n   the access control check,\
    \ they would get a handle to the credentials\n   which could be used in subsequent\
    \ calls.\n"
- title: B.2.2.2 GSS_Release_cred
  contents:
  - "B.2.2.2 GSS_Release_cred\n   This call corresponds to the \"delete_credentials\"\
    \ call of DASS.\n"
- title: B.2.2.3 GSS_Init_sec_context
  contents:
  - "B.2.2.3 GSS_Init_sec_context\n   In the course of a normal mutual authentication,\
    \ this routine will be\n   called twice. The procedure can determine whether this\
    \ is the first\n   or second call by seeing whether the \"input_context_handle\"\
    \ is zero\n   (it will be on the first call).  On the first call, it will use\
    \ the\n   DASS Create_token service to create a token and it will also allocate\n\
    \   and populate a \"context\" structure. That structure will hold the key,\n\
    \   instance identifier, and mutual authentication token returned by\n   Create_token\
    \ and will in addition hold the flags which were passed\n   into the Init_sec_context\
    \ call. The token returned by\n   Init_sec_context will be the DASS token included\
    \ in the GSSAPI token\n   \"wrapper\".  The DASS token will include the optional\
    \ principal name.\n   If mutual authentication is not requested in the GSSAPI\
    \ call, the\n   mutual authentication token returned by DASS will be ignored and\
    \ the\n   initial call will return a COMPLETE status. If mutual authentication\n\
    \   is requested, the mutual authentication token will be stored in the\n   context\
    \ information and a CONTINUE_NEEDED status returned.\n   On the second call to\
    \ GSS_Init_sec_context (with input_context_handle\n   non-zero), the returned\
    \ token will be compared to the one in the\n   context information using the Compare_mutual_token\
    \ procedure and a\n   COMPLETE status will be returned if they match.\n"
- title: B.2.2.4 GSS_Accept_sec_context
  contents:
  - "B.2.2.4 GSS_Accept_sec_context\n   This routine in GSSAPI accepts an incoming\
    \ token and creates a\n   context.  It combines the effects of a series of DASS\
    \ functions.  It\n   could be implemented as follows:\n    - Remove the GSSAPI\
    \ \"wrapper\" from the incoming token and pass\n      the rest and the credentials\
    \ to \"Accept_token\".  Accept_token\n      produces a mutual authentication token\
    \ and a new credentials\n      structure.  If delegation was requested, the new\
    \ credentials\n      structure will be an output of GSS_Accept_sec_context.  In\
    \ any\n      case, it will be used in the subsequent steps of this\n      procedure.\n\
    \    - Use the DASS Get_principal_name function to extract the\n      principal\
    \ name from the credentials produced by Accept_token.\n      This name is one\
    \ of the outputs of \"GSS_Accept_sec_context.\n    - Apply the DASS Verify_principal_name\
    \ to the new credentials\n      and the retrieved name to authenticate the token\
    \ as having\n      come from the named principal.\n    - Create and populate a\
    \ context structure with the key and\n      timestamp returned by Accept_token\
    \ and a status of COMPLETE.\n      Return a handle to that context.\n    - If\
    \ delegation was requested, return the new credentials from\n      GSS_Accept_sec_context.\
    \  Otherwise, call Delete_credentials.\n    - If mutual authentication was requested,\
    \ wrap the mutual\n      authentication token from Accept_token in a GSSAPI \"\
    wrapper\"\n      and return it.  Otherwise return a null string.\n"
- title: B.2.2.5 GSS_Delete_sec_context
  contents:
  - "B.2.2.5 GSS_Delete_sec_context\n   This routine simply deletes the context state.\
    \  No calls to DASS are\n   required.\n"
- title: B.2.2.6 GSS_Sign
  contents:
  - "B.2.2.6 GSS_Sign\n   This routine takes as input a context handle and a message.\
    \ It\n   creates a per_msg_token by computing a digital signature on the\n   message\
    \ using the key and timestamp in the context block.  No DASS\n   services are\
    \ required. If additional cryptographic services were\n   requested (replay detection\
    \ or sequencing), a timestamp or sequence\n   number must be prepended to the\
    \ message and sent with the signature.\n   The syntax for this message is listed\
    \ in section C.3.\n"
- title: B.2.2.7 GSS_Verify
  contents:
  - "B.2.2.7 GSS_Verify\n   This routine repeats the calculation of the sign routine\
    \ and verifies\n   the signature provided. If replay detection or sequencing services\n\
    \   are provided, the context must maintain as part of its state\n   information\
    \ containing the sequence numbers or timestamps of messages\n   already received\
    \ and this one must be checked for acceptability.\n"
- title: B.2.2.8 GSS_Seal
  contents:
  - "B.2.2.8 GSS_Seal\n   This routine performs the same functions as Sign but also\
    \ optionally\n   encrypts the message for privacy using the shared key and\n \
    \  encapsulates the whole thing in a GSSAPI specified ASN.1 wrapper.\n"
- title: B.2.2.9 GSS_Unseal
  contents:
  - "B.2.2.9 GSS_Unseal\n   This routine performs the same functions as GSS_Verify\
    \ but also\n   parses the data structure including the signature and message and\n\
    \   decrypts the message if necessary.\n"
- title: B.3 Syntax
  contents:
  - "B.3 Syntax\n   The GSSAPI specification recommends the following ASN.1 encoding\
    \ for\n   the tokens and messages generated through the GSSAPI:\n        --optional\
    \ top-level token definitions to frame\n        -- different mechanisms\n    \
    \    GSSAPI DEFINITIONS ::=\n        BEGIN\n        MechType ::= OBJECT IDENTIFIER\n\
    \        -- data structure definitions\n        ContextToken ::=\n        -- option\
    \ indication (delegation, etc.) indicated\n        -- within mechanism-specific\
    \ token\n        [APPLICATION 0] IMPLICIT SEQUENCE {\n             thisMech MechType,\n\
    \             responseExpected BOOLEAN,\n             innerContextToken ANY DEFINED\
    \ BY MechType\n               -- contents mechanism-specific\n             }\n\
    \        PerMsgToken ::=\n        -- as emitted by GSS_Sign and processed by\n\
    \        -- GSS_Verify\n        [APPLICATION 1] IMPLICIT SEQUENCE {\n        \
    \     thisMech MechType,\n             innerMsgToken ANY DEFINED BY MechType\n\
    \               -- contents mechanism-specific\n             }\n        SealedMessage\
    \ ::=\n        -- as emitted by GSS_Seal and processed by\n        -- GSS_Unseal\n\
    \        [APPLICATION 2] IMPLICIT SEQUENCE {\n             sealingToken PERMSGTOKEN,\n\
    \             confFlag BOOLEAN,\n             userData OCTET STRING\n        \
    \       -- encrypted if confFlag TRUE\n             }\n   The object identifier\
    \ for the DASS MechType is 1.3.12.2.1011.7.5.\n   The innerContextToken of a token\
    \ is a DASS token or mutual\n   authentication token.\n   The innerMsgToken is\
    \ a null string in the case where the message is\n   encrypted and the token is\
    \ included as part of a SealedMessage.\n   Otherwise, it is an eight octet sequence\
    \ computed as the CBC residue\n   computed using a key and string of bytes defined\
    \ as follows:\n    - Pad the message provided by the application with 1-8 bytes\
    \ of\n      pad to produce a string whose length is a multiple of 8\n      octets.\
    \  Each pad byte has a value equal to the number of pad\n      bytes.\n    - Compute\
    \ the key by taking the timestamp of the association\n      (two four byte integers\
    \ laid out in big endian order with the\n      most significant integer first),\
    \ complementing the high order\n      bit (to avoid aliasing with mutual authenticators),\
    \ and\n      encrypting the block in ECB mode with the shared key of the\n   \
    \   association.\n   The userData field of a SealedMessage is exactly the application\n\
    \   provided byte string if confFlag=FALSE.  Otherwise, it is the\n   application\
    \ supplied message encrypted as follows:\n    - Pad the message provided by the\
    \ application with 1-8 bytes of\n      pad to produce a string whose length =\
    \ 4 (mod 8).  Each pad\n      byte has a value equal to the number of pad bytes.\n\
    \    - Append a four byte CRC32 computed over the message + pad.\n    - Compute\
    \ a key by taking the timestamp of the association (two\n      four byte integers\
    \ laid out in big endian order with the most\n      significant integer first),\
    \ complementing the high order bit\n      (to avoid aliasing with mutual authenticators),\
    \ and encrypting\n      the block in ECB mode with the shared key of the association.\n\
    \    - Encrypt the message + pad + CRC32 using CBC and the key\n      computed\
    \ in the previous step.\n   A note of the logic behind the above:\n    - Because\
    \ the shared key of an association may be reused by many\n      associations between\
    \ the same pair of principals, it is\n      necessary to bind the association\
    \ timestamp into the messages\n      somehow to prevent messages from a previous\
    \ association being\n      replayed into a new sequence.  The technique above\
    \ of\n      generating an association key accomplishes this and has a side\n \
    \     benefit.  An implementation may with to keep the long term\n      keys out\
    \ of the hands of applications for purposes of\n      confinement but may wish\
    \ to put the encryption associated with\n      an association in process context\
    \ for reasons of performance.\n      Defining an association key makes that possible.\n\
    \    - The reason that the association specific key is not specified\n      as\
    \ the output of Create_token and Accept_token is that the DCE\n      RPC security\
    \ implementation requires that a series of\n      associations between two principals\
    \ always have the same key\n      and we did not want to have to support a different\
    \ interface\n      in that application.\n    - The CRC32 after pad constitutes\
    \ a cheap integrity check when\n      data is encrypted.\n    - The fact that\
    \ padding is done differently for encrypted and\n      signed messages means that\
    \ there are no threats related to\n      sending the same message encrypted and\
    \ unencrypted and using\n      the last block of the encrypted message as a signature\
    \ on the\n      unencrypted one.\n"
- title: Annex C
  contents:
  - 'Annex C

    '
- title: Imported ASN.1 definitions
  contents:
  - "Imported ASN.1 definitions\n   This annex contains extracts from the ASN.1 description\
    \ of X.509 and\n   X.500 definitions referenced by the DASS ASN.1 definitions.\n\
    \   CCITT DEFINITIONS ::=\n   BEGIN joint-iso-ccitt          OBJECT IDENTIFIER\
    \ ::= {2} ds\n   OBJECT IDENTIFIER ::= {joint-iso-ccitt 5} algorithm\n   OBJECT\
    \ IDENTIFIER ::= {ds 8}\n   iso                      OBJECT IDENTIFIER ::= {1}\
    \ identified-\n   organization  OBJECT IDENTIFIER ::= {iso 3} ecma           \
    \ OBJECT\n   IDENTIFIER ::= {identified-organization 12} digital\n   OBJECT IDENTIFIER\
    \ ::= { ecma 1011 }\n   -- X.501 definitions\n   AttributeType ::= OBJECT IDENTIFIER\
    \ AttributeValue ::= ANY\n           -- useful ones are\n                   --\
    \      OCTET STRING ,\n                   --      PrintableString ,\n        \
    \           --      NumericString ,\n                   --      T61String ,\n\
    \                   --      VisibleString\n   AttributeValueAssertion ::= SEQUENCE\
    \ {AttributeType,\n                                                 AttributeValue}\n\
    \   Name ::= CHOICE {-- only one possibility for now --\n                   RDNSequence}\n\
    \   RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n   DistinguishedName\
    \ ::= RDNSequence\n   RelativeDistinguishedName ::= SET OF AttributeValueAssertion\n\
    \   -- X.509 definitions\n   Certificate ::= SIGNED SEQUENCE {\n             \
    \      version [0]             Version DEFAULT 1988 ,\n                   serialNumber\
    \            SerialNumber ,\n                   signature               AlgorithmIdentifier\
    \ ,\n                   issuer                  Name,\n                   valid\
    \                   Validity,\n                   subject                 Name,\n\
    \                   subjectPublicKey        SubjectPublicKeyInfo }\n   Version\
    \ ::=      INTEGER { 1988(0)} SerialNumber ::= INTEGER Validity\n   ::=     SEQUENCE{\n\
    \           notBefore               UTCTime,\n           notAfter            \
    \    UTCTime}\n   SubjectPublicKeyInfo  ::=  SEQUENCE {\n           algorithm\
    \               AlgorithmIdentifier ,\n           subjectPublicKey        BIT\
    \ STRING\n           }\n   AlgorithmIdentifier ::= SEQUENCE {\n           algorithm\
    \       OBJECT IDENTIFIER ,\n                       parameters ANY DEFINED BY\
    \ algorithm OPTIONAL}\n   ALGORITHM MACRO BEGIN TYPE NOTATION   ::= \"PARAMETER\"\
    \ type VALUE\n   NOTATION  ::= value (VALUE OBJECT IDENTIFIER) END -- of ALGORITHM\n\
    \   ENCRYPTED MACRO BEGIN TYPE NOTATION   ::=type(ToBeEnciphered) VALUE\n   NOTATION\
    \  ::= value(VALUE BIT STRING)\n           -- the value of the bit string is generated\
    \ by\n           -- taking the octets which form the complete\n           -- encoding\
    \ (using the ASN.1 Basic Encoding Rules)\n           -- of the value of the ToBeEnciphered\
    \ type and\n           -- applying an encipherment procedure to those octets--\
    \ END\n   SIGNED MACRO    ::= BEGIN TYPE NOTATION   ::= type (ToBeSigned) VALUE\n\
    \   NOTATION  ::= value(VALUE SEQUENCE{\n           ToBeSigned,\n           AlgorithIdentifier,\
    \ -- of the algorithm used to generate\n                               -- the\
    \ signature\n           ENCRYPTED OCTET STRING\n           -- where the octet\
    \ string is the result\n           -- of the hashing of the value of \"ToBeSigned\"\
    \ END -- of\n   SIGNED\n   SIGNATURE MACRO ::= BEGIN TYPE NOTATION   ::= type(OfSignature)\
    \ VALUE\n   NOTATION  ::= value(VALUE\n           SEQUENCE{\n                \
    \   AlgorithmIdentifier,\n                   -- of the algorithm used to compute\
    \ the signature\n                   ENCRYPTED OCTET STRING\n                 \
    \  -- where the octet string is a function (e.g., a\n                   -- compressed\
    \ or hashed version) of the value\n                   -- \"OfSignature\", which\
    \ may include the identifier\n                   -- of the algorithm used to compute\n\
    \                   -- the signature--}\n                           ) END -- of\
    \ SIGNATURE\n   -- X.509 Annex H (not part of the standard)\n   encryptionAlgorithm\
    \ OBJECT IDENTIFIER ::= {algorithm 1} rsa ALGORITHM\n           PARAMETER KeySize\n\
    \           ::= {encryptionAlgorithm 1}\n   KeySize ::= INTEGER\n   END\n"
- title: Glossary
  contents:
  - "Glossary\n   authentication\n        The process of determining the identity\n\
    \        (usually the name) of the other party in some communication\n       \
    \ exchange.\n   authentication context\n        Cached information used during\
    \ a particular instance of\n        authentication and including a shared symmetric\
    \ (DES) key as\n        well as components of the authentication token conveyed\n\
    \        during establishment of this context.\n   authentication token\n    \
    \    Information conveyed during a strong authentication exchange\n        that\
    \ can be used to authenticate its sender. An\n        authentication token can,\
    \ but is not necessarily limited to,\n        include the claimant identity and\
    \ ticket, as well as signed\n        and encrypted secret key exchange messages\
    \ conveying a\n        secret key to be used in future cryptographic operations.\
    \ An\n        authentication token names a particular protocol data\n        structure\
    \ component.\n   authorization\n        The process of determining the rights\n\
    \        associated with a particular principal.\n   certificate\n        The\
    \ public key of a particular principal, together\n        with some other information\
    \ relating to the names of the\n        principal and the certifying authority,\
    \ rendered unforgeable\n        by encipherment with the private key of the certification\n\
    \        authority that issued it.\n   certification authority\n        An authority\
    \ trusted by one or more principals to create and\n        assign certificates.\n\
    \   claimant\n        The party that initiates the authentication process.\n \
    \       In the DASS architecture, claimants possess credentials\n        which\
    \ include their identity, authenticating private key and\n        a ticket certifying\
    \ their authenticating public key.\n   credentials\n        Information \"state\"\
    \ required by principals in order\n        to for them to authenticate.   Credentials\
    \ may contain\n        information used to initiate the authentication process\n\
    \        (claimant information), information used to respond to an\n        authentication\
    \ request (verifier information), and cached\n        information useful in improving\
    \ performance.\n   cryptographic checksum\n        Information which is derived\
    \ by performing a cryptographic\n        transformation on the data unit. This\
    \ information can be\n        used by the receiver to verify the authenticity\
    \ of data\n        passed in cleartext\n   decipher\n        To reverse the effects\
    \ of encipherment and render a\n        message comprehensible by use of a cryptographic\
    \ key.\n   delegation\n        The granting of temporary credentials that allow\
    \ a\n        process to act on behalf of a principal.\n   delegation key\n   \
    \     A short term public/private key pair used by a claimant\n        to act\
    \ on behalf of a principal for a bounded period. The\n        delegation public\
    \ key appears in the ticket, whereas the\n        delegation private key is used\
    \ to sign secret key exchange\n        messages.\n   DES\n        Data Encryption\
    \ Standard: a symmetric (secret key)\n        encryption algorithm used by DASS.\
    \ An alternate encryption\n        algorithm could be substituted with little\
    \ or no disruption\n        to the architecture.\n   DES key\n        A 56-bit\
    \ secret quantity used as a parameter to the\n        DES encryption algorithm.\n\
    \   digital signature\n        A value computed from a block of data\n       \
    \ and a key which could only be computed by someone knowing\n        the key.\
    \ A digital signature computed with a secret key can\n        only be verified\
    \ by someone knowing that secret key.  A\n        digital signature computed with\
    \ a private key can be\n        verified by anyone knowing the corresponding public\
    \ key.\n   encipher\n        To render incomprehensible except to the holder of\
    \ a\n        particular key. If you encipher with a secret key, only the\n   \
    \     holder of the same secret can decipher the message. If you\n        encipher\
    \ with a public key, only the holder of the\n        corresponding private key\
    \ can decipher it.\n   initial trust certificate\n        A certificate signed\
    \ by a principal for its own use which\n        states the name and public key\
    \ of a trusted authority.\n   global user name\n        A hierarchical name for\
    \ a user which is\n        unique within the entire domain of discussion (typically\
    \ the\n        network).\n   local user name\n        A simple (non-hierarchical)\
    \ name by\n        which a user is known within a limited context such as on a\n\
    \        single computer.\n   principal\n        Abstract entity which can be\
    \ authenticated by name.\n        In DASS there are user principals and server\
    \ principals.\n   private key\n        Cryptographic key used in asymmetric (public\
    \ key)\n        cryptography to decrypt and/or sign messages. In asymmetric\n\
    \        cryptography, knowing the encryption key is independent of\n        knowing\
    \ the decryption key. The decryption (or signing)\n        private key cannot\
    \ be derived from the encrypting (or\n        verifying) public key.\n   proxy\n\
    \        A mapping from an external name to a local account\n        name for\
    \ purposes of establishing a set of local access\n        rights. Note that this\
    \ differs from the definition in ECMA\n        TR/46.\n   public key\n       \
    \ Cryptographic key used in asymmetric cryptography to\n        encrypt messages\
    \ and/or verify signatures.\n   RSA\n        The Rivest-Shamir-Adelman public\
    \ key cryptosystem\n        based on modular exponentiation where the modulus\
    \ is the\n        product of two large primes.  When the term RSA key is used,\n\
    \        it should be clear from context whether the public key, the\n       \
    \ private key, or the public/private pair is intended.\n   secret key\n      \
    \  Cryptographic key used in symmetric cryptography to\n        encrypt, sign,\
    \ decrypt and verify messages. In symmetric\n        cryptography, knowledge of\
    \ the decryption key implies\n        knowledge of the encryption key, and vice-versa.\n\
    \   sign\n        A process which takes a piece of data and a key and\n      \
    \  produces a digital signature which can only be calculated by\n        someone\
    \ with the key. The holder of a corresponding key can\n        verify the signature.\n\
    \   source\n        The initiator of an authentication exchange.\n   strong authentication\n\
    \        Authentication by means of cryptographically derived\n        authentication\
    \ tokens and credentials. The actual working\n        definition is closer to\
    \ that of \"zero knowledge\" proof:\n        authentication so as to not reveal\
    \ any information usable by\n        either the verifier, or by an eavesdropping\
    \ third party, to\n        further their potential ability to impersonate the\
    \ claimant.\n   target\n        The intended second party (other than the source)\
    \ to\n        an authentication exchange.\n   ticket\n        A data structure\
    \ certifying an authenticating\n        (public) key by virtue of being signed\
    \ by a user principal\n        using their (long term) private key. The ticket\
    \ also\n        includes the UID of the principal.\n   trusted authority\n   \
    \     The public key, name and UID of a\n        certification authority trusted\
    \ in some context to certify\n        the public keys of other principals.\n \
    \  UID\n        A 128 bit unique identifier produced according to OSF\n      \
    \  standard specifications.\n   user key\n        A \"long term\" RSA key whose\
    \ private portion\n        authenticates its holder as having the access rights\
    \ of a\n        particular person.\n   verify\n        To cryptographically process\
    \ a piece of data and a\n        digital signature to determine that the holder\
    \ of a\n        particular key signed the data.\n   verifier\n        The party\
    \ who will perform the operations necessary\n        to verify the claimed identity\
    \ of a claimant.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are discussed throughout this memo.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Charles Kaufman\n   Digital Equipment Corporation\n   ZKO3-3/U14\n\
    \   110 Spit Brook Road\n   Nashua, NH 03062\n   Phone: (603) 881-1495\n   Email:\
    \ kaufman@zk3.dec.com\n   General comments on this document should be sent to\
    \ cat-ietf@mit.edu.\n   Minor corrections should be sent to the author.\n"
