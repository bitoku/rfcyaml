- title: __initial_text__
  contents:
  - '               Basic Socket Interface Extensions for IPv6

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The de facto standard Application Program Interface (API) for TCP/IP\n\
    \   applications is the \"sockets\" interface.  Although this API was\n   developed\
    \ for Unix in the early 1980s it has also been implemented on\n   a wide variety\
    \ of non-Unix systems.  TCP/IP applications written\n   using the sockets API\
    \ have in the past enjoyed a high degree of\n   portability and we would like\
    \ the same portability with IPv6\n   applications.  But changes are required to\
    \ the sockets API to support\n   IPv6 and this memo describes these changes. \
    \ These include a new\n   socket address structure to carry IPv6 addresses, new\
    \ address\n   conversion functions, and some new socket options.  These extensions\n\
    \   are designed to provide access to the basic IPv6 features required by\n  \
    \ TCP and UDP applications, including multicasting, while introducing a\n   minimum\
    \ of change into the system and providing complete\n   compatibility for existing\
    \ IPv4 applications.  Additional extensions\n   for advanced IPv6 features (raw\
    \ sockets and access to the IPv6\n   extension headers) are defined in another\
    \ document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction................................................3\n\
    \   2.  Design Considerations.......................................4\n      \
    \ 2.1  What Needs to be Changed...............................4\n       2.2  Data\
    \ Types.............................................6\n       2.3  Headers................................................6\n\
    \       2.4  Structures.............................................6\n   3. \
    \ Socket Interface............................................6\n       3.1  IPv6\
    \ Address Family and Protocol Family................6\n       3.2  IPv6 Address\
    \ Structure.................................7\n       3.3  Socket Address Structure\
    \ for 4.3BSD-Based Systems......7\n       3.4  Socket Address Structure for 4.4BSD-Based\
    \ Systems......9\n       3.5  The Socket Functions...................................9\n\
    \       3.6  Compatibility with IPv4 Applications..................10\n      \
    \ 3.7  Compatibility with IPv4 Nodes.........................11\n       3.8  IPv6\
    \ Wildcard Address.................................11\n       3.9  IPv6 Loopback\
    \ Address.................................13\n       3.10 Portability Additions.................................14\n\
    \   4.  Interface Identification...................................16\n      \
    \ 4.1  Name-to-Index.........................................17\n       4.2  Index-to-Name.........................................17\n\
    \       4.3  Return All Interface Names and Indexes................18\n      \
    \ 4.4  Free Memory...........................................18\n   5.  Socket\
    \ Options.............................................18\n       5.1  Unicast\
    \ Hop Limit.....................................19\n       5.2  Sending and Receiving\
    \ Multicast Packets...............19\n       5.3  IPV6_V6ONLY option for AF_INET6\
    \ Sockets...............22\n   6.  Library Functions..........................................22\n\
    \       6.1  Protocol-Independent Nodename and\n            Service Name Translation..............................23\n\
    \       6.2  Socket Address Structure to Node Name\n            and Service Name......................................28\n\
    \       6.3  Address Conversion Functions..........................31\n      \
    \ 6.4  Address Testing Macros................................33\n   7.  Summary\
    \ of New Definitions.................................33\n   8.  Security Considerations....................................35\n\
    \   9.  Changes from RFC 2553......................................35\n   10.\
    \ Acknowledgments............................................36\n   11. References.................................................37\n\
    \   12. Authors' Addresses.........................................38\n   13.\
    \ Full Copyright Statement...................................39\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   While IPv4 addresses are 32 bits long, IPv6 addresses are\
    \ 128 bits\n   long.  The socket interface makes the size of an IP address quite\n\
    \   visible to an application; virtually all TCP/IP applications for\n   BSD-based\
    \ systems have knowledge of the size of an IP address.  Those\n   parts of the\
    \ API that expose the addresses must be changed to\n   accommodate the larger\
    \ IPv6 address size.  IPv6 also introduces new\n   features, some of which must\
    \ be made visible to applications via the\n   API.  This memo defines a set of\
    \ extensions to the socket interface\n   to support the larger address size and\
    \ new features of IPv6.  It\n   defines \"basic\" extensions that are of use to\
    \ a broad range of\n   applications.  A companion document, the \"advanced\" API\
    \ [4], covers\n   extensions that are of use to more specialized applications,\
    \ examples\n   of which include routing daemons, and the \"ping\" and \"traceroute\"\
    \n   utilities.\n   The development of this API was started in 1994 in the IETF\
    \ IPng\n   working group.  The API has evolved over the years, published first\n\
    \   in RFC 2133, then again in RFC 2553, and reaching its final form in\n   this\
    \ document.\n   As the API matured and stabilized, it was incorporated into the\
    \ Open\n   Group's Networking Services (XNS) specification, issue 5.2, which was\n\
    \   subsequently incorporated into a joint Open Group/IEEE/ISO standard\n   [3].\n\
    \   Effort has been made to ensure that this document and [3] contain the\n  \
    \ same information with regard to the API definitions.  However, the\n   reader\
    \ should note that this document is for informational purposes\n   only, and that\
    \ the official standard specification of the sockets API\n   is [3].\n   It is\
    \ expected that any future standardization work on this API would\n   be done\
    \ by the Open Group Base Working Group [6].\n   It should also be noted that this\
    \ document describes only those\n   portions of the API needed for IPv4 and IPv6\
    \ communications.  Other\n   potential uses of the API, for example the use of\
    \ getaddrinfo() and\n   getnameinfo() with the AF_UNIX address family, are beyond\
    \ the scope\n   of this document.\n"
- title: 2. Design Considerations
  contents:
  - "2. Design Considerations\n   There are a number of important considerations in\
    \ designing changes\n   to this well-worn API:\n   -  The API changes should provide\
    \ both source and binary\n      compatibility for programs written to the original\
    \ API.  That is,\n      existing program binaries should continue to operate when\
    \ run on a\n      system supporting the new API.  In addition, existing applications\n\
    \      that are re-compiled and run on a system supporting the new API\n     \
    \ should continue to operate.  Simply put, the API changes for IPv6\n      should\
    \ not break existing programs.  An additional mechanism for\n      implementations\
    \ to verify this is to verify the new symbols are\n      protected by Feature\
    \ Test Macros as described in [3].  (Such\n      Feature Test Macros are not defined\
    \ by this RFC.)\n   -  The changes to the API should be as small as possible in\
    \ order to\n      simplify the task of converting existing IPv4 applications to\n\
    \      IPv6.\n   -  Where possible, applications should be able to use this API\
    \ to\n      interoperate with both IPv6 and IPv4 hosts.  Applications should\n\
    \      not need to know which type of host they are communicating with.\n   -\
    \  IPv6 addresses carried in data structures should be 64-bit\n      aligned.\
    \  This is necessary in order to obtain optimum performance\n      on 64-bit machine\
    \ architectures.\n   Because of the importance of providing IPv4 compatibility\
    \ in the API,\n   these extensions are explicitly designed to operate on machines\
    \ that\n   provide complete support for both IPv4 and IPv6.  A subset of this\n\
    \   API could probably be designed for operation on systems that support\n   only\
    \ IPv6.  However, this is not addressed in this memo.\n"
- title: 2.1 What Needs to be Changed
  contents:
  - "2.1 What Needs to be Changed\n   The socket interface API consists of a few distinct\
    \ components:\n   -  Core socket functions.\n   -  Address data structures.\n\
    \   -  Name-to-address translation functions.\n   -  Address conversion functions.\n\
    \   The core socket functions -- those functions that deal with such\n   things\
    \ as setting up and tearing down TCP connections, and sending\n   and receiving\
    \ UDP packets -- were designed to be transport\n   independent.  Where protocol\
    \ addresses are passed as function\n   arguments, they are carried via opaque\
    \ pointers.  A protocol-specific\n   address data structure is defined for each\
    \ protocol that the socket\n   functions support.  Applications must cast pointers\
    \ to these\n   protocol-specific address structures into pointers to the generic\n\
    \   \"sockaddr\" address structure when using the socket functions.  These\n \
    \  functions need not change for IPv6, but a new IPv6-specific address\n   data\
    \ structure is needed.\n   The \"sockaddr_in\" structure is the protocol-specific\
    \ data structure\n   for IPv4.  This data structure actually includes 8-octets\
    \ of unused\n   space, and it is tempting to try to use this space to adapt the\n\
    \   sockaddr_in structure to IPv6.  Unfortunately, the sockaddr_in\n   structure\
    \ is not large enough to hold the 16-octet IPv6 address as\n   well as the other\
    \ information (address family and port number) that\n   is needed.  So a new address\
    \ data structure must be defined for IPv6.\n   IPv6 addresses are scoped [2] so\
    \ they could be link-local, site,\n   organization, global, or other scopes at\
    \ this time undefined.  To\n   support applications that want to be able to identify\
    \ a set of\n   interfaces for a specific scope, the IPv6 sockaddr_in structure\
    \ must\n   support a field that can be used by an implementation to identify a\n\
    \   set of interfaces identifying the scope for an IPv6 address.\n   The IPv4\
    \ name-to-address translation functions in the socket\n   interface are gethostbyname()\
    \ and gethostbyaddr().  These are left as\n   is, and new functions are defined\
    \ which support both IPv4 and IPv6.\n   The IPv4 address conversion functions\
    \ -- inet_ntoa() and inet_addr()\n   -- convert IPv4 addresses between binary\
    \ and printable form.  These\n   functions are quite specific to 32-bit IPv4 addresses.\
    \  We have\n   designed two analogous functions that convert both IPv4 and IPv6\n\
    \   addresses, and carry an address type parameter so that they can be\n   extended\
    \ to other protocol families as well.\n   Finally, a few miscellaneous features\
    \ are needed to support IPv6.  A\n   new interface is needed to support the IPv6\
    \ hop limit header field.\n   New socket options are needed to control the sending\
    \ and receiving of\n   IPv6 multicast packets.\n   The socket interface will be\
    \ enhanced in the future to provide access\n   to other IPv6 features.  Some of\
    \ these extensions are described in\n   [4].\n"
- title: 2.2 Data Types
  contents:
  - "2.2 Data Types\n   The data types of the structure elements given in this memo\
    \ are\n   intended to track the relevant standards.  uintN_t means an unsigned\n\
    \   integer of exactly N bits (e.g., uint16_t).  The sa_family_t and\n   in_port_t\
    \ types are defined in [3].\n"
- title: 2.3 Headers
  contents:
  - "2.3 Headers\n   When function prototypes and structures are shown we show the\
    \ headers\n   that must be #included to cause that item to be defined.\n"
- title: 2.4 Structures
  contents:
  - "2.4 Structures\n   When structures are described the members shown are the ones\
    \ that\n   must appear in an implementation.  Additional, nonstandard members\n\
    \   may also be defined by an implementation.  As an additional\n   precaution\
    \ nonstandard members could be verified by Feature Test\n   Macros as described\
    \ in [3].  (Such Feature Test Macros are not\n   defined by this RFC.)\n   The\
    \ ordering shown for the members of a structure is the recommended\n   ordering,\
    \ given alignment considerations of multibyte members, but an\n   implementation\
    \ may order the members differently.\n"
- title: 3. Socket Interface
  contents:
  - "3. Socket Interface\n   This section specifies the socket interface changes for\
    \ IPv6.\n"
- title: 3.1 IPv6 Address Family and Protocol Family
  contents:
  - "3.1 IPv6 Address Family and Protocol Family\n   A new address family name, AF_INET6,\
    \ is defined in <sys/socket.h>.\n   The AF_INET6 definition distinguishes between\
    \ the original\n   sockaddr_in address data structure, and the new sockaddr_in6\
    \ data\n   structure.\n   A new protocol family name, PF_INET6, is defined in\
    \ <sys/socket.h>.\n   Like most of the other protocol family names, this will\
    \ usually be\n   defined to have the same value as the corresponding address family\n\
    \   name:\n      #define PF_INET6        AF_INET6\n   The AF_INET6 is used in\
    \ the first argument to the socket() function\n   to indicate that an IPv6 socket\
    \ is being created.\n"
- title: 3.2 IPv6 Address Structure
  contents:
  - "3.2 IPv6 Address Structure\n   A new in6_addr structure holds a single IPv6 address\
    \ and is defined\n   as a result of including <netinet/in.h>:\n      struct in6_addr\
    \ {\n          uint8_t  s6_addr[16];      /* IPv6 address */\n      };\n   This\
    \ data structure contains an array of sixteen 8-bit elements,\n   which make up\
    \ one 128-bit IPv6 address.  The IPv6 address is stored\n   in network byte order.\n\
    \   The structure in6_addr above is usually implemented with an embedded\n   union\
    \ with extra fields that force the desired alignment level in a\n   manner similar\
    \ to BSD implementations of \"struct in_addr\".  Those\n   additional implementation\
    \ details are omitted here for simplicity.\n   An example is as follows:\n   struct\
    \ in6_addr {\n        union {\n            uint8_t  _S6_u8[16];\n            uint32_t\
    \ _S6_u32[4];\n            uint64_t _S6_u64[2];\n        } _S6_un;\n   };\n  \
    \ #define s6_addr _S6_un._S6_u8\n"
- title: 3.3 Socket Address Structure for 4.3BSD-Based Systems
  contents:
  - "3.3 Socket Address Structure for 4.3BSD-Based Systems\n   In the socket interface,\
    \ a different protocol-specific data structure\n   is defined to carry the addresses\
    \ for each protocol suite.  Each\n   protocol-specific data structure is designed\
    \ so it can be cast into a\n   protocol-independent data structure -- the \"sockaddr\"\
    \ structure.\n   Each has a \"family\" field that overlays the \"sa_family\" of\
    \ the\n   sockaddr data structure.  This field identifies the type of the data\n\
    \   structure.\n   The sockaddr_in structure is the protocol-specific address\
    \ data\n   structure for IPv4.  It is used to pass addresses between\n   applications\
    \ and the system in the socket functions.  The following\n   sockaddr_in6 structure\
    \ holds IPv6 addresses and is defined as a\n   result of including the <netinet/in.h>\
    \ header:\n"
- title: struct sockaddr_in6 {
  contents:
  - "struct sockaddr_in6 {\n    sa_family_t     sin6_family;    /* AF_INET6 */\n \
    \   in_port_t       sin6_port;      /* transport layer port # */\n    uint32_t\
    \        sin6_flowinfo;  /* IPv6 flow information */\n    struct in6_addr sin6_addr;\
    \      /* IPv6 address */\n    uint32_t        sin6_scope_id;  /* set of interfaces\
    \ for a scope */\n"
- title: '};'
  contents:
  - "};\n   This structure is designed to be compatible with the sockaddr data\n \
    \  structure used in the 4.3BSD release.\n   The sin6_family field identifies\
    \ this as a sockaddr_in6 structure.\n   This field overlays the sa_family field\
    \ when the buffer is cast to a\n   sockaddr data structure.  The value of this\
    \ field must be AF_INET6.\n   The sin6_port field contains the 16-bit UDP or TCP\
    \ port number.  This\n   field is used in the same way as the sin_port field of\
    \ the\n   sockaddr_in structure.  The port number is stored in network byte\n\
    \   order.\n   The sin6_flowinfo field is a 32-bit field intended to contain flow-\n\
    \   related information.  The exact way this field is mapped to or from a\n  \
    \ packet is not currently specified.  Until such time as its use is\n   specified,\
    \ applications should set this field to zero when\n   constructing a sockaddr_in6,\
    \ and ignore this field in a sockaddr_in6\n   structure constructed by the system.\n\
    \   The sin6_addr field is a single in6_addr structure (defined in the\n   previous\
    \ section).  This field holds one 128-bit IPv6 address.  The\n   address is stored\
    \ in network byte order.\n   The ordering of elements in this structure is specifically\
    \ designed\n   so that when sin6_addr field is aligned on a 64-bit boundary, the\n\
    \   start of the structure will also be aligned on a 64-bit boundary.\n   This\
    \ is done for optimum performance on 64-bit architectures.\n   The sin6_scope_id\
    \ field is a 32-bit integer that identifies a set of\n   interfaces as appropriate\
    \ for the scope [2] of the address carried in\n   the sin6_addr field.  The mapping\
    \ of sin6_scope_id to an interface or\n   set of interfaces is left to implementation\
    \ and future specifications\n   on the subject of scoped addresses.\n   Notice\
    \ that the sockaddr_in6 structure will normally be larger than\n   the generic\
    \ sockaddr structure.  On many existing implementations the\n   sizeof(struct\
    \ sockaddr_in) equals sizeof(struct sockaddr), with both\n   being 16 bytes. \
    \ Any existing code that makes this assumption needs\n   to be examined carefully\
    \ when converting to IPv6.\n"
- title: 3.4 Socket Address Structure for 4.4BSD-Based Systems
  contents:
  - "3.4 Socket Address Structure for 4.4BSD-Based Systems\n   The 4.4BSD release\
    \ includes a small, but incompatible change to the\n   socket interface.  The\
    \ \"sa_family\" field of the sockaddr data\n   structure was changed from a 16-bit\
    \ value to an 8-bit value, and the\n   space saved used to hold a length field,\
    \ named \"sa_len\".  The\n   sockaddr_in6 data structure given in the previous\
    \ section cannot be\n   correctly cast into the newer sockaddr data structure.\
    \  For this\n   reason, the following alternative IPv6 address data structure\
    \ is\n   provided to be used on systems based on 4.4BSD.  It is defined as a\n\
    \   result of including the <netinet/in.h> header.\n"
- title: struct sockaddr_in6 {
  contents:
  - "struct sockaddr_in6 {\n    uint8_t         sin6_len;       /* length of this\
    \ struct */\n    sa_family_t     sin6_family;    /* AF_INET6 */\n    in_port_t\
    \       sin6_port;      /* transport layer port # */\n    uint32_t        sin6_flowinfo;\
    \  /* IPv6 flow information */\n    struct in6_addr sin6_addr;      /* IPv6 address\
    \ */\n    uint32_t        sin6_scope_id;  /* set of interfaces for a scope */\n"
- title: '};'
  contents:
  - "};\n   The only differences between this data structure and the 4.3BSD\n   variant\
    \ are the inclusion of the length field, and the change of the\n   family field\
    \ to a 8-bit data type.  The definitions of all the other\n   fields are identical\
    \ to the structure defined in the previous\n   section.\n   Systems that provide\
    \ this version of the sockaddr_in6 data structure\n   must also declare SIN6_LEN\
    \ as a result of including the\n   <netinet/in.h> header.  This macro allows applications\
    \ to determine\n   whether they are being built on a system that supports the\
    \ 4.3BSD or\n   4.4BSD variants of the data structure.\n"
- title: 3.5 The Socket Functions
  contents:
  - "3.5 The Socket Functions\n   Applications call the socket() function to create\
    \ a socket descriptor\n   that represents a communication endpoint.  The arguments\
    \ to the\n   socket() function tell the system which protocol to use, and what\n\
    \   format address structure will be used in subsequent functions.  For\n   example,\
    \ to create an IPv4/TCP socket, applications make the call:\n      s = socket(AF_INET,\
    \ SOCK_STREAM, 0);\n   To create an IPv4/UDP socket, applications make the call:\n\
    \      s = socket(AF_INET, SOCK_DGRAM, 0);\n   Applications may create IPv6/TCP\
    \ and IPv6/UDP sockets (which may also\n   handle IPv4 communication as described\
    \ in section 3.7) by simply\n   using the constant AF_INET6 instead of AF_INET\
    \ in the first argument.\n   For example, to create an IPv6/TCP socket, applications\
    \ make the\n   call:\n      s = socket(AF_INET6, SOCK_STREAM, 0);\n   To create\
    \ an IPv6/UDP socket, applications make the call:\n      s = socket(AF_INET6,\
    \ SOCK_DGRAM, 0);\n   Once the application has created a AF_INET6 socket, it must\
    \ use the\n   sockaddr_in6 address structure when passing addresses in to the\n\
    \   system.  The functions that the application uses to pass addresses\n   into\
    \ the system are:\n      bind()\n      connect()\n      sendmsg()\n      sendto()\n\
    \   The system will use the sockaddr_in6 address structure to return\n   addresses\
    \ to applications that are using AF_INET6 sockets.  The\n   functions that return\
    \ an address from the system to an application\n   are:\n      accept()\n    \
    \  recvfrom()\n      recvmsg()\n      getpeername()\n      getsockname()\n   No\
    \ changes to the syntax of the socket functions are needed to\n   support IPv6,\
    \ since all of the \"address carrying\" functions use an\n   opaque address pointer,\
    \ and carry an address length as a function\n   argument.\n"
- title: 3.6 Compatibility with IPv4 Applications
  contents:
  - "3.6 Compatibility with IPv4 Applications\n   In order to support the large base\
    \ of applications using the original\n   API, system implementations must provide\
    \ complete source and binary\n   compatibility with the original API.  This means\
    \ that systems must\n   continue to support AF_INET sockets and the sockaddr_in\
    \ address\n   structure.  Applications must be able to create IPv4/TCP and IPv4/UDP\n\
    \   sockets using the AF_INET constant in the socket() function, as\n   described\
    \ in the previous section.  Applications should be able to\n   hold a combination\
    \ of IPv4/TCP, IPv4/UDP, IPv6/TCP and IPv6/UDP\n   sockets simultaneously within\
    \ the same process.\n   Applications using the original API should continue to\
    \ operate as\n   they did on systems supporting only IPv4.  That is, they should\n\
    \   continue to interoperate with IPv4 nodes.\n"
- title: 3.7 Compatibility with IPv4 Nodes
  contents:
  - "3.7 Compatibility with IPv4 Nodes\n   The API also provides a different type\
    \ of compatibility: the ability\n   for IPv6 applications to interoperate with\
    \ IPv4 applications.  This\n   feature uses the IPv4-mapped IPv6 address format\
    \ defined in the IPv6\n   addressing architecture specification [2].  This address\
    \ format\n   allows the IPv4 address of an IPv4 node to be represented as an IPv6\n\
    \   address.  The IPv4 address is encoded into the low-order 32 bits of\n   the\
    \ IPv6 address, and the high-order 96 bits hold the fixed prefix\n   0:0:0:0:0:FFFF.\
    \  IPv4-mapped addresses are written as follows:\n      ::FFFF:<IPv4-address>\n\
    \   These addresses can be generated automatically by the getaddrinfo()\n   function,\
    \ as described in Section 6.1.\n   Applications may use AF_INET6 sockets to open\
    \ TCP connections to IPv4\n   nodes, or send UDP packets to IPv4 nodes, by simply\
    \ encoding the\n   destination's IPv4 address as an IPv4-mapped IPv6 address,\
    \ and\n   passing that address, within a sockaddr_in6 structure, in the\n   connect()\
    \ or sendto() call.  When applications use AF_INET6 sockets\n   to accept TCP\
    \ connections from IPv4 nodes, or receive UDP packets\n   from IPv4 nodes, the\
    \ system returns the peer's address to the\n   application in the accept(), recvfrom(),\
    \ or getpeername() call using\n   a sockaddr_in6 structure encoded this way.\n\
    \   Few applications will likely need to know which type of node they are\n  \
    \ interoperating with.  However, for those applications that do need to\n   know,\
    \ the IN6_IS_ADDR_V4MAPPED() macro, defined in Section 6.4, is\n   provided.\n"
- title: 3.8 IPv6 Wildcard Address
  contents:
  - "3.8 IPv6 Wildcard Address\n   While the bind() function allows applications to\
    \ select the source IP\n   address of UDP packets and TCP connections, applications\
    \ often want\n   the system to select the source address for them.  With IPv4,\
    \ one\n   specifies the address as the symbolic constant INADDR_ANY (called the\n\
    \   \"wildcard\" address) in the bind() call, or simply omits the bind()\n   entirely.\n\
    \   Since the IPv6 address type is a structure (struct in6_addr), a\n   symbolic\
    \ constant can be used to initialize an IPv6 address variable,\n   but cannot\
    \ be used in an assignment.  Therefore systems provide the\n   IPv6 wildcard address\
    \ in two forms.\n   The first version is a global variable named \"in6addr_any\"\
    \ that is an\n   in6_addr structure.  The extern declaration for this variable\
    \ is\n   defined in <netinet/in.h>:\n      extern const struct in6_addr in6addr_any;\n\
    \   Applications use in6addr_any similarly to the way they use INADDR_ANY\n  \
    \ in IPv4.  For example, to bind a socket to port number 23, but let\n   the system\
    \ select the source address, an application could use the\n   following code:\n\
    \      struct sockaddr_in6 sin6;\n       . . .\n      sin6.sin6_family = AF_INET6;\n\
    \      sin6.sin6_flowinfo = 0;\n      sin6.sin6_port = htons(23);\n      sin6.sin6_addr\
    \ = in6addr_any;  /* structure assignment */\n       . . .\n      if (bind(s,\
    \ (struct sockaddr *) &sin6, sizeof(sin6)) == -1)\n              . . .\n   The\
    \ other version is a symbolic constant named IN6ADDR_ANY_INIT and\n   is defined\
    \ in <netinet/in.h>.  This constant can be used to\n   initialize an in6_addr\
    \ structure:\n      struct in6_addr anyaddr = IN6ADDR_ANY_INIT;\n   Note that\
    \ this constant can be used ONLY at declaration time.  It can\n   not be used\
    \ to assign a previously declared in6_addr structure.  For\n   example, the following\
    \ code will not work:\n      /* This is the WRONG way to assign an unspecified\
    \ address */\n      struct sockaddr_in6 sin6;\n       . . .\n      sin6.sin6_addr\
    \ = IN6ADDR_ANY_INIT; /* will NOT compile */\n   Be aware that the IPv4 INADDR_xxx\
    \ constants are all defined in host\n   byte order but the IPv6 IN6ADDR_xxx constants\
    \ and the IPv6\n   in6addr_xxx externals are defined in network byte order.\n"
- title: 3.9 IPv6 Loopback Address
  contents:
  - "3.9 IPv6 Loopback Address\n   Applications may need to send UDP packets to, or\
    \ originate TCP\n   connections to, services residing on the local node.  In IPv4,\
    \ they\n   can do this by using the constant IPv4 address INADDR_LOOPBACK in\n\
    \   their connect(), sendto(), or sendmsg() call.\n   IPv6 also provides a loopback\
    \ address to contact local TCP and UDP\n   services.  Like the unspecified address,\
    \ the IPv6 loopback address is\n   provided in two forms -- a global variable\
    \ and a symbolic constant.\n   The global variable is an in6_addr structure named\n\
    \   \"in6addr_loopback.\"  The extern declaration for this variable is\n   defined\
    \ in <netinet/in.h>:\n      extern const struct in6_addr in6addr_loopback;\n \
    \  Applications use in6addr_loopback as they would use INADDR_LOOPBACK\n   in\
    \ IPv4 applications (but beware of the byte ordering difference\n   mentioned\
    \ at the end of the previous section).  For example, to open\n   a TCP connection\
    \ to the local telnet server, an application could use\n   the following code:\n\
    \   struct sockaddr_in6 sin6;\n    . . .\n   sin6.sin6_family = AF_INET6;\n  \
    \ sin6.sin6_flowinfo = 0;\n   sin6.sin6_port = htons(23);\n   sin6.sin6_addr =\
    \ in6addr_loopback;  /* structure assignment */\n    . . .\n   if (connect(s,\
    \ (struct sockaddr *) &sin6, sizeof(sin6)) == -1)\n           . . .\n   The symbolic\
    \ constant is named IN6ADDR_LOOPBACK_INIT and is defined\n   in <netinet/in.h>.\
    \  It can be used at declaration time ONLY; for\n   example:\n      struct in6_addr\
    \ loopbackaddr = IN6ADDR_LOOPBACK_INIT;\n   Like IN6ADDR_ANY_INIT, this constant\
    \ cannot be used in an assignment\n   to a previously declared IPv6 address variable.\n"
- title: 3.10 Portability Additions
  contents:
  - "3.10 Portability Additions\n   One simple addition to the sockets API that can\
    \ help application\n   writers is the \"struct sockaddr_storage\".  This data\
    \ structure can\n   simplify writing code that is portable across multiple address\n\
    \   families and platforms.  This data structure is designed with the\n   following\
    \ goals.\n   - Large enough to accommodate all supported protocol-specific address\n\
    \      structures.\n   - Aligned at an appropriate boundary so that pointers to\
    \ it can be\n      cast as pointers to protocol specific address structures and\
    \ used\n      to access the fields of those structures without alignment\n   \
    \   problems.\n   The sockaddr_storage structure contains field ss_family which\
    \ is of\n   type sa_family_t.  When a sockaddr_storage structure is cast to a\n\
    \   sockaddr structure, the ss_family field of the sockaddr_storage\n   structure\
    \ maps onto the sa_family field of the sockaddr structure.\n   When a sockaddr_storage\
    \ structure is cast as a protocol specific\n   address structure, the ss_family\
    \ field maps onto a field of that\n   structure that is of type sa_family_t and\
    \ that identifies the\n   protocol's address family.\n   An example implementation\
    \ design of such a data structure would be as\n   follows.\n"
- title: /*
  contents:
  - "/*\n * Desired design of maximum size and alignment\n */\n"
- title: '#define _SS_MAXSIZE    128  /* Implementation specific max size */'
  contents:
  - '#define _SS_MAXSIZE    128  /* Implementation specific max size */

    '
- title: '#define _SS_ALIGNSIZE  (sizeof (int64_t))'
  contents:
  - "#define _SS_ALIGNSIZE  (sizeof (int64_t))\n                         /* Implementation\
    \ specific desired alignment */\n"
- title: /*
  contents:
  - "/*\n * Definitions used for sockaddr_storage structure paddings design.\n */\n"
- title: '#define _SS_PAD1SIZE   (_SS_ALIGNSIZE - sizeof (sa_family_t))'
  contents:
  - '#define _SS_PAD1SIZE   (_SS_ALIGNSIZE - sizeof (sa_family_t))

    '
- title: '#define _SS_PAD2SIZE   (_SS_MAXSIZE - (sizeof (sa_family_t) +'
  contents:
  - "#define _SS_PAD2SIZE   (_SS_MAXSIZE - (sizeof (sa_family_t) +\n             \
    \                 _SS_PAD1SIZE + _SS_ALIGNSIZE))\n"
- title: struct sockaddr_storage {
  contents:
  - "struct sockaddr_storage {\n    sa_family_t  ss_family;     /* address family\
    \ */\n    /* Following fields are implementation specific */\n    char      __ss_pad1[_SS_PAD1SIZE];\n\
    \              /* 6 byte pad, this is to make implementation\n              /*\
    \ specific pad up to alignment field that */\n              /* follows explicit\
    \ in the data structure */\n    int64_t   __ss_align;     /* field to force desired\
    \ structure */\n               /* storage alignment */\n    char      __ss_pad2[_SS_PAD2SIZE];\n\
    \              /* 112 byte pad to achieve desired size, */\n              /* _SS_MAXSIZE\
    \ value minus size of ss_family */\n              /* __ss_pad1, __ss_align fields\
    \ is 112 */\n"
- title: '};'
  contents:
  - "};\n   The above example implementation illustrates a data structure which\n\
    \   will align on a 64-bit boundary.  An implementation-specific field\n   \"\
    __ss_align\" along with \"__ss_pad1\" is used to force a 64-bit\n   alignment\
    \ which covers proper alignment good enough for the needs of\n   sockaddr_in6\
    \ (IPv6), sockaddr_in (IPv4) address data structures.  The\n   size of padding\
    \ field __ss_pad1 depends on the chosen alignment\n   boundary.  The size of padding\
    \ field __ss_pad2 depends on the value\n   of overall size chosen for the total\
    \ size of the structure.  This\n   size and alignment are represented in the above\
    \ example by\n   implementation specific (not required) constants _SS_MAXSIZE\
    \ (chosen\n   value 128) and _SS_ALIGNSIZE (with chosen value 8).  Constants\n\
    \   _SS_PAD1SIZE (derived value 6) and _SS_PAD2SIZE (derived value 112)\n   are\
    \ also for illustration and not required.  The derived values\n   assume sa_family_t\
    \ is 2 bytes.  The implementation specific\n   definitions and structure field\
    \ names above start with an underscore\n   to denote implementation private namespace.\
    \  Portable code is not\n   expected to access or reference those fields or constants.\n\
    \   On implementations where the sockaddr data structure includes a\n   \"sa_len\"\
    \ field this data structure would look like this:\n"
- title: /*
  contents:
  - "/*\n * Definitions used for sockaddr_storage structure paddings design.\n */\n"
- title: '#define _SS_PAD1SIZE (_SS_ALIGNSIZE -'
  contents:
  - "#define _SS_PAD1SIZE (_SS_ALIGNSIZE -\n                            (sizeof (uint8_t)\
    \ + sizeof (sa_family_t))\n"
- title: '#define _SS_PAD2SIZE (_SS_MAXSIZE -'
  contents:
  - "#define _SS_PAD2SIZE (_SS_MAXSIZE -\n                            (sizeof (uint8_t)\
    \ + sizeof (sa_family_t) +\n                             _SS_PAD1SIZE + _SS_ALIGNSIZE))\n"
- title: struct sockaddr_storage {
  contents:
  - "struct sockaddr_storage {\n    uint8_t      ss_len;        /* address length\
    \ */\n    sa_family_t  ss_family;     /* address family */\n    /* Following fields\
    \ are implementation specific */\n    char         __ss_pad1[_SS_PAD1SIZE];\n\
    \                  /* 6 byte pad, this is to make implementation\n           \
    \       /* specific pad up to alignment field that */\n                  /* follows\
    \ explicit in the data structure */\n    int64_t      __ss_align;  /* field to\
    \ force desired structure */\n                  /* storage alignment */\n    char\
    \         __ss_pad2[_SS_PAD2SIZE];\n                  /* 112 byte pad to achieve\
    \ desired size, */\n                  /* _SS_MAXSIZE value minus size of ss_len,\
    \ */\n                  /* __ss_family, __ss_pad1, __ss_align fields is 112 */\n"
- title: '};'
  contents:
  - '};

    '
- title: 4. Interface Identification
  contents:
  - "4. Interface Identification\n   This API uses an interface index (a small positive\
    \ integer) to\n   identify the local interface on which a multicast group is joined\n\
    \   (Section 5.2).  Additionally, the advanced API [4] uses these same\n   interface\
    \ indexes to identify the interface on which a datagram is\n   received, or to\
    \ specify the interface on which a datagram is to be\n   sent.\n   Interfaces\
    \ are normally known by names such as \"le0\", \"sl1\", \"ppp2\",\n   and the\
    \ like.  On Berkeley-derived implementations, when an interface\n   is made known\
    \ to the system, the kernel assigns a unique positive\n   integer value (called\
    \ the interface index) to that interface.  These\n   are small positive integers\
    \ that start at 1.  (Note that 0 is never\n   used for an interface index.)  There\
    \ may be gaps so that there is no\n   current interface for a particular positive\
    \ interface index.\n   This API defines two functions that map between an interface\
    \ name and\n   index, a third function that returns all the interface names and\n\
    \   indexes, and a fourth function to return the dynamic memory allocated\n  \
    \ by the previous function.  How these functions are implemented is\n   left up\
    \ to the implementation.  4.4BSD implementations can implement\n   these functions\
    \ using the existing sysctl() function with the\n   NET_RT_IFLIST command.  Other\
    \ implementations may wish to use ioctl()\n   for this purpose.\n"
- title: 4.1 Name-to-Index
  contents:
  - "4.1 Name-to-Index\n   The first function maps an interface name into its corresponding\n\
    \   index.\n      #include <net/if.h>\n      unsigned int  if_nametoindex(const\
    \ char *ifname);\n   If ifname is the name of an interface, the if_nametoindex()\
    \ function\n   shall return the interface index corresponding to name ifname;\n\
    \   otherwise, it shall return zero.  No errors are defined.\n"
- title: 4.2 Index-to-Name
  contents:
  - "4.2 Index-to-Name\n   The second function maps an interface index into its corresponding\n\
    \   name.\n      #include <net/if.h>\n      char  *if_indextoname(unsigned int\
    \ ifindex, char *ifname);\n   When this function is called, the ifname argument\
    \ shall point to a\n   buffer of at least IF_NAMESIZE bytes.  The function shall\
    \ place in\n   this buffer the name of the interface with index ifindex.\n   (IF_NAMESIZE\
    \ is also defined in <net/if.h> and its value includes a\n   terminating null\
    \ byte at the end of the interface name.)  If ifindex\n   is an interface index,\
    \ then the function shall return the value\n   supplied in ifname, which points\
    \ to a buffer now containing the\n   interface name.  Otherwise, the function\
    \ shall return a NULL pointer\n   and set errno to indicate the error.  If there\
    \ is no interface\n   corresponding to the specified index, errno is set to ENXIO.\
    \  If\n   there was a system error (such as running out of memory), errno would\n\
    \   be set to the proper value (e.g., ENOMEM).\n"
- title: 4.3 Return All Interface Names and Indexes
  contents:
  - "4.3 Return All Interface Names and Indexes\n   The if_nameindex structure holds\
    \ the information about a single\n   interface and is defined as a result of including\
    \ the <net/if.h>\n   header.\n   struct if_nameindex {\n     unsigned int   if_index;\
    \  /* 1, 2, ... */\n     char          *if_name;   /* null terminated name: \"\
    le0\", ... */\n   };\n   The final function returns an array of if_nameindex structures,\
    \ one\n   structure per interface.\n      #include <net/if.h>\n      struct if_nameindex\
    \  *if_nameindex(void);\n   The end of the array of structures is indicated by\
    \ a structure with\n   an if_index of 0 and an if_name of NULL.  The function\
    \ returns a NULL\n   pointer upon an error, and would set errno to the appropriate\
    \ value.\n   The memory used for this array of structures along with the interface\n\
    \   names pointed to by the if_name members is obtained dynamically.\n   This\
    \ memory is freed by the next function.\n"
- title: 4.4 Free Memory
  contents:
  - "4.4 Free Memory\n   The following function frees the dynamic memory that was\
    \ allocated by\n   if_nameindex().\n      #include <net/if.h>\n      void  if_freenameindex(struct\
    \ if_nameindex *ptr);\n   The ptr argument shall be a pointer that was returned\
    \ by\n   if_nameindex().  After if_freenameindex() has been called, the\n   application\
    \ shall not use the array of which ptr is the address.\n"
- title: 5. Socket Options
  contents:
  - "5. Socket Options\n   A number of new socket options are defined for IPv6.  All\
    \ of these\n   new options are at the IPPROTO_IPV6 level.  That is, the \"level\"\
    \n   parameter in the getsockopt() and setsockopt() calls is IPPROTO_IPV6\n  \
    \ when using these options.  The constant name prefix IPV6_ is used in\n   all\
    \ of the new socket options.  This serves to clearly identify these\n   options\
    \ as applying to IPv6.\n   The declaration for IPPROTO_IPV6, the new IPv6 socket\
    \ options, and\n   related constants defined in this section are obtained by including\n\
    \   the header <netinet/in.h>.\n"
- title: 5.1 Unicast Hop Limit
  contents:
  - "5.1 Unicast Hop Limit\n   A new setsockopt() option controls the hop limit used\
    \ in outgoing\n   unicast IPv6 packets.  The name of this option is IPV6_UNICAST_HOPS,\n\
    \   and it is used at the IPPROTO_IPV6 layer.  The following example\n   illustrates\
    \ how it is used:\n   int  hoplimit = 10;\n   if (setsockopt(s, IPPROTO_IPV6,\
    \ IPV6_UNICAST_HOPS,\n                  (char *) &hoplimit, sizeof(hoplimit))\
    \ == -1)\n       perror(\"setsockopt IPV6_UNICAST_HOPS\");\n   When the IPV6_UNICAST_HOPS\
    \ option is set with setsockopt(), the\n   option value given is used as the hop\
    \ limit for all subsequent\n   unicast packets sent via that socket.  If the option\
    \ is not set, the\n   system selects a default value.  The integer hop limit value\
    \ (called\n   x) is interpreted as follows:\n      x < -1:        return an error\
    \ of EINVAL\n      x == -1:       use kernel default\n      0 <= x <= 255: use\
    \ x\n      x >= 256:      return an error of EINVAL\n   The IPV6_UNICAST_HOPS\
    \ option may be used with getsockopt() to\n   determine the hop limit value that\
    \ the system will use for subsequent\n   unicast packets sent via that socket.\
    \  For example:\n      int  hoplimit;\n      socklen_t  len = sizeof(hoplimit);\n\
    \      if (getsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS,\n                  \
    \   (char *) &hoplimit, &len) == -1)\n          perror(\"getsockopt IPV6_UNICAST_HOPS\"\
    );\n      else\n          printf(\"Using %d for hop limit.\\n\", hoplimit);\n"
- title: 5.2 Sending and Receiving Multicast Packets
  contents:
  - "5.2 Sending and Receiving Multicast Packets\n   IPv6 applications may send multicast\
    \ packets by simply specifying an\n   IPv6 multicast address as the destination\
    \ address, for example in the\n   destination address argument of the sendto()\
    \ function.\n   Three socket options at the IPPROTO_IPV6 layer control some of\
    \ the\n   parameters for sending multicast packets.  Setting these options is\n\
    \   not required: applications may send multicast packets without using\n   these\
    \ options.  The setsockopt() options for controlling the sending\n   of multicast\
    \ packets are summarized below.  These three options can\n   also be used with\
    \ getsockopt().\n      IPV6_MULTICAST_IF\n         Set the interface to use for\
    \ outgoing multicast packets.  The\n         argument is the index of the interface\
    \ to use.  If the\n         interface index is specified as zero, the system selects\
    \ the\n         interface (for example, by looking up the address in a routing\n\
    \         table and using the resulting interface).\n         Argument type: unsigned\
    \ int\n      IPV6_MULTICAST_HOPS\n         Set the hop limit to use for outgoing\
    \ multicast packets.  (Note\n         a separate option - IPV6_UNICAST_HOPS -\
    \ is provided to set the\n         hop limit to use for outgoing unicast packets.)\n\
    \         The interpretation of the argument is the same as for the\n        \
    \ IPV6_UNICAST_HOPS option:\n            x < -1:        return an error of EINVAL\n\
    \            x == -1:       use kernel default\n            0 <= x <= 255: use\
    \ x\n            x >= 256:      return an error of EINVAL\n            If IPV6_MULTICAST_HOPS\
    \ is not set, the default is 1\n            (same as IPv4 today)\n         Argument\
    \ type: int\n      IPV6_MULTICAST_LOOP\n         If a multicast datagram is sent\
    \ to a group to which the sending\n         host itself belongs (on the outgoing\
    \ interface), a copy of the\n         datagram is looped back by the IP layer\
    \ for local delivery if\n         this option is set to 1.  If this option is\
    \ set to 0 a copy is\n         not looped back.  Other option values return an\
    \ error of\n         EINVAL.\n         If IPV6_MULTICAST_LOOP is not set, the\
    \ default is 1 (loopback;\n         same as IPv4 today).\n         Argument type:\
    \ unsigned int\n   The reception of multicast packets is controlled by the two\n\
    \   setsockopt() options summarized below.  An error of EOPNOTSUPP is\n   returned\
    \ if these two options are used with getsockopt().\n      IPV6_JOIN_GROUP\n  \
    \       Join a multicast group on a specified local interface.\n         If the\
    \ interface index is specified as 0,\n         the kernel chooses the local interface.\n\
    \         For example, some kernels look up the multicast group\n         in the\
    \ normal IPv6 routing table and use the resulting\n         interface.\n     \
    \    Argument type: struct ipv6_mreq\n      IPV6_LEAVE_GROUP\n         Leave a\
    \ multicast group on a specified interface.\n         If the interface index is\
    \ specified as 0, the system\n         may choose a multicast group membership\
    \ to drop by\n         matching the multicast address only.\n         Argument\
    \ type: struct ipv6_mreq\n   The argument type of both of these options is the\
    \ ipv6_mreq\n   structure, defined as a result of including the <netinet/in.h>\n\
    \   header;\n   struct ipv6_mreq {\n       struct in6_addr ipv6mr_multiaddr; /*\
    \ IPv6 multicast addr */\n       unsigned int    ipv6mr_interface; /* interface\
    \ index */\n   };\n   Note that to receive multicast datagrams a process must\
    \ join the\n   multicast group to which datagrams will be sent.  UDP applications\n\
    \   must also bind the UDP port to which datagrams will be sent.  Some\n   processes\
    \ also bind the multicast group address to the socket, in\n   addition to the\
    \ port, to prevent other datagrams destined to that\n   same port from being delivered\
    \ to the socket.\n"
- title: 5.3 IPV6_V6ONLY option for AF_INET6 Sockets
  contents:
  - "5.3 IPV6_V6ONLY option for AF_INET6 Sockets\n   This socket option restricts\
    \ AF_INET6 sockets to IPv6 communications\n   only.  As stated in section <3.7\
    \ Compatibility with IPv4 Nodes>,\n   AF_INET6 sockets may be used for both IPv4\
    \ and IPv6 communications.\n   Some applications may want to restrict their use\
    \ of an AF_INET6\n   socket to IPv6 communications only.  For these applications\
    \ the\n   IPV6_V6ONLY socket option is defined.  When this option is turned on,\n\
    \   the socket can be used to send and receive IPv6 packets only.  This\n   is\
    \ an IPPROTO_IPV6 level option.  This option takes an int value.\n   This is a\
    \ boolean option.  By default this option is turned off.\n   Here is an example\
    \ of setting this option:\n      int on = 1;\n      if (setsockopt(s, IPPROTO_IPV6,\
    \ IPV6_V6ONLY,\n                     (char *)&on, sizeof(on)) == -1)\n       \
    \   perror(\"setsockopt IPV6_V6ONLY\");\n      else\n          printf(\"IPV6_V6ONLY\
    \ set\\n\");\n   Note - This option has no effect on the use of IPv4 Mapped addresses\n\
    \   which enter a node as a valid IPv6 addresses for IPv6 communications\n   as\
    \ defined by Stateless IP/ICMP Translation Algorithm (SIIT) [5].\n   An example\
    \ use of this option is to allow two versions of the same\n   server process to\
    \ run on the same port, one providing service over\n   IPv6, the other providing\
    \ the same service over IPv4.\n"
- title: 6. Library Functions
  contents:
  - "6. Library Functions\n   New library functions are needed to perform a variety\
    \ of operations\n   with IPv6 addresses.  Functions are needed to lookup IPv6\
    \ addresses\n   in the Domain Name System (DNS).  Both forward lookup (nodename-to-\n\
    \   address translation) and reverse lookup (address-to-nodename\n   translation)\
    \ need to be supported.  Functions are also needed to\n   convert IPv6 addresses\
    \ between their binary and textual form.\n   We note that the two existing functions,\
    \ gethostbyname() and\n   gethostbyaddr(), are left as-is.  New functions are\
    \ defined to handle\n   both IPv4 and IPv6 addresses.\n   The commonly used function\
    \ gethostbyname() is inadequate for many\n   applications, first because it provides\
    \ no way for the caller to\n   specify anything about the types of addresses desired\
    \ (IPv4 only,\n   IPv6 only, IPv4-mapped IPv6 are OK, etc.), and second because\
    \ many\n   implementations of this function are not thread safe.  RFC 2133\n \
    \  defined a function named gethostbyname2() but this function was also\n   inadequate,\
    \ first because its use required setting a global option\n   (RES_USE_INET6) when\
    \ IPv6 addresses were required, and second because\n   a flag argument is needed\
    \ to provide the caller with additional\n   control over the types of addresses\
    \ required.  The gethostbyname2()\n   function was deprecated in RFC 2553 and\
    \ is no longer part of the\n   basic API.\n"
- title: 6.1 Protocol-Independent Nodename and Service Name Translation
  contents:
  - "6.1 Protocol-Independent Nodename and Service Name Translation\n   Nodename-to-address\
    \ translation is done in a protocol-independent\n   fashion using the getaddrinfo()\
    \ function.\n"
- title: '#include <sys/socket.h>'
  contents:
  - '#include <sys/socket.h>

    '
- title: '#include <netdb.h>'
  contents:
  - '#include <netdb.h>

    '
- title: int getaddrinfo(const char *nodename, const char *servname,
  contents:
  - "int getaddrinfo(const char *nodename, const char *servname,\n               \
    \ const struct addrinfo *hints, struct addrinfo **res);\n"
- title: void freeaddrinfo(struct addrinfo *ai);
  contents:
  - 'void freeaddrinfo(struct addrinfo *ai);

    '
- title: struct addrinfo {
  contents:
  - "struct addrinfo {\n  int     ai_flags;     /* AI_PASSIVE, AI_CANONNAME,\n   \
    \                        AI_NUMERICHOST, .. */\n  int     ai_family;    /* AF_xxx\
    \ */\n  int     ai_socktype;  /* SOCK_xxx */\n  int     ai_protocol;  /* 0 or\
    \ IPPROTO_xxx for IPv4 and IPv6 */\n  socklen_t  ai_addrlen;   /* length of ai_addr\
    \ */\n  char   *ai_canonname; /* canonical name for nodename */\n  struct sockaddr\
    \  *ai_addr; /* binary address */\n  struct addrinfo  *ai_next; /* next structure\
    \ in linked list */\n"
- title: '};'
  contents:
  - "};\n   The getaddrinfo() function translates the name of a service location\n\
    \   (for example, a host name) and/or a service name and returns a set of\n  \
    \ socket addresses and associated information to be used in creating a\n   socket\
    \ with which to address the specified service.\n   The nodename and servname arguments\
    \ are either null pointers or\n   pointers to null-terminated strings.  One or\
    \ both of these two\n   arguments must be a non-null pointer.\n   The format of\
    \ a valid name depends on the address family or families.\n   If a specific family\
    \ is not given and the name could be interpreted\n   as valid within multiple\
    \ supported families, the implementation will\n   attempt to resolve the name\
    \ in all supported families and, in absence\n   of errors, one or more results\
    \ shall be returned.\n   If the nodename argument is not null, it can be a descriptive\
    \ name or\n   can be an address string.  If the specified address family is\n\
    \   AF_INET, AF_INET6, or AF_UNSPEC, valid descriptive names include host\n  \
    \ names. If the specified address family is AF_INET or AF_UNSPEC,\n   address\
    \ strings using Internet standard dot notation as specified in\n   inet_addr()\
    \ are valid.  If the specified address family is AF_INET6\n   or AF_UNSPEC, standard\
    \ IPv6 text forms described in inet_pton() are\n   valid.\n   If nodename is not\
    \ null, the requested service location is named by\n   nodename; otherwise, the\
    \ requested service location is local to the\n   caller.\n   If servname is null,\
    \ the call shall return network-level addresses\n   for the specified nodename.\
    \  If servname is not null, it is a null-\n   terminated character string identifying\
    \ the requested service.  This\n   can be either a descriptive name or a numeric\
    \ representation suitable\n   for use with the address family or families.  If\
    \ the specified\n   address family is AF_INET, AF_INET6 or AF_UNSPEC, the service\
    \ can be\n   specified as a string specifying a decimal port number.\n   If the\
    \ argument hints is not null, it refers to a structure\n   containing input values\
    \ that may direct the operation by providing\n   options and by limiting the returned\
    \ information to a specific socket\n   type, address family and/or protocol. \
    \ In this hints structure every\n   member other than ai_flags, ai_family, ai_socktype\
    \ and ai_protocol\n   shall be set to zero or a null pointer.  A value of AF_UNSPEC\
    \ for\n   ai_family means that the caller shall accept any address family.  A\n\
    \   value of zero for ai_socktype means that the caller shall accept any\n   socket\
    \ type.  A value of zero for ai_protocol means that the caller\n   shall accept\
    \ any protocol.  If hints is a null pointer, the behavior\n   shall be as if it\
    \ referred to a structure containing the value zero\n   for the ai_flags, ai_socktype\
    \ and ai_protocol fields, and AF_UNSPEC\n   for the ai_family field.\n   Note:\n\
    \   1. If the caller handles only TCP and not UDP, for example, then the\n   \
    \   ai_protocol member of the hints structure should be set to\n      IPPROTO_TCP\
    \ when getaddrinfo() is called.\n   2. If the caller handles only IPv4 and not\
    \ IPv6, then the ai_family\n      member of the hints structure should be set\
    \ to AF_INET when\n      getaddrinfo() is called.\n   The ai_flags field to which\
    \ hints parameter points shall be set to\n   zero or be the bitwise-inclusive\
    \ OR of one or more of the values\n   AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST,\
    \ AI_NUMERICSERV,\n   AI_V4MAPPED, AI_ALL, and AI_ADDRCONFIG.\n   If the AI_PASSIVE\
    \ flag is specified, the returned address information\n   shall be suitable for\
    \ use in binding a socket for accepting incoming\n   connections for the specified\
    \ service (i.e., a call to bind()).  In\n   this case, if the nodename argument\
    \ is null, then the IP address\n   portion of the socket address structure shall\
    \ be set to INADDR_ANY\n   for an IPv4 address or IN6ADDR_ANY_INIT for an IPv6\
    \ address.  If the\n   AI_PASSIVE flag is not specified, the returned address\
    \ information\n   shall be suitable for a call to connect() (for a connection-mode\n\
    \   protocol) or for a call to connect(), sendto() or sendmsg() (for a\n   connectionless\
    \ protocol).  In this case, if the nodename argument is\n   null, then the IP\
    \ address portion of the socket address structure\n   shall be set to the loopback\
    \ address.  This flag is ignored if the\n   nodename argument is not null.\n \
    \  If the AI_CANONNAME flag is specified and the nodename argument is\n   not\
    \ null, the function shall attempt to determine the canonical name\n   corresponding\
    \ to nodename (for example, if nodename is an alias or\n   shorthand notation\
    \ for a complete name).\n   If the AI_NUMERICHOST flag is specified, then a non-null\
    \ nodename\n   string supplied shall be a numeric host address string.  Otherwise,\n\
    \   an [EAI_NONAME] error is returned.  This flag shall prevent any type\n   of\
    \ name resolution service (for example, the DNS) from being invoked.\n   If the\
    \ AI_NUMERICSERV flag is specified, then a non-null servname\n   string supplied\
    \ shall be a numeric port string.  Otherwise, an\n   [EAI_NONAME] error shall\
    \ be returned.  This flag shall prevent any\n   type of name resolution service\
    \ (for example, NIS+) from being\n   invoked.\n   If the AI_V4MAPPED flag is specified\
    \ along with an ai_family of\n   AF_INET6, then getaddrinfo() shall return IPv4-mapped\
    \ IPv6 addresses\n   on finding no matching IPv6 addresses (ai_addrlen shall be\
    \ 16).\n      For example, when using the DNS, if no AAAA records are found then\n\
    \      a query is made for A records and any found are returned as IPv4-\n   \
    \   mapped IPv6 addresses.\n   The AI_V4MAPPED flag shall be ignored unless ai_family\
    \ equals\n   AF_INET6.\n   If the AI_ALL flag is used with the AI_V4MAPPED flag,\
    \ then\n   getaddrinfo() shall return all matching IPv6 and IPv4 addresses.\n\
    \      For example, when using the DNS, queries are made for both AAAA\n     \
    \ records and A records, and getaddrinfo() returns the combined\n      results\
    \ of both queries.  Any IPv4 addresses found are returned as\n      IPv4-mapped\
    \ IPv6 addresses.\n   The AI_ALL flag without the AI_V4MAPPED flag is ignored.\n\
    \      Note:\n      When ai_family is not specified (AF_UNSPEC), AI_V4MAPPED and\n\
    \      AI_ALL flags will only be used if AF_INET6 is supported.\n   If the AI_ADDRCONFIG\
    \ flag is specified, IPv4 addresses shall be\n   returned only if an IPv4 address\
    \ is configured on the local system,\n   and IPv6 addresses shall be returned\
    \ only if an IPv6 address is\n   configured on the local system.  The loopback\
    \ address is not\n   considered for this case as valid as a configured address.\n\
    \      For example, when using the DNS, a query for AAAA records should\n    \
    \  occur only if the node has at least one IPv6 address configured\n      (other\
    \ than IPv6 loopback) and a query for A records should occur\n      only if the\
    \ node has at least one IPv4 address configured (other\n      than the IPv4 loopback).\n\
    \   The ai_socktype field to which argument hints points specifies the\n   socket\
    \ type for the service, as defined for socket().  If a specific\n   socket type\
    \ is not given (for example, a value of zero) and the\n   service name could be\
    \ interpreted as valid with multiple supported\n   socket types, the implementation\
    \ shall attempt to resolve the service\n   name for all supported socket types\
    \ and, in the absence of errors,\n   all possible results shall be returned. \
    \ A non-zero socket type value\n   shall limit the returned information to values\
    \ with the specified\n   socket type.\n   If the ai_family field to which hints\
    \ points has the value AF_UNSPEC,\n   addresses shall be returned for use with\
    \ any address family that can\n   be used with the specified nodename and/or servname.\
    \  Otherwise,\n   addresses shall be returned for use only with the specified\
    \ address\n   family.  If ai_family is not AF_UNSPEC and ai_protocol is not zero,\n\
    \   then addresses are returned for use only with the specified address\n   family\
    \ and protocol; the value of ai_protocol shall be interpreted as\n   in a call\
    \ to the socket() function with the corresponding values of\n   ai_family and\
    \ ai_protocol.\n   The freeaddrinfo() function frees one or more addrinfo structures\n\
    \   returned by getaddrinfo(), along with any additional storage\n   associated\
    \ with those structures (for example, storage pointed to by\n   the ai_canonname\
    \ and ai_addr fields; an application must not\n   reference this storage after\
    \ the associated addrinfo structure has\n   been freed).  If the ai_next field\
    \ of the structure is not null, the\n   entire list of structures is freed.  The\
    \ freeaddrinfo() function must\n   support the freeing of arbitrary sublists of\
    \ an addrinfo list\n   originally returned by getaddrinfo().\n   Functions getaddrinfo()\
    \ and freeaddrinfo() must be thread-safe.\n   A zero return value for getaddrinfo()\
    \ indicates successful\n   completion; a non-zero return value indicates failure.\
    \  The possible\n   values for the failures are listed below under Error Return\
    \ Values.\n   Upon successful return of getaddrinfo(), the location to which res\n\
    \   points shall refer to a linked list of addrinfo structures, each of\n   which\
    \ shall specify a socket address and information for use in\n   creating a socket\
    \ with which to use that socket address.  The list\n   shall include at least\
    \ one addrinfo structure.  The ai_next field of\n   each structure contains a\
    \ pointer to the next structure on the list,\n   or a null pointer if it is the\
    \ last structure on the list.  Each\n   structure on the list shall include values\
    \ for use with a call to the\n   socket() function, and a socket address for use\
    \ with the connect()\n   function or, if the AI_PASSIVE flag was specified, for\
    \ use with the\n   bind() function.  The fields ai_family, ai_socktype, and ai_protocol\n\
    \   shall be usable as the arguments to the socket() function to create a\n  \
    \ socket suitable for use with the returned address.  The fields\n   ai_addr and\
    \ ai_addrlen are usable as the arguments to the connect()\n   or bind() functions\
    \ with such a socket, according to the AI_PASSIVE\n   flag.\n   If nodename is\
    \ not null, and if requested by the AI_CANONNAME flag,\n   the ai_canonname field\
    \ of the first returned addrinfo structure shall\n   point to a null-terminated\
    \ string containing the canonical name\n   corresponding to the input nodename;\
    \ if the canonical name is not\n   available, then ai_canonname shall refer to\
    \ the nodename argument or\n   a string with the same contents.  The contents\
    \ of the ai_flags field\n   of the returned structures are undefined.\n   All\
    \ fields in socket address structures returned by getaddrinfo()\n   that are not\
    \ filled in through an explicit argument (for example,\n   sin6_flowinfo) shall\
    \ be set to zero.\n   Note: This makes it easier to compare socket address structures.\n\
    \   Error Return Values:\n   The getaddrinfo() function shall fail and return\
    \ the corresponding\n   value if:\n   [EAI_AGAIN]     The name could not be resolved\
    \ at this time.  Future\n                   attempts may succeed.\n   [EAI_BADFLAGS]\
    \  The flags parameter had an invalid value.\n   [EAI_FAIL]      A non-recoverable\
    \ error occurred when attempting to\n                   resolve the name.\n  \
    \ [EAI_FAMILY]    The address family was not recognized.\n   [EAI_MEMORY]    There\
    \ was a memory allocation failure when trying to\n                   allocate\
    \ storage for the return value.\n   [EAI_NONAME]    The name does not resolve\
    \ for the supplied\n                   parameters.  Neither nodename nor servname\
    \ were\n                   supplied.  At least one of these must be supplied.\n\
    \   [EAI_SERVICE]   The service passed was not recognized for the\n          \
    \         specified socket type.\n   [EAI_SOCKTYPE]  The intended socket type\
    \ was not recognized.\n   [EAI_SYSTEM]    A system error occurred; the error code\
    \ can be found\n                   in errno.\n   The gai_strerror() function provides\
    \ a descriptive text string\n   corresponding to an EAI_xxx error value.\n   \
    \   #include <netdb.h>\n      const char *gai_strerror(int ecode);\n   The argument\
    \ is one of the EAI_xxx values defined for the\n   getaddrinfo() and getnameinfo()\
    \ functions.  The return value points\n   to a string describing the error.  If\
    \ the argument is not one of the\n   EAI_xxx values, the function still returns\
    \ a pointer to a string\n   whose contents indicate an unknown error.\n"
- title: 6.2 Socket Address Structure to Node Name and Service Name
  contents:
  - "6.2 Socket Address Structure to Node Name and Service Name\n   The getnameinfo()\
    \ function is used to translate the contents of a\n   socket address structure\
    \ to a node name and/or service name.\n   #include <sys/socket.h>\n   #include\
    \ <netdb.h>\n   int getnameinfo(const struct sockaddr *sa, socklen_t salen,\n\
    \                       char *node, socklen_t nodelen,\n                     \
    \  char *service, socklen_t servicelen,\n                         int flags);\n\
    \   The getnameinfo() function shall translate a socket address to a node\n  \
    \ name and service location, all of which are defined as in\n   getaddrinfo().\n\
    \   The sa argument points to a socket address structure to be\n   translated.\n\
    \   The salen argument holds the size of the socket address structure\n   pointed\
    \ to by sa.\n   If the socket address structure contains an IPv4-mapped IPv6 address\n\
    \   or an IPv4-compatible IPv6 address, the implementation shall extract\n   the\
    \ embedded IPv4 address and lookup the node name for that IPv4\n   address.\n\
    \      Note: The IPv6 unspecified address (\"::\") and the IPv6 loopback\n   \
    \   address (\"::1\") are not IPv4-compatible addresses.  If the address\n   \
    \   is the IPv6 unspecified address (\"::\"), a lookup is not performed,\n   \
    \   and the [EAI_NONAME] error is returned.\n   If the node argument is non-NULL\
    \ and the nodelen argument is nonzero,\n   then the node argument points to a\
    \ buffer able to contain up to\n   nodelen characters that receives the node name\
    \ as a null-terminated\n   string.  If the node argument is NULL or the nodelen\
    \ argument is\n   zero, the node name shall not be returned.  If the node's name\
    \ cannot\n   be located, the numeric form of the node's address is returned\n\
    \   instead of its name.\n   If the service argument is non-NULL and the servicelen\
    \ argument is\n   non-zero, then the service argument points to a buffer able\
    \ to\n   contain up to servicelen bytes that receives the service name as a\n\
    \   null-terminated string.  If the service argument is NULL or the\n   servicelen\
    \ argument is zero, the service name shall not be returned.\n   If the service's\
    \ name cannot be located, the numeric form of the\n   service address (for example,\
    \ its port number) shall be returned\n   instead of its name.\n   The arguments\
    \ node and service cannot both be NULL.\n   The flags argument is a flag that\
    \ changes the default actions of the\n   function.  By default the fully-qualified\
    \ domain name (FQDN) for the\n   host shall be returned, but:\n   -  If the flag\
    \ bit NI_NOFQDN is set, only the node name portion of\n      the FQDN shall be\
    \ returned for local hosts.\n   -  If the flag bit NI_NUMERICHOST is set, the\
    \ numeric form of the\n      host's address shall be returned instead of its name,\
    \ under all\n      circumstances.\n   -  If the flag bit NI_NAMEREQD is set, an\
    \ error shall be returned if\n      the host's name cannot be located.\n   - \
    \ If the flag bit NI_NUMERICSERV is set, the numeric form of the\n      service\
    \ address shall be returned (for example, its port number)\n      instead of its\
    \ name, under all circumstances.\n   -  If the flag bit NI_DGRAM is set, this\
    \ indicates that the service\n      is a datagram service (SOCK_DGRAM).  The default\
    \ behavior shall\n      assume that the service is a stream service (SOCK_STREAM).\n\
    \   Note:\n   1. The NI_NUMERICxxx flags are required to support the \"-n\" flags\n\
    \      that many commands provide.\n   2. The NI_DGRAM flag is required for the\
    \ few AF_INET and AF_INET6\n      port numbers (for example, [512,514]) that represent\
    \ different\n      services for UDP and TCP.\n   The getnameinfo() function shall\
    \ be thread safe.\n   A zero return value for getnameinfo() indicates successful\n\
    \   completion; a non-zero return value indicates failure.\n   Upon successful\
    \ completion, getnameinfo() shall return the node and\n   service names, if requested,\
    \ in the buffers provided.  The returned\n   names are always null-terminated\
    \ strings.\n   Error Return Values:\n   The getnameinfo() function shall fail\
    \ and return the corresponding\n   value if:\n   [EAI_AGAIN]    The name could\
    \ not be resolved at this time.\n                  Future attempts may succeed.\n\
    \   [EAI_BADFLAGS] The flags had an invalid value.\n   [EAI_FAIL]     A non-recoverable\
    \ error occurred.\n   [EAI_FAMILY]   The address family was not recognized or\
    \ the address\n                  length was invalid for the specified family.\n\
    \   [EAI_MEMORY]   There was a memory allocation failure.\n   [EAI_NONAME]   The\
    \ name does not resolve for the supplied parameters.\n                  NI_NAMEREQD\
    \ is set and the host's name cannot be\n                  located, or both nodename\
    \ and servname were null.\n   [EAI_OVERFLOW] An argument buffer overflowed.\n\
    \   [EAI_SYSTEM]   A system error occurred.  The error code can be found\n   \
    \               in errno.\n"
- title: 6.3 Address Conversion Functions
  contents:
  - "6.3 Address Conversion Functions\n   The two IPv4 functions inet_addr() and inet_ntoa()\
    \ convert an IPv4\n   address between binary and text form.  IPv6 applications\
    \ need similar\n   functions.  The following two functions convert both IPv6 and\
    \ IPv4\n   addresses:\n   #include <arpa/inet.h>\n   int inet_pton(int af, const\
    \ char *src, void *dst);\n   const char *inet_ntop(int af, const void *src,\n\
    \                            char *dst, socklen_t size);\n   The inet_pton() function\
    \ shall convert an address in its standard\n   text presentation form into its\
    \ numeric binary form.  The af argument\n   shall specify the family of the address.\
    \  The AF_INET and AF_INET6\n   address families shall be supported.  The src\
    \ argument points to the\n   string being passed in.  The dst argument points\
    \ to a buffer into\n   which the function stores the numeric address; this shall\
    \ be large\n   enough to hold the numeric address (32 bits for AF_INET, 128 bits\
    \ for\n   AF_INET6).  The inet_pton() function shall return 1 if the conversion\n\
    \   succeeds, with the address pointed to by dst in network byte order.\n   It\
    \ shall return 0 if the input is not a valid IPv4 dotted-decimal\n   string or\
    \ a valid IPv6 address string, or -1 with errno set to\n   EAFNOSUPPORT if the\
    \ af argument is unknown.\n   If the af argument of inet_pton() is AF_INET, the\
    \ src string shall be\n   in the standard IPv4 dotted-decimal form:\n      ddd.ddd.ddd.ddd\n\
    \   where \"ddd\" is a one to three digit decimal number between 0 and 255.\n\
    \   The inet_pton() function does not accept other formats (such as the\n   octal\
    \ numbers, hexadecimal numbers, and fewer than four numbers that\n   inet_addr()\
    \ accepts).\n   If the af argument of inet_pton() is AF_INET6, the src string\
    \ shall\n   be in one of the standard IPv6 text forms defined in Section 2.2 of\n\
    \   the addressing architecture specification [2].\n   The inet_ntop() function\
    \ shall convert a numeric address into a text\n   string suitable for presentation.\
    \  The af argument shall specify the\n   family of the address.  This can be AF_INET\
    \ or AF_INET6.  The src\n   argument points to a buffer holding an IPv4 address\
    \ if the af\n   argument is AF_INET, or an IPv6 address if the af argument is\n\
    \   AF_INET6; the address must be in network byte order.  The dst\n   argument\
    \ points to a buffer where the function stores the resulting\n   text string;\
    \ it shall not be NULL.  The size argument specifies the\n   size of this buffer,\
    \ which shall be large enough to hold the text\n   string (INET_ADDRSTRLEN characters\
    \ for IPv4, INET6_ADDRSTRLEN\n   characters for IPv6).\n   In order to allow applications\
    \ to easily declare buffers of the\n   proper size to store IPv4 and IPv6 addresses\
    \ in string form, the\n   following two constants are defined in <netinet/in.h>:\n\
    \      #define INET_ADDRSTRLEN    16\n      #define INET6_ADDRSTRLEN   46\n  \
    \ The inet_ntop() function shall return a pointer to the buffer\n   containing\
    \ the text string if the conversion succeeds, and NULL\n   otherwise.  Upon failure,\
    \ errno is set to EAFNOSUPPORT if the af\n   argument is invalid or ENOSPC if\
    \ the size of the result buffer is\n   inadequate.\n"
- title: 6.4 Address Testing Macros
  contents:
  - "6.4 Address Testing Macros\n   The following macros can be used to test for special\
    \ IPv6 addresses.\n   #include <netinet/in.h>\n   int  IN6_IS_ADDR_UNSPECIFIED\
    \ (const struct in6_addr *);\n   int  IN6_IS_ADDR_LOOPBACK    (const struct in6_addr\
    \ *);\n   int  IN6_IS_ADDR_MULTICAST   (const struct in6_addr *);\n   int  IN6_IS_ADDR_LINKLOCAL\
    \   (const struct in6_addr *);\n   int  IN6_IS_ADDR_SITELOCAL   (const struct\
    \ in6_addr *);\n   int  IN6_IS_ADDR_V4MAPPED    (const struct in6_addr *);\n \
    \  int  IN6_IS_ADDR_V4COMPAT    (const struct in6_addr *);\n   int  IN6_IS_ADDR_MC_NODELOCAL(const\
    \ struct in6_addr *);\n   int  IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr\
    \ *);\n   int  IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);\n   int  IN6_IS_ADDR_MC_ORGLOCAL\
    \ (const struct in6_addr *);\n   int  IN6_IS_ADDR_MC_GLOBAL   (const struct in6_addr\
    \ *);\n   The first seven macros return true if the address is of the specified\n\
    \   type, or false otherwise.  The last five test the scope of a\n   multicast\
    \ address and return true if the address is a multicast\n   address of the specified\
    \ scope or false if the address is either not\n   a multicast address or not of\
    \ the specified scope.\n   Note that IN6_IS_ADDR_LINKLOCAL and IN6_IS_ADDR_SITELOCAL\
    \ return true\n   only for the two types of local-use IPv6 unicast addresses (Link-\n\
    \   Local and Site-Local) defined in [2], and that by this definition,\n   the\
    \ IN6_IS_ADDR_LINKLOCAL macro returns false for the IPv6 loopback\n   address\
    \ (::1).  These two macros do not return true for IPv6\n   multicast addresses\
    \ of either link-local scope or site-local scope.\n"
- title: 7. Summary of New Definitions
  contents:
  - "7. Summary of New Definitions\n   The following list summarizes the constants,\
    \ structure, and extern\n   definitions discussed in this memo, sorted by header.\n"
- title: <net/if.h>      IF_NAMESIZE
  contents:
  - '<net/if.h>      IF_NAMESIZE

    '
- title: <net/if.h>      struct if_nameindex{};
  contents:
  - '<net/if.h>      struct if_nameindex{};

    '
- title: <netdb.h>       AI_ADDRCONFIG
  contents:
  - '<netdb.h>       AI_ADDRCONFIG

    '
- title: <netdb.h>       AI_ALL
  contents:
  - '<netdb.h>       AI_ALL

    '
- title: <netdb.h>       AI_CANONNAME
  contents:
  - '<netdb.h>       AI_CANONNAME

    '
- title: <netdb.h>       AI_NUMERICHOST
  contents:
  - '<netdb.h>       AI_NUMERICHOST

    '
- title: <netdb.h>       AI_NUMERICSERV
  contents:
  - '<netdb.h>       AI_NUMERICSERV

    '
- title: <netdb.h>       AI_PASSIVE
  contents:
  - '<netdb.h>       AI_PASSIVE

    '
- title: <netdb.h>       AI_V4MAPPED
  contents:
  - '<netdb.h>       AI_V4MAPPED

    '
- title: <netdb.h>       EAI_AGAIN
  contents:
  - '<netdb.h>       EAI_AGAIN

    '
- title: <netdb.h>       EAI_BADFLAGS
  contents:
  - '<netdb.h>       EAI_BADFLAGS

    '
- title: <netdb.h>       EAI_FAIL
  contents:
  - '<netdb.h>       EAI_FAIL

    '
- title: <netdb.h>       EAI_FAMILY
  contents:
  - '<netdb.h>       EAI_FAMILY

    '
- title: <netdb.h>       EAI_MEMORY
  contents:
  - '<netdb.h>       EAI_MEMORY

    '
- title: <netdb.h>       EAI_NONAME
  contents:
  - '<netdb.h>       EAI_NONAME

    '
- title: <netdb.h>       EAI_OVERFLOW
  contents:
  - '<netdb.h>       EAI_OVERFLOW

    '
- title: <netdb.h>       EAI_SERVICE
  contents:
  - '<netdb.h>       EAI_SERVICE

    '
- title: <netdb.h>       EAI_SOCKTYPE
  contents:
  - '<netdb.h>       EAI_SOCKTYPE

    '
- title: <netdb.h>       EAI_SYSTEM
  contents:
  - '<netdb.h>       EAI_SYSTEM

    '
- title: <netdb.h>       NI_DGRAM
  contents:
  - '<netdb.h>       NI_DGRAM

    '
- title: <netdb.h>       NI_NAMEREQD
  contents:
  - '<netdb.h>       NI_NAMEREQD

    '
- title: <netdb.h>       NI_NOFQDN
  contents:
  - '<netdb.h>       NI_NOFQDN

    '
- title: <netdb.h>       NI_NUMERICHOST
  contents:
  - '<netdb.h>       NI_NUMERICHOST

    '
- title: <netdb.h>       NI_NUMERICSERV
  contents:
  - '<netdb.h>       NI_NUMERICSERV

    '
- title: <netdb.h>       struct addrinfo{};
  contents:
  - '<netdb.h>       struct addrinfo{};

    '
- title: <netinet/in.h>  IN6ADDR_ANY_INIT
  contents:
  - '<netinet/in.h>  IN6ADDR_ANY_INIT

    '
- title: <netinet/in.h>  IN6ADDR_LOOPBACK_INIT
  contents:
  - '<netinet/in.h>  IN6ADDR_LOOPBACK_INIT

    '
- title: <netinet/in.h>  INET6_ADDRSTRLEN
  contents:
  - '<netinet/in.h>  INET6_ADDRSTRLEN

    '
- title: <netinet/in.h>  INET_ADDRSTRLEN
  contents:
  - '<netinet/in.h>  INET_ADDRSTRLEN

    '
- title: <netinet/in.h>  IPPROTO_IPV6
  contents:
  - '<netinet/in.h>  IPPROTO_IPV6

    '
- title: <netinet/in.h>  IPV6_JOIN_GROUP
  contents:
  - '<netinet/in.h>  IPV6_JOIN_GROUP

    '
- title: <netinet/in.h>  IPV6_LEAVE_GROUP
  contents:
  - '<netinet/in.h>  IPV6_LEAVE_GROUP

    '
- title: <netinet/in.h>  IPV6_MULTICAST_HOPS
  contents:
  - '<netinet/in.h>  IPV6_MULTICAST_HOPS

    '
- title: <netinet/in.h>  IPV6_MULTICAST_IF
  contents:
  - '<netinet/in.h>  IPV6_MULTICAST_IF

    '
- title: <netinet/in.h>  IPV6_MULTICAST_LOOP
  contents:
  - '<netinet/in.h>  IPV6_MULTICAST_LOOP

    '
- title: <netinet/in.h>  IPV6_UNICAST_HOPS
  contents:
  - '<netinet/in.h>  IPV6_UNICAST_HOPS

    '
- title: <netinet/in.h>  IPV6_V6ONLY
  contents:
  - '<netinet/in.h>  IPV6_V6ONLY

    '
- title: <netinet/in.h>  SIN6_LEN
  contents:
  - '<netinet/in.h>  SIN6_LEN

    '
- title: <netinet/in.h>  extern const struct in6_addr in6addr_any;
  contents:
  - '<netinet/in.h>  extern const struct in6_addr in6addr_any;

    '
- title: <netinet/in.h>  extern const struct in6_addr in6addr_loopback;
  contents:
  - '<netinet/in.h>  extern const struct in6_addr in6addr_loopback;

    '
- title: <netinet/in.h>  struct in6_addr{};
  contents:
  - '<netinet/in.h>  struct in6_addr{};

    '
- title: <netinet/in.h>  struct ipv6_mreq{};
  contents:
  - '<netinet/in.h>  struct ipv6_mreq{};

    '
- title: <netinet/in.h>  struct sockaddr_in6{};
  contents:
  - '<netinet/in.h>  struct sockaddr_in6{};

    '
- title: <sys/socket.h>  AF_INET6
  contents:
  - '<sys/socket.h>  AF_INET6

    '
- title: <sys/socket.h>  PF_INET6
  contents:
  - '<sys/socket.h>  PF_INET6

    '
- title: <sys/socket.h>  struct sockaddr_storage;
  contents:
  - "<sys/socket.h>  struct sockaddr_storage;\n   The following list summarizes the\
    \ function and macro prototypes\n   discussed in this memo, sorted by header.\n"
- title: <arpa/inet.h>   int inet_pton(int, const char *, void *);
  contents:
  - '<arpa/inet.h>   int inet_pton(int, const char *, void *);

    '
- title: <arpa/inet.h>   const char *inet_ntop(int, const void *,
  contents:
  - "<arpa/inet.h>   const char *inet_ntop(int, const void *,\n                  \
    \             char *, socklen_t);\n"
- title: <net/if.h>      char *if_indextoname(unsigned int, char *);
  contents:
  - '<net/if.h>      char *if_indextoname(unsigned int, char *);

    '
- title: <net/if.h>      unsigned int if_nametoindex(const char *);
  contents:
  - '<net/if.h>      unsigned int if_nametoindex(const char *);

    '
- title: <net/if.h>      void if_freenameindex(struct if_nameindex *);
  contents:
  - '<net/if.h>      void if_freenameindex(struct if_nameindex *);

    '
- title: <net/if.h>      struct if_nameindex *if_nameindex(void);
  contents:
  - '<net/if.h>      struct if_nameindex *if_nameindex(void);

    '
- title: <netdb.h>       int getaddrinfo(const char *, const char *,
  contents:
  - "<netdb.h>       int getaddrinfo(const char *, const char *,\n               \
    \                 const struct addrinfo *,\n                                struct\
    \ addrinfo **);\n"
- title: <netdb.h>       int getnameinfo(const struct sockaddr *, socklen_t,
  contents:
  - "<netdb.h>       int getnameinfo(const struct sockaddr *, socklen_t,\n       \
    \           char *, socklen_t, char *, socklen_t, int);\n"
- title: <netdb.h>       void freeaddrinfo(struct addrinfo *);
  contents:
  - '<netdb.h>       void freeaddrinfo(struct addrinfo *);

    '
- title: <netdb.h>       const char *gai_strerror(int);
  contents:
  - '<netdb.h>       const char *gai_strerror(int);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_LINKLOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_LINKLOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_LOOPBACK(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_LOOPBACK(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MC_GLOBAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MC_GLOBAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MC_ORGLOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MC_ORGLOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_MULTICAST(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_MULTICAST(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_SITELOCAL(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_SITELOCAL(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_UNSPECIFIED(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_UNSPECIFIED(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_V4COMPAT(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_V4COMPAT(const struct in6_addr *);

    '
- title: <netinet/in.h>  int IN6_IS_ADDR_V4MAPPED(const struct in6_addr *);
  contents:
  - '<netinet/in.h>  int IN6_IS_ADDR_V4MAPPED(const struct in6_addr *);

    '
- title: 8. Security Considerations
  contents:
  - "8. Security Considerations\n   IPv6 provides a number of new security mechanisms,\
    \ many of which need\n   to be accessible to applications.  Companion memos detailing\
    \ the\n   extensions to the socket interfaces to support IPv6 security are\n \
    \  being written.\n"
- title: 9. Changes from RFC 2553
  contents:
  - "9. Changes from RFC 2553\n   1. Add brief description of the history of this\
    \ API and its relation\n      to the Open Group/IEEE/ISO standards.\n   2. Alignments\
    \ with [3].\n   3. Removed all references to getipnodebyname() and getipnodebyaddr(),\n\
    \      which are deprecated in favor of getaddrinfo() and getnameinfo().\n   4.\
    \ Added IPV6_V6ONLY IP level socket option to permit nodes to not\n      process\
    \ IPv4 packets as IPv4 Mapped addresses in implementations.\n   5. Added SIIT\
    \ to references and added new contributors.\n   6. In previous versions of this\
    \ specification, the sin6_flowinfo\n      field was associated with the IPv6 traffic\
    \ class and flow label,\n      but its usage was not completely specified.  The\
    \ complete\n      definition of the sin6_flowinfo field, including its association\n\
    \      with the traffic class or flow label, is now deferred to a future\n   \
    \   specification.\n"
- title: 10. Acknowledgments
  contents:
  - "10. Acknowledgments\n   This specification's evolution and completeness were\
    \ significantly\n   influenced by the efforts of Richard Stevens, who has passed\
    \ on.\n   Richard's wisdom and talent made the specification what it is today.\n\
    \   The co-authors will long think of Richard with great respect.\n   Thanks to\
    \ the many people who made suggestions and provided feedback\n   to this document,\
    \ including:\n   Werner Almesberger, Ran Atkinson, Fred Baker, Dave Borman, Andrew\n\
    \   Cherenson, Alex Conta, Alan Cox, Steve Deering, Richard Draves,\n   Francis\
    \ Dupont, Robert Elz, Brian Haberman, Jun-ichiro itojun Hagino,\n   Marc Hasson,\
    \ Tom Herbert, Bob Hinden, Wan-Yen Hsu, Christian Huitema,\n   Koji Imada, Markus\
    \ Jork, Ron Lee, Alan Lloyd, Charles Lynn, Dan\n   McDonald, Dave Mitton, Finnbarr\
    \ Murphy, Thomas Narten, Josh Osborne,\n   Craig Partridge, Jean-Luc Richier,\
    \ Bill Sommerfield, Erik Scoredos,\n   Keith Sklower, JINMEI Tatuya, Dave Thaler,\
    \ Matt Thomas, Harvey\n   Thompson, Dean D. Throop, Karen Tracey, Glenn Trewitt,\
    \ Paul Vixie,\n   David Waitzman, Carl Williams, Kazu Yamamoto, Vlad Yasevich,\
    \ Stig\n   Venaas, and Brian Zill.\n   The getaddrinfo() and getnameinfo() functions\
    \ are taken from an\n   earlier document by Keith Sklower.  As noted in that document,\n\
    \   William Durst, Steven Wise, Michael Karels, and Eric Allman provided\n   many\
    \ useful discussions on the subject of protocol-independent name-\n   to-address\
    \ translation, and reviewed early versions of Keith\n   Sklower's original proposal.\
    \  Eric Allman implemented the first\n   prototype of getaddrinfo().  The observation\
    \ that specifying the pair\n   of name and service would suffice for connecting\
    \ to a service\n   independent of protocol details was made by Marshall Rose in\
    \ a\n   proposal to X/Open for a \"Uniform Network Interface\".\n   Craig Metz,\
    \ Jack McCann, Erik Nordmark, Tim Hartrick, and Mukesh\n   Kacker made many contributions\
    \ to this document.  Ramesh Govindan\n   made a number of contributions and co-authored\
    \ an earlier version of\n   this memo.\n"
- title: 11. References
  contents:
  - "11. References\n   [1]  Deering, S. and R. Hinden, \"Internet Protocol, Version\
    \ 6 (IPv6)\n        Specification\", RFC 2460, December 1998.\n   [2]  Hinden,\
    \ R. and S. Deering, \"IP Version 6 Addressing\n        Architecture\", RFC 2373,\
    \ July 1998.\n   [3]  IEEE Std. 1003.1-2001 Standard for Information Technology\
    \ --\n        Portable Operating System Interface (POSIX). Open Group\n      \
    \  Technical Standard: Base Specifications, Issue 6, December 2001.\n        ISO/IEC\
    \ 9945:2002.  http://www.opengroup.org/austin\n   [4]  Stevens, W. and M. Thomas,\
    \ \"Advanced Sockets API for IPv6\", RFC\n        2292, February 1998.\n   [5]\
    \  Nordmark, E., \"Stateless IP/ICMP Translation Algorithm (SIIT)\",\n       \
    \ RFC 2765, February 2000.\n   [6]  The Open Group Base Working Group\n      \
    \  http://www.opengroup.org/platform/base.html\n"
- title: 12. Authors' Addresses
  contents:
  - "12. Authors' Addresses\n   Bob Gilligan\n   Intransa, Inc.\n   2870 Zanker Rd.\n\
    \   San Jose, CA 95134\n   Phone: 408-678-8647\n   EMail: gilligan@intransa.com\n\
    \   Susan Thomson\n   Cisco Systems\n   499 Thornall Street, 8th floor\n   Edison,\
    \ NJ 08837\n   Phone: 732-635-3086\n   EMail:  sethomso@cisco.com\n   Jim Bound\n\
    \   Hewlett-Packard Company\n   110 Spitbrook Road ZKO3-3/W20\n   Nashua, NH 03062\n\
    \   Phone: 603-884-0062\n   EMail: Jim.Bound@hp.com\n   Jack McCann\n   Hewlett-Packard\
    \ Company\n   110 Spitbrook Road ZKO3-3/W20\n   Nashua, NH 03062\n   Phone: 603-884-2608\n\
    \   EMail: Jack.McCann@hp.com\n"
- title: 13. Full Copyright Statement
  contents:
  - "13. Full Copyright Statement\n   Copyright (C) The Internet Society (2003). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
