- contents:
  - '             A One-way Active Measurement Protocol (OWAMP)

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   The One-Way Active Measurement Protocol (OWAMP) measures\n   unidirectional
    characteristics such as one-way delay and one-way\n   loss.  High-precision measurement
    of these one-way IP performance\n   metrics became possible with wider availability
    of good time sources\n   (such as GPS and CDMA).  OWAMP enables the interoperability
    of these\n   measurements.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n
    \     1.1. Relationship of Test and Control Protocols .................3\n      1.2.
    Logical Model ..............................................4\n   2. Protocol
    Overview ...............................................5\n   3. OWAMP-Control
    ...................................................6\n      3.1. Connection Setup
    ...........................................6\n      3.2. Integrity Protection
    (HMAC) ...............................11\n      3.3. Values of the Accept Field
    ................................11\n      3.4. OWAMP-Control Commands ....................................12\n
    \     3.5. Creating Test Sessions ....................................13\n      3.6.
    Send Schedules ............................................18\n      3.7. Starting
    Test Sessions ....................................19\n      3.8. Stop-Sessions
    .............................................20\n      3.9. Fetch-Session .............................................24\n
    \  4. OWAMP-Test .....................................................27\n      4.1.
    Sender Behavior ...........................................28\n           4.1.1.
    Packet Timings .....................................28\n           4.1.2. OWAMP-Test
    Packet Format and Content ...............29\n      4.2. Receiver Behavior .........................................33\n
    \  5. Computing Exponentially Distributed Pseudo-Random Numbers ......35\n      5.1.
    High-Level Description of the Algorithm ...................35\n      5.2. Data
    Types, Representation, and Arithmetic ................36\n      5.3. Uniform Random
    Quantities .................................37\n   6. Security Considerations
    ........................................38\n      6.1. Introduction ..............................................38\n
    \     6.2. Preventing Third-Party Denial of Service ..................38\n      6.3.
    Covert Information Channels ...............................39\n      6.4. Requirement
    to Include AES in Implementations .............39\n      6.5. Resource Use Limitations
    ..................................39\n      6.6. Use of Cryptographic Primitives
    in OWAMP ..................40\n      6.7. Cryptographic Primitive Replacement
    .......................42\n      6.8. Long-term Manually Managed Keys ...........................43\n
    \     6.9. (Not) Using Time as Salt ..................................44\n      6.10.
    The Use of AES-CBC and HMAC ..............................44\n   7. Acknowledgements
    ...............................................45\n   8. IANA Considerations ............................................45\n
    \  9. Internationalization Considerations ............................46\n   10.
    References ....................................................46\n      10.1.
    Normative References .....................................46\n      10.2. Informative
    References ...................................47\n   Appendix A: Sample C Code
    for Exponential Deviates ................49\n   Appendix B: Test Vectors for Exponential
    Deviates .................54\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The IETF IP Performance Metrics (IPPM) working group has
    defined\n   metrics for one-way packet delay [RFC2679] and loss [RFC2680] across\n
    \  Internet paths.  Although there are now several measurement platforms\n   that
    implement collection of these metrics [SURVEYOR] [SURVEYOR-INET]\n   [RIPE] [BRIX],
    there is not currently a standard that would permit\n   initiation of test streams
    or exchange of packets to collect\n   singleton metrics in an interoperable manner.\n
    \  With the increasingly wide availability of affordable global\n   positioning
    systems (GPS) and CDMA-based time sources, hosts\n   increasingly have available
    to them very accurate time sources,\n   either directly or through their proximity
    to Network Time Protocol\n   (NTP) primary (stratum 1) time servers.  By standardizing
    a technique\n   for collecting IPPM one-way active measurements, we hope to create
    an\n   environment where IPPM metrics may be collected across a far broader\n
    \  mesh of Internet paths than is currently possible.  One particularly\n   compelling
    vision is of widespread deployment of open OWAMP servers\n   that would make measurement
    of one-way delay as commonplace as\n   measurement of round-trip time using an
    ICMP-based tool like ping.\n   Additional design goals of OWAMP include: being
    hard to detect and\n   manipulate, security, logical separation of control and
    test\n   functionality, and support for small test packets.  (Being hard to\n
    \  detect makes interference with measurements more difficult for\n   intermediaries
    in the middle of the network.)\n   OWAMP test traffic is hard to detect because
    it is simply a stream of\n   UDP packets from and to negotiated port numbers,
    with potentially\n   nothing static in the packets (size is negotiated, as well).
    \ OWAMP\n   also supports an encrypted mode that further obscures the traffic
    and\n   makes it impossible to alter timestamps undetectably.\n   Security features
    include optional authentication and/or encryption\n   of control and test messages.
    \ These features may be useful to\n   prevent unauthorized access to results or
    man-in-the-middle attacks\n   that attempt to provide special treatment to OWAMP
    test streams or\n   that attempt to modify sender-generated timestamps to falsify
    test\n   results.\n   In this document, the key words \"MUST\", \"REQUIRED\",
    \"SHOULD\",\n   \"RECOMMENDED\", and \"MAY\" are to be interpreted as described
    in\n   [RFC2119].\n"
  - contents:
    - "1.1.  Relationship of Test and Control Protocols\n   OWAMP actually consists
      of two inter-related protocols: OWAMP-Control\n   and OWAMP-Test.  OWAMP-Control
      is used to initiate, start, and stop\n   test sessions and to fetch their results,
      whereas OWAMP-Test is used\n   to exchange test packets between two measurement
      nodes.\n   Although OWAMP-Test may be used in conjunction with a control\n   protocol
      other than OWAMP-Control, the authors have deliberately\n   chosen to include
      both protocols in the same RFC to encourage the\n   implementation and deployment
      of OWAMP-Control as a common\n   denominator control protocol for one-way active
      measurements.  Having\n   a complete and open one-way active measurement solution
      that is\n   simple to implement and deploy is crucial to ensuring a future in\n
      \  which inter-domain one-way active measurement could become as\n   commonplace
      as ping.  We neither anticipate nor recommend that\n   OWAMP-Control form the
      foundation of a general-purpose extensible\n   measurement and monitoring control
      protocol.\n   OWAMP-Control is designed to support the negotiation of one-way\n
      \  active measurement sessions and results retrieval in a\n   straightforward
      manner.  At session initiation, there is a\n   negotiation of sender and receiver
      addresses and port numbers,\n   session start time, session length, test packet
      size, the mean\n   Poisson sampling interval for the test stream, and some attributes
      of\n   the very general [RFC 2330] notion of packet type, including packet\n
      \  size and per-hop behavior (PHB) [RFC2474], which could be used to\n   support
      the measurement of one-way network characteristics across\n   differentiated
      services networks.  Additionally, OWAMP-Control\n   supports per-session encryption
      and authentication for both test and\n   control traffic, measurement servers
      that can act as proxies for test\n   stream endpoints, and the exchange of a
      seed value for the pseudo-\n   random Poisson process that describes the test
      stream generated by\n   the sender.\n   We believe that OWAMP-Control can effectively
      support one-way active\n   measurement in a variety of environments, from publicly
      accessible\n   measurement beacons running on arbitrary hosts to network monitoring\n
      \  deployments within private corporate networks.  If integration with\n   Simple
      Network Management Protocol (SNMP) or proprietary network\n   management protocols
      is required, gateways may be created.\n"
    title: 1.1.  Relationship of Test and Control Protocols
  - contents:
    - "1.2.  Logical Model\n   Several roles are logically separated to allow for
      broad flexibility\n   in use.  Specifically, we define the following:\n   Session-Sender
      \     The sending endpoint of an OWAMP-Test session;\n   Session-Receiver    The
      receiving endpoint of an OWAMP-Test session;\n   Server              An end
      system that manages one or more OWAMP-Test\n                       sessions,
      is capable of configuring per-session\n                       state in session
      endpoints, and is capable of\n                       returning the results of
      a test session;\n   Control-Client      An end system that initiates requests
      for\n                       OWAMP-Test sessions, triggers the start of a set\n
      \                      of sessions, and may trigger their termination;\n                       and\n
      \  Fetch-Client        An end system that initiates requests to fetch\n                       the
      results of completed OWAMP-Test sessions.\n   One possible scenario of relationships
      between these roles is shown\n   below.\n       +----------------+               +------------------+\n
      \      | Session-Sender |--OWAMP-Test-->| Session-Receiver |\n       +----------------+
      \              +------------------+\n         ^                                     ^\n
      \        |                                     |\n         |                                     |\n
      \        |                                     |\n         |  +----------------+<----------------+\n
      \        |  |     Server     |<-------+\n         |  +----------------+        |\n
      \        |    ^                       |\n         |    |                       |\n
      \        | OWAMP-Control         OWAMP-Control\n         |    |                       |\n
      \        v    v                       v\n       +----------------+     +-----------------+\n
      \      | Control-Client |     |   Fetch-Client  |\n       +----------------+
      \    +-----------------+\n   (Unlabeled links in the figure are unspecified
      by this document and\n   may be proprietary protocols.)\n   Different logical
      roles can be played by the same host.  For example,\n   in the figure above,
      there could actually be only two hosts: one\n   playing the roles of Control-Client,
      Fetch-Client, and Session-\n   Sender, and the other playing the roles of Server
      and Session-\n   Receiver.  This is shown below.\n       +-----------------+
      \                  +------------------+\n       | Control-Client  |<--OWAMP-Control-->|
      Server           |\n       | Fetch-Client    |                   |                  |\n
      \      | Session-Sender  |---OWAMP-Test----->| Session-Receiver |\n       +-----------------+
      \                  +------------------+\n   Finally, because many Internet paths
      include segments that transport\n   IP over ATM, delay and loss measurements
      can include the effects of\n   ATM segmentation and reassembly (SAR).  Consequently,
      OWAMP has been\n   designed to allow for small test packets that would fit inside
      the\n   payload of a single ATM cell (this is only achieved in\n   unauthenticated
      mode).\n"
    title: 1.2.  Logical Model
  title: 1.  Introduction
- contents:
  - "2.  Protocol Overview\n   As described above, OWAMP consists of two inter-related
    protocols:\n   OWAMP-Control and OWAMP-Test.  The former is layered over TCP and
    is\n   used to initiate and control measurement sessions and to fetch their\n
    \  results.  The latter protocol is layered over UDP and is used to send\n   singleton
    measurement packets along the Internet path under test.\n   The initiator of the
    measurement session establishes a TCP connection\n   to a well-known port, 861,
    on the target point and this connection\n   remains open for the duration of the
    OWAMP-Test sessions.  An OWAMP\n   server SHOULD listen to this well-known port.\n
    \  OWAMP-Control messages are transmitted only before OWAMP-Test\n   sessions
    are actually started and after they are completed (with the\n   possible exception
    of an early Stop-Sessions message).\n   The OWAMP-Control and OWAMP-Test protocols
    support three modes of\n   operation: unauthenticated, authenticated, and encrypted.
    \ The\n   authenticated or encrypted modes require that endpoints possess a\n
    \  shared secret.\n   All multi-octet quantities defined in this document are
    represented\n   as unsigned integers in network byte order unless specified\n
    \  otherwise.\n"
  title: 2.  Protocol Overview
- contents:
  - "3.  OWAMP-Control\n   The type of each OWAMP-Control message can be found after
    reading the\n   first 16 octets.  The length of each OWAMP-Control message can
    be\n   computed upon reading its fixed-size part.  No message is shorter\n   than
    16 octets.\n   An implementation SHOULD expunge unused state to prevent denial-of-\n
    \  service attacks, or unbounded memory usage, on the server.  For\n   example,
    if the full control message is not received within some\n   number of minutes
    after it is expected, the TCP connection associated\n   with the OWAMP-Control
    session SHOULD be dropped.  In absence of\n   other considerations, 30 minutes
    seems like a reasonable upper bound.\n"
  - contents:
    - "3.1.  Connection Setup\n   Before either a Control-Client or a Fetch-Client
      can issue commands\n   to a Server, it has to establish a connection to the
      server.\n   First, a client opens a TCP connection to the server on a well-known\n
      \  port 861.  The server responds with a server greeting:\n      0                   1
      \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                     Unused (12 octets)                       |\n     |                                                               |\n
      \    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
      \                           Modes                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                    Challenge (16 octets)                     |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                       Salt (16 octets)                       |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                        Count (4 octets)                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                       MBZ (12 octets)                        |\n     |                                                               |\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The
      following Mode values are meaningful: 1 for unauthenticated, 2\n   for authenticated,
      and 4 for encrypted.  The value of the Modes field\n   sent by the server is
      the bit-wise OR of the mode values that it is\n   willing to support during
      this session.  Thus, the last three bits of\n   the Modes 32-bit value are used.
      \ The first 29 bits MUST be zero.  A\n   client MUST ignore the values in the
      first 29 bits of the Modes\n   value.  (This way, the bits are available for
      future protocol\n   extensions.  This is the only intended extension mechanism.)\n
      \  Challenge is a random sequence of octets generated by the server; it\n   is
      used subsequently by the client to prove possession of a shared\n   secret in
      a manner prescribed below.\n   Salt and Count are parameters used in deriving
      a key from a shared\n   secret as described below.\n   Salt MUST be generated
      pseudo-randomly (independently of anything\n   else in this document).\n   Count
      MUST be a power of 2.  Count MUST be at least 1024.  Count\n   SHOULD be increased
      as more computing power becomes common.\n   If the Modes value is zero, the
      server does not wish to communicate\n   with the client and MAY close the connection
      immediately.  The client\n   SHOULD close the connection if it receives a greeting
      with Modes\n   equal to zero.  The client MAY close the connection if the client's\n
      \  desired mode is unavailable.\n   Otherwise, the client MUST respond with
      the following Set-Up-Response\n   message:\n      0                   1                   2
      \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                             Mode                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     .
      \                                                              .\n     .                       KeyID
      (80 octets)                       .\n     .                                                               .\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     .
      \                                                              .\n     .                       Token
      (64 octets)                       .\n     .                                                               .\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     .
      \                                                              .\n     .                     Client-IV
      (16 octets)                     .\n     .                                                               .\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Here Mode is the mode that the client chooses to use during this\n   OWAMP-Control
      session.  It will also be used for all OWAMP-Test\n   sessions started under
      control of this OWAMP-Control session.  In\n   Mode, one or zero bits MUST be
      set within last three bits.  If it is\n   one bit that is set within the last
      three bits, this bit MUST\n   indicate a mode that the server agreed to use
      (i.e., the same bit\n   MUST have been set by the server in the server greeting).
      \ The first\n   29 bits of Mode MUST be zero.  A server MUST ignore the values
      of the\n   first 29 bits.  If zero Mode bits are set by the client, the client\n
      \  indicates that it will not continue with the session; in this case,\n   the
      client and the server SHOULD close the TCP connection associated\n   with the
      OWAMP-Control session.\n   In unauthenticated mode, KeyID, Token, and Client-IV
      are unused.\n   Otherwise, KeyID is a UTF-8 string, up to 80 octets in length
      (if the\n   string is shorter, it is padded with zero octets), that tells the\n
      \  server which shared secret the client wishes to use to authenticate\n   or
      encrypt, while Token is the concatenation of a 16-octet challenge,\n   a 16-octet
      AES Session-key used for encryption, and a 32-octet HMAC-\n   SHA1 Session-key
      used for authentication.  The token itself is\n   encrypted using the AES (Advanced
      Encryption Standard) [AES] in\n   Cipher Block Chaining (CBC). Encryption MUST
      be performed using an\n   Initialization Vector (IV) of zero and a key derived
      from the shared\n   secret associated with KeyID.  (Both the server and the
      client use\n   the same mappings from KeyIDs to shared secrets.  The server,
      being\n   prepared to conduct sessions with more than one client, uses KeyIDs\n
      \  to choose the appropriate secret key; a client would typically have\n   different
      secret keys for different servers.  The situation is\n   analogous to that with
      passwords.)\n   The shared secret is a passphrase; it MUST not contain newlines.
      \ The\n   secret key is derived from the passphrase using a password-based key\n
      \  derivation function PBKDF2 (PKCS #5) [RFC2898].  The PBKDF2 function\n   requires
      several parameters: the PRF is HMAC-SHA1 [RFC2104]; the salt\n   and count are
      as transmitted by the server.\n   AES Session-key, HMAC Session-key and Client-IV
      are generated\n   randomly by the client.  AES Session-key and HMAC Session-key
      MUST be\n   generated with sufficient entropy not to reduce the security of
      the\n   underlying cipher [RFC4086].  Client-IV merely needs to be unique\n
      \  (i.e., it MUST never be repeated for different sessions using the\n   same
      secret key; a simple way to achieve that without the use of\n   cumbersome state
      is to generate the Client-IV values using a\n   cryptographically secure pseudo-random
      number source:  if this is\n   done, the first repetition is unlikely to occur
      before 2^64 sessions\n   with the same secret key are conducted).\n   The server
      MUST respond with the following Server-Start message:\n      0                   1
      \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                        MBZ (15 octets)                       |\n     |                                                               |\n
      \    |                                               +-+-+-+-+-+-+-+-+\n     |
      \                                              |   Accept      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                    Server-IV (16 octets)                     |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                     Start-Time (Timestamp)                    |\n     |
      \                                                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                         MBZ (8 octets)                        |\n     |
      \                                                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The MBZ parts MUST be zero.  The client MUST ignore their value.  MBZ\n   (MUST
      be zero) fields here and after have the same semantics: the\n   party that sends
      the message MUST set the field so that all bits are\n   equal to zero; the party
      that interprets the message MUST ignore the\n   value.  (This way, the field
      could be used for future extensions.)\n   Server-IV is generated randomly by
      the server.  In unauthenticated\n   mode, Server-IV is unused.\n   The Accept
      field indicates the server's willingness to continue\n   communication.  A zero
      value in the Accept field means that the\n   server accepts the authentication
      and is willing to conduct further\n   transactions.  Non-zero values indicate
      that the server does not\n   accept the authentication or, for some other reason,
      is not willing\n   to conduct further transactions in this OWAMP-Control session.
      \ The\n   full list of available Accept values is described in Section 3.3,\n
      \  \"Values of the Accept Field\".\n   If a negative (non-zero) response is
      sent, the server MAY (and the\n   client SHOULD) close the connection after
      this message.\n   Start-Time is a timestamp representing the time when the current\n
      \  instantiation of the server started operating.  (For example, in a\n   multi-user
      general purpose operating system, it could be the time\n   when the server process
      was started.)  If Accept is non-zero, Start-\n   Time SHOULD be set so that
      all of its bits are zeros.  In\n   authenticated and encrypted modes, Start-Time
      is encrypted as\n   described in Section 3.4, \"OWAMP-Control Commands\", unless
      Accept is\n   non-zero.  (Authenticated and encrypted mode cannot be entered
      unless\n   the control connection can be initialized.)\n   Timestamp format
      is described in Section 4.1.2.  The same\n   instantiation of the server SHOULD
      report the same exact Start-Time\n   value to each client in each session.\n
      \  The previous transactions constitute connection setup.\n"
    title: 3.1.  Connection Setup
  - contents:
    - "3.2.  Integrity Protection (HMAC)\n   Authentication of each message (also
      referred to as a command in this\n   document) in OWAMP-Control is accomplished
      by adding an HMAC to it.\n   The HMAC that OWAMP uses is HMAC-SHA1 truncated
      to 128 bits.  Thus,\n   all HMAC fields are 16 octets.  An HMAC needs a key.
      \ The HMAC\n   Session-key is communicated along with the AES Session-key during\n
      \  OWAMP-Control connection setup.  The HMAC Session-key SHOULD be\n   derived
      independently of the AES Session-key (an implementation, of\n   course, MAY
      use the same mechanism to generate the random bits for\n   both keys).  Each
      HMAC sent covers everything sent in a given\n   direction between the previous
      HMAC (but not including it) and up to\n   the beginning of the new HMAC.  This
      way, once encryption is set up,\n   each bit of the OWAMP-Control connection
      is authenticated by an HMAC\n   exactly once.\n   When encrypting, authentication
      happens before encryption, so HMAC\n   blocks are encrypted along with the rest
      of the stream.  When\n   decrypting, the order, of course, is reversed: first
      one decrypts,\n   then one checks the HMAC, then one proceeds to use the data.\n
      \  The HMAC MUST be checked as early as possible to avoid using and\n   propagating
      corrupt data.\n   In open mode, the HMAC fields are unused and have the same
      semantics\n   as MBZ fields.\n"
    title: 3.2.  Integrity Protection (HMAC)
  - contents:
    - "3.3.  Values of the Accept Field\n   Accept values are used throughout the
      OWAMP-Control protocol to\n   communicate the server response to client requests.
      \ The full set of\n   valid Accept field values are as follows:\n     0    OK.\n
      \    1    Failure, reason unspecified (catch-all).\n     2    Internal error.\n
      \    3    Some aspect of request is not supported.\n     4    Cannot perform
      request due to permanent resource limitations.\n     5    Cannot perform request
      due to temporary resource limitations.\n   All other values are reserved.  The
      sender of the message MAY use the\n   value of 1 for all non-zero Accept values.
      \ A message sender SHOULD\n   use the correct Accept value if it is going to
      use other values.  The\n   message receiver MUST interpret all values of Accept
      other than these\n   reserved values as 1.  This way, other values are available
      for\n   future extensions.\n"
    title: 3.3.  Values of the Accept Field
  - contents:
    - "3.4.  OWAMP-Control Commands\n   In authenticated or encrypted mode (which
      are identical as far as\n   OWAMP-Control is concerned, and only differ in OWAMP-Test),
      all\n   further communications are encrypted with the AES Session-key (using\n
      \  CBC mode) and authenticated with HMAC Session-key.  The client\n   encrypts
      everything it sends through the just-established OWAMP-\n   Control connection
      using stream encryption with Client-IV as the IV.\n   Correspondingly, the server
      encrypts its side of the connection using\n   Server-IV as the IV.\n   The IVs
      themselves are transmitted in cleartext.  Encryption starts\n   with the block
      immediately following the block containing the IV.\n   The two streams (one
      going from the client to the server and one\n   going back) are encrypted independently,
      each with its own IV, but\n   using the same key (the AES Session-key).\n   The
      following commands are available for the client: Request-Session,\n   Start-Sessions,
      Stop-Sessions, and Fetch-Session.  The command Stop-\n   Sessions is available
      to both the client and the server.  (The server\n   can also send other messages
      in response to commands it receives.)\n   After the client sends the Start-Sessions
      command and until it both\n   sends and receives (in an unspecified order) the
      Stop-Sessions\n   command, it is said to be conducting active measurements.
      \ Similarly,\n   the server is said to be conducting active measurements after
      it\n   receives the Start-Sessions command and until it both sends and\n   receives
      (in an unspecified order) the Stop-Sessions command.\n   While conducting active
      measurements, the only command available is\n   Stop-Sessions.\n   These commands
      are described in detail below.\n"
    title: 3.4.  OWAMP-Control Commands
  - contents:
    - "3.5.  Creating Test Sessions\n   Individual one-way active measurement sessions
      are established using\n   a simple request/response protocol.  An OWAMP client
      MAY issue zero\n   or more Request-Session messages to an OWAMP server, which
      MUST\n   respond to each with an Accept-Session message.  An Accept-Session\n
      \  message MAY refuse a request.\n   The format of Request-Session message is
      as follows:\n      0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |      1        |  MBZ  | IPVN  |  Conf-Sender  | Conf-Receiver |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                  Number of Schedule Slots                     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                      Number of Packets                        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |          Sender Port          |         Receiver Port         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                        Sender Address                         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \          Sender Address (cont.) or MBZ (12 octets)           |\n     |                                                               |\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
      \                       Receiver Address                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \          Receiver Address (cont.) or MBZ (12 octets)         |\n     |                                                               |\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
      \                                                              |\n     |                        SID
      (16 octets)                        |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                         Padding Length                        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                           Start Time                          |\n     |
      \                                                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                       Timeout, (8 octets)                     |\n     |
      \                                                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                       Type-P Descriptor                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                         MBZ (8 octets)                        |\n     |
      \                                                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                      HMAC (16 octets)                        |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  This is immediately followed by one or more schedule slot\n   descriptions
      (the number of schedule slots is specified in the\n   \"Number of Schedule Slots\"
      field above):\n      0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |    Slot Type  |                                               |\n     +-+-+-+-+-+-+-+-+
      \        MBZ (7 octets)                        |\n     |                                                               |\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
      \                Slot Parameter (Timestamp)                    |\n     |                                                               |\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   These
      are immediately followed by HMAC:\n      0                   1                   2
      \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                      HMAC (16 octets)                        |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  All these messages constitute one logical message: the Request-\n   Session
      command.\n   Above, the first octet (1) indicates that this is the Request-Session\n
      \  command.\n   IPVN is the IP version numbers for Sender and Receiver.  When
      the IP\n   version number is 4, 12 octets follow the 4-octet IPv4 address stored\n
      \  in Sender Address and Receiver Address.  These octets MUST be set to\n   zero
      by the client and MUST be ignored by the server.  Currently\n   meaningful IPVN
      values are 4 and 6.\n   Conf-Sender and Conf-Receiver MUST be set to 0 or 1
      by the client.\n   The server MUST interpret any non-zero value as 1.  If the
      value is\n   1, the server is being asked to configure the corresponding agent\n
      \  (sender or receiver).  In this case, the corresponding Port value\n   SHOULD
      be disregarded by the server.  At least one of Conf-Sender and\n   Conf-Receiver
      MUST be 1.  (Both can be set, in which case the server\n   is being asked to
      perform a session between two hosts it can\n   configure.)\n   Number of Schedule
      Slots, as mentioned before, specifies the number\n   of slot records that go
      between the two blocks of HMAC.  It is used\n   by the sender to determine when
      to send test packets (see next\n   section).\n   Number of Packets is the number
      of active measurement packets to be\n   sent during this OWAMP-Test session
      (note that either the server or\n   the client can abort the session early).\n
      \  If Conf-Sender is not set, Sender Port is the UDP port from which\n   OWAMP-Test
      packets will be sent.  If Conf-Receiver is not set,\n   Receiver Port is the
      UDP port OWAMP-Test to which packets are\n   requested to be sent.\n   The Sender
      Address and Receiver Address fields contain, respectively,\n   the sender and
      receiver addresses of the end points of the Internet\n   path over which an
      OWAMP test session is requested.\n   SID is the session identifier.  It can
      be used in later sessions as\n   an argument for the Fetch-Session command.
      \ It is meaningful only if\n   Conf-Receiver is 0.  This way, the SID is always
      generated by the\n   receiving side.  See the end of the section for information
      on how\n   the SID is generated.\n   Padding length is the number of octets
      to be appended to the normal\n   OWAMP-Test packet (see more on padding in discussion
      of OWAMP-Test).\n   Start Time is the time when the session is to be started
      (but not\n   before Start-Sessions command is issued).  This timestamp is in
      the\n   same format as OWAMP-Test timestamps.\n   Timeout (or a loss threshold)
      is an interval of time (expressed as a\n   timestamp).  A packet belonging to
      the test session that is being set\n   up by the current Request-Session command
      will be considered lost if\n   it is not received during Timeout seconds after
      it is sent.\n   Type-P Descriptor covers only a subset of (very large) Type-P
      space.\n   If the first two bits of the Type-P Descriptor are 00, then the\n
      \  subsequent six bits specify the requested Differentiated Services\n   Codepoint
      (DSCP) value of sent OWAMP-Test packets, as defined in\n   [RFC2474].  If the
      first two bits of Type-P descriptor are 01, then\n   the subsequent 16 bits
      specify the requested PHB Identification Code\n   (PHB ID), as defined in [RFC2836].\n
      \  Therefore, the value of all zeros specifies the default best-effort\n   service.\n
      \  If Conf-Sender is set, the Type-P Descriptor is to be used to\n   configure
      the sender to send packets according to its value.  If\n   Conf-Sender is not
      set, the Type-P Descriptor is a declaration of how\n   the sender will be configured.\n
      \  If Conf-Sender is set and the server does not recognize the Type-P\n   Descriptor,
      or it cannot or does not wish to set the corresponding\n   attributes on OWAMP-Test
      packets, it SHOULD reject the session\n   request.  If Conf-Sender is not set,
      the server SHOULD accept or\n   reject the session, paying no attention to the
      value of the Type-P\n   Descriptor.\n   To each Request-Session message, an
      OWAMP server MUST respond with an\n   Accept-Session message:\n      0                   1
      \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |    Accept     |  MBZ          |            Port               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|\n
      \    |                                                               |\n     |
      \                       SID (16 octets)                        |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                       MBZ (12 octets)                        |\n     |                                                               |\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
      \                                                              |\n     |                       HMAC
      (16 octets)                        |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  In this message, zero in the Accept field means that the server is\n   willing
      to conduct the session.  A non-zero value indicates rejection\n   of the request.
      \ The full list of available Accept values is\n   described in Section 3.3,
      \"Values of the Accept Field\".\n   If the server rejects a Request-Session
      message, it SHOULD not close\n   the TCP connection.  The client MAY close it
      if it receives a\n   negative response to the Request-Session message.\n   The
      meaning of Port in the response depends on the values of Conf-\n   Sender and
      Conf-Receiver in the query that solicited the response.\n   If both were set,
      the Port field is unused.  If only Conf-Sender was\n   set, Port is the port
      from which to expect OWAMP-Test packets.  If\n   only Conf-Receiver was set,
      Port is the port to which OWAMP-Test\n   packets are sent.\n   If only Conf-Sender
      was set, the SID field in the response is unused.\n   Otherwise, SID is a unique
      server-generated session identifier.  It\n   can be used later as handle to
      fetch the results of a session.\n   SIDs SHOULD be constructed by concatenation
      of the 4-octet IPv4 IP\n   number belonging to the generating machine, an 8-octet
      timestamp, and\n   a 4-octet random value.  To reduce the probability of collisions,
      if\n   the generating machine has any IPv4 addresses (with the exception of\n
      \  loopback), one of them SHOULD be used for SID generation, even if all\n   communication
      is IPv6-based.  If it has no IPv4 addresses at all, the\n   last four octets
      of an IPv6 address MAY be used instead.  Note that\n   SID is always chosen
      by the receiver.  If truly random values are not\n   available, it is important
      that the SID be made unpredictable, as\n   knowledge of the SID might be used
      for access control.\n"
    title: 3.5.  Creating Test Sessions
  - contents:
    - "3.6.  Send Schedules\n   The sender and the receiver both need to know the
      same send schedule.\n   This way, when packets are lost, the receiver knows
      when they were\n   supposed to be sent.  It is desirable to compress common
      schedules\n   and still to be able to use an arbitrary one for the test sessions.\n
      \  In many cases, the schedule will consist of repeated sequences of\n   packets:
      this way, the sequence performs some test, and the test is\n   repeated a number
      of times to gather statistics.\n   To implement this, we have a schedule with
      a given number of slots.\n   Each slot has a type and a parameter.  Two types
      are supported:\n   exponentially distributed pseudo-random quantity (denoted
      by a code\n   of 0) and a fixed quantity (denoted by a code of 1).  The parameter\n
      \  is expressed as a timestamp and specifies a time interval.  For a\n   type
      0 slot (exponentially distributed pseudo-random quantity), this\n   interval
      is the mean value (or 1/lambda if the distribution density\n   function is expressed
      as lambda*exp(-lambda*x) for positive values of\n   x).  For a type 1 (fixed
      quantity) slot, the parameter is the delay\n   itself.  The sender starts with
      the beginning of the schedule and\n   executes the instructions in the slots:
      for a slot of type 0, wait an\n   exponentially distributed time with a mean
      of the specified parameter\n   and then send a test packet (and proceed to the
      next slot); for a\n   slot of type 1, wait the specified time and send a test
      packet (and\n   proceed to the next slot).  The schedule is circular: when there
      are\n   no more slots, the sender returns to the first slot.\n   The sender
      and the receiver need to be able to reproducibly execute\n   the entire schedule
      (so, if a packet is lost, the receiver can still\n   attach a send timestamp
      to it).  Slots of type 1 are trivial to\n   reproducibly execute.  To reproducibly
      execute slots of type 0, we\n   need to be able to generate pseudo-random exponentially
      distributed\n   quantities in a reproducible manner.  The way this is accomplished
      is\n   discussed later in Section 5, \"Computing Exponentially Distributed\n
      \  Pseudo-Random Numbers\".\n   Using this mechanism, one can easily specify
      common testing\n   scenarios.  The following are some examples:\n   +  Poisson
      stream: a single slot of type 0.\n   +  Periodic stream: a single slot of type
      1.\n   +  Poisson stream of back-to-back packet pairs: two slots, type 0\n      with
      a non-zero parameter and type 1 with a zero parameter.\n   Further, a completely
      arbitrary schedule can be specified (albeit\n   inefficiently) by making the
      number of test packets equal to the\n   number of schedule slots.  In this case,
      the complete schedule is\n   transmitted in advance of an OWAMP-Test session.\n"
    title: 3.6.  Send Schedules
  - contents:
    - "3.7.  Starting Test Sessions\n   Having requested one or more test sessions
      and received affirmative\n   Accept-Session responses, an OWAMP client MAY start
      the execution of\n   the requested test sessions by sending a Start-Sessions
      message to\n   the server.\n   The format of this message is as follows:\n      0
      \                  1                   2                   3\n      0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |      2        |                                               |\n     +-+-+-+-+-+-+-+-+
      \                                              |\n     |                        MBZ
      (15 octets)                        |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                      HMAC (16 octets)                        |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The server MUST respond with an Start-Ack message (which SHOULD be\n   sent
      as quickly as possible).  Start-Ack messages have the following\n   format:\n
      \     0                   1                   2                   3\n      0
      1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |     Accept    |                                               |\n     +-+-+-+-+-+-+-+-+
      \                                              |\n     |                        MBZ
      (15 octets)                        |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                      HMAC (16 octets)                        |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  If Accept is non-zero, the Start-Sessions request was rejected; zero\n   means
      that the command was accepted.  The full list of available\n   Accept values
      is described in Section 3.3, \"Values of the Accept\n   Field\".  The server
      MAY, and the client SHOULD, close the connection\n   in the case of a rejection.\n
      \  The server SHOULD start all OWAMP-Test streams immediately after it\n   sends
      the response or immediately after their specified start times,\n   whichever
      is later.  If the client represents a Sender, the client\n   SHOULD start its
      OWAMP-Test streams immediately after it sees the\n   Start-Ack response from
      the Server (if the Start-Sessions command was\n   accepted) or immediately after
      their specified start times, whichever\n   is later.  See more on OWAMP-Test
      sender behavior in a separate\n   section below.\n"
    title: 3.7.  Starting Test Sessions
  - contents:
    - "3.8.  Stop-Sessions\n   The Stop-Sessions message may be issued by either the
      Control-Client\n   or the Server.  The format of this command is as follows:\n
      \     0                   1                   2                   3\n      0
      1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |      3        |    Accept     |              MBZ              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                      Number of Sessions                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                        MBZ (8 octets)                         |\n     |
      \                                                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  This is immediately followed by zero or more session description\n   records
      (the number of session description records is specified in\n   the \"Number
      of Sessions\" field above).  The session description\n   record is used to indicate
      which packets were actually sent by the\n   sender process (rather than skipped).
      \ The header of the session\n   description record is as follows:\n      0                   1
      \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|\n
      \    |                                                               |\n     |
      \                       SID (16 octets)                        |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                           Next Seqno                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                     Number of Skip Ranges                     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  This is immediately followed by zero or more Skip Range descriptions\n   as
      specified by the \"Number of Skip Ranges\" field above.  Skip Ranges\n   are
      simply two sequence numbers that, together, indicate a range of\n   packets
      that were not sent:\n      0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|\n
      \    |                      First Seqno Skipped                      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                       Last Seqno Skipped                      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Skip Ranges MUST be in order.  The last (possibly full, possibly\n   incomplete)
      block (16 octets) of data MUST be padded with zeros, if\n   necessary.  This
      ensures that the next session description record\n   starts on a block boundary.\n
      \  Finally, a single block (16 octets) of HMAC is concatenated on the\n   end
      to complete the Stop-Sessions message.\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                      HMAC (16 octets)                        |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  All these records comprise one logical message: the Stop-Sessions\n   command.\n
      \  Above, the first octet (3) indicates that this is the Stop-Sessions\n   command.\n
      \  Non-zero Accept values indicate a failure of some sort.  Zero values\n   indicate
      normal (but possibly premature) completion.  The full list\n   of available
      Accept values is described in Section 3.3, \"Values of\n   the Accept Field\".\n
      \  If Accept had a non-zero value (from either party), results of all\n   OWAMP-Test
      sessions spawned by this OWAMP-Control session SHOULD be\n   considered invalid,
      even if a Fetch-Session with SID from this\n   session works for a different
      OWAMP-Control session.  If Accept was\n   not transmitted at all (for whatever
      reason, including the TCP\n   connection used for OWAMP-Control breaking), the
      results of all\n   OWAMP-Test sessions spawned by this OWAMP-control session
      MAY be\n   considered invalid.\n   Number of Sessions indicates the number of
      session description\n   records that immediately follow the Stop-Sessions header.\n
      \  Number of Sessions MUST contain the number of send sessions started\n   by
      the local side of the control connection that have not been\n   previously terminated
      by a Stop-Sessions command (i.e., the Control-\n   Client MUST account for each
      accepted Request-Session where Conf-\n   Receiver was set; the Control-Server
      MUST account for each accepted\n   Request-Session where Conf-Sender was set).
      \ If the Stop-Sessions\n   message does not account for exactly the send sessions
      controlled by\n   that side, then it is to be considered invalid and the connection\n
      \  SHOULD be closed and any results obtained considered invalid.\n   Each session
      description record represents one OWAMP-Test session.\n   SID is the session
      identifier (SID) used to indicate which send\n   session is being described.\n
      \  Next Seqno indicates the next sequence number that would have been\n   sent
      from this send session.  For completed sessions, this will equal\n   NumPackets
      from the Request-Session.\n   Number of Skip Ranges indicates the number of
      holes that actually\n   occurred in the sending process.  This is a range of
      packets that\n   were never actually sent by the sending process.  For example,
      if a\n   send session is started too late for the first 10 packets to be sent\n
      \  and this is the only hole in the schedule, then \"Number of Skip\n   Ranges\"
      would be 1.  The single Skip Range description will have\n   First Seqno Skipped
      equal to 0 and Last Seqno Skipped equal to 9.\n   This is described further
      in the \"Sender Behavior\" section.\n   If the OWAMP-Control connection breaks
      when the Stop-Sessions command\n   is sent, the receiver MAY not completely
      invalidate the session\n   results.  It MUST discard all record of packets that
      follow (in other\n   words, that have greater sequence number than) the last
      packet that\n   was actually received before any lost packet records.  This
      will help\n   differentiate between packet losses that occurred in the network
      and\n   packets the sending process may have never sent.\n   If a receiver of
      an OWAMP-Test session learns, through an OWAMP-\n   Control Stop-Sessions message,
      that the OWAMP-Test sender's last\n   sequence number is lower than any sequence
      number actually received,\n   the results of the complete OWAMP-Test session
      MUST be invalidated.\n   A receiver of an OWAMP-Test session, upon receipt of
      an OWAMP-Control\n   Stop-Sessions command, MUST discard any packet records
      -- including\n   lost packet records -- with a (computed) send time that falls
      between\n   the current time minus Timeout and the current time.  This ensures\n
      \  statistical consistency for the measurement of loss and duplicates in\n   the
      event that the Timeout is greater than the time it takes for the\n   Stop-Sessions
      command to take place.\n   To effect complete sessions, each side of the control
      connection\n   SHOULD wait until all sessions are complete before sending the
      Stop-\n   Sessions message.  The completed time of each session is determined\n
      \  as Timeout after the scheduled time for the last sequence number.\n   Endpoints
      MAY add a small increment to the computed completed time\n   for send endpoints
      to ensure that the Stop-Sessions message reaches\n   the receiver endpoint after
      Timeout.\n   To effect a premature stop of sessions, the party that initiates
      this\n   command MUST stop its OWAMP-Test send streams to send the Session\n
      \  Packets Sent values before sending this command.  That party SHOULD\n   wait
      until receiving the response Stop-Sessions message before\n   stopping the receiver
      streams so that it can use the values from the\n   received Stop-Sessions message
      to validate the data.\n"
    title: 3.8.  Stop-Sessions
  - contents:
    - "3.9.  Fetch-Session\n   The format of this client command is as follows:\n
      \     0                   1                   2                   3\n      0
      1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |      4        |                                               |\n     +-+-+-+-+-+-+-+-+
      \                                              |\n     |                        MBZ
      (7 octets)                         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                         Begin Seq                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                          End Seq                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                       SID (16 octets)                        |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                      HMAC (16 octets)                        |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Begin Seq is the sequence number of the first requested packet.  End\n   Seq
      is the sequence number of the last requested packet.  If Begin\n   Seq is all
      zeros and End Seq is all ones, complete session is said to\n   be requested.\n
      \  If a complete session is requested and the session is still in\n   progress
      or has terminated in any way other than normally, the\n   request to fetch session
      results MUST be denied.  If an incomplete\n   session is requested, all packets
      received so far that fall into the\n   requested range SHOULD be returned.  Note
      that, since no commands can\n   be issued between Start-Sessions and Stop-Sessions,
      incomplete\n   requests can only happen on a different OWAMP-Control connection\n
      \  (from the same or different host as Control-Client).\n   The server MUST
      respond with a Fetch-Ack message.  The format of this\n   server response is
      as follows:\n      0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |     Accept    | Finished      |          MBZ (2 octets)       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                           Next Seqno                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                    Number of Skip Ranges                      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                       Number of Records                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     |
      \                      HMAC (16 octets)                        |\n     |                                                               |\n
      \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Again, non-zero in the Accept field means a rejection of command.\n   The
      server MUST specify zero for all remaining fields if Accept is\n   non-zero.
      \ The client MUST ignore all remaining fields (except for\n   the HMAC) if Accept
      is non-zero.  The full list of available Accept\n   values is described in Section
      3.3, \"Values of the Accept Field\".\n   Finished is non-zero if the OWAMP-Test
      session has terminated.\n   Next Seqno indicates the next sequence number that
      would have been\n   sent from this send session.  For completed sessions, this
      will equal\n   NumPackets from the Request-Session.  This information is only\n
      \  available if the session has terminated.  If Finished is zero, then\n   Next
      Seqno MUST be set to zero by the server.\n   Number of Skip Ranges indicates
      the number of holes that actually\n   occurred in the sending process.  This
      information is only available\n   if the session has terminated.  If Finished
      is zero, then Skip Ranges\n   MUST be set to zero by the server.\n   Number
      of Records is the number of packet records that fall within\n   the requested
      range.  This number might be less than the Number of\n   Packets in the reproduction
      of the Request-Session command because of\n   a session that ended prematurely,
      or it might be greater because of\n   duplicates.\n   If Accept was non-zero,
      this concludes the response to the Fetch-\n   Session message.  If Accept was
      0, the server then MUST immediately\n   send the OWAMP-Test session data in
      question.\n   The OWAMP-Test session data consists of the following (concatenated):\n
      \  +  A reproduction of the Request-Session command that was used to\n      start
      the session; it is modified so that actual sender and\n      receiver port numbers
      that were used by the OWAMP-Test session\n      always appear in the reproduction.\n
      \  +  Zero or more (as specified) Skip Range descriptions.  The last\n      (possibly
      full, possibly incomplete) block (16 octets) of Skip\n      Range descriptions
      is padded with zeros, if necessary.\n   +  16 octets of HMAC.\n   +  Zero or
      more (as specified) packet records.  The last (possibly\n      full, possibly
      incomplete) block (16 octets) of data is padded\n      with zeros, if necessary.\n
      \  +  16 octets of HMAC.\n   Skip Range descriptions are simply two sequence
      numbers that,\n   together, indicate a range of packets that were not sent:\n
      \     0                   1                   2                   3\n      0
      1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|\n
      \    |                      First Seqno Skipped                      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                       Last Seqno Skipped                      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Skip Range descriptions should be sent out in order, as sorted by\n   First
      Seqno.  If any Skip Ranges overlap or are out of order, the\n   session data
      is to be considered invalid and the connection SHOULD be\n   closed and any
      results obtained considered invalid.\n   Each packet record is 25 octets and
      includes 4 octets of sequence\n   number, 8 octets of send timestamp, 2 octets
      of send timestamp error\n   estimate, 8 octets of receive timestamp, 2 octets
      of receive\n   timestamp error estimate, and 1 octet of Time To Live (TTL),
      or Hop\n   Limit in IPv6:\n        0                   1                   2
      \                  3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
      3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    00|                          Seq Number                           |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    04|      Send Error Estimate      |    Receive Error Estimate     |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    08|                         Send Timestamp                        |\n     12|
      \                                                              |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    16|                       Receive Timestamp                       |\n     20|
      \                                                              |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    24|    TTL        |\n       +-+-+-+-+-+-+-+-+\n   Packet records are sent
      out in the same order the actual packets were\n   received.  Therefore, the
      data is in arrival order.\n   Note that lost packets (if any losses were detected
      during the\n   OWAMP-Test session) MUST appear in the sequence of packets.  They
      can\n   appear either at the point when the loss was detected or at any later\n
      \  point.  Lost packet records are distinguished as follows:\n   +  A send timestamp
      filled with the presumed send time (as computed\n      by the send schedule).\n
      \  +  A send error estimate filled with Multiplier=1, Scale=64, and S=0\n      (see
      the OWAMP-Test description for definition of these quantities\n      and explanation
      of timestamp format and error estimate format).\n   +  A normal receive error
      estimate as determined by the error of the\n      clock being used to declare
      the packet lost.  (It is declared lost\n      if it is not received by the Timeout
      after the presumed send time,\n      as determined by the receiver's clock.)\n
      \  +  A receive timestamp consisting of all zero bits.\n   +  A TTL value of
      255.\n"
    title: 3.9.  Fetch-Session
  title: 3.  OWAMP-Control
- contents:
  - "4.  OWAMP-Test\n   This section describes OWAMP-Test protocol.  It runs over
    UDP, using\n   sender and receiver IP and port numbers negotiated during the\n
    \  Request-Session exchange.\n   As with OWAMP-Control, OWAMP-Test has three modes:
    unauthenticated,\n   authenticated, and encrypted.  All OWAMP-Test sessions that
    are\n   spawned by an OWAMP-Control session inherit its mode.\n   OWAMP-Control
    client, OWAMP-Control server, OWAMP-Test sender, and\n   OWAMP-Test receiver can
    potentially all be different machines.  (In a\n   typical case, we expect that
    there will be only two machines.)\n"
  - contents:
    - '4.1.  Sender Behavior

      '
    - contents:
      - "4.1.1.  Packet Timings\n   Send schedules based on slots, described previously,
        in conjunction\n   with scheduled session start time, enable the sender and
        the receiver\n   to compute the same exact packet sending schedule independently
        of\n   each other.  These sending schedules are independent for different\n
        \  OWAMP-Test sessions, even if they are governed by the same OWAMP-\n   Control
        session.\n   Consider any OWAMP-Test session.  Once Start-Sessions exchange
        is\n   complete, the sender is ready to start sending packets.  Under normal\n
        \  OWAMP use circumstances, the time to send the first packet is in the\n
        \  near future (perhaps a fraction of a second away).  The sender SHOULD\n
        \  send packets as close as possible to their scheduled time, with the\n   following
        exception: if the scheduled time to send is in the past,\n   and is separated
        from the present by more than Timeout time, the\n   sender MUST NOT send the
        packet.  (Indeed, such a packet would be\n   considered lost by the receiver
        anyway.)  The sender MUST keep track\n   of which packets it does not send.
        \ It will use this to tell the\n   receiver what packets were not sent by
        setting Skip Ranges in the\n   Stop-Sessions message from the sender to the
        receiver upon completion\n   of the test.  The Skip Ranges are also sent to
        a Fetch-Client as part\n   of the session data results.  These holes in the
        sending schedule can\n   happen if a time in the past was specified in the
        Request-Session\n   command, or if the Start-Sessions exchange took unexpectedly
        long, or\n   if the sender could not start serving the OWAMP-Test session
        on time\n   due to internal scheduling problems of the OS.  Packets that are
        in\n   the past but are separated from the present by less than Timeout\n
        \  value SHOULD be sent as quickly as possible.  With normal test rates\n
        \  and timeout values, the number of packets in such a burst is limited.\n
        \  Nevertheless, hosts SHOULD NOT intentionally schedule sessions so\n   that
        such bursts of packets occur.\n   Regardless of any scheduling delays, each
        packet that is actually\n   sent MUST have the best possible approximation
        of its real time of\n   departure as its timestamp (in the packet).\n"
      title: 4.1.1.  Packet Timings
    - contents:
      - "4.1.2.  OWAMP-Test Packet Format and Content\n   The sender sends the receiver
        a stream of packets with the schedule\n   specified in the Request-Session
        command.  The sender SHOULD set the\n   TTL in IPv4 (or Hop Limit in IPv6)
        in the UDP packet to 255.  The\n   format of the body of a UDP packet in the
        stream depends on the mode\n   being used.\n   For unauthenticated mode:\n
        \     0                   1                   2                   3\n      0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                        Sequence Number                        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                          Timestamp                            |\n     |
        \                                                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |        Error Estimate         |                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        \                              |\n     |                                                               |\n
        \    .                                                               .\n     .
        \                        Packet Padding                        .\n     .                                                               .\n
        \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  For authenticated and encrypted modes:\n      0                   1                   2
        \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                        Sequence Number                        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                                                               |\n     |
        \                       MBZ (12 octets)                        |\n     |                                                               |\n
        \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
        \                         Timestamp                            |\n     |                                                               |\n
        \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
        \       Error Estimate         |                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        \                              |\n     |                         MBZ (6 octets)
        \                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                                                               |\n     |
        \                      HMAC (16 octets)                        |\n     |                                                               |\n
        \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                                                               |\n     .
        \                                                              .\n     .                        Packet
        Padding                         .\n     .                                                               .\n
        \    |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  The format of the timestamp is the same as in [RFC1305] and is as\n   follows:
        the first 32 bits represent the unsigned integer number of\n   seconds elapsed
        since 0h on 1 January 1900; the next 32 bits\n   represent the fractional
        part of a second that has elapsed since\n   then.\n   So, Timestamp is represented
        as follows:\n      0                   1                   2                   3\n
        \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                   Integer part of seconds                     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                 Fractional part of seconds                    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  The Error Estimate specifies the estimate of the error and\n   synchronization.
        \ It has the following format:\n         0                   1\n         0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \       |S|Z|   Scale   |   Multiplier  |\n        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  The first bit, S, SHOULD be set if the party generating the timestamp\n
        \  has a clock that is synchronized to UTC using an external source\n   (e.g.,
        the bit should be set if GPS hardware is used and it indicates\n   that it
        has acquired current position and time or if NTP is used and\n   it indicates
        that it has synchronized to an external source, which\n   includes stratum
        0 source, etc.).  If there is no notion of external\n   synchronization for
        the time source, the bit SHOULD NOT be set.  The\n   next bit has the same
        semantics as MBZ fields elsewhere: it MUST be\n   set to zero by the sender
        and ignored by everyone else.  The next six\n   bits, Scale, form an unsigned
        integer; Multiplier is an unsigned\n   integer as well.  They are interpreted
        as follows: the error estimate\n   is equal to Multiplier*2^(-32)*2^Scale
        (in seconds).  (Notation\n   clarification: 2^Scale is two to the power of
        Scale.)  Multiplier\n   MUST NOT be set to zero.  If Multiplier is zero, the
        packet SHOULD be\n   considered corrupt and discarded.\n   Sequence numbers
        start with zero and are incremented by one for each\n   subsequent packet.\n
        \  The minimum data segment length is, therefore, 14 octets in\n   unauthenticated
        mode, and 48 octets in both authenticated mode and\n   encrypted modes.\n
        \  The OWAMP-Test packet layout is the same in authenticated and\n   encrypted
        modes.  The encryption and authentication operations are,\n   however, different.
        \ The difference is that in encrypted mode both\n   the sequence number and
        the timestamp are protected to provide\n   maximum data confidentiality and
        integrity protection, whereas in\n   authenticated mode the sequence number
        is protected while the\n   timestamp is sent in clear text.  Sending the timestamp
        in clear text\n   in authenticated mode allows one to reduce the time between
        when a\n   timestamp is obtained by a sender and when the packet is shipped
        out.\n   In encrypted mode, the sender has to fetch the timestamp, encrypt
        it,\n   and send it; in authenticated mode, the middle step is removed,\n
        \  potentially improving accuracy (the sequence number can be encrypted\n
        \  and authenticated before the timestamp is fetched).\n   In authenticated
        mode, the first block (16 octets) of each packet is\n   encrypted using AES
        Electronic Cookbook (ECB) mode.\n   Similarly to each OWAMP-Control session,
        each OWAMP-Test session has\n   two keys: an AES Session-key and an HMAC Session-key.
        \ However, there\n   is a difference in how the keys are obtained: in the
        case of OWAMP-\n   Control, the keys are generated by the client and communicated
        (as\n   part of the Token) during connection setup as part of Set-Up-Response\n
        \  message; in the case of OWAMP-Test, described here, the keys are\n   derived
        from the OWAMP-Control keys and the SID.\n   The OWAMP-Test AES Session-key
        is obtained as follows: the OWAMP-\n   Control AES Session-key (the same AES
        Session-key as is used for the\n   corresponding OWAMP-Control session, where
        it is used in a different\n   chaining mode) is encrypted, using AES, with
        the 16-octet session\n   identifier (SID) as the key; this is a single-block
        ECB encryption;\n   its result is the OWAMP-Test AES Session-key to use in
        encrypting\n   (and decrypting) the packets of the particular OWAMP-Test session.\n
        \  Note that all of OWAMP-Test AES Session-key, OWAMP-Control AES\n   Session-key,
        and the SID are comprised of 16 octets.\n   The OWAMP-Test HMAC Session-key
        is obtained as follows: the OWAMP-\n   Control HMAC Session-key (the same
        HMAC Session-key as is used for\n   the corresponding OWAMP-Control session)
        is encrypted, using AES,\n   with the 16-octet session identifier (SID) as
        the key; this is a\n   two-block CBC encryption, always performed with IV=0;
        its result is\n   the OWAMP-Test HMAC Session-key to use in authenticating
        the packets\n   of the particular OWAMP-Test session.  Note that all of OWAMP-Test\n
        \  HMAC Session-key and OWAMP-Control HMAC Session-key are comprised of\n
        \  32 octets, while the SID is 16 octets.\n   ECB mode used for encrypting
        the first block of OWAMP-Test packets in\n   authenticated mode does not involve
        any actual chaining; this way,\n   lost, duplicated, or reordered packets
        do not cause problems with\n   deciphering any packet in an OWAMP-Test session.\n
        \  In encrypted mode, the first two blocks (32 octets) are encrypted\n   using
        AES CBC mode.  The AES Session-key to use is obtained in the\n   same way
        as the key for authenticated mode.  Each OWAMP-Test packet\n   is encrypted
        as a separate stream, with just one chaining operation;\n   chaining does
        not span multiple packets so that lost, duplicated, or\n   reordered packets
        do not cause problems.  The initialization vector\n   for the CBC encryption
        is a value with all bits equal to zero.\n   Implementation note: Naturally,
        the key schedule for each OWAMP-Test\n   session MAY be set up only once per
        session, not once per packet.\n   HMAC in OWAMP-Test only covers the part
        of the packet that is also\n   encrypted.  So, in authenticated mode, HMAC
        covers the first block\n   (16 octets); in encrypted mode, HMAC covers two
        first blocks (32\n   octets).  In OWAMP-Test HMAC is not encrypted (note that
        this is\n   different from OWAMP-Control, where encryption in stream mode
        is\n   used, so everything including the HMAC blocks ends up being\n   encrypted).\n
        \  In unauthenticated mode, no encryption or authentication is applied.\n
        \  Packet Padding in OWAMP-Test SHOULD be pseudo-random (it MUST be\n   generated
        independently of any other pseudo-random numbers mentioned\n   in this document).
        \ However, implementations MUST provide a\n   configuration parameter, an
        option, or a different means of making\n   Packet Padding consist of all zeros.\n
        \  The time elapsed between packets is computed according to the slot\n   schedule
        as mentioned in Request-Session command description.  At\n   that point, we
        skipped over the issue of computing exponentially\n   distributed pseudo-random
        numbers in a reproducible fashion.  It is\n   discussed later in a separate
        section.\n"
      title: 4.1.2.  OWAMP-Test Packet Format and Content
    title: 4.1.  Sender Behavior
  - contents:
    - "4.2.  Receiver Behavior\n   The receiver knows when the sender will send packets.
      \ The following\n   parameter is defined: Timeout (from Request-Session).  Packets
      that\n   are delayed by more than Timeout are considered lost (or \"as good
      as\n   lost\").  Note that there is never an actual assurance of loss by the\n
      \  network: a \"lost\" packet might still be delivered at any time.  The\n   original
      specification for IPv4 required that packets be delivered\n   within TTL seconds
      or never (with TTL having a maximum value of 255).\n   To the best of the authors'
      knowledge, this requirement was never\n   actually implemented (and, of course,
      only a complete and universal\n   implementation would ensure that packets do
      not travel for longer\n   than TTL seconds).  In fact, in IPv6, the name of
      this field has\n   actually been changed to Hop Limit.  Further, IPv4 specification\n
      \  makes no claims about the time it takes the packet to traverse the\n   last
      link of the path.\n   The choice of a reasonable value of Timeout is a problem
      faced by a\n   user of OWAMP protocol, not by an implementor.  A value such
      as two\n   minutes is very safe.  Note that certain applications (such as\n
      \  interactive \"one-way ping\" might wish to obtain the data faster than\n
      \  that.\n   As packets are received,\n   +  timestamp the received packet;\n
      \  +  in authenticated or encrypted mode, decrypt and authenticate as\n      necessary
      (packets for which authentication fails MUST be\n      discarded); and\n   +
      \ store the packet sequence number, send time, receive time, and the\n      TTL
      for IPv4 (or Hop Limit for IPv6) from the packet IP header for\n      the results
      to be transferred.\n   Packets not received within the Timeout are considered
      lost.  They\n   are recorded with their true sequence number, presumed send
      time,\n   receive time value with all bits being zero, and a TTL (or Hop Limit)\n
      \  of 255.\n   Implementations SHOULD fetch the TTL/Hop Limit value from the
      IP\n   header of the packet.  If an implementation does not fetch the actual\n
      \  TTL value (the only good reason not to do so is an inability to\n   access
      the TTL field of arriving packets), it MUST record the TTL\n   value as 255.\n
      \  Packets that are actually received are recorded in the order of\n   arrival.
      \ Lost packet records serve as indications of the send times\n   of lost packets.
      \ They SHOULD be placed either at the point where the\n   receiver learns about
      the loss or at any later point; in particular,\n   one MAY place all the records
      that correspond to lost packets at the\n   very end.\n   Packets that have send
      time in the future MUST be recorded normally,\n   without changing their send
      timestamp, unless they have to be\n   discarded.  (Send timestamps in the future
      would normally indicate\n   clocks that differ by more than the delay.  Some
      data -- such as\n   jitter -- can be extracted even without knowledge of time
      difference.\n   For other kinds of data, the adjustment is best handled by the
      data\n   consumer on the basis of the complete information in a measurement\n
      \  session, as well as, possibly, external data.)\n   Packets with a sequence
      number that was already observed (duplicate\n   packets) MUST be recorded normally.
      \ (Duplicate packets are sometimes\n   introduced by IP networks.  The protocol
      has to be able to measure\n   duplication.)\n   If any of the following is true,
      the packet MUST be discarded:\n   +  Send timestamp is more than Timeout in
      the past or in the future.\n   +  Send timestamp differs by more than Timeout
      from the time when the\n      packet should have been sent according to its
      sequence number.\n   +  In authenticated or encrypted mode, HMAC verification
      fails.\n"
    title: 4.2.  Receiver Behavior
  title: 4.  OWAMP-Test
- contents:
  - "5.  Computing Exponentially Distributed Pseudo-Random Numbers\n   Here we describe
    the way exponential random quantities used in the\n   protocol are generated.
    \ While there is a fair number of algorithms\n   for generating exponential random
    variables, most of them rely on\n   having logarithmic function as a primitive,
    resulting in potentially\n   different values, depending on the particular implementation
    of the\n   math library.  We use algorithm 3.4.1.S from [KNUTH], which is free\n
    \  of the above-mentioned problem, and which guarantees the same output\n   on
    any implementation.  The algorithm belongs to the ziggurat family\n   developed
    in the 1970s by G. Marsaglia, M. Sibuya, and J. H. Ahrens\n   [ZIGG].  It replaces
    the use of logarithmic function by clever bit\n   manipulation, still producing
    the exponential variates on output.\n"
  - contents:
    - "5.1.  High-Level Description of the Algorithm\n   For ease of exposition, the
      algorithm is first described with all\n   arithmetic operations being interpreted
      in their natural sense.\n   Later, exact details on data types, arithmetic,
      and generation of the\n   uniform random variates used by the algorithm are
      given.  It is an\n   almost verbatim quotation from [KNUTH], p.133.\n   Algorithm
      S: Given a real positive number \"mu\", produce an\n   exponential random variate
      with mean \"mu\".\n   First, the constants\n   Q[k] = (ln2)/(1!) + (ln2)^2/(2!)
      + ... + (ln2)^k/(k!),  1 <= k <= 11\n   are computed in advance.  The exact
      values which MUST be used by all\n   implementations are given in the next section.
      \ This is necessary to\n   ensure that exactly the same pseudo-random sequences
      are produced by\n   all implementations.\n   S1. [Get U and shift.] Generate
      a 32-bit uniform random binary\n   fraction\n             U = (.b0 b1 b2 ...
      b31)    [note the binary point]\n   Locate the first zero bit b_j and shift
      off the leading (j+1) bits,\n   setting U <- (.b_{j+1} ... b31)\n   Note: In
      the rare case that the zero has not been found, it is\n   prescribed that the
      algorithm return (mu*32*ln2).\n   S2. [Immediate acceptance?] If U < ln2, set
      X <- mu*(j*ln2 + U) and\n   terminate the algorithm. (Note that Q[1] = ln2.)\n
      \  S3. [Minimize.] Find the least k >= 2 such that U < Q[k]. Generate k\n   new
      uniform random binary fractions U1,...,Uk and set V <-\n   min(U1,...,Uk).\n
      \  S4. [Deliver the answer.] Set X <- mu*(j + V)*ln2.\n"
    title: 5.1.  High-Level Description of the Algorithm
  - contents:
    - "5.2.  Data Types, Representation, and Arithmetic\n   The high-level algorithm
      operates on real numbers, typically\n   represented as floating point numbers.
      \ This specification prescribes\n   that unsigned 64-bit integers be used instead.\n
      \  u_int64_t integers are interpreted as real numbers by placing the\n   decimal
      point after the first 32 bits.  In other words, conceptually,\n   the interpretation
      is given by the following map:\n          u_int64_t u;\n          u  |--> (double)u
      / (2**32)\n   The algorithm produces a sequence of such u_int64_t integers that,\n
      \  for any given value of SID, is guaranteed to be the same on any\n   implementation.\n
      \  We specify that the u_int64_t representations of the first 11 values\n   of
      the Q array in the high-level algorithm MUST be as follows:\n   #1      0xB17217F8,\n
      \  #2      0xEEF193F7,\n   #3      0xFD271862,\n   #4      0xFF9D6DD0,\n   #5
      \     0xFFF4CFD0,\n   #6      0xFFFEE819,\n   #7      0xFFFFE7FF,\n   #8      0xFFFFFE2B,\n
      \  #9      0xFFFFFFE0,\n   #10     0xFFFFFFFE,\n   #11     0xFFFFFFFF\n   For
      example, Q[1] = ln2 is indeed approximated by 0xB17217F8/(2**32)\n   = 0.693147180601954;
      for j > 11, Q[j] is 0xFFFFFFFF.\n   Small integer j in the high-level algorithm
      is represented as\n   u_int64_t value j * (2**32).\n   Operation of addition
      is done as usual on u_int64_t numbers; however,\n   the operation of multiplication
      in the high-level algorithm should be\n   replaced by\n      (u, v) |---> (u
      * v) >> 32.\n   Implementations MUST compute the product (u * v) exactly.  For\n
      \  example, a fragment of unsigned 128-bit arithmetic can be implemented\n   for
      this purpose (see the sample implementation in Appendix A).\n"
    title: 5.2.  Data Types, Representation, and Arithmetic
  - contents:
    - "5.3.  Uniform Random Quantities\n   The procedure for obtaining a sequence
      of 32-bit random numbers (such\n   as U in algorithm S) relies on using AES
      encryption in counter mode.\n   To describe the exact working of the algorithm,
      we introduce two\n   primitives from Rijndael.  Their prototypes and specification
      are\n   given below, and they are assumed to be provided by the supporting\n
      \  Rijndael implementation, such as [RIJN].\n   +  A function that initializes
      a Rijndael key with bytes from seed\n      (the SID will be used as the seed):\n
      \     void KeyInit(unsigned char seed[16]);\n   +  A function that encrypts
      the 16-octet block inblock with the\n      specified key, returning a 16-octet
      encrypted block.  Here,\n      keyInstance is an opaque type used to represent
      Rijndael keys:\n      void BlockEncrypt(keyInstance key, unsigned char inblock[16]);\n
      \  Algorithm Unif: given a 16-octet quantity seed, produce a sequence of\n   unsigned
      32-bit pseudo-random uniformly distributed integers.  In\n   OWAMP, the SID
      (session ID) from Control protocol plays the role of\n   seed.\n   U1. [Initialize
      Rijndael key] key <- KeyInit(seed) [Initialize an\n   unsigned 16-octet (network
      byte order) counter] c <- 0\n   U2. [Need more random bytes?]  Set i <- c mod
      4.  If (i == 0) set s\n   <- BlockEncrypt(key, c)\n   U3. [Increment the counter
      as unsigned 16-octet quantity] c <- c + 1\n   U4. [Do output] Output the i_th
      quartet of octets from s starting\n   from high-order octets, converted to native
      byte order and\n   represented as OWPNum64 value (as in 3.b).\n   U5. [Loop]
      Go to step U2.\n"
    title: 5.3.  Uniform Random Quantities
  title: 5.  Computing Exponentially Distributed Pseudo-Random Numbers
- contents:
  - '6.  Security Considerations

    '
  - contents:
    - "6.1.  Introduction\n   The goal of authenticated mode is to let one passphrase-protect
      the\n   service provided by a particular OWAMP-Control server.  One can\n   imagine
      a variety of circumstances where this could be useful.\n   Authenticated mode
      is designed to prohibit theft of service.\n   An additional design objective
      of the authenticated mode was to make\n   it impossible for an attacker who
      cannot read traffic between OWAMP-\n   Test sender and receiver to tamper with
      test results in a fashion\n   that affects the measurements, but not other traffic.\n
      \  The goal of encrypted mode is quite different: to make it hard for a\n   party
      in the middle of the network to make results look \"better\" than\n   they should
      be.  This is especially true if one of client and server\n   does not coincide
      with either sender or receiver.\n   Encryption of OWAMP-Control using AES CBC
      mode with blocks of HMAC\n   after each message aims to achieve two goals: (i)
      to provide secrecy\n   of exchange, and (ii) to provide authentication of each
      message.\n"
    title: 6.1.  Introduction
  - contents:
    - "6.2.  Preventing Third-Party Denial of Service\n   OWAMP-Test sessions directed
      at an unsuspecting party could be used\n   for denial of service (DoS) attacks.
      \ In unauthenticated mode,\n   servers SHOULD limit receivers to hosts they
      control or to the OWAMP-\n   Control client.\n   Unless otherwise configured,
      the default behavior of servers MUST be\n   to decline requests where the Receiver
      Address field is not equal to\n   the address that the control connection was
      initiated from or an\n   address of the server (or an address of a host it controls).
      \ Given\n   the TCP handshake procedure and sequence numbers in the control\n
      \  connection, this ensures that the hosts that make such requests are\n   actually
      those hosts themselves, or at least on the path towards\n   them.  If either
      this test or the handshake procedure were omitted,\n   it would become possible
      for attackers anywhere in the Internet to\n   request that large amounts of
      test packets be directed against victim\n   nodes somewhere else.\n   In any
      case, OWAMP-Test packets with a given source address MUST only\n   be sent from
      the node that has been assigned that address (i.e.,\n   address spoofing is
      not permitted).\n"
    title: 6.2.  Preventing Third-Party Denial of Service
  - contents:
    - "6.3.  Covert Information Channels\n   OWAMP-Test sessions could be used as
      covert channels of information.\n   Environments that are worried about covert
      channels should take this\n   into consideration.\n"
    title: 6.3.  Covert Information Channels
  - contents:
    - "6.4.  Requirement to Include AES in Implementations\n   Notice that AES, in
      counter mode, is used for pseudo-random number\n   generation, so implementation
      of AES MUST be included even in a\n   server that only supports unauthenticated
      mode.\n"
    title: 6.4.  Requirement to Include AES in Implementations
  - contents:
    - "6.5.  Resource Use Limitations\n   An OWAMP server can consume resources of
      various kinds.  The two most\n   important kinds of resources are network capacity
      and memory (primary\n   or secondary) for storing test results.\n   Any implementation
      of OWAMP server MUST include technical mechanisms\n   to limit the use of network
      capacity and memory.  Mechanisms for\n   managing the resources consumed by
      unauthenticated users and users\n   authenticated with a KeyID and passphrase
      SHOULD be separate.  The\n   default configuration of an implementation MUST
      enable these\n   mechanisms and set the resource use limits to conservatively
      low\n   values.\n   One way to design the resource limitation mechanisms is
      as follows:\n   assign each session to a user class.  User classes are partially\n
      \  ordered with \"includes\" relation, with one class (\"all users\") that\n
      \  is always present and that includes any other class.  The assignment\n   of
      a session to a user class can be based on the presence of\n   authentication
      of the session, the KeyID, IP address range, time of\n   day, and, perhaps,
      other factors.  Each user class would have a limit\n   for usage of network
      capacity (specified in units of bit/second) and\n   memory for storing test
      results (specified in units of octets).\n   Along with the limits for resource
      use, current use would be tracked\n   by the server.  When a session is requested
      by a user in a specific\n   user class, the resources needed for this session
      are computed: the\n   average network capacity use (based on the sending schedule)
      and the\n   maximum memory use (based on the number of packets and number of\n
      \  octets each packet would need to be stored internally -- note that\n   outgoing
      sessions would not require any memory use).  These resource\n   use numbers
      are added to the current resource use numbers for the\n   given user class;
      if such addition would take the resource use\n   outside of the limits for the
      given user class, the session is\n   rejected.  When resources are reclaimed,
      corresponding measures are\n   subtracted from the current use.  Network capacity
      is reclaimed as\n   soon as the session ends.  Memory is reclaimed when the
      data is\n   deleted.  For unauthenticated sessions, memory consumed by an OWAMP-\n
      \  Test session SHOULD be reclaimed after the OWAMP-Control connection\n   that
      initiated the session is closed (gracefully or otherwise).  For\n   authenticated
      sessions, the administrator who configures the service\n   should be able to
      decide the exact policy, but useful policy\n   mechanisms that MAY be implemented
      are the ability to automatically\n   reclaim memory when the data is retrieved
      and the ability to reclaim\n   memory after a certain configurable (based on
      user class) period of\n   time passes after the OWAMP-Test session terminates.\n"
    title: 6.5.  Resource Use Limitations
  - contents:
    - "6.6.  Use of Cryptographic Primitives in OWAMP\n   At an early stage in designing
      the protocol, we considered using\n   Transport Layer Security (TLS) [RFC2246,
      RFC3546] and IPsec [RFC2401]\n   as cryptographic security mechanisms for OWAMP;
      later, we also\n   considered DTLS.  The disadvantages of those are as follows
      (not an\n   exhaustive list):\n   Regarding TLS:\n   +  TLS could be used to
      secure TCP-based OWAMP-Control, but it would\n      be difficult to use it to
      secure UDP-based OWAMP-Test: OWAMP-Test\n      packets, if lost, are not resent,
      so packets have to be\n      (optionally) encrypted and authenticated while
      retaining\n      individual usability.  Stream-based TLS cannot be easily used
      for\n      this.\n   +  Dealing with streams, TLS does not authenticate individual\n
      \     messages (even in OWAMP-Control).  The easiest way out would be to\n      add
      some known-format padding to each message and to verify that\n      the format
      of the padding is intact before using the message.  The\n      solution would
      thus lose some of its appeal (\"just use TLS\").  It\n      would also be much
      more difficult to evaluate the security of this\n      scheme with the various
      modes and options of TLS; it would almost\n      certainly not be secure with
      all.  The capacity of an attacker to\n      replace parts of messages (namely,
      the end) with random garbage\n      could have serious security implications
      and would need to be\n      analyzed carefully.  Suppose, for example, that
      a parameter that\n      is used in some form to control the rate were replaced
      by random\n      garbage; chances are that the result (an unsigned integer)
      would\n      be quite large.\n   +  Dependent on the mode of use, one can end
      up with a requirement\n      for certificates for all users and a PKI.  Even
      if one is to\n      accept that PKI is desirable, there just isn't a usable
      one today.\n   +  TLS requires a fairly large implementation.  OpenSSL, for
      example,\n      is larger than our implementation of OWAMP as a whole.  This
      can\n      matter for embedded implementations.\n   Regarding DTLS:\n   +  Duplication
      and, similarly, reordering are network phenomena that\n      OWAMP needs to
      be able to measure; yet anti-replay measures and\n      reordering protection
      of DTLS would prevent the duplicated and\n      reordered packets from reaching
      the relevant part of the OWAMP\n      code.  One could, of course, modify DTLS
      so that these protections\n      are weakened or even specify examining the
      messages in a carefully\n      crafted sequence somewhere in between DTLS checks;
      but then, of\n      course, the advantage of using an existing protocol would
      not be\n      realized.\n   +  In authenticated mode, the timestamp is in the
      clear and is not\n      protected cryptographically in any way, while the rest
      of the\n      message has the same protection as in encrypted mode.  This mode\n
      \     allows one to trade off cryptographic protection against accuracy\n      of
      timestamps.  For example, the APAN hardware implementation of\n      OWAMP [APAN]
      is capable of supporting authenticated mode.  The\n      accuracy of these measurements
      is in the sub-microsecond range.\n      The errors in OWAMP measurements of
      Abilene [Abilene] (done using\n      a software implementation, in its encrypted
      mode) exceed 10us.\n      Users in different environments have different concerns,
      and some\n      might very well care about every last microsecond of accuracy.
      \ At\n      the same time, users in these same environments might care about\n
      \     access control to the service.  Authenticated mode permits them to\n      control
      access to the server yet to use unprotected timestamps,\n      perhaps generated
      by a hardware device.\n   Regarding IPsec:\n   +  What we now call authenticated
      mode would not be possible (in\n      IPsec you can't authenticate part of a
      packet).\n   +  The deployment paths of IPsec and OWAMP could be separate if
      OWAMP\n      does not depend on IPsec.  After nine years of IPsec, only 0.05%\n
      \     of traffic on an advanced backbone network, such as Abilene, uses\n      IPsec
      (for comparison purposes with encryption above layer 4, SSH\n      use is at
      2-4% and HTTPS use is at 0.2-0.6%).  It is desirable to\n      be able to deploy
      OWAMP on as large a number of different\n      platforms as possible.\n   +
      \ The deployment problems of a protocol dependent on IPsec would be\n      especially
      acute in the case of lightweight embedded devices.\n      Ethernet switches,
      DSL \"modems\", and other such devices mostly do\n      not support IPsec.\n
      \  +  The API for manipulating IPsec from an application is currently\n      poorly
      understood.  Writing a program that needs to encrypt some\n      packets, to
      authenticate some packets, and to leave some open --\n      for the same destination
      -- would become more of an exercise in\n      IPsec than in IP measurement.\n
      \  For the enumerated reasons, we decided to use a simple cryptographic\n   protocol
      (based on a block cipher in CBC mode) that is different from\n   TLS and IPsec.\n"
    title: 6.6.  Use of Cryptographic Primitives in OWAMP
  - contents:
    - "6.7.  Cryptographic Primitive Replacement\n   It might become necessary in
      the future to replace AES, or the way it\n   is used in OWAMP, with a new cryptographic
      primitive, or to make\n   other security-related changes to the protocol.  OWAMP
      provides a\n   well-defined point of extensibility: the Modes word in the server\n
      \  greeting and the Mode response in the Set-Up-Response message.  For\n   example,
      if a simple replacement of AES with a different block cipher\n   with a 128-bit
      block is needed, this could be accomplished as\n   follows: take two bits from
      the reserved (MBZ) part of the Modes word\n   of the server greeting; use one
      of these bits to indicate encrypted\n   mode with the new cipher and another
      one to indicate authenticated\n   mode with the new cipher.  (Bit consumption
      could, in fact, be\n   reduced from two to one, if the client is allowed to
      return a mode\n   selection with more than a single bit set: one could designate
      a\n   single bit to mean that the new cipher is supported (in the case of\n
      \  the server) or selected (in the case of the client) and continue to\n   use
      already allocated bits for authenticated and encrypted modes;\n   this optimization
      is unimportant conceptually, but it could be useful\n   in practice to make
      the best use of bits.)  Then, if the new cipher\n   is negotiated, all subsequent
      operations simply use it instead of\n   AES.  Note that the normal transition
      sequence would be used in such\n   a case: implementations would probably first
      start supporting and\n   preferring the new cipher, and then drop support for
      the old cipher\n   (presumably no longer considered secure).\n   If the need
      arises to make more extensive changes (perhaps to replace\n   AES with a 256-bit-block
      cipher), this would be more difficult and\n   would require changing the layout
      of the messages.  However, the\n   change can still be conducted within the
      framework of OWAMP\n   extensibility using the Modes/Mode words.  The semantics
      of the new\n   bits (or single bit, if the optimization described above is used)\n
      \  would include the change to message layout as well as the change in\n   the
      cryptographic primitive.\n   Each of the bits in the Modes word can be used
      for an independent\n   extension.  The extensions signaled by various bits are
      orthogonal;\n   for example, one bit might be allocated to change from AES-128
      to\n   some other cipher, another bit might be allocated to add a protocol\n
      \  feature (such as, e.g., support for measuring over multicast), yet\n   another
      might be allocated to change a key derivation function, etc.\n   The progression
      of versions is not a linear order, but rather a\n   partial order.  An implementation
      can implement any subset of these\n   features (of course, features can be made
      mandatory to implement,\n   e.g., new more secure ciphers if they are needed).\n
      \  Should a cipher with a different key size (say, a 256-bit key) become\n   needed,
      a new key derivation function for OWAMP-Test keys would also\n   be needed.
      \ The semantics of change in the cipher SHOULD then in the\n   future be tied
      to the semantics of change in the key derivation\n   function (KDF).  One KDF
      that might be considered for the purpose\n   might be a pseudo-random function
      (PRF) with appropriately sized\n   output, such as 256 bits (perhaps HMAC-SHA256,
      if it is then still\n   considered a secure PRF), which could then be used to
      derive the\n   OWAMP-Test session keys from the OWAMP-Control session key by
      using\n   the OWAMP-Control session key as the HMAC key and the SID as HMAC\n
      \  message.\n   Note that the replacement scheme outlined above is trivially\n
      \  susceptible to downgrade attacks: a malicious party in the middle can\n   flip
      modes bits as the mode is negotiated so that the oldest and\n   weakest mode
      supported by the two parties is used.  If this is deemed\n   problematic at
      the time of cryptographic primitive replacement, the\n   scheme might be augmented
      with a measure to prevent such an attack\n   (by perhaps exchanging the modes
      again once a secure communications\n   channel is established, comparing the
      two sets of mode words, and\n   dropping the connection should they not match).\n"
    title: 6.7.  Cryptographic Primitive Replacement
  - contents:
    - "6.8.  Long-term Manually Managed Keys\n   OWAMP-Control uses long-term keys
      with manual management.  These keys\n   are used to automatically negotiate
      session keys for each OWAMP-\n   Control session running in authenticated or
      encrypted mode.  The\n   number of these keys managed by a server scales linearly
      with (and,\n   in fact, is equal to) the number of administratively different
      users\n   (perhaps particular humans, roles, or robots representing sites) that\n
      \  need to connect to this server.  Similarly, the number of different\n   manual
      keys managed by each client is the number of different servers\n   that the
      client needs to connect to.  This use of manual long-term\n   keys is compliant
      with [BCP107].\n"
    title: 6.8.  Long-term Manually Managed Keys
  - contents:
    - "6.9.  (Not) Using Time as Salt\n   A natural idea is to use the current time
      as salt when deriving\n   session keys.  Unfortunately, this appears to be too
      limiting.\n   Although OWAMP is often run on hosts with well-synchronized clocks,\n
      \  it is also possible to run it on hosts with clocks completely\n   untrained.
      \ The delays obtained thus are, of course, not directly\n   usable; however,
      some metrics, such as unidirectional loss,\n   reordering, measures of congestion
      such as the median delay minus\n   minimum, and many others are usable directly
      and immediately (and\n   improve upon the information that would have been provided
      by a\n   round-trip measurement).  Further, even delay information can be\n
      \  useful with appropriate post-processing.  Indeed, one can even argue\n   that
      running the clocks free and post-processing the results of a\n   mesh of measurements
      will result in better accuracy, as more\n   information is available a posteriori
      and correlation of data from\n   different hosts is possible in post-processing,
      but not with online\n   clock training.\n   Given this, time is not used as
      salt in key derivation.\n"
    title: 6.9.  (Not) Using Time as Salt
  - contents:
    - "6.10.  The Use of AES-CBC and HMAC\n   OWAMP relies on AES-CBC for confidentiality
      and on HMAC-SHA1\n   truncated to 128 bits for message authentication.  Random
      IV choice\n   is important for prevention of a codebook attack on the first
      block\n   (it should also be noted that, with its 128-bit block size, AES is\n
      \  more resistant to codebook attacks than are ciphers with shorter\n   blocks;
      we use random IV anyway).\n   HMAC MUST verify.  It is crucial to check for
      this before using the\n   message; otherwise, existential forgery becomes possible.
      \ The\n   complete message for which HMAC verification fails MUST be discarded\n
      \  (both for short messages consisting of a few blocks and potentially\n   for
      long messages, such as a response to the Fetch-Session command).\n   If such
      a message is part of OWAMP-Control, the connection MUST be\n   dropped.\n   Since
      OWAMP messages can have different numbers of blocks, the\n   existential forgery
      attack described in example 9.62 of [MENEZES]\n   becomes a concern.  To prevent
      it (and to simplify implementation),\n   the length of any message becomes known
      after decrypting its first\n   block.\n   A special case is the first (fixed-length)
      message sent by the\n   client.  There, the token is a concatenation of the
      128-bit challenge\n   (transmitted by the server in the clear), a 128-bit AES
      Session-key\n   (generated randomly by the client, encrypted with AES-CBC with
      IV=0),\n   and a 256-bit HMAC-SHA1 Session-key used for authentication.  Since\n
      \  IV=0, the challenge (a single cipher block) is simply encrypted with\n   the
      secret key.  Therefore, we rely on resistance of AES to chosen\n   plaintext
      attacks (as the challenge could be substituted by an\n   attacker).  It should
      be noted that the number of blocks of chosen\n   plaintext an attacker can have
      encrypted with the secret key is\n   limited by the number of sessions the client
      wants to initiate.  An\n   attacker who knows the encryption of a server's challenge
      can produce\n   an existential forgery of the session key and thus disrupt the\n
      \  session; however, any attacker can disrupt a session by corrupting\n   the
      protocol messages in an arbitrary fashion.  Therefore, no new\n   threat is
      created here; nevertheless, we require that the server\n   never issues the
      same challenge twice.  (If challenges are generated\n   randomly, a repetition
      would occur, on average, after 2^64 sessions;\n   we deem this satisfactory
      as this is enough even for an implausibly\n   busy server that participates
      in 1,000,000 sessions per second to go\n   without repetitions for more than
      500 centuries.)  With respect to\n   the second part of the token, an attacker
      can produce an existential\n   forgery of the session key by modifying the second
      half of the\n   client's token while leaving the first part intact.  This forgery,\n
      \  however, would be immediately discovered by the client when the HMAC\n   on
      the server's next message (acceptance or rejection of the\n   connection) does
      not verify.\n"
    title: 6.10.  The Use of AES-CBC and HMAC
  title: 6.  Security Considerations
- contents:
  - "7.  Acknowledgements\n   We would like to thank Guy Almes, Mark Allman, Jari
    Arkko, Hamid\n   Asgari, Steven Van den Berghe, Eric Boyd, Robert Cole, Joan\n
    \  Cucchiara, Stephen Donnelly, Susan Evett, Sam Hartman, Kaynam\n   Hedayat,
    Petri Helenius, Scott Hollenbeck, Russ Housley, Kitamura\n   Yasuichi, Daniel
    H. T. R. Lawson, Will E. Leland, Bruce A. Mah,\n   Allison Mankin, Al Morton,
    Attila Pasztor, Randy Presuhn, Matthew\n   Roughan, Andy Scherrer, Henk Uijterwaal,
    and Sam Weiler for their\n   comments, suggestions, reviews, helpful discussion
    and proof-reading.\n"
  title: 7.  Acknowledgements
- contents:
  - "8.  IANA Considerations\n   IANA has allocated a well-known TCP port number (861)
    for the OWAMP-\n   Control part of the OWAMP protocol.\n"
  title: 8.  IANA Considerations
- contents:
  - "9.  Internationalization Considerations\n   The protocol does not carry any information
    in a natural language,\n   with the possible exception of the KeyID in OWAMP-Control,
    which is\n   encoded in UTF-8.\n"
  title: 9.  Internationalization Considerations
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [AES]           Advanced Encryption Standard
      (AES),\n                   http://csrc.nist.gov/encryption/aes/\n   [BCP107]
      \       Bellovin, S. and R. Housley, \"Guidelines for\n                   Cryptographic
      Key Management\", BCP 107, RFC 4107,\n                   June 2005.\n   [RFC2104]
      \      Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC:\n                   Keyed-Hashing
      for Message Authentication\", RFC 2104,\n                   February 1997.\n
      \  [RFC2119]       Bradner, S., \"Key words for use in RFCs to Indicate\n                   Requirement
      Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2330]       Paxson, V., Almes,
      G., Mahdavi, J., and M. Mathis,\n                   \"Framework for IP Performance
      Metrics\", RFC 2330, May\n                   1998.\n   [RFC2474]       Nichols,
      K., Blake, S., Baker, F., and D. Black,\n                   \"Definition of
      the Differentiated Services Field (DS\n                   Field) in the IPv4
      and IPv6 Headers\", RFC 2474,\n                   December 1998.\n   [RFC2679]
      \      Almes, G., Kalidindi, S., and M. Zekauskas, \"A One-\n                   way
      Delay Metric for IPPM\", RFC 2679, September 1999.\n   [RFC2680]       Almes,
      G., Kalidindi, S., and M. Zekauskas, \"A One-\n                   way Packet
      Loss Metric for IPPM\", RFC 2680, September\n                   1999.\n   [RFC2836]
      \      Brim, S., Carpenter, B., and F. Le Faucheur, \"Per Hop\n                   Behavior
      Identification Codes\", RFC 2836, May 2000.\n   [RFC2898]       Kaliski, B.,
      \"PKCS #5: Password-Based Cryptography\n                   Specification Version
      2.0\", RFC 2898, September 2000.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [APAN]          Z. Shu and K. Kobayashi,
      \"HOTS: An OWAMP-Compliant\n                   Hardware Packet Timestamper\",
      In Proceedings of PAM\n                   2005, http://www.springerlink.com/index/\n
      \                  W4GBD39YWC11GQTN.pdf\n   [BRIX]          Brix Networks, http://www.brixnet.com/\n
      \  [ZIGG]          J. H. Ahrens, U. Dieter, \"Computer methods for\n                   sampling
      from the exponential and normal\n                   distributions\", Communications
      of ACM, volume 15,\n                   issue 10, 873-882, 1972.\n                   http://doi.acm.org/10.1145/355604.361593\n
      \  [MENEZES]       A. J. Menezes, P. C. van Oorschot, and S. A.\n                   Vanstone,
      Handbook of Applied Cryptography, CRC\n                   Press, revised reprint
      with updates, 1997.\n   [KNUTH]         D. Knuth, The Art of Computer Programming,
      vol.2, 3rd\n                   edition, 1998.\n   [Abilene]       One-way Latency
      Measurement (OWAMP),\n                   http://e2epi.internet2.edu/owamp/\n
      \  [RIJN]          Reference ANSI C Implementation of Rijndael,\n                   http://www.esat.kuleuven.ac.be/~rijmen/\n
      \                  rijndael/rijndaelref.zip\n   [RIPE]          RIPE NCC Test-Traffic
      Measurements home,\n                   http://www.ripe.net/test-traffic/.\n
      \  [SURVEYOR]      Surveyor Home Page,\n                   http://www.advanced.org/surveyor/.\n
      \  [SURVEYOR-INET] S. Kalidindi and M. Zekauskas, \"Surveyor: An\n                   Infrastructure
      for Network Performance Measurements\",\n                   Proceedings of INET'99,
      June 1999.\n                   http://www.isoc.org/inet99/proceedings/4h/4h_2.htm\n
      \  [RFC1305]       Mills, D., \"Network Time Protocol (Version 3)\n                   Specification,
      Implementation and Analysis\", RFC\n                   1305, March 1992.\n   [RFC2246]
      \      Dierks, T. and C. Allen, \"The TLS Protocol Version\n                   1.0\",
      RFC 2246, January 1999.\n   [RFC2401]       Kent, S. and R. Atkinson, \"Security
      Architecture for\n                   the Internet Protocol\", RFC 2401, November
      1998.\n   [RFC3546]       Blake-Wilson, S., Nystrom, M., Hopwood, D.,\n                   Mikkelsen,
      J., and T. Wright, \"Transport Layer\n                   Security (TLS) Extensions\",
      RFC 3546, June 2003.\n   [RFC4086]       Eastlake, D., 3rd, Schiller, J., and
      S. Crocker,\n                   \"Randomness Requirements for Security\", BCP
      106, RFC\n                   4086, June 2005.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A: Sample C Code for Exponential Deviates\n   The values in array Q[]
    are the exact values that MUST be used by all\n   implementations (see Sections
    5.1 and 5.2).  This appendix only\n   serves for illustrative purposes.\n   /*\n
    \  ** Example usage: generate a stream of exponential (mean 1)\n   ** random quantities
    (ignoring error checking during initialization).\n   ** If a variate with some
    mean mu other than 1 is desired, the output\n   ** of this algorithm can be multiplied
    by mu according to the rules\n   ** of arithmetic we described.\n   ** Assume
    that a 16-octet 'seed' has been initialized\n   ** (as the shared secret in OWAMP,
    for example)\n   ** unsigned char seed[16];\n   ** OWPrand_context next;\n   **
    (initialize state)\n   ** OWPrand_context_init(&next, seed);\n   ** (generate
    a sequence of exponential variates)\n   ** while (1) {\n   **    u_int64_t num
    = OWPexp_rand64(&next);\n         <do something with num here>\n                    ...\n
    \  ** }\n   */\n   #include <stdlib.h>\n   typedef u_int64_t u_int64_t;\n   /*
    (K - 1) is the first k such that Q[k] > 1 - 1/(2^32). */\n   #define K 12\n   #define
    BIT31   0x80000000UL    /* See if first bit in the lower\n                                      32
    bits is zero. */\n   #define MASK32(n)       ((n) & 0xFFFFFFFFUL)\n   #define
    EXP2POW32       0x100000000ULL\n   typedef struct OWPrand_context {\n           unsigned
    char counter[16];/* Counter (network byte order).*/\n           keyInstance key;
    \         /* Key to encrypt the counter.*/\n           unsigned char out[16];
    \   /* The encrypted block.*/\n   } OWPrand_context;\n   /*\n   ** The array has
    been computed according to the formula:\n   **\n   **       Q[k] = (ln2)/(1!)
    + (ln2)^2/(2!) + ... + (ln2)^k/(k!)\n   **\n   ** as described in algorithm S.
    (The values below have been\n   ** multiplied by 2^32 and rounded to the nearest
    integer.)\n   ** These exact values MUST be used so that different implementation\n
    \  ** produce the same sequences.\n   */\n   static u_int64_t Q[K] = {\n           0,
    \       /* Placeholder - so array indices start from 1. */\n           0xB17217F8,\n
    \          0xEEF193F7,\n           0xFD271862,\n           0xFF9D6DD0,\n           0xFFF4CFD0,\n
    \          0xFFFEE819,\n           0xFFFFE7FF,\n           0xFFFFFE2B,\n           0xFFFFFFE0,\n
    \          0xFFFFFFFE,\n           0xFFFFFFFF\n   };\n   /* this element represents
    ln2 */\n   #define LN2 Q[1]\n   /*\n   ** Convert an unsigned 32-bit integer into
    a u_int64_t number.\n   */\n   u_int64_t\n   OWPulong2num64(u_int32_t a)\n   {\n
    \          return ((u_int64_t)1 << 32) * a;\n   }\n   /*\n   ** Arithmetic functions
    on u_int64_t numbers.\n   */\n   /*\n   ** Addition.\n   */\n   u_int64_t\n   OWPnum64_add(u_int64_t
    x, u_int64_t y)\n   {\n           return x + y;\n   }\n   /*\n   ** Multiplication.
    \ Allows overflow.  Straightforward implementation\n   ** of Algorithm 4.3.1.M
    (p.268) from [KNUTH].\n   */\n   u_int64_t\n   OWPnum64_mul(u_int64_t x, u_int64_t
    y)\n   {\n           unsigned long w[4];\n           u_int64_t xdec[2];\n           u_int64_t
    ydec[2];\n           int i, j;\n           u_int64_t k, t, ret;\n           xdec[0]
    = MASK32(x);\n           xdec[1] = MASK32(x>>32);\n           ydec[0] = MASK32(y);\n
    \          ydec[1] = MASK32(y>>32);\n           for (j = 0; j < 4; j++)\n                   w[j]
    = 0;\n           for (j = 0; j < 2; j++) {\n                   k = 0;\n                   for
    (i = 0; ; ) {\n                           t = k + (xdec[i]*ydec[j]) + w[i + j];\n
    \                          w[i + j] = t%EXP2POW32;\n                           k
    = t/EXP2POW32;\n                           if (++i < 2)\n                                   continue;\n
    \                          else {\n                                   w[j + 2]
    = k;\n                                   break;\n                           }\n
    \                  }\n           }\n           ret = w[2];\n           ret <<=
    32;\n           return w[1] + ret;\n   }\n   /*\n   ** Seed the random number
    generator using a 16-byte quantity 'seed'\n   ** (== the session ID in OWAMP).
    This function implements step U1\n   ** of algorithm Unif.\n   */\n   void\n   OWPrand_context_init(OWPrand_context
    *next, unsigned char *seed)\n   {\n           int i;\n           /* Initialize
    the key */\n           rijndaelKeyInit(next->key, seed);\n           /* Initialize
    the counter with zeros */\n           memset(next->out, 0, 16);\n           for
    (i = 0; i < 16; i++)\n                   next->counter[i] = 0UL;\n   }\n   /*\n
    \  ** Random number generating functions.\n   */\n   /*\n   ** Generate and return
    a 32-bit uniform random value (saved in the\n   **less significant half of the
    u_int64_t).  This function implements\n   **steps U2-U4 of the algorithm Unif.\n
    \  */\n   u_int64_t\n   OWPunif_rand64(OWPrand_context *next)\n   {\n           int
    j;\n           u_int8_t  *buf;\n           u_int64_t  ret = 0;\n           /*
    step U2 */\n           u_int8_t i = next->counter[15] & (u_int8_t)3;\n           if
    (!i)\n                   rijndaelEncrypt(next->key, next->counter, next->out);\n
    \          /* Step U3.  Increment next.counter as a 16-octet single\n              quantity
    in network byte order for AES counter mode. */\n           for (j = 15; j >= 0;
    j--)\n                   if (++next->counter[j])\n                           break;\n
    \          /* Step U4.  Do output.  The last 4 bytes of ret now contain\n              the
    random integer in network byte order */\n           buf = &next->out[4*i];\n           for
    (j=0; j<4; j++) {\n                   ret <<= 8;\n                   ret += *buf++;\n
    \          }\n           return ret;\n   }\n   /*\n   ** Generate an exponential
    deviate with mean 1.\n   */\n   u_int64_t\n   OWPexp_rand64(OWPrand_context *next)\n
    \  {\n           unsigned long i, k;\n           u_int32_t j = 0;\n           u_int64_t
    U, V, J, tmp;\n           /* Step S1. Get U and shift */\n           U = OWPunif_rand64(next);\n
    \          while ((U & BIT31) && (j < 32)) { /* Shift until first 0. */\n                   U
    <<= 1;\n                   j++;\n           }\n           /* Remove the 0 itself.
    */\n           U <<= 1;\n           U = MASK32(U);  /* Keep only the fractional
    part. */\n           J = OWPulong2num64(j);\n           /* Step S2.  Immediate
    acceptance? */\n           if (U < LN2)       /* return  (j*ln2 + U) */\n                   return
    OWPnum64_add(OWPnum64_mul(J, LN2), U);\n           /* Step S3.  Minimize. */\n
    \          for (k = 2; k < K; k++)\n                   if (U < Q[k])\n                           break;\n
    \          V = OWPunif_rand64(next);\n           for (i = 2; i <= k; i++) {\n
    \                  tmp = OWPunif_rand64(next);\n                   if (tmp < V)\n
    \                          V = tmp;\n           }\n           /* Step S4.  Return
    (j+V)*ln2 */\n           return OWPnum64_mul(OWPnum64_add(J, V), LN2);\n   }\n"
  title: 'Appendix A: Sample C Code for Exponential Deviates'
- contents:
  - "Appendix B: Test Vectors for Exponential Deviates\n   It is important that the
    test schedules generated by different\n   implementations from identical inputs
    be identical.  The non-trivial\n   part is the generation of pseudo-random exponentially
    distributed\n   deviates.  To aid implementors in verifying interoperability,
    several\n   test vectors are provided.  For each of the four given 128-bit values\n
    \  of SID represented as hexadecimal numbers, 1,000,000 exponentially\n   distributed
    64-bit deviates are generated as described above.  As\n   they are generated,
    they are all added to each other.  The sum of all\n   1,000,000 deviates is given
    as a hexadecimal number for each SID.  An\n   implementation MUST produce exactly
    these hexadecimal numbers.  To\n   aid in the verification of the conversion of
    these numbers to values\n   of delay in seconds, approximate values are given
    (assuming\n   lambda=1).  An implementation SHOULD produce delay values in seconds\n
    \  that are close to the ones given below.\n       SID = 0x2872979303ab47eeac028dab3829dab2\n
    \      SUM[1000000] = 0x000f4479bd317381 (1000569.739036 seconds)\n       SID
    = 0x0102030405060708090a0b0c0d0e0f00\n       SUM[1000000] = 0x000f433686466a62
    (1000246.524512 seconds)\n       SID = 0xdeadbeefdeadbeefdeadbeefdeadbeef\n       SUM[1000000]
    = 0x000f416c8884d2d3 (999788.533277 seconds)\n       SID = 0xfeed0feed1feed2feed3feed4feed5ab\n
    \      SUM[1000000] = 0x000f3f0b4b416ec8 (999179.293967 seconds)\n"
  title: 'Appendix B: Test Vectors for Exponential Deviates'
- contents:
  - "Authors' Addresses\n   Stanislav Shalunov\n   Internet2\n   1000 Oakbrook Drive,
    Suite 300\n   Ann Arbor, MI 48104\n   EMail: shalunov@internet2.edu\n   WWW: http://www.internet2.edu/~shalunov/\n
    \  Benjamin Teitelbaum\n   Internet2\n   1000 Oakbrook Drive, Suite 300\n   Ann
    Arbor, MI 48104\n   EMail: ben@internet2.edu\n   WWW: http://people.internet2.edu/~ben/\n
    \  Anatoly Karp\n   Computer Sciences Department\n   University of Wisconsin-Madison\n
    \  Madison, WI 53706\n   EMail: akarp@cs.wisc.edu\n   Jeff W. Boote\n   Internet2\n
    \  1000 Oakbrook Drive, Suite 300\n   Ann Arbor, MI 48104\n   EMail: boote@internet2.edu\n
    \  Matthew J. Zekauskas\n   Internet2\n   1000 Oakbrook Drive, Suite 300\n   Ann
    Arbor, MI 48104\n   EMail: matt@internet2.edu\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This
    document is subject to the rights, licenses and restrictions\n   contained in
    BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n
    \  Administrative Support Activity (IASA).\n"
  title: Acknowledgement
