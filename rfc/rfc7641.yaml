- title: __initial_text__
  contents:
  - '   Observing Resources in the Constrained Application Protocol (CoAP)

    '
- title: Abstract
  contents:
  - "Abstract\n   The Constrained Application Protocol (CoAP) is a RESTful application\n\
    \   protocol for constrained nodes and networks.  The state of a resource\n  \
    \ on a CoAP server can change over time.  This document specifies a\n   simple\
    \ protocol extension for CoAP that enables CoAP clients to\n   \"observe\" resources,\
    \ i.e., to retrieve a representation of a resource\n   and keep this representation\
    \ updated by the server over a period of\n   time.  The protocol follows a best-effort\
    \ approach for sending new\n   representations to clients and provides eventual\
    \ consistency between\n   the state observed by each client and the actual resource\
    \ state at\n   the server.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7641.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  4\n     1.1.  Background  . . . . . . . . . . . . . . . . . . . .\
    \ . . .  4\n     1.2.  Protocol Overview . . . . . . . . . . . . . . . . . . .\
    \ .  4\n     1.3.  Consistency Model . . . . . . . . . . . . . . . . . . . . \
    \ 6\n     1.4.  Observable Resources  . . . . . . . . . . . . . . . . . .  7\n\
    \     1.5.  Requirements Notation . . . . . . . . . . . . . . . . . .  8\n   2.\
    \  The Observe Option  . . . . . . . . . . . . . . . . . . . . .  9\n   3.  Client-Side\
    \ Requirements  . . . . . . . . . . . . . . . . . . 10\n     3.1.  Request . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . 10\n     3.2.  Notifications .\
    \ . . . . . . . . . . . . . . . . . . . . . 10\n     3.3.  Caching . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . 11\n     3.4.  Reordering  . . . . . .\
    \ . . . . . . . . . . . . . . . . . 12\n     3.5.  Transmission  . . . . . . .\
    \ . . . . . . . . . . . . . . . 13\n     3.6.  Cancellation  . . . . . . . . .\
    \ . . . . . . . . . . . . . 13\n   4.  Server-Side Requirements  . . . . . . .\
    \ . . . . . . . . . . . 14\n     4.1.  Request . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . 14\n     4.2.  Notifications . . . . . . . . . . . . . . .\
    \ . . . . . . . 14\n     4.3.  Caching . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . 15\n     4.4.  Reordering  . . . . . . . . . . . . . . . . . . . .\
    \ . . . 16\n     4.5.  Transmission  . . . . . . . . . . . . . . . . . . . . .\
    \ . 17\n   5.  Intermediaries  . . . . . . . . . . . . . . . . . . . . . . . 20\n\
    \   6.  Web Linking . . . . . . . . . . . . . . . . . . . . . . . . . 20\n   7.\
    \  Security Considerations . . . . . . . . . . . . . . . . . . . 21\n   8.  IANA\
    \ Considerations . . . . . . . . . . . . . . . . . . . . . 22\n   9.  References\
    \  . . . . . . . . . . . . . . . . . . . . . . . . . 22\n     9.1.  Normative\
    \ References  . . . . . . . . . . . . . . . . . . 22\n     9.2.  Informative References\
    \  . . . . . . . . . . . . . . . . . 22\n   Appendix A.  Examples . . . . . .\
    \ . . . . . . . . . . . . . . . . 24\n     A.1.  Client/Server Examples  . . .\
    \ . . . . . . . . . . . . . . 24\n     A.2.  Proxy Examples  . . . . . . . . .\
    \ . . . . . . . . . . . . 28\n   Acknowledgements  . . . . . . . . . . . . . .\
    \ . . . . . . . . . . 30\n   Author's Address  . . . . . . . . . . . . . . . .\
    \ . . . . . . . . 30\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1.  Background
  contents:
  - "1.1.  Background\n   The Constrained Application Protocol (CoAP) [RFC7252] is\
    \ intended to\n   provide RESTful services [REST] not unlike HTTP [RFC7230] while\n\
    \   reducing the complexity of implementation as well as the size of\n   packets\
    \ exchanged in order to make these services useful in a highly\n   constrained\
    \ network of themselves highly constrained nodes [RFC7228].\n   The model of REST\
    \ is that of a client exchanging representations of\n   resources with a server,\
    \ where a representation captures the current\n   or intended state of a resource.\
    \  The server is the authority for\n   representations of the resources in its\
    \ namespace.  A client\n   interested in the state of a resource initiates a request\
    \ to the\n   server; the server then returns a response with a representation\
    \ of\n   the resource that is current at the time of the request.\n   This model\
    \ does not work well when a client is interested in having a\n   current representation\
    \ of a resource over a period of time.  Existing\n   approaches from HTTP, such\
    \ as repeated polling or HTTP long polling\n   [RFC6202], generate significant\
    \ complexity and/or overhead and thus\n   are less applicable in a constrained\
    \ environment.\n   The protocol specified in this document extends the CoAP core\n\
    \   protocol with a mechanism for a CoAP client to \"observe\" a resource\n  \
    \ on a CoAP server: the client retrieves a representation of the\n   resource\
    \ and requests this representation be updated by the server\n   as long as the\
    \ client is interested in the resource.\n   The protocol keeps the architectural\
    \ properties of REST.  It enables\n   high scalability and efficiency through\
    \ the support of caches and\n   proxies.  There is no intention, though, to solve\
    \ the full set of\n   problems that the existing HTTP solutions solve or to replace\n\
    \   publish/subscribe networks that solve a much more general problem\n   [RFC5989].\n"
- title: 1.2.  Protocol Overview
  contents:
  - "1.2.  Protocol Overview\n   The protocol is based on the well-known observer\
    \ design pattern\n   [GOF].  In this design pattern, components called \"observers\"\
    \n   register at a specific, known provider called the \"subject\" that they\n\
    \   are interested in being notified whenever the subject undergoes a\n   change\
    \ in state.  The subject is responsible for administering its\n   list of registered\
    \ observers.  If multiple subjects are of interest\n   to an observer, the observer\
    \ must register separately for all of\n   them.\n                       Observer\
    \             Subject\n                          |                    |\n    \
    \                      |    Registration    |\n                          +------------------->|\n\
    \                          |                    |\n                          |\
    \    Notification    |\n                          |<-------------------+\n   \
    \                       |                    |\n                          |  \
    \  Notification    |\n                          |<-------------------+\n     \
    \                     |                    |\n                          |    Notification\
    \    |\n                          |<-------------------+\n                   \
    \       |                    |\n                   Figure 1: The Observer Design\
    \ Pattern\n   The observer design pattern is realized in CoAP as follows:\n  \
    \ Subject:  In the context of CoAP, the subject is a resource in the\n      namespace\
    \ of a CoAP server.  The state of the resource can change\n      over time, ranging\
    \ from infrequent updates to continuous state\n      transformations.\n   Observer:\
    \  An observer is a CoAP client that is interested in having\n      a current\
    \ representation of the resource at any given time.\n   Registration:  A client\
    \ registers its interest in a resource by\n      initiating an extended GET request\
    \ to the server.  In addition to\n      returning a representation of the target\
    \ resource, this request\n      causes the server to add the client to the list\
    \ of observers of\n      the resource.\n   Notification:  Whenever the state of\
    \ a resource changes, the server\n      notifies each client in the list of observers\
    \ of the resource.\n      Each notification is an additional CoAP response sent\
    \ by the\n      server in reply to the single extended GET request and includes\
    \ a\n      complete, updated representation of the new resource state.\n   Figure\
    \ 2 below shows an example of a CoAP client registering its\n   interest in a\
    \ resource and receiving three notifications: the first\n   with the current state\
    \ upon registration, and then two upon changes\n   to the resource state.  Both\
    \ the registration request and the\n   notifications are identified as such by\
    \ the presence of the Observe\n   Option defined in this document.  In notifications,\
    \ the Observe\n   Option additionally provides a sequence number for reordering\n\
    \   detection.  All notifications carry the token specified by the\n   client,\
    \ so the client can easily correlate them to the request.\n                  \
    \     Client                Server\n                          |              \
    \      |\n                          |  GET /temperature  |\n                 \
    \         |    Token: 0x4a     |   Registration\n                          | \
    \ Observe: 0        |\n                          +------------------->|\n    \
    \                      |                    |\n                          |   \
    \ 2.05 Content    |\n                          |    Token: 0x4a     |   Notification\
    \ of\n                          |  Observe: 12       |   the current state\n \
    \                         |  Payload: 22.9 Cel |\n                          |<-------------------+\n\
    \                          |                    |\n                          |\
    \    2.05 Content    |\n                          |    Token: 0x4a     |   Notification\
    \ upon\n                          |  Observe: 44       |   a state change\n  \
    \                        |  Payload: 22.8 Cel |\n                          |<-------------------+\n\
    \                          |                    |\n                          |\
    \    2.05 Content    |\n                          |    Token: 0x4a     |   Notification\
    \ upon\n                          |  Observe: 60       |   a state change\n  \
    \                        |  Payload: 23.1 Cel |\n                          |<-------------------+\n\
    \                          |                    |\n                  Figure 2:\
    \ Observing a Resource in CoAP\n   Note: In this document, \"Cel\" stands for\
    \ \"degrees Celsius\".\n   A client remains on the list of observers as long as\
    \ the server can\n   determine the client's continued interest in the resource.\
    \  The\n   server may send a notification in a confirmable CoAP message to\n \
    \  request an acknowledgement from the client.  When the client\n   deregisters,\
    \ rejects a notification, or the transmission of a\n   notification times out\
    \ after several transmission attempts, the\n   client is considered no longer\
    \ interested in the resource and is\n   removed by the server from the list of\
    \ observers.\n"
- title: 1.3.  Consistency Model
  contents:
  - "1.3.  Consistency Model\n   While a client is in the list of observers of a resource,\
    \ the goal of\n   the protocol is to keep the resource state observed by the client\
    \ as\n   closely in sync with the actual state at the server as possible.\n  \
    \ It cannot be avoided that the client and the server become out of\n   sync at\
    \ times: First, there is always some latency between the change\n   of the resource\
    \ state and the receipt of the notification.  Second,\n   CoAP messages with notifications\
    \ can get lost, which will cause the\n   client to assume an old state until it\
    \ receives a new notification.\n   And third, the server may erroneously come\
    \ to the conclusion that the\n   client is no longer interested in the resource,\
    \ which will cause the\n   server to stop sending notifications and the client\
    \ to assume an old\n   state until it eventually registers its interest again.\n\
    \   The protocol addresses this issue as follows:\n   o  It follows a best-effort\
    \ approach for sending the current\n      representation to the client after a\
    \ state change: clients should\n      see the new state after a state change as\
    \ soon as possible, and\n      they should see as many states as possible.  This\
    \ is limited by\n      congestion control, however, so a client cannot rely on\
    \ observing\n      every single state that a resource might go through.\n   o\
    \  It labels notifications with a maximum duration up to which it is\n      acceptable\
    \ for the observed state and the actual state to be out\n      of sync.  When\
    \ the age of the notification received reaches this\n      limit, the client cannot\
    \ use the enclosed representation until it\n      receives a new notification.\n\
    \   o  It is designed on the principle of eventual consistency: the\n      protocol\
    \ guarantees that if the resource does not undergo a new\n      change in state,\
    \ eventually all registered observers will have a\n      current representation\
    \ of the latest resource state.\n"
- title: 1.4.  Observable Resources
  contents:
  - "1.4.  Observable Resources\n   A CoAP server is the authority for determining\
    \ under what conditions\n   resources change their state and thus when observers\
    \ are notified of\n   new resource states.  The protocol does not offer explicit\
    \ means for\n   setting up triggers or thresholds; it is up to the server to expose\n\
    \   observable resources that change their state in a way that is useful\n   in\
    \ the application context.\n   For example, a CoAP server with an attached temperature\
    \ sensor could\n   expose one or more of the following resources:\n   o  <coap://server/temperature>,\
    \ which changes its state every few\n      seconds to a current reading of the\
    \ temperature sensor;\n   o  <coap://server/temperature/felt>, which changes its\
    \ state to\n      \"COLD\" whenever the temperature reading drops below a certain\
    \ pre-\n      configured threshold and to \"WARM\" whenever the reading exceeds\
    \ a\n      second, slightly higher threshold;\n   o  <coap://server/temperature/critical?above=42>,\
    \ which changes its\n      state based on the client-specified parameter value\
    \ either every\n      few seconds to the current temperature reading if the temperature\n\
    \      exceeds the threshold or to \"OK\" when the reading drops below;\n   o\
    \  <coap://server/?query=select+avg(temperature)+from+Sensor.window:\n      time(30sec)>,\
    \ which accepts expressions of arbitrary complexity\n      and changes its state\
    \ accordingly.\n   Thus, by designing CoAP resources that change their state on\
    \ certain\n   conditions, it is possible to update the client only when these\n\
    \   conditions occur instead of supplying it continuously with raw sensor\n  \
    \ data.  By parameterizing resources, this is not limited to conditions\n   defined\
    \ by the server, but can be extended to arbitrarily complex\n   queries specified\
    \ by the client.  The application designer therefore\n   can choose exactly the\
    \ right level of complexity for the application\n   envisioned and devices involved\
    \ and is not constrained to a \"one size\n   fits all\" mechanism built into the\
    \ protocol.\n"
- title: 1.5.  Requirements Notation
  contents:
  - "1.5.  Requirements Notation\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 2.  The Observe Option
  contents:
  - "2.  The Observe Option\n   The Observe Option has the following properties. \
    \ Its meaning depends\n   on whether it is included in a GET request or in a response.\n\
    \       +-----+---+---+---+---+---------+--------+--------+---------+\n      \
    \ | No. | C | U | N | R | Name    | Format | Length | Default |\n       +-----+---+---+---+---+---------+--------+--------+---------+\n\
    \       |   6 |   | x | - |   | Observe | uint   | 0-3 B  | (none)  |\n      \
    \ +-----+---+---+---+---+---------+--------+--------+---------+\n            C=Critical,\
    \ U=Unsafe, N=No-Cache-Key, R=Repeatable\n                        Table 1: The\
    \ Observe Option\n   When included in a GET request, the Observe Option extends\
    \ the GET\n   method so it does not only retrieve a current representation of\
    \ the\n   target resource, but also requests the server to add or remove an\n\
    \   entry in the list of observers of the resource depending on the\n   option\
    \ value.  The list entry consists of the client endpoint and the\n   token specified\
    \ by the client in the request.  Possible values are:\n      0 (register) adds\
    \ the entry to the list, if not present;\n      1 (deregister) removes the entry\
    \ from the list, if present.\n   The Observe Option is not critical for processing\
    \ the request.  If\n   the server is unwilling or unable to add a new entry to\
    \ the list of\n   observers, then the request falls back to a normal GET request\
    \ and\n   the response does not include the Observe Option.\n   The Observe Option\
    \ is not part of the Cache-Key: a cacheable response\n   obtained with an Observe\
    \ Option in the request can be used to satisfy\n   a request without an Observe\
    \ Option, and vice versa.  When a stored\n   response with an Observe Option is\
    \ used to satisfy a normal GET\n   request, the option MUST be removed before\
    \ the response is returned.\n   When included in a response, the Observe Option\
    \ identifies the\n   message as a notification.  This implies that a matching\
    \ entry exists\n   in the list of observers and that the server will notify the\
    \ client\n   of changes to the resource state.  The option value is a sequence\n\
    \   number for reordering detection (see Sections 3.4 and 4.4).\n   The value\
    \ of the Observe Option is encoded as an unsigned integer in\n   network byte\
    \ order using a variable number of bytes ('uint' option\n   format); see Section\
    \ 3.2 of RFC 7252 [RFC7252].\n"
- title: 3.  Client-Side Requirements
  contents:
  - '3.  Client-Side Requirements

    '
- title: 3.1.  Request
  contents:
  - "3.1.  Request\n   A client registers its interest in a resource by issuing a\
    \ GET\n   request with an Observe Option set to 0 (register).  If the server\n\
    \   returns a 2.xx response that includes an Observe Option as well, the\n   server\
    \ has successfully added an entry with the client endpoint and\n   request token\
    \ to the list of observers of the target resource, and\n   the client will be\
    \ notified of changes to the resource state.\n   Like a fresh response can be\
    \ used to satisfy a request without\n   contacting the server, the stream of updates\
    \ resulting from one\n   observation request can be used to satisfy another (observation\
    \ or\n   normal GET) request if the target resource is the same.  A client\n \
    \  MUST aggregate such requests and MUST NOT register more than once for\n   the\
    \ same target resource.  The target resource is identified by all\n   options\
    \ in the request that are part of the Cache-Key. This includes,\n   for example,\
    \ the full request URI and the Accept Option.\n"
- title: 3.2.  Notifications
  contents:
  - "3.2.  Notifications\n   Notifications are additional responses sent by the server\
    \ in reply to\n   the single extended GET request that created the registration.\
    \  Each\n   notification includes the token specified by the client in the\n \
    \  request.  The only difference between a notification and a normal\n   response\
    \ is the presence of the Observe Option.\n   Notifications typically have a 2.05\
    \ (Content) response code.  They\n   include an Observe Option with a sequence\
    \ number for reordering\n   detection (see Section 3.4) and a payload in the same\
    \ Content-Format\n   as the initial response.  If the client included one or more\
    \ ETag\n   Options in the GET request (see Section 3.3), notifications can have\n\
    \   a 2.03 (Valid) response code rather than a 2.05 (Content) response\n   code.\
    \  Such notifications include an Observe Option with a sequence\n   number but\
    \ no payload.\n   In the event that the resource changes in a way that would cause\
    \ a\n   normal GET request at that time to return a non-2.xx response (for\n \
    \  example, when the resource is deleted), the server sends a\n   notification\
    \ with an appropriate response code (such as 4.04 Not\n   Found) and removes the\
    \ client's entry from the list of observers of\n   the resource.  Non-2.xx responses\
    \ do not include an Observe Option.\n"
- title: 3.3.  Caching
  contents:
  - "3.3.  Caching\n   As notifications are just additional responses to a GET request,\n\
    \   notifications partake in caching as defined in Section 5.6 of RFC\n   7252\
    \ [RFC7252].  Both the freshness model and the validation model\n   are supported.\n"
- title: 3.3.1.  Freshness
  contents:
  - "3.3.1.  Freshness\n   A client MAY store a notification like a response in its\
    \ cache and\n   use a stored notification that is fresh without contacting the\n\
    \   server.  Like a response, a notification is considered fresh while\n   its\
    \ age is not greater than the value indicated by the Max-Age Option\n   (and no\
    \ newer notification/response has been received).\n   The server will do its best\
    \ to keep the resource state observed by\n   the client as closely in sync with\
    \ the actual state as possible.\n   However, a client cannot rely on observing\
    \ every single state that a\n   resource might go through.  For example, if the\
    \ network is congested\n   or the state changes more frequently than the network\
    \ can handle, the\n   server can skip notifications for any number of intermediate\
    \ states.\n   The server uses the Max-Age Option to indicate an age up to which\
    \ it\n   is acceptable that the observed state and the actual state are\n   inconsistent.\
    \  If the age of the latest notification becomes greater\n   than its indicated\
    \ Max-Age, then the client MUST NOT assume that the\n   enclosed representation\
    \ reflects the actual resource state.\n   To make sure it has a current representation\
    \ and/or to re-register\n   its interest in a resource, a client MAY issue a new\
    \ GET request with\n   the same token as the original at any time.  All options\
    \ MUST be\n   identical to those in the original request except for the set of\
    \ ETag\n   Options.  It is RECOMMENDED that the client does not issue the\n  \
    \ request while it still has a fresh notification/response for the\n   resource\
    \ in its cache.  Additionally, the client SHOULD at least wait\n   for a random\
    \ amount of time between 5 and 15 seconds after Max-Age\n   expired to reduce\
    \ collisions with other clients.\n"
- title: 3.3.2.  Validation
  contents:
  - "3.3.2.  Validation\n   When a client has one or more notifications stored in\
    \ its cache for a\n   resource, it can use the ETag Option in the GET request\
    \ to give the\n   server an opportunity to select a stored notification to be\
    \ used.\n   The client MAY include an ETag Option for each stored response that\n\
    \   is applicable in the GET request.  Whenever the observed resource\n   changes\
    \ to a representation identified by one of the ETag Options,\n   the server can\
    \ select a stored response by sending a 2.03 (Valid)\n   notification with an\
    \ appropriate ETag Option instead of a 2.05\n   (Content) notification.\n   A\
    \ client implementation needs to keep all candidate responses in its\n   cache\
    \ until it is no longer interested in the target resource or it\n   re-registers\
    \ with a new set of entity tags.\n"
- title: 3.4.  Reordering
  contents:
  - "3.4.  Reordering\n   Messages with notifications can arrive in a different order\
    \ than they\n   were sent.  Since the goal is to keep the observed state as closely\n\
    \   in sync with the actual state as possible, a client MUST consider the\n  \
    \ notification that was sent most recently as the freshest, regardless\n   of\
    \ the order of arrival.\n   To provide an order among notifications for the client,\
    \ the server\n   sets the value of the Observe Option in each notification to\
    \ the 24\n   least significant bits of a strictly increasing sequence number.\
    \  An\n   incoming notification was sent more recently than the freshest\n   notification\
    \ so far when one of the following conditions is met:\n                      (V1\
    \ < V2 and V2 - V1 < 2^23) or\n                      (V1 > V2 and V1 - V2 > 2^23)\
    \ or\n                      (T2 > T1 + 128 seconds)\n   where V1 is the value\
    \ of the Observe Option in the freshest\n   notification so far, V2 is the value\
    \ of the Observe Option in the\n   incoming notification, T1 is a client-local\
    \ timestamp for the\n   freshest notification so far, and T2 is a client-local\
    \ timestamp for\n   the incoming notification.\n   Design Note:  The first two\
    \ conditions verify that V1 is less than V2\n      in 24-bit serial number arithmetic\
    \ [RFC1982].  The third condition\n      ensures that if the server is generating\
    \ serial numbers based on a\n      local clock, the time elapsed between the two\
    \ incoming messages is\n      not so large that the difference between V1 and\
    \ V2 has become\n      larger than the largest integer that it is meaningful to\
    \ add to a\n      24-bit serial number; in other words, after 128 seconds have\n\
    \      elapsed without any notification, a client does not need to check\n   \
    \   the sequence numbers to assume that an incoming notification was\n      sent\
    \ more recently than the freshest notification it has received\n      so far.\n\
    \      The duration of 128 seconds was chosen as a nice round number\n      greater\
    \ than MAX_LATENCY (Section 4.8.2 of RFC 7252 [RFC7252]).\n"
- title: 3.5.  Transmission
  contents:
  - "3.5.  Transmission\n   A notification can be confirmable or non-confirmable,\
    \ i.e., it can be\n   sent in a confirmable or a non-confirmable message.  The\
    \ message type\n   used for a notification is independent of the type used for\
    \ the\n   request and of any previous notification.\n   If a client does not recognize\
    \ the token in a confirmable\n   notification, it MUST NOT acknowledge the message\
    \ and SHOULD reject\n   it with a Reset message; otherwise, the client MUST acknowledge\
    \ the\n   message as usual.  In the case of a non-confirmable notification,\n\
    \   rejecting the message with a Reset message is OPTIONAL.\n   An acknowledgement\
    \ message signals to the server that the client is\n   alive and interested in\
    \ receiving further notifications; if the\n   server does not receive an acknowledgement\
    \ in reply to a confirmable\n   notification, it will assume that the client is\
    \ no longer interested\n   and will eventually remove the associated entry from\
    \ the list of\n   observers (Section 4.5).\n"
- title: 3.6.  Cancellation
  contents:
  - "3.6.  Cancellation\n   A client that is no longer interested in receiving notifications\
    \ for\n   a resource can simply \"forget\" the observation.  When the server then\n\
    \   sends the next notification, the client will not recognize the token\n   in\
    \ the message and thus will return a Reset message.  This causes the\n   server\
    \ to remove the associated entry from the list of observers.\n   The entries in\
    \ lists of observers are effectively \"garbage collected\"\n   by the server.\n\
    \   Implementation Note:  Due to potential message loss, the Reset\n      message\
    \ may not reach the server.  The client may therefore have\n      to reject multiple\
    \ notifications, each with one Reset message,\n      until the server finally\
    \ removes the associated entry from the\n      list of observers and stops sending\
    \ notifications.\n   In some circumstances, it may be desirable to cancel an observation\n\
    \   and release the resources allocated by the server to it more eagerly.\n  \
    \ In this case, a client MAY explicitly deregister by issuing a GET\n   request\
    \ that has the Token field set to the token of the observation\n   to be cancelled\
    \ and includes an Observe Option with the value set to\n   1 (deregister).  All\
    \ other options MUST be identical to those in the\n   registration request except\
    \ for the set of ETag Options.  When the\n   server receives such a request, it\
    \ will remove any matching entry\n   from the list of observers and process the\
    \ GET request as usual.\n"
- title: 4.  Server-Side Requirements
  contents:
  - '4.  Server-Side Requirements

    '
- title: 4.1.  Request
  contents:
  - "4.1.  Request\n   A GET request with an Observe Option set to 0 (register) requests\
    \ the\n   server not only to return a current representation of the target\n \
    \  resource, but also to add the client to the list of observers of that\n   resource.\
    \  Upon success, the server returns a current representation\n   of the resource\
    \ and MUST keep this representation updated (as\n   described in Section 1.3)\
    \ as long as the client is on the list of\n   observers.\n   The entry in the\
    \ list of observers is keyed by the client endpoint\n   and the token specified\
    \ by the client in the request.  If an entry\n   with a matching endpoint/token\
    \ pair is already present in the list\n   (which, for example, happens when the\
    \ client wishes to reinforce its\n   interest in a resource), the server MUST\
    \ NOT add a new entry but MUST\n   replace or update the existing one.\n   A server\
    \ that is unable or unwilling to add a new entry to the list\n   of observers\
    \ of a resource MAY silently ignore the registration\n   request and process the\
    \ GET request as usual.  The resulting response\n   MUST NOT include an Observe\
    \ Option, the absence of which signals to\n   the client that it will not be notified\
    \ of changes to the resource\n   and, e.g., needs to poll the resource for its\
    \ state instead.\n   If the Observe Option in a GET request is set to 1 (deregister),\
    \ then\n   the server MUST remove any existing entry with a matching endpoint/\n\
    \   token pair from the list of observers and process the GET request as\n   usual.\
    \  The resulting response MUST NOT include an Observe Option.\n"
- title: 4.2.  Notifications
  contents:
  - "4.2.  Notifications\n   A client is notified of changes to the resource state\
    \ by additional\n   responses sent by the server in reply to the GET request.\
    \  Each such\n   notification response (including the initial response) MUST echo\
    \ the\n   token specified by the client in the GET request.  If there are\n  \
    \ multiple entries in the list of observers, the order in which the\n   clients\
    \ are notified is not defined; the server is free to use any\n   method to determine\
    \ the order.\n   A notification SHOULD have a 2.05 (Content) or 2.03 (Valid) response\n\
    \   code.  However, in the event that the state of a resource changes in\n   a\
    \ way that would cause a normal GET request at that time to return a\n   non-2.xx\
    \ response (for example, when the resource is deleted), the\n   server SHOULD\
    \ notify the client by sending a notification with an\n   appropriate response\
    \ code (such as 4.04 Not Found) and subsequently\n   MUST remove the associated\
    \ entry from the list of observers of the\n   resource.\n   The Content-Format\
    \ specified in a 2.xx notification MUST be the same\n   as the one used in the\
    \ initial response to the GET request.  If the\n   server is unable to continue\
    \ sending notifications in this format, it\n   SHOULD send a notification with\
    \ a 4.06 (Not Acceptable) response code\n   and subsequently MUST remove the associated\
    \ entry from the list of\n   observers of the resource.\n   A 2.xx notification\
    \ MUST include an Observe Option with a sequence\n   number as specified in Section\
    \ 4.4 below; a non-2.xx notification\n   MUST NOT include an Observe Option.\n"
- title: 4.3.  Caching
  contents:
  - "4.3.  Caching\n   As notifications are just additional responses sent by the\
    \ server in\n   reply to a GET request, they are subject to caching as defined\
    \ in\n   Section 5.6 of RFC 7252 [RFC7252].\n"
- title: 4.3.1.  Freshness
  contents:
  - "4.3.1.  Freshness\n   After returning the initial response, the server MUST keep\
    \ the\n   resource state that is observed by the client as closely in sync with\n\
    \   the actual resource state as possible.\n   Since becoming out of sync at times\
    \ cannot be avoided, the server\n   MUST indicate for each representation an age\
    \ up to which it is\n   acceptable that the observed state and the actual state\
    \ are\n   inconsistent.  This age is application dependent and MUST be\n   specified\
    \ in notifications using the Max-Age Option.\n   When the resource does not change\
    \ and the client has a current\n   representation, the server does not need to\
    \ send a notification.\n   However, if the client does not receive a notification,\
    \ the client\n   cannot tell if the observed state and the actual state are still\
    \ in\n   sync.  Thus, when the age of the latest notification becomes greater\n\
    \   than its indicated Max-Age, the client no longer has a usable\n   representation\
    \ of the resource state.  The server MAY wish to prevent\n   that by sending a\
    \ new notification with the unchanged representation\n   and a new Max-Age just\
    \ before the Max-Age indicated earlier expires.\n"
- title: 4.3.2.  Validation
  contents:
  - "4.3.2.  Validation\n   A client can include a set of entity tags in its request\
    \ using the\n   ETag Option.  When an observed resource changes its state and\
    \ the\n   origin server is about to send a 2.05 (Content) notification, then\n\
    \   whenever that notification has an entity tag in the set of entity\n   tags\
    \ specified by the client, the server MAY send a 2.03 (Valid)\n   response with\
    \ an appropriate ETag Option instead.\n"
- title: 4.4.  Reordering
  contents:
  - "4.4.  Reordering\n   Because messages can get reordered, the client needs a way\
    \ to\n   determine if a notification arrived later than a newer notification.\n\
    \   For this purpose, the server MUST set the value of the Observe Option\n  \
    \ of each notification it sends to the 24 least significant bits of a\n   strictly\
    \ increasing sequence number.  The sequence number MAY start\n   at any value\
    \ and MUST NOT increase so fast that it increases by more\n   than 2^23 within\
    \ less than 256 seconds.\n   The sequence number selected for a notification MUST\
    \ be greater than\n   that of any preceding notification sent to the same client\
    \ with the\n   same token for the same resource.  The value of the Observe Option\n\
    \   MUST be current at the time of transmission; if a notification is\n   retransmitted,\
    \ the server MUST update the value of the option to the\n   sequence number that\
    \ is current at that time before retransmission.\n   Implementation Note:  A simple\
    \ implementation that satisfies the\n      requirements is to obtain a timestamp\
    \ from a local clock.  The\n      sequence number then is the timestamp in ticks,\
    \ where 1 tick =\n      (256 seconds)/(2^23) = 30.52 microseconds.  It is not\
    \ necessary\n      that the clock reflects the current time/date.\n      Another\
    \ valid implementation is to store a 24-bit unsigned integer\n      variable per\
    \ resource and increment this variable each time the\n      resource undergoes\
    \ a change of state (provided that the resource\n      changes its state less\
    \ than 2^23 times in the first 256 seconds\n      after every state change). \
    \ This removes the need to update the\n      value of the Observe Option on retransmission\
    \ when the resource\n      state did not change.\n   Design Note:  The choice\
    \ of a 24-bit option value and a time span of\n      256 seconds theoretically\
    \ allows for a notification rate of up to\n      65536 notifications per second.\
    \  Constrained nodes often have\n      rather imprecise clocks, though, and inaccuracies\
    \ of the client\n      and server side may cancel out or add in effect.  Therefore,\
    \ the\n      maximum notification rate is reduced to 32768 notifications per\n\
    \      second.  This is still well beyond the highest known design\n      objective\
    \ of around 1 kHz (most CoAP applications will be several\n      orders of magnitude\
    \ below that) but allows total clock\n      inaccuracies of up to -50/+100%.\n"
- title: 4.5.  Transmission
  contents:
  - "4.5.  Transmission\n   A notification can be sent in a confirmable or a non-confirmable\n\
    \   message.  The message type used is typically application dependent\n   and\
    \ may be determined by the server for each notification\n   individually.\n  \
    \ For example, for resources that change in a somewhat predictable or\n   regular\
    \ fashion, notifications can be sent in non-confirmable\n   messages; for resources\
    \ that change infrequently, notifications can\n   be sent in confirmable messages.\
    \  The server can combine these two\n   approaches depending on the frequency\
    \ of state changes and the\n   importance of individual notifications.\n   A server\
    \ MAY choose to skip sending a notification if it knows that\n   it will send\
    \ another notification soon, for example, when the state\n   of a resource is\
    \ changing frequently.  It also MAY choose to send\n   more than one notification\
    \ for the same resource state.  However,\n   above all, the server MUST ensure\
    \ that a client in the list of\n   observers of a resource eventually observes\
    \ the latest state if the\n   resource does not undergo a new change in state.\n\
    \   For example, when state changes occur in bursts, the server can skip\n   some\
    \ notifications, send the notifications in non-confirmable\n   messages, and make\
    \ sure that the client observes the latest state\n   change by repeating the last\
    \ notification in a confirmable message\n   when the burst is over.\n   The client's\
    \ acknowledgement of a confirmable notification signals\n   that the client is\
    \ interested in receiving further notifications.  If\n   a client rejects a confirmable\
    \ or non-confirmable notification with a\n   Reset message, or if the last attempt\
    \ to retransmit a confirmable\n   notification times out, then the client is considered\
    \ no longer\n   interested and the server MUST remove the associated entry from\
    \ the\n   list of observers.\n   Implementation Note:  To properly process a Reset\
    \ message that\n      rejects a non-confirmable notification, a server needs to\
    \ remember\n      the message IDs of the non-confirmable notifications it sends.\n\
    \      This may be challenging for a server with constrained resources.\n    \
    \  However, since Reset messages are transmitted unreliably, the\n      client\
    \ must be prepared in case the Reset messages are not\n      received by the server.\
    \  Thus, a server can always pretend that a\n      Reset message rejecting a non-confirmable\
    \ notification was lost.\n      If a server does this, it could accelerate cancellation\
    \ by sending\n      the following notifications to that client in confirmable\n\
    \      messages.\n   A server that transmits notifications mostly in non-confirmable\n\
    \   messages MUST send a notification in a confirmable message instead of\n  \
    \ a non-confirmable message at least every 24 hours.  This prevents a\n   client\
    \ that went away or is no longer interested from remaining in\n   the list of\
    \ observers indefinitely.\n"
- title: 4.5.1.  Congestion Control
  contents:
  - "4.5.1.  Congestion Control\n   Basic congestion control for CoAP is provided\
    \ by the exponential\n   back-off mechanism in Section 4.2 of RFC 7252 [RFC7252]\
    \ and the\n   limitations in Section 4.7 of RFC 7252 [RFC7252].  However, CoAP\n\
    \   places the responsibility of congestion control for simple request/\n   response\
    \ interactions only on the clients: rate-limiting request\n   transmission implicitly\
    \ controls the transmission of the responses.\n   When a single request yields\
    \ a potentially infinite number of\n   notifications, additional responsibility\
    \ needs to be placed on the\n   server.\n   In order not to cause congestion,\
    \ servers MUST strictly limit the\n   number of simultaneous outstanding notifications/responses\
    \ that they\n   transmit to a given client to NSTART (1 by default; see Section\
    \ 4.7\n   of RFC 7252 [RFC7252]).  An outstanding notification/response is\n \
    \  either a confirmable message for which an acknowledgement has not yet\n   been\
    \ received and whose last retransmission attempt has not yet timed\n   out or\
    \ a non-confirmable message for which the waiting time that\n   results from the\
    \ following rate-limiting rules has not yet elapsed.\n   The server SHOULD NOT\
    \ send more than one non-confirmable notification\n   per round-trip time (RTT)\
    \ to a client on average.  If the server\n   cannot maintain an RTT estimate for\
    \ a client, it SHOULD NOT send more\n   than one non-confirmable notification\
    \ every 3 seconds and SHOULD use\n   an even less aggressive rate when possible\
    \ (see also Section 3.1.2 of\n   RFC 5405 [RFC5405]).\n   Further congestion control\
    \ optimizations and considerations are\n   expected in the future with advanced\
    \ CoAP congestion control\n   mechanisms.\n"
- title: 4.5.2.  Advanced Transmission
  contents:
  - "4.5.2.  Advanced Transmission\n   The state of an observed resource may change\
    \ while the number of\n   simultaneous outstanding notifications/responses to\
    \ a client on the\n   list of observers is greater than or equal to NSTART.  In\
    \ this case,\n   the server cannot notify the client of the new resource state\n\
    \   immediately but has to wait for an outstanding notification/response\n   to\
    \ complete first.\n   If there exists an outstanding notification/response that\
    \ the server\n   transmits to the client and that pertains to the changed resource,\n\
    \   then it is desirable for the server to stop working towards getting\n   the\
    \ representation of the old resource state to the client and to\n   start transmitting\
    \ the current representation to the client instead,\n   so the resource state\
    \ observed by the client stays closer in sync\n   with the actual state at the\
    \ server.\n   For this purpose, the server MAY optimize the transmission process\
    \ by\n   aborting the transmission of the old notification (but not before the\n\
    \   current transmission attempt is completed) and starting a new\n   transmission\
    \ for the new notification (but with the retransmission\n   timer and counter\
    \ of the aborted transmission retained).\n   In more detail, a server MAY supersede\
    \ an outstanding transmission\n   that pertains to an observation as follows:\n\
    \   1.  Wait for the current (re)transmission attempt to be acknowledged,\n  \
    \     rejected, or to time out (confirmable transmission); or, wait for\n    \
    \   the waiting time to elapse or the transmission to be rejected\n       (non-confirmable\
    \ transmission).\n   2.  If the transmission is rejected or it was the last attempt\
    \ to\n       retransmit a notification, remove the associated entry from the\n\
    \       list of observers of the observed resource.\n   3.  If the entry is still\
    \ in the list of observers, start to transmit\n       a new notification with\
    \ a representation of the current resource\n       state.  Should the resource\
    \ have changed its state more than once\n       in the meantime, the notifications\
    \ for the intermediate states\n       are silently skipped.\n   4.  The new notification\
    \ is transmitted with a new Message ID and the\n       following transmission\
    \ parameters: if the previous\n       (re)transmission attempt timed out, retain\
    \ its transmission\n       parameters, increment the retransmission counter, and\
    \ double the\n       timeout; otherwise, initialize the transmission parameters\
    \ as\n       usual (see Section 4.2 of RFC 7252 [RFC7252]).\n   It is possible\
    \ that the server later receives an acknowledgement for\n   a confirmable notification\
    \ that it superseded this way.  Even though\n   this does not signal consistency,\
    \ it is valuable in that it signals\n   the client's further interest in the resource.\
    \  The server therefore\n   should avoid inadvertently removing the associated\
    \ entry from the\n   list of observers.\n"
- title: 5.  Intermediaries
  contents:
  - "5.  Intermediaries\n   A client may be interested in a resource in the namespace\
    \ of a server\n   that is reached through a chain of one or more CoAP intermediaries.\n\
    \   In this case, the client registers its interest with the first\n   intermediary\
    \ towards the server, acting as if it was communicating\n   with the server itself,\
    \ as specified in Section 3.  It is the task of\n   this intermediary to provide\
    \ the client with a current representation\n   of the target resource and to keep\
    \ the representation updated upon\n   changes to the resource state, as specified\
    \ in Section 4.\n   To perform this task, the intermediary SHOULD make use of\
    \ the\n   protocol specified in this document, taking the role of the client\n\
    \   and registering its own interest in the target resource with the next\n  \
    \ hop towards the server.  If the response returned by the next hop\n   doesn't\
    \ include an Observe Option, the intermediary MAY resort to\n   polling the next\
    \ hop or MAY itself return a response without an\n   Observe Option.\n   The communication\
    \ between each pair of hops is independent; each hop\n   in the server role MUST\
    \ determine individually how many notifications\n   to send, of which message\
    \ type, and so on.  Each hop MUST generate\n   its own values for the Observe\
    \ Option in notifications and MUST set\n   the value of the Max-Age Option according\
    \ to the age of the local\n   current representation.\n   If two or more clients\
    \ have registered their interest in a resource\n   with an intermediary, the intermediary\
    \ MUST register itself only once\n   with the next hop and fan out the notifications\
    \ it receives to all\n   registered clients.  This relieves the next hop from\
    \ sending the same\n   notifications multiple times and thus enables scalability.\n\
    \   An intermediary is not required to act on behalf of a client to\n   observe\
    \ a resource; an intermediary MAY observe a resource, for\n   example, just to\
    \ keep its own cache up to date.\n   See Appendix A.2 for examples.\n"
- title: 6.  Web Linking
  contents:
  - "6.  Web Linking\n   A web link [RFC5988] to a resource accessible over CoAP (for\
    \ example,\n   in a link-format document [RFC6690]) MAY include the target attribute\n\
    \   \"obs\".\n   The \"obs\" attribute, when present, is a hint indicating that\
    \ the\n   destination of a link is useful for observation and thus, for\n   example,\
    \ should have a suitable graphical representation in a user\n   interface.  Note\
    \ that this is only a hint; it is not a promise that\n   the Observe Option can\
    \ actually be used to perform the observation.\n   A client may need to resort\
    \ to polling the resource if the Observe\n   Option is not returned in the response\
    \ to the GET request.\n   A value MUST NOT be given for the \"obs\" attribute;\
    \ any present value\n   MUST be ignored by parsers.  The \"obs\" attribute MUST\
    \ NOT appear more\n   than once in a given link-value; occurrences after the first\
    \ MUST be\n   ignored by parsers.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   The security considerations in Section 11 of\
    \ [RFC7252], the CoAP\n   specification, apply.\n   Observing resources can dramatically\
    \ increase the negative effects of\n   amplification attacks.  That is, not only\
    \ can notifications messages\n   be much larger than the request message, but\
    \ the nature of the\n   protocol can cause a significant number of notifications\
    \ to be\n   generated.  Without client authentication, a server therefore MUST\n\
    \   strictly limit the number of notifications that it sends between\n   receiving\
    \ acknowledgements that confirm the actual interest of the\n   client in the data;\
    \ i.e., any notifications sent in non-confirmable\n   messages MUST be interspersed\
    \ with confirmable messages.  Note that\n   an attacker may still spoof the acknowledgements\
    \ if the confirmable\n   messages are sufficiently predictable.\n   The protocol\
    \ follows a best-effort approach for keeping the state\n   observed by a client\
    \ and the actual resource state at a server in\n   sync.  This may have the client\
    \ and the server become out of sync at\n   times.  Depending on the sensitivity\
    \ of the observed resource,\n   operating on an old state might be a security\
    \ threat.  The client\n   therefore must be careful not to use a representation\
    \ after its Max-\n   Age expires, and the server must set the Max-Age Option to\
    \ a sensible\n   value.\n   As with any protocol that creates state, attackers\
    \ may attempt to\n   exhaust the resources that the server has available for maintaining\n\
    \   the list of observers for each resource.  Servers may want to apply\n   access\
    \ controls to this creation of state.  As degraded behavior, the\n   server can\
    \ always fall back to processing the request as a normal GET\n   request (without\
    \ an Observe Option) if it is unwilling or unable to\n   add a client to the list\
    \ of observers of a resource, including if\n   system resources are exhausted\
    \ or nearing exhaustion.\n   Intermediaries must be careful to ensure that notifications\
    \ cannot be\n   employed to create a loop.  A simple way to break any loops is\
    \ to\n   employ caches for forwarding notifications in intermediaries.\n   Resources\
    \ can be observed over CoAP that is secured by Datagram\n   Transport Layer Security\
    \ (DTLS) using any of the security modes\n   described in Section 9 of RFC 7252.\
    \  The use of DTLS is indicated by\n   the \"coaps\" URI scheme.  All notifications\
    \ resulting from a GET\n   request with an Observe Option MUST be returned within\
    \ the same epoch\n   of the same connection as the request.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   The following entry has been added to the CoAP Option\
    \ Numbers\n   registry:\n                     +--------+---------+-----------+\n\
    \                     | Number | Name    | Reference |\n                     +--------+---------+-----------+\n\
    \                     |      6 | Observe | RFC 7641  |\n                     +--------+---------+-----------+\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC5988]  Nottingham, M., \"Web Linking\", RFC 5988,\n              DOI 10.17487/RFC5988,\
    \ October 2010,\n              <http://www.rfc-editor.org/info/rfc5988>.\n   [RFC7252]\
    \  Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained\n              Application\
    \ Protocol (CoAP)\", RFC 7252,\n              DOI 10.17487/RFC7252, June 2014,\n\
    \              <http://www.rfc-editor.org/info/rfc7252>.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [GOF]      Gamma, E., Helm, R., Johnson, R.,\
    \ and J. Vlissides,\n              \"Design Patterns: Elements of Reusable Object-Oriented\n\
    \              Software\", Addison-Wesley Professional Computing Series,\n   \
    \           1994.\n   [REST]     Fielding, R., \"Architectural Styles and the\
    \ Design of\n              Network-based Software Architectures\", Ph.D. Dissertation,\n\
    \              University of California, Irvine, 2000,\n              <http://www.ics.uci.edu/~fielding/pubs/dissertation/\n\
    \              fielding_dissertation.pdf>.\n   [RFC1982]  Elz, R. and R. Bush,\
    \ \"Serial Number Arithmetic\", RFC 1982,\n              DOI 10.17487/RFC1982,\
    \ August 1996,\n              <http://www.rfc-editor.org/info/rfc1982>.\n   [RFC5405]\
    \  Eggert, L. and G. Fairhurst, \"Unicast UDP Usage Guidelines\n             \
    \ for Application Designers\", BCP 145, RFC 5405,\n              DOI 10.17487/RFC5405,\
    \ November 2008,\n              <http://www.rfc-editor.org/info/rfc5405>.\n  \
    \ [RFC5989]  Roach, A., \"A SIP Event Package for Subscribing to Changes\n   \
    \           to an HTTP Resource\", RFC 5989, DOI 10.17487/RFC5989,\n         \
    \     October 2010, <http://www.rfc-editor.org/info/rfc5989>.\n   [RFC6202]  Loreto,\
    \ S., Saint-Andre, P., Salsano, S., and G. Wilkins,\n              \"Known Issues\
    \ and Best Practices for the Use of Long\n              Polling and Streaming\
    \ in Bidirectional HTTP\", RFC 6202,\n              DOI 10.17487/RFC6202, April\
    \ 2011,\n              <http://www.rfc-editor.org/info/rfc6202>.\n   [RFC6690]\
    \  Shelby, Z., \"Constrained RESTful Environments (CoRE) Link\n              Format\"\
    , RFC 6690, DOI 10.17487/RFC6690, August 2012,\n              <http://www.rfc-editor.org/info/rfc6690>.\n\
    \   [RFC7228]  Bormann, C., Ersue, M., and A. Keranen, \"Terminology for\n   \
    \           Constrained-Node Networks\", RFC 7228,\n              DOI 10.17487/RFC7228,\
    \ May 2014,\n              <http://www.rfc-editor.org/info/rfc7228>.\n   [RFC7230]\
    \  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n             \
    \ Protocol (HTTP/1.1): Message Syntax and Routing\",\n              RFC 7230,\
    \ DOI 10.17487/RFC7230, June 2014,\n              <http://www.rfc-editor.org/info/rfc7230>.\n"
- title: Appendix A.  Examples
  contents:
  - 'Appendix A.  Examples

    '
- title: A.1.  Client/Server Examples
  contents:
  - "A.1.  Client/Server Examples\n         Observed   CLIENT  SERVER     Actual\n\
    \     t   State         |      |         State\n         ____________  |     \
    \ |  ____________\n     1                 |      |\n     2    unknown      | \
    \     |     18.5 Cel\n     3                 +----->|                  Header:\
    \ GET 0x41011633\n     4                 | GET  |                   Token: 0x4a\n\
    \     5                 |      |                Uri-Path: temperature\n     6\
    \                 |      |                 Observe: 0 (register)\n     7     \
    \            |      |\n     8                 |      |\n     9   ____________\
    \  |<-----+                  Header: 2.05 0x61451633\n    10                 |\
    \ 2.05 |                   Token: 0x4a\n    11    18.5 Cel     |      |      \
    \           Observe: 9\n    12                 |      |                 Max-Age:\
    \ 15\n    13                 |      |                 Payload: \"18.5 Cel\"\n\
    \    14                 |      |\n    15                 |      |  ____________\n\
    \    16   ____________  |<-----+                  Header: 2.05 0x51457b50\n  \
    \  17                 | 2.05 |     19.2 Cel      Token: 0x4a\n    18    19.2 Cel\
    \     |      |                 Observe: 16\n    29                 |      |  \
    \               Max-Age: 15\n    20                 |      |                 Payload:\
    \ \"19.2 Cel\"\n    21                 |      |\n     Figure 3: A Client Registers\
    \ and Receives One Notification of the\n         Current State and One of a New\
    \ State upon a State Change\n         Observed   CLIENT  SERVER     Actual\n \
    \    t   State         |      |         State\n         ____________  |      |\
    \  ____________\n    22                 |      |\n    23    19.2 Cel     |   \
    \   |     19.2 Cel\n    24                 |      |  ____________\n    25    \
    \             | X----+                  Header: 2.05 0x51457b51\n    26      \
    \           | 2.05 |     19.7 Cel      Token: 0x4a\n    27                 | \
    \     |                 Observe: 25\n    28                 |      |         \
    \        Max-Age: 15\n    29                 |      |                 Payload:\
    \ \"19.7 Cel\"\n    30                 |      |\n    31   ____________  |    \
    \  |\n    32                 |      |\n    33    19.2 Cel     |      |\n    34\
    \    (stale)      |      |\n    35                 |      |\n    36          \
    \       |      |\n    37                 |      |\n    38                 +----->|\
    \                  Header: GET 0x41011634\n    39                 | GET  |   \
    \                Token: 0xb2\n    40                 |      |                Uri-Path:\
    \ temperature\n    41                 |      |                 Observe: 0 (register)\n\
    \    42                 |      |\n    43                 |      |\n    44   ____________\
    \  |<-----+                  Header: 2.05 0x61451634\n    45                 |\
    \ 2.05 |                   Token: 0xb2\n    46    19.7 Cel     |      |      \
    \           Observe: 44\n    47                 |      |                 Max-Age:\
    \ 15\n    48                 |      |                    ETag: 0x78797a7a79\n\
    \    49                 |      |                 Payload: \"19.7 Cel\"\n    50\
    \                 |      |\n           Figure 4: The Client Re-registers after\
    \ Max-Age Ends\n         Observed   CLIENT  SERVER     Actual\n     t   State\
    \         |      |         State\n         ____________  |      |  ____________\n\
    \    51                 |      |\n    52    19.7 Cel     |      |     19.7 Cel\n\
    \    53                 |      |\n    54                 |      |  ____________\n\
    \    55                 |    crash\n    56                 |\n    57         \
    \        |\n    58                 |\n    59   ____________  |\n    60       \
    \          |\n    61    19.7 Cel     |\n    62    (stale)      |\n    63     \
    \            |   reboot____________\n    64                 |      |\n    65 \
    \                |      |     20.0 Cel\n    66                 |      |\n    67\
    \                 +----->|                  Header: GET 0x41011635\n    68   \
    \              | GET  |                   Token: 0xf9\n    69                \
    \ |      |                Uri-Path: temperature\n    70                 |    \
    \  |                 Observe: 0 (register)\n    71                 |      |  \
    \                  ETag: 0x78797a7a79\n    72                 |      |\n    73\
    \                 |      |\n    74   ____________  |<-----+                  Header:\
    \ 2.05 0x61451635\n    75                 | 2.05 |                   Token: 0xf9\n\
    \    76    20.0 Cel     |      |                 Observe: 74\n    77         \
    \        |      |                 Max-Age: 15\n    78                 |      |\
    \                 Payload: \"20.0 Cel\"\n    79                 |      |\n   \
    \ 80                 |      |  ____________\n    81   ____________  |<-----+ \
    \                 Header: 2.03 0x5143aa0c\n    82                 | 2.03 |   \
    \  19.7 Cel      Token: 0xf9\n    83    19.7 Cel     |      |                \
    \ Observe: 81\n    84                 |      |                    ETag: 0x78797a7a79\n\
    \    85                 |      |                 Max-Age: 15\n    86         \
    \        |      |\n        Figure 5: The Client Re-registers and Gives the Server\
    \ the\n                  Opportunity to Select a Stored Response\n         Observed\
    \   CLIENT  SERVER     Actual\n     t   State         |      |         State\n\
    \         ____________  |      |  ____________\n    87                 |     \
    \ |\n    88    19.7 Cel     |      |     19.7 Cel\n    89                 |  \
    \    |\n    90                 |      |  ____________\n    91   ____________ \
    \ |<-----+                  Header: 2.05 0x4145aa0f\n    92                 |\
    \ 2.05 |     19.3 Cel      Token: 0xf9\n    93    19.3 Cel     |      |      \
    \           Observe: 91\n    94                 |      |                 Max-Age:\
    \ 15\n    95                 |      |                 Payload: \"19.3 Cel\"\n\
    \    96                 |      |\n    97                 |      |\n    98    \
    \             +- - ->|                  Header: 0x7000aa0f\n    99           \
    \      |      |\n   100                 |      |\n   101                 |   \
    \   |\n   102                 |      |  ____________\n   103                 |\
    \      |\n   104                 |      |     19.0 Cel\n   105               \
    \  |      |\n   106   ____________  |      |\n   107                 |      |\n\
    \   108    19.3 Cel     |      |\n   109    (stale)      |      |\n   110    \
    \             |      |\n    Figure 6: The Client Rejects a Notification and Thereby\
    \ Cancels the\n                                Observation\n"
- title: A.2.  Proxy Examples
  contents:
  - "A.2.  Proxy Examples\n   CLIENT  PROXY  SERVER\n      |      |      |\n     \
    \ |      +----->|     Header: GET 0x41015fb8\n      |      | GET  |      Token:\
    \ 0x1a\n      |      |      |   Uri-Host: sensor.example\n      |      |     \
    \ |   Uri-Path: status\n      |      |      |    Observe: 0 (register)\n     \
    \ |      |      |\n      |      |<-----+     Header: 2.05 0x61455fb8\n      |\
    \      | 2.05 |      Token: 0x1a\n      |      |      |    Observe: 42\n     \
    \ |      |      |    Max-Age: 60\n      |      |      |    Payload: \"ready\"\n\
    \      |      |      |\n      +----->|      |     Header: GET 0x41011633\n   \
    \   | GET  |      |      Token: 0x9a\n      |      |      |  Proxy-Uri: coap://sensor.example/status\n\
    \      |      |      |\n      |<-----+      |     Header: 2.05 0x61451633\n  \
    \    | 2.05 |      |      Token: 0x9a\n      |      |      |    Max-Age: 53\n\
    \      |      |      |    Payload: \"ready\"\n      |      |      |\n      | \
    \     |<-----+     Header: 2.05 0x514505fc0\n      |      | 2.05 |      Token:\
    \ 0x1a\n      |      |      |    Observe: 135\n      |      |      |    Max-Age:\
    \ 60\n      |      |      |    Payload: \"busy\"\n      |      |      |\n    \
    \  +----->|      |     Header: GET 0x41011634\n      | GET  |      |      Token:\
    \ 0x9b\n      |      |      |  Proxy-Uri: coap://sensor.example/status\n     \
    \ |      |      |\n      |<-----+      |     Header: 2.05 0x61451634\n      |\
    \ 2.05 |      |      Token: 0x9b\n      |      |      |    Max-Age: 49\n     \
    \ |      |      |    Payload: \"busy\"\n      |      |      |\n    Figure 7: A\
    \ Proxy Observes a Resource to Keep its Cache Up to Date\n   CLIENT  PROXY  SERVER\n\
    \      |      |      |\n      +----->|      |     Header: GET 0x41011635\n   \
    \   | GET  |      |      Token: 0x6a\n      |      |      |  Proxy-Uri: coap://sensor.example/status\n\
    \      |      |      |    Observe: 0 (register)\n      |      |      |\n     \
    \ |<- - -+      |     Header: 0x60001635\n      |      |      |\n      |     \
    \ +----->|     Header: GET 0x4101af90\n      |      | GET  |      Token: 0xaa\n\
    \      |      |      |   Uri-Host: sensor.example\n      |      |      |   Uri-Path:\
    \ status\n      |      |      |    Observe: 0 (register)\n      |      |     \
    \ |\n      |      |<-----+     Header: 2.05 0x6145af90\n      |      | 2.05 |\
    \      Token: 0xaa\n      |      |      |    Observe: 67\n      |      |     \
    \ |    Max-Age: 60\n      |      |      |    Payload: \"ready\"\n      |     \
    \ |      |\n      |<-----+      |     Header: 2.05 0x4145af94\n      | 2.05 |\
    \      |      Token: 0x6a\n      |      |      |    Observe: 17346\n      |  \
    \    |      |    Max-Age: 60\n      |      |      |    Payload: \"ready\"\n  \
    \    |      |      |\n      +- - ->|      |     Header: 0x6000af94\n      |  \
    \    |      |\n      |      |<-----+     Header: 2.05 0x51455a20\n      |    \
    \  | 2.05 |      Token: 0xaa\n      |      |      |    Observe: 157\n      | \
    \     |      |    Max-Age: 60\n      |      |      |    Payload: \"busy\"\n  \
    \    |      |      |\n      |<-----+      |     Header: 2.05 0x5145af9b\n    \
    \  | 2.05 |      |      Token: 0x6a\n      |      |      |    Observe: 17436\n\
    \      |      |      |    Max-Age: 60\n      |      |      |    Payload: \"busy\"\
    \n      |      |      |\n          Figure 8: A Client Observes a Resource through\
    \ a Proxy\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Carsten Bormann was an original author of this document\
    \ and is\n   acknowledged for significant contribution to this document.\n   Thanks\
    \ to Daniele Alessandrelli, Jari Arkko, Peter A. Bigot, Angelo\n   P. Castellani,\
    \ Gilbert Clark, Esko Dijk, Thomas Fossati, Brian Frank,\n   Bert Greevenbosch,\
    \ Jeroen Hoebeke, Cullen Jennings, Matthias\n   Kovatsch, Barry Leiba, Salvatore\
    \ Loreto, Charles Palmer, Akbar\n   Rahman, Zach Shelby, and Floris Van den Abeele\
    \ for helpful comments\n   and discussions that have shaped the document.\n  \
    \ This work was supported in part by Klaus Tschira Foundation, Intel,\n   Cisco,\
    \ and Nokia.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Klaus Hartke\n   Universitaet Bremen TZI\n   Postfach 330440\n\
    \   Bremen  D-28359\n   Germany\n   Phone: +49-421-218-63905\n   Email: hartke@tzi.org\n"
