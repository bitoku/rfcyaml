- title: __initial_text__
  contents:
  - "        A Virtual Terminal Management Model\n        RFC 782\n        prepared\
    \ for \n        Defense Communications Agency\n        WWMCCS ADP Directorate\n\
    \        Command and Control Technical Center\n        11440 Isaac Newton Square\n\
    \        Reston, Virginia 22090\n        by\n        Jose Nabielsky\n        Anita\
    \ P. Skelton\n        The MITRE Corporation\n                          TABLE OF\
    \ CONTENTS\n                                                                Page\n\
    LIST OF ILLUSTRATIONS                                             vi\n1.0  INTRODUCTION\
    \                                                  1\n1.1  The Workstation Environment\
    \                                   1\n1.2  Virtual Terminal Management      \
    \                             2\n1.3  The Scope                              \
    \                       3\n1.4  Related Work                                 \
    \                 4\n2.0  THE VTM MODEL                                      \
    \           5\n2.1  The VTM Model Components                                 \
    \     7\n2.2  The Virtual Terminal Model                                   10\n\
    \     2.2.1  Virtual Terminal Connectivity                         11\n     2.2.2\
    \  Virtual Terminal Organization                         11\n            2.2.2.1\
    \  The Virtual Keys                             12\n            2.2.2.2  The Virtual\
    \ Controller                       12\n            2.2.2.3  The Virtual Display\
    \                          12\n     2.2.3  Virtual Terminal Architecture     \
    \                    13\n            2.2.3.1  Communication Variables        \
    \              13\n            2.2.3.2  Virtual Display with File Extension  \
    \        13\n            2.2.3.3  Virtual Display Windows                    \
    \  14\n2.3  The Workstation Model                                        17\n\
    \     2.3.1  The Adaptation Unit                                   17\n     2.3.2\
    \  The Executive                                         18\nREFERENCES      \
    \                                                  19\n                      \
    \                                          Page\nFigure Number\n     2.1     \
    \  The Virtual Terminal Model                          7\n     2.2       The Workstation\
    \ Model                               8\n     2.3       VT 0 (expanded from previous\
    \ figure)                9\n     2.4       The Domains                       \
    \                 14\n1.0  INTRODUCTION\n     Recent advances in micro-electronics\
    \ have brought us to the  age\nof the inexpensive, yet powerful, microprocessor.\
    \  Closely resembling\nthe advances of the 1960's which brought about  the  transition\
    \  from\nbatch  processing  to time-sharing, this technological trend suggests\n\
    the birth of decentralized architectures where the  processing  power\nis  shifted\
    \  closer  to  the user in the form of intelligent personal\nworkstations.  The\
    \ virtual terminal model described in this  document\ncaters to this anticipated\
    \ personal computing environment.\n1.1  The Workstation Environment\n     A personal\
    \ workstation is a computing engine which  consists  of\nhardware  and  software\
    \ dedicated to serve a single user.  As part of\nits architecture, the workstation\
    \ can invoke the resources of  other,\nphysically  separate  components, effectively\
    \ extending this personal\nenvironment well beyond the bounds of the single workstation.\n\
    \     In this personal environment,  processing  resources  previously\nshared\
    \  among  multiple  users  now become dedicated to a single one,\nwith a large\
    \ part of these resources summoned to provide an effective\nhuman-machine  interface.\
    \   As a consequence, modalities of input and\noutput that were unfeasible under\
    \ the time-shared regime now become a\npart of a conversational language  between\
    \ user and workstation.  Due\nto the availability of processing cycles, and the\
    \  closeness  of  the\nuser devices to these cycles, the workstation can support\
    \ interactive\ndevices, and dialogue modes using these devices, which could  not\
    \  be\nafforded before.\n     The workstation can provide the  user  with  the\
    \  mechanisms  to\nconduct  several  concurrent  conversations  with user-agents\
    \ located\nelsewhere in the global architecture.   One  such  mechanism  is  the\n\
    partitioning  of  the  workstation  physical  display  into  multiple\nlogical\
    \  displays,  with  one  or  more  of  these  logical  displays\nproviding a dedicated\
    \ workspace between user and agent.\n     The nature of the conversations on these\
    \ logical  displays  need\nnot  be  limited  to  conventional  alphanumeric  input\
    \  and  output.\nConversations using input tools  such  as  positioning  and \
    \ pointing\ndevices  (e.g.,  mouse,  tablet, and such), and using high-resolution\n\
    graphics objects for output (e.g., line drawings, raster  blocks  and\nimages,\
    \  possibly  intermixed with text) should be possible on one or\nmore of these\
    \ screens.\n     Moreover, as long as the technological trend  continues  in \
    \ its\npredicted  path,  one can postulate a workstation which could support\n\
    synchronized   with  text  and  graphics.   At  present,  multi-media\ninformation\
    \   management   (i.e.,   acquisition,   processing,    and\ndissemination)  is\
    \  an  active  research area, but eventually it will\nbecome an engineering problem\
    \ which, when  solved,  will  add  a  new\ndimension  to  already feasible modes\
    \ of interaction between user and\nworkstation.\n1.2  Virtual Terminal Management\n\
    \     All virtual terminal protocols  (VTPs)  provide  a  vehicle  for\ndevice-independent,\
    \     bi-directional,     8-bit    byte    oriented\ncommunications between two\
    \ VTP users.  Most Vo so by invoking  a\ndevice abstraction of real terminals,\
    \ called a virtual terminal.\n     As with a real device, a virtual  terminal\
    \  has  a  well-defined\narchitecture  with  its  own character sets and functions.\
    \ A VTP uses\nthe architectural features of  the  virtual  terminal  to  provide\
    \  a\ncommon  language,  an  intermediate  representation,  between its two\n\
    communicating entities.  However a  VTP  user  does  not  communicate\ndirectly\
    \  with  this  virtual  terminal.   A function of a VTP is the\nlocal mapping\
    \ between the site-specific order codes and  the  virtual\nterminal  domain, \
    \ thus allowing this adaptation to be transparent to\nthe VTP users.\n     The\
    \ model of a personal workstation as a dedicated  device  with\nconsiderable \
    \  resources    affects  the  way  we  conceptualize  the\narchitecture of virtual\
    \ terminals,  both  in  breadth  and  depth  of\nfunction.   It also affects the\
    \ way we view the virtual terminal vis-\na-vis its local correspondents, the personal\
    \  workstations,  and  its\nremote correspondents, the other virtual terminals.\n\
    \     This document presents a radical view of  virtual  terminals  as\nresource\
    \  sharing  devices.   The  classical  concept  of  a  virtual\nterminal as a\
    \ two-way device with a  limited  architecture  has  been\ndismissed.   Instead,\
    \  we  view a virtual terminal as an n-way device\nwith multiple correspondents\
    \ sharing access to its virtual \"keyboard\"\nand  \"display.\"  In  this  model,\
    \ a virtual terminal has two kinds of\ncorrespondents:  adaptation units, and\
    \ other virtual terminals.   The\nadaptation  units  serve  as  interface  agents\
    \  between  the virtual\nterminal and its users, providing the step transformation\
    \ between the\nuser-specific   order   codes  and  the  virtual  terminal  interface\n\
    language.  In turn,  the  other  virtual  terminals  are  cooperating\nco-equals\
    \  of the  virtual  terminal, interacting with it to maintain\nglobal control\
    \ and data store synchrony. Resembling the administrator\nof  a  local  copy \
    \ of  a distributed data base, the virtual terminal\ninteracts with the other\
    \ virtual  terminals  (the  remote  data  base\nmanagers)  and  with  the  local\
    \  adaptation  units  (the  data  base\ndata  store  (the  local  copy  of  the\
    \ distributed data base), while\nproviding concurrency control to maintain a \"\
    single user  view\"  when\nso desired.\n     To communicate with its correspondents,\
    \ a virtual terminal  uses\ntwo virtual languages. In the case where the correspondent\
    \ is another\nvirtual terminal, it  uses  the  language  of  the  virtual  terminal\n\
    protocol;  in the case where the correspondent is an adaptation unit,\nit uses\
    \ an interface language closer to the physical architecture  of\nthe end-user,\
    \ but a virtual language nevertheless.\n     In essence, the virtual terminal\
    \ has become a device in its  own\nright,  free  from  a  single physical realization\
    \ and also dedicated\nownership. As a result, a single workstation not only may\
    \ request any\nnumber  of  virtual  terminals,  but  a  number  of  workstations\
    \ may\nshare -- and interact with -- a particular virtual terminal.\n     The\
    \ functional breadth of virtual terminals has  been  augmented\nby  the  concept\
    \  of  virtual  terminal  classes.   Each  class is an\nabstraction of a particular\
    \ device architecture.  There  are  stream,\nline,  logical  page,  physical page,\
    \ and graphics virtual terminals,\nall made up of:  a class-constrained data structure\
    \ and its attendant\noperations  (the virtual display); a general controlling\
    \ element (the\nvirtual controller); and an input selector (the virtual keys).\n\
    \     Finally, the functional depth of the virtual terminal  has  been\nextended\
    \  by  architectural  features  previously  unavailable.   The\nvirtual terminal\
    \ becomes a  multi-user  device  with  a  non-volatile\nvirtual  display available\
    \ for selective viewing.  These concepts are\ndiscussed is some detail in the\
    \ chapter that follows.\n1.3  The Scope\n     An overview of the virtual terminal\
    \ model and the management  of\ncommunicating  virtual  terminals  is  presented.\
    \   A detailed design\ndescription  of  the  data  structures  and  accompanying\
    \  addressing\nfunctions  has been completed.  The operations and control mechanisms\n\
    are less complete.  Before  the  design  is  solidified,  an  initial\nmimimal\
    \ implementation will be made to validate the model.\n     This document represents\
    \ work in progress; current international\ninterest  in  virtual  terminal  protocols\
    \ has motivated us to submit\nthis as an example of  mechanisms  that  a  virtual\
    \  terminal  should\nsupport.   The  model  provides a framework for supporting\
    \ device and\nprocessing  capabilities  not  yet  commonly  available.   A  virtual\n\
    terminal  protocol standardization effort may not want to include all\nthe mechanisms\
    \ that are described here, but it is our contention that\n1.4  Related Work\n\
    \     The concepts presented in this document  are  the  offspring  of\nprevious\
    \  work  in  the  area  of  personal  computing,  and  of user\ninterfaces to\
    \ (distributed) systems.  The bibliography at the end  of\nthe  document  collects\
    \  this  material.  In  particular,  we want to\nacknowledge the work done at\
    \ the University of Rochester  on  virtual\nterminals,(6)   work  which  has \
    \ influenced to a large degree how we\nview user interfaces through a display.\n\
    2.0  THE VTM MODEL\n     This section describes a virtual terminal management\
    \ (VTM) model\nwhose  architecture  not  only  derives  from  a  quest  for  device-\n\
    independent, terminal-oriented communications, but  more  importantly\nfrom a\
    \ desire to provide effective human-machine interfaces.\n     The VTM architecture\
    \  is  a  multi-user  structure  which  spans\nseveral  building blocks. The underlying\
    \ foundation to this structure\nis provided by the cooperating  virtual  terminals.\
    \   Under  the  VTM\nmodel,  these  cooperating  virtual  terminals  are  viewed\
    \ as device\nabstractions, all with  a  common  architecture,  exchanging  virtual\n\
    terminal  protocol  items  to  update each other's view of the world.\nResting\
    \ on this foundation lie the adaptation units.  Associated with\na   single  \
    \ end-user,   an   adaptation   unit   provides  the  step\ntransformation between\
    \ user and virtual  domains.   In  a  sense  the\nadaptation  unit  is  also \
    \ a virtual terminal, although one which is\nmuch closer to the architecture of\
    \ the end-user.  Finally, on top  of\nthis  supporting  structure  are  the  end-users,\
    \ the application and\nhuman processes, all interacting towards a common goal.\n\
    \     Before embarking on a description of the VTM  model  components,\nwe  present\
    \  the  set of capabilities the VTM model provides its end-\nusers, either human\
    \ or application.  After all,  the  motivation  for\nthe  model  and  its  underlying\
    \  concepts  stems  from our desire to\nprovide productive user environments.\n\
    \     HUMAN  <--->  WORKSTATION\n     o   Multiplexing the workstation physical\
    \ display both  in  time\n         and space.\n         The workstation assigns\
    \ to each user conversation a  logical\n         terminal  with  a well-distinguished\
    \ logical display.  Under\n         the  user  control,  the  workstation  maps\
    \  these   logical\n         displays  on  non-overlapping areas of the physical\
    \ display,\n         providing   a   dedicated   workspace   between   user  \
    \ and\n         correspondents.   Limited  only  by the area of the display,\n\
    \         many logical displays could be  mapped  at  one  time,  each\n     \
    \    providing  display updates when so required.  Since the area\n         of\
    \ the  display  is  a  scarce  resource,  not  all  logical\n         displays\
    \  need  be  mapped at the same time.  Therefore, the\n         workstation may\
    \ roll-out and roll-in selected displays under\n         the  user  control, \
    \ thereby  also multiplexing the physical\n         display in time.\n     o \
    \  Multiplexing the workstation input devices in time.\n         The input devices\
    \ always map to a single  user  conversation\n         (i.e.,  a  single  logical\
    \ terminal).  However, the user can\n         select  a  new  logical  terminal\
    \   by   some   well-defined\n         interaction  (e.g.,  depressing  a  function\
    \  key,  using  a\n         pointing  device,  and  such),  effectively  switching\
    \   the\n         ownership of the input tools.\n     o   Concurrent multi-mode\
    \ use of the workstation.\n         The capabilities of the  workstation  limit\
    \  the  scope  and\n         character   of   the   individual   conversations.\
    \   If  the\n         workstation  supports   rubout   processing   (i.e.,   erase\n\
    \         operations  on  lines  and  characters),  then  the  logical\n     \
    \    terminals can be independent,  scrolling  \"terminals,\"  some\n        \
    \ page-oriented, others line-oriented.  If the architecture of\n         the \
    \ workstation  supports  graphics  objects  as  primitive\n         objects  then\
    \ so can the individual logical terminals.  As a\n         consequence, while\
    \ some logical  terminal  displays  may  be\n         dedicated  to alphanumeric\
    \ output, others may include raster\n         graphics and imaging data together\
    \ with positioned text.\n     o   The sharing of  a  single  logical  terminal\
    \  among  several\n         users.\n         Several end-users may link to  a\
    \  single  logical  terminal.\n         All linked parties are viewed by the shared\
    \ \"device\" as both\n         input sources and  output  sinks.   As  a  consequence\
    \  this\n         device  sharing  need  not be limited only to the sharing of\n\
    \         device output. In general, each linked party may  have  full\n     \
    \    read  and  write  access  to  the logical terminal, if it so\n         desires.\n\
    \     o   Selective viewing on a logical terminal display.\n         In the user's\
    \ view, a logical terminal display  is  a  user-\n         specified  window \
    \ on  a  potentially  larger structure, the\n         \"device\"  display.   This\
    \  window  provides  the  \"peephole\"\n         through  which the device display\
    \ is viewed.  The portion of\n         the device display mapped on this window\
    \ is not  limited  to\n         its   \"present   contents.\"  Under  the  user\
    \  control,  the\n         workstation may invoke the viewing of  past  activity\
    \  on  a\n         logical  terminal  display  when  the  device display is I/O\n\
    \         file-extended.  Since the window mechanism  is  an  integral\n     \
    \    part  of  the  device  architecture,  it is available on all\n         logical\
    \ terminal displays.  Furthermore, the viewing of past\n         activity  does\
    \  not  affect  others  sharing  access  to the\n         device.\n     o   Discarding,\
    \ suspending, and resuming the output of a logical\n         terminal always under\
    \ user control.\n         As part of the  user  interface,  the  workstation \
    \ provides\n         simple  \"keys\" through which the user controls the output\
    \ on\n         a logical terminal display.  These workstation  \"keys\"  need\n\
    \         not  be  physical  keys, but could be other input tools used\n     \
    \    for this purpose (e.g., analog dials, hit-sensitive areas on\n         the\
    \  physical display, and such).  In any event, through the\n         auspices\
    \ of the workstation,  the  user's  control  requests\n         translate   into\
    \   the   proper  commands  to  the  \"device\"\n         associated with the\
    \ logical terminal.\n     APPLICATION  <--->  ADAPTATION UNIT\n     o   A logical\
    \ view of real devices.\n         For  each  real   terminal   architecture, \
    \  one   canonical\n         representation:  a logical device.\n     o   For\
    \  a   particular   logical   device,   several   possible\n         interaction\
    \ paradigms.\n         Some logical devices are intrinsically half-duplex (e.g.,\
    \  a\n         page-oriented  logical  device), some are full-duplex (e.g.,\n\
    \         communicating  processes  using  a  stream-oriented  logical\n     \
    \    device), and some may be either half or full-duplex (e.g., a\n         line-oriented\
    \ logical  device).   Some  full-duplex  logical\n         devices  can  provide\
    \  no  echoing, remote echoing, or local\n         echoing.   Those  that  interface\
    \  with  applications   that\n         support command completion (e.g., command-line\
    \ interpreters)\n         can shift the locus of echoing as a function  of  a\
    \  dynamic\n         break character set.\n     o   One application communicating\
    \ with several logical devices.\n         As  part  of  an  application's  model\
    \  of  interaction,  an\n         application may \"own\" several logical devices.\
    \  For example,\n         an editor could use a line-oriented logical device to\
    \ gather\n         top-level  commands,  and  a page-oriented logical device to\n\
    \         provide editing workspace.\n2.1  The VTM Model Components\n     The\
    \ virtual terminal management  model  consists  of  two  major\ncomponents:  \
    \ the  virtual  terminal model, and the workstation model\n(see Figures 2.1, 2.2,\
    \ and 2.3 respectively).\n                              AU1\n                \
    \               |\n                         AU0   |    AU2\n                 \
    \         |    |     |\n                         _______________\n           \
    \              |             |\n                         |     VT2     |\n   \
    \                      |             |\n                         |           \
    \  |\n                         _______________\n                             \
    \   |       _______________\n                                |       |       \
    \      |----AU0\n                                |_______|     VT0     |\n   \
    \                             |_______|             |\n                      \
    \          |       |             |----AU1\n                                | \
    \      _______________\n                                |\n                  \
    \       ________________\n                         |              |\n        \
    \                 |              |\n                         |     VT1      |\n\
    \                         |              |\n                         ________________\n\
    \                          |     |     |\n                         AU0    |  \
    \  AU2\n                                |\n                               AU1\n\
    VT = VIRTUAL TERMINAL\nAU = ADAPTATION UNIT\n               FIGURE 2.1 - THE VIRTUAL\
    \ TERMINAL MODEL\n                    ___  ___               ___  ___\n      \
    \             |VT1||VT2|             |VT1||VT2|\n                   ____ _____\
    \             _____ ____\n                    |     |                 |    |\n\
    \                  __|_____|_________________|_____|__\n                  | |\
    \     | |             | |     |  |\n                  |  REMOTE | -CONTROLLER-|\
    \  REMOTE  |\n                  |   KEYS  |             | DISPLAYS |\n       \
    \           |         |             |          |\n                  | VIRTUAL\
    \ |             |   DATA   |\n                  |   KEYS  |             |  STORE\
    \   |\n                  |         |<----------->|          |\n              \
    \    |  LOCAL  |             |   LOCAL  |\n                  |   KEYS  |     \
    \        | DISPLAYS |\n                  |         |             |          |\n\
    \                  __|_____|__________________|_____|__\n                    |\
    \     |                  |     |\n                   ____ ____               _____\
    \ ____\n                  |AU0||AU1|               |AU0||AU1|\n              \
    \     ____ ____               _____ ____\n          FIGURE 2.2 -- VT0 (expanded\
    \ from previous figure)\n                              +--------------------+\n\
    \                              |                    |\n                      \
    \      o-|-------------------|\n                              |     EXECUTIVE\
    \      |\n                              |--------------------|\n   Screen    \
    \    +-------+  o-|--------------------|      +-----+\n+---------+     /|OUTPUT\
    \ |    |  ADAPTATION UNIT 0 |<---->| VT0 |\n|EXECUTIVE|    / |       |<---|--------------------|\
    \      +-----+\n|---------|   /  |HANDLER|  o-|--------------------|      +-----+\n\
    |   AU0   |  /   |-------|    |  ADAPTATION UNIT 1 |<---->| VT1 |\n|---------|\
    \ /    | INPUT |    |--------------------|      +-----+\n|   AU1   |/     |  \
    \     |  o-|--------------------|\n|---------|      |HANDLER|    |         . \
    \         |\n|         |      |    /--|o   |         .          |\n~         ~\
    \      +-------+   ~         .          ~\n~         ~         /        ~    \
    \                ~\n|---------|        /        o-|--------------------|     \
    \ +-----+\n|   AUK   |       /           |  ADAPTATION UNIT K |<---->| VTK |\n\
    +---------+      /            +--------------------+      +-----+\n          \
    \      /             |                    |\n+---------+    /              +--------------------+\n\
    |Keyboard |   /\n+---------+  /\n|[] [] [] | /\n|[] [] [] |/\n+---------+\n  \
    \               FIGURE 2.3 - THE WORKSTATION MODEL\nThe first component embodies\
    \ the canonical device, while  the  second\ncomponent   includes   the   adaptation\
    \   unit   and  its  associated\nenvironment.  Each component will be described\
    \ in turn below.\n2.2  The Virtual Terminal Model\n     The objective of virtual\
    \ terminal protocols is  to  provide  the\nusers  of  the service with a common,\
    \ logical view of terminals.  The\ncommon user  view  is  attained  through  a\
    \  standard,  protocol-wide\npermits the exchanges between users of the protocol\
    \  to  be  free  of\ndevice-specific encodings.\n     The design postulates an\
    \ integrated virtual terminal model which\nextends  the  nature  and  scope  of\
    \ this canonical device in several\nimportant ways.  The major aspects of the\
    \  model,  its  connectivity,\nits organization, and its architecture are described\
    \ below.\n     2.2.1  Virtual Terminal Connectivity\n     Most virtual terminal\
    \ protocols only cater to two-way  dialogues\nin  which  a  single  virtual  terminal\
    \  terminates  each  end of the\ncommunication path.\n     We define the virtual\
    \ terminal as a n-way device  where  one  or\nmore  of  the  correspondents  to\
    \  this device are local users of the\nservice, and the remaining correspondents\
    \ (if any) are  peer  virtual\nterminals.   Each  correspondent  to the virtual\
    \ terminal has its own\nbi-directional path to produce virtual input to, and receive\
    \  virtual\noutput from, the virtual terminal.  This bi-directional path provides\n\
    the vehicle for a virtual terminal session between user  and  virtual\nterminal.\
    \   Globally, the cooperating virtual terminals and these bi-\ndirectional paths\
    \ span a dendritic (tree-like) topology.\n     It is important to note  that \
    \ we  have  decoupled  the  virtual\nterminal  from  its  physical  realization,\
    \  a  single real terminal.\nIndeed, a virtual terminal does not map necessarily\
    \ to just one  real\ndevice, but possibly to many real devices.\n     The virtual\
    \ terminal is viewed ultimately as a well-defined data\nstructure  which  provides\
    \  its  correspondents  with a non-dedicated\nvirtual terminal service.  And these\
    \  correspondents  may  have  read\nonly, write only, or read/write access rights\
    \ to this data structure.\n     2.2.2  Virtual Terminal Organization\n     The\
    \ virtual terminal is an abstraction;  its  organization,  the\nbuilding  blocks\
    \ which make up the virtual terminal, is the result of\na feature extraction of\
    \ the real terminal  that  it  is  tailored  to\nsupport.\n     We have conceptualized\
    \ the virtual terminal as  a  meta-terminal\n(i.e.,  the terminal of terminals).\
    \  The meta-terminal is composed of\nthree well-distinguished building  blocks:\
    \ virtual  keys,  a  virtual\ncontroller, and a virtual display.\n     2.2.2.1\
    \  The Virtual Keys.  The analog of the  virtual  keys  is\nthe  physical keyboard\
    \ of real terminals.  However, while the keys of\na physical terminal are controlled\
    \ by a single manual process,  these\nvirtual  keys  can be activated by multiple,\
    \ concurrent entities (the\nvirtual terminal correspondents).  Each correspondent\
    \ of the  virtual\nterminal, be it a user of the service or a peer virtual terminal,\
    \ has\nits input stream to the meta-terminal terminated at the virtual keys.\n\
    The  virtual  keys  provide the control of access of input streams to\nthe meta-terminal.\n\
    \     2.2.2.2    The Virtual Controller.    The   virtual   controller\nprovides\
    \   virtual  terminal  session  management.   It  manages  the\nestablishment\
    \ and termination of a virtual terminal  session  with  a\ncorrespondent; supports\
    \ the possible negotiation and renegotiation of\nthe session  attributes;  and\
    \  enables  the  deactivation  and  later\nactivation  of  the  session.   The\
    \  virtual controller also provides\nvirtual terminal  signalling  control  by\
    \  managing  the  out-of-band\nsignals addressed to the virtual terminal.\n  \
    \   2.2.2.3   The Virtual Display.   The  virtual  display  is   the\ndynamic\
    \  component in the meta-terminal organization.  For each class\nof  real  device\
    \  (e.g.  stream,  line,  page,  or  graphics-oriented\ndevices)  there  is  a\
    \  corresponding  virtual  terminal  class.  The\norganization  of  the  virtual\
    \  terminal  data  structure  is  class-\nspecific.  A virtual terminal models\
    \ a particular terminal class when\nit is 'fitted' with the proper  data  structure\
    \  manager  or  virtual\ndisplay.   This  binding  need  not  be  static  (e.g.,\
    \  a line-class\nspecialist, and so forth), but could be result of decisions \
    \ made  at\n\"run-time\" by applying the principle of negotiated options.\n  \
    \   The virtual display manages the data structure  associated  with\nthe  meta-terminal\
    \  and  performs  operations on the control and data\nelements  of  the  structure.\
    \  As  a  direct  consequence  of   these\noperations  on  the meta-terminal data\
    \ structure, the virtual display\nmay  generate  display  updates  to  one,  some,\
    \  or   all   of   the\ncorrespondents.  All virtual terminal output streams originate\
    \ at the\nvirtual display.\n     Different virtual terminal  classes  are  spawned\
    \  by  different\n\"kinds\" of virtual displays, and this is realized in one of\
    \ two ways.\nFor character-oriented virtual devices,  it  is  possible  to  use\
    \  a\nsingle,  wide-scoped  virtual  display with a character-oriented data\n\
    structure by constraining it to conform to the model  of  the  device\nclass (e.g.,\
    \ line-oriented devices must be constrained to line-access\nrules).  For non character-oriented\
    \ virtual devices  (e.g.,  graphics\nproperties better suited for the new domain\
    \ (e.g., a graphics virtual\ndisplay based on a structured display file).\n  \
    \   2.2.3  Virtual Terminal Architecture\n     The commands, and associated parameters,\
    \ which are available  to\nthe  users  of  the  virtual terminal constitute the\
    \ virtual terminal\narchitecture.  The commands available to a user  --  to  request\
    \  the\nvirtual  controller  to  establish,  abort,  or  close a session, and\n\
    discard, suspend, or resume output -- remain invariant to the virtual\nterminal\
    \  class.  However, as one would expect, the user interface to\nthe virtual display\
    \ depends on the nature of this data structure.\n     Three important architectural\
    \ features of the meta-terminal are:\nthe concept of communication variables,\
    \ the notion of a file-extended\nvirtual display, and the concept of virtual display\
    \ windows. Each  of\nthese  concepts  are a part of the meta-terminal architecture\
    \ because\nthey are apparent to the users of the virtual terminal.\n     2.2.3.1\
    \  Communication Variables.  Each component of  the  meta-\nterminal  (i.e., \
    \ virtual  keys,  controller,  display) is assigned a\nstandard, protocol-wide\
    \ name which we call a communication  variable.\nThe communication variable is\
    \ a part of the header of each command to\nthe  virtual  terminal  (i.e.  protocol\
    \  item).   It  permits  better\nmanagement  of  the  virtual  terminal  command\
    \  name space, and also\nprovides the virtual keys  with  an  easy  mechanism\
    \  to  select  the\ndestination  of  the  request.   It must be noted that nothing\
    \ in the\nmodel precludes the addition of more virtual entities  to  the  meta-\n\
    terminal,  such  as auxiliary virtual devices and signalling devices.\nThe use\
    \ of communication variables provides a naming hierarchy  which\nalleviates  \
    \ the  problems  of  device  selection  and  command  name\nallocation in the\
    \ case of such extensions.\n     2.2.3.2    Virtual Display with File Extension.\
    \    The   virtual\ndisplay is the immediate manager of the meta-terminal data\
    \ structure.\nWhen the virtual display is provided with an I/O file  extension,\
    \  it\nis   possible  to  introduce  the  concept  of  a  stable-store  data\n\
    structure, a data structure whose  contents  are  stored  in  backing\nstore \
    \ (e.g.,  disk).   If  the virtual display is provided with this\nfile  extension\
    \  capability  (a  local  option  with  no   end-to-end\nsignificance),  then\
    \  the  meta-terminal  data structure inherits the\nspatial and temporal attributes\
    \ (dimensions and time-to-live) of  the\nassociated file.  Such a virtual display,\
    \ coupled with the concept of\nvirtual display windows below, provides the users\
    \ of the service with\na very powerful tool.\n     2.2.3.3  Virtual Display Windows.\
    \  To communicate with a virtual\nterminal,  each  real device uses an adaptation\
    \ unit as its interface\nentity (this adaptation unit is a part of the workstation\
    \ model,  see\nsection  2.3).  What is important to note is that the adaptation\
    \ unit\nprovides the  transition  between  the  device-specific  domain,  the\n\
    device workspace,  and  the virtual domain, the master workspace (see\nFigure\
    \ 2.4).\n |                                 |                                \
    \   |\n |        VIRTUAL TERMINAL         |         ADAPTATION UNIT          \
    \ |\n |<------------------------------->|<--------------------------------->|\n\
    \ |             DOMAIN              |              DOMAIN               |\n |\
    \                                 |                                   |\n + -\
    \ - - - - - - - - +   + - - - - - - - - - +        - - - - - - - - -\n |  +--->\
    \  x(m)      |   |                   |       /                /|\n |  |      \
    \          |   |            x(i)   |      /                / |\n |  v  y(m)  \
    \        |   | +---------------> |      - - - - - - - - -  |\n |             \
    \      |   | |              |  |     | +------------+ |  |\n | +--------------+\
    \  |   | |              |  |     | | VIEWPORT 1 | |  |\n | |              |  |\
    \   | |              |  |     | |            | |  |\n | |              |  |  \
    \ | |              |  |     | |            | |  |\n | |              |  |   |\
    \ |              |  |     | |            | |  |\n | |              |  |   | |\
    \              |  |     | |            | |  |\n | |              |  |   | |  \
    \ A<---------|--|-----|-|->A         | |  |\n | |              |  |   | |  / \\\
    \         |  |     | |            | |  |\n | |     <--------|--|---|-|->   \\\
    \        |  |     | |            | |  |\n | |    /         |  |   | |      \\\
    \       |  |     | |        <---|-|--|+\n | |    A         |  |   | |       \\\
    \      |  |     | +------------+ |  ||\n | |              |  |   | |        \\\
    \     |  |     |                |  ||\n | |     WINDOW   |  |   | |         \\\
    \    |  |     | +------------+ |  ||\n | |              |  |   | |          \\\
    \   |  |     | | VIEWPORT 2 | |  ||\n | |              |  |   | |-----------\\\
    --+  |     | |            | |  ||\n | |              |  |   | |            \\\
    \    |     | |            | |  ||\n | +--------------+  |   | v  y(i)       \\\
    \   |     | +------------+ |  ||\n |                   |   |                \\\
    \  |     |                | / |\n |                   |   |                 \\\
    \ |     |                |   |\n |                   |   |                  \\\
    |      - - - - - - - -     |\n |     /             |   |       /           | \
    \           |  |          |\n + - -/- - - - - - - +   + - - -/- - - - - - +\\\
    \           |  |          |\n     /                         /               \\\
    \     - - - - - - - -    |\n    /                         /                 \\\
    \   |    KEYBOARD   |   |\n  MASTER WORKSPACE         INSTANCE WORKSPACE    \\\
    \  + - - - - - - - +   |\n                                                  <-/\
    \   []  []  [] /|   | \n                                                   / \
    \  []  []  [] / |   |\n                                                  + - -\
    \ - - - - - - +   |\n                                                        \
    \                |\n                                            PHYSICAL DEVICE\
    \ WORKSPACE --+\n                           FIGURE 2.4 -- THE DOMAINS\nHowever\
    \  a  device  need  not  be  interested  in  the  whole  master\nworkspace,  only\
    \  in  a  portion  of  it.   As  part  of  its session\nattributes, each adaptation\
    \ unit has a window, a  rectangular  region\nin  the  virtual  display, which\
    \ delimits its area of interest in the\nmaster.  This portion of the master domain\
    \ will be  referred  as  the\ninstance workspace.   Then,  for  each  adaptation\
    \  unit, there is an\ninstance workspace whose spatial attributes (dimension \
    \ and  position\nwithin the master) are those of its window definition.\n    \
    \ All adaptation  units  communicate  with  the  virtual  terminal\n\"relative\"\
    \  to  their  own instance workspace.  As far as the virtual\nterminal is concerned,\
    \  each  instance  workspace  defines  a  \"real\"\nterminal,  although in fact\
    \ it is just an intermediate representation\nof the real device.   In  essence,\
    \  the  instance  workspace  is  the\ncoordinate  space  where  both  virtual\
    \  terminal and adaptation unit\nrendezvous. (See section 2.3 for a discussion\
    \ of  how  this  instance\nworkspace is mapped onto the device workspace).\n \
    \    The window dimensions are the exclusive choice of the adaptation\nunit  that\
    \  owns  it.   With  these  dimensions  the  adaptation unit\nspecifies to the\
    \ virtual terminal how much of the  master  is  to  be\nviewed; data  elements\
    \  not  contained  within  the boundaries of the\nwindow are clipped.  Varying\
    \ the dimension of the window  results  in\ncorresponding changes on the amount\
    \ of the master that is viewed.\n     In contrast, the position of the window\
    \ on the master might  not\nbe  under  direct  control of the adaptation unit.\
    \  To understand the\ndynamics of a window, we introduce the notion of a master\
    \ cursor  and\nan instance cursor.  The master cursor is a read/write pointer,\
    \ which\nis a part of the virtual display architecture.  In turn, the instance\n\
    cursor  is a pointer owned by the adaptation unit, which is a part of\nthe state\
    \ information maintained by the virtual  display.   Normally,\nboth master and\
    \ instance cursors are bound together so that motion of\none cursor translates\
    \ into an equivalent motion  of  the  other.   As\nlong  as  the adaptation unit\
    \ does not explicitly unbind its instance\ncursor from the master cursor, the\
    \ active region of the master (i.e.,\nthe position where the master cursor lies)\
    \ is guaranteed to be always\nwithin the instance  space,  and  thus  viewable.\
    \   This  means  that\ncertain  operations  on  the virtual display will implicitly\
    \ relocate\nthe window of an adaptation unit within  the  bounds  of  the  master\n\
    workspace  to  insure the tracking of the master cursor.  (The actual\nalgorithm\
    \ which enforces  this  tracking  rule,  called  the  viewing\nalgorithm,  has\
    \  not  been included here.)  This window relocation is\nviewed  at  the  real\
    \  terminal  as  either  vertical  or  horizontal\nscrolling.\n     However, an\
    \ adaptation unit has the choice to bypass  this  rule\nby detaching its instance\
    \ cursor from the master, effectively getting\ncomplete control of its cursor\
    \ to view other portions of  the  master\nspace.   If  the  virtual display has\
    \ an I/O file extension, then the\nadaptation unit can pan its window on the \
    \ file-extended  space  well\nbeyond  the  present  contents of the master space.\
    \  Therein lies the\npower of a stable-store data structure when coupled with\
    \ the  concept\nof windowing.\n2.3  The Workstation Model\n     The workstation\
    \ model is composed  of  one  or  more  adaptation\nunits,  and  a workstation\
    \ monitor, which we will call the executive.\nEach will be  described  in  turn\
    \  below.   In  addition,  the  model\nincludes  input  and output handlers, and\
    \ an underlying multi-tasking\noperating system of unspecified architecture.\n\
    \     2.3.1  The Adaptation Unit\n     An adaptation unit embodies an instance\
    \ of a  virtual  terminal,\nand  since  the  workstation model postulates possibly\
    \ many different\nsuch  instances  per  physical  workstation,  then  potentially\
    \  many\nadaptation units will be co-located at a workstation.\n     The adaptation\
    \ unit can be viewed as the workstation agent which\nprovides the mapping between\
    \ instance workspace and device workspace.\nTo define this mapping, we introduce\
    \ the notion of a  viewport  as  a\nrectangular  area of the physical screen allocated\
    \ for the viewing of\na virtual terminal instance.  An adaptation  unit  has \
    \ the  task  of\nmapping  the  totality of the instance workspace onto the viewport,\
    \ a\nmapping which is a device-specific concern totally removed  from  the\ndomain\
    \  of  discourse  of the virtual terminal.  Thus the position of\nthe viewport\
    \ determines the relocation of the selected data structure\nelements   on  the\
    \  viewing  unit,  and  the  viewport  dimensions  a\n(potential) scaling transformation.\n\
    \     The adaptation unit also produces virtual input to  the  virtual\nterminal\
    \   by  translating  the  user  input  into  virtual  terminal\ncommands.  It\
    \ implements the service side of  the  interface  to  the\nvirtual terminal.\n\
    \     2.3.2  The Executive\n     This conceptual entity performs the task and\
    \ resource management\nrequired to create and destroy virtual terminal instances,\
    \ and to map\nthese virtual terminal instances to the screen viewports.\n    \
    \ It must provide at least a minimal  user  command  interface  so\nthat  its\
    \  tools may be accessed (one of them being the management of\nscreen real estate).\n\
    \     Finally, the executive provides the mechanism for  the  end-user\nto  switch\
    \  viewport  contexts  through  the use of some input device\n(e.g., function\
    \ key, pointing or positioning  device).   Following  a\nuser  interaction  which\
    \ indicates a change of context, the executive\nmakes the newly selected  virtual\
    \  terminal  instance  the  dedicated\nowner of the input devices.\n         \
    \                    REFERENCES\n1.   R. Bisbey II and D. Hollingworth.   \"A\
    \  distributable,  display-\n     device-independent  vector  graphics  system\
    \  for  the  military\n     command   and   control   environment,\"   Information\
    \   Sciences\n     Institute, Marina del Rey, California, April 1978.\n2.   Alan\
    \ Branden, et al.  \"Lisp Machine Project Report,\"  Artificial\n     Intelligence\
    \  Laboratory, Massachusetts Institute of Technology,\n     AIM 444, August 1977.\n\
    3.   John Day.  \"TELNET Data Entry  Terminal  Option,\"  ARPA  Network\n    \
    \ Working   Group   RFC   732,  Network  Information  Center,  SRI\n     International,\
    \ September 1977.\n4.   Douglas Gerhart and D. L. Parnas.  WINDOW  A  formally\
    \ specified\n     graphics based   text   editor,   Computer  Science  Department,\n\
    \     Carnegie-Mellon University, June 1973.\n5.   B. W. Lampson and R. F. Sproull,\
    \ \"An Open Operating System for a\n     Single-User  Machine,\"  Proc  7th Symposium\
    \ on Operating Systems\n     Principles 9-17, ACM, December 1979.\n6.   Keith\
    \ Lantz.  Uniform Interfaces for Distributed Systems,  Ph.D.\n     thesis, University\
    \ of Rochester, Rochester, N.Y., May 1980.\n7.   Mathis, J.E., et al, \"Terminal\
    \ Interface Unit Notebook,\"  Volume\n     2, ARPA Order No. 2302, SRI Project\
    \ No. 6933, SRI International,\n     Menlo Park, California, 1979.\n8.   Allen\
    \ Newell, Scott  Fahlman,  Bob  Sproull.   \"A  Proposal  for\n     Personal \
    \ Scientific Computing,\" Department of Computer Science,\n     Carnegie-Mellon\
    \ University, July 1979 (DRAFT).\n9.   \"PERQ,\"  Three  Rivers  Computer  Corp.,\
    \  160  N.   Craig   St.,\n     Pittsburgh, Pa. 15213.\n10.  Jon  Postel  and\
    \  Dave  Crocker.   \"TELNET   Remote   Controlled\n     Transmission and Echoing\
    \ Option,\" ARPA Network Working Group RFC\n     726, Network Information Center,\
    \ SRI International, March 1977.\n11.  John F. Shoch and Jon A. Hupp.  \"Notes\
    \ on the 'Worm'  programs -\n     - some  early  experience with a distributed\
    \ computation,\" Xerox\n     Palo Alto Research Center publication  SSL-80-3.\
    \   Presented  at\n     the  Workshop  on  Fundamental  Issues in Distributed\
    \ Computing,\n     ACM/SIGOPS and ACM/SIGPLAN, December 1980.\n12.  R. F. Sproull\
    \ and E. L. Thomas.  A  network  graphics  protocol,\n     Computer Graphics 8(3),\
    \ Fall 1974.\n13.  C. P. Thacker, E. M. McCreight, B. W. Lampson,  R.  F.  Sproull,\n\
    \     and  D. R. Boggs.  \"Alto: A Personal Computer.\" D. Siewiorek, C.\n   \
    \  G. Bell,  and  A.  Newell,  Computer  Structures   Readings  and\n     Examples,\
    \ editors, second edition, McGraw-Hill, 1979.\n                              \
    \   20\n"
