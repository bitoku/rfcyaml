- title: __initial_text__
  contents:
  - '              Evolution of the Interfaces Group of MIB-II

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction .............................................\
    \    2\n   2. The SNMPv2 Network Management Framework ..................    2\n\
    \   2.1 Object Definitions ......................................    3\n   3 Experience\
    \ with the Interfaces Group ......................    3\n   3.1 Areas of Clarification/Revision\
    \ .........................    3\n   3.1.1 Interface Numbering ...................................\
    \    4\n   3.1.2 Interface Sub-Layers ..................................    4\n\
    \   3.1.3 Virtual Circuits ......................................    5\n   3.1.4\
    \ Bit, Character, and Fixed-Length Interfaces ...........    5\n   3.1.5 Counter\
    \ Size ..........................................    5\n   3.1.6 Interface Speed\
    \ .......................................    6\n   3.1.7 Multicast/Broadcast Counters\
    \ ..........................    6\n   3.1.8 Addition of New ifType values .........................\
    \    6\n   3.1.9 ifSpecific ............................................    6\n\
    \   3.2 Clarifications/Revisions ................................    7\n   3.2.1\
    \ Interface Numbering ...................................    7\n   3.2.2 Interface\
    \ Sub-Layers ..................................    8\n   3.2.3 Guidance on Defining\
    \ Sub-layers .......................   11\n   3.2.4 Virtual Circuits ......................................\
    \   12\n   3.2.5 Bit, Character, and Fixed-Length Interfaces ...........   12\n\
    \   3.2.6 Counter Size ..........................................   14\n   3.2.7\
    \ Interface Speed .......................................   16\n   3.2.8 Multicast/Broadcast\
    \ Counters ..........................   16\n   3.2.9 Trap Enable ...........................................\
    \   17\n   3.2.10 Addition of New ifType values ........................   17\n\
    \   3.2.11 InterfaceIndex Textual Convention ....................   17\n   3.2.12\
    \ IfAdminStatus and IfOperStatus .......................   18\n   3.2.13 Traps\
    \ ................................................   19\n   3.2.14 ifSpecific\
    \ ...........................................   20\n   3.3 Media-Specific MIB\
    \ Applicability ........................   20\n   4. Overview .................................................\
    \   21\n   5. IANAifType Definition ....................................   22\n\
    \   6. Interfaces Group Definitions .............................   24\n   7.\
    \ Acknowledgements .........................................   53\n   8. References\
    \ ...............................................   53\n   9. Security Considerations\
    \ ..................................   55\n   10. Authors' Addresses.......................................\
    \   55\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This memo defines a portion of the Management Information\
    \ Base (MIB)\n   for use with network management protocols in the Internet community.\n\
    \   In particular, it describes managed objects used for managing Network\n  \
    \ Interfaces.\n   This memo discusses the 'interfaces' group of MIB-II, especially\
    \ the\n   experience gained from the definition of numerous media-specific MIB\n\
    \   modules for use in conjunction with the 'interfaces' group for\n   managing\
    \ various sub-layers beneath the internetwork-layer.  It\n   proposes clarifications\
    \ to, and extensions of, the architectural\n   issues within the current model\
    \ used for the 'interfaces' group.\n   This memo also includes a MIB module. \
    \ As well as including new MIB\n   definitions to support the architectural extensions,\
    \ this MIB module\n   also re-specifies the 'interfaces' group of MIB-II in a\
    \ manner which\n   is both compliant to the SNMPv2 SMI and semantically-identical\
    \ to the\n   existing SNMPv1-based definitions.\n"
- title: 2.  The SNMPv2 Network Management Framework
  contents:
  - "2.  The SNMPv2 Network Management Framework\n   The SNMPv2 Network Management\
    \ Framework consists of four major\n   components.  They are:\n      o    RFC\
    \ 1442 which defines the SMI, the mechanisms used for\n           describing and\
    \ naming objects for the purpose of management.\n      o    STD 17, RFC 1213 defines\
    \ MIB-II, the core set of managed\n           objects for the Internet suite of\
    \ protocols.\n      o    RFC 1445 which defines the administrative and other\n\
    \           architectural aspects of the framework.\n      o    RFC 1448 which\
    \ defines the protocol used for network access\n           to managed objects.\n\
    \   The Framework permits new objects to be defined for the purpose of\n   experimentation\
    \ and evaluation.\n"
- title: 2.1.  Object Definitions
  contents:
  - "2.1.  Object Definitions\n   Managed objects are accessed via a virtual information\
    \ store, termed\n   the Management Information Base or MIB.  Objects in the MIB\
    \ are\n   defined using the subset of Abstract Syntax Notation One (ASN.1)\n \
    \  defined in the SMI.  In particular, each object object type is named\n   by\
    \ an OBJECT IDENTIFIER, an administratively assigned name.  The\n   object type\
    \ together with an object instance serves to uniquely\n   identify a specific\
    \ instantiation of the object.  For human\n   convenience, we often use a textual\
    \ string, termed the descriptor, to\n   refer to the object type.\n"
- title: 3.  Experience with the Interfaces Group
  contents:
  - "3.  Experience with the Interfaces Group\n   One of the strengths of internetwork-layer\
    \ protocols such as IP [6]\n   is that they are designed to run over any network\
    \ interface.  In\n   achieving this, IP considers any and all protocols it runs\
    \ over as a\n   single \"network interface\" layer.  A similar view is taken by\
    \ other\n   internetwork-layer protocols.  This concept is represented in MIB-II\n\
    \   by the 'interfaces' group which defines a generic set of managed\n   objects\
    \ such that any network interface can be managed in an\n   interface-independent\
    \ manner through these managed objects.  The\n   'interfaces' group provides the\
    \ means for additional managed objects\n   specific to particular types of network\
    \ interface (e.g., a specific\n   medium such as Ethernet) to be defined as extensions\
    \ to the\n   'interfaces' group for media-specific management.  Since the\n  \
    \ standardization of MIB-II, many such media-specific MIB modules have\n   been\
    \ defined.\n   Experience in defining these media-specific MIB modules has shown\n\
    \   that the model defined by MIB-II is too simplistic and/or static for\n   some\
    \ types of media-specific management.  As a result, some of these\n   media-specific\
    \ MIB modules have assumed an evolution or loosening of\n   the model.  This memo\
    \ is a proposal to document and standardize the\n   evolution of the model and\
    \ to fill in the gaps caused by that\n   evolution.\n   A previous effort to extend\
    \ the interfaces group resulted in the\n   publication of RFC 1229 [7].  As part\
    \ of defining the evolution of\n   the interfaces group, this memo applies that\
    \ evolution to, and\n   thereby incorporates, the RFC 1229 extensions.\n"
- title: 3.1.  Areas of Clarification/Revision
  contents:
  - "3.1.  Areas of Clarification/Revision\n   There are several areas for which experience\
    \ indicates that\n   clarification, revision, or extension of the model would\
    \ be helpful.\n   The next sections discuss these.\n"
- title: 3.1.1.  Interface Numbering
  contents:
  - "3.1.1.  Interface Numbering\n   MIB-II defines an object, ifNumber, whose value\
    \ represents:\n     \"The number of network interfaces (regardless of their\n\
    \     current state) present on this system.\"\n   Each interface is identified\
    \ by a unique value of the ifIndex object,\n   and the description of ifIndex\
    \ constrains its value as follows:\n     \"Its value ranges between 1 and the\
    \ value of ifNumber.  The\n     value for each interface must remain constant\
    \ at least from\n     one re-initialization of the entity's network management\n\
    \     system to the next re-initialization.\"\n   This constancy requirement on\
    \ the value of ifIndex for a particular\n   interface is vital for efficient management.\
    \  However, an increasing\n   number of devices allow for the dynamic addition/removal\
    \ of network\n   interfaces.  One example of this is a dynamic ability to configure\n\
    \   the use of SLIP/PPP over a character-oriented port.  For such dynamic\n  \
    \ additions/removals, the combination of the constancy requirement and\n   the\
    \ restriction that the value of ifIndex is less than ifNumber is\n   problematic.\n"
- title: 3.1.2.  Interface Sub-Layers
  contents:
  - "3.1.2.  Interface Sub-Layers\n   Experience in defining media-specific management\
    \ information has\n   shown the need to distinguish between the multiple sub-layers\
    \ beneath\n   the internetwork-layer.  In addition, there is a need to manage\
    \ these\n   sub-layers in devices (e.g., MAC-layer bridges) which are unaware\
    \ of\n   which, if any, internetwork protocols run over these sub-layers.  As\n\
    \   such, a model of having a single conceptual row in the interfaces\n   table\
    \ (MIB-II's ifTable) represent a whole interface underneath the\n   internetwork-layer,\
    \ and having a single associated media-specific MIB\n   module (referenced via\
    \ the ifType object) is too simplistic.  A\n   further problem arises with the\
    \ value of the ifType object which has\n   enumerated values for each type of\
    \ interface.\n   Consider, for example, an interface with PPP running over an\
    \ HDLC\n   link which uses a RS232-like connector.  Each of these sub-layers has\n\
    \   its own media-specific MIB module.  If all of this is represented by\n   a\
    \ single conceptual row in the ifTable, then an enumerated value for\n   ifType\
    \ is needed for that specific combination which maps to the\n   specific combination\
    \ of media-specific MIBs.  Furthermore, there is\n   still a lack of a method\
    \ to describe the relationship of all the\n   sub-layers of the MIB stack.\n \
    \  An associated problem is that of upward and downward multiplexing of\n   the\
    \ sub-layers.  An example of upward multiplexing is MLP (Multi-\n   Link-Procedure)\
    \ which provides load-sharing over several serial lines\n   by appearing as a\
    \ single point-to-point link to the sub-layer(s)\n   above.  An example of downward\
    \ multiplexing would be several\n   instances of PPP, each framed within a separate\
    \ X.25 virtual circuit,\n   all of which run over one fractional T1 channel, concurrently\
    \ with\n   other uses of the T1 link.  The current MIB structure does not allow\n\
    \   for these sorts of relationships to be described.\n"
- title: 3.1.3.  Virtual Circuits
  contents:
  - "3.1.3.  Virtual Circuits\n   Several of the sub-layers for which media-specific\
    \ MIB modules have\n   been defined are connection oriented (e.g., Frame Relay,\
    \ X.25).\n   Experience has shown that each effort to define such a MIB module\n\
    \   revisits the question of whether separate conceptual rows in the\n   ifTable\
    \ are needed for each virtual circuit.  Most, if not all, of\n   these efforts\
    \ to date have decided to have all virtual circuits\n   reference a single conceptual\
    \ row in the ifTable.\n"
- title: 3.1.4.  Bit, Character, and Fixed-Length Interfaces
  contents:
  - "3.1.4.  Bit, Character, and Fixed-Length Interfaces\n   RS-232 is an example\
    \ of a character-oriented sub-layer over which\n   (e.g., through use of PPP)\
    \ IP datagrams can be sent.  Due to the\n   packet-based nature of many of the\
    \ objects in the ifTable, experience\n   has shown that it is not appropriate\
    \ to have a character-oriented\n   sub-layer represented by a (whole) conceptual\
    \ row in the ifTable.\n   Experience has also shown that it is sometimes desirable\
    \ to have some\n   management information for bit-oriented interfaces, which are\n\
    \   similarly difficult to represent by a (whole) conceptual row in the\n   ifTable.\
    \  For example, to manage the channels of a DS1 circuit, where\n   only some of\
    \ the channels are carrying packet-based data.\n   A further complication is that\
    \ some subnetwork technologies transmit\n   data in fixed length transmission\
    \ units.  One example of such a\n   technology is cell relay, and in particular\
    \ Asynchronous Transfer\n   Mode (ATM), which transmits data in fixed-length cells.\
    \  Representing\n   such a interface as a packet-based interface produces redundant\n\
    \   objects if the relationship between the number of packets and the\n   number\
    \ of octets in either direction is fixed by the size of the\n   transmission unit\
    \ (e.g., the size of a cell).\n"
- title: 3.1.5.  Counter Size
  contents:
  - "3.1.5.  Counter Size\n   As the speed of network media increase, the minimum\
    \ time in which a\n   32 bit counter will wrap decreases.  For example, on an\
    \ Ethernet, a\n   stream of back-to-back, full-size packets will cause ifInOctets\
    \ to\n   wrap in just over 57 minutes.  For a T3 line, the minimum wrap-time\n\
    \   is just over 12 minutes.  For FDDI, it will wrap in 5.7 minutes.  For\n  \
    \ a 1-gigabit medium, the counter might wrap in as little as 34\n   seconds. \
    \ Requiring that interfaces be polled frequently enough not\n   to miss a counter\
    \ wrap will be increasingly problematic.\n"
- title: 3.1.6.  Interface Speed
  contents:
  - "3.1.6.  Interface Speed\n   Network speeds are increasing.  The range of ifSpeed\
    \ is limited to\n   reporting a maximum speed of (2**31)-1 bits/second, or approximately\n\
    \   2.2Gbs.  SONET defines an OC-48 interface, which is defined at\n   operating\
    \ at 48 times 51 Mbs, which is a speed in excess of 2.4gbits.\n   Thus, ifSpeed\
    \ will be of diminishing utility over the next several\n   years.\n"
- title: 3.1.7.  Multicast/Broadcast Counters
  contents:
  - "3.1.7.  Multicast/Broadcast Counters\n   The counters in the ifTable for packets\
    \ addressed to a multicast or\n   the broadcast address, are combined as counters\
    \ of non-unicast\n   packets.  In contrast, the ifExtensions MIB [7] defines one\
    \ set of\n   counters for multicast, and a separate set for broadcast packets.\n\
    \   With the separate counters, the original combined counters become\n   redundant.\n"
- title: 3.1.8.  Addition of New ifType values
  contents:
  - "3.1.8.  Addition of New ifType values\n   Over time new ifType enumerated values\
    \ have been needed for new\n   interface types.  With the syntax of ifType being\
    \ defined in a MIB,\n   this requires the new MIB to be re-issued in order to\
    \ define the new\n   values.  In the past, re-issuing of the MIB has occurred\
    \ only after\n   several years.\n"
- title: 3.1.9.  ifSpecific
  contents:
  - "3.1.9.  ifSpecific\n   The original definition of the OBJECT IDENTIFIER value\
    \ of ifSpecific\n   was not sufficently clear.  As a result, different implementors\
    \ have\n   used it differently, and confusion has resulted.  Some\n   implementations\
    \ have the value of ifSpecific be the OBJECT IDENTIFIER\n   that defines the media-specific\
    \ MIB, i.e., the \"foo\" of:\n          foo OBJECT IDENTIFIER ::= { transmission\
    \ xxx }\n   while others have it be the OBJECT IDENTIFIER of the table or entry\n\
    \   in the appropriate media-specific MIB (e.g. fooTable or fooEntry),\n   while\
    \ still others have it be the OBJECT IDENTIFIER of the index\n   object of the\
    \ table's row, including instance identifier (e.g.,\n   fooIfIndex.ifIndex). \
    \ A definition based on the latter would not be\n   sufficient unless it also\
    \ allowed for media-specific MIBs which\n   include several tables, where each\
    \ table has its own, different,\n   indexing.\n"
- title: 3.2.  Clarifications/Revisions
  contents:
  - "3.2.  Clarifications/Revisions\n   The following clarifications and/or revisions\
    \ are proposed.\n"
- title: 3.2.1.  Interface Numbering
  contents:
  - "3.2.1.  Interface Numbering\n   One solution to the interface numbering problem\
    \ would be to redefine\n   ifNumber to be the largest value of ifIndex, but the\
    \ utility of such\n   an object is questionable, and such a re-definition would\
    \ require\n   ifNumber to be deprecated.  Thus, an improvement would be to\n \
    \  deprecate ifNumber and not replace it.  However, the deprecation of\n   ifNumber\
    \ would require a change to that portion of ifIndex's\n   definition which refers\
    \ to ifNumber.  So, since the definition of\n   ifIndex must be changed anyway\
    \ in order to solve the problem, changes\n   to ifNumber do not benefit the solution.\n\
    \   The solution adopted in this memo is to delete the requirement that\n   the\
    \ value of ifIndex must be less than the value of ifNumber, and to\n   retain\
    \ ifNumber with its current definition.  It could be argued that\n   this is a\
    \ change in the semantics of ifIndex; however, all existing\n   implementations\
    \ conform to this new definition, and in the interests\n   of not requiring changes\
    \ in existing implementations and in the many\n   existing media-specific MIBs,\
    \ it is proposed that this change does\n   not require ifIndex to be deprecated.\n\
    \   This solution also results in the possibility of \"holes\" in the\n   ifTable\
    \ (i.e., the ifIndex values of conceptual rows in the ifTable\n   are not necessarily\
    \ contiguous), but SNMP's GetNext (and SNMPv2's\n   GetBulk) operation easily\
    \ deals with such holes.  The value of\n   ifNumber still represents the number\
    \ of conceptual rows, which\n   increases/decreases as new interfaces are dynamically\
    \ added/removed.\n   The vital constancy requirement is met by requiring that\
    \ after an\n   interface is dynamically removed, its ifIndex value is not re-used\n\
    \   (by a different dynamically added interface) until after the\n   following\
    \ re-initialization of the network management system.  This\n   avoids the need\
    \ for a priori assignment of ifIndex values for all\n   possible interfaces which\
    \ might be added dynamically.\n   The exact meaning of a \"different\" interface\
    \ is hard to define, and\n   there will be gray areas.  One important criterion\
    \ is that a\n   management station, not noticing that an interface has gone away\
    \ and\n   another come into existence, should not be confused when it\n   calculates\
    \ the difference between the counter values retrieved on\n   successive polls\
    \ for a particular ifIndex value.  However, any firm\n   definition in this document\
    \ would likely to turn out to be\n   inadequate.  Instead, the following guidelines\
    \ are offered to allow\n   implementors to choose what \"different\" means in\
    \ their particular\n   situation.\n   A previously-unused value of ifIndex should\
    \ be assigned to a\n   dynamically added interface if:\n      (1)  the assignment\
    \ of a previously-used ifIndex value to the\n           interface could result\
    \ in a discontinuity in the values of\n           ifTable counters for that value\
    \ of ifIndex; or,\n      (2)  an agent has no knowledge of whether the interface\
    \ is the\n           \"same\" or \"different\" from a previous interface incarnation.\n\
    \   Because of the restriction of the value of ifIndex to be less than\n   ifNumber,\
    \ interfaces have been numbered with small integer values.\n   This has led to\
    \ the ability by humans to use the ifIndex values as\n   (somewhat) user-friendly\
    \ names for network interfaces (e.g.,\n   \"interface number 3\").  With the relaxation\
    \ of the restriction on the\n   value of ifIndex, there is now the possibility\
    \ that ifIndex values\n   could be assigned as very large numbers (e.g., memory\
    \ addresses).\n   Such numbers would be much less user-friendly.\n   Therefore,\
    \ this memo recommends that ifIndex values still be assigned\n   as (relatively)\
    \ small integer values starting at 1, even though the\n   values in use at any\
    \ one time are not necessarily contiguous.  (Note\n   that this makes remembering\
    \ which values have been assigned easy for\n   agents which dynamically add new\
    \ interfaces.)\n   This proposed change introduces a new problem of its own.\n\
    \   Previously, there usually was a simple, direct, mapping of interfaces\n  \
    \ to the physical ports on systems.  This mapping would be based on the\n   ifIndex\
    \ value.  However, by removing the previous restrictions on the\n   values allowed\
    \ for ifIndex, along with the interface sub-layer\n   concept (see the following\
    \ section), mapping from interfaces to\n   physical ports becomes increasingly\
    \ problematic.\n   To address this issue, a new object, ifName, is added to the\
    \ MIB.\n   This object contains the device's name for the interface of which the\n\
    \   relevant entry in the ifTable is a component.  For example, if a\n   router\
    \ has an interface named wan1, which is composed of PPP running\n   over an RS-232\
    \ port, the ifName objects for the corresponding PPP and\n   RS-232 entries in\
    \ the ifTable will contain the string \"wan1\".\n"
- title: 3.2.2.  Interface Sub-Layers
  contents:
  - "3.2.2.  Interface Sub-Layers\n   One possible but not recommended solution to\
    \ the problem of\n   representing multiple sub-layers would be to retain the concept\
    \ of\n   one conceptual row for all the sub-layers of an interface and have\n\
    \   each media-specific MIB module identify its \"superior\" and\n   \"subordinate\"\
    \ sub-layers through OBJECT IDENTIFIER \"pointers\".  The\n   drawbacks of this\
    \ scheme are: 1) the superior/subordinate pointers\n   are contained in the media-specific\
    \ MIB modules, and thus, a manager\n   could not learn the structure of an interface,\
    \ without inspecting\n   multiple pointers in different MIB modules; this is overly\
    \ complex\n   and only possible if the manager has knowledge of all the relevant\n\
    \   media-specific MIB modules; 2) current MIB modules would all need to\n   be\
    \ retrofitted with these new \"pointers\"; 3) this scheme does not\n   adequately\
    \ address the problem of upward and downward multiplexing;\n   and 4) enumerated\
    \ values of ifType are needed for each combination of\n   sub-layers.\n   Another\
    \ possible but not recommended scheme would be to retain the\n   concept of one\
    \ conceptual row for all the sub-layers of an interface\n   and have a new separate\
    \ MIB table to identify the \"superior\" and\n   \"subordinate\" sub-layers which\
    \ contain OBJECT IDENTIFIER \"pointers\"\n   to media-specific MIB module(s) for\
    \ each sub-layer.  Effectively, one\n   conceptual row in the ifTable would represent\
    \ each combination of\n   sub-layers between the internetwork-layer and the wire.\
    \  While this\n   scheme has fewer drawbacks, it does not support downward\n \
    \  multiplexing, such as PPP over MLP; since MLP makes two (or more)\n   serial\
    \ lines appear to the layers above as a single physical\n   interface, PPP over\
    \ MLP should appear to the internetwork-layer as a\n   single interface.  However,\
    \ this scheme would result in two (or more)\n   conceptual rows in the ifTable\
    \ and the internetwork-layer would run\n   over both of them.  This scheme also\
    \ requires enumerated values of\n   ifType for each combination of sub-layers.\n\
    \   The solution adopted in this memo is to have an individual conceptual\n  \
    \ row in the ifTable to represent each sub-layer and have a new\n   separate MIB\
    \ table (the ifStackTable, see section 5 of this memo) to\n   identify the \"\
    superior\" and \"subordinate\" sub-layers through INTEGER\n   \"pointers\" to\
    \ the appropriate conceptual rows in the ifTable.  This\n   solution supports\
    \ both upward and downward multiplexing.  It also\n   allows the IANAIfType to\
    \ Media-Specific MIB mapping to identify the\n   media-specific MIB module for\
    \ each sub- layer.  The new table\n   (ifStackTable) need be referenced only to\
    \ obtain information about\n   layering.  Enumerated values for ifType are required\
    \ for each sub-\n   layer only, not for combinations of them.\n   However, this\
    \ solution does require that the descriptions of some\n   objects in the ifTable\
    \ (specifically, ifType, ifPhysAddress,\n   ifInUcastPkts, and ifOutUcastPkts)\
    \ be generalized so as to apply to\n   any sub-layer (rather than only to a sub-layer\
    \ immediately beneath\n   the network layer, as at present).  It also requires\
    \ that some\n   objects (specifically, ifSpeed) need to have appropriate values\n\
    \   identified for use when a generalized definition does not apply to a\n   particular\
    \ sub-layer.\n   In addition, this adopted solution makes no requirement that\
    \ a\n   device, in which a sub-layer is instrumented by a conceptual row of\n\
    \   the ifTable, be aware of whether an internetwork protocol runs on top\n  \
    \ of (i.e., at some layer above) that sub-layer.  In fact, the counters\n   of\
    \ packets received on an interface are defined as counting the\n   number \"delivered\
    \ to a higher-layer protocol\".  This meaning of\n   \"higher-layer\" includes:\n\
    \      (1)  Delivery to a forwarding module which accepts\n           packets/frames/octets\
    \ and forwards them on at the same\n           protocol layer.  For example, for\
    \ the purposes of this\n           definition, the forwarding module of a MAC-layer\
    \ bridge is\n           considered as a \"higher-layer\" to the MAC-layer of each\
    \ port\n           on the bridge.\n      (2)  Delivery to a higher sub-layer within\
    \ a interface stack.  For\n           example, for the purposes of this definition,\
    \ if a PPP module\n           operated directly over a serial interface, the PPP\
    \ module\n           would be considered the higher sub-layer to the serial\n\
    \           interface.\n      (3)  Delivery to a higher protocol layer which does\
    \ not do packet\n           forwarding for sub-layers that are \"at the top of\"\
    \ the\n           interface stack.  For example, for the purposes of this\n  \
    \         definition, the local IP module would be considered the\n          \
    \ higher layer to a SLIP serial interface.\n   Similarly, for output, the counters\
    \ of packets transmitted out an\n   interface are defined as counting the number\
    \ \"that higher-level\n   protocols requested to be transmitted\".  This meaning\
    \ of \"higher-\n   layer\" includes:\n      (1)  A forwarding module, at the same\
    \ protocol layer, which\n           transmits packets/frames/octets that were\
    \ received on an\n           different interface.  For example, for the purposes\
    \ of this\n           definition, the forwarding module of a MAC-layer bridge\
    \ is\n           considered as a \"higher-layer\" to the MAC-layer of each port\n\
    \           on the bridge.\n      (2)  The next higher sub-layer within an interface\
    \ stack.  For\n           example, for the purposes of this definition, if a PPP\
    \ module\n           operated directly over a serial interface, the PPP module\n\
    \           would be a \"higher layer\" to the serial interface.\n      (3)  For\
    \ sub-layers that are \"at the top of\" the interface stack,\n           a higher\
    \ element in the network protocol stack.  For example,\n           for the purposes\
    \ of this definition, the local IP module\n           would be considered the\
    \ higher layer to an Ethernet\n           interface.\n"
- title: 3.2.3.  Guidance on Defining Sub-layers
  contents:
  - "3.2.3.  Guidance on Defining Sub-layers\n   The designer of a media-specific\
    \ MIB must decide whether to divide\n   the interface into sub-layers, and if\
    \ so, how to make the divisions.\n   The following guidance is offered to assist\
    \ the media-specific MIB\n   designer in these decisions.\n   In general, the\
    \ number of entries in the ifTable should be kept to\n   the minimum required\
    \ for network management.  In particular, a group\n   of related interfaces should\
    \ be treated as a single interface with\n   one entry in the ifTable providing\
    \ that:\n      (1)  None of the group of interfaces performs multiplexing for\
    \ any\n           other interface in the agent,\n      (2)  There is a meaningful\
    \ and useful way for all of the ifTable's\n           information (e.g., the counters,\
    \ and the status variables),\n           and all of the ifTable's capabilities\
    \ (e.g., write access to\n           ifAdminStatus), to apply to the group of\
    \ interfaces as a\n           whole.\n   Under these circumstances, there should\
    \ be one entry in the ifTable\n   for such a group of interfaces, and any internal\
    \ structure which\n   needs to be represented to network management should be\
    \ captured in a\n   MIB module specific to the particular type of interface.\n\
    \   Note that application of bullet 2 above to the ifTable's ifType\n   object\
    \ requires that there is a meaningful media-specific MIB and a\n   meaningful\
    \ ifType value which apply to the group of interfaces as a\n   whole.  For example,\
    \ it is not appropriate to treat an HDLC sub-layer\n   and an RS-232 sub-layer\
    \ as a single ifTable entry when the media-\n   specific MIBs and the ifType values\
    \ for HDLC and RS-232 are separate\n   (rather than combined).\n   Note that the\
    \ sub-layers of an interface on one device will sometimes\n   be different to\
    \ the sub-layers of the interconnected interface of\n   another device.  A simple\
    \ example of this is a frame-relay DTE\n   interface which connects to a frameRelayService\
    \ interface, where the\n   DTE interface has a different ifType value and media-specific\
    \ MIB to\n   the DCE interface.\n   Also note that a media-specific MIB may mandate\
    \ that a particular\n   ifTable counter does not apply and that its value must\
    \ always be 0,\n   signifying that the applicable event can not and does not occur\
    \ for\n   that type of interface; for example, ifInMulticastPkts and\n   ifOutMulticastPkts\
    \ on an interface type which has no multicast\n   capability.  In other circumstances,\
    \ an agent must not always return\n   0 for any counter just because its implementation\
    \ is incapable of\n   detecting occurrences of the particular event; instead,\
    \ it must\n   return a noSuchName/noSuchObject error/exception when queried for\
    \ the\n   counter, even if this prevents the implementation from complying with\n\
    \   the relevant MODULE-COMPLIANCE macro.\n   These guidelines are just that -\
    \ guidelines.  The designer of a\n   media-specific MIB is free to lay out the\
    \ MIB in whatever SMI\n   conformant manner is desired.  However, in so doing,\
    \ the media-\n   specific MIB MUST completely specify the sub-layering model used\
    \ for\n   the MIB, and provide the assumptions, reasoning, and rationale used\n\
    \   to develop that model.\n"
- title: 3.2.4.  Virtual Circuits
  contents:
  - "3.2.4.  Virtual Circuits\n   This memo strongly recommends that connection-oriented\
    \ sub-layers do\n   not have a conceptual row in the ifTable for each virtual\
    \ circuit.\n   This avoids the proliferation of conceptual rows, especially those\n\
    \   which have considerable redundant information.  (Note, as a\n   comparison,\
    \ that connection-less sub-layers do not have conceptual\n   rows for each remote\
    \ address.)  There may, however, be circumstances\n   under which it is appropriate\
    \ for a virtual circuit of a connection-\n   oriented sub-layer to have its own\
    \ conceptual row in the ifTable; an\n   example of this might be PPP over an X.25\
    \ virtual circuit.  The MIB\n   in section 6 of this memo supports such circumstances.\n\
    \   If a media-specific MIB wishes to assign an entry in the ifTable to\n   each\
    \ virtual circuit, the MIB designer must present the rationale for\n   this decision\
    \ in the media-specific MIB's specification.\n"
- title: 3.2.5.  Bit, Character, and Fixed-Length Interfaces
  contents:
  - "3.2.5.  Bit, Character, and Fixed-Length Interfaces\n   About half the objects\
    \ in the ifTable are applicable to every type of\n   interface: packet-oriented,\
    \ character-oriented, and bit-oriented.  Of\n   the other half, two are applicable\
    \ to both character-oriented and\n   packet-oriented interfaces, and the rest\
    \ are applicable only to\n   packet-oriented interfaces.  Thus, while it is desirable\
    \ for\n   consistency to be able to represent any/all types of interfaces in\n\
    \   the ifTable, it is not possible to implement the full ifTable for\n   bit-\
    \ and character-oriented sub-layers.\n   One possible but not recommended solution\
    \ to this problem would be to\n   split the ifTable into two (or more) new MIB\
    \ tables, one of which\n   would contain objects that are relevant only to packet-oriented\n\
    \   interfaces (e.g., PPP), and another that may be used by all\n   interfaces.\
    \  This is highly undesirable since it would require\n   changes in every agent\
    \ implementing the ifTable (i.e., just about\n   every existing SNMP agent).\n\
    \   The solution adopted in this memo builds upon the fact that\n   compliance\
    \ statements in SNMPv2 (in contrast to SNMPv1) refer to\n   object groups, where\
    \ object groups are explicitly defined by listing\n   the objects they contain.\
    \  Thus, in SNMPv2, multiple compliance\n   statements can be specified, one for\
    \ all interfaces and additional\n   ones for specific types of interfaces.  The\
    \ separate compliance\n   statements can be based on separate object groups, where\
    \ the object\n   group for all interfaces can contain only those objects from\
    \ the\n   ifTable which are appropriate for every type of interfaces.  Using\n\
    \   this solution, every sub-layer can have its own conceptual row in the\n  \
    \ ifTable.\n   Thus, section 6 of this memo contains definitions of the objects\
    \ of\n   the existing 'interfaces' group of MIB-II, in a manner which is both\n\
    \   SNMPv2-compliant and semantically-equivalent to the existing MIB-II\n   definitions.\
    \  With equivalent semantics, and with the BER (\"on the\n   wire\") encodings\
    \ unchanged, these definitions retain the same OBJECT\n   IDENTIFIER values as\
    \ assigned by MIB-II.  Thus, in general, no\n   rewrite of existing agents which\
    \ conform to MIB-II and the\n   ifExtensions MIB is required.\n   In addition,\
    \ this memo defines several object groups for the purposes\n   of defining which\
    \ objects apply to which types of interface:\n      (1)  the ifGeneralGroup. \
    \ This group contains those objects\n           applicable to all types of network\
    \ interfaces, including\n           bit-oriented interfaces.\n      (2)  the ifPacketGroup.\
    \  This group contains those objects\n           applicable to packet-oriented\
    \ network interfaces.\n      (3)  the ifFixedLengthGroup.  This group contains\
    \ the objects\n           applicable not only to character-oriented interfaces,\
    \ such as\n           RS-232, but also to those subnetwork technologies, such\
    \ as\n           cell-relay/ATM, which transmit data in fixed length\n       \
    \    transmission units.  As well as the octet counters, there are\n         \
    \  also a few other counters (e.g., the error counters) which\n           are\
    \ useful for this type of interface, but are currently\n           defined as\
    \ being packet-oriented.  To accommodate this, the\n           definitions of\
    \ these counters are generalized to apply to\n           character-oriented interfaces\
    \ and fixed-length-transmission\n           interfaces.\n   It should be noted\
    \ that the octet counters in the ifTable aggregate\n   octet counts for unicast\
    \ and non-unicast packets into a single octet\n   counter per direction (received/transmitted).\
    \  Thus, with the above\n   definition of fixed-length-transmission interfaces,\
    \ where such\n   interfaces which support non-unicast packets, separate counts\
    \ of\n   unicast and multicast/broadcast transmissions can only be maintained\n\
    \   in a media-specific MIB module.\n"
- title: 3.2.6.  Counter Size
  contents:
  - "3.2.6.  Counter Size\n   Two approaches to addressing the shrinking minimum counter-wrap\
    \ time\n   problem were evaluated.  Counters could be scaled, for example,\n \
    \  ifInOctets could be changed to count received octets in, e.g., 1024\n   byte\
    \ blocks.  Alternatively, the size of the counter could be\n   increased.\n  \
    \ Scaling the counters was rejected.  While it provides acceptable\n   performance\
    \ at high count rates, at low rates it suffers.  If there\n   is little traffic\
    \ on an interface, there might be a significant\n   interval before enough counts\
    \ occur to cause a counter to be\n   incremented.  Traffic would then appear to\
    \ be very bursty, leading to\n   incorrect conclusions of the network's performance.\n\
    \   The alternative, which this memo adopts, is to provide expanded, 64\n   bit,\
    \ counters.  These counters are provided in new \"high capacity\"\n   groups,\n\
    \   The old, 32-bit, counters have not been deprecated.  The 64-bit\n   counters\
    \ are to be used only when the 32-bit counters do not provide\n   enough capacity;\
    \ that is, the 32 bit counters could wrap too fast.\n   For interfaces that operate\
    \ at 20,000,000 (20 million) bits per\n   second or less, 32-bit byte and packet\
    \ counters MUST be used.  For\n   interfaces that operate faster than 20,000,000\
    \ bits/second, and\n   slower than 650,000,000 bits/second, 32-bit packet counters\
    \ MUST be\n   used and 64-bit octet counters MUST be used.  For interfaces that\n\
    \   operate at 650,000,000 bits/second or faster, both 64-bit packet\n   counters\
    \ AND 64-bit octet counters MUST be used.\n   These speed steps were chosen as\
    \ reasonable compromises based on the\n   following:\n      (1)  The cost of maintaining\
    \ 64-bit counters is relatively high,\n           so minimizing the number of\
    \ agents which must support them is\n           desirable.  Common interfaces\
    \ (such as Ethernet) should not\n           require them.\n      (2)  64-bit counters\
    \ are a new feature, introduced in SNMPv2.  It\n           is reasonable to expect\
    \ that support for them will be spotty\n           for the immediate future. \
    \ Thus, we wish to limit them to as\n           few systems as possible.  This,\
    \ in effect, means that 64-bit\n           counters should be limited to higher\
    \ speed interfaces.\n           Ethernet (10,000,000 bps) and Token Ring (16,000,000\
    \ bps) are\n           fairly wide-spread so it seems reasonable to not require\
    \ 64-\n           bit counters for these interfaces.\n      (3)  The 32-bit octet\
    \ counters will wrap in the following times,\n           for the following interfaces\
    \ (when transmitting maximum-sized\n           packets back-to-back):\n      \
    \     -   Ethernet: 57 minutes,\n           -   16 megabit Token Ring: 36 minutes,\n\
    \           -   A US T3 line (45 megabits): 12 minutes,\n           -   FDDI:\
    \ 5.7 minutes\n      (4)  The 32-bit packet counters wraps in about 57 minutes\
    \ when\n           64-byte packets are transmitted back-to-back on a 650,000,000\n\
    \           bit/second link.\n           As an aside, a 1-terabit (1,000 gigabits)\
    \ link will cause a\n           64 bit octet counter to wrap in just under 5 years.\n\
    \           Conversely, an 81,000,000 terabit/second link is required to\n   \
    \        cause a 64-bit counter to wrap in 30 minutes.  We believe\n         \
    \  that, while technology rapidly marches forward, this link\n           speed\
    \ will not be achieved for at least several years,\n           leaving sufficient\
    \ time to evaluate the introduction of 96\n           bit counters.\n   When 64-bit\
    \ counters are in use, the 32-bit counters MUST still be\n   available.  They\
    \ will report the low 32-bits of the associated 64-bit\n   count (e.g., ifInOctets\
    \ will report the least significant 32 bits of\n   ifHCInOctets).  This enhances\
    \ inter-operability with existing\n   implementations at a very minimal cost to\
    \ agents.\n   The new \"high capacity\" groups are:\n      (1)  the ifHCFixedLengthGroup\
    \ for character-oriented/fixed-length\n           interfaces, and the ifHCPacketGroup\
    \ for packet-based\n           interfaces; both of these groups include 64 bit\
    \ counters for\n           octets, and\n      (2)  the ifVHCPacketGroup for packet-based\
    \ interfaces; this group\n           includes 64 bit counters for octets and packets.\n"
- title: 3.2.7.  Interface Speed
  contents:
  - "3.2.7.  Interface Speed\n   In order to deal with increasing interface speeds,\
    \ we have added an\n   ifHighSpeed object.\n   This object reports the speed of\
    \ the interface in 1,000,000 (1\n   million) bits/second units.  Thus, the true\
    \ speed of the interface\n   will be the value reported by this object, plus or\
    \ minus 500,000\n   bits/second.\n   Other alternatives considered were:\n   \
    \   (1)  Making the interface speed a 64-bit gauge.  This was rejected\n     \
    \      since the current SMI does not allow such a syntax.\n           Furthermore,\
    \ even if 64-bit gauges were available, their use\n           would require additional\
    \ complexity in agents due to an\n           increased requirement for 64-bit\
    \ operations.\n      (2)  We also considered making \"high-32 bit\" and \"low-32-bit\"\
    \n           objects which, when combined, would be a 64-bit value.  This\n  \
    \         simply seemed overly complex for what we are trying to do.\n       \
    \    Furthermore, a full 64-bits of precision does not seem\n           necessary.\
    \  The value of ifHighSpeed will be the only report\n           of interface speed\
    \ for interfaces that are faster than\n           4,294,967,295 bits per second.\
    \  At this speed, the\n           granularity of ifHighSpeed will be 1,000,000\
    \ bits per second,\n           thus the error will be 1/4294, or about 0.02%.\
    \  This seems\n           reasonable.\n      (3)  Adding a \"scale\" object, which\
    \ would define the units which\n           ifSpeed's value is.\n           This\
    \ would require two additional objects; one for the\n           scaling object,\
    \ and one to replace the current ifSpeed.  This\n           later object is required\
    \ since the semantics of ifSpeed would\n           be significantly altered, and\
    \ manager stations which do not\n           understand the new semantics would\
    \ be confused.\n"
- title: 3.2.8.  Multicast/Broadcast Counters
  contents:
  - "3.2.8.  Multicast/Broadcast Counters\n   To avoid the redundancy of counting\
    \ all non-unicast packets as well\n   as having individual multicast and broadcast\
    \ packet counters, we\n   deprecate the use of the non-unicast counters, which\
    \ can be derived\n   from the values of the others.\n   For the output broadcast\
    \ and multicast counters defined in RFC 1229,\n   their definitions varied slightly\
    \ from the packet counters in the\n   ifTable, in that they did not count errors/discarded\
    \ packets.  To\n   align the definitions better, the old counters are deprecated\
    \ and\n   replaced by new definitions.  Counters with 64 bits of range are also\n\
    \   needed, as explained above.\n"
- title: 3.2.9.  Trap Enable
  contents:
  - "3.2.9.  Trap Enable\n   In the multi-layer interface model, each sub-layer for\
    \ which there is\n   an entry in the ifTable can generate linkUp/Down Traps. \
    \ Since\n   interface state changes would tend to propagate through the interface\n\
    \   (from top to bottom, or bottom to top), it is likely that several\n   traps\
    \ would be generated for each linkUp/Down occurrence.\n   It is desirable to provide\
    \ a mechanism for manager stations to\n   control the generation of these traps.\
    \  To this end, the\n   ifLinkUpDownTrapEnable object has been added.  This object\
    \ allows\n   managers to limit generation of traps to just the sub-layers of\n\
    \   interest.\n   The default setting should limit the number of traps generated\
    \ to one\n   per interface per linkUp/Down event.  Furthermore, it seems that\
    \ the\n   conditions that cause these state changes that are of most interest\n\
    \   to network managers occur at the lowest level of an interface stack.\n   Therefore\
    \ we specify that by default, only the lowest sub-layer of\n   the interface generate\
    \ traps.\n"
- title: 3.2.10.  Addition of New ifType values
  contents:
  - "3.2.10.  Addition of New ifType values\n   The syntax of ifType is changed to\
    \ be a textual convention, such that\n   the enumerated integer values are now\
    \ defined in the textual\n   convention, IANAifType, which can be re-specified\
    \ (with additional\n   values) without issuing a new version of this document.\
    \  The Internet\n   Assigned Number Authority (IANA) is responsible for the assignment\
    \ of\n   all Internet numbers, including various SNMP-related numbers, and\n \
    \  specifically, new ifType values.  Thus, this document defines two MIB\n   modules:\
    \ one to define the MIB for the 'interfaces' group, and a\n   second to define\
    \ the first version of the IANAifType textual\n   convention.  The latter will\
    \ be periodically re-issued by the IANA.\n"
- title: 3.2.11.  InterfaceIndex Textual Convention
  contents:
  - "3.2.11.  InterfaceIndex Textual Convention\n   A new textual convention, InterfaceIndex,\
    \ has been defined.  This\n   textual convention \"contains\" all of the semantics\
    \ of the ifIndex\n   object.  This allows other mib modules to easily import the\
    \ semantics\n   of ifIndex.\n"
- title: 3.2.12.  IfAdminStatus and IfOperStatus
  contents:
  - "3.2.12.  IfAdminStatus and IfOperStatus\n   A new state has been added to ifOperStatus:\
    \ dormant.  This state\n   indicates that the relevant interface is not actually\
    \ in a condition\n   to pass packets (i.e., up) but is in a \"pending\" state,\
    \ waiting for\n   some external event.  For \"on-demand\" interfaces, this new\
    \ state\n   identifies the situation where the interface is waiting for events\
    \ to\n   place it in the up state.  Examples of such events might be:\n      (1)\
    \  having packets to transmit before establishing a connection\n           to\
    \ a remote system.\n      (2)  having a remote system establish a connection to\
    \ the\n           interface (e.g., dialing up to a slip-server).\n   The down\
    \ state now has two meanings, depending on the value of\n   ifAdminStatus.\n \
    \     (1)  If ifAdminStatus is not down and ifOperStatus is down, then a\n   \
    \        fault condition is presumed to exist on the interface.\n      (2)  If\
    \ ifAdminStatus is down, then ifOperStatus will normally\n           also be down,\
    \ i.e., there is not (necessarily) a fault\n           condition on the interface.\n\
    \   Note that when ifAdminStatus transitions to down, ifOperStatus will\n   normally\
    \ also transition to down.  In this situation, it is possible\n   that ifOperStatus's\
    \ transition will not occur immediately, but rather\n   after a small time lag\
    \ to complete certain operations before going\n   \"down\"; for example, it might\
    \ need to finish transmitting a packet.\n   If a manager station finds that ifAdminStatus\
    \ is down and\n   ifOperStatus is not down for a particular interface, the manager\n\
    \   station should wait a short while and check again.  If the condition\n   still\
    \ exists only then should it raise an error indication.\n   Naturally, it should\
    \ also ensure that ifLastChange has not changed\n   during this interval.\n  \
    \ Whenever an interface table entry is created (usually as a result of\n   system\
    \ initialization), the relevant instance of ifAdminStatus is set\n   to down,\
    \ and presumably ifOperStatus will also be down.\n   An interface may be enabled\
    \ in two ways: either as a result of\n   explicit management action (e.g., setting\
    \ ifAdminStatus to up) or as\n   a result of the managed system's initialization\
    \ process.  When\n   ifAdminStatus changes to the up state, the related ifOperStatus\n\
    \   should do one of the following:\n      (1)  Change to the up state if and\
    \ only if the interface is able\n           to send and receive packets.\n   \
    \   (2)  Change to the dormant state if and only if the interface is\n       \
    \    found to be operable, but the interface is waiting for other,\n         \
    \  external, events to occur before it can transmit or receive\n           packets.\
    \  Presumably when the expected events occur, the\n           interface will then\
    \ transition to the up state.\n      (3)  Remain in the down state if an error\
    \ or other fault condition\n           is detected on the interface.\n      (4)\
    \  Change to the unknown state if, for some reason, the state of\n           the\
    \ interface can not be ascertained.\n      (5)  Change to the testing state if\
    \ some test(s) must be performed\n           on the interface.  Presumably after\
    \ completion of the test,\n           the interface's state will change to up,\
    \ dormant, or down, as\n           appropriate.\n"
- title: 3.2.13.  Traps
  contents:
  - "3.2.13.  Traps\n   The exact definition of when linkUp and linkDown traps are\
    \ generated,\n   has been changed to reflect the changes to ifAdminStatus and\n\
    \   ifOperStatus.\n   LinkUp and linkDown traps are generated just after ifOperStatus\n\
    \   leaves, or just before it enters, the down state, respectively.  The\n   wording\
    \ of the conditions under which a linkDown trap is generated\n   was explicitly\
    \ chosen to allow a node with only one interface to\n   transmit the linkDown\
    \ trap before that interface goes down.\n   Operational experience seems to indicate\
    \ that manager stations are\n   most concerned with an interface being in the\
    \ down state and the fact\n   that this state may indicate a failure.  It seemed\
    \ most useful to\n   instrument either transitions into/out of the up state or\
    \ the down\n   state.\n   Instrumenting transitions into or out of the up state\
    \ has the\n   drawback that an on-demand interface might have many transitions\n\
    \   between up and dormant, leading to many linkUp traps and no linkDown\n   traps.\
    \  Furthermore, if a node's only interface is the on-demand\n   interface, then\
    \ a transition to dormant will entail generation of a\n   trap, necessitating\
    \ bringing the link to the up state (and a linkUp\n   trap)!!\n   On the other\
    \ hand, instrumenting transitions into or out of the down\n   state has the advantages:\n\
    \      (1)  A transition into the down state will occur when an error is\n   \
    \        detected on an interface.  Error conditions are presumably of\n     \
    \      great interest to network managers.\n      (2)  Departing the down state\
    \ generally indicates that the\n           interface is going to either up or\
    \ dormant, both of which are\n           considered \"healthy\" states.\n   Furthermore,\
    \ it is believed that generarating traps on transitions\n   into or out of the\
    \ down state is generally consistent with current\n   usage and interpretation\
    \ of these traps by manager stations.\n   Therefore, this memo defines that it\
    \ is the transitions into/out of\n   the down state which generate traps.\n  \
    \ Obviously, if a failure condition is present on a node with a single\n   interface,\
    \ the linkDown trap will probably not be succesfully\n   transmitted since the\
    \ interface through which it must be transmitted\n   has failed.\n"
- title: 3.2.14.  ifSpecific
  contents:
  - "3.2.14.  ifSpecific\n   The current definition of ifSpecific is not explicit\
    \ enough.  The\n   only definition that can both be made explicit and can cover\
    \ all the\n   useful situations (see section 3.1.9) is to have ifSpecific be the\n\
    \   most general value for the media-specific MIB module (the first\n   example\
    \ given section in 3.1.9).  This effectively makes it redundant\n   because it\
    \ contains no more information than is provided by ifType.\n   For this reason,\
    \ ifSpecific has been deprecated.\n"
- title: 3.3.  Media-Specific MIB Applicability
  contents:
  - "3.3.  Media-Specific MIB Applicability\n   The exact use and semantics of many\
    \ objects in this MIB are open to\n   some interpretation.  This is a result of\
    \ the generic nature of this\n   MIB.  It is not always possible to come up with\
    \ specific,\n   unambiguous, text that covers all cases and yet preserve the generic\n\
    \   nature of the MIB.\n   Therefore, it is incumbent upon a media-specific MIB\
    \ designer to,\n   wherever necessary, clarify the use of the objects in this\
    \ MIB with\n   respect to the media-specific MIB.\n   Specific areas of clarification\
    \ include:\n   Layering Model\n        The media-specific MIB designer MUST completely\
    \ and\n        unambiguously specify the layering model used.  Each\n        individual\
    \ sub-layer must be identified.\n   Virtual Circuits\n        The media-specific\
    \ MIB designer MUST specify whether virtual\n        circuits are assigned entries\
    \ in the ifTable or not.  If they\n        are, compelling rationale must be presented.\n\
    \   ifTestTable\n        The media-specific MIB designer MUST specify the\n  \
    \      applicability of the ifTestTable.\n   ifRcvAddressTable\n        The media-specific\
    \ MIB designer MUST specify the\n        applicability of the ifRcvAddressTable.\n\
    \   ifType\n        For each of the ifType values to which the media-specific\
    \ MIB\n        applies, it must specify the mapping of ifType values to\n    \
    \    media-specific MIB module(s) and instances of MIB objects\n        within\
    \ those modules.\n   However, wherever this interface MIB is specific in the semantics,\n\
    \   DESCRIPTION, or applicability of objects, the media-specific MIB\n   designer\
    \ MUST NOT change said semantics, DESCRIPTION, or\n   applicability.\n"
- title: 4.  Overview
  contents:
  - "4.  Overview\n   This MIB consists of 5 tables:\n   ifTable\n        This table\
    \ is the ifTable from MIB-II.\n   ifXTable\n        This table contains objects\
    \ that have been added to the\n        Interface MIB as a result of the Interface\
    \ Evolution effort,\n        or replacements for objects of the original, MIB-II,\
    \ ifTable\n        that were deprecated because the semantics of said objects\n\
    \        have significantly changed.  This table also contains objects\n     \
    \   that were previously in the ifExtnsTable.\n   ifStackTable\n        This table\
    \ contains objects that define the relationships\n        among the sub-layers\
    \ of an interface.\n   ifTestTable\n        This table contains objects that are\
    \ used to perform tests on\n        interfaces.  This table is a generic table.\
    \  The designers of\n        media-specific MIBs must define exactly how this\
    \ table\n        applies to their specific MIB.\n        This table replaces the\
    \ interface test table defined in\n        RFC1229 [7].  The significant change\
    \ is the replacement of\n        the ifExtnsTestCommunity (and ifExtnsTestContext\
    \ which would\n        also have been required for SNMPv2) and ifExtnsTestRequestId\n\
    \        objects, by the new ifTestId, ifTestStatus, and ifTestOwner\n       \
    \ objects.\n   ifRcvAddressTable\n        This table contains objects that are\
    \ used to define the\n        media-level addresses which this interface will\
    \ receive.\n        This table is a generic table.  The designers of media-\n\
    \        specific MIBs must define exactly how this table applies to\n       \
    \ their specific MIB.\n"
- title: 5.  IANAifType Definition
  contents:
  - "5.  IANAifType Definition\n   IANAifType-MIB DEFINITIONS ::= BEGIN\n   IMPORTS\n\
    \       MODULE-IDENTITY, OBJECT-TYPE        FROM SNMPv2-SMI\n       TEXTUAL-CONVENTION\
    \                  FROM SNMPv2-TC;\n   ianaifType MODULE-IDENTITY\n       LAST-UPDATED\
    \ \"9311082155Z\"\n       ORGANIZATION \"IANA\"\n       CONTACT-INFO\n       \
    \           \"        Internet Assigned Numbers Authority\n                  \
    \ Postal: USC/Information Sciences Institute\n                           4676\
    \ Admiralty Way, Marina del Rey, CA 90292\n                   Tel:    +1  310\
    \ 822 1511\n                   E-Mail: iana@isi.edu\"\n       DESCRIPTION\n  \
    \             \"The MIB module which defines the IANAifType textual\n        \
    \       convention, and thus the enumerated values of the\n               ifType\
    \ object defined in MIB-II's ifTable.\"\n       ::= { mib-2 30 }\n   IANAifType\
    \ ::= TEXTUAL-CONVENTION\n       STATUS       current\n       DESCRIPTION\n  \
    \             \"This data type is used as the syntax of the ifType\n         \
    \      object in the (updated) definition of MIB-II's\n               ifTable.\n\
    \               The definition of this textual convention with the\n         \
    \      addition of newly assigned values is published\n               periodically\
    \ by the IANA, in either the Assigned\n               Numbers RFC, or some derivative\
    \ of it specific to\n               Internet Network Management number assignments.\
    \  (The\n               latest arrangements can be obtained by contacting the\n\
    \               IANA.)\n               Requests for new values should be made\
    \ to IANA via\n               email (iana@isi.edu).\n               The relationship\
    \ between the assignment of ifType\n               values and of OIDs to particular\
    \ media-specific MIBs\n               is solely the purview of IANA and is subject\
    \ to change\n               without notice.  Quite often, a media-specific MIB's\n\
    \               OID-subtree assignment within MIB-II's 'transmission'\n      \
    \         subtree will be the same as its ifType value.\n               However,\
    \ in some circumstances this will not be the\n               case, and implementors\
    \ must not pre-assume any\n               specific relationship between ifType\
    \ values and\n               transmission subtree OIDs.\"\n       SYNTAX  INTEGER\
    \ {\n                   other(1),          -- none of the following\n        \
    \           regular1822(2),\n                   hdh1822(3),\n                \
    \   ddnX25(4),\n                   rfc877x25(5),\n                   ethernetCsmacd(6),\n\
    \                   iso88023Csmacd(7),\n                   iso88024TokenBus(8),\n\
    \                   iso88025TokenRing(9),\n                   iso88026Man(10),\n\
    \                   starLan(11),\n                   proteon10Mbit(12),\n    \
    \               proteon80Mbit(13),\n                   hyperchannel(14),\n   \
    \                fddi(15),\n                   lapb(16),\n                   sdlc(17),\n\
    \                   ds1(18),           -- DS1/E1 (RFC 1406)\n                \
    \   e1(19),            -- obsolete\n                   basicISDN(20),\n      \
    \             primaryISDN(21),\n                   propPointToPointSerial(22),\
    \ -- proprietary serial\n                   ppp(23),\n                   softwareLoopback(24),\n\
    \                   eon(25),            -- CLNP over IP (RFC 1070)\n         \
    \          ethernet3Mbit(26),\n                   nsip(27),           -- XNS over\
    \ IP\n                   slip(28),           -- generic SLIP\n               \
    \    ultra(29),          -- ULTRA technologies\n                   ds3(30),  \
    \          -- T-3\n                   sip(31),            -- SMDS\n          \
    \         frameRelay(32),    -- DTE only\n                   rs232(33),\n    \
    \               para(34),           -- parallel-port\n                   arcnet(35),\
    \         -- arcnet\n                   arcnetPlus(36),     -- arcnet plus\n \
    \                  atm(37),            -- ATM cells\n                   miox25(38),\n\
    \                   sonet(39),          -- SONET or SDH\n                   x25ple(40),\n\
    \                   iso88022llc(41),\n                   localTalk(42),\n    \
    \               smdsDxi(43),\n                   frameRelayService(44),  -- Frame\
    \ relay DCE\n                   v35(45),\n                   hssi(46),\n     \
    \              hippi(47),\n                   modem(48),          -- Generic modem\n\
    \                   aal5(49),           -- AAL5 over ATM\n                   sonetPath(50),\n\
    \                   sonetVT(51),\n                   smdsIcip(52),       -- SMDS\
    \ InterCarrier Interface\n                   propVirtual(53),    -- proprietary\
    \ virtual/internal\n                   propMultiplexor(54) -- proprietary multiplexing\n\
    \               }\n   END\n"
- title: 6.  Interfaces Group Definitions
  contents:
  - "6.  Interfaces Group Definitions\n   IF-MIB DEFINITIONS ::= BEGIN\n   IMPORTS\n\
    \       MODULE-IDENTITY, OBJECT-TYPE, Counter32, Gauge32,\n       Integer32, TimeTicks,\n\
    \       NOTIFICATION-TYPE                        FROM SNMPv2-SMI\n       TEXTUAL-CONVENTION,\
    \ DisplayString,\n       PhysAddress, TruthValue, RowStatus,\n       AutonomousType,\
    \ TestAndIncr              FROM SNMPv2-TC\n       MODULE-COMPLIANCE, OBJECT-GROUP\
    \          FROM SNMPv2-CONF\n       IANAifType                               FROM\
    \ IANAifType-MIB\n       interfaces                               FROM RFC-1213;\n\
    \   ifMIB MODULE-IDENTITY\n       LAST-UPDATED \"9311082155Z\"\n       ORGANIZATION\
    \ \"IETF Interfaces MIB Working Group\"\n       CONTACT-INFO\n               \
    \   \"        Keith McCloghrie\n                   Postal: Hughes LAN Systems\n\
    \                           1225 Charleston Road, Mountain View, CA 94043\n  \
    \                 Tel:    +1 415 966 7934\n                   E-Mail: kzm@hls.com\n\
    \                           Frank Kastenholz\n                   Postal: FTP Software\n\
    \                           2 High Street, North Andover, MA 01845\n         \
    \          Tel:    +1 508 685 4000\n                   E-Mail: kasten@ftp.com\"\
    \n       DESCRIPTION\n               \"The MIB module to describe generic objects\
    \ for\n               network interface sub-layers.  This MIB is an updated\n\
    \               version of MIB-II's ifTable, and incorporates the\n          \
    \     extensions defined in RFC 1229.\"\n       ::= { mib-2 31 }\n   ifMIBObjects\
    \ OBJECT IDENTIFIER ::= { ifMIB 1 }\n   -- OwnerString has the same semantics\
    \ as used in RFC 1271\n   OwnerString ::= TEXTUAL-CONVENTION\n       DISPLAY-HINT\
    \ \"255a\"\n       STATUS       current\n       DESCRIPTION\n               \"\
    This data type is used to model an administratively\n               assigned name\
    \ of the owner of a resource.  This\n               information is taken from\
    \ the NVT ASCII character set.\n               It is suggested that this name\
    \ contain one or more of\n               the following: ASCII form of the manager\
    \ station's\n               transport address, management station name (e.g.,\n\
    \               domain name), network management personnel's name,\n         \
    \      location, or phone number.  In some cases the agent\n               itself\
    \ will be the owner of an entry.  In these cases,\n               this string\
    \ shall be set to a string starting with\n               'agent'.\"\n       SYNTAX\
    \       OCTET STRING (SIZE(0..255))\n   -- InterfaceIndex contains the semantics\
    \ of ifIndex and\n   -- should be used for any objects defined on other mib\n\
    \   -- modules that need these semantics.\n   InterfaceIndex ::= TEXTUAL-CONVENTION\n\
    \       DISPLAY-HINT \"d\"\n       STATUS       current\n       DESCRIPTION\n\
    \               \"A unique value, greater than zero, for each interface\n    \
    \           or interface sub-layer in the managed system.  It is\n           \
    \    recommended that values are assigned contiguously\n               starting\
    \ from 1.  The value for each interface sub-\n               layer must remain\
    \ constant at least from one re-\n               initialization of the entity's\
    \ network management\n               system to the next re-initialization.\"\n\
    \       SYNTAX       Integer32\n   ifNumber  OBJECT-TYPE\n       SYNTAX      Integer32\n\
    \       MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The number of network interfaces (regardless of their\n    \
    \           current state) present on this system.\"\n       ::= { interfaces\
    \ 1 }\n   -- the Interfaces table\n   -- The Interfaces table contains information\
    \ on the entity's\n   -- interfaces.  Each sub-layer below the internetwork-layer\n\
    \   -- of a network interface is considered to be an interface.\n   ifTable OBJECT-TYPE\n\
    \       SYNTAX      SEQUENCE OF IfEntry\n       MAX-ACCESS  not-accessible\n \
    \      STATUS      current\n       DESCRIPTION\n               \"A list of interface\
    \ entries.  The number of entries\n               is given by the value of ifNumber.\"\
    \n       ::= { interfaces 2 }\n   ifEntry OBJECT-TYPE\n       SYNTAX      IfEntry\n\
    \       MAX-ACCESS  not-accessible\n       STATUS      current\n       DESCRIPTION\n\
    \               \"An entry containing management information applicable\n    \
    \           to a particular interface.\"\n       INDEX   { ifIndex }\n       ::=\
    \ { ifTable 1 }\n   IfEntry ::=\n       SEQUENCE {\n           ifIndex       \
    \          InterfaceIndex,\n           ifDescr                 DisplayString,\n\
    \           ifType                  IANAifType,\n           ifMtu            \
    \       Integer32,\n           ifSpeed                 Gauge32,\n           ifPhysAddress\
    \           PhysAddress,\n           ifAdminStatus           INTEGER,\n      \
    \     ifOperStatus            INTEGER,\n           ifLastChange            TimeTicks,\n\
    \           ifInOctets              Counter32,\n           ifInUcastPkts     \
    \      Counter32,\n           ifInNUcastPkts          Counter32,  -- deprecated\n\
    \           ifInDiscards            Counter32,\n           ifInErrors        \
    \      Counter32,\n           ifInUnknownProtos       Counter32,\n           ifOutOctets\
    \             Counter32,\n           ifOutUcastPkts          Counter32,\n    \
    \       ifOutNUcastPkts         Counter32,  -- deprecated\n           ifOutDiscards\
    \           Counter32,\n           ifOutErrors             Counter32,\n      \
    \     ifOutQLen               Gauge32,    -- deprecated\n           ifSpecific\
    \              OBJECT IDENTIFIER -- deprecated\n       }\n   ifIndex OBJECT-TYPE\n\
    \       SYNTAX      InterfaceIndex\n       MAX-ACCESS  read-only\n       STATUS\
    \      current\n       DESCRIPTION\n               \"A unique value, greater than\
    \ zero, for each\n               interface.  It is recommended that values are\
    \ assigned\n               contiguously starting from 1.  The value for each\n\
    \               interface sub-layer must remain constant at least from\n     \
    \          one re-initialization of the entity's network\n               management\
    \ system to the next re-initialization.\"\n       ::= { ifEntry 1 }\n   ifDescr\
    \ OBJECT-TYPE\n       SYNTAX      DisplayString (SIZE (0..255))\n       MAX-ACCESS\
    \  read-only\n       STATUS      current\n       DESCRIPTION\n               \"\
    A textual string containing information about the\n               interface. \
    \ This string should include the name of the\n               manufacturer, the\
    \ product name and the version of the\n               interface hardware/software.\"\
    \n       ::= { ifEntry 2 }\n   ifType OBJECT-TYPE\n       SYNTAX      IANAifType\n\
    \       MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The type of interface.  Additional values for ifType\n     \
    \          are assigned by the Internet Assigned Numbers\n               Authority\
    \ (IANA), through updating the syntax of the\n               IANAifType textual\
    \ convention.\"\n       ::= { ifEntry 3 }\n   ifMtu OBJECT-TYPE\n       SYNTAX\
    \      Integer32\n       MAX-ACCESS  read-only\n       STATUS      current\n \
    \      DESCRIPTION\n               \"The size of the largest packet which can\
    \ be\n               sent/received on the interface, specified in octets.\n  \
    \             For interfaces that are used for transmitting network\n        \
    \       datagrams, this is the size of the largest network\n               datagram\
    \ that can be sent on the interface.\"\n       ::= { ifEntry 4 }\n   ifSpeed OBJECT-TYPE\n\
    \       SYNTAX      Gauge32\n       MAX-ACCESS  read-only\n       STATUS     \
    \ current\n       DESCRIPTION\n               \"An estimate of the interface's\
    \ current bandwidth in\n               bits per second.  For interfaces which\
    \ do not vary in\n               bandwidth or for those where no accurate estimation\n\
    \               can be made, this object should contain the nominal\n        \
    \       bandwidth.  If the bandwidth of the interface is\n               greater\
    \ than the maximum value reportable by this\n               object then this object\
    \ should report its maximum\n               value (4,294,967,295) and ifHighSpeed\
    \ must be used to\n               report the interace's speed.  For a sub-layer\
    \ which\n               has no concept of bandwidth, this object should be\n \
    \              zero.\"\n       ::= { ifEntry 5 }\n   ifPhysAddress OBJECT-TYPE\n\
    \       SYNTAX      PhysAddress\n       MAX-ACCESS  read-only\n       STATUS \
    \     current\n       DESCRIPTION\n               \"The interface's address at\
    \ its protocol sub-layer.\n               The interface's media-specific MIB must\
    \ define the bit\n               and byte ordering and format of the value contained\
    \ by\n               this object.  For interfaces which do not have such an\n\
    \               address (e.g., a serial line), this object should\n          \
    \     contain an octet string of zero length.\"\n       ::= { ifEntry 6 }\n  \
    \ ifAdminStatus OBJECT-TYPE\n       SYNTAX  INTEGER {\n                   up(1),\
    \       -- ready to pass packets\n                   down(2),\n              \
    \     testing(3)   -- in some test mode\n               }\n       MAX-ACCESS \
    \ read-write\n       STATUS      current\n       DESCRIPTION\n               \"\
    The desired state of the interface.  The testing(3)\n               state indicates\
    \ that no operational packets can be\n               passed.  When a managed system\
    \ initializes, all\n               interfaces start with ifAdminStatus in the\
    \ down(2)\n               state.  As a result of either explicit management\n\
    \               action or per configuration information retained by\n        \
    \       the managed system, ifAdminStatus is then changed to\n               either\
    \ the up(1) or testing(3) states (or remains in\n               the down(2) state).\"\
    \n       ::= { ifEntry 7 }\n   ifOperStatus OBJECT-TYPE\n       SYNTAX  INTEGER\
    \ {\n                   up(1),       -- ready to pass packets\n              \
    \     down(2),\n                   testing(3),  -- in some test mode\n       \
    \            unknown(4),  -- status can not be determined\n                  \
    \              -- for some reason.\n                   dormant(5)\n          \
    \     }\n       MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The current operational state of the interface.  The\n     \
    \          testing(3) state indicates that no operational packets\n          \
    \     can be passed.  If ifAdminStatus is down(2) then\n               ifOperStatus\
    \ should be down(2).  If ifAdminStatus is\n               changed to up(1) then\
    \ ifOperStatus should change to\n               up(1) if the interface is ready\
    \ to transmit and\n               receive network traffic; it should change to\n\
    \               dormant(5) if the interface is waiting for external\n        \
    \       actions (such as a serial line waiting for an\n               incomming\
    \ connection); it should remain in the down(2)\n               state if and only\
    \ if there is a fault that prevents if\n               from going to the up(1)\
    \ state.\"\n       ::= { ifEntry 8 }\n   ifLastChange OBJECT-TYPE\n       SYNTAX\
    \      TimeTicks\n       MAX-ACCESS  read-only\n       STATUS      current\n \
    \      DESCRIPTION\n               \"The value of sysUpTime at the time the interface\n\
    \               entered its current operational state.  If the current\n     \
    \          state was entered prior to the last re-initialization\n           \
    \    of the local network management subsystem, then this\n               object\
    \ contains a zero value.\"\n       ::= { ifEntry 9 }\n   ifInOctets OBJECT-TYPE\n\
    \       SYNTAX      Counter32\n       MAX-ACCESS  read-only\n       STATUS   \
    \   current\n       DESCRIPTION\n               \"The total number of octets received\
    \ on the interface,\n               including framing characters.\"\n       ::=\
    \ { ifEntry 10 }\n   ifInUcastPkts OBJECT-TYPE\n       SYNTAX      Counter32\n\
    \       MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The number of packets, delivered by this sub-layer to\n    \
    \           a higher (sub-)layer, which were not addressed to a\n            \
    \   multicast or broadcast address at this sub-layer.\"\n       ::= { ifEntry\
    \ 11 }\n   ifInNUcastPkts OBJECT-TYPE\n       SYNTAX  Counter32\n       MAX-ACCESS\
    \  read-only\n       STATUS      deprecated\n       DESCRIPTION\n            \
    \   \"The number of packets, delivered by this sub-layer to\n               a\
    \ higher (sub-)layer, which were addressed to a\n               multicast or broadcast\
    \ address at this sub-layer.\n               This object is deprecated in favour\
    \ of\n               ifInMulticastPkts and ifInBroadcastPkts.\"\n       ::= {\
    \ ifEntry 12 }\n   ifInDiscards OBJECT-TYPE\n       SYNTAX      Counter32\n  \
    \     MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The number of inbound packets which were chosen to be\n    \
    \           discarded even though no errors had been detected to\n           \
    \    prevent their being deliverable to a higher-layer\n               protocol.\
    \  One possible reason for discarding such a\n               packet could be to\
    \ free up buffer space.\"\n       ::= { ifEntry 13 }\n   ifInErrors OBJECT-TYPE\n\
    \       SYNTAX      Counter32\n       MAX-ACCESS  read-only\n       STATUS   \
    \   current\n       DESCRIPTION\n               \"For packet-oriented interfaces,\
    \ the number of inbound\n               packets that contained errors preventing\
    \ them from\n               being deliverable to a higher-layer protocol.  For\n\
    \               character-oriented or fixed-length interfaces, the\n         \
    \      number of inbound transmission units that contained\n               errors\
    \ preventing them from being deliverable to a\n               higher-layer protocol.\"\
    \n       ::= { ifEntry 14 }\n   ifInUnknownProtos OBJECT-TYPE\n       SYNTAX \
    \     Counter32\n       MAX-ACCESS  read-only\n       STATUS      current\n  \
    \     DESCRIPTION\n               \"For packet-oriented interfaces, the number\
    \ of packets\n               received via the interface which were discarded\n\
    \               because of an unknown or unsupported protocol.  For\n        \
    \       character-oriented or fixed-length interfaces which\n               support\
    \ protocol multiplexing the number of\n               transmission units received\
    \ via the interface which\n               were discarded because of an unknown\
    \ or unsupported\n               protocol.  For any interface which does not support\n\
    \               protocol multiplexing, this counter will always be 0.\"\n    \
    \   ::= { ifEntry 15 }\n   ifOutOctets OBJECT-TYPE\n       SYNTAX      Counter32\n\
    \       MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The total number of octets transmitted out of the\n        \
    \       interface, including framing characters.\"\n       ::= { ifEntry 16 }\n\
    \   ifOutUcastPkts OBJECT-TYPE\n       SYNTAX      Counter32\n       MAX-ACCESS\
    \  read-only\n       STATUS      current\n       DESCRIPTION\n               \"\
    The total number of packets that higher-level\n               protocols requested\
    \ be transmitted, and which were not\n               addressed to a multicast\
    \ or broadcast address at this\n               sub-layer, including those that\
    \ were discarded or not\n               sent.\"\n       ::= { ifEntry 17 }\n \
    \  ifOutNUcastPkts OBJECT-TYPE\n       SYNTAX      Counter32\n       MAX-ACCESS\
    \  read-only\n       STATUS      deprecated\n       DESCRIPTION\n            \
    \   \"The total number of packets that higher-level\n               protocols\
    \ requested be transmitted, and which were\n               addressed to a multicast\
    \ or broadcast address at this\n               sub-layer, including those that\
    \ were discarded or not\n               sent.\n               This object is deprecated\
    \ in favour of\n               ifOutMulticastPkts and ifOutBroadcastPkts.\"\n\
    \       ::= { ifEntry 18 }\n   ifOutDiscards OBJECT-TYPE\n       SYNTAX      Counter32\n\
    \       MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The number of outbound packets which were chosen to\n      \
    \         be discarded even though no errors had been detected\n             \
    \  to prevent their being transmitted.  One possible\n               reason for\
    \ discarding such a packet could be to free\n               up buffer space.\"\
    \n       ::= { ifEntry 19 }\n   ifOutErrors OBJECT-TYPE\n       SYNTAX      Counter32\n\
    \       MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"For packet-oriented interfaces, the number of\n            \
    \   outbound packets that could not be transmitted because\n               of\
    \ errors.  For character-oriented or fixed-length\n               interfaces,\
    \ the number of outbound transmission units\n               that could not be\
    \ transmitted because of errors.\"\n       ::= { ifEntry 20 }\n   ifOutQLen OBJECT-TYPE\n\
    \       SYNTAX      Gauge32\n       MAX-ACCESS  read-only\n       STATUS     \
    \ deprecated\n       DESCRIPTION\n               \"The length of the output packet\
    \ queue (in packets).\"\n       ::= { ifEntry 21 }\n   ifSpecific OBJECT-TYPE\n\
    \       SYNTAX      OBJECT IDENTIFIER\n       MAX-ACCESS  read-only\n       STATUS\
    \      deprecated\n       DESCRIPTION\n               \"A reference to MIB definitions\
    \ specific to the\n               particular media being used to realize the interface.\n\
    \               It is recommended that this value point to an instance\n     \
    \          of a MIB object in the media-specific MIB, i.e., that\n           \
    \    this object have the semantics associated with the\n               InstancePointer\
    \ textual convention defined in RFC\n               1443.  In fact, it is recommended\
    \ that the media-\n               specific MIB specify what value ifSpecific should/can\n\
    \               take for values of ifType.  If no MIB definitions\n          \
    \     specific to the particular media are available, the\n               value\
    \ should be set to the OBJECT IDENTIFIER { 0 0 }.\"\n       ::= { ifEntry 22 }\n\
    \   --\n   --   Extension to the interface table\n   --\n   -- This table replaces\
    \ the ifExtnsTable table.\n   --\n   ifXTable        OBJECT-TYPE\n       SYNTAX\
    \      SEQUENCE OF IfXEntry\n       MAX-ACCESS  not-accessible\n       STATUS\
    \      current\n       DESCRIPTION\n               \"A list of interface entries.\
    \  The number of entries\n               is given by the value of ifNumber.  This\
    \ table\n               contains additional objects for the interface table.\"\
    \n       ::= { ifMIBObjects 1 }\n   ifXEntry        OBJECT-TYPE\n       SYNTAX\
    \      IfXEntry\n       MAX-ACCESS  not-accessible\n       STATUS      current\n\
    \       DESCRIPTION\n               \"An entry containing additional management\
    \ information\n               applicable to a particular interface.\"\n      \
    \ AUGMENTS    { ifEntry }\n       ::= { ifXTable 1 }\n   IfXEntry ::=\n      \
    \ SEQUENCE {\n           ifName                  DisplayString,\n           ifInMulticastPkts\
    \       Counter32,\n           ifInBroadcastPkts       Counter32,\n          \
    \ ifOutMulticastPkts      Counter32,\n           ifOutBroadcastPkts      Counter32,\n\
    \           ifHCInOctets            Counter64,\n           ifHCInUcastPkts   \
    \      Counter64,\n           ifHCInMulticastPkts     Counter64,\n           ifHCInBroadcastPkts\
    \     Counter64,\n           ifHCOutOctets           Counter64,\n           ifHCOutUcastPkts\
    \        Counter64,\n           ifHCOutMulticastPkts    Counter64,\n         \
    \  ifHCOutBroadcastPkts    Counter64,\n           ifLinkUpDownTrapEnable  INTEGER,\n\
    \           ifHighSpeed             Gauge32,\n           ifPromiscuousMode   \
    \    TruthValue,\n           ifConnectorPresent      TruthValue\n       }\n  \
    \ ifName OBJECT-TYPE\n       SYNTAX      DisplayString\n       MAX-ACCESS  read-only\n\
    \       STATUS      current\n       DESCRIPTION\n               \"The textual\
    \ name of the interface.  The value of this\n               object should be the\
    \ name of the interface as assigned\n               by the local device and should\
    \ be suitable for use in\n               commands entered at the device's `console'.\
    \  This\n               might be a text name, such as `le0' or a simple port\n\
    \               number, such as `1', depending on the interface naming\n     \
    \          syntax of the device.  If several entries in the\n               ifTable\
    \ together represent a single interface as named\n               by the device,\
    \ then each will have the same value of\n               ifName.  If there is no\
    \ local name, or this object is\n               otherwise not applicable, then\
    \ this object contains a\n               0-length string.\"\n       ::= { ifXEntry\
    \ 1 }\n   ifInMulticastPkts OBJECT-TYPE\n       SYNTAX      Counter32\n      \
    \ MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n    \
    \           \"The number of packets, delivered by this sub-layer to\n        \
    \       a higher (sub-)layer, which were addressed to a\n               multicast\
    \ address at this sub-layer.  For a MAC layer\n               protocol, this includes\
    \ both Group and Functional\n               addresses.\"\n       ::= { ifXEntry\
    \ 2 }\n   ifInBroadcastPkts OBJECT-TYPE\n       SYNTAX      Counter32\n      \
    \ MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n    \
    \           \"The number of packets, delivered by this sub-layer to\n        \
    \       a higher (sub-)layer, which were addressed to a\n               broadcast\
    \ address at this sub-layer.\"\n       ::= { ifXEntry 3 }\n   ifOutMulticastPkts\
    \ OBJECT-TYPE\n       SYNTAX      Counter32\n       MAX-ACCESS  read-only\n  \
    \     STATUS      current\n       DESCRIPTION\n               \"The total number\
    \ of packets that higher-level\n               protocols requested be transmitted,\
    \ and which were\n               addressed to a multicast address at this sub-layer,\n\
    \               including those that were discarded or not sent.  For\n      \
    \         a MAC layer protocol, this includes both Group and\n               Functional\
    \ addresses.\"\n       ::= { ifXEntry 4 }\n   ifOutBroadcastPkts OBJECT-TYPE\n\
    \       SYNTAX      Counter32\n       MAX-ACCESS  read-only\n       STATUS   \
    \   current\n       DESCRIPTION\n               \"The total number of packets\
    \ that higher-level\n               protocols requested be transmitted, and which\
    \ were\n               addressed to a broadcast address at this sub-layer,\n \
    \              including those that were discarded or not sent.\"\n       ::=\
    \ { ifXEntry 5 }\n   --\n   -- High Capacity Counter objects.  These objects are\
    \ all\n   -- 64 bit versions of the \"basic\" ifTable counters.  These\n   --\
    \ objects all have the same basic semantics as their 32-bit\n   -- counterparts,\
    \ however, their syntax has been extended\n   -- to 64 bits.\n   --\n   ifHCInOctets\
    \ OBJECT-TYPE\n       SYNTAX      Counter64\n       MAX-ACCESS  read-only\n  \
    \     STATUS      current\n       DESCRIPTION\n               \"The total number\
    \ of octets received on the interface,\n               including framing characters.\
    \  This object is a 64-bit\n               version of ifInOctets.\"\n       ::=\
    \ { ifXEntry 6 }\n   ifHCInUcastPkts OBJECT-TYPE\n       SYNTAX      Counter64\n\
    \       MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The number of packets, delivered by this sub-layer to\n    \
    \           a higher (sub-)layer, which were not addressed to a\n            \
    \   multicast or broadcast address at this sub-layer.\n               This object\
    \ is a 64-bit version of ifInUcastPkts.\"\n       ::= { ifXEntry 7 }\n   ifHCInMulticastPkts\
    \ OBJECT-TYPE\n       SYNTAX      Counter64\n       MAX-ACCESS  read-only\n  \
    \     STATUS      current\n       DESCRIPTION\n               \"The number of\
    \ packets, delivered by this sub-layer to\n               a higher (sub-)layer,\
    \ which were addressed to a\n               multicast address at this sub-layer.\
    \  For a MAC layer\n               protocol, this includes both Group and Functional\n\
    \               addresses.  This object is a 64-bit version of\n             \
    \  ifInMulticastPkts.\"\n       ::= { ifXEntry 8 }\n   ifHCInBroadcastPkts OBJECT-TYPE\n\
    \       SYNTAX      Counter64\n       MAX-ACCESS  read-only\n       STATUS   \
    \   current\n       DESCRIPTION\n               \"The number of packets, delivered\
    \ by this sub-layer to\n               a higher (sub-)layer, which were addressed\
    \ to a\n               broadcast address at this sub-layer.  This object is a\n\
    \               64-bit version of ifInBroadcastPkts.\"\n       ::= { ifXEntry\
    \ 9 }\n   ifHCOutOctets OBJECT-TYPE\n       SYNTAX      Counter64\n       MAX-ACCESS\
    \  read-only\n       STATUS      current\n       DESCRIPTION\n               \"\
    The total number of octets transmitted out of the\n               interface, including\
    \ framing characters.  This object\n               is a 64-bit version of ifOutOctets.\"\
    \n       ::= { ifXEntry 10 }\n   ifHCOutUcastPkts OBJECT-TYPE\n       SYNTAX \
    \     Counter64\n       MAX-ACCESS  read-only\n       STATUS      current\n  \
    \     DESCRIPTION\n               \"The total number of packets that higher-level\n\
    \               protocols requested be transmitted, and which were not\n     \
    \          addressed to a multicast or broadcast address at this\n           \
    \    sub-layer, including those that were discarded or not\n               sent.\
    \  This object is a 64-bit version of\n               ifOutUcastPkts.\"\n    \
    \   ::= { ifXEntry 11 }\n   ifHCOutMulticastPkts OBJECT-TYPE\n       SYNTAX  \
    \    Counter64\n       MAX-ACCESS  read-only\n       STATUS      current\n   \
    \    DESCRIPTION\n               \"The total number of packets that higher-level\n\
    \               protocols requested be transmitted, and which were\n         \
    \      addressed to a multicast address at this sub-layer,\n               including\
    \ those that were discarded or not sent.  For\n               a MAC layer protocol,\
    \ this includes both Group and\n               Functional addresses.  This object\
    \ is a 64-bit version\n               of ifOutMulticastPkts.\"\n       ::= { ifXEntry\
    \ 12 }\n   ifHCOutBroadcastPkts OBJECT-TYPE\n       SYNTAX      Counter64\n  \
    \     MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The total number of packets that higher-level\n            \
    \   protocols requested be transmitted, and which were\n               addressed\
    \ to a broadcast address at this sub-layer,\n               including those that\
    \ were discarded or not sent.  This\n               object is a 64-bit version\
    \ of ifOutBroadcastPkts.\"\n       ::= { ifXEntry 13 }\n   ifLinkUpDownTrapEnable\
    \  OBJECT-TYPE\n       SYNTAX      INTEGER { enabled(1), disabled(2) }\n     \
    \  MAX-ACCESS  read-write\n       STATUS      current\n       DESCRIPTION\n  \
    \             \"Indicates whether linkUp/linkDown traps should be\n          \
    \     generated for this interface.\n               By default, this object should\
    \ have the value\n               enabled(1) for interfaces which do not operate\
    \ on\n               'top' of any other interface (as defined in the\n       \
    \        ifStackTable), and disabled(2) otherwise.\"\n       ::= { ifXEntry 14\
    \ }\n   ifHighSpeed OBJECT-TYPE\n       SYNTAX      Gauge32\n       MAX-ACCESS\
    \  read-only\n       STATUS      current\n       DESCRIPTION\n               \"\
    An estimate of the interface's current bandwidth in\n               units of 1,000,000\
    \ bits per second.  If this object\n               reports a value of `n' then\
    \ the speed of the interface\n               is somewhere in the range of `n-500,000'\
    \ to\n               `n+499,999'.  For interfaces which do not vary in\n     \
    \          bandwidth or for those where no accurate estimation\n             \
    \  can be made, this object should contain the nominal\n               bandwidth.\
    \  For a sub-layer which has no concept of\n               bandwidth, this object\
    \ should be zero.\"\n       ::= { ifXEntry 15 }\n   ifPromiscuousMode  OBJECT-TYPE\n\
    \       SYNTAX      TruthValue\n       MAX-ACCESS  read-write\n       STATUS \
    \     current\n       DESCRIPTION\n               \"This object has a value of\
    \ false(2) if this interface\n               only accepts packets/frames that\
    \ are addressed to this\n               station.  This object has a value of true(1)\
    \ when the\n               station accepts all packets/frames transmitted on the\n\
    \               media.  The value true(1) is only legal on certain\n         \
    \      types of media.  If legal, setting this object to a\n               value\
    \ of true(1) may require the interface to be reset\n               before becoming\
    \ effective.\n               The value of ifPromiscuousMode does not affect the\n\
    \               reception of broadcast and multicast packets/frames by\n     \
    \          the interface.\"\n       ::= { ifXEntry 16 }\n   ifConnectorPresent\
    \   OBJECT-TYPE\n       SYNTAX      TruthValue\n       MAX-ACCESS  read-only\n\
    \       STATUS      current\n       DESCRIPTION\n               \"This object\
    \ has the value 'true(1)' if the interface\n               sublayer has a physical\
    \ connector and the value\n               'false(2)' otherwise.\"\n       ::=\
    \ { ifXEntry 17 }\n   --           The Interface Stack Group\n   --\n   -- Implementation\
    \ of this group is mandatory for all systems\n   --\n   ifStackTable  OBJECT-TYPE\n\
    \        SYNTAX        SEQUENCE OF IfStackEntry\n        MAX-ACCESS    not-accessible\n\
    \        STATUS        current\n        DESCRIPTION\n               \"The table\
    \ containing information on the relationships\n               between the multiple\
    \ sub-layers of network interfaces.\n               In particular, it contains\
    \ information on which sub-\n               layers run 'on top of' which other\
    \ sub-layers.  Each\n               sub-layer corresponds to a conceptual row\
    \ in the\n               ifTable.\"\n        ::= { ifMIBObjects 2 }\n   ifStackEntry\
    \  OBJECT-TYPE\n        SYNTAX        IfStackEntry\n        MAX-ACCESS    not-accessible\n\
    \        STATUS        current\n        DESCRIPTION\n               \"Information\
    \ on a particular relationship between two\n               sub-layers, specifying\
    \ that one sub-layer runs on\n               'top' of the other sub-layer.  Each\
    \ sub-layer\n               corresponds to a conceptual row in the ifTable.\"\n\
    \        INDEX { ifStackHigherLayer, ifStackLowerLayer }\n        ::= { ifStackTable\
    \ 1 }\n   IfStackEntry ::=\n       SEQUENCE {\n           ifStackHigherLayer \
    \ Integer32,\n           ifStackLowerLayer   Integer32,\n           ifStackStatus\
    \       RowStatus\n        }\n   ifStackHigherLayer  OBJECT-TYPE\n        SYNTAX\
    \        Integer32\n        MAX-ACCESS    not-accessible\n        STATUS     \
    \   current\n        DESCRIPTION\n               \"The value of ifIndex corresponding\
    \ to the higher\n               sub-layer of the relationship, i.e., the sub-layer\n\
    \               which runs on 'top' of the sub-layer identified by the\n     \
    \          corresponding instance of ifStackLowerLayer.  If there\n          \
    \     is no higher sub-layer (below the internetwork layer),\n               then\
    \ this object has the value 0.\"\n        ::= { ifStackEntry 1 }\n   ifStackLowerLayer\
    \  OBJECT-TYPE\n        SYNTAX        Integer32\n        MAX-ACCESS    not-accessible\n\
    \        STATUS        current\n        DESCRIPTION\n               \"The value\
    \ of ifIndex corresponding to the lower sub-\n               layer of the relationship,\
    \ i.e., the sub-layer which\n               runs 'below' the sub-layer identified\
    \ by the\n               corresponding instance of ifStackHigherLayer.  If\n \
    \              there is no lower sub-layer, then this object has the\n       \
    \        value 0.\"\n        ::= { ifStackEntry 2 }\n   ifStackStatus  OBJECT-TYPE\n\
    \       SYNTAX         RowStatus\n       MAX-ACCESS     read-write\n       STATUS\
    \         current\n       DESCRIPTION\n               \"The status of the relationship\
    \ between two sub-\n               layers.\n               Changing the value\
    \ of this object from 'active' to\n               'notInService' or 'destroy'\
    \ will likely have\n               consequences up and down the interface stack.\
    \  Thus,\n               write access to this object is likely to be\n       \
    \        inappropriate for some types of interfaces, and many\n              \
    \ implementations will choose not to support write-\n               access for\
    \ any type of interface.\"\n       ::= { ifStackEntry 3 }\n   --\n   --    The\
    \ Interface Test Table\n   --\n   -- This group of objects is optional.  However,\
    \ a media-specific\n   -- MIB may make implementation of this group mandatory.\n\
    \   --\n   -- This table replaces the ifExtnsTestTable\n   --\n   ifTestTable\
    \   OBJECT-TYPE\n       SYNTAX      SEQUENCE OF IfTestEntry\n       MAX-ACCESS\
    \  not-accessible\n       STATUS      current\n       DESCRIPTION\n          \
    \     \"This table contains one entry per interface.  It\n               defines\
    \ objects which allow a network manager to\n               instruct an agent to\
    \ test an interface for various\n               faults.  Tests for an interface\
    \ are defined in the\n               media-specific MIB for that interface.  After\
    \ invoking\n               a test, the object ifTestResult can be read to\n  \
    \             determine the outcome.  If an agent can not perform\n          \
    \     the test, ifTestResult is set to so indicate.  The\n               object\
    \ ifTestCode can be used to provide further\n               test-specific or interface-specific\
    \ (or even\n               enterprise-specific) information concerning the\n \
    \              outcome of the test.  Only one test can be in progress\n      \
    \         on each interface at any one time.  If one test is in\n            \
    \   progress when another test is invoked, the second test\n               is\
    \ rejected.  Some agents may reject a test when a\n               prior test is\
    \ active on another interface.\n               Before starting a test, a manager-station\
    \ must first\n               obtain 'ownership' of the entry in the ifTestTable\
    \ for\n               the interface to be tested.  This is accomplished with\n\
    \               the ifTestId and ifTestStatus objects as follows:\n          \
    \  try_again:\n                get (ifTestId, ifTestStatus)\n                while\
    \ (ifTestStatus != notInUse)\n                    /*\n                     * Loop\
    \ while a test is running or some other\n                     * manager is configuring\
    \ a test.\n                     */\n                    short delay\n        \
    \            get (ifTestId, ifTestStatus)\n                }\n               \
    \ /*\n                 * Is not being used right now -- let's compete\n      \
    \           * to see who gets it.\n                 */\n                lock_value\
    \ = ifTestId\n                if ( set(ifTestId = lock_value, ifTestStatus = inUse,\n\
    \                         ifTestOwner = 'my-IP-address') == FAILURE)\n       \
    \             /*\n                     * Another manager got the ifTestEntry --\
    \ go\n                     * try again\n                     */\n            \
    \        goto try_again;\n                /*\n                 * I have the lock\n\
    \                 */\n                set up any test parameters.\n          \
    \      /*\n                 * This starts the test\n                 */\n    \
    \            set(ifTestType = test_to_run);\n                wait for test completion\
    \ by polling ifTestResult\n                when test completes, agent sets ifTestResult\n\
    \                     agent also sets ifTestStatus = 'notInUse'\n            \
    \    retrieve any additional test results, and ifTestId\n                if (ifTestId\
    \ == lock_value+1) results are valid\n              A manager station first retrieves\
    \ the value of the\n              appropriate ifTestId and ifTestStatus objects,\n\
    \              periodically repeating the retrieval if necessary,\n          \
    \    until the value of ifTestStatus is 'notInUse'.  The\n              manager\
    \ station then tries to set the same ifTestId\n              object to the value\
    \ it just retrieved, the same\n              ifTestStatus object to 'inUse', and\
    \ the corresponding\n              ifTestOwner object to a value indicating itself.\
    \  If\n              the set operation succeeds then the manager has\n       \
    \       obtained ownership of the ifTestEntry, and the value of\n            \
    \  the ifTestId object is incremented by the agent (per\n              the semantics\
    \ of TestAndIncr).  Failure of the set\n              operation indicates that\
    \ some other manager has\n              obtained ownership of the ifTestEntry.\n\
    \              Once ownership is obtained, any test parameters can be\n      \
    \        setup, and then the test is initiated by setting\n              ifTestType.\
    \  On completion of the test, the agent sets\n              ifTestStatus to 'notInUse'.\
    \  Once this occurs, the\n              manager can retrieve the results.  In\
    \ the (rare) event\n              that the invocation of tests by two network\
    \ managers\n              were to overlap, then there would be a possibility that\n\
    \              the first test's results might be overwritten by the\n        \
    \      second test's results prior to the first results being\n              read.\
    \  This unlikely circumstance can be detected by a\n              network manager\
    \ retrieving ifTestId at the same time as\n              retrieving the test results,\
    \ and ensuring that the\n              results are for the desired request.\n\
    \              If ifTestType is not set within an abnormally long\n          \
    \    period of time after ownership is obtained, the agent\n              should\
    \ time-out the manager, and reset the value of the\n              ifTestStatus\
    \ object back to 'notInUse'.  It is\n              suggested that this time-out\
    \ period be 5 minutes.\n              In general, a management station must not\
    \ retransmit a\n              request to invoke a test for which it does not receive\n\
    \              a response; instead, it properly inspects an agent's\n        \
    \      MIB to determine if the invocation was successful.\n              Only\
    \ if the invocation was unsuccessful, is the\n              invocation request\
    \ retransmitted.\n              Some tests may require the interface to be taken\
    \ off-\n              line in order to execute them, or may even require the\n\
    \              agent to reboot after completion of the test.  In these\n     \
    \         circumstances, communication with the management\n              station\
    \ invoking the test may be lost until after\n              completion of the test.\
    \  An agent is not required to\n              support such tests.  However, if\
    \ such tests are\n              supported, then the agent should make every effort\
    \ to\n              transmit a response to the request which invoked the\n   \
    \           test prior to losing communication.  When the agent is\n         \
    \     restored to normal service, the results of the test are\n              properly\
    \ made available in the appropriate objects.\n              Note that this requires\
    \ that the ifIndex value assigned\n              to an interface must be unchanged\
    \ even if the test\n              causes a reboot.  An agent must reject any test\
    \ for\n              which it cannot, perhaps due to resource constraints,\n \
    \             make available at least the minimum amount of\n              information\
    \ after that test completes.\"\n       ::= { ifMIBObjects 3 }\n   ifTestEntry\
    \ OBJECT-TYPE\n       SYNTAX       IfTestEntry\n       MAX-ACCESS   not-accessible\n\
    \       STATUS       current\n       DESCRIPTION\n               \"An entry containing\
    \ objects for invoking tests on an\n               interface.\"\n       AUGMENTS\
    \  { ifEntry }\n       ::= { ifTestTable 1 }\n   IfTestEntry ::=\n       SEQUENCE\
    \ {\n           ifTestId           TestAndIncr,\n           ifTestStatus     \
    \  INTEGER,\n           ifTestType         AutonomousType,\n           ifTestResult\
    \       INTEGER,\n           ifTestCode         OBJECT IDENTIFIER,\n         \
    \  ifTestOwner        OwnerString\n       }\n   ifTestId         OBJECT-TYPE\n\
    \       SYNTAX       TestAndIncr\n       MAX-ACCESS   read-write\n       STATUS\
    \       current\n       DESCRIPTION\n               \"This object identifies the\
    \ current invocation of the\n               interface's test.\"\n       ::= {\
    \ ifTestEntry 1 }\n   ifTestStatus     OBJECT-TYPE\n       SYNTAX       INTEGER\
    \ { notInUse(1), inUse(2) }\n       MAX-ACCESS   read-write\n       STATUS   \
    \    current\n       DESCRIPTION\n               \"This object indicates whether\
    \ or not some manager\n               currently has the necessary 'ownership'\
    \ required to\n               invoke a test on this interface.  A write to this\n\
    \               object is only successful when it changes its value\n        \
    \       from 'notInUse(1)' to 'inUse(2)'.  After completion of\n             \
    \  a test, the agent resets the value back to\n               'notInUse(1)'.\"\
    \n       ::= { ifTestEntry 2 }\n   ifTestType       OBJECT-TYPE\n       SYNTAX\
    \       AutonomousType\n       MAX-ACCESS   read-write\n       STATUS       current\n\
    \       DESCRIPTION\n               \"A control variable used to start and stop\
    \ operator-\n               initiated interface tests.  Most OBJECT IDENTIFIER\n\
    \               values assigned to tests are defined elsewhere, in\n         \
    \      association with specific types of interface.\n               However,\
    \ this document assigns a value for a full-\n               duplex loopback test,\
    \ and defines the special meanings\n               of the subject identifier:\n\
    \                   noTest  OBJECT IDENTIFIER ::= { 0 0 }\n               When\
    \ the value noTest is written to this object, no\n               action is taken\
    \ unless a test is in progress, in which\n               case the test is aborted.\
    \  Writing any other value to\n               this object is only valid when no\
    \ test is currently in\n               progress, in which case the indicated test\
    \ is\n               initiated.\n               When read, this object always\
    \ returns the most recent\n               value that ifTestType was set to.  If\
    \ it has not been\n               set since the last initialization of the network\n\
    \               management subsystem on the agent, a value of noTest\n       \
    \        is returned.\"\n       ::= { ifTestEntry 3 }\n   ifTestResult  OBJECT-TYPE\n\
    \       SYNTAX       INTEGER {\n                        none(1),          -- no\
    \ test yet requested\n                        success(2),\n                  \
    \      inProgress(3),\n                        notSupported(4),\n            \
    \            unAbleToRun(5),   -- due to state of system\n                   \
    \     aborted(6),\n                        failed(7)\n                    }\n\
    \       MAX-ACCESS   read-only\n       STATUS       current\n       DESCRIPTION\n\
    \               \"This object contains the result of the most recently\n     \
    \          requested test, or the value none(1) if no tests have\n           \
    \    been requested since the last reset.  Note that this\n               facility\
    \ provides no provision for saving the results\n               of one test when\
    \ starting another, as could be\n               required if used by multiple managers\
    \ concurrently.\"\n       ::= { ifTestEntry 4 }\n   ifTestCode  OBJECT-TYPE\n\
    \       SYNTAX       OBJECT IDENTIFIER\n       MAX-ACCESS   read-only\n      \
    \ STATUS       current\n       DESCRIPTION\n               \"This object contains\
    \ a code which contains more\n               specific information on the test\
    \ result, for example\n               an error-code after a failed test.  Error\
    \ codes and\n               other values this object may take are specific to\
    \ the\n               type of interface and/or test.  The value may have the\n\
    \               semantics of either the AutonomousType or\n               InstancePointer\
    \ textual conventions as defined in RFC\n               1443.  The identifier:\n\
    \                   testCodeUnknown  OBJECT IDENTIFIER ::= { 0 0 }\n         \
    \      is defined for use if no additional result code is\n               available.\"\
    \n       ::= { ifTestEntry 5 }\n   ifTestOwner      OBJECT-TYPE\n       SYNTAX\
    \       OwnerString\n       MAX-ACCESS   read-write\n       STATUS       current\n\
    \       DESCRIPTION\n               \"The entity which currently has the 'ownership'\n\
    \               required to invoke a test on this interface.\"\n       ::= { ifTestEntry\
    \ 6 }\n   --   Generic Receive Address Table\n   --\n   -- This group of objects\
    \ is mandatory for all types of\n   -- interfaces which can receive packets/frames\
    \ addressed to\n   -- more than one address.\n   --\n   -- This table replaces\
    \ the ifExtnsRcvAddr table.  The main\n   -- difference is that this table makes\
    \ use of the RowStatus\n   -- textual convention, while ifExtnsRcvAddr did not.\n\
    \   ifRcvAddressTable  OBJECT-TYPE\n       SYNTAX      SEQUENCE OF IfRcvAddressEntry\n\
    \       MAX-ACCESS  not-accessible\n       STATUS      current\n       DESCRIPTION\n\
    \               \"This table contains an entry for each address\n            \
    \   (broadcast, multicast, or uni-cast) for which the\n               system will\
    \ receive packets/frames on a particular\n               interface, except as\
    \ follows:\n               - for an interface operating in promiscuous mode,\n\
    \               entries are only required for those addresses for\n          \
    \     which the system would receive frames were it not\n               operating\
    \ in promiscuous mode.\n               - for 802.5 functional addresses, only\
    \ one entry is\n               required, for the address which has the functional\n\
    \               address bit ANDed with the bit mask of all functional\n      \
    \         addresses for which the interface will accept frames.\"\n       ::=\
    \ { ifMIBObjects 4 }\n   ifRcvAddressEntry  OBJECT-TYPE\n       SYNTAX      IfRcvAddressEntry\n\
    \       MAX-ACCESS  not-accessible\n       STATUS      current\n       DESCRIPTION\n\
    \               \"A list of objects identifying an address for which\n       \
    \        the system will accept packets/frames on the\n               particular\
    \ interface identified by the index value\n               ifIndex.\"\n       INDEX\
    \  { ifIndex, ifRcvAddressAddress }\n       ::= { ifRcvAddressTable 1 }\n   IfRcvAddressEntry\
    \ ::=\n       SEQUENCE {\n           ifRcvAddressAddress   PhysAddress,\n    \
    \       ifRcvAddressStatus    RowStatus,\n           ifRcvAddressType      INTEGER\n\
    \       }\n   ifRcvAddressAddress OBJECT-TYPE\n       SYNTAX      PhysAddress\n\
    \       MAX-ACCESS  read-create\n       STATUS      current\n       DESCRIPTION\n\
    \               \"An address for which the system will accept\n              \
    \ packets/frames on this entry's interface.\"\n       ::= { ifRcvAddressEntry\
    \ 1 }\n   ifRcvAddressStatus OBJECT-TYPE\n       SYNTAX      RowStatus\n     \
    \  MAX-ACCESS  read-write\n       STATUS      current\n       DESCRIPTION\n  \
    \             \"This object is used to create and delete rows in the\n       \
    \        ifRcvAddressTable.\"\n       ::= { ifRcvAddressEntry 2 }\n   ifRcvAddressType\
    \ OBJECT-TYPE\n       SYNTAX      INTEGER {\n                       other(1),\n\
    \                       volatile(2),\n                       nonVolatile(3)\n\
    \                   }\n       MAX-ACCESS  read-create\n       STATUS      current\n\
    \       DESCRIPTION\n               \"This object has the value nonVolatile(3)\
    \ for those\n               entries in the table which are valid and will not\
    \ be\n               deleted by the next restart of the managed system.\n    \
    \           Entries having the value volatile(2) are valid and\n             \
    \  exist, but have not been saved, so that will not exist\n               after\
    \ the next restart of the managed system.  Entries\n               having the\
    \ value other(1) are valid and exist but are\n               not classified as\
    \ to whether they will continue to\n               exist after the next restart.\"\
    \n       DEFVAL  { volatile }\n       ::= { ifRcvAddressEntry 3 }\n   -- definition\
    \ of interface-related traps.\n   linkDown NOTIFICATION-TYPE\n       OBJECTS {\
    \ ifIndex, ifAdminStatus, ifOperStatus }\n       STATUS  current\n       DESCRIPTION\n\
    \               \"A linkDown trap signifies that the SNMPv2 entity,\n        \
    \       acting in an agent role, has detected that the\n               ifOperStatus\
    \ object for one of its communication links\n               is about to transition\
    \ into the down state.\"\n       ::= { snmpTraps 3 }\n   linkUp NOTIFICATION-TYPE\n\
    \       OBJECTS { ifIndex, ifAdminStatus, ifOperStatus }\n       STATUS  current\n\
    \       DESCRIPTION\n               \"A linkUp trap signifies that the SNMPv2\
    \ entity,\n               acting in an agent role, has detected that the\n   \
    \            ifOperStatus object for one of its communication links\n        \
    \       has transitioned out of the down state.\"\n       ::= { snmpTraps 4 }\n\
    \   -- conformance information\n   ifConformance OBJECT IDENTIFIER ::= { ifMIB\
    \ 2 }\n   ifGroups      OBJECT IDENTIFIER ::= { ifConformance 1 }\n   ifCompliances\
    \ OBJECT IDENTIFIER ::= { ifConformance 2 }\n   -- compliance statements\n   ifCompliance\
    \ MODULE-COMPLIANCE\n       STATUS  current\n       DESCRIPTION\n            \
    \   \"The compliance statement for SNMPv2 entities which\n               have\
    \ network interfaces.\"\n       MODULE  -- this module\n           MANDATORY-GROUPS\
    \ { ifGeneralGroup, ifStackGroup }\n           GROUP       ifFixedLengthGroup\n\
    \           DESCRIPTION\n               \"This group is mandatory for all network\
    \ interfaces\n               which are character-oriented or transmit data in\n\
    \               fixed-length transmission units.\"\n           GROUP       ifHCFixedLengthGroup\n\
    \           DESCRIPTION\n               \"This group is mandatory only for those\
    \ network\n               interfaces which are character-oriented or transmit\n\
    \               data in fixed-length transmission units, and for which\n     \
    \          the value of the corresponding instance of ifSpeed is\n           \
    \    greater than 20,000,000 bits/second.\"\n           GROUP       ifPacketGroup\n\
    \           DESCRIPTION\n               \"This group is mandatory for all network\
    \ interfaces\n               which are packet-oriented.\"\n           GROUP  \
    \     ifHCPacketGroup\n           DESCRIPTION\n               \"This group is\
    \ mandatory only for those network\n               interfaces which are packet-oriented\
    \ and for which the\n               value of the corresponding instance of ifSpeed\
    \ is\n               greater than 650,000,000 bits/second.\"\n           GROUP\
    \       ifTestGroup\n           DESCRIPTION\n               \"This group is optional.\
    \  Media-specific MIBs which\n               require interface tests are strongly\
    \ encouraged to use\n               this group for invoking tests and reporting\
    \ results.\n               A medium specific MIB which has mandatory tests may\n\
    \               make implementation of this group mandatory.\"\n           GROUP\
    \       ifRcvAddressGroup\n           DESCRIPTION\n               \"The applicability\
    \ of this group MUST be defined by\n               the media-specific MIBs.  Media-specific\
    \ MIBs must\n               define the exact meaning, use, and semantics of the\n\
    \               addresses in this group.\"\n           OBJECT      ifLinkUpDownTrapEnable\n\
    \           MIN-ACCESS  read-only\n           DESCRIPTION\n               \"Write\
    \ access is not required.\"\n           OBJECT      ifPromiscuousMode\n      \
    \     MIN-ACCESS  read-only\n           DESCRIPTION\n               \"Write access\
    \ is not required.\"\n           OBJECT      ifStackStatus\n           SYNTAX\
    \      INTEGER { active(1) } -- subset of RowStatus\n           MIN-ACCESS  read-only\n\
    \           DESCRIPTION\n               \"Write access is not required, and only\
    \ one of the six\n               enumerated values for the RowStatus textual convention\n\
    \               need be supported, specifically: active(1).\"\n           OBJECT\
    \       ifAdminStatus\n           SYNTAX       INTEGER { up(1), down(2) }\n  \
    \         MIN-ACCESS   read-only\n           DESCRIPTION\n               \"Write\
    \ access is not required, nor is support for the\n               value testing(3).\"\
    \n       ::= { ifCompliances 1 }\n   -- units of conformance\n   ifGeneralGroup\
    \    OBJECT-GROUP\n       OBJECTS { ifDescr, ifType, ifSpeed, ifPhysAddress,\n\
    \                 ifAdminStatus, ifOperStatus, ifLastChange,\n               \
    \  ifLinkUpDownTrapEnable, ifConnectorPresent,\n                 ifHighSpeed,\
    \ ifName }\n       STATUS  current\n       DESCRIPTION\n               \"A collection\
    \ of objects providing information\n               applicable to all network interfaces.\"\
    \n       ::= { ifGroups 1 }\n   -- the following five groups are mutually exclusive;\
    \ at most\n   -- one of these groups is implemented for any interface\n   ifFixedLengthGroup\
    \    OBJECT-GROUP\n       OBJECTS { ifInOctets, ifOutOctets, ifInUnknownProtos,\n\
    \                 ifInErrors, ifOutErrors }\n       STATUS  current\n       DESCRIPTION\n\
    \               \"A collection of objects providing information\n            \
    \   specific to non-high speed, character-oriented or\n               fixed-length-transmission\
    \ network interfaces.  (Non-\n               high speed interfaces transmit and\
    \ receive at speeds\n               less than or equal to 20,000,000 bits/second.)\"\
    \n       ::= { ifGroups 2 }\n   ifHCFixedLengthGroup    OBJECT-GROUP\n       OBJECTS\
    \ { ifHCInOctets, ifHCOutOctets,\n                 ifInOctets, ifOutOctets, ifInUnknownProtos,\n\
    \                 ifInErrors, ifOutErrors }\n       STATUS  current\n       DESCRIPTION\n\
    \               \"A collection of objects providing information\n            \
    \   specific to high speed (greater than 20,000,000\n               bits/second)\
    \ character-oriented or fixed-length-\n               transmission network interfaces.\"\
    \n       ::= { ifGroups 3 }\n   ifPacketGroup    OBJECT-GROUP\n       OBJECTS\
    \ { ifInOctets, ifOutOctets, ifInUnknownProtos,\n                 ifInErrors,\
    \ ifOutErrors,\n                 ifMtu, ifInUcastPkts, ifInMulticastPkts,\n  \
    \               ifInBroadcastPkts, ifInDiscards,\n                 ifOutUcastPkts,\
    \ ifOutMulticastPkts,\n                 ifOutBroadcastPkts, ifOutDiscards,\n \
    \                ifPromiscuousMode }\n       STATUS  current\n       DESCRIPTION\n\
    \               \"A collection of objects providing information\n            \
    \   specific to non-high speed, packet-oriented network\n               interfaces.\
    \  (Non-high speed interfaces transmit and\n               receive at speeds less\
    \ than or equal to 20,000,000\n               bits/second.)\"\n       ::= { ifGroups\
    \ 4 }\n   ifHCPacketGroup    OBJECT-GROUP\n       OBJECTS { ifHCInOctets, ifHCOutOctets,\n\
    \                 ifInOctets, ifOutOctets, ifInUnknownProtos,\n              \
    \   ifInErrors, ifOutErrors,\n                 ifMtu, ifInUcastPkts, ifInMulticastPkts,\n\
    \                 ifInBroadcastPkts, ifInDiscards,\n                 ifOutUcastPkts,\
    \ ifOutMulticastPkts,\n                 ifOutBroadcastPkts, ifOutDiscards,\n \
    \                ifPromiscuousMode }\n       STATUS  current\n       DESCRIPTION\n\
    \               \"A collection of objects providing information\n            \
    \   specific to high speed (greater than 20,000,000\n               bits/second\
    \ but less than or equal to 650,000,000\n               bits/second) packet-oriented\
    \ network interfaces.\"\n       ::= { ifGroups 5 }\n   ifVHCPacketGroup    OBJECT-GROUP\n\
    \       OBJECTS { ifHCInUcastPkts, ifHCInMulticastPkts,\n                 ifHCInBroadcastPkts,\
    \ ifHCOutUcastPkts,\n                 ifHCOutMulticastPkts, ifHCOutBroadcastPkts,\n\
    \                 ifHCInOctets, ifHCOutOctets,\n                 ifInOctets, ifOutOctets,\
    \ ifInUnknownProtos,\n                 ifInErrors, ifOutErrors,\n            \
    \     ifMtu, ifInUcastPkts, ifInMulticastPkts,\n                 ifInBroadcastPkts,\
    \ ifInDiscards,\n                 ifOutUcastPkts, ifOutMulticastPkts,\n      \
    \           ifOutBroadcastPkts, ifOutDiscards,\n                 ifPromiscuousMode\
    \ }\n       STATUS  current\n       DESCRIPTION\n               \"A collection\
    \ of objects providing information\n               specific to higher speed (greater\
    \ than 650,000,000\n               bits/second) packet-oriented network interfaces.\"\
    \n       ::= { ifGroups 6 }\n   ifRcvAddressGroup    OBJECT-GROUP\n       OBJECTS\
    \ { ifRcvAddressStatus, ifRcvAddressType }\n       STATUS  current\n       DESCRIPTION\n\
    \               \"A collection of objects providing information on the\n     \
    \          multiple addresses which an interface receives.\"\n       ::= { ifGroups\
    \ 7 }\n   ifTestGroup    OBJECT-GROUP\n       OBJECTS { ifTestId, ifTestStatus,\
    \ ifTestType,\n                 ifTestResult, ifTestCode, ifTestOwner }\n    \
    \   STATUS  current\n       DESCRIPTION\n               \"A collection of objects\
    \ providing the ability to\n               invoke tests on an interface.\"\n \
    \      ::= { ifGroups 8 }\n   ifStackGroup    OBJECT-GROUP\n       OBJECTS { ifStackStatus\
    \ }\n       STATUS  current\n       DESCRIPTION\n               \"A collection\
    \ of objects providing information on the\n               layering of MIB-II interfaces.\"\
    \n       ::= { ifGroups 9 }\n   END\n"
- title: 7.  Acknowledgements
  contents:
  - "7.  Acknowledgements\n   This memo has been produced by the IETF's Interfaces\
    \ MIB Working\n   Group.\n   The initial proposal to the working group was the\
    \ result of\n   conversations and discussions with many people, including at least\n\
    \   the following: Fred Baker, Ted Brunner, Chuck Davin, Jeremy Greene,\n   Marshall\
    \ Rose, Kaj Tesink, and Dean Throop.\n"
- title: 8.  References
  contents:
  - "8.  References\n   [1] Case, J., McCloghrie, K., Rose, M., and S. Waldbusser,\
    \ \"Structure\n       of Management Information for version 2 of the Simple Network\n\
    \       Management Protocol (SNMPv2)\", RFC 1442, SNMP Research, Inc.,\n     \
    \  Hughes LAN Systems, Dover Beach Consulting, Inc., Carnegie Mellon\n       University,\
    \ April 1993.\n   [2] Galvin, J., and K. McCloghrie, \"Administrative Model for\
    \ version\n       2 of the Simple Network Management Protocol (SNMPv2)\", RFC\
    \ 1445,\n       Trusted Information Systems, Hughes LAN Systems, April 1993.\n\
    \   [3] Case, J., McCloghrie, K., Rose, M., and S. Waldbusser, \"Protocol\n  \
    \     Operations for version 2 of the Simple Network Management\n       Protocol\
    \ (SNMPv2)\", RFC 1448, SNMP Research, Inc., Hughes LAN\n       Systems, Dover\
    \ Beach Consulting, Inc., Carnegie Mellon\n       University, April 1993.\n  \
    \ [4] McCloghrie, K., and M. Rose, \"Management Information Base for\n       Network\
    \ Management of TCP/IP-based internets - MIB-II\", STD 17,\n       RFC 1213, Hughes\
    \ LAN Systems, Performance Systems International,\n       March 1991.\n   [5]\
    \ Case, J., Fedor, M., Schoffstall, M., and J. Davin, \"Simple\n       Network\
    \ Management Protocol\", RFC 1157, SNMP Research,\n       Performance Systems\
    \ International, Performance Systems\n       International, MIT Laboratory for\
    \ Computer Science, May 1990.\n   [6] Postel, J., \"Internet Protocol\", STD 5,\
    \ RFC 791, USC/Information\n       Sciences Institute, September 1981.\n   [7]\
    \ McCloghrie, K., \"Extensions to the Generic-Interface MIB\", RFC\n       1229,\
    \ Hughes LAN Systems, May 1991.\n   [8] Case, J., McCloghrie, K., Rose, M., and\
    \ S. Waldbusser, \"Textual\n       Conventions for version 2 of the Simple Network\
    \ Management\n       Protocol (SNMPv2)\", RFC 1443, SNMP Research, Inc., Hughes\
    \ LAN\n       Systems, Dover Beach Consulting, Inc., Carnegie Mellon\n       University,\
    \ April 1993.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: 10.  Authors' Addresses
  contents:
  - "10.  Authors' Addresses\n   Keith McCloghrie\n   Hughes LAN Systems\n   1225\
    \ Charleston Rd,\n   Mountain View, Ca 94043\n   Phone: 415-966-7934\n   EMail:\
    \ kzm@hls.com\n   Frank Kastenholz\n   FTP Software\n   2 High Street\n   North\
    \ Andover, Mass. USA 01845\n   Phone: (508)685-4000\n   EMail: kasten@ftp.com\n"
