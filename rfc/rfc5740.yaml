- title: __initial_text__
  contents:
  - '       NACK-Oriented Reliable Multicast (NORM) Transport Protocol

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes the messages and procedures of the Negative-\n\
    \   ACKnowledgment (NACK) Oriented Reliable Multicast (NORM) protocol.\n   This\
    \ protocol can provide end-to-end reliable transport of bulk data\n   objects\
    \ or streams over generic IP multicast routing and forwarding\n   services.  NORM\
    \ uses a selective, negative acknowledgment mechanism\n   for transport reliability\
    \ and offers additional protocol mechanisms\n   to allow for operation with minimal\
    \ a priori coordination among\n   senders and receivers.  A congestion control\
    \ scheme is specified to\n   allow the NORM protocol to fairly share available\
    \ network bandwidth\n   with other transport protocols such as Transmission Control\
    \ Protocol\n   (TCP).  It is capable of operating with both reciprocal multicast\n\
    \   routing among senders and receivers and with asymmetric connectivity\n   (possibly\
    \ a unicast return path) between the senders and receivers.\n   The protocol offers\
    \ a number of features to allow different types of\n   applications or possibly\
    \ other higher-level transport protocols to\n   utilize its service in different\
    \ ways.  The protocol leverages the\n   use of FEC-based (forward error correction)\
    \ repair and other IETF\n   Reliable Multicast Transport (RMT) building blocks\
    \ in its design.\n   This document obsoletes RFC 3940.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the BSD License.\n   This document may\
    \ contain material from IETF Documents or IETF\n   Contributions published or\
    \ made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction and Applicability . . . . . . . . . .\
    \ . . . . . .  4\n     1.1.  Requirements Language  . . . . . . . . . . . . .\
    \ . . . . .  5\n     1.2.  NORM Data Delivery Service Model . . . . . . . . .\
    \ . . . .  5\n     1.3.  NORM Scalability . . . . . . . . . . . . . . . . . .\
    \ . . .  7\n     1.4.  Environmental Requirements and Considerations  . . . .\
    \ . .  8\n   2.  Architecture Definition  . . . . . . . . . . . . . . . . . .\
    \ .  8\n     2.1.  Protocol Operation Overview  . . . . . . . . . . . . . . .\
    \ 10\n     2.2.  Protocol Building Blocks . . . . . . . . . . . . . . . . . 12\n\
    \     2.3.  Design Trade-Offs  . . . . . . . . . . . . . . . . . . . . 12\n  \
    \ 3.  Conformance Statement  . . . . . . . . . . . . . . . . . . . . 13\n   4.\
    \  Message Formats  . . . . . . . . . . . . . . . . . . . . . . . 15\n     4.1.\
    \  NORM Common Message Header and Extensions  . . . . . . . . 15\n     4.2.  Sender\
    \ Messages  . . . . . . . . . . . . . . . . . . . . . 18\n       4.2.1.  NORM_DATA\
    \ Message  . . . . . . . . . . . . . . . . . . 18\n       4.2.2.  NORM_INFO Message\
    \  . . . . . . . . . . . . . . . . . . 28\n       4.2.3.  NORM_CMD Messages  .\
    \ . . . . . . . . . . . . . . . . . 29\n     4.3.  Receiver Messages  . . . .\
    \ . . . . . . . . . . . . . . . . 47\n       4.3.1.  NORM_NACK Message  . . .\
    \ . . . . . . . . . . . . . . . 47\n       4.3.2.  NORM_ACK Message . . . . .\
    \ . . . . . . . . . . . . . . 53\n     4.4.  General Purpose Messages . . . .\
    \ . . . . . . . . . . . . . 55\n       4.4.1.  NORM_REPORT Message  . . . . .\
    \ . . . . . . . . . . . . 55\n   5.  Detailed Protocol Operation  . . . . . .\
    \ . . . . . . . . . . . 55\n     5.1.  Sender Initialization and Transmission\
    \ . . . . . . . . . . 57\n       5.1.1.  Object Segmentation Algorithm  . . .\
    \ . . . . . . . . . 58\n     5.2.  Receiver Initialization and Reception  . .\
    \ . . . . . . . . 59\n     5.3.  Receiver NACK Procedure  . . . . . . . . . .\
    \ . . . . . . . 59\n     5.4.  Sender NACK Processing and Response  . . . . .\
    \ . . . . . . 62\n       5.4.1.  Sender Repair State Aggregation  . . . . . .\
    \ . . . . . 62\n       5.4.2.  Sender FEC Repair Transmission Strategy  . . .\
    \ . . . . 63\n       5.4.3.  Sender NORM_CMD(SQUELCH) Generation  . . . . . .\
    \ . . . 64\n       5.4.4.  Sender NORM_CMD(REPAIR_ADV) Generation . . . . . .\
    \ . . 65\n     5.5.  Additional Protocol Mechanisms . . . . . . . . . . . . .\
    \ . 65\n       5.5.1.  Group Round-Trip Time (GRTT) Collection  . . . . . . .\
    \ 65\n       5.5.2.  NORM Congestion Control Operation  . . . . . . . . . . 67\n\
    \       5.5.3.  NORM Positive Acknowledgment Procedure . . . . . . . . 75\n  \
    \     5.5.4.  Group Size Estimate  . . . . . . . . . . . . . . . . . 77\n   6.\
    \  Configurable Elements  . . . . . . . . . . . . . . . . . . . . 77\n   7.  Security\
    \ Considerations  . . . . . . . . . . . . . . . . . . . 80\n     7.1.  Baseline\
    \ Secure NORM Operation . . . . . . . . . . . . . . 82\n       7.1.1.  IPsec Approach\
    \ . . . . . . . . . . . . . . . . . . . . 83\n       7.1.2.  IPsec Requirements\
    \ . . . . . . . . . . . . . . . . . . 85\n   8.  IANA Considerations  . . . .\
    \ . . . . . . . . . . . . . . . . . 86\n     8.1.  Explicit IANA Assignment Guidelines\
    \  . . . . . . . . . . . 87\n       8.1.1.  NORM Header Extension Types  . . .\
    \ . . . . . . . . . . 87\n       8.1.2.  NORM Stream Control Codes  . . . . .\
    \ . . . . . . . . . 88\n       8.1.3.  NORM_CMD Message Sub-Types . . . . . .\
    \ . . . . . . . . 88\n   9.  Suggested Use  . . . . . . . . . . . . . . . . .\
    \ . . . . . . . 89\n   10. Changes from RFC 3940  . . . . . . . . . . . . . .\
    \ . . . . . . 90\n   11. Acknowledgments  . . . . . . . . . . . . . . . . . .\
    \ . . . . . 91\n   12. References . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . 91\n     12.1. Normative References . . . . . . . . . . . . . . . .\
    \ . . . 91\n     12.2. Informative References . . . . . . . . . . . . . . . .\
    \ . . 92\n"
- title: 1.  Introduction and Applicability
  contents:
  - "1.  Introduction and Applicability\n   The Negative-ACKnowledgment (NACK) Oriented\
    \ Reliable Multicast (NORM)\n   protocol can provide reliable transport of data\
    \ from one or more\n   senders to a group of receivers over an IP multicast network.\
    \  The\n   primary design goals of NORM are to provide efficient, scalable, and\n\
    \   robust bulk data (e.g., computer files, transmission of persistent\n   data)\
    \ transfer across possibly heterogeneous IP networks and\n   topologies.  The\
    \ NORM protocol design provides support for\n   distributed multicast session\
    \ participation with minimal coordination\n   among senders and receivers.  NORM\
    \ allows senders and receivers to\n   dynamically join and leave multicast sessions\
    \ at will with minimal\n   overhead for control information and timing synchronization\
    \ among\n   participants.  To accommodate this capability, NORM protocol message\n\
    \   headers contain some common information allowing receivers to easily\n   synchronize\
    \ to senders throughout the lifetime of a reliable\n   multicast session.  NORM\
    \ is self-adapting to a wide range of dynamic\n   network conditions with little\
    \ or no pre-configuration.  The protocol\n   is tolerant of inaccurate timing\
    \ estimations or lossy conditions that\n   can occur in many networks including\
    \ mobile and wireless.  The\n   protocol can also converge and maintain efficient\
    \ operation even in\n   situations of heavy packet loss and large queuing or transmission\n\
    \   delays.  This document obsoletes the Experimental RFC 3940\n   specification.\n\
    \   This document is a product of the IETF RMT working group and follows\n   the\
    \ guidelines provided in the Author Guidelines for Reliable\n   Multicast Transport\
    \ (RMT) Building Blocks and Protocol Instantiation\n   documents [RFC3269].\n\
    \   Statement of Intent\n   This memo contains the definitions necessary to fully\
    \ specify a\n   Reliable Multicast Transport protocol in accordance with the criteria\n\
    \   of IETF Criteria for Evaluating Reliable Multicast Transport and\n   Application\
    \ Protocols [RFC2357].  The NORM specification described in\n   this document\
    \ was previously published in the Experimental Category\n   [RFC3940].  It was\
    \ the stated intent of the RMT working group to re-\n   submit this specifications\
    \ as an IETF Proposed Standard in due\n   course.  This Proposed Standard specification\
    \ is thus based on RFC\n   3940 and has been updated according to accumulated\
    \ experience and\n   growing protocol maturity since the publication of RFC 3940.\
    \  Said\n   experience applies both to this specification itself and to\n   congestion\
    \ control strategies related to the use of this\n   specification.  The differences\
    \ between RFC 3940 and this document\n   are listed in Section 10.\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 1.2.  NORM Data Delivery Service Model
  contents:
  - "1.2.  NORM Data Delivery Service Model\n   A NORM protocol instance (NormSession)\
    \ is defined within the context\n   of participants communicating connectionless\
    \ (e.g., Internet Protocol\n   (IP) or User Datagram Protocol (UDP)) packets over\
    \ a network using\n   pre-determined addresses and host port numbers.  Generally,\
    \ the\n   participants exchange packets using an IP multicast group address,\n\
    \   but unicast transport MAY also be established or applied as an\n   adjunct\
    \ to multicast delivery.  In the case of multicast, the\n   participating NormNodes\
    \ will communicate using a common IP multicast\n   group address and port number\
    \ chosen via means outside the context of\n   the given NormSession.  Other existing\
    \ IETF data format and protocol\n   standards MAY be applied to describe and convey\
    \ the necessary a\n   priori information for a specific NormSession (e.g., Session\n\
    \   Description Protocol (SDP) [RFC4566], Session Announcement Protocol\n   (SAP)\
    \ [RFC2974], etc.).\n   The NORM protocol design is principally driven by the\
    \ assumption of a\n   single sender transmitting bulk data content to a group\
    \ of receivers.\n   However, the protocol MAY operate with multiple senders within\
    \ the\n   context of a single NormSession.  In initial implementations of this\n\
    \   protocol, it is anticipated that multiple senders will transmit\n   independently\
    \ of one another and receivers will maintain state as\n   necessary for each sender.\
    \  In future versions of NORM, it is\n   possible some aspects of protocol operation\
    \ (e.g., round-trip time\n   collection) will provide for alternate modes allowing\
    \ more efficient\n   performance for applications requiring multiple senders.\n\
    \   NORM provides for three types of bulk data content objects\n   (NormObjects)\
    \ to be reliably transported.  These types include:\n   1.  static computer memory\
    \ data content (NORM_OBJECT_DATA type),\n   2.  computer storage files (NORM_OBJECT_FILE\
    \ type), and\n   3.  non-finite streams of continuous data content (NORM_OBJECT_STREAM\n\
    \       type).\n   The distinction between NORM_OBJECT_DATA and NORM_OBJECT_FILE\
    \ is\n   simply to provide a hint to receivers in NormSessions serving\n   multiple\
    \ types of content as to what type of storage to allocate for\n   received content\
    \ (i.e., memory or file storage).  Other than that\n   distinction, the two are\
    \ identical, providing for reliable transport\n   of finite (but potentially very\
    \ large) units of content.  These\n   static data and file services are anticipated\
    \ to be useful for\n   multicast-based cache applications with the ability to\
    \ reliably\n   provide transmission of large quantities of static data.  Other\
    \ types\n   of static data/file delivery services might make use of these\n  \
    \ transport object types, too.  The use of the NORM_OBJECT_STREAM type\n   is\
    \ at the application's discretion and could be used to carry static\n   data or\
    \ file content also.  The NORM reliable stream service opens up\n   additional\
    \ possibilities such as serialized reliable messaging or\n   other unbounded,\
    \ perhaps dynamically produced content.  The\n   NORM_OBJECT_STREAM provides for\
    \ reliable transport analogous to that\n   of the Transmission Control Protocol\
    \ (TCP), although NORM receivers\n   will be able to begin receiving stream content\
    \ at any point in time.\n   The applicability of this feature will depend upon\
    \ the application.\n   The NORM protocol also allows for a small amount of out-of-band\
    \ data\n   (sent as NORM_INFO messages) to be attached to the data content\n \
    \  objects transmitted by the sender.  This readily available out-of-\n   band\
    \ data allows multicast receivers to quickly and efficiently\n   determine the\
    \ nature of the corresponding data, file, or stream bulk\n   content being transmitted.\
    \  This allows application-level control of\n   the receiver node's participation\
    \ in the current transport activity.\n   This also allows the protocol to be flexible\
    \ with minimal pre-\n   coordination among senders and receivers.  The NORM_INFO\
    \ content is\n   atomic in that its size MUST fit into the payload portion of\
    \ a single\n   NORM message.\n   NORM does NOT provide for global or application-level\
    \ identification\n   of data content within its message headers.  Note the NORM_INFO\
    \ out-\n   of-band data mechanism can be leveraged by the application for this\n\
    \   purpose if desired, or identification can alternatively be embedded\n   within\
    \ the data content.  NORM does identify transmitted content\n   (NormObjects)\
    \ with transport identifiers that are applicable only\n   while the sender is\
    \ transmitting and/or repairing the given object.\n   These transport data content\
    \ identifiers (NormTransportIds) are\n   assigned in a monotonically increasing\
    \ fashion by each NORM sender\n   during the course of a NormSession.  Participants,\
    \ including senders,\n   in NORM protocol sessions are also identified with unique\
    \ identifiers\n   (NormNodeIds).  Each sender maintains its NormTransportId assignments\n\
    \   independently and thus individual NormObjects can be uniquely\n   identified\
    \ during transport by concatenation of the session-unique\n   sender identifier\
    \ (NormNodeId) and the assigned NormTransportId.  The\n   NormTransportIds are\
    \ assigned from a large, but fixed, numeric space\n   in increasing order and\
    \ will be reassigned during long-lived\n   sessions.  The NORM protocol provides\
    \ mechanisms so the sender\n   application can terminate transmission of data\
    \ content and inform the\n   group of this in an efficient manner.  Other similar\
    \ protocol control\n   mechanisms (e.g., session termination, receiver synchronization,\n\
    \   etc.) are specified so reliable multicast application variants can\n   realize\
    \ different, complete bulk transfer communication models to\n   meet their goals.\n\
    \   To summarize, the NORM protocol provides reliable transport of\n   different\
    \ types of data content (including potentially mixed types).\n   The senders enqueue\
    \ and transmit bulk content in the form of static\n   data or files and/or non-finite,\
    \ ongoing stream types.  NORM senders\n   provide for repair transmission of data\
    \ and/or FEC content in\n   response to NACK messages received from the receiver\
    \ group.\n   Mechanisms for out-of-band information and other transport control\n\
    \   mechanisms are specified for use by applications to form complete\n   reliable\
    \ multicast solutions for different purposes.\n"
- title: 1.3.  NORM Scalability
  contents:
  - "1.3.  NORM Scalability\n   Group communication scalability requirements lead\
    \ to adaptation of\n   NACK-based protocol schemes when feedback for reliability\
    \ is needed\n   [RmComparison].  NORM is a protocol centered around the use of\n\
    \   selective NACKs to request repairs of missing data.  NORM provides\n   for\
    \ the use of packet-level forward error correction (FEC) techniques\n   for efficient\
    \ multicast repair and OPTIONAL proactive transmission\n   robustness [RFC3453].\
    \  FEC-based repair can be used to greatly reduce\n   the quantity of reliable\
    \ multicast repair requests and repair\n   transmissions [MdpToolkit] in a NACK-oriented\
    \ protocol.  The\n   principal factor in NORM scalability is the volume of feedback\n\
    \   traffic generated by the receiver set to facilitate reliability and\n   congestion\
    \ control.  NORM uses probabilistic suppression of redundant\n   feedback based\
    \ on exponentially distributed random backoff timers.\n   The performance of this\
    \ type of suppression relative to other\n   techniques is described in [McastFeedback].\
    \  NORM dynamically\n   measures the group's round-trip timing status to set its\
    \ suppression\n   and other protocol timers.  This allows NORM to scale well while\n\
    \   maintaining reliable data delivery transport with low latency\n   relative\
    \ to the network topology over which it is operating.\n   Feedback messages can\
    \ be either multicast to the group at large or\n   sent via unicast routing to\
    \ the sender.  In the case of unicast\n   feedback, the sender relays the feedback\
    \ state to the group to\n   facilitate feedback suppression.  In typical Internet\
    \ environments,\n   the NORM protocol will readily scale to group sizes on the\
    \ order of\n   tens of thousands of receivers.  A study of the quantity of feedback\n\
    \   for this type of protocol is described in [NormFeedback].  NORM is\n   able\
    \ to operate with a smaller amount of feedback than a single TCP\n   connection,\
    \ even with relatively large numbers of receivers.  Thus,\n   depending upon the\
    \ network topology, it is possible for NORM to scale\n   to larger group sizes.\
    \  With respect to computer resource usage, the\n   NORM protocol does not need\
    \ state to be kept on all receivers in the\n   group.  NORM senders maintain state\
    \ only for receivers providing\n   explicit congestion control feedback.  However,\
    \ NORM receivers need\n   to maintain state for each active sender.  This can\
    \ constrain the\n   number of simultaneous senders in some uses of NORM.\n"
- title: 1.4.  Environmental Requirements and Considerations
  contents:
  - "1.4.  Environmental Requirements and Considerations\n   All of the environmental\
    \ requirements and considerations that apply\n   to the \"Multicast Negative-Acknowledgment\
    \ (NACK) Building Blocks\"\n   [RFC5401], \"Forward Error Correction (FEC) Building\
    \ Block\" [RFC5052],\n   and \"TCP-Friendly Multicast Congestion Control (TFMCC)\
    \ Protocol\n   Specification\" [RFC4654] also apply to the NORM protocol.\n  \
    \ The NORM protocol SHALL be capable of operating in an end-to-end\n   fashion\
    \ with no assistance from intermediate systems beyond basic IP\n   multicast group\
    \ management, routing, and forwarding services.  While\n   the techniques utilized\
    \ in NORM are principally applicable to flat,\n   end-to-end IP multicast topologies,\
    \ they could also be applied in the\n   sub-levels of hierarchical (e.g., tree-based)\
    \ multicast distribution\n   if so desired.  NORM can make use of reciprocal (among\
    \ senders and\n   receivers) multicast communication under the Any-Source Multicast\n\
    \   (ASM) model defined in \"Host Extensions for IP Multicasting\"\n   [RFC1112],\
    \ but it SHALL also be capable of scalable operation in\n   asymmetric topologies\
    \ such as Source-Specific Multicast (SSM)\n   [RFC4607] where only unicast routing\
    \ service is available from the\n   receivers to the sender(s).\n   NORM is compatible\
    \ with IPv4 and IPv6.  Additionally, NORM can be\n   used with networks employing\
    \ Network Address Translation (NAT)\n   provided that the NAT device supports\
    \ IP multicast and/or can cache\n   UDP traffic source port numbers for remapping\
    \ feedback traffic from\n   receivers to the sender(s).\n"
- title: 2.  Architecture Definition
  contents:
  - "2.  Architecture Definition\n   A NormSession is comprised of participants (NormNodes)\
    \ acting as\n   senders and/or receivers.  NORM senders transmit data content\
    \ in the\n   form of NormObjects to the session destination address, and the NORM\n\
    \   receivers attempt to reliably receive the transmitted content using\n   negative\
    \ acknowledgments to request repair.  Each NormNode within a\n   NormSession is\
    \ assumed to have a preselected unique 32-bit identifier\n   (NormNodeId).  NormNodes\
    \ MUST have uniquely assigned identifiers\n   within a single NormSession to distinguish\
    \ between multiple possible\n   senders and to distinguish feedback information\
    \ from different\n   receivers.  There are two reserved NormNodeId values.  A\
    \ value of\n   0x00000000 is considered an invalid NormNodeId (NORM_NODE_NONE),\
    \ and\n   a value of 0xffffffff is a \"wild card\" NormNodeId (NORM_NODE_ANY).\n\
    \   While the protocol does not preclude multiple sender nodes\n   concurrently\
    \ transmitting within the context of a single NORM session\n   (i.e., many-to-many\
    \ operation), any type of interactive coordination\n   among NORM senders is assumed\
    \ to be controlled by the application- or\n   higher-protocol layer.  There are\
    \ some OPTIONAL mechanisms specified\n   in this document that can be leveraged\
    \ for such application-layer\n   coordination.\n   As previously noted, NORM allows\
    \ for reliable transmission of three\n   different basic types of data content.\
    \  The first type is\n   NORM_OBJECT_DATA, which is used for static, persistent\
    \ blocks of data\n   content maintained in the sender's application memory storage.\
    \  The\n   second type is NORM_OBJECT_FILE, which corresponds to data stored in\n\
    \   the sender's non-volatile file system.  The NORM_OBJECT_DATA and\n   NORM_OBJECT_FILE\
    \ types both represent NormObjects of finite but\n   potentially very large size.\
    \  The third type of data content is\n   NORM_OBJECT_STREAM, which corresponds\
    \ to an ongoing transmission of\n   undefined length.  This is analogous to the\
    \ reliable stream service\n   provided by TCP for unicast data transport.  The\
    \ format of the stream\n   content is application-defined and can be \"byte\"\
    \ or \"message\"\n   oriented.  The NORM protocol provides for \"flushing\" of\
    \ the stream to\n   expedite delivery or possibly enforce application message\
    \ boundaries.\n   NORM protocol implementations MAY offer either (or both) in-order\n\
    \   delivery of the stream data to the receive application or out-of-\n   order\
    \ (more immediate) delivery of received segments of the stream to\n   the receiver\
    \ application.  In either case, NORM sender and receiver\n   implementations provide\
    \ buffering to facilitate repair of the stream\n   as it is transported.\n   All\
    \ NormObjects are logically segmented into FEC coding blocks and\n   symbols for\
    \ transmission by the sender.  In NORM, a FEC encoding\n   symbol directly corresponds\
    \ to the payload of NORM_DATA messages or\n   \"segment\".  Note that when systematic\
    \ FEC codes are used, the payload\n   of NORM_DATA messages sent for the first\
    \ portion of a FEC encoding\n   block are source symbols (actual segments of original\
    \ user data),\n   while the remaining symbols for the block consist of parity\
    \ symbols\n   generated by FEC encoding.  These parity symbols are generally sent\n\
    \   in response to repair requests, but some number MAY be sent\n   proactively\
    \ at the end of each encoding block to increase the\n   robustness of transmission.\
    \  When non-systematic FEC codes are used,\n   all symbols sent consist of FEC\
    \ encoding parity content.  In this\n   case, the receiver needs to receive a\
    \ sufficient number of symbols to\n   reconstruct (via FEC decoding) the original\
    \ user data for the given\n   block.\n   Transmitted NormObjects are temporarily,\
    \ yet uniquely, identified\n   within the NormSession context using the given\
    \ sender's NormNodeId,\n   NormInstanceId, and a temporary NormTransportId.  Depending\
    \ upon the\n   implementation, individual NORM senders can manage their\n   NormInstanceIds\
    \ independently, or a common NormInstanceId could be\n   agreed upon for all participating\
    \ nodes within a session, if needed,\n   as a session identifier.  NORM NormTransportId\
    \ data content\n   identifiers are sender-assigned and applicable and valid only\
    \ during\n   a NormObject's actual transport (i.e., for as long as the sender\
    \ is\n   transmitting and providing repair of the indicated NormObject).  For\n\
    \   a long-lived session, the NormTransportId field can wrap and\n   previously\
    \ used identifiers will be re-used.  Note that globally\n   unique identification\
    \ of transported data content is not provided by\n   NORM and, if necessary, is\
    \ expected to be managed by the NORM\n   application.  The individual segments\
    \ or symbols of the NormObject\n   are further identified with FEC payload identifiers\
    \ that include\n   coding block and symbol identifiers.  These are discussed in\
    \ detail\n   later in this document.\n"
- title: 2.1.  Protocol Operation Overview
  contents:
  - "2.1.  Protocol Operation Overview\n   A NORM sender primarily generates messages\
    \ of type NORM_DATA.  These\n   messages carry original data segments or FEC symbols\
    \ and repair\n   segments/symbols for the bulk data/file or stream NormObjects\
    \ being\n   transferred.  By default, redundant FEC symbols are sent only in\n\
    \   response to receiver repair requests (NACKs) and thus normally little\n  \
    \ or no additional transmission overhead is imposed due to FEC\n   encoding. \
    \ However, the NORM implementation MAY be configured to\n   proactively transmit\
    \ some amount of redundant FEC symbols along with\n   the original content to\
    \ potentially enhance performance (e.g.,\n   improved delay) at the cost of additional\
    \ transmission overhead.\n   This configuration is sensible for certain network\
    \ conditions and can\n   allow for robust, asymmetric multicast (e.g., unidirectional\
    \ routing,\n   satellite, cable) [FecHybrid] with reduced receiver feedback, or,\
    \ in\n   some cases, no feedback.\n   A sender message of type NORM_INFO is also\
    \ defined and is used to\n   carry OPTIONAL out-of-band context information for\
    \ a given transport\n   object.  A single NORM_INFO message can be associated\
    \ with a\n   NormObject.  Because of its atomic nature, missing NORM_INFO messages\n\
    \   can be NACKed and repaired with a slightly lower delay process than\n   NORM's\
    \ general FEC-encoded data content.  The NORM_INFO message can\n   serve special\
    \ purposes for some bulk transfer, reliable multicast\n   applications where receivers\
    \ join the group mid-stream and need to\n   ascertain contextual information on\
    \ the current content being\n   transmitted.  The NACK process for NORM_INFO will\
    \ be described later.\n   When the NORM_INFO message type is used, its transmission\
    \ SHOULD\n   precede transmission of any NORM_DATA message for the associated\n\
    \   NormObject.\n   The sender also generates messages of type NORM_CMD to assist\
    \ in\n   certain protocol operations such as congestion control, end-of-\n   transmission\
    \ flushing, group round-trip time (GRTT) estimation,\n   receiver synchronization,\
    \ and OPTIONAL positive acknowledgment\n   requests or application-defined commands.\
    \  The transmission of\n   NORM_CMD messages from the sender is accomplished by\
    \ one of three\n   different procedures: single, best-effort unreliable transmission\
    \ of\n   the command; repeated redundant transmissions of the command; and\n \
    \  positively acknowledged commands.  The transmission technique used\n   for\
    \ a given command depends upon the function of the command.\n   Several core commands\
    \ are defined for basic protocol operation.\n   Additionally, implementations\
    \ MAY wish to consider providing the\n   OPTIONAL application-defined commands\
    \ that can take advantage of the\n   transmission methodologies available for\
    \ commands.  This allows for\n   application-level session management mechanisms\
    \ that can make use of\n   information available to the underlying NORM protocol\
    \ engine (e.g.,\n   round-trip timing, transmission rate, etc.).  A notable distinction\n\
    \   between NORM_DATA message and some NORM_CMD message transmissions is\n   that\
    \ typically a receiver will need to allocate resources to manage\n   reliable\
    \ reception when NORM_DATA messages are received.  However,\n   some NORM_CMD\
    \ messages are completely atomic and no specific\n   reliability (buffering) state\
    \ needs to be kept.  Thus, for session\n   management or other purposes, it is\
    \ possible that even participants\n   acting principally as data receivers MAY\
    \ transmit NORM_CMD messages.\n   However, it is RECOMMENDED that this is not\
    \ done within the context\n   of the NORM multicast session unless congestion\
    \ control is addressed.\n   For example, many receiver nodes transmitting NORM_CMD\
    \ messages\n   simultaneously can cause congestion for the destination(s).\n \
    \  All sender transmissions are subject to rate control governed by a\n   peak\
    \ transmission rate set for each participant by the application.\n   This can\
    \ be used to limit the quantity of multicast data transmitted\n   by the group.\
    \  When NORM's congestion control algorithm is enabled,\n   the rate for senders\
    \ is automatically adjusted.  In some networks, it\n   is desirable to establish\
    \ minimum and maximum bounds for the rate\n   adjustment depending upon the application\
    \ even when dynamic\n   congestion control is enabled.  However, in the case of\
    \ the general\n   Internet, congestion control policy SHALL be observed that is\n\
    \   compatible with coexistent TCP flows.\n   NORM receivers generate messages\
    \ of type NORM_NACK or NORM_ACK in\n   response to transmissions of data and commands\
    \ from a sender.  The\n   NORM_NACK messages are generated to request repair of\
    \ detected data\n   transmission losses.  Receivers generally detect losses by\
    \ tracking\n   the sequence of transmission from a sender.  Sequencing information\n\
    \   is embedded in the transmitted data packets and end-of-transmission\n   commands\
    \ from the sender.  NORM_ACK messages are generated in\n   response to certain\
    \ commands transmitted by the sender.  In the\n   general (and most scalable)\
    \ protocol mode, NORM_ACK messages are sent\n   only in response to congestion\
    \ control commands from the sender.  The\n   feedback volume of these congestion\
    \ control NORM_ACK messages is\n   controlled using the same timer-based probabilistic\
    \ suppression\n   techniques as for NORM_NACK messages to avoid feedback implosion.\
    \  In\n   order to meet potential application requirements for positive\n   acknowledgment\
    \ from receivers, other NORM_ACK messages are defined\n   and are available for\
    \ use.\n"
- title: 2.2.  Protocol Building Blocks
  contents:
  - "2.2.  Protocol Building Blocks\n   The operation of the NORM protocol is based\
    \ primarily upon the\n   concepts presented in the Multicast NACK Building Block\
    \ [RFC5401]\n   document.  This includes the basic NORM architecture and the data\n\
    \   transmission, repair, and feedback strategies discussed in that\n   document.\
    \  The reliable multicast building block approach, as\n   described in \"Reliable\
    \ Multicast Transport Building Blocks for One-\n   to-Many Bulk-Data Transfer\"\
    \ [RFC3048], is applied in creating the\n   full NORM protocol instantiation.\
    \  NORM also makes use of the parity-\n   based encoding techniques for repair\
    \ messaging and added transmission\n   robustness as described in \"The Use of\
    \ Forward Error Correction (FEC)\n   in Reliable Multicast\" [RFC3453].  NORM\
    \ uses the FEC Payload ID as\n   specified by the FEC Building Block document\
    \ [RFC5052].\n   Additionally, for congestion control, this document fully specifies\
    \ a\n   baseline congestion control mechanism (NORM-CC) based on the TCP-\n  \
    \ Friendly Multicast Congestion Control (TFMCC) scheme [TfmccPaper],\n   [RFC4654].\n"
- title: 2.3.  Design Trade-Offs
  contents:
  - "2.3.  Design Trade-Offs\n   While the various features of NORM provide some measure\
    \ of general\n   purpose utility, it is important to emphasize the understanding\
    \ that\n   \"no one size fits all\" in the reliable multicast transport arena.\n\
    \   There are numerous engineering trade-offs involved in reliable\n   multicast\
    \ transport design and this necessitates an increased\n   awareness of application\
    \ and network architecture considerations.\n   Performance requirements affecting\
    \ design can include: group size,\n   heterogeneity (e.g., capacity and/or delay),\
    \ asymmetric delivery,\n   data ordering, delivery delay, group dynamics, mobility,\
    \ congestion\n   control, and transport across low-capacity connections.  NORM\n\
    \   contains various parameters to accommodate many of these differing\n   requirements.\
    \  The NORM protocol and its mechanisms MAY be applied in\n   multicast applications\
    \ outside of bulk data transfer, but there is an\n   assumed model of bulk transfer\
    \ transport service that drives the\n   trade-offs that determine the scalability\
    \ and performance described\n   in this document.\n   The ability of NORM to provide\
    \ reliable data delivery is also\n   governed by any buffer constraints of the\
    \ sender and receiver\n   applications.  NORM protocol implementations SHOULD\
    \ operate with the\n   greatest efficiency and robustness possible within application-\n\
    \   defined buffer constraints.  Buffer requirements for reliability, as\n   always,\
    \ are a function of the delay-bandwidth product of the network\n   topology. \
    \ NORM performs best when allowed more buffering resources\n   than typical point-to-point\
    \ transport protocols.  This is because\n   NORM feedback suppression is based\
    \ upon randomly delayed\n   transmissions from the receiver set, rather than immediately\n\
    \   transmitted feedback.  There are definitive trade-offs between buffer\n  \
    \ utilization, group size scalability, and efficiency of performance.\n   Large\
    \ buffer sizes allow the NORM protocol to perform most\n   efficiently in large\
    \ delay-bandwidth topologies and allow for longer\n   feedback suppression backoff\
    \ timeouts.  This yields improved group\n   size scalability.  NORM can operate\
    \ with reduced buffering but at a\n   cost of decreased efficiency (lower relative\
    \ goodput) and reduced\n   group size scalability.\n"
- title: 3.  Conformance Statement
  contents:
  - "3.  Conformance Statement\n   This RMT Protocol Instantiation document, in conjunction\
    \ with the\n   \"Multicast Negative-Acknowledgment (NACK) Building Blocks\" [RFC5401]\n\
    \   and \"Forward Error Correction (FEC) Building Block\" [RFC5052]\n   Building\
    \ Blocks, completely specifies a working reliable multicast\n   transport protocol\
    \ that conforms to the requirements described in RFC\n   2357.\n   This document\
    \ specifies the following message types and mechanisms\n   that are REQUIRED in\
    \ complying NORM protocol implementations:\n   +----------------------+--------------------------------------------+\n\
    \   | Message Type         | Purpose                                    |\n  \
    \ +----------------------+--------------------------------------------+\n   |\
    \ NORM_DATA            | Sender message for application data        |\n   |  \
    \                    | transmission.  Implementations MUST        |\n   |    \
    \                  | support at least one of the                |\n   |      \
    \                | NORM_OBJECT_DATA, NORM_OBJECT_FILE, or     |\n   |        \
    \              | NORM_OBJECT_STREAM delivery services.  The |\n   |          \
    \            | use of the NORM FEC Object Transmission    |\n   |            \
    \          | Information header extension is OPTIONAL   |\n   |              \
    \        | with NORM_DATA messages.                   |\n   | NORM_CMD(FLUSH)\
    \      | Sender command to excite receivers for     |\n   |                  \
    \    | repair requests in lieu of ongoing         |\n   |                    \
    \  | NORM_DATA transmissions.  Note the use of  |\n   |                      |\
    \ the NORM_CMD(FLUSH) for positive           |\n   |                      | acknowledgment\
    \ of data receipt is          |\n   |                      | OPTIONAL.       \
    \                           |\n   | NORM_CMD(SQUELCH)    | Sender command to advertise\
    \ its current    |\n   |                      | valid repair window in response\
    \ to invalid |\n   |                      | requests for repair.             \
    \          |\n   | NORM_CMD(REPAIR_ADV) | Sender command to advertise current\
    \ repair |\n   |                      | (and congestion control state) to group\
    \    |\n   |                      | when unicast feedback messages are       \
    \  |\n   |                      | detected.  Used to control/suppress        |\n\
    \   |                      | excessive receiver feedback in asymmetric  |\n  \
    \ |                      | multicast topologies.                      |\n   |\
    \ NORM_CMD(CC)         | Sender command used in collection of       |\n   |  \
    \                    | round-trip timing and congestion control   |\n   |    \
    \                  | status from group (this is OPTIONAL if     |\n   |      \
    \                | alternative congestion control mechanism   |\n   |        \
    \              | and round-trip timing collection is used). |\n   | NORM_NACK\
    \            | Receiver message used to request repair of |\n   |            \
    \          | missing transmitted content.               |\n   | NORM_ACK     \
    \        | Receiver message used to proactively       |\n   |                \
    \      | provide feedback for congestion control    |\n   |                  \
    \    | purposes.  Also used with the OPTIONAL     |\n   |                    \
    \  | NORM Positive Acknowledgment Process.      |\n   +----------------------+--------------------------------------------+\n\
    \   This document also describes the following message types and\n   associated\
    \ mechanisms that are OPTIONAL for complying NORM protocol\n   implementations:\n\
    \   +-----------------------+-------------------------------------------+\n  \
    \ | Message Type          | Purpose                                   |\n   +-----------------------+-------------------------------------------+\n\
    \   | NORM_INFO             | Sender message for providing ancillary    |\n  \
    \ |                       | context information associated with NORM  |\n   |\
    \                       | transport objects.  The use of the NORM   |\n   |  \
    \                     | FEC Object Transmission Information       |\n   |    \
    \                   | header extension is OPTIONAL with         |\n   |      \
    \                 | NORM_INFO messages.                       |\n   | NORM_CMD(EOT)\
    \         | Sender command to indicate it has reached |\n   |                \
    \       | end-of-transmission and will no longer    |\n   |                  \
    \     | respond to repair requests.               |\n   | NORM_CMD(ACK_REQ)  \
    \   | Sender command to support                 |\n   |                      \
    \ | application-defined, positively           |\n   |                       |\
    \ acknowledged commands sent outside of the |\n   |                       | context\
    \ of the bulk data content being    |\n   |                       | transmitted.\
    \  The NORM Positive           |\n   |                       | Acknowledgment\
    \ Procedure associated with  |\n   |                       | this message type\
    \ is OPTIONAL.            |\n   | NORM_CMD(APPLICATION) | Sender command containing\
    \                 |\n   |                       | application-defined commands\
    \ sent outside |\n   |                       | of the context of the bulk data\
    \ content   |\n   |                       | being transmitted.               \
    \         |\n   | NORM_REPORT           | Optional message type reserved for \
    \       |\n   |                       | experimental implementations of the NORM\
    \  |\n   |                       | protocol.                                 |\n\
    \   +-----------------------+-------------------------------------------+\n"
- title: 4.  Message Formats
  contents:
  - "4.  Message Formats\n   There are two primary classes of NORM messages (see Section\
    \ 2.1):\n   sender messages and receiver messages.  NORM_CMD, NORM_INFO, and\n\
    \   NORM_DATA message types are generated by senders of data content, and\n  \
    \ NORM_NACK and NORM_ACK messages generated by receivers within a\n   NormSession.\
    \  Sender messages SHALL be governed by congestion control\n   for Internet use.\
    \  For session management or other purposes,\n   receivers can also employ NORM_CMD\
    \ message transmissions.  The\n   principal rationale for distinguishing sender\
    \ and receiver messages\n   is that receivers will typically need to allocate\
    \ resources to\n   support reliable reception from sender(s) and NORM sender messages\n\
    \   are subject to congestion control.  NORM receivers MAY employ the\n   NORM_CMD\
    \ message type for application-defined purposes, but it is\n   RECOMMENDED that\
    \ congestion control and feedback implosion issues be\n   addressed.  Additionally,\
    \ an auxiliary message type of NORM_REPORT is\n   also provided for experimental\
    \ purposes.  This section describes the\n   message formats used by the NORM protocol.\
    \  These messages and their\n   fields are referenced in the detailed functional\
    \ description of the\n   NORM protocol given in Section 5.  Individual NORM messages\
    \ are\n   compatible with the Maximum Transmission Unit (MTU) limitations of\n\
    \   encapsulating Internet protocols including IPv4, IPv6, and UDP.  The\n   current\
    \ NORM protocol specification assumes UDP encapsulation and\n   leverages the\
    \ transport features of UDP.  The NORM messages are\n   independent of network\
    \ addresses and can be used in IPv4 and IPv6\n   networks.\n"
- title: 4.1.  NORM Common Message Header and Extensions
  contents:
  - "4.1.  NORM Common Message Header and Extensions\n   There are some common message\
    \ fields contained in all NORM message\n   types.  Additionally, a header extension\
    \ mechanism is defined to\n   expand the functionality of the NORM protocol without\
    \ revision to\n   this document.  All NORM protocol messages begin with a common\
    \ header\n   with information fields as follows:\n      0                   1\
    \                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |version|  type |    hdr_len    |          sequence             |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                         source_id                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 1: NORM Common Message Header Format\n   The \"version\"\
    \ field is a 4-bit value indicating the protocol version\n   number.  NORM implementations\
    \ SHOULD ignore received messages with\n   version numbers different from their\
    \ own.  This number is intended to\n   indicate and distinguish upgrades of the\
    \ protocol that are non-\n   interoperable.  The NORM version number for this\
    \ specification is 1.\n   The message \"type\" field is a 4-bit value indicating\
    \ the NORM\n   protocol message type.  These types are defined as follows:\n \
    \                 +------------------+------------------+\n                  |\
    \ Message          |       Value      |\n                  +------------------+------------------+\n\
    \                  | NORM_INFO        |         1        |\n                 \
    \ | NORM_DATA        |         2        |\n                  | NORM_CMD      \
    \   |         3        |\n                  | NORM_NACK        |         4   \
    \     |\n                  | NORM_ACK         |         5        |\n         \
    \         | NORM_REPORT      |         6        |\n                  +------------------+------------------+\n\
    \   The 8-bit \"hdr_len\" field indicates the number of 32-bit words that\n  \
    \ comprise the given message's header portion.  This is used to\n   facilitate\
    \ the addition of header extensions.  The presence of header\n   extensions is\
    \ implied when the \"hdr_len\" value is greater than the\n   base value for the\
    \ given message \"type\".\n   The \"sequence\" field is a 16-bit value that is\
    \ set by the message\n   originator.  The \"sequence\" field serves two separate\
    \ purposes,\n   depending upon the message type:\n   1.  NORM senders MUST set\
    \ the \"sequence\" field of sender messages\n       (NORM_INFO, NORM_DATA, and\
    \ NORM_CMD) so that receivers can\n       monitor the \"sequence\" value to maintain\
    \ an estimate of packet\n       loss that can be used for congestion control purposes\
    \ (see\n       Section 5.5.2 for a detailed description of NORM Congestion\n \
    \      Control operation).  A monotonically increasing sequence number\n     \
    \  space MUST be maintained to mark NORM sender messages in this\n       way.\
    \  Note that this \"sequence\" number is explicitly NOT used in\n       NORM as\
    \ part of its reliability procedures.  The NORM object and\n       FEC payload\
    \ identifiers are used to detect missing content for\n       reliable transfer\
    \ purposes.\n   2.  NORM receivers SHOULD set the \"sequence\" field to support\n\
    \       protection from message replay attacks of NORM_NACK or NORM_NACK\n   \
    \    messages.  Note that, depending upon configuration, NORM feedback\n     \
    \  messages are sent to the session multicast address or the unicast\n       address(es)\
    \ of the active NORM sender(s).  Thus, a separate,\n       monotonically increasing\
    \ sequence number space MUST be maintained\n       for each destination address\
    \ to which the NORM receiver is\n       transmitting feedback messages.\n   Note\
    \ that these two separate purposes necessitate the maintenance of\n   separate\
    \ sequence spaces to support the functions described here.\n   And, in the case\
    \ of NORM receivers, additional sequence spaces are\n   needed when feedback messages\
    \ are sent to the sender unicast\n   address(es) instead of the session address.\n\
    \   The \"source_id\" field is a 32-bit value that uniquely identifies the\n \
    \  node that sent the message within the context of a single\n   NormSession.\
    \  This value is termed the NORM node identifier\n   (NormNodeId) and unique NormNodeIds\
    \ MUST be assigned within a single\n   NormSession.  In some cases, use of the\
    \ host IPv4 address or a hash\n   of an address can suffice, but alternative methodologies\
    \ for\n   assignment and potential collision resolution of node identifiers\n\
    \   within a multicast session SHOULD be considered.  For example, the\n   techniques\
    \ for managing the 32-bit \"synchronization source\" (SSRC)\n   identifiers defined\
    \ in the Real-Time Protocol (RTP) specification\n   [RFC3550] are applicable for\
    \ use with NORM node identifiers when an\n   ASM traffic model is observed.  In\
    \ most deployments of the NORM\n   protocol to date, the NormNodeId assignments\
    \ are administratively\n   configured, and this form of NormNodeId assignment\
    \ is RECOMMENDED for\n   most purposes.  NORM sender NormNodeId values MUST be\
    \ unique within\n   an ASM session so that NORM receiver feedback can be properly\n\
    \   demultiplexed by senders, and NORM receiver NormNodeId values MUST\n   also\
    \ be unique for congestion control operation or when the OPTIONAL\n   positive\
    \ acknowledgment mechanism is used.\n   NORM Header Extensions\n   When header\
    \ extensions are applied, they follow the message type's\n   base header and precede\
    \ any payload portion.  There are two formats\n   for header extensions, both\
    \ of which begin with an 8-bit \"het\"\n   (header extension type) field.  One\
    \ format is provided for variable-\n   length extensions with \"het\" values in\
    \ the range from 0 through 127.\n   The other format is for fixed-length (one\
    \ 32-bit word) extensions\n   with \"het\" values in the range from 128 through\
    \ 255.\n   For variable-length extensions, the value of the \"hel\" (header\n\
    \   extension length) field is the length of the entire header extension,\n  \
    \ expressed in multiples of 32-bit words.  The \"hel\" field MUST be\n   present\
    \ for variable-length extensions (\"het\" between 0 and 127) and\n   MUST NOT\
    \ be present for fixed-length extensions (\"het\" between 128\n   and 255).\n\
    \   The formats of the variable-length and fixed-length header extensions\n  \
    \ are given, respectively, here:\n      0                   1                \
    \   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |   het <=127   |      hel      |                               |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |\n     |  \
    \                  Header Extension Content                   |\n     |      \
    \                        ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \          Figure 2: NORM Variable-Length Header Extension Format\n      0   \
    \                1                   2                   3\n      0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |   het >=128   |    reserved   |    Header Extension Content   |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       Figure\
    \ 3: NORM Fixed-Length (32-bit) Header Extension Format\n   The \"Header Extension\
    \ Content\" portion of the header extension is\n   defined for each extension\
    \ type.  Some header extensions are defined\n   within this document for NORM\
    \ baseline FEC and congestion control\n   operations.\n"
- title: 4.2.  Sender Messages
  contents:
  - "4.2.  Sender Messages\n   NORM sender messages include the NORM_DATA type, the\
    \ NORM_INFO type,\n   and the NORM_CMD type.  NORM_DATA and NORM_INFO messages\
    \ contain\n   application data content while NORM_CMD messages are used for various\n\
    \   protocol control functions.\n"
- title: 4.2.1.  NORM_DATA Message
  contents:
  - "4.2.1.  NORM_DATA Message\n   The NORM_DATA message is generally the predominant\
    \ type transmitted\n   by NORM senders.  These messages are used to encapsulate\
    \ segmented\n   data content for objects of type NORM_OBJECT_DATA, NORM_OBJECT_FILE,\n\
    \   and NORM_OBJECT_STREAM.  NORM_DATA messages contain original or FEC-\n   encoded\
    \ application data content.\n   The format of NORM_DATA messages is comprised\
    \ of three logical\n   portions: 1) a fixed-format NORM_DATA header portion, 2)\
    \ a FEC\n   Payload ID portion with a format dependent upon the FEC encoding\n\
    \   used, and 3) a payload portion containing source or encoded\n   application\
    \ data content.  Note for objects of type\n   NORM_OBJECT_STREAM, the payload\
    \ portion contains additional fields\n   used to appropriately recover stream\
    \ content.  NORM implementations\n   MAY also extend the NORM_DATA header to include\
    \ a FEC Object\n   Transmission Information (EXT_FTI) header extension.  This\
    \ allows\n   NORM receivers to automatically allocate resources and properly\n\
    \   perform FEC decoding without the need for pre-configuration or out-\n   of-band\
    \ information.\n      0                   1                   2              \
    \     3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \ |version| type=2|    hdr_len    |          sequence             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                           source_id                           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \        instance_id          |     grtt      |backoff| gsize |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |     flags     |    fec_id     |     object_transport_id       |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                       fec_payload_id                        |\n     |      \
    \                        ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                header_extensions (if applicable)              |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          payload_len*         |       payload_msg_start*      |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                      payload_offset*                        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                          payload_data*                        |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 4: NORM_DATA Message Format\n   *IMPORTANT NOTE: The\
    \ \"payload_len\", \"payload_msg_start\" and\n   \"payload_offset\" fields are\
    \ present only for objects of type\n   NORM_OBJECT_STREAM.  These fields, as with\
    \ the entire payload, are\n   subject to any FEC encoding used.  Thus, when systematic\
    \ FEC codes\n   are used, these values can be directly interpreted only for packets\n\
    \   containing source symbols while packets containing FEC parity content\n  \
    \ need decoding before these fields can be interpreted.\n   The \"version\", \"\
    type\", \"hdr_len\", \"sequence\", and \"source_id\" fields\n   form the NORM\
    \ common message header as described in Section 4.1.  The\n   value of the NORM_DATA\
    \ \"type\" field is 2.  The NORM_DATA base\n   \"hdr_len\" value is 4 (i.e., four\
    \ 32-bit words) plus the size of the\n   \"fec_payload_id\" field.  The \"fec_payload_id\"\
    \ field size depends upon\n   the FEC encoding type referenced by the \"fec_id\"\
    \ field.  For example,\n   when small block, systematic codes are used, a \"fec_id\"\
    \ value of 129\n   is indicated, and the size of the \"fec_payload_id\" is two\
    \ 32-bit\n   words.  In this case the NORM_DATA base \"hdr_len\" value is 6. \
    \ The\n   cumulative size of any header extensions applied is added into the\n\
    \   \"hdr_len\" field.\n   The \"instance_id\" field contains a value generated\
    \ by the sender to\n   uniquely identify its current instance of participation\
    \ in the\n   NormSession.  This allows receivers to detect when senders have\n\
    \   perhaps left and rejoined a session in progress.  When a sender\n   (identified\
    \ by its \"source_id\") is detected to have a new\n   \"instance_id\", the NORM\
    \ receivers SHOULD drop their previous state on\n   the sender and begin reception\
    \ anew, or at least treat this\n   \"instance\" as a new, separate sender.\n \
    \  The \"grtt\" field contains a non-linear quantized representation of\n   the\
    \ sender's current estimate of group round-trip time (GRTT_sender)\n   (this is\
    \ also referred to as R_max in [TfmccPaper]).  This value is\n   used to control\
    \ timing of the NACK repair process and other aspects\n   of protocol operation\
    \ as described in this document.  Normally, the\n   advertised \"grtt\" value\
    \ will correspond to what the sender has\n   measured based on feedback from the\
    \ group, but, at low transmission\n   rates, the advertised \"grtt\" SHALL be\
    \ set to MAX(grttMeasured,\n   NormSegmentSize/senderRate) where the NormSegmentSize\
    \ is the sender's\n   segment size in bytes and the senderRate is the sender's\
    \ current\n   transmission rate in bytes per second.  The algorithm for encoding\n\
    \   and decoding this field is described in the Multicast NACK Building\n   Block\
    \ [RFC5401] document.\n   The \"backoff\" field value is used by receivers to\
    \ determine the\n   maximum backoff timer value used in the timer-based NORM NACK\n\
    \   feedback suppression.  This 4-bit field supports values from 0-15\n   that\
    \ are multiplied by GRTT_sender to determine the maximum backoff\n   timeout.\
    \  The \"backoff\" field informs the receivers of the sender's\n   backoff factor\
    \ parameter (K_sender).  Recommended values and their\n   uses are described in\
    \ the NORM receiver NACK procedure description in\n   Section 5.3.\n   The \"\
    gsize\" field contains a representation of the sender's current\n   estimate of\
    \ group size (GSIZE_sender).  This 4-bit field can roughly\n   represent values\
    \ from ten to 500 million where the most significant\n   bit value of 0 or 1 represents\
    \ a mantissa of 1 or 5, respectively,\n   and the three least significant bits\
    \ incremented by one represent a\n   base-10 exponent (order of magnitude).  For\
    \ example, a field value of\n   \"0x0\" represents 1.0e+01 (10), a value of \"\
    0x8\" represents 5.0e+01\n   (50), a value of \"0x1\" represents 1.0e+02 (100),\
    \ and a value of \"0xf\"\n   represents 5.0e+08.  For NORM feedback suppression\
    \ purposes, the\n   group size does not need to be represented with a high degree\
    \ of\n   precision.  The group size MAY even be estimated somewhat\n   conservatively\
    \ (i.e., overestimated) to maintain low levels of\n   feedback traffic.  A default\
    \ group size estimate of 10,000 (\"gsize\" =\n   0x3) is RECOMMENDED for general\
    \ purpose reliable multicast\n   applications using the NORM protocol.\n   The\
    \ \"flags\" field contains a number of different binary flags\n   providing information\
    \ and hints for the receiver to appropriately\n   handle the identified object.\
    \  Defined flags in this field include:\n   +----------------------+-------+------------------------------------+\n\
    \   | Flag                 | Value | Purpose                            |\n  \
    \ +----------------------+-------+------------------------------------+\n   |\
    \ NORM_FLAG_REPAIR     |  0x01 | Indicates message is a repair      |\n   |  \
    \                    |       | transmission                       |\n   | NORM_FLAG_EXPLICIT\
    \   |  0x02 | Indicates a repair segment         |\n   |                     \
    \ |       | intended to meet a specific        |\n   |                      |\
    \       | receiver erasure, as compared to   |\n   |                      |  \
    \     | parity segments provided by the    |\n   |                      |    \
    \   | sender for general purpose (with   |\n   |                      |      \
    \ | respect to a FEC coding block)     |\n   |                      |       |\
    \ erasure filling.                   |\n   | NORM_FLAG_INFO       |  0x04 | Indicates\
    \ availability of          |\n   |                      |       | NORM_INFO for\
    \ object.              |\n   | NORM_FLAG_UNRELIABLE |  0x08 | Indicates that repair\
    \              |\n   |                      |       | transmissions for the specified\
    \    |\n   |                      |       | object will be unavailable       \
    \  |\n   |                      |       | (one-shot, best-effort             |\n\
    \   |                      |       | transmission).                     |\n  \
    \ | NORM_FLAG_FILE       |  0x10 | Indicates object is file-based     |\n   |\
    \                      |       | data (hint to use disk storage for |\n   |  \
    \                    |       | reception).                        |\n   | NORM_FLAG_STREAM\
    \     |  0x20 | Indicates object is of type        |\n   |                   \
    \   |       | NORM_OBJECT_STREAM.                |\n   +----------------------+-------+------------------------------------+\n\
    \   NORM_FLAG_REPAIR is set when the associated message is a repair\n   transmission.\
    \  This information can be used by receivers to help\n   observe a join policy\
    \ where it is desired that newly joining\n   receivers only begin participating\
    \ in the NACK process upon receipt\n   of new (non-repair) data content.  NORM_FLAG_EXPLICIT\
    \ is used to mark\n   repair messages sent when the data sender has exhausted\
    \ its ability\n   to provide \"fresh\" (not previously transmitted) parity segments\
    \ as\n   repair.  This flag could possibly be used by intermediate systems\n \
    \  implementing functionality to control sub-casting of repair content\n   to\
    \ different legs of a reliable multicast topology with disparate\n   repair needs.\
    \  NORM_FLAG_INFO is set only when OPTIONAL NORM_INFO\n   content is actually\
    \ available for the associated object.  Thus,\n   receivers will NACK for retransmission\
    \ of NORM_INFO only when it is\n   available for a given object.  NORM_FLAG_UNRELIABLE\
    \ is set when the\n   sender wishes to transmit an object with only \"best effort\"\
    \ delivery\n   and will not supply repair transmissions for the object.  NORM\n\
    \   receivers SHOULD NOT execute repair requests for objects marked with\n   the\
    \ NORM_FLAG_UNRELIABLE flag.  There are cases where receivers can\n   inadvertently\
    \ request repair of such objects when all segments (or\n   info content) for those\
    \ objects are not received (i.e., a gap in the\n   \"object_transport_id\" sequence\
    \ is noted).  In this case, the sender\n   SHALL invoke the NORM_CMD(SQUELCH)\
    \ process as described in\n   Section 4.2.3.\n   NORM_FLAG_FILE can be set as\
    \ a hint from the sender that the\n   associated object SHOULD be stored in non-volatile\
    \ storage.\n   NORM_FLAG_STREAM is set when the identified object is of type\n\
    \   NORM_OBJECT_STREAM.  The presence of NORM_FLAG_STREAM overrides that\n   of\
    \ NORM_FLAG_FILE with respect to interpretation of object size and\n   the format\
    \ of NORM_DATA messages.\n   The \"fec_id\" field corresponds to the FEC Encoding\
    \ Identifier\n   described in the FEC Building Block document [RFC5052].  The\
    \ \"fec_id\"\n   value implies the format of the \"fec_payload_id\" field and,\
    \ coupled\n   with FEC Object Transmission Information, the procedures to decode\n\
    \   FEC-encoded content.  Small block, systematic codes (\"fec_id\" = 129)\n \
    \  are expected to be used for most NORM purposes and systematic FEC\n   codes\
    \ are RECOMMENDED for the most efficient performance of\n   NORM_OBJECT_STREAM\
    \ transport.\n   The \"object_transport_id\" field is a monotonically and incrementally\n\
    \   increasing value assigned by the sender to NormObjects being\n   transmitted.\
    \  Transmissions and repair requests related to that\n   object use the same \"\
    object_transport_id\" value.  For sessions of\n   very long or indefinite duration,\
    \ the \"object_transport_id\" field\n   will wrap and be repeated, but it is presumed\
    \ that the 16-bit field\n   size provides a sufficient sequence space to avoid\
    \ object confusion\n   amongst receivers and sources (i.e., receivers SHOULD re-synchronize\n\
    \   with a server when receiving object sequence identifiers sufficiently\n  \
    \ out-of-range with the current state kept for a given source).  During\n   the\
    \ course of its transmission within a NORM session, an object is\n   uniquely\
    \ identified by the concatenation of the sender \"source_id\"\n   and the given\
    \ \"object_transport_id\".  Note that NORM_INFO messages\n   associated with the\
    \ identified object carry the same\n   \"object_transport_id\" value.\n   The\
    \ \"fec_payload_id\" identifies the attached NORM_DATA \"payload\"\n   content.\
    \  The size and format of the \"fec_payload_id\" field depends\n   upon the FEC\
    \ type indicated by the \"fec_id\" field.  These formats are\n   given in the\
    \ descriptions of specific FEC schemes such as those\n   described in the FEC\
    \ Basic Schemes [RFC5445] specification or in\n   other FEC Schemes.  As an example,\
    \ the format of the \"fec_payload_id\"\n   format for Small Block, Systematic\
    \ codes (\"fec_id\" = 129) from the\n   FEC Basic Schemes [RFC5445] specification\
    \ is given here:\n      0                   1                   2            \
    \       3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                       source_block_number                     |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \      source_block_len       |      encoding_symbol_id       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \        Figure 5: Example: FEC Payload Id Format for 'fec_id' = 129\n   In this\
    \ example, FEC payload identifier, the \"source_block_number\",\n   \"source_block_len\"\
    , and \"encoding_symbol_id\" fields correspond to the\n   \"Source Block Number\"\
    , \"Source Block Length\", and \"Encoding Symbol\n   ID\" fields of the FEC Payload\
    \ ID format for Small Block Systematic\n   FEC Schemes identified by a \"fec_id\"\
    \ value of 129 as specified by the\n   FEC Basic Schemes [RFC5445] specification.\
    \  The \"source_block_number\"\n   identifies the coding block's relative position\
    \ with a NormObject.\n   Note that, for NormObjects of type NORM_OBJECT_STREAM,\
    \ the\n   \"source_block_number\" will wrap for very long-lived sessions.  The\n\
    \   \"source_block_len\" indicates the number of user data segments in the\n \
    \  identified coding block.  Given the \"source_block_len\" information of\n \
    \  how many symbols of application data are contained in the block, the\n   receiver\
    \ can determine whether the attached segment is data or parity\n   content and\
    \ treat it appropriately.  Applications MAY dynamically\n   \"shorten\" code blocks\
    \ when the pending information content is not\n   predictable (e.g., real-time\
    \ message streams).  In that case, the\n   \"source_block_len\" value given for\
    \ an \"encoding_symbol_id\" that\n   contains FEC parity content SHALL take precedence\
    \ over the\n   \"source_block_len\" value provided for any packets containing\
    \ source\n   symbols.  Also, the \"source_block_len\" value given for an ordinally\n\
    \   higher \"encoding_symbol_id\" SHALL take precedence over the\n   \"source_block_len\"\
    \ given for prior encoding symbols.  The reason for\n   this is that the sender\
    \ will only know the maximum source block\n   length at the time it is transmitting\
    \ source symbols, but then\n   subsequently \"shorten\" the code and then provide\
    \ that last source\n   symbol and/or encoding symbols with FEC parity content.\
    \  The\n   \"encoding_symbol_id\" identifies which specific symbol (segment)\n\
    \   within the coding block the attached payload conveys.  Depending upon\n  \
    \ the value of the \"encoding_symbol_id\" and the associated\n   \"source_block_len\"\
    \ parameters for the block, the symbol (segment)\n   referenced will be a user\
    \ data or a FEC parity segment.  For\n   systematic codes, encoding symbols numbered\
    \ less than the\n   source_block_len contain original application data while segments\n\
    \   greater than or equal to source_block_len contain parity symbols\n   calculated\
    \ for the block.  The concatenation of object_transport_id::\n   fec_payload_id\
    \ can be viewed as a unique transport protocol data unit\n   identifier for the\
    \ attached segment with respect to the NORM sender's\n   instance within a session.\n\
    \   Additional FEC Object Transmission Information (FTI) (as described in\n  \
    \ the FEC Building Block [RFC5052]) document is needed to properly\n   receive\
    \ and decode NORM transport objects.  This information MAY be\n   provided as\
    \ out-of-band session information.  In some cases, it will\n   be useful for the\
    \ sender to include this information \"in-band\" to\n   facilitate receiver operation\
    \ with minimal pre-configuration.  For\n   this purpose, the NORM FEC Object Transmission\
    \ Information Header\n   Extension (EXT_FTI) is defined.  This header extension\
    \ MAY be applied\n   to NORM_DATA and NORM_INFO messages to provide this necessary\n\
    \   information.  The format of the EXT_FTI consists of two parts, a\n   general\
    \ part that contains the size of the associated transport\n   object and a portion\
    \ that depends upon the FEC scheme being used.\n   The \"fec_id\" field in NORM_DATA\
    \ and NORM_INFO messages identifies the\n   FEC scheme.  The format of the EXT_FTI\
    \ general part is given here.\n      0                   1                   2\
    \                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |    het = 64   |    hel = 4    |       object_size (msb)       |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                     object_size (lsb)                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                  FEC scheme-specific content ...              |\n    \
    \     Figure 6: EXT_FTI Header Extension General Portion Format\n   The header\
    \ extension type \"het\" field value for the EXT_FTI header\n   extension is 64.\
    \  The header extension length \"hel\" value depends\n   upon the format of the\
    \ FTI for encoding type identified by the\n   \"fec_id\" field.\n   The 48-bit\
    \ \"object_size\" field indicates the total length of the\n   object (in bytes)\
    \ for the static object types of NORM_OBJECT_FILE and\n   NORM_OBJECT_DATA.  This\
    \ information is used by receivers to determine\n   storage requirements and/or\
    \ allocate storage for the received object.\n   Receivers with insufficient storage\
    \ capability might wish to forego\n   reliable reception (i.e., not NACK for)\
    \ of the indicated object.  In\n   the case of objects of type NORM_OBJECT_STREAM,\
    \ the \"object_size\"\n   field is used by the sender to advertise the size of\
    \ its stream\n   buffer to the receiver group.  In turn, the receivers SHOULD\
    \ use this\n   information to allocate a stream buffer for reception of\n   corresponding\
    \ size.\n   As noted, the format of the extension depends upon the FEC code in\n\
    \   use, but in general, it contains any necessary details on the code in\n  \
    \ use (e.g., FEC Instance ID, etc.).  As an example, the format of the\n   EXT_FTI\
    \ for small block systematic codes (\"fec_id\" = 129) is given\n   here:\n   \
    \   0                   1                   2                   3\n      0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |    het = 64   |    hel = 4    |       object_size (msb)       |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                     object_size (lsb)                       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       fec_instance_id         |          segment_size         |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \     fec_max_block_len       |         fec_num_parity        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Figure 7: Example: EXT_FTI Header Extension Format for 'fec_id' = 129\n  \
    \ In this example (for \"fec_id\" = 129), the \"hel\" field value is 4.\n   The\
    \ size of the EXT_FTI header extension will possibly be different\n   for other\
    \ FEC schemes.\n   The 48-bit \"object_size\" serves the purpose described previously.\n\
    \   The \"fec_instance_id\" corresponds to the \"FEC Instance ID\" described\n\
    \   in the FEC Building Block [RFC5052] document.  In this case, the\n   \"fec_instance_id\"\
    \ is a value corresponding to the particular type of\n   Small Block Systematic\
    \ Code being used (e.g., Reed-Solomon GF(2^8),\n   Reed-Solomon GF(2^16), etc).\
    \  The standardized assignment of FEC\n   Instance ID values is described in RFC\
    \ 5052.\n   The \"segment_size\" field indicates the sender's current setting\
    \ for\n   maximum message payload content (in bytes).  This allows receivers to\n\
    \   allocate appropriate buffering resources and to determine other\n   information\
    \ in order to properly process received data messaging.\n   Typically, FEC parity\
    \ symbol segments will be of this size.\n   The \"fec_max_block_len\" indicates\
    \ the current maximum number of user\n   data segments per FEC coding block to\
    \ be used by the sender during\n   the session.  This allows receivers to allocate\
    \ appropriate buffer\n   space for buffering blocks transmitted by the sender.\n\
    \   The \"fec_num_parity\" corresponds to the \"maximum number of encoding\n \
    \  symbols that can be generated for any source block\" as described in\n   FEC\
    \ Object Transmission Information for Small Block Systematic Codes\n   as described\
    \ in the FEC Building Block [RFC5052] document.  For\n   example, Reed-Solomon\
    \ codes can be arbitrarily shortened to create\n   different code variations for\
    \ a given block length.  In the case of\n   Reed-Solomon (GF(2^8) and GF(2^16))\
    \ codes, this value indicates the\n   maximum number of parity segments available\
    \ from the sender for the\n   coding blocks.  This field MAY be interpreted differently\
    \ for other\n   systematic codes as they are defined.\n   The payload portion\
    \ of NORM_DATA messages includes source data or\n   FEC-encoded application content.\
    \  The content of this payload depends\n   upon the FEC scheme being employed,\
    \ and support for streaming using\n   the NORM_OBJECT_STREAM type, when applicable,\
    \ necessitates some\n   additional content in the payload.\n   The \"payload_len\"\
    , \"payload_msg_start\", and \"payload_offset\" fields\n   are present only for\
    \ transport objects of type NORM_OBJECT_STREAM.\n   These REQUIRED fields allow\
    \ senders to arbitrarily vary the size of\n   NORM_DATA payload segments for streams.\
    \  This allows applications to\n   flush transmitted streams as needed to meet\
    \ unique streaming\n   requirements.  For objects of types NORM_OBJECT_FILE and\n\
    \   NORM_OBJECT_DATA, these fields are unnecessary since the receiver can\n  \
    \ calculate the payload length and offset information from the\n   \"fec_payload_id\"\
    \ using the REQUIRED block partitioning algorithm\n   described in the FEC Building\
    \ Block [RFC5052] document.  When\n   systematic FEC codes (e.g., \"fec_id\" =\
    \ 129) are used, the\n   \"payload_len\", \"payload_msg_start\", and \"payload_offset\"\
    \ fields\n   contain actual payload_data length, message start index (or stream\n\
    \   control code), and byte offset values for the associated application\n   stream\
    \ data segment (the remainder of the \"payload_data\" field\n   content) for those\
    \ NORM_DATA messages containing source data symbols.\n   In NORM_DATA messages\
    \ that contain FEC parity content, these fields\n   do not contain values that\
    \ can be directly interpreted, but instead\n   are values computed from FEC encoding\
    \ the \"payload_len\",\n   \"payload_msg_start\", and \"payload_offset\" fields\
    \ for the source data\n   segments of the corresponding coding block.  The actual\n\
    \   \"payload_msg_start\", \"payload_len\" and, \"payload_offset\" values of\n\
    \   missing data content can be determined upon decoding a FEC coding\n   block.\
    \  Note that these fields do NOT contribute to the value of the\n   NORM_DATA\
    \ \"hdr_len\" field.  These fields are present only when the\n   \"flags\" portion\
    \ of the NORM_DATA message indicate the transport\n   object is of type NORM_OBJECT_STREAM.\n\
    \   The \"payload_len\" value, when non-zero, indicates the length (in\n   bytes)\
    \ of the source content contained in the associated\n   \"payload_data\" field.\
    \  However, when the \"payload_len\" value is equal\n   to ZERO, this indicates\
    \ that the \"payload_msg_start\" field be\n   alternatively interpreted as a \"\
    stream_control_code\".  The only\n   \"stream_control_code\" value defined is\
    \ NORM_STREAM_END = 0.  The\n   NORM_STREAM_END code indicates that the sender\
    \ is terminating the\n   transmission of stream content at the corresponding position\
    \ in the\n   stream and the receiver MUST NOT expect content (or request repair\n\
    \   for any content) following that position in the stream.  Additional\n   specifications\
    \ MAY extend the functionality of the NORM stream\n   transport mode by defining\
    \ additional stream control codes.  These\n   control codes are delivered to the\
    \ recipient application reliably,\n   in-order with respect to the streamed application\
    \ data content.\n   The \"payload_msg_start\" field serves one of two exclusive\
    \ purposes.\n   When the \"payload_len\" value is non-zero, the \"payload_msg_start\"\
    \n   field, when also set to a non-zero value, indicates that the\n   associated\
    \ \"payload_data\" content contains an application-defined\n   message boundary\
    \ (start-of-message).  When such a message boundary is\n   indicated, the first\
    \ byte of an application-defined message, with\n   respect to the \"payload_data\"\
    \ field, will be found at an offset of\n   \"payload_msg_start - 1\" bytes.  Thus,\
    \ if a NORM_DATA payload for a\n   NORM_OBJECT_STREAM contains the start of an\
    \ application message at\n   the first byte of the \"payload_data\" field, the\
    \ value of the\n   \"payload_msg_start\" field will be '1'.  NORM implementations\
    \ SHOULD\n   provide sender stream applications with a capability to mark message\n\
    \   boundaries in this manner.  Similarly, the NORM receiver\n   implementation\
    \ SHOULD enable the application to recover such message\n   boundary information.\
    \  This enables NORM receivers to \"synchronize\"\n   reliable reception of transmitted\
    \ message stream content in a\n   meaningful way (i.e., meaningful to the application)\
    \ at any time,\n   whether joining a session already in progress, or departing\
    \ the\n   session and returning.  Note that if the value of the\n   \"payload_msg_start\"\
    \ field is ZERO, no message boundary is present.\n   The \"payload_msg_start\"\
    \ value will always be less than or equal to\n   the \"payload_len\" value except\
    \ for the special case of \"payload_len =\n   0\", which indicates the \"payload_msg_start\"\
    \ field be instead\n   interpreted as a \"stream_control_code\"\n   The \"payload_offset\"\
    \ field indicates the relative byte position (from\n   the sender stream transmission\
    \ start) of the source content contained\n   in the \"payload_data\" field.  Note\
    \ that for long-lived streams, the\n   \"payload_offset\" field will wrap.\n \
    \  The \"payload_data\" field contains the original application source or\n  \
    \ parity content for the symbol identified by the \"fec_payload_id\".\n   The\
    \ length of this field SHALL be limited to a maximum of the\n   sender's NormSegmentSize\
    \ bytes as given in the FTI for the object.\n   Note the length of this field\
    \ for messages containing parity content\n   will always be of length NormSegmentSize.\
    \  When encoding data\n   segments of varying sizes, the FEC encoder SHALL assume\
    \ ZERO value\n   padding for data segments with a length less than the\n   NormSegmentSize.\
    \  It is RECOMMENDED that a sender's NormSegmentSize\n   generally be constant\
    \ for the duration of a given sender's term of\n   participation in the session,\
    \ but can possibly vary on a per-object\n   basis.  The NormSegmentSize SHOULD\
    \ be configurable by the sender\n   application prior to session participation\
    \ as needed for network\n   topology MTU considerations.  For IPv6, MTU discovery\
    \ MAY be possibly\n   leveraged at session startup to perform this configuration.\
    \  The\n   \"payload_data\" content MAY be delivered directly to the application\n\
    \   for source symbols (when systematic FEC encoding is used) or upon\n   decoding\
    \ of the FEC block.  For NORM_OBJECT_FILE and\n   NORM_OBJECT_STREAM objects,\
    \ the data segment length and offset can be\n   calculated using the block partitioning\
    \ algorithm described in the\n   FEC Building Block [RFC5052] document.  For NORM_OBJECT_STREAM\n\
    \   objects, the length and offset is obtained from the segment's\n   corresponding\
    \ embedded \"payload_len\" and \"payload_offset\" fields.\n"
- title: 4.2.2.  NORM_INFO Message
  contents:
  - "4.2.2.  NORM_INFO Message\n   The NORM_INFO message is used to convey OPTIONAL,\
    \ application-\n   defined, out-of-band context information for transmitted NormObjects.\n\
    \   An example NORM_INFO use for bulk file transfer is to place MIME type\n  \
    \ information for the associated file, data, or stream object into the\n   NORM_INFO\
    \ payload.  Receivers could then use the NORM_INFO content to\n   make a decision\
    \ as to whether to participate in reliable reception of\n   the associated object.\
    \  Each NormObject can have an independent unit\n   of NORM_INFO with which it\
    \ is associated.  NORM_DATA messages contain\n   a flag to indicate the availability\
    \ of NORM_INFO for a given\n   NormObject.  NORM receivers will NACK for retransmission\
    \ of NORM_INFO\n   when they have not received it for a given NormObject.  The\
    \ size of\n   the NORM_INFO content is limited to that of a single NormSegmentSize\n\
    \   for the given sender.  This atomic nature allows the NORM_INFO to be\n   rapidly\
    \ and efficiently repaired within the NORM reliable\n   transmission process.\n\
    \   When NORM_INFO content is available for a NormObject, the\n   NORM_FLAG_INFO\
    \ flag SHALL be set in NORM_DATA messages for the\n   corresponding \"object_transport_id\"\
    \ and the NORM_INFO message SHALL\n   be transmitted as the first message for\
    \ the NormObject.\n      0                   1                   2           \
    \        3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |version| type=1|    hdr_len    |          sequence             |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                         source_id                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          instance_id          |     grtt      |backoff| gsize |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \   flags     |     fec_id    |     object_transport_id       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                header_extensions (if applicable)              |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                         payload_data                          |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 8: NORM_INFO Message Format\n   The \"version\", \"\
    type\", \"hdr_len\", \"sequence\", and \"source_id\" fields\n   form the NORM\
    \ common message header as described in Section 4.1.  The\n   value of the \"\
    hdr_len\" field when no header extensions are present is\n   4.\n   The \"instance_id\"\
    , \"grtt\", \"backoff\", \"gsize\", \"flags\", \"fec_id\", and\n   \"object_transport_id\"\
    \ fields carry the same information and serve the\n   same purpose as NORM_DATA\
    \ messages.  These values allow the receiver\n   to prepare appropriate buffering,\
    \ etc., for further transmissions\n   from the sender when NORM_INFO is the first\
    \ message received.\n   As with NORM_DATA messages, the NORM FTI Header Extension\
    \ (EXT_FTI)\n   MAY be optionally applied to NORM_INFO messages.  To conserve\n\
    \   protocol overhead, NORM implementations MAY apply the EXT_FTI when\n   used\
    \ to NORM_INFO messages only and not to NORM_DATA messages.\n   The NORM_INFO\
    \ \"payload_data\" field contains sender application-\n   defined content that\
    \ can be used by receiver applications for various\n   purposes as described above.\n"
- title: 4.2.3.  NORM_CMD Messages
  contents:
  - "4.2.3.  NORM_CMD Messages\n   NORM_CMD messages are transmitted by senders to\
    \ perform a number of\n   different protocol functions.  This includes functions\
    \ such as round-\n   trip timing collection, congestion control functions, synchronization\n\
    \   of sender/receiver repair \"windows\", and notification of sender\n   status.\
    \  A core set of NORM_CMD messages is enumerated.\n   Additionally, a range of\
    \ command types remain available for potential\n   application-specific use. \
    \ Some NORM_CMD types can have dynamic\n   content attached.  Any attached content\
    \ will be limited to the\n   maximum length of the sender NormSegmentSize to retain\
    \ the atomic\n   nature of the commands.  All NORM_CMD messages begin with a common\n\
    \   set of fields, after the usual NORM message common header.  The\n   standard\
    \ NORM_CMD fields are:\n      0                   1                   2      \
    \             3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |version| type=3|    hdr_len    |          sequence             |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                         source_id                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          instance_id          |     grtt      |backoff| gsize |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \  sub-type   |                                               |\n     +-+-+-+-+-+-+-+-+\
    \        NORM_CMD Content                       +\n     |                    \
    \          ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 9: NORM_CMD Standard Fields\n   The \"version\", \"\
    type\", \"hdr_len\", \"sequence\", and \"source_id\" fields\n   form the NORM\
    \ common message header as described in Section 4.1.  The\n   value of the \"\
    hdr_len\" field for NORM_CMD messages without header\n   extensions present depends\
    \ upon the \"sub-type\" field.\n   The \"instance_id\", \"grtt\", \"backoff\"\
    , and \"gsize\" fields provide the\n   same information and serve the same purpose\
    \ as NORM_DATA and\n   NORM_INFO messages.  The \"sub-type\" field indicates the\
    \ type of\n   command to follow.  The remainder of the NORM_CMD message is\n \
    \  dependent upon the command sub-type.  NORM command sub-types include:\n   +-----------------------+----------+--------------------------------+\n\
    \   | Command               | Sub-type | Purpose                        |\n  \
    \ +-----------------------+----------+--------------------------------+\n   |\
    \ NORM_CMD(FLUSH)       |     1    | Used to indicate sender        |\n   |  \
    \                     |          | temporary end-of-transmission. |\n   |    \
    \                   |          | (Assists in robustly           |\n   |      \
    \                 |          | initiating outstanding repair  |\n   |        \
    \               |          | requests from receivers).  May |\n   |          \
    \             |          | also be optionally used to     |\n   |            \
    \           |          | collect positive               |\n   |              \
    \         |          | acknowledgment of reliable     |\n   |                \
    \       |          | reception from a subset of     |\n   |                  \
    \     |          | receivers.                     |\n   | NORM_CMD(EOT)      \
    \   |     2    | Used to indicate sender        |\n   |                      \
    \ |          | permanent end-of-transmission. |\n   | NORM_CMD(SQUELCH)     |\
    \     3    | Used to advertise sender's     |\n   |                       |  \
    \        | current repair window in       |\n   |                       |    \
    \      | response to out-of-range NACKs |\n   |                       |      \
    \    | from receivers.                |\n   | NORM_CMD(CC)          |     4  \
    \  | Used for GRTT measurement and  |\n   |                       |          |\
    \ collection of congestion       |\n   |                       |          | control\
    \ feedback.              |\n   | NORM_CMD(REPAIR_ADV)  |     5    | Used to advertise\
    \ sender's     |\n   |                       |          | aggregated repair/feedback\
    \     |\n   |                       |          | state for suppression of    \
    \   |\n   |                       |          | unicast feedback from         \
    \ |\n   |                       |          | receivers.                     |\n\
    \   | NORM_CMD(ACK_REQ)     |     6    | Used to request                |\n  \
    \ |                       |          | application-defined positive   |\n   |\
    \                       |          | acknowledgment from a list of  |\n   |  \
    \                     |          | receivers (OPTIONAL).          |\n   | NORM_CMD(APPLICATION)\
    \ |     7    | Used for application-defined   |\n   |                       |\
    \          | purposes that need to          |\n   |                       |  \
    \        | temporarily preempt or         |\n   |                       |    \
    \      | supplement data transmission   |\n   |                       |      \
    \    | (OPTIONAL).                    |\n   +-----------------------+----------+--------------------------------+\n"
- title: 4.2.3.1.  NORM_CMD(FLUSH) Message
  contents:
  - "4.2.3.1.  NORM_CMD(FLUSH) Message\n   The NORM_CMD(FLUSH) command is sent when\
    \ the sender reaches the end\n   of all data content and pending repairs it has\
    \ queued for\n   transmission.  This can indicate either a temporary or permanent\
    \ end-\n   of-data transmission, but that the sender is still willing to respond\n\
    \   to repair requests.  This command is repeated once per 2*GRTT_sender\n   to\
    \ excite the receiver set for any outstanding repair requests up to\n   and including\
    \ the transmission point indicated within the\n   NORM_CMD(FLUSH) message.  The\
    \ number of repeats is equal to\n   NORM_ROBUST_FACTOR unless a list of receivers\
    \ from which explicit\n   positive acknowledgment is expected (\"acking_node_list\"\
    ) is given.\n   In that case, the \"acking_node_list\" is updated as acknowledgments\n\
    \   are received and the NORM_CMD(FLUSH) is repeated according to the\n   mechanism\
    \ described in Section 5.5.3.  The greater the\n   NORM_ROBUST_FACTOR, the greater\
    \ the probability that all applicable\n   receivers will be excited for acknowledgment\
    \ or repair requests\n   (NACKs) AND that the corresponding NACKs are delivered\
    \ to the sender.\n   A default value of NORM_ROBUST_FACTOR equal to 20 is RECOMMENDED.\
    \  If\n   a NORM_NACK message interrupts the flush process, the sender SHALL\n\
    \   re-initiate the flush process after any resulting repair\n   transmissions\
    \ are completed.\n   Note that receivers also employ a timeout mechanism to self-initiate\n\
    \   NACKing (if there are outstanding repair needs) when no messages of\n   any\
    \ type are received from a sender.  This inactivity timeout is\n   related to\
    \ the NORM_CMD(FLUSH) and NORM_ROBUST_FACTOR and is\n   specified in Section 5.3.\
    \  Receivers SHALL self-initiate the NACK\n   repair process when the inactivity\
    \ timeout has expired for a specific\n   sender and the receiver has pending repairs\
    \ needed from that sender.\n   With a sufficiently large NORM_ROBUST_FACTOR value,\
    \ data content is\n   delivered with a high assurance of reliability.  The penalty\
    \ of a\n   large NORM_ROBUST_FACTOR value is the potential transmission of\n \
    \  excess NORM_CMD(FLUSH) messages and a longer inactivity timeout for\n   receivers\
    \ to self-initiate a terminal NACK process.\n   For finite-sized transport objects\
    \ such as NORM_OBJECT_DATA and\n   NORM_OBJECT_FILE, the flush process (if there\
    \ are no further pending\n   objects) occurs at the end of these objects.  Thus,\
    \ FEC repair\n   information is always available for repairs in response to repair\n\
    \   requests elicited by the flush command.  However, for\n   NORM_OBJECT_STREAM,\
    \ the flush can occur at any time, including in the\n   middle of a FEC coding\
    \ block if systematic FEC codes are employed.\n   In this case, the sender will\
    \ not yet be able to provide FEC parity\n   content for the concurrent coding\
    \ block and will be limited to\n   explicitly repairing the stream with source\
    \ data content for that\n   block.  Applications that anticipate frequent flushing\
    \ of stream\n   content SHOULD be judicious in the selection of the FEC coding\
    \ block\n   size (i.e., do not use a very large coding block size if frequent\n\
    \   flushing occurs).  For example, a reliable multicast application\n   transmitting\
    \ an ongoing series of intermittent, relatively small\n   messages will need to\
    \ trade-off using the NORM_OBJECT_DATA paradigm\n   versus the NORM_OBJECT_STREAM\
    \ paradigm with an appropriate FEC coding\n   block size.  This is analogous to\
    \ application trade-offs for other\n   transport protocols such as the selection\
    \ of different TCP modes of\n   operation such as \"no delay\", etc.\n      0\
    \                   1                   2                   3\n      0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |version| type=3|    hdr_len    |          sequence             |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                         source_id                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          instance_id          |     grtt      |backoff| gsize |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  sub-type\
    \ = 1 |    fec_id     |      object_transport_id      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                         fec_payload_id                        |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                acking_node_list (if applicable)               |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure 10: NORM_CMD(FLUSH) Message Format\n   The \"version\"\
    , \"type\", \"hdr_len\", \"sequence\", and \"source_id\" fields\n   form the NORM\
    \ common message header as described in Section 4.1.  In\n   addition to the NORM\
    \ common message header and standard NORM_CMD\n   fields, the NORM_CMD(FLUSH)\
    \ message contains fields to identify the\n   current status and logical transmit\
    \ position of the sender.\n   The \"fec_id\" field indicates the FEC type used\
    \ for the flushing\n   \"object_transport_id\" and implies the size and format\
    \ of the\n   \"fec_payload_id\" field.  Note the \"hdr_len\" value for the\n \
    \  NORM_CMD(FLUSH) message is 4 plus the size of the \"fec_payload_id\"\n   field\
    \ when no header extensions are present.\n   The \"object_transport_id\" and \"\
    fec_payload_id\" fields indicate the\n   sender's current logical \"transmit position\"\
    .  These fields are\n   interpreted in the same manner as in the NORM_DATA message\
    \ type.\n   Upon receipt of the NORM_CMD(FLUSH), receivers are expected to check\n\
    \   their completion state THROUGH (including) this transmission\n   position.\
    \  If receivers have outstanding repair needs in this range,\n   they SHALL initiate\
    \ the NORM NACK Repair Process as described in\n   Section 5.3.  If receivers\
    \ have no outstanding repair needs, no\n   response to the NORM_CMD(FLUSH) is\
    \ generated.\n   For NORM_OBJECT_STREAM objects using systematic FEC codes, receivers\n\
    \   MUST request \"explicit-only\" repair of the identified\n   \"source_block_number\"\
    \ if the given \"encoding_symbol_id\" is less than\n   the \"source_block_len\"\
    .  This condition indicates the sender has not\n   yet completed encoding the\
    \ corresponding FEC block and parity content\n   is not yet available.  An \"\
    explicit-only\" repair request consists of\n   NACK content for the applicable\
    \ \"source_block_number\" that does not\n   include any requests for parity-based\
    \ repair.  This allows NORM\n   sender applications to \"flush\" an ongoing stream\
    \ of transmission when\n   needed, even if in the middle of a FEC block.  Once\
    \ the sender\n   resumes stream transmission and passes the end of the pending\
    \ coding\n   block, subsequent NACKs from receivers SHALL request parity-based\n\
    \   repair as usual.  Note that the use of a systematic FEC code is\n   assumed\
    \ here.  Note that a sender has the option of arbitrarily\n   shortening a given\
    \ code block when such an application \"flush\"\n   occurs.  In this case, the\
    \ receiver will request explicit repair, but\n   the sender MAY provide FEC-based\
    \ repair (parity segments) in\n   response.  These parity segments MUST contain\
    \ the corrected\n   \"source_block_len\" for the shortened block and that\n  \
    \ \"source_block_len\" associated with segments containing parity content\n  \
    \ SHALL override the previously advertised \"source_block_len\".\n   Similarly,\
    \ the \"source_block_len\" associated with the highest ordinal\n   \"encoding_symbol_id\"\
    \ SHALL take precedence over prior symbols when a\n   difference (e.g., due to\
    \ code shortening at the sender) occurs.\n   Normal receiver NACK initiation and\
    \ construction is discussed in\n   detail in Section 5.3.\n   The OPTIONAL \"\
    acking_node_list\" field contains a list of NormNodeIds\n   for receivers from\
    \ which the sender is requesting explicit positive\n   acknowledgment of reception\
    \ up through the transmission point\n   identified by the \"object_transport_id\"\
    \ and \"fec_payload_id\" fields.\n   The length of the list can be inferred from\
    \ the length of the\n   received NORM_CMD(FLUSH) message.  When the \"acking_node_list\"\
    \ is\n   present, the lightweight positive acknowledgment process described in\n\
    \   Section 5.5.3 SHALL be observed.\n"
- title: 4.2.3.2.  NORM_CMD(EOT) Message
  contents:
  - "4.2.3.2.  NORM_CMD(EOT) Message\n   The NORM_CMD(EOT) command is sent when the\
    \ sender reaches permanent\n   end-of-transmission with respect to the NormSession\
    \ and will not\n   respond to further repair requests.  This allows receivers\
    \ to\n   gracefully reach closure of operation with this sender (without\n   requiring\
    \ any timeout) and free any resources that are no longer\n   needed.  The NORM_CMD(EOT)\
    \ command SHOULD be sent with the same\n   robust mechanism as used for NORM_CMD(FLUSH)\
    \ commands to provide a\n   high assurance of reception by the receiver set.\n\
    \      0                   1                   2                   3\n      0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |version| type=3|    hdr_len    |          sequence             |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                         source_id                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          instance_id          |     grtt      |backoff| gsize |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  sub-type\
    \ = 2 |                    reserved                   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 11: NORM_CMD(EOT) Message Format\n   The value of the\
    \ \"hdr_len\" field for NORM_CMD(EOT) messages without\n   header extensions present\
    \ is 4.  The \"reserved\" field is reserved for\n   future use and MUST be set\
    \ to an all ZERO value.  Receivers MUST\n   ignore the \"reserved\" field.\n"
- title: 4.2.3.3.  NORM_CMD(SQUELCH) Message
  contents:
  - "4.2.3.3.  NORM_CMD(SQUELCH) Message\n   The NORM_CMD(SQUELCH) command is transmitted\
    \ in response to outdated\n   or invalid NORM_NACK content received by the sender.\
    \  Invalid\n   NORM_NACK content consists of repair requests for NormObjects for\n\
    \   which the sender is unable or unwilling to provide repair.  This\n   includes\
    \ repair requests for outdated objects, aborted objects, or\n   those objects\
    \ that the sender previously transmitted marked with the\n   NORM_FLAG_UNRELIABLE\
    \ flag.  This command indicates to receivers what\n   content is available for\
    \ repair, thus serving as a description of the\n   sender's current \"repair window\"\
    .  Receivers SHALL NOT generate\n   repair requests for content identified as\
    \ invalid by a\n   NORM_CMD(SQUELCH).\n   The NORM_CMD(SQUELCH) command is sent\
    \ once per 2*GRTT_sender at the\n   most.  The NORM_CMD(SQUELCH) advertises the\
    \ current \"repair window\"\n   of the sender by identifying the earliest (lowest)\
    \ transmission point\n   for which it will provide repair, along with an encoded\
    \ list of\n   objects from that point forward that are no longer valid for repair.\n\
    \   This mechanism allows the sender application to cancel or abort\n   transmission\
    \ and/or repair of specific previously enqueued objects.\n   The list also contains\
    \ the identifiers for any objects within the\n   repair window that were sent\
    \ with the NORM_FLAG_UNRELIABLE flag set.\n   In normal conditions, the NORM_CMD(SQUELCH)\
    \ will be needed\n   infrequently, and generally only to provide a reference repair\
    \ window\n   for receivers who have fallen \"out-of-sync\" with the sender due\
    \ to\n   extremely poor network conditions.\n   The starting point of the invalid\
    \ NormObject list begins with the\n   lowest invalid NormTransportId greater than\
    \ the current \"repair\n   window\" start from the invalid NACK(s) that prompted\
    \ the generation\n   of the squelch.  The length of the list is limited by the\
    \ sender's\n   NormSegmentSize.  This allows the receivers to learn the status\
    \ of\n   the sender's applicable object repair window with minimal\n   transmission\
    \ of NORM_CMD(SQUELCH) commands.  The format of the\n   NORM_CMD(SQUELCH) message\
    \ is:\n      0                   1                   2                   3\n \
    \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |version| type=3|    hdr_len    |          sequence             |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                         source_id                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          instance_id          |     grtt      |backoff| gsize |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     | sub-type\
    \ = 3  |     fec_id    |      object_transport_id      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                         fec_payload_id                        |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                        invalid_object_list                    |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 12: NORM_CMD(SQUELCH) Message Format\n   In addition to\
    \ the NORM common message header and standard NORM_CMD\n   fields, the NORM_CMD(SQUELCH)\
    \ message contains fields to identify the\n   earliest logical transmit position\
    \ of the sender's current repair\n   window and an \"invalid_object_list\" beginning\
    \ with the index of the\n   logically earliest invalid repair request from the\
    \ offending NACK\n   message that initiated the NORM_CMD(SQUELCH) transmission.\
    \  The value\n   of the \"hdr_len\" field when no extensions are present is 4\
    \ plus the\n   size of the \"fec_payload_id\" field that is dependent upon the\
    \ FEC\n   scheme identified by the \"fec_id\" field.\n   The \"object_transport_id\"\
    \ and \"fec_payload_id\" fields are\n   concatenated to indicate the beginning\
    \ of the sender's current repair\n   window (i.e., the logically earliest point\
    \ in its transmission\n   history for which the sender can provide repair).  The\
    \ \"fec_id\" field\n   implies the size and format of the \"fec_payload_id\" field.\
    \  This\n   serves as an advertisement of a \"synchronization\" point for receivers\n\
    \   to request repair.  Note, that while an \"encoding_symbol_id\" MAY be\n  \
    \ included in the \"fec_payload_id\" field, the sender's repair window\n   SHOULD\
    \ be aligned on FEC coding block boundaries and thus the\n   \"encoding_symbol_id\"\
    \ SHOULD be zero.\n   The \"invalid_object_list\" is a list of 16-bit NormTransportIds\
    \ that,\n   although they are within the range of the sender's current repair\n\
    \   window, are no longer available for repair from the sender.  For\n   example,\
    \ a sender application MAY dequeue an out-of-date object even\n   though it is\
    \ still within the repair window.  The total size of the\n   \"invalid_object_list\"\
    \ content can be determined from the packet's\n   payload length and is limited\
    \ to a maximum of the NormSegmentSize of\n   the sender.  Thus, for very large\
    \ repair windows, it is possible that\n   a single NORM_CMD(SQUELCH) message cannot\
    \ include the entire set of\n   invalid objects in the repair window.  In this\
    \ case, the sender SHALL\n   ensure that the list begins with a NormTransportId\
    \ that is greater\n   than or equal to the lowest ordinal invalid NormTransportId\
    \ from the\n   NACK message(s) that prompted the NORM_CMD(SQUELCH) generation.\
    \  The\n   NormTransportId in the \"invalid_object_list\" MUST be ordinally\n\
    \   greater than the \"object_transport_id\" marking the beginning of the\n  \
    \ sender's repair window.  This ensures convergence of the squelch\n   process,\
    \ even if multiple invalid NACK/squelch iterations are\n   required.  This explicit\
    \ description of invalid content within the\n   sender's current window allows\
    \ the sender application (most notably\n   for discrete object transport) to arbitrarily\
    \ invalidate (i.e.,\n   dequeue) portions of enqueued content (e.g., certain objects)\
    \ for\n   which it no longer wishes to provide reliable transport.\n"
- title: 4.2.3.4.  NORM_CMD(CC) Message
  contents:
  - "4.2.3.4.  NORM_CMD(CC) Message\n   The NORM_CMD(CC) message contains fields to\
    \ enable sender-to-group\n   GRTT measurement and to excite the group for congestion\
    \ control\n   feedback.  A baseline NORM congestion control scheme (NORM-CC),\
    \ based\n   on the TCP-Friendly Multicast Congestion Control (TFMCC) scheme of\n\
    \   RFC 4654 is fully specified in Section 5.5.2 of this document.  The\n   NORM_CMD(CC)\
    \ message is usually transmitted as part of NORM-CC\n   operation.  A NORM header\
    \ extension is defined below to be used with\n   the NORM_CMD(CC) message to support\
    \ NORM-CC operation.  Different\n   header extensions MAY be defined for the NORM_CMD(CC)\
    \ (and/or other\n   NORM messages as needed) to support alternative congestion\
    \ control\n   schemes in the future.  If NORM is operated in a network where\n\
    \   resources are explicitly dedicated to the NORM session and therefore\n   congestion\
    \ control operation is disabled, the NORM_CMD(CC) message is\n   then used solely\
    \ for GRTT measurement and MAY be sent less frequently\n   than with congestion\
    \ control operation.\n      0                   1                   2        \
    \           3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |version| type=3|    hdr_len    |            sequence           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                         source_id                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          instance_id          |     grtt      |backoff| gsize |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  sub-type\
    \ = 4 |    reserved   |          cc_sequence          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                         send_time_sec                         |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                      send_time_usec                         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |               header extensions (if applicable)               |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                  cc_node_list (if applicable)                 |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 13: NORM_CMD(CC) Message Format\n   The NORM common\
    \ message header and standard NORM_CMD fields serve\n   their usual purposes.\
    \  The value of the \"hdr_len\" field when no\n   header extensions are present\
    \ is 6.\n   The \"reserved\" field is for potential future use and MUST be set\
    \ to\n   ZERO in this version of the NORM protocol and its baseline NORM-CC\n\
    \   congestion control scheme.  It is possible for alternative congestion\n  \
    \ control schemes to use the NORM_CMD(CC) message defined here and\n   leverage\
    \ the \"reserved\" field for scheme-specific purposes.\n   The \"cc_sequence\"\
    \ field is a sequence number applied by the sender.\n   For NORM-CC operation,\
    \ it is used to provide functionality equivalent\n   to the \"feedback round number\"\
    \ (fb_nr) described in RFC 4654.  The\n   most recently received \"cc_sequence\"\
    \ value is recorded by receivers\n   and can be fed back to the sender in congestion\
    \ control feedback\n   generated by the receivers for that sender.  The \"cc_sequence\"\
    \ number\n   can also be used in NORM implementations to assess how recently a\n\
    \   receiver has received NORM_CMD(CC) probes from the sender.  This can\n   be\
    \ useful instrumentation for complex or experimental multicast\n   routing environments.\n\
    \   The \"send_time\" field is a timestamp indicating the time that the\n   NORM_CMD(CC)\
    \ message was transmitted.  This consists of a 64-bit\n   field containing 32-bits\
    \ with the time in seconds (\"send_time_sec\")\n   and 32-bits with the time in\
    \ microseconds (\"send_time_usec\") since\n   some reference time the source maintains\
    \ (usually 00:00:00, 1 January\n   1970).  The byte ordering of the fields is\
    \ \"Big Endian\" network\n   order.  Receivers use this timestamp adjusted by\
    \ the amount of delay\n   from the time they received the NORM_CMD(CC) message\
    \ to the time of\n   their response as the \"grtt_response\" portion of NORM_ACK\
    \ and\n   NORM_NACK messages generated.  This allows the sender to evaluate\n\
    \   round-trip times to different receivers for congestion control and\n   other\
    \ (e.g., GRTT determination) purposes.\n   To facilitate the baseline NORM-CC\
    \ scheme described in Section 5.5.2,\n   a NORM-CC Rate header extension (EXT_RATE)\
    \ is defined to inform the\n   group of the sender's current transmission rate.\
    \  This is used along\n   with the loss detection \"sequence\" field of all NORM\
    \ sender messages\n   and the NORM_CMD(CC) GRTT collection process to support\
    \ NORM-CC\n   congestion control operation.  The format of this header extension\
    \ is\n   as follows:\n      0                   1                   2        \
    \           3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |    het = 128  |    reserved   |           send_rate           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The \"\
    send_rate\" field indicates the sender's current transmission\n   rate in bytes\
    \ per second.  The 16-bit \"send_rate\" field consists of\n   12 bits of mantissa\
    \ in the most significant portion and 4 bits of\n   base 10 integer exponent (E)\
    \ information in the least significant\n   portion.  The 12-bit mantissa portion\
    \ of the field is scaled such\n   that a base 10 mantissa (M) floating point value\
    \ of 0.0 corresponds\n   to 0 and a value of 10.0 corresponds to 4096 in the upper\
    \ 12 bits of\n   the 16-bit \"send_rate\" field.  Thus:\n          send_rate =\
    \ (((int)(M * 4096.0 / 10.0 + 0.5)) << 4) | E;\n   For example, to represent a\
    \ transmission rate of 256 kbit/s (3.2e+04\n   bytes per second), the lower 4\
    \ bits of the 16-bit field contain a\n   value of 0x04 to represent the exponent\
    \ (E) while the upper 12 bits\n   contain a value of 0x51f (M) as determined from\
    \ the equation given\n   above:\n        send_rate = (((int)((3.2 * 4096.0 / 10.0)\
    \ + 0.5)) << 4) | 4;\n                  = (0x51f << 4) | 0x4\n               \
    \   = 0x51f4\n   To decode the \"send_rate\" field, the following equation can\
    \ be used:\n   value = (send_rate >> 4) * (10/4096) * power(10, (send_rate & x000f))\n\
    \   Note the maximum transmission rate that can be represented by this\n   scheme\
    \ is approximately 9.99e+15 bytes per second.\n   When this extension is present,\
    \ a \"cc_node_list\" might be attached as\n   the payload of the NORM_CMD(CC)\
    \ message.  The presence of this header\n   extension also implies that NORM receivers\
    \ MUST respond according to\n   the procedures described in Section 5.5.2.\n \
    \  The \"cc_node_list\" consists of a list of NormNodeIds and their\n   associated\
    \ congestion control status.  This includes the current\n   limiting receiver\
    \ (CLR) node, any potential limiting receiver (PLR)\n   nodes that have been identified,\
    \ and some number of receivers for\n   which congestion control status is being\
    \ provided, most notably\n   including the receivers' current RTT measurement.\
    \  The maximum length\n   of the \"cc_node_list\" provides for at least the CLR\
    \ and one other\n   receiver, but can be increased for more timely feedback to\
    \ the group.\n   The list length can be inferred from the length of the NORM_CMD(CC)\n\
    \   message.\n   Each item in the \"cc_node_list\" is in the following format:\n\
    \      0                   1                   2                   3\n      0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                          cc_node_id                           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \  cc_flags   |     cc_rtt    |            cc_rate            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The \"cc_node_id\" is the NormNodeId of the receiver the item\n   represents.\n\
    \   The \"cc_flags\" field contains flags indicating the congestion control\n\
    \   status of the indicated receiver.  The following flags are defined:\n   +--------------------+-------+--------------------------------------+\n\
    \   | Flag               | Value | Purpose                              |\n  \
    \ +--------------------+-------+--------------------------------------+\n   |\
    \ NORM_FLAG_CC_CLR   |  0x01 | Receiver is the current limiting     |\n   |  \
    \                  |       | receiver (CLR).                      |\n   | NORM_FLAG_CC_PLR\
    \   |  0x02 | Receiver is a potential limiting     |\n   |                   \
    \ |       | receiver (PLR).                      |\n   | NORM_FLAG_CC_RTT   |\
    \  0x04 | Receiver has measured RTT with       |\n   |                    |  \
    \     | respect to sender.                   |\n   | NORM_FLAG_CC_START |  0x08\
    \ | Sender/receiver is in \"slow start\"   |\n   |                    |      \
    \ | phase of congestion control          |\n   |                    |       |\
    \ operation (i.e., the receiver has    |\n   |                    |       | not\
    \ yet detected any packet loss and |\n   |                    |       | the \"\
    cc_rate\" field is the           |\n   |                    |       | receiver's\
    \ actual measured receive   |\n   |                    |       | rate).      \
    \                         |\n   | NORM_FLAG_CC_LEAVE |  0x10 | Receiver is imminently\
    \ leaving the   |\n   |                    |       | session and its feedback\
    \ SHOULD not  |\n   |                    |       | be considered in congestion\
    \ control  |\n   |                    |       | operation.                   \
    \        |\n   +--------------------+-------+--------------------------------------+\n\
    \   The \"cc_rtt\" contains a quantized representation of the RTT as\n   measured\
    \ by the sender with respect to the indicated receiver.  This\n   field is valid\
    \ only if the NORM_FLAG_CC_RTT flag is set in the\n   \"cc_flags\" field.  This\
    \ one-byte field is a quantized representation\n   of the RTT using the algorithm\
    \ described in the Multicast NACK\n   Building Block [RFC5401] document.\n   The\
    \ \"cc_rate\" field contains a representation of the receiver's\n   current calculated\
    \ (during steady-state congestion control operation)\n   or twice its measured\
    \ (during the slow start phase) congestion\n   control rate.  This field is encoded\
    \ and decoded using the same\n   technique as described for the NORM_CMD(CC) \"\
    send_rate\" field.\n"
- title: 4.2.3.5.  NORM_CMD(REPAIR_ADV) Message
  contents:
  - "4.2.3.5.  NORM_CMD(REPAIR_ADV) Message\n   The NORM_CMD(REPAIR_ADV) message is\
    \ used by the sender to \"advertise\"\n   its aggregated repair state from NORM_NACK\
    \ messages accumulated\n   during a repair cycle and/or congestion control feedback\
    \ received.\n   This message is sent only when the sender has received NORM_NACK\n\
    \   and/or NORM_ACK(CC) (when congestion control is enabled) messages via\n  \
    \ unicast transmission instead of multicast.  By relaying this\n   information\
    \ to the receiver set, suppression of feedback can be\n   achieved even when receivers\
    \ are unicasting that feedback instead of\n   multicasting it among the group\
    \ [NormFeedback].\n      0                   1                   2           \
    \        3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |version| type=3|    hdr_len    |          sequence             |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                         source_id                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          instance_id          |     grtt      |backoff| gsize |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     | sub-type\
    \ = 5  |     flags     |            reserved           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |               header extensions (if applicable)               |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                       repair_adv_payload                      |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \              Figure 14: NORM_CMD(REPAIR_ADV) Message Format\n   The \"instance_id\"\
    , \"grtt\", \"backoff\", \"gsize\", and \"sub-type\" fields\n   serve the same\
    \ purpose as in other NORM_CMD messages.  The value of\n   the \"hdr_len\" field\
    \ when no extensions are present is 4.\n   The \"flags\" field provides information\
    \ on the NORM_CMD(REPAIR_ADV)\n   content.  There is currently one NORM_CMD(REPAIR_ADV)\
    \ flag defined:\n                     NORM_REPAIR_ADV_FLAG_LIMIT = 0x01\n   This\
    \ flag is set by the sender when it is unable to fit its full\n   current repair\
    \ state into a single NormSegmentSize.  If this flag is\n   set, receivers SHALL\
    \ limit their NACK response to generating NACK\n   content only up through the\
    \ maximum ordinal transmission position\n   (objectTransportId::fecPayloadId)\
    \ included in the\n   \"repair_adv_content\".\n   When congestion control operation\
    \ is enabled, a header extension\n   SHOULD be applied to the NORM_CMD(REPAIR_ADV)\
    \ representing the most\n   limiting (in terms of congestion control feedback\
    \ suppression)\n   congestion control response.  This allows the NORM_CMD(REPAIR_ADV)\n\
    \   message to suppress receiver congestion control responses as well as\n   NACK\
    \ feedback messages.  The field is defined as a header extension\n   so that alternative\
    \ congestion control schemes can be used for NORM\n   without revision to this\
    \ document.  A NORM-CC Feedback Header\n   Extension (EXT_CC) is defined to encapsulate\
    \ congestion control\n   feedback within NORM_NACK, NORM_ACK, and NORM_CMD(REPAIR_ADV)\n\
    \   messages.  If another congestion control technique (e.g., Pragmatic\n   General\
    \ Multicast Congestion Control (PGMCC) [PgmccPaper]) is used\n   within a NORM\
    \ implementation, an additional header extension MAY need\n   to be defined to\
    \ encapsulate any required feedback content.  The\n   NORM-CC Feedback Header\
    \ Extension format is:\n      0                   1                   2      \
    \             3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |     het = 3   |    hel = 3    |          cc_sequence          |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \  cc_flags   |     cc_rtt    |            cc_loss            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |            cc_rate            |          cc_reserved          |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The \"\
    cc_sequence\" field contains the current greatest \"cc_sequence\"\n   value receivers\
    \ have received in NORM_CMD(CC) messages from the\n   sender.  This information\
    \ assists the sender in congestion control\n   operation by providing an indicator\
    \ of how current (\"fresh\") the\n   receiver's round-trip measurement reference\
    \ time is and whether the\n   receiver has been successfully receiving recent\
    \ congestion control\n   probes.  For example, if it is apparent the receiver\
    \ has not been\n   receiving recent congestion control probes (and thus possibly\
    \ other\n   messages from the sender), the sender SHOULD choose to take\n   congestion\
    \ avoidance measures.  For NORM_CMD(REPAIR_ADV) messages,\n   the sender SHALL\
    \ set the \"cc_sequence\" field value to the value set\n   in the last NORM_CMD(CC)\
    \ message sent.\n   The \"cc_flags\" field contains bits representing the receiver's\
    \ state\n   with respect to congestion control operation.  The possible values\n\
    \   for the \"cc_flags\" field are those specified for the NORM_CMD(CC)\n   message\
    \ node list item flags.  These fields are used by receivers in\n   controlling\
    \ (suppressing as necessary) their congestion control\n   feedback.  For NORM_CMD(REPAIR_ADV)\
    \ messages, the NORM_FLAG_CC_RTT\n   SHALL be set only when all feedback messages\
    \ received by the sender\n   have the flag set.  Similarly, the NORM_FLAG_CC_CLR\
    \ or\n   NORM_FLAG_CC_PLR SHALL be set only when no feedback has been received\n\
    \   from non-CLR or non-PLR receivers.  And the NORM_FLAG_CC_LEAVE SHALL\n   be\
    \ set only when all feedback messages the sender has received have\n   this flag\
    \ set.  These heuristics for setting the flags in\n   NORM_CMD(REPAIR_ADV) ensure\
    \ the most effective suppression of\n   receivers providing unicast feedback messages.\n\
    \   The \"cc_rtt\" field SHALL be set to a default maximum value, and the\n  \
    \ NORM_FLAG_CC_RTT flag SHALL be cleared when no receiver has yet\n   received\
    \ RTT measurement information.  When a receiver has received\n   RTT measurement\
    \ information, it SHALL set the \"cc_rtt\" value\n   accordingly and set the NORM_FLAG_CC_RTT\
    \ flag in the \"cc_flags\"\n   field.  For NORM_CMD(REPAIR_ADV) messages, the\
    \ sender SHALL set the\n   \"cc_rtt\" field value to the largest non-CLR/non-PLR\
    \ RTT it has\n   measured from receivers for the current feedback round.\n   The\
    \ \"cc_loss\" field represents the receiver's current packet loss\n   fraction\
    \ estimate for the indicated source.  The loss fraction is a\n   value from 0.0\
    \ to 1.0 corresponding to a range of zero to 100 percent\n   packet loss.  The\
    \ 16-bit \"cc_loss\" value is calculated by the\n   following formula:\n     \
    \        \"cc_loss\" = floor(decimal_loss_fraction * 65535.0)\n   For NORM_CMD(REPAIR_ADV)\
    \ messages, the sender SHALL set the \"cc_loss\"\n   field value to the largest\
    \ non-CLR/non-PLR loss estimate it has\n   received from receivers for the current\
    \ feedback round.\n   The \"cc_rate\" field represents the receiver's current\
    \ local\n   congestion control rate.  During \"slow start\", when the receiver\
    \ has\n   detected no loss, this value is set to twice the actual rate it has\n\
    \   measured from the corresponding sender and the NORM_FLAG_CC_START is\n   set\
    \ in the \"cc_flags\" field.  Otherwise, the receiver calculates a\n   congestion\
    \ control rate based on its loss measurement and RTT\n   measurement information\
    \ (even if default) for the \"cc_rate\" field.\n   For NORM_CMD(REPAIR_ADV) messages,\
    \ the sender SHALL set the \"cc_loss\"\n   field value to the lowest non-CLR/non-PLR\
    \ \"cc_rate\" report it has\n   received from receivers for the current feedback\
    \ round.\n   The \"cc_reserved\" field is reserved for future NORM protocol use.\n\
    \   Currently, senders SHALL set this field to ZERO, and receivers SHALL\n   ignore\
    \ the content of this field.\n   The \"repair_adv_payload\" is in exactly the\
    \ same form as the\n   \"nack_content\" of NORM_NACK messages and can be processed\
    \ by\n   receivers for suppression purposes in the same manner, with the\n   exception\
    \ of the condition when the NORM_REPAIR_ADV_FLAG_LIMIT is\n   set.\n"
- title: 4.2.3.6.  NORM_CMD(ACK_REQ) Message
  contents:
  - "4.2.3.6.  NORM_CMD(ACK_REQ) Message\n   The NORM_CMD(ACK_REQ) message is used\
    \ by the sender to request\n   acknowledgment from a specified list of receivers.\
    \  This message is\n   used in providing a lightweight positive acknowledgment\
    \ mechanism\n   that is OPTIONAL for use by the reliable multicast application.\
    \  A\n   range of acknowledgment request types is provided for use at the\n  \
    \ application's discretion.  Provision for application-defined,\n   positively\
    \ acknowledged commands allows the application to\n   automatically take advantage\
    \ of transmission and round-trip timing\n   information available to the NORM\
    \ protocol.  The details of the NORM\n   Positive Acknowledgment Process including\
    \ transmission of the\n   NORM_CMD(ACK_REQ) messages and the receiver response\
    \ (NORM_ACK) are\n   described in Section 5.5.3.  The format of the NORM_CMD(ACK_REQ)\n\
    \   message is:\n      0                   1                   2             \
    \      3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |version| type=3|    hdr_len    |          sequence             |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                         source_id                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          instance_id          |     grtt      |backoff| gsize |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     | sub-type\
    \ = 6  |    reserved   |    ack_type   |    ack_id     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                       acking_node_list                        |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 15: NORM_CMD(ACK_REQ) Message Format\n   The NORM common\
    \ message header and standard NORM_CMD fields serve\n   their usual purposes.\
    \  The value of the \"hdr_len\" field for\n   NORM_CMD(ACK_REQ) messages with\
    \ no header extension present is 4.\n   The \"ack_type\" field indicates the type\
    \ of acknowledgment being\n   requested and thus implies rules for how the receiver\
    \ will treat this\n   request.  The following \"ack_type\" values are defined\
    \ and are also\n   used in NORM_ACK messages described later:\n   +-----------------------+------------+------------------------------+\n\
    \   | ACK Type              | Value      | Purpose                      |\n  \
    \ +-----------------------+------------+------------------------------+\n   |\
    \ NORM_ACK(CC)          | 1          | Used to identify NORM_ACK    |\n   |  \
    \                     |            | messages sent in response to |\n   |    \
    \                   |            | NORM_CMD(CC) messages.       |\n   | NORM_ACK(FLUSH)\
    \       | 2          | Used to identify NORM_ACK    |\n   |                  \
    \     |            | messages sent in response to |\n   |                    \
    \   |            | NORM_CMD(FLUSH) messages.    |\n   | NORM_ACK(RESERVED)   \
    \ | 3-15       | Reserved for possible future |\n   |                       |\
    \            | NORM protocol use.           |\n   | NORM_ACK(APPLICATION) | 16-255\
    \     | Used at application's        |\n   |                       |         \
    \   | discretion.                  |\n   +-----------------------+------------+------------------------------+\n\
    \   The NORM_ACK(CC) value is provided for use only in NORM_ACKs\n   generated\
    \ in response to the NORM_CMD(CC) messages used in congestion\n   control operation.\
    \  Similarly, the NORM_ACK(FLUSH) is provided for\n   use only in NORM_ACKs generated\
    \ in response to applicable\n   NORM_CMD(FLUSH) messages.  NORM_CMD(ACK_REQ) messages\
    \ with \"ack_type\"\n   of NORM_ACK(CC) or NORM_ACK(FLUSH) SHALL NOT be generated\
    \ by the\n   sender.\n   The NORM_ACK(RESERVED) range of \"ack_type\" values is\
    \ provided for\n   possible future NORM protocol use.\n   The NORM_ACK(APPLICATION)\
    \ range of \"ack_type\" values is provided so\n   that NORM applications can implement\
    \ application-defined, positively\n   acknowledged commands that are able to leverage\
    \ internal transmission\n   and round-trip timing information available to the\
    \ NORM protocol\n   implementation.\n   The \"ack_id\" provides a sequenced identifier\
    \ for the given\n   NORM_CMD(ACK_REQ) message.  This \"ack_id\" is returned in\
    \ NORM_ACK\n   messages generated by the receivers so that the sender can associate\n\
    \   the response with its corresponding request.\n   The \"reserved\" field is\
    \ reserved for possible future protocol use and\n   SHALL be set to ZERO by senders\
    \ and ignored by receivers.\n   The \"acking_node_list\" field contains the NormNodeIds\
    \ of the current\n   NORM receivers that are desired to provide positive acknowledgment\n\
    \   (NORM_ACK) to this request.  The packet payload length implies the\n   length\
    \ of the \"acking_node_list\", and its length is limited to the\n   sender NormSegmentSize.\
    \  The individual NormNodeId items are listed\n   in network (Big Endian) byte\
    \ order.  If a receiver's NormNodeId is\n   included in the \"acking_node_list\"\
    , it SHALL schedule transmission of\n   a NORM_ACK message as described in Section\
    \ 5.5.3.\n"
- title: 4.2.3.7.  NORM_CMD(APPLICATION) Message
  contents:
  - "4.2.3.7.  NORM_CMD(APPLICATION) Message\n   This command allows the NORM application\
    \ to robustly transmit\n   application-defined commands.  The command message\
    \ preempts any\n   ongoing data transmission and is repeated up to NORM_ROBUST_FACTOR\n\
    \   times at a rate of once per 2*GRTT_sender.  This rate of repetition\n   allows\
    \ the application to observe any response (if that is the\n   application's purpose\
    \ for the command) before it is repeated.\n   Possible responses can include initiation\
    \ of data transmission, other\n   NORM_CMD(APPLICATION) messages, or even application-defined,\n\
    \   positively acknowledged commands from other NormSession participants.\n  \
    \ The transmission of these commands will preempt data transmission\n   when they\
    \ are scheduled and can be multiplexed with ongoing data\n   transmission.  This\
    \ type of robustly transmitted command allows NORM\n   applications to define\
    \ a complete set of session control mechanisms\n   with less state than the transfer\
    \ of FEC-encoded reliable content\n   needs while taking advantage of NORM transmission\
    \ and round-trip\n   timing information.\n      0                   1        \
    \           2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |version| type=3|    hdr_len    |          sequence             |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                         source_id                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          instance_id          |     grtt      |backoff| gsize |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     | sub-type\
    \ = 7  |                    reserved                   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                   Application-Defined Content                 |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \              Figure 16: NORM_CMD(APPLICATION) Message Format\n   The NORM common\
    \ message header and NORM_CMD fields are interpreted as\n   previously described.\
    \  The value of the NORM_CMD(APPLICATION)\n   \"hdr_len\" field when no header\
    \ extensions are present is 4.\n   The \"Application-Defined Content\" area contains\
    \ information in a\n   format at the discretion of the application.  The size\
    \ of this\n   payload SHALL be limited to a maximum of the sender's NormSegmentSize\n\
    \   setting.  Upon reception, the NORM protocol implementation SHALL\n   deliver\
    \ the content to the receiver application.  Note that any\n   detection of duplicate\
    \ reception of a NORM_CMD(APPLICATION) message\n   is the responsibility of the\
    \ application.\n"
- title: 4.3.  Receiver Messages
  contents:
  - "4.3.  Receiver Messages\n   The NORM message types generated by participating\
    \ receivers consist\n   of the NORM_NACK and NORM_ACK message types.  NORM_NACK\
    \ messages are\n   sent to request repair of missing data content from sender\n\
    \   transmission, and NORM_ACK messages are generated in response to\n   certain\
    \ sender commands including NORM_CMD(CC) and NORM_CMD(ACK_REQ).\n"
- title: 4.3.1.  NORM_NACK Message
  contents:
  - "4.3.1.  NORM_NACK Message\n   The principal purpose of NORM_NACK messages is\
    \ for receivers to\n   request repair of sender content via selective, negative\n\
    \   acknowledgment upon detection of incomplete data.  NORM_NACK messages\n  \
    \ will be transmitted according to the rules of NORM_NACK generation\n   and suppression\
    \ described in Section 5.3.  NORM_NACK messages also\n   contain additional fields\
    \ to provide feedback to the sender(s) for\n   purposes of round-trip timing collection\
    \ and congestion control.\n   The payload of NORM_NACK messages contains one or\
    \ more repair\n   requests for different objects or portions of those objects.\
    \  The\n   NORM_NACK message format is as follows:\n      0                  \
    \ 1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |version| type=4|    hdr_len    |            sequence           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                         source_id                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                           server_id                           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \         instance_id         |            reserved           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                       grtt_response_sec                       |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                     grtt_response_usec                      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |               header extensions (if applicable)               |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                          nack_payload                         |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 17: NORM_NACK Message Format\n   The NORM common message\
    \ header fields serve their usual purposes.\n   The value of the \"hdr_len\" field\
    \ for NORM_NACK messages without\n   header extensions present is 6.\n   The \"\
    server_id\" field identifies the NORM sender to which the\n   NORM_NACK message\
    \ is destined.\n   The \"instance_id\" field contains the current session identifier\
    \ given\n   by the sender identified by the \"server_id\" field in its sender\n\
    \   messages.  The sender SHOULD ignore feedback messages containing an\n   invalid\
    \ \"instance_id\" value.\n   The \"grtt_response\" fields contain an adjusted\
    \ version of the\n   timestamp from the most recently received NORM_CMD(CC) message\
    \ for\n   the indicated NORM sender.  The format of the \"grtt_response\" is the\n\
    \   same as the \"send_time\" field of the NORM_CMD(CC).  The\n   \"grtt_response\"\
    \ value is relative to the \"send_time\" the source\n   provided with a corresponding\
    \ NORM_CMD(CC) command.  The receiver\n   adjusts the source's NORM_CMD(CC) \"\
    send_time\" timestamp by adding the\n   time delta from when the receiver received\
    \ the NORM_CMD(CC) to when\n   the NORM_NACK is transmitted in response to calculate\
    \ the value in\n   the \"grtt_response\" field.  This is the \"receive_to_response_delta\"\
    \n   value used in the following formula:\n     grtt_response = NORM_CMD(CC) send_time\
    \ + receive_to_response_delta\n   The receiver SHALL set the \"grtt_response\"\
    \ to a ZERO value, to\n   indicate it has not yet received a NORM_CMD(CC) message\
    \ from the\n   indicated sender, and the sender MUST ignore the \"grtt_response\"\
    \ in\n   this message.\n   For NORM-CC operation, the NORM-CC Feedback Header\
    \ Extension, as\n   described in the NORM_CMD(REPAIR_ADV} message description,\
    \ is added\n   to NORM_NACK messages to provide feedback on the receiver's current\n\
    \   state with respect to congestion control operation.  Alternative\n   header\
    \ extensions for congestion control feedback MAY be defined for\n   alternative\
    \ congestion control schemes for NORM use in the future.\n   The \"reserved\"\
    \ field is for potential future NORM use and SHALL be\n   set to ZERO for this\
    \ version of the protocol.\n   The \"nack_payload\" of the NORM_NACK message specifies\
    \ the repair\n   needs of the receiver with respect to the NORM sender indicated\
    \ by\n   the \"server_id\" field.  The receiver constructs repair requests based\n\
    \   on the NORM_DATA and/or NORM_INFO segments it needs from the sender\n   to\
    \ complete reliable reception up to the sender's transmission\n   position at\
    \ the moment the receiver initiates the NACK procedure as\n   described in Section\
    \ 5.3.  A single NORM Repair Request consists of a\n   list of items, ranges,\
    \ and/or FEC coding block erasure counts for\n   needed NORM_DATA and/or NORM_INFO\
    \ content.  Multiple repair requests\n   can be concatenated within the \"nack_payload\"\
    \ field of a NORM_NACK\n   message.  A single NORM Repair Request can possibly\
    \ include multiple\n   \"items\", \"ranges\", or \"erasure_counts\".  In turn,\
    \ the \"nack_payload\"\n   field MAY contain multiple repair requests.  A single\
    \ NORM Repair\n   Request has the following format:\n      0                 \
    \  1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |      form     |     flags     |             length            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                    repair_request_items                     |\n     |      \
    \                       ...                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 18: NORM Repair Request Format\n   The \"form\" field\
    \ indicates the type of repair request items given in\n   the \"repair_request_items\"\
    \ list.  Possible values for the \"form\"\n   field include:\n               \
    \       +--------------------+-------+\n                      | Form         \
    \      | Value |\n                      +--------------------+-------+\n     \
    \                 | NORM_NACK_ITEMS    |   1   |\n                      | NORM_NACK_RANGES\
    \   |   2   |\n                      | NORM_NACK_ERASURES |   3   |\n        \
    \              +--------------------+-------+\n   A \"form\" value of NORM_NACK_ITEMS\
    \ indicates each repair request item\n   in the \"repair_request_items\" list\
    \ is to be treated as an individual\n   request.  A value of NORM_NACK_RANGES\
    \ indicates the\n   \"repair_request_items\" list consists of pairs of repair\
    \ request items\n   corresponding to the inclusive ranges of repair needs.  The\n\
    \   NORM_NACK_ERASURES \"form\" indicates the repair request items are to\n  \
    \ be treated individually and the \"encoding_symbol_id\" portion of the\n   \"\
    fec_payload_id\" field of the repair request item (see below) is to\n   be interpreted\
    \ as an erasure count for the FEC coding block\n   identified by the repair request\
    \ item's \"source_block_number\".\n   The \"flags\" field is currently used to\
    \ indicate the level of data\n   content for which the repair request items apply\
    \ (i.e., an individual\n   segment, entire FEC coding block, or entire transport\
    \ object).\n   Possible flag values include:\n   +-------------------+--------+--------------------------------------+\n\
    \   | Flag              |  Value | Purpose                              |\n  \
    \ +-------------------+--------+--------------------------------------+\n   |\
    \ NORM_NACK_SEGMENT |  0x01  | Indicates the listed segment(s) or   |\n   |  \
    \                 |        | range of segments needed as repair.  |\n   | NORM_NACK_BLOCK\
    \   |  0x02  | Indicates the listed block(s) or     |\n   |                  \
    \ |        | range of blocks in entirety that are |\n   |                   |\
    \        | needed as repair.                    |\n   | NORM_NACK_INFO    |  0x04\
    \  | Indicates NORM_INFO is needed as     |\n   |                   |        |\
    \ repair for the listed object(s).     |\n   | NORM_NACK_OBJECT  |  0x08  | Indicates\
    \ the listed object(s) or    |\n   |                   |        | range of objects\
    \ in entirety are     |\n   |                   |        | needed as repair. \
    \                   |\n   +-------------------+--------+--------------------------------------+\n\
    \   When the NORM_NACK_SEGMENT flag is set, the \"object_transport_id\" and\n\
    \   \"fec_payload_id\" fields are used to determine which sets or ranges of\n\
    \   individual NORM_DATA segments are needed to repair content at the\n   receiver.\
    \  When the NORM_NACK_BLOCK flag is set, this indicates the\n   receiver is completely\
    \ missing the indicated coding block(s), and\n   that transmissions sufficient\
    \ to repair the indicated block(s) in\n   their entirety are needed.  When the\
    \ NORM_NACK_INFO flag is set, this\n   indicates the receiver is missing the NORM_INFO\
    \ segment for the\n   indicated \"object_transport_id\".  Note the NORM_NACK_INFO\
    \ can be set\n   in combination with the NORM_NACK_BLOCK or NORM_NACK_SEGMENT\
    \ flags,\n   or can be set alone.  When the NORM_NACK_OBJECT flag is set, this\n\
    \   indicates the receiver is missing the entire NormTransportObject\n   referenced\
    \ by the \"object_transport_id\".  This also implicitly\n   requests any available\
    \ NORM_INFO for the NormObject, if applicable.\n   The \"fec_payload_id\" field\
    \ is ignored when the flag NORM_NACK_OBJECT\n   is set.\n   The \"length\" field\
    \ value is the length in bytes of the\n   \"repair_request_items\" field.\n  \
    \ The \"repair_request_items\" field consists of a list of individual or\n   range\
    \ pairs of transport data unit identifiers in the following\n   format.\n    \
    \  0                   1                   2                   3\n      0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |     fec_id    |   reserved    |      object_transport_id      |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                      fec_payload_id                         |\n     |      \
    \                        ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 19: NORM Repair Request Item Format\n   The \"fec_id\"\
    \ indicates the FEC type and can be used to determine the\n   format of the \"\
    fec_payload_id\" field.  The \"reserved\" field is kept\n   for possible future\
    \ use and SHALL be set to a ZERO value and ignored\n   by NORM nodes processing\
    \ NACK content.\n   The \"object_transport_id\" corresponds to the NormObject\
    \ for which\n   repair is being requested, and the \"fec_payload_id\" identifies\
    \ the\n   specific FEC coding block and/or segment being requested.  When the\n\
    \   NORM_NACK_OBJECT flag is set, the value of the \"fec_payload_id\" field\n\
    \   is ignored.  When the NORM_NACK_BLOCK flag is set, only the FEC code\n   block\
    \ identifier portion of the \"fec_payload_id\" is to be\n   interpreted.\n   The\
    \ format of the \"fec_payload_id\" field depends upon the \"fec_id\"\n   field\
    \ value.\n   When the receiver's repair needs dictate that different forms (mixed\n\
    \   ranges and/or individual items) or types (mixed specific segments\n   and/or\
    \ blocks or objects in entirety) are needed to complete reliable\n   transmission,\
    \ multiple NORM Repair Requests with different \"form\" and\n   or \"flags\" values\
    \ can be concatenated within a single NORM_NACK\n   message.  Additionally, NORM\
    \ receivers SHALL construct NORM_NACK\n   messages with their repair requests\
    \ in ordinal order with respect to\n   \"object_transport_id\" and \"fec_payload_id\"\
    \ values.  The\n   \"nack_payload\" size SHALL NOT exceed the NormSegmentSize\
    \ for the\n   sender to which the NORM_NACK is destined.\n   NORM_NACK Content\
    \ Examples:\n   In these examples, a small block, systematic FEC code (\"fec_id\"\
    \ =\n   129) is assumed with a user data block length of 32 segments.  In\n  \
    \ Example 1, a list of individual NORM_NACK_ITEMS repair requests is\n   given.\
    \  In Example 2, a list of NORM_NACK_RANGES requests AND a\n   single NORM_NACK_ITEMS\
    \ request are concatenated to illustrate the\n   possible content of a NORM_NACK\
    \ message.  Note that FEC coding block\n   erasure counts could also be provided\
    \ in each case.  However, the\n   erasure counts are not really necessary since\
    \ the sender can easily\n   determine the erasure count while processing the NACK\
    \ content.\n   However, the erasure count option can be useful for operation with\n\
    \   other FEC codes or for intermediate system purposes.\n    Example 1: NORM_NACK\
    \ \"nack_payload\" for: Object 12, Coding Block 3,\n                         \
    \  Segments 2, 5, and 8\n      0                   1                   2     \
    \              3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |   form = 1    | flags = 0x01  |       length  = 36            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  fec_id\
    \ = 129 |   reserved    |    object_transport_id = 12   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                    source_block_number = 3                    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \  source_block_length = 32   |    encoding_symbol_id = 2     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  fec_id = 129 |   reserved    |    object_transport_id = 12   |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                  source_block_number = 3                    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |    source_block_length = 32   |    encoding_symbol_id = 5     |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  fec_id\
    \ = 129 |   reserved    |    object_transport_id = 12   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                    source_block_number = 3                    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \  source_block_length = 32   |    encoding_symbol_id = 8     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    Example 2: NORM_NACK \"nack_payload\" for: Object 18, Coding Block 6,\n \
    \  Segments 5, 6, 7, 8, 9, 10; and Object 19 NORM_INFO and Coding Block\n    \
    \                           1, Segment 3\n      0                   1        \
    \           2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |   form = 2    | flags = 0x01  |       length  = 24            |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  fec_id\
    \ = 129 |   reserved    |    object_transport_id = 18   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                    source_block_number = 6                    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \  source_block_length = 32   |    encoding_symbol_id = 5     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  fec_id = 129 |   reserved    |    object_transport_id = 18   |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                  source_block_number = 6                    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |    source_block_length = 32   |    encoding_symbol_id = 10    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \ form = 1    | flags = 0x05  |       length  = 12            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  fec_id = 129 |   reserved    |    object_transport_id = 19   |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                  source_block_number = 1                    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |    source_block_length = 32   |    encoding_symbol_id = 3     |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.3.2.  NORM_ACK Message
  contents:
  - "4.3.2.  NORM_ACK Message\n   The NORM_ACK message is intended to be used primarily\
    \ as part of NORM\n   congestion control operation and round-trip timing measurement.\
    \  The\n   acknowledgment type NORM_ACK(CC) is provided for this purpose as\n\
    \   described in the NORM_CMD(ACK_REQ) message description.  The\n   generation\
    \ of NORM_ACK(CC) messages for round-trip timing estimation\n   and congestion\
    \ control operation is described in Section 5.5.1 and\n   Section 5.5.2, respectively.\
    \  However, some multicast applications\n   can benefit from some limited form\
    \ of positive acknowledgment for\n   certain functions.  A simple, scalable positive\
    \ acknowledgment scheme\n   is defined in Section 5.5.3, which can be leveraged\
    \ by protocol\n   implementations when appropriate.  The NORM_CMD(FLUSH) can also\
    \ be\n   used for OPTIONAL collection of positive acknowledgment of reliable\n\
    \   reception to a certain \"watermark\" transmission point from specific\n  \
    \ receivers using this mechanism.  The NORM_ACK type NORM_ACK(FLUSH) is\n   provided\
    \ for this purpose and the format of the \"nack_payload\" for\n   this acknowledgment\
    \ type is given below.  Beyond that, a range of\n   application-defined \"ack_type\"\
    \ values is provided for use at the NORM\n   application's discretion.  Implementations\
    \ making use of application-\n   defined positive acknowledgments MAY also make\
    \ use of the\n   \"nack_payload\" as needed, observing the constraint that the\n\
    \   \"nack_payload\" field size be limited to a maximum of the\n   NormSegmentSize\
    \ for the sender to which the NORM_ACK is destined.\n      0                 \
    \  1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |version| type=5|    hdr_len    |          sequence             |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                         source_id                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                           server_id                           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \         instance_id         |    ack_type  |     ack_id     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                       grtt_response_sec                       |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                     grtt_response_usec                      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |               header extensions (if applicable)               |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                   ack_payload (if applicable)                 |\n    \
    \ |                              ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 20: NORM_ACK Message Format\n   The NORM common message\
    \ header fields serve their usual purposes.\n   The value of the \"hdr_len\" field\
    \ when no header extensions are\n   present is 6.\n   The \"server_id\", \"instance_id\"\
    , and \"grtt_response\" fields serve the\n   same purpose as the corresponding\
    \ fields in NORM_NACK messages.\n   Header extensions can be applied to support\
    \ congestion control\n   feedback or other functions in the same manner.\n   The\
    \ \"ack_type\" field indicates the nature of the NORM_ACK message.\n   This directly\
    \ corresponds to the \"ack_type\" field of the\n   NORM_CMD(ACK_REQ) message to\
    \ which this acknowledgment applies.\n   The \"ack_id\" field serves as a sequence\
    \ number so the sender can\n   verify a received NORM_ACK message actually applies\
    \ to a current\n   acknowledgment request.  The \"ack_id\" field is not used in\
    \ the case\n   of the NORM_ACK(CC) and NORM_ACK(FLUSH) acknowledgment types.\n\
    \   The \"ack_payload\" format is a function of the \"ack_type\".  The\n   NORM_ACK(CC)\
    \ message has no attached content.  Only the NORM_ACK\n   header applies.  In\
    \ the case of NORM_ACK(FLUSH), a specific\n   \"ack_payload\" format is defined:\n\
    \      0                   1                   2                   3\n      0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |     fec_id    |   reserved    |      object_transport_id      |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                      fec_payload_id                         |\n     |      \
    \                        ...                              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The \"object_transport_id\" and \"fec_payload_id\" are used by the\n   receiver\
    \ to acknowledge applicable NORM_CMD(FLUSH) messages\n   transmitted by the sender\
    \ identified by the \"server_id\" field.\n   The \"ack_payload\" of NORM_ACK messages\
    \ for application-defined\n   \"ack_type\" values is specific to the application\
    \ but is limited in\n   size to a maximum of the NormSegmentSize of the sender\
    \ referenced by\n   the \"server_id\".\n"
- title: 4.4.  General Purpose Messages
  contents:
  - "4.4.  General Purpose Messages\n   Some additional message formats are defined\
    \ for general purpose in\n   NORM multicast sessions whether the participant is\
    \ acting as a sender\n   and/or receiver within the group.\n"
- title: 4.4.1.  NORM_REPORT Message
  contents:
  - "4.4.1.  NORM_REPORT Message\n   This is an OPTIONAL message generated by NORM\
    \ participants.  This\n   message can be used for periodic performance reports\
    \ from receivers\n   in experimental NORM implementations.  The format of this\
    \ message is\n   currently undefined.  Experimental NORM implementations MAY define\n\
    \   NORM_REPORT formats as needed for test purposes.  These report\n   messages\
    \ SHOULD be disabled for interoperability testing between\n   different compliant\
    \ NORM implementations.\n"
- title: 5.  Detailed Protocol Operation
  contents:
  - "5.  Detailed Protocol Operation\n   This section describes the detailed interactions\
    \ of senders and\n   receivers participating in a NORM session.  A simple synopsis\
    \ of the\n   protocol operation is given here:\n   1.  The sender periodically\
    \ transmits NORM_CMD(CC) messages as needed\n       to initialize and collect\
    \ round-trip timing and congestion\n       control feedback from the receiver\
    \ set.\n   2.  The sender transmits an ordinal set of NormObjects segmented in\n\
    \       the form of NORM_DATA messages labeled with NormTransportIds and\n   \
    \    logically identified with FEC encoding block numbers and symbol\n       identifiers.\
    \  When applicable, NORM_INFO messages MAY optionally\n       precede the transmission\
    \ of data content for NORM transport\n       objects.\n   3.  As receivers detect\
    \ missing content from the sender, they\n       initiate repair requests with\
    \ NORM_NACK messages.  The receivers\n       track the sender's most recent objectTransportId::fecPayloadId\n\
    \       transmit position and NACK only for content that is ordinally\n      \
    \ prior to that current transmit position.  The receivers schedule\n       random\
    \ backoff timeouts before generating NORM_NACK messages and\n       wait an appropriate\
    \ amount of time before repeating the NORM_NACK\n       if their repair request\
    \ is not satisfied.\n   4.  The sender aggregates repair requests from the receivers\
    \ and\n       logically \"rewinds\" its transmit position to send appropriate\n\
    \       repair messages.  The sender sends repairs for the earliest\n       ordinal\
    \ transmit position first and maintains this ordinal repair\n       transmission\
    \ sequence.  FEC parity content not previously\n       transmitted for the applicable\
    \ FEC coding block is used for\n       repair transmissions to the greatest extent\
    \ possible.  If the\n       sender exhausts its available FEC parity content on\
    \ multiple\n       repair cycles for the same coding block, it resorts to an\n\
    \       explicit repair strategy (possibly using parity content) to\n       complete\
    \ repairs.  (The use of explicit repair is an exception in\n       general protocol\
    \ operation, but the possibility does exist for\n       extreme conditions). \
    \ The sender immediately assumes transmission\n       of new content once it has\
    \ sent pending repairs.\n   5.  The sender transmits NORM_CMD(FLUSH) messages\
    \ when it reaches the\n       end of enqueued transmit content and pending repairs.\
    \  Receivers\n       respond to the NORM_CMD(FLUSH) messages with NORM_NACK\n\
    \       transmissions (following the same suppression backoff timeout\n      \
    \ strategy as for data) if they need further repair.\n   6.  The sender transmissions\
    \ are subject to rate control limits\n       determined by congestion control\
    \ mechanisms.  In the baseline\n       NORM-CC operation, each sender in a NormSession\
    \ maintains its own\n       independent congestion control state.  Receivers provide\n\
    \       congestion control feedback in NORM_NACK and NORM_ACK messages.\n    \
    \   NORM_ACK feedback for congestion control purposes is governed\n       using\
    \ a suppression mechanism similar to that for NORM_NACK\n       messages.\n  \
    \ While this overall concept is relatively simple, there are details to\n   each\
    \ of these aspects that need to be addressed for successful,\n   efficient, robust,\
    \ and scalable NORM protocol operation.\n"
- title: 5.1.  Sender Initialization and Transmission
  contents:
  - "5.1.  Sender Initialization and Transmission\n   Upon startup, the NORM sender\
    \ immediately begins sending NORM_CMD(CC)\n   messages to collect round-trip timing\
    \ and other information from the\n   potential group.  If NORM-CC congestion control\
    \ operation is enabled,\n   the NORM-CC Rate header extension MUST be included\
    \ in these messages.\n   Congestion control operation SHALL be observed at all\
    \ times when not\n   operating using dedicated resources, like in the general\
    \ Internet.\n   Even if congestion control operation is disabled at the sender,\
    \ it\n   can be desirable to use the NORM_CMD(CC) messaging to collect\n   feedback\
    \ from the group using the baseline NORM-CC feedback\n   mechanisms.  This proactive\
    \ feedback collection can be used to\n   establish a GRTT estimate prior to data\
    \ transmission and potential\n   NACK operation.\n   In some cases, applications\
    \ might need the sender to also proceed\n   with data transmission immediately.\
    \  In other cases, the sender might\n   wish to defer data transmission until\
    \ it has received some feedback\n   or request from the receiver set indicating\
    \ receivers are indeed\n   present.  Note, in some applications (e.g., web push),\
    \ this\n   indication MAY come out-of-band with respect to the multicast session\n\
    \   via other means.  As noted, the periodic transmission of NORM_CMD(CC)\n  \
    \ messages MAY precede actual data transmission in order to have an\n   initial\
    \ GRTT estimate.\n   With inclusion of the OPTIONAL NORM FEC Object Transmission\n\
    \   Information Header Extension (EXT_FTI), the NORM protocol sender\n   message\
    \ headers can contain all information necessary to prepare\n   receivers for subsequent\
    \ reliable reception.  This includes FEC\n   coding parameters, the sender NormSegmentSize,\
    \ and other information.\n   If this header extension is not used, it is presumed\
    \ receivers have\n   received the FEC Object Transmission Information via other\
    \ means.\n   Additionally, applications MAY leverage the use of NORM_INFO messages\n\
    \   associated with the session data objects in the session to provide\n   application-specific\
    \ context information for the session and data\n   being transmitted.  These mechanisms\
    \ allow for operation with minimal\n   pre-coordination among the senders and\
    \ receivers.\n   The NORM sender begins segmenting application-enqueued data into\n\
    \   NORM_DATA segments and transmitting it to the group.  For objects of\n   type\
    \ NORM_OBJECT_DATA and NORM_OBJECT_FILE, the segmentation\n   algorithm described\
    \ in FEC Building Block [RFC5052] is RECOMMENDED.\n   For objects of type NORM_OBJECT_STREAM,\
    \ segmentation will typically\n   be into uniform FEC coding block sizes, with\
    \ individual segment sizes\n   controlled by the application.  In most cases,\
    \ the application and\n   NORM implementation SHOULD strive to produce full-sized\n\
    \   (NormSegmentSize) segments when possible.  The rate of transmission\n   is\
    \ controlled via congestion control mechanisms or is a fixed rate if\n   desired\
    \ for closed network operations.  The receivers participating\n   in the multicast\
    \ group provide feedback to the sender as needed.\n   When the sender reaches\
    \ the end of data it has enqueued for\n   transmission or any pending repairs,\
    \ it transmits a series of\n   NORM_CMD(FLUSH) messages at a rate of one per 2*GRTT_sender.\
    \  Similar\n   to the end of each transmitted FEC coding block during transmission,\n\
    \   receivers SHALL respond to these NORM_CMD(FLUSH) messages with\n   additional\
    \ repair requests as needed.  A protocol parameter\n   NORM_ROBUST_FACTOR determines\
    \ the number of flush messages sent.  If\n   receivers request repair, the repair\
    \ is provided, and flushing occurs\n   again at the end of repair transmission.\
    \  The sender MAY attach an\n   OPTIONAL \"acking_node_list\" to NORM_CMD(FLUSH)\
    \ containing the\n   NormNodeIds for receivers from which it expects explicit\
    \ positive\n   acknowledgment of reception.  The NORM_CMD(FLUSH) message MAY be\
    \ also\n   used for this OPTIONAL purpose any time prior to the end of data\n\
    \   enqueued for transmission with the NORM_CMD(FLUSH) messages\n   multiplexed\
    \ with ongoing data transmissions.  The OPTIONAL NORM\n   positive acknowledgment\
    \ procedure is described in Section 5.5.3.\n"
- title: 5.1.1.  Object Segmentation Algorithm
  contents:
  - "5.1.1.  Object Segmentation Algorithm\n   NORM senders and receivers MUST use\
    \ a common algorithm for logically\n   segmenting transport data into FEC encoding\
    \ blocks and symbols so\n   appropriate NACKs can be constructed to request repair\
    \ of missing\n   data.  NORM FEC coding blocks are comprised of multi-byte symbols\n\
    \   (segments) transmitted in the payload of NORM_DATA messages.  Each\n   NORM_DATA\
    \ message will contain one or more source or encoding symbols\n   identified by\
    \ the \"fec_payload_id\" field, and the NormSegmentSize\n   sender parameter defines\
    \ the maximum size (in bytes) of the\n   \"payload_data\" field containing the\
    \ content (a \"segment\").  The FEC\n   encoding type and associated parameters\
    \ govern the source block size\n   (number of source symbols per coding block,\
    \ etc.).  NORM senders and\n   receivers use these FEC parameters, along with\
    \ the NormSegmentSize\n   and transport object size to compute the source block\
    \ structure for\n   transport objects.  These parameters are provided in the FEC\
    \ Object\n   Transmission Information for each object.  The block partitioning\n\
    \   algorithm described in the FEC Building Block [RFC5052] document is\n   RECOMMENDED\
    \ for use in computing a source block structure such that\n   all source blocks\
    \ are as close to being equal length as possible.\n   This helps avoid the performance\
    \ disadvantages of \"short\" FEC blocks.\n   Note that this algorithm applies\
    \ only to the statically sized\n   NORM_OBJECT_DATA and NORM_OBJECT_FILE transport\
    \ object types where\n   the object size is fixed and predetermined.  For NORM_OBJECT_STREAM\n\
    \   objects, the object is segmented according to the maximum source\n   block\
    \ length given in the FEC Transmission Information, unless the\n   FEC Payload\
    \ ID indicates an alternative size for a given block.\n"
- title: 5.2.  Receiver Initialization and Reception
  contents:
  - "5.2.  Receiver Initialization and Reception\n   For typical operation, NORM receivers\
    \ will join a specified multicast\n   group and listen on a specific port number\
    \ for sender transmissions.\n   As the NORM receiver receives NORM_DATA messages,\
    \ it will establish\n   buffering state and provide content to its application\
    \ as appropriate\n   for the given data type.  The NORM protocol allows receivers\
    \ to join\n   and leave the group at will, although some applications might need\n\
    \   receivers to be members of the group prior to start of data\n   transmission.\
    \  Thus, different NORM applications MAY use different\n   policies to constrain\
    \ the impact of new receivers joining the group\n   in the middle of a session.\
    \  For example, a useful implementation\n   policy is for new receivers joining\
    \ the group to limit or avoid\n   repair requests for transport objects already\
    \ in progress.  The NORM\n   sender implementation MAY impose additional constraints\
    \ to limit the\n   ability of receivers to disrupt reliable multicast performance\
    \ by\n   joining, leaving, and rejoining the group often.  Different receiver\n\
    \   \"join policies\" might be appropriate for different applications\n   and/or\
    \ scenarios.  For general purpose operation, a default policy\n   where receivers\
    \ are allowed to request repair only for coding blocks\n   with a NormTransportId\
    \ and FEC coding block number greater than or\n   equal to the first non-repair\
    \ NORM_DATA or NORM_INFO message received\n   upon joining the group is RECOMMENDED.\
    \  For objects of type\n   NORM_OBJECT_STREAM, it is RECOMMENDED the join policy\
    \ constrain\n   receivers to begin reliable reception at the current FEC coding\
    \ block\n   for which non-repair content is received.\n   In some deployments,\
    \ different multicast receivers might have\n   differing quality of network connectivity.\
    \  Some receivers may suffer\n   significantly poorer performance with very limited\
    \ goodput due to low\n   connection rate or substantial packet loss.  Similar\
    \ to the \"join\n   policies\" described above, a NORM sender implementation MAY\
    \ choose to\n   enforce different \"service policies\" to perhaps exclude exceptionally\n\
    \   poorly performing (or otherwise badly behaving) receivers from the\n   group.\
    \  The sender implementation could choose to ignore NACKs from\n   such receivers\
    \ and/or force advancement of its logical \"repair\n   window\" (i.e., enforcing\
    \ a minimal level of service) and use the\n   NORM_CMD(SQUELCH) message to advise\
    \ those poor performers of its\n   advance.  Note in some cases, the application\
    \ may need to support the\n   \"weakest member\" regardless of the time needed\
    \ to achieve reliable\n   delivery.  When implemented, the protocol instantiation\
    \ SHOULD expose\n   controls to the set of \"join\" and/or \"service\" policies\
    \ available to\n   support the needs of different applications.\n"
- title: 5.3.  Receiver NACK Procedure
  contents:
  - "5.3.  Receiver NACK Procedure\n   When the receiver detects it is missing data\
    \ from a sender's NORM\n   transmissions, it initiates its NACKing procedure.\
    \  The NACKing\n   procedure SHALL be initiated only at FEC coding block boundaries,\n\
    \   NormObject boundaries, upon receipt of a NORM_CMD(FLUSH) message, or\n   upon\
    \ an \"inactivity\" timeout when NORM_DATA or NORM_INFO\n   transmissions are\
    \ no longer received from a previously active sender.\n   The RECOMMENDED value\
    \ of such an inactivity timeout is:\n            T_inactivity = NORM_ROBUST_FACTOR\
    \ * 2 * GRTT_sender\n   where the GRTT_sender value corresponds to the GRTT estimate\n\
    \   advertised in the \"grtt\" field of NORM sender messages.  A minimum\n   T_inactivity\
    \ value of 1 second is RECOMMENDED.  The NORM receiver\n   SHOULD reset this inactivity\
    \ timer and repeat NACK initiation upon\n   timeout for up to NORM_ROBUST_FACTOR\
    \ times or more depending upon the\n   application's need for persistence by its\
    \ receivers.  It is also\n   important receivers rescale the T_inactivity timeout\
    \ as the sender's\n   advertised GRTT changes.\n   The NACKing procedure begins\
    \ with a random backoff timeout.  The\n   duration of the backoff timeout is chosen\
    \ using the \"RandomBackoff\"\n   algorithm described in the Multicast NACK Building\
    \ Block [RFC5401]\n   document using (K_sender*GRTT_sender) for the maxTime parameter\
    \ and\n   the sender advertised group size (GSIZE_sender) as the groupSize\n \
    \  parameter.  NORM senders provide values for GRTT_sender, K_sender and\n   GSIZE_sender\
    \ via the \"grtt\", \"backoff\", and \"gsize\" fields of\n   transmitted messages.\
    \  The GRTT_sender value is determined by the\n   sender based on feedback it\
    \ has received from the group while the\n   K_sender and GSIZE_sender values can\
    \ be determined by application\n   requirements and expectations or ancillary\
    \ information.  The backoff\n   factor K_sender MUST be greater than one to provide\
    \ for effective\n   feedback suppression.  A value of K_sender = 4 is RECOMMENDED\
    \ for the\n   Any Source Multicast (ASM) model, while a value of K_sender = 6\
    \ is\n   RECOMMENDED for Single Source Multicast (SSM) operation.\n   Thus:\n\
    \       T_backoff = RandomBackoff(K_sender*GRTT_sender, GSIZE_sender)\n   To avoid\
    \ the possibility of NACK implosion in the case of sender or\n   network failure\
    \ during SSM operation, the receiver SHALL\n   automatically suppress its NACK\
    \ and immediately enter the \"holdoff\"\n   period described below when T_backoff\
    \ is greater than (K_sender-\n   1)*GRTT_sender.  Otherwise, the backoff period\
    \ is entered and the\n   receiver MUST accumulate external pending repair state\
    \ from NORM_NACK\n   messages and NORM_CMD(REPAIR_ADV) messages received.  At\
    \ the end of\n   the backoff time, the receiver SHALL generate a NORM_NACK message\n\
    \   only if the following conditions are met:\n   1.  The sender's current transmit\
    \ position (in terms of\n       objectTransportId::fecPayloadId) exceeds the earliest\
    \ repair\n       position of the receiver.\n   2.  The repair state accumulated\
    \ from NORM_NACK and\n       NORM_CMD(REPAIR_ADV) messages does not equal or supersede\
    \ the\n       receiver's repair needs up to the sender transmission position at\n\
    \       the time the NACK procedure (backoff timeout) was initiated.\n   If these\
    \ conditions are met, the receiver immediately generates a\n   NORM_NACK message\
    \ when the backoff timeout expires.  Otherwise, the\n   receiver's NACK is considered\
    \ to be \"suppressed\" and the message is\n   not sent.  At this time, the receiver\
    \ begins a \"holdoff\" period\n   during which it constrains itself to not re-initiate\
    \ the NACKing\n   process.  The purpose of this timeout is to allow the sender\
    \ worst-\n   case time to respond to the repair needs before the receiver requests\n\
    \   repair again.  The value of this \"holdoff\" timeout (T_rcvrHoldoff) as\n\
    \   described in [RFC5401] is:\n                  T_rcvrHoldoff =(K_sender+2)*GRTT_sender\n\
    \   The NORM_NACK message contains repair request content beginning with\n   the\
    \ lowest ordinal repair position of the receiver up through the\n   coding block\
    \ prior to the most recently heard ordinal transmission\n   position for the sender.\
    \  If the size of the NORM_NACK content\n   exceeds the sender's NormSegmentSize,\
    \ the NACK content is truncated\n   so the receiver only generates a single NORM_NACK\
    \ message per NACK\n   cycle for a given sender.  In summary, a single NACK message\
    \ is\n   generated containing the receiver's lowest ordinal repair needs.\n  \
    \ For each partially received FEC coding block requiring repair, the\n   receiver\
    \ SHALL, on its FIRST repair attempt for the block, request\n   the parity portion\
    \ of the FEC coding block beginning with the lowest\n   ordinal parity \"encoding_symbol_id\"\
    \ (i.e., \"encoding_symbol_id\" =\n   \"source_block_len\") and request the number\
    \ of FEC symbols\n   corresponding to its data segment erasure count for the block.\
    \  On\n   subsequent repair cycles for the same coding block, the receiver\n \
    \  SHALL request only those repair symbols from the first set it has not\n   yet\
    \ received up to the remaining erasure count for that applicable\n   coding block.\
    \  Note the sender might have transmitted other\n   different, additional parity\
    \ segments for other receivers that could\n   also be used to satisfy the local\
    \ receiver's erasure-filling needs.\n   In the case where the erasure count for\
    \ a partially received FEC\n   coding block exceeds the maximum number of parity\
    \ symbols available\n   from the sender for the block (as indicated by the NORM_DATA\n\
    \   \"fec_num_parity\" field), the receiver SHALL request all available\n   parity\
    \ segments plus the ordinally highest missing data segments\n   needed to satisfy\
    \ its total erasure needs for the block.  The goal of\n   this strategy is for\
    \ the overall receiver set to request a lowest\n   common denominator set of repair\
    \ symbols for a given FEC coding\n   block.  This allows the sender to construct\
    \ the most efficient repair\n   transmission segment set and enables effective\
    \ NACK suppression among\n   the receivers even with uncorrelated packet loss.\
    \  This approach also\n   does not demand synchronization among the receiver set\
    \ in their\n   repair requests for the sender.\n   For FEC coding blocks or NormObjects\
    \ missed in their entirety, the\n   NORM receiver constructs repair requests with\
    \ NORM_NACK_BLOCK or\n   NORM_NACK_OBJECT flags set as appropriate.  The request\
    \ for\n   retransmission of NORM_INFO is accomplished by setting the\n   NORM_NACK_INFO\
    \ flag in a corresponding repair request.\n"
- title: 5.4.  Sender NACK Processing and Response
  contents:
  - "5.4.  Sender NACK Processing and Response\n   The principal goal of the sender\
    \ is to make forward progress in the\n   transmission of data its application\
    \ has enqueued.  However, the\n   sender will need to occasionally \"rewind\"\
    \ its logical transmission\n   point to satisfy the repair needs of receivers\
    \ who have NACKed.\n   Aggregation of multiple NACKs is used to determine an optimal\
    \ repair\n   strategy when a NACK event occurs.  Since receivers initiate the\
    \ NACK\n   process on coding block or object boundaries, there is some loose\n\
    \   degree of synchronization of the repair process even when receivers\n   experience\
    \ uncorrelated data loss.\n"
- title: 5.4.1.  Sender Repair State Aggregation
  contents:
  - "5.4.1.  Sender Repair State Aggregation\n   When a sender is in its normal state\
    \ of transmitting new data and\n   receives a NACK, it begins a procedure to accumulate\
    \ NACK repair\n   state from NORM_NACK messages before beginning repair transmissions.\n\
    \   Note that this period of aggregating repair state does NOT interfere\n   with\
    \ its ongoing transmission of new data.\n   As described in [RFC5401], the period\
    \ of time during which the sender\n   aggregates NORM_NACK messages is equal to:\n\
    \               T_sndrAggregate = (K_sender + 1) * GRTT_sender\n   where K_sender\
    \ is the backoff scaling value advertised to the\n   receivers, and GRTT_sender\
    \ is the sender's current estimate of the\n   group's greatest round-trip time.\
    \  Note, for NORM unicast sessions,\n   the T_sndrAggregate time can be set to\
    \ ZERO since there is only one\n   receiver.  Similarly, the K_sender value SHOULD\
    \ be set to ZERO for\n   NORM unicast sessions to minimize repair latency.\n \
    \  When this period ends, the sender \"rewinds\" by incorporating the\n   accumulated\
    \ repair state into its pending transmission state and\n   begins transmitting\
    \ repair messages.  After pending repair\n   transmissions are completed, the\
    \ sender continues with new\n   transmissions of any enqueued data.  Also, at\
    \ this point in time, the\n   sender begins a \"holdoff\" timeout during which\
    \ time the sender\n   constrains itself from initiating a new repair aggregation\
    \ cycle,\n   even if NORM_NACK messages arrive.  As described in [RFC5401], the\n\
    \   value of this sender \"holdoff\" period is:\n                     T_sndrHoldoff\
    \ = (1 * GRTT_sender)\n   If additional NORM_NACK messages are received during\
    \ this sender\n   \"holdoff\" period, the sender will immediately incorporate\
    \ these late-\n   arriving messages into its pending transmission state if, and\
    \ only\n   if, the NACK content is ordinally greater than the sender's current\n\
    \   transmission position.  This \"holdoff\" time allows worst-case time\n   for\
    \ the sender to propagate its current transmission sequence\n   position to the\
    \ group, thus avoiding redundant repair transmissions.\n   After the holdoff timeout\
    \ expires, a new NACK accumulation period can\n   be started (upon arrival of\
    \ a NACK) in concert with the pending\n   repair and new data transmission.  Recall\
    \ receivers are not to\n   initiate the NACK repair process until the sender's\
    \ logical\n   transmission position exceeds the lowest ordinal position of their\n\
    \   repair needs.  With the new NACK aggregation period, the sender\n   repeats\
    \ the same process of incorporating accumulated repair state\n   into its transmission\
    \ plan and subsequently \"rewinding\" to transmit\n   the lowest ordinal repair\
    \ data when the aggregation period expires.\n   Again, this is conducted in concert\
    \ with ongoing new data and/or\n   pending repair transmissions.\n"
- title: 5.4.2.  Sender FEC Repair Transmission Strategy
  contents:
  - "5.4.2.  Sender FEC Repair Transmission Strategy\n   The NORM sender SHOULD leverage\
    \ transmission of FEC parity content\n   for repair to the greatest extent possible.\
    \  Recall that receivers\n   use a strategy to request a lowest common denominator\
    \ of explicit\n   repair (including parity content) in the formation of their\
    \ NORM_NACK\n   messages.  Before falling back to explicitly satisfying different\n\
    \   receivers' repair needs, the sender can make use of the general\n   erasure-filling\
    \ capability of FEC-generated parity segments.  The\n   sender can determine the\
    \ maximum erasure-filling needs for individual\n   FEC coding blocks from the\
    \ NORM_NACK messages received during the\n   repair aggregation period.  Then,\
    \ if the sender has a sufficient\n   number (less than or equal to the maximum\
    \ erasure count) of\n   previously unsent parity segments available for the applicable\
    \ coding\n   blocks, the sender can transmit these in lieu of the specific packets\n\
    \   the receiver set has requested.  The sender SHOULD NOT resort to\n   explicit\
    \ transmission of the receiver set's repair needs until after\n   exhausting its\
    \ supply of \"fresh\" (unsent) parity segments for a given\n   coding block. \
    \ In general, if a sufficiently powerful FEC code is\n   used, the need for explicit\
    \ repair will be an exception, and the\n   fulfillment of reliable multicast can\
    \ be accomplished quite\n   efficiently.  However, the ability to resort to explicit\
    \ repair\n   allows the protocol to be continue to operate under even very extreme\n\
    \   circumstances.\n   NORM_DATA messages sent as repair transmissions SHALL be\
    \ flagged with\n   the NORM_FLAG_REPAIR flag.  This allows receivers to obey any\n\
    \   policies limiting new receivers from joining the reliable\n   transmission\
    \ when only repair transmissions have been received.\n   Additionally, the sender\
    \ SHOULD flag NORM_DATA transmissions sent as\n   explicit repair with the NORM_FLAG_EXPLICIT\
    \ flag.\n   Although NORM end system receivers do not make use of the\n   NORM_FLAG_EXPLICIT\
    \ flag, this message transmission status could be\n   leveraged by intermediate\
    \ systems wishing to \"assist\" NORM protocol\n   performance.  If such systems\
    \ are properly positioned with respect to\n   reciprocal reverse-path multicast\
    \ routing, they need to sub-cast only\n   a sufficient count of non-explicit parity\
    \ repairs to satisfy a\n   multicast routing sub-tree's erasure-filling needs\
    \ for a given FEC\n   coding block.  When the sender has resorted to explicit\
    \ repair, then\n   the intermediate systems SHOULD sub-cast all of the explicit\
    \ repair\n   packets to those portions of the routing tree still requiring repair\n\
    \   for a given coding block.  Note the intermediate systems will need to\n  \
    \ conduct repair state accumulation for sub-routes in a manner similar\n   to\
    \ the sender's repair state accumulation in order to have sufficient\n   information\
    \ to perform the sub-casting.  Additionally, the\n   intermediate systems could\
    \ perform NORM_NACK suppression/aggregation\n   as it conducts this repair state\
    \ accumulation for NORM repair cycles.\n   The details of this type of operation\
    \ are beyond the scope of this\n   document, but this information is provided\
    \ for possible future\n   consideration.\n"
- title: 5.4.3.  Sender NORM_CMD(SQUELCH) Generation
  contents:
  - "5.4.3.  Sender NORM_CMD(SQUELCH) Generation\n   If the sender receives a NORM_NACK\
    \ message for repair of data it is\n   no longer supporting, the sender generates\
    \ a NORM_CMD(SQUELCH)\n   message to advertise its repair window and squelch any\
    \ receivers from\n   additional NACKing of invalid data.  The transmission rate\
    \ of\n   NORM_CMD(SQUELCH) messages is limited to once per 2*GRTT_sender.  The\n\
    \   \"invalid_object_list\" (if applicable) of the NORM_CMD(SQUELCH)\n   message\
    \ SHALL begin with the lowest \"object_transport_id\" from the\n   invalid NORM_NACK\
    \ messages received since the last NORM_CMD(SQUELCH)\n   transmission.  The list\
    \ includes as many lower ordinal invalid\n   \"object_transport_ids\" that can\
    \ fit for the NORM_CMD(SQUELCH) payload\n   size to less than or equal to the\
    \ sender's NormSegmentSize parameter.\n"
- title: 5.4.4.  Sender NORM_CMD(REPAIR_ADV) Generation
  contents:
  - "5.4.4.  Sender NORM_CMD(REPAIR_ADV) Generation\n   When a NORM sender receives\
    \ NORM_NACK messages from receivers via\n   unicast transmission, it uses NORM_CMD(REPAIR_ADV)\
    \ messages to\n   advertise its accumulated repair state to the receiver set since\
    \ the\n   receiver set is not directly sharing their repair needs via multicast\n\
    \   communication.  A NORM sender implementation MAY use a separate port\n   number\
    \ from the NormSession port number as the source port for its\n   transmissions.\
    \  Thus, NORM receivers can direct any unicast feedback\n   messages to this separate\
    \ sender port number, distinct from the NORM\n   session (or destination) port\
    \ number.  Then, the NORM sender\n   implementation can discriminate unicast feedback\
    \ messages from\n   multicast feedback messages when there is a mix of multicast\
    \ and\n   unicast feedback receivers.  The NORM_CMD(REPAIR_ADV) message is\n \
    \  multicast to the receiver set by the sender.  The payload portion of\n   this\
    \ message has content in the same format as the NORM_NACK receiver\n   message\
    \ payload.  Receivers are then able to perform feedback\n   suppression in the\
    \ same manner as with NORM_NACK messages directly\n   received from other receivers.\
    \  Note that the sender does not merely\n   retransmit NACK content it receives,\
    \ but instead transmits a\n   representation of its aggregated repair state. \
    \ The transmission of\n   NORM_CMD(REPAIR_ADV) messages is subject to the sender\
    \ transmit rate\n   limit and NormSegmentSize limitation.  When the NORM_CMD(REPAIR_ADV)\n\
    \   message is of maximum size (as indicated by the flag\n   NORM_REPAIR_ADV_FLAG_LIMIT),\
    \ receivers SHALL consider the maximum\n   ordinal transmission position value\
    \ embedded in the message as the\n   senders current transmission position and\
    \ implicitly suppress\n   requests for ordinally higher repair.  For congestion\
    \ control\n   operation, the sender will also need to provide any information\n\
    \   needed so dynamic congestion control feedback can be suppressed among\n  \
    \ receivers.  This document specifies the NORM-CC Feedback Header\n   Extension\
    \ that is applied for baseline NORM-CC operation.  If other\n   congestion control\
    \ mechanisms are used within a NORM implementation,\n   other header extensions\
    \ MAY be defined.  Whatever content format is\n   used for this purpose SHOULD\
    \ ensure that maximum possible suppression\n   state is conveyed to the receiver\
    \ set.\n"
- title: 5.5.  Additional Protocol Mechanisms
  contents:
  - "5.5.  Additional Protocol Mechanisms\n   In addition to the principal function\
    \ of data content transmission\n   and repair, there are some other protocol mechanisms\
    \ to help NORM to\n   adapt to network conditions and play fairly with other coexistent\n\
    \   protocols.\n"
- title: 5.5.1.  Group Round-Trip Time (GRTT) Collection
  contents:
  - "5.5.1.  Group Round-Trip Time (GRTT) Collection\n   For NORM receivers to appropriately\
    \ scale backoff timeouts and the\n   senders to use proper corresponding timeouts,\
    \ the participants need\n   to use a common timeout basis.  Each NORM sender monitors\
    \ the round-\n   trip time of active receivers and determines the greatest group\n\
    \   round-trip time.  The sender advertises this GRTT estimate in every\n   message\
    \ it transmits so receivers have this value available for\n   scaling their timers.\
    \  To measure the current GRTT, the sender\n   periodically sends NORM_CMD(CC)\
    \ messages containing a locally\n   generated timestamp.  Receivers are expected\
    \ to record this timestamp\n   along with the time the NORM_CMD(CC) message is\
    \ received.  Then, when\n   the receivers generate feedback messages to the sender,\
    \ an adjusted\n   version of the sender timestamp is embedded in the feedback\
    \ message\n   (NORM_NACK or NORM_ACK).  The adjustment adds the amount of time\
    \ the\n   receiver held the timestamp before generating its response.  Upon\n\
    \   receipt of this adjusted timestamp, the sender is able to calculate\n   the\
    \ round-trip time to that receiver.\n   The round-trip time for each receiver\
    \ is fed into an algorithm that\n   assigns weights and smoothes the values for\
    \ a conservative estimate\n   of the GRTT.  The algorithm and methodology are\
    \ described in the\n   Multicast NACK Building Block [RFC5401] document in the\
    \ section\n   entitled \"One-to-Many Sender GRTT Measurement\".  A conservative\n\
    \   estimate helps guarantee feedback suppression at a small cost in\n   overall\
    \ protocol repair delay.  The sender's current estimate of GRTT\n   is advertised\
    \ in the \"grtt\" field found in all NORM sender messages.\n   The advertised\
    \ GRTT is also limited to a minimum of the nominal\n   inter-packet transmission\
    \ time given the sender's current\n   transmission rate and system clock granularity.\
    \  The reason for this\n   additional limit is to keep the receiver somewhat event-driven\
    \ by\n   making sure the sender has had adequate time to generate any response\n\
    \   to repair requests from receivers given transmit rate limitations due\n  \
    \ to congestion control or configuration.\n   When the NORM-CC Rate header extension\
    \ is present in NORM_CMD(CC)\n   messages, the receivers respond to NORM_CMD(CC)\
    \ messages as described\n   in Section 5.5.2, \"NORM Congestion Control Operation\"\
    .  The\n   NORM_CMD(CC) messages are periodically generated by the sender as\n\
    \   described for congestion control operation.  This provides for\n   proactive,\
    \ but controlled, feedback from the group in the form of\n   NORM_ACK messages.\
    \  This provides for GRTT feedback even if no\n   NORM_NACK messages are being\
    \ sent.  If operating without congestion\n   control in a closed network, the\
    \ NORM_CMD(CC) messages MAY be sent\n   periodically without the NORM-CC Rate\
    \ header extension.  In this\n   case, receivers will only provide GRTT measurement\
    \ feedback when\n   NORM_NACK messages are generated since no NORM_ACK messages\
    \ are\n   generated.  In this case, the NORM_CMD(CC) messages MAY be sent less\n\
    \   frequently, perhaps as little as once per minute, to conserve network\n  \
    \ capacity.  Note the NORM-CC Rate header extension MAY also be used to\n   proactively\
    \ solicit RTT feedback from the receiver group per\n   congestion control operation\
    \ even when the sender is not conducting\n   congestion control rate adjustment.\
    \  NORM operation without\n   congestion control SHOULD be considered only in\
    \ closed networks.\n"
- title: 5.5.2.  NORM Congestion Control Operation
  contents:
  - "5.5.2.  NORM Congestion Control Operation\n   This section describes baseline\
    \ congestion control operation for the\n   NORM protocol (NORM-CC).  The supporting\
    \ NORM message formats and\n   approach described here are an adaptation of the\
    \ equation-based TCP-\n   Friendly Multicast Congestion Control (TFMCC) approach\
    \ [RFC4654].\n   This congestion control scheme is REQUIRED for operation within\
    \ the\n   general Internet unless the NORM implementation is adapted to use\n\
    \   another IETF-sanctioned reliable multicast congestion control\n   mechanism.\
    \  With this TFMCC-based approach, the transmissions of NORM\n   senders are controlled\
    \ in a rate-based manner as opposed to window-\n   based congestion control algorithms\
    \ as in TCP.  However, it is\n   possible the NORM protocol message set MAY alternatively\
    \ be used to\n   support a window-based multicast congestion control scheme such\
    \ as\n   PGMCC.  The details of such an alternative MAY be described\n   separately\
    \ or in a future revision of this document.  In either case\n   (rate-based TFMCC\
    \ or window-based PGMCC), successful control of\n   sender transmission depends\
    \ upon collection of sender-to-receiver\n   packet loss estimates and RTTs to\
    \ identify the congestion control\n   bottleneck path(s) within the multicast\
    \ topology and adjust the\n   sender rate accordingly.  The receiver with loss\
    \ and RTT estimates\n   corresponding to the lowest resulting calculated transmission\
    \ rate is\n   identified as the \"current limiting receiver\" (CLR).  In the case\
    \ of\n   a tie (where candidate CLRs are within 10% of the same calculated\n \
    \  rate), the receiver with the largest RTT value SHOULD be designated\n   as\
    \ the CLR.\n   As described in [TcpModel], a steady-state sender transmission\
    \ rate,\n   to be \"friendly\" with competing TCP flows, can be calculated as:\n\
    \                                    S\n   Rsender = ----------------------------------------------------------\n\
    \           T_rtt*(sqrt((2/3)*p) + 12*sqrt((3/8)*p) * p * (1 + 32*(p^2)))\n  \
    \ where\n   S = nominal transmitted packet size.  (In NORM, the \"nominal\" packet\n\
    \   size can be determined by the sender as an exponentially weighted\n   moving\
    \ average (EWMA) of transmitted packet sizes to account for\n   variable message\
    \ sizes).\n   T_rtt = RTT estimate of the current \"current limiting receiver\"\
    \n   (CLR).\n   p = loss event fraction of the CLR.\n   To support congestion\
    \ control feedback collection and operation, the\n   NORM sender periodically\
    \ transmits NORM_CMD(CC) command messages.\n   NORM_CMD(CC) messages are multiplexed\
    \ with NORM data and repair\n   transmissions and serve several purposes, they:\n\
    \   1.  Stimulate explicit feedback from the general receiver set to\n       collect\
    \ congestion control information.\n   2.  Communicate state to the receiver set\
    \ on the sender's current\n       congestion control status including details\
    \ of the CLR.\n   3.  Initiate rapid (immediate) feedback from the CLR in order\
    \ to\n       closely track the dynamics of congestion control for the current\n\
    \       worst path in the group multicast topology.\n   The format of the NORM_CMD(CC)\
    \ message is described in Section 4.2.3\n   of this document.  The NORM_CMD(CC)\
    \ message contains information to\n   allow measurement of RTTs, to inform the\
    \ group of the congestion\n   control CLR, and to provide feedback of individual\
    \ RTT measurements\n   to the receivers in the group.  The NORM_CMD(CC) also provides\
    \ for\n   exciting feedback from OPTIONAL \"potential limiting receiver\" (PLR)\n\
    \   nodes that might be determined administratively or possibly\n   algorithmically\
    \ based upon congestion control feedback.  PLR nodes\n   are receivers that have\
    \ been identified to have potential for\n   (perhaps soon) becoming the CLR and\
    \ thus immediate, up-to-date\n   feedback is beneficial for congestion control\
    \ performance.  The PLR\n   list MAY be populated with a small number of receivers\
    \ the sender\n   identifies as approaching the CLR loss and delay conditions based\
    \ on\n   feedback from the group.\n"
- title: 5.5.2.1.  NORM_CMD(CC) Transmission
  contents:
  - "5.5.2.1.  NORM_CMD(CC) Transmission\n   The NORM_CMD(CC) message is transmitted\
    \ periodically by the sender\n   along with its normal data transmission.  Note\
    \ the repeated\n   transmission of NORM_CMD(CC) messages MAY be initiated some\
    \ time\n   before transmission of user data content at session startup.  This\n\
    \   can be done to collect some estimation of the current state of the\n   multicast\
    \ topology with respect to group and individual RTT and\n   congestion control\
    \ state.\n   A NORM_CMD(CC) message is immediately transmitted at sender startup.\n\
    \   The interval of subsequent NORM_CMD(CC) message transmission is\n   determined\
    \ as follows:\n   1.  By default, the interval is set according to the current\
    \ sender\n       GRTT estimate.  A startup initial value of GRTT_sender = 0.5\n\
    \       seconds is RECOMMENDED when no feedback has yet been received\n      \
    \ from the group.\n   2.  Until a CLR has been identified (based on previous receiver\n\
    \       feedback) or when no data transmission is pending, the\n       NORM_CMD(CC)\
    \ interval is doubled up from its current interval to\n       a maximum of once\
    \ per 30 seconds.  This results in a low duty\n       cycle for NORM_CMD(CC) probing\
    \ when no CLR is identified or there\n       is no pending data to transmit.\n\
    \   3.  When a CLR has been identified (based on receiver feedback) and\n    \
    \   data transmission is pending, the probing interval is set to the\n       RTT\
    \ between the sender and the CLR (RTT_clr).\n   4.  Additionally, when the data\
    \ transmission rate is low with respect\n       to the RTT_clr interval used for\
    \ probing, the implementation\n       SHOULD ensure no more than one NORM_CMD(CC)\
    \ message is sent per\n       NORM_DATA message when there is data pending transmission.\
    \  This\n       ensures the transmission of this control message is not done to\n\
    \       the exclusion of user data transmission.\n   The NORM_CMD(CC) \"cc_sequence\"\
    \ field is incremented with each\n   transmission of a NORM_CMD(CC) command. \
    \ The greatest \"cc_sequence\"\n   recently received by receivers is included\
    \ in their feedback to the\n   sender.  This allows the sender to determine the\
    \ age of feedback to\n   assist in congestion avoidance.\n   The NORM-CC Rate\
    \ Header Extension is applied to the NORM_CMD(CC)\n   message and the sender advertises\
    \ its current transmission rate in\n   the \"send_rate\" field.  The rate information\
    \ is used by receivers to\n   initialize loss estimation during congestion control\
    \ startup or\n   restart.\n   The \"cc_node_list\" contains a list of entries\
    \ identifying receivers\n   and their current congestion control state (status\
    \ \"flags\", \"rtt\",\n   and \"loss\" estimates).  The list will be empty if\
    \ the sender has not\n   yet received any feedback from the group.  If the sender\
    \ has received\n   feedback, the list will minimally contain an entry identifying\
    \ the\n   CLR.  A NORM_FLAG_CC_CLR flag value is provided for the \"cc_flags\"\
    \n   field to identify the CLR entry.  It is RECOMMENDED the CLR entry be\n  \
    \ the first in the list for implementation efficiency.  Additional\n   entries\
    \ in the list are used to provide sender-measured individual\n   RTT estimates\
    \ to receivers in the group.  The number of additional\n   entries in this list\
    \ is dependent upon the percentage of control\n   traffic the sender application\
    \ is willing to send with respect to\n   user data message transmissions.  More\
    \ entries in the list will allow\n   the sender to be more responsive to congestion\
    \ control dynamics.  The\n   length of the list can be dynamically determined\
    \ according to the\n   current transmission rate and scheduling of NORM_CMD(CC)\
    \ messages.\n   The maximum length of the list corresponds to the sender's\n \
    \  NormSegmentSize parameter for the session.  The inclusion of\n   additional\
    \ entries in the list based on receiver feedback is\n   prioritized with the following\
    \ rules:\n   1.  Receivers that have not yet been provided an RTT measurement\
    \ get\n       first priority.  Of these, those with the greatest loss fraction\n\
    \       receive precedence for list inclusion.\n   2.  Secondly, receivers that\
    \ have previously been provided an RTT\n       measurement are included with receivers\
    \ yielding the lowest\n       calculated congestion rate getting precedence.\n\
    \   There are \"cc_flag\" values in addition to NORM_FLAG_CC_CLR used for\n  \
    \ other congestion control functions.  The NORM_FLAG_CC_PLR flag value\n   is\
    \ used to mark additional receivers from which the sender would like\n   to have\
    \ immediate, non-suppressed feedback.  These can be receivers\n   the sender algorithmically\
    \ identified as potential future CLRs or\n   have been pre-configured as potential\
    \ congestion control points in\n   the network.  The NORM_FLAG_CC_RTT indicates\
    \ the validity of the\n   \"cc_rtt\" field for the associated receiver node. \
    \ Normally, this flag\n   will be set since the receivers in the list will typically\
    \ be\n   receivers from which the sender has received feedback.  However, in\n\
    \   the case the NORM sender has been pre-configured with a set of PLR\n   nodes,\
    \ feedback from those receivers might not have yet been\n   collected and thus\
    \ the \"cc_rtt\" field does not contain a valid value\n   when this flag is not\
    \ set.  Similarly, a value of ZERO for the\n   \"cc_rate\" field here MUST be\
    \ treated as an invalid value and be\n   ignored for the purposes of feedback\
    \ suppression, etc.\n"
- title: 5.5.2.2.  NORM_CMD(CC) Feedback Response
  contents:
  - "5.5.2.2.  NORM_CMD(CC) Feedback Response\n   Receivers explicitly respond to\
    \ NORM_CMD(CC) messages in the form of\n   a NORM_ACK(RTT) message.  The goal\
    \ of the congestion control feedback\n   is to determine the receivers with the\
    \ lowest congestion control\n   rates.  Receivers marked as CLR or PLR nodes in\
    \ the NORM_CMD(CC)\n   \"cc_node_list\" immediately provide feedback in the form\
    \ of a NORM_ACK\n   to this message.  When a NORM_CMD(CC) is received, non-CLR\
    \ or non-PLR\n   nodes initiate random feedback backoff timeouts similar to those\
    \ used\n   when the receiver initiates a repair cycle (see Section 5.3) in\n \
    \  response to detection of data loss.  The backoff timeout for the\n   congestion\
    \ control response is generated as follows:\n      T_backoff = RandomBackoff(K_backoff\
    \ * GRTT_sender, GSIZE_sender)\n   The RandomBackoff() algorithm provides a truncated\
    \ exponentially\n   distributed random number and is described in the Multicast\
    \ NACK\n   Building Block [RFC5401] document.  The same backoff factor,\n   K_backoff\
    \ = K_sender, as used with NORM_NACK suppression is generally\n   RECOMMENDED.\
    \  However, in cases where the application purposefully\n   specifies a very small\
    \ K_sender backoff factor to minimize the NACK\n   repair process latency (trading\
    \ off group size scalability), it is\n   RECOMMENDED a larger backoff factor for\
    \ congestion control feedback\n   be maintained, since there can be a larger volume\
    \ of congestion\n   control feedback than NACKs in many cases and some congestion\
    \ control\n   feedback latency might be tolerable where reliable delivery latency\n\
    \   is not.  As previously noted, a backoff factor value of K_sender = 4\n   is\
    \ generally RECOMMENDED for ASM operation and K_sender = 6 for SSM\n   operation.\
    \  A receiver SHALL cancel the backoff timeout and thus its\n   pending transmission\
    \ of a NORM_ACK(RTT) message under the following\n   conditions:\n   1.  The receiver\
    \ generates another feedback message (NORM_NACK or\n       other NORM_ACK) before\
    \ the congestion control feedback timeout\n       expires (these messages will\
    \ convey the current congestion\n       control feedback information).\n   2.\
    \  A NORM_CMD(CC) or other receiver feedback with an ordinally\n       greater\
    \ \"cc_sequence\" field value is received before the\n       congestion control\
    \ feedback timeout expires (this is similar to\n       the TFMCC feedback round\
    \ number).\n   3.  When the T_backoff is greater than 1*GRTT_sender.  This prevents\n\
    \       NACK implosion in the event of sender or network failure.\n   4.  \"Suppressing\"\
    \ congestion control feedback is heard from another\n       receiver (in a NORM_ACK\
    \ or NORM_NACK) or via a\n       NORM_CMD(REPAIR_ADV) message from the sender.\
    \  The local\n       receiver's feedback is \"suppressed\" if the rate of the\
    \ competing\n       feedback (Rfb) is sufficiently close to or less than the local\n\
    \       receiver's calculated rate (Rcalc).  The local receiver's\n       feedback\
    \ is canceled when Rcalc > (0.9 * Rfb).  Also, note\n       receivers that have\
    \ not yet received an RTT measurement from the\n       sender are suppressed only\
    \ by other receivers that have not yet\n       measured RTT.  Additionally, receivers\
    \ whose RTT estimate has\n       aged considerably (i.e., they haven't been included\
    \ in the\n       NORM_CMD(CC) \"cc_node_list\" in a long time) might wish to compete\n\
    \       as a receiver with no prior RTT measurement after some long-term\n   \
    \    expiration period.\n   When the backoff timer expires, the receiver SHALL\
    \ generate a\n   NORM_ACK(RTT) message to provide feedback to the sender and group.\n\
    \   This message MAY be multicast to the group for most effective\n   suppression\
    \ in ASM topologies or unicast to the sender depending upon\n   how the NORM protocol\
    \ is deployed and configured.\n   Whenever any feedback is generated (including\
    \ this NORM_ACK(RTT)\n   message), receivers include an adjusted version of the\
    \ sender\n   timestamp from the most recently received NORM_CMD(CC) message and\n\
    \   its \"cc_sequence\" value in the corresponding NORM_ACK or NORM_NACK\n   message\
    \ fields.  For NORM-CC operation, any generated feedback\n   message SHALL also\
    \ contain the NORM-CC Feedback header extension.\n   The receiver provides its\
    \ current \"cc_rate\" estimate, \"cc_loss\"\n   estimate, \"cc_rtt\" if known,\
    \ and any applicable \"cc_flags\" via this\n   header extension.\n   During slow\
    \ start (when the receiver has not yet detected loss from\n   the sender), the\
    \ receiver uses a value equal to two times its\n   measured rate from the sender\
    \ in the \"cc_rate\" field.  For steady-\n   state congestion control operation,\
    \ the receiver \"cc_rate\" value is\n   from the equation-based value using its\
    \ current loss event estimate\n   and sender<->receiver RTT information.  (The\
    \ GRTT_sender is used when\n   the receiver has not yet measured its individual\
    \ RTT.)\n   The \"cc_loss\" field value reflects the receiver's current loss event\n\
    \   estimate with respect to the sender in question.\n   When the receiver has\
    \ a valid individual RTT measurement, it SHALL\n   include this value in the \"\
    cc_rtt\" field.  The NORM_FLAG_CC_RTT MUST\n   be set when the \"cc_rtt\" field\
    \ is valid.\n   After a congestion control feedback message is generated or when\
    \ the\n   feedback is suppressed, a non-CLR receiver begins a \"holdoff\" timeout\n\
    \   period during which it will restrain itself from providing congestion\n  \
    \ control feedback, even if NORM_CMD(CC) messages are received from the\n   sender\
    \ (unless the receive becomes marked as a CLR or PLR node).  The\n   value of\
    \ this holdoff timeout (T_ccHoldoff) period is:\n                   T_ccHoldoff\
    \ = (K_sender * GRTT_sender)\n   Thus, non-CLR receivers are constrained to providing\
    \ explicit\n   congestion control feedback once per K_sender*GRTT_sender intervals.\n\
    \   However, as the session progresses, different receivers will be\n   responding\
    \ to different NORM_CMD(CC) messages and there will be\n   relatively continuous\
    \ feedback of congestion control information\n   while the sender is active.\n"
- title: 5.5.2.3.  Congestion Control Rate Adjustment
  contents:
  - "5.5.2.3.  Congestion Control Rate Adjustment\n   During steady-state operation,\
    \ the sender will directly adjust its\n   transmission rate to the rate indicated\
    \ by the feedback from its\n   currently selected CLR.  As noted in [TfmccPaper],\
    \ the estimation of\n   parameters (loss and RTT) for the CLR will generally constrain\
    \ the\n   rate changes possible within acceptable bounds.  For rate increases,\n\
    \   the sender SHALL observe a maximum rate of increase of one packet per\n  \
    \ RTT at all times during steady-state operation.\n   The sender processes congestion\
    \ control feedback from the receivers\n   and selects the CLR based on the lowest\
    \ rate receiver.  Receiver\n   rates are determined either directly from the slow\
    \ start \"cc_rate\"\n   provided by the receiver in the NORM-CC Feedback header\
    \ extension or\n   by performing the equation-based calculation using individual\
    \ RTT and\n   loss estimates (\"cc_loss\") as feedback is received.\n   The sender\
    \ can calculate a current RTT for a receiver (RTT_rcvrNew)\n   using the \"grtt_response\"\
    \ timestamp included in feedback messages.\n   When the \"cc_rtt\" value in a\
    \ response is not valid, the sender simply\n   uses this RTT_rcvrNew value as\
    \ the receiver's current RTT (RTT_rcvr).\n   For non-CLR and non-PLR receivers,\
    \ the sender SHOULD use the \"cc_rtt\"\n   provided in the NORM-CC Feedback header\
    \ extension as the receiver's\n   previous RTT measurement (RTT_rcvrPrev) averaged\
    \ with the current\n   measurement (\"RTT_rcvrNew\") as the receiver's RTT value:\n\
    \             RTT_rcvr = 0.5 * RTT_rcvrPrev + 0.5 * RTT_rcvrNew\n   For CLR receivers\
    \ where feedback is received more regularly, the\n   sender SHOULD maintain a\
    \ more smoothed RTT estimate upon new feedback\n   from the CLR where:\n     \
    \            RTT_clr = 0.9 * RTT_clr + 0.1 * RTT_clrNew\n   RTT_clrNew is the\
    \ new RTT calculated from the timestamp in the\n   feedback message received from\
    \ the CLR.  The RTT_clr is initialized\n   to RTT_clrNew on the first feedback\
    \ message received.  Note that the\n   same procedure is observed by the sender\
    \ for PLR receivers, and if a\n   PLR is \"promoted\" to CLR status, the smoothed\
    \ estimate can be\n   continued.\n   There are some additional periods besides\
    \ steady-state operation to\n   be considered in NORM-CC operation.  These periods\
    \ are:\n   1.  during session startup,\n   2.  when no feedback is received from\
    \ the CLR, and\n   3.  when the sender has a break in data transmission.\n   During\
    \ session startup, the congestion control operation SHALL\n   observe a \"slow-start\"\
    \ procedure to quickly approach its fair\n   bandwidth share.  An initial sender\
    \ startup rate is assumed where:\n    Rinit = MIN(NormSegmentSize/GRTT_sender,\
    \ NormSegmentSize) bytes/sec\n   The rate is increased only when feedback is received\
    \ from the\n   receiver set.  The \"slow start\" phase proceeds until any receiver\n\
    \   provides feedback indicating loss has occurred.  Rate increase during\n  \
    \ slow start is applied as:\n                              Rnew = Rrecv_min\n\
    \   where Rrecv_min is the minimum reported receiver rate in the\n   \"cc_rate\"\
    \ field of congestion control feedback messages received from\n   the group. \
    \ Note during slow start, receivers use two times their\n   measured rate from\
    \ the sender in the \"cc_rate\" field of their\n   feedback.  Rate increase adjustment\
    \ is limited to once per GRTT\n   during slow start.\n   If the CLR or any receiver\
    \ intends to leave the group, it will set\n   the NORM_FLAG_CC_LEAVE in its congestion\
    \ control feedback message as\n   an indication the sender SHOULD NOT select it\
    \ as the CLR.  When the\n   CLR changes to a lower rate receiver, the sender SHOULD\
    \ immediately\n   adjust to the new lower rate.  The sender is limited to increasing\n\
    \   its rate at one additional packet per RTT towards any new, higher CLR\n  \
    \ rate.\n   The sender SHOULD also track the age of the feedback it has received\n\
    \   from the CLR by comparing its current \"cc_sequence\" value\n   (Seq_sender)\
    \ to the last \"cc_sequence\" value received from the CLR\n   (Seq_clr).  As the\
    \ age of the CLR feedback increases with no new\n   feedback, the sender SHALL\
    \ begin reducing its rate once per RTT_clr\n   as a congestion avoidance measure.\
    \  The following algorithm is used\n   to determine the decrease in sender rate\
    \ (Rsender bytes/sec) as the\n   CLR feedback, unexpectedly, excessively ages:\n\
    \                   Age = Seq_sender - Seq_clr;\n                   if (Age >\
    \ 4) Rsender = Rsender * 0.5;\n   This rate reduction is limited to the lower\
    \ bound on NORM\n   transmission rates.  After NORM_ROBUST_FACTOR consecutive\n\
    \   NORM_CMD(CC) rounds without any feedback from the CLR, the sender\n   SHOULD\
    \ assume the CLR has left the group and pick the receiver with\n   the next lowest\
    \ rate as the new CLR.  Note this assumes the sender\n   does not have explicit\
    \ knowledge the CLR intentionally left the\n   group.  If no receiver feedback\
    \ is received, the sender MAY wish to\n   withhold further transmissions of NORM_DATA\
    \ segments and maintain\n   NORM_CMD(CC) transmissions only until feedback is\
    \ detected.  After\n   such a CLR timeout, the sender will be transmitting with\
    \ a minimal\n   rate and SHOULD return to slow start as described here for a break\
    \ in\n   data transmission.\n   When the sender has a break in its data transmission,\
    \ it can continue\n   to probe the group with NORM_CMD(CC) messages to maintain\
    \ RTT\n   collection from the group.  This will enable the sender to quickly\n\
    \   determine an appropriate CLR upon data transmission restart.\n   However,\
    \ the sender SHOULD exponentially reduce its target rate to be\n   used for transmission\
    \ restart as time since the break elapses.  The\n   target rate SHOULD be recalculated\
    \ once per RTT_clr as:\n                          Rsender = Rsender * 0.5;\n \
    \  If the minimum NORM rate is reached, the sender SHOULD set the\n   NORM_FLAG_START\
    \ flag in its NORM_CMD(CC) messages upon restart and\n   the group SHOULD observe\
    \ slow-start congestion control procedures\n   until any receiver experiences\
    \ a new loss event.\n"
- title: 5.5.3.  NORM Positive Acknowledgment Procedure
  contents:
  - "5.5.3.  NORM Positive Acknowledgment Procedure\n   NORM provides options for\
    \ the source application to request positive\n   acknowledgment (ACK) of NORM_CMD(FLUSH)\
    \ and NORM_CMD(ACK_REQ)\n   messages from members of the group.  There are some\
    \ specific\n   acknowledgment requests defined for the NORM protocol and a range\
    \ of\n   acknowledgment request types left to be defined by the application.\n\
    \   One predefined acknowledgment type is the NORM_ACK(FLUSH) type.  This\n  \
    \ acknowledgment is used to determine if receivers have achieved\n   completion\
    \ of reliable reception up through a specific logical\n   transmission point with\
    \ respect to the sender's sequence of\n   transmission.  The NORM_ACK(FLUSH) acknowledgment\
    \ MAY be used to\n   assist in application flow control when the sender has information\
    \ on\n   a portion of the receiver set.  Another predefined acknowledgment\n \
    \  type is NORM_ACK(CC) used to explicitly provide congestion control\n   feedback\
    \ in response to NORM_CMD(CC) messages transmitted by the\n   sender for NORM-CC\
    \ operation.  Note the NORM_ACK(CC) response does\n   NOT follow the positive\
    \ acknowledgment procedure described here.  The\n   NORM_CMD(ACK_REQ) and NORM_ACK\
    \ messages contain an \"ack_type\" field\n   to identify the type of acknowledgment\
    \ requested and provided.  A\n   range of \"ack_type\" values is provided for\
    \ application-defined use.\n   While the application is responsible for initiating\
    \ the\n   acknowledgment request and interprets application-defined \"ack_type\"\
    \n   values, the acknowledgment procedure SHOULD be conducted within the\n   protocol\
    \ implementation to take advantage of timing and transmission\n   scheduling information\
    \ available to the NORM transport.\n   The NORM Positive Acknowledgment Procedure\
    \ uses polling by the sender\n   to query the receiver group for response.  Note\
    \ this polling\n   procedure is not intended to scale to very large receiver groups,\
    \ but\n   could be used in a large group setting to query a critical subset of\n\
    \   the group.  Either the NORM_CMD(ACK_REQ), or when applicable, the\n   NORM_CMD(FLUSH)\
    \ message is used for polling and contains a list of\n   NormNodeIds of the receivers\
    \ expected to respond to the command.  The\n   list of receivers providing acknowledgment\
    \ is determined by the\n   source application with a priori knowledge of participating\
    \ nodes or\n   via some other application-level mechanism.\n   The ACK process\
    \ is initiated by the sender generating NORM_CMD(FLUSH)\n   or NORM_CMD(ACK_REQ)\
    \ messages in periodic rounds.  For\n   NORM_ACK(FLUSH) requests, the NORM_CMD(FLUSH)\
    \ contains a\n   \"object_transport_id\" and \"fec_payload_id\" denoting the watermark\n\
    \   transmission point for which acknowledgment is requested.  This\n   watermark\
    \ transmission point is echoed in the corresponding fields of\n   the NORM_ACK(FLUSH)\
    \ message sent by the receiver in response.\n   NORM_CMD(ACK_REQ) messages contain\
    \ an \"ack_id\" field that is\n   similarly echoed in response so the sender can\
    \ match the response to\n   the appropriate request.\n   In response to the NORM_CMD(ACK_REQ),\
    \ the listed receivers randomly,\n   with a uniform distribution, transmit NORM_ACK\
    \ messages over a time\n   window of (1*GRTT_sender).  These NORM_ACK messages\
    \ are typically\n   unicast to the sender.  (Note NORM_ACK(CC) messages SHALL\
    \ be\n   multicast or unicast in the same manner as NORM_NACK messages.)\n   The\
    \ ACK process is self-limiting and avoids ACK implosion because:\n   1.  Only\
    \ a single NORM_CMD(ACK_REQ) message is generated once per\n       (2*GRTT_sender),\
    \ and\n   2.  The size of the \"acking_node_list\" of NormNodeIds from which\n\
    \       acknowledgment is requested is limited to a maximum of the sender\n  \
    \     NormSegmentSize setting per round of the positive acknowledgment\n     \
    \  process.\n   Because the size of the included list is limited to the sender's\n\
    \   NormSegmentSize setting, multiple NORM_CMD(ACK_REQ) rounds will\n   sometimes\
    \ be necessary to achieve responses from all receivers\n   specified.  The content\
    \ of the attached NormNodeId list will be\n   dynamically updated as this process\
    \ progresses and NORM_ACK responses\n   are received from the specified receiver\
    \ set.  As the sender receives\n   valid responses (i.e., matching watermark point\
    \ or \"ack_id\") from\n   receivers, it SHALL eliminate those receivers from the\
    \ subsequent\n   NORM_CMD(ACK_REQ) message \"acking_node_list\" and add in any\
    \ pending\n   receiver NormNodeIds while keeping within the NormSegmentSize\n\
    \   limitation of the list size.  Each receiver is queried a maximum\n   number\
    \ of times (NORM_ROBUST_FACTOR, by default).  Receivers not\n   responding within\
    \ this number of repeated requests are removed from\n   the payload list to make\
    \ room for other potential receivers pending\n   acknowledgment.  The transmission\
    \ of the NORM_CMD(ACK_REQ) is\n   repeated until no further responses are needed\
    \ or until the repeat\n   threshold is exceeded for all pending receivers.  The\
    \ transmission of\n   NORM_CMD(ACK_REQ) or NORM_CMD(FLUSH) messages to conduct\
    \ the positive\n   acknowledgment process is multiplexed with ongoing sender data\n\
    \   transmissions.  However, the NORM_CMD(FLUSH) positive acknowledgment\n   process\
    \ MAY be interrupted in response to negative acknowledgment\n   repair requests\
    \ (NACKs) received from receivers during the\n   acknowledgment period.  The NORM_CMD(FLUSH)\
    \ positive acknowledgment\n   process is restarted for receivers pending acknowledgment\
    \ once any\n   the repairs have been transmitted.\n   In the case of NORM_CMD(FLUSH)\
    \ commands with an attached\n   \"acking_node_list\", receivers will not ACK until\
    \ they have received\n   complete transmission of all data up to and including\
    \ the given\n   watermark transmission point.  All receivers SHALL interpret the\n\
    \   watermark point provided in the request NACK for repairs if needed as\n  \
    \ for NORM_CMD(FLUSH) commands with no attached \"acking_node_list\".\n"
- title: 5.5.4.  Group Size Estimate
  contents:
  - "5.5.4.  Group Size Estimate\n   NORM sender messages contain a \"gsize\" field\
    \ that is a representation\n   of the group size and that is used in scaling random\
    \ backoff timer\n   ranges.  The use of the group size estimate within the NORM\
    \ protocol\n   does not demand a precise estimation and works reasonably well\
    \ if the\n   estimate is within an order of magnitude of the actual group size.\n\
    \   By default, the NORM sender group size estimate MAY be\n   administratively\
    \ configured.  Also, given the expected scalability of\n   the NORM protocol for\
    \ general use, a default value of 10,000 is\n   RECOMMENDED for use as the group\
    \ size estimate.  It is also possible\n   the group size MAY be algorithmically\
    \ approximated from the volume of\n   congestion control feedback messages based\
    \ on the exponentially\n   weighted random backoff.  However, the specification\
    \ of such an\n   algorithm is currently beyond the scope of this document.\n"
- title: 6.  Configurable Elements
  contents:
  - "6.  Configurable Elements\n   The NORM protocol supports a modest number of configurable\
    \ parameters\n   that control operation.  Most of these need only be set at NORM\n\
    \   sender(s) and the configuration information is communicated to the\n   receiver\
    \ set in NORM header and/or header extension fields.  A\n   notable exception\
    \ to this is the NORM_ROBUST_FACTOR that is presumed\n   to be a common value\
    \ preset among senders and receivers for a given\n   NORM session.  The following\
    \ table summarizes these configurable\n   elements:\n   +--------------------+----------------------------------------------+\n\
    \   | Configurable       | Purpose                                      |\n  \
    \ | Element            |                                              |\n   +--------------------+----------------------------------------------+\n\
    \   | Sender initial     | Sender's initial estimate of greatest group  |\n  \
    \ | GRTT Estimate      | round-trip time.  Affects timing of feedback |\n   |\
    \ (GRTT_sender)      | suppression and sender command transmissions |\n   |  \
    \                  | at sender startup.                           |\n   | Backoff\
    \ Factor     | Sender's scaling factor used for timer-based |\n   | (K_sender)\
    \         | feedback suppression.                        |\n   | Group Size  \
    \       | Sender's rough estimate of receiver group    |\n   | Estimate      \
    \     | size used in generation of random feedback   |\n   | (GSIZE_sender)  \
    \   | backoff timeout.                             |\n   | NORM_ROBUST_FACTOR\
    \ | Integer factor determining how persistently  |\n   |                    |\
    \ (i.e., robust) senders transmit repeated     |\n   |                    | control\
    \ messages and receivers self-initiate |\n   |                    | timeout-based\
    \ NACKing in the absence of      |\n   |                    | sender activity.\
    \                             |\n   | FEC Type           | Sender FEC encoding\
    \ type.                    |\n   | (\"fec_id\")         |                    \
    \                          |\n   | Sender segment     | Maximum size (in bytes)\
    \ of the payload       |\n   | size               | portion of NORM_DATA and other\
    \ messages.     |\n   | (NormSegmentSize)  |                                 \
    \             |\n   | NormNodeId         | Unique identifiers pre-assigned to\
    \ all NORM  |\n   |                    | session participants.               \
    \         |\n   +--------------------+----------------------------------------------+\n\
    \   The sender-controlled GRTT estimate (referred to as GRTT_sender in\n   this\
    \ document) is used to set and scale various timers associated\n   with NORM protocol\
    \ operation.  During steady-state operation, the\n   sender probes the receiver\
    \ set, adapts to the group round-trip timing\n   state, and advertises its estimate\
    \ to the receiver set in the \"grtt\"\n   field of relevant NORM protocol messages.\
    \  However, an initial value\n   must be assumed at sender startup.  A large initial\
    \ estimate is\n   conservative and safer with regard to preventing feedback implosion\n\
    \   and starting up congestion control operation, but requires the sender\n  \
    \ and receivers to allocate more buffering resources for a given\n   transmission\
    \ rate (i.e., larger effective delay*bandwidth product) to\n   maintain efficient\
    \ operation.  A default initial value of GRTT_sender\n   = 0.5 seconds is RECOMMENDED.\n\
    \   The sender-controlled Backoff Factor (referred to a K_sender in this\n   document)\
    \ is used to scale protocol timers and contributes to the\n   generation of the\
    \ random backoff timeout value that facilitates\n   timer-based feedback suppression.\
    \  The sender advertises its\n   configured Backoff Factor to the receiver set\
    \ in the \"backoff\" field\n   of applicable NORM messages and thus no receiver\
    \ configuration is\n   necessary.  For ASM operation, a default value of K_sender\
    \ = 4 is\n   RECOMMENDED; for SSM operation, a default value of K_sender = 6 is\n\
    \   RECOMMENDED.\n   The sender estimate of session Group Size (referred to as\n\
    \   GSIZE_sender in this document) also plays a role in the random\n   selection\
    \ of feedback suppression timeout values.  The sender\n   advertises its configured\
    \ Group Size estimate to the receiver set in\n   the \"gsize\" field of applicable\
    \ NORM messages; thus, no receiver\n   configuration is necessary.  Only a rough\
    \ estimate (i.e., \"order-of-\n   magnitude\") is needed for effective feedback\
    \ suppression and a\n   default value of GSIZE_sender = 10,000 is RECOMMENDED\
    \ as a\n   conservative estimate for most uses.\n   The NORM_ROBUST_FACTOR is\
    \ an integer parameter that determines how\n   persistently NORM senders transmit\
    \ control messages (NORM_CMD\n   messages) such as end-of-transmission flushing,\
    \ OPTIONAL positive\n   acknowledgment requests, etc.  Additionally, the receivers\
    \ use their\n   knowledge of NORM_ROBUST_FACTOR to determine when to consider\
    \ a NORM\n   sender inactive and MAY use the factor in determining how\n   persistently\
    \ to self-initiate repeated NACK repair requests upon such\n   timeouts.  This\
    \ parameter is NOT communicated in NORM protocol\n   message headers and is presumed\
    \ to be preset to a consistent value\n   among sender and receivers for a given\
    \ NORM session.  A default value\n   of NORM_ROBUST_FACTOR = 20 is RECOMMENDED.\n\
    \   Another NORM sender configuration element is the FEC type used to\n   encode\
    \ NORM_DATA message content.  The FEC type is communicated from\n   the sender\
    \ to the receiver set in the \"fec_id\" field of relevant NORM\n   message headers.\
    \  The \"fec_id\" value corresponds to an IANA-assigned\n   value identifying\
    \ the FEC encoding type as described in the FEC\n   Building Block [RFC5052] document.\
    \  Typically, a sender SHOULD use a\n   consistent FEC encoding for its participation\
    \ in a session to\n   simplify receiver state allocation and maintenance, but\
    \ its\n   implementations MAY vary the FEC encoding type on a per-object basis\n\
    \   if necessary.\n   The sender NormSegmentSize setting determines the maximum\
    \ size of the\n   payload portion of NORM_DATA and other messages that the sender\n\
    \   transmits.  Additionally, the payload size of feedback messages from\n   receivers\
    \ to a given sender is limited to that sender's\n   NormSegmentSize.  The NormSegmentSize\
    \ SHOULD be configured to be\n   compatible with expected network MTU limitations,\
    \ given the added\n   overhead of NORM, UDP, and IP protocol message headers.\n\
    \   Additionally, MTU Discovery MAY be employed by the sender to\n   determine\
    \ an appropriate NormSegmentSize.  The NormSegmentSize for a\n   given sender\
    \ can be determined by receivers from the FEC Object\n   Transmission Information\
    \ (FTI) provided either in applied EXT_FTI\n   header extensions or pre-configured\
    \ session information.\n   Although it is not technically a configurable element,\
    \ the receivers\n   MUST have FEC Object Transmission Information for transmitted\n\
    \   NormObjects to properly buffer, decode, and reassemble the original\n   content.\
    \  For loosely organized NORM protocol sessions, the sender\n   MAY apply the\
    \ EXT_FTI Header Extension to NORM_DATA and NORM_INFO (if\n   applicable) messages\
    \ so that receivers can get this information\n   without prior coordination. \
    \ An implementation MAY also apply the\n   EXT_FTI only to NORM_INFO messages\
    \ for reduced overhead.  Finally,\n   applications MAY also provide the FTI out-of-band\
    \ prior to sender\n   transmission.\n   Each participant in a NORM protocol session\
    \ MUST be configured with a\n   unique NormNodeId value.  The NormNodeId value\
    \ is used by receivers\n   to identify the sender to which their NACK or other\
    \ feedback messages\n   are addressed, and senders use the NormNodeId to differentiate\n\
    \   receivers for purposes of congestion control and OPTIONAL positive\n   acknowledgment\
    \ collection.  Assignment of unique NormNodeId values\n   can be done via a priori\
    \ coordination and/or use of a deconfliction\n   mechanism external to the NORM\
    \ protocol itself.  The values of\n   NORM_NODE_NONE = 0x00000000 and NORM_NODE_ANY\
    \ = 0xffffffff are\n   reserved and MUST NOT be assigned to NORM participants.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   The same security considerations that apply to\
    \ the Multicast NACK\n   [RFC5401], TFMCC [RFC4654], and FEC [RFC5052] Building\
    \ Blocks also\n   apply to the NORM protocol.  In addition to the vulnerabilities\
    \ to\n   which any IP and IP multicast protocol implementation is subject,\n \
    \  malicious hosts might engage in excessive NACKing in an attempt to\n   prevent\
    \ the NORM sender(s) from making forward progress in reliable\n   transmission.\
    \  Receiver \"join\" and \"service\" policy enforcement as\n   described in Section\
    \ 5.2 can be applied if such activity is detected.\n   The use of cryptographic\
    \ peer authentication, integrity checks,\n   and/or confidentiality mechanisms\
    \ can be used to provide a more\n   effective degree of protection from objectionable\
    \ transmissions from\n   unauthorized hosts.  But in some cases, even with authentication\
    \ and\n   integrity checks, the NACK-based feedback of NORM can be exploited by\n\
    \   replay attacks forcing the NORM sender to unnecessarily transmit\n   repair\
    \ information.  This MAY be addressed in part with network-layer\n   IP security\
    \ implementations that guard against this potential\n   security exploitation\
    \ or alternatively with a security mechanism\n   using the EXT_AUTH header extension\
    \ for similar purposes.  Such\n   security mechanisms SHOULD be deployed and used\
    \ when available.  Use\n   of security mechanisms will impose additional \"a priori\"\
    \n   configuration upon the NORM deployment depending upon the techniques\n  \
    \ used.\n   The NORM protocol is compatible with the use of IP security (IPsec)\n\
    \   [RFC4301], and the IPsec Encapsulating Security Payload (ESP)\n   protocol\
    \ or Authentication Header (AH) extension can be used to\n   secure IP packets\
    \ transmitted by NORM participants.  A baseline\n   approach to secure NORM operation\
    \ using IPsec is described below.\n   Compliant implementations of this specification\
    \ are REQUIRED to be\n   compatible with IPsec usage as described in Section 7.1.\
    \  IPsec can\n   be used to provide peer authentication, integrity protection,\
    \ and/or\n   encryption of packets containing NORM messages.\n   Additionally,\
    \ the EXT_AUTH header extension (HET = 1) is reserved for\n   use by security\
    \ mechanisms to provide alternatives to IPsec for the\n   security of NORM messages.\
    \  The format of this header extension and\n   its processing is outside the scope\
    \ of this document and is to be\n   communicated out-of-band as part of the session\
    \ description.  It is\n   possible an EXT_AUTH implementation MAY also provide\
    \ for encryption\n   of NORM message payloads as well as peer authentication and\
    \ integrity\n   protection.  The use of this approach as compared to IPsec can\
    \ allow\n   for header compression techniques to be applied jointly to IP and\n\
    \   NORM protocol headers.  In cases where security analysis deems\n   encryption\
    \ of NORM protocol header content to be beneficial or\n   necessary, the aforementioned\
    \ use of IPsec ESP might be more\n   appropriate.  Additionally, the EXT_AUTH\
    \ header extension can be\n   utilized when NORM is implemented in a network with\
    \ Network Address\n   Translation (NAT) systems that are incompatible with use\
    \ of the IPsec\n   AH extension.  If EXT_AUTH is present, whatever packet authentication\n\
    \   or integrity checks that can be performed immediately upon reception\n   of\
    \ the packet MUST be performed before accepting the packet and\n   performing\
    \ any congestion-control-related action on it.  Some packet\n   authentication\
    \ schemes impose a delay of several seconds between when\n   a packet is received\
    \ and when the packet can be fully authenticated.\n   Any appropriate congestion\
    \ control related action MUST NOT be\n   postponed by any such packet security\
    \ mechanism (i.e., security\n   mechanisms MUST NOT result in poor congestion\
    \ control behavior).\n   Consideration MUST also be given to the potential for\
    \ replay-attacks\n   that would transplant authenticated packets from one NORM\
    \ session to\n   another to disrupt service.  To avoid this potential, unique\
    \ keys\n   SHOULD be assigned on a per-session basis or NORM sender nodes SHOULD\n\
    \   be configured to use unique \"instance_id\" identifiers managed as part\n\
    \   of the security association for the sessions.\n   Note NORM implementations\
    \ can use the \"sequence\" field from the NORM\n   common message header to detect\
    \ replay attacks.  This can be\n   accomplished if the NORM sender maintains state\
    \ on actively NACKing\n   receivers.  A cache of such receiver state can be used\
    \ to provide\n   protection against NACK replay attacks.  NORM receivers MUST\
    \ also\n   maintain similar state for protection against possible replay of\n\
    \   other receiver messages in ASM operation as well.  For example, a\n   receiver\
    \ could be suppressed from providing NACK or congestion\n   control feedback by\
    \ replay of certain receiver messages.  For these\n   reasons, authentication\
    \ of NORM messages (e.g., via IPsec) SHOULD be\n   applied for protection against\
    \ similar attacks that use fabricated\n   messages.  Also, encryption of messages\
    \ to provide confidentiality of\n   application data and protect privacy of users\
    \ MAY also be applied\n   using IPsec or similar mechanisms.\n   When applicable\
    \ security measures are used, automated key management\n   mechanisms such as\
    \ those described in the Group Domain of\n   Interpretation (GDOI) [RFC3547],\
    \ Multimedia Internet KEYing (MIKEY)\n   [RFC3830], or Group Secure Association\
    \ Key Management Protocol\n   (GSAKMP) [RFC4535] specifications SHOULD be applied.\n\
    \   While NORM does leverage FEC-based repair for scalability, this alone\n  \
    \ does not guarantee integrity of received data.  Application-level\n   integrity-checking\
    \ of received data content is highly RECOMMENDED.\n   This recommendation also\
    \ applies when the IPsec security approach\n   described below is used for added\
    \ assurance in data content integrity\n   given the shared use of IPsec Security\
    \ Association information among\n   the group.\n"
- title: 7.1.  Baseline Secure NORM Operation
  contents:
  - "7.1.  Baseline Secure NORM Operation\n   This section describes a baseline mode\
    \ of secure NORM protocol\n   operation based on application of the IPsec security\
    \ protocol.  This\n   approach is documented here to provide a baseline interoperable\n\
    \   secure mode of operation.  This particular approach represents one\n   possible\
    \ trade-off in the level of assurance that can be achieved and\n   the scalability\
    \ of multicast group-size given current IPsec\n   mechanisms and the state required\
    \ to support them.  For example, this\n   baseline approach specifies the use\
    \ of a Security Association that is\n   shared among the receiver set for feedback\
    \ messages to the sender.\n   This model requires that the receiver membership\
    \ receiving the\n   session keys is trusted and only provides protection from\
    \ attacks\n   that are external to the NORM group membership.  More stateful and\n\
    \   complex IPsec approaches and key management schemes may be applied\n   for\
    \ higher levels of assurance, but those are beyond the scope of\n   this transport\
    \ protocol specification.  Additional approaches to NORM\n   security, including\
    \ other forms of IPsec application, MAY be\n   specified in the future.  For example,\
    \ the use of the EXT_AUTH header\n   extension could enable NORM-specific authentication\
    \ or security\n   encapsulation headers similar to those of IPsec to be specified\
    \ and\n   inserted into the NORM protocol message headers.  This would allow\n\
    \   header compression techniques to be applied to IP and NORM protocol\n   headers\
    \ when needed in a similar fashion to RTP [RFC3550] and as\n   preserved in the\
    \ specification for Secure Real Time Protocol (SRTP)\n   [RFC3711].\n   The baseline\
    \ approach described is applicable to NORM operation\n   configured for SSM (or\
    \ SSM-like) operation where there is a single\n   sender and the receivers are\
    \ providing unicast feedback.  This form\n   of NORM operation allows for IPsec\
    \ to be used with a manageable\n   number of security associations (SA).\n"
- title: 7.1.1.  IPsec Approach
  contents:
  - "7.1.1.  IPsec Approach\n   For NORM one-to-many SSM operation with unicast feedback\
    \ from\n   receivers, each node SHALL be configured with two transport mode\n\
    \   IPsec security associations and corresponding Security Policy\n   Database\
    \ (SPD) entries.  One entry will be used for sender-to-group\n   multicast packet\
    \ authentication and optionally encryption while the\n   other entry will be used\
    \ to provide security for the unicast feedback\n   messaging from the receiver(s)\
    \ to the sender.  Note that this single\n   SA for NORM receiver feedback messages\
    \ is shared to protect traffic\n   from possibly multiple receivers to the single\
    \ sender.\n   For each NormSession, the NORM sender SHALL use an IPsec SA\n  \
    \ configured for ESP protocol [RFC4303] operation with the option for\n   data\
    \ origin authentication enabled.  It is also RECOMMENDED this\n   IPsec ESP SA\
    \ be also configured to provide confidentiality protection\n   for IP packets\
    \ containing NORM protocol messages.  This is suggested\n   to make the realization\
    \ of complex replay attacks much more\n   difficult.  The encryption key for this\
    \ SA SHALL be preplaced at the\n   sender and receiver(s) prior to NORM protocol\
    \ operation.  Use of\n   automated key management is RECOMMENDED as a rekey SHALL\
    \ be REQUIRED\n   prior to expiration of the sequence space for the SA.  This\
    \ is\n   necessary so receivers can use the built-in IPsec replay attack\n   protection\
    \ possible for an IPsec SA with a single source (the NORM\n   sender).  Thus,\
    \ the receivers SHALL enable replay attack protection\n   for this SA used to\
    \ secure NORM sender traffic.  An IPsec SPD entry\n   MUST be configured to process\
    \ outbound packets to the session\n   (destination) address and UDP port number\
    \ of the applicable\n   (NormSession).\n   The NORM receiver(s) MUST be configured\
    \ with the SA and SPD entry to\n   properly process the IPsec-secured packets\
    \ from the sender.  The NORM\n   receiver(s) SHALL also use a common, second IPsec\
    \ SA (common Security\n   Parameter Index (SPI) and encryption key) configured\
    \ for ESP\n   operation with the option for data origination authentication\n\
    \   enabled.  Similar to the NORM sender, is RECOMMENDED this IPsec ESP\n   SA\
    \ be also configured to provide confidentiality protection for IP\n   packets\
    \ containing NORM protocol messages.  The receivers MUST have\n   an IPsec SPD\
    \ entry configured to process outbound NORM/UDP packets\n   directed to the NORM\
    \ sender source address and port number using this\n   second SA.  To support\
    \ NORM unicast feedback, the sender's\n   transmission port number SHOULD be selected\
    \ to be distinct from the\n   multicast session port number to allow discrimination\
    \ between unicast\n   and multicast feedback messages when access to the IP destination\n\
    \   address is not possible (e.g., a user-space NORM implementation).\n   For\
    \ processing of packets from receivers, the NORM sender SHALL be\n   configured\
    \ with this common, second SA (and the corresponding SPD\n   entry needed) in\
    \ order to properly process messages from the\n   receiver.\n   Multiple receivers\
    \ using a common IPsec SA for traffic directed to\n   the NORM sender (i.e., many-to-one)\
    \ typically prevents the use of\n   built-in IPsec replay attack protection by\
    \ the NORM sender with\n   current IPsec implementations.  Thus the built-in IPsec\
    \ replay attack\n   protection for this second SA at the sender MUST be disabled\
    \ unless\n   the particular IPsec implementation manages its replay protection\
    \ on\n   a per-source basis (which is not typical of existing IPsec\n   implementations).\
    \  So, to support a fully secure mode of operation,\n   the NORM sender implementation\
    \ MUST provide replay attack protection\n   based upon the \"sequence\" field\
    \ of NORM protocol messages from\n   receivers.  This can be accomplished with\
    \ a high assurance of\n   security, even with the limited size (16-bits) of this\
    \ field,\n   because:\n   1.  NORM receiver NACK and non-CLR ACK feedback messages\
    \ are sparse.\n   2.  The more frequent NORM_ACK feedback from CLR or PLR nodes\
    \ is only\n       a small set of receivers for which the sender needs to keep\
    \ more\n       persistent replay attack state.\n   3.  NORM_NACK feedback messages\
    \ preceding the sender's current repair\n       window do not significantly impact\
    \ protocol operation (generation\n       of NORM_CMD(SQUELCH) is limited) and\
    \ could be in fact ignored.\n       This means the sender can prune any replay\
    \ attack state that\n       precedes the current repair window.\n   4.  NORM_ACK\
    \ messages correspond to either a specific sender\n       \"ack_id\", the sender\
    \ \"cc_sequence\" for ACKs sent in response to\n       NORM_CMD(CC), or the sender's\
    \ current repair window in the case\n       of ACKs sent in response to NORM_CMD(FLUSH).\
    \  Thus, the sender\n       can prune any replay attack state for receivers that\
    \ precede the\n       current applicable sequence or repair window space.\n  \
    \ The use of ESP confidentiality for secure NORM protocol operation\n   makes\
    \ it more difficult for adversaries to conduct any form of replay\n   attacks.\
    \  Additionally, a NORM sender implementation with access to\n   the full ESP\
    \ protocol header could also use the ESP sequence\n   information to make replay\
    \ attack protection even more robust by\n   maintaining the per-source ESP sequence\
    \ state that existing IPsec\n   implementations typically do not provide.  The\
    \ design of this\n   baseline security approach for NORM intentionally places\
    \ any more\n   complex processing state or processing (e.g., replay attack\n \
    \  protection given multiple receivers) at the NORM sender since NORM\n   receiver\
    \ implementations might often need to be less complex.\n   This baseline approach\
    \ can be used for NORM protocol sessions with\n   multiple senders if the SA pairs\
    \ described are established for each\n   sender.  For small-sized groups, it is\
    \ even possible many-to-many\n   (ASM) IPsec configuration could be achieved where\
    \ each participant\n   uses a unique SA (with a unique SPI).  In this case, the\
    \ sender(s)\n   would maintain an SA for each other participant rather than a\
    \ single,\n   shared SA for receiver feedback messages.  This does not scale to\n\
    \   larger group sizes given the complex set of SA and SPD entries each\n   participant\
    \ would need to maintain.\n   It is anticipated in early deployments of this baseline\
    \ approach to\n   NORM security that key management will be conducted out-of-band\
    \ with\n   respect to NORM protocol operation.  In the case of one-to-many NORM\n\
    \   operation, it is possible receivers will retrieve keying information\n   from\
    \ a central server as needed or otherwise conduct group key\n   updates with a\
    \ similar centralized approach.  Alternatively, it is\n   possible with some key\
    \ management schemes for rekey messages to be\n   transmitted to the group as\
    \ a message or transport object within the\n   NORM reliable transfer session.\
    \  Similarly, for group-wise\n   communication sessions, it is possible for potential\
    \ group\n   participants to request keying and/or rekeying as part of NORM\n \
    \  communications.  Additional specification is necessary to define an\n   in-band\
    \ key management scheme for NORM sessions perhaps using the\n   mechanisms of\
    \ the automated group key management specifications cited\n   in this document.\
    \  Additional specification outside of the scope of\n   this document would be\
    \ needed to provide an interoperable approach\n   for key management in-band of\
    \ a NORM reliable transport session.\n"
- title: 7.1.2.  IPsec Requirements
  contents:
  - "7.1.2.  IPsec Requirements\n   In order to implement this secure mode of NORM\
    \ protocol operation,\n   the following IPsec capabilities are REQUIRED.\n"
- title: 7.1.2.1.  Selectors
  contents:
  - "7.1.2.1.  Selectors\n   The implementation MUST be able to use the source address,\n\
    \   destination address, protocol (UDP), and UDP port numbers as\n   selectors\
    \ in the SPD.\n"
- title: 7.1.2.2.  Mode
  contents:
  - "7.1.2.2.  Mode\n   IPsec in transport mode MUST be supported.  The use of IPsec\n\
    \   [RFC4301] processing for secure NORM traffic MUST be configured such\n   that\
    \ unauthenticated packets are not received by the NORM protocol\n   implementation.\n"
- title: 7.1.2.3.  Key Management
  contents:
  - "7.1.2.3.  Key Management\n   An automated key management scheme for group key\
    \ distribution and\n   rekeying such as GDOI [RFC3547], GSAKMP [RFC4535], or MIKEY\
    \ [RFC3830]\n   is RECOMMENDED for use.  Note it is possible for key update messages\n\
    \   (e.g., the GDOI GROUPKEY-PUSH message) to be included as part of the\n   NORM\
    \ application reliable data transmission if appropriate interfaces\n   are available\
    \ between the NORM application and the key management\n   daemon.  Relatively\
    \ short-lived NORM sessions MAY be able to use\n   Manual Keying with a single,\
    \ preplaced key, particularly if Extended\n   Sequence Numbering (ESN) [RFC4303]\
    \ is available in the IPsec\n   implementation used.  When manual keys are used,\
    \ it is important that\n   cryptographic algorithms suitable for manual key use\
    \ are selected.\n"
- title: 7.1.2.4.  Security Policy
  contents:
  - "7.1.2.4.  Security Policy\n   Receivers MUST accept protocol messages only from\
    \ the designated,\n   authorized sender(s).  Appropriate key management will provide\n\
    \   authentication, integrity and/or encryption keys only to receivers\n   authorized\
    \ to participate in a designated session.  The approach\n   outlined here allows\
    \ receiver sets to be controlled on a per-sender\n   basis.\n"
- title: 7.1.2.5.  Authentication and Encryption
  contents:
  - "7.1.2.5.  Authentication and Encryption\n   Large NORM group sizes will necessitate\
    \ some form of key management\n   that does rely upon shared secrets.  The GDOI\
    \ and GSAKMP protocols\n   mentioned here allow for certificate-based authentication.\
    \  It is\n   RECOMMENDED these certificates use IP addresses for authentication.\n"
- title: 7.1.2.6.  Availability
  contents:
  - "7.1.2.6.  Availability\n   The IPsec requirements profile outlined here is commonly\
    \ available on\n   many potential NORM hosts.  Configuration and operation of\
    \ IPsec\n   typically requires privileged user authorization.  Automated key\n\
    \   management implementations are typically configured with the\n   privileges\
    \ necessary to affect system IPsec configuration.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   Values of NORM Header Extension Types, Stream Control\
    \ Codes, and\n   NORM_CMD message sub-types are subject to IANA registration.\
    \  They\n   are in the registry named \"Reliable Multicast Transport (RMT) NORM\n\
    \   Protocol Parameters\" available from http://www.iana.org.\n   Note the reliable\
    \ multicast building block components used by this\n   specification also have\
    \ their respective IANA considerations, and\n   those documents SHOULD be consulted\
    \ accordingly.  In particular, the\n   FEC Building Block used by NORM does REQUIRE\
    \ IANA registration of the\n   FEC codecs used.  The registration instructions\
    \ for FEC codecs are\n   provided in RFC 5052.  It is possible additional extensions\
    \ of the\n   NORM protocol might be specified in the future (e.g., additional\
    \ NORM\n   message types) and additional registries be established at that time\n\
    \   with appropriate IETF standards action.\n"
- title: 8.1.  Explicit IANA Assignment Guidelines
  contents:
  - "8.1.  Explicit IANA Assignment Guidelines\n   This document introduces three\
    \ registries for the NORM Header\n   Extension Types, Stream Control Codes, and\
    \ NORM_CMD Message sub-\n   types.  This section describes explicit IANA assignment\
    \ guidelines\n   for each of these.\n"
- title: 8.1.1.  NORM Header Extension Types
  contents:
  - "8.1.1.  NORM Header Extension Types\n   This document defines a registry for\
    \ NORM Header Extensions named\n   \"NORM Header Extension Types\".\n   The NORM\
    \ Header Extension Type field is an 8-bit value.  The values\n   of this field\
    \ identify extended header content allowing the protocol\n   functionality to\
    \ be expanded to include additional features and\n   operating modes.  The values\
    \ that can be assigned within the \"NORM\n   Header Extensions\" registry are\
    \ numeric indexes in the range {0,\n   255}, boundaries included.  Values in the\
    \ range {0,127} indicate\n   variable-length extended header fields while values\
    \ in the range\n   {128,255} indicate extensions of a fixed 4-byte length.  This\n\
    \   specification registers the following NORM Header Extension Types:\n     \
    \            +-------+----------+--------------------+\n                 | Value\
    \ | Name     | Reference          |\n                 +-------+----------+--------------------+\n\
    \                 | 1     | EXT_AUTH | This specification |\n                \
    \ | 3     | EXT_CC   | This specification |\n                 | 64    | EXT_FTI\
    \  | This specification |\n                 | 128   | EXT_RATE | This specification\
    \ |\n                 +-------+----------+--------------------+\n   Requests for\
    \ assignment of additional NORM Header Extension Type\n   values are granted on\
    \ a \"Specification Required\" basis as defined by\n   IANA Guidelines [RFC5226].\
    \  Any such header extension specifications\n   MUST include a description of\
    \ protocol actions to be taken when the\n   extension type is encountered by a\
    \ protocol implementation not\n   supporting that specific option.  For example,\
    \ it is often possible\n   for protocol implementations to ignore unknown header\
    \ extensions.\n"
- title: 8.1.2.  NORM Stream Control Codes
  contents:
  - "8.1.2.  NORM Stream Control Codes\n   This document defines a registry for NORM\
    \ Stream Control Codes named\n   \"NORM Stream Control Codes\".\n   NORM Stream\
    \ Control Codes are 16-bit values that can be inserted\n   within a NORM_OBJECT_STREAM\
    \ delivery object to convey sequenced, out-\n   of-band (with respect to the stream\
    \ data) control signaling\n   applicable to the referenced stream object.  These\
    \ control codes are\n   to be delivered to the application or protocol implementation\
    \ with\n   reliable delivery, in-order with respect to the their inserted\n  \
    \ position within the stream.  This specification registers the\n   following\
    \ NORM Stream Control Code:\n             +-------+-----------------+--------------------+\n\
    \             | Value | Name            | Reference          |\n             +-------+-----------------+--------------------+\n\
    \             | 0     | NORM_STREAM_END | This specification |\n             +-------+-----------------+--------------------+\n\
    \   Additional NORM Stream Control Code value assignment requests are\n   granted\
    \ on a \"Specification Required\" basis as defined by IANA\n   Guidelines [RFC5226].\
    \  The full 16-bit space outside of the value\n   assigned in this specification\
    \ are available for future assignment.\n   In addition to describing the control\
    \ code's expected interpretation,\n   such specifications MUST include a description\
    \ of protocol actions to\n   be taken when the control code is encountered by\
    \ a protocol\n   implementation not supporting that specific option.\n"
- title: 8.1.3.  NORM_CMD Message Sub-Types
  contents:
  - "8.1.3.  NORM_CMD Message Sub-Types\n   This document defines a registry for NORM_CMD\
    \ message sub-types named\n   \"NORM Command Message Sub-types\".\n   The NORM_CMD\
    \ message \"sub-type\" field is an 8-bit value with valid\n   values in the range\
    \ of 1-255.  Note the value 0 is reserved to\n   indicate an invalid NORM_CMD\
    \ message sub-type.  The current\n   specification defines a number of NORM_CMD\
    \ message sub-types senders\n   can use to signal the receivers in various aspects\
    \ of NORM protocol\n   operation.  This specification registers the following\
    \ NORM_CMD\n   Message Sub-types:\n          +-------+-----------------------+--------------------+\n\
    \          | Value | Name                  | Reference          |\n          +-------+-----------------------+--------------------+\n\
    \          | 0     | reserved              | This specification |\n          |\
    \ 1     | NORM_CMD(FLUSH)       | This specification |\n          | 2     | NORM_CMD(EOT)\
    \         | This specification |\n          | 3     | NORM_CMD(SQUELCH)     |\
    \ This specification |\n          | 4     | NORM_CMD(CC)          | This specification\
    \ |\n          | 5     | NORM_CMD(REPAIR_ADV)  | This specification |\n      \
    \    | 6     | NORM_CMD(ACK_REQ)     | This specification |\n          | 7   \
    \  | NORM_CMD(APPLICATION) | This specification |\n          +-------+-----------------------+--------------------+\n\
    \   Future specifications extending NORM MAY define additional NORM_CMD\n   messages\
    \ to enhance protocol functionality.  NORM_CMD message sub-\n   type value assignment\
    \ requests are granted on a \"Specification\n   Required\" basis as defined by\
    \ IANA Guidelines [RFC5226].  In addition\n   to describing the command sub-type's\
    \ expected interpretation,\n   specifications MUST include a description of protocol\
    \ actions to be\n   taken when the command is encountered by a protocol implementation\n\
    \   not supporting that specific option.\n   This specification already defines\
    \ an \"application-defined\" NORM_CMD\n   message sub-type for use at the discretion\
    \ of individual applications\n   using NORM for transport.  These \"application-defined\"\
    \ commands are\n   suitable for many application-specific purposes and do not\
    \ involve\n   standards action.  In any case, such additional messages SHALL be\n\
    \   subject to the same congestion control constraints as the existing\n   NORM\
    \ sender message set.\n"
- title: 9.  Suggested Use
  contents:
  - "9.  Suggested Use\n   The present NORM protocol is seen as a useful tool for\
    \ the reliable\n   data transfer over generic IP multicast services.  It is not\
    \ the\n   intention of the authors to suggest it is suitable for supporting all\n\
    \   envisioned multicast reliability requirements.  NORM provides a\n   simple\
    \ and flexible framework for multicast applications with a\n   degree of concern\
    \ for network traffic implosion and protocol overhead\n   efficiency.  NORM-like\
    \ protocols have been successfully demonstrated\n   within the MBone for bulk\
    \ data dissemination applications, including\n   weather satellite compressed\
    \ imagery updates servicing a large group\n   of receivers and a generic web content\
    \ reliable \"push\" application.\n   In addition, this framework approach has\
    \ some design features making\n   it attractive for bulk transfer in asymmetric\
    \ and wireless\n   internetwork applications.  NORM is capable of successfully\
    \ operating\n   independent of network structure and in environments with high\
    \ packet\n   loss, delay, and out-of-order delivery.  Hybrid proactive/reactive\n\
    \   FEC-based repairing improve protocol performance in some multicast\n   scenarios.\
    \  A sender-only repair approach often makes additional\n   engineering sense\
    \ in asymmetric networks.  NORM's unicast feedback\n   capability is suitable\
    \ for use in asymmetric networks or in networks\n   where only unidirectional\
    \ multicast routing/delivery service exists.\n   Asymmetric architectures supporting\
    \ multicast delivery are likely to\n   make up an important portion of the future\
    \ Internet structure (e.g.,\n   direct broadcast satellite (DBS) or cable and\
    \ public-switched\n   telephone network (PSTN) hybrids, etc.) and efficient, reliable\
    \ bulk\n   data transfer will be an important capability for servicing large\n\
    \   groups of subscribed receivers.\n"
- title: 10.  Changes from RFC 3940
  contents:
  - "10.  Changes from RFC 3940\n   This section lists the changes between the Experimental\
    \ version of\n   this specification, RFC 3940, and this version:\n   1.  Removal\
    \ of the NORM_FLAG_MSG_START for NORM_OBJECT_STREAM,\n       replacing it with\
    \ the \"payload_msg_start\" field in the FEC-\n       encoded preamble of the\
    \ NORM_OBJECT_STREAM NORM_DATA payload.\n   2.  Definition of IANA registry for\
    \ header extension and other\n       assignments.\n   3.  Removal of file blocking\
    \ scheme description now specified in the\n       FEC Building Block document\
    \ [RFC5052].\n   4.  Removal of restriction of NORM receiver feedback message\
    \ rate to\n       local NORM sender rate (this caused congestion control failures\n\
    \       in high speed operation.  The extremely low feedback rate of the\n   \
    \    NORM protocol as compared to TCP avoids any resultant impact to\n       the\
    \ network as shown in [Mdpcc].)\n   5.  Correction of errors in some message format\
    \ descriptions.\n   6.  Correction of inconsistency in specification of the inactivity\n\
    \       timeout.\n   7.  Addition of IPsec secure mode description with IPsec\n\
    \       requirements.\n   8.  Addition of the EXT_AUTH header extension definition.\n\
    \   9.  Clarification of interpretation of \"Source Block Length\" when FEC\n\
    \       codes are arbitrarily shortened by the sender.\n"
- title: 11.  Acknowledgments
  contents:
  - "11.  Acknowledgments\n   (and these are not Negative)\n   The authors would like\
    \ to thank Rick Jones, Vincent Roca, Rod Walsh,\n   Toni Paila, Michael Luby,\
    \ and Joerg Widmer for their valuable input\n   and comments on this document.\
    \  The authors would also like to thank\n   the RMT working group chairs, Roger\
    \ Kermode and Lorenzo Vicisano, for\n   their support in development of this specification,\
    \ and Sally Floyd\n   for her early input into this document.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [RFC1112]        Deering, S., \"Host extensions\
    \ for IP multicasting\",\n                    STD 5, RFC 1112, August 1989.\n\
    \   [RFC2119]        Bradner, S., \"Key words for use in RFCs to Indicate\n  \
    \                  Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC4301]\
    \        Kent, S. and K. Seo, \"Security Architecture for the\n              \
    \      Internet Protocol\", RFC 4301, December 2005.\n   [RFC4303]        Kent,\
    \ S., \"IP Encapsulating Security Payload (ESP)\",\n                    RFC 4303,\
    \ December 2005.\n   [RFC4607]        Holbrook, H. and B. Cain, \"Source-Specific\
    \ Multicast\n                    for IP\", RFC 4607, August 2006.\n   [RFC4654]\
    \        Widmer, J. and M. Handley, \"TCP-Friendly Multicast\n               \
    \     Congestion Control (TFMCC): Protocol Specification\",\n                \
    \    RFC 4654, August 2006.\n   [RFC5052]        Watson, M., Luby, M., and L.\
    \ Vicisano, \"Forward\n                    Error Correction (FEC) Building Block\"\
    , RFC 5052,\n                    August 2007.\n   [RFC5226]        Narten, T.\
    \ and H. Alvestrand, \"Guidelines for\n                    Writing an IANA Considerations\
    \ Section in RFCs\",\n                    BCP 26, RFC 5226, May 2008.\n   [RFC5401]\
    \        Adamson, B., Bormann, C., Handley, M., and J.\n                    Macker,\
    \ \"Multicast Negative-Acknowledgment (NACK)\n                    Building Blocks\"\
    , RFC 5401, November 2008.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [FecHybrid]      Gossink, D. and J. Macker,\
    \ \"Reliable Multicast and\n                    Integrated Parity Retransmission\
    \ with Channel\n                    Estimation\", IEEE GLOBECOMM, 1998.\n   [McastFeedback]\
    \  Nonnenmacher, J. and E. Biersack, \"Optimal Multicast\n                   \
    \ Feedback\", IEEE INFOCOM, p. 964, March/April 1998.\n   [MdpToolkit]     Macker,\
    \  J. and B. Adamson, \"The Multicast\n                    Dissemination Protocol\
    \ (MDP) Toolkit\", Proc.\n                    IEEE MILCOM, October 1999.\n   [Mdpcc]\
    \          Adamson,  B. and J. Macker, \"A TCP-Friendly, Rate-\n             \
    \       based Mechanism for NACK-Oriented Reliable Multicast\n               \
    \     Congestion Control\", Proc. IEEE GLOBECOMM,\n                    November\
    \ 2001.\n   [NormFeedback]   Adamson, B. and J. Macker, \"Quantitative Prediction\n\
    \                    of NACK-Oriented Reliable Multicast (NORM)\n            \
    \        Feedback\", IEEE MILCOM, October 2002.\n   [PgmccPaper]     Rizzo, L.,\
    \ \"pgmcc: A TCP-Friendly Single-Rate\n                    Multicast Congestion\
    \ Control Scheme\", ACM SIGCOMM,\n                    August 2000.\n   [RFC2357]\
    \        Mankin, A., Romanov, A., Bradner, S., and V. Paxson,\n              \
    \      \"IETF Criteria for Evaluating Reliable Multicast\n                   \
    \ Transport and Application Protocols\", RFC 2357,\n                    June 1998.\n\
    \   [RFC2974]        Handley, M., Perkins, C., and E. Whelan, \"Session\n    \
    \                Announcement Protocol\", RFC 2974, October 2000.\n   [RFC3048]\
    \        Whetten, B., Vicisano, L., Kermode, R., Handley, M.,\n              \
    \      Floyd, S., and M. Luby, \"Reliable Multicast\n                    Transport\
    \ Building Blocks for One-to-Many Bulk-Data\n                    Transfer\", RFC\
    \ 3048, January 2001.\n   [RFC3269]        Kermode, R. and L. Vicisano, \"Author\
    \ Guidelines for\n                    Reliable Multicast Transport (RMT) Building\
    \ Blocks\n                    and Protocol Instantiation documents\", RFC 3269,\n\
    \                    April 2002.\n   [RFC3453]        Luby, M., Vicisano, L.,\
    \ Gemmell, J., Rizzo, L.,\n                    Handley, M., and J. Crowcroft,\
    \ \"The Use of Forward\n                    Error Correction (FEC) in Reliable\
    \ Multicast\",\n                    RFC 3453, December 2002.\n   [RFC3547]   \
    \     Baugher, M., Weis, B., Hardjono, T., and H. Harney,\n                  \
    \  \"The Group Domain of Interpretation\", RFC 3547,\n                    July\
    \ 2003.\n   [RFC3550]        Schulzrinne, H., Casner, S., Frederick, R., and V.\n\
    \                    Jacobson, \"RTP: A Transport Protocol for Real-Time\n   \
    \                 Applications\", STD 64, RFC 3550, July 2003.\n   [RFC3711] \
    \       Baugher, M., McGrew, D., Naslund, M., Carrara, E.,\n                 \
    \   and K. Norrman, \"The Secure Real-time Transport\n                    Protocol\
    \ (SRTP)\", RFC 3711, March 2004.\n   [RFC3830]        Arkko, J., Carrara, E.,\
    \ Lindholm, F., Naslund, M.,\n                    and K. Norrman, \"MIKEY: Multimedia\
    \ Internet KEYing\",\n                    RFC 3830, August 2004.\n   [RFC3940]\
    \        Adamson, B., Bormann, C., Handley, M., and J.\n                    Macker,\
    \ \"Negative-acknowledgment (NACK)-Oriented\n                    Reliable Multicast\
    \ (NORM) Protocol\", RFC 3940,\n                    November 2004.\n   [RFC4535]\
    \        Harney, H., Meth, U., Colegrove, A., and G. Gross,\n                \
    \    \"GSAKMP: Group Secure Association Key Management\n                    Protocol\"\
    , RFC 4535, June 2006.\n   [RFC4566]        Handley, M., Jacobson, V., and C.\
    \ Perkins, \"SDP:\n                    Session Description Protocol\", RFC 4566,\
    \ July 2006.\n   [RFC5445]        Watson, M., \"Basic Forward Error Correction\
    \ (FEC)\n                    Schemes\", RFC 5445, March 2009.\n   [RmComparison]\
    \   Pingali, S., Towsley, D., and J. Kurose, \"A\n                    Comparison\
    \ of Sender-Initiated and Receiver-\n                    Initiated Reliable Multicast\
    \ Protocols\", Proc.\n                    INFOCOMM, San Francisco CA, October\
    \ 1993.\n   [TcpModel]       Padhye,  J., Firoiu, V., Towsley, D., and J. Kurose,\n\
    \                    \"Modeling TCP Throughput: A Simple Model and its\n     \
    \               Empirical Validation\", ACM SIGCOMM, 1998.\n   [TfmccPaper]  \
    \   Widmer, J. and M. Handley, \"Extending Equation-Based\n                  \
    \  Congestion Control to Multicast Applications\",\n                    ACM SIGCOMM,\
    \ August 2001.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Brian Adamson\n   Naval Research Laboratory\n   Washington,\
    \ DC  20375\n   USA\n   EMail: adamson@itd.nrl.navy.mil\n   Carsten Bormann\n\
    \   Universitaet Bremen TZI\n   Postfach 330440\n   D-28334 Bremen\n   Germany\n\
    \   EMail: cabo@tzi.org\n   Mark Handley\n   University College London\n   Gower\
    \ Street\n   London  WC1E 6BT\n   UK\n   EMail: M.Handley@cs.ucl.ac.uk\n   Joe\
    \ Macker\n   Naval Research Laboratory\n   Washington, DC  20375\n   USA\n   EMail:\
    \ macker@itd.nrl.navy.mil\n"
