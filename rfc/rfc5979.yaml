- title: __initial_text__
  contents:
  - '                     NSIS Operation over IP Tunnels

    '
- title: Abstract
  contents:
  - "Abstract\n   NSIS Quality of Service (QoS) signaling enables applications to\n\
    \   perform QoS reservation along a data flow path.  When the data flow\n   path\
    \ contains IP tunnel segments, NSIS QoS signaling has no effect\n   within those\
    \ tunnel segments.  Therefore, the resulting tunnel\n   segments could become\
    \ the weakest QoS link and invalidate the QoS\n   efforts in the rest of the end-to-end\
    \ path.  The problem with NSIS\n   signaling within the tunnel is caused by the\
    \ tunnel encapsulation\n   that masks packets' original IP header fields.  Those\
    \ original IP\n   header fields are needed to intercept NSIS signaling messages\
    \ and\n   classify QoS data packets.  This document defines a solution to this\n\
    \   problem by mapping end-to-end QoS session requests to corresponding\n   QoS\
    \ sessions in the tunnel, thus extending the end-to-end QoS\n   signaling into\
    \ the IP tunnel segments.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5979.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n   2.  Terminology  . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  4\n   3.  Problem Statement  . . . . . . . . . . . . . . . . . .\
    \ . . . .  6\n     3.1.  IP Tunneling Protocols . . . . . . . . . . . . . . .\
    \ . . .  6\n     3.2.  NSIS QoS Signaling in the Presence of IP Tunnels . . .\
    \ . .  7\n   4.  Design Overview  . . . . . . . . . . . . . . . . . . . . . .\
    \ . 10\n     4.1.  Design Requirements  . . . . . . . . . . . . . . . . . . .\
    \ 10\n     4.2.  Overall Design Approach  . . . . . . . . . . . . . . . . . 11\n\
    \     4.3.  Tunnel Flow ID for Different IP Tunneling Protocols  . . . 13\n  \
    \ 5.  NSIS Operation over Tunnels with Preconfigured QoS Sessions  . 14\n    \
    \ 5.1.  Sender-initiated Reservation . . . . . . . . . . . . . . . 14\n     5.2.\
    \  Receiver-Initiated Reservation . . . . . . . . . . . . . . 15\n   6.  NSIS\
    \ Operation over Tunnels with Dynamically Created QoS\n       Sessions . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . 16\n     6.1.  Sender-Initiated\
    \ Reservation . . . . . . . . . . . . . . . 17\n     6.2.  Receiver-Initiated\
    \ Reservation . . . . . . . . . . . . . . 19\n   7.  NSIS-Tunnel Signaling Capability\
    \ Discovery . . . . . . . . . . 22\n   8.  IANA Considerations  . . . . . . .\
    \ . . . . . . . . . . . . . . 23\n   9.  Security Considerations  . . . . . .\
    \ . . . . . . . . . . . . . 24\n   10. Acknowledgments  . . . . . . . . . . .\
    \ . . . . . . . . . . . . 24\n   11. References . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . 25\n     11.1. Normative References . . . . . . . . .\
    \ . . . . . . . . . . 25\n     11.2. Informative References . . . . . . . . .\
    \ . . . . . . . . . 25\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   IP tunneling [RFC1853] [RFC2003] is a technique that allows\
    \ a packet\n   to be encapsulated and carried as payload within an IP packet.\
    \  The\n   resulting encapsulated packet is called an IP tunnel packet, and the\n\
    \   packet being tunneled is called the original packet.  In typical\n   scenarios,\
    \ IP tunneling is used to exert explicit forwarding path\n   control (e.g., in\
    \ Mobile IP [RFC5944]), implement secure IP data\n   delivery (e.g., in IPsec\
    \ [RFC4301]), and help packet routing in IP\n   networks of different characteristics\
    \ (e.g., between IPv6 and IPv4\n   networks [RFC4213]).  Section 3.1 summarizes\
    \ a list of common IP\n   tunneling protocols.\n   This document considers the\
    \ situation when the packet being tunneled\n   contains a Next Step In Signaling\
    \ (NSIS) [RFC4080] packet.  NSIS is\n   an IP signaling architecture consisting\
    \ of a Generic Internet\n   Signaling Transport (GIST) [RFC5971] sub-layer for\
    \ signaling\n   transport, and an NSIS Signaling Layer Protocol (NSLP) sub-layer\n\
    \   customizable for different applications.  We focus on the Quality of\n   Service\
    \ (QoS) NSLP [RFC5974] which provides functionalities that\n   extend those of\
    \ the earlier RSVP [RFC2205] signaling.  In this\n   document, the terms \"NSIS\"\
    \ and \"NSIS QoS\" are used interchangeably.\n   Without additional efforts, NSIS\
    \ signaling does not work within IP\n   tunnel segments of a signaling path. \
    \ The reason is that tunnel\n   encapsulation masks the original packet including\
    \ its header and\n   payload.  However, information from the original packet is\
    \ required\n   both for NSIS peer node discovery and for QoS data flow packet\n\
    \   classification.  Without access to information from the original\n   packet,\
    \ an IP tunnel acts as an NSIS-unaware virtual link in the end-\n   to-end NSIS\
    \ signaling path.\n   This document defines a mechanism to extend end-to-end NSIS\
    \ signaling\n   for QoS reservation into IP tunnels.  The NSIS-aware IP tunnel\n\
    \   endpoints that support this mechanism are called NSIS-tunnel-aware\n   endpoints.\
    \  There are two main operation modes.  On one hand, if the\n   tunnel already\
    \ has preconfigured QoS sessions, the NSIS-tunnel-aware\n   endpoints map end-to-end\
    \ QoS signaling requests directly to existing\n   tunnel sessions as long as there\
    \ are enough tunnel session resources;\n   on the other hand, if no preconfigured\
    \ tunnel QoS sessions are\n   available, the NSIS-tunnel-aware endpoints dynamically\
    \ initiate and\n   maintain tunnel QoS sessions that are then associated with\
    \ the\n   corresponding end-to-end QoS sessions.  Note that whether or not the\n\
    \   tunnel preconfigures QoS sessions, and which preconfigured tunnel QoS\n  \
    \ sessions a particular end-to-end QoS signaling request should be\n   mapped\
    \ to are policy issues that are out of scope of this document.\n   The rest of\
    \ this document is organized as follows.  Section 2 defines\n   terminology. \
    \ Section 3 presents the problem statement including\n   common IP tunneling protocols\
    \ and existing behavior of NSIS QoS\n   signaling over IP tunnels.  Section 4\
    \ introduces the design\n   requirements and overall approach of our mechanism.\
    \  More details\n   about how NSIS QoS signaling operates with tunnels that use\n\
    \   preconfigured QoS and dynamic QoS signaling are provided in Sections\n   5\
    \ and 6.  Section 7 describes a method to automatically discover\n   whether a\
    \ tunnel endpoint node supports the NSIS-tunnel\n   interoperation mechanism defined\
    \ in this document.  Section 8\n   discusses IANA considerations, and Section\
    \ 9 considers security.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   This document uses terminology defined in [RFC2473], [RFC5971],\
    \ and\n   [RFC5974].  In addition, the following terms are used:\n   IP Tunnel:\
    \  A tunnel that is configured as a virtual link between two\n      IP nodes and\
    \ on which the encapsulating protocol is IP.\n   Tunnel IP Header:  The IP header\
    \ prepended to the original packet\n      during encapsulation.  It specifies\
    \ the tunnel endpoints as source\n      and destination.\n   Tunnel-Specific Header:\
    \  The header fields inserted by the\n      encapsulation mechanism after the\
    \ tunnel IP header and before the\n      original packet.  These headers may or\
    \ may not exist depending on\n      the specific tunnel mechanism used.  An example\
    \ of such header\n      fields is the Encapsulation Security Payload (ESP) header\
    \ for\n      IPsec [RFC4301] tunneling mode.\n   Tunnel Intermediate Node (Tmid):\
    \  A node that resides in the middle\n      of the forwarding path between the\
    \ tunnel entry-point node and the\n      tunnel exit-point node.\n   Flow Identifier\
    \ (Flow ID):  The set of header fields that is used to\n      identify a data\
    \ flow.  For example, it may include flow sender and\n      receiver addresses,\
    \ and protocol and port numbers.\n   End-to-End QoS Signaling:  The signaling\
    \ process that manipulates the\n      QoS control information in the end-to-end\
    \ path from the flow\n      sender to the flow receiver.  When the end-to-end\
    \ flow path\n      contains tunnel segments, this document uses end-to-end QoS\n\
    \      signaling to refer to the QoS signaling outside the tunnel\n      segments.\
    \  This document uses \"end-to-end QoS signaling\" and \"end-\n      to-end signaling\"\
    \ interchangeably.\n   Tunnel QoS Signaling:  The signaling process that manipulates\
    \ the QoS\n      control information in the path inside a tunnel, between the\n\
    \      tunnel entry-point and the tunnel exit-point nodes.  This document\n  \
    \    uses \"tunnel QoS signaling\" and \"tunnel signaling\"\n      interchangeably.\n\
    \   NSIS-Aware Node:  A node that supports NSIS signaling.\n   NSIS-Aware Tunnel\
    \ Endpoint Node:  A tunnel endpoint node that is also\n      an NSIS node.\n \
    \  NSIS-Tunnel-Aware Endpoint Node:  An NSIS-aware tunnel endpoint node\n    \
    \  that also supports the mechanism for NSIS operating over IP\n      tunnels\
    \ defined in this document.\n"
- title: 3.  Problem Statement
  contents:
  - '3.  Problem Statement

    '
- title: 3.1.  IP Tunneling Protocols
  contents:
  - "3.1.  IP Tunneling Protocols\n                    Tunnel from node B to node\
    \ D\n                     <---------------------->\n                  Tunnel \
    \      Tunnel        Tunnel\n                  Entry-Point  Intermediate  Exit-Point\n\
    \                  Node         Node          Node\n   +-+            +-+    \
    \      +-+           +-+            +-+\n   |A|-->--//-->--|B|=====>====|C|===//==>===|D|-->--//-->--|E|\n\
    \   +-+            +-+          +-+           +-+            +-+\n   Original\
    \                                                 Original\n   Packet        \
    \                                           Packet\n   Source                \
    \                                   Destination\n   Node                     \
    \                                Node\n                            Figure 1: IP\
    \ Tunnel\n   The following description about IP tunneling is derived from\n  \
    \ [RFC2473] and adapted for both IPv4 and IPv6.\n   IP tunneling (Figure 1) is\
    \ a technique for establishing a \"virtual\n   link\" between two IP nodes for\
    \ transmitting data packets as payloads\n   of IP packets.  From the point of\
    \ view of the two nodes, this\n   \"virtual link\", called an IP tunnel, appears\
    \ as a point-to-point link\n   on which IP acts like a link-layer protocol.  The\
    \ two IP nodes play\n   specific roles.  One node encapsulates original packets\
    \ received from\n   other nodes or from itself and forwards the resulting tunnel\
    \ packets\n   through the tunnel.  The other node decapsulates the received tunnel\n\
    \   packets and forwards the resulting original packets towards their\n   destinations,\
    \ possibly itself.  The encapsulating node is called the\n   tunnel entry-point\
    \ node (Tentry), and it is the source of the tunnel\n   packets.  The decapsulating\
    \ node is called the tunnel exit-point node\n   (Texit), and it is the destination\
    \ of the tunnel packets.\n   An IP tunnel is a unidirectional mechanism - the\
    \ tunnel packet flow\n   takes place in one direction between the IP tunnel entry-point\
    \ and\n   exit-point nodes.  Bidirectional tunneling is achieved by combining\n\
    \   two unidirectional mechanisms, that is, configuring two tunnels, each\n  \
    \ in opposite direction to the other -- the entry-point node of one\n   tunnel\
    \ is the exit-point node of the other tunnel.\n   Figure 2 illustrates the original\
    \ packet and the resulting tunnel\n   packet.  In a tunnel packet, the original\
    \ packet is encapsulated\n   within the tunnel header.  The tunnel header contains\
    \ two components,\n   the tunnel IP header and other tunnel-specific headers.\
    \  The tunnel\n   IP header specifies the tunnel entry-point node as the IP source\n\
    \   address and the tunnel exit-point node as the IP destination address,\n  \
    \ causing the tunnel packet to be forwarded in the tunnel.  The tunnel-\n   specific\
    \ header between the tunnel IP header and the original packet\n   is optional,\
    \ depending on the tunneling protocol in use.\n                         +----------------------------------//-----+\n\
    \                         | Original |                              |\n      \
    \                   |          |   Original Packet Payload    |\n            \
    \             | Header   |                              |\n                  \
    \       +----------------------------------//-----+\n                        \
    \  <            Original Packet            >\n                               \
    \                |\n                                               v\n    <  Tunnel\
    \ Headers   > <            Original Packet            >\n   +---------+-----------+-------------------------//--------------+\n\
    \   | Tunnel  | Tunnel-   |                                         |\n   | IP\
    \      | Specific  |             Original Packet             |\n   | Header  |\
    \ Header    |                                         |\n   +---------+-----------+-------------------------//--------------+\n\
    \    <                        Tunnel IP Packet                     >\n       \
    \              Figure 2: IP Tunnel Encapsulation\n   Commonly used IP tunneling\
    \ protocols include Generic Routing\n   Encapsulation (GRE) [RFC1701][RFC2784],\
    \ Generic Routing Encapsulation\n   over IPv4 Networks (GREIPv4) [RFC1702] and\
    \ IP Encapsulation within IP\n   (IPv4INIPv4) [RFC1853][RFC2003], Minimal Encapsulation\
    \ within IP\n   (MINENC) [RFC2004], IPv6 over IPv4 Tunneling (IPv6INIPv4) [RFC4213],\n\
    \   Generic Packet Tunneling in IPv6 Specification (IPv6GEN) [RFC2473]\n   and\
    \ IPsec tunneling mode [RFC4301] [RFC4303].  Among these tunneling\n   protocols,\
    \ the tunnel headers in IPv4INIPv4, IPv6INIPv4, and IPv6GEN\n   contain only a\
    \ tunnel IP header, and no tunnel-specific header.  All\n   the other tunneling\
    \ protocols have a tunnel header consisting of both\n   a tunnel IP header and\
    \ a tunnel-specific header.  The tunnel-specific\n   header is the GRE header\
    \ for GRE and GREIPv4, the minimum\n   encapsulation header for MINENC, and the\
    \ ESP header for IPsec\n   tunneling mode.  As will be discussed in Section 4.3,\
    \ some of the\n   tunnel-specific headers may be used to identify a flow in the\
    \ tunnel\n   and facilitate NSIS operating over IP tunnels.\n"
- title: 3.2.  NSIS QoS Signaling in the Presence of IP Tunnels
  contents:
  - "3.2.  NSIS QoS Signaling in the Presence of IP Tunnels\n   Typically, applications\
    \ use NSIS QoS signaling to reserve resources\n   for a flow along the flow path.\
    \  NSIS QoS signaling can be initiated\n   by either the flow sender or flow receiver.\
    \  Figure 3 shows an\n   example scenario with five NSIS nodes, including flow\
    \ sender node A,\n   flow receiver node E, and intermediate NSIS nodes B, C, and\
    \ D.  Nodes\n   that are not NSIS QoS capable are not shown.\n    NSIS QoS   \
    \    NSIS QoS     NSIS QoS      NSIS QoS       NSIS QoS\n    Node           Node\
    \         Node          Node           Node\n    +-+            +-+          +-+\
    \           +-+            +-+\n    |A|-->--//-->--|B|----->----|C|---//-->---|D|-->--//-->--|E|\n\
    \    +-+            +-+          +-+           +-+            +-+\n    Flow  \
    \                                                   Flow\n    Sender         \
    \                                          Receiver\n    Node                \
    \                                     Node\n             Figure 3: Example Scenario\
    \ of NSIS QoS Signaling\n   Figure 4 illustrates a sender-initiated signaling\
    \ sequence in the\n   scenario of Figure 3.  Sender node A sends a RESERVE message\
    \ towards\n   receiver node E.  The RESERVE message gets forwarded by intermediate\n\
    \   NSIS Nodes B, C, and D and finally reaches receiver node E.  Receiver\n  \
    \ node E then sends back a RESPONSE message confirming the QoS\n   reservation,\
    \ again through the previous intermediate NSIS nodes in\n   the flow path.\n \
    \  There are two important aspects in the above signaling process that\n   are\
    \ worth mentioning.  First, the flow sender does not initially know\n   exactly\
    \ which intermediate nodes are NSIS-aware and should be\n   involved in the signaling\
    \ process for a flow from node A to node E.\n    Discovery of those nodes (namely,\
    \ nodes B, C, and D) is accomplished\n   by a separate NSIS peer discovery process\
    \ (not shown above; see\n   [RFC5971]).  The NSIS peer discovery messages contain\
    \ special IP\n   header and payload formats or include a Router Alert Option (RAO)\n\
    \   [RFC2113] [RFC2711].  The special formats of NSIS discovery messages\n   allow\
    \ nodes B, C, and D to intercept the messages and subsequently\n   insert themselves\
    \ into the signaling path for the flow in question.\n   After formation of the\
    \ signaling path, all signaling messages\n   corresponding to this flow will be\
    \ passed to these nodes for\n   processing.  Other nodes that are not NSIS-aware\
    \ simply forward all\n   signaling messages, as they would any other IP packets\
    \ that do not\n   require additional handling.\n    Node A         Node B    \
    \     Node C         Node D         Node E\n      |              |           \
    \   |              |              |\n      |   RESERVE    |              |   \
    \           |              |\n      +------------->|              |          \
    \    |              |\n      |              |   RESERVE    |              |  \
    \            |\n      |              +------------->|              |         \
    \     |\n      |              |              |   RESERVE    |              |\n\
    \      |              |              +------------->|              |\n      |\
    \              |              |              |   RESERVE    |\n      |       \
    \       |              |              +------------->|\n      |              |\
    \              |              |   RESPONSE   |\n      |              |       \
    \       |              |<-------------+\n      |              |              |\
    \   RESPONSE   |              |\n      |              |              |<-------------+\
    \              |\n      |              |   RESPONSE   |              |       \
    \       |\n      |              |<-------------+              |              |\n\
    \      |   RESPONSE   |              |              |              |\n      |<-------------+\
    \              |              |              |\n      |              |       \
    \       |              |              |\n      |              |              |\
    \              |              |\n               Figure 4: Sender-Initiated NSIS\
    \ QoS Signaling\n   Second, the goal of QoS signaling is to install control information\n\
    \   to give QoS treatment for the flow being signaled.  Basic QoS control\n  \
    \ information includes the data Flow ID for packet classification and\n   the\
    \ type of QoS treatment those packets are entitled to.  The Flow ID\n   contains\
    \ a set of header fields such as flow sender and receiver\n   addresses, and protocol\
    \ and port numbers.\n   Now consider Figure 5 where nodes B, C, and D are endpoints\
    \ and\n   intermediate nodes of an IP tunnel.  During the signaling path\n   discovery\
    \ process, node B can still intercept and process NSIS peer\n   discovery messages\
    \ if it recognizes them before performing tunnel\n   encapsulation; node D can\
    \ identify NSIS peer discovery messages after\n   performing tunnel decapsulation.\
    \  A tunnel intermediate node such as\n   node C, however, only sees the tunnel\
    \ header of the packets and will\n   not be able to identify the original NSIS\
    \ peer discovery message or\n   insert itself in the flow signaling path.  Furthermore,\
    \ the Flow ID\n   of the original flow is based on IP header fields of the original\n\
    \   packet.  Those fields are also hidden in the payload of the tunnel\n   packet.\
    \  So, there is no way node C can classify packets belonging to\n   that flow\
    \ in the tunnel.\n                     Tunnel from node B to node D\n        \
    \              <---------------------->\n                   Tunnel       Tunnel\
    \        Tunnel\n                   Entry-Point  Intermediate  Exit-Point\n  \
    \  NSIS QoS       NSIS QoS     NSIS QoS      NSIS QoS       NSIS QoS\n    Node\
    \           Node         Node          Node           Node\n    +-+          \
    \  +-+          +-+           +-+            +-+\n    |A|-->--//-->--|B|=====>====|C|===//==>===|D|-->--//-->--|E|\n\
    \    +-+            +-+          +-+           +-+            +-+\n    Flow  \
    \                                                   Flow\n    Sender         \
    \                                          Receiver\n    Node                \
    \                                     Node\n      Figure 5: Example Scenario of\
    \ NSIS QoS Signaling with IP Tunnel\n   In summary, an IP tunnel segment normally\
    \ appears like a QoS-unaware\n   virtual link.  Since the best QoS of an end-to-end\
    \ path is judged\n   based on its weakest segment, we need a mechanism to extend\
    \ NSIS into\n   the IP tunnel segments, which should allow the tunnel intermediate\n\
    \   nodes to intercept original NSIS signaling messages and classify\n   original\
    \ data flow packets in the presence of tunnel encapsulation.\n"
- title: 4.  Design Overview
  contents:
  - '4.  Design Overview

    '
- title: 4.1.  Design Requirements
  contents:
  - "4.1.  Design Requirements\n   We identify the following design requirements for\
    \ NSIS operating over\n   IP tunnels.\n   o  The mechanism should work with all\
    \ common IP tunneling protocols\n      listed in Section 3.1.\n   o  Some IP tunnels\
    \ maintain preconfigured QoS sessions inside the\n      tunnel.  The mechanism\
    \ should work for IP tunnels both with and\n      without preconfigured tunnel\
    \ QoS sessions.\n   o  The mechanism should minimize the required upgrade to existing\n\
    \      infrastructure in order to facilitate its deployment.\n      Specifically,\
    \ we should limit the necessary upgrade to the tunnel\n      endpoints.\n   o\
    \  The mechanism should provide a method for one NSIS-tunnel-aware\n      endpoint\
    \ to discover whether the other endpoint is also NSIS-\n      tunnel-aware, when\
    \ necessary.\n   o  The mechanism should learn from the design experience of previous\n\
    \      related work on RSVP over IP tunnels (RSVP-TUNNEL) [RFC2746],\n      while\
    \ also addressing the following major differences of NSIS from\n      RSVP.  First,\
    \ NSIS is designed as a generic framework to\n      accommodate various signaling\
    \ application needs, and therefore is\n      split into a signaling transport\
    \ layer and a signaling application\n      layer; RSVP does not have a layer split\
    \ and is designed only for\n      QoS signaling.  Second, NSIS QoS NSLP allows\
    \ both sender-initiated\n      and receiver-initiated reservations; RSVP only\
    \ supports receiver-\n      initiated reservations.  Third, NSIS deals only with\
    \ unicast; RSVP\n      also supports multicast.  Fourth, NSIS integrates a new\
    \ SESSION-ID\n      feature which is different from the session identification\
    \ concept\n      in RSVP.\n"
- title: 4.2.  Overall Design Approach
  contents:
  - "4.2.  Overall Design Approach\n   The overall design of this NSIS signaling and\
    \ IP tunnel interworking\n   mechanism draws similar concepts from RSVP-TUNNEL\
    \ [RFC2746], but is\n   tailored and extended for NSIS operation.\n   Since we\
    \ only consider unidirectional flows, to accommodate flows in\n   both directions\
    \ of a tunnel, we require both tunnel entry-point and\n   tunnel exit-point to\
    \ be NSIS-tunnel-aware.  An NSIS-tunnel-aware\n   endpoint knows whether the other\
    \ tunnel endpoint is NSIS-tunnel-aware\n   either through preconfiguration or\
    \ through an NSIS-tunnel capability\n   discovery mechanism defined in Section\
    \ 7.\n   Tunnel endpoints need to always intercept NSIS peer discovery\n   messages\
    \ and insert themselves into the NSIS signaling path so they\n   can receive all\
    \ NSIS signaling messages and coordinate their\n   interaction with tunnel QoS.\n\
    \   To facilitate QoS handling in the tunnel, an end-to-end QoS session\n   is\
    \ mapped to a tunnel QoS session, either preconfigured or\n   dynamically created.\
    \  The tunnel session uses a tunnel Flow ID based\n   on information available\
    \ in the tunnel headers, thus allowing tunnel\n   intermediate nodes to classify\
    \ flow packets correctly.\n   For tunnels that maintain preconfigured QoS sessions,\
    \ upon receiving\n   a request to reserve resources for an end-to-end session,\
    \ the tunnel\n   endpoint maps the end-to-end QoS session to an existing tunnel\n\
    \   session.  To simplify the design, the mapping decision is always made\n  \
    \ by the tunnel entry-point, regardless of whether the end-to-end\n   session\
    \ uses sender-initiated or receiver-initiated NSIS signaling\n   mode.  The details\
    \ about which end-to-end session can be mapped to\n   which preconfigured tunnel\
    \ session depend on policy mechanisms\n   outside the scope of this document.\n\
    \   For tunnels that do not maintain preconfigured QoS sessions, the\n   NSIS-tunnel-aware\
    \ endpoints dynamically create and manage a\n   corresponding tunnel QoS session\
    \ for the end-to-end session.  Since\n   the initiation mode of both QoS sessions\
    \ can be sender-initiated or\n   receiver-initiated, to simplify the design, we\
    \ require that the\n   initiation mode of the tunnel QoS session follows that\
    \ of the end-to-\n   end QoS session.  In other words, the end-to-end QoS session\
    \ and its\n   corresponding tunnel QoS session are either both sender-initiated\
    \ or\n   both receiver-initiated.  To keep the handling mechanism consistent\n\
    \   with the case for tunnels with preconfigured QoS sessions, the tunnel\n  \
    \ entry-point always initiates the mapping between the tunnel session\n   and\
    \ the end-to-end session.\n   As the mapping initiator, the tunnel entry-point\
    \ records the\n   association between the end-to-end session and its corresponding\n\
    \   tunnel session, both in tunnels with and without preconfigured QoS\n   sessions.\
    \  This association serves two purposes, one for the\n   signaling plane and the\
    \ other for the data plane.  For the signaling\n   plane, the association enables\
    \ the tunnel entry-point to coordinate\n   necessary interactions between the\
    \ end-to-end and the tunnel QoS\n   sessions, such as QoS adjustment in sender-initiated\
    \ reservations.\n   For the data plane, the association allows the tunnel entry-point\
    \ to\n   correctly encapsulate data flow packets according to the chosen\n   tunnel\
    \ Flow ID.  Since the tunnel Flow ID uses header fields that are\n   visible inside\
    \ the tunnel, the tunnel intermediate nodes can classify\n   the data flow packets\
    \ and apply appropriate QoS treatment.\n   In addition to the tunnel entry-point\
    \ recording the association\n   between the end-to-end session and its corresponding\
    \ tunnel session,\n   the tunnel exit-point also needs to maintain the same association\
    \ for\n   similar reasons.  For the signaling plane, this association at the\n\
    \   tunnel exit-point enables the interaction of the end-to-end and the\n   tunnel\
    \ QoS session such as QoS adjustment in receiver-initiated\n   reservations. \
    \ For the data plane, this association tells the tunnel\n   exit-point that the\
    \ relevant data flow packets need to be\n   decapsulated according to the corresponding\
    \ tunnel Flow ID.\n   In tunnels with preconfigured QoS sessions, the tunnel exit-point\
    \ may\n   also learn about the mapping information between the corresponding\n\
    \   tunnel and end-to-end QoS sessions through preconfiguration as well.\n   In\
    \ tunnels without preconfigured QoS sessions, the tunnel exit-point\n   knows\
    \ the mapping between the corresponding tunnel and end-to-end QoS\n   sessions\
    \ through the NSIS signaling process that creates the tunnel\n   QoS sessions\
    \ inside the tunnel, with the help of appropriate QoS NSLP\n   session-binding\
    \ and message-binding mechanisms.\n   One problem for NSIS operating over IP tunnels\
    \ that dynamically\n   create QoS sessions is that it involves two signaling sequences.\
    \  The\n   outcome of the tunnel signaling session directly affects the outcome\n\
    \   of the end-to-end signaling session.  Since the two signaling\n   sessions\
    \ overlap in time, there are circumstances when a tunnel\n   endpoint has to decide\
    \ whether it should proceed with the end-to-end\n   signaling session while it\
    \ is still waiting for results of the tunnel\n   session.  This problem can be\
    \ addressed in two ways, namely\n   sequential mode and parallel mode.  In sequential\
    \ mode, end-to-end\n   signaling pauses while it is waiting for results of tunnel\
    \ signaling,\n   and resumes upon receipt of the tunnel signaling outcome.  In\n\
    \   parallel mode, end-to-end signaling continues outside the tunnel\n   while\
    \ tunnel signaling is still in process and its outcome is\n   unknown.  The parallel\
    \ mode may lead to reduced signaling delays if\n   the QoS resources in the tunnel\
    \ path are sufficient compared to the\n   rest of the end-to-end path.  If the\
    \ QoS resources in the tunnel path\n   are more constraint than the rest of the\
    \ end-to-end path, however,\n   the parallel mode may lead to wasted end-to-end\
    \ signaling or may\n   necessitate renegotiation after the tunnel signaling outcome\
    \ becomes\n   available.  In those cases, the signaling flow of the parallel mode\n\
    \   also tends to be complicated.  This document adopts a sequential mode\n  \
    \ approach for the two signaling sequences.\n"
- title: 4.3.  Tunnel Flow ID for Different IP Tunneling Protocols
  contents:
  - "4.3.  Tunnel Flow ID for Different IP Tunneling Protocols\n   A tunnel Flow ID\
    \ identifies the end-to-end flow for packet\n   classification within the tunnel.\
    \  The tunnel Flow ID is based on a\n   set of tunnel header fields.  Different\
    \ tunnel Flow IDs can be chosen\n   for different tunneling mechanisms in order\
    \ to minimize the\n   classification overhead.  This document specifies the following\
    \ Flow\n   ID formats for the respective tunneling protocols.\n   o  For IPv6\
    \ tunneling protocols (IPv6GEN), the tunnel Flow ID\n      consists of the tunnel\
    \ entry-point IPv6 address and the tunnel\n      exit-point IPv6 address plus\
    \ a unique IPv6 flow label [RFC3697].\n   o  For IPsec tunnel mode (IPsec), the\
    \ tunnel Flow ID contains the\n      tunnel entry-point IP address and the tunnel\
    \ exit-point IP address\n      plus the Security Parameter Index (SPI).\n   o\
    \  For all other tunneling protocols (GRE, GREIPv4, IPv4INIPv4,\n      MINENC,\
    \ IPv6INIPv4), the tunnel entry-point inserts an additional\n      UDP header\
    \ between the tunnel header and the original packet.  The\n      Flow ID consists\
    \ of the tunnel entry-point and tunnel exit-point\n      IP addresses and the\
    \ source port number in the additional UDP\n      header.  The source port number\
    \ is dynamically chosen by the\n      tunnel entry-point and conveyed to the tunnel\
    \ exit-point.  In\n      these cases, it is especially important that the tunnel\
    \ exit-point\n      understands the additional UDP encapsulation, and therefore\
    \ can\n      correctly decapsulate both the normal tunnel header and the\n   \
    \   additional UDP header.  In other words, both tunnel endpoints need\n     \
    \ to be NSIS-tunnel-aware.\n   The above recommendations about choosing the tunnel\
    \ Flow ID apply to\n   dynamically created QoS tunnel sessions.  For preconfigured\
    \ QoS\n   tunnel sessions, the corresponding Flow ID is determined by the\n  \
    \ configuration mechanism itself.  For example, if the tunnel QoS is\n   Diffserv\
    \ based, the Diffserv Code Point (DSCP) field value may be\n   used to identify\
    \ the corresponding tunnel session.\n"
- title: 5.  NSIS Operation over Tunnels with Preconfigured QoS Sessions
  contents:
  - "5.  NSIS Operation over Tunnels with Preconfigured QoS Sessions\n   When tunnel\
    \ QoS is managed by preconfigured QoS sessions, both the\n   tunnel entry-point\
    \ and tunnel exit-point need to be configured with\n   information about the Flow\
    \ ID of the tunnel QoS session.  This allows\n   the tunnel endpoints to correctly\
    \ perform matching encapsulating and\n   decapsulating operations.  The procedures\
    \ of NSIS operating over\n   tunnels with preconfigured QoS sessions depend on\
    \ whether the end-to-\n   end NSIS signaling is sender-initiated or receiver-initiated.\
    \  But in\n   both cases, it is the tunnel entry-point that first creates the\n\
    \   mapping between a tunnel session and an end-to-end session.\n"
- title: 5.1.  Sender-initiated Reservation
  contents:
  - "5.1.  Sender-initiated Reservation\n   Figure 6 illustrates the signaling sequence\
    \ when end-to-end signaling\n   outside the tunnel is sender-initiated.  Upon\
    \ receiving a RESERVE\n   message from the sender, Tentry checks the tunnel QoS\
    \ configuration,\n   determines whether and how this end-to-end session can be\
    \ mapped to a\n   preconfigured tunnel session.  The mapping criteria are part\
    \ of the\n   preconfiguration and outside the scope of this document.  Tentry\
    \ then\n   tunnels the RESERVE message to Texit.  Texit forwards the RESERVE\n\
    \   message to the receiver.  The receiver replies with a RESPONSE\n   message\
    \ that arrives at Texit, Tentry, and finally the sender.  If\n   the RESPONSE\
    \ message that Tentry receives confirms that the overall\n   signaling is successful,\
    \ Tentry starts to encapsulate all incoming\n   packets of the data flow using\
    \ the tunnel Flow ID corresponding to\n   the mapped tunnel session.  Texit knows\
    \ how to decapsulate the tunnel\n   packets because it recognizes the mapped tunnel\
    \ Flow ID based on\n   information supplied during tunnel session preconfiguration.\n\
    \    Sender         Tentry          Tmid          Texit         Receiver\n   \
    \   |              |              |              |              |\n      |   RESERVE\
    \    |              |              |              |\n      +------------->|  \
    \            |              |              |\n      |              |         \
    \  RESERVE           |              |\n      |              +---------------------------->|\
    \              |\n      |              |              |              |   RESERVE\
    \    |\n      |              |              |              +------------->|\n\
    \      |              |              |              |   RESPONSE   |\n      |\
    \              |              |              |<-------------+\n      |       \
    \       |           RESPONSE          |              |\n      |              |<----------------------------+\
    \              |\n      |   RESPONSE   |              |              |       \
    \       |\n      |<-------------+              |              |              |\n\
    \      |              |              |              |              |\n      |\
    \              |              |              |              |\n     Figure 6:\
    \ Sender-Initiated End-to-End Session with Preconfigured\n                   \
    \         Tunnel QoS Sessions\n"
- title: 5.2.  Receiver-Initiated Reservation
  contents:
  - "5.2.  Receiver-Initiated Reservation\n   Figure 7 shows the signaling sequence\
    \ when end-to-end signaling\n   outside the tunnel is receiver-initiated.  Upon\
    \ receiving the first\n   end-to-end Query message, Tentry examines the tunnel\
    \ QoS\n   configuration, then updates and tunnels the Query message to Texit.\n\
    \   Texit decapsulates the QUERY message, processes it, and forwards it\n   toward\
    \ the receiver.  The receiver sends back a RESERVE message\n   passing through\
    \ Texit and arriving at Tentry.  Tentry decides on\n   whether and how the QoS\
    \ request for this end-to-end session can be\n   mapped to a preconfigured tunnel\
    \ session based on criteria outside\n   the scope of this document.  Then, Tentry\
    \ forwards the RESERVE\n   message towards the sender.  The signaling continues\
    \ until a RESPONSE\n   message arrives at Tentry, Texit, and finally the receiver.\
    \  If the\n   RESPONSE message that Tentry receives confirms that the overall\n\
    \   signaling is successful, Tentry starts to encapsulate all incoming\n   packets\
    \ of the data flow using the tunnel Flow ID corresponding to\n   the mapped tunnel\
    \ session.  Similarly, Texit knows how to decapsulate\n   the tunnel packets because\
    \ it recognizes the mapped tunnel Flow ID\n   based on information supplied during\
    \ tunnel session preconfiguration.\n   Since separate tunnel QoS signaling is\
    \ not involved in preconfigured\n   QoS tunnels, Figures 6 and 7 make the tunnel\
    \ look like a single\n   virtual link.  The signaling path simply skips all tunnel\n\
    \   intermediate nodes.  However, both Tentry and Texit need to deploy\n   the\
    \ NSIS-tunnel-related functionalities described above, including\n   acting on\
    \ the end-to-end NSIS signaling messages based on tunnel QoS\n   status, mapping\
    \ end-to-end and tunnel QoS sessions, and correctly\n   encapsulating and decapsulating\
    \ tunnel packets according to the\n   tunnel protocol and the configured tunnel\
    \ Flow ID.\n    Sender         Tentry          Tmid          Texit         Receiver\n\
    \      |              |              |              |              |\n      |\
    \    QUERY     |              |              |              |\n      +------------->|\
    \              |              |              |\n      |              |       \
    \     QUERY            |              |\n      |              +---------------------------->|\
    \              |\n      |              |              |              |    QUERY\
    \     |\n      |              |              |              +------------->|\n\
    \      |              |              |              |   RESERVE    |\n      |\
    \              |              |              |<-------------+\n      |       \
    \       |           RESERVE           |              |\n      |              |<----------------------------+\
    \              |\n      |   RESERVE    |              |              |       \
    \       |\n      |<-------------+              |              |              |\n\
    \      |   RESPONSE   |              |              |              |\n      +------------->|\
    \              |              |              |\n      |              |       \
    \    RESPONSE          |              |\n      |              +---------------------------->|\
    \              |\n      |              |              |              |   RESPONSE\
    \   |\n      |              |              |              +------------->|\n \
    \     |              |              |              |              |\n      | \
    \             |              |              |              |\n    Figure 7: Receiver-Initiated\
    \ End-to-End Session with Preconfigured\n                            Tunnel QoS\
    \ Sessions\n"
- title: 6.  NSIS Operation over Tunnels with Dynamically Created QoS Sessions
  contents:
  - "6.  NSIS Operation over Tunnels with Dynamically Created QoS Sessions\n   When\
    \ there are no preconfigured tunnel QoS sessions, a tunnel can\n   apply the same\
    \ NSIS QoS signaling mechanism used for the end-to-end\n   path to manage the\
    \ QoS inside the tunnel.  The tunnel NSIS signaling\n   involves only those NSIS\
    \ nodes in the tunnel forwarding path.  The\n   Flow IDs for the tunnel signaling\
    \ are based on tunnel header fields.\n   NSIS peer discovery messages inside the\
    \ tunnel distinguish themselves\n   using the tunnel header fields, which solves\
    \ the problem for tunnel\n   intermediate NSIS nodes to intercept signaling messages.\n\
    \   When tunnel endpoints dynamically create tunnel QoS sessions, the\n   initiation\
    \ mode of the tunnel session always follows the initiation\n   mode of the end-to-end\
    \ session.  Specifically, when the end-to-end\n   session is sender-initiated,\
    \ the tunnel session should also be\n   sender-initiated; when the end-to-end\
    \ session is receiver-initiated,\n   the tunnel session should also be receiver-initiated.\n\
    \   The tunnel entry-point conveys the corresponding tunnel Flow ID\n   associated\
    \ with an end-to-end session to the tunnel exit-point during\n   the tunnel signaling\
    \ process.  The tunnel entry-point also informs\n   the exit-point of the binding\
    \ between the corresponding tunnel\n   session and end-to-end session through\
    \ the BOUND_SESSION_ID QoS NSLP\n   message object.  The reservation message dependencies\
    \ between the\n   tunnel session and end-to-end session are resolved using the\
    \ MSG-ID\n   and BOUND-MSG-ID objects of the QoS NSLP message binding mechanism.\n"
- title: 6.1.  Sender-Initiated Reservation
  contents:
  - "6.1.  Sender-Initiated Reservation\n   Figure 8 shows the typical messaging sequence\
    \ of how NSIS operates\n   over IP tunnels when both the end-to-end session and\
    \ tunnel session\n   are sender-initiated.  Tunnel signaling messages are distinguished\n\
    \   from end-to-end messages by a prime symbol after the message name.\n   The\
    \ sender first sends an end-to-end RESERVE message (1) that arrives\n   at Tentry.\
    \  Tentry chooses the tunnel Flow ID, creates the tunnel\n   session, and associates\
    \ the end-to-end session with the tunnel\n   session.  Tentry then sends a tunnel\
    \ RESERVE' message (2) matching\n   the request of the end-to-end session towards\
    \ Texit to reserve tunnel\n   resources.  This RESERVE' message (2) includes a\
    \ MSG-ID object that\n   contains a randomly generated 128-bit MSG-ID.  Meanwhile,\
    \ Tentry\n   inserts a BOUND-MSG-ID object containing the same MSG-ID as well\
    \ as a\n   BOUND-SESSION-ID object containing the SESSION-ID of the tunnel\n \
    \  session into the original RESERVE message, and sends this RESERVE\n   message\
    \ (3) towards Texit using normal tunnel encapsulation.  The\n   Message_Binding_Type\
    \ flags of both the MSG-ID and BOUND-MSG-ID\n   objects in the RESERVE' and RESERVE\
    \ messages (2, 3) are SET,\n   indicating a bidirectional binding.  The tunnel\
    \ RESERVE' message (2)\n   is processed hop-by-hop inside the tunnel for the flow\
    \ identified by\n   the chosen tunnel Flow ID, while the end-to-end RESERVE message\
    \ (3)\n   passes through the tunnel intermediate nodes (Tmid) just like other\n\
    \   tunneled packets.  These two messages could arrive at Texit in\n   different\
    \ orders, and the reaction of Texit in these different\n   situations should combine\
    \ the tunnel QoS message processing rules\n   with the QoS NSLP processing principles\
    \ for message binding\n   [RFC5974], as illustrated below.\n   The first possibility\
    \ is shown in the example messaging flow of\n   Figure 8, where the tunnel RESERVE'\
    \ message (2), also known as the\n   triggering message in QoS NSLP message binding\
    \ terms, arrives first.\n   Since the message binding is bidirectional, Texit\
    \ records the MSG-ID\n   of the RESERVE' message (2), enqueues it and starts a\
    \ MsgIDWait timer\n   waiting for the end-to-end RESERVE message (3), also known\
    \ as the\n   bound signaling message in QoS NSLP message binding terms.  The timer\n\
    \   Sender         Tentry         Tmid           Texit         Receiver\n    \
    \ |              |              |              |              |\n     | RESERVE(1)\
    \   |              |              |              |\n     +------------->|    \
    \          |              |              |\n     |              | RESERVE'(2)\
    \  |              |              |\n     |              +=============>|     \
    \         |              |\n     |              |              | RESERVE'(2) \
    \ |              |\n     |              |              +=============>|      \
    \        |\n     |              |          RESERVE(3)         |              |\n\
    \     |              +---------------------------->|              |\n     |  \
    \            |              | RESPONSE'(4) |              |\n     |          \
    \    |              |<=============+              |\n     |              | RESPONSE'(4)\
    \ |              |              |\n     |              |<=============+      \
    \        |              |\n     |              |              |              |\
    \  RESERVE(5)  |\n     |              |              |              +------------->|\n\
    \     |              |              |              | RESPONSE(6)  |\n     |  \
    \            |              |              |<-------------+\n     |          \
    \    |         RESPONSE(6)         |              |\n     |              |<----------------------------+\
    \              |\n     | RESPONSE(6)  |              |              |        \
    \      |\n     |<-------------+              |              |              |\n\
    \     |              |              |              |              |\n     |  \
    \            |              |              |              |\n     (1,5): RESERVE\
    \ w/o BOUND-MSG-ID and BOUND-SESSION-ID\n     (2): RESERVE' w/ MSG-ID\n     (3):\
    \ RESERVE w/ BOUND-MSG-ID and BOUND-SESSION-ID\n   Figure 8: Sender-Initiated\
    \ Reservation for Both End-to-End and Tunnel\n                               \
    \  Signaling\n   value is set to the default retransmission timeout period\n \
    \  QOSNSLP_REQUEST_RETRY.  When the end-to-end RESERVE message (3)\n   arrives,\
    \ Texit notices that there is an existing stored MSG-ID which\n   matches the\
    \ MSG-ID in the BOUND-MSG-ID object of the incoming RESERVE\n   message (3). \
    \ Therefore, the message binding condition has been\n   satisfied.  Texit resumes\
    \ processing of the tunnel RESERVE' message\n   (2), creates the reservation state\
    \ for the tunnel session, and sends\n   a tunnel RESPONSE' message (4) to Tentry.\
    \  At the same time, Texit\n   checks the BOUND-SESSION-ID object of the end-to-end\
    \ RESERVE message\n   (3) and records the binding of the corresponding tunnel\
    \ session with\n   the end-to-end session.  Texit also updates the end-to-end\
    \ RESERVE\n   message based on the result of the tunnel session reservation,\n\
    \   removes its tunnel BOUND-SESSION-ID and BOUND-MSG-ID object and\n   forwards\
    \ the end-to-end RESERVE message (5) along the path towards\n   the receiver.\
    \  When the receiver receives the end-to-end RESERVE\n   message (5), it sends\
    \ an end-to-end RESPONSE message (6) back to the\n   sender.\n   The second possibility\
    \ is that the end-to-end RESERVE message arrives\n   before the tunnel RESERVE'\
    \ message at Texit.  In that case, Texit\n   notices a BOUND-SESSION-ID object\
    \ and a BOUND-MSG-ID object in the\n   end-to-end RESERVE message, but realizes\
    \ that the tunnel session does\n   not exist yet.  So, Texit enqueues the RESERVE\
    \ message and starts a\n   MsgIDWait timer.  The timer value is set to the default\n\
    \   retransmission timeout period QOSNSLP_REQUEST_RETRY.  When the\n   corresponding\
    \ tunnel RESERVE' message arrives with a MSG-ID matching\n   that of the outstanding\
    \ BOUND-MSG-ID object, the message binding\n   condition is satisfied.  Texit\
    \ sends a tunnel RESPONSE' message back\n   to Tentry and updates the end-to-end\
    \ RESERVE message by incorporating\n   the result of the tunnel session reservation,\
    \ as well as removing the\n   tunnel BOUND-SESSION-ID and BOUND-MSG-ID objects.\
    \  Texit then\n   forwards the end-to-end RESERVE message along the path towards\
    \ the\n   receiver.  When the receiver receives the end-to-end RESERVE message,\n\
    \   it sends an end-to-end RESPONSE message back to the sender.\n   Yet another\
    \ possibility is that the tunnel RESERVE' message arrives\n   at Texit first,\
    \ but the end-to-end RESERVE message never arrives.  In\n   that case, the MsgIDWait\
    \ timer for the queued tunnel RESERVE' message\n   will expire.  Texit should\
    \ then send a tunnel RESPONSE' message back\n   to Tentry indicating a reservation\
    \ error has occurred, and discard\n   the tunnel RESERVE' message.  The last possibility\
    \ is that the end-\n   to-end RESERVE message arrives at Texit first, but the\
    \ tunnel\n   RESERVE' message never arrives.  In that case, the MsgIDWait timer\n\
    \   for the queued end-to-end RESERVE message will expire.  Texit should\n   then\
    \ treat this situation as a local reservation failure, and\n   according to [RFC5974],\
    \ Texit as a stateful QoS NSLP should generate\n   an end-to-end RESPONSE message\
    \ indicating RESERVE error to the\n   sender.\n   Once the end-to-end and the\
    \ tunnel QoS session have both been\n   successfully created and associated, the\
    \ tunnel endpoints Tentry and\n   Texit coordinate the signaling between the two\
    \ sessions and make sure\n   that adjustment or teardown of either session may\
    \ trigger similar\n   actions for the other session as necessary, by invoking\
    \ appropriate\n   signaling messages.\n"
- title: 6.2.  Receiver-Initiated Reservation
  contents:
  - "6.2.  Receiver-Initiated Reservation\n   Figure 9 shows the typical messaging\
    \ sequence of how NSIS signaling\n   operates over IP tunnels when both end-to-end\
    \ and tunnel sessions are\n   receiver-initiated.  Upon receiving an end-to-end\
    \ QUERY message (1)\n   from the sender, Tentry chooses the tunnel Flow ID and\
    \ sends a tunnel\n   Sender         Tentry          Tmid          Texit      \
    \   Receiver\n     |              |              |              |            \
    \  |\n     |   QUERY(1)   |              |              |              |\n   \
    \  +------------->|              |              |              |\n     |     \
    \         |  QUERY'(2)   |              |              |\n     |             \
    \ +=============>|              |              |\n     |              |      \
    \        |  QUERY'(2)   |              |\n     |              |              +=============>|\
    \              |\n     |              |              | RESPONSE'(3) |        \
    \      |\n     |              |              |<=============+              |\n\
    \     |              | RESPONSE'(3) |              |              |\n     |  \
    \            |<=============+              |              |\n     |          \
    \    |           QUERY(4)          |              |\n     |              +---------------------------->|\
    \              |\n     |              |              |              |   QUERY(5)\
    \   |\n     |              |              |              +------------->|\n  \
    \   |              |              |              |  RESERVE(6)  |\n     |    \
    \          |              |              |<-------------+\n     |            \
    \  |              | RESERVE'(7)  |              |\n     |              |     \
    \         |<=============+              |\n     |              | RESERVE'(7) \
    \ |              |              |\n     |              |<=============+      \
    \        |              |\n     |              |          RESERVE(8)         |\
    \              |\n     |              |<----------------------------+        \
    \      |\n     |              | RESPONSE'(9) |              |              |\n\
    \     |              +=============>|              |              |\n     |  \
    \            |              | RESPONSE'(9) |              |\n     |          \
    \    |              +=============>|              |\n     | RESERVE(10)  |   \
    \           |              |              |\n     |<-------------+           \
    \   |              |              |\n     | RESPONSE(11) |              |    \
    \          |              |\n     +------------->|              |            \
    \  |              |\n     |              |         RESPONSE(11)        |     \
    \         |\n     |              +---------------------------->|             \
    \ |\n     |              |              |              | RESPONSE(11) |\n    \
    \ |              |              |              +------------->|\n     |      \
    \        |              |              |              |\n     |              |\
    \              |              |              |\n     (1), (5): QUERY w/ RESERVE-INIT\n\
    \     (2): QUERY' w/ RII\n     (4): QUERY w/ RESERVE-INIT and BOUND-SESSION-ID\n\
    \     (6), (10): RESERVE w/o BOUND-SESSION-ID\n     (7): RESERVE' w/ MSG-ID\n\
    \     (8): RESERVE w/ BOUND-MSG-ID and BOUND-SESSION-ID\n     Figure 9: Receiver-Initiated\
    \ Reservation for Both End-to-end and\n                             Tunnel Signaling\n\
    \   QUERY' message (2) matching the request of the end-to-end session\n   towards\
    \ Texit.  This tunnel QUERY' message (2) is meant to discover\n   QoS characteristics\
    \ of the tunnel path, rather than initiate an\n   actual reservation.  Therefore,\
    \ it includes a Request Identification\n   Information (RII) object but does not\
    \ set the RESERVE-INIT flag.  The\n   tunnel QUERY' message (2) is processed hop-by-hop\
    \ inside the tunnel\n   for the flow identified by the tunnel Flow ID.  When Texit\
    \ receives\n   this tunnel QUERY' message (2), it replies with a corresponding\n\
    \   tunnel RESPONSE' message (3) containing the tunnel path\n   characteristics.\
    \  After receiving the tunnel RESPONSE' message (3),\n   Tentry creates the tunnel\
    \ session, generates an outgoing end-to-end\n   QUERY message (4) considering\
    \ the tunnel path characteristics,\n   appends a tunnel BOUND-SESSION-ID object\
    \ containing the tunnel\n   SESSION-ID, and sends it toward Texit using normal\
    \ tunnel\n   encapsulation.  The end-to-end QUERY message (4) passes along tunnel\n\
    \   intermediate nodes like other tunneled packets.  Upon receiving this\n   end-to-end\
    \ QUERY message (4), Texit notices the tunnel session\n   binding, creates the\
    \ tunnel session state, removes the tunnel BOUND-\n   SESSION-ID object, and forwards\
    \ the end-to-end QUERY message (5)\n   further along the path.\n   The end-to-end\
    \ QUERY message (5) arrives at the receiver and triggers\n   a RESERVE message\
    \ (6).  When Texit receives the RESERVE message (6),\n   it notices that the session\
    \ is bound to a receiver-initiated tunnel\n   session.  Therefore, Texit triggers\
    \ a RESERVE' message (7) toward\n   Tentry for the tunnel session reservation.\
    \  This tunnel RESERVE'\n   message (7) includes a randomly generated 128-bit\
    \ MSG-ID.  Meanwhile,\n   Texit inserts a BOUND-MSG-ID object containing the same\
    \ MSG-ID and a\n   BOUND-SESSION-ID object containing the tunnel SESSION-ID into\
    \ the\n   end-to-end RESERVE message (8), and sends it towards Tentry using\n\
    \   normal tunnel encapsulation.  The Message_Binding_Type flags of the\n   MSG-ID\
    \ and BOUND-MSG-ID objects in the RESERVE' and RESERVE messages\n   (7,8) are\
    \ SET, indicating a bidirectional binding.\n   At Tentry, the tunnel RESERVE'\
    \ message (7) and the end-to-end RESERVE\n   message (8) could arrive in either\
    \ order.  In a typical case shown in\n   Figure 9, the tunnel RESERVE' message\
    \ (7) arrives first.  Tentry then\n   records the MSG-ID of the tunnel RESERVE'\
    \ message (7) and starts a\n   MsgIDWait timer.  When the end-to-end RESERVE message\
    \ (8) with the\n   BOUND-MSG-ID object containing the same MSG-ID arrives, the\
    \ message\n   binding condition is satisfied.  Tentry resumes processing of the\n\
    \   tunnel RESERVE' message (7), creates the reservation state for the\n   tunnel\
    \ session, and sends a tunnel RESPONSE' message (9) to Texit.\n   At the same\
    \ time, Tentry creates the outgoing end-to-end RESERVE\n   message (10) by incorporating\
    \ results of the tunnel session\n   reservation and removing the BOUND-SESSION-ID\
    \ and BOUND-MSG-ID\n   objects, and forwards it along the path towards the sender.\
    \  When the\n   sender receives the end-to-end RESERVE message (10), it sends\
    \ an end-\n   to-end RESPONSE message (11) back to the receiver.\n   If the end-to-end\
    \ RESERVE message arrives before the tunnel RESERVE'\n   message at Tentry, or\
    \ either of the two messages fails to arrive at\n   Tentry, the processing rules\
    \ at Tentry are similar to those of Texit\n   in the situation discussed in Section\
    \ 6.1.\n   Once the end-to-end and the tunnel QoS session have both been\n   successfully\
    \ created and associated, the tunnel endpoints Tentry and\n   Texit coordinate\
    \ the signaling between the two sessions and make sure\n   that adjustment or\
    \ teardown of either session can trigger similar\n   actions for the other session\
    \ as necessary, by invoking appropriate\n   signaling messages.\n"
- title: 7.  NSIS-Tunnel Signaling Capability Discovery
  contents:
  - "7.  NSIS-Tunnel Signaling Capability Discovery\n   The mechanism of NSIS operating\
    \ over IP tunnels requires the\n   coordination of both tunnel endpoints in tasks\
    \ such as special\n   encapsulation and decapsulation of data flow packets according\
    \ to the\n   chosen tunnel Flow ID, as well as the possible creation and\n   adjustment\
    \ of the end-to-end and tunnel QoS sessions.  Therefore, one\n   NSIS-tunnel-aware\
    \ endpoint needs to know that the other tunnel\n   endpoint is also NSIS-tunnel-aware\
    \ before initiating this mechanism\n   of NSIS operating over IP tunnels.  In\
    \ some cases, especially for IP\n   tunnels with preconfigured QoS sessions, an\
    \ NSIS-tunnel-aware\n   endpoint can learn about whether the other tunnel endpoint\
    \ is also\n   NSIS-tunnel-aware through preconfiguration.  In other cases where\n\
    \   such preconfiguration is not available, the initiating NSIS-tunnel-\n   aware\
    \ endpoint may dynamically discover the other tunnel endpoint's\n   capability\
    \ through a QoS NSLP NODE_CAPABILITY_TUNNEL object defined\n   in this section.\n\
    \   The NODE_CAPABILITY_TUNNEL object is a zero-length object with a\n   standard\
    \ NSLP object header as shown in Figure 10.\n     0                   1      \
    \             2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |A|B|r|r|         Type          |r|r|r|r|        Length         |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \              Figure 10: NODE_CAPABILITY_TUNNEL Object Format\n   Type: NODE_CAPABILITY_TUNNEL\
    \ (0x015) from the shared NSLP object type\n   space\n   Length: 0\n   The bits\
    \ marked 'A' and 'B' define the desired behavior for objects\n   whose Type field\
    \ is not recognized.  If a node does not recognize the\n   NODE_CAPABILITY_TUNNEL\
    \ object, the desired behavior is \"Forward\".\n   That is, the object must be\
    \ retained unchanged and forwarded as a\n   result of message processing.  This\
    \ is satisfied by setting 'AB' to\n   '10'.\n   The 'r' bit stands for 'reserved'.\n\
    \   The NODE_CAPABILITY_TUNNEL object is included in a tunnel QUERY' or\n   RESERVE'\
    \ message by a tunnel endpoint that needs to learn about the\n   other endpoint's\
    \ capability for NSIS tunnel handling.  If the\n   receiving tunnel endpoint is\
    \ indeed NSIS-tunnel-aware, it recognizes\n   this object and knows that the sending\
    \ endpoint is NSIS-tunnel-aware.\n   The receiving tunnel endpoint places the\
    \ same object in a tunnel\n   RESPONSE' message to inform the sending endpoint\
    \ that it is also\n   NSIS-tunnel-aware.  The use of the NODE_CAPABILITY_TUNNEL\
    \ object in\n   the cases of sender-initiated reservation and receiver-initiated\n\
    \   reservation are as follows.\n   First, assume that the end-to-end session\
    \ is sender-initiated as in\n   Figure 8, and the NSIS-tunnel-aware Tentry wants\
    \ to discover the NSIS\n   tunnel capability of Texit.  After receiving the first\
    \ end-to-end\n   RESERVE message (1), Tentry inserts an RII object and a\n   NODE_CAPABILITY_TUNNEL\
    \ object into the tunnel RESERVE' message (2)\n   and sends it to Texit.  If Texit\
    \ is NSIS-tunnel-aware, it learns from\n   the NODE_CAPABILITY_TUNNEL object that\
    \ Tentry is also NSIS-tunnel-\n   aware and includes the same object into the\
    \ tunnel RESPONSE' message\n   (4) sent back to Tentry.\n   Second, assume that\
    \ the end-to-end session is receiver-initiated as\n   in Figure 9, and the NSIS-tunnel-aware\
    \ Tentry wants to discover the\n   NSIS tunnel capability of Texit.  Upon receiving\
    \ the first end-to-end\n   QUERY message (1), Tentry inserts an RII object and\
    \ a\n   NODE_CAPABILITY_TUNNEL object in the tunnel QUERY' message (2) and\n \
    \  sends it toward Texit.  If Texit is NSIS-tunnel-aware, it learns from\n   the\
    \ NODE_CAPABILITY_TUNNEL object that Tentry is also NSIS-tunnel-\n   aware and\
    \ includes the same object tunnel RESPONSE' message (3) sent\n   to Tentry.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   This document defines a new object type called NODE_CAPABILITY_TUNNEL\n\
    \   for QoS NSLP.  Its Type value (0x015) has been assigned by IANA.  The\n  \
    \ object format and the setting of the extensibility bits are defined\n   in Section\
    \ 7.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   This NSIS and IP tunnel interoperation mechanism\
    \ has two IPsec-\n   related security implications.  First, NSIS messages may\
    \ require per-\n   hop processing within the IPsec tunnel, and that is potentially\n\
    \   incompatible with IPsec.  A similar problem exists for RSVP\n   interacting\
    \ with IPsec, when the Router Alert option is used\n   (Appendix A.1 of RFC 4302\
    \ [RFC4302]).  If this mechanism is indeed\n   used for NSIS and IPsec tunnels,\
    \ a so-called covert channel could\n   exist where someone can create spurious\
    \ NSIS signaling flows within\n   the protected network in order to create signaling\
    \ in the outside\n   network, which then someone else is monitoring.  For highly\
    \ secure\n   networks, this would be seen as a way to smuggle information out\
    \ of\n   the network, and therefore this channel will need to be rate-limited.\n\
    \   A similar covert channel rate-limit problem exists for using\n   Differentiated\
    \ Services (DS) or Explicit Congestion Notification\n   (ECN) fields with IPsec\
    \ (Section 5.1.2 of RFC 4301 [RFC4301]).\n   Second, since the NSIS-tunnel-aware\
    \ endpoint is responsible for\n   adapting changes between the NSIS signaling\
    \ both inside and outside\n   the tunnel, there could be additional risks for\
    \ an IPsec endpoint\n   that is also an NSIS-tunnel-aware endpoint.  For example,\
    \ security\n   vulnerability (e.g., buffer overflow) on the NSIS stack of that\
    \ IPsec\n   tunnel endpoint may be exposed to the unprotected outside network.\n\
    \   Nevertheless, it should also be noted that if any node along the\n   signaling\
    \ path is compromised, the whole end-to-end QoS signaling\n   could be affected,\
    \ whether or not the end-to-end path includes an\n   IPsec tunnel.\n   Several\
    \ other documents discuss security issues for NSIS.  General\n   threats for NSIS\
    \ can be found in [RFC4081].  Security considerations\n   for NSIS NTLP and QoS\
    \ NSLP are discussed in [RFC5971] and [RFC5974],\n   respectively.\n"
- title: 10.  Acknowledgments
  contents:
  - "10.  Acknowledgments\n   The authors would like to thank Roland Bless, Francis\
    \ Dupont, Lars\n   Eggert, Adrian Farrel, Russ Housley, Georgios Karagiannis,\
    \ Jukka\n   Manner, Martin Rohricht, Peter Saint-Andre, Martin Stiemerling,\n\
    \   Hannes Tschofenig, and other members of the NSIS working group for\n   comments.\
    \  Thanks to Yaron Sheffer for pointing out the IPsec-related\n   security considerations.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2113]  Katz, D., \"IP Router Alert Option\"\
    , RFC 2113,\n              February 1997.\n   [RFC2473]  Conta, A. and S. Deering,\
    \ \"Generic Packet Tunneling in\n              IPv6 Specification\", RFC 2473,\
    \ December 1998.\n   [RFC2711]  Partridge, C. and A. Jackson, \"IPv6 Router Alert\
    \ Option\",\n              RFC 2711, October 1999.\n   [RFC2746]  Terzis, A.,\
    \ Krawczyk, J., Wroclawski, J., and L. Zhang,\n              \"RSVP Operation\
    \ Over IP Tunnels\", RFC 2746, January 2000.\n   [RFC3697]  Rajahalme, J., Conta,\
    \ A., Carpenter, B., and S. Deering,\n              \"IPv6 Flow Label Specification\"\
    , RFC 3697, March 2004.\n   [RFC4080]  Hancock, R., Karagiannis, G., Loughney,\
    \ J., and S. Van den\n              Bosch, \"Next Steps in Signaling (NSIS): Framework\"\
    ,\n              RFC 4080, June 2005.\n   [RFC4081]  Tschofenig, H. and D. Kroeselberg,\
    \ \"Security Threats for\n              Next Steps in Signaling (NSIS)\", RFC\
    \ 4081, June 2005.\n   [RFC5971]  Schulzrinne, H. and R. Hancock, \"GIST: General\
    \ Internet\n              Signalling Transport\", RFC 5971, October 2010.\n  \
    \ [RFC5974]  Manner, J., Karagiannis, G., and A. McDonald, \"NSIS\n          \
    \    Signaling Layer Protocol (NSLP) for Quality-of-Service\n              Signaling\"\
    , RFC 5974, October 2010.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [RFC1701]  Hanks, S., Li, T., Farinacci, D.,\
    \ and P. Traina, \"Generic\n              Routing Encapsulation (GRE)\", RFC 1701,\
    \ October 1994.\n   [RFC1702]  Hanks, S., Li, T., Farinacci, D., and P. Traina,\
    \ \"Generic\n              Routing Encapsulation over IPv4 networks\", RFC 1702,\n\
    \              October 1994.\n   [RFC1853]  Simpson, W., \"IP in IP Tunneling\"\
    , RFC 1853, October 1995.\n   [RFC2003]  Perkins, C., \"IP Encapsulation within\
    \ IP\", RFC 2003,\n              October 1996.\n   [RFC2004]  Perkins, C., \"\
    Minimal Encapsulation within IP\", RFC 2004,\n              October 1996.\n  \
    \ [RFC2205]  Braden, B., Zhang, L., Berson, S., Herzog, S., and S.\n         \
    \     Jamin, \"Resource ReSerVation Protocol (RSVP) -- Version 1\n           \
    \   Functional Specification\", RFC 2205, September 1997.\n   [RFC2784]  Farinacci,\
    \ D., Li, T., Hanks, S., Meyer, D., and P.\n              Traina, \"Generic Routing\
    \ Encapsulation (GRE)\", RFC 2784,\n              March 2000.\n   [RFC4213]  Nordmark,\
    \ E. and R. Gilligan, \"Basic Transition Mechanisms\n              for IPv6 Hosts\
    \ and Routers\", RFC 4213, October 2005.\n   [RFC4301]  Kent, S. and K. Seo, \"\
    Security Architecture for the\n              Internet Protocol\", RFC 4301, December\
    \ 2005.\n   [RFC4302]  Kent, S., \"IP Authentication Header\", RFC 4302,\n   \
    \           December 2005.\n   [RFC4303]  Kent, S., \"IP Encapsulating Security\
    \ Payload (ESP)\",\n              RFC 4303, December 2005.\n   [RFC5944]  Perkins,\
    \ C., Ed., \"IP Mobility Support for IPv4, Revised\",\n              RFC 5944,\
    \ November 2010.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Charles Shen\n   Columbia University\n   Department of\
    \ Computer Science\n   1214 Amsterdam Avenue, MC 0401\n   New York, NY  10027\n\
    \   USA\n   Phone: +1 212 854 3109\n   EMail: charles@cs.columbia.edu\n   Henning\
    \ Schulzrinne\n   Columbia University\n   Department of Computer Science\n   1214\
    \ Amsterdam Avenue, MC 0401\n   New York, NY  10027\n   USA\n   Phone: +1 212\
    \ 939 7004\n   EMail: hgs@cs.columbia.edu\n   Sung-Hyuck Lee\n   Convergence Technologies\
    \ & Standardization Lab\n   Samsung Information System America, INC.\n   95 West\
    \ Plumeria Drive\n   San Jose, CA  95134\n   USA\n   Phone: 1-408-544-5809\n \
    \  EMail: sung1.lee@samsung.com\n   Jong Ho Bang\n   SAMSUNG Advanced Institute\
    \ of Technology\n   San 14-1, Nongseo-ri, Giheung-eup\n   Yongin-si, Gyeonggi-do\
    \  449-712\n   South Korea\n   Phone: +82 31 280 9585\n   EMail: jh0278.bang@samsung.com\n"
