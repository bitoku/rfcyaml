- title: __initial_text__
  contents:
  - '         Multicast Using Bit Index Explicit Replication (BIER)

    '
- title: Abstract
  contents:
  - "Abstract\n   This document specifies a new architecture for the forwarding of\n\
    \   multicast data packets.  It provides optimal forwarding of multicast\n   packets\
    \ through a \"multicast domain\".  However, it does not require a\n   protocol\
    \ for explicitly building multicast distribution trees, nor\n   does it require\
    \ intermediate nodes to maintain any per-flow state.\n   This architecture is\
    \ known as \"Bit Index Explicit Replication\"\n   (BIER).  When a multicast data\
    \ packet enters the domain, the ingress\n   router determines the set of egress\
    \ routers to which the packet needs\n   to be sent.  The ingress router then encapsulates\
    \ the packet in a\n   BIER header.  The BIER header contains a bit string in which\
    \ each bit\n   represents exactly one egress router in the domain; to forward\
    \ the\n   packet to a given set of egress routers, the bits corresponding to\n\
    \   those routers are set in the BIER header.  The procedures for\n   forwarding\
    \ a packet based on its BIER header are specified in this\n   document.  Elimination\
    \ of the per-flow state and the explicit tree-\n   building protocols results\
    \ in a considerable simplification.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 7841.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8279.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \   2. The BFR Identifier and BFR-Prefix ...............................7\n  \
    \ 3. Encoding BFR Identifiers in BitStrings ..........................8\n   4.\
    \ Layering .......................................................11\n      4.1.\
    \ The Routing Underlay ......................................11\n      4.2. The\
    \ BIER Layer ............................................12\n      4.3. The Multicast\
    \ Flow Overlay ................................13\n   5. Advertising BFR-ids and\
    \ BFR-Prefixes ...........................13\n   6. BIER Intra-Domain Forwarding\
    \ Procedures ........................15\n      6.1. Overview ..................................................15\n\
    \      6.2. BFR Neighbors .............................................17\n  \
    \    6.3. The Bit Index Routing Table ...............................18\n    \
    \  6.4. The Bit Index Forwarding Table ............................19\n      6.5.\
    \ The BIER Forwarding Procedure .............................20\n      6.6. Examples\
    \ of BIER Forwarding ...............................23\n           6.6.1. Example\
    \ 1 ..........................................23\n           6.6.2. Example 2\
    \ ..........................................24\n      6.7. Equal-Cost Multipath\
    \ Forwarding ...........................26\n           6.7.1. Non-deterministic\
    \ ECMP .............................27\n           6.7.2. Deterministic ECMP .................................28\n\
    \      6.8. Prevention of Loops and Duplicates ........................29\n  \
    \    6.9. When Some Nodes Do Not Support BIER .......................30\n    \
    \  6.10. Use of Different BitStringLengths within a Domain ........33\n      \
    \     6.10.1. BitStringLength Compatibility Check ...............34\n        \
    \   6.10.2. Handling BitStringLength Mismatches ...............36\n          \
    \ 6.10.3. Transitioning from One BitStringLength to\n                   Another\
    \ ...........................................36\n   7. Operational Considerations\
    \ .....................................37\n      7.1. Configuration .............................................37\n\
    \   8. IANA Considerations ............................................37\n  \
    \ 9. Security Considerations ........................................38\n   10.\
    \ References ....................................................39\n      10.1.\
    \ Normative References .....................................39\n      10.2. Informative\
    \ References ...................................39\n   Acknowledgements ..................................................40\n\
    \   Contributors ......................................................41\n  \
    \ Authors' Addresses ................................................43\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies a new architecture for the forwarding\
    \ of\n   multicast data packets.  The architecture provides optimal forwarding\n\
    \   of multicast data packets through a \"multicast domain\".  However, it\n \
    \  does not require the use of a protocol for explicitly building\n   multicast\
    \ distribution trees, and it does not require intermediate\n   nodes to maintain\
    \ any per-flow state.  This architecture is known as\n   \"Bit Index Explicit\
    \ Replication\" (BIER).\n   A router that supports BIER is known as a \"Bit-Forwarding\
    \ Router\"\n   (BFR).  The BIER control-plane protocols (see Section 4.2) run\
    \ within\n   a \"BIER domain\", allowing the BFRs within that domain to exchange\
    \ the\n   information needed for them to forward packets to each other\n   using\
    \ BIER.\n   A multicast data packet enters a BIER domain at a \"Bit-Forwarding\n\
    \   Ingress Router\" (BFIR), and leaves the BIER domain at one or more\n   \"\
    Bit-Forwarding Egress Routers\" (BFERs).  A BFR that receives a\n   multicast\
    \ data packet from another BFR in the same BIER domain, and\n   forwards the packet\
    \ to another BFR in the same BIER domain, will be\n   known as a \"transit BFR\"\
    \ for that packet.  A single BFR may be a BFIR\n   for some multicast traffic\
    \ while also being a BFER for some multicast\n   traffic and a transit BFR for\
    \ some multicast traffic.  In fact, for a\n   given packet, a BFR may be a BFIR\
    \ and/or a transit BFR and/or (one\n   of) the BFER(s) for that packet.\n   A\
    \ BIER domain may contain one or more sub-domains.  Each BIER domain\n   MUST\
    \ contain at least one sub-domain, the \"default sub-domain\" (also\n   denoted\
    \ \"sub-domain 0\").  If a BIER domain contains more than one\n   sub-domain,\
    \ each BFR in the domain MUST be provisioned to know the\n   set of sub-domains\
    \ to which it belongs.  Each sub-domain is\n   identified by a sub-domain-id in\
    \ the range [0,255].\n   For each sub-domain to which a given BFR belongs, if\
    \ the BFR is\n   capable of acting as a BFIR or a BFER, it MUST be provisioned\
    \ with a\n   \"BFR-id\" that is unique within the sub-domain.  A BFR-id is a small\n\
    \   unstructured positive integer.  For instance, if a particular BIER\n   sub-domain\
    \ contains 1,374 BFRs, each one could be given a BFR-id in\n   the range [1,1374].\n\
    \   If a given BFR belongs to more than one sub-domain, it may (though it\n  \
    \ need not) have a different BFR-id for each sub-domain.\n   When a multicast\
    \ packet arrives from outside the domain at a BFIR,\n   the BFIR determines the\
    \ set of BFERs to which the packet will be\n   sent.  The BFIR also determines\
    \ the sub-domain in which the packet\n   will be sent.  Determining the sub-domain\
    \ in which a given packet\n   will be sent is known as \"assigning the packet\
    \ to a sub-domain\".\n   Procedures for choosing the sub-domain to which a particular\
    \ packet\n   is assigned are outside the scope of this document.  However, once\
    \ a\n   particular packet has been assigned to a particular sub-domain, it\n \
    \  remains assigned to that sub-domain until it leaves the BIER domain.\n   That\
    \ is, the sub-domain to which a packet is assigned MUST NOT be\n   changed while\
    \ the packet is in flight through the BIER domain.\n   Once the BFIR determines\
    \ the sub-domain and the set of BFERs for a\n   given packet, the BFIR encapsulates\
    \ the packet in a \"BIER header\".\n   The BIER header contains a bit string in\
    \ which each bit represents a\n   single BFR-id.  To indicate that a particular\
    \ BFER is to receive a\n   given packet, the BFIR sets the bit corresponding to\
    \ that BFER's\n   BFR-id in the sub-domain to which the packet has been assigned.\
    \  We\n   will use the term \"BitString\" to refer to the bit string field in\
    \ the\n   BIER header.  We will use the term \"payload\" to refer to the packet\n\
    \   that has been encapsulated.  Thus, a \"BIER-encapsulated\" packet\n   consists\
    \ of a \"BIER header\" followed by a \"payload\".\n   The number of BFERs to which\
    \ a given packet can be forwarded is\n   limited only by the length of the BitString\
    \ in the BIER header.\n   Different deployments can use different BitString lengths.\
    \  We will\n   use the term \"BitStringLength\" to refer to the number of bits\
    \ in the\n   BitString.  It is possible that some deployments will have more BFERs\n\
    \   in a given sub-domain than there are bits in the BitString.  To\n   accommodate\
    \ this case, the BIER encapsulation includes both the\n   BitString and a \"Set\
    \ Identifier\" (SI).  It is the BitString and the\n   SI together that determine\
    \ the set of BFERs to which a given packet\n   will be delivered:\n   o  By convention,\
    \ the least significant (rightmost) bit in the\n      BitString is \"bit 1\",\
    \ and the most significant (leftmost) bit is\n      \"bit BitStringLength\".\n\
    \   o  If a BIER-encapsulated packet has an SI of n and a BitString with\n   \
    \   bit k set, then the packet must be delivered to the BFER whose\n      BFR-id\
    \ (in the sub-domain to which the packet has been assigned)\n      is n*BitStringLength+k.\n\
    \   For example, suppose the BIER encapsulation uses a BitStringLength of\n  \
    \ 256 bits.  By convention, the least significant (rightmost) bit is\n   bit 1,\
    \ and the most significant (leftmost) bit is bit 256.  Suppose\n   that a given\
    \ packet has been assigned to sub-domain 0 and needs to be\n   delivered to three\
    \ BFERs, where those BFERs have BFR-ids in\n   sub-domain 0 of 13, 126, and 235,\
    \ respectively.  The BFIR would\n   create a BIER encapsulation with the SI set\
    \ to zero and with bits 13,\n   126, and 235 of the BitString set.  (All other\
    \ bits of the BitString\n   would be clear.)  If the packet also needs to be sent\
    \ to a BFER whose\n   BFR-id is 257, the BFIR would have to create a second copy\
    \ of the\n   packet, and the BIER encapsulation would specify an SI of 1, and\
    \ a\n   BitString with bit 1 set and all the other bits clear.\n   It is generally\
    \ advantageous to assign the BFR-ids of a given\n   sub-domain so that as many\
    \ BFERs as possible can be represented in a\n   single bit string.\n   Suppose\
    \ a BFR (call it \"BFR-A\") receives a packet whose BIER\n   encapsulation specifies\
    \ an SI of 0 and a BitString with bits 13, 26,\n   and 235 set.  Suppose BFR-A\
    \ has two BFR neighbors, BFR-B and BFR-C,\n   such that the best path to BFERs\
    \ 13 and 26 is via BFR-B, but the best\n   path to BFER 235 is via BFR-C.  BFR-A\
    \ will then replicate the packet,\n   sending one copy to BFR-B and one copy to\
    \ BFR-C.  However, BFR-A will\n   clear bit 235 in the BitString of the packet\
    \ copy it sends to BFR-B\n   and will clear bits 13 and 26 in the BitString of\
    \ the packet copy it\n   sends to BFR-C.  As a result, BFR-B will forward the\
    \ packet only\n   towards BFERs 13 and 26, and BFR-C will forward the packet only\n\
    \   towards BFER 235.  This ensures that each BFER receives only one copy\n  \
    \ of the packet.\n   Detailed procedures for forwarding a BIER-encapsulated packet\
    \ through\n   a BIER domain can be found in Section 6.\n   With this forwarding\
    \ procedure, a multicast data packet can follow an\n   optimal path from its BFIR\
    \ to each of its BFERs.  Further, since the\n   set of BFERs for a given packet\
    \ is explicitly encoded into the BIER\n   header, the packet is not sent to any\
    \ BFER that does not need to\n   receive it.  This allows for optimal forwarding\
    \ of multicast traffic.\n   This optimal forwarding is achieved without any need\
    \ for transit BFRs\n   to maintain per-flow state or to run a multicast tree-building\n\
    \   protocol.\n   The idea of encoding the set of egress nodes into the header\
    \ of a\n   multicast packet is not new.  For example, [Boivie_Feldman] proposes\n\
    \   to encode the set of egress nodes as a set of IP addresses, and\n   proposes\
    \ mechanisms and procedures that are in some ways similar to\n   those described\
    \ in the current document.  However, since BIER encodes\n   each BFR-id as a single\
    \ bit in a bit string, it can represent up to\n   128 BFERs in the same number\
    \ of bits that it would take to carry the\n   IPv6 address of a single BFER. \
    \ Thus, BIER scales to a much larger\n   number of egress nodes per packet.\n\
    \   BIER does not require that each transit BFR look up the best path to\n   each\
    \ BFER that is identified in the BIER header; the number of\n   lookups required\
    \ in the forwarding path for a single packet can be\n   limited to the number\
    \ of neighboring BFRs; this can be much smaller\n   than the number of BFERs.\
    \  See Section 6 (especially Section 6.5) for\n   details.\n   The key words \"\
    MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\",\
    \ \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\"\
    \ in this document are to be interpreted as described in\n   BCP 14 [RFC2119]\
    \ [RFC8174] when, and only when, they appear in all\n   capitals, as shown here.\n"
- title: 2.  The BFR Identifier and BFR-Prefix
  contents:
  - "2.  The BFR Identifier and BFR-Prefix\n   Each BFR MUST be assigned a single\
    \ \"BFR-prefix\" for each sub-domain\n   to which it belongs.  A BFR's BFR-prefix\
    \ MUST be an IP address\n   (either IPv4 or IPv6) of the BFR.  It is RECOMMENDED\
    \ that the\n   BFR-prefix be a loopback address of the BFR.\n   If a BFR belongs\
    \ to more than one sub-domain, it may (though it need\n   not) have a different\
    \ BFR-prefix in each sub-domain.\n   All BFR-prefixes used within a given sub-domain\
    \ MUST belong to the\n   same address family (either IPv4 or IPv6).\n   The BFR-prefix\
    \ of a given BFR in a given sub-domain MUST be routable\n   in that sub-domain.\
    \  Whether a particular BFR-prefix is routable in a\n   given sub-domain depends\
    \ on the \"routing underlay\" associated with\n   that sub-domain.  The notion\
    \ of \"routing underlay\" is described in\n   Section 4.1.\n   A \"BFR Identifier\"\
    \ (BFR-id) is a number in the range [1,65535].\n   Within a given sub-domain,\
    \ every BFR that may need to function as a\n   BFIR or BFER MUST have a single\
    \ BFR-id, which identifies it uniquely\n   within that sub-domain.  A BFR that\
    \ does not need to function as a\n   BFIR or BFER in a given sub-domain does not\
    \ need to have a BFR-id in\n   that sub-domain.\n   The value 0 is not a legal\
    \ BFR-id.\n   The procedure for assigning a particular BFR-id to a particular\
    \ BFR\n   is outside the scope of this document.  However, it is RECOMMENDED\n\
    \   that the BFR-ids for each sub-domain be assigned \"densely\" from the\n  \
    \ numbering space, as this will result in a more efficient encoding\n   (see Section\
    \ 3).  That is, if there are 256 or fewer BFERs, it is\n   RECOMMENDED to assign\
    \ all the BFR-ids from the range [1,256].  If\n   there are more than 256 BFERs\
    \ but less than 512, it is RECOMMENDED to\n   assign all the BFR-ids from the\
    \ range [1,512], with as few \"holes\" as\n   possible in the earlier range. \
    \ However, in some deployments, it may\n   be advantageous to depart from this\
    \ recommendation; this is discussed\n   further in Section 3.\n   In some deployments,\
    \ it may not be possible to support (in a given\n   sub-domain) the full range\
    \ of 65,535 BFR-ids.  For example, if the\n   BFRs in a given sub-domain only\
    \ support 16 SIs and if they only\n   support BitStringLengths of 256 or less,\
    \ then only 16*256=4,096\n   BFR-ids can be supported in that sub-domain.\n"
- title: 3.  Encoding BFR Identifiers in BitStrings
  contents:
  - "3.  Encoding BFR Identifiers in BitStrings\n   To encode a BFR-id in a BIER data\
    \ packet, one must convert the BFR-id\n   to an SI and a BitString.  This conversion\
    \ depends upon the parameter\n   we are calling \"BitStringLength\".  The conversion\
    \ is done as follows.\n   If the BFR-id is N, then\n   o  SI is the integer part\
    \ of the quotient (N-1)/BitStringLength.\n   o  The BitString has one bit position\
    \ set.  If the low-order bit is\n      bit 1 and the high-order bit is bit BitStringLength,\
    \ the bit\n      position that represents BFR-id N is\n      ((N-1) modulo BitStringLength)+1.\n\
    \   If several different BFR-ids all resolve to the same SI, then all of\n   those\
    \ BFR-ids can be represented in a single BitString.  The\n   BitStrings for all\
    \ of those BFR-ids are combined using a bitwise\n   logical OR operation.\n  \
    \ Within a given BIER domain (or even within a given BIER sub-domain),\n   different\
    \ values of BitStringLength may be used.  Each BFR MUST be\n   provisioned to\
    \ know the following:\n   o  The BitStringLength (\"Imposition BitStringLength\"\
    ) and sub-domain\n      (\"Imposition sub-domain\") to use when it imposes (as\
    \ a BFIR) a\n      BIER encapsulation on a particular set of packets, and\n  \
    \ o  The BitStringLengths (\"Disposition BitStringLengths\") that it will\n  \
    \    process when (as a BFR or BFER) it receives packets from a\n      particular\
    \ sub-domain.\n   It is not required that a BFIR use the same Imposition\n   BitStringLength\
    \ or the same Imposition sub-domain for all packets on\n   which it imposes the\
    \ BIER encapsulation.  However, if a particular\n   BFIR is provisioned to use\
    \ a particular Imposition BitStringLength\n   and a particular Imposition sub-domain\
    \ when imposing the\n   encapsulation on a given set of packets, all other BFRs\
    \ with BFR-ids\n   in that sub-domain SHOULD be provisioned to process received\
    \ BIER\n   packets with that BitStringLength (i.e., all other BFRs with BFR-ids\n\
    \   in that sub-domain SHOULD be provisioned with that BitStringLength as\n  \
    \ a Disposition BitStringLength for that sub-domain).  Exceptions to\n   this\
    \ rule MAY be made under certain conditions; this is discussed in\n   Section\
    \ 6.10.\n   When a BIER encapsulation is specified, the specification MUST define\n\
    \   a default BitStringLength for the encapsulation.  Every BFIR\n   supporting\
    \ that encapsulation MUST be capable of being provisioned\n   with that default\
    \ BitStringLength as its Imposition BitStringLength.\n   Every BFR and BFER supporting\
    \ that encapsulation MUST be capable of\n   being provisioned with that default\
    \ BitStringLength as a Disposition\n   BitStringLength.\n   The specification\
    \ of a BIER encapsulation MAY also allow the use of\n   other BitStringLengths.\n\
    \   If a BFR is capable of being provisioned with a given value of\n   BitStringLength\
    \ as an Imposition BitStringLength, it MUST also be\n   capable of being provisioned\
    \ with that same value as one of its\n   Disposition BitStringLengths.  It SHOULD\
    \ be capable of being\n   provisioned with each legal smaller value of BitStringLength\
    \ as (a)\n   its Imposition BitStringLength, and (b) one of its Disposition\n\
    \   BitStringLengths.\n   In order to support transition from one BitStringLength\
    \ to another,\n   every BFR MUST be capable of being provisioned to simultaneously\
    \ use\n   two different Disposition BitStringLengths.\n   A BFR MUST support SI\
    \ values in the range [0,15] and MAY support SI\n   values in the range [0,255].\
    \  (\"Supporting the values in a given\n   range\" means, in this context, that\
    \ any value in the given range is\n   legal and will be properly interpreted.)\
    \  Note that for a given\n   BitStringLength, the total number of BFR-ids that\
    \ can be represented\n   is the product of the BitStringLength and the number\
    \ of supported\n   SIs.  For example, if a deployment uses (in a given sub-domain)\
    \ a\n   BitStringLength of 64 and supports 256 SIs, that deployment can only\n\
    \   support 16384 BFR-ids in that sub-domain.  Even a deployment that\n   supports\
    \ 256 SIs will not be able to support 65,535 BFR-ids unless it\n   uses a BitStringLength\
    \ of at least 256.\n   When a BFIR determines that a multicast data packet, assigned\
    \ to a\n   given sub-domain, needs to be forwarded to a particular set of\n  \
    \ destination BFERs, the BFIR partitions that set of BFERs into\n   subsets, where\
    \ each subset contains the target BFERs whose BFR-ids in\n   the given sub-domain\
    \ all resolve to the same SI.  Call these the\n   \"SI-subsets\" for the packet.\
    \  Each SI-subset can be represented by a\n   single BitString.  The BFIR creates\
    \ a copy of the packet for each\n   SI-subset.  The BIER encapsulation is then\
    \ applied to each packet.\n   The encapsulation specifies a single SI for each\
    \ packet and contains\n   the BitString that represents all the BFR-ids in the\
    \ corresponding\n   SI-subset.  Of course, in order to properly interpret the\
    \ BitString,\n   it must be possible to infer the sub-domain-id from the encapsulation\n\
    \   as well.\n   Suppose, for example, that a BFIR determines that a given packet\n\
    \   needs to be forwarded to three BFERs, whose BFR-ids (in the\n   appropriate\
    \ sub-domain) are 27, 235, and 497.  The BFIR will have to\n   forward two copies\
    \ of the packet.  One copy, associated with SI=0,\n   will have a BitString with\
    \ bits 27 and 235 set.  The other copy,\n   associated with SI=1, will have a\
    \ BitString with bit 241 set.\n   In order to minimize the number of copies that\
    \ must be made of a\n   given multicast packet, it is RECOMMENDED that the BFR-ids\
    \ used in a\n   given sub-domain be assigned \"densely\" (see Section 2) from\
    \ the\n   numbering space.  This will minimize the number of SIs that have to\n\
    \   be used in that sub-domain.  However, depending upon the details of a\n  \
    \ particular deployment, other assignment methods may be more\n   advantageous.\
    \  Suppose, for example, that in a certain deployment,\n   every multicast flow\
    \ is intended either for the \"east coast\" or for\n   the \"west coast\", but\
    \ not for both coasts.  In such a deployment, it\n   would be advantageous to\
    \ assign BFR-ids so that all the \"west coast\"\n   BFR-ids fall into the same\
    \ SI-subset and so that all the \"east coast\"\n   BFR-ids fall into the same\
    \ SI-subset.\n   When a BFR receives a BIER data packet, it will infer the SI\
    \ from the\n   encapsulation.  The set of BFERs to which the packet needs to be\n\
    \   forwarded can then be inferred from the SI and the BitString.\n   In some\
    \ of the examples given later in this document, we will use a\n   BitStringLength\
    \ of 4 and will represent a BFR-id in the form\n   \"SI:xyzw\", where SI is the\
    \ Set Identifier of the BFR-id (assuming a\n   BitStringLength of 4) and xyzw\
    \ is a string of 4 bits.  A\n   BitStringLength of 4 is used only in the examples;\
    \ we would not\n   expect actual deployments to have such a small BitStringLength.\n\
    \   It is possible that several different forms of BIER encapsulation\n   will\
    \ be developed.  If so, the particular encapsulation that is used\n   in a given\
    \ deployment will depend on the type of network\n   infrastructure that is used\
    \ to realize the BIER domain.  Details of\n   the BIER encapsulation(s) will be\
    \ given in companion documents.  An\n   encapsulation for use in MPLS networks\
    \ is described in\n   [MPLS_BIER_ENCAPS]; that document also describes a very\
    \ similar\n   encapsulation that can be used in non-MPLS networks.\n"
- title: 4.  Layering
  contents:
  - "4.  Layering\n   It is helpful to think of the BIER architecture as consisting\
    \ of\n   three layers: the \"routing underlay\", the \"BIER layer\", and the\n\
    \   \"multicast flow overlay\".\n"
- title: 4.1.  The Routing Underlay
  contents:
  - "4.1.  The Routing Underlay\n   The \"routing underlay\" establishes \"adjacencies\"\
    \ between pairs of\n   BFRs and determines one or more \"best paths\" from a given\
    \ BFR to a\n   given set of BFRs.  Each such path is a sequence of BFRs\n   <BFR(k),\
    \ BFR(k+1), ..., BFR(k+n)> such that BFR(k+j) is \"adjacent\" to\n   BFR(k+j+1)\
    \ (for 0<=j<n).\n   At a given BFR, say BFR-A, for every IP address that is the\
    \ address\n   of a BFR in the BIER domain, the routing underlay will map that\
    \ IP\n   address into a set of one or more \"equal-cost\" adjacencies.  If a\n\
    \   BIER data packet has to be forwarded by BFR-A to a given BFER, say\n   BFER-B,\
    \ the packet will follow the path from BFR-A to BFER-B that is\n   determined\
    \ by the routing underlay.\n   It is expected that in a typical deployment, the\
    \ routing underlay\n   will be the default topology that the Interior Gateway\
    \ Protocol\n   (IGP), e.g., OSPF, uses for unicast routing.  In that case, the\n\
    \   underlay adjacencies are just the OSPF adjacencies.  A BIER data\n   packet\
    \ traveling from BFR-A to BFER-B will follow the path that OSPF\n   has selected\
    \ for unicast traffic from BFR-A to BFER-B.\n   If one wants to have multicast\
    \ traffic from BFR-A to BFER-B travel a\n   path that is different from the path\
    \ used by the unicast traffic from\n   BFR-A to BFER-B, one can use a different\
    \ underlay.  For example, if\n   multi-topology OSPF is being used, one OSPF topology\
    \ could be used\n   for unicast traffic and the other for multicast traffic. \
    \ (Each\n   topology would be considered to be a different underlay.)\n   Alternatively,\
    \ one could deploy a routing underlay that creates a\n   multicast-specific tree\
    \ of some sort.  BIER could then be used to\n   forward multicast data packets\
    \ along the multicast-specific tree,\n   while unicast packets follow the \"ordinary\"\
    \ OSPF best path.  (In a\n   case like this, many multicast flows could be traveling\
    \ along a\n   single tree, and the BitString carried by a particular packet would\n\
    \   identify those nodes of the tree that need to receive that packet.)\n   It\
    \ is even possible to have multiple routing underlays used by BIER,\n   as long\
    \ as one can infer from a data packet's BIER encapsulation\n   which underlay\
    \ is being used for that packet.\n   If multiple routing underlays are used in\
    \ a single BIER domain, each\n   BIER sub-domain MUST be associated with a single\
    \ routing underlay\n   (though multiple sub-domains may be associated with the\
    \ same routing\n   underlay).  A BFR that belongs to multiple sub-domains MUST\
    \ be\n   provisioned to know which routing underlay is used by each\n   sub-domain.\
    \  By default (i.e., in the absence of any provisioning to\n   the contrary),\
    \ each sub-domain uses the default topology of the\n   unicast IGP as the routing\
    \ underlay.\n   In scenarios where External BGP (EBGP) is used as the IGP, the\n\
    \   underlay adjacencies, by default, are the BGP adjacencies.\n   Specification\
    \ of the protocols and procedures of the routing underlay\n   is outside the scope\
    \ of this document.\n"
- title: 4.2.  The BIER Layer
  contents:
  - "4.2.  The BIER Layer\n   The BIER layer consists of the protocols and procedures\
    \ that are used\n   in order to transmit a multicast data packet across a BIER\
    \ domain,\n   from its BFIR to its BFERs.  This includes the following components:\n\
    \   o  Protocols and procedures that a given BFR uses to advertise, to\n     \
    \ all other BFRs in the same BIER domain:\n      *  its BFR-prefix;\n      * \
    \ its BFR-id in each sub-domain for which it has been provisioned\n         with\
    \ a BFR-id;\n      *  the set of Disposition BitStringLengths it has been provisioned\n\
    \         to use for each sub-domain;\n      *  optionally, information about\
    \ the routing underlay associated\n         with each sub-domain.\n   o  The procedures\
    \ used by a BFIR to impose a BIER header on a\n      multicast data packet.\n\
    \   o  The procedures for forwarding BIER-encapsulated packets and for\n     \
    \ modifying the BIER header during transit.\n   o  The procedures used by a BFER\
    \ to decapsulate a BIER packet and\n      properly dispatch it.\n"
- title: 4.3.  The Multicast Flow Overlay
  contents:
  - "4.3.  The Multicast Flow Overlay\n   The \"multicast flow overlay\" consists\
    \ of the set of protocols and\n   procedures that enable the following set of\
    \ functions.\n   o  When a BFIR receives a multicast data packet from outside\
    \ the BIER\n      domain, the BFIR must determine the set of BFERs for that packet.\n\
    \      This information is provided by the multicast flow overlay.\n   o  When\
    \ a BFER receives a BIER-encapsulated packet from inside the\n      BIER domain,\
    \ the BFER must determine how to further forward the\n      packet.  This information\
    \ is provided by the multicast flow\n      overlay.\n   For example, suppose the\
    \ BFIR and BFERs are Provider Edge (PE)\n   routers providing Multicast Virtual\
    \ Private Network (MVPN) service.\n   The multicast flow overlay consists of the\
    \ protocols and procedures\n   described in [RFC6513] and [RFC6514].  The MVPN\
    \ signaling described\n   in those RFCs enables an ingress PE to determine the\
    \ set of egress\n   PEs for a given multicast flow (or set of flows); it also\
    \ enables an\n   egress PE to determine the \"Virtual Routing and Forwarding Tables\"\
    \n   (VRFs) to which multicast packets from the backbone network should be\n \
    \  sent.  MVPN signaling also has several components that depend on the\n   type\
    \ of \"tunneling technology\" used to carry multicast data through\n   the network.\
    \  Since BIER is, in effect, a new type of \"tunneling\n   technology\", some\
    \ extensions to the MVPN signaling are needed in\n   order to properly interface\
    \ the multicast flow overlay with the BIER\n   layer.  These are specified in\
    \ [BIER_MVPN].\n   MVPN is just one example of a multicast flow overlay.  Protocols\
    \ and\n   procedures for other overlays will be provided in companion\n   documents.\
    \  It is also possible to implement the multicast flow\n   overlay by means of\
    \ a \"Software-Defined Network\" (SDN) controller.\n   Specification of the protocols\
    \ and procedures of the multicast flow\n   overlay is outside the scope of this\
    \ document.\n"
- title: 5.  Advertising BFR-ids and BFR-Prefixes
  contents:
  - "5.  Advertising BFR-ids and BFR-Prefixes\n   As stated in Section 2, each BFER\
    \ is assigned (by provisioning) a\n   BFR-id (for a given BIER sub-domain).  Each\
    \ BFER must advertise these\n   assignments to all the other BFRs in the domain.\
    \  Similarly, each BFR\n   is assigned (by provisioning) a BFR-prefix (for a given\
    \ BIER domain)\n   and must advertise this assignment to all the other BFRs in\
    \ the\n   domain.  Finally, each BFR has been provisioned to use a certain set\n\
    \   of Disposition BitStringLengths for each sub-domain and must\n   advertise\
    \ these to all other BFRs in the domain.\n   If the BIER domain is also a link-state\
    \ routing IGP domain (i.e., an\n   OSPF or IS-IS domain), the advertisement of\
    \ the BFR-prefix,\n   <sub-domain-id, BFR-id>, and BitStringLength can be done\
    \ using the\n   advertisement capabilities of the IGP.  For example, if a BIER\
    \ domain\n   is also an OSPF domain, these advertisements can be done using the\n\
    \   OSPF \"Opaque Link State Advertisement\" (Opaque LSA) mechanism.\n   Details\
    \ of the necessary extensions to OSPF and IS-IS will be\n   provided in companion\
    \ documents.  (See [OSPF_BIER_EXTENSIONS] and\n   [ISIS_BIER_EXTENSIONS].)\n \
    \  If, in a particular deployment, the BIER domain is not an OSPF or\n   IS-IS\
    \ domain, procedures suitable to the deployment must be used to\n   advertise\
    \ this information.  Details of the necessary procedures will\n   be provided\
    \ in companion documents.  For example, if BGP is the only\n   routing algorithm\
    \ used in the BIER domain, the procedures of\n   [BGP_BIER_EXTENSIONS] may be\
    \ used.\n   These advertisements enable each BFR to associate a given\n   <sub-domain-id,\
    \ BFR-id> with a given BFR-prefix.  As will be seen in\n   subsequent sections\
    \ of this document, knowledge of this association\n   is an important part of\
    \ the forwarding process.\n   Since each BFR needs to have a unique (in each sub-domain)\
    \ BFR-id,\n   two different BFRs will not advertise ownership of the same\n  \
    \ <sub-domain-id, BFR-id> unless there has been a provisioning error.\n   o  If\
    \ BFR-A determines that BFR-B and BFR-C have both advertised the\n      same BFR-id\
    \ for the same sub-domain, BFR-A MUST log an error.\n      Suppose that the duplicate\
    \ BFR-id is \"N\".  When BFR-A is\n      functioning as a BFIR, it MUST NOT encode\
    \ the BFR-id value N in\n      the BIER encapsulation of any packet that has been\
    \ assigned to the\n      given sub-domain, even if it has determined that the\
    \ packet needs\n      to be received by BFR-B and/or BFR-C.\n      This will mean\
    \ that BFR-B and BFR-C cannot receive multicast\n      traffic at all in the given\
    \ sub-domain until the provisioning\n      error is fixed.  However, that is preferable\
    \ to having them\n      receive each other's traffic.\n   o  Suppose that BFR-A\
    \ has been provisioned with BFR-id N for a\n      particular sub-domain but that\
    \ it has not yet advertised its\n      ownership of BFR-id N for that sub-domain.\
    \  Suppose also that it\n      has received an advertisement from a different\
    \ BFR (say BFR-B)\n      that is advertising ownership of BFR-id N for the same\
    \ sub-domain.\n      In such a case, BFR-A SHOULD log an error and MUST NOT advertise\n\
    \      its own ownership of BFR-id N for that sub-domain as long as the\n    \
    \  advertisement from BFR-B is extant.\n      This procedure may prevent the accidental\
    \ misconfiguration of a\n      new BFR from impacting an existing BFR.\n   If\
    \ a BFR advertises that it has a BFR-id of 0 in a particular\n   sub-domain, other\
    \ BFRs receiving the advertisement MUST interpret\n   that advertisement as meaning\
    \ that the advertising BFR does not have\n   a BFR-id in that sub-domain.\n"
- title: 6.  BIER Intra-Domain Forwarding Procedures
  contents:
  - "6.  BIER Intra-Domain Forwarding Procedures\n   This section specifies the rules\
    \ for forwarding a BIER-encapsulated\n   data packet within a BIER domain.  These\
    \ rules are not intended to\n   specify an implementation strategy; to conform\
    \ to this specification,\n   an implementation need only produce the same results\
    \ that these rules\n   produce.\n"
- title: 6.1.  Overview
  contents:
  - "6.1.  Overview\n   This section provides a brief overview of the BIER forwarding\n\
    \   procedures.  Subsequent subsections specify the procedures in more\n   detail.\n\
    \   To forward a BIER-encapsulated packet:\n   1.  Determine the packet's sub-domain.\n\
    \   2.  Determine the packet's BitStringLength and BitString.\n   3.  Determine\
    \ the packet's SI.\n   4.  From the sub-domain, the SI, and the BitString, determine\
    \ the set\n       of destination BFERs for the packet.\n   5.  Using information\
    \ provided by the routing underlay associated\n       with the packet's sub-domain,\
    \ determine the next-hop adjacency\n       for each of the destination BFERs.\n\
    \   6.  It is possible that the packet's BitString will have one or more\n   \
    \    bits that correspond to BFR-ids that are not in use.  It is also\n      \
    \ possible that the packet's BitString will have one or more bits\n       that\
    \ correspond to BFERs that are unreachable, i.e., that have no\n       next-hop\
    \ adjacency.  In the following, we will consider the\n       \"next-hop adjacency\"\
    \ for all such bit positions to be the \"null\"\n       next hop.\n   7.  Partition\
    \ the set of destination BFERs such that all the BFERs in\n       a single partition\
    \ have the same next hop.  We will say that each\n       partition is associated\
    \ with a next hop.\n   8.  For each partition:\n       a.  Make a copy of the\
    \ packet.\n       b.  Clear any bit in the packet's BitString that identifies\
    \ a\n           BFER that is not in the partition.\n       c.  Transmit the packet\
    \ to the associated next hop.  (If the\n           next hop is the null next hop,\
    \ the packet is discarded.)\n   If a BFR receives a BIER-encapsulated packet whose\
    \ <sub-domain, SI,\n   BitString> triple identifies that BFR itself, then the\
    \ BFR is also a\n   BFER for that packet.  As a BFER, it must pass the payload\
    \ to the\n   multicast flow overlay.  If the BitString has bits set for other\n\
    \   BFRs, the packet also needs to be forwarded further within the BIER\n   domain.\
    \  If the BF(E)R also forwards one or more copies of the packet\n   within the\
    \ BIER domain, the bit representing the BFR's own BFR-id\n   MUST be clear in\
    \ all the copies.\n   When BIER on a BFER is to pass a packet to the multicast\
    \ flow\n   overlay, it of course decapsulates the packet by removing the BIER\n\
    \   header.  However, it may be necessary to provide the multicast flow\n   overlay\
    \ with contextual information obtained from the BIER\n   encapsulation.  The information\
    \ that needs to pass between the BIER\n   layer and the multicast flow overlay\
    \ is specific to the multicast\n   flow overlay.  Specification of the interaction\
    \ between the BIER\n   layer and the multicast flow overlay is outside the scope\
    \ of this\n   specification.\n   If the BIER encapsulation contains a \"Time to\
    \ Live\" (TTL) value, this\n   value is not, by default, inherited by the payload.\
    \  If a particular\n   multicast flow overlay needs to know the TTL value, this\
    \ needs to be\n   specified in whatever specification defines the interaction\
    \ between\n   BIER and that multicast flow overlay.\n   If the BIER encapsulation\
    \ contains a Traffic Class field, a\n   Type of Service field, a Differentiated\
    \ Services field, or any field\n   of that sort, the value of that field is not,\
    \ by default, passed to\n   the multicast flow overlay.  If a particular multicast\
    \ flow overlay\n   needs to know the values of such fields, this fact needs to\
    \ be\n   specified in whatever specification defines the interaction between\n\
    \   BIER and that multicast flow overlay.\n   When BIER on a BFER passes a packet\
    \ to the multicast flow overlay,\n   the overlay will determine how to further\
    \ dispatch the packet.  If\n   the packet needs to be forwarded into another BIER\
    \ domain, then the\n   BFR will act as a BFER in one BIER domain and as a BFIR\
    \ in another.\n   A BIER-encapsulated packet cannot pass directly from one BIER\
    \ domain\n   to another; at the boundary between BIER domains, the packet must\
    \ be\n   decapsulated and passed to the multicast flow overlay.\n   Note that\
    \ when a BFR transmits multiple copies of a packet within a\n   BIER domain, only\
    \ one copy will be destined to any given BFER.\n   Therefore, it is not possible\
    \ for any BIER-encapsulated packet to be\n   delivered more than once to any BFER.\n"
- title: 6.2.  BFR Neighbors
  contents:
  - "6.2.  BFR Neighbors\n   The \"BFR Neighbors\" (BFR-NBRs) of a given BFR, say\
    \ BFR-A, are those\n   BFRs that, according to the routing underlay, are adjacencies\
    \ of\n   BFR-A.  Each BFR-NBR will have a BFR-prefix.\n   Suppose a BIER-encapsulated\
    \ packet arrives at BFR-A.  From the\n   packet's encapsulation, BFR-A learns\
    \ (a) the sub-domain of the packet\n   and (b) the BFR-ids (in that sub-domain)\
    \ of the BFERs to which the\n   packet is destined.  Then, using the information\
    \ advertised per\n   Section 5, BFR-A can find the BFR-prefix of each destination\
    \ BFER.\n   Given the BFR-prefix of a particular destination BFER, say BFER-D,\n\
    \   BFR-A learns from the routing underlay (associated with the packet's\n   sub-domain)\
    \ an IP address of the BFR that is the next hop on the path\n   from BFR-A to\
    \ BFER-D.  Let's call this next hop \"BFR-B\".  BFR-A must\n   then determine\
    \ the BFR-prefix of BFR-B.  (This determination can be\n   made from the information\
    \ advertised per Section 5.)  This BFR-prefix\n   is the BFR-NBR of BFR-A on the\
    \ path from BFR-A to BFER-D.\n   Note that if the routing underlay provides multiple\
    \ equal-cost paths\n   from BFR-A to BFER-D, BFR-A may have multiple BFR-NBRs\
    \ for BFER-D.\n   Under certain circumstances, a BFR may have adjacencies (in\
    \ a\n   particular routing underlay) that are not BFRs.  Please see\n   Section\
    \ 6.9 for a discussion of how to handle those circumstances.\n"
- title: 6.3.  The Bit Index Routing Table
  contents:
  - "6.3.  The Bit Index Routing Table\n   The \"Bit Index Routing Table\" (BIRT)\
    \ is a table that maps from the\n   BFR-id (in a particular sub-domain) of a BFER\
    \ to the BFR-prefix of\n   that BFER, and to the BFR-NBR on the path to that BFER.\
    \  As an\n   example, consider the topology shown in Figure 1.  In this diagram,\n\
    \   we represent the BFR-id of each BFR in the SI:xyzw form discussed in\n   Section\
    \ 3.\n      ( A ) ------------ ( B ) ------------ ( C ) ------------ ( D )\n \
    \    4 (0:1000)             \\                  \\           1 (0:0001)\n    \
    \                         \\                  \\\n                           \
    \  ( E )              ( F )\n                           3 (0:0100)         2 (0:0010)\n\
    \                         Figure 1: BIER Topology 1\n   This topology will result\
    \ in the BIRT of Figure 2 at BFR-B.  The\n   first column shows the BFR-id as\
    \ a number and also (in parentheses)\n   in the SI:BitString format that corresponds\
    \ to a BitStringLength\n   of 4.  (The actual minimum BitStringLength is 64, but\
    \ we use 4 in the\n   examples.)\n   Note that a BIRT is specific to a particular\
    \ BIER sub-domain.\n               --------------------------------------------\n\
    \               |     BFR-id     |  BFR-Prefix  | BFR-NBR  |\n               |\
    \ (SI:BitString) | of Dest BFER |          |\n               ============================================\n\
    \               |   4 (0:1000)   |     A        |     A    |\n               --------------------------------------------\n\
    \               |   1 (0:0001)   |     D        |     C    |\n               --------------------------------------------\n\
    \               |   3 (0:0100)   |     E        |     E    |\n               --------------------------------------------\n\
    \               |   2 (0:0010)   |     F        |     C    |\n               --------------------------------------------\n\
    \                Figure 2: Bit Index Routing Table at BFR-B\n"
- title: 6.4.  The Bit Index Forwarding Table
  contents:
  - "6.4.  The Bit Index Forwarding Table\n   The \"Bit Index Forwarding Table\" (BIFT)\
    \ is derived from the BIRT as\n   follows.  (Note that a BIFT is specific to a\
    \ particular sub-domain.)\n   Suppose that several rows in the BIRT have the same\
    \ SI and the same\n   BFR-NBR.  By taking the logical OR of the BitStrings of\
    \ those rows,\n   we obtain a bit mask that corresponds to that combination of\
    \ SI and\n   BFR-NBR.  We will refer to this bit mask as the \"Forwarding Bit\
    \ Mask\"\n   (F-BM) for that <SI, BFR-NBR> combination.\n   For example, in Figure\
    \ 2, we see that two of the rows have the same\n   SI (0) and same BFR-NBR (C).\
    \  The bit mask that corresponds to\n   <SI=0, BFR-NBR-C> is 0011 (\"0001\" OR'd\
    \ with \"0010\").\n   The BIFT is used to map from the BFR-id of a BFER to the\n\
    \   corresponding F-BM and BFR-NBR.  For example, Figure 3 shows the BIFT\n  \
    \ that is derived from the BIRT of Figure 2.  Note that BFR-ids 1 and 2\n   have\
    \ the same SI and the same BFR-NBR; hence, they have the\n   same F-BM.\n    \
    \               -------------------------------------\n                   |  \
    \    BFR-id    |  F-BM  | BFR-NBR |\n                   | (SI:BitString) |   \
    \     |         |\n                   =====================================\n\
    \                   |   1 (0:0001)   |  0011  |    C    |\n                  \
    \ -------------------------------------\n                   |   2 (0:0010)   |\
    \  0011  |    C    |\n                   -------------------------------------\n\
    \                   |   3 (0:0100)   |  0100  |    E    |\n                  \
    \ -------------------------------------\n                   |   4 (0:1000)   |\
    \  1000  |    A    |\n                   -------------------------------------\n\
    \                   Figure 3: Bit Index Forwarding Table\n   This BIFT is programmed\
    \ into the data plane and used to forward\n   packets, applying the rules specified\
    \ below in Section 6.5.\n"
- title: 6.5.  The BIER Forwarding Procedure
  contents:
  - "6.5.  The BIER Forwarding Procedure\n   Below is the procedure that a BFR uses\
    \ for forwarding a\n   BIER-encapsulated packet.\n   1.  Determine the packet's\
    \ SI, BitStringLength, and sub-domain.\n   2.  If the BitString consists entirely\
    \ of zeroes, discard the packet;\n       the forwarding process has been completed.\
    \  Otherwise, proceed to\n       step 3.\n   3.  Find the position (call it \"\
    k\") of the least significant (i.e.,\n       of the rightmost) bit that is set\
    \ in the packet's BitString.\n       (Remember, bits are numbered from 1, starting\
    \ with the least\n       significant bit.)\n   4.  If bit k identifies the BFR\
    \ itself, copy the packet, and send the\n       copy to the multicast flow overlay.\
    \  Then clear bit k in the\n       original packet, and go to step 2.  Otherwise,\
    \ proceed to step 5.\n   5.  Use the value k, together with the SI, sub-domain,\
    \ and\n       BitStringLength, as the \"index\" into the BIFT.\n   6.  Extract\
    \ from the BIFT the F-BM and the BFR-NBR.\n   7.  Copy the packet.  Update the\
    \ copy's BitString by AND'ing it with\n       the F-BM (i.e., PacketCopy->BitString\
    \ &= F-BM).  Then forward the\n       copy to the BFR-NBR.  (If the BFR-NBR is\
    \ null, the copy is just\n       discarded.)  Note that when a packet is forwarded\
    \ to a particular\n       BFR-NBR, its BitString identifies only those BFERs that\
    \ are to be\n       reached via that BFR-NBR.\n   8.  Now update the original\
    \ packet's BitString by AND'ing it with the\n       INVERSE of the F-BM (i.e.,\
    \ Packet->BitString &= ~F-BM).  (This\n       clears the bits that identify the\
    \ BFERs to which a copy of the\n       packet has just been forwarded.)  Go to\
    \ step 2.\n   This procedure causes the packet to be forwarded to a particular\n\
    \   BFR-NBR only once.  The number of lookups in the BIFT is the same as\n   the\
    \ number of BFR-NBRs to which the packet must be forwarded; it is\n   not necessary\
    \ to do a separate lookup for each destination BFER.\n   When a packet is sent\
    \ to a particular BFR-NBR, the BitString is not\n   the only part of the BIER\
    \ header that needs to be modified.  If there\n   is a TTL field in the BIER header,\
    \ it will need to be decremented.\n   In addition, when either of the encapsulations\
    \ of [MPLS_BIER_ENCAPS]\n   is used, the BIFT-id field is likely to require modification,\
    \ based\n   on signaling from the BFR-NBR to which the packet is being sent. \
    \ The\n   BIFT-id field of an incoming BIER packet implicitly identifies an SI,\n\
    \   a sub-domain, and a BitStringLength.  If the packet is sent to a\n   particular\
    \ BFR-NBR, the BIFT-id field must be changed to whatever\n   value that BFR-NBR\
    \ has advertised for the same SI, sub-domain, and\n   BitStringLength.  (If the\
    \ encapsulation of Section 2.1 of\n   [MPLS_BIER_ENCAPS] is used, this is essentially\
    \ an MPLS label swap\n   operation.)\n   Suppose it has been decided (by the above\
    \ rules) to send a packet to\n   a particular BFR-NBR.  If that BFR-NBR is connected\
    \ via multiple\n   parallel interfaces, it may be desirable to apply some form\
    \ of load\n   balancing.  Load-balancing algorithms are outside the scope of this\n\
    \   document.  However, if the packet's encapsulation contains an entropy\n  \
    \ field, the entropy field SHOULD be respected; two packets with the\n   same\
    \ value of the entropy field SHOULD be sent on the same interface\n   (if possible).\n\
    \   In some cases, the routing underlay may provide multiple equal-cost\n   paths\
    \ (through different BFR-NBRs) to a given BFER.  This is known as\n   \"Equal-Cost\
    \ Multipath\" (ECMP).  The procedures described in this\n   section must be augmented\
    \ in order to support load balancing over\n   ECMP.  The necessary augmentations\
    \ can be found in Section 6.7.\n   In the event that unicast traffic to the BFR-NBR\
    \ is being sent via a\n   \"bypass tunnel\" of some sort, the BIER-encapsulated\
    \ multicast traffic\n   sent to the BFR-NBR SHOULD also be sent via that tunnel.\
    \  This allows\n   any existing \"fast reroute\" schemes to be applied to multicast\n\
    \   traffic as well as to unicast traffic.\n   Some examples of these forwarding\
    \ procedures can be found in\n   Section 6.6.\n   The rules given in this section\
    \ can be represented by the following\n   pseudocode:\n   void ForwardBitMaskPacket\
    \ (Packet)\n   {\n       SI=GetPacketSI(Packet);\n       Offset=SI*BitStringLength;\n\
    \       for (Index = GetFirstBitPosition(Packet->BitString); Index ;\n       \
    \     Index = GetNextBitPosition(Packet->BitString, Index)) {\n           F-BM\
    \ = BIFT[Index+Offset]->F-BM;\n           if (!F-BM) continue;\n           BFR-NBR\
    \ = BIFT[Index+Offset]->BFR-NBR;\n           PacketCopy = Copy(Packet);\n    \
    \       PacketCopy->BitString &= F-BM;\n           PacketSend(PacketCopy, BFR-NBR);\n\
    \           Packet->BitString &= ~F-BM;\n       }\n   }\n                    \
    \       Figure 4: Pseudocode\n   This pseudocode assumes that, at a given BFER,\
    \ the BFR-NBR entry\n   corresponding to the BFER's own BFR-id will be the BFER's\
    \ own\n   BFR-prefix.  It also assumes that the corresponding F-BM has only\n\
    \   one bit set, the bit representing the BFER itself.  In this case, the\n  \
    \ \"PacketSend\" function sends the packet to the multicast flow overlay.\n  \
    \ This pseudocode also assumes that the F-BM for the null next hop\n   contains\
    \ a 1 in a given bit position if and only if that bit position\n   corresponds\
    \ to either an unused BFR-id or an unreachable BFER.  When\n   the BFR-NBR is\
    \ null, the \"PacketSend\" function discards the packet.\n"
- title: 6.6.  Examples of BIER Forwarding
  contents:
  - "6.6.  Examples of BIER Forwarding\n   In this section, we give two examples of\
    \ BIER forwarding, based on\n   the topology in Figure 1.  In these examples,\
    \ all packets have been\n   assigned to the default sub-domain, all packets have\
    \ SI=0, and the\n   BitStringLength is 4.  Figure 5 shows the BIFT entries for\
    \ SI=0 only.\n   For compactness, we show the first column of the BIFT, the BFR-id,\n\
    \   only as an integer.\n           BFR-A BIFT            BFR-B BIFT         \
    \   BFR-C BIFT\n      -------------------   -------------------   -------------------\n\
    \      | Id | F-BM | NBR |   | Id | F-BM | NBR |   | Id | F-BM | NBR |\n     \
    \ ===================   ===================   ===================\n      |  1\
    \ | 0111 |  B  |   |  1 | 0011 |  C  |   |  1 | 0001 |  D  |\n      -------------------\
    \   -------------------   -------------------\n      |  2 | 0111 |  B  |   | \
    \ 2 | 0011 |  C  |   |  2 | 0010 |  F  |\n      -------------------   -------------------\
    \   -------------------\n      |  3 | 0111 |  B  |   |  3 | 0100 |  E  |   | \
    \ 3 | 1100 |  B  |\n      -------------------   -------------------   -------------------\n\
    \      |  4 | 1000 |  A  |   |  4 | 1000 |  A  |   |  4 | 1100 |  B  |\n     \
    \ -------------------   -------------------   -------------------\n          \
    \    Figure 5: BIFTs Used in the Forwarding Examples\n"
- title: 6.6.1.  Example 1
  contents:
  - "6.6.1.  Example 1\n   BFR-D, BFR-E, and BFR-F are BFERs.  BFR-A is the BFIR.\
    \  Suppose that\n   BFIR-A has learned from the multicast flow overlay that BFER-D\
    \ is\n   interested in a given multicast flow.  If BFIR-A receives a packet of\n\
    \   that flow from outside the BIER domain, BFIR-A applies the BIER\n   encapsulation\
    \ to the packet.  The encapsulation must be such that the\n   SI is zero.  The\
    \ encapsulation also includes a BitString, with just\n   bit 1 set and with all\
    \ other bits clear (i.e., 0001).  This indicates\n   that BFER-D is the only BFER\
    \ that needs to receive the packet.\n   BFIR-A then follows the procedures of\
    \ Section 6.5, as follows:\n   o  Since the packet's BitString is 0001, BFIR-A\
    \ finds that the first\n      bit in the string is bit 1.  Looking at entry 1\
    \ in its BIFT, BFR-A\n      determines that the bit mask F-BM is 0111 and the\
    \ BFR-NBR is\n      BFR-B.\n   o  BFR-A then makes a copy of the packet and applies\
    \ the F-BM to the\n      copy: Copy->BitString &= 0111.  The copy's BitString\
    \ is now 0001\n      (0001 & 0111).\n   o  The copy is now sent to BFR-B.\n  \
    \ o  BFR-A then updates the packet's BitString by applying the inverse\n     \
    \ of the F-BM: Packet->BitString &= ~F-BM.  As a result, the\n      packet's BitString\
    \ is now 0000 (0001 & 1000).\n   o  As the packet's BitString is now zero, the\
    \ forwarding procedure is\n      complete.\n   When BFR-B receives the multicast\
    \ packet from BFR-A, it follows the\n   same procedure.  The result is that a\
    \ copy of the packet, with a\n   BitString of 0001, is sent to BFR-C.  BFR-C applies\
    \ the same\n   procedures and, as a result, sends a copy of the packet, with a\n\
    \   BitString of 0001, to BFR-D.\n   At BFER-D, the BIFT entry (not pictured)\
    \ for BFR-id 1 will specify an\n   F-BM of 0001 and a BFR-NBR of BFR-D itself.\
    \  This will cause a copy\n   of the packet to be delivered to the multicast flow\
    \ overlay at BFR-D.\n   The packet's BitString will be set to 0000, and the packet\
    \ will not\n   be forwarded any further.\n"
- title: 6.6.2.  Example 2
  contents:
  - "6.6.2.  Example 2\n   This example is similar to example 1, except that BFIR-A\
    \ has learned\n   from the multicast flow overlay that both BFER-D and BFER-E\
    \ are\n   interested in a given multicast flow.  If BFIR-A receives a packet of\n\
    \   that flow from outside the BIER domain, BFIR-A applies the BIER\n   encapsulation\
    \ to the packet.  The encapsulation must be such that the\n   SI is zero.  The\
    \ encapsulation also includes a BitString with\n   two bits set: bit 1 is set\
    \ (as in example 1) to indicate that BFR-D\n   is a BFER for this packet, and\
    \ bit 3 is set to indicate that BFR-E is\n   a BFER for this packet.  That is,\
    \ the BitString (assuming again a\n   BitStringLength of 4) is 0101.  To forward\
    \ the packet, BFIR-A follows\n   the procedures of Section 6.5, as follows:\n\
    \   o  Since the packet's BitString is 0101, BFIR-A finds that the first\n   \
    \   bit in the string is bit 1.  Looking at entry 1 in its BIFT, BFR-A\n     \
    \ determines that the bit mask F-BM is 0111 and the BFR-NBR is\n      BFR-B.\n\
    \   o  BFR-A then makes a copy of the packet and applies the F-BM to the\n   \
    \   copy: Copy->BitString &= 0111.  The copy's BitString is now 0101\n      (0101\
    \ & 0111).\n   o  The copy is now sent to BFR-B.\n   o  BFR-A then updates the\
    \ packet's BitString by applying the inverse\n      of the F-BM: Packet->BitString\
    \ &= ~F-BM.  As a result, the\n      packet's BitString is now 0000 (0101 & 1000).\n\
    \   o  As the packet's BitString is now zero, the forwarding procedure is\n  \
    \    complete.\n   When BFR-B receives the multicast packet from BFR-A, it follows\
    \ the\n   procedure of Section 6.5, as follows:\n   o  Since the packet's BitString\
    \ is 0101, BFR-B finds that the first\n      bit in the string is bit 1.  Looking\
    \ at entry 1 in its BIFT, BFR-B\n      determines that the bit mask F-BM is 0011\
    \ and the BFR-NBR is\n      BFR-C.\n   o  BFR-B then makes a copy of the packet\
    \ and applies the F-BM to the\n      copy: Copy->BitString &= 0011.  The copy's\
    \ BitString is now 0001\n      (0101 & 0011).\n   o  The copy is now sent to BFR-C.\n\
    \   o  BFR-B then updates the packet's BitString by applying the inverse\n   \
    \   of the F-BM: Packet->BitString &= ~F-BM.  As a result, the\n      packet's\
    \ BitString is now 0100 (0101 & 1100).\n   o  Now BFR-B finds the next bit in\
    \ the packet's (modified) BitString.\n      This is bit 3.  Looking at entry 3\
    \ in its BIFT, BFR-B determines\n      that the F-BM is 0100 and the BFR-NBR is\
    \ BFR-E.\n   o  BFR-B then makes a copy of the packet and applies the F-BM to\
    \ the\n      copy: Copy->BitString &= 0100.  The copy's BitString is now 0100\n\
    \      (0100 & 0100).\n   o  The copy is now sent to BFR-E.\n   o  BFR-B then\
    \ updates the packet's BitString by applying the inverse\n      of the F-BM: Packet->BitString\
    \ &= ~F-BM.  As a result, the\n      packet's BitString is now 0000 (0100 & 1011).\n\
    \   o  As the packet's BitString is now zero, the forwarding procedure is\n  \
    \    complete.\n   Thus, BFR-B forwards two copies of the packet.  One copy of\
    \ the\n   packet, with BitString 0001, has now been sent from BFR-B to BFR-C.\n\
    \   Following the same procedures, BFR-C will forward the packet to\n   BFER-D.\n\
    \   At BFER-D, the BIFT entry (not pictured) for BFR-id 1 will specify an\n  \
    \ F-BM of 0001 and a BFR-NBR of BFR-D itself.  This will cause a copy\n   of the\
    \ packet to be delivered to the multicast flow overlay at BFR-D.\n   The packet's\
    \ BitString will be set to 0000, and the packet will not\n   be forwarded any\
    \ further.\n   The other copy of the packet has been sent from BFR-B to BFER-E,\
    \ with\n   BitString 0100.\n   At BFER-E, the BIFT entry (not pictured) for BFR-id\
    \ 3 will specify an\n   F-BM of 0100 and a BFR-NBR of BFR-E itself.  This will\
    \ cause a copy\n   of the packet to be delivered to the multicast flow overlay\
    \ at BFR-E.\n   The packet's BitString will be set to 0000, and the packet will\
    \ not\n   be forwarded any further.\n"
- title: 6.7.  Equal-Cost Multipath Forwarding
  contents:
  - "6.7.  Equal-Cost Multipath Forwarding\n   In many networks, the routing underlay\
    \ will provide multiple\n   equal-cost paths from a given BFR to a given BFER.\
    \  When forwarding\n   multicast packets through the network, it can be beneficial\
    \ to take\n   advantage of this by load-balancing among those paths.  This feature\n\
    \   is known as \"Equal-Cost Multipath (ECMP) forwarding\".\n   BIER supports\
    \ ECMP forwarding, but the procedures of Section 6.5 must\n   be modified slightly.\
    \  Two ECMP procedures are defined.  In the first\n   (described in Section 6.7.1),\
    \ the choice among equal-cost paths taken\n   by a given packet from a given BFR\
    \ to a given BFER depends on\n   (a) routing, (b) the packet's entropy, and (c)\
    \ the other BFERs to\n   which that packet is destined.  In the second (described\
    \ in\n   Section 6.7.2), the choice depends only upon the packet's entropy.\n\
    \   There are trade-offs between the two forwarding procedures described\n   here.\
    \  In the procedure of Section 6.7.1, the number of packet\n   replications is\
    \ minimized.  The procedure in Section 6.7.1 also uses\n   less memory in the\
    \ BFR.  In the procedure of Section 6.7.2, the path\n   traveled by a given packet\
    \ from a given BFR to a given BFER is\n   independent of the other BFERs to which\
    \ the packet is destined.\n   While the procedures of Section 6.7.2 may cause\
    \ more replications,\n   they provide a more predictable behavior.\n   The two\
    \ procedures described here operate on identical packet formats\n   and will interoperate\
    \ correctly.  However, if deterministic behavior\n   is desired, then all BFRs\
    \ would need to use the procedure from\n   Section 6.7.2.\n"
- title: 6.7.1.  Non-deterministic ECMP
  contents:
  - "6.7.1.  Non-deterministic ECMP\n   Figure 6 shows the operation of non-deterministic\
    \ ECMP in BIER.\n          BFR-A BIFT            BFR-B BIFT            BFR-C BIFT\n\
    \     -------------------   -------------------   -------------------\n     |\
    \ Id | F-BM | NBR |   | Id | F-BM | NBR |   | Id | F-BM | NBR |\n     ===================\
    \   ===================   ===================\n     | 1  | 0111 |  B  |   | 1\
    \  | 0011 |  C  |   | 1  | 0001 |  D  |\n     -------------------   -------------------\
    \   -------------------\n     | 2  | 0111 |  B  |   | 2  | 0011 |  C  |   | 2\
    \  | 0010 |  F  |\n     -------------------   |    | 0110 |  E  |   -------------------\n\
    \     | 3  | 0111 |  B  |   -------------------   | 3  | 1100 |  B  |\n     -------------------\
    \   | 3  | 0110 |  E  |   -------------------\n     | 4  | 1000 |  A  |   ------------------|\
    \   | 4  | 1100 |  B  |\n     -------------------   | 4  | 1000 |  A  |   -------------------\n\
    \                           -------------------\n      ( A ) ------------ ( B\
    \ ) ------------ ( C ) ------------ ( D )\n     4 (0:1000)             \\    \
    \              \\           1 (0:0001)\n                             \\      \
    \            \\\n                             ( E ) ------------ ( F )\n     \
    \                      3 (0:0100)         2 (0:0010)\n                Figure 6:\
    \ Example of Non-deterministic ECMP\n   In this example, BFR-B has two equal-cost\
    \ paths to reach BFER-F: one\n   via BFR-C and one via BFR-E.  Since the BFR-id\
    \ of BFER-F is 2, this\n   is reflected in entry 2 of BFR-B's BIFT.  Entry 2 shows\
    \ that BFR-B\n   has a choice of two BFR-NBRs for BFER-B and that a different\
    \ F-BM is\n   associated with each choice.  When BFR-B looks up entry 2 in the\n\
    \   BIFT, it can choose either BFR-NBR.  However, when following the\n   procedures\
    \ of Section 6.5, it MUST use the F-BM corresponding to the\n   BFR-NBR that it\
    \ chooses.\n   How the choice is made is an implementation matter.  However, the\n\
    \   usual rules for ECMP apply: packets of a given flow SHOULD NOT be\n   split\
    \ among two paths, and any entropy field in the packet's\n   encapsulation SHOULD\
    \ be respected.\n   Note, however, that by the rules of Section 6.5, any packet\
    \ destined\n   for both BFER-D and BFER-F will be sent via BFR-C.\n"
- title: 6.7.2.  Deterministic ECMP
  contents:
  - "6.7.2.  Deterministic ECMP\n   With the procedures of Section 6.7.1, where ECMP\
    \ paths exist, the\n   path a packet takes to reach any particular BFER depends\
    \ not only on\n   routing and on the packet's entropy but also on the set of other\n\
    \   BFERs to which the packet is destined.\n   For example, consider the following\
    \ scenario in the network of\n   Figure 6.\n   o  There is a sequence of packets\
    \ being transmitted by BFR-A, some of\n      which are destined for both D and\
    \ F and some of which are destined\n      only for F.\n   o  All the packets in\
    \ this sequence have the same entropy value (call\n      it \"Q\").\n   o  At\
    \ BFR-B, when a packet with entropy value Q is forwarded via\n      entry 2 in\
    \ the BIFT, the packet is sent to E.\n   Using the forwarding procedure of Section\
    \ 6.7.1, packets of this\n   sequence that are destined for both D and F are forwarded\
    \ according\n   to entry 1 in the BIFT and thus will reach F via the path A-B-C-F.\n\
    \   However, packets of this sequence that are destined only for F are\n   forwarded\
    \ according to entry 2 in the BIFT and thus will reach F via\n   the path A-B-E-F.\n\
    \   That procedure minimizes the number of packets transmitted by BFR-B.\n   However,\
    \ consider the following scenario:\n   o  Beginning at time t0, the multicast\
    \ flow in question needs to be\n      received ONLY by BFER-F.\n   o  Beginning\
    \ at a later time, t1, the flow needs to be received by\n      both BFER-D and\
    \ BFER-F.\n   o  Beginning at a later time, t2, the flow no longer needs to be\n\
    \      received by D, but still needs to be received by F.\n   Then, from t0 until\
    \ t1, the flow will travel to F via the path\n   A-B-E-F.  From t1 until t2, the\
    \ flow will travel to F via the path\n   A-B-C-F.  And from t2, the flow will\
    \ again travel to F via the path\n   A-B-E-F.\n   The problem is that if D repeatedly\
    \ joins and leaves the flow, the\n   flow's path from B to F will keep switching.\
    \  This could cause F to\n   receive packets out of order.  It also makes troubleshooting\n\
    \   difficult.  For example, if there is some problem on the E-F link,\n   receivers\
    \ at F will get good service when the flow is also going to D\n   (avoiding the\
    \ E-F link) but bad service when the flow is not going\n   to D.  Since it is\
    \ hard to know which path is being used at any given\n   time, this may be hard\
    \ to troubleshoot.  Also, it is very difficult\n   to perform a traceroute that\
    \ is known to follow the path taken by the\n   flow at any given time.\n   The\
    \ source of this difficulty is that, in the procedures of\n   Section 6.7.1, the\
    \ path taken by a particular flow to a particular\n   BFER depends upon whether\
    \ there are lower-numbered BFERs that are\n   also receiving the flow.  Thus,\
    \ the choice among the ECMP paths is\n   fundamentally non-deterministic.\n  \
    \ Deterministic forwarding can be achieved by using multiple BIFTs,\n   such that\
    \ each row in a BIFT has only one path to each destination\n   but the multiple\
    \ ECMP paths to any particular destination are spread\n   across the multiple\
    \ tables.  When a BIER-encapsulated packet arrives\n   to be forwarded, the BFR\
    \ uses a hash of the BIER entropy field to\n   determine which BIFT to use, and\
    \ then the normal BIER forwarding\n   algorithm (as described in Sections 6.5\
    \ and 6.6) is used with the\n   selected BIFT.\n   As an example, suppose there\
    \ are two paths to destination X (call\n   them \"X1\" and \"X2\") and four paths\
    \ to destination Y (call them \"Y1\",\n   \"Y2\", \"Y3\", and \"Y4\").  If there\
    \ are, say, four BIFTs, one BIFT would\n   have paths X1 and Y1, one would have\
    \ X1 and Y2, one would have X2 and\n   Y3, and one would have X2 and Y4.  If traffic\
    \ to X is split evenly\n   among these four BIFTs, the traffic will be split evenly\
    \ between the\n   two paths to X; if traffic to Y is split evenly among these\
    \ four\n   BIFTs, the traffic will be split evenly between the four paths to Y.\n\
    \   Note that if there are three paths to one destination and four paths\n   to\
    \ another, 12 BIFTs would be required in order to get even splitting\n   of the\
    \ load to each of those two destinations.  Of course, each BIFT\n   uses some\
    \ memory, and one might be willing to have less optimal\n   splitting in order\
    \ to have fewer BIFTs.  How that trade-off is made\n   is an implementation or\
    \ deployment decision.\n"
- title: 6.8.  Prevention of Loops and Duplicates
  contents:
  - "6.8.  Prevention of Loops and Duplicates\n   The BitString in a BIER-encapsulated\
    \ packet specifies the set of\n   BFERs to which that packet is to be forwarded.\
    \  When a\n   BIER-encapsulated packet is replicated, no two copies of the packet\n\
    \   will ever have a BFER in common.  If one of the packet's BFERs\n   forwards\
    \ the packet further, that BFER will first clear the bit that\n   identifies itself.\
    \  As a result, duplicate delivery of packets is not\n   possible with BIER.\n\
    \   As long as the routing underlay provides a loop-free path between\n   each\
    \ pair of BFRs, BIER-encapsulated packets will not loop.  Since\n   the BIER layer\
    \ does not create any paths of its own, there is no need\n   for any BIER-specific\
    \ loop-prevention techniques beyond the\n   forwarding procedures specified in\
    \ Section 6.5.\n   If, at some time, the routing underlay is not providing a loop-free\n\
    \   path between BFIR-A and BFER-B, then BIER-encapsulated packets may\n   loop\
    \ while traveling from BFIR-A to BFER-B.  However, such loops will\n   never result\
    \ in delivery of duplicate packets to BFER-B.\n   These properties of BIER eliminate\
    \ the need for the \"Reverse Path\n   Forwarding\" (RPF) check that is used in\
    \ conventional IP multicast\n   forwarding.\n"
- title: 6.9.  When Some Nodes Do Not Support BIER
  contents:
  - "6.9.  When Some Nodes Do Not Support BIER\n   The procedures of Section 6.2 presuppose\
    \ that, within a given BIER\n   domain, all the nodes adjacent to a given BFR\
    \ in a given routing\n   underlay are also BFRs.  However, it is possible to use\
    \ BIER even\n   when this is not the case, as long as the ingress and egress nodes\n\
    \   are BFRs.  In this section, we describe procedures that can be used\n   if\
    \ the routing underlay is an SPF-based IGP that computes a\n   shortest-path tree\
    \ from each node to all other nodes in the domain.\n   At a given BFR, say \"\
    BFR-B\", start with a copy of the IGP-computed\n   shortest-path tree from BFR-B\
    \ to each router in the domain.  (This\n   tree is computed by the SPF algorithm\
    \ of the IGP.)  Let's call this\n   copy the \"BIER-SPF tree rooted at BFR-B\"\
    .  BFR-B then modifies this\n   BIER-SPF tree as follows.\n   1.  BFR-B looks\
    \ in turn at each of its child nodes on the BIER-SPF\n       tree.\n   2.  If\
    \ one of the child nodes does not support BIER, BFR-B removes\n       that node\
    \ from the tree.  The child nodes of the node that has\n       just been removed\
    \ are then re-parented on the tree, so that BFR-B\n       now becomes their parent.\n\
    \   3.  BFR-B then continues to look at each of its child nodes,\n       including\
    \ any nodes that have been re-parented to BFR-B as a\n       result of the previous\
    \ step.\n   When all of the child nodes (the original child nodes plus any new\n\
    \   ones) have been examined, BFR-B's children on the BIER-SPF tree will\n   all\
    \ be BFRs.\n   When the BIFT is constructed, BFR-B's child nodes on the BIER-SPF\n\
    \   tree are considered to be the BFR-NBRs.  The F-BMs must be computed\n   appropriately,\
    \ based on the BFR-NBRs.\n   BFR-B may now have BFR-NBRs that are not \"directly\
    \ connected\" to\n   BFR-B via Layer 2.  To send a packet to one of these BFR-NBRs,\
    \ BFR-B\n   will have to send the packet through a unicast tunnel.  In an MPLS\n\
    \   network, this may be as simple as finding the IGP unicast next hop to\n  \
    \ the child node and pushing on (above the BIER encapsulation header)\n   an MPLS\
    \ label that the IGP next hop has bound to an address of the\n   child node. \
    \ (This assumes that the packet is using an MPLS-based\n   BIER encapsulation,\
    \ such as the one specified in Section 2.1 of\n   [MPLS_BIER_ENCAPS].)  Of course,\
    \ the BIFT-id in the BIER\n   encapsulation header must be the BIFT-id advertised\
    \ by the child node\n   for the packet's SI, sub-domain, and BitStringLength.\n\
    \   If for some reason the unicast tunnel cannot be an MPLS tunnel, any\n   other\
    \ kind of tunnel can be used, as long as the encapsulation for\n   that tunnel\
    \ type has a way of indicating that the payload is a\n   BIER-encapsulated packet.\n\
    \   Note that if a BIER-encapsulated packet is not using an MPLS-based\n   BIER\
    \ encapsulation, it will not be possible to send it through an\n   MPLS tunnel\
    \ unless it is known that the tunnel only carries BIER\n   packets; this is because\
    \ MPLS has no \"next protocol type\" field.\n   This is not a problem if an MPLS-based\
    \ BIER encapsulation is used,\n   because in that case the BIER encapsulation\
    \ begins with an MPLS label\n   that identifies the packet as a BIER-encapsulated\
    \ packet.\n   Of course, the above is not meant as an implementation technique,\n\
    \   just as a functional description.\n   While the above description assumes\
    \ that the routing underlay\n   provides an SPF tree, it may also be applicable\
    \ to other types of\n   routing underlays.\n   The technique above can also be\
    \ used to provide \"node protection\"\n   (i.e., to provide fast reroute around\
    \ nodes that are believed to have\n   failed).  If BFR-B has a failed BFR-NBR,\
    \ BFR-B can remove the failed\n   BFR-NBR from the BIER-SPF tree and can then\
    \ re-parent the child\n   BFR-NBRs of the failed BFR-NBR so that they appear to\
    \ be BFR-B's own\n   child nodes on the tree (i.e., so that they appear to be\
    \ BFR-B's\n   BFR-NBRs).  The usual BIER forwarding procedures then apply.\n \
    \  However, getting the packet from BFR-B to the child nodes of the\n   failed\
    \ BFR-NBR is a bit more complicated, as it may require using a\n   unicast bypass\
    \ tunnel to get around the failed node.\n   A simpler variant of step 2 above\
    \ would be the following:\n      If one of the child nodes does not support BIER,\
    \ BFR-B removes\n      that node from the tree.  All BFERs that are reached through\
    \ that\n      child node are then re-parented on the tree, so that BFR-B now\n\
    \      becomes their parent.\n   This variant is simpler because the set of BFERs\
    \ that are reached\n   through a particular child node of BFR-B can be determined\
    \ from the\n   F-BM in the BIFT.  However, if this variant is used, the results\
    \ are\n   less optimal, because packets will be unicast directly from BFR-B to\n\
    \   the BFERs that are reachable through the non-BIER child node.\n   When using\
    \ a unicast MPLS tunnel to get a packet to a BFR-NBR:\n   o  The TTL of the MPLS\
    \ label entry representing the tunnel SHOULD be\n      set to a large value, rather\
    \ than being copied from the TTL value\n      from the BIER encapsulation header,\
    \ and\n   o  When the tunnel labels are popped off, the TTL from the tunnel\n\
    \      labels SHOULD NOT be copied to the BIER encapsulation header.\n   In other\
    \ words, the TTL processing for the tunnel SHOULD be as\n   specified in [RFC3443]\
    \ for \"Pipe Model\" and \"Short Pipe Model\" Label\n   Switched Paths (LSPs).\
    \  The same principle applies if the tunnels are\n   not MPLS tunnels; the BIER\
    \ packet SHOULD NOT inherit the TTL from the\n   tunnel encapsulation.  That way,\
    \ the TTL of the BIER encapsulation\n   header constrains only the number of BFRs\
    \ that the packet may\n   traverse, not the total number of hops.\n   If two BIER\
    \ packets have the same value in the entropy field of their\n   respective BIER\
    \ headers and if both are transmitted through a given\n   tunnel, it is desirable\
    \ for the tunnel encapsulation to preserve the\n   fact that the two packets have\
    \ the same entropy.\n   The material in this section presupposes that if a given\
    \ router is a\n   BFR, then it supports BIER on all its interfaces.  It is, however,\n\
    \   possible that a router will have some line cards that support BIER\n   and\
    \ some that do not.  In such a case, one can think of the router as\n   a \"partial\
    \ BFR\" that supports BIER only on some of its interfaces.\n   If it is desired\
    \ to deploy such partial BFRs, one can use the\n   multi-topology features of\
    \ the IGP to set up a BIER-specific\n   topology.  This topology would exclude\
    \ all the non-BIER-capable\n   interfaces that attach to BFRs.  BIER would then\
    \ have to be run in a\n   sub-domain that is bound to this topology.  If unicast\
    \ tunnels are\n   used to bypass non-BFRs, either (a) the tunnels have to be restricted\n\
    \   to this topology or (b) the tunnel endpoints have to be BFRs that do\n   not\
    \ have any non-BIER-capable interfaces.\n"
- title: 6.10.  Use of Different BitStringLengths within a Domain
  contents:
  - "6.10.  Use of Different BitStringLengths within a Domain\n   The procedures of\
    \ this section apply only when the same encapsulation\n   is used throughout the\
    \ BIER domain.  Consideration of the scenario\n   where both multiple encapsulations\
    \ and multiple BitStringLengths are\n   used in a given BIER domain is outside\
    \ the scope of this document.\n   It is possible for different BFRs within a BIER\
    \ domain to be using\n   different Imposition and/or Disposition BitStringLengths.\
    \  As stated\n   in Section 3:\n   \"if a particular BFIR is provisioned to use\
    \ a particular Imposition\n   BitStringLength and a particular Imposition sub-domain\
    \ when imposing\n   the encapsulation on a given set of packets, all other BFRs\
    \ with\n   BFR-ids in that sub-domain SHOULD be provisioned to process received\n\
    \   BIER packets with that BitStringLength (i.e., all other BFRs with\n   BFR-ids\
    \ in that sub-domain SHOULD be provisioned with that\n   BitStringLength as a\
    \ Disposition BitStringLength for that\n   sub-domain).\"\n   Note that mis-provisioning\
    \ can result in \"black holes\".  If a BFIR\n   creates a BIER packet with a particular\
    \ BitStringLength and if that\n   packet needs to travel through a BFR that cannot\
    \ process received\n   BIER packets with that BitStringLength, then it may be\
    \ impossible to\n   forward the packet to all of the BFERs identified in its BIER\
    \ header.\n   Section 6.10.1 defines a procedure, the \"BitStringLength\n   Compatibility\
    \ Check\", that can be used to detect the possibility of\n   such black holes.\n\
    \   However, failure of the BitStringLength Compatibility Check does not\n   necessarily\
    \ result in the creation of black holes; Section 6.10.2\n   specifies OPTIONAL\
    \ procedures that allow BIER forwarding to proceed\n   without black holes, even\
    \ if the BitStringLength Compatibility Check\n   fails.\n   If the procedures\
    \ of Section 6.10.2 are not deployed but the\n   BitStringLength Compatibility\
    \ Check fails at some BFIR, the BFIR has\n   two choices:\n   o  Create BIER packets\
    \ with the provisioned Imposition\n      BitStringLength, even though the packets\
    \ may not be able to reach\n      all the BFERs identified in their BitStrings.\n\
    \   o  Use an Imposition BitStringLength that passes the Compatibility\n     \
    \ Check (assuming that there is one), even if this is not the\n      provisioned\
    \ Imposition BitStringLength.\n   Section 6.10.1 discusses the implications of\
    \ making one or the other\n   of these choices.\n   There will be times when an\
    \ operator wishes to change the\n   BitStringLengths used in a particular BIER\
    \ domain.  Section 6.10.3\n   specifies a simple procedure that can be used to\
    \ transition a BIER\n   domain from one BitStringLength to another.\n"
- title: 6.10.1.  BitStringLength Compatibility Check
  contents:
  - "6.10.1.  BitStringLength Compatibility Check\n   When a BFIR needs to encapsulate\
    \ a packet, the BFIR first assigns the\n   packet to a sub-domain.  The BFIR then\
    \ chooses an Imposition\n   BitStringLength L for the packet.  The choice of Imposition\n\
    \   BitStringLength is determined by provisioning.  However, the BFIR\n   should\
    \ also perform the BitStringLength Compatibility Check defined\n   below.\n  \
    \ The combination of sub-domain S and Imposition BitStringLength L\n   passes\
    \ the BitStringLength Compatibility Check if and only if the\n   following condition\
    \ holds:\n      Every BFR that has advertised its membership in sub-domain S has\n\
    \      also advertised that it is using Disposition BitStringLength L\n      (and\
    \ possibly other BitStringLengths as well) in that sub-domain.\n      (If MPLS\
    \ encapsulation (Section 2.1 of [MPLS_BIER_ENCAPS]) is\n      being used, this\
    \ means that every BFR that is advertising a label\n      for sub-domain S is\
    \ advertising a label for the combination of\n      sub-domain S and Disposition\
    \ BitStringLength L.)\n   If a BFIR has been provisioned to use a particular Imposition\n\
    \   BitStringLength and a particular sub-domain for some set of packets,\n   and\
    \ if that combination of Imposition BitStringLength and sub-domain\n   does not\
    \ pass the BitStringLength Compatibility Check, the BFIR\n   SHOULD log this fact\
    \ as an error.  It then has the following two\n   choices about what to do with\
    \ the packets:\n   1.  The BFIR MAY use the provisioned Imposition BitStringLength\n\
    \       anyway.  If the procedure of either option 2 or option 3 of\n       Section\
    \ 6.10.2 is deployed, this will not cause black holes and\n       may actually\
    \ be the optimal result.  It should be understood,\n       though, that the BFIR\
    \ cannot determine by signaling whether those\n       procedures have been deployed.\n\
    \   2.  If the BFIR is capable of using an Imposition BitStringLength\n      \
    \ that does pass the BitStringLength Compatibility Check for the\n       particular\
    \ sub-domain, the BFIR MAY use that Imposition\n       BitStringLength instead.\n\
    \   Which of these two choices to make is itself determined by\n   provisioning.\n\
    \   Note that discarding the packets is not one of the allowable choices.\n  \
    \ Suppose, for example, that all the BFIRs are provisioned to use\n   Imposition\
    \ BitStringLength L for a particular sub-domain S but one\n   BFR has not been\
    \ provisioned to use Disposition BitStringLength L for\n   sub-domain S.  This\
    \ will cause the BitStringLength Compatibility\n   Check to fail.  If the BFIR\
    \ sends packets with BitStringLength L and\n   sub-domain S, the mis-provisioned\
    \ BFR will not be able to forward\n   those packets, and thus the packets may\
    \ only be able to reach a\n   subset of the BFERs to which they are destined.\
    \  However, this is\n   still better than having the BFIRs drop the packets; if\
    \ the BFIRs\n   discard the packets, the packets won't reach any of the BFERs\
    \ to\n   which they are destined at all.\n   If the procedures of Section 6.10.2\
    \ have not been deployed, choice 2\n   above might seem like a better option.\
    \  However, there might not be\n   any Imposition BitStringLength that a given\
    \ BFIR can use that also\n   passes the BitStringLength Compatibility Check. \
    \ If it is desired to\n   use choice 2 in a particular deployment, then there\
    \ should be a\n   \"Fallback Disposition BitStringLength\" (call it \"F\") such\
    \ that:\n   o  Every BFR advertises that it uses BitStringLength F as a\n    \
    \  Disposition BitStringLength for every sub-domain, and\n   o  If a BFIR is provisioned\
    \ to use Imposition BitStringLength X and\n      Imposition sub-domain S for a\
    \ certain class of packets but the\n      BitStringLength Compatibility Check\
    \ fails for the combination of\n      BitStringLength X and sub-domain S, then\
    \ the BFIR will fall back\n      to using BitStringLength F as the Imposition\
    \ BitStringLength\n      whenever the Imposition sub-domain is S.\n   It is RECOMMENDED\
    \ that the value of F be the default BitStringLength\n   for the encapsulation\
    \ being used.\n"
- title: 6.10.2.  Handling BitStringLength Mismatches
  contents:
  - "6.10.2.  Handling BitStringLength Mismatches\n   Suppose that a packet has been\
    \ BIER-encapsulated with a\n   BitStringLength value of X and that the packet\
    \ has arrived at BFR-A.\n   Now suppose that according to the routing underlay\
    \ the next hop is\n   BFR-B, but BFR-B is not using X as one of its Disposition\n\
    \   BitStringLengths.  What should BFR-A do with the packet?  BFR-A has\n   three\
    \ options.  It MUST do one of the three, but the choice of which\n   procedure\
    \ to follow is a local matter.  The three options are:\n   1.  BFR-A MAY discard\
    \ the packet.\n   2.  BFR-A MAY re-encapsulate the packet, using a BIER header\
    \ whose\n       BitStringLength value is supported by BFR-B.\n       Note that\
    \ if BFR-B only uses Disposition BitStringLength values\n       that are smaller\
    \ than the BitStringLength value of the packet,\n       this may require creating\
    \ additional copies of the packet.\n       Whether additional copies actually\
    \ have to be created depends\n       upon the bits that are actually set in the\
    \ original packet's\n       BitString.\n   3.  BFR-A MAY treat BFR-B as if BFR-B\
    \ did not support BIER at all,\n       in which case BFR-A applies the rules of\
    \ Section 6.9.\n   Note that there is no signaling that enables a BFR to advertise\
    \ which\n   of the three options it will use.\n   Option 2 can be useful if there\
    \ is a region of the BIER domain where\n   the BFRs are capable of using a long\
    \ BitStringLength as well as a\n   region where the BFRs are only capable of using\
    \ a shorter\n   BitStringLength.\n"
- title: 6.10.3.  Transitioning from One BitStringLength to Another
  contents:
  - "6.10.3.  Transitioning from One BitStringLength to Another\n   Suppose one wants\
    \ to migrate the BitStringLength used in a particular\n   BIER domain from one\
    \ value (X) to another value (Y).  The following\n   migration procedure can be\
    \ used.  This procedure allows the BFRs to\n   be reprovisioned one at a time\
    \ and does not require a \"flag day\".\n   1.  Upgrade all the BFRs in the domain\
    \ so that they use both value X\n       and value Y as their Disposition BitStringLengths.\n\
    \   2.  Reprovision the BFIRs so that they use BitStringLength value Y as\n  \
    \     the Imposition BitStringLength.\n   3.  One may then optionally reprovision\
    \ all the BFRs so that they no\n       longer use Disposition BitStringLength\
    \ X.\n"
- title: 7.  Operational Considerations
  contents:
  - "7.  Operational Considerations\n   BIER offers a radical simplification over\
    \ current IP multicast\n   operations: no tree-building control plane, no per-flow\
    \ forwarding\n   state, no Reverse Path Forwarding (RPF), no Rendezvous Point\
    \ (RP),\n   etc.  BIER packet forwarding/replication is along the unicast paths\n\
    \   to each bit position set in the packet, ensuring that the\n   encapsulated\
    \ multicast packets follow the same path as unicast to\n   each set bit in the\
    \ header.  The BIER FIB can be derived from the\n   SPF-calculated unicast FIB\
    \ or from any other forwarding-path\n   calculation in or out of band.  Each bit\
    \ will follow this unicast\n   path from the entry point of the BIER domain to\
    \ the edge device with\n   that assigned bit.\n   Due to these differences, operational\
    \ expectations from traditional\n   multicast solutions do not apply to a BIER\
    \ domain.  There is no\n   granular per-flow state at each node defining a tree.\
    \  Monitoring\n   flows at the forwarding-plane level ((S,G) entries) is not provided\n\
    \   in a BIER node.  BIER FIB packet counters may be maintained for\n   BFR-ids\
    \ or next-hop neighbors.  Any flow-based metrics will require\n   deeper packet\
    \ inspection; this topic is outside the scope of this\n   document.  In this way,\
    \ BIER is again more like unicast.\n   It is this reduction in state that allows\
    \ for one of the key\n   operational benefits of BIER: deterministic convergence.\
    \  The BIER\n   FIB can converge immediately after the unicast FIB regardless\
    \ of how\n   many multicast flows are transiting the links.  Careful monitoring\
    \ of\n   (S,G) utilization is not required within a BIER domain.\n"
- title: 7.1.  Configuration
  contents:
  - "7.1.  Configuration\n   A BIER domain requires that each edge node (BFER) be\
    \ given a unique\n   bit position in the BIER mask (BFR-id).  The BFR-id must\
    \ be\n   configured on each BFER and associated with a unique IP address of\n\
    \   that BFER.  Any existing manual or automated configuration tools must\n  \
    \ provide access to BIER-specific configuration.  The association of\n   the BFR-id\
    \ with a unique address of the BFER to which it is assigned\n   must also be advertised\
    \ into the IGP of the BIER domain.  This may be\n   implied from the BIER configuration\
    \ or require IGP-specific\n   configuration.  This document does not dictate any\
    \ specific\n   configuration methodology.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   This document does not require any IANA actions.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   When BIER is paired with a particular multicast\
    \ flow overlay, it\n   inherits the security considerations of that layer.  Similarly,\
    \ when\n   BIER is paired with a particular routing underlay, it inherits the\n\
    \   security considerations of that layer.\n   If the BIER encapsulation of a\
    \ particular packet specifies an SI or a\n   BitString other than the one intended\
    \ by the BFIR, the packet is\n   likely to be misdelivered.  If the BIER encapsulation\
    \ of a packet is\n   modified (through error or malfeasance) in a way other than\
    \ that\n   specified in this document, the packet may be misdelivered.  Some\n\
    \   modifications of the BIER encapsulation, e.g., setting every bit in\n   the\
    \ BitString, may result in (intentional or unintentional)\n   denial-of-service\
    \ (DoS) attacks.\n   If a BFIR is compromised, it may impose a BIER encapsulation\
    \ with all\n   the bits in the BitString set; this would also result in a DoS\n\
    \   attack.\n   Every BFR MUST be provisioned to know which of its interfaces\
    \ lead to\n   a BIER domain and which do not.  BIER-encapsulated packets MUST\
    \ NOT\n   be accepted from outside the BIER domain.  (Reception of\n   BIER-encapsulated\
    \ packets from outside the BIER domain would create\n   an attack vector for DoS\
    \ attacks, as an attacker might set all the\n   bits in the BitString.)\n   If\
    \ two interfaces lead to different BIER domains, the BFR MUST be\n   provisioned\
    \ to know that those two interfaces lead to different BIER\n   domains.  If the\
    \ provisioning is not correct, BIER-encapsulated\n   packets from one BIER domain\
    \ may \"leak\" into another; this is likely\n   to result in misdelivery of packets.\n\
    \   DoS attacks may also result from incorrect provisioning (through\n   error\
    \ or malfeasance) of the BFRs.\n   If the procedures used for advertising BFR-ids\
    \ and BFR-prefixes are\n   not secure, an attack on those procedures may result\
    \ in incorrect\n   delivery of BIER-encapsulated packets.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC3443]  Agarwal, P. and B. Akyol, \"Time To Live (TTL) Processing\n   \
    \           in Multi-Protocol Label Switching (MPLS) Networks\",\n           \
    \   RFC 3443, DOI 10.17487/RFC3443, January 2003,\n              <https://www.rfc-editor.org/info/rfc3443>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in\n         \
    \     RFC 2119 Key Words\", BCP 14, RFC 8174,\n              DOI 10.17487/RFC8174,\
    \ May 2017,\n              <https://www.rfc-editor.org/info/rfc8174>.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [BGP_BIER_EXTENSIONS]\n              Xu, X.,\
    \ Ed., Chen, M., Patel, K., Wijnands, IJ., and A.\n              Przygienda, \"\
    BGP Extensions for BIER\", Work in Progress,\n              draft-ietf-bier-idr-extensions-03,\
    \ August 2017.\n   [BIER_MVPN]\n              Rosen, E., Ed., Sivakumar, M., Aldrin,\
    \ S., Dolganow, A.,\n              and T. Przygienda, \"Multicast VPN Using BIER\"\
    , Work in\n              Progress, draft-ietf-bier-mvpn-09, November 2017.\n \
    \  [Boivie_Feldman]\n              Boivie, R. and N. Feldman, \"Small Group Multicast\"\
    , Work\n              in Progress, draft-boivie-sgm-02, February 2001.\n   [ISIS_BIER_EXTENSIONS]\n\
    \              Ginsberg, L., Ed., Przygienda, A., Aldrin, S., and J.\n       \
    \       Zhang, \"BIER Support via ISIS\", Work in Progress,\n              draft-ietf-bier-isis-extensions-06,\
    \ October 2017.\n   [MPLS_BIER_ENCAPS]\n              Wijnands, IJ., Ed., Rosen,\
    \ E., Ed., Dolganow, A.,\n              Tantsura, J., Aldrin, S., and I. Meilik,\
    \ \"Encapsulation\n              for Bit Index Explicit Replication in MPLS and\
    \ non-MPLS\n              Networks\", Work in Progress, draft-ietf-bier-mpls-\n\
    \              encapsulation-12, October 2017.\n   [OSPF_BIER_EXTENSIONS]\n  \
    \            Psenak, P., Ed., Kumar, N., Wijnands, IJ., Dolganow, A.,\n      \
    \        Przygienda, T., Zhang, J., and S. Aldrin, \"OSPF Extensions\n       \
    \       for BIER\", Work in Progress, draft-ietf-bier-ospf-bier-\n           \
    \   extensions-09, October 2017.\n   [RFC6513]  Rosen, E., Ed., and R. Aggarwal,\
    \ Ed., \"Multicast in\n              MPLS/BGP IP VPNs\", RFC 6513, DOI 10.17487/RFC6513,\n\
    \              February 2012, <https://www.rfc-editor.org/info/rfc6513>.\n   [RFC6514]\
    \  Aggarwal, R., Rosen, E., Morin, T., and Y. Rekhter, \"BGP\n              Encodings\
    \ and Procedures for Multicast in MPLS/BGP IP\n              VPNs\", RFC 6514,\
    \ DOI 10.17487/RFC6514, February 2012,\n              <https://www.rfc-editor.org/info/rfc6514>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authors wish to thank Rajiv Asati, Alia Atlas, John\
    \ Bettink, Ross\n   Callon (who contributed much of the text on deterministic\
    \ ECMP),\n   Nagendra Kumar, Christian Martin, Neale Ranns, Albert Tian, Ramji\n\
    \   Vaithianathan, Xiaohu Xu, and Jeffrey Zhang for their ideas and\n   contributions\
    \ to this work.\n   The authors also wish to thank Sue Hares, Victor Kuarsingh,\
    \ and Dan\n   Romascanu for their reviews of this document.\n"
- title: Contributors
  contents:
  - "Contributors\n   The following people contributed significantly to the content\
    \ of this\n   document and should be considered co-authors:\n   Gregory Cauchie\n\
    \   Bouygues Telecom\n   Email: gcauchie@bouyguestelecom.fr\n   Mach(Guoyi) Chen\n\
    \   Huawei\n   Email: mach.chen@huawei.com\n   Arkadiy Gulko\n   Thomson Reuters\n\
    \   195 Broadway\n   New York, NY  10007\n   United States of America\n   Email:\
    \ arkadiy.gulko@thomsonreuters.com\n   Wim Henderickx\n   Nokia\n   Copernicuslaan\
    \ 50\n   Antwerp  2018\n   Belgium\n   Email: wim.henderickx@nokia.com\n   Martin\
    \ Horneffer\n   Deutsche Telekom\n   Hammer Str. 216-226\n   Muenster  48153\n\
    \   Germany\n   Email: Martin.Horneffer@telekom.de\n   Luay Jalil\n   Verizon\n\
    \   1201 East Arapaho Rd.\n   Richardson, TX  75081\n   United States of America\n\
    \   Email: luay.jalil@verizon.com\n   Uwe Joorde\n   Deutsche Telekom\n   Hammer\
    \ Str. 216-226\n   Muenster  D-48153\n   Germany\n   Email: Uwe.Joorde@telekom.de\n\
    \   Greg Shepherd\n   Cisco Systems\n   170 West Tasman Drive\n   San Jose, CA\
    \  95134\n   United States of America\n   Email: shep@cisco.com\n   Jeff Tantsura\n\
    \   Email: jefftant.ietf@gmail.com\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   IJsbrand Wijnands (editor)\n   Cisco Systems, Inc.\n \
    \  De Kleetlaan 6a\n   Diegem  1831\n   Belgium\n   Email: ice@cisco.com\n   Eric\
    \ C. Rosen (editor)\n   Juniper Networks, Inc.\n   10 Technology Park Drive\n\
    \   Westford, Massachusetts  01886\n   United States of America\n   Email: erosen@juniper.net\n\
    \   Andrew Dolganow\n   Nokia\n   438B Alexandra Rd #08-07/10\n   Alexandra Technopark\n\
    \   Singapore  119968\n   Singapore\n   Email: andrew.dolganow@nokia.com\n   Tony\
    \ Przygienda\n   Juniper Networks, Inc.\n   1194 N. Mathilda Ave.\n   Sunnyvale,\
    \ California  94089\n   United States of America\n   Email: prz@juniper.net\n\
    \   Sam K. Aldrin\n   Google, Inc.\n   1600 Amphitheatre Parkway\n   Mountain\
    \ View, California  94043\n   United States of America\n   Email: aldrin.ietf@gmail.com\n"
